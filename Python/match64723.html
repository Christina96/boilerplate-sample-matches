<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_apigateway.py &amp; virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_apigateway.py &amp; virt_1.py
      </h3>
<h1 align="center">
        4.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_apigateway.py (9.476876%)<th>virt_1.py (3.2228954%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(395-448)<td><a href="#" name="0">(7722-7809)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1965-1976)<td><a href="#" name="1">(3948-3958)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(658-661)<td><a href="#" name="2">(4072-4090)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1-23)<td><a href="#" name="3">(133-155)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(596-601)<td><a href="#" name="4">(3284-3291)</a><td align="center"><font color="#da0000">18</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(2231-2240)<td><a href="#" name="5">(6457-6469)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(1395-1405)<td><a href="#" name="6">(6661-6666)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1236-1242)<td><a href="#" name="7">(4514-4517)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(299-313)<td><a href="#" name="8">(6892-7125)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(625-629)<td><a href="#" name="9">(2970-2977)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1442-1450)<td><a href="#" name="10">(6510-6517)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1311-1317)<td><a href="#" name="11">(8657-8662)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(1104-1114)<td><a href="#" name="12">(3451-3457)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(743-745)<td><a href="#" name="13">(3251-3255)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(812-814)<td><a href="#" name="14">(6763-6767)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(775-777)<td><a href="#" name="15">(6419-6422)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import random
4 import string
5 import pytest
6 import salt.config
7 import salt.loader
8 import salt.states.boto_apigateway as boto_apigateway
9 import salt.utils.files
10 import salt.utils.yaml
11 from salt.utils.versions import LooseVersion
12 from tests.support.mixins import LoaderModuleMockMixin
13 from tests.support.mock import MagicMock, patch
14 from tests.support.unit import TestCase, skipIf
15 from tests.unit.modules.test_boto_apigateway import BotoApiGatewayTestCaseMixin
16 try:
17     import boto3
18     import</b></font> botocore
19     from botocore.exceptions import ClientError
20     HAS_BOTO = True
21 except ImportError:
22     HAS_BOTO = False
23 required_boto3_version = "1.2.1"
24 required_botocore_version = "1.4.49"
25 region = "us-east-1"
26 access_key = "GKTADJGHEIQSXMKKRBJ08H"
27 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
28 conn_parameters = {
29     "region": region,
30     "key": access_key,
31     "keyid": secret_key,
32     "profile": {},
33 }
34 error_message = (
35     "An error occurred (101) when calling the {0} operation: Test-defined error"
36 )
37 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
38 api_ret = dict(
39     description=(
40         '{\n    "context": "See deployment or stage description",\n   '
41         ' "provisioned_by": "Salt boto_apigateway.present State"\n}'
42     ),
43     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
44     id="vni0vq8wzi",
45     name="unit test api",
46 )
47 no_apis_ret = {"items": []}
48 apis_ret = {"items": [api_ret]}
49 mock_model_ret = dict(
50     contentType="application/json",
51     description="mock model",
52     id="123abc",
53     name="mock model",
54     schema=(
55         "{\n"
56         '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
57         '    "properties": {\n'
58         '        "field": {\n'
59         '            "type": "string"\n'
60         "        }\n"
61         "    }\n"
62         "}"
63     ),
64 )
65 models_ret = {
66     "items": [
67         dict(
68             contentType="application/json",
69             description="Error",
70             id="50nw8r",
71             name="Error",
72             schema=(
73                 "{\n"
74                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
75                 '    "properties": {\n'
76                 '        "code": {\n'
77                 '            "format": "int32",\n'
78                 '            "type": "integer"\n'
79                 "        },\n"
80                 '        "fields": {\n'
81                 '            "type": "string"\n'
82                 "        },\n"
83                 '        "message": {\n'
84                 '            "type": "string"\n'
85                 "        }\n"
86                 "    },\n"
87                 '    "title": "Error Schema",\n'
88                 '    "type": "object"\n'
89                 "}"
90             ),
91         ),
92         dict(
93             contentType="application/json",
94             description="User",
95             id="terlnw",
96             name="User",
97             schema=(
98                 "{\n"
99                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
100                 '    "properties": {\n'
101                 '        "password": {\n'
102                 '            "description": "A password for the new user",\n'
103                 '            "type": "string"\n'
104                 "        },\n"
105                 '        "username": {\n'
106                 '            "description": "A unique username for the user",\n'
107                 '            "type": "string"\n'
108                 "        }\n"
109                 "    },\n"
110                 '    "title": "User Schema",\n'
111                 '    "type": "object"\n'
112                 "}"
113             ),
114         ),
115     ]
116 }
117 root_resources_ret = {"items": [dict(id="bgk0rk8rqb", path="/")]}
118 resources_ret = {
119     "items": [
120         dict(id="bgk0rk8rqb", path="/"),
121         dict(
122             id="9waiaz",
123             parentId="bgk0rk8rqb",
124             path="/users",
125             pathPart="users",
126             resourceMethods={"POST": {}},
127         ),
128     ]
129 }
130 no_resources_ret = {"items": []}
131 stage1_deployment1_ret = dict(
132     cacheClusterEnabled=False,
133     cacheClusterSize=0.5,
134     cacheClusterStatus="NOT_AVAILABLE",
135     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
136     deploymentId="kobnrb",
137     description=(
138         "{\n"
139         '    "current_deployment_label": {\n'
140         '        "api_name": "unit test api",\n'
141         '        "swagger_file": "temp-swagger-sample.yaml",\n'
142         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
143         '        "swagger_info_object": {\n'
144         '            "description": "salt boto apigateway unit test service",\n'
145         '            "title": "salt boto apigateway unit test service",\n'
146         '            "version": "0.0.0"\n'
147         "        }\n"
148         "    }\n"
149         "}"
150     ),
151     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
152     methodSettings=dict(),
153     stageName="test",
154     variables=dict(),
155 )
156 stage1_deployment1_vars_ret = dict(
157     cacheClusterEnabled=False,
158     cacheClusterSize=0.5,
159     cacheClusterStatus="NOT_AVAILABLE",
160     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
161     deploymentId="kobnrb",
162     description=(
163         "{\n"
164         '    "current_deployment_label": {\n'
165         '        "api_name": "unit test api",\n'
166         '        "swagger_file": "temp-swagger-sample.yaml",\n'
167         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
168         '        "swagger_info_object": {\n'
169         '            "description": "salt boto apigateway unit test service",\n'
170         '            "title": "salt boto apigateway unit test service",\n'
171         '            "version": "0.0.0"\n'
172         "        }\n"
173         "    }\n"
174         "}"
175     ),
176     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
177     methodSettings=dict(),
178     stageName="test",
179     variables={"var1": "val1"},
180 )
181 stage1_deployment2_ret = dict(
182     cacheClusterEnabled=False,
183     cacheClusterSize=0.5,
184     cacheClusterStatus="NOT_AVAILABLE",
185     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
186     deploymentId="kobnrc",
187     description=(
188         "{\n"
189         '    "current_deployment_label": {\n'
190         '        "api_name": "unit test api",\n'
191         '        "swagger_file": "temp-swagger-sample.yaml",\n'
192         '        "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
193         '        "swagger_info_object": {\n'
194         '            "description": "salt boto apigateway unit test service",\n'
195         '            "title": "salt boto apigateway unit test service",\n'
196         '            "version": "0.0.2"\n'
197         "        }\n"
198         "    }\n"
199         "}"
200     ),
201     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
202     methodSettings=dict(),
203     stageName="test",
204     variables=dict(),
205 )
206 stage2_ret = dict(
207     cacheClusterEnabled=False,
208     cacheClusterSize=0.5,
209     cacheClusterStatus="NOT_AVAILABLE",
210     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
211     deploymentId="kobnrb",
212     description=(
213         "{\n"
214         '    "current_deployment_label": {\n'
215         '        "api_name": "unit test api",\n'
216         '        "swagger_file": "temp-swagger-sample.yaml",\n'
217         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
218         '        "swagger_info_object": {\n'
219         '            "description": "salt boto apigateway unit test service",\n'
220         '            "title": "salt boto apigateway unit test service",\n'
221         '            "version": "0.0.0"\n'
222         "        }\n"
223         "    }\n"
224         "}"
225     ),
226     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
227     methodSettings=dict(),
228     stageName="dev",
229     variables=dict(),
230 )
231 stages_stage2_ret = {"item": [stage2_ret]}
232 no_stages_ret = {"item": []}
233 deployment1_ret = dict(
234     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
235     description=(
236         "{\n"
237         '    "api_name": "unit test api",\n'
238         '    "swagger_file": "temp-swagger-sample.yaml",\n'
239         '    "swagger_file_md5sum": "55a948ff90ad80ff747ec91657c7a299",\n'
240         '    "swagger_info_object": {\n'
241         '        "description": "salt boto apigateway unit test service",\n'
242         '        "title": "salt boto apigateway unit test service",\n'
243         '        "version": "0.0.0"\n'
244         "    }\n"
245         "}"
246     ),
247     id="kobnrb",
248 )
249 deployment2_ret = dict(
250     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
251     description=(
252         "{\n"
253         '    "api_name": "unit test api",\n'
254         '    "swagger_file": "temp-swagger-sample.yaml",\n'
255         '    "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
256         '    "swagger_info_object": {\n'
257         '        "description": "salt boto apigateway unit test service",\n'
258         '        "title": "salt boto apigateway unit test service",\n'
259         '        "version": "0.0.2"\n'
260         "    }\n"
261         "}"
262     ),
263     id="kobnrc",
264 )
265 function_ret = dict(
266     FunctionName<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="unit_test_api_users_post",
267     Runtime="python2.7",
268     Role=None,
269     Handler="handler",
270     Description="abcdefg",
271     Timeout=5,
272     MemorySize=128,
273     CodeSha256="abcdef",
274     CodeSize=199,
275     FunctionArn="arn:lambda:us-east-1:1234:Something",
276     LastModified="yes",
277 )
278 method_integration_response_200_ret = dict(
279     responseParameters={"method.response.header.Access-Control-Allow-Origin"</b></font>: "*"},
280     responseTemplates={},
281     selectionPattern=".*",
282     statusCode="200",
283 )
284 method_integration_ret = dict(
285     cacheKeyParameters={},
286     cacheNamespace="9waiaz",
287     credentials="arn:aws:iam::1234:role/apigatewayrole",
288     httpMethod="POST",
289     integrationResponses={"200": method_integration_response_200_ret},
290     requestParameters={},
291     requestTemplates={
292         "application/json": (
293             "#set($inputRoot = $input.path('$')){\"header-params\" : {#set ($map ="
294             ' $input.params().header)#foreach( $param in $map.entrySet() )"$param.key"'
295             ' : "$param.value" #if( $foreach.hasNext ), #end#end},"query-params" :'
296             " {#set ($map = $input.params().querystring)#foreach( $param in"
297             ' $map.entrySet() )"$param.key" : "$param.value" #if( $foreach.hasNext ),'
298             ' #end#end},"path-params" : {#set ($map = $input.params().path)#foreach('
299             ' $param in $map.entrySet() )"$param.key" : "$param.value" #if('
300             " $foreach.hasNext ), #end#end},\"body-params\" : $input.json('$')}"
301         )
302     },
303     type="AWS",
304     uri=(
305         "arn:aws:apigateway:us-west-2:"
306         "lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:1234567:"
307         "function:unit_test_api_api_users_post/invocations"
308     ),
309 )
310 method_response_200_ret = dict(
311     responseModels={"application/json": "User"},
312     responseParameters={"method.response.header.Access-Control-Allow-Origin": False},
313     statusCode="200",
314 )
315 method_ret = dict(
316     apiKeyRequired=False,
317     authorizationType="None",
318     httpMethod="POST",
319     methodIntegration=method_integration_ret,
320     methodResponses={"200": method_response_200_ret},
321     requestModels={"application/json": "User"},
322     requestParameters={},
323 )
324 throttle_rateLimit = 10.0
325 association_stage_1 = {"apiId": "apiId1", "stage": "stage1"}
326 association_stage_2 = {"apiId": "apiId1", "stage": "stage2"}
327 log = logging.getLogger(__name__)
328 def _has_required_boto():
329     if not HAS_BOTO:
330         return False
331     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
332         return False
333     else:
334         return True
335 def _has_required_botocore():
336     if not HAS_BOTO:
337         return False
338     elif LooseVersion(botocore.__version__) &lt; LooseVersion(required_botocore_version):
339         return False
340     else:
341         return True
342 class TempSwaggerFile:
343     _tmp_swagger_dict <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
344         "info": {
345             "version": "0.0.0",
346             "description": "salt boto apigateway unit test service",
347             "title": "salt boto apigateway unit test service",
348         },
349         "paths": {
350             "/users": {
351                 "post": {
352                     "responses": {
353                         "200": {
354                             "headers": {
355                                 "Access-Control-Allow-Origin": {"type": "string"}
356                             },
357                             "description": "The username of the new user",
358                             "schema": {"$ref": "#/definitions/User"},
359                         }
360                     },
361                     "parameters": [
362                         {
363                             "in": "body",
364                             "description": "New user details.",
365                             "name": "NewUser",
366                             "schema": {"$ref": "#/definitions/User"},
367                         }
368                     ],
369                     "produces": ["application/json"],
370                     "description": "Creates a new user.",
371                     "tags": ["Auth"],
372                     "consumes": ["application/json"],
373                     "summary": "Registers a new user",
374                 }
375             }
376         },
377         "schemes": ["https"],
378         "produces": ["application/json"],
379         "basePath": "/api",
380         "host": "rm06h9oac4.execute-api.us-west-2.amazonaws.com",
381         "definitions": {
382             "User": {
383                 "properties": {
384                     "username": {
385                         "type": "string",
386                         "description": "A unique username for the user",
387                     },
388                     "password": {
389                         "type": "string",
390                         "description": "A password for the new user",
391                     },
392                 }
393             },
394             "Error": {
395                 "properties": {
396                     "fields"</b></font>: {"type": "string"},
397                     "message": {"type": "string"},
398                     "code": {"type": "integer", "format": "int32"},
399                 }
400             },
401         },
402         "swagger": "2.0",
403     }
404     def __enter__(self):
405         self.swaggerfile = "temp-swagger-sample.yaml"
406         with salt.utils.files.fopen(self.swaggerfile, "w") as fp_:
407             salt.utils.yaml.safe_dump(self.swaggerdict, fp_, default_flow_style=False)
408         return self.swaggerfile
409     def __exit__(self, objtype, value, traceback):
410         os.remove(self.swaggerfile)
411     def __init__(self, create_invalid_file=False):
412         if create_invalid_file:
413             self.swaggerdict = TempSwaggerFile._tmp_swagger_dict.copy()
414             self.swaggerdict["invalid_key"] = "invalid"
415             self.swaggerdict.pop("schemes", None)
416             self.swaggerdict["swagger"] = "3.0"
417             self.swaggerdict.pop("info", None)
418         else:
419             self.swaggerdict = TempSwaggerFile._tmp_swagger_dict
420 class BotoApiGatewayStateTestCaseBase(TestCase, LoaderModuleMockMixin):
421     conn = None
422     @classmethod
423     def setUpClass(cls):
424         cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
425         cls.opts["grains"] = salt.loader.grains(cls.opts)
426     @classmethod
427     def tearDownClass(cls):
428         del cls.opts
429     def setup_loader_modules(self):
430         context = {}
431         utils = salt.loader.utils(
432             self.opts,
433             whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
434             context=context,
435         )
436         serializers = salt.loader.serializers(self.opts)
437         self.funcs = salt.loader.minion_mods(
438             self.opts, context=context, utils=utils, whitelist=["boto_apigateway"]
439         )
440         self.salt_states = salt.loader.states(
441             opts=self.opts,
442             functions=self.funcs,
443             utils=utils,
444             whitelist=["boto_apigateway"],
445             serializers=serializers,
446         )
447         return {
448             boto_apigateway: {
449                 "__opts__": self.opts,
450                 "__utils__": utils,
451                 "__salt__": self.funcs,
452                 "__states__": self.salt_states,
453                 "__serializers__": serializers,
454             }
455         }
456     def setUp(self):
457         self.addCleanup(delattr, self, "funcs")
458         self.addCleanup(delattr, self, "salt_states")
459         conn_parameters["key"] = "".join(
460             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
461         )
462         patcher = patch("boto3.session.Session")
463         self.addCleanup(patcher.stop)
464         mock_session = patcher.start()
465         session_instance = mock_session.return_value
466         self.conn = MagicMock()
467         self.addCleanup(delattr, self, "conn")
468         session_instance.client.return_value = self.conn
469 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
470 @skipIf(
471     _has_required_boto() is False,
472     "The boto3 module must be greater than or equal to version {}".format(
473         required_boto3_version
474     ),
475 )
476 class BotoApiGatewayTestCase(
477     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
478 ):
479     def test_present_when_swagger_file_is_invalid(self):
480         result = {}
481         with TempSwaggerFile(create_invalid_file=True) as swagger_file:
482             result = self.salt_states["boto_apigateway.present"](
483                 "api present",
484                 "unit test api",
485                 swagger_file,
486                 "test",
487                 False,
488                 "arn:aws:iam::1234:role/apigatewayrole",
489                 **conn_parameters
490             )
491         self.assertFalse(result.get("result", True))
492     def test_present_when_stage_is_already_at_desired_deployment(self):
493         self.conn.get_rest_apis.return_value = apis_ret
494         self.conn.get_deployment.return_value = deployment1_ret
495         self.conn.get_stage.return_value = stage1_deployment1_ret
496         self.conn.update_stage.side_effect = ClientError(
497             error_content, "update_stage should not be called"
498         )
499         result = {}
500         with TempSwaggerFile() as swagger_file:
501             result = self.salt_states["boto_apigateway.present"](
502                 "api present",
503                 "unit test api",
504                 swagger_file,
505                 "test",
506                 False,
507                 **conn_parameters
508             )
509         self<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertFalse(result.get("abort"))
510         self.assertTrue(result.get("current"))
511         self.assertIs(result.get("result"), True)
512         self.assertNotIn("update_stage should not be called", result.get("comment", ""))
513     def</b></font> test_present_when_stage_is_already_at_desired_deployment_and_needs_stage_variables_update(
514         self,
515     ):
516         self.conn.get_rest_apis.return_value = apis_ret
517         self.conn.get_deployment.return_value = deployment1_ret
518         self.conn.get_stage.return_value = stage1_deployment1_ret
519         self.conn.update_stage.return_value = stage1_deployment1_vars_ret
520         result = {}
521         with TempSwaggerFile() as swagger_file:
522             result = self.salt_states["boto_apigateway.present"](
523                 "api present",
524                 "unit test api",
525                 swagger_file,
526                 "test",
527                 False,
528                 "arn:aws:iam::1234:role/apigatewayrole",
529                 stage_variables={"var1": "val1"},
530             )
531         self<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertFalse(result.get("abort"))
532         self.assertTrue(result.get("current"))
533         self.assertIs(result.get("result"), True)
534     def</b></font> test_present_when_stage_exists_and_is_to_associate_to_existing_deployment(self):
535         self.conn.get_rest_apis.return_value = apis_ret
536         self.conn.get_deployment.return_value = deployment2_ret
537         self.conn.get_deployments.return_value = deployments_ret
538         self.conn.get_stage.return_value = stage1_deployment2_ret
539         self.conn.update_stage.return_value = stage1_deployment1_ret
540         self.conn.create_stage.side_effect = ClientError(error_content, "create_stage")
541         self.conn.create_deployment.side_effect = ClientError(
542             error_content, "create_deployment"
543         )
544         result = {}
545         with TempSwaggerFile() as swagger_file:
546             result = self.salt_states["boto_apigateway.present"](
547                 "api present",
548                 "unit test api",
549                 swagger_file,
550                 "test",
551                 False,
552                 "arn:aws:iam::1234:role/apigatewayrole",
553             )
554         self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertTrue(result.get("publish"))
555         self.assertIs(result.get("result"), True)
556         self.assertFalse(result.get("abort"))
557         self.assertTrue(result.get("changes", {}).get("new", [{}])[</b></font>0])
558     @pytest.mark.slow_test
559     def test_present_when_stage_is_to_associate_to_new_deployment(self):
560         self.conn.get_rest_apis.return_value = no_apis_ret
561         self.conn.create_rest_api.return_value = api_ret
562         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
563         self.conn.create_model.return_value = mock_model_ret
564         self.conn.get_resources.return_value = resources_ret
565         self.conn.create_resource.side_effect = ClientError(
566             error_content, "create_resource"
567         )
568         self.conn.put_method.return_value = method_ret
569         self.conn.put_integration.return_value = method_integration_ret
570         self.conn.put_method_response.return_value = method_response_200_ret
571         self.conn.put_intgration_response.return_value = (
572             method_integration_response_200_ret
573         )
574         result = {}
575         with patch.dict(
576             self.funcs,
577             {
578                 "boto_lambda.describe_function": MagicMock(
579                     return_value={"function": function_ret}
580                 )
581             },
582         ):
583             with TempSwaggerFile() as swagger_file:
584                 result = self.salt_states["boto_apigateway.present"](
585                     "api present",
586                     "unit test api",
587                     swagger_file,
588                     "test",
589                     False,
590                     "arn:aws:iam::1234:role/apigatewayrole",
591                     **conn_parameters
592                 )
593         self.assertIs(result.get("result"), True)
594         self.assertIs(result.get("abort"), None)
595     def test_present_when_stage_associating_to_new_deployment_errored_on_api_creation(
596         self,
597     ):
598         self.conn.get_rest_apis.return_value = no_apis_ret
599         self.conn.create_rest_api.side_effect = ClientError(
600             error_content, "create_rest_api"
601         )
602         result = {}
603         with TempSwaggerFile() as swagger_file:
604             result = self.salt_states["boto_apigateway.present"](
605                 "api present",
606                 "unit test api",
607                 swagger_file,
608                 "test",
609                 False,
610                 "arn:aws:iam::1234:role/apigatewayrole",
611             )
612         self<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIs(result.get("abort"), True)
613         self.assertIs(result.get("result"), False)
614         self.assertIn("create_rest_api", result.get(</b></font>"comment", ""))
615     def test_present_when_stage_associating_to_new_deployment_errored_on_model_creation(
616         self,
617     ):
618         self.conn.get_rest_apis.return_value = no_apis_ret
619         self.conn.create_rest_api.return_value = api_ret
620         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
621         self.conn.create_model.side_effect = ClientError(error_content, "create_model")
622         result = {}
623         with TempSwaggerFile() as swagger_file:
624             result = self.salt_states["boto_apigateway.present"](
625                 "api present",
626                 "unit test api",
627                 swagger_file,
628                 "test",
629                 False,
630                 "arn:aws:iam::1234:role/apigatewayrole",
631             )
632         self<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIs(result.get("abort"), True)
633         self.assertIs(result.get("result"), False)
634         self.assertIn("create_model", result.get(</b></font>"comment", ""))
635     def test_present_when_stage_associating_to_new_deployment_errored_on_resource_creation(
636         self,
637     ):
638         self.conn.get_rest_apis.return_value = no_apis_ret
639         self.conn.create_rest_api.return_value = api_ret
640         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
641         self.conn.create_model.return_value = mock_model_ret
642         self.conn.get_resources.return_value = root_resources_ret
643         self.conn.create_resource.side_effect = ClientError(
644             error_content, "create_resource"
645         )
646         result = {}
647         with TempSwaggerFile() as swagger_file:
648             result = self.salt_states["boto_apigateway.present"](
649                 "api present",
650                 "unit test api",
651                 swagger_file,
652                 "test",
653                 False,
654                 **conn_parameters
655             )
656         self<font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIs(result.get("abort"), True)
657         self.assertIs(result.get("result"), False)
658         self.assertIn("create_resource", result.get(</b></font>"comment", ""))
659     @pytest.mark.slow_test
660     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method(
661         self,
662     ):
663         self.conn.get_rest_apis.return_value = no_apis_ret
664         self.conn.create_rest_api.return_value = api_ret
665         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
666         self.conn.create_model.return_value = mock_model_ret
667         self.conn.get_resources.return_value = resources_ret
668         self.conn.create_resource.side_effect = ClientError(
669             error_content, "create_resource"
670         )
671         self.conn.put_method.side_effect = ClientError(error_content, "put_method")
672         result = {}
673         with patch.dict(
674             self.funcs,
675             {
676                 "boto_lambda.describe_function": MagicMock(
677                     return_value={"function": function_ret}
678                 )
679             },
680         ):
681             with TempSwaggerFile() as swagger_file:
682                 result = self.salt_states["boto_apigateway.present"](
683                     "api present",
684                     "unit test api",
685                     swagger_file,
686                     "test",
687                     False,
688                     "arn:aws:iam::1234:role/apigatewayrole",
689                     **conn_parameters
690                 )
691         self.assertIs(result.get("abort"), True)
692         self.assertIs(result.get("result"), False)
693         self.assertIn("put_method", result.get("comment", ""))
694     @pytest.mark.slow_test
695     def test_present_when_stage_associating_to_new_deployment_errored_on_lambda_function_lookup(
696         self,
697     ):
698         self.conn.get_rest_apis.return_value = no_apis_ret
699         self.conn.create_rest_api.return_value = api_ret
700         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
701         self.conn.create_model.return_value = mock_model_ret
702         self.conn.get_resources.return_value = resources_ret
703         self.conn.create_resource.side_effect = ClientError(
704             error_content, "create_resource"
705         )
706         self.conn.put_method.return_value = method_ret
707         self.conn.put_integration.side_effect = ClientError(
708             error_content, "put_integration should not be invoked"
709         )
710         result = {}
711         with patch.dict(
712             self.funcs,
713             {
714                 "boto_lambda.describe_function": MagicMock(
715                     return_value={"error": "no such lambda"}
716                 )
717             },
718         ):
719             with TempSwaggerFile() as swagger_file:
720                 result = self.salt_states["boto_apigateway.present"](
721                     "api present",
722                     "unit test api",
723                     swagger_file,
724                     "test",
725                     False,
726                     "arn:aws:iam::1234:role/apigatewayrole",
727                     **conn_parameters
728                 )
729         self.assertIs(result.get("result"), False)
730         self.assertNotIn(
731             "put_integration should not be invoked", result.get("comment", "")
732         )
733         self.assertIn("not find lambda function", result.get("comment", ""))
734     @pytest.mark.slow_test
735     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration(
736         self,
737     ):
738         self.conn.get_rest_apis.return_value = no_apis_ret
739         self.conn.create_rest_api.return_value = api_ret
740         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
741         self.conn.create_model.return_value = mock_model_ret
742         self.conn.get_resources.return_value = resources_ret
743         self.conn.create_resource.side_effect = ClientError(
744             error_content, "create_resource"
745         )
746         self.conn.put_method.return_value = method_ret
747         self.conn.put_integration.side_effect = ClientError(
748             error_content, "put_integration"
749         )
750         result = {}
751         with patch.dict(
752             self.funcs,
753             {
754                 "boto_lambda.describe_function": MagicMock(
755                     return_value={"function": function_ret}
756                 )
757             },
758         ):
759             with TempSwaggerFile() as swagger_file:
760                 result = self.salt_states["boto_apigateway.present"](
761                     "api present",
762                     "unit test api",
763                     swagger_file,
764                     "test",
765                     False,
766                     "arn:aws:iam::1234:role/apigatewayrole",
767                     **conn_parameters
768                 )
769         self.assertIs(result.get("abort"), True)
770         self.assertIs(result.get("result"), False)
771         self.assertIn("put_integration", result.get("comment", ""))
772     @pytest.mark.slow_test
773     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method_response(
774         self,
775     ):
776         self.conn.get_rest_apis.return_value = no_apis_ret
777         self.conn.create_rest_api.return_value = api_ret
778         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
779         self.conn.create_model.return_value = mock_model_ret
780         self.conn.get_resources.return_value = resources_ret
781         self.conn.create_resource.side_effect = ClientError(
782             error_content, "create_resource"
783         )
784         self.conn.put_method.return_value = method_ret
785         self.conn.put_integration.return_value = method_integration_ret
786         self.conn.put_method_response.side_effect = ClientError(
787             error_content, "put_method_response"
788         )
789         result = {}
790         with patch.dict(
791             self.funcs,
792             {
793                 "boto_lambda.describe_function": MagicMock(
794                     return_value={"function": function_ret}
795                 )
796             },
797         ):
798             with TempSwaggerFile() as swagger_file:
799                 result = self.salt_states["boto_apigateway.present"](
800                     "api present",
801                     "unit test api",
802                     swagger_file,
803                     "test",
804                     False,
805                     "arn:aws:iam::1234:role/apigatewayrole",
806                     **conn_parameters
807                 )
808         self.assertIs(result.get("abort"), True)
809         self.assertIs(result.get("result"), False)
810         self.assertIn("put_method_response", result.get("comment", ""))
811     @pytest.mark.slow_test
812     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration_response(
813         self,
814     ):
815         self.conn.get_rest_apis.return_value = no_apis_ret
816         self.conn.create_rest_api.return_value = api_ret
817         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
818         self.conn.create_model.return_value = mock_model_ret
819         self.conn.get_resources.return_value = resources_ret
820         self.conn.create_resource.side_effect = ClientError(
821             error_content, "create_resource"
822         )
823         self.conn.put_method.return_value = method_ret
824         self.conn.put_integration.return_value = method_integration_ret
825         self.conn.put_method_response.return_value = method_response_200_ret
826         self.conn.put_integration_response.side_effect = ClientError(
827             error_content, "put_integration_response"
828         )
829         result = {}
830         with patch.dict(
831             self.funcs,
832             {
833                 "boto_lambda.describe_function": MagicMock(
834                     return_value={"function": function_ret}
835                 )
836             },
837         ):
838             with TempSwaggerFile() as swagger_file:
839                 result = self.salt_states["boto_apigateway.present"](
840                     "api present",
841                     "unit test api",
842                     swagger_file,
843                     "test",
844                     False,
845                     "arn:aws:iam::1234:role/apigatewayrole",
846                     **conn_parameters
847                 )
848         self.assertIs(result.get("abort"), True)
849         self.assertIs(result.get("result"), False)
850         self.assertIn("put_integration_response", result.get("comment", ""))
851     def test_absent_when_rest_api_does_not_exist(self):
852         self.conn.get_rest_apis.return_value = apis_ret
853         self.conn.get_stage.side_effect = ClientError(
854         )
855         result = self<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.salt_states["boto_apigateway.absent"](
856             "api present",
857             "no_such_rest_api",
858             "no_such_stage",
859             nuke_api=False,
860             **conn_parameters
861         )
862         self.assertIs(result.get("result"), True)
863         self.assertNotIn("get_stage should not be called", result.get("comment", ""))
864         self.</b></font>assertEqual(result.get("changes"), {})
865     def test_absent_when_stage_is_invalid(self):
866         self.conn.get_rest_apis.return_value = apis_ret
867         self.conn.get_stage.return_value = stage1_deployment1_ret
868         self.conn.delete_stage.side_effect = ClientError(error_content, "delete_stage")
869         result = self.salt_states["boto_apigateway.absent"](
870             "api present",
871             "unit test api",
872             "no_such_stage",
873             nuke_api=False,
874             **conn_parameters
875         )
876         self.assertTrue(result.get("abort", False))
877     def test_absent_when_stage_is_valid_and_only_one_stage_is_associated_to_deployment(
878         self,
879     ):
880         self.conn.get_rest_apis.return_value = apis_ret
881         self.conn.get_stage.return_value = stage1_deployment1_ret
882         self.conn.delete_stage.return_value = {
883             "ResponseMetadata": {
884                 "HTTPStatusCode": 200,
885                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
886             }
887         }
888         self.conn.get_stages.return_value = no_stages_ret
889         self.conn.delete_deployment.return_value = {
890             "ResponseMetadata": {
891                 "HTTPStatusCode": 200,
892                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
893             }
894         }
895         result = self.salt_states["boto_apigateway.absent"](
896             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
897         )
898         self.assertTrue(result.get("result", False))
899     def test_absent_when_stage_is_valid_and_two_stages_are_associated_to_deployment(
900         self,
901     ):
902         self.conn.get_rest_apis.return_value = apis_ret
903         self.conn.get_stage.return_value = stage1_deployment1_ret
904         self.conn.delete_stage.return_value = {
905             "ResponseMetadata": {
906                 "HTTPStatusCode": 200,
907                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
908             }
909         }
910         self.conn.get_stages.return_value = stages_stage2_ret
911         result = self.salt_states["boto_apigateway.absent"](
912             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
913         )
914         self.assertTrue(result.get("result", False))
915     def test_absent_when_failing_to_delete_a_deployment_no_longer_associated_with_any_stages(
916         self,
917     ):
918         self.conn.get_rest_apis.return_value = apis_ret
919         self.conn.get_stage.return_value = stage1_deployment1_ret
920         self.conn.delete_stage.return_value = {
921             "ResponseMetadata": {
922                 "HTTPStatusCode": 200,
923                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
924             }
925         }
926         self.conn.get_stages.return_value = no_stages_ret
927         self.conn.delete_deployment.side_effect = ClientError(
928             error_content, "delete_deployment"
929         )
930         result = self.salt_states["boto_apigateway.absent"](
931             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
932         )
933         self.assertTrue(result.get("abort", False))
934     def test_absent_when_nuke_api_and_no_more_stages_deployments_remain(self):
935         self.conn.get_rest_apis.return_value = apis_ret
936         self.conn.get_stage.return_value = stage1_deployment1_ret
937         self.conn.delete_stage.return_value = {
938             "ResponseMetadata": {
939                 "HTTPStatusCode": 200,
940                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
941             }
942         }
943         self.conn.get_stages.return_value = no_stages_ret
944         self.conn.get_deployments.return_value = deployments_ret
945         self.conn.delete_rest_api.return_value = {
946             "ResponseMetadata": {
947                 "HTTPStatusCode": 200,
948                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
949             }
950         }
951         result = self.salt_states["boto_apigateway.absent"](
952         )
953         self.assertIs(result.get<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("result"), True)
954         self.assertIsNot(result.get("abort"), True)
955         self.assertIs(
956             result.get("changes", {})
957             .get("new", [{}])[0]
958             .get("delete_api", {})
959             .</b></font>get("deleted"),
960             True,
961         )
962     def test_absent_when_nuke_api_and_other_stages_deployments_exist(self):
963         self.conn.get_rest_apis.return_value = apis_ret
964         self.conn.get_stage.return_value = stage1_deployment1_ret
965         self.conn.delete_stage.return_value = {
966             "ResponseMetadata": {
967                 "HTTPStatusCode": 200,
968                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
969             }
970         }
971         self.conn.get_stages.return_value = stages_stage2_ret
972         self.conn.get_deployments.return_value = deployments_ret
973         self.conn.delete_rest_api.side_effect = ClientError(
974             error_content, "unexpected_api_delete"
975         )
976         result = self.salt_states["boto_apigateway.absent"](
977             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
978         )
979         self.assertIs(result.get("result"), True)
980         self.assertIsNot(result.get("abort"), True)
981 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
982 @skipIf(
983     _has_required_boto() is False,
984     "The boto3 module must be greater than or equal to version {}".format(
985         required_boto3_version
986     ),
987 )
988 @skipIf(
989     _has_required_botocore() is False,
990     "The botocore module must be greater than or equal to version {}".format(
991         required_botocore_version
992     ),
993 )
994 class BotoApiGatewayUsagePlanTestCase(
995     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
996 ):
997     @pytest.mark.slow_test
998     def test_usage_plan_present_if_describe_fails(self, *args):
999         with patch.dict(
1000             boto_apigateway.__salt__,
1001             {
1002                 "boto_apigateway.describe_usage_plans": MagicMock(
1003                     return_value={"error": "error"}
1004                 )
1005             },
1006         ):
1007             result = boto_apigateway.usage_plan_present(
1008                 "name", "plan_name", **conn_parameters
1009             self.assertIn("result", result)
1010             self<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(result["result"], False)
1011             self.assertIn("comment", result)
1012             self.assertEqual(
1013                 result["comment"], "Failed to describe existing usage plans"
1014             )
1015             self.assertIn("changes", result)
1016             self.assertEqual(result[</b></font>"changes"], {})
1017     @pytest.mark.slow_test
1018     def test_usage_plan_present_if_there_is_no_such_plan_and_test_option_is_set(
1019         self, *args
1020     ):
1021         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1022             with patch.dict(
1023                 boto_apigateway.__salt__,
1024                 {
1025                     "boto_apigateway.describe_usage_plans": MagicMock(
1026                         return_value={"plans": []}
1027                     )
1028                 },
1029             ):
1030                 result = boto_apigateway.usage_plan_present(
1031                     "name", "plan_name", **conn_parameters
1032                 )
1033                 self.assertIn("comment", result)
1034                 self.assertEqual(
1035                     result["comment"], "a new usage plan plan_name would be created"
1036                 )
1037                 self.assertIn("result", result)
1038                 self.assertEqual(result["result"], None)
1039     @pytest.mark.slow_test
1040     def test_usage_plan_present_if_create_usage_plan_fails(self, *args):
1041         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1042             with patch.dict(
1043                 boto_apigateway.__salt__,
1044                 {
1045                     "boto_apigateway.describe_usage_plans": MagicMock(
1046                         return_value={"plans": []}
1047                     ),
1048                     "boto_apigateway.create_usage_plan": MagicMock(
1049                         return_value={"error": "error"}
1050                     ),
1051                 },
1052             ):
1053                 result = boto_apigateway.usage_plan_present(
1054                     "name", "plan_name", **conn_parameters
1055                 )
1056                 self.assertIn("result", result)
1057                 self.assertEqual(result["result"], False)
1058                 self.assertIn("comment", result)
1059                 self.assertEqual(
1060                     result["comment"], "Failed to create a usage plan plan_name, error"
1061                 )
1062                 self.assertIn("changes", result)
1063                 self.assertEqual(result["changes"], {})
1064     @pytest.mark.slow_test
1065     def test_usage_plan_present_if_plan_is_there_and_needs_no_updates(self, *args):
1066         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1067             with patch.dict(
1068                 boto_apigateway.__salt__,
1069                 {
1070                     "boto_apigateway.describe_usage_plans": MagicMock(
1071                         return_value={"plans": [{"id": "planid", "name": "planname"}]}
1072                     ),
1073                     "boto_apigateway.update_usage_plan": MagicMock(),
1074                 },
1075             ):
1076                 result = boto_apigateway.usage_plan_present(
1077                 )
1078                 self<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIn("result", result)
1079                 self.assertEqual(result["result"], True)
1080                 self.assertIn("comment", result)
1081                 self.assertEqual(
1082                     result["comment"],
1083                     "usage plan plan_name is already in a correct state",
1084                 )
1085                 self.assertIn("changes", result)
1086                 self.assertEqual(result["changes"], {})
1087                 self.assertTrue(</b></font>
1088                     boto_apigateway.__salt__[
1089                         "boto_apigateway.update_usage_plan"
1090                     ].call_count
1091                     == 0
1092                 )
1093     @pytest.mark.slow_test
1094     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_test_is_set(
1095         self, *args
1096     ):
1097         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1098             with patch.dict(
1099                 boto_apigateway.__salt__,
1100                 {
1101                     "boto_apigateway.describe_usage_plans": MagicMock(
1102                         return_value={
1103                             "plans": [
1104                                 {
1105                                     "id": "planid",
1106                                     "name": "planname",
1107                                     "throttle": {"rateLimit": 10.0},
1108                                 }
1109                             ]
1110                         }
1111                     ),
1112                     "boto_apigateway.update_usage_plan": MagicMock(),
1113                 },
1114             ):
1115                 result = boto_apigateway.usage_plan_present(
1116                     "name", "plan_name", **conn_parameters
1117                 self.assertIn("comment", result)
1118                 self<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(
1119                     result["comment"], "a new usage plan plan_name would be updated"
1120                 )
1121                 self.assertIn("result", result)
1122                 self.assertEqual(result["result"], None)
1123                 self.assertTrue(
1124                     boto_apigateway.__salt__[
1125                         "boto_apigateway.update_usage_plan"
1126                     ].</b></font>call_count
1127                     == 0
1128                 )
1129     @pytest.mark.slow_test
1130     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_update_fails(
1131         self, *args
1132     ):
1133         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1134             with patch.dict(
1135                 boto_apigateway.__salt__,
1136                 {
1137                     "boto_apigateway.describe_usage_plans": MagicMock(
1138                         return_value={
1139                             "plans": [
1140                                 {
1141                                     "id": "planid",
1142                                     "name": "planname",
1143                                     "throttle": {"rateLimit": 10.0},
1144                                 }
1145                             ]
1146                         }
1147                     ),
1148                     "boto_apigateway.update_usage_plan": MagicMock(
1149                         return_value={"error": "error"}
1150                     ),
1151                 },
1152             ):
1153                 result = boto_apigateway.usage_plan_present(
1154                     "name", "plan_name", **conn_parameters
1155                 )
1156                 self.assertIn("result", result)
1157                 self.assertEqual(result["result"], False)
1158                 self.assertIn("comment", result)
1159                 self.assertEqual(
1160                     result["comment"], "Failed to update a usage plan plan_name, error"
1161                 )
1162     @pytest.mark.slow_test
1163     def test_usage_plan_present_if_plan_has_been_created(self, *args):
1164         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1165             with patch.dict(
1166                 boto_apigateway.__salt__,
1167                 {
1168                     "boto_apigateway.describe_usage_plans": MagicMock(
1169                         side_effect=[{"plans": []}, {"plans": [{"id": "id"}]}]
1170                     ),
1171                     "boto_apigateway.create_usage_plan": MagicMock(
1172                         return_value={"created": True}
1173                     ),
1174                 },
1175             ):
1176                 result = boto_apigateway.usage_plan_present(
1177                     "name", "plan_name", **conn_parameters
1178                 )
1179                 self.assertIn("result", result)
1180                 self.assertEqual(result["result"], True)
1181                 self.assertIn("comment", result)
1182                 self.assertEqual(
1183                     result["comment"], "A new usage plan plan_name has been created"
1184                 )
1185                 self.assertEqual(result["changes"]["old"], {"plan": None})
1186                 self.assertEqual(result["changes"]["new"], {"plan": {"id": "id"}})
1187     @pytest.mark.slow_test
1188     def test_usage_plan_present_if_plan_has_been_updated(self, *args):
1189         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1190             with patch.dict(
1191                 boto_apigateway.__salt__,
1192                 {
1193                     "boto_apigateway.describe_usage_plans": MagicMock(
1194                         side_effect=[
1195                             {"plans": [{"id": "id"}]},
1196                             {
1197                                 "plans": [
1198                                     {
1199                                         "id": "id",
1200                                         "throttle": {"rateLimit": throttle_rateLimit},
1201                                     }
1202                                 ]
1203                             },
1204                         ]
1205                     ),
1206                     "boto_apigateway.update_usage_plan": MagicMock(
1207                         return_value={"updated": True}
1208                     ),
1209                 },
1210             ):
1211                 result = boto_apigateway.usage_plan_present(
1212                     "name",
1213                     "plan_name",
1214                     throttle={"rateLimit": throttle_rateLimit},
1215                     **conn_parameters
1216                 )
1217                 self.assertIn("result", result)
1218                 self.assertEqual(result["result"], True)
1219                 self.assertIn("comment", result)
1220                 self.assertEqual(
1221                     result["comment"], "usage plan plan_name has been updated"
1222                 )
1223                 self.assertEqual(result["changes"]["old"], {"plan": {"id": "id"}})
1224                 self.assertEqual(
1225                     result["changes"]["new"],
1226                     {
1227                         "plan": {
1228                             "id": "id",
1229                             "throttle": {"rateLimit": throttle_rateLimit},
1230                         }
1231                     },
1232                 )
1233     @pytest.mark.slow_test
1234     def test_usage_plan_present_if_ValueError_is_raised(self, *args):
1235         with patch.dict(
1236             boto_apigateway.__salt__,
1237             {
1238                 "boto_apigateway.describe_usage_plans": MagicMock(
1239                     side_effect=ValueError("error")
1240                 )
1241             },
1242         ):
1243             result = boto_apigateway.usage_plan_present(
1244                 "name",
1245                 "plan_name",
1246                 throttle={"rateLimit": throttle_rateLimit},
1247                 **conn_parameters
1248             )
1249             self.assertIn("result", result)
1250             self.assertEqual(result["result"], False)
1251             self.assertIn("comment", result)
1252             self.assertEqual(result["comment"], repr(("error",)))
1253     @pytest.mark.slow_test
1254     def test_usage_plan_present_if_IOError_is_raised(self, *args):
1255         with patch.dict(
1256             boto_apigateway.__salt__,
1257             {
1258                 "boto_apigateway.describe_usage_plans": MagicMock(
1259                     side_effect=IOError("error")
1260                 )
1261             },
1262         ):
1263             result = boto_apigateway.usage_plan_present(
1264                 "name",
1265                 "plan_name",
1266                 throttle={"rateLimit": throttle_rateLimit},
1267                 **conn_parameters
1268             )
1269             self.assertIn("result", result)
1270             self.assertEqual(result["result"], False)
1271             self.assertIn("comment", result)
1272             self.assertEqual(result["comment"], repr(("error",)))
1273     @pytest.mark.slow_test
1274     def test_usage_plan_absent_if_describe_fails(self, *args):
1275         with patch.dict(
1276             boto_apigateway.__salt__,
1277             {
1278                 "boto_apigateway.describe_usage_plans": MagicMock(
1279                     return_value={"error": "error"}
1280                 )
1281             },
1282         ):
1283             result = {}
1284             result = boto_apigateway.usage_plan_absent(
1285                 "name", "plan_name", **conn_parameters
1286             )
1287             self.assertIn("result", result)
1288             self.assertEqual(result["result"], False)
1289             self.assertIn("comment", result)
1290             self.assertEqual(
1291                 result["comment"], "Failed to describe existing usage plans"
1292             )
1293             self.assertIn("changes", result)
1294             self.assertEqual(result["changes"], {})
1295     @pytest.mark.slow_test
1296     def test_usage_plan_absent_if_plan_is_not_present(self, *args):
1297         with patch.dict(
1298             boto_apigateway.__salt__,
1299             {
1300                 "boto_apigateway.describe_usage_plans": MagicMock(
1301                     return_value={"plans": []}
1302                 )
1303             },
1304         ):
1305             result = {}
1306             result = boto_apigateway.usage_plan_absent(
1307                 "name", "plan_name", **conn_parameters
1308             )
1309             self.assertIn("result", result)
1310             self.assertEqual(result["result"], True)
1311             self.assertIn("comment", result)
1312             self.assertEqual(
1313                 result["comment"], "Usage plan plan_name does not exist already"
1314             )
1315             self.assertIn("changes", result)
1316             self.assertEqual(result["changes"], {})
1317     @pytest.mark.slow_test
1318     def test_usage_plan_absent_if_plan_is_present_but_test_option_is_set(self, *args):
1319         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1320             with patch.dict(
1321                 boto_apigateway.__salt__,
1322                 {
1323                     "boto_apigateway.describe_usage_plans": MagicMock(
1324                         return_value={"plans": [{"id": "id"}]}
1325                     )
1326                 },
1327             ):
1328                 result = {}
1329                 result = boto_apigateway.usage_plan_absent(
1330                     "name", "plan_name", **conn_parameters
1331                 )
1332                 self.assertIn("result", result)
1333                 self.assertEqual(result["result"], None)
1334                 self.assertIn("comment", result)
1335                 self.assertEqual(
1336                     result["comment"],
1337                     "Usage plan plan_name exists and would be deleted",
1338                 )
1339                 self.assertIn("changes", result)
1340                 self.assertEqual(result["changes"], {})
1341     @pytest.mark.slow_test
1342     def test_usage_plan_absent_if_plan_is_present_but_delete_fails(self, *args):
1343         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1344             with patch.dict(
1345                 boto_apigateway.__salt__,
1346                 {
1347                     "boto_apigateway.describe_usage_plans": MagicMock(
1348                         return_value={"plans": [{"id": "id"}]}
1349                     ),
1350                     "boto_apigateway.delete_usage_plan": MagicMock(
1351                         return_value={"error": "error"}
1352                     ),
1353                 },
1354             ):
1355                 result = boto_apigateway.usage_plan_absent(
1356                     "name", "plan_name", **conn_parameters
1357                 )
1358                 self.assertIn("result", result)
1359                 self.assertEqual(result["result"], False)
1360                 self.assertIn("comment", result)
1361                 self.assertEqual(
1362                     result["comment"],
1363                     "Failed to delete usage plan plan_name, "
1364                     + repr({"error": "error"}),
1365                 )
1366                 self.assertIn("changes", result)
1367                 self.assertEqual(result["changes"], {})
1368     @pytest.mark.slow_test
1369     def test_usage_plan_absent_if_plan_has_been_deleted(self, *args):
1370         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1371             with patch.dict(
1372                 boto_apigateway.__salt__,
1373                 {
1374                     "boto_apigateway.describe_usage_plans": MagicMock(
1375                         return_value={"plans": [{"id": "id"}]}
1376                     ),
1377                     "boto_apigateway.delete_usage_plan": MagicMock(
1378                         return_value={"deleted": True}
1379                     ),
1380                 },
1381             ):
1382                 result = boto_apigateway.usage_plan_absent(
1383                     "name", "plan_name", **conn_parameters
1384                 )
1385                 self.assertIn("result", result)
1386                 self.assertEqual(result["result"], True)
1387                 self.assertIn("comment", result)
1388                 self.assertEqual(
1389                     result["comment"], "Usage plan plan_name has been deleted"
1390                 )
1391                 self.assertIn("changes", result)
1392                 self.assertEqual(
1393                     result["changes"],
1394                     {"new": {"plan": None}, "old": {"plan": {"id": "id"}}},
1395                 )
1396     @pytest.mark.slow_test
1397     def test_usage_plan_absent_if_ValueError_is_raised(self, *args):
1398         with patch.dict(
1399             boto_apigateway.__salt__,
1400             {
1401                 "boto_apigateway.describe_usage_plans": MagicMock(
1402                     side_effect=ValueError("error")
1403                 )
1404             },
1405         ):
1406             result = boto_apigateway.usage_plan_absent(
1407                 "name", "plan_name", **conn_parameters
1408             )
1409             self.assertIn("result", result)
1410             self.assertEqual(result["result"], False)
1411             self.assertIn("comment", result)
1412             self.assertEqual(result["comment"], repr(("error",)))
1413     @pytest.mark.slow_test
1414     def test_usage_plan_absent_if_IOError_is_raised(self, *args):
1415         with patch.dict(
1416             boto_apigateway.__salt__,
1417             {
1418                 "boto_apigateway.describe_usage_plans": MagicMock(
1419                     side_effect=IOError("error")
1420                 )
1421             },
1422         ):
1423             result = boto_apigateway.usage_plan_absent(
1424                 "name", "plan_name", **conn_parameters
1425             )
1426             self.assertIn("result", result)
1427             self.assertEqual(result["result"], False)
1428             self.assertIn("comment", result)
1429             self.assertEqual(result["comment"], repr(("error",)))
1430 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
1431 @skipIf(
1432     _has_required_boto() is False,
1433     "The boto3 module must be greater than or equal to version {}".format(
1434         required_boto3_version
1435     ),
1436 )
1437 @skipIf(
1438     _has_required_botocore() is False,
1439     "The botocore module must be greater than or equal to version {}".format(
1440         required_botocore_version
1441     ),
1442 )
1443 class BotoApiGatewayUsagePlanAssociationTestCase(
1444     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1445 ):
1446     @pytest.mark.slow_test
1447     def test_usage_plan_association_present_if_describe_fails(self, *args):
1448         with patch.dict(
1449             boto_apigateway.__salt__,
1450             {
1451                 "boto_apigateway.describe_usage_plans": MagicMock(
1452                     return_value={"error": "error"}
1453                 )
1454             },
1455         ):
1456             result = boto_apigateway.usage_plan_association_present(
1457                 "name", "plan_name", [association_stage_1], **conn_parameters
1458             )
1459             self.assertIn("result", result)
1460             self.assertEqual(result["result"], False)
1461             self.assertIn("comment", result)
1462             self.assertEqual(
1463                 result["comment"], "Failed to describe existing usage plans"
1464             )
1465             self.assertIn("changes", result)
1466             self.assertEqual(result["changes"], {})
1467     @pytest.mark.slow_test
1468     def test_usage_plan_association_present_if_plan_is_not_present(self, *args):
1469         with patch.dict(
1470             boto_apigateway.__salt__,
1471             {
1472                 "boto_apigateway.describe_usage_plans": MagicMock(
1473                     return_value={"plans": []}
1474                 )
1475             },
1476         ):
1477             result = boto_apigateway.usage_plan_association_present(
1478                 "name", "plan_name", [association_stage_1], **conn_parameters
1479             )
1480             self.assertIn("result", result)
1481             self.assertEqual(result["result"], False)
1482             self.assertIn("comment", result)
1483             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1484             self.assertIn("changes", result)
1485             self.assertEqual(result["changes"], {})
1486     @pytest.mark.slow_test
1487     def test_usage_plan_association_present_if_multiple_plans_with_the_same_name_exist(
1488         self, *args
1489     ):
1490         with patch.dict(
1491             boto_apigateway.__salt__,
1492             {
1493                 "boto_apigateway.describe_usage_plans": MagicMock(
1494                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1495                 )
1496             },
1497         ):
1498             result = boto_apigateway.usage_plan_association_present(
1499                 "name", "plan_name", [association_stage_1], **conn_parameters
1500             )
1501             self.assertIn("result", result)
1502             self.assertEqual(result["result"], False)
1503             self.assertIn("comment", result)
1504             self.assertEqual(
1505                 result["comment"],
1506                 "There are multiple usage plans with the same name - it is not"
1507                 " supported",
1508             )
1509             self.assertIn("changes", result)
1510             self.assertEqual(result["changes"], {})
1511     @pytest.mark.slow_test
1512     def test_usage_plan_association_present_if_association_already_exists(self, *args):
1513         with patch.dict(
1514             boto_apigateway.__salt__,
1515             {
1516                 "boto_apigateway.describe_usage_plans": MagicMock(
1517                     return_value={
1518                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1519                     }
1520                 )
1521             },
1522         ):
1523             result = boto_apigateway.usage_plan_association_present(
1524                 "name", "plan_name", [association_stage_1], **conn_parameters
1525             )
1526             self.assertIn("result", result)
1527             self.assertEqual(result["result"], True)
1528             self.assertIn("comment", result)
1529             self.assertEqual(
1530                 result["comment"], "Usage plan is already asssociated to all api stages"
1531             )
1532             self.assertIn("changes", result)
1533             self.assertEqual(result["changes"], {})
1534     @pytest.mark.slow_test
1535     def test_usage_plan_association_present_if_update_fails(self, *args):
1536         with patch.dict(
1537             boto_apigateway.__salt__,
1538             {
1539                 "boto_apigateway.describe_usage_plans": MagicMock(
1540                     return_value={
1541                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1542                     }
1543                 ),
1544                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1545                     return_value={"error": "error"}
1546             },
1547         ):
1548             result = boto_apigateway<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.usage_plan_association_present(
1549                 "name", "plan_name", [association_stage_2], **conn_parameters
1550             )
1551             self.assertIn("result", result)
1552             self.assertEqual(result["result"], False)
1553             self.assertIn("comment", result)
1554             self.assertTrue(
1555                 result["comment"].startswith("Failed to associate a usage plan")
1556             )
1557             self.assertIn("changes", result)
1558             self.assertEqual(result[</b></font>"changes"], {})
1559     @pytest.mark.slow_test
1560     def test_usage_plan_association_present_success(self, *args):
1561         with patch.dict(
1562             boto_apigateway.__salt__,
1563             {
1564                 "boto_apigateway.describe_usage_plans": MagicMock(
1565                     return_value={
1566                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1567                     }
1568                 ),
1569                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1570                     return_value={
1571                         "result": {
1572                             "apiStages": [association_stage_1, association_stage_2]
1573                         }
1574                     }
1575                 ),
1576             },
1577         ):
1578             result = boto_apigateway.usage_plan_association_present(
1579                 "name", "plan_name", [association_stage_2], **conn_parameters
1580             )
1581             self.assertIn("result", result)
1582             self.assertEqual(result["result"], True)
1583             self.assertIn("comment", result)
1584             self.assertEqual(
1585                 result["comment"], "successfully associated usage plan to apis"
1586             )
1587             self.assertIn("changes", result)
1588             self.assertEqual(
1589                 result["changes"],
1590                 {
1591                     "new": [association_stage_1, association_stage_2],
1592                     "old": [association_stage_1],
1593                 },
1594             )
1595     @pytest.mark.slow_test
1596     def test_usage_plan_association_present_if_value_error_is_thrown(self, *args):
1597         with patch.dict(
1598             boto_apigateway.__salt__,
1599             {
1600                 "boto_apigateway.describe_usage_plans": MagicMock(
1601                     side_effect=ValueError("error")
1602                 )
1603             },
1604         ):
1605             result = boto_apigateway.usage_plan_association_present(
1606                 "name", "plan_name", [], **conn_parameters
1607             )
1608             self.assertIn("result", result)
1609             self.assertEqual(result["result"], False)
1610             self.assertIn("comment", result)
1611             self.assertEqual(result["comment"], repr(("error",)))
1612             self.assertIn("changes", result)
1613             self.assertEqual(result["changes"], {})
1614     @pytest.mark.slow_test
1615     def test_usage_plan_association_present_if_io_error_is_thrown(self, *args):
1616         with patch.dict(
1617             boto_apigateway.__salt__,
1618             {
1619                 "boto_apigateway.describe_usage_plans": MagicMock(
1620                     side_effect=IOError("error")
1621                 )
1622             },
1623         ):
1624             result = boto_apigateway.usage_plan_association_present(
1625                 "name", "plan_name", [], **conn_parameters
1626             )
1627             self.assertIn("result", result)
1628             self.assertEqual(result["result"], False)
1629             self.assertIn("comment", result)
1630             self.assertEqual(result["comment"], repr(("error",)))
1631             self.assertIn("changes", result)
1632             self.assertEqual(result["changes"], {})
1633     @pytest.mark.slow_test
1634     def test_usage_plan_association_absent_if_describe_fails(self, *args):
1635         with patch.dict(
1636             boto_apigateway.__salt__,
1637             {
1638                 "boto_apigateway.describe_usage_plans": MagicMock(
1639                     return_value={"error": "error"}
1640                 )
1641             },
1642         ):
1643             result = boto_apigateway.usage_plan_association_absent(
1644                 "name", "plan_name", [association_stage_1], **conn_parameters
1645             )
1646             self.assertIn("result", result)
1647             self.assertEqual(result["result"], False)
1648             self.assertIn("comment", result)
1649             self.assertEqual(
1650                 result["comment"], "Failed to describe existing usage plans"
1651             )
1652             self.assertIn("changes", result)
1653             self.assertEqual(result["changes"], {})
1654     @pytest.mark.slow_test
1655     def test_usage_plan_association_absent_if_plan_is_not_present(self, *args):
1656         with patch.dict(
1657             boto_apigateway.__salt__,
1658             {
1659                 "boto_apigateway.describe_usage_plans": MagicMock(
1660                     return_value={"plans": []}
1661                 )
1662             },
1663         ):
1664             result = boto_apigateway.usage_plan_association_absent(
1665                 "name", "plan_name", [association_stage_1], **conn_parameters
1666             )
1667             self.assertIn("result", result)
1668             self.assertEqual(result["result"], False)
1669             self.assertIn("comment", result)
1670             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1671             self.assertIn("changes", result)
1672             self.assertEqual(result["changes"], {})
1673     @pytest.mark.slow_test
1674     def test_usage_plan_association_absent_if_multiple_plans_with_the_same_name_exist(
1675         self, *args
1676     ):
1677         with patch.dict(
1678             boto_apigateway.__salt__,
1679             {
1680                 "boto_apigateway.describe_usage_plans": MagicMock(
1681                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1682                 )
1683             },
1684         ):
1685             result = boto_apigateway.usage_plan_association_absent(
1686                 "name", "plan_name", [association_stage_1], **conn_parameters
1687             )
1688             self.assertIn("result", result)
1689             self.assertEqual(result["result"], False)
1690             self.assertIn("comment", result)
1691             self.assertEqual(
1692                 result["comment"],
1693                 "There are multiple usage plans with the same name - it is not"
1694                 " supported",
1695             )
1696             self.assertIn("changes", result)
1697             self.assertEqual(result["changes"], {})
1698     @pytest.mark.slow_test
1699     def test_usage_plan_association_absent_if_plan_has_no_associations(self, *args):
1700         with patch.dict(
1701             boto_apigateway.__salt__,
1702             {
1703                 "boto_apigateway.describe_usage_plans": MagicMock(
1704                     return_value={"plans": [{"id": "id1", "apiStages": []}]}
1705                 )
1706             },
1707         ):
1708             result = boto_apigateway.usage_plan_association_absent(
1709                 "name", "plan_name", [association_stage_1], **conn_parameters
1710             )
1711             self.assertIn("result", result)
1712             self.assertEqual(result["result"], True)
1713             self.assertIn("comment", result)
1714             self.assertEqual(
1715                 result["comment"],
1716                 "Usage plan plan_name has no associated stages already",
1717             )
1718             self.assertIn("changes", result)
1719             self.assertEqual(result["changes"], {})
1720     @pytest.mark.slow_test
1721     def test_usage_plan_association_absent_if_plan_has_no_specific_association(
1722         self, *args
1723     ):
1724         with patch.dict(
1725             boto_apigateway.__salt__,
1726             {
1727                 "boto_apigateway.describe_usage_plans": MagicMock(
1728                     return_value={
1729                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1730                     }
1731                 )
1732             },
1733         ):
1734             result = boto_apigateway.usage_plan_association_absent(
1735                 "name", "plan_name", [association_stage_2], **conn_parameters
1736             )
1737             self.assertIn("result", result)
1738             self.assertEqual(result["result"], True)
1739             self.assertIn("comment", result)
1740             self.assertEqual(
1741                 result["comment"],
1742                 "Usage plan is already not asssociated to any api stages",
1743             )
1744             self.assertIn("changes", result)
1745             self.assertEqual(result["changes"], {})
1746     @pytest.mark.slow_test
1747     def test_usage_plan_association_absent_if_detaching_association_fails(self, *args):
1748         with patch.dict(
1749             boto_apigateway.__salt__,
1750             {
1751                 "boto_apigateway.describe_usage_plans": MagicMock(
1752                     return_value={
1753                         "plans": [
1754                             {
1755                                 "id": "id1",
1756                                 "apiStages": [association_stage_1, association_stage_2],
1757                             }
1758                         ]
1759                     }
1760                 ),
1761                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1762                     return_value={"error": "error"}
1763                 ),
1764             },
1765         ):
1766             result = boto_apigateway.usage_plan_association_absent(
1767             )
1768             self<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIn("result", result)
1769             self.assertEqual(result["result"], False)
1770             self.assertIn("comment", result)
1771             self.assertTrue(
1772                 result["comment"].startswith(
1773                     "Failed to disassociate a usage plan plan_name from the apis"
1774                 )
1775             )
1776             self.assertIn("changes", result)
1777             self.assertEqual(result[</b></font>"changes"], {})
1778     @pytest.mark.slow_test
1779     def test_usage_plan_association_absent_success(self, *args):
1780         with patch.dict(
1781             boto_apigateway.__salt__,
1782             {
1783                 "boto_apigateway.describe_usage_plans": MagicMock(
1784                     return_value={
1785                         "plans": [
1786                             {
1787                                 "id": "id1",
1788                                 "apiStages": [association_stage_1, association_stage_2],
1789                             }
1790                         ]
1791                     }
1792                 ),
1793                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1794                     return_value={"result": {"apiStages": [association_stage_1]}}
1795                 ),
1796             },
1797         ):
1798             result = boto_apigateway.usage_plan_association_absent(
1799                 "name", "plan_name", [association_stage_2], **conn_parameters
1800             )
1801             self.assertIn("result", result)
1802             self.assertEqual(result["result"], True)
1803             self.assertIn("comment", result)
1804             self.assertEqual(
1805                 result["comment"], "successfully disassociated usage plan from apis"
1806             )
1807             self.assertIn("changes", result)
1808             self.assertEqual(
1809                 result["changes"],
1810                 {
1811                     "new": [association_stage_1],
1812                     "old": [association_stage_1, association_stage_2],
1813                 },
1814             )
1815     @pytest.mark.slow_test
1816     def test_usage_plan_association_absent_if_ValueError_is_raised(self, *args):
1817         with patch.dict(
1818             boto_apigateway.__salt__,
1819             {
1820                 "boto_apigateway.describe_usage_plans": MagicMock(
1821                     side_effect=ValueError("error")
1822                 )
1823             },
1824         ):
1825             result = boto_apigateway.usage_plan_association_absent(
1826                 "name", "plan_name", [association_stage_1], **conn_parameters
1827             )
1828             self.assertIn("result", result)
1829             self.assertEqual(result["result"], False)
1830             self.assertIn("comment", result)
1831             self.assertEqual(result["comment"], repr(("error",)))
1832             self.assertIn("changes", result)
1833             self.assertEqual(result["changes"], {})
1834     @pytest.mark.slow_test
1835     def test_usage_plan_association_absent_if_IOError_is_raised(self, *args):
1836         with patch.dict(
1837             boto_apigateway.__salt__,
1838             {
1839                 "boto_apigateway.describe_usage_plans": MagicMock(
1840                     side_effect=IOError("error")
1841                 )
1842             },
1843         ):
1844             result = boto_apigateway.usage_plan_association_absent(
1845                 "name", "plan_name", [association_stage_1], **conn_parameters
1846             )
1847             self.assertIn("result", result)
1848             self.assertEqual(result["result"], False)
1849             self.assertIn("comment", result)
1850             self.assertEqual(result["comment"], repr(("error",)))
1851             self.assertIn("changes", result)
1852             self.assertEqual(result["changes"], {})
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import collections
3 import copy
4 import datetime
5 import logging
6 import os
7 import re
8 import shutil
9 import subprocess
10 import sys
11 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import time
12 import urllib.parse
13 from xml.etree import ElementTree
14 from xml.sax import saxutils
15 import jinja2.exceptions
16 import salt.utils.data
17 import salt.utils.files
18 import salt.utils.json
19 import salt.utils.path
20 import salt.utils.stringutils
21 import salt.utils.templates
22 import salt.utils.virt
23 import salt.utils.xmlutil as xmlutil
24 import salt.utils.yaml
25 from salt._compat import ipaddress
26 from salt.exceptions import CommandExecutionError, SaltInvocationError
27 try:
28     import libvirt  # pylint: disable=import-error
29     from</b></font> libvirt import libvirtError
30     HAS_LIBVIRT = True
31 except ImportError:
32     HAS_LIBVIRT = False
33 log = logging.getLogger(__name__)
34 JINJA = jinja2.Environment(
35     loader=jinja2.FileSystemLoader(
36         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "virt")
37     )
38 )
39 CACHE_DIR = "/var/lib/libvirt/saltinst"
40 VIRT_STATE_NAME_MAP = {
41     0: "running",
42     1: "running",
43     2: "running",
44     3: "paused",
45     4: "shutdown",
46     5: "shutdown",
47     6: "crashed",
48 }
49 def __virtual__():
50     if not HAS_LIBVIRT:
51         return (False, "Unable to locate or import python libvirt library.")
52     return "virt"
53 def __get_request_auth(username, password):
54     def __request_auth(credentials, user_data):
55         for credential in credentials:
56             if credential[0] == libvirt.VIR_CRED_AUTHNAME:
57                 credential[4] = (
58                     username
59                     if username
60                     else __salt__["config.get"](
61                         "virt:connection:auth:username", credential[3]
62                     )
63                 )
64             elif credential[0] == libvirt.VIR_CRED_NOECHOPROMPT:
65                 credential[4] = (
66                     password
67                     if password
68                     else __salt__["config.get"](
69                         "virt:connection:auth:password", credential[3]
70                     )
71                 )
72             else:
73                 log.info("Unhandled credential type: %s", credential[0])
74         return 0
75 def __get_conn(**kwargs):
76     username = kwargs.get("username", None)
77     password = kwargs.get("password", None)
78     conn_str = kwargs.get("connection", None)
79     if not conn_str:
80         conn_str = __salt__["config.get"]("virt:connection:uri", conn_str)
81     try:
82         auth_types = [
83             libvirt.VIR_CRED_AUTHNAME,
84             libvirt.VIR_CRED_NOECHOPROMPT,
85             libvirt.VIR_CRED_ECHOPROMPT,
86             libvirt.VIR_CRED_PASSPHRASE,
87             libvirt.VIR_CRED_EXTERNAL,
88         ]
89         conn = libvirt.openAuth(
90             conn_str, [auth_types, __get_request_auth(username, password), None], 0
91         )
92     except Exception:  # pylint: disable=broad-except
93         raise CommandExecutionError(
94             "Sorry, {} failed to open a connection to the hypervisor "
95             "software at {}".format(__grains__["fqdn"], conn_str)
96         )
97     return conn
98 def _get_domain(conn, *vms, **kwargs):
99     ret = list()
100     lookup_vms = list()
101     all_vms = []
102     if kwargs.get("active", True):
103         for id_ in conn.listDomainsID():
104             all_vms.append(conn.lookupByID(id_).name())
105     if kwargs.get("inactive", True):
106         for id_ in conn.listDefinedDomains():
107             all_vms.append(id_)
108     if vms and not all_vms:
109         raise CommandExecutionError("No virtual machines found.")
110     if vms:
111         for name in vms:
112             if name not in all_vms:
113                 raise CommandExecutionError(
114                     'The VM "{name}" is not present'.format(name=name)
115                 )
116             else:
117                 lookup_vms.append(name)
118     else:
119         lookup_vms = list(all_vms)
120     for name in lookup_vms:
121         ret.append(conn.lookupByName(name))
122     return len(ret) == 1 and not kwargs.get("iterable") and ret[0] or ret
123 def _parse_qemu_img_info(info):
124     raw_infos = salt.utils.json.loads(info)
125     disks = []
126     for disk_infos in raw_infos:
127         disk = {
128             "file": disk_infos["filename"],
129             "file format": disk_infos["format"],
130             "disk size": disk_infos["actual-size"],
131             "virtual size": disk_infos["virtual-size"],
132             "cluster size": disk_infos["cluster-size"]
133             if "cluster-size" in disk_infos
134             else None,
135         }
136         if "full-backing-filename" in disk_infos.keys():
137             disk["backing file"] = format(disk_infos["full-backing-filename"])
138         if "snapshots" in disk_infos.keys():
139             disk["snapshots"] = [
140                 {
141                     "id": snapshot["id"],
142                     "tag": snapshot["name"],
143                     "vmsize": snapshot["vm-state-size"],
144                     "date": datetime.datetime.fromtimestamp(
145                         float(
146                             "{}.{}".format(snapshot["date-sec"], snapshot["date-nsec"])
147                         )
148                     ).isoformat(),
149                     "vmclock": datetime.datetime.utcfromtimestamp(
150                         float(
151                             "{}.{}".format(
152                                 snapshot["vm-clock-sec"], snapshot["vm-clock-nsec"]
153                             )
154                         )
155                     )
156                     .time()
157                     .isoformat(),
158                 }
159                 for snapshot in disk_infos["snapshots"]
160             ]
161         disks.append(disk)
162     for disk in disks:
163         if "backing file" in disk.keys():
164             candidates = [
165                 info
166                 for info in disks
167                 if "file" in info.keys() and info["file"] == disk["backing file"]
168             ]
169             if candidates:
170                 disk["backing file"] = candidates[0]
171     return disks[0]
172 def _get_uuid(dom):
173     return ElementTree.fromstring(get_xml(dom)).find("uuid").text
174 def _get_on_poweroff(dom):
175     node = ElementTree.fromstring(get_xml(dom)).find("on_poweroff")
176     return node.text if node is not None else ""
177 def _get_on_reboot(dom):
178     node = ElementTree.fromstring(get_xml(dom)).find("on_reboot")
179     return node.text if node is not None else ""
180 def _get_on_crash(dom):
181     node = ElementTree.fromstring(get_xml(dom)).find("on_crash")
182     return node.text if node is not None else ""
183 def _get_nics(dom):
184     nics = {}
185     doc = ElementTree.fromstring(dom.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
186     for iface_node in doc.findall("devices/interface"):
187         nic = {}
188         nic["type"] = iface_node.get("type")
189         for v_node in iface_node:
190             if v_node.tag == "mac":
191                 nic["mac"] = v_node.get("address")
192             if v_node.tag == "model":
193                 nic["model"] = v_node.get("type")
194             if v_node.tag == "target":
195                 nic["target"] = v_node.get("dev")
196             if re.match("(driver|source|address)", v_node.tag):
197                 temp = {}
198                 for key, value in v_node.attrib.items():
199                     temp[key] = value
200                 nic[v_node.tag] = temp
201             if v_node.tag == "virtualport":
202                 temp = {}
203                 temp["type"] = v_node.get("type")
204                 for key, value in v_node.attrib.items():
205                     temp[key] = value
206                 nic["virtualport"] = temp
207         if "mac" not in nic:
208             continue
209         nics[nic["mac"]] = nic
210     return nics
211 def _get_graphics(dom):
212     out = {
213         "autoport": "None",
214         "keymap": "None",
215         "listen": "None",
216         "port": "None",
217         "type": "None",
218     }
219     doc = ElementTree.fromstring(dom.XMLDesc(0))
220     for g_node in doc.findall("devices/graphics"):
221         for key, value in g_node.attrib.items():
222             out[key] = value
223     return out
224 def _get_loader(dom):
225     out = {"path": "None"}
226     doc = ElementTree.fromstring(dom.XMLDesc(0))
227     for g_node in doc.findall("os/loader"):
228         out["path"] = g_node.text
229         for key, value in g_node.attrib.items():
230             out[key] = value
231     return out
232 def _get_disks(conn, dom):
233     disks = {}
234     doc = ElementTree.fromstring(dom.XMLDesc(0))
235     all_volumes = _get_all_volumes_paths(conn)
236     for elem in doc.findall("devices/disk"):
237         source = elem.find("source")
238         if source is None:
239             continue
240         target = elem.find("target")
241         driver = elem.find("driver")
242         if target is None:
243             continue
244         qemu_target = None
245         extra_properties = None
246         if "dev" in target.attrib:
247             disk_type = elem.get("type")
248             def _get_disk_volume_data(pool_name, volume_name):
249                 qemu_target = "{}/{}".format(pool_name, volume_name)
250                 pool = conn.storagePoolLookupByName(pool_name)
251                 extra_properties = {}
252                 try:
253                     vol = pool.storageVolLookupByName(volume_name)
254                     vol_info = vol.info()
255                     extra_properties = {
256                         "virtual size": vol_info[1],
257                         "disk size": vol_info[2],
258                     }
259                     backing_files = [
260                         {
261                             "file": node.find("source").get("file"),
262                             "file format": node.find("format").get("type"),
263                         }
264                         for node in elem.findall(".//backingStore[source]")
265                     ]
266                     if backing_files:
267                         extra_properties["backing file"] = backing_files[0]
268                         parent = extra_properties["backing file"]
269                         for sub_backing_file in backing_files[1:]:
270                             parent["backing file"] = sub_backing_file
271                             parent = sub_backing_file
272                     else:
273                         vol_desc = ElementTree.fromstring(vol.XMLDesc())
274                         backing_path = vol_desc.find("./backingStore/path")
275                         backing_format = vol_desc.find("./backingStore/format")
276                         if backing_path is not None:
277                             extra_properties["backing file"] = {
278                                 "file": backing_path.text
279                             }
280                             if backing_format is not None:
281                                 extra_properties["backing file"][
282                                     "file format"
283                                 ] = backing_format.get("type")
284                 except libvirt.libvirtError:
285                     log.info(
286                         "Couldn't extract all volume informations: pool is likely not"
287                         " running or refreshed"
288                     )
289                 return (qemu_target, extra_properties)
290             if disk_type == "file":
291                 qemu_target = source.get("file", "")
292                 if qemu_target.startswith("/dev/zvol/"):
293                     disks[target.get("dev")] = {"file": qemu_target, "zfs": True}
294                     continue
295                 if qemu_target in all_volumes.keys():
296                     volume = all_volumes[qemu_target]
297                     qemu_target, extra_properties = _get_disk_volume_data(
298                         volume["pool"], volume["name"]
299                     )
300                 elif elem.get("device", "disk") != "cdrom":
301                     try:
302                         process = subprocess.Popen(
303                             [
304                                 "qemu-img",
305                                 "info",
306                                 "-U",
307                                 "--output",
308                                 "json",
309                                 "--backing-chain",
310                                 qemu_target,
311                             ],
312                             shell=False,
313                             stdout=subprocess.PIPE,
314                             stderr=subprocess.PIPE,
315                         )
316                         stdout, stderr = process.communicate()
317                         if process.returncode == 0:
318                             qemu_output = salt.utils.stringutils.to_str(stdout)
319                             output = _parse_qemu_img_info(qemu_output)
320                             extra_properties = output
321                         else:
322                             extra_properties = {"error": stderr}
323                     except FileNotFoundError:
324                         extra_properties = {"error": "qemu-img not found"}
325             elif disk_type == "block":
326                 qemu_target = source.get("dev", "")
327                 if qemu_target in all_volumes.keys():
328                     volume = all_volumes[qemu_target]
329                     qemu_target, extra_properties = _get_disk_volume_data(
330                         volume["pool"], volume["name"]
331                     )
332             elif disk_type == "network":
333                 qemu_target = source.get("protocol")
334                 source_name = source.get("name")
335                 if source_name:
336                     qemu_target = "{}:{}".format(qemu_target, source_name)
337                 if source.get("protocol") in ["rbd", "gluster"]:
338                     for pool_i in conn.listAllStoragePools():
339                         pool_i_xml = ElementTree.fromstring(pool_i.XMLDesc())
340                         name_node = pool_i_xml.find("source/name")
341                         if name_node is not None and source_name.startswith(
342                             "{}/".format(name_node.text)
343                         ):
344                             qemu_target = "{}{}".format(
345                                 pool_i.name(), source_name[len(name_node.text) :]
346                             )
347                             break
348                 if elem.get("device", "disk") == "cdrom":
349                     host_node = source.find("host")
350                     if host_node is not None:
351                         hostname = host_node.get("name")
352                         port = host_node.get("port")
353                         qemu_target = urllib.parse.urlunparse(
354                             (
355                                 source.get("protocol"),
356                                 "{}:{}".format(hostname, port) if port else hostname,
357                                 source_name,
358                                 "",
359                                 saxutils.unescape(source.get("query", "")),
360                                 "",
361                             )
362                         )
363             elif disk_type == "volume":
364                 pool_name = source.get("pool")
365                 volume_name = source.get("volume")
366                 qemu_target, extra_properties = _get_disk_volume_data(
367                     pool_name, volume_name
368                 )
369             if not qemu_target:
370                 continue
371             disk = {
372                 "file": qemu_target,
373                 "type": elem.get("device"),
374             }
375             if driver is not None and "type" in driver.attrib:
376                 disk["file format"] = driver.get("type")
377             if extra_properties:
378                 disk.update(extra_properties)
379             disks[target.get("dev")] = disk
380     return disks
381 def _libvirt_creds():
382     g_cmd = ["grep", "^\\s*group", "/etc/libvirt/qemu.conf"]
383     u_cmd = ["grep", "^\\s*user", "/etc/libvirt/qemu.conf"]
384     try:
385         stdout = subprocess.Popen(g_cmd, stdout=subprocess.PIPE).communicate()[0]
386         group = salt.utils.stringutils.to_str(stdout).split('"')[1]
387     except IndexError:
388         group = "root"
389     try:
390         stdout = subprocess.Popen(u_cmd, stdout=subprocess.PIPE).communicate()[0]
391         user = salt.utils.stringutils.to_str(stdout).split('"')[1]
392     except IndexError:
393         user = "root"
394     return {"user": user, "group": group}
395 def _migrate(dom, dst_uri, **kwargs):
396     flags = 0
397     params = {}
398     migrated_state = libvirt.VIR_DOMAIN_RUNNING_MIGRATED
399     if kwargs.get("live", True):
400         flags |= libvirt.VIR_MIGRATE_LIVE
401     if kwargs.get("persistent", True):
402         flags |= libvirt.VIR_MIGRATE_PERSIST_DEST
403     if kwargs.get("undefinesource", True):
404         flags |= libvirt.VIR_MIGRATE_UNDEFINE_SOURCE
405     max_bandwidth = kwargs.get("max_bandwidth")
406     if max_bandwidth:
407         try:
408             bandwidth_value = int(max_bandwidth)
409         except ValueError:
410             raise SaltInvocationError(
411                 "Invalid max_bandwidth value: {}".format(max_bandwidth)
412             )
413         dom.migrateSetMaxSpeed(bandwidth_value)
414     max_downtime = kwargs.get("max_downtime")
415     if max_downtime:
416         try:
417             downtime_value = int(max_downtime)
418         except ValueError:
419             raise SaltInvocationError(
420                 "Invalid max_downtime value: {}".format(max_downtime)
421             )
422         dom.migrateSetMaxDowntime(downtime_value)
423     if kwargs.get("offline") is True:
424         flags |= libvirt.VIR_MIGRATE_OFFLINE
425         migrated_state = libvirt.VIR_DOMAIN_RUNNING_UNPAUSED
426     if kwargs.get("compressed") is True:
427         flags |= libvirt.VIR_MIGRATE_COMPRESSED
428     comp_methods = kwargs.get("comp_methods")
429     if comp_methods:
430         params[libvirt.VIR_MIGRATE_PARAM_COMPRESSION] = comp_methods.split(",")
431     comp_options = {
432         "comp_mt_level": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL,
433         "comp_mt_threads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS,
434         "comp_mt_dthreads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS,
435         "comp_xbzrle_cache": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE,
436     }
437     for (comp_option, param_key) in comp_options.items():
438         comp_option_value = kwargs.get(comp_option)
439         if comp_option_value:
440             try:
441                 params[param_key] = int(comp_option_value)
442             except ValueError:
443                 raise SaltInvocationError("Invalid {} value".format(comp_option))
444     parallel_connections = kwargs.get("parallel_connections")
445     if parallel_connections:
446         try:
447             params[libvirt.VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS] = int(
448                 parallel_connections
449             )
450         except ValueError:
451             raise SaltInvocationError("Invalid parallel_connections value")
452         flags |= libvirt.VIR_MIGRATE_PARALLEL
453     if __salt__["config.get"]("virt:tunnel"):
454         if parallel_connections:
455             raise SaltInvocationError(
456                 "Parallel migration isn't compatible with tunneled migration"
457             )
458         flags |= libvirt.VIR_MIGRATE_PEER2PEER
459         flags |= libvirt.VIR_MIGRATE_TUNNELLED
460     if kwargs.get("postcopy") is True:
461         flags |= libvirt.VIR_MIGRATE_POSTCOPY
462     postcopy_bandwidth = kwargs.get("postcopy_bandwidth")
463     if postcopy_bandwidth:
464         try:
465             postcopy_bandwidth_value = int(postcopy_bandwidth)
466         except ValueError:
467             raise SaltInvocationError("Invalid postcopy_bandwidth value")
468         dom.migrateSetMaxSpeed(
469             postcopy_bandwidth_value,
470             flags=libvirt.VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY,
471         )
472     copy_storage = kwargs.get("copy_storage")
473     if copy_storage:
474         if copy_storage == "all":
475             flags |= libvirt.VIR_MIGRATE_NON_SHARED_DISK
476         elif copy_storage in ["inc", "incremental"]:
477             flags |= libvirt.VIR_MIGRATE_NON_SHARED_INC
478         else:
479             raise SaltInvocationError("invalid copy_storage value")
480     try:
481         state = False
482         dst_conn = __get_conn(
483             connection=dst_uri,
484             username=kwargs.get("username"),
485             password=kwargs.get("password"),
486         )
487         new_dom = dom.migrate3(dconn=dst_conn, params=params, flags=flags)
488         if new_dom:
489             state = new_dom.state()
490         dst_conn.close()
491         return state and migrated_state in state
492     except libvirt.libvirtError as err:
493         dst_conn.close()
494         raise CommandExecutionError(err.get_error_message())
495 def _get_volume_path(pool, volume_name):
496     if volume_name in pool.listVolumes():
497         volume = pool.storageVolLookupByName(volume_name)
498         volume_xml = ElementTree.fromstring(volume.XMLDesc())
499         return volume_xml.find("./target/path").text
500     pool_xml = ElementTree.fromstring(pool.XMLDesc())
501     pool_path = pool_xml.find("./target/path").text
502     return pool_path + "/" + volume_name
503 def _disk_from_pool(conn, pool, pool_xml, volume_name):
504     pool_type = pool_xml.get("type")
505     disk_context = {}
506     if pool_type in ["dir", "netfs", "fs"]:
507         disk_context["type"] = "file"
508         disk_context["source_file"] = _get_volume_path(pool, volume_name)
509     elif pool_type in ["logical", "disk", "iscsi", "scsi"]:
510         disk_context["type"] = "block"
511         disk_context["format"] = "raw"
512         disk_context["source_file"] = _get_volume_path(pool, volume_name)
513     elif pool_type in ["rbd", "gluster", "sheepdog"]:
514         disk_context["type"] = "network"
515         disk_context["protocol"] = pool_type
516         disk_context["hosts"] = [
517             {"name": host.get("name"), "port": host.get("port")}
518             for host in pool_xml.findall(".//host")
519         ]
520         dir_node = pool_xml.find("./source/dir")
521         name_node = pool_xml.find("./source/name")
522         if name_node is not None:
523             disk_context["volume"] = "{}/{}".format(name_node.text, volume_name)
524         auth_node = pool_xml.find("./source/auth")
525         if auth_node is not None:
526             username = auth_node.get("username")
527             secret_node = auth_node.find("./secret")
528             usage = secret_node.get("usage")
529             if not usage:
530                 uuid = secret_node.get("uuid")
531                 usage = conn.secretLookupByUUIDString(uuid).usageID()
532             disk_context["auth"] = {
533                 "type": "ceph",
534                 "username": username,
535                 "usage": usage,
536             }
537     return disk_context
538 def _handle_unit(s, def_unit="m"):
539     m = re.match(r"(?P&lt;value&gt;[0-9.]*)\s*(?P&lt;unit&gt;.*)$", str(s).strip())
540     value = m.group("value")
541     unit = m.group("unit").lower() or def_unit
542     try:
543         value = int(value)
544     except ValueError:
545         try:
546             value = float(value)
547         except ValueError:
548             raise SaltInvocationError("invalid number")
549     dec = False
550     if re.match(r"[kmgtpezy]b$", unit):
551         dec = True
552     elif not re.match(r"(b|[kmgtpezy](ib)?)$", unit):
553         raise SaltInvocationError("invalid units")
554     p = "bkmgtpezy".index(unit[0])
555     value *= 10 ** (p * 3) if dec else 2 ** (p * 10)
556     return int(value)
557 def nesthash(value=None):
558     return collections.defaultdict(nesthash, value or {})
559 def _gen_xml(
560     conn,
561     name,
562     cpu,
563     mem,
564     diskp,
565     nicp,
566     hypervisor,
567     os_type,
568     arch,
569     graphics=None,
570     boot=None,
571     boot_dev=None,
572     numatune=None,
573     hypervisor_features=None,
574     clock=None,
575     serials=None,
576     consoles=None,
577     stop_on_reboot=False,
578     host_devices=None,
579     **kwargs
580 ):
581     context = {
582         "hypervisor": hypervisor,
583         "name": name,
584         "hypervisor_features": hypervisor_features or {},
585         "clock": clock or {},
586         "on_reboot": "destroy" if stop_on_reboot else "restart",
587     }
588     context["to_kib"] = lambda v: int(_handle_unit(v) / 1024)
589     context["yesno"] = lambda v: "yes" if v else "no"
590     context["mem"] = nesthash()
591     if isinstance(mem, int):
592         context["mem"]["boot"] = mem
593         context["mem"]["current"] = mem
594     elif isinstance(mem, dict):
595         context["mem"] = nesthash(mem)
596     context["cpu"] = nesthash()
597     context["cputune"] = nesthash()
598     if isinstance(cpu, int):
599         context["cpu"]["maximum"] = str(cpu)
600     elif isinstance(cpu, dict):
601         context["cpu"] = nesthash(cpu)
602     if clock:
603         offset = "utc" if clock.get("utc", True) else "localtime"
604         if "timezone" in clock:
605             offset = "timezone"
606         context["clock"]["offset"] = offset
607     if hypervisor in ["qemu", "kvm"]:
608         context["numatune"] = numatune if numatune else {}
609         context["controller_model"] = False
610     elif hypervisor == "vmware":
611         context["controller_model"] = "lsilogic"
612     if graphics:
613         if "listen" not in graphics:
614             graphics["listen"] = {"type": "address", "address": "0.0.0.0"}
615         elif (
616             "address" not in graphics["listen"]
617             and graphics["listen"]["type"] == "address"
618         ):
619             graphics["listen"]["address"] = "0.0.0.0"
620         if graphics.get("type", "none") == "none":
621             graphics = None
622     context["graphics"] = graphics
623     context["boot_dev"] = boot_dev.split() if boot_dev is not None else ["hd"]
624     context["boot"] = boot if boot else {}
625     efi_value = context["boot"].get("efi", None) if boot else None
626     if efi_value is True:
627         context["boot"]["os_attrib"] = "firmware='efi'"
628     elif efi_value is not None and type(efi_value) != bool:
629         raise SaltInvocationError("Invalid efi value")
630     if os_type == "xen":
631         if __grains__["os_family"] == "Suse":
632             if not boot or not boot.get("kernel", None):
633                 paths = [
634                     path
635                     for path in ["/usr/share", "/usr/lib"]
636                     if os.path.exists(path + "/grub2/x86_64-xen/grub.xen")
637                 ]
638                 if not paths:
639                     raise CommandExecutionError("grub-x86_64-xen needs to be installed")
640                 context["boot"]["kernel"] = paths[0] + "/grub2/x86_64-xen/grub.xen"
641                 context["boot_dev"] = []
642     default_port = 23023
643     default_chardev_type = "tcp"
644     chardev_types = ["serial", "console"]
645     for chardev_type in chardev_types:
646         context[chardev_type + "s"] = []
647         parameter_value = locals()[chardev_type + "s"]
648         if parameter_value is not None:
649             for chardev in parameter_value:
650                 chardev_context = chardev
651                 chardev_context["type"] = chardev.get("type", default_chardev_type)
652                 if chardev_context["type"] == "tcp":
653                     chardev_context["port"] = chardev.get("port", default_port)
654                     chardev_context["protocol"] = chardev.get("protocol", "telnet")
655                 context[chardev_type + "s"].append(chardev_context)
656     context["disks"] = []
657     disk_bus_map = {"virtio": "vd", "xen": "xvd", "fdc": "fd", "ide": "hd"}
658     targets = []
659     for i, disk in enumerate(diskp):
660         prefix = disk_bus_map.get(disk["model"], "sd")
661         disk_context = {
662             "device": disk.get("device", "disk"),
663             "target_dev": _get_disk_target(targets, len(diskp), prefix),
664             "disk_bus": disk["model"],
665             "format": disk.get("format", "raw"),
666             "index": str(i),
667             "io": disk.get("io", "native"),
668             "iothread": disk.get("iothread_id", None),
669         }
670         targets.append(disk_context["target_dev"])
671         if disk.get("source_file"):
672             url = urllib.parse.urlparse(disk["source_file"])
673             if not url.scheme or not url.hostname:
674                 disk_context["source_file"] = disk["source_file"]
675                 disk_context["type"] = "file"
676             elif url.scheme in ["http", "https", "ftp", "ftps", "tftp"]:
677                 disk_context["type"] = "network"
678                 disk_context["protocol"] = url.scheme
679                 disk_context["volume"] = url.path
680                 disk_context["query"] = saxutils.escape(url.query)
681                 disk_context["hosts"] = [{"name": url.hostname, "port": url.port}]
682         elif disk.get("pool"):
683             disk_context["volume"] = disk["filename"]
684             pool = conn.storagePoolLookupByName(disk["pool"])
685             pool_xml = ElementTree.fromstring(pool.XMLDesc())
686             pool_type = pool_xml.get("type")
687             if hypervisor == "xen" or pool_type in ["rbd", "gluster", "sheepdog"]:
688                 disk_context.update(
689                     _disk_from_pool(conn, pool, pool_xml, disk_context["volume"])
690                 )
691             else:
692                 if pool_type in ["disk", "logical"]:
693                     disk_context["format"] = "raw"
694                 disk_context["type"] = "volume"
695                 disk_context["pool"] = disk["pool"]
696         else:
697             disk_context["type"] = "file"
698         if hypervisor in ["qemu", "kvm", "bhyve", "xen"]:
699             disk_context["address"] = False
700             disk_context["driver"] = True
701         elif hypervisor in ["esxi", "vmware"]:
702             disk_context["address"] = True
703             disk_context["driver"] = False
704         context["disks"].append(disk_context)
705     context["nics"] = nicp
706     hostdev_context = []
707     try:
708         for hostdev_name in host_devices or []:
709             hostdevice = conn.nodeDeviceLookupByName(hostdev_name)
710             doc = ElementTree.fromstring(hostdevice.XMLDesc())
711             if "pci" in hostdevice.listCaps():
712                 hostdev_context.append(
713                     {
714                         "type": "pci",
715                         "domain": "0x{:04x}".format(
716                             int(doc.find("./capability[@type='pci']/domain").text)
717                         ),
718                         "bus": "0x{:02x}".format(
719                             int(doc.find("./capability[@type='pci']/bus").text)
720                         ),
721                         "slot": "0x{:02x}".format(
722                             int(doc.find("./capability[@type='pci']/slot").text)
723                         ),
724                         "function": "0x{}".format(
725                             doc.find("./capability[@type='pci']/function").text
726                         ),
727                     }
728                 )
729             elif "usb_device" in hostdevice.listCaps():
730                 vendor_id = doc.find(".//vendor").get("id")
731                 product_id = doc.find(".//product").get("id")
732                 hostdev_context.append(
733                     {"type": "usb", "vendor": vendor_id, "product": product_id}
734                 )
735     except libvirt.libvirtError as err:
736         conn.close()
737         raise CommandExecutionError(
738             "Failed to get host devices: " + err.get_error_message()
739         )
740     context["hostdevs"] = hostdev_context
741     context["os_type"] = os_type
742     context["arch"] = arch
743     fn_ = "libvirt_domain.jinja"
744     try:
745         template = JINJA.get_template(fn_)
746     except jinja2.exceptions.TemplateNotFound:
747         log.error("Could not load template %s", fn_)
748         return ""
749     return template.render(**context)
750 def _gen_vol_xml(
751     name,
752     size,
753     format=None,
754     allocation=0,
755     type=None,
756     permissions=None,
757     backing_store=None,
758     nocow=False,
759 ):
760     size = int(size) * 1024  # MB
761     context = {
762         "type": type,
763         "name": name,
764         "target": {"permissions": permissions, "nocow": nocow},
765         "format": format,
766         "size": str(size),
767         "allocation": str(int(allocation) * 1024),
768         "backingStore": backing_store,
769     }
770     fn_ = "libvirt_volume.jinja"
771     try:
772         template = JINJA.get_template(fn_)
773     except jinja2.exceptions.TemplateNotFound:
774         log.error("Could not load template %s", fn_)
775         return ""
776     return template.render(**context)
777 def _gen_net_xml(
778     name,
779     bridge,
780     forward,
781     vport,
782     tag=None,
783     ip_configs=None,
784     mtu=None,
785     domain=None,
786     nat=None,
787     interfaces=None,
788     addresses=None,
789     physical_function=None,
790     dns=None,
791 ):
792     if isinstance(vport, str):
793         vport_context = {"type": vport}
794     else:
795         vport_context = vport
796     if isinstance(tag, (str, int)):
797         tag_context = {"tags": [{"id": tag}]}
798     else:
799         tag_context = tag
800     addresses_context = []
801     if addresses:
802         matches = [
803             re.fullmatch(r"([0-9]+):([0-9A-Fa-f]+):([0-9A-Fa-f]+)\.([0-9])", addr)
804             for addr in addresses.lower().split(" ")
805         ]
806         addresses_context = [
807             {
808                 "domain": m.group(1),
809                 "bus": m.group(2),
810                 "slot": m.group(3),
811                 "function": m.group(4),
812             }
813             for m in matches
814             if m
815         ]
816     context = {
817         "name": name,
818         "bridge": bridge,
819         "mtu": mtu,
820         "domain": domain,
821         "forward": forward,
822         "nat": nat,
823         "interfaces": interfaces.split(" ") if interfaces else [],
824         "addresses": addresses_context,
825         "pf": physical_function,
826         "vport": vport_context,
827         "vlan": tag_context,
828         "dns": dns,
829         "ip_configs": [
830             {
831                 "address": ipaddress.ip_network(config["cidr"]),
832                 "dhcp_ranges": config.get("dhcp_ranges", []),
833                 "hosts": config.get("hosts", {}),
834                 "bootp": config.get("bootp", {}),
835                 "tftp": config.get("tftp"),
836             }
837             for config in ip_configs or []
838         ],
839         "yesno": lambda v: "yes" if v else "no",
840     }
841     fn_ = "libvirt_network.jinja"
842     try:
843         template = JINJA.get_template(fn_)
844     except jinja2.exceptions.TemplateNotFound:
845         log.error("Could not load template %s", fn_)
846         return ""
847     return template.render(**context)
848 def _gen_pool_xml(
849     name,
850     ptype,
851     target=None,
852     permissions=None,
853     source_devices=None,
854     source_dir=None,
855     source_adapter=None,
856     source_hosts=None,
857     source_auth=None,
858     source_name=None,
859     source_format=None,
860     source_initiator=None,
861 ):
862     hosts = [host.split(":") for host in source_hosts or []]
863     source = None
864     if any(
865         [
866             source_devices,
867             source_dir,
868             source_adapter,
869             hosts,
870             source_auth,
871             source_name,
872             source_format,
873             source_initiator,
874         ]
875     ):
876         source = {
877             "devices": source_devices or [],
878             "dir": source_dir
879             if source_format != "cifs" or not source_dir
880             else source_dir.lstrip("/"),
881             "adapter": source_adapter,
882             "hosts": [
883                 {"name": host[0], "port": host[1] if len(host) &gt; 1 else None}
884                 for host in hosts
885             ],
886             "auth": source_auth,
887             "name": source_name,
888             "format": source_format,
889             "initiator": source_initiator,
890         }
891     context = {
892         "name": name,
893         "ptype": ptype,
894         "target": {"path": target, "permissions": permissions},
895         "source": source,
896     }
897     fn_ = "libvirt_pool.jinja"
898     try:
899         template = JINJA.get_template(fn_)
900     except jinja2.exceptions.TemplateNotFound:
901         log.error("Could not load template %s", fn_)
902         return ""
903     return template.render(**context)
904 def _gen_secret_xml(auth_type, usage, description):
905     context = {
906         "type": auth_type,
907         "usage": usage,
908         "description": description,
909     }
910     fn_ = "libvirt_secret.jinja"
911     try:
912         template = JINJA.get_template(fn_)
913     except jinja2.exceptions.TemplateNotFound:
914         log.error("Could not load template %s", fn_)
915         return ""
916     return template.render(**context)
917 def _get_images_dir():
918     img_dir = __salt__["config.get"]("virt:images")
919     log.debug("Image directory from config option `virt:images` is %s", img_dir)
920     return img_dir
921 def _zfs_image_create(
922     vm_name,
923     pool,
924     disk_name,
925     hostname_property_name,
926     sparse_volume,
927     disk_size,
928     disk_image_name,
929 ):
930     if not disk_image_name and not disk_size:
931         raise CommandExecutionError(
932             "Unable to create new disk {}, please specify"
933             " the disk image name or disk size argument".format(disk_name)
934         )
935     if not pool:
936         raise CommandExecutionError(
937             "Unable to create new disk {}, please specify the disk pool name".format(
938                 disk_name
939             )
940         )
941     destination_fs = os.path.join(pool, "{}.{}".format(vm_name, disk_name))
942     log.debug("Image destination will be %s", destination_fs)
943     existing_disk = __salt__["zfs.list"](name=pool)
944     if "error" in existing_disk:
945         raise CommandExecutionError(
946             "Unable to create new disk {}. {}".format(
947                 destination_fs, existing_disk["error"]
948             )
949         )
950     elif destination_fs in existing_disk:
951         log.info("ZFS filesystem %s already exists. Skipping creation", destination_fs)
952         blockdevice_path = os.path.join("/dev/zvol", pool, vm_name)
953         return blockdevice_path
954     properties = {}
955     if hostname_property_name:
956         properties[hostname_property_name] = vm_name
957     if disk_image_name:
958         __salt__["zfs.clone"](
959             name_a=disk_image_name, name_b=destination_fs, properties=properties
960         )
961     elif disk_size:
962         __salt__["zfs.create"](
963             name=destination_fs,
964             properties=properties,
965             volume_size=disk_size,
966             sparse=sparse_volume,
967         )
968     blockdevice_path = os.path.join(
969         "/dev/zvol", pool, "{}.{}".format(vm_name, disk_name)
970     )
971     log.debug("Image path will be %s", blockdevice_path)
972     return blockdevice_path
973 def _qemu_image_create(disk, create_overlay=False, saltenv="base"):
974     disk_size = disk.get("size", None)
975     disk_image = disk.get("image", None)
976     if not disk_size and not disk_image:
977         raise CommandExecutionError(
978             "Unable to create new disk {}, please specify"
979             " disk size and/or disk image argument".format(disk["filename"])
980         )
981     img_dest = disk["source_file"]
982     log.debug("Image destination will be %s", img_dest)
983     img_dir = os.path.dirname(img_dest)
984     log.debug("Image destination directory is %s", img_dir)
985     if not os.path.exists(img_dir):
986         os.makedirs(img_dir)
987     if disk_image:
988         log.debug("Create disk from specified image %s", disk_image)
989         sfn = __salt__["cp.cache_file"](disk_image, saltenv)
990         qcow2 = False
991         if salt.utils.path.which("qemu-img"):
992             res = __salt__["cmd.run"]('qemu-img info "{}"'.format(sfn))
993             imageinfo = salt.utils.yaml.safe_load(res)
994             qcow2 = imageinfo["file format"] == "qcow2"
995         try:
996             if create_overlay and qcow2:
997                 log.info("Cloning qcow2 image %s using copy on write", sfn)
998                 __salt__["cmd.run"](
999                     'qemu-img create -f qcow2 -o backing_file="{}" "{}"'.format(
1000                         sfn, img_dest
1001                     ).split()
1002                 )
1003             else:
1004                 log.debug("Copying %s to %s", sfn, img_dest)
1005                 salt.utils.files.copyfile(sfn, img_dest)
1006             mask = salt.utils.files.get_umask()
1007             if disk_size and qcow2:
1008                 log.debug("Resize qcow2 image to %sM", disk_size)
1009                 __salt__["cmd.run"](
1010                     'qemu-img resize "{}" {}M'.format(img_dest, disk_size)
1011                 )
1012             log.debug("Apply umask and remove exec bit")
1013             mode = (0o0777 ^ mask) &amp; 0o0666
1014             os.chmod(img_dest, mode)
1015         except OSError as err:
1016             raise CommandExecutionError(
1017                 "Problem while copying image. {} - {}".format(disk_image, err)
1018             )
1019     else:
1020         try:
1021             mask = salt.utils.files.get_umask()
1022             if disk_size:
1023                 log.debug("Create empty image with size %sM", disk_size)
1024                 __salt__["cmd.run"](
1025                     'qemu-img create -f {} "{}" {}M'.format(
1026                         disk.get("format", "qcow2"), img_dest, disk_size
1027                     )
1028                 )
1029             else:
1030                 raise CommandExecutionError(
1031                     "Unable to create new disk {},"
1032                     " please specify &lt;size&gt; argument".format(img_dest)
1033                 )
1034             log.debug("Apply umask and remove exec bit")
1035             mode = (0o0777 ^ mask) &amp; 0o0666
1036             os.chmod(img_dest, mode)
1037         except OSError as err:
1038             raise CommandExecutionError(
1039                 "Problem while creating volume {} - {}".format(img_dest, err)
1040             )
1041     return img_dest
1042 def _seed_image(seed_cmd, img_path, name, config, install, pub_key, priv_key):
1043     log.debug("Seeding image")
1044     __salt__[seed_cmd](
1045         img_path,
1046         id_=name,
1047         config=config,
1048         install=install,
1049         pub_key=pub_key,
1050         priv_key=priv_key,
1051     )
1052 def _disk_volume_create(conn, disk, seeder=None, saltenv="base"):
1053     if disk.get("overlay_image"):
1054         raise SaltInvocationError(
1055             "Disk overlay_image property is not supported when creating volumes,"
1056             "use backing_store_path and backing_store_format instead."
1057         )
1058     pool = conn.storagePoolLookupByName(disk["pool"])
1059     if disk["filename"] in pool.listVolumes():
1060         return
1061     pool_type = ElementTree.fromstring(pool.XMLDesc()).get("type")
1062     backing_path = disk.get("backing_store_path")
1063     backing_format = disk.get("backing_store_format")
1064     backing_store = None
1065     if (
1066         backing_path
1067         and backing_format
1068         and (disk.get("format") == "qcow2" or pool_type == "logical")
1069     ):
1070         backing_store = {"path": backing_path, "format": backing_format}
1071     if backing_store and disk.get("image"):
1072         raise SaltInvocationError(
1073             "Using a template image with a backing store is not possible, "
1074             "choose either of them."
1075         )
1076     vol_xml = _gen_vol_xml(
1077         disk["filename"],
1078         disk.get("size", 0),
1079         format=disk.get("format"),
1080         backing_store=backing_store,
1081     )
1082     _define_vol_xml_str(conn, vol_xml, disk.get("pool"))
1083     if disk.get("image"):
1084         log.debug("Caching disk template image: %s", disk.get("image"))
1085         cached_path = __salt__["cp.cache_file"](disk.get("image"), saltenv)
1086         if seeder:
1087             seeder(cached_path)
1088         _volume_upload(
1089             conn,
1090             disk["pool"],
1091             disk["filename"],
1092             cached_path,
1093             sparse=disk.get("format") == "qcow2",
1094         )
1095 def _disk_profile(conn, profile, hypervisor, disks, vm_name):
1096     default = [{"system": {"size": 8192}}]
1097     if hypervisor == "vmware":
1098         overlay = {"format": "vmdk", "model": "scsi", "device": "disk"}
1099     elif hypervisor in ["qemu", "kvm"]:
1100         overlay = {"device": "disk", "model": "virtio"}
1101     elif hypervisor == "xen":
1102         overlay = {"device": "disk", "model": "xen"}
1103     elif hypervisor == "bhyve":
1104         overlay = {"format": "raw", "model": "virtio", "sparse_volume": False}
1105     else:
1106         overlay = {}
1107     disklist = []
1108     if profile:
1109         disklist = copy.deepcopy(
1110             __salt__["config.get"]("virt:disk", {}).get(profile, default)
1111         )
1112         disklist = [dict(d, name=name) for disk in disklist for name, d in disk.items()]
1113     if disks:
1114         for udisk in disks:
1115             if "name" in udisk:
1116                 found = [disk for disk in disklist if udisk["name"] == disk["name"]]
1117                 if found:
1118                     found[0].update(udisk)
1119                 else:
1120                     disklist.append(udisk)
1121     pool_caps = _pool_capabilities(conn)
1122     for disk in disklist:
1123         if disk.get("device", "disk") == "cdrom" and "model" not in disk:
1124             disk["model"] = "ide"
1125         for key, val in overlay.items():
1126             if key not in disk:
1127                 disk[key] = val
1128         if disk.get("source_file") and os.path.exists(disk["source_file"]):
1129             disk["filename"] = os.path.basename(disk["source_file"])
1130             if not disk.get("format"):
1131                 disk["format"] = (
1132                     "qcow2" if disk.get("device", "disk") != "cdrom" else "raw"
1133                 )
1134         elif vm_name and disk.get("device", "disk") == "disk":
1135             _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps)
1136     return disklist
1137 def _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps):
1138     disk["filename"] = "{}_{}".format(vm_name, disk["name"])
1139     base_dir = disk.get("pool", None)
1140     if hypervisor in ["qemu", "kvm", "xen"]:
1141         if not base_dir:
1142             base_dir = _get_images_dir()
1143         if base_dir not in conn.listStoragePools():
1144             if not disk.get("format"):
1145                 disk["format"] = "qcow2"
1146             disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1147             disk["source_file"] = os.path.join(base_dir, disk["filename"])
1148         else:
1149             if "pool" not in disk:
1150                 disk["pool"] = base_dir
1151             pool_obj = conn.storagePoolLookupByName(base_dir)
1152             pool_xml = ElementTree.fromstring(pool_obj.XMLDesc())
1153             pool_type = pool_xml.get("type")
1154             if pool_type == "disk":
1155                 device = pool_xml.find("./source/device").get("path")
1156                 all_volumes = pool_obj.listVolumes()
1157                 if disk.get("source_file") not in all_volumes:
1158                     indexes = [
1159                         int(re.sub("[a-z]+", "", vol_name)) for vol_name in all_volumes
1160                     ] or [0]
1161                     index = min(
1162                         idx for idx in range(1, max(indexes) + 2) if idx not in indexes
1163                     )
1164                     disk["filename"] = "{}{}".format(os.path.basename(device), index)
1165             if disk.get("source_file"):
1166                 if not disk.get("source_file") in pool_obj.listVolumes():
1167                     raise SaltInvocationError(
1168                         "{} volume doesn't exist in pool {}".format(
1169                             disk.get("source_file"), base_dir
1170                         )
1171                     )
1172                 disk["filename"] = disk["source_file"]
1173                 del disk["source_file"]
1174             if not disk.get("format"):
1175                 volume_options = (
1176                     [
1177                         type_caps.get("options", {}).get("volume", {})
1178                         for type_caps in pool_caps.get("pool_types")
1179                         if type_caps["name"] == pool_type
1180                     ]
1181                     or [{}]
1182                 )[0]
1183                 if "qcow2" in volume_options.get("targetFormatType", []):
1184                     disk["format"] = "qcow2"
1185                 else:
1186                     disk["format"] = volume_options.get("default_format", None)
1187     elif hypervisor == "bhyve" and vm_name:
1188         disk["filename"] = "{}.{}".format(vm_name, disk["name"])
1189         disk["source_file"] = os.path.join(
1190             "/dev/zvol", base_dir or "", disk["filename"]
1191         )
1192     elif hypervisor in ["esxi", "vmware"]:
1193         if not base_dir:
1194             base_dir = __salt__["config.get"]("virt:storagepool", "[0] ")
1195         disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1196         disk["source_file"] = "{}{}".format(base_dir, disk["filename"])
1197 def _complete_nics(interfaces, hypervisor):
1198     vmware_overlay = {"type": "bridge", "source": "DEFAULT", "model": "e1000"}
1199     kvm_overlay = {"type": "bridge", "source": "br0", "model": "virtio"}
1200     xen_overlay = {"type": "bridge", "source": "br0", "model": None}
1201     bhyve_overlay = {"type": "bridge", "source": "bridge0", "model": "virtio"}
1202     overlays = {
1203         "xen": xen_overlay,
1204         "kvm": kvm_overlay,
1205         "qemu": kvm_overlay,
1206         "vmware": vmware_overlay,
1207         "bhyve": bhyve_overlay,
1208     }
1209     def _normalize_net_types(attributes):
1210         for type_ in ["bridge", "network"]:
1211             if type_ in attributes:
1212                 attributes["type"] = type_
1213                 attributes["source"] = attributes.pop(type_)
1214         attributes["type"] = attributes.get("type", None)
1215         attributes["source"] = attributes.get("source", None)
1216     def _apply_default_overlay(attributes):
1217         for key, value in overlays[hypervisor].items():
1218             if key not in attributes or not attributes[key]:
1219                 attributes[key] = value
1220     for interface in interfaces:
1221         _normalize_net_types(interface)
1222         if hypervisor in overlays:
1223             _apply_default_overlay(interface)
1224     return interfaces
1225 def _nic_profile(profile_name, hypervisor):
1226     config_data = __salt__["config.get"]("virt:nic", {}).get(
1227         profile_name, [{"eth0": {}}]
1228     )
1229     interfaces = []
1230     def append_dict_profile_to_interface_list(profile_dict):
1231         for interface_name, attributes in profile_dict.items():
1232             attributes["name"] = interface_name
1233             interfaces.append(attributes)
1234     if isinstance(config_data, dict):
1235         append_dict_profile_to_interface_list(config_data)
1236     elif isinstance(config_data, list):
1237         for interface in config_data:
1238             if isinstance(interface, dict):
1239                 if len(interface) == 1:
1240                     append_dict_profile_to_interface_list(interface)
1241                 else:
1242                     interfaces.append(interface)
1243     return _complete_nics(interfaces, hypervisor)
1244 def _get_merged_nics(hypervisor, profile, interfaces=None):
1245     nicp = _nic_profile(profile, hypervisor) if profile else []
1246     log.debug("NIC profile is %s", nicp)
1247     if interfaces:
1248         users_nics = _complete_nics(interfaces, hypervisor)
1249         for unic in users_nics:
1250             found = [nic for nic in nicp if nic["name"] == unic["name"]]
1251             if found:
1252                 found[0].update(unic)
1253             else:
1254                 nicp.append(unic)
1255         log.debug("Merged NICs: %s", nicp)
1256     return nicp
1257 def _handle_remote_boot_params(orig_boot):
1258     saltinst_dir = None
1259     new_boot = orig_boot.copy()
1260     keys = orig_boot.keys()
1261     cases = [
1262         {"efi"},
1263         {"kernel", "initrd", "efi"},
1264         {"kernel", "initrd", "cmdline", "efi"},
1265         {"loader", "nvram"},
1266         {"kernel", "initrd"},
1267         {"kernel", "initrd", "cmdline"},
1268         {"kernel", "initrd", "loader", "nvram"},
1269         {"kernel", "initrd", "cmdline", "loader", "nvram"},
1270     ]
1271     if keys in cases:
1272         for key in keys:
1273             if key == "efi" and type(orig_boot.get(key)) == bool:
1274                 new_boot[key] = orig_boot.get(key)
1275             elif orig_boot.get(key) is not None and salt.utils.virt.check_remote(
1276                 orig_boot.get(key)
1277             ):
1278                 if saltinst_dir is None:
1279                     os.makedirs(CACHE_DIR)
1280                     saltinst_dir = CACHE_DIR
1281                 new_boot[key] = salt.utils.virt.download_remote(
1282                     orig_boot.get(key), saltinst_dir
1283                 )
1284         return new_boot
1285     else:
1286         raise SaltInvocationError(
1287             "Invalid boot parameters,It has to follow this combination: [(kernel,"
1288             " initrd) or/and cmdline] or/and [(loader, nvram) or efi]"
1289         )
1290 def _handle_efi_param(boot, desc):
1291     efi_value = boot.get("efi", None) if boot else None
1292     parent_tag = desc.find("os")
1293     os_attrib = parent_tag.attrib
1294     if efi_value is False and os_attrib != {}:
1295         parent_tag.attrib.pop("firmware", None)
1296         return True
1297     elif type(efi_value) == bool and os_attrib == {}:
1298         if efi_value is True and parent_tag.find("loader") is None:
1299             parent_tag.set("firmware", "efi")
1300             return True
1301         if efi_value is False and parent_tag.find("loader") is not None:
1302             parent_tag.remove(parent_tag.find("loader"))
1303             parent_tag.remove(parent_tag.find("nvram"))
1304             return True
1305     elif type(efi_value) != bool:
1306         raise SaltInvocationError("Invalid efi value")
1307     return False
1308 def init(
1309     name,
1310     cpu,
1311     mem,
1312     nic="default",
1313     interfaces=None,
1314     hypervisor=None,
1315     start=True,  # pylint: disable=redefined-outer-name
1316     disk="default",
1317     disks=None,
1318     saltenv="base",
1319     seed=True,
1320     install=True,
1321     pub_key=None,
1322     priv_key=None,
1323     seed_cmd="seed.apply",
1324     graphics=None,
1325     os_type=None,
1326     arch=None,
1327     boot=None,
1328     boot_dev=None,
1329     numatune=None,
1330     hypervisor_features=None,
1331     clock=None,
1332     serials=None,
1333     consoles=None,
1334     stop_on_reboot=False,
1335     host_devices=None,
1336     **kwargs
1337 ):
1338     try:
1339         conn = __get_conn(**kwargs)
1340         caps = _capabilities(conn)
1341         os_types = sorted({guest["os_type"] for guest in caps["guests"]})
1342         arches = sorted({guest["arch"]["name"] for guest in caps["guests"]})
1343         virt_hypervisor = hypervisor
1344         if not virt_hypervisor:
1345             hypervisors = sorted(
1346                 {
1347                     x
1348                     for y in [
1349                         guest["arch"]["domains"].keys() for guest in caps["guests"]
1350                     ]
1351                     for x in y
1352                 }
1353             )
1354             if len(hypervisors) == 0:
1355                 raise SaltInvocationError("No supported hypervisors were found")
1356             virt_hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
1357         virt_hypervisor = "vmware" if virt_hypervisor == "esxi" else virt_hypervisor
1358         log.debug("Using hypervisor %s", virt_hypervisor)
1359         nicp = _get_merged_nics(virt_hypervisor, nic, interfaces)
1360         diskp = _disk_profile(conn, disk, virt_hypervisor, disks, name)
1361         for _disk in diskp:
1362             if _disk.get("device", "disk") == "cdrom":
1363                 continue
1364             log.debug("Creating disk for VM [ %s ]: %s", name, _disk)
1365             if virt_hypervisor == "vmware":
1366                 if "image" in _disk:
1367                     raise SaltInvocationError(
1368                         "virt.init does not support image "
1369                         "template in conjunction with esxi hypervisor"
1370                     )
1371                 else:
1372                     log.debug("Generating libvirt XML for %s", _disk)
1373                     volume_name = "{}/{}".format(name, _disk["name"])
1374                     filename = "{}.{}".format(volume_name, _disk["format"])
1375                     vol_xml = _gen_vol_xml(
1376                         filename, _disk["size"], format=_disk["format"]
1377                     )
1378                     _define_vol_xml_str(conn, vol_xml, pool=_disk.get("pool"))
1379             elif virt_hypervisor in ["qemu", "kvm", "xen"]:
1380                 def seeder(path):
1381                     _seed_image(
1382                         seed_cmd,
1383                         path,
1384                         name,
1385                         kwargs.get("config"),
1386                         install,
1387                         pub_key,
1388                         priv_key,
1389                     )
1390                 create_overlay = _disk.get("overlay_image", False)
1391                 format = _disk.get("format")
1392                 if _disk.get("source_file"):
1393                     if os.path.exists(_disk["source_file"]):
1394                         img_dest = _disk["source_file"]
1395                     else:
1396                         img_dest = _qemu_image_create(_disk, create_overlay, saltenv)
1397                 else:
1398                     _disk_volume_create(conn, _disk, seeder if seed else None, saltenv)
1399                     img_dest = None
1400                 if seed and img_dest and _disk.get("image", None):
1401                     seeder(img_dest)
1402             elif hypervisor in ["bhyve"]:
1403                 img_dest = _zfs_image_create(
1404                     vm_name=name,
1405                     pool=_disk.get("pool"),
1406                     disk_name=_disk.get("name"),
1407                     disk_size=_disk.get("size"),
1408                     disk_image_name=_disk.get("image"),
1409                     hostname_property_name=_disk.get("hostname_property"),
1410                     sparse_volume=_disk.get("sparse_volume"),
1411                 )
1412             else:
1413                 raise SaltInvocationError(
1414                     "Unsupported hypervisor when handling disk image: {}".format(
1415                         virt_hypervisor
1416                     )
1417                 )
1418         log.debug("Generating VM XML")
1419         if os_type is None:
1420             os_type = "hvm" if "hvm" in os_types else os_types[0]
1421         if arch is None:
1422             arch = "x86_64" if "x86_64" in arches else arches[0]
1423         if boot is not None:
1424             boot = _handle_remote_boot_params(boot)
1425         vm_xml = _gen_xml(
1426             conn,
1427             name,
1428             cpu,
1429             mem,
1430             diskp,
1431             nicp,
1432             virt_hypervisor,
1433             os_type,
1434             arch,
1435             graphics,
1436             boot,
1437             boot_dev,
1438             numatune,
1439             hypervisor_features,
1440             clock,
1441             serials,
1442             consoles,
1443             stop_on_reboot,
1444             host_devices,
1445             **kwargs
1446         )
1447         log.debug("New virtual machine definition: %s", vm_xml)
1448         conn.defineXML(vm_xml)
1449     except libvirt.libvirtError as err:
1450         conn.close()
1451         raise CommandExecutionError(err.get_error_message())
1452     if start:
1453         log.debug("Starting VM %s", name)
1454         _get_domain(conn, name).create()
1455     conn.close()
1456     return True
1457 def _disks_equal(disk1, disk2):
1458     target1 = disk1.find("target")
1459     target2 = disk2.find("target")
1460     disk1_dict = xmlutil.to_dict(disk1, True)
1461     disk2_dict = xmlutil.to_dict(disk2, True)
1462     source1_dict = disk1_dict.get("source", {})
1463     source2_dict = disk2_dict.get("source", {})
1464     io1 = disk1_dict.get("driver", {}).get("io", "native")
1465     io2 = disk2_dict.get("driver", {}).get("io", "native")
1466     if source1_dict:
1467         source1_dict.pop("index", None)
1468     if source2_dict:
1469         source2_dict.pop("index", None)
1470     return (
1471         and target1 is not None
1472         and target2 is not None
1473         and target1<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("bus") == target2.get("bus")
1474         and disk1.get("device", "disk") == disk2.get("device", "disk")
1475         and target1.get("dev") == target2.get("dev")
1476         and io1 == io2
1477     )
1478 def</b></font> _nics_equal(nic1, nic2):
1479     def _filter_nic(nic):
1480         source_node = nic.find("source")
1481         source_attrib = source_node.attrib if source_node is not None else {}
1482         source_type = "network" if "network" in source_attrib else nic.attrib["type"]
1483         source_getters = {
1484             "network": lambda n: n.get("network"),
1485             "bridge": lambda n: n.get("bridge"),
1486             "direct": lambda n: n.get("dev"),
1487             "hostdev": lambda n: _format_pci_address(n.find("address")),
1488         }
1489         return {
1490             "type": source_type,
1491             "source": source_getters[source_type](source_node)
1492             if source_node is not None
1493             else None,
1494             "model": nic.find("model").attrib["type"]
1495             if nic.find("model") is not None
1496             else None,
1497         }
1498     def _get_mac(nic):
1499         return (
1500             nic.find("mac").attrib["address"].lower()
1501             if nic.find("mac") is not None
1502             else None
1503         )
1504     mac1 = _get_mac(nic1)
1505     mac2 = _get_mac(nic2)
1506     macs_equal = not mac1 or not mac2 or mac1 == mac2
1507     return _filter_nic(nic1) == _filter_nic(nic2) and macs_equal
1508 def _graphics_equal(gfx1, gfx2):
1509     def _filter_graphics(gfx):
1510         gfx_copy = copy.deepcopy(gfx)
1511         defaults = [
1512             {"node": ".", "attrib": "port", "values": ["5900", "-1"]},
1513             {"node": ".", "attrib": "address", "values": ["127.0.0.1"]},
1514             {"node": "listen", "attrib": "address", "values": ["127.0.0.1"]},
1515         ]
1516         for default in defaults:
1517             node = gfx_copy.find(default["node"])
1518             attrib = default["attrib"]
1519             if node is not None and (
1520                 attrib in node.attrib and node.attrib[attrib] in default["values"]
1521             ):
1522                 node.attrib.pop(attrib)
1523         return gfx_copy
1524     return xmlutil.to_dict(_filter_graphics(gfx1), True) == xmlutil.to_dict(
1525         _filter_graphics(gfx2), True
1526     )
1527 def _hostdevs_equal(dev1, dev2):
1528     def _filter_hostdevs(dev):
1529         type_ = dev.get("type")
1530         definition = {
1531             "type": type_,
1532         }
1533         if type_ == "pci":
1534             address_node = dev.find("./source/address")
1535             for attr in ["domain", "bus", "slot", "function"]:
1536                 definition[attr] = address_node.get(attr)
1537         elif type_ == "usb":
1538             for attr in ["vendor", "product"]:
1539                 definition[attr] = dev.find("./source/" + attr).get("id")
1540         return definition
1541     return _filter_hostdevs(dev1) == _filter_hostdevs(dev2)
1542 def _diff_lists(old, new, comparator):
1543     def _remove_indent(node):
1544         node_copy = copy.deepcopy(node)
1545         node_copy.text = None
1546         for item in node_copy.iter():
1547             item.tail = None
1548         return node_copy
1549     diff = {"unchanged": [], "new": [], "deleted": [], "sorted": []}
1550     old_devices = copy.deepcopy(old)
1551     for new_item in new:
1552         found = [
1553             item
1554             for item in old_devices
1555             if comparator(_remove_indent(item), _remove_indent(new_item))
1556         ]
1557         if found:
1558             old_devices.remove(found[0])
1559             diff["unchanged"].append(found[0])
1560             diff["sorted"].append(found[0])
1561         else:
1562             diff["new"].append(new_item)
1563             diff["sorted"].append(new_item)
1564     diff["deleted"] = old_devices
1565     return diff
1566 def _get_disk_target(targets, disks_count, prefix):
1567     for i in range(disks_count):
1568         ret = "{}{}".format(prefix, string.ascii_lowercase[i])
1569         if ret not in targets:
1570             return ret
1571     return None
1572 def _diff_disk_lists(old, new):
1573     targets = []
1574     prefixes = ["fd", "hd", "vd", "sd", "xvd", "ubd"]
1575     for disk in new:
1576         target_node = disk.find("target")
1577         target = target_node.get("dev")
1578         prefix = [item for item in prefixes if target.startswith(item)][0]
1579         new_target = _get_disk_target(targets, len(new), prefix)
1580         target_node.set("dev", new_target)
1581         targets.append(new_target)
1582     return _diff_lists(old, new, _disks_equal)
1583 def _diff_interface_lists(old, new):
1584     return _diff_lists(old, new, _nics_equal)
1585 def _diff_graphics_lists(old, new):
1586     return _diff_lists(old, new, _graphics_equal)
1587 def _diff_hostdev_lists(old, new):
1588     return _diff_lists(old, new, _hostdevs_equal)
1589 def _expand_cpuset(cpuset):
1590     if cpuset is None:
1591         return None
1592     if isinstance(cpuset, int):
1593         return str(cpuset)
1594     result = set()
1595     toremove = set()
1596     for part in cpuset.split(","):
1597         m = re.match("([0-9]+)-([0-9]+)", part)
1598         if m:
1599             result |= set(range(int(m.group(1)), int(m.group(2)) + 1))
1600         elif part.startswith("^"):
1601             toremove.add(int(part[1:]))
1602         else:
1603             result.add(int(part))
1604     cpus = list(result - toremove)
1605     cpus.sort()
1606     cpus = [str(cpu) for cpu in cpus]
1607     return ",".join(cpus)
1608 def _normalize_cpusets(desc, data):
1609     xpaths = ["cputune/cachetune", "cputune/cachetune/monitor", "cputune/memorytune"]
1610     for xpath in xpaths:
1611         nodes = desc.findall(xpath)
1612         for node in nodes:
1613             node.set("vcpus", _expand_cpuset(node.get("vcpus")))
1614     if not isinstance(data.get("cpu"), dict):
1615         return
1616     tuning = data["cpu"].get("tuning", {})
1617     for child in ["cachetune", "memorytune"]:
1618         if tuning.get(child):
1619             new_item = dict()
1620             for cpuset, value in tuning[child].items():
1621                 if child == "cachetune" and value.get("monitor"):
1622                     value["monitor"] = {
1623                         _expand_cpuset(monitor_cpus): monitor
1624                         for monitor_cpus, monitor in value["monitor"].items()
1625                     }
1626                 new_item[_expand_cpuset(cpuset)] = value
1627             tuning[child] = new_item
1628 def _serial_or_concole_equal(old, new):
1629     def _filter_serial_or_concole(item):
1630         """
1631             "port": item<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("source").get("service")
1632             if item.find("source") is not None
1633             else None,
1634             "protocol": item.find("protocol").get("type")
1635             if item.find(</b></font>"protocol") is not None
1636             else None,
1637         }
1638     return _filter_serial_or_concole(old) == _filter_serial_or_concole(new)
1639 def _diff_serial_lists(old, new):
1640     """
1641     Compare serial definitions to extract the changes
1642     :param old: list of ElementTree nodes representing the old serials
1643     :param new: list of ElementTree nodes representing the new serials
1644     """
1645     return _diff_lists(old, new, _serial_or_concole_equal)
1646 def _diff_console_lists(old, new):
1647     """
1648     Compare console definitions to extract the changes
1649     :param old: list of ElementTree nodes representing the old consoles
1650     :param new: list of ElementTree nodes representing the new consoles
1651     """
1652     return _diff_lists(old, new, _serial_or_concole_equal)
1653 def _format_pci_address(node):
1654     return "{}:{}:{}.{}".format(
1655         node<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("domain").replace("0x", ""),
1656         node.get("bus").replace("0x", ""),
1657         node.get("slot").replace("0x", ""),
1658         node.get("function").replace("0x", ""),
1659     )
1660 def</b></font> _almost_equal(current, new):
1661     """
1662     return True if the parameters are numbers that are almost
1663     """
1664     if current is None or new is None:
1665         return False
1666     return abs(current - new) / current &lt; 1e-03
1667 def _compute_device_changes(old_xml, new_xml, to_skip):
1668     """
1669     Compute the device changes between two domain XML definitions.
1670     """
1671     devices_node = old_xml.find("devices")
1672     changes = {}
1673     for dev_type in to_skip:
1674         changes[dev_type] = {}
1675         if not to_skip[dev_type]:
1676             old = devices_node.findall(dev_type)
1677             new = new_xml.findall("devices/{}".format(dev_type))
1678             changes[dev_type] = globals()["_diff_{}_lists".format(dev_type)](old, new)
1679     return changes
1680 def _get_pci_addresses(node):
1681     """
1682     Get all the pci addresses in the node in 0000:00:00.0 form
1683     """
1684     return {_format_pci_address(address) for address in node.findall(".//address")}
1685 def _correct_networks(conn, desc):
1686     """
1687     Adjust the interface devices matching existing networks.
1688     Returns the network interfaces XML definition as string mapped to the new device node.
1689     """
1690     networks = [ElementTree.fromstring(net.XMLDesc()) for net in conn.listAllNetworks()]
1691     nics = desc.findall("devices/interface")
1692     device_map = {}
1693     for nic in nics:
1694         if nic.get("type") == "hostdev":
1695             addr = _get_pci_addresses(nic.find("source"))
1696             matching_nets = [
1697                 net
1698                 for net in networks
1699                 if net.find("forward").get("mode") == "hostdev"
1700                 and addr &amp; _get_pci_addresses(net)
1701             ]
1702             if matching_nets:
1703                 old_xml = ElementTree.tostring(nic)
1704                 nic.set("type", "network")
1705                 nic.find("source").set("network", matching_nets[0].find("name").text)
1706                 device_map[nic] = old_xml
1707     return device_map
1708 def _update_live(domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test):
1709     """
1710     Perform the live update of a domain.
1711     """
1712     status = {}
1713     errors = []
1714     if not domain.isActive():
1715         return status, errors
1716     commands = []
1717     if cpu and (isinstance(cpu, int) or isinstance(cpu, dict) and cpu.get("maximum")):
1718         new_cpu = cpu.get("maximum") if isinstance(cpu, dict) else cpu
1719         if old_cpu != new_cpu and new_cpu is not None:
1720             commands.append(
1721                 {
1722                     "device": "cpu",
1723                     "cmd": "setVcpusFlags",
1724                     "args": [new_cpu, libvirt.VIR_DOMAIN_AFFECT_LIVE],
1725                 }
1726             )
1727     if mem:
1728         if isinstance(mem, dict):
1729             new_mem = (
1730                 int(_handle_unit(mem.get("current")) / 1024)
1731                 if "current" in mem
1732                 else None
1733             )
1734         elif isinstance(mem, int):
1735             new_mem = int(mem * 1024)
1736         if not _almost_equal(old_mem, new_mem) and new_mem is not None:
1737             commands.append(
1738                 {
1739                     "device": "mem",
1740                     "cmd": "setMemoryFlags",
1741                     "args": [new_mem, libvirt.VIR_DOMAIN_AFFECT_LIVE],
1742                 }
1743             )
1744     old_desc = ElementTree.fromstring(domain.XMLDesc(0))
1745     changed_devices = {"interface": _correct_networks(domain.connect(), old_desc)}
1746     changes = _compute_device_changes(old_desc, new_desc, to_skip)
1747     removable_changes = []
1748     new_disks = []
1749     for new_disk in changes["disk"].get("new", []):
1750         device = new_disk.get("device", "disk")
1751         if device not in ["cdrom", "floppy"]:
1752             new_disks.append(new_disk)
1753             continue
1754         target_dev = new_disk.find("target").get("dev")
1755         matching = [
1756             old_disk
1757             for old_disk in changes["disk"].get("deleted", [])
1758             if old_disk.get("device", "disk") == device
1759             and old_disk.find("target").get("dev") == target_dev
1760         ]
1761         if not matching:
1762             new_disks.append(new_disk)
1763         else:
1764             updated_disk = matching[0]
1765             changes["disk"]["deleted"].remove(updated_disk)
1766             removable_changes.append(updated_disk)
1767             source_node = updated_disk.find("source")
1768             new_source_node = new_disk.find("source")
1769             source_file = (
1770                 new_source_node.get("file") if new_source_node is not None else None
1771             )
1772             updated_disk.set("type", "file")
1773             if source_node is not None:
1774                 updated_disk.remove(source_node)
1775             if source_file:
1776                 ElementTree.SubElement(
1777                     updated_disk, "source", attrib={"file": source_file}
1778                 )
1779     changes["disk"]["new"] = new_disks
1780     for dev_type in ["disk", "interface", "hostdev"]:
1781         for added in changes[dev_type].get("new", []):
1782             commands.append(
1783                 {
1784                     "device": dev_type,
1785                     "cmd": "attachDevice",
1786                     "args": [xmlutil.element_to_str(added)],
1787             )
1788         for removed in changes<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[dev_type].get("deleted", []):
1789             removed_def = changed_devices.get(dev_type, {}).get(
1790                 removed, ElementTree.tostring(removed)
1791             )
1792             commands.append(
1793                 {
1794                     "device"</b></font>: dev_type,
1795                     "cmd": "detachDevice",
1796                     "args": [salt.utils.stringutils.to_str(removed_def)],
1797                 }
1798             )
1799     for updated_disk in removable_changes:
1800         commands.append(
1801             {
1802                 "device": "disk",
1803                 "cmd": "updateDeviceFlags",
1804                 "args": [xmlutil.element_to_str(updated_disk)],
1805             }
1806         )
1807     for cmd in commands:
1808         try:
1809             ret = 0 if test else getattr(domain, cmd["cmd"])(*cmd["args"])
1810             device_type = cmd["device"]
1811             if device_type in ["cpu", "mem"]:
1812                 status[device_type] = not ret
1813             else:
1814                 actions = {
1815                     "attachDevice": "attached",
1816                     "detachDevice": "detached",
1817                     "updateDeviceFlags": "updated",
1818                 }
1819                 device_status = status.setdefault(device_type, {})
1820                 cmd_status = device_status.setdefault(actions[cmd["cmd"]], [])
1821                 cmd_status.append(cmd["args"][0])
1822         except libvirt.libvirtError as err:
1823             errors.append(str(err))
1824     return status, errors
1825 def update(
1826     name,
1827     cpu=0,
1828     mem=0,
1829     disk_profile=None,
1830     disks=None,
1831     nic_profile=None,
1832     interfaces=None,
1833     graphics=None,
1834     live=True,
1835     boot=None,
1836     numatune=None,
1837     test=False,
1838     boot_dev=None,
1839     hypervisor_features=None,
1840     clock=None,
1841     serials=None,
1842     consoles=None,
1843     stop_on_reboot=False,
1844     host_devices=None,
1845     **kwargs
1846 ):
1847     """
1848     Update the definition of an existing domain.
1849     :param name: Name of the domain to update
1850     :param cpu:
1851         Number of virtual CPUs to assign to the virtual machine or a dictionary with detailed information to configure
1852         cpu model and topology, numa node tuning, cpu tuning and iothreads allocation. The structure of the dictionary is
1853         documented in :ref:`init-cpu-def`.
1854         To update any cpu parameters specify the new values to the corresponding tag. To remove any element or attribute,
1855         specify ``None`` object. Please note that ``None`` object is mapped to ``null`` in yaml, use ``null`` in sls file
1856         instead.
1857     :param mem: Amount of memory to allocate to the virtual machine in MiB. Since 3002, a dictionary can be used to
1858         contain detailed configuration which support memory allocation or tuning. Supported parameters are ``boot``,
1859         ``current``, ``max``, ``slots``, ``hard_limit``, ``soft_limit``, ``swap_hard_limit``, ``min_guarantee``,
1860         ``hugepages`` ,  ``nosharepages``, ``locked``, ``source``, ``access``, ``allocation`` and ``discard``. The structure
1861         of the dictionary is documented in  :ref:`init-mem-def`. Both decimal and binary base are supported. Detail unit
1862         specification is documented  in :ref:`virt-units`. Please note that the value for ``slots`` must be an integer.
1863         To remove any parameters, pass a None object, for instance: 'soft_limit': ``None``. Please note  that ``None``
1864         is mapped to ``null`` in sls file, pass ``null`` in sls file instead.
1865         .. code-block:: yaml
1866             - mem:
1867                 hard_limit: null
1868                 soft_limit: null
1869         .. versionchanged:: 3002
1870     :param disk_profile: disk profile to use
1871     :param disks:
1872         Disk definitions as documented in the :func:`init` function.
1873         If neither the profile nor this parameter are defined, the disk devices
1874         will not be changed. However to clear disks set this parameter to empty list.
1875     :param nic_profile: network interfaces profile to use
1876     :param interfaces:
1877         Network interface definitions as documented in the :func:`init` function.
1878         If neither the profile nor this parameter are defined, the interface devices
1879         will not be changed. However to clear network interfaces set this parameter
1880         to empty list.
1881     :param graphics:
1882         The new graphics definition as defined in :ref:`init-graphics-def`. If not set,
1883         the graphics will not be changed. To remove a graphics device, set this parameter
1884         to ``{'type': 'none'}``.
1885     :param live:
1886         ``False`` to avoid trying to live update the definition. In such a case, the
1887         new definition is applied at the next start of the virtual machine. If ``True``,
1888         not all aspects of the definition can be live updated, but as much as possible
1889         will be attempted. (Default: ``True``)
1890     :param connection: libvirt connection URI, overriding defaults
1891     :param username: username to connect with, overriding defaults
1892     :param password: password to connect with, overriding defaults
1893     :param boot:
1894         Specifies kernel, initial ramdisk and kernel command line parameters for the virtual machine.
1895         This is an optional parameter, all of the keys are optional within the dictionary.
1896         Refer to :ref:`init-boot-def` for the complete boot parameter description.
1897         To update any boot parameters, specify the new path for each. To remove any boot parameters, pass ``None`` object,
1898         for instance: 'kernel': ``None``. To switch back to BIOS boot, specify ('loader': ``None`` and 'nvram': ``None``)
1899         or 'efi': ``False``. Please note that ``None`` is mapped to ``null`` in sls file, pass ``null`` in sls file instead.
1900         SLS file Example:
1901         .. code-block:: yaml
1902             - boot:
1903                 loader: null
1904                 nvram: null
1905         .. versionadded:: 3000
1906     :param boot_dev:
1907         Space separated list of devices to boot from sorted by decreasing priority.
1908         Values can be ``hd``, ``fd``, ``cdrom`` or ``network``.
1909         By default, the value will ``"hd"``.
1910         .. versionadded:: 3002
1911     :param numatune:
1912         The optional numatune element provides details of how to tune the performance of a NUMA host via controlling NUMA
1913         policy for domain process. The optional ``memory`` element specifies how to allocate memory for the domain process
1914         on a NUMA host. ``memnode`` elements can specify memory allocation policies per each guest NUMA node. The definition
1915         used in the dictionary can be found at :ref:`init-cpu-def`.
1916         To update any numatune parameters, specify the new value. To remove any ``numatune`` parameters, pass a None object,
1917         for instance: 'numatune': ``None``. Please note that ``None`` is mapped to ``null`` in sls file, pass ``null`` in
1918         sls file instead.
1919         .. versionadded:: 3003
1920     :param serials:
1921         Dictionary providing details on the serials connection to create. (Default: ``None``)
1922         See :ref:`init-chardevs-def` for more details on the possible values.
1923         .. versionadded:: 3003
1924     :param consoles:
1925         Dictionary providing details on the consoles device to create. (Default: ``None``)
1926         See :ref:`init-chardevs-def` for more details on the possible values.
1927         .. versionadded:: 3003
1928     :param stop_on_reboot:
1929         If set to ``True`` the guest will stop instead of rebooting.
1930         This is specially useful when creating a virtual machine with an installation cdrom or
1931         an autoinstallation needing a special first boot configuration.
1932         Defaults to ``False``
1933         .. versionadded:: 3003
1934     :param test: run in dry-run mode if set to True
1935         .. versionadded:: 3001
1936     :param hypervisor_features:
1937         Enable or disable hypervisor-specific features on the virtual machine.
1938         .. versionadded:: 3003
1939         .. code-block:: yaml
1940             hypervisor_features:
1941               kvm-hint-dedicated: True
1942     :param clock:
1943         Configure the guest clock.
1944         The value is a dictionary with the following keys:
1945         adjustment
1946             time adjustment in seconds or ``reset``
1947         utc
1948             set to ``False`` to use the host local time as the guest clock. Defaults to ``True``.
1949         timezone
1950             synchronize the guest to the correspding timezone
1951         timers
1952             a dictionary associating the timer name with its configuration.
1953             This configuration is a dictionary with the properties ``track``, ``tickpolicy``,
1954             ``catchup``, ``frequency``, ``mode``, ``present``, ``slew``, ``threshold`` and ``limit``.
1955             See `libvirt time keeping documentation &lt;https://libvirt.org/formatdomain.html#time-keeping&gt;`_ for the possible values.
1956         .. versionadded:: 3003
1957         Set the clock to local time using an offset in seconds
1958         .. code-block:: yaml
1959             clock:
1960               adjustment: 3600
1961               utc: False
1962         Set the clock to a specific time zone:
1963         .. code-block:: yaml
1964             clock:
1965               timezone: CEST
1966         Tweak guest timers:
1967         .. code-block:: yaml
1968             clock:
1969               timers:
1970                 tsc:
1971                   frequency: 3504000000
1972                   mode: native
1973                 rtc:
1974                   track: wall
1975                   tickpolicy: catchup
1976                   slew: 4636
1977                   threshold: 123
1978                   limit: 2342
1979                 hpet:
1980                   present: False
1981     :param host_devices:
1982         List of host devices to passthrough to the guest.
1983         The value is a list of device names as provided by the :py:func:`~salt.modules.virt.node_devices` function.
1984         (Default: ``None``)
1985         .. versionadded:: 3003
1986     :return:
1987         Returns a dictionary indicating the status of what has been done. It is structured in
1988         the following way:
1989         .. code-block:: python
1990             {
1991               'definition': True,
1992               'cpu': True,
1993               'mem': True,
1994               'disks': {'attached': [list of actually attached disks],
1995                         'detached': [list of actually detached disks]},
1996               'nics': {'attached': [list of actually attached nics],
1997                        'detached': [list of actually detached nics]},
1998               'errors': ['error messages for failures']
1999             }
2000     .. versionadded:: 2019.2.0
2001     CLI Example:
2002     .. code-block:: bash
2003         salt '*' virt.update domain cpu=2 mem=1024
2004     """
2005     status = {
2006         "definition": False,
2007         "disk": {"attached": [], "detached": [], "updated": []},
2008         "interface": {"attached": [], "detached": []},
2009     }
2010     conn = __get_conn(**kwargs)
2011     domain = _get_domain(conn, name)
2012     desc = ElementTree.fromstring(domain.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
2013     need_update = False
2014     hypervisor = desc.get("type")
2015     all_disks = _disk_profile(conn, disk_profile, hypervisor, disks, name)
2016     if boot is not None:
2017         boot = _handle_remote_boot_params(boot)
2018         if boot.get("efi", None) is not None:
2019             need_update = _handle_efi_param(boot, desc)
2020     new_desc = ElementTree.fromstring(
2021         _gen_xml(
2022             conn,
2023             name,
2024             cpu,
2025             mem or 0,
2026             all_disks,
2027             _get_merged_nics(hypervisor, nic_profile, interfaces),
2028             hypervisor,
2029             domain.OSType(),
2030             desc.find(".//os/type").get("arch"),
2031             graphics,
2032             boot,
2033             boot_dev,
2034             numatune,
2035             serials=serials,
2036             consoles=consoles,
2037             stop_on_reboot=stop_on_reboot,
2038             host_devices=host_devices,
2039             **kwargs
2040         )
2041     )
2042     if clock:
2043         offset = "utc" if clock.get("utc", True) else "localtime"
2044         if "timezone" in clock:
2045             offset = "timezone"
2046         clock["offset"] = offset
2047     def _set_loader(node, value):
2048         salt.utils.xmlutil.set_node_text(node, value)
2049         if value is not None:
2050             node.set("readonly", "yes")
2051             node.set("type", "pflash")
2052     def _set_nvram(node, value):
2053         node.set("template", value)
2054     def _set_with_byte_unit(attr_name=None):
2055         def _setter(node, value):
2056             if attr_name:
2057                 node.set(attr_name, str(value))
2058             else:
2059                 node.text = str(value)
2060             node.set("unit", "bytes")
2061         return _setter
2062     def _get_with_unit(node):
2063         unit = node.get("unit", "KiB")
2064         unit = unit if unit != "bytes" else "b"
2065         value = node.get("memory") or node.get("size") or node.text
2066         return _handle_unit("{}{}".format(value, unit)) if value else None
2067     def _set_vcpu(node, value):
2068         node.text = str(value)
2069         node.set("current", str(value))
2070     old_mem = int(_get_with_unit(desc.find("memory")) / 1024)
2071     old_cpu = int(desc.find("./vcpu").text)
2072     def _yesno_attribute(path, xpath, attr_name, ignored=None):
2073         return xmlutil.attribute(
2074             path, xpath, attr_name, ignored, lambda v: "yes" if v else "no"
2075         )
2076     def _memory_parameter(path, xpath, attr_name=None, ignored=None):
2077         entry = {
2078             "path": path,
2079             "xpath": xpath,
2080             "convert": _handle_unit,
2081             "get": _get_with_unit,
2082             "set": _set_with_byte_unit(attr_name),
2083             "equals": _almost_equal,
2084         }
2085         if attr_name:
2086             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
2087         return entry
2088     def _cpuset_parameter(path, xpath, attr_name=None, ignored=None):
2089         def _set_cpuset(node, value):
2090             if attr_name:
2091                 node.set(attr_name, value)
2092             else:
2093                 node.text = value
2094         entry = {
2095             "path": path,
2096             "xpath": xpath,
2097             "convert": _expand_cpuset,
2098             "get": lambda n: _expand_cpuset(n.get(attr_name) if attr_name else n.text),
2099             "set": _set_cpuset,
2100         }
2101         if attr_name:
2102             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
2103         return entry
2104     data = {k: v for k, v in locals().items() if bool(v)}
2105     data["stop_on_reboot"] = stop_on_reboot
2106     if boot_dev:
2107         data["boot_dev"] = boot_dev.split()
2108     timer_names = [
2109         "platform",
2110         "hpet",
2111         "kvmclock",
2112         "pit",
2113         "rtc",
2114         "tsc",
2115         "hypervclock",
2116         "armvtimer",
2117     ]
2118     if data.get("clock", {}).get("timers"):
2119         attributes = [
2120             "track",
2121             "tickpolicy",
2122             "frequency",
2123             "mode",
2124             "present",
2125             "slew",
2126             "threshold",
2127             "limit",
2128         ]
2129         for timer in data["clock"]["timers"].values():
2130             for attribute in attributes:
2131                 if attribute not in timer:
2132                     timer[attribute] = None
2133         for timer_name in timer_names:
2134             if timer_name not in data["clock"]["timers"]:
2135                 data["clock"]["timers"][timer_name] = None
2136     _normalize_cpusets(desc, data)
2137     params_mapping = [
2138         {
2139             "path": "stop_on_reboot",
2140             "xpath": "on_reboot",
2141             "convert": lambda v: "destroy" if v else "restart",
2142         },
2143         {"path": "boot:kernel", "xpath": "os/kernel"},
2144         {"path": "boot:initrd", "xpath": "os/initrd"},
2145         {"path": "boot:cmdline", "xpath": "os/cmdline"},
2146         {"path": "boot:loader", "xpath": "os/loader", "set": _set_loader},
2147         {"path": "boot:nvram", "xpath": "os/nvram", "set": _set_nvram},
2148         _memory_parameter("mem", "memory"),
2149         _memory_parameter("mem", "currentMemory"),
2150         _memory_parameter("mem:max", "maxMemory"),
2151         _memory_parameter("mem:boot", "memory"),
2152         _memory_parameter("mem:current", "currentMemory"),
2153         xmlutil.attribute("mem:slots", "maxMemory", "slots", ["unit"]),
2154         _memory_parameter("mem:hard_limit", "memtune/hard_limit"),
2155         _memory_parameter("mem:soft_limit", "memtune/soft_limit"),
2156         _memory_parameter("mem:swap_hard_limit", "memtune/swap_hard_limit"),
2157         _memory_parameter("mem:min_guarantee", "memtune/min_guarantee"),
2158         xmlutil.attribute("boot_dev:{dev}", "os/boot[$dev]", "dev"),
2159         _memory_parameter(
2160             "mem:hugepages:{id}:size",
2161             "memoryBacking/hugepages/page[$id]",
2162             "size",
2163             ["unit", "nodeset"],
2164         ),
2165         _cpuset_parameter(
2166             "mem:hugepages:{id}:nodeset", "memoryBacking/hugepages/page[$id]", "nodeset"
2167         ),
2168         {
2169             "path": "mem:nosharepages",
2170             "xpath": "memoryBacking/nosharepages",
2171             "get": lambda n: n is not None,
2172             "set": lambda n, v: None,
2173         },
2174         {
2175             "path": "mem:locked",
2176             "xpath": "memoryBacking/locked",
2177             "get": lambda n: n is not None,
2178             "set": lambda n, v: None,
2179         },
2180         xmlutil.attribute("mem:source", "memoryBacking/source", "type"),
2181         xmlutil.attribute("mem:access", "memoryBacking/access", "mode"),
2182         xmlutil.attribute("mem:allocation", "memoryBacking/allocation", "mode"),
2183         {"path": "mem:discard", "xpath": "memoryBacking/discard"},
2184         {
2185             "path": "cpu",
2186             "xpath": "vcpu",
2187             "get": lambda n: int(n.text),
2188             "set": _set_vcpu,
2189         },
2190         {"path": "cpu:maximum", "xpath": "vcpu", "get": lambda n: int(n.text)},
2191         _cpuset_parameter("cpu:cpuset", "vcpu", "cpuset"),
2192         xmlutil.attribute("cpu:current", "vcpu", "current"),
2193         xmlutil<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.attribute("cpu:match", "cpu", "match"),
2194         xmlutil.attribute("cpu:mode", "cpu", "mode"),
2195         xmlutil.attribute("cpu:check", "cpu", "check"),
2196         {"path": "cpu:model:name", "xpath": "cpu/model"},
2197         xmlutil.attribute("cpu:model:fallback", "cpu/model", "fallback"),
2198         xmlutil.attribute("cpu:model:vendor_id", "cpu/model", "vendor_id"),
2199         {"path": "cpu:vendor", "xpath": "cpu/vendor"},
2200         xmlutil.attribute("cpu:topology:sockets", "cpu/topology", "sockets"),
2201         xmlutil.attribute("cpu:topology:cores", "cpu/topology", "cores"),
2202         xmlutil.attribute("cpu:topology:threads", "cpu/topology", "threads"),
2203         xmlutil.</b></font>attribute("cpu:cache:level", "cpu/cache", "level"),
2204         xmlutil.attribute("cpu:cache:mode", "cpu/cache", "mode"),
2205         xmlutil.attribute(
2206             "cpu:features:{id}", "cpu/feature[@name='$id']", "policy", ["name"]
2207         ),
2208         _yesno_attribute(
2209             "cpu:vcpus:{id}:enabled", "vcpus/vcpu[@id='$id']", "enabled", ["id"]
2210         ),
2211         _yesno_attribute(
2212             "cpu:vcpus:{id}:hotpluggable",
2213             "vcpus/vcpu[@id='$id']",
2214             "hotpluggable",
2215             ["id"],
2216         ),
2217         xmlutil.int_attribute(
2218             "cpu:vcpus:{id}:order", "vcpus/vcpu[@id='$id']", "order", ["id"]
2219         ),
2220         _cpuset_parameter(
2221             "cpu:numa:{id}:cpus", "cpu/numa/cell[@id='$id']", "cpus", ["id"]
2222         ),
2223         _memory_parameter(
2224             "cpu:numa:{id}:memory", "cpu/numa/cell[@id='$id']", "memory", ["id"]
2225         ),
2226         _yesno_attribute(
2227             "cpu:numa:{id}:discard", "cpu/numa/cell[@id='$id']", "discard", ["id"]
2228         ),
2229         xmlutil.attribute(
2230             "cpu:numa:{id}:memAccess", "cpu/numa/cell[@id='$id']", "memAccess", ["id"]
2231         ),
2232         xmlutil.attribute(
2233             "cpu:numa:{id}:distances:{sid}",
2234             "cpu/numa/cell[@id='$id']/distances/sibling[@id='$sid']",
2235             "value",
2236             ["id"],
2237         ),
2238         {"path": "cpu:iothreads", "xpath": "iothreads"},
2239         {"path": "cpu:tuning:shares", "xpath": "cputune/shares"},
2240         {"path": "cpu:tuning:period", "xpath": "cputune/period"},
2241         {"path": "cpu:tuning:quota", "xpath": "cputune/quota"},
2242         {"path": "cpu:tuning:global_period", "xpath": "cputune/global_period"},
2243         {"path": "cpu:tuning:global_quota", "xpath": "cputune/global_quota"},
2244         {"path": "cpu:tuning:emulator_period", "xpath": "cputune/emulator_period"},
2245         {"path": "cpu:tuning:emulator_quota", "xpath": "cputune/emulator_quota"},
2246         {"path": "cpu:tuning:iothread_period", "xpath": "cputune/iothread_period"},
2247         {"path": "cpu:tuning:iothread_quota", "xpath": "cputune/iothread_quota"},
2248         _cpuset_parameter(
2249             "cpu:tuning:vcpupin:{id}",
2250             "cputune/vcpupin[@vcpu='$id']",
2251             "cpuset",
2252             ["vcpu"],
2253         ),
2254         _cpuset_parameter("cpu:tuning:emulatorpin", "cputune/emulatorpin", "cpuset"),
2255         _cpuset_parameter(
2256             "cpu:tuning:iothreadpin:{id}",
2257             "cputune/iothreadpin[@iothread='$id']",
2258             "cpuset",
2259             ["iothread"],
2260         ),
2261         xmlutil.attribute(
2262             "cpu:tuning:vcpusched:{id}:scheduler",
2263             "cputune/vcpusched[$id]",
2264             "scheduler",
2265             ["priority", "vcpus"],
2266         ),
2267         xmlutil.attribute(
2268             "cpu:tuning:vcpusched:{id}:priority", "cputune/vcpusched[$id]", "priority"
2269         ),
2270         _cpuset_parameter(
2271             "cpu:tuning:vcpusched:{id}:vcpus", "cputune/vcpusched[$id]", "vcpus"
2272         ),
2273         xmlutil.attribute(
2274             "cpu:tuning:iothreadsched:{id}:scheduler",
2275             "cputune/iothreadsched[$id]",
2276             "scheduler",
2277             ["priority", "iothreads"],
2278         ),
2279         xmlutil.attribute(
2280             "cpu:tuning:iothreadsched:{id}:priority",
2281             "cputune/iothreadsched[$id]",
2282             "priority",
2283         ),
2284         _cpuset_parameter(
2285             "cpu:tuning:iothreadsched:{id}:iothreads",
2286             "cputune/iothreadsched[$id]",
2287             "iothreads",
2288         ),
2289         xmlutil.attribute(
2290             "cpu:tuning:emulatorsched:scheduler",
2291             "cputune/emulatorsched",
2292             "scheduler",
2293             ["priority"],
2294         ),
2295         xmlutil.attribute(
2296             "cpu:tuning:emulatorsched:priority", "cputune/emulatorsched", "priority"
2297         ),
2298         xmlutil.attribute(
2299             "cpu:tuning:cachetune:{id}:monitor:{sid}",
2300             "cputune/cachetune[@vcpus='$id']/monitor[@vcpus='$sid']",
2301             "level",
2302             ["vcpus"],
2303         ),
2304         xmlutil.attribute(
2305             "cpu:tuning:memorytune:{id}:{sid}",
2306             "cputune/memorytune[@vcpus='$id']/node[@id='$sid']",
2307             "bandwidth",
2308             ["id", "vcpus"],
2309         ),
2310         xmlutil.attribute("clock:offset", "clock", "offset"),
2311         xmlutil.attribute("clock:adjustment", "clock", "adjustment", convert=str),
2312         xmlutil.attribute("clock:timezone", "clock", "timezone"),
2313     ]
2314     for timer in timer_names:
2315         params_mapping += [
2316             xmlutil<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.attribute(
2317                 "clock:timers:{}:track".format(timer),
2318                 "clock/timer[@name='{}']".format(timer),
2319                 "track",
2320                 ["name"],
2321             ),
2322             xmlutil.attribute(
2323                 "clock:timers:{}:tickpolicy".format(timer),
2324                 "clock/timer[@name='{}']".format(timer),
2325                 "tickpolicy",
2326                 ["name"],
2327             ),
2328             xmlutil.int_attribute(
2329                 "clock:timers:{}:frequency".format(timer),
2330                 "clock/timer[@name='{}']".format(timer),
2331                 "frequency",
2332                 ["name"],
2333             ),
2334             xmlutil.</b></font>attribute(
2335                 "clock:timers:{}:mode".format(timer),
2336                 "clock/timer[@name='{}']".format(timer),
2337                 "mode",
2338                 ["name"],
2339             ),
2340             _yesno_attribute(
2341                 "clock:timers:{}:present".format(timer),
2342                 "clock/timer[@name='{}']".format(timer),
2343                 "present",
2344                 ["name"],
2345             ),
2346         ]
2347         for attr in ["slew", "threshold", "limit"]:
2348             params_mapping.append(
2349                 xmlutil.int_attribute(
2350                     "clock:timers:{}:{}".format(timer, attr),
2351                     "clock/timer[@name='{}']/catchup".format(timer),
2352                     attr,
2353                 )
2354             )
2355     for attr in ["level", "type", "size"]:
2356         params_mapping.append(
2357             xmlutil.attribute(
2358                 "cpu:tuning:cachetune:{id}:{sid}:" + attr,
2359                 "cputune/cachetune[@vcpus='$id']/cache[@id='$sid']",
2360                 attr,
2361                 ["id", "unit", "vcpus"],
2362             )
2363         )
2364     if hypervisor in ["qemu", "kvm"]:
2365         params_mapping += [
2366             xmlutil.attribute("numatune:memory:mode", "numatune/memory", "mode"),
2367             _cpuset_parameter("numatune:memory:nodeset", "numatune/memory", "nodeset"),
2368             xmlutil.attribute(
2369                 "numatune:memnodes:{id}:mode",
2370                 "numatune/memnode[@cellid='$id']",
2371                 "mode",
2372                 ["cellid"],
2373             ),
2374             _cpuset_parameter(
2375                 "numatune:memnodes:{id}:nodeset",
2376                 "numatune/memnode[@cellid='$id']",
2377                 "nodeset",
2378                 ["cellid"],
2379             ),
2380             xmlutil.attribute(
2381                 "hypervisor_features:kvm-hint-dedicated",
2382                 "features/kvm/hint-dedicated",
2383                 "state",
2384                 convert=lambda v: "on" if v else "off",
2385             ),
2386         ]
2387     need_update = (
2388         salt.utils.xmlutil.change_xml(desc, data, params_mapping) or need_update
2389     )
2390     devices_node = desc.find("devices")
2391     func_locals = locals()
2392     def _skip_update(names):
2393         return all(func_locals.get(n) is None for n in names)
2394     to_skip = {
2395         "disk": _skip_update(["disks", "disk_profile"]),
2396         "interface": _skip_update(["interfaces", "nic_profile"]),
2397         "graphics": _skip_update(["graphics"]),
2398         "serial": _skip_update(["serials"]),
2399         "console": _skip_update(["consoles"]),
2400         "hostdev": _skip_update(["host_devices"]),
2401     }
2402     changes = _compute_device_changes(desc, new_desc, to_skip)
2403     for dev_type in changes:
2404         if not to_skip[dev_type]:
2405             old = devices_node.findall(dev_type)
2406             if changes[dev_type].get("deleted") or changes[dev_type].get("new"):
2407                 for item in old:
2408                     devices_node.remove(item)
2409                 devices_node.extend(changes[dev_type]["sorted"])
2410                 need_update = True
2411     if need_update:
2412         try:
2413             if changes["disk"]:
2414                 for idx, item in enumerate(changes["disk"]["sorted"]):
2415                     source_file = all_disks[idx].get("source_file")
2416                     if all_disks[idx].get("device", "disk") == "cdrom":
2417                         continue
2418                     if (
2419                         item in changes["disk"]["new"]
2420                         and source_file
2421                         and not os.path.exists(source_file)
2422                     ):
2423                         _qemu_image_create(all_disks[idx])
2424                     elif item in changes["disk"]["new"] and not source_file:
2425                         _disk_volume_create(conn, all_disks[idx])
2426             if not test:
2427                 xml_desc = xmlutil.element_to_str(desc)
2428                 log.debug("Update virtual machine definition: %s", xml_desc)
2429                 conn.defineXML(xml_desc)
2430             status["definition"] = True
2431         except libvirt.libvirtError as err:
2432             conn.close()
2433             raise err
2434     if live:
2435         live_status, errors = _update_live(
2436             domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test
2437         )
2438         status.update(live_status)
2439         if errors:
2440             status_errors = status.setdefault("errors", [])
2441             status_errors += errors
2442     conn.close()
2443     return status
2444 def list_domains(**kwargs):
2445     """
2446     Return a list of available domains.
2447     :param connection: libvirt connection URI, overriding defaults
2448         .. versionadded:: 2019.2.0
2449     :param username: username to connect with, overriding defaults
2450         .. versionadded:: 2019.2.0
2451     :param password: password to connect with, overriding defaults
2452         .. versionadded:: 2019.2.0
2453     CLI Example:
2454     .. code-block:: bash
2455         salt '*' virt.list_domains
2456     """
2457     vms = []
2458     conn = __get_conn(**kwargs)
2459     for dom in _get_domain(conn, iterable=True):
2460         vms.append(dom.name())
2461     conn.close()
2462     return vms
2463 def list_active_vms(**kwargs):
2464     """
2465     Return a list of names for active virtual machine on the minion
2466     :param connection: libvirt connection URI, overriding defaults
2467         .. versionadded:: 2019.2.0
2468     :param username: username to connect with, overriding defaults
2469         .. versionadded:: 2019.2.0
2470     :param password: password to connect with, overriding defaults
2471         .. versionadded:: 2019.2.0
2472     CLI Example:
2473     .. code-block:: bash
2474         salt '*' virt.list_active_vms
2475     """
2476     vms = []
2477     conn = __get_conn(**kwargs)
2478     for dom in _get_domain(conn, iterable=True, inactive=False):
2479         vms.append(dom.name())
2480     conn.close()
2481     return vms
2482 def list_inactive_vms(**kwargs):
2483     """
2484     Return a list of names for inactive virtual machine on the minion
2485     :param connection: libvirt connection URI, overriding defaults
2486         .. versionadded:: 2019.2.0
2487     :param username: username to connect with, overriding defaults
2488         .. versionadded:: 2019.2.0
2489     :param password: password to connect with, overriding defaults
2490         .. versionadded:: 2019.2.0
2491     CLI Example:
2492     .. code-block:: bash
2493         salt '*' virt.list_inactive_vms
2494     """
2495     vms = []
2496     conn = __get_conn(**kwargs)
2497     for dom in _get_domain(conn, iterable=True, active=False):
2498         vms.append(dom.name())
2499     conn.close()
2500     return vms
2501 def vm_info(vm_=None, **kwargs):
2502     """
2503     Return detailed information about the vms on this hyper in a
2504     list of dicts:
2505     :param vm_: name of the domain
2506     :param connection: libvirt connection URI, overriding defaults
2507         .. versionadded:: 2019.2.0
2508     :param username: username to connect with, overriding defaults
2509         .. versionadded:: 2019.2.0
2510     :param password: password to connect with, overriding defaults
2511         .. versionadded:: 2019.2.0
2512     .. code-block:: python
2513         [
2514             'your-vm': {
2515                 'cpu': &lt;int&gt;,
2516                 'maxMem': &lt;int&gt;,
2517                 'mem': &lt;int&gt;,
2518                 'state': '&lt;state&gt;',
2519                 'cputime' &lt;int&gt;
2520                 },
2521             ...
2522             ]
2523     If you pass a VM name in as an argument then it will return info
2524     for just the named VM, otherwise it will return all VMs.
2525     CLI Example:
2526     .. code-block:: bash
2527         salt '*' virt.vm_info
2528     """
2529     def _info(conn, dom):
2530         """
2531         Compute the infos of a domain
2532         """
2533         raw = dom.info()
2534         return {
2535             "cpu": raw[3],
2536             "cputime": int(raw[4]),
2537             "disks": _get_disks(conn, dom),
2538             "graphics": _get_graphics(dom),
2539             "nics": _get_nics(dom),
2540             "uuid": _get_uuid(dom),
2541             "loader": _get_loader(dom),
2542             "on_crash": _get_on_crash(dom),
2543             "on_reboot": _get_on_reboot(dom),
2544             "on_poweroff": _get_on_poweroff(dom),
2545             "maxMem": int(raw[1]),
2546             "mem": int(raw[2]),
2547             "state": VIRT_STATE_NAME_MAP.get(raw[0], "unknown"),
2548         }
2549     info = {}
2550     conn = __get_conn(**kwargs)
2551     if vm_:
2552         info[vm_] = _info(conn, _get_domain(conn, vm_))
2553     else:
2554         for domain in _get_domain(conn, iterable=True):
2555             info[domain.name()] = _info(conn, domain)
2556     conn.close()
2557     return info
2558 def vm_state(vm_=None, **kwargs):
2559     """
2560     Return list of all the vms and their state.
2561     If you pass a VM name in as an argument then it will return info
2562     for just the named VM, otherwise it will return all VMs.
2563     :param vm_: name of the domain
2564     :param connection: libvirt connection URI, overriding defaults
2565         .. versionadded:: 2019.2.0
2566     :param username: username to connect with, overriding defaults
2567         .. versionadded:: 2019.2.0
2568     :param password: password to connect with, overriding defaults
2569         .. versionadded:: 2019.2.0
2570     CLI Example:
2571     .. code-block:: bash
2572         salt '*' virt.vm_state &lt;domain&gt;
2573     """
2574     def _info(dom):
2575         """
2576         Compute domain state
2577         """
2578         state = ""
2579         raw = dom.info()
2580         state = VIRT_STATE_NAME_MAP.get(raw[0], "unknown")
2581         return state
2582     info = {}
2583     conn = __get_conn(**kwargs)
2584     if vm_:
2585         info[vm_] = _info(_get_domain(conn, vm_))
2586     else:
2587         for domain in _get_domain(conn, iterable=True):
2588             info[domain.name()] = _info(domain)
2589     conn.close()
2590     return info
2591 def _node_info(conn):
2592     """
2593     Internal variant of node_info taking a libvirt connection as parameter
2594     """
2595     raw = conn.getInfo()
2596     info = {
2597         "cpucores": raw[6],
2598         "cpumhz": raw[3],
2599         "cpumodel": str(raw[0]),
2600         "cpus": raw[2],
2601         "cputhreads": raw[7],
2602         "numanodes": raw[4],
2603         "phymemory": raw[1],
2604         "sockets": raw[5],
2605     }
2606     return info
2607 def node_info(**kwargs):
2608     """
2609     Return a dict with information about this node
2610     :param connection: libvirt connection URI, overriding defaults
2611         .. versionadded:: 2019.2.0
2612     :param username: username to connect with, overriding defaults
2613         .. versionadded:: 2019.2.0
2614     :param password: password to connect with, overriding defaults
2615         .. versionadded:: 2019.2.0
2616     CLI Example:
2617     .. code-block:: bash
2618         salt '*' virt.node_info
2619     """
2620     conn = __get_conn(**kwargs)
2621     info = _node_info(conn)
2622     conn.close()
2623     return info
2624 def _node_devices(conn):
2625     """
2626     List the host available devices, using an established connection.
2627     :param conn: the libvirt connection handle to use.
2628     .. versionadded:: 3003
2629     """
2630     devices = conn.listAllDevices()
2631     devices_infos = []
2632     for dev in devices:
2633         root = ElementTree.fromstring(dev.XMLDesc())
2634         if not set(dev.listCaps()) &amp; {"pci", "usb_device", "net"}:
2635             continue
2636         infos = {
2637             "caps": " ".join(dev.listCaps()),
2638         }
2639         if "net" in dev.listCaps():
2640             parent = root.find(".//parent").text
2641             if parent == "computer":
2642                 continue
2643             infos.update(
2644                 {
2645                     "name": root.find(".//interface").text,
2646                     "address": root.find(".//address").text,
2647                     "device name": parent,
2648                     "state": root.find(".//link").get("state"),
2649                 }
2650             )
2651             devices_infos.append(infos)
2652             continue
2653         vendor_node = root.find(".//vendor")
2654         vendor_id = vendor_node.get("id").lower()
2655         product_node = root.find(".//product")
2656         product_id = product_node.get("id").lower()
2657         infos.update(
2658             {"name": dev.name(), "vendor_id": vendor_id, "product_id": product_id}
2659         )
2660         if vendor_node.text:
2661             infos["vendor"] = vendor_node.text
2662         if product_node.text:
2663             infos["product"] = product_node.text
2664         if "pci" in dev.listCaps():
2665             infos["address"] = "{:04x}:{:02x}:{:02x}.{}".format(
2666                 int<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(root.find(".//domain").text),
2667                 int(root.find(".//bus").text),
2668                 int(root.find(".//slot").text),
2669                 root.find(".//function").</b></font>text,
2670             )
2671             class_node = root.find(".//class")
2672             if class_node is not None:
2673                 infos["PCI class"] = class_node.text
2674             vf_addresses = [
2675                 _format_pci_address(vf)
2676                 for vf in root.findall(
2677                     "./capability[@type='pci']/capability[@type='virt_functions']/address"
2678                 )
2679             ]
2680             if vf_addresses:
2681                 infos["virtual functions"] = vf_addresses
2682             pf = root.find(
2683                 "./capability[@type='pci']/capability[@type='phys_function']/address"
2684             )
2685             if pf is not None:
2686                 infos["physical function"] = _format_pci_address(pf)
2687         elif "usb_device" in dev.listCaps():
2688             infos["address"] = "{:03}:{:03}".format(
2689                 int(root.find(".//bus").text), int(root.find(".//device").text)
2690             )
2691         linux_usb_host = vendor_id == "0x1d6b" and product_id in [
2692             "0x0001",
2693             "0x0002",
2694             "0x0003",
2695         ]
2696         if (
2697             root.find(".//capability[@type='pci-bridge']") is None
2698             and not linux_usb_host
2699         ):
2700             devices_infos.append(infos)
2701     return devices_infos
2702 def node_devices(**kwargs):
2703     """
2704     List the host available devices.
2705     :param connection: libvirt connection URI, overriding defaults
2706     :param username: username to connect with, overriding defaults
2707     :param password: password to connect with, overriding defaults
2708     .. versionadded:: 3003
2709     """
2710     conn = __get_conn(**kwargs)
2711     devs = _node_devices(conn)
2712     conn.close()
2713     return devs
2714 def get_nics(vm_, **kwargs):
2715     """
2716     Return info about the network interfaces of a named vm
2717     :param vm_: name of the domain
2718     :param connection: libvirt connection URI, overriding defaults
2719         .. versionadded:: 2019.2.0
2720     :param username: username to connect with, overriding defaults
2721         .. versionadded:: 2019.2.0
2722     :param password: password to connect with, overriding defaults
2723         .. versionadded:: 2019.2.0
2724     CLI Example:
2725     .. code-block:: bash
2726         salt '*' virt.get_nics &lt;domain&gt;
2727     """
2728     conn = __get_conn(**kwargs)
2729     nics = _get_nics(_get_domain(conn, vm_))
2730     conn.close()
2731     return nics
2732 def get_macs(vm_, **kwargs):
2733     """
2734     Return a list off MAC addresses from the named vm
2735     :param vm_: name of the domain
2736     :param connection: libvirt connection URI, overriding defaults
2737         .. versionadded:: 2019.2.0
2738     :param username: username to connect with, overriding defaults
2739         .. versionadded:: 2019.2.0
2740     :param password: password to connect with, overriding defaults
2741         .. versionadded:: 2019.2.0
2742     CLI Example:
2743     .. code-block:: bash
2744         salt '*' virt.get_macs &lt;domain&gt;
2745     """
2746     doc = ElementTree.fromstring(get_xml(vm_, **kwargs))
2747     return [node.get("address") for node in doc.findall("devices/interface/mac")]
2748 def get_graphics(vm_, **kwargs):
2749     """
2750     Returns the information on vnc for a given vm
2751     :param vm_: name of the domain
2752     :param connection: libvirt connection URI, overriding defaults
2753         .. versionadded:: 2019.2.0
2754     :param username: username to connect with, overriding defaults
2755         .. versionadded:: 2019.2.0
2756     :param password: password to connect with, overriding defaults
2757         .. versionadded:: 2019.2.0
2758     CLI Example:
2759     .. code-block:: bash
2760         salt '*' virt.get_graphics &lt;domain&gt;
2761     """
2762     conn = __get_conn(**kwargs)
2763     graphics = _get_graphics(_get_domain(conn, vm_))
2764     conn.close()
2765     return graphics
2766 def get_loader(vm_, **kwargs):
2767     """
2768     Returns the information on the loader for a given vm
2769     :param vm_: name of the domain
2770     :param connection: libvirt connection URI, overriding defaults
2771     :param username: username to connect with, overriding defaults
2772     :param password: password to connect with, overriding defaults
2773     CLI Example:
2774     .. code-block:: bash
2775         salt '*' virt.get_loader &lt;domain&gt;
2776     .. versionadded:: 2019.2.0
2777     """
2778     conn = __get_conn(**kwargs)
2779     try:
2780         loader = _get_loader(_get_domain(conn, vm_))
2781         return loader
2782     finally:
2783         conn.close()
2784 def get_disks(vm_, **kwargs):
2785     """
2786     Return the disks of a named vm
2787     :param vm_: name of the domain
2788     :param connection: libvirt connection URI, overriding defaults
2789         .. versionadded:: 2019.2.0
2790     :param username: username to connect with, overriding defaults
2791         .. versionadded:: 2019.2.0
2792     :param password: password to connect with, overriding defaults
2793         .. versionadded:: 2019.2.0
2794     CLI Example:
2795     .. code-block:: bash
2796         salt '*' virt.get_disks &lt;domain&gt;
2797     """
2798     conn = __get_conn(**kwargs)
2799     disks = _get_disks(conn, _get_domain(conn, vm_))
2800     conn.close()
2801     return disks
2802 def setmem(vm_, memory, config=False, **kwargs):
2803     """
2804     Changes the amount of memory allocated to VM. The VM must be shutdown
2805     for this to work.
2806     :param vm_: name of the domain
2807     :param memory: memory amount to set in MB
2808     :param config: if True then libvirt will be asked to modify the config as well
2809     :param connection: libvirt connection URI, overriding defaults
2810         .. versionadded:: 2019.2.0
2811     :param username: username to connect with, overriding defaults
2812         .. versionadded:: 2019.2.0
2813     :param password: password to connect with, overriding defaults
2814         .. versionadded:: 2019.2.0
2815     CLI Example:
2816     .. code-block:: bash
2817         salt '*' virt.setmem &lt;domain&gt; &lt;size&gt;
2818         salt '*' virt.setmem my_domain 768
2819     """
2820     conn = __get_conn(**kwargs)
2821     dom = _get_domain(conn, vm_)
2822     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
2823         return False
2824     flags = libvirt.VIR_DOMAIN_MEM_MAXIMUM
2825     if config:
2826         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
2827     ret1 = dom.setMemoryFlags(memory * 1024, flags)
2828     ret2 = dom.setMemoryFlags(memory * 1024, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
2829     conn.close()
2830     return ret1 == ret2 == 0
2831 def setvcpus(vm_, vcpus, config=False, **kwargs):
2832     """
2833     Changes the amount of vcpus allocated to VM. The VM must be shutdown
2834     for this to work.
2835     If config is True then we ask libvirt to modify the config as well
2836     :param vm_: name of the domain
2837     :param vcpus: integer representing the number of CPUs to be assigned
2838     :param config: if True then libvirt will be asked to modify the config as well
2839     :param connection: libvirt connection URI, overriding defaults
2840         .. versionadded:: 2019.2.0
2841     :param username: username to connect with, overriding defaults
2842         .. versionadded:: 2019.2.0
2843     :param password: password to connect with, overriding defaults
2844         .. versionadded:: 2019.2.0
2845     CLI Example:
2846     .. code-block:: bash
2847         salt '*' virt.setvcpus &lt;domain&gt; &lt;amount&gt;
2848         salt '*' virt.setvcpus my_domain 4
2849     """
2850     conn = __get_conn(**kwargs)
2851     dom = _get_domain(conn, vm_)
2852     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
2853         return False
2854     flags = libvirt.VIR_DOMAIN_VCPU_MAXIMUM
2855     if config:
2856         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
2857     ret1 = dom.setVcpusFlags(vcpus, flags)
2858     ret2 = dom.setVcpusFlags(vcpus, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
2859     conn.close()
2860     return ret1 == ret2 == 0
2861 def _freemem(conn):
2862     """
2863     Internal variant of freemem taking a libvirt connection as parameter
2864     """
2865     mem = conn.getInfo()[1]
2866     mem -= 256
2867     for dom in _get_domain(conn, iterable=True):
2868         if dom.ID() &gt; 0:
2869             mem -= dom.info()[2] / 1024
2870     return mem
2871 def freemem(**kwargs):
2872     """
2873     Return an int representing the amount of memory (in MB) that has not
2874     been given to virtual machines on this node
2875     :param connection: libvirt connection URI, overriding defaults
2876         .. versionadded:: 2019.2.0
2877     :param username: username to connect with, overriding defaults
2878         .. versionadded:: 2019.2.0
2879     :param password: password to connect with, overriding defaults
2880         .. versionadded:: 2019.2.0
2881     CLI Example:
2882     .. code-block:: bash
2883         salt '*' virt.freemem
2884     """
2885     conn = __get_conn(**kwargs)
2886     mem = _freemem(conn)
2887     conn.close()
2888     return mem
2889 def _freecpu(conn):
2890     """
2891     Internal variant of freecpu taking a libvirt connection as parameter
2892     """
2893     cpus = conn.getInfo()[2]
2894     for dom in _get_domain(conn, iterable=True):
2895         if dom.ID() &gt; 0:
2896             cpus -= dom.info()[3]
2897     return cpus
2898 def freecpu(**kwargs):
2899     """
2900     Return an int representing the number of unallocated cpus on this
2901     hypervisor
2902     :param connection: libvirt connection URI, overriding defaults
2903         .. versionadded:: 2019.2.0
2904     :param username: username to connect with, overriding defaults
2905         .. versionadded:: 2019.2.0
2906     :param password: password to connect with, overriding defaults
2907         .. versionadded:: 2019.2.0
2908     CLI Example:
2909     .. code-block:: bash
2910         salt '*' virt.freecpu
2911     """
2912     conn = __get_conn(**kwargs)
2913     cpus = _freecpu(conn)
2914     conn.close()
2915     return cpus
2916 def full_info(**kwargs):
2917     """
2918     Return the node_info, vm_info and freemem
2919     :param connection: libvirt connection URI, overriding defaults
2920         .. versionadded:: 2019.2.0
2921     :param username: username to connect with, overriding defaults
2922         .. versionadded:: 2019.2.0
2923     :param password: password to connect with, overriding defaults
2924         .. versionadded:: 2019.2.0
2925     CLI Example:
2926     .. code-block:: bash
2927         salt '*' virt.full_info
2928     """
2929     conn = __get_conn(**kwargs)
2930     info = {
2931         "freecpu": _freecpu(conn),
2932         "freemem": _freemem(conn),
2933         "node_info": _node_info(conn),
2934         "vm_info": vm_info(),
2935     }
2936     conn.close()
2937     return info
2938 def get_xml(vm_, **kwargs):
2939     """
2940     Returns the XML for a given vm
2941     :param vm_: domain name
2942     :param connection: libvirt connection URI, overriding defaults
2943         .. versionadded:: 2019.2.0
2944     :param username: username to connect with, overriding defaults
2945         .. versionadded:: 2019.2.0
2946     :param password: password to connect with, overriding defaults
2947         .. versionadded:: 2019.2.0
2948     CLI Example:
2949     .. code-block:: bash
2950         salt '*' virt.get_xml &lt;domain&gt;
2951     """
2952     conn = __get_conn(**kwargs)
2953     xml_desc = (
2954         vm_.XMLDesc(0)
2955         if isinstance(vm_, libvirt.virDomain)
2956         else _get_domain(conn, vm_).XMLDesc(0)
2957     )
2958     conn.close()
2959     return xml_desc
2960 def get_profiles(hypervisor=None, **kwargs):
2961     """
2962     Return the virt profiles for hypervisor.
2963     Currently there are profiles for:
2964     - nic
2965     - disk
2966     :param hypervisor: override the default machine type.
2967     :param connection: libvirt connection URI, overriding defaults
2968         .. versionadded:: 2019.2.0
2969     :param username: username to connect with, overriding defaults
2970         .. versionadded:: 2019.2.0
2971     :param password: password to connect with, overriding defaults
2972         .. versionadded:: 2019.2.0
2973     CLI Example:
2974     .. code-block:: bash
2975         salt '*' virt.get_profiles
2976         salt '*' virt.get_profiles hypervisor=vmware
2977     """
2978     conn = __get_conn(**kwargs)
2979     caps = _capabilities(conn)
2980     hypervisors = sorted(
2981         {
2982             x
2983             for y in [guest["arch"]["domains"].keys() for guest in caps["guests"]]
2984             for x in y
2985         }
2986     )
2987     if len(hypervisors) == 0:
2988         raise SaltInvocationError("No supported hypervisors were found")
2989     if not hypervisor:
2990         hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
2991     ret = {
2992         "disk": {"default": _disk_profile(conn, "default", hypervisor, [], None)},
2993         "nic": {"default": _nic_profile("default", hypervisor)},
2994     }
2995     virtconf = __salt__["config.get"]("virt", {})
2996     for profile in virtconf.get("disk", []):
2997         ret["disk"][profile] = _disk_profile(conn, profile, hypervisor, [], None)
2998     for profile in virtconf.get("nic", []):
2999         ret["nic"][profile] = _nic_profile(profile, hypervisor)
3000     return ret
3001 def shutdown(vm_, **kwargs):
3002     """
3003     Send a soft shutdown signal to the named vm
3004     :param vm_: domain name
3005     :param connection: libvirt connection URI, overriding defaults
3006         .. versionadded:: 2019.2.0
3007     :param username: username to connect with, overriding defaults
3008         .. versionadded:: 2019.2.0
3009     :param password: password to connect with, overriding defaults
3010         .. versionadded:: 2019.2.0
3011     CLI Example:
3012     .. code-block:: bash
3013         salt '*' virt.shutdown &lt;domain&gt;
3014     """
3015     conn = __get_conn(**kwargs)
3016     dom = _get_domain(conn, vm_)
3017     ret = dom.shutdown() == 0
3018     conn.close()
3019     return ret
3020 def pause(vm_, **kwargs):
3021     """
3022     Pause the named vm
3023     :param vm_: domain name
3024     :param connection: libvirt connection URI, overriding defaults
3025         .. versionadded:: 2019.2.0
3026     :param username: username to connect with, overriding defaults
3027         .. versionadded:: 2019.2.0
3028     :param password: password to connect with, overriding defaults
3029         .. versionadded:: 2019.2.0
3030     CLI Example:
3031     .. code-block:: bash
3032         salt '*' virt.pause &lt;domain&gt;
3033     """
3034     conn = __get_conn(**kwargs)
3035     dom = _get_domain(conn, vm_)
3036     ret = dom.suspend() == 0
3037     conn.close()
3038     return ret
3039 def resume(vm_, **kwargs):
3040     """
3041     Resume the named vm
3042     :param vm_: domain name
3043     :param connection: libvirt connection URI, overriding defaults
3044         .. versionadded:: 2019.2.0
3045     :param username: username to connect with, overriding defaults
3046         .. versionadded:: 2019.2.0
3047     :param password: password to connect with, overriding defaults
3048         .. versionadded:: 2019.2.0
3049     CLI Example:
3050     .. code-block:: bash
3051         salt '*' virt.resume &lt;domain&gt;
3052     """
3053     conn = __get_conn(**kwargs)
3054     dom = _get_domain(conn, vm_)
3055     ret = dom.resume() == 0
3056     conn.close()
3057     return ret
3058 def start(name, **kwargs):
3059     """
3060     Start a defined domain
3061     :param vm_: domain name
3062     :param connection: libvirt connection URI, overriding defaults
3063         .. versionadded:: 2019.2.0
3064     :param username: username to connect with, overriding defaults
3065         .. versionadded:: 2019.2.0
3066     :param password: password to connect with, overriding defaults
3067         .. versionadded:: 2019.2.0
3068     CLI Example:
3069     .. code-block:: bash
3070         salt '*' virt.start &lt;domain&gt;
3071     """
3072     conn = __get_conn(**kwargs)
3073     ret = _get_domain(conn, name).create() == 0
3074     conn.close()
3075     return ret
3076 def stop(name, **kwargs):
3077     """
3078     Hard power down the virtual machine, this is equivalent to pulling the power.
3079     :param vm_: domain name
3080     :param connection: libvirt connection URI, overriding defaults
3081         .. versionadded:: 2019.2.0
3082     :param username: username to connect with, overriding defaults
3083         .. versionadded:: 2019.2.0
3084     :param password: password to connect with, overriding defaults
3085         .. versionadded:: 2019.2.0
3086     CLI Example:
3087     .. code-block:: bash
3088         salt '*' virt.stop &lt;domain&gt;
3089     """
3090     conn = __get_conn(**kwargs)
3091     ret = _get_domain(conn, name).destroy() == 0
3092     conn.close()
3093     return ret
3094 def reboot(name, **kwargs):
3095     """
3096     Reboot a domain via ACPI request
3097     :param vm_: domain name
3098     :param connection: libvirt connection URI, overriding defaults
3099         .. versionadded:: 2019.2.0
3100     :param username: username to connect with, overriding defaults
3101         .. versionadded:: 2019.2.0
3102     :param password: password to connect with, overriding defaults
3103         .. versionadded:: 2019.2.0
3104     CLI Example:
3105     .. code-block:: bash
3106         salt '*' virt.reboot &lt;domain&gt;
3107     """
3108     conn = __get_conn(**kwargs)
3109     ret = _get_domain(conn, name).reboot(libvirt.VIR_DOMAIN_REBOOT_DEFAULT) == 0
3110     conn.close()
3111     return ret
3112 def reset(vm_, **kwargs):
3113     """
3114     Reset a VM by emulating the reset button on a physical machine
3115     :param vm_: domain name
3116     :param connection: libvirt connection URI, overriding defaults
3117         .. versionadded:: 2019.2.0
3118     :param username: username to connect with, overriding defaults
3119         .. versionadded:: 2019.2.0
3120     :param password: password to connect with, overriding defaults
3121         .. versionadded:: 2019.2.0
3122     CLI Example:
3123     .. code-block:: bash
3124         salt '*' virt.reset &lt;domain&gt;
3125     """
3126     conn = __get_conn(**kwargs)
3127     dom = _get_domain(conn, vm_)
3128     ret = dom.reset(0) == 0
3129     conn.close()
3130     return ret
3131 def ctrl_alt_del(vm_, **kwargs):
3132     """
3133     Sends CTRL+ALT+DEL to a VM
3134     :param vm_: domain name
3135     :param connection: libvirt connection URI, overriding defaults
3136         .. versionadded:: 2019.2.0
3137     :param username: username to connect with, overriding defaults
3138         .. versionadded:: 2019.2.0
3139     :param password: password to connect with, overriding defaults
3140         .. versionadded:: 2019.2.0
3141     CLI Example:
3142     .. code-block:: bash
3143         salt '*' virt.ctrl_alt_del &lt;domain&gt;
3144     """
3145     conn = __get_conn(**kwargs)
3146     dom = _get_domain(conn, vm_)
3147     ret = dom.sendKey(0, 0, [29, 56, 111], 3, 0) == 0
3148     conn.close()
3149     return ret
3150 def create_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
3151     """
3152     Start a transient domain based on the XML passed to the function
3153     :param xml: libvirt XML definition of the domain
3154     :param connection: libvirt connection URI, overriding defaults
3155         .. versionadded:: 2019.2.0
3156     :param username: username to connect with, overriding defaults
3157         .. versionadded:: 2019.2.0
3158     :param password: password to connect with, overriding defaults
3159         .. versionadded:: 2019.2.0
3160     CLI Example:
3161     .. code-block:: bash
3162         salt '*' virt.create_xml_str &lt;XML in string format&gt;
3163     """
3164     conn = __get_conn(**kwargs)
3165     ret = conn.createXML(xml, 0) is not None
3166     conn.close()
3167     return ret
3168 def create_xml_path(path, **kwargs):
3169     """
3170     Start a transient domain based on the XML-file path passed to the function
3171     :param path: path to a file containing the libvirt XML definition of the domain
3172     :param connection: libvirt connection URI, overriding defaults
3173         .. versionadded:: 2019.2.0
3174     :param username: username to connect with, overriding defaults
3175         .. versionadded:: 2019.2.0
3176     :param password: password to connect with, overriding defaults
3177         .. versionadded:: 2019.2.0
3178     CLI Example:
3179     .. code-block:: bash
3180         salt '*' virt.create_xml_path &lt;path to XML file on the node&gt;
3181     """
3182     try:
3183         with salt.utils.files.fopen(path, "r") as fp_:
3184             return create_xml_str(
3185                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
3186             )
3187     except OSError:
3188         return False
3189 def define_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
3190     """
3191     Define a persistent domain based on the XML passed to the function
3192     :param xml: libvirt XML definition of the domain
3193     :param connection: libvirt connection URI, overriding defaults
3194         .. versionadded:: 2019.2.0
3195     :param username: username to connect with, overriding defaults
3196         .. versionadded:: 2019.2.0
3197     :param password: password to connect with, overriding defaults
3198         .. versionadded:: 2019.2.0
3199     CLI Example:
3200     .. code-block:: bash
3201         salt '*' virt.define_xml_str &lt;XML in string format&gt;
3202     """
3203     conn = __get_conn(**kwargs)
3204     ret = conn.defineXML(xml) is not None
3205     conn.close()
3206     return ret
3207 def define_xml_path(path, **kwargs):
3208     """
3209     Define a persistent domain based on the XML-file path passed to the function
3210     :param path: path to a file containing the libvirt XML definition of the domain
3211     :param connection: libvirt connection URI, overriding defaults
3212         .. versionadded:: 2019.2.0
3213     :param username: username to connect with, overriding defaults
3214         .. versionadded:: 2019.2.0
3215     :param password: password to connect with, overriding defaults
3216         .. versionadded:: 2019.2.0
3217     CLI Example:
3218     .. code-block:: bash
3219         salt '*' virt.define_xml_path &lt;path to XML file on the node&gt;
3220     """
3221     try:
3222         with salt.utils.files.fopen(path, "r") as fp_:
3223             return define_xml_str(
3224                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
3225             )
3226     except OSError:
3227         return False
3228 def _define_vol_xml_str(conn, xml, pool=None):  # pylint: disable=redefined-outer-name
3229     """
3230     Same function than define_vml_xml_str but using an already opened libvirt connection
3231     """
3232     default_pool = "default" if conn.getType() != "ESX" else "0"
3233     poolname = (
3234         pool if pool else __salt__["config.get"]("virt:storagepool", default_pool)
3235     )
3236     pool = conn.storagePoolLookupByName(str(poolname))
3237     ret = pool.createXML(xml, 0) is not None
3238     return ret
3239 def define_vol_xml_str(
3240     xml, pool=None, **kwargs
3241 ):  # pylint: disable=redefined-outer-name
3242     """
3243     Define a volume based on the XML passed to the function
3244     :param xml: libvirt XML definition of the storage volume
3245     :param pool:
3246         storage pool name to define the volume in.
3247         If defined, this parameter will override the configuration setting.
3248         .. versionadded:: 3001
3249     :param connection: libvirt connection URI, overriding defaults
3250         .. versionadded:: 2019.2.0
3251     :param username: username to connect with, overriding defaults
3252         .. versionadded:: 2019.2.0
3253     :param password: password to connect with, overriding defaults
3254         .. versionadded:: 2019.2.0
3255     CLI Example:
3256     .. code-block:: bash
3257         salt '*' virt.define_vol_xml_str &lt;XML in string format&gt;
3258     The storage pool where the disk image will be defined is ``default``
3259     unless changed with the pool parameter or a configuration like this:
3260     .. code-block:: yaml
3261         virt:
3262             storagepool: mine
3263     """
3264     conn = __get_conn(**kwargs)
3265     ret = False
3266     try:
3267         ret = _define_vol_xml_str(conn, xml, pool=pool)
3268     except libvirtError as err:
3269         raise CommandExecutionError(err.get_error_message())
3270     finally:
3271         conn.close()
3272     return ret
3273 def define_vol_xml_path(path, pool=None, **kwargs):
3274     """
3275     Define a volume based on the XML-file path passed to the function
3276     :param path: path to a file containing the libvirt XML definition of the volume
3277     :param pool:
3278         storage pool name to define the volume in.
3279         If defined, this parameter will override the configuration setting.
3280         .. versionadded:: 3001
3281     :param connection: libvirt connection URI, overriding defaults
3282         .. versionadded:: 2019.2.0
3283     :param username: username to connect with, overriding defaults
3284         .. versionadded:: 2019.2.0
3285     :param password: password to connect with, overriding defaults
3286         .. versionadded:: 2019.2.0
3287     CLI Example:
3288     .. code-block:: bash
3289         salt '*' virt.define_vol_xml_path &lt;path to XML file on the node&gt;
3290     """
3291     try:
3292         with salt.utils.files.fopen(path, "r") as fp_:
3293             return define_vol_xml_str(
3294                 salt.utils.stringutils.to_unicode(fp_.read()), pool=pool, **kwargs
3295             )
3296     except OSError:
3297         return False
3298 def migrate(vm_, target, **kwargs):
3299     """
3300     Shared storage migration
3301     :param vm_: domain name
3302     :param target: target libvirt URI or host name
3303     :param kwargs:
3304         - live:            Use live migration. Default value is True.
3305         - persistent:      Leave the domain persistent on destination host.
3306                            Default value is True.
3307         - undefinesource:  Undefine the domain on the source host.
3308                            Default value is True.
3309         - offline:         If set to True it will migrate the domain definition
3310                            without starting the domain on destination and without
3311                            stopping it on source host. Default value is False.
3312         - max_bandwidth:   The maximum bandwidth (in MiB/s) that will be used.
3313         - max_downtime:    Set maximum tolerable downtime for live-migration.
3314                            The value represents a number of milliseconds the guest
3315                            is allowed to be down at the end of live migration.
3316         - parallel_connections: Specify a number of parallel network connections
3317                            to be used to send memory pages to the destination host.
3318         - compressed:      Activate compression.
3319         - comp_methods:    A comma-separated list of compression methods. Supported
3320                            methods are "mt" and "xbzrle" and can be  used in any
3321                            combination. QEMU defaults to "xbzrle".
3322         - comp_mt_level:   Set compression level. Values are in range from 0 to 9,
3323                            where 1 is maximum speed and 9 is  maximum compression.
3324         - comp_mt_threads: Set number of compress threads on source host.
3325         - comp_mt_dthreads: Set number of decompress threads on target host.
3326         - comp_xbzrle_cache: Set the size of page cache for xbzrle compression in bytes.
3327         - copy_storage:    Migrate non-shared storage. It must be one of the following
3328                            values: all (full disk copy) or incremental (Incremental copy)
3329         - postcopy:        Enable the use of post-copy migration.
3330         - postcopy_bandwidth: The maximum bandwidth allowed in post-copy phase. (MiB/s)
3331         - username:        Username to connect with target host
3332         - password:        Password to connect with target host
3333         .. versionadded:: 3002
3334     CLI Example:
3335     .. code-block:: bash
3336         salt '*' virt.migrate &lt;domain&gt; &lt;target hypervisor URI&gt;
3337         salt src virt.migrate guest qemu+ssh://dst/system
3338         salt src virt.migrate guest qemu+tls://dst/system
3339         salt src virt.migrate guest qemu+tcp://dst/system
3340     A tunnel data migration can be performed by setting this in the
3341     configuration:
3342     .. code-block:: yaml
3343         virt:
3344             tunnel: True
3345     For more details on tunnelled data migrations, report to
3346     https://libvirt.org/migration.html#transporttunnel
3347     """
3348     conn = __get_conn()
3349     dom = _get_domain(conn, vm_)
3350     if not urllib.parse.urlparse(target).scheme:
3351         proto = "qemu"
3352         dst_uri = "{}://{}/system".format(proto, target)
3353     else:
3354         dst_uri = target
3355     ret = _migrate(dom, dst_uri, **kwargs)
3356     conn.close()
3357     return ret
3358 def migrate_start_postcopy(vm_):
3359     """
3360     Starts post-copy migration. This function has to be called
3361     while live migration is in progress and it has been initiated
3362     with the `postcopy=True` option.
3363     CLI Example:
3364     .. code-block:: bash
3365         salt '*' virt.migrate_start_postcopy &lt;domain&gt;
3366     """
3367     conn = __get_conn()
3368     dom = _get_domain(conn, vm_)
3369     try:
3370         dom.migrateStartPostCopy()
3371     except libvirt.libvirtError as err:
3372         conn.close()
3373         raise CommandExecutionError(err.get_error_message())
3374     conn.close()
3375 def seed_non_shared_migrate(disks, force=False):
3376     """
3377     Non shared migration requires that the disks be present on the migration
3378     destination, pass the disks information via this function, to the
3379     migration destination before executing the migration.
3380     :param disks: the list of disk data as provided by virt.get_disks
3381     :param force: skip checking the compatibility of source and target disk
3382                   images if True. (default: False)
3383     CLI Example:
3384     .. code-block:: bash
3385         salt '*' virt.seed_non_shared_migrate &lt;disks&gt;
3386     """
3387     for _, data in disks.items():
3388         fn_ = data["file"]
3389         form = data["file format"]
3390         size = data["virtual size"].split()[1][1:]
3391         if os.path.isfile(fn_) and not force:
3392             pre = salt.utils.yaml.safe_load(
3393                 subprocess.Popen(
3394                     ["qemu-img", "info", "arch"], stdout=subprocess.PIPE
3395                 ).communicate()[0]
3396             )
3397             if (
3398                 pre["file format"] != data["file format"]
3399                 and pre["virtual size"] != data["virtual size"]
3400             ):
3401                 return False
3402         if not os.path.isdir(os.path.dirname(fn_)):
3403             os.makedirs(os.path.dirname(fn_))
3404         if os.path.isfile(fn_):
3405             os.remove(fn_)
3406         subprocess.call(["qemu-img", "create", "-f", form, fn_, size])
3407         creds = _libvirt_creds()
3408         subprocess.call(["chown", "{user}:{group}".format(**creds), fn_])
3409     return True
3410 def set_autostart(vm_, state="on", **kwargs):
3411     """
3412     Set the autostart flag on a VM so that the VM will start with the host
3413     system on reboot.
3414     :param vm_: domain name
3415     :param state: 'on' to auto start the pool, anything else to mark the
3416                   pool not to be started when the host boots
3417     :param connection: libvirt connection URI, overriding defaults
3418         .. versionadded:: 2019.2.0
3419     :param username: username to connect with, overriding defaults
3420         .. versionadded:: 2019.2.0
3421     :param password: password to connect with, overriding defaults
3422         .. versionadded:: 2019.2.0
3423     CLI Example:
3424     .. code-block:: bash
3425         salt "*" virt.set_autostart &lt;domain&gt; &lt;on | off&gt;
3426     """
3427     conn = __get_conn(**kwargs)
3428     dom = _get_domain(conn, vm_)
3429     ret = False
3430     if state == "on":
3431         ret = dom.setAutostart(1) == 0
3432     elif state == "off":
3433         ret = dom.setAutostart(0) == 0
3434     conn.close()
3435     return ret
3436 def undefine(vm_, **kwargs):
3437     """
3438     Remove a defined vm, this does not purge the virtual machine image, and
3439     this only works if the vm is powered down
3440     :param vm_: domain name
3441     :param connection: libvirt connection URI, overriding defaults
3442         .. versionadded:: 2019.2.0
3443     :param username: username to connect with, overriding defaults
3444         .. versionadded:: 2019.2.0
3445     :param password: password to connect with, overriding defaults
3446         .. versionadded:: 2019.2.0
3447     CLI Example:
3448     .. code-block:: bash
3449         salt '*' virt.undefine &lt;domain&gt;
3450     """
3451     conn = __get_conn(**kwargs)
3452     dom = _get_domain(conn, vm_)
3453     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
3454         ret = dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM) == 0
3455     else:
3456         ret = dom.undefine() == 0
3457     conn.close()
3458     return ret
3459 def purge(vm_, dirs=False, removables=False, **kwargs):
3460     """
3461     Recursively destroy and delete a persistent virtual machine, pass True for
3462     dir's to also delete the directories containing the virtual machine disk
3463     images - USE WITH EXTREME CAUTION!
3464     :param vm_: domain name
3465     :param dirs: pass True to remove containing directories
3466     :param removables: pass True to remove removable devices
3467         .. versionadded:: 2019.2.0
3468     :param connection: libvirt connection URI, overriding defaults
3469         .. versionadded:: 2019.2.0
3470     :param username: username to connect with, overriding defaults
3471         .. versionadded:: 2019.2.0
3472     :param password: password to connect with, overriding defaults
3473         .. versionadded:: 2019.2.0
3474     CLI Example:
3475     .. code-block:: bash
3476         salt '*' virt.purge &lt;domain&gt;
3477     """
3478     conn = __get_conn(**kwargs)
3479     dom = _get_domain(conn, vm_)
3480     disks = _get_disks(conn, dom)
3481     if (
3482         VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown"
3483         and dom.destroy() != 0
3484     ):
3485         return False
3486     directories = set()
3487     for disk in disks:
3488         if not removables and disks[disk]["type"] in ["cdrom", "floppy"]:
3489             continue
3490         if disks[disk].get("zfs", False):
3491             time.sleep(3)
3492             fs_name = disks[disk]["file"][len("/dev/zvol/") :]
3493             log.info("Destroying VM ZFS volume %s", fs_name)
3494             __salt__["zfs.destroy"](name=fs_name, force=True)
3495         elif os.path.exists(disks[disk]["file"]):
3496             os.remove(disks[disk]["file"])
3497             directories.add(os.path.dirname(disks[disk]["file"]))
3498         else:
3499             matcher = re.match("^(?P&lt;pool&gt;[^/]+)/(?P&lt;volume&gt;.*)$", disks[disk]["file"])
3500             if matcher:
3501                 pool_name = matcher.group("pool")
3502                 pool = None
3503                 if pool_name in conn.listStoragePools():
3504                     pool = conn.storagePoolLookupByName(pool_name)
3505                 if pool and matcher.group("volume") in pool.listVolumes():
3506                     volume = pool.storageVolLookupByName(matcher.group("volume"))
3507                     volume.delete()
3508     if dirs:
3509         for dir_ in directories:
3510             shutil.rmtree(dir_)
3511     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
3512         try:
3513             dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM)
3514         except Exception:  # pylint: disable=broad-except
3515             dom.undefine()
3516     else:
3517         dom.undefine()
3518     conn.close()
3519     return True
3520 def virt_type():
3521     """
3522     Returns the virtual machine type as a string
3523     CLI Example:
3524     .. code-block:: bash
3525         salt '*' virt.virt_type
3526     """
3527     return __grains__["virtual"]
3528 def _is_kvm_hyper():
3529     """
3530     Returns a bool whether or not this node is a KVM hypervisor
3531     """
3532     if not os.path.exists("/dev/kvm"):
3533         return False
3534     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
3535 def _is_xen_hyper():
3536     """
3537     Returns a bool whether or not this node is a XEN hypervisor
3538     """
3539     try:
3540         if __grains__["virtual_subtype"] != "Xen Dom0":
3541             return False
3542     except KeyError:
3543         return False
3544     try:
3545         with salt.utils.files.fopen("/proc/modules") as fp_:
3546             if "xen_" not in salt.utils.stringutils.to_unicode(fp_.read()):
3547                 return False
3548     except OSError:
3549         return False
3550     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
3551 def get_hypervisor():
3552     """
3553     Returns the name of the hypervisor running on this node or ``None``.
3554     Detected hypervisors:
3555     - kvm
3556     - xen
3557     - bhyve
3558     CLI Example:
3559     .. code-block:: bash
3560         salt '*' virt.get_hypervisor
3561     .. versionadded:: 2019.2.0
3562         the function and the ``kvm``, ``xen`` and ``bhyve`` hypervisors support
3563     """
3564     hypervisors = ["kvm", "xen", "bhyve"]
3565     result = [
3566         hyper
3567         for hyper in hypervisors
3568         if getattr(sys.modules[__name__], "_is_{}_hyper".format(hyper))()
3569     ]
3570     return result[0] if result else None
3571 def _is_bhyve_hyper():
3572     sysctl_cmd = "sysctl hw.vmm.create"
3573     vmm_enabled = False
3574     try:
3575         stdout = subprocess.Popen(
3576             ["sysctl", "hw.vmm.create"], stdout=subprocess.PIPE
3577         ).communicate()[0]
3578         vmm_enabled = len(salt.utils.stringutils.to_str(stdout).split('"')[1]) != 0
3579     except IndexError:
3580         pass
3581     return vmm_enabled
3582 def is_hyper():
3583     """
3584     Returns a bool whether or not this node is a hypervisor of any kind
3585     CLI Example:
3586     .. code-block:: bash
3587         salt '*' virt.is_hyper
3588     """
3589     if HAS_LIBVIRT:
3590         return _is_xen_hyper() or _is_kvm_hyper() or _is_bhyve_hyper()
3591     return False
3592 def vm_cputime(vm_=None, **kwargs):
3593     """
3594     Return cputime used by the vms on this hyper in a
3595     list of dicts:
3596     :param vm_: domain name
3597     :param connection: libvirt connection URI, overriding defaults
3598         .. versionadded:: 2019.2.0
3599     :param username: username to connect with, overriding defaults
3600         .. versionadded:: 2019.2.0
3601     :param password: password to connect with, overriding defaults
3602         .. versionadded:: 2019.2.0
3603     .. code-block:: python
3604         [
3605             'your-vm': {
3606                 'cputime' &lt;int&gt;
3607                 'cputime_percent' &lt;int&gt;
3608                 },
3609             ...
3610             ]
3611     If you pass a VM name in as an argument then it will return info
3612     for just the named VM, otherwise it will return all VMs.
3613     CLI Example:
3614     .. code-block:: bash
3615         salt '*' virt.vm_cputime
3616     """
3617     conn = __get_conn(**kwargs)
3618     host_cpus = conn.getInfo()[2]
3619     def _info(dom):
3620         """
3621         Compute cputime info of a domain
3622         """
3623         raw = dom.info()
3624         vcpus = int(raw[3])
3625         cputime = int(raw[4])
3626         cputime_percent = 0
3627         if cputime:
3628             cputime_percent = (1.0e-7 * cputime / host_cpus) / vcpus
3629         return {
3630             "cputime": int(raw[4]),
3631             "cputime_percent": int("{:.0f}".format(cputime_percent)),
3632         }
3633     info = {}
3634     if vm_:
3635         info[vm_] = _info(_get_domain(conn, vm_))
3636     else:
3637         for domain in _get_domain(conn, iterable=True):
3638             info[domain.name()] = _info(domain)
3639     conn.close()
3640     return info
3641 def vm_netstats(vm_=None, **kwargs):
3642     """
3643     Return combined network counters used by the vms on this hyper in a
3644     list of dicts:
3645     :param vm_: domain name
3646     :param connection: libvirt connection URI, overriding defaults
3647         .. versionadded:: 2019.2.0
3648     :param username: username to connect with, overriding defaults
3649         .. versionadded:: 2019.2.0
3650     :param password: password to connect with, overriding defaults
3651         .. versionadded:: 2019.2.0
3652     .. code-block:: python
3653         [
3654             'your-vm': {
3655                 'rx_bytes'   : 0,
3656                 'rx_packets' : 0,
3657                 'rx_errs'    : 0,
3658                 'rx_drop'    : 0,
3659                 'tx_bytes'   : 0,
3660                 'tx_packets' : 0,
3661                 'tx_errs'    : 0,
3662                 'tx_drop'    : 0
3663                 },
3664             ...
3665             ]
3666     If you pass a VM name in as an argument then it will return info
3667     for just the named VM, otherwise it will return all VMs.
3668     CLI Example:
3669     .. code-block:: bash
3670         salt '*' virt.vm_netstats
3671     """
3672     def _info(dom):
3673         """
3674         Compute network stats of a domain
3675         """
3676         nics = _get_nics(dom)
3677         ret = {
3678             "rx_bytes": 0,
3679             "rx_packets": 0,
3680             "rx_errs": 0,
3681             "rx_drop": 0,
3682             "tx_bytes": 0,
3683             "tx_packets": 0,
3684             "tx_errs": 0,
3685             "tx_drop": 0,
3686         }
3687         for attrs in nics.values():
3688             if "target" in attrs:
3689                 dev = attrs["target"]
3690                 stats = dom.interfaceStats(dev)
3691                 ret["rx_bytes"] += stats[0]
3692                 ret["rx_packets"] += stats[1]
3693                 ret["rx_errs"] += stats[2]
3694                 ret["rx_drop"] += stats[3]
3695                 ret["tx_bytes"] += stats[4]
3696                 ret["tx_packets"] += stats[5]
3697                 ret["tx_errs"] += stats[6]
3698                 ret["tx_drop"] += stats[7]
3699         return ret
3700     info = {}
3701     conn = __get_conn(**kwargs)
3702     if vm_:
3703         info[vm_] = _info(_get_domain(conn, vm_))
3704     else:
3705         for domain in _get_domain(conn, iterable=True):
3706             info[domain.name()] = _info(domain)
3707     conn.close()
3708     return info
3709 def vm_diskstats(vm_=None, **kwargs):
3710     """
3711     Return disk usage counters used by the vms on this hyper in a
3712     list of dicts:
3713     :param vm_: domain name
3714     :param connection: libvirt connection URI, overriding defaults
3715         .. versionadded:: 2019.2.0
3716     :param username: username to connect with, overriding defaults
3717         .. versionadded:: 2019.2.0
3718     :param password: password to connect with, overriding defaults
3719         .. versionadded:: 2019.2.0
3720     .. code-block:: python
3721         [
3722             'your-vm': {
3723                 'rd_req'   : 0,
3724                 'rd_bytes' : 0,
3725                 'wr_req'   : 0,
3726                 'wr_bytes' : 0,
3727                 'errs'     : 0
3728                 },
3729             ...
3730             ]
3731     If you pass a VM name in as an argument then it will return info
3732     for just the named VM, otherwise it will return all VMs.
3733     CLI Example:
3734     .. code-block:: bash
3735         salt '*' virt.vm_blockstats
3736     """
3737     def get_disk_devs(dom):
3738         """
3739         Extract the disk devices names from the domain XML definition
3740         """
3741         doc = ElementTree.fromstring(get_xml(dom, **kwargs))
3742         return [target.get("dev") for target in doc.findall("devices/disk/target")]
3743     def _info(dom):
3744         """
3745         Compute the disk stats of a domain
3746         """
3747         disks = get_disk_devs(dom)
3748         ret = {"rd_req": 0, "rd_bytes": 0, "wr_req": 0, "wr_bytes": 0, "errs": 0}
3749         for disk in disks:
3750             stats = dom.blockStats(disk)
3751             ret["rd_req"] += stats[0]
3752             ret["rd_bytes"] += stats[1]
3753             ret["wr_req"] += stats[2]
3754             ret["wr_bytes"] += stats[3]
3755             ret["errs"] += stats[4]
3756         return ret
3757     info = {}
3758     conn = __get_conn(**kwargs)
3759     if vm_:
3760         info[vm_] = _info(_get_domain(conn, vm_))
3761     else:
3762         for domain in _get_domain(conn, iterable=True, inactive=False):
3763             info[domain.name()] = _info(domain)
3764     conn.close()
3765     return info
3766 def _parse_snapshot_description(vm_snapshot, unix_time=False):
3767     """
3768     Parse XML doc and return a dict with the status values.
3769     :param xmldoc:
3770     :return:
3771     """
3772     ret = dict()
3773     tree = ElementTree.fromstring(vm_snapshot.getXMLDesc())
3774     for node in tree:
3775         if node.tag == "name":
3776             ret["name"] = node.text
3777         elif node.tag == "creationTime":
3778             ret["created"] = (
3779                 datetime.datetime.fromtimestamp(float(node.text)).isoformat(" ")
3780                 if not unix_time
3781                 else float(node.text)
3782             )
3783         elif node.tag == "state":
3784             ret["running"] = node.text == "running"
3785     ret["current"] = vm_snapshot.isCurrent() == 1
3786     return ret
3787 def list_snapshots(domain=None, **kwargs):
3788     """
3789     List available snapshots for certain vm or for all.
3790     :param domain: domain name
3791     :param connection: libvirt connection URI, overriding defaults
3792         .. versionadded:: 2019.2.0
3793     :param username: username to connect with, overriding defaults
3794         .. versionadded:: 2019.2.0
3795     :param password: password to connect with, overriding defaults
3796         .. versionadded:: 2019.2.0
3797     .. versionadded:: 2016.3.0
3798     CLI Example:
3799     .. code-block:: bash
3800         salt '*' virt.list_snapshots
3801         salt '*' virt.list_snapshots &lt;domain&gt;
3802     """
3803     ret = dict()
3804     conn = __get_conn(**kwargs)
3805     for vm_domain in _get_domain(conn, *(domain and [domain] or list()), iterable=True):
3806         ret[vm_domain.name()] = [
3807             _parse_snapshot_description(snap) for snap in vm_domain.listAllSnapshots()
3808         ] or "N/A"
3809     conn.close()
3810     return ret
3811 def snapshot(domain, name=None, suffix=None, **kwargs):
3812     """
3813     Create a snapshot of a VM.
3814     :param domain: domain name
3815     :param name: Name of the snapshot. If the name is omitted, then will be used original domain
3816                  name with ISO 8601 time as a suffix.
3817     :param suffix: Add suffix for the new name. Useful in states, where such snapshots
3818                    can be distinguished from manually created.
3819     :param connection: libvirt connection URI, overriding defaults
3820         .. versionadded:: 2019.2.0
3821     :param username: username to connect with, overriding defaults
3822         .. versionadded:: 2019.2.0
3823     :param password: password to connect with, overriding defaults
3824         .. versionadded:: 2019.2.0
3825     .. versionadded:: 2016.3.0
3826     CLI Example:
3827     .. code-block:: bash
3828         salt '*' virt.snapshot &lt;domain&gt;
3829     """
3830     if name and name.lower() == domain.lower():
3831         raise CommandExecutionError(
3832             "Virtual Machine {name} is already defined. "
3833             "Please choose another name for the snapshot".format(name=name)
3834         )
3835     if not name:
3836         name = "{domain}-{tsnap}".format(
3837             domain=domain, tsnap=time.strftime("%Y%m%d-%H%M%S", time.localtime())
3838         )
3839     if suffix:
3840         name = "{name}-{suffix}".format(name=name, suffix=suffix)
3841     doc = ElementTree.Element("domainsnapshot")
3842     n_name = ElementTree.SubElement(doc, "name")
3843     n_name.text = name
3844     conn = __get_conn(**kwargs)
3845     _get_domain(conn, domain).snapshotCreateXML(xmlutil.element_to_str(doc))
3846     conn.close()
3847     return {"name": name}
3848 def delete_snapshots(name, *names, **kwargs):
3849     """
3850     Delete one or more snapshots of the given VM.
3851     :param name: domain name
3852     :param names: names of the snapshots to remove
3853     :param connection: libvirt connection URI, overriding defaults
3854         .. versionadded:: 2019.2.0
3855     :param username: username to connect with, overriding defaults
3856         .. versionadded:: 2019.2.0
3857     :param password: password to connect with, overriding defaults
3858         .. versionadded:: 2019.2.0
3859     .. versionadded:: 2016.3.0
3860     CLI Example:
3861     .. code-block:: bash
3862         salt '*' virt.delete_snapshots &lt;domain&gt; all=True
3863         salt '*' virt.delete_snapshots &lt;domain&gt; &lt;snapshot&gt;
3864         salt '*' virt.delete_snapshots &lt;domain&gt; &lt;snapshot1&gt; &lt;snapshot2&gt; ...
3865     """
3866     deleted = dict()
3867     conn = __get_conn(**kwargs)
3868     domain = _get_domain(conn, name)
3869     for snap in domain.listAllSnapshots():
3870         if snap.getName() in names or not names:
3871             deleted[snap.getName()] = _parse_snapshot_description(snap)
3872             snap.delete()
3873     conn.close()
3874     available = {
3875         name: [_parse_snapshot_description(snap) for snap in domain.listAllSnapshots()]
3876         or "N/A"
3877     }
3878     return {"available": available, "deleted": deleted}
3879 def revert_snapshot(name, vm_snapshot=None, cleanup=False, **kwargs):
3880     """
3881     Revert snapshot to the previous from current (if available) or to the specific.
3882     :param name: domain name
3883     :param vm_snapshot: name of the snapshot to revert
3884     :param cleanup: Remove all newer than reverted snapshots. Values: True or False (default False).
3885     :param connection: libvirt connection URI, overriding defaults
3886         .. versionadded:: 2019.2.0
3887     :param username: username to connect with, overriding defaults
3888         .. versionadded:: 2019.2.0
3889     :param password: password to connect with, overriding defaults
3890         .. versionadded:: 2019.2.0
3891     .. versionadded:: 2016.3.0
3892     CLI Example:
3893     .. code-block:: bash
3894         salt '*' virt.revert &lt;domain&gt;
3895         salt '*' virt.revert &lt;domain&gt; &lt;snapshot&gt;
3896     """
3897     ret = dict()
3898     conn = __get_conn(**kwargs)
3899     domain = _get_domain(conn, name)
3900     snapshots = domain.listAllSnapshots()
3901     _snapshots = list()
3902     for snap_obj in snapshots:
3903         _snapshots.append(
3904             {
3905                 "idx": _parse_snapshot_description(snap_obj, unix_time=True)["created"],
3906                 "ptr": snap_obj,
3907             }
3908         )
3909     snapshots = [
3910         w_ptr["ptr"]
3911         for w_ptr in sorted(_snapshots, key=lambda item: item["idx"], reverse=True)
3912     ]
3913     del _snapshots
3914     if not snapshots:
3915         conn.close()
3916         raise CommandExecutionError("No snapshots found")
3917     elif len(snapshots) == 1:
3918         conn.close()
3919         raise CommandExecutionError(
3920             "Cannot revert to itself: only one snapshot is available."
3921         )
3922     snap = None
3923     for p_snap in snapshots:
3924         if not vm_snapshot:
3925             if p_snap.isCurrent() and snapshots[snapshots.index(p_snap) + 1 :]:
3926                 snap = snapshots[snapshots.index(p_snap) + 1 :][0]
3927                 break
3928         elif p_snap.getName() == vm_snapshot:
3929             snap = p_snap
3930             break
3931     if not snap:
3932         conn.close()
3933         raise CommandExecutionError(
3934             snapshot
3935             and 'Snapshot "{}" not found'.format(vm_snapshot)
3936             or "No more previous snapshots available"
3937         )
3938     elif snap.isCurrent():
3939         conn.close()
3940         raise CommandExecutionError("Cannot revert to the currently running snapshot.")
3941     domain.revertToSnapshot(snap)
3942     ret["reverted"] = snap.getName()
3943     if cleanup:
3944         delete = list()
3945         for p_snap in snapshots:
3946             if p_snap.getName() != snap.getName():
3947                 delete.append(p_snap.getName())
3948                 p_snap.delete()
3949             else:
3950                 break
3951         ret["deleted"] = delete
3952     else:
3953         ret["deleted"] = "N/A"
3954     conn.close()
3955     return ret
3956 def _caps_add_machine(machines, node):
3957     """
3958     Parse the &lt;machine&gt; element of the host capabilities and add it
3959     to the machines list.
3960     """
3961     maxcpus = node.get("maxCpus")
3962     canonical = node.get("canonical")
3963     name = node.text
3964     alternate_name = ""
3965     if canonical:
3966         alternate_name = name
3967         name = canonical
3968     machine = machines.get(name)
3969     if not machine:
3970         machine = {"alternate_names": []}
3971         if maxcpus:
3972             machine["maxcpus"] = int(maxcpus)
3973         machines[name] = machine
3974     if alternate_name:
3975         machine["alternate_names"].append(alternate_name)
3976 def _parse_caps_guest(guest):
3977     """
3978     Parse the &lt;guest&gt; element of the connection capabilities XML
3979     """
3980     arch_node = guest.find("arch")
3981     result = {
3982         "os_type": guest.find("os_type").text,
3983         "arch": {"name": arch_node.get("name"), "machines": {}, "domains": {}},
3984     }
3985     child = None
3986     for child in arch_node:
3987         if child.tag == "wordsize":
3988             result["arch"]["wordsize"] = int(child.text)
3989         elif child.tag == "emulator":
3990             result["arch"]["emulator"] = child.text
3991         elif child.tag == "machine":
3992             _caps_add_machine(result["arch"]["machines"], child)
3993         elif child.tag == "domain":
3994             domain_type = child.get("type")
3995             domain = {"emulator": None, "machines": {}}
3996             emulator_node = child.find("emulator")
3997             if emulator_node is not None:
3998                 domain["emulator"] = emulator_node.text
3999             for machine in child.findall("machine"):
4000                 _caps_add_machine(domain["machines"], machine)
4001             result["arch"]["domains"][domain_type] = domain
4002     features_nodes = guest.find("features")
4003     if features_nodes is not None and child is not None:
4004         result["features"] = {
4005             child.tag: {
4006                 "toggle": child.get("toggle", "no") == "yes",
4007                 "default": child.get("default", "on") == "on",
4008             }
4009             for child in features_nodes
4010         }
4011     return result
4012 def _parse_caps_cell(cell):
4013     """
4014     Parse the &lt;cell&gt; nodes of the connection capabilities XML output.
4015     """
4016     result = {"id": int(cell.get("id"))}
4017     mem_node = cell.find("memory")
4018     if mem_node is not None:
4019         unit = mem_node.get("unit", "KiB")
4020         memory = mem_node.text
4021         result["memory"] = "{} {}".format(memory, unit)
4022     pages = [
4023         {
4024             "size": "{} {}".format(page.get("size"), page.get("unit", "KiB")),
4025             "available": int(page.text),
4026         }
4027         for page in cell.findall("pages")
4028     ]
4029     if pages:
4030         result["pages"] = pages
4031     distances = {
4032         int(distance.get("id")): int(distance.get("value"))
4033         for distance in cell.findall("distances/sibling")
4034     }
4035     if distances:
4036         result["distances"] = distances
4037     cpus = []
4038     for cpu_node in cell.findall("cpus/cpu"):
4039         cpu = {"id": int(cpu_node.get("id"))}
4040         socket_id = cpu_node.get("socket_id")
4041         if socket_id:
4042             cpu["socket_id"] = int(socket_id)
4043         core_id = cpu_node.get("core_id")
4044         if core_id:
4045             cpu["core_id"] = int(core_id)
4046         siblings = cpu_node.get("siblings")
4047         if siblings:
4048             cpu["siblings"] = siblings
4049         cpus.append(cpu)
4050     if cpus:
4051         result["cpus"] = cpus
4052     return result
4053 def _parse_caps_bank(bank):
4054     """
4055     Parse the &lt;bank&gt; element of the connection capabilities XML.
4056     result = {
4057         "id": int(bank.get("id")),
4058         "level": int(bank<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("level")),
4059         "type": bank.get("type"),
4060         "size": "{} {}".format(bank.get("size"), bank.get("unit")),
4061         "cpus": bank.get(</b></font>"cpus"),
4062     }
4063     controls = []
4064     for control in bank.findall("control"):
4065         unit = control.get("unit")
4066         result_control = {
4067             "granularity": "{} {}".format(control.get("granularity"), unit),
4068             "type": control.get("type"),
4069             "maxAllocs": int(control.get("maxAllocs")),
4070         }
4071         minimum = control.get("min")
4072         if minimum:
4073             result_control["min"] = "{} {}".format(minimum, unit)
4074         controls.append(result_control)
4075     if controls:
4076         result["controls"] = controls
4077     return result
4078 def _parse_caps_host(host):
4079     """
4080     Parse the &lt;host&gt; element of the connection capabilities XML.
4081     """
4082     result = {}
4083     for child in host:
4084         if child.tag == "uuid":
4085             result["uuid"] = child.text
4086             cpu = {
4087                 "arch": child.find("arch").text
4088                 if child<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("arch") is not None
4089                 else None,
4090                 "model": child.find("model").text
4091                 if child.find("model") is not None
4092                 else None,
4093                 "vendor": child.find("vendor").text
4094                 if child.find("vendor") is not None
4095                 else None,
4096                 "features": [
4097                     feature.get("name") for feature in child.findall("feature")
4098                 ],
4099                 "pages": [
4100                     {</b></font>"size": "{} {}".format(page.get("size"), page.get("unit", "KiB"))}
4101                     for page in child.findall("pages")
4102                 ],
4103             }
4104             microcode = child.find("microcode")
4105             if microcode is not None:
4106                 cpu["microcode"] = microcode.get("version")
4107             topology = child.find("topology")
4108             if topology is not None:
4109                 cpu["sockets"] = int(topology.get("sockets"))
4110                 cpu["cores"] = int(topology.get("cores"))
4111                 cpu["threads"] = int(topology.get("threads"))
4112             result["cpu"] = cpu
4113         elif child.tag == "power_management":
4114             result["power_management"] = [node.tag for node in child]
4115         elif child.tag == "migration_features":
4116             result["migration"] = {
4117                 "live": child.find("live") is not None,
4118                 "transports": [
4119                     node.text for node in child.findall("uri_transports/uri_transport")
4120                 ],
4121             }
4122         elif child.tag == "topology":
4123             result["topology"] = {
4124                 "cells": [
4125                     _parse_caps_cell(cell) for cell in child.findall("cells/cell")
4126                 ]
4127             }
4128         elif child.tag == "cache":
4129             result["cache"] = {
4130                 "banks": [_parse_caps_bank(bank) for bank in child.findall("bank")]
4131             }
4132     result["security"] = [
4133         {
4134             "model": secmodel<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("model").text
4135             if secmodel.find("model") is not None
4136             else None,
4137             "doi": secmodel.find("doi").text
4138             if secmodel.find("doi") is not None
4139             else None,
4140             "baselabels": [
4141                 {"type": label.</b></font>get("type"), "label": label.text}
4142                 for label in secmodel.findall("baselabel")
4143             ],
4144         }
4145         for secmodel in host.findall("secmodel")
4146     ]
4147     return result
4148 def _capabilities(conn):
4149     """
4150     Return the hypervisor connection capabilities.
4151     :param conn: opened libvirt connection to use
4152     """
4153     caps = ElementTree.fromstring(conn.getCapabilities())
4154     return {
4155         "host": _parse_caps_host(caps.find("host")),
4156         "guests": [_parse_caps_guest(guest) for guest in caps.findall("guest")],
4157     }
4158 def capabilities(**kwargs):
4159     """
4160     Return the hypervisor connection capabilities.
4161     :param connection: libvirt connection URI, overriding defaults
4162     :param username: username to connect with, overriding defaults
4163     :param password: password to connect with, overriding defaults
4164     .. versionadded:: 2019.2.0
4165     CLI Example:
4166     .. code-block:: bash
4167         salt '*' virt.capabilities
4168     """
4169     conn = __get_conn(**kwargs)
4170     try:
4171         caps = _capabilities(conn)
4172     except libvirt.libvirtError as err:
4173         raise CommandExecutionError(str(err))
4174     finally:
4175         conn.close()
4176     return caps
4177 def _parse_caps_enum(node):
4178     """
4179     Return a tuple containing the name of the enum and the possible values
4180     """
4181     return (node.get("name"), [value.text for value in node.findall("value")])
4182 def _parse_caps_cpu(node):
4183     """
4184     Parse the &lt;cpu&gt; element of the domain capabilities
4185     """
4186     result = {}
4187     for mode in node.findall("mode"):
4188         if not mode.get("supported") == "yes":
4189             continue
4190         name = mode.get("name")
4191         if name == "host-passthrough":
4192             result[name] = True
4193         elif name == "host-model":
4194             host_model = {}
4195             model_node = mode.find("model")
4196             if model_node is not None:
4197                 model = {"name": model_node.text}
4198                 vendor_id = model_node.get("vendor_id")
4199                 if vendor_id:
4200                     model["vendor_id"] = vendor_id
4201                 fallback = model_node.get("fallback")
4202                 if fallback:
4203                     model["fallback"] = fallback
4204                 host_model["model"] = model
4205             vendor = (
4206                 mode.find("vendor").text if mode.find("vendor") is not None else None
4207             )
4208             if vendor:
4209                 host_model["vendor"] = vendor
4210             features = {
4211                 feature.get("name"): feature.get("policy")
4212                 for feature in mode.findall("feature")
4213             }
4214             if features:
4215                 host_model["features"] = features
4216             result[name] = host_model
4217         elif name == "custom":
4218             custom_model = {}
4219             models = {
4220                 model.text: model.get("usable") for model in mode.findall("model")
4221             }
4222             if models:
4223                 custom_model["models"] = models
4224             result[name] = custom_model
4225     return result
4226 def _parse_caps_devices_features(node):
4227     """
4228     Parse the devices or features list of the domain capatilities
4229     """
4230     result = {}
4231     for child in node:
4232         if child.get("supported") == "yes":
4233             enums = [_parse_caps_enum(node) for node in child.findall("enum")]
4234             result[child.tag] = {item[0]: item[1] for item in enums if item[0]}
4235     return result
4236 def _parse_caps_loader(node):
4237     """
4238     Parse the &lt;loader&gt; element of the domain capabilities.
4239     """
4240     enums = [_parse_caps_enum(enum) for enum in node.findall("enum")]
4241     result = {item[0]: item[1] for item in enums if item[0]}
4242     values = [child.text for child in node.findall("value")]
4243     if values:
4244         result["values"] = values
4245     return result
4246 def _parse_domain_caps(caps):
4247     """
4248     """
4249     result = {
4250         "emulator": caps.find("path").text if caps<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("path") is not None else None,
4251         "domain": caps.find("domain").text if caps.find("domain") is not None else None,
4252         "machine": caps.find("machine").text
4253         if caps.find("machine") is not None
4254         else None,
4255         "arch": caps.find("arch").text if caps.find(</b></font>"arch") is not None else None,
4256     }
4257     for child in caps:
4258         if child.tag == "vcpu" and child.get("max"):
4259             result["max_vcpus"] = int(child.get("max"))
4260         elif child.tag == "iothreads":
4261             result["iothreads"] = child.get("supported") == "yes"
4262         elif child.tag == "os":
4263             result["os"] = {}
4264             loader_node = child.find("loader")
4265             if loader_node is not None and loader_node.get("supported") == "yes":
4266                 loader = _parse_caps_loader(loader_node)
4267                 result["os"]["loader"] = loader
4268         elif child.tag == "cpu":
4269             cpu = _parse_caps_cpu(child)
4270             if cpu:
4271                 result["cpu"] = cpu
4272         elif child.tag == "devices":
4273             devices = _parse_caps_devices_features(child)
4274             if devices:
4275                 result["devices"] = devices
4276         elif child.tag == "features":
4277             features = _parse_caps_devices_features(child)
4278             if features:
4279                 result["features"] = features
4280     return result
4281 def domain_capabilities(emulator=None, arch=None, machine=None, domain=None, **kwargs):
4282     """
4283     Return the domain capabilities given an emulator, architecture, machine or virtualization type.
4284     .. versionadded:: 2019.2.0
4285     :param emulator: return the capabilities for the given emulator binary
4286     :param arch: return the capabilities for the given CPU architecture
4287     :param machine: return the capabilities for the given emulated machine type
4288     :param domain: return the capabilities for the given virtualization type.
4289     :param connection: libvirt connection URI, overriding defaults
4290     :param username: username to connect with, overriding defaults
4291     :param password: password to connect with, overriding defaults
4292     The list of the possible emulator, arch, machine and domain can be found in
4293     the host capabilities output.
4294     If none of the parameters is provided, the libvirt default one is returned.
4295     CLI Example:
4296     .. code-block:: bash
4297         salt '*' virt.domain_capabilities arch='x86_64' domain='kvm'
4298     """
4299     conn = __get_conn(**kwargs)
4300     result = []
4301     try:
4302         caps = ElementTree.fromstring(
4303             conn.getDomainCapabilities(emulator, arch, machine, domain, 0)
4304         )
4305         result = _parse_domain_caps(caps)
4306     finally:
4307         conn.close()
4308     return result
4309 def all_capabilities(**kwargs):
4310     """
4311     Return the host and domain capabilities in a single call.
4312     .. versionadded:: 3001
4313     :param connection: libvirt connection URI, overriding defaults
4314     :param username: username to connect with, overriding defaults
4315     :param password: password to connect with, overriding defaults
4316     CLI Example:
4317     .. code-block:: bash
4318         salt '*' virt.all_capabilities
4319     """
4320     conn = __get_conn(**kwargs)
4321     try:
4322         host_caps = ElementTree.fromstring(conn.getCapabilities())
4323             [
4324                 (
4325                     guest<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("arch", {}).get("name", None),
4326                     key,
4327                     guest.get("arch", {}).get("emulator", None),
4328                 )
4329                 for key in guest.get("arch", {}).get(</b></font>"domains", {}).keys()
4330             ]
4331             for guest in [
4332                 _parse_caps_guest(guest) for guest in host_caps.findall("guest")
4333             ]
4334         ]
4335         flattened = [pair for item in (x for x in domains) for pair in item]
4336         result = {
4337             "host": {
4338                 "host": _parse_caps_host(host_caps.find("host")),
4339                 "guests": [
4340                     _parse_caps_guest(guest) for guest in host_caps.findall("guest")
4341                 ],
4342             },
4343             "domains": [
4344                 _parse_domain_caps(
4345                     ElementTree.fromstring(
4346                         conn.getDomainCapabilities(emulator, arch, None, domain)
4347                     )
4348                 )
4349                 for (arch, domain, emulator) in flattened
4350             ],
4351         }
4352         return result
4353     finally:
4354         conn.close()
4355 def cpu_baseline(full=False, migratable=False, out="libvirt", **kwargs):
4356     """
4357     Return the optimal 'custom' CPU baseline config for VM's on this minion
4358     .. versionadded:: 2016.3.0
4359     :param full: Return all CPU features rather than the ones on top of the closest CPU model
4360     :param migratable: Exclude CPU features that are unmigratable (libvirt 2.13+)
4361     :param out: 'libvirt' (default) for usable libvirt XML definition, 'salt' for nice dict
4362     :param connection: libvirt connection URI, overriding defaults
4363         .. versionadded:: 2019.2.0
4364     :param username: username to connect with, overriding defaults
4365         .. versionadded:: 2019.2.0
4366     :param password: password to connect with, overriding defaults
4367         .. versionadded:: 2019.2.0
4368     CLI Example:
4369     .. code-block:: bash
4370         salt '*' virt.cpu_baseline
4371     """
4372     conn = __get_conn(**kwargs)
4373     caps = ElementTree.fromstring(conn.getCapabilities())
4374     cpu = caps.find("host/cpu")
4375     host_cpu_def = xmlutil.element_to_str(cpu)
4376     log.debug("Host CPU model definition: %s", host_cpu_def)
4377     flags = 0
4378     if migratable:
4379         if getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_MIGRATABLE", False):
4380             flags += libvirt.VIR_CONNECT_BASELINE_CPU_MIGRATABLE
4381         else:
4382             conn.close()
4383             raise ValueError
4384     if full and getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
4385         flags += libvirt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES
4386     cpu = ElementTree.fromstring(conn.baselineCPU([host_cpu_def], flags))
4387     conn.close()
4388     if full and not getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
4389         with salt.utils.files.fopen("/usr/share/libvirt/cpu_map.xml", "r") as cpu_map:
4390             cpu_map = ElementTree.parse(cpu_map)
4391         cpu_model = cpu.find("model").text
4392         while cpu_model:
4393             cpu_map_models = cpu_map.findall("arch/model")
4394             cpu_specs = [
4395                 el
4396                 for el in cpu_map_models
4397                 if el.get("name") == cpu_model and bool(len(el))
4398             ]
4399             if not cpu_specs:
4400                 raise ValueError("Model {} not found in CPU map".format(cpu_model))
4401             elif len(cpu_specs) &gt; 1:
4402                 raise ValueError(
4403                     "Multiple models {} found in CPU map".format(cpu_model)
4404                 )
4405             cpu_specs = cpu_specs[0]
4406             model_node = cpu_specs.find("model")
4407             if model_node is None:
4408                 cpu_model = None
4409             else:
4410                 cpu_model = model_node.get("name")
4411             cpu.extend([feature for feature in cpu_specs.findall("feature")])
4412     if out == "salt":
4413         return {
4414             "model": cpu.find("model").text,
4415             "vendor": cpu.find("vendor").text,
4416             "features": [feature.get("name") for feature in cpu.findall("feature")],
4417         }
4418     return ElementTree.tostring(cpu)
4419 def network_define(
4420     name,
4421     bridge,
4422     ipv4_config=None,
4423     ipv6_config=None,
4424     vport<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
4425     tag=None,
4426     autostart=True,
4427     start=True,
4428     mtu=None,
4429     domain=None,
4430     nat=None,
4431     interfaces=None,
4432     addresses=None,
4433     physical_function=None,
4434     dns=None,
4435     **kwargs
4436 ):
4437     """
4438     Create libvirt network.
4439     :param name: Network name.
4440     :param bridge: Bridge name.
4441     :param forward: Forward mode (bridge, router, nat).
4442         .. versionchanged:: 3003
4443            a ``None`` value creates an isolated network with no forwarding at all
4444     :param vport: Virtualport type.
4445         The value can also be a dictionary with ``type`` and ``parameters`` keys.
4446         The ``parameters`` value is a dictionary of virtual port parameters.
4447         .. code-block:: yaml
4448           - vport:
4449               type: openvswitch
4450               parameters:
4451                 interfaceid: 09b11c53-8b5c-4eeb-8f00-d84eaa0aaa4f
4452         .. versionchanged:: 3003
4453            possible dictionary value
4454     :param tag: Vlan tag.
4455         The value can also be a dictionary with the ``tags`` and optional ``trunk`` keys.
4456         ``trunk`` is a boolean value indicating whether to use VLAN trunking.
4457         ``tags`` is a list of dictionaries with keys ``id`` and ``nativeMode``.
4458         The ``nativeMode`` value can be one of ``tagged`` or ``untagged``.
4459         .. code-block:: yaml
4460           - tag:
4461               trunk: True
4462               tags:
4463                 - id: 42
4464                   nativeMode: untagged
4465                 - id: 47
4466         .. versionchanged:: 3003
4467            possible dictionary value
4468     :param autostart: Network autostart (default True).
4469     :param start: Network start (default True).
4470     :param ipv4_config: IP v4 configuration.
4471         Dictionary describing the IP v4 setup like IP range and
4472         a possible DHCP configuration. The structure is documented
4473         in net-define-ip_.
4474         .. versionadded:: 3000
4475     :type ipv4_config: dict or None
4476     :param ipv6_config: IP v6 configuration.
4477         Dictionary describing the IP v6 setup like IP range and
4478         a possible DHCP configuration. The structure is documented
4479         in net-define-ip_.
4480         .. versionadded:: 3000
4481     :type ipv6_config: dict or None
4482     :param connection: libvirt connection URI, overriding defaults.
4483     :param username: username to connect with, overriding defaults.
4484     :param password: password to connect with, overriding defaults.
4485     :param mtu: size of the Maximum Transmission Unit (MTU) of the network.
4486         (default ``None``)
4487         .. versionadded:: 3003
4488     :param domain: DNS domain name of the DHCP server.
4489         The value is a dictionary with a mandatory ``name`` property and an optional ``localOnly`` boolean one.
4490         (default ``None``)
4491         .. code-block:: yaml
4492           - domain:
4493               name: lab.acme.org
4494               localOnly: True
4495         .. versionadded:: 3003
4496     :param nat: addresses and ports to route in NAT forward mode.
4497         The value is a dictionary with optional keys ``address`` and ``port``.
4498         Both values are a dictionary with ``start`` and ``end`` values.
4499         (default ``None``)
4500         .. code-block:: yaml
4501           - forward: nat
4502           - nat:
4503               address:
4504                 start: 1.2.3.4
4505                 end: 1.2.3.10
4506               port:
4507                 start: 500
4508                 end: 1000
4509         .. versionadded:: 3003
4510     :param interfaces: whitespace separated list of network interfaces devices that can be used for this network.
4511         (default ``None``)
4512         .. code-block:: yaml
4513           - forward: passthrough
4514           - interfaces: "eth10 eth11 eth12"
4515         .. versionadded:: 3003
4516     :param addresses: whitespace separated list of addresses of PCI devices that can be used for this network in `hostdev` forward mode.
4517         (default ``None``)
4518         .. code-block:: yaml
4519           - forward: hostdev
4520           - interfaces: "0000:04:00.1 0000:e3:01.2"
4521         .. versionadded:: 3003
4522     :param physical_function: device name of the physical interface to use in ``hostdev`` forward mode.
4523         (default ``None``)
4524         .. code-block:: yaml
4525           - forward: hostdev
4526           - physical_function: "eth0"
4527         .. versionadded:: 3003
4528     :param dns: virtual network DNS configuration.
4529         The value is a dictionary described in net-define-dns_.
4530         (default ``None``)
4531         .. code-block:: yaml
4532           - dns:
4533               forwarders:
4534                 - domain: example.com
4535                   addr: 192.168.1.1
4536                 - addr: 8.8.8.8
4537                 - domain: www.example.com
4538               txt:
4539                 example.com: "v=spf1 a -all"
4540                 _http.tcp.example.com: "name=value,paper=A4"
4541               hosts:
4542                 192.168.1.2:
4543                   - mirror.acme.lab
4544                   - test.acme.lab
4545               srvs:
4546                 - name: ldap
4547                   protocol: tcp
4548                   domain: ldapserver.example.com
4549                   target: .
4550                   port: 389
4551                   priority: 1
4552                   weight: 10
4553         .. versionadded:: 3003
4554     .. _net-define-ip:
4555     .. rubric:: IP configuration definition
4556     Both the IPv4 and IPv6 configuration dictionaries can contain the following properties:
4557     cidr
4558         CIDR notation for the network. For example '192.168.124.0/24'
4559     dhcp_ranges
4560         A list of dictionaries with ``'start'`` and ``'end'`` properties.
4561     hosts
4562         A list of dictionaries with ``ip`` property and optional ``name``, ``mac`` and ``id`` properties.
4563         .. versionadded:: 3003
4564     bootp
4565         A dictionary with a ``file`` property and an optional ``server`` one.
4566         .. versionadded:: 3003
4567     tftp
4568         The path to the TFTP root directory to serve.
4569         .. versionadded:: 3003
4570     .. _net-define-dns:
4571     .. rubric:: DNS configuration definition
4572     The DNS configuration dictionary contains the following optional properties:
4573     forwarders
4574         List of alternate DNS forwarders to use.
4575         Each item is a dictionary with the optional ``domain`` and ``addr`` keys.
4576         If both are provided, the requests to the domain are forwarded to the server at the ``addr``.
4577         If only ``domain`` is provided the requests matching this domain will be resolved locally.
4578         If only ``addr`` is provided all requests will be forwarded to this DNS server.
4579     txt:
4580         Dictionary of TXT fields to set.
4581     hosts:
4582         Dictionary of host DNS entries.
4583         The key is the IP of the host, and the value is a list of hostnames for it.
4584     srvs:
4585         List of SRV DNS entries.
4586         Each entry is a dictionary with the mandatory ``name`` and ``protocol`` keys.
4587         Entries can also have ``target``, ``port``, ``priority``, ``domain`` and ``weight`` optional properties.
4588     CLI Example:
4589     .. code-block:: bash
4590         salt '*' virt.network_define network main bridge openvswitch
4591     .. versionadded:: 2019.2.0
4592     """
4593     conn = __get_conn(**kwargs)
4594     vport = kwargs.</b></font>get("vport", None)
4595     tag = kwargs.get("tag", None)
4596     net_xml = _gen_net_xml(
4597         name,
4598         bridge,
4599         forward,
4600         vport,
4601         tag=tag,
4602         ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
4603         mtu=mtu,
4604         domain=domain,
4605         nat=nat,
4606         interfaces=interfaces,
4607         addresses=addresses,
4608         physical_function=physical_function,
4609         dns=dns,
4610     )
4611     try:
4612         conn.networkDefineXML(net_xml)
4613     except libvirt.libvirtError as err:
4614         log.warning(err)
4615         conn.close()
4616         raise err  # a real error we should report upwards
4617     try:
4618         network = conn.networkLookupByName(name)
4619     except libvirt.libvirtError as err:
4620         log.warning(err)
4621         conn.close()
4622         raise err  # a real error we should report upwards
4623     if network is None:
4624         conn.close()
4625         return False
4626     if (start or autostart) and network.isActive() != 1:
4627         network.create()
4628     if autostart and network.autostart() != 1:
4629         network.setAutostart(int(autostart))
4630     elif not autostart and network.autostart() == 1:
4631         network.setAutostart(int(autostart))
4632     conn.close()
4633     return True
4634 def _remove_empty_xml_node(node):
4635     """
4636     Remove the nodes with no children, no text and no attribute
4637     """
4638     for child in node:
4639         if not child.tail and not child.text and not child.items() and not child:
4640             node.remove(child)
4641         else:
4642             _remove_empty_xml_node(child)
4643     return node
4644 def network_update(
4645     name,
4646     bridge,
4647     forward,
4648     ipv4_config=None,
4649     ipv6_config=None,
4650     vport=None,
4651     tag=None,
4652     mtu=None,
4653     domain=None,
4654     nat=None,
4655     interfaces=None,
4656     addresses=None,
4657     physical_function=None,
4658     dns=None,
4659     test=False,
4660     **kwargs
4661 ):
4662     """
4663     Update a virtual network if needed.
4664     :param name: Network name.
4665     :param bridge: Bridge name.
4666     :param forward: Forward mode (bridge, router, nat).
4667         A ``None`` value creates an isolated network with no forwarding at all.
4668     :param vport: Virtualport type.
4669         The value can also be a dictionary with ``type`` and ``parameters`` keys.
4670         The ``parameters`` value is a dictionary of virtual port parameters.
4671         .. code-block:: yaml
4672           - vport:
4673               type: openvswitch
4674               parameters:
4675                 interfaceid: 09b11c53-8b5c-4eeb-8f00-d84eaa0aaa4f
4676     :param tag: Vlan tag.
4677         The value can also be a dictionary with the ``tags`` and optional ``trunk`` keys.
4678         ``trunk`` is a boolean value indicating whether to use VLAN trunking.
4679         ``tags`` is a list of dictionaries with keys ``id`` and ``nativeMode``.
4680         The ``nativeMode`` value can be one of ``tagged`` or ``untagged``.
4681         .. code-block:: yaml
4682           - tag:
4683               trunk: True
4684               tags:
4685                 - id: 42
4686                   nativeMode: untagged
4687                 - id: 47
4688     :param ipv4_config: IP v4 configuration.
4689         Dictionary describing the IP v4 setup like IP range and
4690         a possible DHCP configuration. The structure is documented
4691         in net-define-ip_.
4692     :type ipv4_config: dict or None
4693     :param ipv6_config: IP v6 configuration.
4694         Dictionary describing the IP v6 setup like IP range and
4695         a possible DHCP configuration. The structure is documented
4696         in net-define-ip_.
4697     :type ipv6_config: dict or None
4698     :param connection: libvirt connection URI, overriding defaults.
4699     :param username: username to connect with, overriding defaults.
4700     :param password: password to connect with, overriding defaults.
4701     :param mtu: size of the Maximum Transmission Unit (MTU) of the network.
4702         (default ``None``)
4703     :param domain: DNS domain name of the DHCP server.
4704         The value is a dictionary with a mandatory ``name`` property and an optional ``localOnly`` boolean one.
4705         (default ``None``)
4706         .. code-block:: yaml
4707           - domain:
4708               name: lab.acme.org
4709               localOnly: True
4710     :param nat: addresses and ports to route in NAT forward mode.
4711         The value is a dictionary with optional keys ``address`` and ``port``.
4712         Both values are a dictionary with ``start`` and ``end`` values.
4713         (default ``None``)
4714         .. code-block:: yaml
4715           - forward: nat
4716           - nat:
4717               address:
4718                 start: 1.2.3.4
4719                 end: 1.2.3.10
4720               port:
4721                 start: 500
4722                 end: 1000
4723     :param interfaces: whitespace separated list of network interfaces devices that can be used for this network.
4724         (default ``None``)
4725         .. code-block:: yaml
4726           - forward: passthrough
4727           - interfaces: "eth10 eth11 eth12"
4728     :param addresses: whitespace separated list of addresses of PCI devices that can be used for this network in `hostdev` forward mode.
4729         (default ``None``)
4730         .. code-block:: yaml
4731           - forward: hostdev
4732           - interfaces: "0000:04:00.1 0000:e3:01.2"
4733     :param physical_function: device name of the physical interface to use in ``hostdev`` forward mode.
4734         (default ``None``)
4735         .. code-block:: yaml
4736           - forward: hostdev
4737           - physical_function: "eth0"
4738     :param dns: virtual network DNS configuration.
4739         The value is a dictionary described in net-define-dns_.
4740         (default ``None``)
4741         .. code-block:: yaml
4742           - dns:
4743               forwarders:
4744                 - domain: example.com
4745                   addr: 192.168.1.1
4746                 - addr: 8.8.8.8
4747                 - domain: www.example.com
4748               txt:
4749                 example.com: "v=spf1 a -all"
4750                 _http.tcp.example.com: "name=value,paper=A4"
4751               hosts:
4752                 192.168.1.2:
4753                   - mirror.acme.lab
4754                   - test.acme.lab
4755               srvs:
4756                 - name: ldap
4757                   protocol: tcp
4758                   domain: ldapserver.example.com
4759                   target: .
4760                   port: 389
4761                   priority: 1
4762                   weight: 10
4763     .. versionadded:: 3003
4764     """
4765     conn = __get_conn(**kwargs)
4766     needs_update = False
4767     try:
4768         net = conn.networkLookupByName(name)
4769         old_xml = ElementTree.fromstring(net.XMLDesc())
4770         new_xml = ElementTree.fromstring(
4771             _gen_net_xml(
4772                 name,
4773                 bridge,
4774                 forward,
4775                 vport,
4776                 tag=tag,
4777                 ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
4778                 mtu=mtu,
4779                 domain=domain,
4780                 nat=nat,
4781                 interfaces=interfaces,
4782                 addresses=addresses,
4783                 physical_function=physical_function,
4784                 dns=dns,
4785             )
4786         )
4787         elements_to_copy = ["uuid", "mac"]
4788         for to_copy in elements_to_copy:
4789             element = old_xml.find(to_copy)
4790             if element is not None:
4791                 new_xml.insert(1, element)
4792         old_xml.attrib.pop("connections", None)
4793         if old_xml.find("forward/pf") is not None:
4794             forward_node = old_xml.find("forward")
4795             address_nodes = forward_node.findall("address")
4796             for node in address_nodes:
4797                 forward_node.remove(node)
4798         default_bridge_attribs = {"stp": "on", "delay": "0"}
4799         old_bridge_node = old_xml.find("bridge")
4800         if old_bridge_node is not None:
4801             for key, value in default_bridge_attribs.items():
4802                 if old_bridge_node.get(key, None) == value:
4803                     old_bridge_node.attrib.pop(key, None)
4804             old_forward = (
4805                 old_xml.find("forward").get("mode")
4806                 if old_xml.find("forward") is not None
4807                 else None
4808             )
4809             if (
4810                 old_forward == forward
4811                 and forward in ["nat", "route", "open", None]
4812                 and bridge is None
4813                 and old_bridge_node.get("name", "").startswith("virbr")
4814             ):
4815                 old_bridge_node.attrib.pop("name", None)
4816         ipv4_nodes = [
4817             node
4818             for node in old_xml.findall("ip")
4819             if node.get("family", "ipv4") == "ipv4"
4820         ]
4821         for ip_node in ipv4_nodes:
4822             netmask = ip_node.attrib.pop("netmask", None)
4823             if netmask:
4824                 address = ipaddress.ip_network(
4825                     "{}/{}".format(ip_node.get("address"), netmask), strict=False
4826                 )
4827                 ip_node.set("prefix", str(address.prefixlen))
4828         for doc in [old_xml, new_xml]:
4829             for node in doc.findall("ip"):
4830                 if "family" not in node.keys():
4831                     node.set("family", "ipv4")
4832         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
4833         xmlutil.strip_spaces(new_xml)
4834         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
4835         if needs_update and not test:
4836             conn.networkDefineXML(xmlutil.element_to_str(new_xml))
4837     finally:
4838         conn.close()
4839     return needs_update
4840 def list_networks(**kwargs):
4841     """
4842     List all virtual networks.
4843     :param connection: libvirt connection URI, overriding defaults
4844     :param username: username to connect with, overriding defaults
4845     :param password: password to connect with, overriding defaults
4846     .. versionadded:: 2019.2.0
4847     CLI Example:
4848     .. code-block:: bash
4849        salt '*' virt.list_networks
4850     """
4851     conn = __get_conn(**kwargs)
4852     try:
4853         return [net.name() for net in conn.listAllNetworks()]
4854     finally:
4855         conn.close()
4856 def network_info(name=None, **kwargs):
4857     """
4858     Return information on a virtual network provided its name.
4859     :param name: virtual network name
4860     :param connection: libvirt connection URI, overriding defaults
4861     :param username: username to connect with, overriding defaults
4862     :param password: password to connect with, overriding defaults
4863     If no name is provided, return the infos for all defined virtual networks.
4864     .. versionadded:: 2019.2.0
4865     CLI Example:
4866     .. code-block:: bash
4867         salt '*' virt.network_info default
4868     """
4869     result = {}
4870     conn = __get_conn(**kwargs)
4871     def _net_get_leases(net):
4872         """
4873         Get all DHCP leases for a network
4874         """
4875         leases = net.DHCPLeases()
4876         for lease in leases:
4877             if lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV4:
4878                 lease["type"] = "ipv4"
4879             elif lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV6:
4880                 lease["type"] = "ipv6"
4881             else:
4882                 lease["type"] = "unknown"
4883         return leases
4884     def _net_get_bridge(net):
4885         """
4886         Get the bridge of the network or None
4887         """
4888         try:
4889             return net.bridgeName()
4890         except libvirt.libvirtError as err:
4891             return None
4892     try:
4893         nets = [
4894             net for net in conn.listAllNetworks() if name is None or net.name() == name
4895         ]
4896         result = {
4897             net.name(): {
4898                 "uuid": net.UUIDString(),
4899                 "bridge": _net_get_bridge(net),
4900                 "autostart": net.autostart(),
4901                 "active": net.isActive(),
4902                 "persistent": net.isPersistent(),
4903                 "leases": _net_get_leases(net),
4904             }
4905             for net in nets
4906         }
4907     except libvirt.libvirtError as err:
4908         log.debug("Silenced libvirt error: %s", err)
4909     finally:
4910         conn.close()
4911     return result
4912 def network_get_xml(name, **kwargs):
4913     """
4914     Return the XML definition of a virtual network
4915     :param name: libvirt network name
4916     :param connection: libvirt connection URI, overriding defaults
4917     :param username: username to connect with, overriding defaults
4918     :param password: password to connect with, overriding defaults
4919     .. versionadded:: 3000
4920     CLI Example:
4921     .. code-block:: bash
4922         salt '*' virt.network_get_xml default
4923     """
4924     conn = __get_conn(**kwargs)
4925     try:
4926         return conn.networkLookupByName(name).XMLDesc()
4927     finally:
4928         conn.close()
4929 def network_start(name, **kwargs):
4930     """
4931     Start a defined virtual network.
4932     :param name: virtual network name
4933     :param connection: libvirt connection URI, overriding defaults
4934     :param username: username to connect with, overriding defaults
4935     :param password: password to connect with, overriding defaults
4936     .. versionadded:: 2019.2.0
4937     CLI Example:
4938     .. code-block:: bash
4939         salt '*' virt.network_start default
4940     """
4941     conn = __get_conn(**kwargs)
4942     try:
4943         net = conn.networkLookupByName(name)
4944         return not bool(net.create())
4945     finally:
4946         conn.close()
4947 def network_stop(name, **kwargs):
4948     """
4949     Stop a defined virtual network.
4950     :param name: virtual network name
4951     :param connection: libvirt connection URI, overriding defaults
4952     :param username: username to connect with, overriding defaults
4953     :param password: password to connect with, overriding defaults
4954     .. versionadded:: 2019.2.0
4955     CLI Example:
4956     .. code-block:: bash
4957         salt '*' virt.network_stop default
4958     """
4959     conn = __get_conn(**kwargs)
4960     try:
4961         net = conn.networkLookupByName(name)
4962         return not bool(net.destroy())
4963     finally:
4964         conn.close()
4965 def network_undefine(name, **kwargs):
4966     """
4967     Remove a defined virtual network. This does not stop the virtual network.
4968     :param name: virtual network name
4969     :param connection: libvirt connection URI, overriding defaults
4970     :param username: username to connect with, overriding defaults
4971     :param password: password to connect with, overriding defaults
4972     .. versionadded:: 2019.2.0
4973     CLI Example:
4974     .. code-block:: bash
4975         salt '*' virt.network_undefine default
4976     """
4977     conn = __get_conn(**kwargs)
4978     try:
4979         net = conn.networkLookupByName(name)
4980         return not bool(net.undefine())
4981     finally:
4982         conn.close()
4983 def network_set_autostart(name, state="on", **kwargs):
4984     """
4985     Set the autostart flag on a virtual network so that the network
4986     will start with the host system on reboot.
4987     :param name: virtual network name
4988     :param state: 'on' to auto start the network, anything else to mark the
4989                   virtual network not to be started when the host boots
4990     :param connection: libvirt connection URI, overriding defaults
4991     :param username: username to connect with, overriding defaults
4992     :param password: password to connect with, overriding defaults
4993     .. versionadded:: 2019.2.0
4994     CLI Example:
4995     .. code-block:: bash
4996         salt "*" virt.network_set_autostart &lt;pool&gt; &lt;on | off&gt;
4997     """
4998     conn = __get_conn(**kwargs)
4999     try:
5000         net = conn.networkLookupByName(name)
5001         return not bool(net.setAutostart(1 if state == "on" else 0))
5002     finally:
5003         conn.close()
5004 def _parse_pools_caps(doc):
5005     """
5006     Parse libvirt pool capabilities XML
5007     """
5008     def _parse_pool_caps(pool):
5009         pool_caps = {
5010             "name": pool.get("type"),
5011             "supported": pool.get("supported", "no") == "yes",
5012         }
5013         for option_kind in ["pool", "vol"]:
5014             options = {}
5015             default_format_node = pool.find(
5016                 "{}Options/defaultFormat".format(option_kind)
5017             )
5018             if default_format_node is not None:
5019                 options["default_format"] = default_format_node.get("type")
5020             options_enums = {
5021                 enum.get("name"): [value.text for value in enum.findall("value")]
5022                 for enum in pool.findall("{}Options/enum".format(option_kind))
5023             }
5024             if options_enums:
5025                 options.update(options_enums)
5026             if options:
5027                 if "options" not in pool_caps:
5028                     pool_caps["options"] = {}
5029                 kind = option_kind if option_kind != "vol" else "volume"
5030                 pool_caps["options"][kind] = options
5031         return pool_caps
5032     return [_parse_pool_caps(pool) for pool in doc.findall("pool")]
5033 def _pool_capabilities(conn):
5034     """
5035     Return the hypervisor connection storage pool capabilities.
5036     :param conn: opened libvirt connection to use
5037     """
5038     has_pool_capabilities = bool(getattr(conn, "getStoragePoolCapabilities", None))
5039     if has_pool_capabilities:
5040         caps = ElementTree.fromstring(conn.getStoragePoolCapabilities())
5041         pool_types = _parse_pools_caps(caps)
5042     else:
5043         all_hypervisors = ["xen", "kvm", "bhyve"]
5044         images_formats = [
5045             "none",
5046             "raw",
5047             "dir",
5048             "bochs",
5049             "cloop",
5050             "dmg",
5051             "iso",
5052             "vpc",
5053             "vdi",
5054             "fat",
5055             "vhd",
5056             "ploop",
5057             "cow",
5058             "qcow",
5059             "qcow2",
5060             "vmdk",
5061         ]
5062         common_drivers <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= [
5063             {
5064                 "name": "fs",
5065                 "default_source_format": "auto",
5066                 "source_formats": [
5067                     "auto",
5068                     "ext2",
5069                     "ext3",
5070                     "ext4",
5071                     "ufs",
5072                     "iso9660",
5073                     "udf",
5074                     "gfs",
5075                     "gfs2",
5076                     "vfat",
5077                     "hfs+",
5078                     "xfs",
5079                     "ocfs2",
5080                 ],
5081                 "default_target_format": "raw",
5082                 "target_formats": images_formats,
5083             },
5084             {
5085                 "name": "dir",
5086                 "default_target_format": "raw",
5087                 "target_formats": images_formats,
5088             },
5089             {"name": "iscsi"},
5090             {"name": "scsi"},
5091             {
5092                 "name": "logical",
5093                 "default_source_format": "lvm2",
5094                 "source_formats": ["unknown", "lvm2"],
5095             },
5096             {
5097                 "name": "netfs",
5098                 "default_source_format": "auto",
5099                 "source_formats": ["auto", "nfs", "glusterfs", "cifs"],
5100                 "default_target_format": "raw",
5101                 "target_formats": images_formats,
5102             },
5103             {
5104                 "name": "disk",
5105                 "default_source_format": "unknown",
5106                 "source_formats": [
5107                     "unknown",
5108                     "dos",
5109                     "dvh",
5110                     "gpt",
5111                     "mac",
5112                     "bsd",
5113                     "pc98",
5114                     "sun",
5115                     "lvm2",
5116                 ],
5117                 "default_target_format": "none",
5118                 "target_formats": [
5119                     "none",
5120                     "linux",
5121                     "fat16",
5122                     "fat32",
5123                     "linux-swap",
5124                     "linux-lvm",
5125                     "linux-raid",
5126                     "extended",
5127                 ],
5128             },
5129             {"name": "mpath"},
5130             {"name": "rbd", "default_target_format": "raw", "target_formats": []},
5131             {
5132                 "name": "sheepdog",
5133                 "version": 10000,
5134                 "hypervisors": ["kvm"],
5135                 "default_target_format": "raw",
5136                 "target_formats": images_formats,
5137             },
5138             {
5139                 "name": "gluster",
5140                 "version": 1002000,
5141                 "hypervisors": ["kvm"],
5142                 "default_target_format": "raw",
5143                 "target_formats": images_formats,
5144             },
5145             {"name": "zfs", "version": 1002008, "hypervisors": ["bhyve"]},
5146             {
5147                 "name": "iscsi-direct",
5148                 "version": 4007000,
5149                 "hypervisors": ["kvm"</b></font>, "xen"],
5150             },
5151         ]
5152         libvirt_version = conn.getLibVersion()
5153         hypervisor = get_hypervisor()
5154         def _get_backend_output(backend):
5155             output = {
5156                 "name": backend["name"],
5157                 "supported": (
5158                     not backend.get("version") or libvirt_version &gt;= backend["version"]
5159                 )
5160                 and hypervisor in backend.get("hypervisors", all_hypervisors),
5161                 "options": {
5162                     "pool": {
5163                         "default_format": backend.get("default_source_format"),
5164                         "sourceFormatType": backend.get("source_formats"),
5165                     },
5166                     "volume": {
5167                         "default_format": backend.get("default_target_format"),
5168                         "targetFormatType": backend.get("target_formats"),
5169                     },
5170                 },
5171             }
5172             for option_kind in ["pool", "volume"]:
5173                 if not [
5174                     value
5175                     for value in output["options"][option_kind].values()
5176                     if value is not None
5177                 ]:
5178                     del output["options"][option_kind]
5179             if not output["options"]:
5180                 del output["options"]
5181             return output
5182         pool_types = [_get_backend_output(backend) for backend in common_drivers]
5183     return {
5184         "computed": not has_pool_capabilities,
5185         "pool_types": pool_types,
5186     }
5187 def pool_capabilities(**kwargs):
5188     """
5189     Return the hypervisor connection storage pool capabilities.
5190     The returned data are either directly extracted from libvirt or computed.
5191     In the latter case some pool types could be listed as supported while they
5192     are not. To distinguish between the two cases, check the value of the ``computed`` property.
5193     :param connection: libvirt connection URI, overriding defaults
5194     :param username: username to connect with, overriding defaults
5195     :param password: password to connect with, overriding defaults
5196     .. versionadded:: 3000
5197     CLI Example:
5198     .. code-block:: bash
5199         salt '*' virt.pool_capabilities
5200     """
5201     try:
5202         conn = __get_conn(**kwargs)
5203         return _pool_capabilities(conn)
5204     finally:
5205         conn.close()
5206 def pool_define(
5207     name,
5208     ptype,
5209     target=None,
5210     permissions=None,
5211     source_devices=None,
5212     source_dir=None,
5213     source_initiator=None,
5214     source_adapter=None,
5215     source_hosts=None,
5216     source_auth=None,
5217     source_name=None,
5218     source_format=None,
5219     transient=False,
5220     start=True,  # pylint: disable=redefined-outer-name
5221     **kwargs
5222 ):
5223     """
5224     Create libvirt pool.
5225     :param name: Pool name
5226     :param ptype:
5227         Pool type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_  for the
5228         possible values.
5229     :param target: Pool full path target
5230     :param permissions:
5231         Permissions to set on the target folder. This is mostly used for filesystem-based
5232         pool types. See :ref:`pool-define-permissions` for more details on this structure.
5233     :param source_devices:
5234         List of source devices for pools backed by physical devices. (Default: ``None``)
5235         Each item in the list is a dictionary with ``path`` and optionally ``part_separator``
5236         keys. The path is the qualified name for iSCSI devices.
5237         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
5238         for more information on the use of ``part_separator``
5239     :param source_dir:
5240         Path to the source directory for pools of type ``dir``, ``netfs`` or ``gluster``.
5241         (Default: ``None``)
5242     :param source_initiator:
5243         Initiator IQN for libiscsi-direct pool types. (Default: ``None``)
5244         .. versionadded:: 3000
5245     :param source_adapter:
5246         SCSI source definition. The value is a dictionary with ``type``, ``name``, ``parent``,
5247         ``managed``, ``parent_wwnn``, ``parent_wwpn``, ``parent_fabric_wwn``, ``wwnn``, ``wwpn``
5248         and ``parent_address`` keys.
5249         The ``parent_address`` value is a dictionary with ``unique_id`` and ``address`` keys.
5250         The address represents a PCI address and is itself a dictionary with ``domain``, ``bus``,
5251         ``slot`` and ``function`` properties.
5252         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
5253         for the meaning and possible values of these properties.
5254     :param source_hosts:
5255         List of source for pools backed by storage from remote servers. Each item is the hostname
5256         optionally followed by the port separated by a colon. (Default: ``None``)
5257     :param source_auth:
5258         Source authentication details. (Default: ``None``)
5259         The value is a dictionary with ``type``, ``username`` and ``secret`` keys. The type
5260         can be one of ``ceph`` for Ceph RBD or ``chap`` for iSCSI sources.
5261         The ``secret`` value links to a libvirt secret object. It is a dictionary with
5262         ``type`` and ``value`` keys. The type value can be either ``uuid`` or ``usage``.
5263         Examples:
5264         .. code-block:: python
5265             source_auth={
5266                 'type': 'ceph',
5267                 'username': 'admin',
5268                 'secret': {
5269                     'type': 'uuid',
5270                     'value': '2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'
5271                 }
5272             }
5273         .. code-block:: python
5274             source_auth={
5275                 'type': 'chap',
5276                 'username': 'myname',
5277                 'secret': {
5278                     'type': 'usage',
5279                     'value': 'mycluster_myname'
5280                 }
5281             }
5282         Since 3000, instead the source authentication can only contain ``username``
5283         and ``password`` properties. In this case the libvirt secret will be defined and used.
5284         For Ceph authentications a base64 encoded key is expected.
5285     :param source_name:
5286         Identifier of name-based sources.
5287     :param source_format:
5288         String representing the source format. The possible values are depending on the
5289         source type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_ for
5290         the possible values.
5291     :param start: Pool start (default True)
5292     :param transient:
5293         When ``True``, the pool will be automatically undefined after being stopped.
5294         Note that a transient pool will force ``start`` to ``True``. (Default: ``False``)
5295     :param connection: libvirt connection URI, overriding defaults
5296     :param username: username to connect with, overriding defaults
5297     :param password: password to connect with, overriding defaults
5298     .. _pool-define-permissions:
5299     .. rubric:: Permissions definition
5300     The permissions are described by a dictionary containing the following keys:
5301     mode
5302         The octal representation of the permissions. (Default: `0711`)
5303     owner
5304         the numeric user ID of the owner. (Default: from the parent folder)
5305     group
5306         the numeric ID of the group. (Default: from the parent folder)
5307     label
5308         the SELinux label. (Default: `None`)
5309     .. rubric:: CLI Example:
5310     Local folder pool:
5311     .. code-block:: bash
5312         salt '*' virt.pool_define somepool dir target=/srv/mypool \
5313                                   permissions="{'mode': '0744' 'ower': 107, 'group': 107 }"
5314     CIFS backed pool:
5315     .. code-block:: bash
5316         salt '*' virt.pool_define myshare netfs source_format=cifs \
5317                                   source_dir=samba_share source_hosts="['example.com']" target=/mnt/cifs
5318     .. versionadded:: 2019.2.0
5319     """
5320     conn = __get_conn(**kwargs)
5321     auth = _pool_set_secret(conn, ptype, name, source_auth)
5322     pool_xml = _gen_pool_xml(
5323         name,
5324         ptype,
5325         target,
5326         permissions=permissions,
5327         source_devices=source_devices,
5328         source_dir=source_dir,
5329         source_adapter=source_adapter,
5330         source_hosts=source_hosts,
5331         source_auth=auth,
5332         source_name=source_name,
5333         source_format=source_format,
5334         source_initiator=source_initiator,
5335     )
5336     try:
5337         if transient:
5338             pool = conn.storagePoolCreateXML(pool_xml)
5339         else:
5340             pool = conn.storagePoolDefineXML(pool_xml)
5341             if start:
5342                 pool.create()
5343     except libvirt.libvirtError as err:
5344         raise err  # a real error we should report upwards
5345     finally:
5346         conn.close()
5347     return True
5348 def _pool_set_secret(
5349     conn, pool_type, pool_name, source_auth, uuid=None, usage=None, test=False
5350 ):
5351     secret_types = {"rbd": "ceph", "iscsi": "chap", "iscsi-direct": "chap"}
5352     secret_type = secret_types.get(pool_type)
5353     auth = source_auth
5354     if source_auth and "username" in source_auth and "password" in source_auth:
5355         if secret_type:
5356             secret = None
5357             try:
5358                 if usage:
5359                     usage_type = (
5360                         libvirt.VIR_SECRET_USAGE_TYPE_CEPH
5361                         if secret_type == "ceph"
5362                         else libvirt.VIR_SECRET_USAGE_TYPE_ISCSI
5363                     )
5364                     secret = conn.secretLookupByUsage(usage_type, usage)
5365                 elif uuid:
5366                     secret = conn.secretLookupByUUIDString(uuid)
5367             except libvirt.libvirtError as err:
5368                 log.info("Secret not found: %s", err.get_error_message())
5369             if not secret:
5370                 description = "Passphrase for {} pool created by Salt".format(pool_name)
5371                 if not usage:
5372                     usage = "pool_{}".format(pool_name)
5373                 secret_xml = _gen_secret_xml(secret_type, usage, description)
5374                 if not test:
5375                     secret = conn.secretDefineXML(secret_xml)
5376             password = auth["password"]
5377             if pool_type == "rbd":
5378                 password = base64.b64decode(salt.utils.stringutils.to_bytes(password))
5379             if not test:
5380                 secret.setValue(password)
5381             auth["type"] = secret_type
5382             auth["secret"] = {
5383                 "type": "uuid" if uuid else "usage",
5384                 "value": uuid if uuid else usage,
5385             }
5386     return auth
5387 def pool_update(
5388     name,
5389     ptype,
5390     target=None,
5391     permissions=None,
5392     source_devices=None,
5393     source_dir=None,
5394     source_initiator=None,
5395     source_adapter=None,
5396     source_hosts=None,
5397     source_auth=None,
5398     source_name=None,
5399     source_format=None,
5400     test=False,
5401     **kwargs
5402 ):
5403     """
5404     Update a libvirt storage pool if needed.
5405     If called with test=True, this is also reporting whether an update would be performed.
5406     :param name: Pool name
5407     :param ptype:
5408         Pool type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_  for the
5409         possible values.
5410     :param target: Pool full path target
5411     :param permissions:
5412         Permissions to set on the target folder. This is mostly used for filesystem-based
5413         pool types. See :ref:`pool-define-permissions` for more details on this structure.
5414     :param source_devices:
5415         List of source devices for pools backed by physical devices. (Default: ``None``)
5416         Each item in the list is a dictionary with ``path`` and optionally ``part_separator``
5417         keys. The path is the qualified name for iSCSI devices.
5418         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
5419         for more information on the use of ``part_separator``
5420     :param source_dir:
5421         Path to the source directory for pools of type ``dir``, ``netfs`` or ``gluster``.
5422         (Default: ``None``)
5423     :param source_initiator:
5424         Initiator IQN for libiscsi-direct pool types. (Default: ``None``)
5425         .. versionadded:: 3000
5426     :param source_adapter:
5427         SCSI source definition. The value is a dictionary with ``type``, ``name``, ``parent``,
5428         ``managed``, ``parent_wwnn``, ``parent_wwpn``, ``parent_fabric_wwn``, ``wwnn``, ``wwpn``
5429         and ``parent_address`` keys.
5430         The ``parent_address`` value is a dictionary with ``unique_id`` and ``address`` keys.
5431         The address represents a PCI address and is itself a dictionary with ``domain``, ``bus``,
5432         ``slot`` and ``function`` properties.
5433         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
5434         for the meaning and possible values of these properties.
5435     :param source_hosts:
5436         List of source for pools backed by storage from remote servers. Each item is the hostname
5437         optionally followed by the port separated by a colon. (Default: ``None``)
5438     :param source_auth:
5439         Source authentication details. (Default: ``None``)
5440         The value is a dictionary with ``type``, ``username`` and ``secret`` keys. The type
5441         can be one of ``ceph`` for Ceph RBD or ``chap`` for iSCSI sources.
5442         The ``secret`` value links to a libvirt secret object. It is a dictionary with
5443         ``type`` and ``value`` keys. The type value can be either ``uuid`` or ``usage``.
5444         Examples:
5445         .. code-block:: python
5446             source_auth={
5447                 'type': 'ceph',
5448                 'username': 'admin',
5449                 'secret': {
5450                     'type': 'uuid',
5451                     'uuid': '2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'
5452                 }
5453             }
5454         .. code-block:: python
5455             source_auth={
5456                 'type': 'chap',
5457                 'username': 'myname',
5458                 'secret': {
5459                     'type': 'usage',
5460                     'uuid': 'mycluster_myname'
5461                 }
5462             }
5463         Since 3000, instead the source authentication can only contain ``username``
5464         and ``password`` properties. In this case the libvirt secret will be defined and used.
5465         For Ceph authentications a base64 encoded key is expected.
5466     :param source_name:
5467         Identifier of name-based sources.
5468     :param source_format:
5469         String representing the source format. The possible values are depending on the
5470         source type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_ for
5471         the possible values.
5472     :param test: run in dry-run mode if set to True
5473     :param connection: libvirt connection URI, overriding defaults
5474     :param username: username to connect with, overriding defaults
5475     :param password: password to connect with, overriding defaults
5476     .. rubric:: Example:
5477     Local folder pool:
5478     .. code-block:: bash
5479         salt '*' virt.pool_update somepool dir target=/srv/mypool \
5480                                   permissions="{'mode': '0744' 'ower': 107, 'group': 107 }"
5481     CIFS backed pool:
5482     .. code-block:: bash
5483         salt '*' virt.pool_update myshare netfs source_format=cifs \
5484                                   source_dir=samba_share source_hosts="['example.com']" target=/mnt/cifs
5485     .. versionadded:: 3000
5486     """
5487     conn = __get_conn(**kwargs)
5488     needs_update = False
5489     try:
5490         pool = conn.storagePoolLookupByName(name)
5491         old_xml = ElementTree.fromstring(pool.XMLDesc())
5492         secret_node = old_xml.find("source/auth/secret")
5493         usage = secret_node.get("usage") if secret_node is not None else None
5494         uuid = secret_node.get("uuid") if secret_node is not None else None
5495         auth = _pool_set_secret(
5496             conn, ptype, name, source_auth, uuid=uuid, usage=usage, test=test
5497         )
5498         new_xml = ElementTree.fromstring(
5499             _gen_pool_xml(
5500                 name,
5501                 ptype,
5502                 target,
5503                 permissions=permissions,
5504                 source_devices=source_devices,
5505                 source_dir=source_dir,
5506                 source_initiator=source_initiator,
5507                 source_adapter=source_adapter,
5508                 source_hosts=source_hosts,
5509                 source_auth=auth,
5510                 source_name=source_name,
5511                 source_format=source_format,
5512             )
5513         )
5514         elements_to_copy = ["available", "allocation", "capacity", "uuid"]
5515         for to_copy in elements_to_copy:
5516             element = old_xml.find(to_copy)
5517             new_xml.insert(1, element)
5518         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
5519         xmlutil.strip_spaces(new_xml)
5520         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
5521         if needs_update and not test:
5522             conn.storagePoolDefineXML(xmlutil.element_to_str(new_xml))
5523     finally:
5524         conn.close()
5525     return needs_update
5526 def list_pools(**kwargs):
5527     """
5528     List all storage pools.
5529     :param connection: libvirt connection URI, overriding defaults
5530     :param username: username to connect with, overriding defaults
5531     :param password: password to connect with, overriding defaults
5532     .. versionadded:: 2019.2.0
5533     CLI Example:
5534     .. code-block:: bash
5535         salt '*' virt.list_pools
5536     """
5537     conn = __get_conn(**kwargs)
5538     try:
5539         return [pool.name() for pool in conn.listAllStoragePools()]
5540     finally:
5541         conn.close()
5542 def pool_info(name=None, **kwargs):
5543     """
5544     Return information on a storage pool provided its name.
5545     :param name: libvirt storage pool name
5546     :param connection: libvirt connection URI, overriding defaults
5547     :param username: username to connect with, overriding defaults
5548     :param password: password to connect with, overriding defaults
5549     If no name is provided, return the infos for all defined storage pools.
5550     .. versionadded:: 2019.2.0
5551     CLI Example:
5552     .. code-block:: bash
5553         salt '*' virt.pool_info default
5554     """
5555     result = {}
5556     conn = __get_conn(**kwargs)
5557     def _pool_extract_infos(pool):
5558         """
5559         Format the pool info dictionary
5560         :param pool: the libvirt pool object
5561         """
5562         states = ["inactive", "building", "running", "degraded", "inaccessible"]
5563         infos = pool.info()
5564         state = states[infos[0]] if infos[0] &lt; len(states) else "unknown"
5565         desc = ElementTree.fromstring(pool.XMLDesc())
5566         path_node = desc.find("target/path")
5567         return {
5568             "uuid": pool.UUIDString(),
5569             "state": state,
5570             "capacity": infos[1],
5571             "allocation": infos[2],
5572             "free": infos[3],
5573             "autostart": pool.autostart(),
5574             "persistent": pool.isPersistent(),
5575             "target_path": path_node.text if path_node is not None else None,
5576             "type": desc.get("type"),
5577         }
5578     try:
5579         pools = [
5580             pool
5581             for pool in conn.listAllStoragePools()
5582             if name is None or pool.name() == name
5583         ]
5584         result = {pool.name(): _pool_extract_infos(pool) for pool in pools}
5585     except libvirt.libvirtError as err:
5586         log.debug("Silenced libvirt error: %s", err)
5587     finally:
5588         conn.close()
5589     return result
5590 def pool_get_xml(name, **kwargs):
5591     """
5592     Return the XML definition of a virtual storage pool
5593     :param name: libvirt storage pool name
5594     :param connection: libvirt connection URI, overriding defaults
5595     :param username: username to connect with, overriding defaults
5596     :param password: password to connect with, overriding defaults
5597     .. versionadded:: 3000
5598     CLI Example:
5599     .. code-block:: bash
5600         salt '*' virt.pool_get_xml default
5601     """
5602     conn = __get_conn(**kwargs)
5603     try:
5604         return conn.storagePoolLookupByName(name).XMLDesc()
5605     finally:
5606         conn.close()
5607 def pool_start(name, **kwargs):
5608     """
5609     Start a defined libvirt storage pool.
5610     :param name: libvirt storage pool name
5611     :param connection: libvirt connection URI, overriding defaults
5612     :param username: username to connect with, overriding defaults
5613     :param password: password to connect with, overriding defaults
5614     .. versionadded:: 2019.2.0
5615     CLI Example:
5616     .. code-block:: bash
5617         salt '*' virt.pool_start default
5618     """
5619     conn = __get_conn(**kwargs)
5620     try:
5621         pool = conn.storagePoolLookupByName(name)
5622         return not bool(pool.create())
5623     finally:
5624         conn.close()
5625 def pool_build(name, **kwargs):
5626     """
5627     Build a defined libvirt storage pool.
5628     :param name: libvirt storage pool name
5629     :param connection: libvirt connection URI, overriding defaults
5630     :param username: username to connect with, overriding defaults
5631     :param password: password to connect with, overriding defaults
5632     .. versionadded:: 2019.2.0
5633     CLI Example:
5634     .. code-block:: bash
5635         salt '*' virt.pool_build default
5636     """
5637     conn = __get_conn(**kwargs)
5638     try:
5639         pool = conn.storagePoolLookupByName(name)
5640         return not bool(pool.build())
5641     finally:
5642         conn.close()
5643 def pool_stop(name, **kwargs):
5644     """
5645     Stop a defined libvirt storage pool.
5646     :param name: libvirt storage pool name
5647     :param connection: libvirt connection URI, overriding defaults
5648     :param username: username to connect with, overriding defaults
5649     :param password: password to connect with, overriding defaults
5650     .. versionadded:: 2019.2.0
5651     CLI Example:
5652     .. code-block:: bash
5653         salt '*' virt.pool_stop default
5654     """
5655     conn = __get_conn(**kwargs)
5656     try:
5657         pool = conn.storagePoolLookupByName(name)
5658         return not bool(pool.destroy())
5659     finally:
5660         conn.close()
5661 def pool_undefine(name, **kwargs):
5662     """
5663     Remove a defined libvirt storage pool. The pool needs to be stopped before calling.
5664     :param name: libvirt storage pool name
5665     :param connection: libvirt connection URI, overriding defaults
5666     :param username: username to connect with, overriding defaults
5667     :param password: password to connect with, overriding defaults
5668     .. versionadded:: 2019.2.0
5669     CLI Example:
5670     .. code-block:: bash
5671         salt '*' virt.pool_undefine default
5672     """
5673     conn = __get_conn(**kwargs)
5674     try:
5675         pool = conn.storagePoolLookupByName(name)
5676         desc = ElementTree.fromstring(pool.XMLDesc())
5677         auth_node = desc.find("source/auth")
5678         if auth_node is not None:
5679             auth_types = {
5680                 "ceph": libvirt.VIR_SECRET_USAGE_TYPE_CEPH,
5681                 "iscsi": libvirt.VIR_SECRET_USAGE_TYPE_ISCSI,
5682             }
5683             secret_type = auth_types[auth_node.get("type")]
5684             secret_usage = auth_node.find("secret").get("usage")
5685             if secret_type and "pool_{}".format(name) == secret_usage:
5686                 secret = conn.secretLookupByUsage(secret_type, secret_usage)
5687                 secret.undefine()
5688         return not bool(pool.undefine())
5689     finally:
5690         conn.close()
5691 def pool_delete(name, **kwargs):
5692     """
5693     Delete the resources of a defined libvirt storage pool.
5694     :param name: libvirt storage pool name
5695     :param connection: libvirt connection URI, overriding defaults
5696     :param username: username to connect with, overriding defaults
5697     :param password: password to connect with, overriding defaults
5698     .. versionadded:: 2019.2.0
5699     CLI Example:
5700     .. code-block:: bash
5701         salt '*' virt.pool_delete default
5702     """
5703     conn = __get_conn(**kwargs)
5704     try:
5705         pool = conn.storagePoolLookupByName(name)
5706         return not bool(pool.delete(libvirt.VIR_STORAGE_POOL_DELETE_NORMAL))
5707     finally:
5708         conn.close()
5709 def pool_refresh(name, **kwargs):
5710     """
5711     Refresh a defined libvirt storage pool.
5712     :param name: libvirt storage pool name
5713     :param connection: libvirt connection URI, overriding defaults
5714     :param username: username to connect with, overriding defaults
5715     :param password: password to connect with, overriding defaults
5716     .. versionadded:: 2019.2.0
5717     CLI Example:
5718     .. code-block:: bash
5719         salt '*' virt.pool_refresh default
5720     """
5721     conn = __get_conn(**kwargs)
5722     try:
5723         pool = conn.storagePoolLookupByName(name)
5724         return not bool(pool.refresh())
5725     finally:
5726         conn.close()
5727 def pool_set_autostart(name, state="on", **kwargs):
5728     """
5729     Set the autostart flag on a libvirt storage pool so that the storage pool
5730     will start with the host system on reboot.
5731     :param name: libvirt storage pool name
5732     :param state: 'on' to auto start the pool, anything else to mark the
5733                   pool not to be started when the host boots
5734     :param connection: libvirt connection URI, overriding defaults
5735     :param username: username to connect with, overriding defaults
5736     :param password: password to connect with, overriding defaults
5737     .. versionadded:: 2019.2.0
5738     CLI Example:
5739     .. code-block:: bash
5740         salt "*" virt.pool_set_autostart &lt;pool&gt; &lt;on | off&gt;
5741     """
5742     conn = __get_conn(**kwargs)
5743     try:
5744         pool = conn.storagePoolLookupByName(name)
5745         return not bool(pool.setAutostart(1 if state == "on" else 0))
5746     finally:
5747         conn.close()
5748 def pool_list_volumes(name, **kwargs):
5749     """
5750     List the volumes contained in a defined libvirt storage pool.
5751     :param name: libvirt storage pool name
5752     :param connection: libvirt connection URI, overriding defaults
5753     :param username: username to connect with, overriding defaults
5754     :param password: password to connect with, overriding defaults
5755     .. versionadded:: 2019.2.0
5756     CLI Example:
5757     .. code-block:: bash
5758         salt "*" virt.pool_list_volumes &lt;pool&gt;
5759     """
5760     conn = __get_conn(**kwargs)
5761     try:
5762         pool = conn.storagePoolLookupByName(name)
5763         return pool.listVolumes()
5764     finally:
5765         conn.close()
5766 def _get_storage_vol(conn, pool, vol):
5767     """
5768     Helper function getting a storage volume. Will throw a libvirtError
5769     if the pool or the volume couldn't be found.
5770     :param conn: libvirt connection object to use
5771     :param pool: pool name
5772     :param vol: volume name
5773     """
5774     pool_obj = conn.storagePoolLookupByName(pool)
5775     return pool_obj.storageVolLookupByName(vol)
5776 def _is_valid_volume(vol):
5777     """
5778     Checks whether a volume is valid for further use since those may have disappeared since
5779     the last pool refresh.
5780     """
5781     try:
5782         def discarder(ctxt, error):  # pylint: disable=unused-argument
5783             log.debug("Ignore libvirt error: %s", error[2])
5784         libvirt.registerErrorHandler(discarder, None)
5785         vol.info()
5786         libvirt.registerErrorHandler(None, None)
5787         return True
5788     except libvirt.libvirtError as err:
5789         return False
5790 def _get_all_volumes_paths(conn):
5791     """
5792     Extract the path, name, pool name and backing stores path of all volumes.
5793     :param conn: libvirt connection to use
5794     """
5795     pools = [
5796         pool
5797         for pool in conn.listAllStoragePools()
5798         if pool.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
5799     ]
5800     for pool in pools:
5801         pool_volumes = {
5802             volume<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.path(): {
5803                 "pool": pool.name(),
5804                 "name": volume.name(),
5805                 "backing_stores": [
5806                     path.text
5807                     for path in ElementTree.fromstring(volume.XMLDesc()).</b></font>findall(
5808                         ".//backingStore/path"
5809                     )
5810                 ],
5811             }
5812             for volume in pool.listAllVolumes()
5813             if _is_valid_volume(volume)
5814         }
5815         volumes.update(pool_volumes)
5816     return volumes
5817 def volume_infos(pool=None, volume=None, **kwargs):
5818     """
5819     Provide details on a storage volume. If no volume name is provided, the infos
5820     all the volumes contained in the pool are provided. If no pool is provided,
5821     the infos of the volumes of all pools are output.
5822     :param pool: libvirt storage pool name (default: ``None``)
5823     :param volume: name of the volume to get infos from (default: ``None``)
5824     :param connection: libvirt connection URI, overriding defaults
5825     :param username: username to connect with, overriding defaults
5826     :param password: password to connect with, overriding defaults
5827     .. versionadded:: 3000
5828     CLI Example:
5829     .. code-block:: bash
5830         salt "*" virt.volume_infos &lt;pool&gt; &lt;volume&gt;
5831     """
5832     result = {}
5833     conn = __get_conn(**kwargs)
5834     try:
5835         backing_stores = _get_all_volumes_paths(conn)
5836         try:
5837             domains = _get_domain(conn)
5838             domains_list = domains if isinstance(domains, list) else [domains]
5839         except CommandExecutionError:
5840             domains_list = []
5841         disks = {
5842             domain.name(): {
5843                 node.get("file")
5844                 for node in ElementTree.fromstring(domain.XMLDesc(0)).findall(
5845                     ".//disk/source/[@file]"
5846                 )
5847             }
5848             for domain in domains_list
5849         }
5850         def _volume_extract_infos(vol):
5851             """
5852             Format the volume info dictionary
5853             :param vol: the libvirt storage volume object.
5854             """
5855             types = ["file", "block", "dir", "network", "netdir", "ploop"]
5856             infos = vol.info()
5857             vol_xml = ElementTree.fromstring(vol.XMLDesc())
5858             backing_store_path = vol_xml.find("./backingStore/path")
5859             backing_store_format = vol_xml.find("./backingStore/format")
5860             backing_store = None
5861             if backing_store_path is not None:
5862                 backing_store = {
5863                     "path": backing_store_path.text,
5864                     "format": backing_store_format.get("type")
5865                     if backing_store_format is not None
5866                     else None,
5867                 }
5868             format_node = vol_xml.find("./target/format")
5869             used_by = []
5870             if vol.path():
5871                 as_backing_store = {
5872                     path
5873                     for (path, volume) in backing_stores.items()
5874                     if vol.path() in volume.get("backing_stores")
5875                 }
5876                 used_by = [
5877                     vm_name
5878                     for (vm_name, vm_disks) in disks.items()
5879                     if vm_disks &amp; as_backing_store or vol.path() in vm_disks
5880                 ]
5881             return {
5882                 "type": types[infos[0]] if infos[0] &lt; len(types) else "unknown",
5883                 "key": vol.key(),
5884                 "path": vol.path(),
5885                 "capacity": infos[1],
5886                 "allocation": infos[2],
5887                 "used_by": used_by,
5888                 "backing_store": backing_store,
5889                 "format": format_node.get("type") if format_node is not None else None,
5890             }
5891         pools = [
5892             obj
5893             for obj in conn.listAllStoragePools()
5894             if (pool is None or obj.name() == pool)
5895             and obj.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
5896         ]
5897         vols = {
5898             pool_obj.name(): {
5899                 vol.name(): _volume_extract_infos(vol)
5900                 for vol in pool_obj.listAllVolumes()
5901                 if (volume is None or vol.name() == volume) and _is_valid_volume(vol)
5902             }
5903             for pool_obj in pools
5904         }
5905         return {pool_name: volumes for (pool_name, volumes) in vols.items() if volumes}
5906     except libvirt.libvirtError as err:
5907         log.debug("Silenced libvirt error: %s", err)
5908     finally:
5909         conn.close()
5910     return result
5911 def volume_delete(pool, volume, **kwargs):
5912     """
5913     Delete a libvirt managed volume.
5914     :param pool: libvirt storage pool name
5915     :param volume: name of the volume to delete
5916     :param connection: libvirt connection URI, overriding defaults
5917     :param username: username to connect with, overriding defaults
5918     :param password: password to connect with, overriding defaults
5919     .. versionadded:: 3000
5920     CLI Example:
5921     .. code-block:: bash
5922         salt "*" virt.volume_delete &lt;pool&gt; &lt;volume&gt;
5923     """
5924     conn = __get_conn(**kwargs)
5925     try:
5926         vol = _get_storage_vol(conn, pool, volume)
5927         return not bool(vol.delete())
5928     finally:
5929         conn.close()
5930 def volume_define(
5931     pool,
5932     name,
5933     size,
5934     allocation=0,
5935     format=None,
5936     type=None,
5937     permissions=None,
5938     backing_store=None,
5939     nocow=False,
5940     **kwargs
5941 ):
5942     """
5943     Create libvirt volume.
5944     :param pool: name of the pool to create the volume in
5945     :param name: name of the volume to define
5946     :param size: capacity of the volume to define in MiB
5947     :param allocation: allocated size of the volume in MiB. Defaults to 0.
5948     :param format:
5949         volume format. The allowed values are depending on the pool type.
5950         Check the virt.pool_capabilities output for the possible values and the default.
5951     :param type:
5952         type of the volume. One of file, block, dir, network, netdiri, ploop or None.
5953         By default, the type is guessed by libvirt from the pool type.
5954     :param permissions:
5955         Permissions to set on the target folder. This is mostly used for filesystem-based
5956         pool types. See :ref:`pool-define-permissions` for more details on this structure.
5957     :param backing_store:
5958         dictionary describing a backing file for the volume. It must contain a ``path``
5959         property pointing to the base volume and a ``format`` property defining the format
5960         of the base volume.
5961         The base volume format will not be guessed for security reasons and is thus mandatory.
5962     :param nocow: disable COW for the volume.
5963     :param connection: libvirt connection URI, overriding defaults
5964     :param username: username to connect with, overriding defaults
5965     :param password: password to connect with, overriding defaults
5966     .. rubric:: CLI Example:
5967     Volume on ESX:
5968     .. code-block:: bash
5969         salt '*' virt.volume_define "[local-storage]" myvm/myvm.vmdk vmdk 8192
5970     QCow2 volume with backing file:
5971     .. code-block:: bash
5972         salt '*' virt.volume_define default myvm.qcow2 qcow2 8192 \
5973                             permissions="{'mode': '0775', 'owner': '123', 'group': '345'"}" \
5974                             backing_store="{'path': '/path/to/base.img', 'format': 'raw'}" \
5975                             nocow=True
5976     .. versionadded:: 3001
5977     """
5978     ret = False
5979     try:
5980         conn = __get_conn(**kwargs)
5981         pool_obj = conn.storagePoolLookupByName(pool)
5982         pool_type = ElementTree.fromstring(pool_obj.XMLDesc()).get("type")
5983         new_allocation = allocation
5984         if pool_type == "logical" and size != allocation:
5985             new_allocation = size
5986         xml = _gen_vol_xml(
5987             name,
5988             size,
5989             format=format,
5990             allocation=new_allocation,
5991             type=type,
5992             permissions=permissions,
5993             backing_store=backing_store,
5994             nocow=nocow,
5995         )
5996         ret = _define_vol_xml_str(conn, xml, pool=pool)
5997     except libvirt.libvirtError as err:
5998         raise CommandExecutionError(err.get_error_message())
5999     finally:
6000         conn.close()
6001     return ret
6002 def _volume_upload(conn, pool, volume, file, offset=0, length=0, sparse=False):
6003     """
6004     Function performing the heavy duty for volume_upload but using an already
6005     opened libvirt connection.
6006     """
6007     def handler(stream, nbytes, opaque):
6008         return os.read(opaque, nbytes)
6009     def holeHandler(stream, opaque):
6010         """
6011         Taken from the sparsestream.py libvirt-python example.
6012         """
6013         fd = opaque
6014         cur = os.lseek(fd, 0, os.SEEK_CUR)
6015         try:
6016             data = os.lseek(fd, cur, os.SEEK_DATA)
6017         except OSError as e:
6018             if e.errno != 6:
6019                 raise e
6020             else:
6021                 data = -1
6022         if data &lt; 0:
6023             inData = False
6024             eof = os.lseek(fd, 0, os.SEEK_END)
6025             if eof &lt; cur:
6026                 raise RuntimeError("Current position in file after EOF: {}".format(cur))
6027             sectionLen = eof - cur
6028         else:
6029             if data &gt; cur:
6030                 inData = False
6031                 sectionLen = data - cur
6032             else:
6033                 inData = True
6034                 hole = os.lseek(fd, data, os.SEEK_HOLE)
6035                 if hole &lt; 0:
6036                     raise RuntimeError("No trailing hole")
6037                 if hole == data:
6038                     raise RuntimeError("Impossible happened")
6039                 else:
6040                     sectionLen = hole - data
6041         os.lseek(fd, cur, os.SEEK_SET)
6042         return [inData, sectionLen]
6043     def skipHandler(stream, length, opaque):
6044         return os.lseek(opaque, length, os.SEEK_CUR)
6045     stream = None
6046     fd = None
6047     ret = False
6048     try:
6049         pool_obj = conn.storagePoolLookupByName(pool)
6050         vol_obj = pool_obj.storageVolLookupByName(volume)
6051         stream = conn.newStream()
6052         fd = os.open(file, os.O_RDONLY)
6053         vol_obj.upload(
6054             stream,
6055             offset,
6056             length,
6057             libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM if sparse else 0,
6058         )
6059         if sparse:
6060             stream.sparseSendAll(handler, holeHandler, skipHandler, fd)
6061         else:
6062             stream.sendAll(handler, fd)
6063         ret = True
6064     except libvirt.libvirtError as err:
6065         raise CommandExecutionError(err.get_error_message())
6066     finally:
6067         if fd:
6068             try:
6069                 os.close(fd)
6070             except OSError as err:
6071                 if stream:
6072                     stream.abort()
6073                 if ret:
6074                     raise CommandExecutionError(
6075                         "Failed to close file: {}".format(err.strerror)
6076                     )
6077         if stream:
6078             try:
6079                 stream.finish()
6080             except libvirt.libvirtError as err:
6081                 if ret:
6082                     raise CommandExecutionError(
6083                         "Failed to finish stream: {}".format(err.get_error_message())
6084                     )
6085     return ret
6086 def volume_upload(pool, volume, file, offset=0, length=0, sparse=False, **kwargs):
6087     """
6088     Create libvirt volume.
6089     :param pool: name of the pool to create the volume in
6090     :param name: name of the volume to define
6091     :param file: the file to upload to the volume
6092     :param offset: where to start writing the data in the volume
6093     :param length: amount of bytes to transfer to the volume
6094     :param sparse: set to True to preserve data sparsiness.
6095     :param connection: libvirt connection URI, overriding defaults
6096     :param username: username to connect with, overriding defaults
6097     :param password: password to connect with, overriding defaults
6098     .. rubric:: CLI Example:
6099     .. code-block:: bash
6100         salt '*' virt.volume_upload default myvm.qcow2 /path/to/disk.qcow2
6101     .. versionadded:: 3001
6102     """
6103     conn = __get_conn(**kwargs)
6104     ret = False
6105     try:
6106         ret = _volume_upload(
6107             conn, pool, volume, file, offset=offset, length=length, sparse=sparse
6108         )
6109     finally:
6110         conn.close()
6111     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
