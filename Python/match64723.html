<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_apigateway.py &amp; virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_apigateway.py &amp; virt_1.py
      </h3>
<h1 align="center">
        4.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_apigateway.py (9.476876%)<th>virt_1.py (3.2228954%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(395-448)<td><a href="#" name="0">(7722-7809)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1965-1976)<td><a href="#" name="1">(3948-3958)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(658-661)<td><a href="#" name="2">(4072-4090)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1-23)<td><a href="#" name="3">(133-155)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(596-601)<td><a href="#" name="4">(3284-3291)</a><td align="center"><font color="#da0000">18</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(2231-2240)<td><a href="#" name="5">(6457-6469)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(1395-1405)<td><a href="#" name="6">(6661-6666)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1236-1242)<td><a href="#" name="7">(4514-4517)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(299-313)<td><a href="#" name="8">(6892-7125)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(625-629)<td><a href="#" name="9">(2970-2977)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1442-1450)<td><a href="#" name="10">(6510-6517)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1311-1317)<td><a href="#" name="11">(8657-8662)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(1104-1114)<td><a href="#" name="12">(3451-3457)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(743-745)<td><a href="#" name="13">(3251-3255)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(812-814)<td><a href="#" name="14">(6763-6767)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(775-777)<td><a href="#" name="15">(6419-6422)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="3"></a><font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import datetime
2 import logging
3 import os
4 import random
5 import string
6 import pytest
7 import salt.config
8 import salt.loader
9 import salt.states.boto_apigateway as boto_apigateway
10 import salt.utils.files
11 import salt.utils.yaml
12 from salt.utils.versions import LooseVersion
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase, skipIf
16 from tests.unit.modules.test_boto_apigateway import BotoApiGatewayTestCaseMixin
17 try:
18     import boto3
19     import</b></font> botocore
20     from botocore.exceptions import ClientError
21     HAS_BOTO = True
22 except ImportError:
23     HAS_BOTO = False
24 required_boto3_version = "1.2.1"
25 required_botocore_version = "1.4.49"
26 region = "us-east-1"
27 access_key = "GKTADJGHEIQSXMKKRBJ08H"
28 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
29 conn_parameters = {
30     "region": region,
31     "key": access_key,
32     "keyid": secret_key,
33     "profile": {},
34 }
35 error_message = (
36     "An error occurred (101) when calling the {0} operation: Test-defined error"
37 )
38 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
39 api_ret = dict(
40     description=(
41         '{\n    "context": "See deployment or stage description",\n   '
42         ' "provisioned_by": "Salt boto_apigateway.present State"\n}'
43     ),
44     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
45     id="vni0vq8wzi",
46     name="unit test api",
47 )
48 no_apis_ret = {"items": []}
49 apis_ret = {"items": [api_ret]}
50 mock_model_ret = dict(
51     contentType="application/json",
52     description="mock model",
53     id="123abc",
54     name="mock model",
55     schema=(
56         "{\n"
57         '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
58         '    "properties": {\n'
59         '        "field": {\n'
60         '            "type": "string"\n'
61         "        }\n"
62         "    }\n"
63         "}"
64     ),
65 )
66 models_ret = {
67     "items": [
68         dict(
69             contentType="application/json",
70             description="Error",
71             id="50nw8r",
72             name="Error",
73             schema=(
74                 "{\n"
75                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
76                 '    "properties": {\n'
77                 '        "code": {\n'
78                 '            "format": "int32",\n'
79                 '            "type": "integer"\n'
80                 "        },\n"
81                 '        "fields": {\n'
82                 '            "type": "string"\n'
83                 "        },\n"
84                 '        "message": {\n'
85                 '            "type": "string"\n'
86                 "        }\n"
87                 "    },\n"
88                 '    "title": "Error Schema",\n'
89                 '    "type": "object"\n'
90                 "}"
91             ),
92         ),
93         dict(
94             contentType="application/json",
95             description="User",
96             id="terlnw",
97             name="User",
98             schema=(
99                 "{\n"
100                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
101                 '    "properties": {\n'
102                 '        "password": {\n'
103                 '            "description": "A password for the new user",\n'
104                 '            "type": "string"\n'
105                 "        },\n"
106                 '        "username": {\n'
107                 '            "description": "A unique username for the user",\n'
108                 '            "type": "string"\n'
109                 "        }\n"
110                 "    },\n"
111                 '    "title": "User Schema",\n'
112                 '    "type": "object"\n'
113                 "}"
114             ),
115         ),
116     ]
117 }
118 root_resources_ret = {"items": [dict(id="bgk0rk8rqb", path="/")]}
119 resources_ret = {
120     "items": [
121         dict(id="bgk0rk8rqb", path="/"),
122         dict(
123             id="9waiaz",
124             parentId="bgk0rk8rqb",
125             path="/users",
126             pathPart="users",
127             resourceMethods={"POST": {}},
128         ),
129     ]
130 }
131 no_resources_ret = {"items": []}
132 stage1_deployment1_ret = dict(
133     cacheClusterEnabled=False,
134     cacheClusterSize=0.5,
135     cacheClusterStatus="NOT_AVAILABLE",
136     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
137     deploymentId="kobnrb",
138     description=(
139         "{\n"
140         '    "current_deployment_label": {\n'
141         '        "api_name": "unit test api",\n'
142         '        "swagger_file": "temp-swagger-sample.yaml",\n'
143         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
144         '        "swagger_info_object": {\n'
145         '            "description": "salt boto apigateway unit test service",\n'
146         '            "title": "salt boto apigateway unit test service",\n'
147         '            "version": "0.0.0"\n'
148         "        }\n"
149         "    }\n"
150         "}"
151     ),
152     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
153     methodSettings=dict(),
154     stageName="test",
155     variables=dict(),
156 )
157 stage1_deployment1_vars_ret = dict(
158     cacheClusterEnabled=False,
159     cacheClusterSize=0.5,
160     cacheClusterStatus="NOT_AVAILABLE",
161     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
162     deploymentId="kobnrb",
163     description=(
164         "{\n"
165         '    "current_deployment_label": {\n'
166         '        "api_name": "unit test api",\n'
167         '        "swagger_file": "temp-swagger-sample.yaml",\n'
168         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
169         '        "swagger_info_object": {\n'
170         '            "description": "salt boto apigateway unit test service",\n'
171         '            "title": "salt boto apigateway unit test service",\n'
172         '            "version": "0.0.0"\n'
173         "        }\n"
174         "    }\n"
175         "}"
176     ),
177     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
178     methodSettings=dict(),
179     stageName="test",
180     variables={"var1": "val1"},
181 )
182 stage1_deployment2_ret = dict(
183     cacheClusterEnabled=False,
184     cacheClusterSize=0.5,
185     cacheClusterStatus="NOT_AVAILABLE",
186     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
187     deploymentId="kobnrc",
188     description=(
189         "{\n"
190         '    "current_deployment_label": {\n'
191         '        "api_name": "unit test api",\n'
192         '        "swagger_file": "temp-swagger-sample.yaml",\n'
193         '        "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
194         '        "swagger_info_object": {\n'
195         '            "description": "salt boto apigateway unit test service",\n'
196         '            "title": "salt boto apigateway unit test service",\n'
197         '            "version": "0.0.2"\n'
198         "        }\n"
199         "    }\n"
200         "}"
201     ),
202     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
203     methodSettings=dict(),
204     stageName="test",
205     variables=dict(),
206 )
207 stage2_ret = dict(
208     cacheClusterEnabled=False,
209     cacheClusterSize=0.5,
210     cacheClusterStatus="NOT_AVAILABLE",
211     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
212     deploymentId="kobnrb",
213     description=(
214         "{\n"
215         '    "current_deployment_label": {\n'
216         '        "api_name": "unit test api",\n'
217         '        "swagger_file": "temp-swagger-sample.yaml",\n'
218         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
219         '        "swagger_info_object": {\n'
220         '            "description": "salt boto apigateway unit test service",\n'
221         '            "title": "salt boto apigateway unit test service",\n'
222         '            "version": "0.0.0"\n'
223         "        }\n"
224         "    }\n"
225         "}"
226     ),
227     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
228     methodSettings=dict(),
229     stageName="dev",
230     variables=dict(),
231 )
232 stages_stage2_ret = {"item": [stage2_ret]}
233 no_stages_ret = {"item": []}
234 deployment1_ret = dict(
235     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
236     description=(
237         "{\n"
238         '    "api_name": "unit test api",\n'
239         '    "swagger_file": "temp-swagger-sample.yaml",\n'
240         '    "swagger_file_md5sum": "55a948ff90ad80ff747ec91657c7a299",\n'
241         '    "swagger_info_object": {\n'
242         '        "description": "salt boto apigateway unit test service",\n'
243         '        "title": "salt boto apigateway unit test service",\n'
244         '        "version": "0.0.0"\n'
245         "    }\n"
246         "}"
247     ),
248     id="kobnrb",
249 )
250 deployment2_ret = dict(
251     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
252     description=(
253         "{\n"
254         '    "api_name": "unit test api",\n'
255         '    "swagger_file": "temp-swagger-sample.yaml",\n'
256         '    "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
257         '    "swagger_info_object": {\n'
258         '        "description": "salt boto apigateway unit test service",\n'
259         '        "title": "salt boto apigateway unit test service",\n'
260         '        "version": "0.0.2"\n'
261         "    }\n"
262         "}"
263     ),
264     id="kobnrc",
265 )
266 <a name="8"></a>deployments_ret = {"items": [deployment1_ret, deployment2_ret]}
267 function_ret = dict(
268     FunctionName<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="unit_test_api_users_post",
269     Runtime="python2.7",
270     Role=None,
271     Handler="handler",
272     Description="abcdefg",
273     Timeout=5,
274     MemorySize=128,
275     CodeSha256="abcdef",
276     CodeSize=199,
277     FunctionArn="arn:lambda:us-east-1:1234:Something",
278     LastModified="yes",
279 )
280 method_integration_response_200_ret = dict(
281     responseParameters={"method.response.header.Access-Control-Allow-Origin"</b></font>: "*"},
282     responseTemplates={},
283     selectionPattern=".*",
284     statusCode="200",
285 )
286 method_integration_ret = dict(
287     cacheKeyParameters={},
288     cacheNamespace="9waiaz",
289     credentials="arn:aws:iam::1234:role/apigatewayrole",
290     httpMethod="POST",
291     integrationResponses={"200": method_integration_response_200_ret},
292     requestParameters={},
293     requestTemplates={
294         "application/json": (
295             "#set($inputRoot = $input.path('$')){\"header-params\" : {#set ($map ="
296             ' $input.params().header)#foreach( $param in $map.entrySet() )"$param.key"'
297             ' : "$param.value" #if( $foreach.hasNext ), #end#end},"query-params" :'
298             " {#set ($map = $input.params().querystring)#foreach( $param in"
299             ' $map.entrySet() )"$param.key" : "$param.value" #if( $foreach.hasNext ),'
300             ' #end#end},"path-params" : {#set ($map = $input.params().path)#foreach('
301             ' $param in $map.entrySet() )"$param.key" : "$param.value" #if('
302             " $foreach.hasNext ), #end#end},\"body-params\" : $input.json('$')}"
303         )
304     },
305     type="AWS",
306     uri=(
307         "arn:aws:apigateway:us-west-2:"
308         "lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:1234567:"
309         "function:unit_test_api_api_users_post/invocations"
310     ),
311 )
312 method_response_200_ret = dict(
313     responseModels={"application/json": "User"},
314     responseParameters={"method.response.header.Access-Control-Allow-Origin": False},
315     statusCode="200",
316 )
317 method_ret = dict(
318     apiKeyRequired=False,
319     authorizationType="None",
320     httpMethod="POST",
321     methodIntegration=method_integration_ret,
322     methodResponses={"200": method_response_200_ret},
323     requestModels={"application/json": "User"},
324     requestParameters={},
325 )
326 throttle_rateLimit = 10.0
327 association_stage_1 = {"apiId": "apiId1", "stage": "stage1"}
328 association_stage_2 = {"apiId": "apiId1", "stage": "stage2"}
329 log = logging.getLogger(__name__)
330 def _has_required_boto():
331     if not HAS_BOTO:
332         return False
333     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
334         return False
335     else:
336         return True
337 def _has_required_botocore():
338     if not HAS_BOTO:
339         return False
340     elif LooseVersion(botocore.__version__) &lt; LooseVersion(required_botocore_version):
341         return False
342     else:
343         return True
344 <a name="0"></a>
345 class TempSwaggerFile:
346     _tmp_swagger_dict <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
347         "info": {
348             "version": "0.0.0",
349             "description": "salt boto apigateway unit test service",
350             "title": "salt boto apigateway unit test service",
351         },
352         "paths": {
353             "/users": {
354                 "post": {
355                     "responses": {
356                         "200": {
357                             "headers": {
358                                 "Access-Control-Allow-Origin": {"type": "string"}
359                             },
360                             "description": "The username of the new user",
361                             "schema": {"$ref": "#/definitions/User"},
362                         }
363                     },
364                     "parameters": [
365                         {
366                             "in": "body",
367                             "description": "New user details.",
368                             "name": "NewUser",
369                             "schema": {"$ref": "#/definitions/User"},
370                         }
371                     ],
372                     "produces": ["application/json"],
373                     "description": "Creates a new user.",
374                     "tags": ["Auth"],
375                     "consumes": ["application/json"],
376                     "summary": "Registers a new user",
377                 }
378             }
379         },
380         "schemes": ["https"],
381         "produces": ["application/json"],
382         "basePath": "/api",
383         "host": "rm06h9oac4.execute-api.us-west-2.amazonaws.com",
384         "definitions": {
385             "User": {
386                 "properties": {
387                     "username": {
388                         "type": "string",
389                         "description": "A unique username for the user",
390                     },
391                     "password": {
392                         "type": "string",
393                         "description": "A password for the new user",
394                     },
395                 }
396             },
397             "Error": {
398                 "properties": {
399                     "fields"</b></font>: {"type": "string"},
400                     "message": {"type": "string"},
401                     "code": {"type": "integer", "format": "int32"},
402                 }
403             },
404         },
405         "swagger": "2.0",
406     }
407     def __enter__(self):
408         self.swaggerfile = "temp-swagger-sample.yaml"
409         with salt.utils.files.fopen(self.swaggerfile, "w") as fp_:
410             salt.utils.yaml.safe_dump(self.swaggerdict, fp_, default_flow_style=False)
411         return self.swaggerfile
412     def __exit__(self, objtype, value, traceback):
413         os.remove(self.swaggerfile)
414     def __init__(self, create_invalid_file=False):
415         if create_invalid_file:
416             self.swaggerdict = TempSwaggerFile._tmp_swagger_dict.copy()
417             self.swaggerdict["invalid_key"] = "invalid"
418             self.swaggerdict.pop("schemes", None)
419             self.swaggerdict["swagger"] = "3.0"
420             self.swaggerdict.pop("info", None)
421         else:
422             self.swaggerdict = TempSwaggerFile._tmp_swagger_dict
423 class BotoApiGatewayStateTestCaseBase(TestCase, LoaderModuleMockMixin):
424     conn = None
425     @classmethod
426     def setUpClass(cls):
427         cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
428         cls.opts["grains"] = salt.loader.grains(cls.opts)
429     @classmethod
430     def tearDownClass(cls):
431         del cls.opts
432     def setup_loader_modules(self):
433         context = {}
434         utils = salt.loader.utils(
435             self.opts,
436             whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
437             context=context,
438         )
439         serializers = salt.loader.serializers(self.opts)
440         self.funcs = salt.loader.minion_mods(
441             self.opts, context=context, utils=utils, whitelist=["boto_apigateway"]
442         )
443         self.salt_states = salt.loader.states(
444             opts=self.opts,
445             functions=self.funcs,
446             utils=utils,
447             whitelist=["boto_apigateway"],
448             serializers=serializers,
449         )
450         return {
451             boto_apigateway: {
452                 "__opts__": self.opts,
453                 "__utils__": utils,
454                 "__salt__": self.funcs,
455                 "__states__": self.salt_states,
456                 "__serializers__": serializers,
457             }
458         }
459     def setUp(self):
460         self.addCleanup(delattr, self, "funcs")
461         self.addCleanup(delattr, self, "salt_states")
462         conn_parameters["key"] = "".join(
463             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
464         )
465         patcher = patch("boto3.session.Session")
466         self.addCleanup(patcher.stop)
467         mock_session = patcher.start()
468         session_instance = mock_session.return_value
469         self.conn = MagicMock()
470         self.addCleanup(delattr, self, "conn")
471         session_instance.client.return_value = self.conn
472 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
473 @skipIf(
474     _has_required_boto() is False,
475     "The boto3 module must be greater than or equal to version {}".format(
476         required_boto3_version
477     ),
478 )
479 class BotoApiGatewayTestCase(
480     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
481 ):
482     def test_present_when_swagger_file_is_invalid(self):
483         result = {}
484         with TempSwaggerFile(create_invalid_file=True) as swagger_file:
485             result = self.salt_states["boto_apigateway.present"](
486                 "api present",
487                 "unit test api",
488                 swagger_file,
489                 "test",
490                 False,
491                 "arn:aws:iam::1234:role/apigatewayrole",
492                 **conn_parameters
493             )
494         self.assertFalse(result.get("result", True))
495     def test_present_when_stage_is_already_at_desired_deployment(self):
496         self.conn.get_rest_apis.return_value = apis_ret
497         self.conn.get_deployment.return_value = deployment1_ret
498         self.conn.get_stage.return_value = stage1_deployment1_ret
499         self.conn.update_stage.side_effect = ClientError(
500             error_content, "update_stage should not be called"
501         )
502         result = {}
503         with TempSwaggerFile() as swagger_file:
504             result = self.salt_states["boto_apigateway.present"](
505                 "api present",
506                 "unit test api",
507                 swagger_file,
508                 "test",
509                 False,
510 <a name="4"></a>                "arn:aws:iam::1234:role/apigatewayrole",
511                 **conn_parameters
512             )
513         self<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertFalse(result.get("abort"))
514         self.assertTrue(result.get("current"))
515         self.assertIs(result.get("result"), True)
516         self.assertNotIn("update_stage should not be called", result.get("comment", ""))
517     def</b></font> test_present_when_stage_is_already_at_desired_deployment_and_needs_stage_variables_update(
518         self,
519     ):
520         self.conn.get_rest_apis.return_value = apis_ret
521         self.conn.get_deployment.return_value = deployment1_ret
522         self.conn.get_stage.return_value = stage1_deployment1_ret
523         self.conn.update_stage.return_value = stage1_deployment1_vars_ret
524         result = {}
525         with TempSwaggerFile() as swagger_file:
526             result = self.salt_states["boto_apigateway.present"](
527                 "api present",
528                 "unit test api",
529                 swagger_file,
530                 "test",
531                 False,
532                 "arn:aws:iam::1234:role/apigatewayrole",
533                 stage_variables={"var1": "val1"},
534 <a name="9"></a>                **conn_parameters
535             )
536         self<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertFalse(result.get("abort"))
537         self.assertTrue(result.get("current"))
538         self.assertIs(result.get("result"), True)
539     def</b></font> test_present_when_stage_exists_and_is_to_associate_to_existing_deployment(self):
540         self.conn.get_rest_apis.return_value = apis_ret
541         self.conn.get_deployment.return_value = deployment2_ret
542         self.conn.get_deployments.return_value = deployments_ret
543         self.conn.get_stage.return_value = stage1_deployment2_ret
544         self.conn.update_stage.return_value = stage1_deployment1_ret
545         self.conn.create_stage.side_effect = ClientError(error_content, "create_stage")
546         self.conn.create_deployment.side_effect = ClientError(
547             error_content, "create_deployment"
548         )
549         result = {}
550         with TempSwaggerFile() as swagger_file:
551             result = self.salt_states["boto_apigateway.present"](
552                 "api present",
553                 "unit test api",
554                 swagger_file,
555                 "test",
556                 False,
557                 "arn:aws:iam::1234:role/apigatewayrole",
558 <a name="2"></a>                **conn_parameters
559             )
560         self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertTrue(result.get("publish"))
561         self.assertIs(result.get("result"), True)
562         self.assertFalse(result.get("abort"))
563         self.assertTrue(result.get("changes", {}).get("new", [{}])[</b></font>0])
564     @pytest.mark.slow_test
565     def test_present_when_stage_is_to_associate_to_new_deployment(self):
566         self.conn.get_rest_apis.return_value = no_apis_ret
567         self.conn.create_rest_api.return_value = api_ret
568         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
569         self.conn.create_model.return_value = mock_model_ret
570         self.conn.get_resources.return_value = resources_ret
571         self.conn.create_resource.side_effect = ClientError(
572             error_content, "create_resource"
573         )
574         self.conn.put_method.return_value = method_ret
575         self.conn.put_integration.return_value = method_integration_ret
576         self.conn.put_method_response.return_value = method_response_200_ret
577         self.conn.put_intgration_response.return_value = (
578             method_integration_response_200_ret
579         )
580         result = {}
581         with patch.dict(
582             self.funcs,
583             {
584                 "boto_lambda.describe_function": MagicMock(
585                     return_value={"function": function_ret}
586                 )
587             },
588         ):
589             with TempSwaggerFile() as swagger_file:
590                 result = self.salt_states["boto_apigateway.present"](
591                     "api present",
592                     "unit test api",
593                     swagger_file,
594                     "test",
595                     False,
596                     "arn:aws:iam::1234:role/apigatewayrole",
597                     **conn_parameters
598                 )
599         self.assertIs(result.get("result"), True)
600         self.assertIs(result.get("abort"), None)
601     def test_present_when_stage_associating_to_new_deployment_errored_on_api_creation(
602         self,
603     ):
604         self.conn.get_rest_apis.return_value = no_apis_ret
605         self.conn.create_rest_api.side_effect = ClientError(
606             error_content, "create_rest_api"
607         )
608         result = {}
609         with TempSwaggerFile() as swagger_file:
610             result = self.salt_states["boto_apigateway.present"](
611                 "api present",
612                 "unit test api",
613                 swagger_file,
614                 "test",
615                 False,
616                 "arn:aws:iam::1234:role/apigatewayrole",
617 <a name="13"></a>                **conn_parameters
618             )
619         self<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIs(result.get("abort"), True)
620         self.assertIs(result.get("result"), False)
621         self.assertIn("create_rest_api", result.get(</b></font>"comment", ""))
622     def test_present_when_stage_associating_to_new_deployment_errored_on_model_creation(
623         self,
624     ):
625         self.conn.get_rest_apis.return_value = no_apis_ret
626         self.conn.create_rest_api.return_value = api_ret
627         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
628         self.conn.create_model.side_effect = ClientError(error_content, "create_model")
629         result = {}
630         with TempSwaggerFile() as swagger_file:
631             result = self.salt_states["boto_apigateway.present"](
632                 "api present",
633                 "unit test api",
634                 swagger_file,
635                 "test",
636                 False,
637                 "arn:aws:iam::1234:role/apigatewayrole",
638 <a name="15"></a>                **conn_parameters
639             )
640         self<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIs(result.get("abort"), True)
641         self.assertIs(result.get("result"), False)
642         self.assertIn("create_model", result.get(</b></font>"comment", ""))
643     def test_present_when_stage_associating_to_new_deployment_errored_on_resource_creation(
644         self,
645     ):
646         self.conn.get_rest_apis.return_value = no_apis_ret
647         self.conn.create_rest_api.return_value = api_ret
648         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
649         self.conn.create_model.return_value = mock_model_ret
650         self.conn.get_resources.return_value = root_resources_ret
651         self.conn.create_resource.side_effect = ClientError(
652             error_content, "create_resource"
653         )
654         result = {}
655         with TempSwaggerFile() as swagger_file:
656             result = self.salt_states["boto_apigateway.present"](
657                 "api present",
658                 "unit test api",
659                 swagger_file,
660                 "test",
661                 False,
662 <a name="14"></a>                "arn:aws:iam::1234:role/apigatewayrole",
663                 **conn_parameters
664             )
665         self<font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIs(result.get("abort"), True)
666         self.assertIs(result.get("result"), False)
667         self.assertIn("create_resource", result.get(</b></font>"comment", ""))
668     @pytest.mark.slow_test
669     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method(
670         self,
671     ):
672         self.conn.get_rest_apis.return_value = no_apis_ret
673         self.conn.create_rest_api.return_value = api_ret
674         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
675         self.conn.create_model.return_value = mock_model_ret
676         self.conn.get_resources.return_value = resources_ret
677         self.conn.create_resource.side_effect = ClientError(
678             error_content, "create_resource"
679         )
680         self.conn.put_method.side_effect = ClientError(error_content, "put_method")
681         result = {}
682         with patch.dict(
683             self.funcs,
684             {
685                 "boto_lambda.describe_function": MagicMock(
686                     return_value={"function": function_ret}
687                 )
688             },
689         ):
690             with TempSwaggerFile() as swagger_file:
691                 result = self.salt_states["boto_apigateway.present"](
692                     "api present",
693                     "unit test api",
694                     swagger_file,
695                     "test",
696                     False,
697                     "arn:aws:iam::1234:role/apigatewayrole",
698                     **conn_parameters
699                 )
700         self.assertIs(result.get("abort"), True)
701         self.assertIs(result.get("result"), False)
702         self.assertIn("put_method", result.get("comment", ""))
703     @pytest.mark.slow_test
704     def test_present_when_stage_associating_to_new_deployment_errored_on_lambda_function_lookup(
705         self,
706     ):
707         self.conn.get_rest_apis.return_value = no_apis_ret
708         self.conn.create_rest_api.return_value = api_ret
709         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
710         self.conn.create_model.return_value = mock_model_ret
711         self.conn.get_resources.return_value = resources_ret
712         self.conn.create_resource.side_effect = ClientError(
713             error_content, "create_resource"
714         )
715         self.conn.put_method.return_value = method_ret
716         self.conn.put_integration.side_effect = ClientError(
717             error_content, "put_integration should not be invoked"
718         )
719         result = {}
720         with patch.dict(
721             self.funcs,
722             {
723                 "boto_lambda.describe_function": MagicMock(
724                     return_value={"error": "no such lambda"}
725                 )
726             },
727         ):
728             with TempSwaggerFile() as swagger_file:
729                 result = self.salt_states["boto_apigateway.present"](
730                     "api present",
731                     "unit test api",
732                     swagger_file,
733                     "test",
734                     False,
735                     "arn:aws:iam::1234:role/apigatewayrole",
736                     **conn_parameters
737                 )
738         self.assertIs(result.get("result"), False)
739         self.assertNotIn(
740             "put_integration should not be invoked", result.get("comment", "")
741         )
742         self.assertIn("not find lambda function", result.get("comment", ""))
743     @pytest.mark.slow_test
744     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration(
745         self,
746     ):
747         self.conn.get_rest_apis.return_value = no_apis_ret
748         self.conn.create_rest_api.return_value = api_ret
749         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
750         self.conn.create_model.return_value = mock_model_ret
751         self.conn.get_resources.return_value = resources_ret
752         self.conn.create_resource.side_effect = ClientError(
753             error_content, "create_resource"
754         )
755         self.conn.put_method.return_value = method_ret
756         self.conn.put_integration.side_effect = ClientError(
757             error_content, "put_integration"
758         )
759         result = {}
760         with patch.dict(
761             self.funcs,
762             {
763                 "boto_lambda.describe_function": MagicMock(
764                     return_value={"function": function_ret}
765                 )
766             },
767         ):
768             with TempSwaggerFile() as swagger_file:
769                 result = self.salt_states["boto_apigateway.present"](
770                     "api present",
771                     "unit test api",
772                     swagger_file,
773                     "test",
774                     False,
775                     "arn:aws:iam::1234:role/apigatewayrole",
776                     **conn_parameters
777                 )
778         self.assertIs(result.get("abort"), True)
779         self.assertIs(result.get("result"), False)
780         self.assertIn("put_integration", result.get("comment", ""))
781     @pytest.mark.slow_test
782     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method_response(
783         self,
784     ):
785         self.conn.get_rest_apis.return_value = no_apis_ret
786         self.conn.create_rest_api.return_value = api_ret
787         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
788         self.conn.create_model.return_value = mock_model_ret
789         self.conn.get_resources.return_value = resources_ret
790         self.conn.create_resource.side_effect = ClientError(
791             error_content, "create_resource"
792         )
793         self.conn.put_method.return_value = method_ret
794         self.conn.put_integration.return_value = method_integration_ret
795         self.conn.put_method_response.side_effect = ClientError(
796             error_content, "put_method_response"
797         )
798         result = {}
799         with patch.dict(
800             self.funcs,
801             {
802                 "boto_lambda.describe_function": MagicMock(
803                     return_value={"function": function_ret}
804                 )
805             },
806         ):
807             with TempSwaggerFile() as swagger_file:
808                 result = self.salt_states["boto_apigateway.present"](
809                     "api present",
810                     "unit test api",
811                     swagger_file,
812                     "test",
813                     False,
814                     "arn:aws:iam::1234:role/apigatewayrole",
815                     **conn_parameters
816                 )
817         self.assertIs(result.get("abort"), True)
818         self.assertIs(result.get("result"), False)
819         self.assertIn("put_method_response", result.get("comment", ""))
820     @pytest.mark.slow_test
821     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration_response(
822         self,
823     ):
824         self.conn.get_rest_apis.return_value = no_apis_ret
825         self.conn.create_rest_api.return_value = api_ret
826         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
827         self.conn.create_model.return_value = mock_model_ret
828         self.conn.get_resources.return_value = resources_ret
829         self.conn.create_resource.side_effect = ClientError(
830             error_content, "create_resource"
831         )
832         self.conn.put_method.return_value = method_ret
833         self.conn.put_integration.return_value = method_integration_ret
834         self.conn.put_method_response.return_value = method_response_200_ret
835         self.conn.put_integration_response.side_effect = ClientError(
836             error_content, "put_integration_response"
837         )
838         result = {}
839         with patch.dict(
840             self.funcs,
841             {
842                 "boto_lambda.describe_function": MagicMock(
843                     return_value={"function": function_ret}
844                 )
845             },
846         ):
847             with TempSwaggerFile() as swagger_file:
848                 result = self.salt_states["boto_apigateway.present"](
849                     "api present",
850                     "unit test api",
851                     swagger_file,
852                     "test",
853                     False,
854                     "arn:aws:iam::1234:role/apigatewayrole",
855                     **conn_parameters
856                 )
857         self.assertIs(result.get("abort"), True)
858         self.assertIs(result.get("result"), False)
859         self.assertIn("put_integration_response", result.get("comment", ""))
860     def test_absent_when_rest_api_does_not_exist(self):
861         self.conn.get_rest_apis.return_value = apis_ret
862         self.conn.get_stage.side_effect = ClientError(
863 <a name="12"></a>            error_content, "get_stage should not be called"
864         )
865         result = self<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.salt_states["boto_apigateway.absent"](
866             "api present",
867             "no_such_rest_api",
868             "no_such_stage",
869             nuke_api=False,
870             **conn_parameters
871         )
872         self.assertIs(result.get("result"), True)
873         self.assertNotIn("get_stage should not be called", result.get("comment", ""))
874         self.</b></font>assertEqual(result.get("changes"), {})
875     def test_absent_when_stage_is_invalid(self):
876         self.conn.get_rest_apis.return_value = apis_ret
877         self.conn.get_stage.return_value = stage1_deployment1_ret
878         self.conn.delete_stage.side_effect = ClientError(error_content, "delete_stage")
879         result = self.salt_states["boto_apigateway.absent"](
880             "api present",
881             "unit test api",
882             "no_such_stage",
883             nuke_api=False,
884             **conn_parameters
885         )
886         self.assertTrue(result.get("abort", False))
887     def test_absent_when_stage_is_valid_and_only_one_stage_is_associated_to_deployment(
888         self,
889     ):
890         self.conn.get_rest_apis.return_value = apis_ret
891         self.conn.get_stage.return_value = stage1_deployment1_ret
892         self.conn.delete_stage.return_value = {
893             "ResponseMetadata": {
894                 "HTTPStatusCode": 200,
895                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
896             }
897         }
898         self.conn.get_stages.return_value = no_stages_ret
899         self.conn.delete_deployment.return_value = {
900             "ResponseMetadata": {
901                 "HTTPStatusCode": 200,
902                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
903             }
904         }
905         result = self.salt_states["boto_apigateway.absent"](
906             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
907         )
908         self.assertTrue(result.get("result", False))
909     def test_absent_when_stage_is_valid_and_two_stages_are_associated_to_deployment(
910         self,
911     ):
912         self.conn.get_rest_apis.return_value = apis_ret
913         self.conn.get_stage.return_value = stage1_deployment1_ret
914         self.conn.delete_stage.return_value = {
915             "ResponseMetadata": {
916                 "HTTPStatusCode": 200,
917                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
918             }
919         }
920         self.conn.get_stages.return_value = stages_stage2_ret
921         result = self.salt_states["boto_apigateway.absent"](
922             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
923         )
924         self.assertTrue(result.get("result", False))
925     def test_absent_when_failing_to_delete_a_deployment_no_longer_associated_with_any_stages(
926         self,
927     ):
928         self.conn.get_rest_apis.return_value = apis_ret
929         self.conn.get_stage.return_value = stage1_deployment1_ret
930         self.conn.delete_stage.return_value = {
931             "ResponseMetadata": {
932                 "HTTPStatusCode": 200,
933                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
934             }
935         }
936         self.conn.get_stages.return_value = no_stages_ret
937         self.conn.delete_deployment.side_effect = ClientError(
938             error_content, "delete_deployment"
939         )
940         result = self.salt_states["boto_apigateway.absent"](
941             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
942         )
943         self.assertTrue(result.get("abort", False))
944     def test_absent_when_nuke_api_and_no_more_stages_deployments_remain(self):
945         self.conn.get_rest_apis.return_value = apis_ret
946         self.conn.get_stage.return_value = stage1_deployment1_ret
947         self.conn.delete_stage.return_value = {
948             "ResponseMetadata": {
949                 "HTTPStatusCode": 200,
950                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
951             }
952         }
953         self.conn.get_stages.return_value = no_stages_ret
954         self.conn.get_deployments.return_value = deployments_ret
955         self.conn.delete_rest_api.return_value = {
956             "ResponseMetadata": {
957                 "HTTPStatusCode": 200,
958                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
959             }
960         }
961         result = self.salt_states["boto_apigateway.absent"](
962 <a name="7"></a>            "api present", "unit test api", "test", nuke_api=True, **conn_parameters
963         )
964         self.assertIs(result.get<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("result"), True)
965         self.assertIsNot(result.get("abort"), True)
966         self.assertIs(
967             result.get("changes", {})
968             .get("new", [{}])[0]
969             .get("delete_api", {})
970             .</b></font>get("deleted"),
971             True,
972         )
973     def test_absent_when_nuke_api_and_other_stages_deployments_exist(self):
974         self.conn.get_rest_apis.return_value = apis_ret
975         self.conn.get_stage.return_value = stage1_deployment1_ret
976         self.conn.delete_stage.return_value = {
977             "ResponseMetadata": {
978                 "HTTPStatusCode": 200,
979                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
980             }
981         }
982         self.conn.get_stages.return_value = stages_stage2_ret
983         self.conn.get_deployments.return_value = deployments_ret
984         self.conn.delete_rest_api.side_effect = ClientError(
985             error_content, "unexpected_api_delete"
986         )
987         result = self.salt_states["boto_apigateway.absent"](
988             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
989         )
990         self.assertIs(result.get("result"), True)
991         self.assertIsNot(result.get("abort"), True)
992 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
993 @skipIf(
994     _has_required_boto() is False,
995     "The boto3 module must be greater than or equal to version {}".format(
996         required_boto3_version
997     ),
998 )
999 @skipIf(
1000     _has_required_botocore() is False,
1001     "The botocore module must be greater than or equal to version {}".format(
1002         required_botocore_version
1003     ),
1004 )
1005 class BotoApiGatewayUsagePlanTestCase(
1006     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1007 ):
1008     @pytest.mark.slow_test
1009     def test_usage_plan_present_if_describe_fails(self, *args):
1010         with patch.dict(
1011             boto_apigateway.__salt__,
1012             {
1013                 "boto_apigateway.describe_usage_plans": MagicMock(
1014                     return_value={"error": "error"}
1015                 )
1016             },
1017         ):
1018             result = boto_apigateway.usage_plan_present(
1019                 "name", "plan_name", **conn_parameters
1020 <a name="11"></a>            )
1021             self.assertIn("result", result)
1022             self<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(result["result"], False)
1023             self.assertIn("comment", result)
1024             self.assertEqual(
1025                 result["comment"], "Failed to describe existing usage plans"
1026             )
1027             self.assertIn("changes", result)
1028             self.assertEqual(result[</b></font>"changes"], {})
1029     @pytest.mark.slow_test
1030     def test_usage_plan_present_if_there_is_no_such_plan_and_test_option_is_set(
1031         self, *args
1032     ):
1033         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1034             with patch.dict(
1035                 boto_apigateway.__salt__,
1036                 {
1037                     "boto_apigateway.describe_usage_plans": MagicMock(
1038                         return_value={"plans": []}
1039                     )
1040                 },
1041             ):
1042                 result = boto_apigateway.usage_plan_present(
1043                     "name", "plan_name", **conn_parameters
1044                 )
1045                 self.assertIn("comment", result)
1046                 self.assertEqual(
1047                     result["comment"], "a new usage plan plan_name would be created"
1048                 )
1049                 self.assertIn("result", result)
1050                 self.assertEqual(result["result"], None)
1051     @pytest.mark.slow_test
1052     def test_usage_plan_present_if_create_usage_plan_fails(self, *args):
1053         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1054             with patch.dict(
1055                 boto_apigateway.__salt__,
1056                 {
1057                     "boto_apigateway.describe_usage_plans": MagicMock(
1058                         return_value={"plans": []}
1059                     ),
1060                     "boto_apigateway.create_usage_plan": MagicMock(
1061                         return_value={"error": "error"}
1062                     ),
1063                 },
1064             ):
1065                 result = boto_apigateway.usage_plan_present(
1066                     "name", "plan_name", **conn_parameters
1067                 )
1068                 self.assertIn("result", result)
1069                 self.assertEqual(result["result"], False)
1070                 self.assertIn("comment", result)
1071                 self.assertEqual(
1072                     result["comment"], "Failed to create a usage plan plan_name, error"
1073                 )
1074                 self.assertIn("changes", result)
1075                 self.assertEqual(result["changes"], {})
1076     @pytest.mark.slow_test
1077     def test_usage_plan_present_if_plan_is_there_and_needs_no_updates(self, *args):
1078         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1079             with patch.dict(
1080                 boto_apigateway.__salt__,
1081                 {
1082                     "boto_apigateway.describe_usage_plans": MagicMock(
1083                         return_value={"plans": [{"id": "planid", "name": "planname"}]}
1084                     ),
1085                     "boto_apigateway.update_usage_plan": MagicMock(),
1086                 },
1087             ):
1088                 result = boto_apigateway.usage_plan_present(
1089 <a name="6"></a>                    "name", "plan_name", **conn_parameters
1090                 )
1091                 self<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIn("result", result)
1092                 self.assertEqual(result["result"], True)
1093                 self.assertIn("comment", result)
1094                 self.assertEqual(
1095                     result["comment"],
1096                     "usage plan plan_name is already in a correct state",
1097                 )
1098                 self.assertIn("changes", result)
1099                 self.assertEqual(result["changes"], {})
1100                 self.assertTrue(</b></font>
1101                     boto_apigateway.__salt__[
1102                         "boto_apigateway.update_usage_plan"
1103                     ].call_count
1104                     == 0
1105                 )
1106     @pytest.mark.slow_test
1107     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_test_is_set(
1108         self, *args
1109     ):
1110         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1111             with patch.dict(
1112                 boto_apigateway.__salt__,
1113                 {
1114                     "boto_apigateway.describe_usage_plans": MagicMock(
1115                         return_value={
1116                             "plans": [
1117                                 {
1118                                     "id": "planid",
1119                                     "name": "planname",
1120                                     "throttle": {"rateLimit": 10.0},
1121                                 }
1122                             ]
1123                         }
1124                     ),
1125                     "boto_apigateway.update_usage_plan": MagicMock(),
1126                 },
1127             ):
1128                 result = boto_apigateway.usage_plan_present(
1129                     "name", "plan_name", **conn_parameters
1130 <a name="10"></a>                )
1131                 self.assertIn("comment", result)
1132                 self<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(
1133                     result["comment"], "a new usage plan plan_name would be updated"
1134                 )
1135                 self.assertIn("result", result)
1136                 self.assertEqual(result["result"], None)
1137                 self.assertTrue(
1138                     boto_apigateway.__salt__[
1139                         "boto_apigateway.update_usage_plan"
1140                     ].</b></font>call_count
1141                     == 0
1142                 )
1143     @pytest.mark.slow_test
1144     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_update_fails(
1145         self, *args
1146     ):
1147         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1148             with patch.dict(
1149                 boto_apigateway.__salt__,
1150                 {
1151                     "boto_apigateway.describe_usage_plans": MagicMock(
1152                         return_value={
1153                             "plans": [
1154                                 {
1155                                     "id": "planid",
1156                                     "name": "planname",
1157                                     "throttle": {"rateLimit": 10.0},
1158                                 }
1159                             ]
1160                         }
1161                     ),
1162                     "boto_apigateway.update_usage_plan": MagicMock(
1163                         return_value={"error": "error"}
1164                     ),
1165                 },
1166             ):
1167                 result = boto_apigateway.usage_plan_present(
1168                     "name", "plan_name", **conn_parameters
1169                 )
1170                 self.assertIn("result", result)
1171                 self.assertEqual(result["result"], False)
1172                 self.assertIn("comment", result)
1173                 self.assertEqual(
1174                     result["comment"], "Failed to update a usage plan plan_name, error"
1175                 )
1176     @pytest.mark.slow_test
1177     def test_usage_plan_present_if_plan_has_been_created(self, *args):
1178         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1179             with patch.dict(
1180                 boto_apigateway.__salt__,
1181                 {
1182                     "boto_apigateway.describe_usage_plans": MagicMock(
1183                         side_effect=[{"plans": []}, {"plans": [{"id": "id"}]}]
1184                     ),
1185                     "boto_apigateway.create_usage_plan": MagicMock(
1186                         return_value={"created": True}
1187                     ),
1188                 },
1189             ):
1190                 result = boto_apigateway.usage_plan_present(
1191                     "name", "plan_name", **conn_parameters
1192                 )
1193                 self.assertIn("result", result)
1194                 self.assertEqual(result["result"], True)
1195                 self.assertIn("comment", result)
1196                 self.assertEqual(
1197                     result["comment"], "A new usage plan plan_name has been created"
1198                 )
1199                 self.assertEqual(result["changes"]["old"], {"plan": None})
1200                 self.assertEqual(result["changes"]["new"], {"plan": {"id": "id"}})
1201     @pytest.mark.slow_test
1202     def test_usage_plan_present_if_plan_has_been_updated(self, *args):
1203         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1204             with patch.dict(
1205                 boto_apigateway.__salt__,
1206                 {
1207                     "boto_apigateway.describe_usage_plans": MagicMock(
1208                         side_effect=[
1209                             {"plans": [{"id": "id"}]},
1210                             {
1211                                 "plans": [
1212                                     {
1213                                         "id": "id",
1214                                         "throttle": {"rateLimit": throttle_rateLimit},
1215                                     }
1216                                 ]
1217                             },
1218                         ]
1219                     ),
1220                     "boto_apigateway.update_usage_plan": MagicMock(
1221                         return_value={"updated": True}
1222                     ),
1223                 },
1224             ):
1225                 result = boto_apigateway.usage_plan_present(
1226                     "name",
1227                     "plan_name",
1228                     throttle={"rateLimit": throttle_rateLimit},
1229                     **conn_parameters
1230                 )
1231                 self.assertIn("result", result)
1232                 self.assertEqual(result["result"], True)
1233                 self.assertIn("comment", result)
1234                 self.assertEqual(
1235                     result["comment"], "usage plan plan_name has been updated"
1236                 )
1237                 self.assertEqual(result["changes"]["old"], {"plan": {"id": "id"}})
1238                 self.assertEqual(
1239                     result["changes"]["new"],
1240                     {
1241                         "plan": {
1242                             "id": "id",
1243                             "throttle": {"rateLimit": throttle_rateLimit},
1244                         }
1245                     },
1246                 )
1247     @pytest.mark.slow_test
1248     def test_usage_plan_present_if_ValueError_is_raised(self, *args):
1249         with patch.dict(
1250             boto_apigateway.__salt__,
1251             {
1252                 "boto_apigateway.describe_usage_plans": MagicMock(
1253                     side_effect=ValueError("error")
1254                 )
1255             },
1256         ):
1257             result = boto_apigateway.usage_plan_present(
1258                 "name",
1259                 "plan_name",
1260                 throttle={"rateLimit": throttle_rateLimit},
1261                 **conn_parameters
1262             )
1263             self.assertIn("result", result)
1264             self.assertEqual(result["result"], False)
1265             self.assertIn("comment", result)
1266             self.assertEqual(result["comment"], repr(("error",)))
1267     @pytest.mark.slow_test
1268     def test_usage_plan_present_if_IOError_is_raised(self, *args):
1269         with patch.dict(
1270             boto_apigateway.__salt__,
1271             {
1272                 "boto_apigateway.describe_usage_plans": MagicMock(
1273                     side_effect=IOError("error")
1274                 )
1275             },
1276         ):
1277             result = boto_apigateway.usage_plan_present(
1278                 "name",
1279                 "plan_name",
1280                 throttle={"rateLimit": throttle_rateLimit},
1281                 **conn_parameters
1282             )
1283             self.assertIn("result", result)
1284             self.assertEqual(result["result"], False)
1285             self.assertIn("comment", result)
1286             self.assertEqual(result["comment"], repr(("error",)))
1287     @pytest.mark.slow_test
1288     def test_usage_plan_absent_if_describe_fails(self, *args):
1289         with patch.dict(
1290             boto_apigateway.__salt__,
1291             {
1292                 "boto_apigateway.describe_usage_plans": MagicMock(
1293                     return_value={"error": "error"}
1294                 )
1295             },
1296         ):
1297             result = {}
1298             result = boto_apigateway.usage_plan_absent(
1299                 "name", "plan_name", **conn_parameters
1300             )
1301             self.assertIn("result", result)
1302             self.assertEqual(result["result"], False)
1303             self.assertIn("comment", result)
1304             self.assertEqual(
1305                 result["comment"], "Failed to describe existing usage plans"
1306             )
1307             self.assertIn("changes", result)
1308             self.assertEqual(result["changes"], {})
1309     @pytest.mark.slow_test
1310     def test_usage_plan_absent_if_plan_is_not_present(self, *args):
1311         with patch.dict(
1312             boto_apigateway.__salt__,
1313             {
1314                 "boto_apigateway.describe_usage_plans": MagicMock(
1315                     return_value={"plans": []}
1316                 )
1317             },
1318         ):
1319             result = {}
1320             result = boto_apigateway.usage_plan_absent(
1321                 "name", "plan_name", **conn_parameters
1322             )
1323             self.assertIn("result", result)
1324             self.assertEqual(result["result"], True)
1325             self.assertIn("comment", result)
1326             self.assertEqual(
1327                 result["comment"], "Usage plan plan_name does not exist already"
1328             )
1329             self.assertIn("changes", result)
1330             self.assertEqual(result["changes"], {})
1331     @pytest.mark.slow_test
1332     def test_usage_plan_absent_if_plan_is_present_but_test_option_is_set(self, *args):
1333         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1334             with patch.dict(
1335                 boto_apigateway.__salt__,
1336                 {
1337                     "boto_apigateway.describe_usage_plans": MagicMock(
1338                         return_value={"plans": [{"id": "id"}]}
1339                     )
1340                 },
1341             ):
1342                 result = {}
1343                 result = boto_apigateway.usage_plan_absent(
1344                     "name", "plan_name", **conn_parameters
1345                 )
1346                 self.assertIn("result", result)
1347                 self.assertEqual(result["result"], None)
1348                 self.assertIn("comment", result)
1349                 self.assertEqual(
1350                     result["comment"],
1351                     "Usage plan plan_name exists and would be deleted",
1352                 )
1353                 self.assertIn("changes", result)
1354                 self.assertEqual(result["changes"], {})
1355     @pytest.mark.slow_test
1356     def test_usage_plan_absent_if_plan_is_present_but_delete_fails(self, *args):
1357         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1358             with patch.dict(
1359                 boto_apigateway.__salt__,
1360                 {
1361                     "boto_apigateway.describe_usage_plans": MagicMock(
1362                         return_value={"plans": [{"id": "id"}]}
1363                     ),
1364                     "boto_apigateway.delete_usage_plan": MagicMock(
1365                         return_value={"error": "error"}
1366                     ),
1367                 },
1368             ):
1369                 result = boto_apigateway.usage_plan_absent(
1370                     "name", "plan_name", **conn_parameters
1371                 )
1372                 self.assertIn("result", result)
1373                 self.assertEqual(result["result"], False)
1374                 self.assertIn("comment", result)
1375                 self.assertEqual(
1376                     result["comment"],
1377                     "Failed to delete usage plan plan_name, "
1378                     + repr({"error": "error"}),
1379                 )
1380                 self.assertIn("changes", result)
1381                 self.assertEqual(result["changes"], {})
1382     @pytest.mark.slow_test
1383     def test_usage_plan_absent_if_plan_has_been_deleted(self, *args):
1384         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1385             with patch.dict(
1386                 boto_apigateway.__salt__,
1387                 {
1388                     "boto_apigateway.describe_usage_plans": MagicMock(
1389                         return_value={"plans": [{"id": "id"}]}
1390                     ),
1391                     "boto_apigateway.delete_usage_plan": MagicMock(
1392                         return_value={"deleted": True}
1393                     ),
1394                 },
1395             ):
1396                 result = boto_apigateway.usage_plan_absent(
1397                     "name", "plan_name", **conn_parameters
1398                 )
1399                 self.assertIn("result", result)
1400                 self.assertEqual(result["result"], True)
1401                 self.assertIn("comment", result)
1402                 self.assertEqual(
1403                     result["comment"], "Usage plan plan_name has been deleted"
1404                 )
1405                 self.assertIn("changes", result)
1406                 self.assertEqual(
1407                     result["changes"],
1408                     {"new": {"plan": None}, "old": {"plan": {"id": "id"}}},
1409                 )
1410     @pytest.mark.slow_test
1411     def test_usage_plan_absent_if_ValueError_is_raised(self, *args):
1412         with patch.dict(
1413             boto_apigateway.__salt__,
1414             {
1415                 "boto_apigateway.describe_usage_plans": MagicMock(
1416                     side_effect=ValueError("error")
1417                 )
1418             },
1419         ):
1420             result = boto_apigateway.usage_plan_absent(
1421                 "name", "plan_name", **conn_parameters
1422             )
1423             self.assertIn("result", result)
1424             self.assertEqual(result["result"], False)
1425             self.assertIn("comment", result)
1426             self.assertEqual(result["comment"], repr(("error",)))
1427     @pytest.mark.slow_test
1428     def test_usage_plan_absent_if_IOError_is_raised(self, *args):
1429         with patch.dict(
1430             boto_apigateway.__salt__,
1431             {
1432                 "boto_apigateway.describe_usage_plans": MagicMock(
1433                     side_effect=IOError("error")
1434                 )
1435             },
1436         ):
1437             result = boto_apigateway.usage_plan_absent(
1438                 "name", "plan_name", **conn_parameters
1439             )
1440             self.assertIn("result", result)
1441             self.assertEqual(result["result"], False)
1442             self.assertIn("comment", result)
1443             self.assertEqual(result["comment"], repr(("error",)))
1444 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
1445 @skipIf(
1446     _has_required_boto() is False,
1447     "The boto3 module must be greater than or equal to version {}".format(
1448         required_boto3_version
1449     ),
1450 )
1451 @skipIf(
1452     _has_required_botocore() is False,
1453     "The botocore module must be greater than or equal to version {}".format(
1454         required_botocore_version
1455     ),
1456 )
1457 class BotoApiGatewayUsagePlanAssociationTestCase(
1458     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1459 ):
1460     @pytest.mark.slow_test
1461     def test_usage_plan_association_present_if_describe_fails(self, *args):
1462         with patch.dict(
1463             boto_apigateway.__salt__,
1464             {
1465                 "boto_apigateway.describe_usage_plans": MagicMock(
1466                     return_value={"error": "error"}
1467                 )
1468             },
1469         ):
1470             result = boto_apigateway.usage_plan_association_present(
1471                 "name", "plan_name", [association_stage_1], **conn_parameters
1472             )
1473             self.assertIn("result", result)
1474             self.assertEqual(result["result"], False)
1475             self.assertIn("comment", result)
1476             self.assertEqual(
1477                 result["comment"], "Failed to describe existing usage plans"
1478             )
1479             self.assertIn("changes", result)
1480             self.assertEqual(result["changes"], {})
1481     @pytest.mark.slow_test
1482     def test_usage_plan_association_present_if_plan_is_not_present(self, *args):
1483         with patch.dict(
1484             boto_apigateway.__salt__,
1485             {
1486                 "boto_apigateway.describe_usage_plans": MagicMock(
1487                     return_value={"plans": []}
1488                 )
1489             },
1490         ):
1491             result = boto_apigateway.usage_plan_association_present(
1492                 "name", "plan_name", [association_stage_1], **conn_parameters
1493             )
1494             self.assertIn("result", result)
1495             self.assertEqual(result["result"], False)
1496             self.assertIn("comment", result)
1497             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1498             self.assertIn("changes", result)
1499             self.assertEqual(result["changes"], {})
1500     @pytest.mark.slow_test
1501     def test_usage_plan_association_present_if_multiple_plans_with_the_same_name_exist(
1502         self, *args
1503     ):
1504         with patch.dict(
1505             boto_apigateway.__salt__,
1506             {
1507                 "boto_apigateway.describe_usage_plans": MagicMock(
1508                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1509                 )
1510             },
1511         ):
1512             result = boto_apigateway.usage_plan_association_present(
1513                 "name", "plan_name", [association_stage_1], **conn_parameters
1514             )
1515             self.assertIn("result", result)
1516             self.assertEqual(result["result"], False)
1517             self.assertIn("comment", result)
1518             self.assertEqual(
1519                 result["comment"],
1520                 "There are multiple usage plans with the same name - it is not"
1521                 " supported",
1522             )
1523             self.assertIn("changes", result)
1524             self.assertEqual(result["changes"], {})
1525     @pytest.mark.slow_test
1526     def test_usage_plan_association_present_if_association_already_exists(self, *args):
1527         with patch.dict(
1528             boto_apigateway.__salt__,
1529             {
1530                 "boto_apigateway.describe_usage_plans": MagicMock(
1531                     return_value={
1532                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1533                     }
1534                 )
1535             },
1536         ):
1537             result = boto_apigateway.usage_plan_association_present(
1538                 "name", "plan_name", [association_stage_1], **conn_parameters
1539             )
1540             self.assertIn("result", result)
1541             self.assertEqual(result["result"], True)
1542             self.assertIn("comment", result)
1543             self.assertEqual(
1544                 result["comment"], "Usage plan is already asssociated to all api stages"
1545             )
1546             self.assertIn("changes", result)
1547             self.assertEqual(result["changes"], {})
1548     @pytest.mark.slow_test
1549     def test_usage_plan_association_present_if_update_fails(self, *args):
1550         with patch.dict(
1551             boto_apigateway.__salt__,
1552             {
1553                 "boto_apigateway.describe_usage_plans": MagicMock(
1554                     return_value={
1555                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1556                     }
1557                 ),
1558                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1559                     return_value={"error": "error"}
1560 <a name="1"></a>                ),
1561             },
1562         ):
1563             result = boto_apigateway<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.usage_plan_association_present(
1564                 "name", "plan_name", [association_stage_2], **conn_parameters
1565             )
1566             self.assertIn("result", result)
1567             self.assertEqual(result["result"], False)
1568             self.assertIn("comment", result)
1569             self.assertTrue(
1570                 result["comment"].startswith("Failed to associate a usage plan")
1571             )
1572             self.assertIn("changes", result)
1573             self.assertEqual(result[</b></font>"changes"], {})
1574     @pytest.mark.slow_test
1575     def test_usage_plan_association_present_success(self, *args):
1576         with patch.dict(
1577             boto_apigateway.__salt__,
1578             {
1579                 "boto_apigateway.describe_usage_plans": MagicMock(
1580                     return_value={
1581                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1582                     }
1583                 ),
1584                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1585                     return_value={
1586                         "result": {
1587                             "apiStages": [association_stage_1, association_stage_2]
1588                         }
1589                     }
1590                 ),
1591             },
1592         ):
1593             result = boto_apigateway.usage_plan_association_present(
1594                 "name", "plan_name", [association_stage_2], **conn_parameters
1595             )
1596             self.assertIn("result", result)
1597             self.assertEqual(result["result"], True)
1598             self.assertIn("comment", result)
1599             self.assertEqual(
1600                 result["comment"], "successfully associated usage plan to apis"
1601             )
1602             self.assertIn("changes", result)
1603             self.assertEqual(
1604                 result["changes"],
1605                 {
1606                     "new": [association_stage_1, association_stage_2],
1607                     "old": [association_stage_1],
1608                 },
1609             )
1610     @pytest.mark.slow_test
1611     def test_usage_plan_association_present_if_value_error_is_thrown(self, *args):
1612         with patch.dict(
1613             boto_apigateway.__salt__,
1614             {
1615                 "boto_apigateway.describe_usage_plans": MagicMock(
1616                     side_effect=ValueError("error")
1617                 )
1618             },
1619         ):
1620             result = boto_apigateway.usage_plan_association_present(
1621                 "name", "plan_name", [], **conn_parameters
1622             )
1623             self.assertIn("result", result)
1624             self.assertEqual(result["result"], False)
1625             self.assertIn("comment", result)
1626             self.assertEqual(result["comment"], repr(("error",)))
1627             self.assertIn("changes", result)
1628             self.assertEqual(result["changes"], {})
1629     @pytest.mark.slow_test
1630     def test_usage_plan_association_present_if_io_error_is_thrown(self, *args):
1631         with patch.dict(
1632             boto_apigateway.__salt__,
1633             {
1634                 "boto_apigateway.describe_usage_plans": MagicMock(
1635                     side_effect=IOError("error")
1636                 )
1637             },
1638         ):
1639             result = boto_apigateway.usage_plan_association_present(
1640                 "name", "plan_name", [], **conn_parameters
1641             )
1642             self.assertIn("result", result)
1643             self.assertEqual(result["result"], False)
1644             self.assertIn("comment", result)
1645             self.assertEqual(result["comment"], repr(("error",)))
1646             self.assertIn("changes", result)
1647             self.assertEqual(result["changes"], {})
1648     @pytest.mark.slow_test
1649     def test_usage_plan_association_absent_if_describe_fails(self, *args):
1650         with patch.dict(
1651             boto_apigateway.__salt__,
1652             {
1653                 "boto_apigateway.describe_usage_plans": MagicMock(
1654                     return_value={"error": "error"}
1655                 )
1656             },
1657         ):
1658             result = boto_apigateway.usage_plan_association_absent(
1659                 "name", "plan_name", [association_stage_1], **conn_parameters
1660             )
1661             self.assertIn("result", result)
1662             self.assertEqual(result["result"], False)
1663             self.assertIn("comment", result)
1664             self.assertEqual(
1665                 result["comment"], "Failed to describe existing usage plans"
1666             )
1667             self.assertIn("changes", result)
1668             self.assertEqual(result["changes"], {})
1669     @pytest.mark.slow_test
1670     def test_usage_plan_association_absent_if_plan_is_not_present(self, *args):
1671         with patch.dict(
1672             boto_apigateway.__salt__,
1673             {
1674                 "boto_apigateway.describe_usage_plans": MagicMock(
1675                     return_value={"plans": []}
1676                 )
1677             },
1678         ):
1679             result = boto_apigateway.usage_plan_association_absent(
1680                 "name", "plan_name", [association_stage_1], **conn_parameters
1681             )
1682             self.assertIn("result", result)
1683             self.assertEqual(result["result"], False)
1684             self.assertIn("comment", result)
1685             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1686             self.assertIn("changes", result)
1687             self.assertEqual(result["changes"], {})
1688     @pytest.mark.slow_test
1689     def test_usage_plan_association_absent_if_multiple_plans_with_the_same_name_exist(
1690         self, *args
1691     ):
1692         with patch.dict(
1693             boto_apigateway.__salt__,
1694             {
1695                 "boto_apigateway.describe_usage_plans": MagicMock(
1696                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1697                 )
1698             },
1699         ):
1700             result = boto_apigateway.usage_plan_association_absent(
1701                 "name", "plan_name", [association_stage_1], **conn_parameters
1702             )
1703             self.assertIn("result", result)
1704             self.assertEqual(result["result"], False)
1705             self.assertIn("comment", result)
1706             self.assertEqual(
1707                 result["comment"],
1708                 "There are multiple usage plans with the same name - it is not"
1709                 " supported",
1710             )
1711             self.assertIn("changes", result)
1712             self.assertEqual(result["changes"], {})
1713     @pytest.mark.slow_test
1714     def test_usage_plan_association_absent_if_plan_has_no_associations(self, *args):
1715         with patch.dict(
1716             boto_apigateway.__salt__,
1717             {
1718                 "boto_apigateway.describe_usage_plans": MagicMock(
1719                     return_value={"plans": [{"id": "id1", "apiStages": []}]}
1720                 )
1721             },
1722         ):
1723             result = boto_apigateway.usage_plan_association_absent(
1724                 "name", "plan_name", [association_stage_1], **conn_parameters
1725             )
1726             self.assertIn("result", result)
1727             self.assertEqual(result["result"], True)
1728             self.assertIn("comment", result)
1729             self.assertEqual(
1730                 result["comment"],
1731                 "Usage plan plan_name has no associated stages already",
1732             )
1733             self.assertIn("changes", result)
1734             self.assertEqual(result["changes"], {})
1735     @pytest.mark.slow_test
1736     def test_usage_plan_association_absent_if_plan_has_no_specific_association(
1737         self, *args
1738     ):
1739         with patch.dict(
1740             boto_apigateway.__salt__,
1741             {
1742                 "boto_apigateway.describe_usage_plans": MagicMock(
1743                     return_value={
1744                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1745                     }
1746                 )
1747             },
1748         ):
1749             result = boto_apigateway.usage_plan_association_absent(
1750                 "name", "plan_name", [association_stage_2], **conn_parameters
1751             )
1752             self.assertIn("result", result)
1753             self.assertEqual(result["result"], True)
1754             self.assertIn("comment", result)
1755             self.assertEqual(
1756                 result["comment"],
1757                 "Usage plan is already not asssociated to any api stages",
1758             )
1759             self.assertIn("changes", result)
1760             self.assertEqual(result["changes"], {})
1761     @pytest.mark.slow_test
1762     def test_usage_plan_association_absent_if_detaching_association_fails(self, *args):
1763         with patch.dict(
1764             boto_apigateway.__salt__,
1765             {
1766                 "boto_apigateway.describe_usage_plans": MagicMock(
1767                     return_value={
1768                         "plans": [
1769                             {
1770                                 "id": "id1",
1771                                 "apiStages": [association_stage_1, association_stage_2],
1772                             }
1773                         ]
1774                     }
1775                 ),
1776                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1777                     return_value={"error": "error"}
1778                 ),
1779             },
1780         ):
1781             result = boto_apigateway.usage_plan_association_absent(
1782 <a name="5"></a>                "name", "plan_name", [association_stage_2], **conn_parameters
1783             )
1784             self<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIn("result", result)
1785             self.assertEqual(result["result"], False)
1786             self.assertIn("comment", result)
1787             self.assertTrue(
1788                 result["comment"].startswith(
1789                     "Failed to disassociate a usage plan plan_name from the apis"
1790                 )
1791             )
1792             self.assertIn("changes", result)
1793             self.assertEqual(result[</b></font>"changes"], {})
1794     @pytest.mark.slow_test
1795     def test_usage_plan_association_absent_success(self, *args):
1796         with patch.dict(
1797             boto_apigateway.__salt__,
1798             {
1799                 "boto_apigateway.describe_usage_plans": MagicMock(
1800                     return_value={
1801                         "plans": [
1802                             {
1803                                 "id": "id1",
1804                                 "apiStages": [association_stage_1, association_stage_2],
1805                             }
1806                         ]
1807                     }
1808                 ),
1809                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1810                     return_value={"result": {"apiStages": [association_stage_1]}}
1811                 ),
1812             },
1813         ):
1814             result = boto_apigateway.usage_plan_association_absent(
1815                 "name", "plan_name", [association_stage_2], **conn_parameters
1816             )
1817             self.assertIn("result", result)
1818             self.assertEqual(result["result"], True)
1819             self.assertIn("comment", result)
1820             self.assertEqual(
1821                 result["comment"], "successfully disassociated usage plan from apis"
1822             )
1823             self.assertIn("changes", result)
1824             self.assertEqual(
1825                 result["changes"],
1826                 {
1827                     "new": [association_stage_1],
1828                     "old": [association_stage_1, association_stage_2],
1829                 },
1830             )
1831     @pytest.mark.slow_test
1832     def test_usage_plan_association_absent_if_ValueError_is_raised(self, *args):
1833         with patch.dict(
1834             boto_apigateway.__salt__,
1835             {
1836                 "boto_apigateway.describe_usage_plans": MagicMock(
1837                     side_effect=ValueError("error")
1838                 )
1839             },
1840         ):
1841             result = boto_apigateway.usage_plan_association_absent(
1842                 "name", "plan_name", [association_stage_1], **conn_parameters
1843             )
1844             self.assertIn("result", result)
1845             self.assertEqual(result["result"], False)
1846             self.assertIn("comment", result)
1847             self.assertEqual(result["comment"], repr(("error",)))
1848             self.assertIn("changes", result)
1849             self.assertEqual(result["changes"], {})
1850     @pytest.mark.slow_test
1851     def test_usage_plan_association_absent_if_IOError_is_raised(self, *args):
1852         with patch.dict(
1853             boto_apigateway.__salt__,
1854             {
1855                 "boto_apigateway.describe_usage_plans": MagicMock(
1856                     side_effect=IOError("error")
1857                 )
1858             },
1859         ):
1860             result = boto_apigateway.usage_plan_association_absent(
1861                 "name", "plan_name", [association_stage_1], **conn_parameters
1862             )
1863             self.assertIn("result", result)
1864             self.assertEqual(result["result"], False)
1865             self.assertIn("comment", result)
1866             self.assertEqual(result["comment"], repr(("error",)))
1867             self.assertIn("changes", result)
1868             self.assertEqual(result["changes"], {})
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import collections
3 import copy
4 import datetime
5 import logging
6 import os
7 import re
8 import shutil
9 import subprocess
10 import sys
11 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import time
12 import urllib.parse
13 from xml.etree import ElementTree
14 from xml.sax import saxutils
15 import jinja2.exceptions
16 import salt.utils.data
17 import salt.utils.files
18 import salt.utils.json
19 import salt.utils.path
20 import salt.utils.stringutils
21 import salt.utils.templates
22 import salt.utils.virt
23 import salt.utils.xmlutil as xmlutil
24 import salt.utils.yaml
25 from salt._compat import ipaddress
26 from salt.exceptions import CommandExecutionError, SaltInvocationError
27 try:
28     import libvirt  # pylint: disable=import-error
29     from</b></font> libvirt import libvirtError
30     HAS_LIBVIRT = True
31 except ImportError:
32     HAS_LIBVIRT = False
33 log = logging.getLogger(__name__)
34 JINJA = jinja2.Environment(
35     loader=jinja2.FileSystemLoader(
36         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "virt")
37     )
38 )
39 CACHE_DIR = "/var/lib/libvirt/saltinst"
40 VIRT_STATE_NAME_MAP = {
41     0: "running",
42     1: "running",
43     2: "running",
44     3: "paused",
45     4: "shutdown",
46     5: "shutdown",
47     6: "crashed",
48 }
49 def __virtual__():
50     if not HAS_LIBVIRT:
51         return (False, "Unable to locate or import python libvirt library.")
52     return "virt"
53 def __get_request_auth(username, password):
54     def __request_auth(credentials, user_data):
55         for credential in credentials:
56             if credential[0] == libvirt.VIR_CRED_AUTHNAME:
57                 credential[4] = (
58                     username
59                     if username
60                     else __salt__["config.get"](
61                         "virt:connection:auth:username", credential[3]
62                     )
63                 )
64             elif credential[0] == libvirt.VIR_CRED_NOECHOPROMPT:
65                 credential[4] = (
66                     password
67                     if password
68                     else __salt__["config.get"](
69                         "virt:connection:auth:password", credential[3]
70                     )
71                 )
72             else:
73                 log.info("Unhandled credential type: %s", credential[0])
74         return 0
75 def __get_conn(**kwargs):
76     username = kwargs.get("username", None)
77     password = kwargs.get("password", None)
78     conn_str = kwargs.get("connection", None)
79     if not conn_str:
80         conn_str = __salt__["config.get"]("virt:connection:uri", conn_str)
81     try:
82         auth_types = [
83             libvirt.VIR_CRED_AUTHNAME,
84             libvirt.VIR_CRED_NOECHOPROMPT,
85             libvirt.VIR_CRED_ECHOPROMPT,
86             libvirt.VIR_CRED_PASSPHRASE,
87             libvirt.VIR_CRED_EXTERNAL,
88         ]
89         conn = libvirt.openAuth(
90             conn_str, [auth_types, __get_request_auth(username, password), None], 0
91         )
92     except Exception:  # pylint: disable=broad-except
93         raise CommandExecutionError(
94             "Sorry, {} failed to open a connection to the hypervisor "
95             "software at {}".format(__grains__["fqdn"], conn_str)
96         )
97     return conn
98 def _get_domain(conn, *vms, **kwargs):
99     ret = list()
100     lookup_vms = list()
101     all_vms = []
102     if kwargs.get("active", True):
103         for id_ in conn.listDomainsID():
104             all_vms.append(conn.lookupByID(id_).name())
105     if kwargs.get("inactive", True):
106         for id_ in conn.listDefinedDomains():
107             all_vms.append(id_)
108     if vms and not all_vms:
109         raise CommandExecutionError("No virtual machines found.")
110     if vms:
111         for name in vms:
112             if name not in all_vms:
113                 raise CommandExecutionError(
114                     'The VM "{name}" is not present'.format(name=name)
115                 )
116             else:
117                 lookup_vms.append(name)
118     else:
119         lookup_vms = list(all_vms)
120     for name in lookup_vms:
121         ret.append(conn.lookupByName(name))
122     return len(ret) == 1 and not kwargs.get("iterable") and ret[0] or ret
123 def _parse_qemu_img_info(info):
124     raw_infos = salt.utils.json.loads(info)
125     disks = []
126     for disk_infos in raw_infos:
127         disk = {
128             "file": disk_infos["filename"],
129             "file format": disk_infos["format"],
130             "disk size": disk_infos["actual-size"],
131             "virtual size": disk_infos["virtual-size"],
132             "cluster size": disk_infos["cluster-size"]
133             if "cluster-size" in disk_infos
134             else None,
135         }
136         if "full-backing-filename" in disk_infos.keys():
137             disk["backing file"] = format(disk_infos["full-backing-filename"])
138         if "snapshots" in disk_infos.keys():
139             disk["snapshots"] = [
140                 {
141                     "id": snapshot["id"],
142                     "tag": snapshot["name"],
143                     "vmsize": snapshot["vm-state-size"],
144                     "date": datetime.datetime.fromtimestamp(
145                         float(
146                             "{}.{}".format(snapshot["date-sec"], snapshot["date-nsec"])
147                         )
148                     ).isoformat(),
149                     "vmclock": datetime.datetime.utcfromtimestamp(
150                         float(
151                             "{}.{}".format(
152                                 snapshot["vm-clock-sec"], snapshot["vm-clock-nsec"]
153                             )
154                         )
155                     )
156                     .time()
157                     .isoformat(),
158                 }
159                 for snapshot in disk_infos["snapshots"]
160             ]
161         disks.append(disk)
162     for disk in disks:
163         if "backing file" in disk.keys():
164             candidates = [
165                 info
166                 for info in disks
167                 if "file" in info.keys() and info["file"] == disk["backing file"]
168             ]
169             if candidates:
170                 disk["backing file"] = candidates[0]
171     return disks[0]
172 def _get_uuid(dom):
173     return ElementTree.fromstring(get_xml(dom)).find("uuid").text
174 def _get_on_poweroff(dom):
175     node = ElementTree.fromstring(get_xml(dom)).find("on_poweroff")
176     return node.text if node is not None else ""
177 def _get_on_reboot(dom):
178     node = ElementTree.fromstring(get_xml(dom)).find("on_reboot")
179     return node.text if node is not None else ""
180 def _get_on_crash(dom):
181     node = ElementTree.fromstring(get_xml(dom)).find("on_crash")
182     return node.text if node is not None else ""
183 def _get_nics(dom):
184     nics = {}
185     doc = ElementTree.fromstring(dom.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
186     for iface_node in doc.findall("devices/interface"):
187         nic = {}
188         nic["type"] = iface_node.get("type")
189         for v_node in iface_node:
190             if v_node.tag == "mac":
191                 nic["mac"] = v_node.get("address")
192             if v_node.tag == "model":
193                 nic["model"] = v_node.get("type")
194             if v_node.tag == "target":
195                 nic["target"] = v_node.get("dev")
196             if re.match("(driver|source|address)", v_node.tag):
197                 temp = {}
198                 for key, value in v_node.attrib.items():
199                     temp[key] = value
200                 nic[v_node.tag] = temp
201             if v_node.tag == "virtualport":
202                 temp = {}
203                 temp["type"] = v_node.get("type")
204                 for key, value in v_node.attrib.items():
205                     temp[key] = value
206                 nic["virtualport"] = temp
207         if "mac" not in nic:
208             continue
209         nics[nic["mac"]] = nic
210     return nics
211 def _get_graphics(dom):
212     out = {
213         "autoport": "None",
214         "keymap": "None",
215         "listen": "None",
216         "port": "None",
217         "type": "None",
218     }
219     doc = ElementTree.fromstring(dom.XMLDesc(0))
220     for g_node in doc.findall("devices/graphics"):
221         for key, value in g_node.attrib.items():
222             out[key] = value
223     return out
224 def _get_loader(dom):
225     out = {"path": "None"}
226     doc = ElementTree.fromstring(dom.XMLDesc(0))
227     for g_node in doc.findall("os/loader"):
228         out["path"] = g_node.text
229         for key, value in g_node.attrib.items():
230             out[key] = value
231     return out
232 def _get_disks(conn, dom):
233     disks = {}
234     doc = ElementTree.fromstring(dom.XMLDesc(0))
235     all_volumes = _get_all_volumes_paths(conn)
236     for elem in doc.findall("devices/disk"):
237         source = elem.find("source")
238         if source is None:
239             continue
240         target = elem.find("target")
241         driver = elem.find("driver")
242         if target is None:
243             continue
244         qemu_target = None
245         extra_properties = None
246         if "dev" in target.attrib:
247             disk_type = elem.get("type")
248             def _get_disk_volume_data(pool_name, volume_name):
249                 qemu_target = "{}/{}".format(pool_name, volume_name)
250                 pool = conn.storagePoolLookupByName(pool_name)
251                 extra_properties = {}
252                 try:
253                     vol = pool.storageVolLookupByName(volume_name)
254                     vol_info = vol.info()
255                     extra_properties = {
256                         "virtual size": vol_info[1],
257                         "disk size": vol_info[2],
258                     }
259                     backing_files = [
260                         {
261                             "file": node.find("source").get("file"),
262                             "file format": node.find("format").get("type"),
263                         }
264                         for node in elem.findall(".//backingStore[source]")
265                     ]
266                     if backing_files:
267                         extra_properties["backing file"] = backing_files[0]
268                         parent = extra_properties["backing file"]
269                         for sub_backing_file in backing_files[1:]:
270                             parent["backing file"] = sub_backing_file
271                             parent = sub_backing_file
272                     else:
273                         vol_desc = ElementTree.fromstring(vol.XMLDesc())
274                         backing_path = vol_desc.find("./backingStore/path")
275                         backing_format = vol_desc.find("./backingStore/format")
276                         if backing_path is not None:
277                             extra_properties["backing file"] = {
278                                 "file": backing_path.text
279                             }
280                             if backing_format is not None:
281                                 extra_properties["backing file"][
282                                     "file format"
283                                 ] = backing_format.get("type")
284                 except libvirt.libvirtError:
285                     log.info(
286                         "Couldn't extract all volume informations: pool is likely not"
287                         " running or refreshed"
288                     )
289                 return (qemu_target, extra_properties)
290             if disk_type == "file":
291                 qemu_target = source.get("file", "")
292                 if qemu_target.startswith("/dev/zvol/"):
293                     disks[target.get("dev")] = {"file": qemu_target, "zfs": True}
294                     continue
295                 if qemu_target in all_volumes.keys():
296                     volume = all_volumes[qemu_target]
297                     qemu_target, extra_properties = _get_disk_volume_data(
298                         volume["pool"], volume["name"]
299                     )
300                 elif elem.get("device", "disk") != "cdrom":
301                     try:
302                         process = subprocess.Popen(
303                             [
304                                 "qemu-img",
305                                 "info",
306                                 "-U",
307                                 "--output",
308                                 "json",
309                                 "--backing-chain",
310                                 qemu_target,
311                             ],
312                             shell=False,
313                             stdout=subprocess.PIPE,
314                             stderr=subprocess.PIPE,
315                         )
316                         stdout, stderr = process.communicate()
317                         if process.returncode == 0:
318                             qemu_output = salt.utils.stringutils.to_str(stdout)
319                             output = _parse_qemu_img_info(qemu_output)
320                             extra_properties = output
321                         else:
322                             extra_properties = {"error": stderr}
323                     except FileNotFoundError:
324                         extra_properties = {"error": "qemu-img not found"}
325             elif disk_type == "block":
326                 qemu_target = source.get("dev", "")
327                 if qemu_target in all_volumes.keys():
328                     volume = all_volumes[qemu_target]
329                     qemu_target, extra_properties = _get_disk_volume_data(
330                         volume["pool"], volume["name"]
331                     )
332             elif disk_type == "network":
333                 qemu_target = source.get("protocol")
334                 source_name = source.get("name")
335                 if source_name:
336                     qemu_target = "{}:{}".format(qemu_target, source_name)
337                 if source.get("protocol") in ["rbd", "gluster"]:
338                     for pool_i in conn.listAllStoragePools():
339                         pool_i_xml = ElementTree.fromstring(pool_i.XMLDesc())
340                         name_node = pool_i_xml.find("source/name")
341                         if name_node is not None and source_name.startswith(
342                             "{}/".format(name_node.text)
343                         ):
344                             qemu_target = "{}{}".format(
345                                 pool_i.name(), source_name[len(name_node.text) :]
346                             )
347                             break
348                 if elem.get("device", "disk") == "cdrom":
349                     host_node = source.find("host")
350                     if host_node is not None:
351                         hostname = host_node.get("name")
352                         port = host_node.get("port")
353                         qemu_target = urllib.parse.urlunparse(
354                             (
355                                 source.get("protocol"),
356                                 "{}:{}".format(hostname, port) if port else hostname,
357                                 source_name,
358                                 "",
359                                 saxutils.unescape(source.get("query", "")),
360                                 "",
361                             )
362                         )
363             elif disk_type == "volume":
364                 pool_name = source.get("pool")
365                 volume_name = source.get("volume")
366                 qemu_target, extra_properties = _get_disk_volume_data(
367                     pool_name, volume_name
368                 )
369             if not qemu_target:
370                 continue
371             disk = {
372                 "file": qemu_target,
373                 "type": elem.get("device"),
374             }
375             if driver is not None and "type" in driver.attrib:
376                 disk["file format"] = driver.get("type")
377             if extra_properties:
378                 disk.update(extra_properties)
379             disks[target.get("dev")] = disk
380     return disks
381 def _libvirt_creds():
382     g_cmd = ["grep", "^\\s*group", "/etc/libvirt/qemu.conf"]
383     u_cmd = ["grep", "^\\s*user", "/etc/libvirt/qemu.conf"]
384     try:
385         stdout = subprocess.Popen(g_cmd, stdout=subprocess.PIPE).communicate()[0]
386         group = salt.utils.stringutils.to_str(stdout).split('"')[1]
387     except IndexError:
388         group = "root"
389     try:
390         stdout = subprocess.Popen(u_cmd, stdout=subprocess.PIPE).communicate()[0]
391         user = salt.utils.stringutils.to_str(stdout).split('"')[1]
392     except IndexError:
393         user = "root"
394     return {"user": user, "group": group}
395 def _migrate(dom, dst_uri, **kwargs):
396     flags = 0
397     params = {}
398     migrated_state = libvirt.VIR_DOMAIN_RUNNING_MIGRATED
399     if kwargs.get("live", True):
400         flags |= libvirt.VIR_MIGRATE_LIVE
401     if kwargs.get("persistent", True):
402         flags |= libvirt.VIR_MIGRATE_PERSIST_DEST
403     if kwargs.get("undefinesource", True):
404         flags |= libvirt.VIR_MIGRATE_UNDEFINE_SOURCE
405     max_bandwidth = kwargs.get("max_bandwidth")
406     if max_bandwidth:
407         try:
408             bandwidth_value = int(max_bandwidth)
409         except ValueError:
410             raise SaltInvocationError(
411                 "Invalid max_bandwidth value: {}".format(max_bandwidth)
412             )
413         dom.migrateSetMaxSpeed(bandwidth_value)
414     max_downtime = kwargs.get("max_downtime")
415     if max_downtime:
416         try:
417             downtime_value = int(max_downtime)
418         except ValueError:
419             raise SaltInvocationError(
420                 "Invalid max_downtime value: {}".format(max_downtime)
421             )
422         dom.migrateSetMaxDowntime(downtime_value)
423     if kwargs.get("offline") is True:
424         flags |= libvirt.VIR_MIGRATE_OFFLINE
425         migrated_state = libvirt.VIR_DOMAIN_RUNNING_UNPAUSED
426     if kwargs.get("compressed") is True:
427         flags |= libvirt.VIR_MIGRATE_COMPRESSED
428     comp_methods = kwargs.get("comp_methods")
429     if comp_methods:
430         params[libvirt.VIR_MIGRATE_PARAM_COMPRESSION] = comp_methods.split(",")
431     comp_options = {
432         "comp_mt_level": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL,
433         "comp_mt_threads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS,
434         "comp_mt_dthreads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS,
435         "comp_xbzrle_cache": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE,
436     }
437     for (comp_option, param_key) in comp_options.items():
438         comp_option_value = kwargs.get(comp_option)
439         if comp_option_value:
440             try:
441                 params[param_key] = int(comp_option_value)
442             except ValueError:
443                 raise SaltInvocationError("Invalid {} value".format(comp_option))
444     parallel_connections = kwargs.get("parallel_connections")
445     if parallel_connections:
446         try:
447             params[libvirt.VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS] = int(
448                 parallel_connections
449             )
450         except ValueError:
451             raise SaltInvocationError("Invalid parallel_connections value")
452         flags |= libvirt.VIR_MIGRATE_PARALLEL
453     if __salt__["config.get"]("virt:tunnel"):
454         if parallel_connections:
455             raise SaltInvocationError(
456                 "Parallel migration isn't compatible with tunneled migration"
457             )
458         flags |= libvirt.VIR_MIGRATE_PEER2PEER
459         flags |= libvirt.VIR_MIGRATE_TUNNELLED
460     if kwargs.get("postcopy") is True:
461         flags |= libvirt.VIR_MIGRATE_POSTCOPY
462     postcopy_bandwidth = kwargs.get("postcopy_bandwidth")
463     if postcopy_bandwidth:
464         try:
465             postcopy_bandwidth_value = int(postcopy_bandwidth)
466         except ValueError:
467             raise SaltInvocationError("Invalid postcopy_bandwidth value")
468         dom.migrateSetMaxSpeed(
469             postcopy_bandwidth_value,
470             flags=libvirt.VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY,
471         )
472     copy_storage = kwargs.get("copy_storage")
473     if copy_storage:
474         if copy_storage == "all":
475             flags |= libvirt.VIR_MIGRATE_NON_SHARED_DISK
476         elif copy_storage in ["inc", "incremental"]:
477             flags |= libvirt.VIR_MIGRATE_NON_SHARED_INC
478         else:
479             raise SaltInvocationError("invalid copy_storage value")
480     try:
481         state = False
482         dst_conn = __get_conn(
483             connection=dst_uri,
484             username=kwargs.get("username"),
485             password=kwargs.get("password"),
486         )
487         new_dom = dom.migrate3(dconn=dst_conn, params=params, flags=flags)
488         if new_dom:
489             state = new_dom.state()
490         dst_conn.close()
491         return state and migrated_state in state
492     except libvirt.libvirtError as err:
493         dst_conn.close()
494         raise CommandExecutionError(err.get_error_message())
495 def _get_volume_path(pool, volume_name):
496     if volume_name in pool.listVolumes():
497         volume = pool.storageVolLookupByName(volume_name)
498         volume_xml = ElementTree.fromstring(volume.XMLDesc())
499         return volume_xml.find("./target/path").text
500     pool_xml = ElementTree.fromstring(pool.XMLDesc())
501     pool_path = pool_xml.find("./target/path").text
502     return pool_path + "/" + volume_name
503 def _disk_from_pool(conn, pool, pool_xml, volume_name):
504     pool_type = pool_xml.get("type")
505     disk_context = {}
506     if pool_type in ["dir", "netfs", "fs"]:
507         disk_context["type"] = "file"
508         disk_context["source_file"] = _get_volume_path(pool, volume_name)
509     elif pool_type in ["logical", "disk", "iscsi", "scsi"]:
510         disk_context["type"] = "block"
511         disk_context["format"] = "raw"
512         disk_context["source_file"] = _get_volume_path(pool, volume_name)
513     elif pool_type in ["rbd", "gluster", "sheepdog"]:
514         disk_context["type"] = "network"
515         disk_context["protocol"] = pool_type
516         disk_context["hosts"] = [
517             {"name": host.get("name"), "port": host.get("port")}
518             for host in pool_xml.findall(".//host")
519         ]
520         dir_node = pool_xml.find("./source/dir")
521         name_node = pool_xml.find("./source/name")
522         if name_node is not None:
523             disk_context["volume"] = "{}/{}".format(name_node.text, volume_name)
524         auth_node = pool_xml.find("./source/auth")
525         if auth_node is not None:
526             username = auth_node.get("username")
527             secret_node = auth_node.find("./secret")
528             usage = secret_node.get("usage")
529             if not usage:
530                 uuid = secret_node.get("uuid")
531                 usage = conn.secretLookupByUUIDString(uuid).usageID()
532             disk_context["auth"] = {
533                 "type": "ceph",
534                 "username": username,
535                 "usage": usage,
536             }
537     return disk_context
538 def _handle_unit(s, def_unit="m"):
539     m = re.match(r"(?P&lt;value&gt;[0-9.]*)\s*(?P&lt;unit&gt;.*)$", str(s).strip())
540     value = m.group("value")
541     unit = m.group("unit").lower() or def_unit
542     try:
543         value = int(value)
544     except ValueError:
545         try:
546             value = float(value)
547         except ValueError:
548             raise SaltInvocationError("invalid number")
549     dec = False
550     if re.match(r"[kmgtpezy]b$", unit):
551         dec = True
552     elif not re.match(r"(b|[kmgtpezy](ib)?)$", unit):
553         raise SaltInvocationError("invalid units")
554     p = "bkmgtpezy".index(unit[0])
555     value *= 10 ** (p * 3) if dec else 2 ** (p * 10)
556     return int(value)
557 def nesthash(value=None):
558     return collections.defaultdict(nesthash, value or {})
559 def _gen_xml(
560     conn,
561     name,
562     cpu,
563     mem,
564     diskp,
565     nicp,
566     hypervisor,
567     os_type,
568     arch,
569     graphics=None,
570     boot=None,
571     boot_dev=None,
572     numatune=None,
573     hypervisor_features=None,
574     clock=None,
575     serials=None,
576     consoles=None,
577     stop_on_reboot=False,
578     host_devices=None,
579     **kwargs
580 ):
581     context = {
582         "hypervisor": hypervisor,
583         "name": name,
584         "hypervisor_features": hypervisor_features or {},
585         "clock": clock or {},
586         "on_reboot": "destroy" if stop_on_reboot else "restart",
587     }
588     context["to_kib"] = lambda v: int(_handle_unit(v) / 1024)
589     context["yesno"] = lambda v: "yes" if v else "no"
590     context["mem"] = nesthash()
591     if isinstance(mem, int):
592         context["mem"]["boot"] = mem
593         context["mem"]["current"] = mem
594     elif isinstance(mem, dict):
595         context["mem"] = nesthash(mem)
596     context["cpu"] = nesthash()
597     context["cputune"] = nesthash()
598     if isinstance(cpu, int):
599         context["cpu"]["maximum"] = str(cpu)
600     elif isinstance(cpu, dict):
601         context["cpu"] = nesthash(cpu)
602     if clock:
603         offset = "utc" if clock.get("utc", True) else "localtime"
604         if "timezone" in clock:
605             offset = "timezone"
606         context["clock"]["offset"] = offset
607     if hypervisor in ["qemu", "kvm"]:
608         context["numatune"] = numatune if numatune else {}
609         context["controller_model"] = False
610     elif hypervisor == "vmware":
611         context["controller_model"] = "lsilogic"
612     if graphics:
613         if "listen" not in graphics:
614             graphics["listen"] = {"type": "address", "address": "0.0.0.0"}
615         elif (
616             "address" not in graphics["listen"]
617             and graphics["listen"]["type"] == "address"
618         ):
619             graphics["listen"]["address"] = "0.0.0.0"
620         if graphics.get("type", "none") == "none":
621             graphics = None
622     context["graphics"] = graphics
623     context["boot_dev"] = boot_dev.split() if boot_dev is not None else ["hd"]
624     context["boot"] = boot if boot else {}
625     efi_value = context["boot"].get("efi", None) if boot else None
626     if efi_value is True:
627         context["boot"]["os_attrib"] = "firmware='efi'"
628     elif efi_value is not None and type(efi_value) != bool:
629         raise SaltInvocationError("Invalid efi value")
630     if os_type == "xen":
631         if __grains__["os_family"] == "Suse":
632             if not boot or not boot.get("kernel", None):
633                 paths = [
634                     path
635                     for path in ["/usr/share", "/usr/lib"]
636                     if os.path.exists(path + "/grub2/x86_64-xen/grub.xen")
637                 ]
638                 if not paths:
639                     raise CommandExecutionError("grub-x86_64-xen needs to be installed")
640                 context["boot"]["kernel"] = paths[0] + "/grub2/x86_64-xen/grub.xen"
641                 context["boot_dev"] = []
642     default_port = 23023
643     default_chardev_type = "tcp"
644     chardev_types = ["serial", "console"]
645     for chardev_type in chardev_types:
646         context[chardev_type + "s"] = []
647         parameter_value = locals()[chardev_type + "s"]
648         if parameter_value is not None:
649             for chardev in parameter_value:
650                 chardev_context = chardev
651                 chardev_context["type"] = chardev.get("type", default_chardev_type)
652                 if chardev_context["type"] == "tcp":
653                     chardev_context["port"] = chardev.get("port", default_port)
654                     chardev_context["protocol"] = chardev.get("protocol", "telnet")
655                 context[chardev_type + "s"].append(chardev_context)
656     context["disks"] = []
657     disk_bus_map = {"virtio": "vd", "xen": "xvd", "fdc": "fd", "ide": "hd"}
658     targets = []
659     for i, disk in enumerate(diskp):
660         prefix = disk_bus_map.get(disk["model"], "sd")
661         disk_context = {
662             "device": disk.get("device", "disk"),
663             "target_dev": _get_disk_target(targets, len(diskp), prefix),
664             "disk_bus": disk["model"],
665             "format": disk.get("format", "raw"),
666             "index": str(i),
667             "io": disk.get("io", "native"),
668             "iothread": disk.get("iothread_id", None),
669         }
670         targets.append(disk_context["target_dev"])
671         if disk.get("source_file"):
672             url = urllib.parse.urlparse(disk["source_file"])
673             if not url.scheme or not url.hostname:
674                 disk_context["source_file"] = disk["source_file"]
675                 disk_context["type"] = "file"
676             elif url.scheme in ["http", "https", "ftp", "ftps", "tftp"]:
677                 disk_context["type"] = "network"
678                 disk_context["protocol"] = url.scheme
679                 disk_context["volume"] = url.path
680                 disk_context["query"] = saxutils.escape(url.query)
681                 disk_context["hosts"] = [{"name": url.hostname, "port": url.port}]
682         elif disk.get("pool"):
683             disk_context["volume"] = disk["filename"]
684             pool = conn.storagePoolLookupByName(disk["pool"])
685             pool_xml = ElementTree.fromstring(pool.XMLDesc())
686             pool_type = pool_xml.get("type")
687             if hypervisor == "xen" or pool_type in ["rbd", "gluster", "sheepdog"]:
688                 disk_context.update(
689                     _disk_from_pool(conn, pool, pool_xml, disk_context["volume"])
690                 )
691             else:
692                 if pool_type in ["disk", "logical"]:
693                     disk_context["format"] = "raw"
694                 disk_context["type"] = "volume"
695                 disk_context["pool"] = disk["pool"]
696         else:
697             disk_context["type"] = "file"
698         if hypervisor in ["qemu", "kvm", "bhyve", "xen"]:
699             disk_context["address"] = False
700             disk_context["driver"] = True
701         elif hypervisor in ["esxi", "vmware"]:
702             disk_context["address"] = True
703             disk_context["driver"] = False
704         context["disks"].append(disk_context)
705     context["nics"] = nicp
706     hostdev_context = []
707     try:
708         for hostdev_name in host_devices or []:
709             hostdevice = conn.nodeDeviceLookupByName(hostdev_name)
710             doc = ElementTree.fromstring(hostdevice.XMLDesc())
711             if "pci" in hostdevice.listCaps():
712                 hostdev_context.append(
713                     {
714                         "type": "pci",
715                         "domain": "0x{:04x}".format(
716                             int(doc.find("./capability[@type='pci']/domain").text)
717                         ),
718                         "bus": "0x{:02x}".format(
719                             int(doc.find("./capability[@type='pci']/bus").text)
720                         ),
721                         "slot": "0x{:02x}".format(
722                             int(doc.find("./capability[@type='pci']/slot").text)
723                         ),
724                         "function": "0x{}".format(
725                             doc.find("./capability[@type='pci']/function").text
726                         ),
727                     }
728                 )
729             elif "usb_device" in hostdevice.listCaps():
730                 vendor_id = doc.find(".//vendor").get("id")
731                 product_id = doc.find(".//product").get("id")
732                 hostdev_context.append(
733                     {"type": "usb", "vendor": vendor_id, "product": product_id}
734                 )
735     except libvirt.libvirtError as err:
736         conn.close()
737         raise CommandExecutionError(
738             "Failed to get host devices: " + err.get_error_message()
739         )
740     context["hostdevs"] = hostdev_context
741     context["os_type"] = os_type
742     context["arch"] = arch
743     fn_ = "libvirt_domain.jinja"
744     try:
745         template = JINJA.get_template(fn_)
746     except jinja2.exceptions.TemplateNotFound:
747         log.error("Could not load template %s", fn_)
748         return ""
749     return template.render(**context)
750 def _gen_vol_xml(
751     name,
752     size,
753     format=None,
754     allocation=0,
755     type=None,
756     permissions=None,
757     backing_store=None,
758     nocow=False,
759 ):
760     size = int(size) * 1024  # MB
761     context = {
762         "type": type,
763         "name": name,
764         "target": {"permissions": permissions, "nocow": nocow},
765         "format": format,
766         "size": str(size),
767         "allocation": str(int(allocation) * 1024),
768         "backingStore": backing_store,
769     }
770     fn_ = "libvirt_volume.jinja"
771     try:
772         template = JINJA.get_template(fn_)
773     except jinja2.exceptions.TemplateNotFound:
774         log.error("Could not load template %s", fn_)
775         return ""
776     return template.render(**context)
777 def _gen_net_xml(
778     name,
779     bridge,
780     forward,
781     vport,
782     tag=None,
783     ip_configs=None,
784     mtu=None,
785     domain=None,
786     nat=None,
787     interfaces=None,
788     addresses=None,
789     physical_function=None,
790     dns=None,
791 ):
792     if isinstance(vport, str):
793         vport_context = {"type": vport}
794     else:
795         vport_context = vport
796     if isinstance(tag, (str, int)):
797         tag_context = {"tags": [{"id": tag}]}
798     else:
799         tag_context = tag
800     addresses_context = []
801     if addresses:
802         matches = [
803             re.fullmatch(r"([0-9]+):([0-9A-Fa-f]+):([0-9A-Fa-f]+)\.([0-9])", addr)
804             for addr in addresses.lower().split(" ")
805         ]
806         addresses_context = [
807             {
808                 "domain": m.group(1),
809                 "bus": m.group(2),
810                 "slot": m.group(3),
811                 "function": m.group(4),
812             }
813             for m in matches
814             if m
815         ]
816     context = {
817         "name": name,
818         "bridge": bridge,
819         "mtu": mtu,
820         "domain": domain,
821         "forward": forward,
822         "nat": nat,
823         "interfaces": interfaces.split(" ") if interfaces else [],
824         "addresses": addresses_context,
825         "pf": physical_function,
826         "vport": vport_context,
827         "vlan": tag_context,
828         "dns": dns,
829         "ip_configs": [
830             {
831                 "address": ipaddress.ip_network(config["cidr"]),
832                 "dhcp_ranges": config.get("dhcp_ranges", []),
833                 "hosts": config.get("hosts", {}),
834                 "bootp": config.get("bootp", {}),
835                 "tftp": config.get("tftp"),
836             }
837             for config in ip_configs or []
838         ],
839         "yesno": lambda v: "yes" if v else "no",
840     }
841     fn_ = "libvirt_network.jinja"
842     try:
843         template = JINJA.get_template(fn_)
844     except jinja2.exceptions.TemplateNotFound:
845         log.error("Could not load template %s", fn_)
846         return ""
847     return template.render(**context)
848 def _gen_pool_xml(
849     name,
850     ptype,
851     target=None,
852     permissions=None,
853     source_devices=None,
854     source_dir=None,
855     source_adapter=None,
856     source_hosts=None,
857     source_auth=None,
858     source_name=None,
859     source_format=None,
860     source_initiator=None,
861 ):
862     hosts = [host.split(":") for host in source_hosts or []]
863     source = None
864     if any(
865         [
866             source_devices,
867             source_dir,
868             source_adapter,
869             hosts,
870             source_auth,
871             source_name,
872             source_format,
873             source_initiator,
874         ]
875     ):
876         source = {
877             "devices": source_devices or [],
878             "dir": source_dir
879             if source_format != "cifs" or not source_dir
880             else source_dir.lstrip("/"),
881             "adapter": source_adapter,
882             "hosts": [
883                 {"name": host[0], "port": host[1] if len(host) &gt; 1 else None}
884                 for host in hosts
885             ],
886             "auth": source_auth,
887             "name": source_name,
888             "format": source_format,
889             "initiator": source_initiator,
890         }
891     context = {
892         "name": name,
893         "ptype": ptype,
894         "target": {"path": target, "permissions": permissions},
895         "source": source,
896     }
897     fn_ = "libvirt_pool.jinja"
898     try:
899         template = JINJA.get_template(fn_)
900     except jinja2.exceptions.TemplateNotFound:
901         log.error("Could not load template %s", fn_)
902         return ""
903     return template.render(**context)
904 def _gen_secret_xml(auth_type, usage, description):
905     context = {
906         "type": auth_type,
907         "usage": usage,
908         "description": description,
909     }
910     fn_ = "libvirt_secret.jinja"
911     try:
912         template = JINJA.get_template(fn_)
913     except jinja2.exceptions.TemplateNotFound:
914         log.error("Could not load template %s", fn_)
915         return ""
916     return template.render(**context)
917 def _get_images_dir():
918     img_dir = __salt__["config.get"]("virt:images")
919     log.debug("Image directory from config option `virt:images` is %s", img_dir)
920     return img_dir
921 def _zfs_image_create(
922     vm_name,
923     pool,
924     disk_name,
925     hostname_property_name,
926     sparse_volume,
927     disk_size,
928     disk_image_name,
929 ):
930     if not disk_image_name and not disk_size:
931         raise CommandExecutionError(
932             "Unable to create new disk {}, please specify"
933             " the disk image name or disk size argument".format(disk_name)
934         )
935     if not pool:
936         raise CommandExecutionError(
937             "Unable to create new disk {}, please specify the disk pool name".format(
938                 disk_name
939             )
940         )
941     destination_fs = os.path.join(pool, "{}.{}".format(vm_name, disk_name))
942     log.debug("Image destination will be %s", destination_fs)
943     existing_disk = __salt__["zfs.list"](name=pool)
944     if "error" in existing_disk:
945         raise CommandExecutionError(
946             "Unable to create new disk {}. {}".format(
947                 destination_fs, existing_disk["error"]
948             )
949         )
950     elif destination_fs in existing_disk:
951         log.info("ZFS filesystem %s already exists. Skipping creation", destination_fs)
952         blockdevice_path = os.path.join("/dev/zvol", pool, vm_name)
953         return blockdevice_path
954     properties = {}
955     if hostname_property_name:
956         properties[hostname_property_name] = vm_name
957     if disk_image_name:
958         __salt__["zfs.clone"](
959             name_a=disk_image_name, name_b=destination_fs, properties=properties
960         )
961     elif disk_size:
962         __salt__["zfs.create"](
963             name=destination_fs,
964             properties=properties,
965             volume_size=disk_size,
966             sparse=sparse_volume,
967         )
968     blockdevice_path = os.path.join(
969         "/dev/zvol", pool, "{}.{}".format(vm_name, disk_name)
970     )
971     log.debug("Image path will be %s", blockdevice_path)
972     return blockdevice_path
973 def _qemu_image_create(disk, create_overlay=False, saltenv="base"):
974     disk_size = disk.get("size", None)
975     disk_image = disk.get("image", None)
976     if not disk_size and not disk_image:
977         raise CommandExecutionError(
978             "Unable to create new disk {}, please specify"
979             " disk size and/or disk image argument".format(disk["filename"])
980         )
981     img_dest = disk["source_file"]
982     log.debug("Image destination will be %s", img_dest)
983     img_dir = os.path.dirname(img_dest)
984     log.debug("Image destination directory is %s", img_dir)
985     if not os.path.exists(img_dir):
986         os.makedirs(img_dir)
987     if disk_image:
988         log.debug("Create disk from specified image %s", disk_image)
989         sfn = __salt__["cp.cache_file"](disk_image, saltenv)
990         qcow2 = False
991         if salt.utils.path.which("qemu-img"):
992             res = __salt__["cmd.run"]('qemu-img info "{}"'.format(sfn))
993             imageinfo = salt.utils.yaml.safe_load(res)
994             qcow2 = imageinfo["file format"] == "qcow2"
995         try:
996             if create_overlay and qcow2:
997                 log.info("Cloning qcow2 image %s using copy on write", sfn)
998                 __salt__["cmd.run"](
999                     'qemu-img create -f qcow2 -o backing_file="{}" "{}"'.format(
1000                         sfn, img_dest
1001                     ).split()
1002                 )
1003             else:
1004                 log.debug("Copying %s to %s", sfn, img_dest)
1005                 salt.utils.files.copyfile(sfn, img_dest)
1006             mask = salt.utils.files.get_umask()
1007             if disk_size and qcow2:
1008                 log.debug("Resize qcow2 image to %sM", disk_size)
1009                 __salt__["cmd.run"](
1010                     'qemu-img resize "{}" {}M'.format(img_dest, disk_size)
1011                 )
1012             log.debug("Apply umask and remove exec bit")
1013             mode = (0o0777 ^ mask) &amp; 0o0666
1014             os.chmod(img_dest, mode)
1015         except OSError as err:
1016             raise CommandExecutionError(
1017                 "Problem while copying image. {} - {}".format(disk_image, err)
1018             )
1019     else:
1020         try:
1021             mask = salt.utils.files.get_umask()
1022             if disk_size:
1023                 log.debug("Create empty image with size %sM", disk_size)
1024                 __salt__["cmd.run"](
1025                     'qemu-img create -f {} "{}" {}M'.format(
1026                         disk.get("format", "qcow2"), img_dest, disk_size
1027                     )
1028                 )
1029             else:
1030                 raise CommandExecutionError(
1031                     "Unable to create new disk {},"
1032                     " please specify &lt;size&gt; argument".format(img_dest)
1033                 )
1034             log.debug("Apply umask and remove exec bit")
1035             mode = (0o0777 ^ mask) &amp; 0o0666
1036             os.chmod(img_dest, mode)
1037         except OSError as err:
1038             raise CommandExecutionError(
1039                 "Problem while creating volume {} - {}".format(img_dest, err)
1040             )
1041     return img_dest
1042 def _seed_image(seed_cmd, img_path, name, config, install, pub_key, priv_key):
1043     log.debug("Seeding image")
1044     __salt__[seed_cmd](
1045         img_path,
1046         id_=name,
1047         config=config,
1048         install=install,
1049         pub_key=pub_key,
1050         priv_key=priv_key,
1051     )
1052 def _disk_volume_create(conn, disk, seeder=None, saltenv="base"):
1053     if disk.get("overlay_image"):
1054         raise SaltInvocationError(
1055             "Disk overlay_image property is not supported when creating volumes,"
1056             "use backing_store_path and backing_store_format instead."
1057         )
1058     pool = conn.storagePoolLookupByName(disk["pool"])
1059     if disk["filename"] in pool.listVolumes():
1060         return
1061     pool_type = ElementTree.fromstring(pool.XMLDesc()).get("type")
1062     backing_path = disk.get("backing_store_path")
1063     backing_format = disk.get("backing_store_format")
1064     backing_store = None
1065     if (
1066         backing_path
1067         and backing_format
1068         and (disk.get("format") == "qcow2" or pool_type == "logical")
1069     ):
1070         backing_store = {"path": backing_path, "format": backing_format}
1071     if backing_store and disk.get("image"):
1072         raise SaltInvocationError(
1073             "Using a template image with a backing store is not possible, "
1074             "choose either of them."
1075         )
1076     vol_xml = _gen_vol_xml(
1077         disk["filename"],
1078         disk.get("size", 0),
1079         format=disk.get("format"),
1080         backing_store=backing_store,
1081     )
1082     _define_vol_xml_str(conn, vol_xml, disk.get("pool"))
1083     if disk.get("image"):
1084         log.debug("Caching disk template image: %s", disk.get("image"))
1085         cached_path = __salt__["cp.cache_file"](disk.get("image"), saltenv)
1086         if seeder:
1087             seeder(cached_path)
1088         _volume_upload(
1089             conn,
1090             disk["pool"],
1091             disk["filename"],
1092             cached_path,
1093             sparse=disk.get("format") == "qcow2",
1094         )
1095 def _disk_profile(conn, profile, hypervisor, disks, vm_name):
1096     default = [{"system": {"size": 8192}}]
1097     if hypervisor == "vmware":
1098         overlay = {"format": "vmdk", "model": "scsi", "device": "disk"}
1099     elif hypervisor in ["qemu", "kvm"]:
1100         overlay = {"device": "disk", "model": "virtio"}
1101     elif hypervisor == "xen":
1102         overlay = {"device": "disk", "model": "xen"}
1103     elif hypervisor == "bhyve":
1104         overlay = {"format": "raw", "model": "virtio", "sparse_volume": False}
1105     else:
1106         overlay = {}
1107     disklist = []
1108     if profile:
1109         disklist = copy.deepcopy(
1110             __salt__["config.get"]("virt:disk", {}).get(profile, default)
1111         )
1112         disklist = [dict(d, name=name) for disk in disklist for name, d in disk.items()]
1113     if disks:
1114         for udisk in disks:
1115             if "name" in udisk:
1116                 found = [disk for disk in disklist if udisk["name"] == disk["name"]]
1117                 if found:
1118                     found[0].update(udisk)
1119                 else:
1120                     disklist.append(udisk)
1121     pool_caps = _pool_capabilities(conn)
1122     for disk in disklist:
1123         if disk.get("device", "disk") == "cdrom" and "model" not in disk:
1124             disk["model"] = "ide"
1125         for key, val in overlay.items():
1126             if key not in disk:
1127                 disk[key] = val
1128         if disk.get("source_file") and os.path.exists(disk["source_file"]):
1129             disk["filename"] = os.path.basename(disk["source_file"])
1130             if not disk.get("format"):
1131                 disk["format"] = (
1132                     "qcow2" if disk.get("device", "disk") != "cdrom" else "raw"
1133                 )
1134         elif vm_name and disk.get("device", "disk") == "disk":
1135             _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps)
1136     return disklist
1137 def _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps):
1138     disk["filename"] = "{}_{}".format(vm_name, disk["name"])
1139     base_dir = disk.get("pool", None)
1140     if hypervisor in ["qemu", "kvm", "xen"]:
1141         if not base_dir:
1142             base_dir = _get_images_dir()
1143         if base_dir not in conn.listStoragePools():
1144             if not disk.get("format"):
1145                 disk["format"] = "qcow2"
1146             disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1147             disk["source_file"] = os.path.join(base_dir, disk["filename"])
1148         else:
1149             if "pool" not in disk:
1150                 disk["pool"] = base_dir
1151             pool_obj = conn.storagePoolLookupByName(base_dir)
1152             pool_xml = ElementTree.fromstring(pool_obj.XMLDesc())
1153             pool_type = pool_xml.get("type")
1154             if pool_type == "disk":
1155                 device = pool_xml.find("./source/device").get("path")
1156                 all_volumes = pool_obj.listVolumes()
1157                 if disk.get("source_file") not in all_volumes:
1158                     indexes = [
1159                         int(re.sub("[a-z]+", "", vol_name)) for vol_name in all_volumes
1160                     ] or [0]
1161                     index = min(
1162                         idx for idx in range(1, max(indexes) + 2) if idx not in indexes
1163                     )
1164                     disk["filename"] = "{}{}".format(os.path.basename(device), index)
1165             if disk.get("source_file"):
1166                 if not disk.get("source_file") in pool_obj.listVolumes():
1167                     raise SaltInvocationError(
1168                         "{} volume doesn't exist in pool {}".format(
1169                             disk.get("source_file"), base_dir
1170                         )
1171                     )
1172                 disk["filename"] = disk["source_file"]
1173                 del disk["source_file"]
1174             if not disk.get("format"):
1175                 volume_options = (
1176                     [
1177                         type_caps.get("options", {}).get("volume", {})
1178                         for type_caps in pool_caps.get("pool_types")
1179                         if type_caps["name"] == pool_type
1180                     ]
1181                     or [{}]
1182                 )[0]
1183                 if "qcow2" in volume_options.get("targetFormatType", []):
1184                     disk["format"] = "qcow2"
1185                 else:
1186                     disk["format"] = volume_options.get("default_format", None)
1187     elif hypervisor == "bhyve" and vm_name:
1188         disk["filename"] = "{}.{}".format(vm_name, disk["name"])
1189         disk["source_file"] = os.path.join(
1190             "/dev/zvol", base_dir or "", disk["filename"]
1191         )
1192     elif hypervisor in ["esxi", "vmware"]:
1193         if not base_dir:
1194             base_dir = __salt__["config.get"]("virt:storagepool", "[0] ")
1195         disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1196         disk["source_file"] = "{}{}".format(base_dir, disk["filename"])
1197 def _complete_nics(interfaces, hypervisor):
1198     vmware_overlay = {"type": "bridge", "source": "DEFAULT", "model": "e1000"}
1199     kvm_overlay = {"type": "bridge", "source": "br0", "model": "virtio"}
1200     xen_overlay = {"type": "bridge", "source": "br0", "model": None}
1201     bhyve_overlay = {"type": "bridge", "source": "bridge0", "model": "virtio"}
1202     overlays = {
1203         "xen": xen_overlay,
1204         "kvm": kvm_overlay,
1205         "qemu": kvm_overlay,
1206         "vmware": vmware_overlay,
1207         "bhyve": bhyve_overlay,
1208     }
1209     def _normalize_net_types(attributes):
1210         for type_ in ["bridge", "network"]:
1211             if type_ in attributes:
1212                 attributes["type"] = type_
1213                 attributes["source"] = attributes.pop(type_)
1214         attributes["type"] = attributes.get("type", None)
1215         attributes["source"] = attributes.get("source", None)
1216     def _apply_default_overlay(attributes):
1217         for key, value in overlays[hypervisor].items():
1218             if key not in attributes or not attributes[key]:
1219                 attributes[key] = value
1220     for interface in interfaces:
1221         _normalize_net_types(interface)
1222         if hypervisor in overlays:
1223             _apply_default_overlay(interface)
1224     return interfaces
1225 def _nic_profile(profile_name, hypervisor):
1226     config_data = __salt__["config.get"]("virt:nic", {}).get(
1227         profile_name, [{"eth0": {}}]
1228     )
1229     interfaces = []
1230     def append_dict_profile_to_interface_list(profile_dict):
1231         for interface_name, attributes in profile_dict.items():
1232             attributes["name"] = interface_name
1233             interfaces.append(attributes)
1234     if isinstance(config_data, dict):
1235         append_dict_profile_to_interface_list(config_data)
1236     elif isinstance(config_data, list):
1237         for interface in config_data:
1238             if isinstance(interface, dict):
1239                 if len(interface) == 1:
1240                     append_dict_profile_to_interface_list(interface)
1241                 else:
1242                     interfaces.append(interface)
1243     return _complete_nics(interfaces, hypervisor)
1244 def _get_merged_nics(hypervisor, profile, interfaces=None):
1245     nicp = _nic_profile(profile, hypervisor) if profile else []
1246     log.debug("NIC profile is %s", nicp)
1247     if interfaces:
1248         users_nics = _complete_nics(interfaces, hypervisor)
1249         for unic in users_nics:
1250             found = [nic for nic in nicp if nic["name"] == unic["name"]]
1251             if found:
1252                 found[0].update(unic)
1253             else:
1254                 nicp.append(unic)
1255         log.debug("Merged NICs: %s", nicp)
1256     return nicp
1257 def _handle_remote_boot_params(orig_boot):
1258     saltinst_dir = None
1259     new_boot = orig_boot.copy()
1260     keys = orig_boot.keys()
1261     cases = [
1262         {"efi"},
1263         {"kernel", "initrd", "efi"},
1264         {"kernel", "initrd", "cmdline", "efi"},
1265         {"loader", "nvram"},
1266         {"kernel", "initrd"},
1267         {"kernel", "initrd", "cmdline"},
1268         {"kernel", "initrd", "loader", "nvram"},
1269         {"kernel", "initrd", "cmdline", "loader", "nvram"},
1270     ]
1271     if keys in cases:
1272         for key in keys:
1273             if key == "efi" and type(orig_boot.get(key)) == bool:
1274                 new_boot[key] = orig_boot.get(key)
1275             elif orig_boot.get(key) is not None and salt.utils.virt.check_remote(
1276                 orig_boot.get(key)
1277             ):
1278                 if saltinst_dir is None:
1279                     os.makedirs(CACHE_DIR)
1280                     saltinst_dir = CACHE_DIR
1281                 new_boot[key] = salt.utils.virt.download_remote(
1282                     orig_boot.get(key), saltinst_dir
1283                 )
1284         return new_boot
1285     else:
1286         raise SaltInvocationError(
1287             "Invalid boot parameters,It has to follow this combination: [(kernel,"
1288             " initrd) or/and cmdline] or/and [(loader, nvram) or efi]"
1289         )
1290 def _handle_efi_param(boot, desc):
1291     efi_value = boot.get("efi", None) if boot else None
1292     parent_tag = desc.find("os")
1293     os_attrib = parent_tag.attrib
1294     if efi_value is False and os_attrib != {}:
1295         parent_tag.attrib.pop("firmware", None)
1296         return True
1297     elif type(efi_value) == bool and os_attrib == {}:
1298         if efi_value is True and parent_tag.find("loader") is None:
1299             parent_tag.set("firmware", "efi")
1300             return True
1301         if efi_value is False and parent_tag.find("loader") is not None:
1302             parent_tag.remove(parent_tag.find("loader"))
1303             parent_tag.remove(parent_tag.find("nvram"))
1304             return True
1305     elif type(efi_value) != bool:
1306         raise SaltInvocationError("Invalid efi value")
1307     return False
1308 def init(
1309     name,
1310     cpu,
1311     mem,
1312     nic="default",
1313     interfaces=None,
1314     hypervisor=None,
1315     start=True,  # pylint: disable=redefined-outer-name
1316     disk="default",
1317     disks=None,
1318     saltenv="base",
1319     seed=True,
1320     install=True,
1321     pub_key=None,
1322     priv_key=None,
1323     seed_cmd="seed.apply",
1324     graphics=None,
1325     os_type=None,
1326     arch=None,
1327     boot=None,
1328     boot_dev=None,
1329     numatune=None,
1330     hypervisor_features=None,
1331     clock=None,
1332     serials=None,
1333     consoles=None,
1334     stop_on_reboot=False,
1335     host_devices=None,
1336     **kwargs
1337 ):
1338     try:
1339         conn = __get_conn(**kwargs)
1340         caps = _capabilities(conn)
1341         os_types = sorted({guest["os_type"] for guest in caps["guests"]})
1342         arches = sorted({guest["arch"]["name"] for guest in caps["guests"]})
1343         virt_hypervisor = hypervisor
1344         if not virt_hypervisor:
1345             hypervisors = sorted(
1346                 {
1347                     x
1348                     for y in [
1349                         guest["arch"]["domains"].keys() for guest in caps["guests"]
1350                     ]
1351                     for x in y
1352                 }
1353             )
1354             if len(hypervisors) == 0:
1355                 raise SaltInvocationError("No supported hypervisors were found")
1356             virt_hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
1357         virt_hypervisor = "vmware" if virt_hypervisor == "esxi" else virt_hypervisor
1358         log.debug("Using hypervisor %s", virt_hypervisor)
1359         nicp = _get_merged_nics(virt_hypervisor, nic, interfaces)
1360         diskp = _disk_profile(conn, disk, virt_hypervisor, disks, name)
1361         for _disk in diskp:
1362             if _disk.get("device", "disk") == "cdrom":
1363                 continue
1364             log.debug("Creating disk for VM [ %s ]: %s", name, _disk)
1365             if virt_hypervisor == "vmware":
1366                 if "image" in _disk:
1367                     raise SaltInvocationError(
1368                         "virt.init does not support image "
1369                         "template in conjunction with esxi hypervisor"
1370                     )
1371                 else:
1372                     log.debug("Generating libvirt XML for %s", _disk)
1373                     volume_name = "{}/{}".format(name, _disk["name"])
1374                     filename = "{}.{}".format(volume_name, _disk["format"])
1375                     vol_xml = _gen_vol_xml(
1376                         filename, _disk["size"], format=_disk["format"]
1377                     )
1378                     _define_vol_xml_str(conn, vol_xml, pool=_disk.get("pool"))
1379             elif virt_hypervisor in ["qemu", "kvm", "xen"]:
1380                 def seeder(path):
1381                     _seed_image(
1382                         seed_cmd,
1383                         path,
1384                         name,
1385                         kwargs.get("config"),
1386                         install,
1387                         pub_key,
1388                         priv_key,
1389                     )
1390                 create_overlay = _disk.get("overlay_image", False)
1391                 format = _disk.get("format")
1392                 if _disk.get("source_file"):
1393                     if os.path.exists(_disk["source_file"]):
1394                         img_dest = _disk["source_file"]
1395                     else:
1396                         img_dest = _qemu_image_create(_disk, create_overlay, saltenv)
1397                 else:
1398                     _disk_volume_create(conn, _disk, seeder if seed else None, saltenv)
1399                     img_dest = None
1400                 if seed and img_dest and _disk.get("image", None):
1401                     seeder(img_dest)
1402             elif hypervisor in ["bhyve"]:
1403                 img_dest = _zfs_image_create(
1404                     vm_name=name,
1405                     pool=_disk.get("pool"),
1406                     disk_name=_disk.get("name"),
1407                     disk_size=_disk.get("size"),
1408                     disk_image_name=_disk.get("image"),
1409                     hostname_property_name=_disk.get("hostname_property"),
1410                     sparse_volume=_disk.get("sparse_volume"),
1411                 )
1412             else:
1413                 raise SaltInvocationError(
1414                     "Unsupported hypervisor when handling disk image: {}".format(
1415                         virt_hypervisor
1416                     )
1417                 )
1418         log.debug("Generating VM XML")
1419         if os_type is None:
1420             os_type = "hvm" if "hvm" in os_types else os_types[0]
1421         if arch is None:
1422             arch = "x86_64" if "x86_64" in arches else arches[0]
1423         if boot is not None:
1424             boot = _handle_remote_boot_params(boot)
1425         vm_xml = _gen_xml(
1426             conn,
1427             name,
1428             cpu,
1429             mem,
1430             diskp,
1431             nicp,
1432             virt_hypervisor,
1433             os_type,
1434             arch,
1435             graphics,
1436             boot,
1437             boot_dev,
1438             numatune,
1439             hypervisor_features,
1440             clock,
1441             serials,
1442             consoles,
1443             stop_on_reboot,
1444             host_devices,
1445             **kwargs
1446         )
1447         log.debug("New virtual machine definition: %s", vm_xml)
1448         conn.defineXML(vm_xml)
1449     except libvirt.libvirtError as err:
1450         conn.close()
1451         raise CommandExecutionError(err.get_error_message())
1452     if start:
1453         log.debug("Starting VM %s", name)
1454         _get_domain(conn, name).create()
1455     conn.close()
1456     return True
1457 def _disks_equal(disk1, disk2):
1458     target1 = disk1.find("target")
1459     target2 = disk2.find("target")
1460     disk1_dict = xmlutil.to_dict(disk1, True)
1461     disk2_dict = xmlutil.to_dict(disk2, True)
1462     source1_dict = disk1_dict.get("source", {})
1463     source2_dict = disk2_dict.get("source", {})
1464     io1 = disk1_dict.get("driver", {}).get("io", "native")
1465     io2 = disk2_dict.get("driver", {}).get("io", "native")
1466     if source1_dict:
1467         source1_dict.pop("index", None)
1468     if source2_dict:
1469         source2_dict.pop("index", None)
1470     return (
1471 <a name="9"></a>        source1_dict == source2_dict
1472         and target1 is not None
1473         and target2 is not None
1474         and target1<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("bus") == target2.get("bus")
1475         and disk1.get("device", "disk") == disk2.get("device", "disk")
1476         and target1.get("dev") == target2.get("dev")
1477         and io1 == io2
1478     )
1479 def</b></font> _nics_equal(nic1, nic2):
1480     def _filter_nic(nic):
1481         source_node = nic.find("source")
1482         source_attrib = source_node.attrib if source_node is not None else {}
1483         source_type = "network" if "network" in source_attrib else nic.attrib["type"]
1484         source_getters = {
1485             "network": lambda n: n.get("network"),
1486             "bridge": lambda n: n.get("bridge"),
1487             "direct": lambda n: n.get("dev"),
1488             "hostdev": lambda n: _format_pci_address(n.find("address")),
1489         }
1490         return {
1491             "type": source_type,
1492             "source": source_getters[source_type](source_node)
1493             if source_node is not None
1494             else None,
1495             "model": nic.find("model").attrib["type"]
1496             if nic.find("model") is not None
1497             else None,
1498         }
1499     def _get_mac(nic):
1500         return (
1501             nic.find("mac").attrib["address"].lower()
1502             if nic.find("mac") is not None
1503             else None
1504         )
1505     mac1 = _get_mac(nic1)
1506     mac2 = _get_mac(nic2)
1507     macs_equal = not mac1 or not mac2 or mac1 == mac2
1508     return _filter_nic(nic1) == _filter_nic(nic2) and macs_equal
1509 def _graphics_equal(gfx1, gfx2):
1510     def _filter_graphics(gfx):
1511         gfx_copy = copy.deepcopy(gfx)
1512         defaults = [
1513             {"node": ".", "attrib": "port", "values": ["5900", "-1"]},
1514             {"node": ".", "attrib": "address", "values": ["127.0.0.1"]},
1515             {"node": "listen", "attrib": "address", "values": ["127.0.0.1"]},
1516         ]
1517         for default in defaults:
1518             node = gfx_copy.find(default["node"])
1519             attrib = default["attrib"]
1520             if node is not None and (
1521                 attrib in node.attrib and node.attrib[attrib] in default["values"]
1522             ):
1523                 node.attrib.pop(attrib)
1524         return gfx_copy
1525     return xmlutil.to_dict(_filter_graphics(gfx1), True) == xmlutil.to_dict(
1526         _filter_graphics(gfx2), True
1527     )
1528 def _hostdevs_equal(dev1, dev2):
1529     def _filter_hostdevs(dev):
1530         type_ = dev.get("type")
1531         definition = {
1532             "type": type_,
1533         }
1534         if type_ == "pci":
1535             address_node = dev.find("./source/address")
1536             for attr in ["domain", "bus", "slot", "function"]:
1537                 definition[attr] = address_node.get(attr)
1538         elif type_ == "usb":
1539             for attr in ["vendor", "product"]:
1540                 definition[attr] = dev.find("./source/" + attr).get("id")
1541         return definition
1542     return _filter_hostdevs(dev1) == _filter_hostdevs(dev2)
1543 def _diff_lists(old, new, comparator):
1544     def _remove_indent(node):
1545         node_copy = copy.deepcopy(node)
1546         node_copy.text = None
1547         for item in node_copy.iter():
1548             item.tail = None
1549         return node_copy
1550     diff = {"unchanged": [], "new": [], "deleted": [], "sorted": []}
1551     old_devices = copy.deepcopy(old)
1552     for new_item in new:
1553         found = [
1554             item
1555             for item in old_devices
1556             if comparator(_remove_indent(item), _remove_indent(new_item))
1557         ]
1558         if found:
1559             old_devices.remove(found[0])
1560             diff["unchanged"].append(found[0])
1561             diff["sorted"].append(found[0])
1562         else:
1563             diff["new"].append(new_item)
1564             diff["sorted"].append(new_item)
1565     diff["deleted"] = old_devices
1566     return diff
1567 def _get_disk_target(targets, disks_count, prefix):
1568     for i in range(disks_count):
1569         ret = "{}{}".format(prefix, string.ascii_lowercase[i])
1570         if ret not in targets:
1571             return ret
1572     return None
1573 def _diff_disk_lists(old, new):
1574     targets = []
1575     prefixes = ["fd", "hd", "vd", "sd", "xvd", "ubd"]
1576     for disk in new:
1577         target_node = disk.find("target")
1578         target = target_node.get("dev")
1579         prefix = [item for item in prefixes if target.startswith(item)][0]
1580         new_target = _get_disk_target(targets, len(new), prefix)
1581         target_node.set("dev", new_target)
1582         targets.append(new_target)
1583     return _diff_lists(old, new, _disks_equal)
1584 def _diff_interface_lists(old, new):
1585     return _diff_lists(old, new, _nics_equal)
1586 def _diff_graphics_lists(old, new):
1587     return _diff_lists(old, new, _graphics_equal)
1588 def _diff_hostdev_lists(old, new):
1589     return _diff_lists(old, new, _hostdevs_equal)
1590 def _expand_cpuset(cpuset):
1591     if cpuset is None:
1592         return None
1593     if isinstance(cpuset, int):
1594         return str(cpuset)
1595     result = set()
1596     toremove = set()
1597     for part in cpuset.split(","):
1598         m = re.match("([0-9]+)-([0-9]+)", part)
1599         if m:
1600             result |= set(range(int(m.group(1)), int(m.group(2)) + 1))
1601         elif part.startswith("^"):
1602             toremove.add(int(part[1:]))
1603         else:
1604             result.add(int(part))
1605     cpus = list(result - toremove)
1606     cpus.sort()
1607     cpus = [str(cpu) for cpu in cpus]
1608     return ",".join(cpus)
1609 def _normalize_cpusets(desc, data):
1610     xpaths = ["cputune/cachetune", "cputune/cachetune/monitor", "cputune/memorytune"]
1611     for xpath in xpaths:
1612         nodes = desc.findall(xpath)
1613         for node in nodes:
1614             node.set("vcpus", _expand_cpuset(node.get("vcpus")))
1615     if not isinstance(data.get("cpu"), dict):
1616         return
1617     tuning = data["cpu"].get("tuning", {})
1618     for child in ["cachetune", "memorytune"]:
1619         if tuning.get(child):
1620             new_item = dict()
1621             for cpuset, value in tuning[child].items():
1622                 if child == "cachetune" and value.get("monitor"):
1623                     value["monitor"] = {
1624                         _expand_cpuset(monitor_cpus): monitor
1625                         for monitor_cpus, monitor in value["monitor"].items()
1626                     }
1627                 new_item[_expand_cpuset(cpuset)] = value
1628             tuning[child] = new_item
1629 def _serial_or_concole_equal(old, new):
1630     def _filter_serial_or_concole(item):
1631             "port": item<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("source").get("service")
1632             if item.find("source") is not None
1633             else None,
1634             "protocol": item.find("protocol").get("type")
1635             if item.find(</b></font>"protocol") is not None
1636             else None,
1637         }
1638     return _filter_serial_or_concole(old) == _filter_serial_or_concole(new)
1639 def _diff_serial_lists(old, new):
1640     return _diff_lists(old, new, _serial_or_concole_equal)
1641 def _diff_console_lists(old, new):
1642     return _diff_lists(old, new, _serial_or_concole_equal)
1643 <a name="4"></a>
1644 def _format_pci_address(node):
1645     return "{}:{}:{}.{}".format(
1646         node<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("domain").replace("0x", ""),
1647         node.get("bus").replace("0x", ""),
1648         node.get("slot").replace("0x", ""),
1649         node.get("function").replace("0x", ""),
1650     )
1651 def</b></font> _almost_equal(current, new):
1652     if current is None or new is None:
1653         return False
1654     return abs(current - new) / current &lt; 1e-03
1655 def _compute_device_changes(old_xml, new_xml, to_skip):
1656     devices_node = old_xml.find("devices")
1657     changes = {}
1658     for dev_type in to_skip:
1659         changes[dev_type] = {}
1660         if not to_skip[dev_type]:
1661             old = devices_node.findall(dev_type)
1662             new = new_xml.findall("devices/{}".format(dev_type))
1663             changes[dev_type] = globals()["_diff_{}_lists".format(dev_type)](old, new)
1664     return changes
1665 def _get_pci_addresses(node):
1666     return {_format_pci_address(address) for address in node.findall(".//address")}
1667 def _correct_networks(conn, desc):
1668     networks = [ElementTree.fromstring(net.XMLDesc()) for net in conn.listAllNetworks()]
1669     nics = desc.findall("devices/interface")
1670     device_map = {}
1671     for nic in nics:
1672         if nic.get("type") == "hostdev":
1673             addr = _get_pci_addresses(nic.find("source"))
1674             matching_nets = [
1675                 net
1676                 for net in networks
1677                 if net.find("forward").get("mode") == "hostdev"
1678                 and addr &amp; _get_pci_addresses(net)
1679             ]
1680             if matching_nets:
1681                 old_xml = ElementTree.tostring(nic)
1682                 nic.set("type", "network")
1683                 nic.find("source").set("network", matching_nets[0].find("name").text)
1684                 device_map[nic] = old_xml
1685     return device_map
1686 def _update_live(domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test):
1687     status = {}
1688     errors = []
1689     if not domain.isActive():
1690         return status, errors
1691     commands = []
1692     if cpu and (isinstance(cpu, int) or isinstance(cpu, dict) and cpu.get("maximum")):
1693         new_cpu = cpu.get("maximum") if isinstance(cpu, dict) else cpu
1694         if old_cpu != new_cpu and new_cpu is not None:
1695             commands.append(
1696                 {
1697                     "device": "cpu",
1698                     "cmd": "setVcpusFlags",
1699                     "args": [new_cpu, libvirt.VIR_DOMAIN_AFFECT_LIVE],
1700                 }
1701             )
1702     if mem:
1703         if isinstance(mem, dict):
1704             new_mem = (
1705                 int(_handle_unit(mem.get("current")) / 1024)
1706                 if "current" in mem
1707                 else None
1708             )
1709         elif isinstance(mem, int):
1710             new_mem = int(mem * 1024)
1711         if not _almost_equal(old_mem, new_mem) and new_mem is not None:
1712             commands.append(
1713                 {
1714                     "device": "mem",
1715                     "cmd": "setMemoryFlags",
1716                     "args": [new_mem, libvirt.VIR_DOMAIN_AFFECT_LIVE],
1717                 }
1718             )
1719     old_desc = ElementTree.fromstring(domain.XMLDesc(0))
1720     changed_devices = {"interface": _correct_networks(domain.connect(), old_desc)}
1721     changes = _compute_device_changes(old_desc, new_desc, to_skip)
1722     removable_changes = []
1723     new_disks = []
1724     for new_disk in changes["disk"].get("new", []):
1725         device = new_disk.get("device", "disk")
1726         if device not in ["cdrom", "floppy"]:
1727             new_disks.append(new_disk)
1728             continue
1729         target_dev = new_disk.find("target").get("dev")
1730         matching = [
1731             old_disk
1732             for old_disk in changes["disk"].get("deleted", [])
1733             if old_disk.get("device", "disk") == device
1734             and old_disk.find("target").get("dev") == target_dev
1735         ]
1736         if not matching:
1737             new_disks.append(new_disk)
1738         else:
1739             updated_disk = matching[0]
1740             changes["disk"]["deleted"].remove(updated_disk)
1741             removable_changes.append(updated_disk)
1742             source_node = updated_disk.find("source")
1743             new_source_node = new_disk.find("source")
1744             source_file = (
1745                 new_source_node.get("file") if new_source_node is not None else None
1746             )
1747             updated_disk.set("type", "file")
1748             if source_node is not None:
1749                 updated_disk.remove(source_node)
1750             if source_file:
1751                 ElementTree.SubElement(
1752                     updated_disk, "source", attrib={"file": source_file}
1753                 )
1754     changes["disk"]["new"] = new_disks
1755     for dev_type in ["disk", "interface", "hostdev"]:
1756         for added in changes[dev_type].get("new", []):
1757             commands.append(
1758                 {
1759                     "device": dev_type,
1760                     "cmd": "attachDevice",
1761                     "args": [xmlutil.element_to_str(added)],
1762 <a name="12"></a>                }
1763             )
1764         for removed in changes<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[dev_type].get("deleted", []):
1765             removed_def = changed_devices.get(dev_type, {}).get(
1766                 removed, ElementTree.tostring(removed)
1767             )
1768             commands.append(
1769                 {
1770                     "device"</b></font>: dev_type,
1771                     "cmd": "detachDevice",
1772                     "args": [salt.utils.stringutils.to_str(removed_def)],
1773                 }
1774             )
1775     for updated_disk in removable_changes:
1776         commands.append(
1777             {
1778                 "device": "disk",
1779                 "cmd": "updateDeviceFlags",
1780                 "args": [xmlutil.element_to_str(updated_disk)],
1781             }
1782         )
1783     for cmd in commands:
1784         try:
1785             ret = 0 if test else getattr(domain, cmd["cmd"])(*cmd["args"])
1786             device_type = cmd["device"]
1787             if device_type in ["cpu", "mem"]:
1788                 status[device_type] = not ret
1789             else:
1790                 actions = {
1791                     "attachDevice": "attached",
1792                     "detachDevice": "detached",
1793                     "updateDeviceFlags": "updated",
1794                 }
1795                 device_status = status.setdefault(device_type, {})
1796                 cmd_status = device_status.setdefault(actions[cmd["cmd"]], [])
1797                 cmd_status.append(cmd["args"][0])
1798         except libvirt.libvirtError as err:
1799             errors.append(str(err))
1800     return status, errors
1801 def update(
1802     name,
1803     cpu=0,
1804     mem=0,
1805     disk_profile=None,
1806     disks=None,
1807     nic_profile=None,
1808     interfaces=None,
1809     graphics=None,
1810     live=True,
1811     boot=None,
1812     numatune=None,
1813     test=False,
1814     boot_dev=None,
1815     hypervisor_features=None,
1816     clock=None,
1817     serials=None,
1818     consoles=None,
1819     stop_on_reboot=False,
1820     host_devices=None,
1821     **kwargs
1822 ):
1823     status = {
1824         "definition": False,
1825         "disk": {"attached": [], "detached": [], "updated": []},
1826         "interface": {"attached": [], "detached": []},
1827     }
1828     conn = __get_conn(**kwargs)
1829     domain = _get_domain(conn, name)
1830     desc = ElementTree.fromstring(domain.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
1831     need_update = False
1832     hypervisor = desc.get("type")
1833     all_disks = _disk_profile(conn, disk_profile, hypervisor, disks, name)
1834     if boot is not None:
1835         boot = _handle_remote_boot_params(boot)
1836         if boot.get("efi", None) is not None:
1837             need_update = _handle_efi_param(boot, desc)
1838     new_desc = ElementTree.fromstring(
1839         _gen_xml(
1840             conn,
1841             name,
1842             cpu,
1843             mem or 0,
1844             all_disks,
1845             _get_merged_nics(hypervisor, nic_profile, interfaces),
1846             hypervisor,
1847             domain.OSType(),
1848             desc.find(".//os/type").get("arch"),
1849             graphics,
1850             boot,
1851             boot_dev,
1852             numatune,
1853             serials=serials,
1854             consoles=consoles,
1855             stop_on_reboot=stop_on_reboot,
1856             host_devices=host_devices,
1857             **kwargs
1858         )
1859     )
1860     if clock:
1861         offset = "utc" if clock.get("utc", True) else "localtime"
1862         if "timezone" in clock:
1863             offset = "timezone"
1864         clock["offset"] = offset
1865     def _set_loader(node, value):
1866         salt.utils.xmlutil.set_node_text(node, value)
1867         if value is not None:
1868             node.set("readonly", "yes")
1869             node.set("type", "pflash")
1870     def _set_nvram(node, value):
1871         node.set("template", value)
1872     def _set_with_byte_unit(attr_name=None):
1873         def _setter(node, value):
1874             if attr_name:
1875                 node.set(attr_name, str(value))
1876             else:
1877                 node.text = str(value)
1878             node.set("unit", "bytes")
1879         return _setter
1880     def _get_with_unit(node):
1881         unit = node.get("unit", "KiB")
1882         unit = unit if unit != "bytes" else "b"
1883         value = node.get("memory") or node.get("size") or node.text
1884         return _handle_unit("{}{}".format(value, unit)) if value else None
1885     def _set_vcpu(node, value):
1886         node.text = str(value)
1887         node.set("current", str(value))
1888     old_mem = int(_get_with_unit(desc.find("memory")) / 1024)
1889     old_cpu = int(desc.find("./vcpu").text)
1890     def _yesno_attribute(path, xpath, attr_name, ignored=None):
1891         return xmlutil.attribute(
1892             path, xpath, attr_name, ignored, lambda v: "yes" if v else "no"
1893         )
1894     def _memory_parameter(path, xpath, attr_name=None, ignored=None):
1895         entry = {
1896             "path": path,
1897             "xpath": xpath,
1898             "convert": _handle_unit,
1899             "get": _get_with_unit,
1900             "set": _set_with_byte_unit(attr_name),
1901             "equals": _almost_equal,
1902         }
1903         if attr_name:
1904             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
1905         return entry
1906     def _cpuset_parameter(path, xpath, attr_name=None, ignored=None):
1907         def _set_cpuset(node, value):
1908             if attr_name:
1909                 node.set(attr_name, value)
1910             else:
1911                 node.text = value
1912         entry = {
1913             "path": path,
1914             "xpath": xpath,
1915             "convert": _expand_cpuset,
1916             "get": lambda n: _expand_cpuset(n.get(attr_name) if attr_name else n.text),
1917             "set": _set_cpuset,
1918         }
1919         if attr_name:
1920             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
1921         return entry
1922     data = {k: v for k, v in locals().items() if bool(v)}
1923     data["stop_on_reboot"] = stop_on_reboot
1924     if boot_dev:
1925         data["boot_dev"] = boot_dev.split()
1926     timer_names = [
1927         "platform",
1928         "hpet",
1929         "kvmclock",
1930         "pit",
1931         "rtc",
1932         "tsc",
1933         "hypervclock",
1934         "armvtimer",
1935     ]
1936     if data.get("clock", {}).get("timers"):
1937         attributes = [
1938             "track",
1939             "tickpolicy",
1940             "frequency",
1941             "mode",
1942             "present",
1943             "slew",
1944             "threshold",
1945             "limit",
1946         ]
1947         for timer in data["clock"]["timers"].values():
1948             for attribute in attributes:
1949                 if attribute not in timer:
1950                     timer[attribute] = None
1951         for timer_name in timer_names:
1952             if timer_name not in data["clock"]["timers"]:
1953                 data["clock"]["timers"][timer_name] = None
1954     _normalize_cpusets(desc, data)
1955     params_mapping = [
1956         {
1957             "path": "stop_on_reboot",
1958             "xpath": "on_reboot",
1959             "convert": lambda v: "destroy" if v else "restart",
1960         },
1961         {"path": "boot:kernel", "xpath": "os/kernel"},
1962         {"path": "boot:initrd", "xpath": "os/initrd"},
1963         {"path": "boot:cmdline", "xpath": "os/cmdline"},
1964         {"path": "boot:loader", "xpath": "os/loader", "set": _set_loader},
1965         {"path": "boot:nvram", "xpath": "os/nvram", "set": _set_nvram},
1966         _memory_parameter("mem", "memory"),
1967         _memory_parameter("mem", "currentMemory"),
1968         _memory_parameter("mem:max", "maxMemory"),
1969         _memory_parameter("mem:boot", "memory"),
1970         _memory_parameter("mem:current", "currentMemory"),
1971         xmlutil.attribute("mem:slots", "maxMemory", "slots", ["unit"]),
1972         _memory_parameter("mem:hard_limit", "memtune/hard_limit"),
1973         _memory_parameter("mem:soft_limit", "memtune/soft_limit"),
1974         _memory_parameter("mem:swap_hard_limit", "memtune/swap_hard_limit"),
1975         _memory_parameter("mem:min_guarantee", "memtune/min_guarantee"),
1976         xmlutil.attribute("boot_dev:{dev}", "os/boot[$dev]", "dev"),
1977         _memory_parameter(
1978             "mem:hugepages:{id}:size",
1979             "memoryBacking/hugepages/page[$id]",
1980             "size",
1981             ["unit", "nodeset"],
1982         ),
1983         _cpuset_parameter(
1984             "mem:hugepages:{id}:nodeset", "memoryBacking/hugepages/page[$id]", "nodeset"
1985         ),
1986         {
1987             "path": "mem:nosharepages",
1988             "xpath": "memoryBacking/nosharepages",
1989             "get": lambda n: n is not None,
1990             "set": lambda n, v: None,
1991         },
1992         {
1993             "path": "mem:locked",
1994             "xpath": "memoryBacking/locked",
1995             "get": lambda n: n is not None,
1996             "set": lambda n, v: None,
1997         },
1998         xmlutil.attribute("mem:source", "memoryBacking/source", "type"),
1999         xmlutil.attribute("mem:access", "memoryBacking/access", "mode"),
2000         xmlutil.attribute("mem:allocation", "memoryBacking/allocation", "mode"),
2001         {"path": "mem:discard", "xpath": "memoryBacking/discard"},
2002         {
2003             "path": "cpu",
2004             "xpath": "vcpu",
2005             "get": lambda n: int(n.text),
2006             "set": _set_vcpu,
2007         },
2008         {"path": "cpu:maximum", "xpath": "vcpu", "get": lambda n: int(n.text)},
2009 <a name="1"></a>        xmlutil.attribute("cpu:placement", "vcpu", "placement"),
2010         _cpuset_parameter("cpu:cpuset", "vcpu", "cpuset"),
2011         xmlutil.attribute("cpu:current", "vcpu", "current"),
2012         xmlutil<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.attribute("cpu:match", "cpu", "match"),
2013         xmlutil.attribute("cpu:mode", "cpu", "mode"),
2014         xmlutil.attribute("cpu:check", "cpu", "check"),
2015         {"path": "cpu:model:name", "xpath": "cpu/model"},
2016         xmlutil.attribute("cpu:model:fallback", "cpu/model", "fallback"),
2017         xmlutil.attribute("cpu:model:vendor_id", "cpu/model", "vendor_id"),
2018         {"path": "cpu:vendor", "xpath": "cpu/vendor"},
2019         xmlutil.attribute("cpu:topology:sockets", "cpu/topology", "sockets"),
2020         xmlutil.attribute("cpu:topology:cores", "cpu/topology", "cores"),
2021         xmlutil.attribute("cpu:topology:threads", "cpu/topology", "threads"),
2022         xmlutil.</b></font>attribute("cpu:cache:level", "cpu/cache", "level"),
2023         xmlutil.attribute("cpu:cache:mode", "cpu/cache", "mode"),
2024         xmlutil.attribute(
2025             "cpu:features:{id}", "cpu/feature[@name='$id']", "policy", ["name"]
2026         ),
2027         _yesno_attribute(
2028             "cpu:vcpus:{id}:enabled", "vcpus/vcpu[@id='$id']", "enabled", ["id"]
2029         ),
2030         _yesno_attribute(
2031             "cpu:vcpus:{id}:hotpluggable",
2032             "vcpus/vcpu[@id='$id']",
2033             "hotpluggable",
2034             ["id"],
2035         ),
2036         xmlutil.int_attribute(
2037             "cpu:vcpus:{id}:order", "vcpus/vcpu[@id='$id']", "order", ["id"]
2038         ),
2039         _cpuset_parameter(
2040             "cpu:numa:{id}:cpus", "cpu/numa/cell[@id='$id']", "cpus", ["id"]
2041         ),
2042         _memory_parameter(
2043             "cpu:numa:{id}:memory", "cpu/numa/cell[@id='$id']", "memory", ["id"]
2044         ),
2045         _yesno_attribute(
2046             "cpu:numa:{id}:discard", "cpu/numa/cell[@id='$id']", "discard", ["id"]
2047         ),
2048         xmlutil.attribute(
2049             "cpu:numa:{id}:memAccess", "cpu/numa/cell[@id='$id']", "memAccess", ["id"]
2050         ),
2051         xmlutil.attribute(
2052             "cpu:numa:{id}:distances:{sid}",
2053             "cpu/numa/cell[@id='$id']/distances/sibling[@id='$sid']",
2054             "value",
2055             ["id"],
2056         ),
2057         {"path": "cpu:iothreads", "xpath": "iothreads"},
2058         {"path": "cpu:tuning:shares", "xpath": "cputune/shares"},
2059         {"path": "cpu:tuning:period", "xpath": "cputune/period"},
2060         {"path": "cpu:tuning:quota", "xpath": "cputune/quota"},
2061         {"path": "cpu:tuning:global_period", "xpath": "cputune/global_period"},
2062         {"path": "cpu:tuning:global_quota", "xpath": "cputune/global_quota"},
2063         {"path": "cpu:tuning:emulator_period", "xpath": "cputune/emulator_period"},
2064         {"path": "cpu:tuning:emulator_quota", "xpath": "cputune/emulator_quota"},
2065         {"path": "cpu:tuning:iothread_period", "xpath": "cputune/iothread_period"},
2066         {"path": "cpu:tuning:iothread_quota", "xpath": "cputune/iothread_quota"},
2067         _cpuset_parameter(
2068             "cpu:tuning:vcpupin:{id}",
2069             "cputune/vcpupin[@vcpu='$id']",
2070             "cpuset",
2071             ["vcpu"],
2072         ),
2073         _cpuset_parameter("cpu:tuning:emulatorpin", "cputune/emulatorpin", "cpuset"),
2074         _cpuset_parameter(
2075             "cpu:tuning:iothreadpin:{id}",
2076             "cputune/iothreadpin[@iothread='$id']",
2077             "cpuset",
2078             ["iothread"],
2079         ),
2080         xmlutil.attribute(
2081             "cpu:tuning:vcpusched:{id}:scheduler",
2082             "cputune/vcpusched[$id]",
2083             "scheduler",
2084             ["priority", "vcpus"],
2085         ),
2086         xmlutil.attribute(
2087             "cpu:tuning:vcpusched:{id}:priority", "cputune/vcpusched[$id]", "priority"
2088         ),
2089         _cpuset_parameter(
2090             "cpu:tuning:vcpusched:{id}:vcpus", "cputune/vcpusched[$id]", "vcpus"
2091         ),
2092         xmlutil.attribute(
2093             "cpu:tuning:iothreadsched:{id}:scheduler",
2094             "cputune/iothreadsched[$id]",
2095             "scheduler",
2096             ["priority", "iothreads"],
2097         ),
2098         xmlutil.attribute(
2099             "cpu:tuning:iothreadsched:{id}:priority",
2100             "cputune/iothreadsched[$id]",
2101             "priority",
2102         ),
2103         _cpuset_parameter(
2104             "cpu:tuning:iothreadsched:{id}:iothreads",
2105             "cputune/iothreadsched[$id]",
2106             "iothreads",
2107         ),
2108         xmlutil.attribute(
2109             "cpu:tuning:emulatorsched:scheduler",
2110             "cputune/emulatorsched",
2111             "scheduler",
2112             ["priority"],
2113         ),
2114         xmlutil.attribute(
2115             "cpu:tuning:emulatorsched:priority", "cputune/emulatorsched", "priority"
2116         ),
2117         xmlutil.attribute(
2118             "cpu:tuning:cachetune:{id}:monitor:{sid}",
2119             "cputune/cachetune[@vcpus='$id']/monitor[@vcpus='$sid']",
2120             "level",
2121             ["vcpus"],
2122         ),
2123         xmlutil.attribute(
2124             "cpu:tuning:memorytune:{id}:{sid}",
2125             "cputune/memorytune[@vcpus='$id']/node[@id='$sid']",
2126             "bandwidth",
2127             ["id", "vcpus"],
2128         ),
2129         xmlutil.attribute("clock:offset", "clock", "offset"),
2130         xmlutil.attribute("clock:adjustment", "clock", "adjustment", convert=str),
2131         xmlutil.attribute("clock:timezone", "clock", "timezone"),
2132     ]
2133 <a name="2"></a>
2134     for timer in timer_names:
2135         params_mapping += [
2136             xmlutil<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.attribute(
2137                 "clock:timers:{}:track".format(timer),
2138                 "clock/timer[@name='{}']".format(timer),
2139                 "track",
2140                 ["name"],
2141             ),
2142             xmlutil.attribute(
2143                 "clock:timers:{}:tickpolicy".format(timer),
2144                 "clock/timer[@name='{}']".format(timer),
2145                 "tickpolicy",
2146                 ["name"],
2147             ),
2148             xmlutil.int_attribute(
2149                 "clock:timers:{}:frequency".format(timer),
2150                 "clock/timer[@name='{}']".format(timer),
2151                 "frequency",
2152                 ["name"],
2153             ),
2154             xmlutil.</b></font>attribute(
2155                 "clock:timers:{}:mode".format(timer),
2156                 "clock/timer[@name='{}']".format(timer),
2157                 "mode",
2158                 ["name"],
2159             ),
2160             _yesno_attribute(
2161                 "clock:timers:{}:present".format(timer),
2162                 "clock/timer[@name='{}']".format(timer),
2163                 "present",
2164                 ["name"],
2165             ),
2166         ]
2167         for attr in ["slew", "threshold", "limit"]:
2168             params_mapping.append(
2169                 xmlutil.int_attribute(
2170                     "clock:timers:{}:{}".format(timer, attr),
2171                     "clock/timer[@name='{}']/catchup".format(timer),
2172                     attr,
2173                 )
2174             )
2175     for attr in ["level", "type", "size"]:
2176         params_mapping.append(
2177             xmlutil.attribute(
2178                 "cpu:tuning:cachetune:{id}:{sid}:" + attr,
2179                 "cputune/cachetune[@vcpus='$id']/cache[@id='$sid']",
2180                 attr,
2181                 ["id", "unit", "vcpus"],
2182             )
2183         )
2184     if hypervisor in ["qemu", "kvm"]:
2185         params_mapping += [
2186             xmlutil.attribute("numatune:memory:mode", "numatune/memory", "mode"),
2187             _cpuset_parameter("numatune:memory:nodeset", "numatune/memory", "nodeset"),
2188             xmlutil.attribute(
2189                 "numatune:memnodes:{id}:mode",
2190                 "numatune/memnode[@cellid='$id']",
2191                 "mode",
2192                 ["cellid"],
2193             ),
2194             _cpuset_parameter(
2195                 "numatune:memnodes:{id}:nodeset",
2196                 "numatune/memnode[@cellid='$id']",
2197                 "nodeset",
2198                 ["cellid"],
2199             ),
2200             xmlutil.attribute(
2201                 "hypervisor_features:kvm-hint-dedicated",
2202                 "features/kvm/hint-dedicated",
2203                 "state",
2204                 convert=lambda v: "on" if v else "off",
2205             ),
2206         ]
2207     need_update = (
2208         salt.utils.xmlutil.change_xml(desc, data, params_mapping) or need_update
2209     )
2210     devices_node = desc.find("devices")
2211     func_locals = locals()
2212     def _skip_update(names):
2213         return all(func_locals.get(n) is None for n in names)
2214     to_skip = {
2215         "disk": _skip_update(["disks", "disk_profile"]),
2216         "interface": _skip_update(["interfaces", "nic_profile"]),
2217         "graphics": _skip_update(["graphics"]),
2218         "serial": _skip_update(["serials"]),
2219         "console": _skip_update(["consoles"]),
2220         "hostdev": _skip_update(["host_devices"]),
2221     }
2222     changes = _compute_device_changes(desc, new_desc, to_skip)
2223     for dev_type in changes:
2224         if not to_skip[dev_type]:
2225             old = devices_node.findall(dev_type)
2226             if changes[dev_type].get("deleted") or changes[dev_type].get("new"):
2227                 for item in old:
2228                     devices_node.remove(item)
2229                 devices_node.extend(changes[dev_type]["sorted"])
2230                 need_update = True
2231     if need_update:
2232         try:
2233             if changes["disk"]:
2234                 for idx, item in enumerate(changes["disk"]["sorted"]):
2235                     source_file = all_disks[idx].get("source_file")
2236                     if all_disks[idx].get("device", "disk") == "cdrom":
2237                         continue
2238                     if (
2239                         item in changes["disk"]["new"]
2240                         and source_file
2241                         and not os.path.exists(source_file)
2242                     ):
2243                         _qemu_image_create(all_disks[idx])
2244                     elif item in changes["disk"]["new"] and not source_file:
2245                         _disk_volume_create(conn, all_disks[idx])
2246             if not test:
2247                 xml_desc = xmlutil.element_to_str(desc)
2248                 log.debug("Update virtual machine definition: %s", xml_desc)
2249                 conn.defineXML(xml_desc)
2250             status["definition"] = True
2251         except libvirt.libvirtError as err:
2252             conn.close()
2253             raise err
2254     if live:
2255         live_status, errors = _update_live(
2256             domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test
2257         )
2258         status.update(live_status)
2259         if errors:
2260             status_errors = status.setdefault("errors", [])
2261             status_errors += errors
2262     conn.close()
2263     return status
2264 def list_domains(**kwargs):
2265     vms = []
2266     conn = __get_conn(**kwargs)
2267     for dom in _get_domain(conn, iterable=True):
2268         vms.append(dom.name())
2269     conn.close()
2270     return vms
2271 def list_active_vms(**kwargs):
2272     vms = []
2273     conn = __get_conn(**kwargs)
2274     for dom in _get_domain(conn, iterable=True, inactive=False):
2275         vms.append(dom.name())
2276     conn.close()
2277     return vms
2278 def list_inactive_vms(**kwargs):
2279     vms = []
2280     conn = __get_conn(**kwargs)
2281     for dom in _get_domain(conn, iterable=True, active=False):
2282         vms.append(dom.name())
2283     conn.close()
2284     return vms
2285 def vm_info(vm_=None, **kwargs):
2286     def _info(conn, dom):
2287         raw = dom.info()
2288         return {
2289             "cpu": raw[3],
2290             "cputime": int(raw[4]),
2291             "disks": _get_disks(conn, dom),
2292             "graphics": _get_graphics(dom),
2293             "nics": _get_nics(dom),
2294             "uuid": _get_uuid(dom),
2295             "loader": _get_loader(dom),
2296             "on_crash": _get_on_crash(dom),
2297             "on_reboot": _get_on_reboot(dom),
2298             "on_poweroff": _get_on_poweroff(dom),
2299             "maxMem": int(raw[1]),
2300             "mem": int(raw[2]),
2301             "state": VIRT_STATE_NAME_MAP.get(raw[0], "unknown"),
2302         }
2303     info = {}
2304     conn = __get_conn(**kwargs)
2305     if vm_:
2306         info[vm_] = _info(conn, _get_domain(conn, vm_))
2307     else:
2308         for domain in _get_domain(conn, iterable=True):
2309             info[domain.name()] = _info(conn, domain)
2310     conn.close()
2311     return info
2312 def vm_state(vm_=None, **kwargs):
2313     def _info(dom):
2314         state = ""
2315         raw = dom.info()
2316         state = VIRT_STATE_NAME_MAP.get(raw[0], "unknown")
2317         return state
2318     info = {}
2319     conn = __get_conn(**kwargs)
2320     if vm_:
2321         info[vm_] = _info(_get_domain(conn, vm_))
2322     else:
2323         for domain in _get_domain(conn, iterable=True):
2324             info[domain.name()] = _info(domain)
2325     conn.close()
2326     return info
2327 def _node_info(conn):
2328     raw = conn.getInfo()
2329     info = {
2330         "cpucores": raw[6],
2331         "cpumhz": raw[3],
2332         "cpumodel": str(raw[0]),
2333         "cpus": raw[2],
2334         "cputhreads": raw[7],
2335         "numanodes": raw[4],
2336         "phymemory": raw[1],
2337         "sockets": raw[5],
2338     }
2339     return info
2340 def node_info(**kwargs):
2341     conn = __get_conn(**kwargs)
2342     info = _node_info(conn)
2343     conn.close()
2344     return info
2345 def _node_devices(conn):
2346     devices = conn.listAllDevices()
2347     devices_infos = []
2348     for dev in devices:
2349         root = ElementTree.fromstring(dev.XMLDesc())
2350         if not set(dev.listCaps()) &amp; {"pci", "usb_device", "net"}:
2351             continue
2352         infos = {
2353             "caps": " ".join(dev.listCaps()),
2354         }
2355         if "net" in dev.listCaps():
2356             parent = root.find(".//parent").text
2357             if parent == "computer":
2358                 continue
2359             infos.update(
2360                 {
2361                     "name": root.find(".//interface").text,
2362                     "address": root.find(".//address").text,
2363                     "device name": parent,
2364                     "state": root.find(".//link").get("state"),
2365                 }
2366             )
2367             devices_infos.append(infos)
2368             continue
2369         vendor_node = root.find(".//vendor")
2370         vendor_id = vendor_node.get("id").lower()
2371         product_node = root.find(".//product")
2372         product_id = product_node.get("id").lower()
2373         infos.update(
2374             {"name": dev.name(), "vendor_id": vendor_id, "product_id": product_id}
2375         )
2376         if vendor_node.text:
2377             infos["vendor"] = vendor_node.text
2378         if product_node.text:
2379             infos["product"] = product_node.text
2380 <a name="7"></a>
2381         if "pci" in dev.listCaps():
2382             infos["address"] = "{:04x}:{:02x}:{:02x}.{}".format(
2383                 int<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(root.find(".//domain").text),
2384                 int(root.find(".//bus").text),
2385                 int(root.find(".//slot").text),
2386                 root.find(".//function").</b></font>text,
2387             )
2388             class_node = root.find(".//class")
2389             if class_node is not None:
2390                 infos["PCI class"] = class_node.text
2391             vf_addresses = [
2392                 _format_pci_address(vf)
2393                 for vf in root.findall(
2394                     "./capability[@type='pci']/capability[@type='virt_functions']/address"
2395                 )
2396             ]
2397             if vf_addresses:
2398                 infos["virtual functions"] = vf_addresses
2399             pf = root.find(
2400                 "./capability[@type='pci']/capability[@type='phys_function']/address"
2401             )
2402             if pf is not None:
2403                 infos["physical function"] = _format_pci_address(pf)
2404         elif "usb_device" in dev.listCaps():
2405             infos["address"] = "{:03}:{:03}".format(
2406                 int(root.find(".//bus").text), int(root.find(".//device").text)
2407             )
2408         linux_usb_host = vendor_id == "0x1d6b" and product_id in [
2409             "0x0001",
2410             "0x0002",
2411             "0x0003",
2412         ]
2413         if (
2414             root.find(".//capability[@type='pci-bridge']") is None
2415             and not linux_usb_host
2416         ):
2417             devices_infos.append(infos)
2418     return devices_infos
2419 def node_devices(**kwargs):
2420     conn = __get_conn(**kwargs)
2421     devs = _node_devices(conn)
2422     conn.close()
2423     return devs
2424 def get_nics(vm_, **kwargs):
2425     conn = __get_conn(**kwargs)
2426     nics = _get_nics(_get_domain(conn, vm_))
2427     conn.close()
2428     return nics
2429 def get_macs(vm_, **kwargs):
2430     doc = ElementTree.fromstring(get_xml(vm_, **kwargs))
2431     return [node.get("address") for node in doc.findall("devices/interface/mac")]
2432 def get_graphics(vm_, **kwargs):
2433     conn = __get_conn(**kwargs)
2434     graphics = _get_graphics(_get_domain(conn, vm_))
2435     conn.close()
2436     return graphics
2437 def get_loader(vm_, **kwargs):
2438     conn = __get_conn(**kwargs)
2439     try:
2440         loader = _get_loader(_get_domain(conn, vm_))
2441         return loader
2442     finally:
2443         conn.close()
2444 def get_disks(vm_, **kwargs):
2445     conn = __get_conn(**kwargs)
2446     disks = _get_disks(conn, _get_domain(conn, vm_))
2447     conn.close()
2448     return disks
2449 def setmem(vm_, memory, config=False, **kwargs):
2450     conn = __get_conn(**kwargs)
2451     dom = _get_domain(conn, vm_)
2452     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
2453         return False
2454     flags = libvirt.VIR_DOMAIN_MEM_MAXIMUM
2455     if config:
2456         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
2457     ret1 = dom.setMemoryFlags(memory * 1024, flags)
2458     ret2 = dom.setMemoryFlags(memory * 1024, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
2459     conn.close()
2460     return ret1 == ret2 == 0
2461 def setvcpus(vm_, vcpus, config=False, **kwargs):
2462     conn = __get_conn(**kwargs)
2463     dom = _get_domain(conn, vm_)
2464     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
2465         return False
2466     flags = libvirt.VIR_DOMAIN_VCPU_MAXIMUM
2467     if config:
2468         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
2469     ret1 = dom.setVcpusFlags(vcpus, flags)
2470     ret2 = dom.setVcpusFlags(vcpus, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
2471     conn.close()
2472     return ret1 == ret2 == 0
2473 def _freemem(conn):
2474     mem = conn.getInfo()[1]
2475     mem -= 256
2476     for dom in _get_domain(conn, iterable=True):
2477         if dom.ID() &gt; 0:
2478             mem -= dom.info()[2] / 1024
2479     return mem
2480 def freemem(**kwargs):
2481     conn = __get_conn(**kwargs)
2482     mem = _freemem(conn)
2483     conn.close()
2484     return mem
2485 def _freecpu(conn):
2486     cpus = conn.getInfo()[2]
2487     for dom in _get_domain(conn, iterable=True):
2488         if dom.ID() &gt; 0:
2489             cpus -= dom.info()[3]
2490     return cpus
2491 def freecpu(**kwargs):
2492     conn = __get_conn(**kwargs)
2493     cpus = _freecpu(conn)
2494     conn.close()
2495     return cpus
2496 def full_info(**kwargs):
2497     conn = __get_conn(**kwargs)
2498     info = {
2499         "freecpu": _freecpu(conn),
2500         "freemem": _freemem(conn),
2501         "node_info": _node_info(conn),
2502         "vm_info": vm_info(),
2503     }
2504     conn.close()
2505     return info
2506 def get_xml(vm_, **kwargs):
2507     conn = __get_conn(**kwargs)
2508     xml_desc = (
2509         vm_.XMLDesc(0)
2510         if isinstance(vm_, libvirt.virDomain)
2511         else _get_domain(conn, vm_).XMLDesc(0)
2512     )
2513     conn.close()
2514     return xml_desc
2515 def get_profiles(hypervisor=None, **kwargs):
2516     conn = __get_conn(**kwargs)
2517     caps = _capabilities(conn)
2518     hypervisors = sorted(
2519         {
2520             x
2521             for y in [guest["arch"]["domains"].keys() for guest in caps["guests"]]
2522             for x in y
2523         }
2524     )
2525     if len(hypervisors) == 0:
2526         raise SaltInvocationError("No supported hypervisors were found")
2527     if not hypervisor:
2528         hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
2529     ret = {
2530         "disk": {"default": _disk_profile(conn, "default", hypervisor, [], None)},
2531         "nic": {"default": _nic_profile("default", hypervisor)},
2532     }
2533     virtconf = __salt__["config.get"]("virt", {})
2534     for profile in virtconf.get("disk", []):
2535         ret["disk"][profile] = _disk_profile(conn, profile, hypervisor, [], None)
2536     for profile in virtconf.get("nic", []):
2537         ret["nic"][profile] = _nic_profile(profile, hypervisor)
2538     return ret
2539 def shutdown(vm_, **kwargs):
2540     conn = __get_conn(**kwargs)
2541     dom = _get_domain(conn, vm_)
2542     ret = dom.shutdown() == 0
2543     conn.close()
2544     return ret
2545 def pause(vm_, **kwargs):
2546     conn = __get_conn(**kwargs)
2547     dom = _get_domain(conn, vm_)
2548     ret = dom.suspend() == 0
2549     conn.close()
2550     return ret
2551 def resume(vm_, **kwargs):
2552     conn = __get_conn(**kwargs)
2553     dom = _get_domain(conn, vm_)
2554     ret = dom.resume() == 0
2555     conn.close()
2556     return ret
2557 def start(name, **kwargs):
2558     conn = __get_conn(**kwargs)
2559     ret = _get_domain(conn, name).create() == 0
2560     conn.close()
2561     return ret
2562 def stop(name, **kwargs):
2563     conn = __get_conn(**kwargs)
2564     ret = _get_domain(conn, name).destroy() == 0
2565     conn.close()
2566     return ret
2567 def reboot(name, **kwargs):
2568     conn = __get_conn(**kwargs)
2569     ret = _get_domain(conn, name).reboot(libvirt.VIR_DOMAIN_REBOOT_DEFAULT) == 0
2570     conn.close()
2571     return ret
2572 def reset(vm_, **kwargs):
2573     conn = __get_conn(**kwargs)
2574     dom = _get_domain(conn, vm_)
2575     ret = dom.reset(0) == 0
2576     conn.close()
2577     return ret
2578 def ctrl_alt_del(vm_, **kwargs):
2579     conn = __get_conn(**kwargs)
2580     dom = _get_domain(conn, vm_)
2581     ret = dom.sendKey(0, 0, [29, 56, 111], 3, 0) == 0
2582     conn.close()
2583     return ret
2584 def create_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
2585     conn = __get_conn(**kwargs)
2586     ret = conn.createXML(xml, 0) is not None
2587     conn.close()
2588     return ret
2589 def create_xml_path(path, **kwargs):
2590     try:
2591         with salt.utils.files.fopen(path, "r") as fp_:
2592             return create_xml_str(
2593                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
2594             )
2595     except OSError:
2596         return False
2597 def define_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
2598     conn = __get_conn(**kwargs)
2599     ret = conn.defineXML(xml) is not None
2600     conn.close()
2601     return ret
2602 def define_xml_path(path, **kwargs):
2603     try:
2604         with salt.utils.files.fopen(path, "r") as fp_:
2605             return define_xml_str(
2606                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
2607             )
2608     except OSError:
2609         return False
2610 def _define_vol_xml_str(conn, xml, pool=None):  # pylint: disable=redefined-outer-name
2611     default_pool = "default" if conn.getType() != "ESX" else "0"
2612     poolname = (
2613         pool if pool else __salt__["config.get"]("virt:storagepool", default_pool)
2614     )
2615     pool = conn.storagePoolLookupByName(str(poolname))
2616     ret = pool.createXML(xml, 0) is not None
2617     return ret
2618 def define_vol_xml_str(
2619     xml, pool=None, **kwargs
2620 ):  # pylint: disable=redefined-outer-name
2621     conn = __get_conn(**kwargs)
2622     ret = False
2623     try:
2624         ret = _define_vol_xml_str(conn, xml, pool=pool)
2625     except libvirtError as err:
2626         raise CommandExecutionError(err.get_error_message())
2627     finally:
2628         conn.close()
2629     return ret
2630 def define_vol_xml_path(path, pool=None, **kwargs):
2631     try:
2632         with salt.utils.files.fopen(path, "r") as fp_:
2633             return define_vol_xml_str(
2634                 salt.utils.stringutils.to_unicode(fp_.read()), pool=pool, **kwargs
2635             )
2636     except OSError:
2637         return False
2638 def migrate(vm_, target, **kwargs):
2639     conn = __get_conn()
2640     dom = _get_domain(conn, vm_)
2641     if not urllib.parse.urlparse(target).scheme:
2642         proto = "qemu"
2643         dst_uri = "{}://{}/system".format(proto, target)
2644     else:
2645         dst_uri = target
2646     ret = _migrate(dom, dst_uri, **kwargs)
2647     conn.close()
2648     return ret
2649 def migrate_start_postcopy(vm_):
2650     conn = __get_conn()
2651     dom = _get_domain(conn, vm_)
2652     try:
2653         dom.migrateStartPostCopy()
2654     except libvirt.libvirtError as err:
2655         conn.close()
2656         raise CommandExecutionError(err.get_error_message())
2657     conn.close()
2658 def seed_non_shared_migrate(disks, force=False):
2659     for _, data in disks.items():
2660         fn_ = data["file"]
2661         form = data["file format"]
2662         size = data["virtual size"].split()[1][1:]
2663         if os.path.isfile(fn_) and not force:
2664             pre = salt.utils.yaml.safe_load(
2665                 subprocess.Popen(
2666                     ["qemu-img", "info", "arch"], stdout=subprocess.PIPE
2667                 ).communicate()[0]
2668             )
2669             if (
2670                 pre["file format"] != data["file format"]
2671                 and pre["virtual size"] != data["virtual size"]
2672             ):
2673                 return False
2674         if not os.path.isdir(os.path.dirname(fn_)):
2675             os.makedirs(os.path.dirname(fn_))
2676         if os.path.isfile(fn_):
2677             os.remove(fn_)
2678         subprocess.call(["qemu-img", "create", "-f", form, fn_, size])
2679         creds = _libvirt_creds()
2680         subprocess.call(["chown", "{user}:{group}".format(**creds), fn_])
2681     return True
2682 def set_autostart(vm_, state="on", **kwargs):
2683     conn = __get_conn(**kwargs)
2684     dom = _get_domain(conn, vm_)
2685     ret = False
2686     if state == "on":
2687         ret = dom.setAutostart(1) == 0
2688     elif state == "off":
2689         ret = dom.setAutostart(0) == 0
2690     conn.close()
2691     return ret
2692 def undefine(vm_, **kwargs):
2693     conn = __get_conn(**kwargs)
2694     dom = _get_domain(conn, vm_)
2695     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
2696         ret = dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM) == 0
2697     else:
2698         ret = dom.undefine() == 0
2699     conn.close()
2700     return ret
2701 def purge(vm_, dirs=False, removables=False, **kwargs):
2702     conn = __get_conn(**kwargs)
2703     dom = _get_domain(conn, vm_)
2704     disks = _get_disks(conn, dom)
2705     if (
2706         VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown"
2707         and dom.destroy() != 0
2708     ):
2709         return False
2710     directories = set()
2711     for disk in disks:
2712         if not removables and disks[disk]["type"] in ["cdrom", "floppy"]:
2713             continue
2714         if disks[disk].get("zfs", False):
2715             time.sleep(3)
2716             fs_name = disks[disk]["file"][len("/dev/zvol/") :]
2717             log.info("Destroying VM ZFS volume %s", fs_name)
2718             __salt__["zfs.destroy"](name=fs_name, force=True)
2719         elif os.path.exists(disks[disk]["file"]):
2720             os.remove(disks[disk]["file"])
2721             directories.add(os.path.dirname(disks[disk]["file"]))
2722         else:
2723             matcher = re.match("^(?P&lt;pool&gt;[^/]+)/(?P&lt;volume&gt;.*)$", disks[disk]["file"])
2724             if matcher:
2725                 pool_name = matcher.group("pool")
2726                 pool = None
2727                 if pool_name in conn.listStoragePools():
2728                     pool = conn.storagePoolLookupByName(pool_name)
2729                 if pool and matcher.group("volume") in pool.listVolumes():
2730                     volume = pool.storageVolLookupByName(matcher.group("volume"))
2731                     volume.delete()
2732     if dirs:
2733         for dir_ in directories:
2734             shutil.rmtree(dir_)
2735     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
2736         try:
2737             dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM)
2738         except Exception:  # pylint: disable=broad-except
2739             dom.undefine()
2740     else:
2741         dom.undefine()
2742     conn.close()
2743     return True
2744 def virt_type():
2745     return __grains__["virtual"]
2746 def _is_kvm_hyper():
2747     if not os.path.exists("/dev/kvm"):
2748         return False
2749     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
2750 def _is_xen_hyper():
2751     try:
2752         if __grains__["virtual_subtype"] != "Xen Dom0":
2753             return False
2754     except KeyError:
2755         return False
2756     try:
2757         with salt.utils.files.fopen("/proc/modules") as fp_:
2758             if "xen_" not in salt.utils.stringutils.to_unicode(fp_.read()):
2759                 return False
2760     except OSError:
2761         return False
2762     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
2763 def get_hypervisor():
2764     hypervisors = ["kvm", "xen", "bhyve"]
2765     result = [
2766         hyper
2767         for hyper in hypervisors
2768         if getattr(sys.modules[__name__], "_is_{}_hyper".format(hyper))()
2769     ]
2770     return result[0] if result else None
2771 def _is_bhyve_hyper():
2772     sysctl_cmd = "sysctl hw.vmm.create"
2773     vmm_enabled = False
2774     try:
2775         stdout = subprocess.Popen(
2776             ["sysctl", "hw.vmm.create"], stdout=subprocess.PIPE
2777         ).communicate()[0]
2778         vmm_enabled = len(salt.utils.stringutils.to_str(stdout).split('"')[1]) != 0
2779     except IndexError:
2780         pass
2781     return vmm_enabled
2782 def is_hyper():
2783     if HAS_LIBVIRT:
2784         return _is_xen_hyper() or _is_kvm_hyper() or _is_bhyve_hyper()
2785     return False
2786 def vm_cputime(vm_=None, **kwargs):
2787     conn = __get_conn(**kwargs)
2788     host_cpus = conn.getInfo()[2]
2789     def _info(dom):
2790         raw = dom.info()
2791         vcpus = int(raw[3])
2792         cputime = int(raw[4])
2793         cputime_percent = 0
2794         if cputime:
2795             cputime_percent = (1.0e-7 * cputime / host_cpus) / vcpus
2796         return {
2797             "cputime": int(raw[4]),
2798             "cputime_percent": int("{:.0f}".format(cputime_percent)),
2799         }
2800     info = {}
2801     if vm_:
2802         info[vm_] = _info(_get_domain(conn, vm_))
2803     else:
2804         for domain in _get_domain(conn, iterable=True):
2805             info[domain.name()] = _info(domain)
2806     conn.close()
2807     return info
2808 def vm_netstats(vm_=None, **kwargs):
2809     def _info(dom):
2810         nics = _get_nics(dom)
2811         ret = {
2812             "rx_bytes": 0,
2813             "rx_packets": 0,
2814             "rx_errs": 0,
2815             "rx_drop": 0,
2816             "tx_bytes": 0,
2817             "tx_packets": 0,
2818             "tx_errs": 0,
2819             "tx_drop": 0,
2820         }
2821         for attrs in nics.values():
2822             if "target" in attrs:
2823                 dev = attrs["target"]
2824                 stats = dom.interfaceStats(dev)
2825                 ret["rx_bytes"] += stats[0]
2826                 ret["rx_packets"] += stats[1]
2827                 ret["rx_errs"] += stats[2]
2828                 ret["rx_drop"] += stats[3]
2829                 ret["tx_bytes"] += stats[4]
2830                 ret["tx_packets"] += stats[5]
2831                 ret["tx_errs"] += stats[6]
2832                 ret["tx_drop"] += stats[7]
2833         return ret
2834     info = {}
2835     conn = __get_conn(**kwargs)
2836     if vm_:
2837         info[vm_] = _info(_get_domain(conn, vm_))
2838     else:
2839         for domain in _get_domain(conn, iterable=True):
2840             info[domain.name()] = _info(domain)
2841     conn.close()
2842     return info
2843 def vm_diskstats(vm_=None, **kwargs):
2844     def get_disk_devs(dom):
2845         doc = ElementTree.fromstring(get_xml(dom, **kwargs))
2846         return [target.get("dev") for target in doc.findall("devices/disk/target")]
2847     def _info(dom):
2848         disks = get_disk_devs(dom)
2849         ret = {"rd_req": 0, "rd_bytes": 0, "wr_req": 0, "wr_bytes": 0, "errs": 0}
2850         for disk in disks:
2851             stats = dom.blockStats(disk)
2852             ret["rd_req"] += stats[0]
2853             ret["rd_bytes"] += stats[1]
2854             ret["wr_req"] += stats[2]
2855             ret["wr_bytes"] += stats[3]
2856             ret["errs"] += stats[4]
2857         return ret
2858     info = {}
2859     conn = __get_conn(**kwargs)
2860     if vm_:
2861         info[vm_] = _info(_get_domain(conn, vm_))
2862     else:
2863         for domain in _get_domain(conn, iterable=True, inactive=False):
2864             info[domain.name()] = _info(domain)
2865     conn.close()
2866     return info
2867 def _parse_snapshot_description(vm_snapshot, unix_time=False):
2868     ret = dict()
2869     tree = ElementTree.fromstring(vm_snapshot.getXMLDesc())
2870     for node in tree:
2871         if node.tag == "name":
2872             ret["name"] = node.text
2873         elif node.tag == "creationTime":
2874             ret["created"] = (
2875                 datetime.datetime.fromtimestamp(float(node.text)).isoformat(" ")
2876                 if not unix_time
2877                 else float(node.text)
2878             )
2879         elif node.tag == "state":
2880             ret["running"] = node.text == "running"
2881     ret["current"] = vm_snapshot.isCurrent() == 1
2882     return ret
2883 def list_snapshots(domain=None, **kwargs):
2884     ret = dict()
2885     conn = __get_conn(**kwargs)
2886     for vm_domain in _get_domain(conn, *(domain and [domain] or list()), iterable=True):
2887         ret[vm_domain.name()] = [
2888             _parse_snapshot_description(snap) for snap in vm_domain.listAllSnapshots()
2889         ] or "N/A"
2890     conn.close()
2891     return ret
2892 def snapshot(domain, name=None, suffix=None, **kwargs):
2893     if name and name.lower() == domain.lower():
2894         raise CommandExecutionError(
2895             "Virtual Machine {name} is already defined. "
2896             "Please choose another name for the snapshot".format(name=name)
2897         )
2898     if not name:
2899         name = "{domain}-{tsnap}".format(
2900             domain=domain, tsnap=time.strftime("%Y%m%d-%H%M%S", time.localtime())
2901         )
2902     if suffix:
2903         name = "{name}-{suffix}".format(name=name, suffix=suffix)
2904     doc = ElementTree.Element("domainsnapshot")
2905     n_name = ElementTree.SubElement(doc, "name")
2906     n_name.text = name
2907     conn = __get_conn(**kwargs)
2908     _get_domain(conn, domain).snapshotCreateXML(xmlutil.element_to_str(doc))
2909     conn.close()
2910     return {"name": name}
2911 def delete_snapshots(name, *names, **kwargs):
2912     deleted = dict()
2913     conn = __get_conn(**kwargs)
2914     domain = _get_domain(conn, name)
2915     for snap in domain.listAllSnapshots():
2916         if snap.getName() in names or not names:
2917             deleted[snap.getName()] = _parse_snapshot_description(snap)
2918             snap.delete()
2919     conn.close()
2920     available = {
2921         name: [_parse_snapshot_description(snap) for snap in domain.listAllSnapshots()]
2922         or "N/A"
2923     }
2924     return {"available": available, "deleted": deleted}
2925 def revert_snapshot(name, vm_snapshot=None, cleanup=False, **kwargs):
2926     ret = dict()
2927     conn = __get_conn(**kwargs)
2928     domain = _get_domain(conn, name)
2929     snapshots = domain.listAllSnapshots()
2930     _snapshots = list()
2931     for snap_obj in snapshots:
2932         _snapshots.append(
2933             {
2934                 "idx": _parse_snapshot_description(snap_obj, unix_time=True)["created"],
2935                 "ptr": snap_obj,
2936             }
2937         )
2938     snapshots = [
2939         w_ptr["ptr"]
2940         for w_ptr in sorted(_snapshots, key=lambda item: item["idx"], reverse=True)
2941     ]
2942     del _snapshots
2943     if not snapshots:
2944         conn.close()
2945         raise CommandExecutionError("No snapshots found")
2946     elif len(snapshots) == 1:
2947         conn.close()
2948         raise CommandExecutionError(
2949             "Cannot revert to itself: only one snapshot is available."
2950         )
2951     snap = None
2952     for p_snap in snapshots:
2953         if not vm_snapshot:
2954             if p_snap.isCurrent() and snapshots[snapshots.index(p_snap) + 1 :]:
2955                 snap = snapshots[snapshots.index(p_snap) + 1 :][0]
2956                 break
2957         elif p_snap.getName() == vm_snapshot:
2958             snap = p_snap
2959             break
2960     if not snap:
2961         conn.close()
2962         raise CommandExecutionError(
2963             snapshot
2964             and 'Snapshot "{}" not found'.format(vm_snapshot)
2965             or "No more previous snapshots available"
2966         )
2967     elif snap.isCurrent():
2968         conn.close()
2969         raise CommandExecutionError("Cannot revert to the currently running snapshot.")
2970     domain.revertToSnapshot(snap)
2971     ret["reverted"] = snap.getName()
2972     if cleanup:
2973         delete = list()
2974         for p_snap in snapshots:
2975             if p_snap.getName() != snap.getName():
2976                 delete.append(p_snap.getName())
2977                 p_snap.delete()
2978             else:
2979                 break
2980         ret["deleted"] = delete
2981     else:
2982         ret["deleted"] = "N/A"
2983     conn.close()
2984     return ret
2985 def _caps_add_machine(machines, node):
2986     maxcpus = node.get("maxCpus")
2987     canonical = node.get("canonical")
2988     name = node.text
2989     alternate_name = ""
2990     if canonical:
2991         alternate_name = name
2992         name = canonical
2993     machine = machines.get(name)
2994     if not machine:
2995         machine = {"alternate_names": []}
2996         if maxcpus:
2997             machine["maxcpus"] = int(maxcpus)
2998         machines[name] = machine
2999     if alternate_name:
3000         machine["alternate_names"].append(alternate_name)
3001 def _parse_caps_guest(guest):
3002     arch_node = guest.find("arch")
3003     result = {
3004         "os_type": guest.find("os_type").text,
3005         "arch": {"name": arch_node.get("name"), "machines": {}, "domains": {}},
3006     }
3007     child = None
3008     for child in arch_node:
3009         if child.tag == "wordsize":
3010             result["arch"]["wordsize"] = int(child.text)
3011         elif child.tag == "emulator":
3012             result["arch"]["emulator"] = child.text
3013         elif child.tag == "machine":
3014             _caps_add_machine(result["arch"]["machines"], child)
3015         elif child.tag == "domain":
3016             domain_type = child.get("type")
3017             domain = {"emulator": None, "machines": {}}
3018             emulator_node = child.find("emulator")
3019             if emulator_node is not None:
3020                 domain["emulator"] = emulator_node.text
3021             for machine in child.findall("machine"):
3022                 _caps_add_machine(domain["machines"], machine)
3023             result["arch"]["domains"][domain_type] = domain
3024     features_nodes = guest.find("features")
3025     if features_nodes is not None and child is not None:
3026         result["features"] = {
3027             child.tag: {
3028                 "toggle": child.get("toggle", "no") == "yes",
3029                 "default": child.get("default", "on") == "on",
3030             }
3031             for child in features_nodes
3032         }
3033     return result
3034 def _parse_caps_cell(cell):
3035     result = {"id": int(cell.get("id"))}
3036     mem_node = cell.find("memory")
3037     if mem_node is not None:
3038         unit = mem_node.get("unit", "KiB")
3039         memory = mem_node.text
3040         result["memory"] = "{} {}".format(memory, unit)
3041     pages = [
3042         {
3043             "size": "{} {}".format(page.get("size"), page.get("unit", "KiB")),
3044             "available": int(page.text),
3045         }
3046         for page in cell.findall("pages")
3047     ]
3048     if pages:
3049         result["pages"] = pages
3050     distances = {
3051         int(distance.get("id")): int(distance.get("value"))
3052         for distance in cell.findall("distances/sibling")
3053     }
3054     if distances:
3055         result["distances"] = distances
3056     cpus = []
3057     for cpu_node in cell.findall("cpus/cpu"):
3058         cpu = {"id": int(cpu_node.get("id"))}
3059         socket_id = cpu_node.get("socket_id")
3060         if socket_id:
3061             cpu["socket_id"] = int(socket_id)
3062         core_id = cpu_node.get("core_id")
3063         if core_id:
3064             cpu["core_id"] = int(core_id)
3065         siblings = cpu_node.get("siblings")
3066         if siblings:
3067             cpu["siblings"] = siblings
3068         cpus.append(cpu)
3069     if cpus:
3070         result["cpus"] = cpus
3071     return result
3072 def _parse_caps_bank(bank):
3073         "level": int(bank<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("level")),
3074         "type": bank.get("type"),
3075         "size": "{} {}".format(bank.get("size"), bank.get("unit")),
3076         "cpus": bank.get(</b></font>"cpus"),
3077     }
3078     controls = []
3079     for control in bank.findall("control"):
3080         unit = control.get("unit")
3081         result_control = {
3082             "granularity": "{} {}".format(control.get("granularity"), unit),
3083             "type": control.get("type"),
3084             "maxAllocs": int(control.get("maxAllocs")),
3085         }
3086         minimum = control.get("min")
3087         if minimum:
3088             result_control["min"] = "{} {}".format(minimum, unit)
3089         controls.append(result_control)
3090     if controls:
3091         result["controls"] = controls
3092     return result
3093 def _parse_caps_host(host):
3094     result = {}
3095     for child in host:
3096         if child.tag == "uuid":
3097             result["uuid"] = child.text
3098 <a name="5"></a>        elif child.tag == "cpu":
3099             cpu = {
3100                 "arch": child.find("arch").text
3101                 if child<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("arch") is not None
3102                 else None,
3103                 "model": child.find("model").text
3104                 if child.find("model") is not None
3105                 else None,
3106                 "vendor": child.find("vendor").text
3107                 if child.find("vendor") is not None
3108                 else None,
3109                 "features": [
3110                     feature.get("name") for feature in child.findall("feature")
3111                 ],
3112                 "pages": [
3113                     {</b></font>"size": "{} {}".format(page.get("size"), page.get("unit", "KiB"))}
3114                     for page in child.findall("pages")
3115                 ],
3116             }
3117             microcode = child.find("microcode")
3118             if microcode is not None:
3119                 cpu["microcode"] = microcode.get("version")
3120             topology = child.find("topology")
3121             if topology is not None:
3122                 cpu["sockets"] = int(topology.get("sockets"))
3123                 cpu["cores"] = int(topology.get("cores"))
3124                 cpu["threads"] = int(topology.get("threads"))
3125             result["cpu"] = cpu
3126         elif child.tag == "power_management":
3127             result["power_management"] = [node.tag for node in child]
3128         elif child.tag == "migration_features":
3129             result["migration"] = {
3130                 "live": child.find("live") is not None,
3131                 "transports": [
3132                     node.text for node in child.findall("uri_transports/uri_transport")
3133                 ],
3134             }
3135         elif child.tag == "topology":
3136             result["topology"] = {
3137                 "cells": [
3138                     _parse_caps_cell(cell) for cell in child.findall("cells/cell")
3139                 ]
3140             }
3141         elif child.tag == "cache":
3142             result["cache"] = {
3143                 "banks": [_parse_caps_bank(bank) for bank in child.findall("bank")]
3144             }
3145 <a name="10"></a>
3146     result["security"] = [
3147         {
3148             "model": secmodel<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("model").text
3149             if secmodel.find("model") is not None
3150             else None,
3151             "doi": secmodel.find("doi").text
3152             if secmodel.find("doi") is not None
3153             else None,
3154             "baselabels": [
3155                 {"type": label.</b></font>get("type"), "label": label.text}
3156                 for label in secmodel.findall("baselabel")
3157             ],
3158         }
3159         for secmodel in host.findall("secmodel")
3160     ]
3161     return result
3162 def _capabilities(conn):
3163     caps = ElementTree.fromstring(conn.getCapabilities())
3164     return {
3165         "host": _parse_caps_host(caps.find("host")),
3166         "guests": [_parse_caps_guest(guest) for guest in caps.findall("guest")],
3167     }
3168 def capabilities(**kwargs):
3169     conn = __get_conn(**kwargs)
3170     try:
3171         caps = _capabilities(conn)
3172     except libvirt.libvirtError as err:
3173         raise CommandExecutionError(str(err))
3174     finally:
3175         conn.close()
3176     return caps
3177 def _parse_caps_enum(node):
3178     return (node.get("name"), [value.text for value in node.findall("value")])
3179 def _parse_caps_cpu(node):
3180     result = {}
3181     for mode in node.findall("mode"):
3182         if not mode.get("supported") == "yes":
3183             continue
3184         name = mode.get("name")
3185         if name == "host-passthrough":
3186             result[name] = True
3187         elif name == "host-model":
3188             host_model = {}
3189             model_node = mode.find("model")
3190             if model_node is not None:
3191                 model = {"name": model_node.text}
3192                 vendor_id = model_node.get("vendor_id")
3193                 if vendor_id:
3194                     model["vendor_id"] = vendor_id
3195                 fallback = model_node.get("fallback")
3196                 if fallback:
3197                     model["fallback"] = fallback
3198                 host_model["model"] = model
3199             vendor = (
3200                 mode.find("vendor").text if mode.find("vendor") is not None else None
3201             )
3202             if vendor:
3203                 host_model["vendor"] = vendor
3204             features = {
3205                 feature.get("name"): feature.get("policy")
3206                 for feature in mode.findall("feature")
3207             }
3208             if features:
3209                 host_model["features"] = features
3210             result[name] = host_model
3211         elif name == "custom":
3212             custom_model = {}
3213             models = {
3214                 model.text: model.get("usable") for model in mode.findall("model")
3215             }
3216             if models:
3217                 custom_model["models"] = models
3218             result[name] = custom_model
3219     return result
3220 def _parse_caps_devices_features(node):
3221     result = {}
3222     for child in node:
3223         if child.get("supported") == "yes":
3224             enums = [_parse_caps_enum(node) for node in child.findall("enum")]
3225             result[child.tag] = {item[0]: item[1] for item in enums if item[0]}
3226     return result
3227 def _parse_caps_loader(node):
3228     enums = [_parse_caps_enum(enum) for enum in node.findall("enum")]
3229     result = {item[0]: item[1] for item in enums if item[0]}
3230     values = [child.text for child in node.findall("value")]
3231     if values:
3232         result["values"] = values
3233     return result
3234 def _parse_domain_caps(caps):
3235     result = {
3236         "emulator": caps.find("path").text if caps<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("path") is not None else None,
3237         "domain": caps.find("domain").text if caps.find("domain") is not None else None,
3238         "machine": caps.find("machine").text
3239         if caps.find("machine") is not None
3240         else None,
3241         "arch": caps.find("arch").text if caps.find(</b></font>"arch") is not None else None,
3242     }
3243     for child in caps:
3244         if child.tag == "vcpu" and child.get("max"):
3245             result["max_vcpus"] = int(child.get("max"))
3246         elif child.tag == "iothreads":
3247             result["iothreads"] = child.get("supported") == "yes"
3248         elif child.tag == "os":
3249             result["os"] = {}
3250             loader_node = child.find("loader")
3251             if loader_node is not None and loader_node.get("supported") == "yes":
3252                 loader = _parse_caps_loader(loader_node)
3253                 result["os"]["loader"] = loader
3254         elif child.tag == "cpu":
3255             cpu = _parse_caps_cpu(child)
3256             if cpu:
3257                 result["cpu"] = cpu
3258         elif child.tag == "devices":
3259             devices = _parse_caps_devices_features(child)
3260             if devices:
3261                 result["devices"] = devices
3262         elif child.tag == "features":
3263             features = _parse_caps_devices_features(child)
3264             if features:
3265                 result["features"] = features
3266     return result
3267 def domain_capabilities(emulator=None, arch=None, machine=None, domain=None, **kwargs):
3268     conn = __get_conn(**kwargs)
3269     result = []
3270     try:
3271         caps = ElementTree.fromstring(
3272             conn.getDomainCapabilities(emulator, arch, machine, domain, 0)
3273         )
3274         result = _parse_domain_caps(caps)
3275     finally:
3276         conn.close()
3277     return result
3278 def all_capabilities(**kwargs):
3279     conn = __get_conn(**kwargs)
3280     try:
3281         host_caps = ElementTree.fromstring(conn.getCapabilities())
3282 <a name="14"></a>        domains = [
3283             [
3284                 (
3285                     guest<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("arch", {}).get("name", None),
3286                     key,
3287                     guest.get("arch", {}).get("emulator", None),
3288                 )
3289                 for key in guest.get("arch", {}).get(</b></font>"domains", {}).keys()
3290             ]
3291             for guest in [
3292                 _parse_caps_guest(guest) for guest in host_caps.findall("guest")
3293             ]
3294         ]
3295         flattened = [pair for item in (x for x in domains) for pair in item]
3296         result = {
3297             "host": {
3298                 "host": _parse_caps_host(host_caps.find("host")),
3299                 "guests": [
3300                     _parse_caps_guest(guest) for guest in host_caps.findall("guest")
3301                 ],
3302             },
3303             "domains": [
3304                 _parse_domain_caps(
3305                     ElementTree.fromstring(
3306                         conn.getDomainCapabilities(emulator, arch, None, domain)
3307                     )
3308                 )
3309                 for (arch, domain, emulator) in flattened
3310             ],
3311         }
3312         return result
3313     finally:
3314         conn.close()
3315 def cpu_baseline(full=False, migratable=False, out="libvirt", **kwargs):
3316     conn = __get_conn(**kwargs)
3317     caps = ElementTree.fromstring(conn.getCapabilities())
3318     cpu = caps.find("host/cpu")
3319     host_cpu_def = xmlutil.element_to_str(cpu)
3320     log.debug("Host CPU model definition: %s", host_cpu_def)
3321     flags = 0
3322     if migratable:
3323         if getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_MIGRATABLE", False):
3324             flags += libvirt.VIR_CONNECT_BASELINE_CPU_MIGRATABLE
3325         else:
3326             conn.close()
3327             raise ValueError
3328     if full and getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
3329         flags += libvirt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES
3330     cpu = ElementTree.fromstring(conn.baselineCPU([host_cpu_def], flags))
3331     conn.close()
3332     if full and not getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
3333         with salt.utils.files.fopen("/usr/share/libvirt/cpu_map.xml", "r") as cpu_map:
3334             cpu_map = ElementTree.parse(cpu_map)
3335         cpu_model = cpu.find("model").text
3336         while cpu_model:
3337             cpu_map_models = cpu_map.findall("arch/model")
3338             cpu_specs = [
3339                 el
3340                 for el in cpu_map_models
3341                 if el.get("name") == cpu_model and bool(len(el))
3342             ]
3343             if not cpu_specs:
3344                 raise ValueError("Model {} not found in CPU map".format(cpu_model))
3345             elif len(cpu_specs) &gt; 1:
3346                 raise ValueError(
3347                     "Multiple models {} found in CPU map".format(cpu_model)
3348                 )
3349             cpu_specs = cpu_specs[0]
3350             model_node = cpu_specs.find("model")
3351             if model_node is None:
3352                 cpu_model = None
3353             else:
3354                 cpu_model = model_node.get("name")
3355             cpu.extend([feature for feature in cpu_specs.findall("feature")])
3356     if out == "salt":
3357         return {
3358             "model": cpu.find("model").text,
3359             "vendor": cpu.find("vendor").text,
3360             "features": [feature.get("name") for feature in cpu.findall("feature")],
3361         }
3362     return ElementTree.tostring(cpu)
3363 def network_define(
3364     name,
3365     bridge,
3366 <a name="8"></a>    forward,
3367     ipv4_config=None,
3368     ipv6_config=None,
3369     vport<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
3370     tag=None,
3371     autostart=True,
3372     start=True,
3373     mtu=None,
3374     domain=None,
3375     nat=None,
3376     interfaces=None,
3377     addresses=None,
3378     physical_function=None,
3379     dns=None,
3380     **kwargs
3381 ):
3382     conn = __get_conn(**kwargs)
3383     vport = kwargs.</b></font>get("vport", None)
3384     tag = kwargs.get("tag", None)
3385     net_xml = _gen_net_xml(
3386         name,
3387         bridge,
3388         forward,
3389         vport,
3390         tag=tag,
3391         ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
3392         mtu=mtu,
3393         domain=domain,
3394         nat=nat,
3395         interfaces=interfaces,
3396         addresses=addresses,
3397         physical_function=physical_function,
3398         dns=dns,
3399     )
3400     try:
3401         conn.networkDefineXML(net_xml)
3402     except libvirt.libvirtError as err:
3403         log.warning(err)
3404         conn.close()
3405         raise err  # a real error we should report upwards
3406     try:
3407         network = conn.networkLookupByName(name)
3408     except libvirt.libvirtError as err:
3409         log.warning(err)
3410         conn.close()
3411         raise err  # a real error we should report upwards
3412     if network is None:
3413         conn.close()
3414         return False
3415     if (start or autostart) and network.isActive() != 1:
3416         network.create()
3417     if autostart and network.autostart() != 1:
3418         network.setAutostart(int(autostart))
3419     elif not autostart and network.autostart() == 1:
3420         network.setAutostart(int(autostart))
3421     conn.close()
3422     return True
3423 def _remove_empty_xml_node(node):
3424     for child in node:
3425         if not child.tail and not child.text and not child.items() and not child:
3426             node.remove(child)
3427         else:
3428             _remove_empty_xml_node(child)
3429     return node
3430 def network_update(
3431     name,
3432     bridge,
3433     forward,
3434     ipv4_config=None,
3435     ipv6_config=None,
3436     vport=None,
3437     tag=None,
3438     mtu=None,
3439     domain=None,
3440     nat=None,
3441     interfaces=None,
3442     addresses=None,
3443     physical_function=None,
3444     dns=None,
3445     test=False,
3446     **kwargs
3447 ):
3448     conn = __get_conn(**kwargs)
3449     needs_update = False
3450     try:
3451         net = conn.networkLookupByName(name)
3452         old_xml = ElementTree.fromstring(net.XMLDesc())
3453         new_xml = ElementTree.fromstring(
3454             _gen_net_xml(
3455                 name,
3456                 bridge,
3457                 forward,
3458                 vport,
3459                 tag=tag,
3460                 ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
3461                 mtu=mtu,
3462                 domain=domain,
3463                 nat=nat,
3464                 interfaces=interfaces,
3465                 addresses=addresses,
3466                 physical_function=physical_function,
3467                 dns=dns,
3468             )
3469         )
3470         elements_to_copy = ["uuid", "mac"]
3471         for to_copy in elements_to_copy:
3472             element = old_xml.find(to_copy)
3473             if element is not None:
3474                 new_xml.insert(1, element)
3475         old_xml.attrib.pop("connections", None)
3476         if old_xml.find("forward/pf") is not None:
3477             forward_node = old_xml.find("forward")
3478             address_nodes = forward_node.findall("address")
3479             for node in address_nodes:
3480                 forward_node.remove(node)
3481         default_bridge_attribs = {"stp": "on", "delay": "0"}
3482         old_bridge_node = old_xml.find("bridge")
3483         if old_bridge_node is not None:
3484             for key, value in default_bridge_attribs.items():
3485                 if old_bridge_node.get(key, None) == value:
3486                     old_bridge_node.attrib.pop(key, None)
3487             old_forward = (
3488                 old_xml.find("forward").get("mode")
3489                 if old_xml.find("forward") is not None
3490                 else None
3491             )
3492             if (
3493                 old_forward == forward
3494                 and forward in ["nat", "route", "open", None]
3495                 and bridge is None
3496                 and old_bridge_node.get("name", "").startswith("virbr")
3497             ):
3498                 old_bridge_node.attrib.pop("name", None)
3499         ipv4_nodes = [
3500             node
3501             for node in old_xml.findall("ip")
3502             if node.get("family", "ipv4") == "ipv4"
3503         ]
3504         for ip_node in ipv4_nodes:
3505             netmask = ip_node.attrib.pop("netmask", None)
3506             if netmask:
3507                 address = ipaddress.ip_network(
3508                     "{}/{}".format(ip_node.get("address"), netmask), strict=False
3509                 )
3510                 ip_node.set("prefix", str(address.prefixlen))
3511         for doc in [old_xml, new_xml]:
3512             for node in doc.findall("ip"):
3513                 if "family" not in node.keys():
3514                     node.set("family", "ipv4")
3515         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
3516         xmlutil.strip_spaces(new_xml)
3517         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
3518         if needs_update and not test:
3519             conn.networkDefineXML(xmlutil.element_to_str(new_xml))
3520     finally:
3521         conn.close()
3522     return needs_update
3523 def list_networks(**kwargs):
3524     conn = __get_conn(**kwargs)
3525     try:
3526         return [net.name() for net in conn.listAllNetworks()]
3527     finally:
3528         conn.close()
3529 def network_info(name=None, **kwargs):
3530     result = {}
3531     conn = __get_conn(**kwargs)
3532     def _net_get_leases(net):
3533         leases = net.DHCPLeases()
3534         for lease in leases:
3535             if lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV4:
3536                 lease["type"] = "ipv4"
3537             elif lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV6:
3538                 lease["type"] = "ipv6"
3539             else:
3540                 lease["type"] = "unknown"
3541         return leases
3542     def _net_get_bridge(net):
3543         try:
3544             return net.bridgeName()
3545         except libvirt.libvirtError as err:
3546             return None
3547     try:
3548         nets = [
3549             net for net in conn.listAllNetworks() if name is None or net.name() == name
3550         ]
3551         result = {
3552             net.name(): {
3553                 "uuid": net.UUIDString(),
3554                 "bridge": _net_get_bridge(net),
3555                 "autostart": net.autostart(),
3556                 "active": net.isActive(),
3557                 "persistent": net.isPersistent(),
3558                 "leases": _net_get_leases(net),
3559             }
3560             for net in nets
3561         }
3562     except libvirt.libvirtError as err:
3563         log.debug("Silenced libvirt error: %s", err)
3564     finally:
3565         conn.close()
3566     return result
3567 def network_get_xml(name, **kwargs):
3568     conn = __get_conn(**kwargs)
3569     try:
3570         return conn.networkLookupByName(name).XMLDesc()
3571     finally:
3572         conn.close()
3573 def network_start(name, **kwargs):
3574     conn = __get_conn(**kwargs)
3575     try:
3576         net = conn.networkLookupByName(name)
3577         return not bool(net.create())
3578     finally:
3579         conn.close()
3580 def network_stop(name, **kwargs):
3581     conn = __get_conn(**kwargs)
3582     try:
3583         net = conn.networkLookupByName(name)
3584         return not bool(net.destroy())
3585     finally:
3586         conn.close()
3587 def network_undefine(name, **kwargs):
3588     conn = __get_conn(**kwargs)
3589     try:
3590         net = conn.networkLookupByName(name)
3591         return not bool(net.undefine())
3592     finally:
3593         conn.close()
3594 def network_set_autostart(name, state="on", **kwargs):
3595     conn = __get_conn(**kwargs)
3596     try:
3597         net = conn.networkLookupByName(name)
3598         return not bool(net.setAutostart(1 if state == "on" else 0))
3599     finally:
3600         conn.close()
3601 def _parse_pools_caps(doc):
3602     def _parse_pool_caps(pool):
3603         pool_caps = {
3604             "name": pool.get("type"),
3605             "supported": pool.get("supported", "no") == "yes",
3606         }
3607         for option_kind in ["pool", "vol"]:
3608             options = {}
3609             default_format_node = pool.find(
3610                 "{}Options/defaultFormat".format(option_kind)
3611             )
3612             if default_format_node is not None:
3613                 options["default_format"] = default_format_node.get("type")
3614             options_enums = {
3615                 enum.get("name"): [value.text for value in enum.findall("value")]
3616                 for enum in pool.findall("{}Options/enum".format(option_kind))
3617             }
3618             if options_enums:
3619                 options.update(options_enums)
3620             if options:
3621                 if "options" not in pool_caps:
3622                     pool_caps["options"] = {}
3623                 kind = option_kind if option_kind != "vol" else "volume"
3624                 pool_caps["options"][kind] = options
3625         return pool_caps
3626     return [_parse_pool_caps(pool) for pool in doc.findall("pool")]
3627 def _pool_capabilities(conn):
3628     has_pool_capabilities = bool(getattr(conn, "getStoragePoolCapabilities", None))
3629     if has_pool_capabilities:
3630         caps = ElementTree.fromstring(conn.getStoragePoolCapabilities())
3631         pool_types = _parse_pools_caps(caps)
3632     else:
3633         all_hypervisors = ["xen", "kvm", "bhyve"]
3634         images_formats = [
3635             "none",
3636             "raw",
3637             "dir",
3638             "bochs",
3639             "cloop",
3640             "dmg",
3641             "iso",
3642             "vpc",
3643             "vdi",
3644             "fat",
3645             "vhd",
3646             "ploop",
3647             "cow",
3648             "qcow",
3649             "qcow2",
3650 <a name="0"></a>            "qed",
3651             "vmdk",
3652         ]
3653         common_drivers <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= [
3654             {
3655                 "name": "fs",
3656                 "default_source_format": "auto",
3657                 "source_formats": [
3658                     "auto",
3659                     "ext2",
3660                     "ext3",
3661                     "ext4",
3662                     "ufs",
3663                     "iso9660",
3664                     "udf",
3665                     "gfs",
3666                     "gfs2",
3667                     "vfat",
3668                     "hfs+",
3669                     "xfs",
3670                     "ocfs2",
3671                 ],
3672                 "default_target_format": "raw",
3673                 "target_formats": images_formats,
3674             },
3675             {
3676                 "name": "dir",
3677                 "default_target_format": "raw",
3678                 "target_formats": images_formats,
3679             },
3680             {"name": "iscsi"},
3681             {"name": "scsi"},
3682             {
3683                 "name": "logical",
3684                 "default_source_format": "lvm2",
3685                 "source_formats": ["unknown", "lvm2"],
3686             },
3687             {
3688                 "name": "netfs",
3689                 "default_source_format": "auto",
3690                 "source_formats": ["auto", "nfs", "glusterfs", "cifs"],
3691                 "default_target_format": "raw",
3692                 "target_formats": images_formats,
3693             },
3694             {
3695                 "name": "disk",
3696                 "default_source_format": "unknown",
3697                 "source_formats": [
3698                     "unknown",
3699                     "dos",
3700                     "dvh",
3701                     "gpt",
3702                     "mac",
3703                     "bsd",
3704                     "pc98",
3705                     "sun",
3706                     "lvm2",
3707                 ],
3708                 "default_target_format": "none",
3709                 "target_formats": [
3710                     "none",
3711                     "linux",
3712                     "fat16",
3713                     "fat32",
3714                     "linux-swap",
3715                     "linux-lvm",
3716                     "linux-raid",
3717                     "extended",
3718                 ],
3719             },
3720             {"name": "mpath"},
3721             {"name": "rbd", "default_target_format": "raw", "target_formats": []},
3722             {
3723                 "name": "sheepdog",
3724                 "version": 10000,
3725                 "hypervisors": ["kvm"],
3726                 "default_target_format": "raw",
3727                 "target_formats": images_formats,
3728             },
3729             {
3730                 "name": "gluster",
3731                 "version": 1002000,
3732                 "hypervisors": ["kvm"],
3733                 "default_target_format": "raw",
3734                 "target_formats": images_formats,
3735             },
3736             {"name": "zfs", "version": 1002008, "hypervisors": ["bhyve"]},
3737             {
3738                 "name": "iscsi-direct",
3739                 "version": 4007000,
3740                 "hypervisors": ["kvm"</b></font>, "xen"],
3741             },
3742         ]
3743         libvirt_version = conn.getLibVersion()
3744         hypervisor = get_hypervisor()
3745         def _get_backend_output(backend):
3746             output = {
3747                 "name": backend["name"],
3748                 "supported": (
3749                     not backend.get("version") or libvirt_version &gt;= backend["version"]
3750                 )
3751                 and hypervisor in backend.get("hypervisors", all_hypervisors),
3752                 "options": {
3753                     "pool": {
3754                         "default_format": backend.get("default_source_format"),
3755                         "sourceFormatType": backend.get("source_formats"),
3756                     },
3757                     "volume": {
3758                         "default_format": backend.get("default_target_format"),
3759                         "targetFormatType": backend.get("target_formats"),
3760                     },
3761                 },
3762             }
3763             for option_kind in ["pool", "volume"]:
3764                 if not [
3765                     value
3766                     for value in output["options"][option_kind].values()
3767                     if value is not None
3768                 ]:
3769                     del output["options"][option_kind]
3770             if not output["options"]:
3771                 del output["options"]
3772             return output
3773         pool_types = [_get_backend_output(backend) for backend in common_drivers]
3774     return {
3775         "computed": not has_pool_capabilities,
3776         "pool_types": pool_types,
3777     }
3778 def pool_capabilities(**kwargs):
3779     try:
3780         conn = __get_conn(**kwargs)
3781         return _pool_capabilities(conn)
3782     finally:
3783         conn.close()
3784 def pool_define(
3785     name,
3786     ptype,
3787     target=None,
3788     permissions=None,
3789     source_devices=None,
3790     source_dir=None,
3791     source_initiator=None,
3792     source_adapter=None,
3793     source_hosts=None,
3794     source_auth=None,
3795     source_name=None,
3796     source_format=None,
3797     transient=False,
3798     start=True,  # pylint: disable=redefined-outer-name
3799     **kwargs
3800 ):
3801     conn = __get_conn(**kwargs)
3802     auth = _pool_set_secret(conn, ptype, name, source_auth)
3803     pool_xml = _gen_pool_xml(
3804         name,
3805         ptype,
3806         target,
3807         permissions=permissions,
3808         source_devices=source_devices,
3809         source_dir=source_dir,
3810         source_adapter=source_adapter,
3811         source_hosts=source_hosts,
3812         source_auth=auth,
3813         source_name=source_name,
3814         source_format=source_format,
3815         source_initiator=source_initiator,
3816     )
3817     try:
3818         if transient:
3819             pool = conn.storagePoolCreateXML(pool_xml)
3820         else:
3821             pool = conn.storagePoolDefineXML(pool_xml)
3822             if start:
3823                 pool.create()
3824     except libvirt.libvirtError as err:
3825         raise err  # a real error we should report upwards
3826     finally:
3827         conn.close()
3828     return True
3829 def _pool_set_secret(
3830     conn, pool_type, pool_name, source_auth, uuid=None, usage=None, test=False
3831 ):
3832     secret_types = {"rbd": "ceph", "iscsi": "chap", "iscsi-direct": "chap"}
3833     secret_type = secret_types.get(pool_type)
3834     auth = source_auth
3835     if source_auth and "username" in source_auth and "password" in source_auth:
3836         if secret_type:
3837             secret = None
3838             try:
3839                 if usage:
3840                     usage_type = (
3841                         libvirt.VIR_SECRET_USAGE_TYPE_CEPH
3842                         if secret_type == "ceph"
3843                         else libvirt.VIR_SECRET_USAGE_TYPE_ISCSI
3844                     )
3845                     secret = conn.secretLookupByUsage(usage_type, usage)
3846                 elif uuid:
3847                     secret = conn.secretLookupByUUIDString(uuid)
3848             except libvirt.libvirtError as err:
3849                 log.info("Secret not found: %s", err.get_error_message())
3850             if not secret:
3851                 description = "Passphrase for {} pool created by Salt".format(pool_name)
3852                 if not usage:
3853                     usage = "pool_{}".format(pool_name)
3854                 secret_xml = _gen_secret_xml(secret_type, usage, description)
3855                 if not test:
3856                     secret = conn.secretDefineXML(secret_xml)
3857             password = auth["password"]
3858             if pool_type == "rbd":
3859                 password = base64.b64decode(salt.utils.stringutils.to_bytes(password))
3860             if not test:
3861                 secret.setValue(password)
3862             auth["type"] = secret_type
3863             auth["secret"] = {
3864                 "type": "uuid" if uuid else "usage",
3865                 "value": uuid if uuid else usage,
3866             }
3867     return auth
3868 def pool_update(
3869     name,
3870     ptype,
3871     target=None,
3872     permissions=None,
3873     source_devices=None,
3874     source_dir=None,
3875     source_initiator=None,
3876     source_adapter=None,
3877     source_hosts=None,
3878     source_auth=None,
3879     source_name=None,
3880     source_format=None,
3881     test=False,
3882     **kwargs
3883 ):
3884     conn = __get_conn(**kwargs)
3885     needs_update = False
3886     try:
3887         pool = conn.storagePoolLookupByName(name)
3888         old_xml = ElementTree.fromstring(pool.XMLDesc())
3889         secret_node = old_xml.find("source/auth/secret")
3890         usage = secret_node.get("usage") if secret_node is not None else None
3891         uuid = secret_node.get("uuid") if secret_node is not None else None
3892         auth = _pool_set_secret(
3893             conn, ptype, name, source_auth, uuid=uuid, usage=usage, test=test
3894         )
3895         new_xml = ElementTree.fromstring(
3896             _gen_pool_xml(
3897                 name,
3898                 ptype,
3899                 target,
3900                 permissions=permissions,
3901                 source_devices=source_devices,
3902                 source_dir=source_dir,
3903                 source_initiator=source_initiator,
3904                 source_adapter=source_adapter,
3905                 source_hosts=source_hosts,
3906                 source_auth=auth,
3907                 source_name=source_name,
3908                 source_format=source_format,
3909             )
3910         )
3911         elements_to_copy = ["available", "allocation", "capacity", "uuid"]
3912         for to_copy in elements_to_copy:
3913             element = old_xml.find(to_copy)
3914             new_xml.insert(1, element)
3915         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
3916         xmlutil.strip_spaces(new_xml)
3917         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
3918         if needs_update and not test:
3919             conn.storagePoolDefineXML(xmlutil.element_to_str(new_xml))
3920     finally:
3921         conn.close()
3922     return needs_update
3923 def list_pools(**kwargs):
3924     conn = __get_conn(**kwargs)
3925     try:
3926         return [pool.name() for pool in conn.listAllStoragePools()]
3927     finally:
3928         conn.close()
3929 def pool_info(name=None, **kwargs):
3930     result = {}
3931     conn = __get_conn(**kwargs)
3932     def _pool_extract_infos(pool):
3933         states = ["inactive", "building", "running", "degraded", "inaccessible"]
3934         infos = pool.info()
3935         state = states[infos[0]] if infos[0] &lt; len(states) else "unknown"
3936         desc = ElementTree.fromstring(pool.XMLDesc())
3937         path_node = desc.find("target/path")
3938         return {
3939             "uuid": pool.UUIDString(),
3940             "state": state,
3941             "capacity": infos[1],
3942             "allocation": infos[2],
3943             "free": infos[3],
3944             "autostart": pool.autostart(),
3945             "persistent": pool.isPersistent(),
3946             "target_path": path_node.text if path_node is not None else None,
3947             "type": desc.get("type"),
3948         }
3949     try:
3950         pools = [
3951             pool
3952             for pool in conn.listAllStoragePools()
3953             if name is None or pool.name() == name
3954         ]
3955         result = {pool.name(): _pool_extract_infos(pool) for pool in pools}
3956     except libvirt.libvirtError as err:
3957         log.debug("Silenced libvirt error: %s", err)
3958     finally:
3959         conn.close()
3960     return result
3961 def pool_get_xml(name, **kwargs):
3962     conn = __get_conn(**kwargs)
3963     try:
3964         return conn.storagePoolLookupByName(name).XMLDesc()
3965     finally:
3966         conn.close()
3967 def pool_start(name, **kwargs):
3968     conn = __get_conn(**kwargs)
3969     try:
3970         pool = conn.storagePoolLookupByName(name)
3971         return not bool(pool.create())
3972     finally:
3973         conn.close()
3974 def pool_build(name, **kwargs):
3975     conn = __get_conn(**kwargs)
3976     try:
3977         pool = conn.storagePoolLookupByName(name)
3978         return not bool(pool.build())
3979     finally:
3980         conn.close()
3981 def pool_stop(name, **kwargs):
3982     conn = __get_conn(**kwargs)
3983     try:
3984         pool = conn.storagePoolLookupByName(name)
3985         return not bool(pool.destroy())
3986     finally:
3987         conn.close()
3988 def pool_undefine(name, **kwargs):
3989     conn = __get_conn(**kwargs)
3990     try:
3991         pool = conn.storagePoolLookupByName(name)
3992         desc = ElementTree.fromstring(pool.XMLDesc())
3993         auth_node = desc.find("source/auth")
3994         if auth_node is not None:
3995             auth_types = {
3996                 "ceph": libvirt.VIR_SECRET_USAGE_TYPE_CEPH,
3997                 "iscsi": libvirt.VIR_SECRET_USAGE_TYPE_ISCSI,
3998             }
3999             secret_type = auth_types[auth_node.get("type")]
4000             secret_usage = auth_node.find("secret").get("usage")
4001             if secret_type and "pool_{}".format(name) == secret_usage:
4002                 secret = conn.secretLookupByUsage(secret_type, secret_usage)
4003                 secret.undefine()
4004         return not bool(pool.undefine())
4005     finally:
4006         conn.close()
4007 def pool_delete(name, **kwargs):
4008     conn = __get_conn(**kwargs)
4009     try:
4010         pool = conn.storagePoolLookupByName(name)
4011         return not bool(pool.delete(libvirt.VIR_STORAGE_POOL_DELETE_NORMAL))
4012     finally:
4013         conn.close()
4014 def pool_refresh(name, **kwargs):
4015     conn = __get_conn(**kwargs)
4016     try:
4017         pool = conn.storagePoolLookupByName(name)
4018         return not bool(pool.refresh())
4019     finally:
4020         conn.close()
4021 def pool_set_autostart(name, state="on", **kwargs):
4022     conn = __get_conn(**kwargs)
4023     try:
4024         pool = conn.storagePoolLookupByName(name)
4025         return not bool(pool.setAutostart(1 if state == "on" else 0))
4026     finally:
4027         conn.close()
4028 def pool_list_volumes(name, **kwargs):
4029     conn = __get_conn(**kwargs)
4030     try:
4031         pool = conn.storagePoolLookupByName(name)
4032         return pool.listVolumes()
4033     finally:
4034         conn.close()
4035 def _get_storage_vol(conn, pool, vol):
4036     pool_obj = conn.storagePoolLookupByName(pool)
4037     return pool_obj.storageVolLookupByName(vol)
4038 def _is_valid_volume(vol):
4039     try:
4040         def discarder(ctxt, error):  # pylint: disable=unused-argument
4041             log.debug("Ignore libvirt error: %s", error[2])
4042         libvirt.registerErrorHandler(discarder, None)
4043         vol.info()
4044         libvirt.registerErrorHandler(None, None)
4045         return True
4046     except libvirt.libvirtError as err:
4047         return False
4048 def _get_all_volumes_paths(conn):
4049     pools = [
4050         pool
4051         for pool in conn.listAllStoragePools()
4052         if pool.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
4053     ]
4054 <a name="11"></a>    volumes = {}
4055     for pool in pools:
4056         pool_volumes = {
4057             volume<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.path(): {
4058                 "pool": pool.name(),
4059                 "name": volume.name(),
4060                 "backing_stores": [
4061                     path.text
4062                     for path in ElementTree.fromstring(volume.XMLDesc()).</b></font>findall(
4063                         ".//backingStore/path"
4064                     )
4065                 ],
4066             }
4067             for volume in pool.listAllVolumes()
4068             if _is_valid_volume(volume)
4069         }
4070         volumes.update(pool_volumes)
4071     return volumes
4072 def volume_infos(pool=None, volume=None, **kwargs):
4073     result = {}
4074     conn = __get_conn(**kwargs)
4075     try:
4076         backing_stores = _get_all_volumes_paths(conn)
4077         try:
4078             domains = _get_domain(conn)
4079             domains_list = domains if isinstance(domains, list) else [domains]
4080         except CommandExecutionError:
4081             domains_list = []
4082         disks = {
4083             domain.name(): {
4084                 node.get("file")
4085                 for node in ElementTree.fromstring(domain.XMLDesc(0)).findall(
4086                     ".//disk/source/[@file]"
4087                 )
4088             }
4089             for domain in domains_list
4090         }
4091         def _volume_extract_infos(vol):
4092             types = ["file", "block", "dir", "network", "netdir", "ploop"]
4093             infos = vol.info()
4094             vol_xml = ElementTree.fromstring(vol.XMLDesc())
4095             backing_store_path = vol_xml.find("./backingStore/path")
4096             backing_store_format = vol_xml.find("./backingStore/format")
4097             backing_store = None
4098             if backing_store_path is not None:
4099                 backing_store = {
4100                     "path": backing_store_path.text,
4101                     "format": backing_store_format.get("type")
4102                     if backing_store_format is not None
4103                     else None,
4104                 }
4105             format_node = vol_xml.find("./target/format")
4106             used_by = []
4107             if vol.path():
4108                 as_backing_store = {
4109                     path
4110                     for (path, volume) in backing_stores.items()
4111                     if vol.path() in volume.get("backing_stores")
4112                 }
4113                 used_by = [
4114                     vm_name
4115                     for (vm_name, vm_disks) in disks.items()
4116                     if vm_disks &amp; as_backing_store or vol.path() in vm_disks
4117                 ]
4118             return {
4119                 "type": types[infos[0]] if infos[0] &lt; len(types) else "unknown",
4120                 "key": vol.key(),
4121                 "path": vol.path(),
4122                 "capacity": infos[1],
4123                 "allocation": infos[2],
4124                 "used_by": used_by,
4125                 "backing_store": backing_store,
4126                 "format": format_node.get("type") if format_node is not None else None,
4127             }
4128         pools = [
4129             obj
4130             for obj in conn.listAllStoragePools()
4131             if (pool is None or obj.name() == pool)
4132             and obj.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
4133         ]
4134         vols = {
4135             pool_obj.name(): {
4136                 vol.name(): _volume_extract_infos(vol)
4137                 for vol in pool_obj.listAllVolumes()
4138                 if (volume is None or vol.name() == volume) and _is_valid_volume(vol)
4139             }
4140             for pool_obj in pools
4141         }
4142         return {pool_name: volumes for (pool_name, volumes) in vols.items() if volumes}
4143     except libvirt.libvirtError as err:
4144         log.debug("Silenced libvirt error: %s", err)
4145     finally:
4146         conn.close()
4147     return result
4148 def volume_delete(pool, volume, **kwargs):
4149     conn = __get_conn(**kwargs)
4150     try:
4151         vol = _get_storage_vol(conn, pool, volume)
4152         return not bool(vol.delete())
4153     finally:
4154         conn.close()
4155 def volume_define(
4156     pool,
4157     name,
4158     size,
4159     allocation=0,
4160     format=None,
4161     type=None,
4162     permissions=None,
4163     backing_store=None,
4164     nocow=False,
4165     **kwargs
4166 ):
4167     ret = False
4168     try:
4169         conn = __get_conn(**kwargs)
4170         pool_obj = conn.storagePoolLookupByName(pool)
4171         pool_type = ElementTree.fromstring(pool_obj.XMLDesc()).get("type")
4172         new_allocation = allocation
4173         if pool_type == "logical" and size != allocation:
4174             new_allocation = size
4175         xml = _gen_vol_xml(
4176             name,
4177             size,
4178             format=format,
4179             allocation=new_allocation,
4180             type=type,
4181             permissions=permissions,
4182             backing_store=backing_store,
4183             nocow=nocow,
4184         )
4185         ret = _define_vol_xml_str(conn, xml, pool=pool)
4186     except libvirt.libvirtError as err:
4187         raise CommandExecutionError(err.get_error_message())
4188     finally:
4189         conn.close()
4190     return ret
4191 def _volume_upload(conn, pool, volume, file, offset=0, length=0, sparse=False):
4192     def handler(stream, nbytes, opaque):
4193         return os.read(opaque, nbytes)
4194     def holeHandler(stream, opaque):
4195         fd = opaque
4196         cur = os.lseek(fd, 0, os.SEEK_CUR)
4197         try:
4198             data = os.lseek(fd, cur, os.SEEK_DATA)
4199         except OSError as e:
4200             if e.errno != 6:
4201                 raise e
4202             else:
4203                 data = -1
4204         if data &lt; 0:
4205             inData = False
4206             eof = os.lseek(fd, 0, os.SEEK_END)
4207             if eof &lt; cur:
4208                 raise RuntimeError("Current position in file after EOF: {}".format(cur))
4209             sectionLen = eof - cur
4210         else:
4211             if data &gt; cur:
4212                 inData = False
4213                 sectionLen = data - cur
4214             else:
4215                 inData = True
4216                 hole = os.lseek(fd, data, os.SEEK_HOLE)
4217                 if hole &lt; 0:
4218                     raise RuntimeError("No trailing hole")
4219                 if hole == data:
4220                     raise RuntimeError("Impossible happened")
4221                 else:
4222                     sectionLen = hole - data
4223         os.lseek(fd, cur, os.SEEK_SET)
4224         return [inData, sectionLen]
4225     def skipHandler(stream, length, opaque):
4226         return os.lseek(opaque, length, os.SEEK_CUR)
4227     stream = None
4228     fd = None
4229     ret = False
4230     try:
4231         pool_obj = conn.storagePoolLookupByName(pool)
4232         vol_obj = pool_obj.storageVolLookupByName(volume)
4233         stream = conn.newStream()
4234         fd = os.open(file, os.O_RDONLY)
4235         vol_obj.upload(
4236             stream,
4237             offset,
4238             length,
4239             libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM if sparse else 0,
4240         )
4241         if sparse:
4242             stream.sparseSendAll(handler, holeHandler, skipHandler, fd)
4243         else:
4244             stream.sendAll(handler, fd)
4245         ret = True
4246     except libvirt.libvirtError as err:
4247         raise CommandExecutionError(err.get_error_message())
4248     finally:
4249         if fd:
4250             try:
4251                 os.close(fd)
4252             except OSError as err:
4253                 if stream:
4254                     stream.abort()
4255                 if ret:
4256                     raise CommandExecutionError(
4257                         "Failed to close file: {}".format(err.strerror)
4258                     )
4259         if stream:
4260             try:
4261                 stream.finish()
4262             except libvirt.libvirtError as err:
4263                 if ret:
4264                     raise CommandExecutionError(
4265                         "Failed to finish stream: {}".format(err.get_error_message())
4266                     )
4267     return ret
4268 def volume_upload(pool, volume, file, offset=0, length=0, sparse=False, **kwargs):
4269     conn = __get_conn(**kwargs)
4270     ret = False
4271     try:
4272         ret = _volume_upload(
4273             conn, pool, volume, file, offset=offset, length=length, sparse=sparse
4274         )
4275     finally:
4276         conn.close()
4277     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
