<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for test_zpool.py &amp; test_snapper.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_zpool.py &amp; test_snapper.py
      </h3>
<h1 align="center">
        6.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_zpool.py (7.4394464%)<th>test_snapper.py (5.5198975%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(360-382)<td><a href="#" name="0">(90-176)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(464-486)<td><a href="#" name="1">(21-85)</a><td align="center"><font color="#c90000">19</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zpool.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Tests for salt.states.zpool

:codeauthor:    Jorge Schrauwen &lt;sjorge@blackdot.be&gt;
:maintainer:    Jorge Schrauwen &lt;sjorge@blackdot.be&gt;
:maturity:      new
:depends:       salt.utils.zfs, salt.modules.zpool
:platform:      illumos,freebsd,linux
"""

import pytest
import salt.config
import salt.loader
import salt.states.zpool as zpool
import salt.utils.zfs
from salt.utils.odict import OrderedDict
from tests.support.mock import MagicMock, patch
from tests.support.zfs import ZFSMockData


@pytest.fixture
def utils_patch():
    return ZFSMockData().get_patched_utils()


@pytest.fixture
def configure_loader_modules():
    opts = salt.config.DEFAULT_MINION_OPTS.copy()
    utils = salt.loader.utils(opts, whitelist=["zfs"])
    zpool_obj = {
        zpool: {
            "__opts__": opts,
            "__grains__": {"kernel": "SunOS"},
            "__utils__": utils,
        }
    }

    return zpool_obj


def test_absent_without_pool(utils_patch):
    """
    Test zpool absent without a pool
    """
    ret = {
        "name": "myzpool",
        "result": True,
        "comment": "storage pool myzpool is absent",
        "changes": {},
    }

    mock_exists = MagicMock(return_value=False)
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__utils__, utils_patch
    ):
        assert zpool.absent("myzpool") == ret


def test_absent_destroy_pool(utils_patch):
    """
    Test zpool absent destroying pool
    """
    ret = {
        "name": "myzpool",
        "result": True,
        "comment": "storage pool myzpool was destroyed",
        "changes": {"myzpool": "destroyed"},
    }

    mock_exists = MagicMock(return_value=True)
    mock_destroy = MagicMock(return_value=OrderedDict([("destroyed", True)]))
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__salt__, {"zpool.destroy": mock_destroy}
    ), patch.dict(zpool.__utils__, utils_patch):
        assert zpool.absent("myzpool") == ret


def test_absent_exporty_pool(utils_patch):
    """
    Test zpool absent exporting pool
    """
    ret = {
        "name": "myzpool",
        "result": True,
        "comment": "storage pool myzpool was exported",
        "changes": {"myzpool": "exported"},
    }

    mock_exists = MagicMock(return_value=True)
    mock_destroy = MagicMock(return_value=OrderedDict([("exported", True)]))
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__salt__, {"zpool.export": mock_destroy}
    ), patch.dict(zpool.__utils__, utils_patch):
        assert zpool.absent("myzpool", export=True) == ret


def test_absent_busy(utils_patch):
    """
    Test zpool absent on a busy pool
    """
    ret = {
        "name": "myzpool",
        "result": False,
        "comment": "\n".join(
            [
                "cannot unmount '/myzpool': Device busy",
                "cannot export 'myzpool': pool is busy",
            ]
        ),
        "changes": {},
    }

    mock_exists = MagicMock(return_value=True)
    mock_destroy = MagicMock(
        return_value=OrderedDict(
            [
                ("exported", False),
                (
                    "error",
                    "\n".join(
                        [
                            "cannot unmount '/myzpool': Device busy",
                            "cannot export 'myzpool': pool is busy",
                        ]
                    ),
                ),
            ]
        )
    )
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__salt__, {"zpool.export": mock_destroy}
    ), patch.dict(zpool.__utils__, utils_patch):
        assert zpool.absent("myzpool", export=True) == ret


def test_present_import_success(utils_patch):
    """
    Test zpool present with import allowed and unimported pool
    """
    ret = {
        "name": "myzpool",
        "result": True,
        "comment": "storage pool myzpool was imported",
        "changes": {"myzpool": "imported"},
    }

    config = {
        "import": True,
    }

    mock_exists = MagicMock(return_value=False)
    mock_import = MagicMock(return_value=OrderedDict([("imported", True)]))
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__salt__, {"zpool.import": mock_import}
    ), patch.dict(zpool.__utils__, utils_patch):
        assert zpool.present("myzpool", config=config) == ret


def test_present_import_fail(utils_patch):
    """
    Test zpool present with import allowed and no unimported pool or layout
    """
    ret = {
        "name": "myzpool",
        "result": False,
        "comment": (
            "storage pool myzpool was not imported, no (valid) layout specified for"
            " creation"
        ),
        "changes": {},
    }

    config = {
        "import": True,
    }

    mock_exists = MagicMock(return_value=False)
    mock_import = MagicMock(return_value=OrderedDict([("imported", False)]))
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__salt__, {"zpool.import": mock_import}
    ), patch.dict(zpool.__utils__, utils_patch):
        assert zpool.present("myzpool", config=config) == ret


def test_present_create_success(utils_patch):
    """
    Test zpool present with non existing pool
    """
    ret = {
        "name": "myzpool",
        "result": True,
        "comment": "storage pool myzpool was created",
        "changes": {"myzpool": "created"},
    }

    config = {
        "import": False,
    }
    layout = [
        OrderedDict([("mirror", ["disk0", "disk1"])]),
        OrderedDict([("mirror", ["disk2", "disk3"])]),
    ]
    properties = {
        "autoexpand": True,
    }
    filesystem_properties = {
        "quota": "5G",
    }

    mock_exists = MagicMock(return_value=False)
    mock_create = MagicMock(
        return_value=OrderedDict(
            [
                ("created", True),
                (
                    "vdevs",
                    OrderedDict(
                        [
                            ("mirror-0", ["/dev/dsk/disk0", "/dev/dsk/disk1"]),
                            ("mirror-1", ["/dev/dsk/disk2", "/dev/dsk/disk3"]),
                        ]
                    ),
                ),
            ]
        )
    )
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__salt__, {"zpool.create": mock_create}
    ), patch.dict(zpool.__utils__, utils_patch):
        assert (
            zpool.present(
                "myzpool",
                config=config,
                layout=layout,
                properties=properties,
                filesystem_properties=filesystem_properties,
            )
            == ret
        )


def test_present_create_fail(utils_patch):
    """
    Test zpool present with non existing pool (without a layout)
    """
    ret = {
        "name": "myzpool",
        "result": False,
        "comment": (
            "storage pool myzpool was not imported, no (valid) layout specified for"
            " creation"
        ),
        "changes": {},
    }

    config = {
        "import": False,
    }

    mock_exists = MagicMock(return_value=False)
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__utils__, utils_patch
    ):
        assert zpool.present("myzpool", config=config) == ret


def test_present_create_passthrough_fail(utils_patch):
    """
    Test zpool present with non existing pool (without a layout)
    """
    ret = {
        "name": "myzpool",
        "result": False,
        "comment": "\n".join(
            [
                "invalid vdev specification",
                "use 'force=True' to override the following errors:",
                "/data/salt/vdisk0 is part of exported pool 'zsalt'",
                "/data/salt/vdisk1 is part of exported pool 'zsalt'",
            ]
        ),
        "changes": {},
    }

    config = {
        "force": False,
        "import": False,
    }
    layout = [
        OrderedDict([("mirror", ["disk0", "disk1"])]),
        OrderedDict([("mirror", ["disk2", "disk3"])]),
    ]
    properties = {
        "autoexpand": True,
    }
    filesystem_properties = {
        "quota": "5G",
    }

    mock_exists = MagicMock(return_value=False)
    mock_create = MagicMock(
        return_value=OrderedDict(
            [
                ("created", False),
                (
                    "error",
                    "\n".join(
                        [
                            "invalid vdev specification",
                            "use 'force=True' to override the following errors:",
                            "/data/salt/vdisk0 is part of exported pool 'zsalt'",
                            "/data/salt/vdisk1 is part of exported pool 'zsalt'",
                        ]
                    ),
                ),
            ]
        )
    )
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__salt__, {"zpool.create": mock_create}
    ), patch.dict(zpool.__utils__, utils_patch):
        assert (
            zpool.present(
                "myzpool",
                config=config,
                layout=layout,
                properties=properties,
                filesystem_properties=filesystem_properties,
            )
            == ret
        )


def test_present_update_success(utils_patch):
    """
    Test zpool present with an existing pool that needs an update
    """
    ret = {
        "name": "myzpool",
        "result": True,
        "comment": "properties updated",
        "changes": {"myzpool": {"autoexpand": False}},
    }

    config = {
        "import": False,
    }
    layout = [
        OrderedDict([("mirror", ["disk0", "disk1"])]),
        OrderedDict([("mirror", ["disk2", "disk3"])]),
    ]
    properties = {
        "autoexpand": False,
    }

    mock_exists = MagicMock(return_value=True)
<a name="0"></a>    mock_get = MagicMock(
        return_value=OrderedDict(
            [
                <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("comment", "salt managed pool"),
                ("freeing", 0),
                ("listsnapshots", False),
                ("leaked", 0),
                ("feature@obsolete_counts", "enabled"),
                ("feature@sha512", "enabled"),
                ("delegation", True),
                ("dedupditto", "0"),
                ("dedupratio", "1.00x"),
                ("autoexpand", True),
                ("feature@bookmarks", "enabled"),
                ("allocated", 115712),
                ("guid", 1591906802560842214),
                ("feature@large_blocks", "enabled"),
                ("size", 2113929216),
                ("feature@enabled_txg", "active"),
                ("feature@hole_birth", "active"),
                ("capacity", 0),
                ("feature@multi_vdev_crash_dump", "enabled"),
                ("feature@extensible_dataset", "enabled"),
                ("cachefile", "-"),
                ("bootfs", "-"),
                ("autoreplace"</b></font>, True),
                ("readonly", False),
                ("version", "-"),
                ("health", "ONLINE"),
                ("expandsize", "-"),
                ("feature@embedded_data", "active"),
                ("feature@lz4_compress", "active"),
                ("feature@async_destroy", "enabled"),
                ("feature@skein", "enabled"),
                ("feature@empty_bpobj", "enabled"),
                ("feature@spacemap_histogram", "active"),
                ("bootsize", "-"),
                ("free", 2113813504),
                ("feature@device_removal", "enabled"),
                ("failmode", "wait"),
                ("feature@filesystem_limits", "enabled"),
                ("feature@edonr", "enabled"),
                ("altroot", "-"),
                ("fragmentation", "0%"),
            ]
        )
    )
    mock_set = MagicMock(return_value=OrderedDict([("set", True)]))
    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}), patch.dict(
        zpool.__salt__, {"zpool.get": mock_get}
    ), patch.dict(zpool.__salt__, {"zpool.set": mock_set}), patch.dict(
        zpool.__utils__, utils_patch
    ):
        assert (
            zpool.present(
                "myzpool",
                config=config,
                layout=layout,
                properties=properties,
            )
            == ret
        )


def test_present_update_nochange_success(utils_patch):
    """
    Test zpool present with non existing pool
    """
    config = {
        "import": False,
    }
    layout = [
        OrderedDict([("mirror", ["disk0", "disk1"])]),
        OrderedDict([("mirror", ["disk2", "disk3"])]),
    ]
    properties = {
        "autoexpand": True,
    }

    mock_exists = MagicMock(return_value=True)
    mock_get = MagicMock(
        return_value=OrderedDict(
            [
                ("comment", "salt managed pool"),
                ("freeing", 0),
                ("listsnapshots", False),
                ("leaked", 0),
                ("feature@obsolete_counts", "enabled"),
                ("feature@sha512", "enabled"),
                ("delegation", True),
                ("dedupditto", "0"),
                ("dedupratio", "1.00x"),
                ("autoexpand", True),
                ("feature@bookmarks", "enabled"),
                ("allocated", 115712),
                ("guid", 1591906802560842214),
                ("feature@large_blocks", "enabled"),
                ("size", 2113929216),
                ("feature@enabled_txg", "active"),
                ("feature@hole_birth", "active"),
                ("capacity", 0),
                ("feature@multi_vdev_crash_dump", "enabled"),
                ("feature@extensible_dataset", "enabled"),
                ("cachefile", "-"),
<a name="1"></a>                ("bootfs", "-"),
                ("autoreplace", True),
                ("readonly", False),
                (<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"version", "-"),
                ("health", "ONLINE"),
                ("expandsize", "-"),
                ("feature@embedded_data", "active"),
                ("feature@lz4_compress", "active"),
                ("feature@async_destroy", "enabled"),
                ("feature@skein", "enabled"),
                ("feature@empty_bpobj", "enabled"),
                ("feature@spacemap_histogram", "active"),
                ("bootsize", "-"),
                ("free", 2113813504),
                ("feature@device_removal", "enabled"),
                ("failmode", "wait"),
                ("feature@filesystem_limits", "enabled"),
                ("feature@edonr", "enabled"),
                ("altroot", "-"),
                ("fragmentation", "0%"),
            ]
        )
    )

    ret = {
        "name"</b></font>: "myzpool",
        "result": True,
        "comment": "no update needed",
        "changes": {},
    }

    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}):
        with patch.dict(zpool.__salt__, {"zpool.get": mock_get}):
            with patch.dict(zpool.__utils__, utils_patch):
                assert (
                    zpool.present(
                        "myzpool",
                        config=config,
                        layout=layout,
                        properties=properties,
                    )
                    == ret
                )

    # Run state with test=true
    ret = {
        "name": "myzpool",
        "result": True,
        "comment": "storage pool myzpool is uptodate",
        "changes": {},
    }

    with patch.dict(zpool.__salt__, {"zpool.exists": mock_exists}):
        with patch.dict(zpool.__salt__, {"zpool.get": mock_get}):
            with patch.dict(zpool.__utils__, utils_patch):
                with patch.dict(zpool.__opts__, {"test": True}):
                    assert (
                        zpool.present(
                            "myzpool",
                            config=config,
                            layout=layout,
                            properties=properties,
                        )
                        == ret
                    )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_snapper.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Unit tests for the Snapper module

:codeauthor:    Duncan Mac-Vicar P. &lt;dmacvicar@suse.de&gt;
:codeauthor:    Pablo Suárez Hernández &lt;psuarezhernandez@suse.de&gt;
"""


import sys

import salt.modules.snapper as snapper
import salt.utils.files
import salt.utils.platform
from salt.exceptions import CommandExecutionError
from tests.support.helpers import with_tempfile
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, mock_open, patch
<a name="1"></a>from tests.support.unit import TestCase, skipIf

DBUS_RET = {
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"ListSnapshots": [
        [
            42,
            1,
            0,
            1457006571,
            0,
            "Some description",
            "",
            {"userdata1": "userval1", "salt_jid": "20160607130930720112"},
        ],
        [
            43,
            2,
            42,
            1457006572,
            0,
            "Blah Blah",
            "",
            {"userdata2": "userval2", "salt_jid": "20160607130930720112"},
        ],
    ],
    "ListConfigs": [
        [
            "root",
            "/",
            {
                "SUBVOLUME": "/",
                "NUMBER_MIN_AGE": "1800",
                "TIMELINE_LIMIT_YEARLY": "4-10",
                "NUMBER_LIMIT_IMPORTANT": "10",
                "FSTYPE": "btrfs",
                "TIMELINE_LIMIT_MONTHLY": "4-10",
                "ALLOW_GROUPS": "",
                "EMPTY_PRE_POST_MIN_AGE": "1800",
                "EMPTY_PRE_POST_CLEANUP": "yes",
                "BACKGROUND_COMPARISON": "yes",
                "TIMELINE_LIMIT_HOURLY": "4-10",
                "ALLOW_USERS": "",
                "TIMELINE_LIMIT_WEEKLY": "0",
                "TIMELINE_CREATE": "no",
                "NUMBER_CLEANUP": "yes",
                "TIMELINE_CLEANUP": "yes",
                "SPACE_LIMIT": "0.5",
                "NUMBER_LIMIT": "10",
                "TIMELINE_MIN_AGE": "1800",
                "TIMELINE_LIMIT_DAILY": "4-10",
                "SYNC_ACL": "no",
                "QGROUP": "1/0",
            },
        ]
    ],
    "GetFiles": [
        ["/root/.viminfo", 8],
        ["/tmp/foo", 52],
        ["/tmp/foo2", 1],
        ["/tmp/foo3", 2],
        ["/var/log/snapper.log", 8],
        ["/var/cache/salt/minion/extmods/modules/snapper.py", 8],
        ["/var/cache/salt/minion/extmods/modules/snapper.pyc", 8],
    ],
}

FILE_CONTENT = {
    "/tmp/foo"</b></font>: {"pre": "dummy text", "post": "another foobar"},
    "/tmp/foo2": {"post": "another foobar"},
<a name="0"></a>}

MODULE_RET = {
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"SNAPSHOTS": [
        {
            "userdata": {"userdata1": "userval1", "salt_jid": "20160607130930720112"},
            "description": "Some description",
            "timestamp": 1457006571,
            "cleanup": "",
            "user": "root",
            "type": "pre",
            "id": 42,
        },
        {
            "pre": 42,
            "userdata": {"userdata2": "userval2", "salt_jid": "20160607130930720112"},
            "description": "Blah Blah",
            "timestamp": 1457006572,
            "cleanup": "",
            "user": "root",
            "type": "post",
            "id": 43,
        },
    ],
    "LISTCONFIGS": {
        "root": {
            "SUBVOLUME": "/",
            "NUMBER_MIN_AGE": "1800",
            "TIMELINE_LIMIT_YEARLY": "4-10",
            "NUMBER_LIMIT_IMPORTANT": "10",
            "FSTYPE": "btrfs",
            "TIMELINE_LIMIT_MONTHLY": "4-10",
            "ALLOW_GROUPS": "",
            "EMPTY_PRE_POST_MIN_AGE": "1800",
            "EMPTY_PRE_POST_CLEANUP": "yes",
            "BACKGROUND_COMPARISON": "yes",
            "TIMELINE_LIMIT_HOURLY": "4-10",
            "ALLOW_USERS": "",
            "TIMELINE_LIMIT_WEEKLY": "0",
            "TIMELINE_CREATE": "no",
            "NUMBER_CLEANUP": "yes",
            "TIMELINE_CLEANUP": "yes",
            "SPACE_LIMIT": "0.5",
            "NUMBER_LIMIT": "10",
            "TIMELINE_MIN_AGE": "1800",
            "TIMELINE_LIMIT_DAILY": "4-10",
            "SYNC_ACL": "no",
            "QGROUP": "1/0",
        }
    },
    "GETFILES": {
        "/root/.viminfo": {"status": ["modified"]},
        "/tmp/foo": {"status": ["type changed", "permission changed", "owner changed"]},
        "/tmp/foo2": {"status": ["created"]},
        "/tmp/foo3": {"status": ["deleted"]},
        "/var/log/snapper.log": {"status": ["modified"]},
        "/var/cache/salt/minion/extmods/modules/snapper.py": {"status": ["modified"]},
        "/var/cache/salt/minion/extmods/modules/snapper.pyc": {"status": ["modified"]},
    },
    "DIFF": {
        "/tmp/foo": {
            "comment": "text file changed",
            "diff": (
                "--- /.snapshots/55/snapshot/tmp/foo\n"
                "+++ /tmp/foo\n"
                "@@ -1 +1 @@\n"
                "-dummy text"
                "+another foobar"
            ),
        },
        "/tmp/foo2": {
            "comment": "text file created",
            "diff": (
                "--- /.snapshots/55/snapshot/tmp/foo2\n"
                "+++ /tmp/foo2\n"
                "@@ -0,0 +1 @@\n"
                "+another foobar"
            ),
        },
        "/tmp/foo26": {
            "comment": "text file created",
            "diff": (
                "--- /.snapshots/55/snapshot/tmp/foo2 \n"
                "+++ /tmp/foo2 \n"
                "@@ -1,0 +1,1 @@\n"
                "+another foobar"
            ),
        },
        "/tmp/foo3": {
            "comment"</b></font>: "binary file changed",
            "old_sha256_digest": (
                "e61f8b762d83f3b4aeb3689564b0ffbe54fa731a69a1e208dc9440ce0f69d19b"
            ),
            "new_sha256_digest": (
                "f18f971f1517449208a66589085ddd3723f7f6cefb56c141e3d97ae49e1d87fa"
            ),
        },
    },
}


@skipIf(sys.platform.startswith("win"), "Snapper not available on Windows")
class SnapperTestCase(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        class DBusException(BaseException):
            get_dbus_name = "foo"

        dbus_mock = MagicMock()
        dbus_mock.configure_mock(DBusException=DBusException)
        return {snapper: {"dbus": dbus_mock, "snapper": MagicMock()}}

    def test__snapshot_to_data(self):
        data = snapper._snapshot_to_data(
            DBUS_RET["ListSnapshots"][0]
        )  # pylint: disable=protected-access
        self.assertEqual(data["id"], 42)
        self.assertNotIn("pre", data)
        self.assertEqual(data["type"], "pre")
        self.assertEqual(data["user"], "root")
        self.assertEqual(data["timestamp"], 1457006571)
        self.assertEqual(data["description"], "Some description")
        self.assertEqual(data["cleanup"], "")
        self.assertEqual(data["userdata"]["userdata1"], "userval1")

    def test_list_snapshots(self):
        with patch(
            "salt.modules.snapper.snapper.ListSnapshots",
            MagicMock(return_value=DBUS_RET["ListSnapshots"]),
        ):
            self.assertEqual(snapper.list_snapshots(), MODULE_RET["SNAPSHOTS"])

    def test_get_snapshot(self):
        with patch(
            "salt.modules.snapper.snapper.GetSnapshot",
            MagicMock(return_value=DBUS_RET["ListSnapshots"][0]),
        ):
            self.assertEqual(snapper.get_snapshot(), MODULE_RET["SNAPSHOTS"][0])
            self.assertEqual(
                snapper.get_snapshot(number=42), MODULE_RET["SNAPSHOTS"][0]
            )
            self.assertNotEqual(
                snapper.get_snapshot(number=42), MODULE_RET["SNAPSHOTS"][1]
            )

    def test_list_configs(self):
        with patch(
            "salt.modules.snapper.snapper.ListConfigs",
            MagicMock(return_value=DBUS_RET["ListConfigs"]),
        ):
            self.assertEqual(snapper.list_configs(), MODULE_RET["LISTCONFIGS"])

    def test_get_config(self):
        with patch(
            "salt.modules.snapper.snapper.GetConfig",
            MagicMock(return_value=DBUS_RET["ListConfigs"][0]),
        ):
            self.assertEqual(snapper.get_config(), DBUS_RET["ListConfigs"][0])

    def test_set_config(self):
        with patch("salt.modules.snapper.snapper.SetConfig", MagicMock()):
            opts = {"sync_acl": True, "dummy": False, "foobar": 1234}
            self.assertEqual(snapper.set_config(opts), True)

    def test_status_to_string(self):
        self.assertEqual(snapper.status_to_string(1), ["created"])
        self.assertEqual(snapper.status_to_string(2), ["deleted"])
        self.assertEqual(snapper.status_to_string(4), ["type changed"])
        self.assertEqual(snapper.status_to_string(8), ["modified"])
        self.assertEqual(snapper.status_to_string(16), ["permission changed"])
        self.assertListEqual(
            snapper.status_to_string(24), ["modified", "permission changed"]
        )
        self.assertEqual(snapper.status_to_string(32), ["owner changed"])
        self.assertEqual(snapper.status_to_string(64), ["group changed"])
        self.assertListEqual(
            snapper.status_to_string(97), ["created", "owner changed", "group changed"]
        )
        self.assertEqual(snapper.status_to_string(128), ["extended attributes changed"])
        self.assertEqual(snapper.status_to_string(256), ["ACL info changed"])

    def test_create_config(self):
        with patch("salt.modules.snapper.snapper.CreateConfig", MagicMock()), patch(
            "salt.modules.snapper.snapper.GetConfig",
            MagicMock(return_value=DBUS_RET["ListConfigs"][0]),
        ):
            opts = {
                "name": "testconfig",
                "subvolume": "/foo/bar/",
                "fstype": "btrfs",
                "template": "mytemplate",
                "extra_opts": {"NUMBER_CLEANUP": False},
            }
            with patch(
                "salt.modules.snapper.set_config", MagicMock()
            ) as set_config_mock:
                self.assertEqual(
                    snapper.create_config(**opts), DBUS_RET["ListConfigs"][0]
                )
                set_config_mock.assert_called_with("testconfig", **opts["extra_opts"])

            with patch(
                "salt.modules.snapper.set_config", MagicMock()
            ) as set_config_mock:
                del opts["extra_opts"]
                self.assertEqual(
                    snapper.create_config(**opts), DBUS_RET["ListConfigs"][0]
                )
                assert not set_config_mock.called
                self.assertRaises(CommandExecutionError, snapper.create_config)

    def test_create_snapshot(self):
        with patch(
            "salt.modules.snapper.snapper.CreateSingleSnapshot",
            MagicMock(return_value=1234),
        ), patch(
            "salt.modules.snapper.snapper.CreatePreSnapshot",
            MagicMock(return_value=1234),
        ), patch(
            "salt.modules.snapper.snapper.CreatePostSnapshot",
            MagicMock(return_value=1234),
        ):
            for snapshot_type in ["pre", "post", "single"]:
                opts = {
                    "__pub_jid": 20160607130930720112,
                    "type": snapshot_type,
                    "description": "Test description",
                    "cleanup_algorithm": "number",
                    "pre_number": 23,
                }
                self.assertEqual(snapper.create_snapshot(**opts), 1234)

    def test_delete_snapshot_id_success(self):
        with patch("salt.modules.snapper.snapper.DeleteSnapshots", MagicMock()), patch(
            "salt.modules.snapper.snapper.ListSnapshots",
            MagicMock(return_value=DBUS_RET["ListSnapshots"]),
        ):
            self.assertEqual(
                snapper.delete_snapshot(snapshots_ids=43),
                {"root": {"ids": [43], "status": "deleted"}},
            )
            self.assertEqual(
                snapper.delete_snapshot(snapshots_ids=[42, 43]),
                {"root": {"ids": [42, 43], "status": "deleted"}},
            )

    def test_delete_snapshot_id_fail(self):
        with patch("salt.modules.snapper.snapper.DeleteSnapshots", MagicMock()), patch(
            "salt.modules.snapper.snapper.ListSnapshots",
            MagicMock(return_value=DBUS_RET["ListSnapshots"]),
        ):
            self.assertRaises(CommandExecutionError, snapper.delete_snapshot)
            self.assertRaises(
                CommandExecutionError, snapper.delete_snapshot, snapshots_ids=1
            )
            self.assertRaises(
                CommandExecutionError, snapper.delete_snapshot, snapshots_ids=[1, 2]
            )

    def test_modify_snapshot(self):
        with patch("salt.modules.snapper.snapper.SetSnapshot", MagicMock()):
            _ret = {
                "userdata": {"userdata2": "uservalue2"},
                "description": "UPDATED DESCRIPTION",
                "timestamp": 1457006571,
                "cleanup": "number",
                "user": "root",
                "type": "pre",
                "id": 42,
            }
            _opts = {
                "config": "root",
                "snapshot_id": 42,
                "cleanup": "number",
                "description": "UPDATED DESCRIPTION",
                "userdata": {"userdata2": "uservalue2"},
            }
            with patch(
                "salt.modules.snapper.get_snapshot",
                MagicMock(side_effect=[DBUS_RET["ListSnapshots"][0], _ret]),
            ):
                self.assertDictEqual(snapper.modify_snapshot(**_opts), _ret)

    def test__get_num_interval(self):
        with patch(
            "salt.modules.snapper._get_last_snapshot",
            MagicMock(return_value={"id": 42}),
        ):
            self.assertEqual(
                snapper._get_num_interval(config=None, num_pre=None, num_post=None),
                (42, 0),
            )  # pylint: disable=protected-access
            self.assertEqual(
                snapper._get_num_interval(config=None, num_pre=None, num_post=50),
                (42, 50),
            )  # pylint: disable=protected-access
            self.assertEqual(
                snapper._get_num_interval(config=None, num_pre=42, num_post=50),
                (42, 50),
            )  # pylint: disable=protected-access

    def test_run(self):
        patch_dict = {
            "snapper.create_snapshot": MagicMock(return_value=43),
            "test.ping": MagicMock(return_value=True),
        }
        with patch.dict(snapper.__salt__, patch_dict):
            self.assertEqual(snapper.run("test.ping"), True)
            self.assertRaises(CommandExecutionError, snapper.run, "unknown.func")

    def test_status(self):
        with patch(
            "salt.modules.snapper._get_num_interval", MagicMock(return_value=(42, 43))
        ), patch("salt.modules.snapper.snapper.GetComparison", MagicMock()), patch(
            "salt.modules.snapper.snapper.GetFiles",
            MagicMock(return_value=DBUS_RET["GetFiles"]),
        ), patch(
            "salt.modules.snapper.snapper.ListConfigs",
            MagicMock(return_value=DBUS_RET["ListConfigs"]),
        ):
            self.assertCountEqual(snapper.status(), MODULE_RET["GETFILES"])
            self.assertCountEqual(
                snapper.status(num_pre="42", num_post=43), MODULE_RET["GETFILES"]
            )
            self.assertCountEqual(snapper.status(num_pre=42), MODULE_RET["GETFILES"])
            self.assertCountEqual(snapper.status(num_post=43), MODULE_RET["GETFILES"])

    def test_changed_files(self):
        with patch(
            "salt.modules.snapper.status",
            MagicMock(return_value=MODULE_RET["GETFILES"]),
        ):
            self.assertEqual(snapper.changed_files(), MODULE_RET["GETFILES"].keys())

    def test_undo(self):
        with patch(
            "salt.modules.snapper._get_num_interval", MagicMock(return_value=(42, 43))
        ), patch(
            "salt.modules.snapper.status",
            MagicMock(return_value=MODULE_RET["GETFILES"]),
        ):
            cmd_ret = "create:0 modify:1 delete:0"
            with patch.dict(
                snapper.__salt__, {"cmd.run": MagicMock(return_value=cmd_ret)}
            ):
                module_ret = {"create": "0", "delete": "0", "modify": "1"}
                self.assertEqual(snapper.undo(files=["/tmp/foo"]), module_ret)

            cmd_ret = "create:1 modify:1 delete:0"
            with patch.dict(
                snapper.__salt__, {"cmd.run": MagicMock(return_value=cmd_ret)}
            ):
                module_ret = {"create": "1", "delete": "0", "modify": "1"}
                self.assertEqual(
                    snapper.undo(files=["/tmp/foo", "/tmp/foo2"]), module_ret
                )

            cmd_ret = "create:1 modify:1 delete:1"
            with patch.dict(
                snapper.__salt__, {"cmd.run": MagicMock(return_value=cmd_ret)}
            ):
                module_ret = {"create": "1", "delete": "1", "modify": "1"}
                self.assertEqual(
                    snapper.undo(files=["/tmp/foo", "/tmp/foo2", "/tmp/foo3"]),
                    module_ret,
                )

    def test__get_jid_snapshots(self):
        with patch(
            "salt.modules.snapper.list_snapshots",
            MagicMock(return_value=MODULE_RET["SNAPSHOTS"]),
        ):
            self.assertEqual(
                snapper._get_jid_snapshots(
                    "20160607130930720112"
                ),  # pylint: disable=protected-access
                (MODULE_RET["SNAPSHOTS"][0]["id"], MODULE_RET["SNAPSHOTS"][1]["id"]),
            )

    def test_undo_jid(self):
        with patch(
            "salt.modules.snapper._get_jid_snapshots", MagicMock(return_value=(42, 43))
        ), patch(
            "salt.modules.snapper.undo",
            MagicMock(return_value="create:1 modify:1 delete:1"),
        ):
            self.assertEqual(
                snapper.undo_jid(20160607130930720112), "create:1 modify:1 delete:1"
            )

    def test_diff_text_file(self):
        with patch(
            "salt.modules.snapper._get_num_interval", MagicMock(return_value=(42, 43))
        ), patch(
            "salt.modules.snapper.snapper.MountSnapshot",
            MagicMock(side_effect=["/.snapshots/55/snapshot", ""]),
        ), patch(
            "salt.modules.snapper.snapper.UmountSnapshot", MagicMock(return_value="")
        ), patch(
            "os.path.isdir", MagicMock(return_value=False)
        ), patch(
            "salt.modules.snapper.changed_files", MagicMock(return_value=["/tmp/foo2"])
        ), patch(
            "salt.modules.snapper._is_text_file", MagicMock(return_value=True)
        ), patch(
            "os.path.isfile", MagicMock(side_effect=[False, True])
        ), patch(
            "salt.utils.files.fopen",
            mock_open(read_data=FILE_CONTENT["/tmp/foo2"]["post"]),
        ), patch(
            "salt.modules.snapper.snapper.ListConfigs",
            MagicMock(return_value=DBUS_RET["ListConfigs"]),
        ):
            if sys.version_info &lt; (2, 7):
                self.assertEqual(
                    snapper.diff(), {"/tmp/foo2": MODULE_RET["DIFF"]["/tmp/foo26"]}
                )
            else:
                self.assertEqual(
                    snapper.diff(), {"/tmp/foo2": MODULE_RET["DIFF"]["/tmp/foo2"]}
                )

    @skipIf(sys.version_info &lt; (2, 7), "Python 2.7 required to compare diff properly")
    def test_diff_text_files(self):
        with patch(
            "salt.modules.snapper._get_num_interval", MagicMock(return_value=(55, 0))
        ), patch(
            "salt.modules.snapper.snapper.MountSnapshot",
            MagicMock(
                side_effect=[
                    "/.snapshots/55/snapshot",
                    "",
                    "/.snapshots/55/snapshot",
                    "",
                ]
            ),
        ), patch(
            "salt.modules.snapper.snapper.UmountSnapshot", MagicMock(return_value="")
        ), patch(
            "salt.modules.snapper.changed_files",
            MagicMock(return_value=["/tmp/foo", "/tmp/foo2"]),
        ), patch(
            "salt.modules.snapper._is_text_file", MagicMock(return_value=True)
        ), patch(
            "os.path.isfile", MagicMock(side_effect=[True, True, False, True])
        ), patch(
            "os.path.isdir", MagicMock(return_value=False)
        ), patch(
            "salt.modules.snapper.snapper.ListConfigs",
            MagicMock(return_value=DBUS_RET["ListConfigs"]),
        ):
            contents = {
                "*/tmp/foo": [
                    FILE_CONTENT["/tmp/foo"]["pre"],
                    FILE_CONTENT["/tmp/foo"]["post"],
                ],
                "*/tmp/foo2": FILE_CONTENT["/tmp/foo2"]["post"],
            }
            with patch("salt.utils.files.fopen", mock_open(read_data=contents)):
                module_ret = {
                    "/tmp/foo": MODULE_RET["DIFF"]["/tmp/foo"],
                    "/tmp/foo2": MODULE_RET["DIFF"]["/tmp/foo2"],
                }
                self.assertEqual(snapper.diff(), module_ret)

    def test_diff_binary_files(self):
        with patch(
            "salt.modules.snapper._get_num_interval", MagicMock(return_value=(55, 0))
        ), patch(
            "salt.modules.snapper.snapper.MountSnapshot",
            MagicMock(
                side_effect=[
                    "/.snapshots/55/snapshot",
                    "",
                    "/.snapshots/55/snapshot",
                    "",
                ]
            ),
        ), patch(
            "salt.modules.snapper.snapper.UmountSnapshot", MagicMock(return_value="")
        ), patch(
            "salt.modules.snapper.changed_files", MagicMock(return_value=["/tmp/foo3"])
        ), patch(
            "salt.modules.snapper._is_text_file", MagicMock(return_value=False)
        ), patch(
            "os.path.isfile", MagicMock(side_effect=[True, True])
        ), patch(
            "os.path.isdir", MagicMock(return_value=False)
        ), patch(
            "salt.modules.snapper.snapper.ListConfigs",
            MagicMock(return_value=DBUS_RET["ListConfigs"]),
        ), patch.dict(
            snapper.__salt__,
            {
                "hashutil.sha256_digest": MagicMock(
                    side_effect=[
                        "e61f8b762d83f3b4aeb3689564b0ffbe54fa731a69a1e208dc9440ce0f69d19b",
                        "f18f971f1517449208a66589085ddd3723f7f6cefb56c141e3d97ae49e1d87fa",
                    ]
                )
            },
        ):
            with patch("salt.utils.files.fopen", mock_open(read_data="dummy binary")):
                module_ret = {
                    "/tmp/foo3": MODULE_RET["DIFF"]["/tmp/foo3"],
                }
                self.assertEqual(snapper.diff(), module_ret)

    @skipIf(salt.utils.platform.is_linux() is False, "This is a linux only test")
    @with_tempfile()
    def test__is_text_file(self, tempfile):
        with salt.utils.files.fopen(tempfile, "w") as wfh:
            wfh.write(
                "Once upon a time there was an old Sow with three little Pigs, and "
                "as she had not enough to keep them, she sent them out to seek their "
                "fortune.\n"
            )
        assert snapper._is_text_file(tempfile) is True

        with salt.utils.files.fopen(tempfile, "wb") as wfh:
            wfh.write(
                b"C\x07\xd6\x13\xe5_\x99D\xeb\xd7v\xc1\x96p\x84\xd2{a\x03++\r\xcd/"
                b"\xdb\x98\xda\xf7H\xf8\xfb-\x95\xa9}|^\t\xddx\x1c\x18s\x1bZ\x86\x8a(S\xe4"
            )
        assert snapper._is_text_file(tempfile) is False
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
