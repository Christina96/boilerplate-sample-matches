
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-helper.py</h3>
            <pre><code>1  import asyncio
2  import math
3  import os
4  import re
5  import sys
6  import time
7  from traceback import format_exc
8  from urllib.parse import unquote
9  from urllib.request import urlretrieve
10  from .. import run_as_module
11  if run_as_module:
12      from ..configs import Var
13  try:
14      from aiohttp import ClientSession as aiohttp_client
15  except ImportError:
16      aiohttp_client = None
17      try:
18          import requests
19      except ImportError:
20          requests = None
21  try:
22      import heroku3
23  except ImportError:
24      heroku3 = None
25  try:
26      from git import Repo
27      from git.exc import GitCommandError, InvalidGitRepositoryError, NoSuchPathError
28  except ImportError:
29      Repo = None
30  import asyncio
31  import multiprocessing
32  from concurrent.futures import ThreadPoolExecutor
33  from functools import partial, wraps
34  from telethon.helpers import _maybe_await
35  from telethon.tl import types
36  from telethon.utils import get_display_name
37  from .._misc import CMD_HELP
38  from .._misc._wrappers import eod, eor
39  from ..exceptions import DependencyMissingError
40  from . import *
41  if run_as_module:
42      from ..dB._core import ADDONS, HELP, LIST, LOADED
43  from ..version import ultroid_version
44  from .FastTelethon import download_file as downloadable
45  from .FastTelethon import upload_file as uploadable
46  def run_async(function):
47      @wraps(function)
48      async def wrapper(*args, **kwargs):
49          return await asyncio.get_event_loop().run_in_executor(
50              ThreadPoolExecutor(max_workers=multiprocessing.cpu_count() * 5),
51              partial(function, *args, **kwargs),
52          )
53      return wrapper
54  def make_mention(user, custom=None):
55      if user.username:
56          return f&quot;@{user.username}&quot;
57      return inline_mention(user, custom=custom)
58  def inline_mention(user, custom=None, html=False):
59      mention_text = get_display_name(user) or &quot;Deleted Account&quot; if not custom else custom
60      if isinstance(user, types.User):
61          if html:
62              return f&quot;&lt;a href=tg://user?id={user.id}&gt;{mention_text}&lt;/a&gt;&quot;
63          return f&quot;[{mention_text}](tg://user?id={user.id})&quot;
64      if isinstance(user, types.Channel) and user.username:
65          if html:
66              return f&quot;&lt;a href=https://t.me/{user.username}&gt;{mention_text}&lt;/a&gt;&quot;
67          return f&quot;[{mention_text}](https://t.me/{user.username})&quot;
68      return mention_text
69  def un_plug(shortname):
70      from .. import asst, ultroid_bot
71      try:
72          all_func = LOADED[shortname]
73          for client in [ultroid_bot, asst]:
74              for x, _ in client.list_event_handlers():
75                  if x in all_func:
76                      client.remove_event_handler(x)
77          del LOADED[shortname]
78          del LIST[shortname]
79          ADDONS.remove(shortname)
80      except (ValueError, KeyError):
81          name = f&quot;addons.{shortname}&quot;
82          for client in [ultroid_bot, asst]:
83              for i in reversed(range(len(client._event_builders))):
84                  ev, cb = client._event_builders[i]
85                  if cb.__module__ == name:
86                      del client._event_builders[i]
87                      try:
88                          del LOADED[shortname]
89                          del LIST[shortname]
90                          ADDONS.remove(shortname)
91                      except KeyError:
92                          pass
93  if run_as_module:
94      async def safeinstall(event):
95          from .. import HNDLR
96          from ..startup.utils import load_addons
97          if not event.reply_to:
98              return await eod(
99                  event, f&quot;Please use `{HNDLR}install` as reply to a .py file.&quot;
100              )
101          ok = await eor(event, &quot;`Installing...`&quot;)
102          reply = await event.get_reply_message()
103          if not (
104              reply.media
105              and hasattr(reply.media, &quot;document&quot;)
106              and reply.file.name
107              and reply.file.name.endswith(&quot;.py&quot;)
108          ):
109              return await eod(ok, &quot;`Please reply to any python plugin`&quot;)
110          plug = reply.file.name.replace(&quot;.py&quot;, &quot;&quot;)
111          if plug in list(LOADED):
112              return await eod(ok, f&quot;Plugin `{plug}` is already installed.&quot;)
113          sm = reply.file.name.replace(&quot;_&quot;, &quot;-&quot;).replace(&quot;|&quot;, &quot;-&quot;)
114          dl = await reply.download_media(f&quot;addons/{sm}&quot;)
115          if event.text[9:] != &quot;f&quot;:
116              read = open(dl).read()
117              for dan in KEEP_SAFE().All:
118                  if re.search(dan, read):
119                      os.remove(dl)
120                      return await ok.edit(
121                          f&quot;**Installation Aborted.**\n**Reason:** Occurance of `{dan}` in `{reply.file.name}`.\n\nIf you trust the provider and/or know what you&#x27;re doing, use `{HNDLR}install f` to force install.&quot;,
122                      )
123          try:
124              load_addons(dl)  # dl.split(&quot;/&quot;)[-1].replace(&quot;.py&quot;, &quot;&quot;))
125          except BaseException:
126              os.remove(dl)
127              return await eor(ok, f&quot;**ERROR**\n\n`{format_exc()}`&quot;, time=30)
128          plug = sm.replace(&quot;.py&quot;, &quot;&quot;)
129          if plug in HELP:
130              output = &quot;**Plugin** - `{}`\n&quot;.format(plug)
131              for i in HELP[plug]:
132                  output += i
133              output += &quot;\n¬© @TeamUltroid&quot;
134              await eod(ok, f&quot;‚úì `Ultroid - Installed`: `{plug}` ‚úì\n\n{output}&quot;)
135          elif plug in CMD_HELP:
136              output = f&quot;Plugin Name-{plug}\n\n‚úò Commands Available-\n\n&quot;
137              output += str(CMD_HELP[plug])
138              await eod(ok, f&quot;‚úì `Ultroid - Installed`: `{plug}` ‚úì\n\n{output}&quot;)
139          else:
140              try:
141                  x = f&quot;Plugin Name-{plug}\n\n‚úò Commands Available-\n\n&quot;
142                  for d in LIST[plug]:
143                      x += HNDLR + d + &quot;\n&quot;
144                  await eod(ok, f&quot;‚úì `Ultroid - Installed`: `{plug}` ‚úì\n\n`{x}`&quot;)
145              except BaseException:
146                  await eod(ok, f&quot;‚úì `Ultroid - Installed`: `{plug}` ‚úì&quot;)
147      async def heroku_logs(event):
148          from .. import LOGS
149          xx = await eor(event, &quot;`Processing...`&quot;)
150          if not (Var.HEROKU_API and Var.HEROKU_APP_NAME):
151              return await xx.edit(
152                  &quot;Please set `HEROKU_APP_NAME` and `HEROKU_API` in vars.&quot;
153              )
154          try:
155              app = (heroku3.from_key(Var.HEROKU_API)).app(Var.HEROKU_APP_NAME)
156          except BaseException as se:
157              LOGS.info(se)
158              return await xx.edit(
159                  &quot;`HEROKU_API` and `HEROKU_APP_NAME` is wrong! Kindly re-check in config vars.&quot;
160              )
161          await xx.edit(&quot;`Downloading Logs...`&quot;)
162          ok = app.get_log()
163          with open(&quot;ultroid-heroku.log&quot;, &quot;w&quot;) as log:
164              log.write(ok)
165          await event.client.send_file(
166              event.chat_id,
167              file=&quot;ultroid-heroku.log&quot;,
168              thumb=ULTConfig.thumb,
169              caption=&quot;**Ultroid Heroku Logs.**&quot;,
170          )
171          os.remove(&quot;ultroid-heroku.log&quot;)
172          await xx.delete()
173      async def def_logs(ult, file):
174          await ult.respond(
175              &quot;**Ultroid Logs.**&quot;,
176              file=file,
177              thumb=ULTConfig.thumb,
178          )
179      async def updateme_requirements():
180          await bash(
181              f&quot;{sys.executable} -m pip install --no-cache-dir -r requirements.txt&quot;
182          )
183      @run_async
184      def gen_chlog(repo, diff):
185          UPSTREAM_REPO_URL = (
186              Repo().remotes[0].config_reader.get(&quot;url&quot;).replace(&quot;.git&quot;, &quot;&quot;)
187          )
188          ac_br = repo.active_branch.name
189          ch_log = tldr_log = &quot;&quot;
190          ch = f&quot;&lt;b&gt;Ultroid {ultroid_version} updates for &lt;a href={UPSTREAM_REPO_URL}/tree/{ac_br}&gt;[{ac_br}]&lt;/a&gt;:&lt;/b&gt;&quot;
191          ch_tl = f&quot;Ultroid {ultroid_version} updates for {ac_br}:&quot;
192          d_form = &quot;%d/%m/%y || %H:%M&quot;
193          for c in repo.iter_commits(diff):
194              ch_log += f&quot;\n\nüí¨ &lt;b&gt;{c.count()}&lt;/b&gt; üóì &lt;b&gt;[{c.committed_datetime.strftime(d_form)}]&lt;/b&gt;\n&lt;b&gt;&lt;a href={UPSTREAM_REPO_URL.rstrip(&#x27;/&#x27;)}/commit/{c}&gt;[{c.summary}]&lt;/a&gt;&lt;/b&gt; üë®‚Äçüíª &lt;code&gt;{c.author}&lt;/code&gt;&quot;
195              tldr_log += f&quot;\n\nüí¨ {c.count()} üóì [{c.committed_datetime.strftime(d_form)}]\n[{c.summary}] üë®‚Äçüíª {c.author}&quot;
196          if ch_log:
197              return str(ch + ch_log), str(ch_tl + tldr_log)
198          return ch_log, tldr_log
199  async def bash(cmd, run_code=0):
200      process = await asyncio.create_subprocess_shell(
201          cmd,
202          stdout=asyncio.subprocess.PIPE,
203          stderr=asyncio.subprocess.PIPE,
204      )
205      stdout, stderr = await process.communicate()
206      err = stderr.decode().strip() or None
207      out = stdout.decode().strip()
208      if not run_code and err:
209          if match := re.match(&quot;\/bin\/sh: (.*): ?(\w+): not found&quot;, err):
210              return out, f&quot;{match.group(2).upper()}_NOT_FOUND&quot;
211      return out, err
212  async def updater():
213      from .. import LOGS
214      try:
215          off_repo = Repo().remotes[0].config_reader.get(&quot;url&quot;).replace(&quot;.git&quot;, &quot;&quot;)
216      except Exception as er:
217          LOGS.exception(er)
218          return
219      try:
220          repo = Repo()
221      except NoSuchPathError as error:
222          LOGS.info(f&quot;`directory {error} is not found`&quot;)
223          Repo().__del__()
224          return
225      except GitCommandError as error:
226          LOGS.info(f&quot;`Early failure! {error}`&quot;)
227          Repo().__del__()
228          return
229      except InvalidGitRepositoryError:
230          repo = Repo.init()
231          origin = repo.create_remote(&quot;upstream&quot;, off_repo)
232          origin.fetch()
233          repo.create_head(&quot;main&quot;, origin.refs.main)
234          repo.heads.main.set_tracking_branch(origin.refs.main)
235          repo.heads.main.checkout(True)
236      ac_br = repo.active_branch.name
237      repo.create_remote(&quot;upstream&quot;, off_repo) if &quot;upstream&quot; not in repo.remotes else None
238      ups_rem = repo.remote(&quot;upstream&quot;)
239      ups_rem.fetch(ac_br)
240      changelog, tl_chnglog = await gen_chlog(repo, f&quot;HEAD..upstream/{ac_br}&quot;)
241      return bool(changelog)
242  async def uploader(file, name, taime, event, msg):
243      with open(file, &quot;rb&quot;) as f:
244          result = await uploadable(
245              client=event.client,
246              file=f,
247              filename=name,
248              progress_callback=lambda d, t: asyncio.get_event_loop().create_task(
249                  progress(
250                      d,
251                      t,
252                      event,
253                      taime,
254                      msg,
255                  ),
256              ),
257          )
258      return result
259  async def downloader(filename, file, event, taime, msg):
260      with open(filename, &quot;wb&quot;) as fk:
261          result = await downloadable(
262              client=event.client,
263              location=file,
264              out=fk,
265              progress_callback=lambda d, t: asyncio.get_event_loop().create_task(
266                  progress(
267                      d,
268                      t,
269                      event,
270                      taime,
271                      msg,
272                  ),
273              ),
274          )
275      return result
276  async def async_searcher(
277      url: str,
278      post: bool = False,
279      head: bool = False,
280      headers: dict = None,
281      evaluate=None,
282      object: bool = False,
283      re_json: bool = False,
284      re_content: bool = False,
285      *args,
286      **kwargs,
287  ):
288      if aiohttp_client:
289          async with aiohttp_client(headers=headers) as client:
290              method = client.head if head else (client.post if post else client.get)
291              data = await method(url, *args, **kwargs)
292              if evaluate:
293                  return await evaluate(data)
294              if re_json:
295                  return await data.json()
296              if re_content:
297                  return await data.read()
298              if head or object:
299                  return data
300              return await data.text()
301      else:
302          raise DependencyMissingError(&quot;install &#x27;aiohttp&#x27; to use this.&quot;)
303  async def download_file(link, name, validate=False):
304      async def _download(content):
305          if validate and &quot;application/json&quot; in content.headers.get(&quot;Content-Type&quot;):
306              return None, await content.json()
307          with open(name, &quot;wb&quot;) as file:
308              file.write(await content.read())
309          return name, &quot;&quot;
310      return await async_searcher(link, evaluate=_download)
311  async def fast_download(download_url, filename=None, progress_callback=None):
312      if not aiohttp_client:
313          return await download_file(download_url, filename)[0], None
314      async with aiohttp_client() as session:
315          async with session.get(download_url, timeout=None) as response:
316              if not filename:
317                  filename = unquote(download_url.rpartition(&quot;/&quot;)[-1])
318              total_size = int(response.headers.get(&quot;content-length&quot;, 0)) or None
319              downloaded_size = 0
320              start_time = time.time()
321              with open(filename, &quot;wb&quot;) as f:
322                  async for chunk in response.content.iter_chunked(1024):
323                      if chunk:
324                          f.write(chunk)
325                          downloaded_size += len(chunk)
326                      if progress_callback and total_size:
327                          await _maybe_await(
328                              progress_callback(downloaded_size, total_size)
329                          )
330              return filename, time.time() - start_time
331  def mediainfo(media):
332      xx = str((str(media)).split(&quot;(&quot;, maxsplit=1)[0])
333      m = &quot;&quot;
334      if xx == &quot;MessageMediaDocument&quot;:
335          mim = media.document.mime_type
336          if mim == &quot;application/x-tgsticker&quot;:
337              m = &quot;sticker animated&quot;
338          elif &quot;image&quot; in mim:
339              if mim == &quot;image/webp&quot;:
340                  m = &quot;sticker&quot;
341              elif mim == &quot;image/gif&quot;:
342                  m = &quot;gif as doc&quot;
343              else:
344                  m = &quot;pic as doc&quot;
345          elif &quot;video&quot; in mim:
346              if &quot;DocumentAttributeAnimated&quot; in str(media):
347                  m = &quot;gif&quot;
348              elif &quot;DocumentAttributeVideo&quot; in str(media):
349                  i = str(media.document.attributes[0])
350                  if &quot;supports_streaming=True&quot; in i:
351                      m = &quot;video&quot;
352                  m = &quot;video as doc&quot;
353              else:
354                  m = &quot;video&quot;
355          elif &quot;audio&quot; in mim:
356              m = &quot;audio&quot;
357          else:
358              m = &quot;document&quot;
359      elif xx == &quot;MessageMediaPhoto&quot;:
360          m = &quot;pic&quot;
361      elif xx == &quot;MessageMediaWebPage&quot;:
362          m = &quot;web&quot;
363      return m
364  def time_formatter(milliseconds):
365      minutes, seconds = divmod(int(milliseconds / 1000), 60)
366      hours, minutes = divmod(minutes, 60)
367      days, hours = divmod(hours, 24)
368      weeks, days = divmod(days, 7)
369      tmp = (
370          ((str(weeks) + &quot;w:&quot;) if weeks else &quot;&quot;)
371          + ((str(days) + &quot;d:&quot;) if days else &quot;&quot;)
372          + ((str(hours) + &quot;h:&quot;) if hours else &quot;&quot;)
373          + ((str(minutes) + &quot;m:&quot;) if minutes else &quot;&quot;)
374          + ((str(seconds) + &quot;s&quot;) if seconds else &quot;&quot;)
375      )
376      if not tmp:
377          return &quot;0s&quot;
378      if tmp.endswith(&quot;:&quot;):
379          return tmp[:-1]
380      return tmp
381  def humanbytes(size):
382      if not size:
383          return &quot;0 B&quot;
384      for unit in [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;G&quot;, &quot;T&quot;]:
385          if size &lt; 1024:
386              break
387          size /= 1024
388      if isinstance(size, int):
389          size = f&quot;{size}{unit}B&quot;
390      elif isinstance(size, float):
391          size = f&quot;{size:.2f}{unit}B&quot;
392      return size
393  def numerize(number):
394      if not number:
395          return None
396      unit = &quot;&quot;
397      for unit in [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;]:
398          if number &lt; 1000:
399              break
400          number /= 1000
401      if isinstance(number, int):
402          number = f&quot;{number}{unit}&quot;
403      elif isinstance(number, float):
404          number = f&quot;{number:.2f}{unit}&quot;
405      return number
406  No_Flood = {}
407  async def progress(current, total, event, start, type_of_ps, file_name=None):
408      now = time.time()
409      if No_Flood.get(event.chat_id):
410          if No_Flood[event.chat_id].get(event.id):
411              if (now - No_Flood[event.chat_id][event.id]) &lt; 1.1:
412                  return
413          else:
414              No_Flood[event.chat_id].update({event.id: now})
415      else:
416          No_Flood.update({event.chat_id: {event.id: now}})
417      diff = time.time() - start
418      if round(diff % 10.00) == 0 or current == total:
419          percentage = current * 100 / total
420          speed = current / diff
421          time_to_completion = round((total - current) / speed) * 1000
422          progress_str = &quot;`[{0}{1}] {2}%`\n\n&quot;.format(
423              &quot;&quot;.join(&quot;‚óè&quot; for i in range(math.floor(percentage / 5))),
424              &quot;&quot;.join(&quot;&quot; for i in range(20 - math.floor(percentage / 5))),
425              round(percentage, 2),
426          )
427          tmp = (
428              progress_str
429              + &quot;`{0} of {1}`\n\n`‚ú¶ Speed: {2}/s`\n\n`‚ú¶ ETA: {3}`\n\n&quot;.format(
430                  humanbytes(current),
431                  humanbytes(total),
432                  humanbytes(speed),
433                  time_formatter(time_to_completion),
434              )
435          )
436          if file_name:
437              await event.edit(
438                  &quot;`‚ú¶ {}`\n\n`File Name: {}`\n\n{}&quot;.format(type_of_ps, file_name, tmp)
439              )
440          else:
441              await event.edit(&quot;`‚ú¶ {}`\n\n{}&quot;.format(type_of_ps, tmp))
442  async def restart(ult=None):
443      if Var.HEROKU_APP_NAME and Var.HEROKU_API:
444          try:
445              Heroku = heroku3.from_key(Var.HEROKU_API)
<span onclick='openModal()' class='match'>446              app = Heroku.apps()[Var.HEROKU_APP_NAME]
447              if ult:
</span>448                  await ult.edit(&quot;`Restarting your app, please wait for a minute!`&quot;)
449              app.restart()
450          except BaseException as er:
451              if ult:
452                  return await eor(
453                      ult,
454                      &quot;`HEROKU_API` or `HEROKU_APP_NAME` is wrong! Kindly re-check in config vars.&quot;,
455                  )
456              LOGS.exception(er)
457      else:
458          if len(sys.argv) == 1:
459              os.execl(sys.executable, sys.executable, &quot;-m&quot;, &quot;pyUltroid&quot;)
460          else:
461              os.execl(
462                  sys.executable,
463                  sys.executable,
464                  &quot;-m&quot;,
465                  &quot;pyUltroid&quot;,
466                  sys.argv[1],
467                  sys.argv[2],
468                  sys.argv[3],
469                  sys.argv[4],
470                  sys.argv[5],
471                  sys.argv[6],
472              )
473  async def shutdown(ult):
474      from .. import HOSTED_ON, LOGS
475      ult = await eor(ult, &quot;Shutting Down&quot;)
476      if HOSTED_ON == &quot;heroku&quot;:
477          if not (Var.HEROKU_APP_NAME and Var.HEROKU_API):
478              return await ult.edit(&quot;Please Fill `HEROKU_APP_NAME` and `HEROKU_API`&quot;)
479          dynotype = os.getenv(&quot;DYNO&quot;).split(&quot;.&quot;)[0]
480          try:
481              Heroku = heroku3.from_key(Var.HEROKU_API)
482              app = Heroku.apps()[Var.HEROKU_APP_NAME]
483              await ult.edit(&quot;`Shutting Down your app, please wait for a minute!`&quot;)
484              app.process_formation()[dynotype].scale(0)
485          except BaseException as e:
486              LOGS.exception(e)
487              return await ult.edit(
488                  &quot;`HEROKU_API` and `HEROKU_APP_NAME` is wrong! Kindly re-check in config vars.&quot;
489              )
490      else:
491          sys.exit()
</code></pre>
        </div>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-helper.py</h3>
            <pre><code>1  import asyncio
2  import math
3  import os
4  import re
5  import sys
6  import time
7  from traceback import format_exc
8  from urllib.parse import unquote
9  from urllib.request import urlretrieve
10  from .. import run_as_module
11  if run_as_module:
12      from ..configs import Var
13  try:
14      from aiohttp import ClientSession as aiohttp_client
15  except ImportError:
16      aiohttp_client = None
17      try:
18          import requests
19      except ImportError:
20          requests = None
21  try:
22      import heroku3
23  except ImportError:
24      heroku3 = None
25  try:
26      from git import Repo
27      from git.exc import GitCommandError, InvalidGitRepositoryError, NoSuchPathError
28  except ImportError:
29      Repo = None
30  import asyncio
31  import multiprocessing
32  from concurrent.futures import ThreadPoolExecutor
33  from functools import partial, wraps
34  from telethon.helpers import _maybe_await
35  from telethon.tl import types
36  from telethon.utils import get_display_name
37  from .._misc import CMD_HELP
38  from .._misc._wrappers import eod, eor
39  from ..exceptions import DependencyMissingError
40  from . import *
41  if run_as_module:
42      from ..dB._core import ADDONS, HELP, LIST, LOADED
43  from ..version import ultroid_version
44  from .FastTelethon import download_file as downloadable
45  from .FastTelethon import upload_file as uploadable
46  def run_async(function):
47      @wraps(function)
48      async def wrapper(*args, **kwargs):
49          return await asyncio.get_event_loop().run_in_executor(
50              ThreadPoolExecutor(max_workers=multiprocessing.cpu_count() * 5),
51              partial(function, *args, **kwargs),
52          )
53      return wrapper
54  def make_mention(user, custom=None):
55      if user.username:
56          return f&quot;@{user.username}&quot;
57      return inline_mention(user, custom=custom)
58  def inline_mention(user, custom=None, html=False):
59      mention_text = get_display_name(user) or &quot;Deleted Account&quot; if not custom else custom
60      if isinstance(user, types.User):
61          if html:
62              return f&quot;&lt;a href=tg://user?id={user.id}&gt;{mention_text}&lt;/a&gt;&quot;
63          return f&quot;[{mention_text}](tg://user?id={user.id})&quot;
64      if isinstance(user, types.Channel) and user.username:
65          if html:
66              return f&quot;&lt;a href=https://t.me/{user.username}&gt;{mention_text}&lt;/a&gt;&quot;
67          return f&quot;[{mention_text}](https://t.me/{user.username})&quot;
68      return mention_text
69  def un_plug(shortname):
70      from .. import asst, ultroid_bot
71      try:
72          all_func = LOADED[shortname]
73          for client in [ultroid_bot, asst]:
74              for x, _ in client.list_event_handlers():
75                  if x in all_func:
76                      client.remove_event_handler(x)
77          del LOADED[shortname]
78          del LIST[shortname]
79          ADDONS.remove(shortname)
80      except (ValueError, KeyError):
81          name = f&quot;addons.{shortname}&quot;
82          for client in [ultroid_bot, asst]:
83              for i in reversed(range(len(client._event_builders))):
84                  ev, cb = client._event_builders[i]
85                  if cb.__module__ == name:
86                      del client._event_builders[i]
87                      try:
88                          del LOADED[shortname]
89                          del LIST[shortname]
90                          ADDONS.remove(shortname)
91                      except KeyError:
92                          pass
93  if run_as_module:
94      async def safeinstall(event):
95          from .. import HNDLR
96          from ..startup.utils import load_addons
97          if not event.reply_to:
98              return await eod(
99                  event, f&quot;Please use `{HNDLR}install` as reply to a .py file.&quot;
100              )
101          ok = await eor(event, &quot;`Installing...`&quot;)
102          reply = await event.get_reply_message()
103          if not (
104              reply.media
105              and hasattr(reply.media, &quot;document&quot;)
106              and reply.file.name
107              and reply.file.name.endswith(&quot;.py&quot;)
108          ):
109              return await eod(ok, &quot;`Please reply to any python plugin`&quot;)
110          plug = reply.file.name.replace(&quot;.py&quot;, &quot;&quot;)
111          if plug in list(LOADED):
112              return await eod(ok, f&quot;Plugin `{plug}` is already installed.&quot;)
113          sm = reply.file.name.replace(&quot;_&quot;, &quot;-&quot;).replace(&quot;|&quot;, &quot;-&quot;)
114          dl = await reply.download_media(f&quot;addons/{sm}&quot;)
115          if event.text[9:] != &quot;f&quot;:
116              read = open(dl).read()
117              for dan in KEEP_SAFE().All:
118                  if re.search(dan, read):
119                      os.remove(dl)
120                      return await ok.edit(
121                          f&quot;**Installation Aborted.**\n**Reason:** Occurance of `{dan}` in `{reply.file.name}`.\n\nIf you trust the provider and/or know what you&#x27;re doing, use `{HNDLR}install f` to force install.&quot;,
122                      )
123          try:
124              load_addons(dl)  # dl.split(&quot;/&quot;)[-1].replace(&quot;.py&quot;, &quot;&quot;))
125          except BaseException:
126              os.remove(dl)
127              return await eor(ok, f&quot;**ERROR**\n\n`{format_exc()}`&quot;, time=30)
128          plug = sm.replace(&quot;.py&quot;, &quot;&quot;)
129          if plug in HELP:
130              output = &quot;**Plugin** - `{}`\n&quot;.format(plug)
131              for i in HELP[plug]:
132                  output += i
133              output += &quot;\n¬© @TeamUltroid&quot;
134              await eod(ok, f&quot;‚úì `Ultroid - Installed`: `{plug}` ‚úì\n\n{output}&quot;)
135          elif plug in CMD_HELP:
136              output = f&quot;Plugin Name-{plug}\n\n‚úò Commands Available-\n\n&quot;
137              output += str(CMD_HELP[plug])
138              await eod(ok, f&quot;‚úì `Ultroid - Installed`: `{plug}` ‚úì\n\n{output}&quot;)
139          else:
140              try:
141                  x = f&quot;Plugin Name-{plug}\n\n‚úò Commands Available-\n\n&quot;
142                  for d in LIST[plug]:
143                      x += HNDLR + d + &quot;\n&quot;
144                  await eod(ok, f&quot;‚úì `Ultroid - Installed`: `{plug}` ‚úì\n\n`{x}`&quot;)
145              except BaseException:
146                  await eod(ok, f&quot;‚úì `Ultroid - Installed`: `{plug}` ‚úì&quot;)
147      async def heroku_logs(event):
148          from .. import LOGS
149          xx = await eor(event, &quot;`Processing...`&quot;)
150          if not (Var.HEROKU_API and Var.HEROKU_APP_NAME):
151              return await xx.edit(
152                  &quot;Please set `HEROKU_APP_NAME` and `HEROKU_API` in vars.&quot;
153              )
154          try:
155              app = (heroku3.from_key(Var.HEROKU_API)).app(Var.HEROKU_APP_NAME)
156          except BaseException as se:
157              LOGS.info(se)
158              return await xx.edit(
159                  &quot;`HEROKU_API` and `HEROKU_APP_NAME` is wrong! Kindly re-check in config vars.&quot;
160              )
161          await xx.edit(&quot;`Downloading Logs...`&quot;)
162          ok = app.get_log()
163          with open(&quot;ultroid-heroku.log&quot;, &quot;w&quot;) as log:
164              log.write(ok)
165          await event.client.send_file(
166              event.chat_id,
167              file=&quot;ultroid-heroku.log&quot;,
168              thumb=ULTConfig.thumb,
169              caption=&quot;**Ultroid Heroku Logs.**&quot;,
170          )
171          os.remove(&quot;ultroid-heroku.log&quot;)
172          await xx.delete()
173      async def def_logs(ult, file):
174          await ult.respond(
175              &quot;**Ultroid Logs.**&quot;,
176              file=file,
177              thumb=ULTConfig.thumb,
178          )
179      async def updateme_requirements():
180          await bash(
181              f&quot;{sys.executable} -m pip install --no-cache-dir -r requirements.txt&quot;
182          )
183      @run_async
184      def gen_chlog(repo, diff):
185          UPSTREAM_REPO_URL = (
186              Repo().remotes[0].config_reader.get(&quot;url&quot;).replace(&quot;.git&quot;, &quot;&quot;)
187          )
188          ac_br = repo.active_branch.name
189          ch_log = tldr_log = &quot;&quot;
190          ch = f&quot;&lt;b&gt;Ultroid {ultroid_version} updates for &lt;a href={UPSTREAM_REPO_URL}/tree/{ac_br}&gt;[{ac_br}]&lt;/a&gt;:&lt;/b&gt;&quot;
191          ch_tl = f&quot;Ultroid {ultroid_version} updates for {ac_br}:&quot;
192          d_form = &quot;%d/%m/%y || %H:%M&quot;
193          for c in repo.iter_commits(diff):
194              ch_log += f&quot;\n\nüí¨ &lt;b&gt;{c.count()}&lt;/b&gt; üóì &lt;b&gt;[{c.committed_datetime.strftime(d_form)}]&lt;/b&gt;\n&lt;b&gt;&lt;a href={UPSTREAM_REPO_URL.rstrip(&#x27;/&#x27;)}/commit/{c}&gt;[{c.summary}]&lt;/a&gt;&lt;/b&gt; üë®‚Äçüíª &lt;code&gt;{c.author}&lt;/code&gt;&quot;
195              tldr_log += f&quot;\n\nüí¨ {c.count()} üóì [{c.committed_datetime.strftime(d_form)}]\n[{c.summary}] üë®‚Äçüíª {c.author}&quot;
196          if ch_log:
197              return str(ch + ch_log), str(ch_tl + tldr_log)
198          return ch_log, tldr_log
199  async def bash(cmd, run_code=0):
200      process = await asyncio.create_subprocess_shell(
201          cmd,
202          stdout=asyncio.subprocess.PIPE,
203          stderr=asyncio.subprocess.PIPE,
204      )
205      stdout, stderr = await process.communicate()
206      err = stderr.decode().strip() or None
207      out = stdout.decode().strip()
208      if not run_code and err:
209          if match := re.match(&quot;\/bin\/sh: (.*): ?(\w+): not found&quot;, err):
210              return out, f&quot;{match.group(2).upper()}_NOT_FOUND&quot;
211      return out, err
212  async def updater():
213      from .. import LOGS
214      try:
215          off_repo = Repo().remotes[0].config_reader.get(&quot;url&quot;).replace(&quot;.git&quot;, &quot;&quot;)
216      except Exception as er:
217          LOGS.exception(er)
218          return
219      try:
220          repo = Repo()
221      except NoSuchPathError as error:
222          LOGS.info(f&quot;`directory {error} is not found`&quot;)
223          Repo().__del__()
224          return
225      except GitCommandError as error:
226          LOGS.info(f&quot;`Early failure! {error}`&quot;)
227          Repo().__del__()
228          return
229      except InvalidGitRepositoryError:
230          repo = Repo.init()
231          origin = repo.create_remote(&quot;upstream&quot;, off_repo)
232          origin.fetch()
233          repo.create_head(&quot;main&quot;, origin.refs.main)
234          repo.heads.main.set_tracking_branch(origin.refs.main)
235          repo.heads.main.checkout(True)
236      ac_br = repo.active_branch.name
237      repo.create_remote(&quot;upstream&quot;, off_repo) if &quot;upstream&quot; not in repo.remotes else None
238      ups_rem = repo.remote(&quot;upstream&quot;)
239      ups_rem.fetch(ac_br)
240      changelog, tl_chnglog = await gen_chlog(repo, f&quot;HEAD..upstream/{ac_br}&quot;)
241      return bool(changelog)
242  async def uploader(file, name, taime, event, msg):
243      with open(file, &quot;rb&quot;) as f:
244          result = await uploadable(
245              client=event.client,
246              file=f,
247              filename=name,
248              progress_callback=lambda d, t: asyncio.get_event_loop().create_task(
249                  progress(
250                      d,
251                      t,
252                      event,
253                      taime,
254                      msg,
255                  ),
256              ),
257          )
258      return result
259  async def downloader(filename, file, event, taime, msg):
260      with open(filename, &quot;wb&quot;) as fk:
261          result = await downloadable(
262              client=event.client,
263              location=file,
264              out=fk,
265              progress_callback=lambda d, t: asyncio.get_event_loop().create_task(
266                  progress(
267                      d,
268                      t,
269                      event,
270                      taime,
271                      msg,
272                  ),
273              ),
274          )
275      return result
276  async def async_searcher(
277      url: str,
278      post: bool = False,
279      head: bool = False,
280      headers: dict = None,
281      evaluate=None,
282      object: bool = False,
283      re_json: bool = False,
284      re_content: bool = False,
285      *args,
286      **kwargs,
287  ):
288      if aiohttp_client:
289          async with aiohttp_client(headers=headers) as client:
290              method = client.head if head else (client.post if post else client.get)
291              data = await method(url, *args, **kwargs)
292              if evaluate:
293                  return await evaluate(data)
294              if re_json:
295                  return await data.json()
296              if re_content:
297                  return await data.read()
298              if head or object:
299                  return data
300              return await data.text()
301      else:
302          raise DependencyMissingError(&quot;install &#x27;aiohttp&#x27; to use this.&quot;)
303  async def download_file(link, name, validate=False):
304      async def _download(content):
305          if validate and &quot;application/json&quot; in content.headers.get(&quot;Content-Type&quot;):
306              return None, await content.json()
307          with open(name, &quot;wb&quot;) as file:
308              file.write(await content.read())
309          return name, &quot;&quot;
310      return await async_searcher(link, evaluate=_download)
311  async def fast_download(download_url, filename=None, progress_callback=None):
312      if not aiohttp_client:
313          return await download_file(download_url, filename)[0], None
314      async with aiohttp_client() as session:
315          async with session.get(download_url, timeout=None) as response:
316              if not filename:
317                  filename = unquote(download_url.rpartition(&quot;/&quot;)[-1])
318              total_size = int(response.headers.get(&quot;content-length&quot;, 0)) or None
319              downloaded_size = 0
320              start_time = time.time()
321              with open(filename, &quot;wb&quot;) as f:
322                  async for chunk in response.content.iter_chunked(1024):
323                      if chunk:
324                          f.write(chunk)
325                          downloaded_size += len(chunk)
326                      if progress_callback and total_size:
327                          await _maybe_await(
328                              progress_callback(downloaded_size, total_size)
329                          )
330              return filename, time.time() - start_time
331  def mediainfo(media):
332      xx = str((str(media)).split(&quot;(&quot;, maxsplit=1)[0])
333      m = &quot;&quot;
334      if xx == &quot;MessageMediaDocument&quot;:
335          mim = media.document.mime_type
336          if mim == &quot;application/x-tgsticker&quot;:
337              m = &quot;sticker animated&quot;
338          elif &quot;image&quot; in mim:
339              if mim == &quot;image/webp&quot;:
340                  m = &quot;sticker&quot;
341              elif mim == &quot;image/gif&quot;:
342                  m = &quot;gif as doc&quot;
343              else:
344                  m = &quot;pic as doc&quot;
345          elif &quot;video&quot; in mim:
346              if &quot;DocumentAttributeAnimated&quot; in str(media):
347                  m = &quot;gif&quot;
348              elif &quot;DocumentAttributeVideo&quot; in str(media):
349                  i = str(media.document.attributes[0])
350                  if &quot;supports_streaming=True&quot; in i:
351                      m = &quot;video&quot;
352                  m = &quot;video as doc&quot;
353              else:
354                  m = &quot;video&quot;
355          elif &quot;audio&quot; in mim:
356              m = &quot;audio&quot;
357          else:
358              m = &quot;document&quot;
359      elif xx == &quot;MessageMediaPhoto&quot;:
360          m = &quot;pic&quot;
361      elif xx == &quot;MessageMediaWebPage&quot;:
362          m = &quot;web&quot;
363      return m
364  def time_formatter(milliseconds):
365      minutes, seconds = divmod(int(milliseconds / 1000), 60)
366      hours, minutes = divmod(minutes, 60)
367      days, hours = divmod(hours, 24)
368      weeks, days = divmod(days, 7)
369      tmp = (
370          ((str(weeks) + &quot;w:&quot;) if weeks else &quot;&quot;)
371          + ((str(days) + &quot;d:&quot;) if days else &quot;&quot;)
372          + ((str(hours) + &quot;h:&quot;) if hours else &quot;&quot;)
373          + ((str(minutes) + &quot;m:&quot;) if minutes else &quot;&quot;)
374          + ((str(seconds) + &quot;s&quot;) if seconds else &quot;&quot;)
375      )
376      if not tmp:
377          return &quot;0s&quot;
378      if tmp.endswith(&quot;:&quot;):
379          return tmp[:-1]
380      return tmp
381  def humanbytes(size):
382      if not size:
383          return &quot;0 B&quot;
384      for unit in [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;G&quot;, &quot;T&quot;]:
385          if size &lt; 1024:
386              break
387          size /= 1024
388      if isinstance(size, int):
389          size = f&quot;{size}{unit}B&quot;
390      elif isinstance(size, float):
391          size = f&quot;{size:.2f}{unit}B&quot;
392      return size
393  def numerize(number):
394      if not number:
395          return None
396      unit = &quot;&quot;
397      for unit in [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;]:
398          if number &lt; 1000:
399              break
400          number /= 1000
401      if isinstance(number, int):
402          number = f&quot;{number}{unit}&quot;
403      elif isinstance(number, float):
404          number = f&quot;{number:.2f}{unit}&quot;
405      return number
406  No_Flood = {}
407  async def progress(current, total, event, start, type_of_ps, file_name=None):
408      now = time.time()
409      if No_Flood.get(event.chat_id):
410          if No_Flood[event.chat_id].get(event.id):
411              if (now - No_Flood[event.chat_id][event.id]) &lt; 1.1:
412                  return
413          else:
414              No_Flood[event.chat_id].update({event.id: now})
415      else:
416          No_Flood.update({event.chat_id: {event.id: now}})
417      diff = time.time() - start
418      if round(diff % 10.00) == 0 or current == total:
419          percentage = current * 100 / total
420          speed = current / diff
421          time_to_completion = round((total - current) / speed) * 1000
422          progress_str = &quot;`[{0}{1}] {2}%`\n\n&quot;.format(
423              &quot;&quot;.join(&quot;‚óè&quot; for i in range(math.floor(percentage / 5))),
424              &quot;&quot;.join(&quot;&quot; for i in range(20 - math.floor(percentage / 5))),
425              round(percentage, 2),
426          )
427          tmp = (
428              progress_str
429              + &quot;`{0} of {1}`\n\n`‚ú¶ Speed: {2}/s`\n\n`‚ú¶ ETA: {3}`\n\n&quot;.format(
430                  humanbytes(current),
431                  humanbytes(total),
432                  humanbytes(speed),
433                  time_formatter(time_to_completion),
434              )
435          )
436          if file_name:
437              await event.edit(
438                  &quot;`‚ú¶ {}`\n\n`File Name: {}`\n\n{}&quot;.format(type_of_ps, file_name, tmp)
439              )
440          else:
441              await event.edit(&quot;`‚ú¶ {}`\n\n{}&quot;.format(type_of_ps, tmp))
442  async def restart(ult=None):
443      if Var.HEROKU_APP_NAME and Var.HEROKU_API:
444          try:
445              Heroku = heroku3.from_key(Var.HEROKU_API)
446              app = Heroku.apps()[Var.HEROKU_APP_NAME]
447              if ult:
448                  await ult.edit(&quot;`Restarting your app, please wait for a minute!`&quot;)
449              app.restart()
450          except BaseException as er:
451              if ult:
452                  return await eor(
453                      ult,
454                      &quot;`HEROKU_API` or `HEROKU_APP_NAME` is wrong! Kindly re-check in config vars.&quot;,
455                  )
456              LOGS.exception(er)
457      else:
458          if len(sys.argv) == 1:
459              os.execl(sys.executable, sys.executable, &quot;-m&quot;, &quot;pyUltroid&quot;)
460          else:
461              os.execl(
462                  sys.executable,
463                  sys.executable,
464                  &quot;-m&quot;,
465                  &quot;pyUltroid&quot;,
466                  sys.argv[1],
467                  sys.argv[2],
468                  sys.argv[3],
469                  sys.argv[4],
470                  sys.argv[5],
471                  sys.argv[6],
472              )
473  async def shutdown(ult):
474      from .. import HOSTED_ON, LOGS
475      ult = await eor(ult, &quot;Shutting Down&quot;)
476      if HOSTED_ON == &quot;heroku&quot;:
477          if not (Var.HEROKU_APP_NAME and Var.HEROKU_API):
478              return await ult.edit(&quot;Please Fill `HEROKU_APP_NAME` and `HEROKU_API`&quot;)
479          dynotype = os.getenv(&quot;DYNO&quot;).split(&quot;.&quot;)[0]
480          try:
481              Heroku = heroku3.from_key(Var.HEROKU_API)
<span onclick='openModal()' class='match'>482              app = Heroku.apps()[Var.HEROKU_APP_NAME]
483              await ult.edit(&quot;`Shutting Down your app, please wait for a minute!`&quot;)
</span>484              app.process_formation()[dynotype].scale(0)
485          except BaseException as e:
486              LOGS.exception(e)
487              return await ult.edit(
488                  &quot;`HEROKU_API` and `HEROKU_APP_NAME` is wrong! Kindly re-check in config vars.&quot;
489              )
490      else:
491          sys.exit()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-helper.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-helper.py</div>
                </div>
                <div class="column column_space"><pre><code>446              app = Heroku.apps()[Var.HEROKU_APP_NAME]
447              if ult:
</pre></code></div>
                <div class="column column_space"><pre><code>482              app = Heroku.apps()[Var.HEROKU_APP_NAME]
483              await ult.edit(&quot;`Shutting Down your app, please wait for a minute!`&quot;)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    