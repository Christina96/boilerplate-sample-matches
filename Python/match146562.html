<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_verify_1.py &amp; opkg.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_verify_1.py &amp; opkg.py
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_verify_1.py (4.608295%)<th>opkg.py (1.6277808%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-33)<td><a href="#" name="0">(19-35)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(171-179)<td><a href="#" name="1">(82-97)</a><td align="center"><font color="#df0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_verify_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import ctypes
2 import getpass
3 import os
4 import shutil
5 import socket
6 import stat
7 import sys
8 import tempfile
9 import pytest
10 import salt.utils.files
11 import salt.utils.platform
12 from salt.utils.verify import (
13     check_max_open_files,
14     check_user,
15     clean_path,
16     log,
17     valid_id,
18     verify_env,
19     verify_log,
20     verify_log_files,
21     verify_logs_filter,
22     verify_socket,
23     zmq_version,
24 )
25 from tests.support.helpers import TstSuiteLoggingHandler
26 from tests.support.mock import MagicMock, patch
27 from tests.support.runtests import RUNTIME_VARS
28 from</b></font> tests.support.unit import TestCase, skipIf
29 if sys.platform.startswith("win"):
30     import win32file
31 else:
32     import resource
33 class TestVerify(TestCase):
34     def test_valid_id_exception_handler(self):
35         opts = {"pki_dir": "/tmp/whatever"}
36         self.assertFalse(valid_id(opts, None))
37     def test_valid_id_pathsep(self):
38         opts = {"pki_dir": "/tmp/whatever"}
39         for pathsep in ("/", "\\"):
40             self.assertFalse(valid_id(opts, pathsep.join(("..", "foobar"))))
41     def test_zmq_verify(self):
42         self.assertTrue(zmq_version())
43     def test_zmq_verify_insufficient(self):
44         import zmq
45         with patch.object(zmq, "__version__", "2.1.0"):
46             self.assertFalse(zmq_version())
47     def test_user(self):
48         self.assertTrue(check_user(getpass.getuser()))
49     def test_no_user(self):
50         class FakeWriter:
51             def __init__(self):
52                 self.output = ""
53                 self.errors = "strict"
54             def write(self, data):
55                 self.output += data
56             def flush(self):
57                 pass
58         stderr = sys.stderr
59         writer = FakeWriter()
60         sys.stderr = writer
61         try:
62             if sys.platform.startswith("win"):
63                 self.assertTrue(check_user("nouser"))
64             else:
65                 with self.assertRaises(SystemExit):
66                     self.assertFalse(check_user("nouser"))
67         finally:
68             sys.stderr = stderr
69         if writer.output != 'CRITICAL: User not found: "nouser"\n':
70             sys.stderr.write(writer.output)
71     @skipIf(salt.utils.platform.is_windows(), "No verify_env Windows")
72     def test_verify_env(self):
73         root_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
74         var_dir = os.path.join(root_dir, "var", "log", "salt")
75         key_dir = os.path.join(root_dir, "key_dir")
76         verify_env([var_dir], getpass.getuser(), root_dir=root_dir)
77         self.assertTrue(os.path.exists(var_dir))
78         dir_stat = os.stat(var_dir)
79         self.assertEqual(dir_stat.st_uid, os.getuid())
80         self.assertEqual(dir_stat.st_mode &amp; stat.S_IRWXU, stat.S_IRWXU)
81         self.assertEqual(dir_stat.st_mode &amp; stat.S_IRWXG, 40)
82         self.assertEqual(dir_stat.st_mode &amp; stat.S_IRWXO, 5)
83     @pytest.mark.requires_network(only_local_network=True)
84     def test_verify_socket(self):
85         self.assertTrue(verify_socket("", 18000, 18001))
86         if socket.has_ipv6:
87             try:
88                 self.assertTrue(verify_socket("::", 18000, 18001))
89             except OSError:
90                 pass
91     def test_max_open_files(self):
92         with TstSuiteLoggingHandler() as handler:
93             logmsg_dbg = "DEBUG:This salt-master instance has accepted {0} minion keys."
94             logmsg_chk = (
95                 "{0}:The number of accepted minion keys({1}) should be lower "
96                 "than 1/4 of the max open files soft setting({2}). According "
97                 "to the system's hard limit, there's still a margin of {3} "
98                 "to raise the salt's max_open_files setting. Please consider "
99                 "raising this value."
100             )
101             logmsg_crash = (
102                 "{0}:The number of accepted minion keys({1}) should be lower "
103                 "than 1/4 of the max open files soft setting({2}). "
104                 "salt-master will crash pretty soon! According to the "
105                 "system's hard limit, there's still a margin of {3} to "
106                 "raise the salt's max_open_files setting. Please consider "
107                 "raising this value."
108             )
109             if sys.platform.startswith("win"):
110                 logmsg_crash = (
111                     "{0}:The number of accepted minion keys({1}) should be lower "
112                     "than 1/4 of the max open files soft setting({2}). "
113                     "salt-master will crash pretty soon! Please consider "
114                     "raising this value."
115                 )
116             if sys.platform.startswith("win"):
117                 mof_s = mof_h = win32file._getmaxstdio()
118 <a name="1"></a>            else:
119                 mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)
120             tempdir = tempfile.mkdtemp(prefix="fake-keys")
121             keys_dir = os.path<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.join(tempdir, "minions")
122             os.makedirs(keys_dir)
123             mof_test = 256
124             if sys.platform.startswith("win"):
125                 win32file._setmaxstdio(mof_test)
126             else:
127                 resource.setrlimit(resource.</b></font>RLIMIT_NOFILE, (mof_test, mof_h))
128             try:
129                 prev = 0
130                 for newmax, level in (
131                     (24, None),
132                     (66, "INFO"),
133                     (127, "WARNING"),
134                     (196, "CRITICAL"),
135                 ):
136                     for n in range(prev, newmax):
137                         kpath = os.path.join(keys_dir, str(n))
138                         with salt.utils.files.fopen(kpath, "w") as fp_:
139                             fp_.write(str(n))
140                     opts = {"max_open_files": newmax, "pki_dir": tempdir}
141                     check_max_open_files(opts)
142                     if level is None:
143                         self.assertEqual([logmsg_dbg.format(newmax)], handler.messages)
144                     else:
145                         self.assertIn(logmsg_dbg.format(newmax), handler.messages)
146                         self.assertIn(
147                             logmsg_chk.format(
148                                 level,
149                                 newmax,
150                                 mof_test,
151                                 mof_test - newmax
152                                 if sys.platform.startswith("win")
153                                 else mof_h - newmax,
154                             ),
155                             handler.messages,
156                         )
157                     handler.clear()
158                     prev = newmax
159                 newmax = mof_test
160                 for n in range(prev, newmax):
161                     kpath = os.path.join(keys_dir, str(n))
162                     with salt.utils.files.fopen(kpath, "w") as fp_:
163                         fp_.write(str(n))
164                 opts = {"max_open_files": newmax, "pki_dir": tempdir}
165                 check_max_open_files(opts)
166                 self.assertIn(logmsg_dbg.format(newmax), handler.messages)
167                 self.assertIn(
168                     logmsg_crash.format(
169                         "CRITICAL",
170                         newmax,
171                         mof_test,
172                         mof_test - newmax
173                         if sys.platform.startswith("win")
174                         else mof_h - newmax,
175                     ),
176                     handler.messages,
177                 )
178                 handler.clear()
179             except OSError as err:
180                 if err.errno == 24:
181                     self.skipTest("We've hit the max open files setting")
182                 raise
183             finally:
184                 if sys.platform.startswith("win"):
185                     win32file._setmaxstdio(mof_h)
186                 else:
187                     resource.setrlimit(resource.RLIMIT_NOFILE, (mof_s, mof_h))
188                 shutil.rmtree(tempdir)
189     def test_verify_log(self):
190         message = (
191             "Insecure logging configuration detected! Sensitive data may be logged."
192         )
193         mock_cheese = MagicMock()
194         with patch.object(log, "warning", mock_cheese):
195             verify_log({"log_level": "cheeseshop"})
196             mock_cheese.assert_called_once_with(message)
197         mock_trace = MagicMock()
198         with patch.object(log, "warning", mock_trace):
199             verify_log({"log_level": "trace"})
200             mock_trace.assert_called_once_with(message)
201         mock_none = MagicMock()
202         with patch.object(log, "warning", mock_none):
203             verify_log({})
204             mock_none.assert_called_once_with(message)
205         mock_info = MagicMock()
206         with patch.object(log, "warning", mock_info):
207             verify_log({"log_level": "info"})
208             self.assertTrue(mock_info.call_count == 0)
209 class TestVerifyLog(TestCase):
210     def setUp(self):
211         self.tmpdir = tempfile.mkdtemp()
212     def tearDown(self):
213         shutil.rmtree(self.tmpdir)
214     def test_verify_logs_filter(self):
215         filtered = verify_logs_filter(
216             ["udp://foo", "tcp://bar", "/tmp/foo", "file://tmp/bar"]
217         )
218         assert filtered == ["/tmp/foo"], filtered
219     @skipIf(salt.utils.platform.is_windows(), "Not applicable on Windows")
220     def test_verify_log_files_udp_scheme(self):
221         verify_log_files(["udp://foo"], getpass.getuser())
222         self.assertFalse(os.path.isdir(os.path.join(os.getcwd(), "udp:")))
223     @skipIf(salt.utils.platform.is_windows(), "Not applicable on Windows")
224     def test_verify_log_files_tcp_scheme(self):
225         verify_log_files(["udp://foo"], getpass.getuser())
226         self.assertFalse(os.path.isdir(os.path.join(os.getcwd(), "tcp:")))
227     @skipIf(salt.utils.platform.is_windows(), "Not applicable on Windows")
228     def test_verify_log_files_file_scheme(self):
229         verify_log_files(["file://{}"], getpass.getuser())
230         self.assertFalse(os.path.isdir(os.path.join(os.getcwd(), "file:")))
231     @skipIf(salt.utils.platform.is_windows(), "Not applicable on Windows")
232     def test_verify_log_files(self):
233         path = os.path.join(self.tmpdir, "foo", "bar.log")
234         self.assertFalse(os.path.exists(path))
235         verify_log_files([path], getpass.getuser())
236         self.assertTrue(os.path.exists(path))
237 class TestCleanPath(TestCase):
238     def setUp(self):
239         self.tmpdir = tempfile.mkdtemp()
240     def tearDown(self):
241         shutil.rmtree(self.tmpdir)
242     def test_clean_path_valid(self):
243         path_a = os.path.join(self.tmpdir, "foo")
244         path_b = os.path.join(self.tmpdir, "foo", "bar")
245         assert clean_path(path_a, path_b) == path_b
246     def test_clean_path_invalid(self):
247         path_a = os.path.join(self.tmpdir, "foo")
248         path_b = os.path.join(self.tmpdir, "baz", "bar")
249         assert clean_path(path_a, path_b) == ""
250 __CSL = None
251 def symlink(source, link_name):
252     global __CSL
253     if __CSL is None:
254         csl = ctypes.windll.kernel32.CreateSymbolicLinkW
255         csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32)
256         csl.restype = ctypes.c_ubyte
257         __CSL = csl
258     flags = 0
259     if source is not None and os.path.isdir(source):
260         flags = 1
261     if __CSL(link_name, source, flags) == 0:
262         raise ctypes.WinError()
263 class TestCleanPathLink(TestCase):
264     def setUp(self):
265         self.tmpdir = tempfile.mkdtemp()
266         self.to_path = os.path.join(self.tmpdir, "linkto")
267         self.from_path = os.path.join(self.tmpdir, "linkfrom")
268         if salt.utils.platform.is_windows():
269             kwargs = {}
270         else:
271             kwargs = {"target_is_directory": True}
272         if salt.utils.platform.is_windows():
273             symlink(self.to_path, self.from_path, **kwargs)
274         else:
275             os.symlink(self.to_path, self.from_path, **kwargs)
276     def tearDown(self):
277         shutil.rmtree(self.tmpdir)
278     def test_clean_path_symlinked_src(self):
279         test_path = os.path.join(self.from_path, "test")
280         expect_path = os.path.join(self.to_path, "test")
281         ret = clean_path(self.from_path, test_path)
282         assert ret == expect_path, "{} is not {}".format(ret, expect_path)
283     def test_clean_path_symlinked_tgt(self):
284         test_path = os.path.join(self.to_path, "test")
285         expect_path = os.path.join(self.to_path, "test")
286         ret = clean_path(self.from_path, test_path)
287         assert ret == expect_path, "{} is not {}".format(ret, expect_path)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>opkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
2 import errno
3 import logging
4 import os
5 import pathlib
6 import re
7 import shlex
8 import salt.utils.args
9 import salt.utils.data
10 import salt.utils.files
11 import salt.utils.itertools
12 import salt.utils.path
13 import salt.utils.pkg
14 import salt.utils.stringutils
15 import salt.utils.versions
16 from</b></font> salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
17 REPO_REGEXP = r'^#?\s*(src|src/gz)\s+([^\s&lt;&gt;]+|"[^&lt;&gt;]+")\s+[^\s&lt;&gt;]+'
18 OPKG_CONFDIR = "/etc/opkg"
19 ATTR_MAP = {
20     "Architecture": "arch",
21     "Homepage": "url",
22     "Installed-Time": "install_date_time_t",
23     "Maintainer": "packager",
24     "Package": "name",
25     "Section": "group",
26 }
27 log = logging.getLogger(__name__)
28 __virtualname__ = "pkg"
29 NILRT_RESTARTCHECK_STATE_PATH = "/var/lib/salt/restartcheck_state"
30 def _get_nisysapi_conf_d_path():
31     return "/usr/lib/{}/nisysapi/conf.d/experts/".format(
32         "arm-linux-gnueabi"
33         if "arm" in __grains__.get("cpuarch")
34         else "x86_64-linux-gnu"
35     )
36 def _update_nilrt_restart_state():
37     uname = __salt__["cmd.run_stdout"]("uname -r")
38     __salt__["cmd.shell"](
39         "stat -c %Y /lib/modules/{}/modules.dep &gt;{}/modules.dep.timestamp".format(
40 <a name="1"></a>            uname, NILRT_RESTARTCHECK_STATE_PATH
41         )
42     )
43     __salt__<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["cmd.shell"](
44         "md5sum /lib/modules/{}/modules.dep &gt;{}/modules.dep.md5sum".format(
45             uname, NILRT_RESTARTCHECK_STATE_PATH
46         )
47     )
48     nisysapi_path = "/usr/local/natinst/share/nisysapi.ini"
49     if os.path.exists(nisysapi_path):
50         __salt__["cmd.shell"](
51             "stat -c %Y {} &gt;{}/nisysapi.ini.timestamp".format(
52                 nisysapi_path, NILRT_RESTARTCHECK_STATE_PATH
53             )
54         )
55         __salt__[</b></font>"cmd.shell"](
56             "md5sum {} &gt;{}/nisysapi.ini.md5sum".format(
57                 nisysapi_path, NILRT_RESTARTCHECK_STATE_PATH
58             )
59         )
60     nisysapi_conf_d_path = _get_nisysapi_conf_d_path()
61     if os.path.exists(nisysapi_conf_d_path):
62         with salt.utils.files.fopen(
63             "{}/sysapi.conf.d.count".format(NILRT_RESTARTCHECK_STATE_PATH), "w"
64         ) as fcount:
65             fcount.write(str(len(os.listdir(nisysapi_conf_d_path))))
66         for fexpert in os.listdir(nisysapi_conf_d_path):
67             _fingerprint_file(
68                 filename=pathlib.Path(nisysapi_conf_d_path, fexpert),
69                 fingerprint_dir=pathlib.Path(NILRT_RESTARTCHECK_STATE_PATH),
70             )
71 def _fingerprint_file(*, filename, fingerprint_dir):
72     __salt__["cmd.shell"](
73         "stat -c %Y {} &gt; {}/{}.timestamp".format(
74             filename, fingerprint_dir, filename.name
75         )
76     )
77     __salt__["cmd.shell"](
78         "md5sum {} &gt; {}/{}.md5sum".format(filename, fingerprint_dir, filename.name)
79     )
80 def _get_restartcheck_result(errors):
81     rs_result = __salt__["restartcheck.restartcheck"](verbose=False)
82     if isinstance(rs_result, dict) and "comment" in rs_result:
83         errors.append(rs_result["comment"])
84     return rs_result
85 def _process_restartcheck_result(rs_result):
86     if "No packages seem to need to be restarted" in rs_result:
87         return
88     for rstr in rs_result:
89         if "System restart required" in rstr:
90             _update_nilrt_restart_state()
91             __salt__["system.set_reboot_required_witnessed"]()
92         else:
93             service = os.path.join("/etc/init.d", rstr)
94             if os.path.exists(service):
95                 __salt__["cmd.run"]([service, "restart"])
96 def __virtual__():
97     if __grains__.get("os_family") == "NILinuxRT":
98         try:
99             os.makedirs(NILRT_RESTARTCHECK_STATE_PATH)
100         except OSError as exc:
101             if exc.errno != errno.EEXIST:
102                 return (
103                     False,
104                     "Error creating {} (-{}): {}".format(
105                         NILRT_RESTARTCHECK_STATE_PATH, exc.errno, exc.strerror
106                     ),
107                 )
108         if not os.listdir(NILRT_RESTARTCHECK_STATE_PATH):
109             _update_nilrt_restart_state()
110         return __virtualname__
111     if os.path.isdir(OPKG_CONFDIR):
112         return __virtualname__
113     return False, "Module opkg only works on OpenEmbedded based systems"
114 def latest_version(*names, **kwargs):
115     refresh = salt.utils.data.is_true(kwargs.pop("refresh", True))
116     if len(names) == 0:
117         return ""
118     ret = {}
119     for name in names:
120         ret[name] = ""
121     if refresh:
122         refresh_db()
123     cmd = ["opkg", "list-upgradable"]
124     out = __salt__["cmd.run_stdout"](cmd, output_loglevel="trace", python_shell=False)
125     for line in salt.utils.itertools.split(out, "\n"):
126         try:
127             name, _oldversion, newversion = line.split(" - ")
128             if name in names:
129                 ret[name] = newversion
130         except ValueError:
131             pass
132     if len(names) == 1:
133         return ret[names[0]]
134     return ret
135 available_version = latest_version
136 def version(*names, **kwargs):
137     return __salt__["pkg_resource.version"](*names, **kwargs)
138 def refresh_db(failhard=False, **kwargs):  # pylint: disable=unused-argument
139     salt.utils.pkg.clear_rtag(__opts__)
140     ret = {}
141     error_repos = []
142     cmd = ["opkg", "update"]
143     call = __salt__["cmd.run_all"](
144         cmd,
145         output_loglevel="trace",
146         python_shell=False,
147         ignore_retcode=True,
148         redirect_stderr=True,
149     )
150     out = call["stdout"]
151     prev_line = ""
152     for line in salt.utils.itertools.split(out, "\n"):
153         if "Inflating" in line:
154             key = line.strip().split()[1][:-1]
155             ret[key] = True
156         elif "Updated source" in line:
157             key = prev_line.strip().split()[1][:-1]
158             ret[key] = True
159         elif "Failed to download" in line:
160             key = line.strip().split()[5].split(",")[0]
161             ret[key] = False
162             error_repos.append(key)
163         prev_line = line
164     if failhard and error_repos:
165         raise CommandExecutionError(
166             "Error getting repos: {}".format(", ".join(error_repos))
167         )
168     if call["retcode"] != 0 and not error_repos:
169         raise CommandExecutionError(out)
170     return ret
171 def _is_testmode(**kwargs):
172     return bool(kwargs.get("test") or __opts__.get("test"))
173 def _append_noaction_if_testmode(cmd, **kwargs):
174     if _is_testmode(**kwargs):
175         cmd.append("--noaction")
176 def _build_install_command_list(cmd_prefix, to_install, to_downgrade, to_reinstall):
177     cmds = []
178     if to_install:
179         cmd = copy.deepcopy(cmd_prefix)
180         cmd.extend(to_install)
181         cmds.append(cmd)
182     if to_downgrade:
183         cmd = copy.deepcopy(cmd_prefix)
184         cmd.append("--force-downgrade")
185         cmd.extend(to_downgrade)
186         cmds.append(cmd)
187     if to_reinstall:
188         cmd = copy.deepcopy(cmd_prefix)
189         cmd.append("--force-reinstall")
190         cmd.extend(to_reinstall)
191         cmds.append(cmd)
192     return cmds
193 def _parse_reported_packages_from_install_output(output):
194     reported_pkgs = {}
195     install_pattern = re.compile(
196         r"Installing\s(?P&lt;package&gt;.*?)\s\((?P&lt;version&gt;.*?)\)\son\s(?P&lt;target&gt;.*?)"
197     )
198     upgrade_pattern = re.compile(
199         r"Upgrading\s(?P&lt;package&gt;.*?)\sfrom\s(?P&lt;oldVersion&gt;.*?)\sto\s(?P&lt;version&gt;.*?)\son\s(?P&lt;target&gt;.*?)"
200     )
201     for line in salt.utils.itertools.split(output, "\n"):
202         match = install_pattern.match(line)
203         if match is None:
204             match = upgrade_pattern.match(line)
205         if match:
206             reported_pkgs[match.group("package")] = match.group("version")
207     return reported_pkgs
208 def _execute_install_command(cmd, parse_output, errors, parsed_packages):
209     out = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
210     if out["retcode"] != 0:
211         if out["stderr"]:
212             errors.append(out["stderr"])
213         else:
214             errors.append(out["stdout"])
215     elif parse_output:
216         parsed_packages.update(
217             _parse_reported_packages_from_install_output(out["stdout"])
218         )
219 def install(
220     name=None, refresh=False, pkgs=None, sources=None, reinstall=False, **kwargs
221 ):
222     refreshdb = salt.utils.data.is_true(refresh)
223     try:
224         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
225             name, pkgs, sources, **kwargs
226         )
227     except MinionError as exc:
228         raise CommandExecutionError(exc)
229     old = list_pkgs()
230     cmd_prefix = ["opkg", "install"]
231     to_install = []
232     to_reinstall = []
233     to_downgrade = []
234     _append_noaction_if_testmode(cmd_prefix, **kwargs)
235     if pkg_params is None or len(pkg_params) == 0:
236         return {}
237     elif pkg_type == "file":
238         if reinstall:
239             cmd_prefix.append("--force-reinstall")
240         if not kwargs.get("only_upgrade", False):
241             cmd_prefix.append("--force-downgrade")
242         to_install.extend(pkg_params)
243     elif pkg_type == "repository":
244         if not kwargs.get("install_recommends", True):
245             cmd_prefix.append("--no-install-recommends")
246         for pkgname, pkgversion in pkg_params.items():
247             if name and pkgs is None and kwargs.get("version") and len(pkg_params) == 1:
248                 version_num = kwargs["version"]
249             else:
250                 version_num = pkgversion
251             if version_num is None:
252                 if reinstall and pkgname in old:
253                     to_reinstall.append(pkgname)
254                 else:
255                     to_install.append(pkgname)
256             else:
257                 pkgstr = "{}={}".format(pkgname, version_num)
258                 cver = old.get(pkgname, "")
259                 if (
260                     reinstall
261                     and cver
262                     and salt.utils.versions.compare(
263                         ver1=version_num, oper="==", ver2=cver, cmp_func=version_cmp
264                     )
265                 ):
266                     to_reinstall.append(pkgstr)
267                 elif not cver or salt.utils.versions.compare(
268                     ver1=version_num, oper="&gt;=", ver2=cver, cmp_func=version_cmp
269                 ):
270                     to_install.append(pkgstr)
271                 else:
272                     if not kwargs.get("only_upgrade", False):
273                         to_downgrade.append(pkgstr)
274                     else:
275                         to_install.append(pkgstr)
276     cmds = _build_install_command_list(
277         cmd_prefix, to_install, to_downgrade, to_reinstall
278     )
279     if not cmds:
280         return {}
281     if refreshdb:
282         refresh_db()
283     errors = []
284     is_testmode = _is_testmode(**kwargs)
285     test_packages = {}
286     for cmd in cmds:
287         _execute_install_command(cmd, is_testmode, errors, test_packages)
288     __context__.pop("pkg.list_pkgs", None)
289     new = list_pkgs()
290     if is_testmode:
291         new = copy.deepcopy(new)
292         new.update(test_packages)
293     ret = salt.utils.data.compare_dicts(old, new)
294     if pkg_type == "file" and reinstall:
295         for pkgfile in to_install:
296             cmd = ["opkg", "info", pkgfile]
297             out = __salt__["cmd.run_all"](
298                 cmd, output_loglevel="trace", python_shell=False
299             )
300             if out["retcode"] == 0:
301                 pkginfo_dict = _process_info_installed_output(out["stdout"], [])
302                 if pkginfo_dict:
303                     to_reinstall.append(next(iter(pkginfo_dict)))
304     for pkgname in to_reinstall:
305         if pkgname not in ret or pkgname in old:
306             ret.update(
307                 {pkgname: {"old": old.get(pkgname, ""), "new": new.get(pkgname, "")}}
308             )
309     rs_result = _get_restartcheck_result(errors)
310     if errors:
311         raise CommandExecutionError(
312             "Problem encountered installing package(s)",
313             info={"errors": errors, "changes": ret},
314         )
315     _process_restartcheck_result(rs_result)
316     return ret
317 def _parse_reported_packages_from_remove_output(output):
318     reported_pkgs = {}
319     remove_pattern = re.compile(
320         r"Removing\s(?P&lt;package&gt;.*?)\s\((?P&lt;version&gt;.*?)\)\sfrom\s(?P&lt;target&gt;.*?)..."
321     )
322     for line in salt.utils.itertools.split(output, "\n"):
323         match = remove_pattern.match(line)
324         if match:
325             reported_pkgs[match.group("package")] = ""
326     return reported_pkgs
327 def remove(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
328     try:
329         pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
330     except MinionError as exc:
331         raise CommandExecutionError(exc)
332     old = list_pkgs()
333     targets = [x for x in pkg_params if x in old]
334     if not targets:
335         return {}
336     cmd = ["opkg", "remove"]
337     _append_noaction_if_testmode(cmd, **kwargs)
338     if kwargs.get("remove_dependencies", False):
339         cmd.append("--force-removal-of-dependent-packages")
340     if kwargs.get("auto_remove_deps", False):
341         cmd.append("--autoremove")
342     cmd.extend(targets)
343     out = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
344     if out["retcode"] != 0:
345         if out["stderr"]:
346             errors = [out["stderr"]]
347         else:
348             errors = [out["stdout"]]
349     else:
350         errors = []
351     __context__.pop("pkg.list_pkgs", None)
352     new = list_pkgs()
353     if _is_testmode(**kwargs):
354         reportedPkgs = _parse_reported_packages_from_remove_output(out["stdout"])
355         new = {k: v for k, v in new.items() if k not in reportedPkgs}
356     ret = salt.utils.data.compare_dicts(old, new)
357     rs_result = _get_restartcheck_result(errors)
358     if errors:
359         raise CommandExecutionError(
360             "Problem encountered removing package(s)",
361             info={"errors": errors, "changes": ret},
362         )
363     _process_restartcheck_result(rs_result)
364     return ret
365 def purge(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
366     return remove(name=name, pkgs=pkgs)
367 def upgrade(refresh=True, **kwargs):  # pylint: disable=unused-argument
368     ret = {
369         "changes": {},
370         "result": True,
371         "comment": "",
372     }
373     errors = []
374     if salt.utils.data.is_true(refresh):
375         refresh_db()
376     old = list_pkgs()
377     cmd = ["opkg", "upgrade"]
378     result = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
379     __context__.pop("pkg.list_pkgs", None)
380     new = list_pkgs()
381     ret = salt.utils.data.compare_dicts(old, new)
382     if result["retcode"] != 0:
383         errors.append(result)
384     rs_result = _get_restartcheck_result(errors)
385     if errors:
386         raise CommandExecutionError(
387             "Problem encountered upgrading packages",
388             info={"errors": errors, "changes": ret},
389         )
390     _process_restartcheck_result(rs_result)
391     return ret
392 def hold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
393     if not name and not pkgs and not sources:
394         raise SaltInvocationError("One of name, pkgs, or sources must be specified.")
395     if pkgs and sources:
396         raise SaltInvocationError("Only one of pkgs or sources can be specified.")
397     targets = []
398     if pkgs:
399         targets.extend(pkgs)
400     elif sources:
401         for source in sources:
402             targets.append(next(iter(source)))
403     else:
404         targets.append(name)
405     ret = {}
406     for target in targets:
407         if isinstance(target, dict):
408             target = next(iter(target))
409         ret[target] = {"name": target, "changes": {}, "result": False, "comment": ""}
410         state = _get_state(target)
411         if not state:
412             ret[target]["comment"] = "Package {} not currently held.".format(target)
413         elif state != "hold":
414             if "test" in __opts__ and __opts__["test"]:
415                 ret[target].update(result=None)
416                 ret[target]["comment"] = "Package {} is set to be held.".format(target)
417             else:
418                 result = _set_state(target, "hold")
419                 ret[target].update(changes=result[target], result=True)
420                 ret[target]["comment"] = "Package {} is now being held.".format(target)
421         else:
422             ret[target].update(result=True)
423             ret[target]["comment"] = "Package {} is already set to be held.".format(
424                 target
425             )
426     return ret
427 def unhold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
428     if not name and not pkgs and not sources:
429         raise SaltInvocationError("One of name, pkgs, or sources must be specified.")
430     if pkgs and sources:
431         raise SaltInvocationError("Only one of pkgs or sources can be specified.")
432     targets = []
433     if pkgs:
434         targets.extend(pkgs)
435     elif sources:
436         for source in sources:
437             targets.append(next(iter(source)))
438     else:
439         targets.append(name)
440     ret = {}
441     for target in targets:
442         if isinstance(target, dict):
443             target = next(iter(target))
444         ret[target] = {"name": target, "changes": {}, "result": False, "comment": ""}
445         state = _get_state(target)
446         if not state:
447             ret[target]["comment"] = "Package {} does not have a state.".format(target)
448         elif state == "hold":
449             if "test" in __opts__ and __opts__["test"]:
450                 ret[target].update(result=None)
451                 ret["comment"] = "Package {} is set not to be held.".format(target)
452             else:
453                 result = _set_state(target, "ok")
454                 ret[target].update(changes=result[target], result=True)
455                 ret[target]["comment"] = "Package {} is no longer being held.".format(
456                     target
457                 )
458         else:
459             ret[target].update(result=True)
460             ret[target]["comment"] = "Package {} is already set not to be held.".format(
461                 target
462             )
463     return ret
464 def _get_state(pkg):
465     cmd = ["opkg", "status"]
466     cmd.append(pkg)
467     out = __salt__["cmd.run"](cmd, python_shell=False)
468     state_flag = ""
469     for line in salt.utils.itertools.split(out, "\n"):
470         if line.startswith("Status"):
471             _status, _state_want, state_flag, _state_status = line.split()
472     return state_flag
473 def _set_state(pkg, state):
474     ret = {}
475     valid_states = ("hold", "noprune", "user", "ok", "installed", "unpacked")
476     if state not in valid_states:
477         raise SaltInvocationError("Invalid state: {}".format(state))
478     oldstate = _get_state(pkg)
479     cmd = ["opkg", "flag"]
480     cmd.append(state)
481     cmd.append(pkg)
482     _out = __salt__["cmd.run"](cmd, python_shell=False)
483     ret[pkg] = {"old": oldstate, "new": state}
484     return ret
485 def _list_pkgs_from_context(versions_as_list):
486     if versions_as_list:
487         return __context__["pkg.list_pkgs"]
488     else:
489         ret = copy.deepcopy(__context__["pkg.list_pkgs"])
490         __salt__["pkg_resource.stringify"](ret)
491         return ret
492 def list_pkgs(versions_as_list=False, **kwargs):
493     versions_as_list = salt.utils.data.is_true(versions_as_list)
494     if any(
495         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
496     ):
497         return {}
498     if "pkg.list_pkgs" in __context__:
499         return _list_pkgs_from_context(versions_as_list)
500     cmd = ["opkg", "list-installed"]
501     ret = {}
502     out = __salt__["cmd.run"](cmd, output_loglevel="trace", python_shell=False)
503     for line in salt.utils.itertools.split(out, "\n"):
504         if not line or line[0] == " ":
505             continue
506         pkg_name, pkg_version = line.split(" - ", 2)[:2]
507         __salt__["pkg_resource.add_pkg"](ret, pkg_name, pkg_version)
508     __salt__["pkg_resource.sort_pkglist"](ret)
509     __context__["pkg.list_pkgs"] = copy.deepcopy(ret)
510     if not versions_as_list:
511         __salt__["pkg_resource.stringify"](ret)
512     return ret
513 def list_upgrades(refresh=True, **kwargs):  # pylint: disable=unused-argument
514     ret = {}
515     if salt.utils.data.is_true(refresh):
516         refresh_db()
517     cmd = ["opkg", "list-upgradable"]
518     call = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
519     if call["retcode"] != 0:
520         comment = ""
521         if "stderr" in call:
522             comment += call["stderr"]
523         if "stdout" in call:
524             comment += call["stdout"]
525         raise CommandExecutionError(comment)
526     else:
527         out = call["stdout"]
528     for line in out.splitlines():
529         name, _oldversion, newversion = line.split(" - ")
530         ret[name] = newversion
531     return ret
532 def _convert_to_standard_attr(attr):
533     ret_attr = ATTR_MAP.get(attr, None)
534     if ret_attr is None:
535         return attr.lower()
536     return ret_attr
537 def _process_info_installed_output(out, filter_attrs):
538     ret = {}
539     name = None
540     attrs = {}
541     attr = None
542     for line in salt.utils.itertools.split(out, "\n"):
543         if line and line[0] == " ":
544             if filter_attrs is None or attr in filter_attrs:
545                 line = line.strip()
546                 if attrs[attr]:
547                     attrs[attr] += "\n"
548                 attrs[attr] += line
549             continue
550         line = line.strip()
551         if not line:
552             if name:
553                 ret[name] = attrs
554             name = None
555             attrs = {}
556             attr = None
557             continue
558         key, value = line.split(":", 1)
559         value = value.lstrip()
560         attr = _convert_to_standard_attr(key)
561         if attr == "name":
562             name = value
563         elif filter_attrs is None or attr in filter_attrs:
564             attrs[attr] = value
565     if name:
566         ret[name] = attrs
567     return ret
568 def info_installed(*names, **kwargs):
569     attr = kwargs.pop("attr", None)
570     if attr is None:
571         filter_attrs = None
572     elif isinstance(attr, str):
573         filter_attrs = set(attr.split(","))
574     else:
575         filter_attrs = set(attr)
576     ret = {}
577     if names:
578         for name in names:
579             cmd = ["opkg", "status", name]
580             call = __salt__["cmd.run_all"](
581                 cmd, output_loglevel="trace", python_shell=False
582             )
583             if call["retcode"] != 0:
584                 comment = ""
585                 if call["stderr"]:
586                     comment += call["stderr"]
587                 else:
588                     comment += call["stdout"]
589                 raise CommandExecutionError(comment)
590             ret.update(_process_info_installed_output(call["stdout"], filter_attrs))
591     else:
592         cmd = ["opkg", "status"]
593         call = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
594         if call["retcode"] != 0:
595             comment = ""
596             if call["stderr"]:
597                 comment += call["stderr"]
598             else:
599                 comment += call["stdout"]
600             raise CommandExecutionError(comment)
601         ret.update(_process_info_installed_output(call["stdout"], filter_attrs))
602     return ret
603 def upgrade_available(name, **kwargs):  # pylint: disable=unused-argument
604     return latest_version(name) != ""
605 def version_cmp(
606     pkg1, pkg2, ignore_epoch=False, **kwargs
607 ):  # pylint: disable=unused-argument
608     normalize = lambda x: str(x).split(":", 1)[-1] if ignore_epoch else str(x)
609     pkg1 = normalize(pkg1)
610     pkg2 = normalize(pkg2)
611     output = __salt__["cmd.run_stdout"](
612         ["opkg", "--version"], output_loglevel="trace", python_shell=False
613     )
614     opkg_version = output.split(" ")[2].strip()
615     if salt.utils.versions.LooseVersion(
616         opkg_version
617     ) &gt;= salt.utils.versions.LooseVersion("0.3.4"):
618         cmd_compare = ["opkg", "compare-versions"]
619     elif salt.utils.path.which("opkg-compare-versions"):
620         cmd_compare = ["opkg-compare-versions"]
621     else:
622         log.warning(
623             "Unable to find a compare-versions utility installed. Either upgrade opkg"
624             " to version &gt; 0.3.4 (preferred) or install the older opkg-compare-versions"
625             " script."
626         )
627         return None
628     for oper, ret in (("&lt;&lt;", -1), ("=", 0), ("&gt;&gt;", 1)):
629         cmd = cmd_compare[:]
630         cmd.append(shlex.quote(pkg1))
631         cmd.append(oper)
632         cmd.append(shlex.quote(pkg2))
633         retcode = __salt__["cmd.retcode"](
634             cmd, output_loglevel="trace", ignore_retcode=True, python_shell=False
635         )
636         if retcode == 0:
637             return ret
638     return None
639 def _set_repo_option(repo, option):
640     if not option:
641         return
642     opt = option.split("=")
643     if len(opt) != 2:
644         return
645     if opt[0] == "trusted":
646         repo["trusted"] = opt[1] == "yes"
647     else:
648         repo[opt[0]] = opt[1]
649 def _set_repo_options(repo, options):
650     delimiters = "[", "]"
651     pattern = "|".join(map(re.escape, delimiters))
652     for option in options:
653         splitted = re.split(pattern, option)
654         for opt in splitted:
655             _set_repo_option(repo, opt)
656 def _create_repo(line, filename):
657     repo = {}
658     if line.startswith("#"):
659         repo["enabled"] = False
660         line = line[1:]
661     else:
662         repo["enabled"] = True
663     cols = salt.utils.args.shlex_split(line.strip())
664     repo["compressed"] = not cols[0] in "src"
665     repo["name"] = cols[1]
666     repo["uri"] = cols[2]
667     repo["file"] = os.path.join(OPKG_CONFDIR, filename)
668     if len(cols) &gt; 3:
669         _set_repo_options(repo, cols[3:])
670     return repo
671 def _read_repos(conf_file, repos, filename, regex):
672     for line in conf_file:
673         line = salt.utils.stringutils.to_unicode(line)
674         if not regex.search(line):
675             continue
676         repo = _create_repo(line, filename)
677         if repo["uri"] not in repos:
678             repos[repo["uri"]] = [repo]
679 def list_repos(**kwargs):  # pylint: disable=unused-argument
680     repos = {}
681     regex = re.compile(REPO_REGEXP)
682     for filename in os.listdir(OPKG_CONFDIR):
683         if not filename.endswith(".conf"):
684             continue
685         with salt.utils.files.fopen(os.path.join(OPKG_CONFDIR, filename)) as conf_file:
686             _read_repos(conf_file, repos, filename, regex)
687     return repos
688 def get_repo(repo, **kwargs):  # pylint: disable=unused-argument
689     repos = list_repos()
690     if repos:
691         for source in repos.values():
692             for sub in source:
693                 if sub["name"] == repo:
694                     return sub
695     return {}
696 def _del_repo_from_file(repo, filepath):
697     with salt.utils.files.fopen(filepath) as fhandle:
698         output = []
699         regex = re.compile(REPO_REGEXP)
700         for line in fhandle:
701             line = salt.utils.stringutils.to_unicode(line)
702             if regex.search(line):
703                 if line.startswith("#"):
704                     line = line[1:]
705                 cols = salt.utils.args.shlex_split(line.strip())
706                 if repo != cols[1]:
707                     output.append(salt.utils.stringutils.to_str(line))
708     with salt.utils.files.fopen(filepath, "w") as fhandle:
709         fhandle.writelines(output)
710 def _set_trusted_option_if_needed(repostr, trusted):
711     if trusted is True:
712         repostr += " [trusted=yes]"
713     elif trusted is False:
714         repostr += " [trusted=no]"
715     return repostr
716 def _add_new_repo(repo, properties):
717     repostr = "# " if not properties.get("enabled") else ""
718     repostr += "src/gz " if properties.get("compressed") else "src "
719     if " " in repo:
720         repostr += '"' + repo + '" '
721     else:
722         repostr += repo + " "
723     repostr += properties.get("uri")
724     repostr = _set_trusted_option_if_needed(repostr, properties.get("trusted"))
725     repostr += "\n"
726     conffile = os.path.join(OPKG_CONFDIR, repo + ".conf")
727     with salt.utils.files.fopen(conffile, "a") as fhandle:
728         fhandle.write(salt.utils.stringutils.to_str(repostr))
729 def _mod_repo_in_file(repo, repostr, filepath):
730     with salt.utils.files.fopen(filepath) as fhandle:
731         output = []
732         for line in fhandle:
733             cols = salt.utils.args.shlex_split(
734                 salt.utils.stringutils.to_unicode(line).strip()
735             )
736             if repo not in cols:
737                 output.append(line)
738             else:
739                 output.append(salt.utils.stringutils.to_str(repostr + "\n"))
740     with salt.utils.files.fopen(filepath, "w") as fhandle:
741         fhandle.writelines(output)
742 def del_repo(repo, **kwargs):  # pylint: disable=unused-argument
743     refresh = salt.utils.data.is_true(kwargs.get("refresh", True))
744     repos = list_repos()
745     if repos:
746         deleted_from = dict()
747         for repository in repos:
748             source = repos[repository][0]
749             if source["name"] == repo:
750                 deleted_from[source["file"]] = 0
751                 _del_repo_from_file(repo, source["file"])
752         if deleted_from:
753             ret = ""
754             for repository in repos:
755                 source = repos[repository][0]
756                 if source["file"] in deleted_from:
757                     deleted_from[source["file"]] += 1
758             for repo_file, count in deleted_from.items():
759                 msg = "Repo '{}' has been removed from {}.\n"
760                 if count == 1 and os.path.isfile(repo_file):
761                     msg = "File {1} containing repo '{0}' has been removed.\n"
762                     try:
763                         os.remove(repo_file)
764                     except OSError:
765                         pass
766                 ret += msg.format(repo, repo_file)
767             if refresh:
768                 refresh_db()
769             return ret
770     return "Repo {} doesn't exist in the opkg repo lists".format(repo)
771 def mod_repo(repo, **kwargs):
772     repos = list_repos()
773     found = False
774     uri = ""
775     if "uri" in kwargs:
776         uri = kwargs["uri"]
777     for repository in repos:
778         source = repos[repository][0]
779         if source["name"] == repo:
780             found = True
781             repostr = ""
782             if "enabled" in kwargs and not kwargs["enabled"]:
783                 repostr += "# "
784             if "compressed" in kwargs:
785                 repostr += "src/gz " if kwargs["compressed"] else "src"
786             else:
787                 repostr += "src/gz" if source["compressed"] else "src"
788             repo_alias = kwargs["alias"] if "alias" in kwargs else repo
789             if " " in repo_alias:
790                 repostr += ' "{}"'.format(repo_alias)
791             else:
792                 repostr += " {}".format(repo_alias)
793             repostr += " {}".format(kwargs["uri"] if "uri" in kwargs else source["uri"])
794             trusted = kwargs.get("trusted")
795             repostr = (
796                 _set_trusted_option_if_needed(repostr, trusted)
797                 if trusted is not None
798                 else _set_trusted_option_if_needed(repostr, source.get("trusted"))
799             )
800             _mod_repo_in_file(repo, repostr, source["file"])
801         elif uri and source["uri"] == uri:
802             raise CommandExecutionError(
803                 "Repository '{}' already exists as '{}'.".format(uri, source["name"])
804             )
805     if not found:
806         if "uri" not in kwargs:
807             raise CommandExecutionError(
808                 "Repository '{}' not found and no URI passed to create one.".format(
809                     repo
810                 )
811             )
812         properties = {"uri": kwargs["uri"]}
813         properties["compressed"] = (
814             kwargs["compressed"] if "compressed" in kwargs else True
815         )
816         properties["enabled"] = kwargs["enabled"] if "enabled" in kwargs else True
817         properties["trusted"] = kwargs.get("trusted")
818         _add_new_repo(repo, properties)
819     if "refresh" in kwargs:
820         refresh_db()
821 def file_list(*packages, **kwargs):  # pylint: disable=unused-argument
822     output = file_dict(*packages)
823     files = []
824     for package in list(output["packages"].values()):
825         files.extend(package)
826     return {"errors": output["errors"], "files": files}
827 def file_dict(*packages, **kwargs):  # pylint: disable=unused-argument
828     errors = []
829     ret = {}
830     cmd_files = ["opkg", "files"]
831     if not packages:
832         packages = list(list_pkgs().keys())
833     for package in packages:
834         files = []
835         cmd = cmd_files[:]
836         cmd.append(package)
837         out = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
838         for line in out["stdout"].splitlines():
839             if line.startswith("/"):
840                 files.append(line)
841             elif line.startswith(" * "):
842                 errors.append(line[3:])
843                 break
844             else:
845                 continue
846         if files:
847             ret[package] = files
848     return {"errors": errors, "packages": ret}
849 def owner(*paths, **kwargs):  # pylint: disable=unused-argument
850     if not paths:
851         return ""
852     ret = {}
853     cmd_search = ["opkg", "search"]
854     for path in paths:
855         cmd = cmd_search[:]
856         cmd.append(path)
857         output = __salt__["cmd.run_stdout"](
858             cmd, output_loglevel="trace", python_shell=False
859         )
860         if output:
861             ret[path] = output.split(" - ")[0].strip()
862         else:
863             ret[path] = ""
864     if len(ret) == 1:
865         return next(iter(ret.values()))
866     return ret
867 def version_clean(version):
868     return version
869 def check_extra_requirements(pkgname, pkgver):
870     return True
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
