<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_verify_1.py &amp; opkg.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_verify_1.py &amp; opkg.py
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_verify_1.py (4.608295%)<th>opkg.py (1.6277808%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-33)<td><a href="#" name="0">(19-35)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(171-179)<td><a href="#" name="1">(82-97)</a><td align="center"><font color="#df0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_verify_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import ctypes
2 import getpass
3 import os
4 import shutil
5 import socket
6 import stat
7 import sys
8 import tempfile
9 import pytest
10 import salt.utils.files
11 import salt.utils.platform
12 from salt.utils.verify import (
13     check_max_open_files,
14     check_user,
15     clean_path,
16     log,
17     valid_id,
18     verify_env,
19     verify_log,
20     verify_log_files,
21     verify_logs_filter,
22     verify_socket,
23     zmq_version,
24 )
25 from tests.support.helpers import TstSuiteLoggingHandler
26 from tests.support.mock import MagicMock, patch
27 from tests.support.runtests import RUNTIME_VARS
28 from</b></font> tests.support.unit import TestCase, skipIf
29 if sys.platform.startswith("win"):
30     import win32file
31 else:
32     import resource
33 class TestVerify(TestCase):
34     def test_valid_id_exception_handler(self):
35         opts = {"pki_dir": "/tmp/whatever"}
36         self.assertFalse(valid_id(opts, None))
37     def test_valid_id_pathsep(self):
38         opts = {"pki_dir": "/tmp/whatever"}
39         for pathsep in ("/", "\\"):
40             self.assertFalse(valid_id(opts, pathsep.join(("..", "foobar"))))
41     def test_zmq_verify(self):
42         self.assertTrue(zmq_version())
43     def test_zmq_verify_insufficient(self):
44         import zmq
45         with patch.object(zmq, "__version__", "2.1.0"):
46             self.assertFalse(zmq_version())
47     def test_user(self):
48         self.assertTrue(check_user(getpass.getuser()))
49     def test_no_user(self):
50         class FakeWriter:
51             def __init__(self):
52                 self.output = ""
53                 self.errors = "strict"
54             def write(self, data):
55                 self.output += data
56             def flush(self):
57                 pass
58         stderr = sys.stderr
59         writer = FakeWriter()
60         sys.stderr = writer
61         try:
62             if sys.platform.startswith("win"):
63                 self.assertTrue(check_user("nouser"))
64             else:
65                 with self.assertRaises(SystemExit):
66                     self.assertFalse(check_user("nouser"))
67         finally:
68             sys.stderr = stderr
69         if writer.output != 'CRITICAL: User not found: "nouser"\n':
70             sys.stderr.write(writer.output)
71     @skipIf(salt.utils.platform.is_windows(), "No verify_env Windows")
72     def test_verify_env(self):
73         root_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
74         var_dir = os.path.join(root_dir, "var", "log", "salt")
75         key_dir = os.path.join(root_dir, "key_dir")
76         verify_env([var_dir], getpass.getuser(), root_dir=root_dir)
77         self.assertTrue(os.path.exists(var_dir))
78         dir_stat = os.stat(var_dir)
79         self.assertEqual(dir_stat.st_uid, os.getuid())
80         self.assertEqual(dir_stat.st_mode &amp; stat.S_IRWXU, stat.S_IRWXU)
81         self.assertEqual(dir_stat.st_mode &amp; stat.S_IRWXG, 40)
82         self.assertEqual(dir_stat.st_mode &amp; stat.S_IRWXO, 5)
83     @pytest.mark.requires_network(only_local_network=True)
84     def test_verify_socket(self):
85         self.assertTrue(verify_socket("", 18000, 18001))
86         if socket.has_ipv6:
87             try:
88                 self.assertTrue(verify_socket("::", 18000, 18001))
89             except OSError:
90                 pass
91     def test_max_open_files(self):
92         with TstSuiteLoggingHandler() as handler:
93             logmsg_dbg = "DEBUG:This salt-master instance has accepted {0} minion keys."
94             logmsg_chk = (
95                 "{0}:The number of accepted minion keys({1}) should be lower "
96                 "than 1/4 of the max open files soft setting({2}). According "
97                 "to the system's hard limit, there's still a margin of {3} "
98                 "to raise the salt's max_open_files setting. Please consider "
99                 "raising this value."
100             )
101             logmsg_crash = (
102                 "{0}:The number of accepted minion keys({1}) should be lower "
103                 "than 1/4 of the max open files soft setting({2}). "
104                 "salt-master will crash pretty soon! According to the "
105                 "system's hard limit, there's still a margin of {3} to "
106                 "raise the salt's max_open_files setting. Please consider "
107                 "raising this value."
108             )
109             if sys.platform.startswith("win"):
110                 logmsg_crash = (
111                     "{0}:The number of accepted minion keys({1}) should be lower "
112                     "than 1/4 of the max open files soft setting({2}). "
113                     "salt-master will crash pretty soon! Please consider "
114                     "raising this value."
115                 )
116             if sys.platform.startswith("win"):
117                 mof_s = mof_h = win32file._getmaxstdio()
118                 mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)
119             tempdir = tempfile.mkdtemp(prefix="fake-keys")
120             keys_dir = os.path<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.join(tempdir, "minions")
121             os.makedirs(keys_dir)
122             mof_test = 256
123             if sys.platform.startswith("win"):
124                 win32file._setmaxstdio(mof_test)
125             else:
126                 resource.setrlimit(resource.</b></font>RLIMIT_NOFILE, (mof_test, mof_h))
127             try:
128                 prev = 0
129                 for newmax, level in (
130                     (24, None),
131                     (66, "INFO"),
132                     (127, "WARNING"),
133                     (196, "CRITICAL"),
134                 ):
135                     for n in range(prev, newmax):
136                         kpath = os.path.join(keys_dir, str(n))
137                         with salt.utils.files.fopen(kpath, "w") as fp_:
138                             fp_.write(str(n))
139                     opts = {"max_open_files": newmax, "pki_dir": tempdir}
140                     check_max_open_files(opts)
141                     if level is None:
142                         self.assertEqual([logmsg_dbg.format(newmax)], handler.messages)
143                     else:
144                         self.assertIn(logmsg_dbg.format(newmax), handler.messages)
145                         self.assertIn(
146                             logmsg_chk.format(
147                                 level,
148                                 newmax,
149                                 mof_test,
150                                 mof_test - newmax
151                                 if sys.platform.startswith("win")
152                                 else mof_h - newmax,
153                             ),
154                             handler.messages,
155                         )
156                     handler.clear()
157                     prev = newmax
158                 newmax = mof_test
159                 for n in range(prev, newmax):
160                     kpath = os.path.join(keys_dir, str(n))
161                     with salt.utils.files.fopen(kpath, "w") as fp_:
162                         fp_.write(str(n))
163                 opts = {"max_open_files": newmax, "pki_dir": tempdir}
164                 check_max_open_files(opts)
165                 self.assertIn(logmsg_dbg.format(newmax), handler.messages)
166                 self.assertIn(
167                     logmsg_crash.format(
168                         "CRITICAL",
169                         newmax,
170                         mof_test,
171                         mof_test - newmax
172                         if sys.platform.startswith("win")
173                         else mof_h - newmax,
174                     ),
175                     handler.messages,
176                 )
177                 handler.clear()
178             except OSError as err:
179                 if err.errno == 24:
180                     self.skipTest("We've hit the max open files setting")
181                 raise
182             finally:
183                 if sys.platform.startswith("win"):
184                     win32file._setmaxstdio(mof_h)
185                 else:
186                     resource.setrlimit(resource.RLIMIT_NOFILE, (mof_s, mof_h))
187                 shutil.rmtree(tempdir)
188     def test_verify_log(self):
189         message = (
190             "Insecure logging configuration detected! Sensitive data may be logged."
191         )
192         mock_cheese = MagicMock()
193         with patch.object(log, "warning", mock_cheese):
194             verify_log({"log_level": "cheeseshop"})
195             mock_cheese.assert_called_once_with(message)
196         mock_trace = MagicMock()
197         with patch.object(log, "warning", mock_trace):
198             verify_log({"log_level": "trace"})
199             mock_trace.assert_called_once_with(message)
200         mock_none = MagicMock()
201         with patch.object(log, "warning", mock_none):
202             verify_log({})
203             mock_none.assert_called_once_with(message)
204         mock_info = MagicMock()
205         with patch.object(log, "warning", mock_info):
206             verify_log({"log_level": "info"})
207             self.assertTrue(mock_info.call_count == 0)
208 class TestVerifyLog(TestCase):
209     def setUp(self):
210         self.tmpdir = tempfile.mkdtemp()
211     def tearDown(self):
212         shutil.rmtree(self.tmpdir)
213     def test_verify_logs_filter(self):
214         filtered = verify_logs_filter(
215             ["udp://foo", "tcp://bar", "/tmp/foo", "file://tmp/bar"]
216         )
217         assert filtered == ["/tmp/foo"], filtered
218     @skipIf(salt.utils.platform.is_windows(), "Not applicable on Windows")
219     def test_verify_log_files_udp_scheme(self):
220         verify_log_files(["udp://foo"], getpass.getuser())
221         self.assertFalse(os.path.isdir(os.path.join(os.getcwd(), "udp:")))
222     @skipIf(salt.utils.platform.is_windows(), "Not applicable on Windows")
223     def test_verify_log_files_tcp_scheme(self):
224         verify_log_files(["udp://foo"], getpass.getuser())
225         self.assertFalse(os.path.isdir(os.path.join(os.getcwd(), "tcp:")))
226     @skipIf(salt.utils.platform.is_windows(), "Not applicable on Windows")
227     def test_verify_log_files_file_scheme(self):
228         verify_log_files(["file://{}"], getpass.getuser())
229         self.assertFalse(os.path.isdir(os.path.join(os.getcwd(), "file:")))
230     @skipIf(salt.utils.platform.is_windows(), "Not applicable on Windows")
231     def test_verify_log_files(self):
232         path = os.path.join(self.tmpdir, "foo", "bar.log")
233         self.assertFalse(os.path.exists(path))
234         verify_log_files([path], getpass.getuser())
235         self.assertTrue(os.path.exists(path))
236 class TestCleanPath(TestCase):
237     def setUp(self):
238         self.tmpdir = tempfile.mkdtemp()
239     def tearDown(self):
240         shutil.rmtree(self.tmpdir)
241     def test_clean_path_valid(self):
242         path_a = os.path.join(self.tmpdir, "foo")
243         path_b = os.path.join(self.tmpdir, "foo", "bar")
244         assert clean_path(path_a, path_b) == path_b
245     def test_clean_path_invalid(self):
246         path_a = os.path.join(self.tmpdir, "foo")
247         path_b = os.path.join(self.tmpdir, "baz", "bar")
248         assert clean_path(path_a, path_b) == ""
249 __CSL = None
250 def symlink(source, link_name):
251     global __CSL
252     if __CSL is None:
253         csl = ctypes.windll.kernel32.CreateSymbolicLinkW
254         csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32)
255         csl.restype = ctypes.c_ubyte
256         __CSL = csl
257     flags = 0
258     if source is not None and os.path.isdir(source):
259         flags = 1
260     if __CSL(link_name, source, flags) == 0:
261         raise ctypes.WinError()
262 class TestCleanPathLink(TestCase):
263     def setUp(self):
264         self.tmpdir = tempfile.mkdtemp()
265         self.to_path = os.path.join(self.tmpdir, "linkto")
266         self.from_path = os.path.join(self.tmpdir, "linkfrom")
267         if salt.utils.platform.is_windows():
268             kwargs = {}
269         else:
270             kwargs = {"target_is_directory": True}
271         if salt.utils.platform.is_windows():
272             symlink(self.to_path, self.from_path, **kwargs)
273         else:
274             os.symlink(self.to_path, self.from_path, **kwargs)
275     def tearDown(self):
276         shutil.rmtree(self.tmpdir)
277     def test_clean_path_symlinked_src(self):
278         test_path = os.path.join(self.from_path, "test")
279         expect_path = os.path.join(self.to_path, "test")
280         ret = clean_path(self.from_path, test_path)
281         assert ret == expect_path, "{} is not {}".format(ret, expect_path)
282     def test_clean_path_symlinked_tgt(self):
283         test_path = os.path.join(self.to_path, "test")
284         expect_path = os.path.join(self.to_path, "test")
285         ret = clean_path(self.from_path, test_path)
286         assert ret == expect_path, "{} is not {}".format(ret, expect_path)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>opkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
2 import errno
3 import logging
4 import os
5 import pathlib
6 import re
7 import shlex
8 import salt.utils.args
9 import salt.utils.data
10 import salt.utils.files
11 import salt.utils.itertools
12 import salt.utils.path
13 import salt.utils.pkg
14 import salt.utils.stringutils
15 import salt.utils.versions
16 from</b></font> salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
17 REPO_REGEXP = r'^#?\s*(src|src/gz)\s+([^\s&lt;&gt;]+|"[^&lt;&gt;]+")\s+[^\s&lt;&gt;]+'
18 OPKG_CONFDIR = "/etc/opkg"
19 ATTR_MAP = {
20     "Architecture": "arch",
21     "Homepage": "url",
22     "Installed-Time": "install_date_time_t",
23     "Maintainer": "packager",
24     "Package": "name",
25     "Section": "group",
26 }
27 log = logging.getLogger(__name__)
28 __virtualname__ = "pkg"
29 NILRT_RESTARTCHECK_STATE_PATH = "/var/lib/salt/restartcheck_state"
30 def _get_nisysapi_conf_d_path():
31     return "/usr/lib/{}/nisysapi/conf.d/experts/".format(
32         "arm-linux-gnueabi"
33         if "arm" in __grains__.get("cpuarch")
34         else "x86_64-linux-gnu"
35     )
36 def _update_nilrt_restart_state():
37     uname = __salt__["cmd.run_stdout"]("uname -r")
38     __salt__["cmd.shell"](
39         "stat -c %Y /lib/modules/{}/modules.dep &gt;{}/modules.dep.timestamp".format(
40         )
41     )
42     __salt__<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["cmd.shell"](
43         "md5sum /lib/modules/{}/modules.dep &gt;{}/modules.dep.md5sum".format(
44             uname, NILRT_RESTARTCHECK_STATE_PATH
45         )
46     )
47     nisysapi_path = "/usr/local/natinst/share/nisysapi.ini"
48     if os.path.exists(nisysapi_path):
49         __salt__["cmd.shell"](
50             "stat -c %Y {} &gt;{}/nisysapi.ini.timestamp".format(
51                 nisysapi_path, NILRT_RESTARTCHECK_STATE_PATH
52             )
53         )
54         __salt__[</b></font>"cmd.shell"](
55             "md5sum {} &gt;{}/nisysapi.ini.md5sum".format(
56                 nisysapi_path, NILRT_RESTARTCHECK_STATE_PATH
57             )
58         )
59     nisysapi_conf_d_path = _get_nisysapi_conf_d_path()
60     if os.path.exists(nisysapi_conf_d_path):
61         with salt.utils.files.fopen(
62             "{}/sysapi.conf.d.count".format(NILRT_RESTARTCHECK_STATE_PATH), "w"
63         ) as fcount:
64             fcount.write(str(len(os.listdir(nisysapi_conf_d_path))))
65         for fexpert in os.listdir(nisysapi_conf_d_path):
66             _fingerprint_file(
67                 filename=pathlib.Path(nisysapi_conf_d_path, fexpert),
68                 fingerprint_dir=pathlib.Path(NILRT_RESTARTCHECK_STATE_PATH),
69             )
70 def _fingerprint_file(*, filename, fingerprint_dir):
71     __salt__["cmd.shell"](
72         "stat -c %Y {} &gt; {}/{}.timestamp".format(
73             filename, fingerprint_dir, filename.name
74         )
75     )
76     __salt__["cmd.shell"](
77         "md5sum {} &gt; {}/{}.md5sum".format(filename, fingerprint_dir, filename.name)
78     )
79 def _get_restartcheck_result(errors):
80     rs_result = __salt__["restartcheck.restartcheck"](verbose=False)
81     if isinstance(rs_result, dict) and "comment" in rs_result:
82         errors.append(rs_result["comment"])
83     return rs_result
84 def _process_restartcheck_result(rs_result):
85     if "No packages seem to need to be restarted" in rs_result:
86         return
87     for rstr in rs_result:
88         if "System restart required" in rstr:
89             _update_nilrt_restart_state()
90             __salt__["system.set_reboot_required_witnessed"]()
91         else:
92             service = os.path.join("/etc/init.d", rstr)
93             if os.path.exists(service):
94                 __salt__["cmd.run"]([service, "restart"])
95 def __virtual__():
96     if __grains__.get("os_family") == "NILinuxRT":
97         try:
98             os.makedirs(NILRT_RESTARTCHECK_STATE_PATH)
99         except OSError as exc:
100             if exc.errno != errno.EEXIST:
101                 return (
102                     False,
103                     "Error creating {} (-{}): {}".format(
104                         NILRT_RESTARTCHECK_STATE_PATH, exc.errno, exc.strerror
105                     ),
106                 )
107         if not os.listdir(NILRT_RESTARTCHECK_STATE_PATH):
108             _update_nilrt_restart_state()
109         return __virtualname__
110     if os.path.isdir(OPKG_CONFDIR):
111         return __virtualname__
112     return False, "Module opkg only works on OpenEmbedded based systems"
113 def latest_version(*names, **kwargs):
114     refresh = salt.utils.data.is_true(kwargs.pop("refresh", True))
115     if len(names) == 0:
116         return ""
117     ret = {}
118     for name in names:
119         ret[name] = ""
120     if refresh:
121         refresh_db()
122     cmd = ["opkg", "list-upgradable"]
123     out = __salt__["cmd.run_stdout"](cmd, output_loglevel="trace", python_shell=False)
124     for line in salt.utils.itertools.split(out, "\n"):
125         try:
126             name, _oldversion, newversion = line.split(" - ")
127             if name in names:
128                 ret[name] = newversion
129         except ValueError:
130             pass
131     if len(names) == 1:
132         return ret[names[0]]
133     return ret
134 available_version = latest_version
135 def version(*names, **kwargs):
136     return __salt__["pkg_resource.version"](*names, **kwargs)
137 def refresh_db(failhard=False, **kwargs):  # pylint: disable=unused-argument
138     salt.utils.pkg.clear_rtag(__opts__)
139     ret = {}
140     error_repos = []
141     cmd = ["opkg", "update"]
142     call = __salt__["cmd.run_all"](
143         cmd,
144         output_loglevel="trace",
145         python_shell=False,
146         ignore_retcode=True,
147         redirect_stderr=True,
148     )
149     out = call["stdout"]
150     prev_line = ""
151     for line in salt.utils.itertools.split(out, "\n"):
152         if "Inflating" in line:
153             key = line.strip().split()[1][:-1]
154             ret[key] = True
155         elif "Updated source" in line:
156             key = prev_line.strip().split()[1][:-1]
157             ret[key] = True
158         elif "Failed to download" in line:
159             key = line.strip().split()[5].split(",")[0]
160             ret[key] = False
161             error_repos.append(key)
162         prev_line = line
163     if failhard and error_repos:
164         raise CommandExecutionError(
165             "Error getting repos: {}".format(", ".join(error_repos))
166         )
167     if call["retcode"] != 0 and not error_repos:
168         raise CommandExecutionError(out)
169     return ret
170 def _is_testmode(**kwargs):
171     return bool(kwargs.get("test") or __opts__.get("test"))
172 def _append_noaction_if_testmode(cmd, **kwargs):
173     if _is_testmode(**kwargs):
174         cmd.append("--noaction")
175 def _build_install_command_list(cmd_prefix, to_install, to_downgrade, to_reinstall):
176     cmds = []
177     if to_install:
178         cmd = copy.deepcopy(cmd_prefix)
179         cmd.extend(to_install)
180         cmds.append(cmd)
181     if to_downgrade:
182         cmd = copy.deepcopy(cmd_prefix)
183         cmd.append("--force-downgrade")
184         cmd.extend(to_downgrade)
185         cmds.append(cmd)
186     if to_reinstall:
187         cmd = copy.deepcopy(cmd_prefix)
188         cmd.append("--force-reinstall")
189         cmd.extend(to_reinstall)
190         cmds.append(cmd)
191     return cmds
192 def _parse_reported_packages_from_install_output(output):
193     reported_pkgs = {}
194     install_pattern = re.compile(
195         r"Installing\s(?P&lt;package&gt;.*?)\s\((?P&lt;version&gt;.*?)\)\son\s(?P&lt;target&gt;.*?)"
196     )
197     upgrade_pattern = re.compile(
198         r"Upgrading\s(?P&lt;package&gt;.*?)\sfrom\s(?P&lt;oldVersion&gt;.*?)\sto\s(?P&lt;version&gt;.*?)\son\s(?P&lt;target&gt;.*?)"
199     )
200     for line in salt.utils.itertools.split(output, "\n"):
201         match = install_pattern.match(line)
202         if match is None:
203             match = upgrade_pattern.match(line)
204         if match:
205             reported_pkgs[match.group("package")] = match.group("version")
206     return reported_pkgs
207 def _execute_install_command(cmd, parse_output, errors, parsed_packages):
208     out = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
209     if out["retcode"] != 0:
210         if out["stderr"]:
211             errors.append(out["stderr"])
212         else:
213             errors.append(out["stdout"])
214     elif parse_output:
215         parsed_packages.update(
216             _parse_reported_packages_from_install_output(out["stdout"])
217         )
218 def install(
219     name=None, refresh=False, pkgs=None, sources=None, reinstall=False, **kwargs
220 ):
221     refreshdb = salt.utils.data.is_true(refresh)
222     try:
223         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
224             name, pkgs, sources, **kwargs
225         )
226     except MinionError as exc:
227         raise CommandExecutionError(exc)
228     old = list_pkgs()
229     cmd_prefix = ["opkg", "install"]
230     to_install = []
231     to_reinstall = []
232     to_downgrade = []
233     _append_noaction_if_testmode(cmd_prefix, **kwargs)
234     if pkg_params is None or len(pkg_params) == 0:
235         return {}
236     elif pkg_type == "file":
237         if reinstall:
238             cmd_prefix.append("--force-reinstall")
239         if not kwargs.get("only_upgrade", False):
240             cmd_prefix.append("--force-downgrade")
241         to_install.extend(pkg_params)
242     elif pkg_type == "repository":
243         if not kwargs.get("install_recommends", True):
244             cmd_prefix.append("--no-install-recommends")
245         for pkgname, pkgversion in pkg_params.items():
246             if name and pkgs is None and kwargs.get("version") and len(pkg_params) == 1:
247                 version_num = kwargs["version"]
248             else:
249                 version_num = pkgversion
250             if version_num is None:
251                 if reinstall and pkgname in old:
252                     to_reinstall.append(pkgname)
253                 else:
254                     to_install.append(pkgname)
255             else:
256                 pkgstr = "{}={}".format(pkgname, version_num)
257                 cver = old.get(pkgname, "")
258                 if (
259                     reinstall
260                     and cver
261                     and salt.utils.versions.compare(
262                         ver1=version_num, oper="==", ver2=cver, cmp_func=version_cmp
263                     )
264                 ):
265                     to_reinstall.append(pkgstr)
266                 elif not cver or salt.utils.versions.compare(
267                     ver1=version_num, oper="&gt;=", ver2=cver, cmp_func=version_cmp
268                 ):
269                     to_install.append(pkgstr)
270                 else:
271                     if not kwargs.get("only_upgrade", False):
272                         to_downgrade.append(pkgstr)
273                     else:
274                         to_install.append(pkgstr)
275     cmds = _build_install_command_list(
276         cmd_prefix, to_install, to_downgrade, to_reinstall
277     )
278     if not cmds:
279         return {}
280     if refreshdb:
281         refresh_db()
282     errors = []
283     is_testmode = _is_testmode(**kwargs)
284     test_packages = {}
285     for cmd in cmds:
286         _execute_install_command(cmd, is_testmode, errors, test_packages)
287     __context__.pop("pkg.list_pkgs", None)
288     new = list_pkgs()
289     if is_testmode:
290         new = copy.deepcopy(new)
291         new.update(test_packages)
292     ret = salt.utils.data.compare_dicts(old, new)
293     if pkg_type == "file" and reinstall:
294         for pkgfile in to_install:
295             cmd = ["opkg", "info", pkgfile]
296             out = __salt__["cmd.run_all"](
297                 cmd, output_loglevel="trace", python_shell=False
298             )
299             if out["retcode"] == 0:
300                 pkginfo_dict = _process_info_installed_output(out["stdout"], [])
301                 if pkginfo_dict:
302                     to_reinstall.append(next(iter(pkginfo_dict)))
303     for pkgname in to_reinstall:
304         if pkgname not in ret or pkgname in old:
305             ret.update(
306                 {pkgname: {"old": old.get(pkgname, ""), "new": new.get(pkgname, "")}}
307             )
308     rs_result = _get_restartcheck_result(errors)
309     if errors:
310         raise CommandExecutionError(
311             "Problem encountered installing package(s)",
312             info={"errors": errors, "changes": ret},
313         )
314     _process_restartcheck_result(rs_result)
315     return ret
316 def _parse_reported_packages_from_remove_output(output):
317     reported_pkgs = {}
318     remove_pattern = re.compile(
319         r"Removing\s(?P&lt;package&gt;.*?)\s\((?P&lt;version&gt;.*?)\)\sfrom\s(?P&lt;target&gt;.*?)..."
320     )
321     for line in salt.utils.itertools.split(output, "\n"):
322         match = remove_pattern.match(line)
323         if match:
324             reported_pkgs[match.group("package")] = ""
325     return reported_pkgs
326 def remove(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
327     try:
328         pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
329     except MinionError as exc:
330         raise CommandExecutionError(exc)
331     old = list_pkgs()
332     targets = [x for x in pkg_params if x in old]
333     if not targets:
334         return {}
335     cmd = ["opkg", "remove"]
336     _append_noaction_if_testmode(cmd, **kwargs)
337     if kwargs.get("remove_dependencies", False):
338         cmd.append("--force-removal-of-dependent-packages")
339     if kwargs.get("auto_remove_deps", False):
340         cmd.append("--autoremove")
341     cmd.extend(targets)
342     out = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
343     if out["retcode"] != 0:
344         if out["stderr"]:
345             errors = [out["stderr"]]
346         else:
347             errors = [out["stdout"]]
348     else:
349         errors = []
350     __context__.pop("pkg.list_pkgs", None)
351     new = list_pkgs()
352     if _is_testmode(**kwargs):
353         reportedPkgs = _parse_reported_packages_from_remove_output(out["stdout"])
354         new = {k: v for k, v in new.items() if k not in reportedPkgs}
355     ret = salt.utils.data.compare_dicts(old, new)
356     rs_result = _get_restartcheck_result(errors)
357     if errors:
358         raise CommandExecutionError(
359             "Problem encountered removing package(s)",
360             info={"errors": errors, "changes": ret},
361         )
362     _process_restartcheck_result(rs_result)
363     return ret
364 def purge(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
365     return remove(name=name, pkgs=pkgs)
366 def upgrade(refresh=True, **kwargs):  # pylint: disable=unused-argument
367     ret = {
368         "changes": {},
369         "result": True,
370         "comment": "",
371     }
372     errors = []
373     if salt.utils.data.is_true(refresh):
374         refresh_db()
375     old = list_pkgs()
376     cmd = ["opkg", "upgrade"]
377     result = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
378     __context__.pop("pkg.list_pkgs", None)
379     new = list_pkgs()
380     ret = salt.utils.data.compare_dicts(old, new)
381     if result["retcode"] != 0:
382         errors.append(result)
383     rs_result = _get_restartcheck_result(errors)
384     if errors:
385         raise CommandExecutionError(
386             "Problem encountered upgrading packages",
387             info={"errors": errors, "changes": ret},
388         )
389     _process_restartcheck_result(rs_result)
390     return ret
391 def hold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
392     if not name and not pkgs and not sources:
393         raise SaltInvocationError("One of name, pkgs, or sources must be specified.")
394     if pkgs and sources:
395         raise SaltInvocationError("Only one of pkgs or sources can be specified.")
396     targets = []
397     if pkgs:
398         targets.extend(pkgs)
399     elif sources:
400         for source in sources:
401             targets.append(next(iter(source)))
402     else:
403         targets.append(name)
404     ret = {}
405     for target in targets:
406         if isinstance(target, dict):
407             target = next(iter(target))
408         ret[target] = {"name": target, "changes": {}, "result": False, "comment": ""}
409         state = _get_state(target)
410         if not state:
411             ret[target]["comment"] = "Package {} not currently held.".format(target)
412         elif state != "hold":
413             if "test" in __opts__ and __opts__["test"]:
414                 ret[target].update(result=None)
415                 ret[target]["comment"] = "Package {} is set to be held.".format(target)
416             else:
417                 result = _set_state(target, "hold")
418                 ret[target].update(changes=result[target], result=True)
419                 ret[target]["comment"] = "Package {} is now being held.".format(target)
420         else:
421             ret[target].update(result=True)
422             ret[target]["comment"] = "Package {} is already set to be held.".format(
423                 target
424             )
425     return ret
426 def unhold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
427     if not name and not pkgs and not sources:
428         raise SaltInvocationError("One of name, pkgs, or sources must be specified.")
429     if pkgs and sources:
430         raise SaltInvocationError("Only one of pkgs or sources can be specified.")
431     targets = []
432     if pkgs:
433         targets.extend(pkgs)
434     elif sources:
435         for source in sources:
436             targets.append(next(iter(source)))
437     else:
438         targets.append(name)
439     ret = {}
440     for target in targets:
441         if isinstance(target, dict):
442             target = next(iter(target))
443         ret[target] = {"name": target, "changes": {}, "result": False, "comment": ""}
444         state = _get_state(target)
445         if not state:
446             ret[target]["comment"] = "Package {} does not have a state.".format(target)
447         elif state == "hold":
448             if "test" in __opts__ and __opts__["test"]:
449                 ret[target].update(result=None)
450                 ret["comment"] = "Package {} is set not to be held.".format(target)
451             else:
452                 result = _set_state(target, "ok")
453                 ret[target].update(changes=result[target], result=True)
454                 ret[target]["comment"] = "Package {} is no longer being held.".format(
455                     target
456                 )
457         else:
458             ret[target].update(result=True)
459             ret[target]["comment"] = "Package {} is already set not to be held.".format(
460                 target
461             )
462     return ret
463 def _get_state(pkg):
464     cmd = ["opkg", "status"]
465     cmd.append(pkg)
466     out = __salt__["cmd.run"](cmd, python_shell=False)
467     state_flag = ""
468     for line in salt.utils.itertools.split(out, "\n"):
469         if line.startswith("Status"):
470             _status, _state_want, state_flag, _state_status = line.split()
471     return state_flag
472 def _set_state(pkg, state):
473     ret = {}
474     valid_states = ("hold", "noprune", "user", "ok", "installed", "unpacked")
475     if state not in valid_states:
476         raise SaltInvocationError("Invalid state: {}".format(state))
477     oldstate = _get_state(pkg)
478     cmd = ["opkg", "flag"]
479     cmd.append(state)
480     cmd.append(pkg)
481     _out = __salt__["cmd.run"](cmd, python_shell=False)
482     ret[pkg] = {"old": oldstate, "new": state}
483     return ret
484 def _list_pkgs_from_context(versions_as_list):
485     if versions_as_list:
486         return __context__["pkg.list_pkgs"]
487     else:
488         ret = copy.deepcopy(__context__["pkg.list_pkgs"])
489         __salt__["pkg_resource.stringify"](ret)
490         return ret
491 def list_pkgs(versions_as_list=False, **kwargs):
492     versions_as_list = salt.utils.data.is_true(versions_as_list)
493     if any(
494         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
495     ):
496         return {}
497     if "pkg.list_pkgs" in __context__:
498         return _list_pkgs_from_context(versions_as_list)
499     cmd = ["opkg", "list-installed"]
500     ret = {}
501     out = __salt__["cmd.run"](cmd, output_loglevel="trace", python_shell=False)
502     for line in salt.utils.itertools.split(out, "\n"):
503         if not line or line[0] == " ":
504             continue
505         pkg_name, pkg_version = line.split(" - ", 2)[:2]
506         __salt__["pkg_resource.add_pkg"](ret, pkg_name, pkg_version)
507     __salt__["pkg_resource.sort_pkglist"](ret)
508     __context__["pkg.list_pkgs"] = copy.deepcopy(ret)
509     if not versions_as_list:
510         __salt__["pkg_resource.stringify"](ret)
511     return ret
512 def list_upgrades(refresh=True, **kwargs):  # pylint: disable=unused-argument
513     ret = {}
514     if salt.utils.data.is_true(refresh):
515         refresh_db()
516     cmd = ["opkg", "list-upgradable"]
517     call = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
518     if call["retcode"] != 0:
519         comment = ""
520         if "stderr" in call:
521             comment += call["stderr"]
522         if "stdout" in call:
523             comment += call["stdout"]
524         raise CommandExecutionError(comment)
525     else:
526         out = call["stdout"]
527     for line in out.splitlines():
528         name, _oldversion, newversion = line.split(" - ")
529         ret[name] = newversion
530     return ret
531 def _convert_to_standard_attr(attr):
532     ret_attr = ATTR_MAP.get(attr, None)
533     if ret_attr is None:
534         return attr.lower()
535     return ret_attr
536 def _process_info_installed_output(out, filter_attrs):
537     ret = {}
538     name = None
539     attrs = {}
540     attr = None
541     for line in salt.utils.itertools.split(out, "\n"):
542         if line and line[0] == " ":
543             if filter_attrs is None or attr in filter_attrs:
544                 line = line.strip()
545                 if attrs[attr]:
546                     attrs[attr] += "\n"
547                 attrs[attr] += line
548             continue
549         line = line.strip()
550         if not line:
551             if name:
552                 ret[name] = attrs
553             name = None
554             attrs = {}
555             attr = None
556             continue
557         key, value = line.split(":", 1)
558         value = value.lstrip()
559         attr = _convert_to_standard_attr(key)
560         if attr == "name":
561             name = value
562         elif filter_attrs is None or attr in filter_attrs:
563             attrs[attr] = value
564     if name:
565         ret[name] = attrs
566     return ret
567 def info_installed(*names, **kwargs):
568     attr = kwargs.pop("attr", None)
569     if attr is None:
570         filter_attrs = None
571     elif isinstance(attr, str):
572         filter_attrs = set(attr.split(","))
573     else:
574         filter_attrs = set(attr)
575     ret = {}
576     if names:
577         for name in names:
578             cmd = ["opkg", "status", name]
579             call = __salt__["cmd.run_all"](
580                 cmd, output_loglevel="trace", python_shell=False
581             )
582             if call["retcode"] != 0:
583                 comment = ""
584                 if call["stderr"]:
585                     comment += call["stderr"]
586                 else:
587                     comment += call["stdout"]
588                 raise CommandExecutionError(comment)
589             ret.update(_process_info_installed_output(call["stdout"], filter_attrs))
590     else:
591         cmd = ["opkg", "status"]
592         call = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
593         if call["retcode"] != 0:
594             comment = ""
595             if call["stderr"]:
596                 comment += call["stderr"]
597             else:
598                 comment += call["stdout"]
599             raise CommandExecutionError(comment)
600         ret.update(_process_info_installed_output(call["stdout"], filter_attrs))
601     return ret
602 def upgrade_available(name, **kwargs):  # pylint: disable=unused-argument
603     return latest_version(name) != ""
604 def version_cmp(
605     pkg1, pkg2, ignore_epoch=False, **kwargs
606 ):  # pylint: disable=unused-argument
607     normalize = lambda x: str(x).split(":", 1)[-1] if ignore_epoch else str(x)
608     pkg1 = normalize(pkg1)
609     pkg2 = normalize(pkg2)
610     output = __salt__["cmd.run_stdout"](
611         ["opkg", "--version"], output_loglevel="trace", python_shell=False
612     )
613     opkg_version = output.split(" ")[2].strip()
614     if salt.utils.versions.LooseVersion(
615         opkg_version
616     ) &gt;= salt.utils.versions.LooseVersion("0.3.4"):
617         cmd_compare = ["opkg", "compare-versions"]
618     elif salt.utils.path.which("opkg-compare-versions"):
619         cmd_compare = ["opkg-compare-versions"]
620     else:
621         log.warning(
622             "Unable to find a compare-versions utility installed. Either upgrade opkg"
623             " to version &gt; 0.3.4 (preferred) or install the older opkg-compare-versions"
624             " script."
625         )
626         return None
627     for oper, ret in (("&lt;&lt;", -1), ("=", 0), ("&gt;&gt;", 1)):
628         cmd = cmd_compare[:]
629         cmd.append(shlex.quote(pkg1))
630         cmd.append(oper)
631         cmd.append(shlex.quote(pkg2))
632         retcode = __salt__["cmd.retcode"](
633             cmd, output_loglevel="trace", ignore_retcode=True, python_shell=False
634         )
635         if retcode == 0:
636             return ret
637     return None
638 def _set_repo_option(repo, option):
639     if not option:
640         return
641     opt = option.split("=")
642     if len(opt) != 2:
643         return
644     if opt[0] == "trusted":
645         repo["trusted"] = opt[1] == "yes"
646     else:
647         repo[opt[0]] = opt[1]
648 def _set_repo_options(repo, options):
649     delimiters = "[", "]"
650     pattern = "|".join(map(re.escape, delimiters))
651     for option in options:
652         splitted = re.split(pattern, option)
653         for opt in splitted:
654             _set_repo_option(repo, opt)
655 def _create_repo(line, filename):
656     repo = {}
657     if line.startswith("#"):
658         repo["enabled"] = False
659         line = line[1:]
660     else:
661         repo["enabled"] = True
662     cols = salt.utils.args.shlex_split(line.strip())
663     repo["compressed"] = not cols[0] in "src"
664     repo["name"] = cols[1]
665     repo["uri"] = cols[2]
666     repo["file"] = os.path.join(OPKG_CONFDIR, filename)
667     if len(cols) &gt; 3:
668         _set_repo_options(repo, cols[3:])
669     return repo
670 def _read_repos(conf_file, repos, filename, regex):
671     for line in conf_file:
672         line = salt.utils.stringutils.to_unicode(line)
673         if not regex.search(line):
674             continue
675         repo = _create_repo(line, filename)
676         if repo["uri"] not in repos:
677             repos[repo["uri"]] = [repo]
678 def list_repos(**kwargs):  # pylint: disable=unused-argument
679     repos = {}
680     regex = re.compile(REPO_REGEXP)
681     for filename in os.listdir(OPKG_CONFDIR):
682         if not filename.endswith(".conf"):
683             continue
684         with salt.utils.files.fopen(os.path.join(OPKG_CONFDIR, filename)) as conf_file:
685             _read_repos(conf_file, repos, filename, regex)
686     return repos
687 def get_repo(repo, **kwargs):  # pylint: disable=unused-argument
688     repos = list_repos()
689     if repos:
690         for source in repos.values():
691             for sub in source:
692                 if sub["name"] == repo:
693                     return sub
694     return {}
695 def _del_repo_from_file(repo, filepath):
696     with salt.utils.files.fopen(filepath) as fhandle:
697         output = []
698         regex = re.compile(REPO_REGEXP)
699         for line in fhandle:
700             line = salt.utils.stringutils.to_unicode(line)
701             if regex.search(line):
702                 if line.startswith("#"):
703                     line = line[1:]
704                 cols = salt.utils.args.shlex_split(line.strip())
705                 if repo != cols[1]:
706                     output.append(salt.utils.stringutils.to_str(line))
707     with salt.utils.files.fopen(filepath, "w") as fhandle:
708         fhandle.writelines(output)
709 def _set_trusted_option_if_needed(repostr, trusted):
710     if trusted is True:
711         repostr += " [trusted=yes]"
712     elif trusted is False:
713         repostr += " [trusted=no]"
714     return repostr
715 def _add_new_repo(repo, properties):
716     repostr = "# " if not properties.get("enabled") else ""
717     repostr += "src/gz " if properties.get("compressed") else "src "
718     if " " in repo:
719         repostr += '"' + repo + '" '
720     else:
721         repostr += repo + " "
722     repostr += properties.get("uri")
723     repostr = _set_trusted_option_if_needed(repostr, properties.get("trusted"))
724     repostr += "\n"
725     conffile = os.path.join(OPKG_CONFDIR, repo + ".conf")
726     with salt.utils.files.fopen(conffile, "a") as fhandle:
727         fhandle.write(salt.utils.stringutils.to_str(repostr))
728 def _mod_repo_in_file(repo, repostr, filepath):
729     with salt.utils.files.fopen(filepath) as fhandle:
730         output = []
731         for line in fhandle:
732             cols = salt.utils.args.shlex_split(
733                 salt.utils.stringutils.to_unicode(line).strip()
734             )
735             if repo not in cols:
736                 output.append(line)
737             else:
738                 output.append(salt.utils.stringutils.to_str(repostr + "\n"))
739     with salt.utils.files.fopen(filepath, "w") as fhandle:
740         fhandle.writelines(output)
741 def del_repo(repo, **kwargs):  # pylint: disable=unused-argument
742     refresh = salt.utils.data.is_true(kwargs.get("refresh", True))
743     repos = list_repos()
744     if repos:
745         deleted_from = dict()
746         for repository in repos:
747             source = repos[repository][0]
748             if source["name"] == repo:
749                 deleted_from[source["file"]] = 0
750                 _del_repo_from_file(repo, source["file"])
751         if deleted_from:
752             ret = ""
753             for repository in repos:
754                 source = repos[repository][0]
755                 if source["file"] in deleted_from:
756                     deleted_from[source["file"]] += 1
757             for repo_file, count in deleted_from.items():
758                 msg = "Repo '{}' has been removed from {}.\n"
759                 if count == 1 and os.path.isfile(repo_file):
760                     msg = "File {1} containing repo '{0}' has been removed.\n"
761                     try:
762                         os.remove(repo_file)
763                     except OSError:
764                         pass
765                 ret += msg.format(repo, repo_file)
766             if refresh:
767                 refresh_db()
768             return ret
769     return "Repo {} doesn't exist in the opkg repo lists".format(repo)
770 def mod_repo(repo, **kwargs):
771     repos = list_repos()
772     found = False
773     uri = ""
774     if "uri" in kwargs:
775         uri = kwargs["uri"]
776     for repository in repos:
777         source = repos[repository][0]
778         if source["name"] == repo:
779             found = True
780             repostr = ""
781             if "enabled" in kwargs and not kwargs["enabled"]:
782                 repostr += "# "
783             if "compressed" in kwargs:
784                 repostr += "src/gz " if kwargs["compressed"] else "src"
785             else:
786                 repostr += "src/gz" if source["compressed"] else "src"
787             repo_alias = kwargs["alias"] if "alias" in kwargs else repo
788             if " " in repo_alias:
789                 repostr += ' "{}"'.format(repo_alias)
790             else:
791                 repostr += " {}".format(repo_alias)
792             repostr += " {}".format(kwargs["uri"] if "uri" in kwargs else source["uri"])
793             trusted = kwargs.get("trusted")
794             repostr = (
795                 _set_trusted_option_if_needed(repostr, trusted)
796                 if trusted is not None
797                 else _set_trusted_option_if_needed(repostr, source.get("trusted"))
798             )
799             _mod_repo_in_file(repo, repostr, source["file"])
800         elif uri and source["uri"] == uri:
801             raise CommandExecutionError(
802                 "Repository '{}' already exists as '{}'.".format(uri, source["name"])
803             )
804     if not found:
805         if "uri" not in kwargs:
806             raise CommandExecutionError(
807                 "Repository '{}' not found and no URI passed to create one.".format(
808                     repo
809                 )
810             )
811         properties = {"uri": kwargs["uri"]}
812         properties["compressed"] = (
813             kwargs["compressed"] if "compressed" in kwargs else True
814         )
815         properties["enabled"] = kwargs["enabled"] if "enabled" in kwargs else True
816         properties["trusted"] = kwargs.get("trusted")
817         _add_new_repo(repo, properties)
818     if "refresh" in kwargs:
819         refresh_db()
820 def file_list(*packages, **kwargs):  # pylint: disable=unused-argument
821     output = file_dict(*packages)
822     files = []
823     for package in list(output["packages"].values()):
824         files.extend(package)
825     return {"errors": output["errors"], "files": files}
826 def file_dict(*packages, **kwargs):  # pylint: disable=unused-argument
827     errors = []
828     ret = {}
829     cmd_files = ["opkg", "files"]
830     if not packages:
831         packages = list(list_pkgs().keys())
832     for package in packages:
833         files = []
834         cmd = cmd_files[:]
835         cmd.append(package)
836         out = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
837         for line in out["stdout"].splitlines():
838             if line.startswith("/"):
839                 files.append(line)
840             elif line.startswith(" * "):
841                 errors.append(line[3:])
842                 break
843             else:
844                 continue
845         if files:
846             ret[package] = files
847     return {"errors": errors, "packages": ret}
848 def owner(*paths, **kwargs):  # pylint: disable=unused-argument
849     if not paths:
850         return ""
851     ret = {}
852     cmd_search = ["opkg", "search"]
853     for path in paths:
854         cmd = cmd_search[:]
855         cmd.append(path)
856         output = __salt__["cmd.run_stdout"](
857             cmd, output_loglevel="trace", python_shell=False
858         )
859         if output:
860             ret[path] = output.split(" - ")[0].strip()
861         else:
862             ret[path] = ""
863     if len(ret) == 1:
864         return next(iter(ret.values()))
865     return ret
866 def version_clean(version):
867     return version
868 def check_extra_requirements(pkgname, pkgver):
869     return True
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
