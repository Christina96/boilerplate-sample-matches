<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for local_cache.py & kubernetesmod.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for local_cache.py & kubernetesmod.py
      </h3>
      <h1 align="center">
        2.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>local_cache.py (4.288939%)<TH>kubernetesmod.py (2.0518358%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match126554-0.html#0',2,'match126554-1.html#0',3)" NAME="0">(6-20)<TD><A HREF="javascript:ZweiFrames('match126554-0.html#0',2,'match126554-1.html#0',3)" NAME="0">(46-60)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match126554-0.html#1',2,'match126554-1.html#1',3)" NAME="1">(463-464)<TD><A HREF="javascript:ZweiFrames('match126554-0.html#1',2,'match126554-1.html#1',3)" NAME="1">(243-246)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match126554-0.html#2',2,'match126554-1.html#2',3)" NAME="2">(112-113)<TD><A HREF="javascript:ZweiFrames('match126554-0.html#2',2,'match126554-1.html#2',3)" NAME="2">(237-240)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>local_cache.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Return data to local job cache
<A NAME="0"></A>
&quot;&quot;&quot;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match126554-1.html#0',3,'match126554-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import bisect
import errno
import glob
import logging
import os
import shutil
import time

import salt.exceptions
import salt.payload
import salt.utils.atomicfile
import salt.utils.files
import salt.utils.jid
import salt.utils.minions
import</B></FONT> salt.utils.msgpack
import salt.utils.stringutils

log = logging.getLogger(__name__)

# load is the published job
LOAD_P = &quot;.load.p&quot;
# the list of minions that the job is targeted to (best effort match on the
# master side)
MINIONS_P = &quot;.minions.p&quot;
# format string for minion lists forwarded from syndic masters (the placeholder
# will be replaced with the syndic master's id)
SYNDIC_MINIONS_P = &quot;.minions.{0}.p&quot;
# return is the &quot;return&quot; from the minion data
RETURN_P = &quot;return.p&quot;
# out is the &quot;out&quot; from the minion data
OUT_P = &quot;out.p&quot;
# endtime is the end time for a job, not stored as msgpack
ENDTIME = &quot;endtime&quot;


def _job_dir():
    &quot;&quot;&quot;
    Return root of the jobs cache directory
    &quot;&quot;&quot;
    return os.path.join(__opts__[&quot;cachedir&quot;], &quot;jobs&quot;)


def _walk_through(job_dir):
    &quot;&quot;&quot;
    Walk though the jid dir and look for jobs
    &quot;&quot;&quot;

    for top in os.listdir(job_dir):
        t_path = os.path.join(job_dir, top)

        if not os.path.exists(t_path):
            continue

        for final in os.listdir(t_path):
            load_path = os.path.join(t_path, final, LOAD_P)

            if not os.path.isfile(load_path):
                continue

            with salt.utils.files.fopen(load_path, &quot;rb&quot;) as rfh:
                try:
                    job = salt.payload.load(rfh)
                except Exception:  # pylint: disable=broad-except
                    log.exception(&quot;Failed to deserialize %s&quot;, load_path)
                    continue
                if not job:
                    log.error(
                        &quot;Deserialization of job succeded but there is no data in %s&quot;,
                        load_path,
                    )
                    continue
                jid = job[&quot;jid&quot;]
                yield jid, job, t_path, final


# TODO: add to returner docs-- this is a new one
def prep_jid(nocache=False, passed_jid=None, recurse_count=0):
    &quot;&quot;&quot;
    Return a job id and prepare the job id directory.

    This is the function responsible for making sure jids don't collide (unless
    it is passed a jid).
    So do what you have to do to make sure that stays the case
    &quot;&quot;&quot;
    if recurse_count &gt;= 5:
        err = &quot;prep_jid could not store a jid after {} tries.&quot;.format(recurse_count)
        log.error(err)
        raise salt.exceptions.SaltCacheError(err)
    if passed_jid is None:  # this can be a None or an empty string.
        jid = salt.utils.jid.gen_jid(__opts__)
    else:
        jid = passed_jid

    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__[&quot;hash_type&quot;])

    # Make sure we create the jid dir, otherwise someone else is using it,
    # meaning we need a new jid.
    if not os.path.isdir(jid_dir):
        try:
            os.makedirs(jid_dir)
        except OSError:
            time.sleep(0.1)
            if passed_jid is None:
<A NAME="2"></A>                return prep_jid(nocache=nocache, recurse_count=recurse_count + 1)

    try:
        with salt.utils<FONT color="#980517"><A HREF="javascript:ZweiFrames('match126554-1.html#2',3,'match126554-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.files.fopen(os.path.join(jid_dir, &quot;jid&quot;), &quot;wb+&quot;) as fn_:
            fn_.write(salt.utils.stringutils.to_bytes(</B></FONT>jid))
        if nocache:
            with salt.utils.files.fopen(os.path.join(jid_dir, &quot;nocache&quot;), &quot;wb+&quot;):
                pass
    except OSError:
        log.warning(&quot;Could not write out jid file for job %s. Retrying.&quot;, jid)
        time.sleep(0.1)
        return prep_jid(
            passed_jid=jid, nocache=nocache, recurse_count=recurse_count + 1
        )

    return jid


def returner(load):
    &quot;&quot;&quot;
    Return data to the local job cache
    &quot;&quot;&quot;

    # if a minion is returning a standalone job, get a jobid
    if load[&quot;jid&quot;] == &quot;req&quot;:
        load[&quot;jid&quot;] = prep_jid(nocache=load.get(&quot;nocache&quot;, False))

    jid_dir = salt.utils.jid.jid_dir(load[&quot;jid&quot;], _job_dir(), __opts__[&quot;hash_type&quot;])
    if os.path.exists(os.path.join(jid_dir, &quot;nocache&quot;)):
        return

    hn_dir = os.path.join(jid_dir, load[&quot;id&quot;])

    try:
        os.makedirs(hn_dir)
    except OSError as err:
        if err.errno == errno.EEXIST:
            # Minion has already returned this jid and it should be dropped
            log.error(
                &quot;An extra return was detected from minion %s, please verify &quot;
                &quot;the minion, this could be a replay attack&quot;,
                load[&quot;id&quot;],
            )
            return False
        elif err.errno == errno.ENOENT:
            log.error(
                &quot;An inconsistency occurred, a job was received with a job id &quot;
                &quot;(%s) that is not present in the local cache&quot;,
                load[&quot;jid&quot;],
            )
            return False
        raise

    salt.payload.dump(
        {key: load[key] for key in [&quot;return&quot;, &quot;retcode&quot;, &quot;success&quot;] if key in load},
        # Use atomic open here to avoid the file being read before it's
        # completely written to. Refs #1935
        salt.utils.atomicfile.atomic_open(os.path.join(hn_dir, RETURN_P), &quot;w+b&quot;),
    )

    if &quot;out&quot; in load:
        salt.payload.dump(
            load[&quot;out&quot;],
            # Use atomic open here to avoid the file being read before
            # it's completely written to. Refs #1935
            salt.utils.atomicfile.atomic_open(os.path.join(hn_dir, OUT_P), &quot;w+b&quot;),
        )


def save_load(jid, clear_load, minions=None, recurse_count=0):
    &quot;&quot;&quot;
    Save the load to the specified jid

    minions argument is to provide a pre-computed list of matched minions for
    the job, for cases when this function can't compute that list itself (such
    as for salt-ssh)
    &quot;&quot;&quot;
    if recurse_count &gt;= 5:
        err = &quot;save_load could not write job cache file after {} retries.&quot;.format(
            recurse_count
        )
        log.error(err)
        raise salt.exceptions.SaltCacheError(err)

    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__[&quot;hash_type&quot;])

    # Save the invocation information
    try:
        if not os.path.exists(jid_dir):
            os.makedirs(jid_dir)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            # rarely, the directory can be already concurrently created between
            # the os.path.exists and the os.makedirs lines above
            pass
        else:
            raise
    try:
        with salt.utils.files.fopen(os.path.join(jid_dir, LOAD_P), &quot;w+b&quot;) as wfh:
            salt.payload.dump(clear_load, wfh)
    except OSError as exc:
        log.warning(&quot;Could not write job invocation cache file: %s&quot;, exc)
        time.sleep(0.1)
        return save_load(
            jid=jid, clear_load=clear_load, recurse_count=recurse_count + 1
        )

    # if you have a tgt, save that for the UI etc
    if &quot;tgt&quot; in clear_load and clear_load[&quot;tgt&quot;] != &quot;&quot;:
        if minions is None:
            ckminions = salt.utils.minions.CkMinions(__opts__)
            # Retrieve the minions list
            _res = ckminions.check_minions(
                clear_load[&quot;tgt&quot;], clear_load.get(&quot;tgt_type&quot;, &quot;glob&quot;)
            )
            minions = _res[&quot;minions&quot;]
        # save the minions to a cache so we can see in the UI
        save_minions(jid, minions)


def save_minions(jid, minions, syndic_id=None):
    &quot;&quot;&quot;
    Save/update the serialized list of minions for a given job
    &quot;&quot;&quot;
    # Ensure we have a list for Python 3 compatibility
    minions = list(minions)

    log.debug(
        &quot;Adding minions for job %s%s: %s&quot;,
        jid,
        &quot; from syndic master '{}'&quot;.format(syndic_id) if syndic_id else &quot;&quot;,
        minions,
    )

    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__[&quot;hash_type&quot;])

    try:
        if not os.path.exists(jid_dir):
            os.makedirs(jid_dir)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            # rarely, the directory can be already concurrently created between
            # the os.path.exists and the os.makedirs lines above
            pass
        else:
            raise

    if syndic_id is not None:
        minions_path = os.path.join(jid_dir, SYNDIC_MINIONS_P.format(syndic_id))
    else:
        minions_path = os.path.join(jid_dir, MINIONS_P)

    try:
        if not os.path.exists(jid_dir):
            try:
                os.makedirs(jid_dir)
            except OSError:
                pass
        with salt.utils.files.fopen(minions_path, &quot;w+b&quot;) as wfh:
            salt.payload.dump(minions, wfh)
    except OSError as exc:
        log.error(
            &quot;Failed to write minion list %s to job cache file %s: %s&quot;,
            minions,
            minions_path,
            exc,
        )


def get_load(jid):
    &quot;&quot;&quot;
    Return the load data that marks a specified jid
    &quot;&quot;&quot;
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__[&quot;hash_type&quot;])
    load_fn = os.path.join(jid_dir, LOAD_P)
    if not os.path.exists(jid_dir) or not os.path.exists(load_fn):
        return {}
    ret = {}
    load_p = os.path.join(jid_dir, LOAD_P)
    num_tries = 5
    for index in range(1, num_tries + 1):
        with salt.utils.files.fopen(load_p, &quot;rb&quot;) as rfh:
            try:
                ret = salt.payload.load(rfh)
                break
            except Exception as exc:  # pylint: disable=broad-except
                if index == num_tries:
                    time.sleep(0.25)
    else:
        log.critical(&quot;Failed to unpack %s&quot;, load_p)
        raise exc
    if ret is None:
        ret = {}
    minions_cache = [os.path.join(jid_dir, MINIONS_P)]
    minions_cache.extend(glob.glob(os.path.join(jid_dir, SYNDIC_MINIONS_P.format(&quot;*&quot;))))
    all_minions = set()
    for minions_path in minions_cache:
        log.debug(&quot;Reading minion list from %s&quot;, minions_path)
        try:
            with salt.utils.files.fopen(minions_path, &quot;rb&quot;) as rfh:
                all_minions.update(salt.payload.load(rfh))
        except OSError as exc:
            salt.utils.files.process_read_exception(exc, minions_path)

    if all_minions:
        ret[&quot;Minions&quot;] = sorted(all_minions)

    return ret


def get_jid(jid):
    &quot;&quot;&quot;
    Return the information returned when the specified job id was executed
    &quot;&quot;&quot;
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__[&quot;hash_type&quot;])

    ret = {}
    # Check to see if the jid is real, if not return the empty dict
    if not os.path.isdir(jid_dir):
        return ret
    for fn_ in os.listdir(jid_dir):
        if fn_.startswith(&quot;.&quot;):
            continue
        if fn_ not in ret:
            retp = os.path.join(jid_dir, fn_, RETURN_P)
            outp = os.path.join(jid_dir, fn_, OUT_P)
            if not os.path.isfile(retp):
                continue
            while fn_ not in ret:
                try:
                    with salt.utils.files.fopen(retp, &quot;rb&quot;) as rfh:
                        ret_data = salt.payload.load(rfh)
                    if not isinstance(ret_data, dict) or &quot;return&quot; not in ret_data:
                        # Convert the old format in which return.p contains the only return data to
                        # the new that is dict containing 'return' and optionally 'retcode' and
                        # 'success'.
                        ret_data = {&quot;return&quot;: ret_data}
                    ret[fn_] = ret_data
                    if os.path.isfile(outp):
                        with salt.utils.files.fopen(outp, &quot;rb&quot;) as rfh:
                            ret[fn_][&quot;out&quot;] = salt.payload.load(rfh)
                except Exception as exc:  # pylint: disable=broad-except
                    if &quot;Permission denied:&quot; in str(exc):
                        raise
    return ret


def get_jids():
    &quot;&quot;&quot;
    Return a dict mapping all job ids to job information
    &quot;&quot;&quot;
    ret = {}
    for jid, job, _, _ in _walk_through(_job_dir()):
        ret[jid] = salt.utils.jid.format_jid_instance(jid, job)

        if __opts__.get(&quot;job_cache_store_endtime&quot;):
            endtime = get_endtime(jid)
            if endtime:
                ret[jid][&quot;EndTime&quot;] = endtime

    return ret


def get_jids_filter(count, filter_find_job=True):
    &quot;&quot;&quot;
    Return a list of all jobs information filtered by the given criteria.
    :param int count: show not more than the count of most recent jobs
    :param bool filter_find_jobs: filter out 'saltutil.find_job' jobs
    &quot;&quot;&quot;
    keys = []
    ret = []
    for jid, job, _, _ in _walk_through(_job_dir()):
        job = salt.utils.jid.format_jid_instance_ext(jid, job)
        if filter_find_job and job[&quot;Function&quot;] == &quot;saltutil.find_job&quot;:
            continue
        i = bisect.bisect(keys, jid)
        if len(keys) == count and i == 0:
            continue
        keys.insert(i, jid)
        ret.insert(i, job)
        if len(keys) &gt; count:
            del keys[0]
            del ret[0]
    return ret


def clean_old_jobs():
    &quot;&quot;&quot;
    Clean out the old jobs from the job cache
    &quot;&quot;&quot;
    if __opts__[&quot;keep_jobs&quot;] != 0:
        jid_root = _job_dir()

        if not os.path.exists(jid_root):
            return

        # Keep track of any empty t_path dirs that need to be removed later
        dirs_to_remove = set()

        for top in os.listdir(jid_root):
            t_path = os.path.join(jid_root, top)

            if not os.path.exists(t_path):
                continue

            # Check if there are any stray/empty JID t_path dirs
            t_path_dirs = os.listdir(t_path)
            if not t_path_dirs and t_path not in dirs_to_remove:
                dirs_to_remove.add(t_path)
                continue

            for final in t_path_dirs:
                f_path = os.path.join(t_path, final)
                jid_file = os.path.join(f_path, &quot;jid&quot;)
                if not os.path.isfile(jid_file) and os.path.exists(f_path):
                    # No jid file means corrupted cache entry, scrub it
                    # by removing the entire f_path directory
                    shutil.rmtree(f_path)
                elif os.path.isfile(jid_file):
                    jid_ctime = os.stat(jid_file).st_ctime
                    hours_difference = (time.time() - jid_ctime) / 3600.0
                    if hours_difference &gt; __opts__[&quot;keep_jobs&quot;] and os.path.exists(
                        t_path
                    ):
                        # Remove the entire f_path from the original JID dir
                        try:
                            shutil.rmtree(f_path)
                        except OSError as err:
                            log.error(&quot;Unable to remove %s: %s&quot;, f_path, err)

        # Remove empty JID dirs from job cache, if they're old enough.
        # JID dirs may be empty either from a previous cache-clean with the bug
        # Listed in #29286 still present, or the JID dir was only recently made
        # And the jid file hasn't been created yet.
        if dirs_to_remove:
            for t_path in dirs_to_remove:
                # Checking the time again prevents a possible race condition where
                # t_path JID dirs were created, but not yet populated by a jid file.
                t_path_ctime = os.stat(t_path).st_ctime
                hours_difference = (time.time() - t_path_ctime) / 3600.0
                if hours_difference &gt; __opts__[&quot;keep_jobs&quot;]:
                    shutil.rmtree(t_path)


def update_endtime(jid, time):
    &quot;&quot;&quot;
    Update (or store) the end time for a given job

    Endtime is stored as a plain text string
    &quot;&quot;&quot;
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__[&quot;hash_type&quot;])
<A NAME="1"></A>    try:
        if not os.path.exists(jid_dir):
            os.makedirs(jid_dir)
        with salt.utils<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match126554-1.html#1',3,'match126554-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.files.fopen(os.path.join(jid_dir, ENDTIME), &quot;w&quot;) as etfile:
            etfile.write(salt.utils.stringutils.to_str(</B></FONT>time))
    except OSError as exc:
        log.warning(&quot;Could not write job invocation cache file: %s&quot;, exc)


def get_endtime(jid):
    &quot;&quot;&quot;
    Retrieve the stored endtime for a given job

    Returns False if no endtime is present
    &quot;&quot;&quot;
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__[&quot;hash_type&quot;])
    etpath = os.path.join(jid_dir, ENDTIME)
    if not os.path.exists(etpath):
        return False
    with salt.utils.files.fopen(etpath, &quot;r&quot;) as etfile:
        endtime = salt.utils.stringutils.to_unicode(etfile.read()).strip(&quot;\n&quot;)
    return endtime


def _reg_dir():
    &quot;&quot;&quot;
    Return the reg_dir for the given job id
    &quot;&quot;&quot;
    return os.path.join(__opts__[&quot;cachedir&quot;], &quot;thorium&quot;)


def save_reg(data):
    &quot;&quot;&quot;
    Save the register to msgpack files
    &quot;&quot;&quot;
    reg_dir = _reg_dir()
    regfile = os.path.join(reg_dir, &quot;register&quot;)
    try:
        if not os.path.exists(reg_dir):
            os.makedirs(reg_dir)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            pass
        else:
            raise
    try:
        with salt.utils.files.fopen(regfile, &quot;a&quot;) as fh_:
            salt.utils.msgpack.dump(data, fh_)
    except Exception:  # pylint: disable=broad-except
        log.error(&quot;Could not write to msgpack file %s&quot;, __opts__[&quot;outdir&quot;])
        raise


def load_reg():
    &quot;&quot;&quot;
    Load the register from msgpack files
    &quot;&quot;&quot;
    reg_dir = _reg_dir()
    regfile = os.path.join(reg_dir, &quot;register&quot;)
    try:
        with salt.utils.files.fopen(regfile, &quot;r&quot;) as fh_:
            return salt.utils.msgpack.load(fh_)
    except Exception:  # pylint: disable=broad-except
        log.error(&quot;Could not write to msgpack file %s&quot;, __opts__[&quot;outdir&quot;])
        raise
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>kubernetesmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Module for handling kubernetes calls.

:optdepends:    - kubernetes Python client
:configuration: The k8s API settings are provided either in a pillar, in
    the minion's config file, or in master's config file::

        kubernetes.kubeconfig: '/path/to/kubeconfig'
        kubernetes.kubeconfig-data: '&lt;base64 encoded kubeconfig content'
        kubernetes.context: 'context'

These settings can be overridden by adding `context and `kubeconfig` or
`kubeconfig_data` parameters when calling a function.

The data format for `kubernetes.kubeconfig-data` value is the content of
`kubeconfig` base64 encoded in one line.

Only `kubeconfig` or `kubeconfig-data` should be provided. In case both are
provided `kubeconfig` entry is preferred.

.. code-block:: bash

    salt '*' kubernetes.nodes kubeconfig=/etc/salt/k8s/kubeconfig context=minikube

.. versionadded:: 2017.7.0
.. versionchanged:: 2019.2.0

.. warning::

    Configuration options changed in 2019.2.0. The following configuration options have been removed:

    - kubernetes.user
    - kubernetes.password
    - kubernetes.api_url
    - kubernetes.certificate-authority-data/file
    - kubernetes.client-certificate-data/file
    - kubernetes.client-key-data/file

    Please use now:

    - kubernetes.kubeconfig or kubernetes.kubeconfig-data
    - kubernetes.context
<A NAME="0"></A>
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match126554-0.html#0',2,'match126554-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import base64
import errno
import logging
import os.path
import signal
import sys
import tempfile
import time
from contextlib import contextmanager

import salt.utils.files
import salt.utils.platform
import salt.utils.templates
import salt.utils.yaml
from</B></FONT> salt.exceptions import CommandExecutionError, TimeoutError

try:
    import kubernetes  # pylint: disable=import-self
    import kubernetes.client
    from kubernetes.client.rest import ApiException
    from urllib3.exceptions import HTTPError

    # pylint: disable=no-name-in-module
    try:
        # There is an API change in Kubernetes &gt;= 2.0.0.
        from kubernetes.client import V1beta1Deployment as AppsV1beta1Deployment
        from kubernetes.client import V1beta1DeploymentSpec as AppsV1beta1DeploymentSpec
    except ImportError:
        from kubernetes.client import AppsV1beta1Deployment
        from kubernetes.client import AppsV1beta1DeploymentSpec
    # pylint: enable=no-name-in-module

    HAS_LIBS = True
except ImportError:
    HAS_LIBS = False

log = logging.getLogger(__name__)

__virtualname__ = &quot;kubernetes&quot;


def __virtual__():
    &quot;&quot;&quot;
    Check dependencies
    &quot;&quot;&quot;
    if HAS_LIBS:
        return __virtualname__

    return False, &quot;python kubernetes library not found&quot;


if not salt.utils.platform.is_windows():

    @contextmanager
    def _time_limit(seconds):
        def signal_handler(signum, frame):
            raise TimeoutError

        signal.signal(signal.SIGALRM, signal_handler)
        signal.alarm(seconds)
        try:
            yield
        finally:
            signal.alarm(0)

    POLLING_TIME_LIMIT = 30


def _setup_conn_old(**kwargs):
    &quot;&quot;&quot;
    Setup kubernetes API connection singleton the old way
    &quot;&quot;&quot;
    host = __salt__[&quot;config.option&quot;](&quot;kubernetes.api_url&quot;, &quot;http://localhost:8080&quot;)
    username = __salt__[&quot;config.option&quot;](&quot;kubernetes.user&quot;)
    password = __salt__[&quot;config.option&quot;](&quot;kubernetes.password&quot;)
    ca_cert = __salt__[&quot;config.option&quot;](&quot;kubernetes.certificate-authority-data&quot;)
    client_cert = __salt__[&quot;config.option&quot;](&quot;kubernetes.client-certificate-data&quot;)
    client_key = __salt__[&quot;config.option&quot;](&quot;kubernetes.client-key-data&quot;)
    ca_cert_file = __salt__[&quot;config.option&quot;](&quot;kubernetes.certificate-authority-file&quot;)
    client_cert_file = __salt__[&quot;config.option&quot;](&quot;kubernetes.client-certificate-file&quot;)
    client_key_file = __salt__[&quot;config.option&quot;](&quot;kubernetes.client-key-file&quot;)

    # Override default API settings when settings are provided
    if &quot;api_url&quot; in kwargs:
        host = kwargs.get(&quot;api_url&quot;)

    if &quot;api_user&quot; in kwargs:
        username = kwargs.get(&quot;api_user&quot;)

    if &quot;api_password&quot; in kwargs:
        password = kwargs.get(&quot;api_password&quot;)

    if &quot;api_certificate_authority_file&quot; in kwargs:
        ca_cert_file = kwargs.get(&quot;api_certificate_authority_file&quot;)

    if &quot;api_client_certificate_file&quot; in kwargs:
        client_cert_file = kwargs.get(&quot;api_client_certificate_file&quot;)

    if &quot;api_client_key_file&quot; in kwargs:
        client_key_file = kwargs.get(&quot;api_client_key_file&quot;)

    if (
        kubernetes.client.configuration.host != host
        or kubernetes.client.configuration.user != username
        or kubernetes.client.configuration.password != password
    ):
        # Recreates API connection if settings are changed
        kubernetes.client.configuration.__init__()

    kubernetes.client.configuration.host = host
    kubernetes.client.configuration.user = username
    kubernetes.client.configuration.passwd = password

    if ca_cert_file:
        kubernetes.client.configuration.ssl_ca_cert = ca_cert_file
    elif ca_cert:
        with tempfile.NamedTemporaryFile(prefix=&quot;salt-kube-&quot;, delete=False) as ca:
            ca.write(base64.b64decode(ca_cert))
            kubernetes.client.configuration.ssl_ca_cert = ca.name
    else:
        kubernetes.client.configuration.ssl_ca_cert = None

    if client_cert_file:
        kubernetes.client.configuration.cert_file = client_cert_file
    elif client_cert:
        with tempfile.NamedTemporaryFile(prefix=&quot;salt-kube-&quot;, delete=False) as c:
            c.write(base64.b64decode(client_cert))
            kubernetes.client.configuration.cert_file = c.name
    else:
        kubernetes.client.configuration.cert_file = None

    if client_key_file:
        kubernetes.client.configuration.key_file = client_key_file
    elif client_key:
        with tempfile.NamedTemporaryFile(prefix=&quot;salt-kube-&quot;, delete=False) as k:
            k.write(base64.b64decode(client_key))
            kubernetes.client.configuration.key_file = k.name
    else:
        kubernetes.client.configuration.key_file = None
    return {}


# pylint: disable=no-member
def _setup_conn(**kwargs):
    &quot;&quot;&quot;
    Setup kubernetes API connection singleton
    &quot;&quot;&quot;
    kubeconfig = kwargs.get(&quot;kubeconfig&quot;) or __salt__[&quot;config.option&quot;](
        &quot;kubernetes.kubeconfig&quot;
    )
    kubeconfig_data = kwargs.get(&quot;kubeconfig_data&quot;) or __salt__[&quot;config.option&quot;](
        &quot;kubernetes.kubeconfig-data&quot;
    )
    context = kwargs.get(&quot;context&quot;) or __salt__[&quot;config.option&quot;](&quot;kubernetes.context&quot;)

    if (kubeconfig_data and not kubeconfig) or (
        kubeconfig_data and kwargs.get(&quot;kubeconfig_data&quot;)
    ):
        with tempfile.NamedTemporaryFile(
            prefix=&quot;salt-kubeconfig-&quot;, delete=False
        ) as kcfg:
            kcfg.write(base64.b64decode(kubeconfig_data))
            kubeconfig = kcfg.name

    if not (kubeconfig and context):
        if kwargs.get(&quot;api_url&quot;) or __salt__[&quot;config.option&quot;](&quot;kubernetes.api_url&quot;):
            try:
                return _setup_conn_old(**kwargs)
            except Exception:  # pylint: disable=broad-except
                raise CommandExecutionError(
                    &quot;Old style kubernetes configuration is only supported up to&quot;
                    &quot; python-kubernetes 2.0.0&quot;
                )
        else:
            raise CommandExecutionError(
                &quot;Invalid kubernetes configuration. Parameter 'kubeconfig' and 'context'&quot;
                &quot; are required.&quot;
            )
    kubernetes.config.load_kube_config(config_file=kubeconfig, context=context)

    # The return makes unit testing easier
    return {&quot;kubeconfig&quot;: kubeconfig, &quot;context&quot;: context}


def _cleanup_old(**kwargs):
    try:
        ca = kubernetes.client.configuration.ssl_ca_cert
        cert = kubernetes.client.configuration.cert_file
<A NAME="2"></A>        key = kubernetes.client.configuration.key_file
        if (
            cert
            and os<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match126554-0.html#2',2,'match126554-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.path.exists(cert)
            and os.path.basename(cert).startswith(&quot;salt-kube-&quot;)
        ):
<A NAME="1"></A>            salt.utils.files.safe_rm(</B></FONT>cert)
        if (
            key
            and os<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match126554-0.html#1',2,'match126554-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.path.exists(key)
            and os.path.basename(key).startswith(&quot;salt-kube-&quot;)
        ):
            salt.utils.files.safe_rm(</B></FONT>key)
        if ca and os.path.exists(ca) and os.path.basename(ca).startswith(&quot;salt-kube-&quot;):
            salt.utils.files.safe_rm(ca)
    except Exception:  # pylint: disable=broad-except
        pass


def _cleanup(**kwargs):
    if not kwargs:
        return _cleanup_old(**kwargs)

    if &quot;kubeconfig&quot; in kwargs:
        kubeconfig = kwargs.get(&quot;kubeconfig&quot;)
        if kubeconfig and os.path.basename(kubeconfig).startswith(&quot;salt-kubeconfig-&quot;):
            try:
                os.unlink(kubeconfig)
            except OSError as err:
                if err.errno != errno.ENOENT:
                    log.exception(err)


def ping(**kwargs):
    &quot;&quot;&quot;
    Checks connections with the kubernetes API server.
    Returns True if the connection can be established, False otherwise.

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.ping
    &quot;&quot;&quot;
    status = True
    try:
        nodes(**kwargs)
    except CommandExecutionError:
        status = False

    return status


def nodes(**kwargs):
    &quot;&quot;&quot;
    Return the names of the nodes composing the kubernetes cluster

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.nodes
        salt '*' kubernetes.nodes kubeconfig=/etc/salt/k8s/kubeconfig context=minikube
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_node()

        return [
            k8s_node[&quot;metadata&quot;][&quot;name&quot;]
            for k8s_node in api_response.to_dict().get(&quot;items&quot;)
        ]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;list_node&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def node(name, **kwargs):
    &quot;&quot;&quot;
    Return the details of the node identified by the specified name

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.node name='minikube'
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_node()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;list_node&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)

    for k8s_node in api_response.items:
        if k8s_node.metadata.name == name:
            return k8s_node.to_dict()

    return None


def node_labels(name, **kwargs):
    &quot;&quot;&quot;
    Return the labels of the node identified by the specified name

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.node_labels name=&quot;minikube&quot;
    &quot;&quot;&quot;
    match = node(name, **kwargs)

    if match is not None:
        return match[&quot;metadata&quot;][&quot;labels&quot;]

    return {}


def node_add_label(node_name, label_name, label_value, **kwargs):
    &quot;&quot;&quot;
    Set the value of the label identified by `label_name` to `label_value` on
    the node identified by the name `node_name`.
    Creates the label if not present.

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.node_add_label node_name=&quot;minikube&quot; \
            label_name=&quot;foo&quot; label_value=&quot;bar&quot;
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        body = {&quot;metadata&quot;: {&quot;labels&quot;: {label_name: label_value}}}
        api_response = api_instance.patch_node(node_name, body)
        return api_response
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;patch_node&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)

    return None


def node_remove_label(node_name, label_name, **kwargs):
    &quot;&quot;&quot;
    Removes the label identified by `label_name` from
    the node identified by the name `node_name`.

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.node_remove_label node_name=&quot;minikube&quot; \
            label_name=&quot;foo&quot;
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        body = {&quot;metadata&quot;: {&quot;labels&quot;: {label_name: None}}}
        api_response = api_instance.patch_node(node_name, body)
        return api_response
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;patch_node&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)

    return None


def namespaces(**kwargs):
    &quot;&quot;&quot;
    Return the names of the available namespaces

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.namespaces
        salt '*' kubernetes.namespaces kubeconfig=/etc/salt/k8s/kubeconfig context=minikube
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespace()

        return [nms[&quot;metadata&quot;][&quot;name&quot;] for nms in api_response.to_dict().get(&quot;items&quot;)]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;list_namespace&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def deployments(namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Return a list of kubernetes deployments defined in the namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.deployments
        salt '*' kubernetes.deployments namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.list_namespaced_deployment(namespace)

        return [dep[&quot;metadata&quot;][&quot;name&quot;] for dep in api_response.to_dict().get(&quot;items&quot;)]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling &quot;
                &quot;ExtensionsV1beta1Api-&gt;list_namespaced_deployment&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def services(namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Return a list of kubernetes services defined in the namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.services
        salt '*' kubernetes.services namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespaced_service(namespace)

        return [srv[&quot;metadata&quot;][&quot;name&quot;] for srv in api_response.to_dict().get(&quot;items&quot;)]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;list_namespaced_service&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def pods(namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Return a list of kubernetes pods defined in the namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.pods
        salt '*' kubernetes.pods namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespaced_pod(namespace)

        return [pod[&quot;metadata&quot;][&quot;name&quot;] for pod in api_response.to_dict().get(&quot;items&quot;)]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;list_namespaced_pod&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def secrets(namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Return a list of kubernetes secrets defined in the namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.secrets
        salt '*' kubernetes.secrets namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespaced_secret(namespace)

        return [
            secret[&quot;metadata&quot;][&quot;name&quot;] for secret in api_response.to_dict().get(&quot;items&quot;)
        ]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;list_namespaced_secret&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def configmaps(namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Return a list of kubernetes configmaps defined in the namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.configmaps
        salt '*' kubernetes.configmaps namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespaced_config_map(namespace)

        return [
            secret[&quot;metadata&quot;][&quot;name&quot;] for secret in api_response.to_dict().get(&quot;items&quot;)
        ]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling CoreV1Api-&gt;list_namespaced_config_map&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def show_deployment(name, namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Return the kubernetes deployment defined by name and namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.show_deployment my-nginx default
        salt '*' kubernetes.show_deployment name=my-nginx namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.read_namespaced_deployment(name, namespace)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling &quot;
                &quot;ExtensionsV1beta1Api-&gt;read_namespaced_deployment&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def show_service(name, namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Return the kubernetes service defined by name and namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.show_service my-nginx default
        salt '*' kubernetes.show_service name=my-nginx namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespaced_service(name, namespace)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;read_namespaced_service&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def show_pod(name, namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Return POD information for a given pod name defined in the namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.show_pod guestbook-708336848-fqr2x
        salt '*' kubernetes.show_pod guestbook-708336848-fqr2x namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespaced_pod(name, namespace)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;read_namespaced_pod&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def show_namespace(name, **kwargs):
    &quot;&quot;&quot;
    Return information for a given namespace defined by the specified name

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.show_namespace kube-system
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespace(name)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;read_namespace&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def show_secret(name, namespace=&quot;default&quot;, decode=False, **kwargs):
    &quot;&quot;&quot;
    Return the kubernetes secret defined by name and namespace.
    The secrets can be decoded if specified by the user. Warning: this has
    security implications.

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.show_secret confidential default
        salt '*' kubernetes.show_secret name=confidential namespace=default
        salt '*' kubernetes.show_secret name=confidential decode=True
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespaced_secret(name, namespace)

        if api_response.data and (decode or decode == &quot;True&quot;):
            for key in api_response.data:
                value = api_response.data[key]
                api_response.data[key] = base64.b64decode(value)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;read_namespaced_secret&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def show_configmap(name, namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Return the kubernetes configmap defined by name and namespace.

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.show_configmap game-config default
        salt '*' kubernetes.show_configmap name=game-config namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespaced_config_map(name, namespace)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling CoreV1Api-&gt;read_namespaced_config_map&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def delete_deployment(name, namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Deletes the kubernetes deployment defined by name and namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.delete_deployment my-nginx
        salt '*' kubernetes.delete_deployment name=my-nginx namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)

    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.delete_namespaced_deployment(
            name=name, namespace=namespace, body=body
        )
        mutable_api_response = api_response.to_dict()
        if not salt.utils.platform.is_windows():
            try:
                with _time_limit(POLLING_TIME_LIMIT):
                    while show_deployment(name, namespace) is not None:
                        time.sleep(1)
                    else:  # pylint: disable=useless-else-on-loop
                        mutable_api_response[&quot;code&quot;] = 200
            except TimeoutError:
                pass
        else:
            # Windows has not signal.alarm implementation, so we are just falling
            # back to loop-counting.
            for i in range(60):
                if show_deployment(name, namespace) is None:
                    mutable_api_response[&quot;code&quot;] = 200
                    break
                else:
                    time.sleep(1)
        if mutable_api_response[&quot;code&quot;] != 200:
            log.warning(
                &quot;Reached polling time limit. Deployment is not yet &quot;
                &quot;deleted, but we are backing off. Sorry, but you'll &quot;
                &quot;have to check manually.&quot;
            )
        return mutable_api_response
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling &quot;
                &quot;ExtensionsV1beta1Api-&gt;delete_namespaced_deployment&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def delete_service(name, namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Deletes the kubernetes service defined by name and namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.delete_service my-nginx default
        salt '*' kubernetes.delete_service name=my-nginx namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespaced_service(
            name=name, namespace=namespace
        )

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;delete_namespaced_service&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def delete_pod(name, namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Deletes the kubernetes pod defined by name and namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.delete_pod guestbook-708336848-5nl8c default
        salt '*' kubernetes.delete_pod name=guestbook-708336848-5nl8c namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespaced_pod(
            name=name, namespace=namespace, body=body
        )

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;delete_namespaced_pod&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def delete_namespace(name, **kwargs):
    &quot;&quot;&quot;
    Deletes the kubernetes namespace defined by name

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.delete_namespace salt
        salt '*' kubernetes.delete_namespace name=salt
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespace(name=name, body=body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;delete_namespace&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def delete_secret(name, namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Deletes the kubernetes secret defined by name and namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.delete_secret confidential default
        salt '*' kubernetes.delete_secret name=confidential namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespaced_secret(
            name=name, namespace=namespace, body=body
        )

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;delete_namespaced_secret&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def delete_configmap(name, namespace=&quot;default&quot;, **kwargs):
    &quot;&quot;&quot;
    Deletes the kubernetes configmap defined by name and namespace

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.delete_configmap settings default
        salt '*' kubernetes.delete_configmap name=settings namespace=default
    &quot;&quot;&quot;
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespaced_config_map(
            name=name, namespace=namespace, body=body
        )

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling CoreV1Api-&gt;delete_namespaced_config_map&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def create_deployment(
    name, namespace, metadata, spec, source, template, saltenv, **kwargs
):
    &quot;&quot;&quot;
    Creates the kubernetes deployment as defined by the user.
    &quot;&quot;&quot;
    body = __create_object_body(
        kind=&quot;Deployment&quot;,
        obj_class=AppsV1beta1Deployment,
        spec_creator=__dict_to_deployment_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.create_namespaced_deployment(namespace, body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling &quot;
                &quot;ExtensionsV1beta1Api-&gt;create_namespaced_deployment&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def create_pod(name, namespace, metadata, spec, source, template, saltenv, **kwargs):
    &quot;&quot;&quot;
    Creates the kubernetes deployment as defined by the user.
    &quot;&quot;&quot;
    body = __create_object_body(
        kind=&quot;Pod&quot;,
        obj_class=kubernetes.client.V1Pod,
        spec_creator=__dict_to_pod_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespaced_pod(namespace, body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;create_namespaced_pod&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def create_service(
    name, namespace, metadata, spec, source, template, saltenv, **kwargs
):
    &quot;&quot;&quot;
    Creates the kubernetes service as defined by the user.
    &quot;&quot;&quot;
    body = __create_object_body(
        kind=&quot;Service&quot;,
        obj_class=kubernetes.client.V1Service,
        spec_creator=__dict_to_service_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespaced_service(namespace, body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;create_namespaced_service&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def create_secret(
    name,
    namespace=&quot;default&quot;,
    data=None,
    source=None,
    template=None,
    saltenv=&quot;base&quot;,
    **kwargs
):
    &quot;&quot;&quot;
    Creates the kubernetes secret as defined by the user.

    CLI Example:

    .. code-block:: bash

        salt 'minion1' kubernetes.create_secret \
            passwords default '{&quot;db&quot;: &quot;letmein&quot;}'

        salt 'minion2' kubernetes.create_secret \
            name=passwords namespace=default data='{&quot;db&quot;: &quot;letmein&quot;}'
    &quot;&quot;&quot;
    if source:
        data = __read_and_render_yaml_file(source, template, saltenv)
    elif data is None:
        data = {}

    data = __enforce_only_strings_dict(data)

    # encode the secrets using base64 as required by kubernetes
    for key in data:
        data[key] = base64.b64encode(data[key])

    body = kubernetes.client.V1Secret(
        metadata=__dict_to_object_meta(name, namespace, {}), data=data
    )

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespaced_secret(namespace, body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;create_namespaced_secret&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def create_configmap(
    name, namespace, data, source=None, template=None, saltenv=&quot;base&quot;, **kwargs
):
    &quot;&quot;&quot;
    Creates the kubernetes configmap as defined by the user.

    CLI Example:

    .. code-block:: bash

        salt 'minion1' kubernetes.create_configmap \
            settings default '{&quot;example.conf&quot;: &quot;# example file&quot;}'

        salt 'minion2' kubernetes.create_configmap \
            name=settings namespace=default data='{&quot;example.conf&quot;: &quot;# example file&quot;}'
    &quot;&quot;&quot;
    if source:
        data = __read_and_render_yaml_file(source, template, saltenv)
    elif data is None:
        data = {}

    data = __enforce_only_strings_dict(data)

    body = kubernetes.client.V1ConfigMap(
        metadata=__dict_to_object_meta(name, namespace, {}), data=data
    )

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespaced_config_map(namespace, body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling CoreV1Api-&gt;create_namespaced_config_map&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def create_namespace(name, **kwargs):
    &quot;&quot;&quot;
    Creates a namespace with the specified name.

    CLI Example:

    .. code-block:: bash

        salt '*' kubernetes.create_namespace salt
        salt '*' kubernetes.create_namespace name=salt
    &quot;&quot;&quot;

    meta_obj = kubernetes.client.V1ObjectMeta(name=name)
    body = kubernetes.client.V1Namespace(metadata=meta_obj)
    body.metadata.name = name

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespace(body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;create_namespace&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def replace_deployment(
    name, metadata, spec, source, template, saltenv, namespace=&quot;default&quot;, **kwargs
):
    &quot;&quot;&quot;
    Replaces an existing deployment with a new one defined by name and
    namespace, having the specificed metadata and spec.
    &quot;&quot;&quot;
    body = __create_object_body(
        kind=&quot;Deployment&quot;,
        obj_class=AppsV1beta1Deployment,
        spec_creator=__dict_to_deployment_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.replace_namespaced_deployment(name, namespace, body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling &quot;
                &quot;ExtensionsV1beta1Api-&gt;replace_namespaced_deployment&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def replace_service(
    name,
    metadata,
    spec,
    source,
    template,
    old_service,
    saltenv,
    namespace=&quot;default&quot;,
    **kwargs
):
    &quot;&quot;&quot;
    Replaces an existing service with a new one defined by name and namespace,
    having the specificed metadata and spec.
    &quot;&quot;&quot;
    body = __create_object_body(
        kind=&quot;Service&quot;,
        obj_class=kubernetes.client.V1Service,
        spec_creator=__dict_to_service_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )

    # Some attributes have to be preserved
    # otherwise exceptions will be thrown
    body.spec.cluster_ip = old_service[&quot;spec&quot;][&quot;cluster_ip&quot;]
    body.metadata.resource_version = old_service[&quot;metadata&quot;][&quot;resource_version&quot;]

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.replace_namespaced_service(name, namespace, body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling CoreV1Api-&gt;replace_namespaced_service&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def replace_secret(
    name,
    data,
    source=None,
    template=None,
    saltenv=&quot;base&quot;,
    namespace=&quot;default&quot;,
    **kwargs
):
    &quot;&quot;&quot;
    Replaces an existing secret with a new one defined by name and namespace,
    having the specificed data.

    CLI Example:

    .. code-block:: bash

        salt 'minion1' kubernetes.replace_secret \
            name=passwords data='{&quot;db&quot;: &quot;letmein&quot;}'

        salt 'minion2' kubernetes.replace_secret \
            name=passwords namespace=saltstack data='{&quot;db&quot;: &quot;passw0rd&quot;}'
    &quot;&quot;&quot;
    if source:
        data = __read_and_render_yaml_file(source, template, saltenv)
    elif data is None:
        data = {}

    data = __enforce_only_strings_dict(data)

    # encode the secrets using base64 as required by kubernetes
    for key in data:
        data[key] = base64.b64encode(data[key])

    body = kubernetes.client.V1Secret(
        metadata=__dict_to_object_meta(name, namespace, {}), data=data
    )

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.replace_namespaced_secret(name, namespace, body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(&quot;Exception when calling CoreV1Api-&gt;replace_namespaced_secret&quot;)
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def replace_configmap(
    name,
    data,
    source=None,
    template=None,
    saltenv=&quot;base&quot;,
    namespace=&quot;default&quot;,
    **kwargs
):
    &quot;&quot;&quot;
    Replaces an existing configmap with a new one defined by name and
    namespace with the specified data.

    CLI Example:

    .. code-block:: bash

        salt 'minion1' kubernetes.replace_configmap \
            settings default '{&quot;example.conf&quot;: &quot;# example file&quot;}'

        salt 'minion2' kubernetes.replace_configmap \
            name=settings namespace=default data='{&quot;example.conf&quot;: &quot;# example file&quot;}'
    &quot;&quot;&quot;
    if source:
        data = __read_and_render_yaml_file(source, template, saltenv)

    data = __enforce_only_strings_dict(data)

    body = kubernetes.client.V1ConfigMap(
        metadata=__dict_to_object_meta(name, namespace, {}), data=data
    )

    cfg = _setup_conn(**kwargs)

    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.replace_namespaced_config_map(name, namespace, body)

        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                &quot;Exception when calling CoreV1Api-&gt;replace_namespaced_configmap&quot;
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)


def __create_object_body(
    kind,
    obj_class,
    spec_creator,
    name,
    namespace,
    metadata,
    spec,
    source,
    template,
    saltenv,
):
    &quot;&quot;&quot;
    Create a Kubernetes Object body instance.
    &quot;&quot;&quot;
    if source:
        src_obj = __read_and_render_yaml_file(source, template, saltenv)
        if (
            not isinstance(src_obj, dict)
            or &quot;kind&quot; not in src_obj
            or src_obj[&quot;kind&quot;] != kind
        ):
            raise CommandExecutionError(
                &quot;The source file should define only a {} object&quot;.format(kind)
            )

        if &quot;metadata&quot; in src_obj:
            metadata = src_obj[&quot;metadata&quot;]
        if &quot;spec&quot; in src_obj:
            spec = src_obj[&quot;spec&quot;]

    return obj_class(
        metadata=__dict_to_object_meta(name, namespace, metadata),
        spec=spec_creator(spec),
    )


def __read_and_render_yaml_file(source, template, saltenv):
    &quot;&quot;&quot;
    Read a yaml file and, if needed, renders that using the specifieds
    templating. Returns the python objects defined inside of the file.
    &quot;&quot;&quot;
    sfn = __salt__[&quot;cp.cache_file&quot;](source, saltenv)
    if not sfn:
        raise CommandExecutionError(&quot;Source file '{}' not found&quot;.format(source))

    with salt.utils.files.fopen(sfn, &quot;r&quot;) as src:
        contents = src.read()

        if template:
            if template in salt.utils.templates.TEMPLATE_REGISTRY:
                # TODO: should we allow user to set also `context` like  # pylint: disable=fixme
                # `file.managed` does?
                # Apply templating
                data = salt.utils.templates.TEMPLATE_REGISTRY[template](
                    contents,
                    from_str=True,
                    to_str=True,
                    saltenv=saltenv,
                    grains=__grains__,
                    pillar=__pillar__,
                    salt=__salt__,
                    opts=__opts__,
                )

                if not data[&quot;result&quot;]:
                    # Failed to render the template
                    raise CommandExecutionError(
                        &quot;Failed to render file path with error: {}&quot;.format(data[&quot;data&quot;])
                    )

                contents = data[&quot;data&quot;].encode(&quot;utf-8&quot;)
            else:
                raise CommandExecutionError(
                    &quot;Unknown template specified: {}&quot;.format(template)
                )

        return salt.utils.yaml.safe_load(contents)


def __dict_to_object_meta(name, namespace, metadata):
    &quot;&quot;&quot;
    Converts a dictionary into kubernetes ObjectMetaV1 instance.
    &quot;&quot;&quot;
    meta_obj = kubernetes.client.V1ObjectMeta()
    meta_obj.namespace = namespace

    # Replicate `kubectl [create|replace|apply] --record`
    if &quot;annotations&quot; not in metadata:
        metadata[&quot;annotations&quot;] = {}
    if &quot;kubernetes.io/change-cause&quot; not in metadata[&quot;annotations&quot;]:
        metadata[&quot;annotations&quot;][&quot;kubernetes.io/change-cause&quot;] = &quot; &quot;.join(sys.argv)

    for key, value in metadata.items():
        if hasattr(meta_obj, key):
            setattr(meta_obj, key, value)

    if meta_obj.name != name:
        log.warning(
            &quot;The object already has a name attribute, overwriting it with &quot;
            &quot;the one defined inside of salt&quot;
        )
        meta_obj.name = name

    return meta_obj


def __dict_to_deployment_spec(spec):
    &quot;&quot;&quot;
    Converts a dictionary into kubernetes AppsV1beta1DeploymentSpec instance.
    &quot;&quot;&quot;
    spec_obj = AppsV1beta1DeploymentSpec(template=spec.get(&quot;template&quot;, &quot;&quot;))
    for key, value in spec.items():
        if hasattr(spec_obj, key):
            setattr(spec_obj, key, value)

    return spec_obj


def __dict_to_pod_spec(spec):
    &quot;&quot;&quot;
    Converts a dictionary into kubernetes V1PodSpec instance.
    &quot;&quot;&quot;
    spec_obj = kubernetes.client.V1PodSpec()
    for key, value in spec.items():
        if hasattr(spec_obj, key):
            setattr(spec_obj, key, value)

    return spec_obj


def __dict_to_service_spec(spec):
    &quot;&quot;&quot;
    Converts a dictionary into kubernetes V1ServiceSpec instance.
    &quot;&quot;&quot;
    spec_obj = kubernetes.client.V1ServiceSpec()
    for key, value in spec.items():  # pylint: disable=too-many-nested-blocks
        if key == &quot;ports&quot;:
            spec_obj.ports = []
            for port in value:
                kube_port = kubernetes.client.V1ServicePort()
                if isinstance(port, dict):
                    for port_key, port_value in port.items():
                        if hasattr(kube_port, port_key):
                            setattr(kube_port, port_key, port_value)
                else:
                    kube_port.port = port
                spec_obj.ports.append(kube_port)
        elif hasattr(spec_obj, key):
            setattr(spec_obj, key, value)

    return spec_obj


def __enforce_only_strings_dict(dictionary):
    &quot;&quot;&quot;
    Returns a dictionary that has string keys and values.
    &quot;&quot;&quot;
    ret = {}

    for key, value in dictionary.items():
        ret[str(key)] = str(value)

    return ret
</PRE>
</div>
  </div>
</body>
</html>
