<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for local_cache.py &amp; kubernetesmod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for local_cache.py &amp; kubernetesmod.py
      </h3>
<h1 align="center">
        2.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>local_cache.py (4.288939%)<th>kubernetesmod.py (2.0518358%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(6-20)<td><a href="#" name="0">(46-60)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(463-464)<td><a href="#" name="1">(243-246)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(112-113)<td><a href="#" name="2">(237-240)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>local_cache.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import bisect
import errno
import glob
import logging
import os
import shutil
import time
import salt.exceptions
import salt.payload
import salt.utils.atomicfile
import salt.utils.files
import salt.utils.jid
import salt.utils.minions
import</b></font> salt.utils.msgpack
import salt.utils.stringutils
log = logging.getLogger(__name__)
LOAD_P = ".load.p"
MINIONS_P = ".minions.p"
SYNDIC_MINIONS_P = ".minions.{0}.p"
RETURN_P = "return.p"
OUT_P = "out.p"
ENDTIME = "endtime"
def _job_dir():
    return os.path.join(__opts__["cachedir"], "jobs")
def _walk_through(job_dir):
    for top in os.listdir(job_dir):
        t_path = os.path.join(job_dir, top)
        if not os.path.exists(t_path):
            continue
        for final in os.listdir(t_path):
            load_path = os.path.join(t_path, final, LOAD_P)
            if not os.path.isfile(load_path):
                continue
            with salt.utils.files.fopen(load_path, "rb") as rfh:
                try:
                    job = salt.payload.load(rfh)
                except Exception:  # pylint: disable=broad-except
                    log.exception("Failed to deserialize %s", load_path)
                    continue
                if not job:
                    log.error(
                        "Deserialization of job succeded but there is no data in %s",
                        load_path,
                    )
                    continue
                jid = job["jid"]
                yield jid, job, t_path, final
def prep_jid(nocache=False, passed_jid=None, recurse_count=0):
    if recurse_count &gt;= 5:
        err = "prep_jid could not store a jid after {} tries.".format(recurse_count)
        log.error(err)
        raise salt.exceptions.SaltCacheError(err)
    if passed_jid is None:  # this can be a None or an empty string.
        jid = salt.utils.jid.gen_jid(__opts__)
    else:
        jid = passed_jid
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
    if not os.path.isdir(jid_dir):
        try:
            os.makedirs(jid_dir)
        except OSError:
            time.sleep(0.1)
            if passed_jid is None:
<a name="2"></a>                return prep_jid(nocache=nocache, recurse_count=recurse_count + 1)
    try:
        with salt.utils<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.files.fopen(os.path.join(jid_dir, "jid"), "wb+") as fn_:
            fn_.write(salt.utils.stringutils.to_bytes(</b></font>jid))
        if nocache:
            with salt.utils.files.fopen(os.path.join(jid_dir, "nocache"), "wb+"):
                pass
    except OSError:
        log.warning("Could not write out jid file for job %s. Retrying.", jid)
        time.sleep(0.1)
        return prep_jid(
            passed_jid=jid, nocache=nocache, recurse_count=recurse_count + 1
        )
    return jid
def returner(load):
    if load["jid"] == "req":
        load["jid"] = prep_jid(nocache=load.get("nocache", False))
    jid_dir = salt.utils.jid.jid_dir(load["jid"], _job_dir(), __opts__["hash_type"])
    if os.path.exists(os.path.join(jid_dir, "nocache")):
        return
    hn_dir = os.path.join(jid_dir, load["id"])
    try:
        os.makedirs(hn_dir)
    except OSError as err:
        if err.errno == errno.EEXIST:
            log.error(
                "An extra return was detected from minion %s, please verify "
                "the minion, this could be a replay attack",
                load["id"],
            )
            return False
        elif err.errno == errno.ENOENT:
            log.error(
                "An inconsistency occurred, a job was received with a job id "
                "(%s) that is not present in the local cache",
                load["jid"],
            )
            return False
        raise
    salt.payload.dump(
        {key: load[key] for key in ["return", "retcode", "success"] if key in load},
        salt.utils.atomicfile.atomic_open(os.path.join(hn_dir, RETURN_P), "w+b"),
    )
    if "out" in load:
        salt.payload.dump(
            load["out"],
            salt.utils.atomicfile.atomic_open(os.path.join(hn_dir, OUT_P), "w+b"),
        )
def save_load(jid, clear_load, minions=None, recurse_count=0):
    if recurse_count &gt;= 5:
        err = "save_load could not write job cache file after {} retries.".format(
            recurse_count
        )
        log.error(err)
        raise salt.exceptions.SaltCacheError(err)
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
    try:
        if not os.path.exists(jid_dir):
            os.makedirs(jid_dir)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            pass
        else:
            raise
    try:
        with salt.utils.files.fopen(os.path.join(jid_dir, LOAD_P), "w+b") as wfh:
            salt.payload.dump(clear_load, wfh)
    except OSError as exc:
        log.warning("Could not write job invocation cache file: %s", exc)
        time.sleep(0.1)
        return save_load(
            jid=jid, clear_load=clear_load, recurse_count=recurse_count + 1
        )
    if "tgt" in clear_load and clear_load["tgt"] != "":
        if minions is None:
            ckminions = salt.utils.minions.CkMinions(__opts__)
            _res = ckminions.check_minions(
                clear_load["tgt"], clear_load.get("tgt_type", "glob")
            )
            minions = _res["minions"]
        save_minions(jid, minions)
def save_minions(jid, minions, syndic_id=None):
    minions = list(minions)
    log.debug(
        "Adding minions for job %s%s: %s",
        jid,
        " from syndic master '{}'".format(syndic_id) if syndic_id else "",
        minions,
    )
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
    try:
        if not os.path.exists(jid_dir):
            os.makedirs(jid_dir)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            pass
        else:
            raise
    if syndic_id is not None:
        minions_path = os.path.join(jid_dir, SYNDIC_MINIONS_P.format(syndic_id))
    else:
        minions_path = os.path.join(jid_dir, MINIONS_P)
    try:
        if not os.path.exists(jid_dir):
            try:
                os.makedirs(jid_dir)
            except OSError:
                pass
        with salt.utils.files.fopen(minions_path, "w+b") as wfh:
            salt.payload.dump(minions, wfh)
    except OSError as exc:
        log.error(
            "Failed to write minion list %s to job cache file %s: %s",
            minions,
            minions_path,
            exc,
        )
def get_load(jid):
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
    load_fn = os.path.join(jid_dir, LOAD_P)
    if not os.path.exists(jid_dir) or not os.path.exists(load_fn):
        return {}
    ret = {}
    load_p = os.path.join(jid_dir, LOAD_P)
    num_tries = 5
    for index in range(1, num_tries + 1):
        with salt.utils.files.fopen(load_p, "rb") as rfh:
            try:
                ret = salt.payload.load(rfh)
                break
            except Exception as exc:  # pylint: disable=broad-except
                if index == num_tries:
                    time.sleep(0.25)
    else:
        log.critical("Failed to unpack %s", load_p)
        raise exc
    if ret is None:
        ret = {}
    minions_cache = [os.path.join(jid_dir, MINIONS_P)]
    minions_cache.extend(glob.glob(os.path.join(jid_dir, SYNDIC_MINIONS_P.format("*"))))
    all_minions = set()
    for minions_path in minions_cache:
        log.debug("Reading minion list from %s", minions_path)
        try:
            with salt.utils.files.fopen(minions_path, "rb") as rfh:
                all_minions.update(salt.payload.load(rfh))
        except OSError as exc:
            salt.utils.files.process_read_exception(exc, minions_path)
    if all_minions:
        ret["Minions"] = sorted(all_minions)
    return ret
def get_jid(jid):
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
    ret = {}
    if not os.path.isdir(jid_dir):
        return ret
    for fn_ in os.listdir(jid_dir):
        if fn_.startswith("."):
            continue
        if fn_ not in ret:
            retp = os.path.join(jid_dir, fn_, RETURN_P)
            outp = os.path.join(jid_dir, fn_, OUT_P)
            if not os.path.isfile(retp):
                continue
            while fn_ not in ret:
                try:
                    with salt.utils.files.fopen(retp, "rb") as rfh:
                        ret_data = salt.payload.load(rfh)
                    if not isinstance(ret_data, dict) or "return" not in ret_data:
                        ret_data = {"return": ret_data}
                    ret[fn_] = ret_data
                    if os.path.isfile(outp):
                        with salt.utils.files.fopen(outp, "rb") as rfh:
                            ret[fn_]["out"] = salt.payload.load(rfh)
                except Exception as exc:  # pylint: disable=broad-except
                    if "Permission denied:" in str(exc):
                        raise
    return ret
def get_jids():
    ret = {}
    for jid, job, _, _ in _walk_through(_job_dir()):
        ret[jid] = salt.utils.jid.format_jid_instance(jid, job)
        if __opts__.get("job_cache_store_endtime"):
            endtime = get_endtime(jid)
            if endtime:
                ret[jid]["EndTime"] = endtime
    return ret
def get_jids_filter(count, filter_find_job=True):
    keys = []
    ret = []
    for jid, job, _, _ in _walk_through(_job_dir()):
        job = salt.utils.jid.format_jid_instance_ext(jid, job)
        if filter_find_job and job["Function"] == "saltutil.find_job":
            continue
        i = bisect.bisect(keys, jid)
        if len(keys) == count and i == 0:
            continue
        keys.insert(i, jid)
        ret.insert(i, job)
        if len(keys) &gt; count:
            del keys[0]
            del ret[0]
    return ret
def clean_old_jobs():
    if __opts__["keep_jobs"] != 0:
        jid_root = _job_dir()
        if not os.path.exists(jid_root):
            return
        dirs_to_remove = set()
        for top in os.listdir(jid_root):
            t_path = os.path.join(jid_root, top)
            if not os.path.exists(t_path):
                continue
            t_path_dirs = os.listdir(t_path)
            if not t_path_dirs and t_path not in dirs_to_remove:
                dirs_to_remove.add(t_path)
                continue
            for final in t_path_dirs:
                f_path = os.path.join(t_path, final)
                jid_file = os.path.join(f_path, "jid")
                if not os.path.isfile(jid_file) and os.path.exists(f_path):
                    shutil.rmtree(f_path)
                elif os.path.isfile(jid_file):
                    jid_ctime = os.stat(jid_file).st_ctime
                    hours_difference = (time.time() - jid_ctime) / 3600.0
                    if hours_difference &gt; __opts__["keep_jobs"] and os.path.exists(
                        t_path
                    ):
                        try:
                            shutil.rmtree(f_path)
                        except OSError as err:
                            log.error("Unable to remove %s: %s", f_path, err)
        if dirs_to_remove:
            for t_path in dirs_to_remove:
                t_path_ctime = os.stat(t_path).st_ctime
                hours_difference = (time.time() - t_path_ctime) / 3600.0
                if hours_difference &gt; __opts__["keep_jobs"]:
                    shutil.rmtree(t_path)
def update_endtime(jid, time):
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
<a name="1"></a>    try:
        if not os.path.exists(jid_dir):
            os.makedirs(jid_dir)
        with salt.utils<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.files.fopen(os.path.join(jid_dir, ENDTIME), "w") as etfile:
            etfile.write(salt.utils.stringutils.to_str(</b></font>time))
    except OSError as exc:
        log.warning("Could not write job invocation cache file: %s", exc)
def get_endtime(jid):
    jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
    etpath = os.path.join(jid_dir, ENDTIME)
    if not os.path.exists(etpath):
        return False
    with salt.utils.files.fopen(etpath, "r") as etfile:
        endtime = salt.utils.stringutils.to_unicode(etfile.read()).strip("\n")
    return endtime
def _reg_dir():
    return os.path.join(__opts__["cachedir"], "thorium")
def save_reg(data):
    reg_dir = _reg_dir()
    regfile = os.path.join(reg_dir, "register")
    try:
        if not os.path.exists(reg_dir):
            os.makedirs(reg_dir)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            pass
        else:
            raise
    try:
        with salt.utils.files.fopen(regfile, "a") as fh_:
            salt.utils.msgpack.dump(data, fh_)
    except Exception:  # pylint: disable=broad-except
        log.error("Could not write to msgpack file %s", __opts__["outdir"])
        raise
def load_reg():
    reg_dir = _reg_dir()
    regfile = os.path.join(reg_dir, "register")
    try:
        with salt.utils.files.fopen(regfile, "r") as fh_:
            return salt.utils.msgpack.load(fh_)
    except Exception:  # pylint: disable=broad-except
        log.error("Could not write to msgpack file %s", __opts__["outdir"])
        raise
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>kubernetesmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import base64
import errno
import logging
import os.path
import signal
import sys
import tempfile
import time
from contextlib import contextmanager
import salt.utils.files
import salt.utils.platform
import salt.utils.templates
import salt.utils.yaml
from</b></font> salt.exceptions import CommandExecutionError, TimeoutError
try:
    import kubernetes  # pylint: disable=import-self
    import kubernetes.client
    from kubernetes.client.rest import ApiException
    from urllib3.exceptions import HTTPError
    try:
        from kubernetes.client import V1beta1Deployment as AppsV1beta1Deployment
        from kubernetes.client import V1beta1DeploymentSpec as AppsV1beta1DeploymentSpec
    except ImportError:
        from kubernetes.client import AppsV1beta1Deployment
        from kubernetes.client import AppsV1beta1DeploymentSpec
    HAS_LIBS = True
except ImportError:
    HAS_LIBS = False
log = logging.getLogger(__name__)
__virtualname__ = "kubernetes"
def __virtual__():
    if HAS_LIBS:
        return __virtualname__
    return False, "python kubernetes library not found"
if not salt.utils.platform.is_windows():
    @contextmanager
    def _time_limit(seconds):
        def signal_handler(signum, frame):
            raise TimeoutError
        signal.signal(signal.SIGALRM, signal_handler)
        signal.alarm(seconds)
        try:
            yield
        finally:
            signal.alarm(0)
    POLLING_TIME_LIMIT = 30
def _setup_conn_old(**kwargs):
    host = __salt__["config.option"]("kubernetes.api_url", "http://localhost:8080")
    username = __salt__["config.option"]("kubernetes.user")
    password = __salt__["config.option"]("kubernetes.password")
    ca_cert = __salt__["config.option"]("kubernetes.certificate-authority-data")
    client_cert = __salt__["config.option"]("kubernetes.client-certificate-data")
    client_key = __salt__["config.option"]("kubernetes.client-key-data")
    ca_cert_file = __salt__["config.option"]("kubernetes.certificate-authority-file")
    client_cert_file = __salt__["config.option"]("kubernetes.client-certificate-file")
    client_key_file = __salt__["config.option"]("kubernetes.client-key-file")
    if "api_url" in kwargs:
        host = kwargs.get("api_url")
    if "api_user" in kwargs:
        username = kwargs.get("api_user")
    if "api_password" in kwargs:
        password = kwargs.get("api_password")
    if "api_certificate_authority_file" in kwargs:
        ca_cert_file = kwargs.get("api_certificate_authority_file")
    if "api_client_certificate_file" in kwargs:
        client_cert_file = kwargs.get("api_client_certificate_file")
    if "api_client_key_file" in kwargs:
        client_key_file = kwargs.get("api_client_key_file")
    if (
        kubernetes.client.configuration.host != host
        or kubernetes.client.configuration.user != username
        or kubernetes.client.configuration.password != password
    ):
        kubernetes.client.configuration.__init__()
    kubernetes.client.configuration.host = host
    kubernetes.client.configuration.user = username
    kubernetes.client.configuration.passwd = password
    if ca_cert_file:
        kubernetes.client.configuration.ssl_ca_cert = ca_cert_file
    elif ca_cert:
        with tempfile.NamedTemporaryFile(prefix="salt-kube-", delete=False) as ca:
            ca.write(base64.b64decode(ca_cert))
            kubernetes.client.configuration.ssl_ca_cert = ca.name
    else:
        kubernetes.client.configuration.ssl_ca_cert = None
    if client_cert_file:
        kubernetes.client.configuration.cert_file = client_cert_file
    elif client_cert:
        with tempfile.NamedTemporaryFile(prefix="salt-kube-", delete=False) as c:
            c.write(base64.b64decode(client_cert))
            kubernetes.client.configuration.cert_file = c.name
    else:
        kubernetes.client.configuration.cert_file = None
    if client_key_file:
        kubernetes.client.configuration.key_file = client_key_file
    elif client_key:
        with tempfile.NamedTemporaryFile(prefix="salt-kube-", delete=False) as k:
            k.write(base64.b64decode(client_key))
            kubernetes.client.configuration.key_file = k.name
    else:
        kubernetes.client.configuration.key_file = None
    return {}
def _setup_conn(**kwargs):
    kubeconfig = kwargs.get("kubeconfig") or __salt__["config.option"](
        "kubernetes.kubeconfig"
    )
    kubeconfig_data = kwargs.get("kubeconfig_data") or __salt__["config.option"](
        "kubernetes.kubeconfig-data"
    )
    context = kwargs.get("context") or __salt__["config.option"]("kubernetes.context")
    if (kubeconfig_data and not kubeconfig) or (
        kubeconfig_data and kwargs.get("kubeconfig_data")
    ):
        with tempfile.NamedTemporaryFile(
            prefix="salt-kubeconfig-", delete=False
        ) as kcfg:
            kcfg.write(base64.b64decode(kubeconfig_data))
            kubeconfig = kcfg.name
    if not (kubeconfig and context):
        if kwargs.get("api_url") or __salt__["config.option"]("kubernetes.api_url"):
            try:
                return _setup_conn_old(**kwargs)
            except Exception:  # pylint: disable=broad-except
                raise CommandExecutionError(
                    "Old style kubernetes configuration is only supported up to"
                    " python-kubernetes 2.0.0"
                )
        else:
            raise CommandExecutionError(
                "Invalid kubernetes configuration. Parameter 'kubeconfig' and 'context'"
                " are required."
            )
    kubernetes.config.load_kube_config(config_file=kubeconfig, context=context)
    return {"kubeconfig": kubeconfig, "context": context}
def _cleanup_old(**kwargs):
    try:
        ca = kubernetes.client.configuration.ssl_ca_cert
        cert = kubernetes.client.configuration.cert_file
<a name="2"></a>        key = kubernetes.client.configuration.key_file
        if (
            cert
            and os<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.path.exists(cert)
            and os.path.basename(cert).startswith("salt-kube-")
        ):
<a name="1"></a>            salt.utils.files.safe_rm(</b></font>cert)
        if (
            key
            and os<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.path.exists(key)
            and os.path.basename(key).startswith("salt-kube-")
        ):
            salt.utils.files.safe_rm(</b></font>key)
        if ca and os.path.exists(ca) and os.path.basename(ca).startswith("salt-kube-"):
            salt.utils.files.safe_rm(ca)
    except Exception:  # pylint: disable=broad-except
        pass
def _cleanup(**kwargs):
    if not kwargs:
        return _cleanup_old(**kwargs)
    if "kubeconfig" in kwargs:
        kubeconfig = kwargs.get("kubeconfig")
        if kubeconfig and os.path.basename(kubeconfig).startswith("salt-kubeconfig-"):
            try:
                os.unlink(kubeconfig)
            except OSError as err:
                if err.errno != errno.ENOENT:
                    log.exception(err)
def ping(**kwargs):
    status = True
    try:
        nodes(**kwargs)
    except CommandExecutionError:
        status = False
    return status
def nodes(**kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_node()
        return [
            k8s_node["metadata"]["name"]
            for k8s_node in api_response.to_dict().get("items")
        ]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;list_node")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def node(name, **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_node()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;list_node")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
    for k8s_node in api_response.items:
        if k8s_node.metadata.name == name:
            return k8s_node.to_dict()
    return None
def node_labels(name, **kwargs):
    match = node(name, **kwargs)
    if match is not None:
        return match["metadata"]["labels"]
    return {}
def node_add_label(node_name, label_name, label_value, **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        body = {"metadata": {"labels": {label_name: label_value}}}
        api_response = api_instance.patch_node(node_name, body)
        return api_response
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;patch_node")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
    return None
def node_remove_label(node_name, label_name, **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        body = {"metadata": {"labels": {label_name: None}}}
        api_response = api_instance.patch_node(node_name, body)
        return api_response
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;patch_node")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
    return None
def namespaces(**kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespace()
        return [nms["metadata"]["name"] for nms in api_response.to_dict().get("items")]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;list_namespace")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def deployments(namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.list_namespaced_deployment(namespace)
        return [dep["metadata"]["name"] for dep in api_response.to_dict().get("items")]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling "
                "ExtensionsV1beta1Api-&gt;list_namespaced_deployment"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def services(namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespaced_service(namespace)
        return [srv["metadata"]["name"] for srv in api_response.to_dict().get("items")]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;list_namespaced_service")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def pods(namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespaced_pod(namespace)
        return [pod["metadata"]["name"] for pod in api_response.to_dict().get("items")]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;list_namespaced_pod")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def secrets(namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespaced_secret(namespace)
        return [
            secret["metadata"]["name"] for secret in api_response.to_dict().get("items")
        ]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;list_namespaced_secret")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def configmaps(namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.list_namespaced_config_map(namespace)
        return [
            secret["metadata"]["name"] for secret in api_response.to_dict().get("items")
        ]
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling CoreV1Api-&gt;list_namespaced_config_map"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def show_deployment(name, namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.read_namespaced_deployment(name, namespace)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling "
                "ExtensionsV1beta1Api-&gt;read_namespaced_deployment"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def show_service(name, namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespaced_service(name, namespace)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;read_namespaced_service")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def show_pod(name, namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespaced_pod(name, namespace)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;read_namespaced_pod")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def show_namespace(name, **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespace(name)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;read_namespace")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def show_secret(name, namespace="default", decode=False, **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespaced_secret(name, namespace)
        if api_response.data and (decode or decode == "True"):
            for key in api_response.data:
                value = api_response.data[key]
                api_response.data[key] = base64.b64decode(value)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;read_namespaced_secret")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def show_configmap(name, namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.read_namespaced_config_map(name, namespace)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling CoreV1Api-&gt;read_namespaced_config_map"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def delete_deployment(name, namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.delete_namespaced_deployment(
            name=name, namespace=namespace, body=body
        )
        mutable_api_response = api_response.to_dict()
        if not salt.utils.platform.is_windows():
            try:
                with _time_limit(POLLING_TIME_LIMIT):
                    while show_deployment(name, namespace) is not None:
                        time.sleep(1)
                    else:  # pylint: disable=useless-else-on-loop
                        mutable_api_response["code"] = 200
            except TimeoutError:
                pass
        else:
            for i in range(60):
                if show_deployment(name, namespace) is None:
                    mutable_api_response["code"] = 200
                    break
                else:
                    time.sleep(1)
        if mutable_api_response["code"] != 200:
            log.warning(
                "Reached polling time limit. Deployment is not yet "
                "deleted, but we are backing off. Sorry, but you'll "
                "have to check manually."
            )
        return mutable_api_response
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling "
                "ExtensionsV1beta1Api-&gt;delete_namespaced_deployment"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def delete_service(name, namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespaced_service(
            name=name, namespace=namespace
        )
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;delete_namespaced_service")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def delete_pod(name, namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespaced_pod(
            name=name, namespace=namespace, body=body
        )
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;delete_namespaced_pod")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def delete_namespace(name, **kwargs):
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespace(name=name, body=body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;delete_namespace")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def delete_secret(name, namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespaced_secret(
            name=name, namespace=namespace, body=body
        )
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;delete_namespaced_secret")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def delete_configmap(name, namespace="default", **kwargs):
    cfg = _setup_conn(**kwargs)
    body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.delete_namespaced_config_map(
            name=name, namespace=namespace, body=body
        )
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling CoreV1Api-&gt;delete_namespaced_config_map"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def create_deployment(
    name, namespace, metadata, spec, source, template, saltenv, **kwargs
):
    body = __create_object_body(
        kind="Deployment",
        obj_class=AppsV1beta1Deployment,
        spec_creator=__dict_to_deployment_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.create_namespaced_deployment(namespace, body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling "
                "ExtensionsV1beta1Api-&gt;create_namespaced_deployment"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def create_pod(name, namespace, metadata, spec, source, template, saltenv, **kwargs):
    body = __create_object_body(
        kind="Pod",
        obj_class=kubernetes.client.V1Pod,
        spec_creator=__dict_to_pod_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespaced_pod(namespace, body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;create_namespaced_pod")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def create_service(
    name, namespace, metadata, spec, source, template, saltenv, **kwargs
):
    body = __create_object_body(
        kind="Service",
        obj_class=kubernetes.client.V1Service,
        spec_creator=__dict_to_service_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespaced_service(namespace, body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;create_namespaced_service")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def create_secret(
    name,
    namespace="default",
    data=None,
    source=None,
    template=None,
    saltenv="base",
    **kwargs
):
    if source:
        data = __read_and_render_yaml_file(source, template, saltenv)
    elif data is None:
        data = {}
    data = __enforce_only_strings_dict(data)
    for key in data:
        data[key] = base64.b64encode(data[key])
    body = kubernetes.client.V1Secret(
        metadata=__dict_to_object_meta(name, namespace, {}), data=data
    )
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespaced_secret(namespace, body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;create_namespaced_secret")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def create_configmap(
    name, namespace, data, source=None, template=None, saltenv="base", **kwargs
):
    if source:
        data = __read_and_render_yaml_file(source, template, saltenv)
    elif data is None:
        data = {}
    data = __enforce_only_strings_dict(data)
    body = kubernetes.client.V1ConfigMap(
        metadata=__dict_to_object_meta(name, namespace, {}), data=data
    )
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespaced_config_map(namespace, body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling CoreV1Api-&gt;create_namespaced_config_map"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def create_namespace(name, **kwargs):
    meta_obj = kubernetes.client.V1ObjectMeta(name=name)
    body = kubernetes.client.V1Namespace(metadata=meta_obj)
    body.metadata.name = name
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.create_namespace(body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;create_namespace")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def replace_deployment(
    name, metadata, spec, source, template, saltenv, namespace="default", **kwargs
):
    body = __create_object_body(
        kind="Deployment",
        obj_class=AppsV1beta1Deployment,
        spec_creator=__dict_to_deployment_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.ExtensionsV1beta1Api()
        api_response = api_instance.replace_namespaced_deployment(name, namespace, body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling "
                "ExtensionsV1beta1Api-&gt;replace_namespaced_deployment"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def replace_service(
    name,
    metadata,
    spec,
    source,
    template,
    old_service,
    saltenv,
    namespace="default",
    **kwargs
):
    body = __create_object_body(
        kind="Service",
        obj_class=kubernetes.client.V1Service,
        spec_creator=__dict_to_service_spec,
        name=name,
        namespace=namespace,
        metadata=metadata,
        spec=spec,
        source=source,
        template=template,
        saltenv=saltenv,
    )
    body.spec.cluster_ip = old_service["spec"]["cluster_ip"]
    body.metadata.resource_version = old_service["metadata"]["resource_version"]
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.replace_namespaced_service(name, namespace, body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling CoreV1Api-&gt;replace_namespaced_service"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def replace_secret(
    name,
    data,
    source=None,
    template=None,
    saltenv="base",
    namespace="default",
    **kwargs
):
    if source:
        data = __read_and_render_yaml_file(source, template, saltenv)
    elif data is None:
        data = {}
    data = __enforce_only_strings_dict(data)
    for key in data:
        data[key] = base64.b64encode(data[key])
    body = kubernetes.client.V1Secret(
        metadata=__dict_to_object_meta(name, namespace, {}), data=data
    )
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.replace_namespaced_secret(name, namespace, body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception("Exception when calling CoreV1Api-&gt;replace_namespaced_secret")
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def replace_configmap(
    name,
    data,
    source=None,
    template=None,
    saltenv="base",
    namespace="default",
    **kwargs
):
    if source:
        data = __read_and_render_yaml_file(source, template, saltenv)
    data = __enforce_only_strings_dict(data)
    body = kubernetes.client.V1ConfigMap(
        metadata=__dict_to_object_meta(name, namespace, {}), data=data
    )
    cfg = _setup_conn(**kwargs)
    try:
        api_instance = kubernetes.client.CoreV1Api()
        api_response = api_instance.replace_namespaced_config_map(name, namespace, body)
        return api_response.to_dict()
    except (ApiException, HTTPError) as exc:
        if isinstance(exc, ApiException) and exc.status == 404:
            return None
        else:
            log.exception(
                "Exception when calling CoreV1Api-&gt;replace_namespaced_configmap"
            )
            raise CommandExecutionError(exc)
    finally:
        _cleanup(**cfg)
def __create_object_body(
    kind,
    obj_class,
    spec_creator,
    name,
    namespace,
    metadata,
    spec,
    source,
    template,
    saltenv,
):
    if source:
        src_obj = __read_and_render_yaml_file(source, template, saltenv)
        if (
            not isinstance(src_obj, dict)
            or "kind" not in src_obj
            or src_obj["kind"] != kind
        ):
            raise CommandExecutionError(
                "The source file should define only a {} object".format(kind)
            )
        if "metadata" in src_obj:
            metadata = src_obj["metadata"]
        if "spec" in src_obj:
            spec = src_obj["spec"]
    return obj_class(
        metadata=__dict_to_object_meta(name, namespace, metadata),
        spec=spec_creator(spec),
    )
def __read_and_render_yaml_file(source, template, saltenv):
    sfn = __salt__["cp.cache_file"](source, saltenv)
    if not sfn:
        raise CommandExecutionError("Source file '{}' not found".format(source))
    with salt.utils.files.fopen(sfn, "r") as src:
        contents = src.read()
        if template:
            if template in salt.utils.templates.TEMPLATE_REGISTRY:
                data = salt.utils.templates.TEMPLATE_REGISTRY[template](
                    contents,
                    from_str=True,
                    to_str=True,
                    saltenv=saltenv,
                    grains=__grains__,
                    pillar=__pillar__,
                    salt=__salt__,
                    opts=__opts__,
                )
                if not data["result"]:
                    raise CommandExecutionError(
                        "Failed to render file path with error: {}".format(data["data"])
                    )
                contents = data["data"].encode("utf-8")
            else:
                raise CommandExecutionError(
                    "Unknown template specified: {}".format(template)
                )
        return salt.utils.yaml.safe_load(contents)
def __dict_to_object_meta(name, namespace, metadata):
    meta_obj = kubernetes.client.V1ObjectMeta()
    meta_obj.namespace = namespace
    if "annotations" not in metadata:
        metadata["annotations"] = {}
    if "kubernetes.io/change-cause" not in metadata["annotations"]:
        metadata["annotations"]["kubernetes.io/change-cause"] = " ".join(sys.argv)
    for key, value in metadata.items():
        if hasattr(meta_obj, key):
            setattr(meta_obj, key, value)
    if meta_obj.name != name:
        log.warning(
            "The object already has a name attribute, overwriting it with "
            "the one defined inside of salt"
        )
        meta_obj.name = name
    return meta_obj
def __dict_to_deployment_spec(spec):
    spec_obj = AppsV1beta1DeploymentSpec(template=spec.get("template", ""))
    for key, value in spec.items():
        if hasattr(spec_obj, key):
            setattr(spec_obj, key, value)
    return spec_obj
def __dict_to_pod_spec(spec):
    spec_obj = kubernetes.client.V1PodSpec()
    for key, value in spec.items():
        if hasattr(spec_obj, key):
            setattr(spec_obj, key, value)
    return spec_obj
def __dict_to_service_spec(spec):
    spec_obj = kubernetes.client.V1ServiceSpec()
    for key, value in spec.items():  # pylint: disable=too-many-nested-blocks
        if key == "ports":
            spec_obj.ports = []
            for port in value:
                kube_port = kubernetes.client.V1ServicePort()
                if isinstance(port, dict):
                    for port_key, port_value in port.items():
                        if hasattr(kube_port, port_key):
                            setattr(kube_port, port_key, port_value)
                else:
                    kube_port.port = port
                spec_obj.ports.append(kube_port)
        elif hasattr(spec_obj, key):
            setattr(spec_obj, key, value)
    return spec_obj
def __enforce_only_strings_dict(dictionary):
    ret = {}
    for key, value in dictionary.items():
        ret[str(key)] = str(value)
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
