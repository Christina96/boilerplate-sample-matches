<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for local_cache.py &amp; kubernetesmod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for local_cache.py &amp; kubernetesmod.py
      </h3>
<h1 align="center">
        2.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>local_cache.py (4.288939%)<th>kubernetesmod.py (2.0518358%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(6-20)<td><a href="#" name="0">(46-60)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(463-464)<td><a href="#" name="1">(243-246)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(112-113)<td><a href="#" name="2">(237-240)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>local_cache.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import bisect
2 import errno
3 import glob
4 import logging
5 import os
6 import shutil
7 import time
8 import salt.exceptions
9 import salt.payload
10 import salt.utils.atomicfile
11 import salt.utils.files
12 import salt.utils.jid
13 import salt.utils.minions
14 import</b></font> salt.utils.msgpack
15 import salt.utils.stringutils
16 log = logging.getLogger(__name__)
17 LOAD_P = ".load.p"
18 MINIONS_P = ".minions.p"
19 SYNDIC_MINIONS_P = ".minions.{0}.p"
20 RETURN_P = "return.p"
21 OUT_P = "out.p"
22 ENDTIME = "endtime"
23 def _job_dir():
24     return os.path.join(__opts__["cachedir"], "jobs")
25 def _walk_through(job_dir):
26     for top in os.listdir(job_dir):
27         t_path = os.path.join(job_dir, top)
28         if not os.path.exists(t_path):
29             continue
30         for final in os.listdir(t_path):
31             load_path = os.path.join(t_path, final, LOAD_P)
32             if not os.path.isfile(load_path):
33                 continue
34             with salt.utils.files.fopen(load_path, "rb") as rfh:
35                 try:
36                     job = salt.payload.load(rfh)
37                 except Exception:  # pylint: disable=broad-except
38                     log.exception("Failed to deserialize %s", load_path)
39                     continue
40                 if not job:
41                     log.error(
42                         "Deserialization of job succeded but there is no data in %s",
43                         load_path,
44                     )
45                     continue
46                 jid = job["jid"]
47                 yield jid, job, t_path, final
48 def prep_jid(nocache=False, passed_jid=None, recurse_count=0):
49     if recurse_count &gt;= 5:
50         err = "prep_jid could not store a jid after {} tries.".format(recurse_count)
51         log.error(err)
52         raise salt.exceptions.SaltCacheError(err)
53     if passed_jid is None:  # this can be a None or an empty string.
54         jid = salt.utils.jid.gen_jid(__opts__)
55     else:
56         jid = passed_jid
57     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
58     if not os.path.isdir(jid_dir):
59         try:
60             os.makedirs(jid_dir)
61         except OSError:
62             time.sleep(0.1)
63             if passed_jid is None:
64     try:
65         with salt.utils<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.files.fopen(os.path.join(jid_dir, "jid"), "wb+") as fn_:
66             fn_.write(salt.utils.stringutils.to_bytes(</b></font>jid))
67         if nocache:
68             with salt.utils.files.fopen(os.path.join(jid_dir, "nocache"), "wb+"):
69                 pass
70     except OSError:
71         log.warning("Could not write out jid file for job %s. Retrying.", jid)
72         time.sleep(0.1)
73         return prep_jid(
74             passed_jid=jid, nocache=nocache, recurse_count=recurse_count + 1
75         )
76     return jid
77 def returner(load):
78     if load["jid"] == "req":
79         load["jid"] = prep_jid(nocache=load.get("nocache", False))
80     jid_dir = salt.utils.jid.jid_dir(load["jid"], _job_dir(), __opts__["hash_type"])
81     if os.path.exists(os.path.join(jid_dir, "nocache")):
82         return
83     hn_dir = os.path.join(jid_dir, load["id"])
84     try:
85         os.makedirs(hn_dir)
86     except OSError as err:
87         if err.errno == errno.EEXIST:
88             log.error(
89                 "An extra return was detected from minion %s, please verify "
90                 "the minion, this could be a replay attack",
91                 load["id"],
92             )
93             return False
94         elif err.errno == errno.ENOENT:
95             log.error(
96                 "An inconsistency occurred, a job was received with a job id "
97                 "(%s) that is not present in the local cache",
98                 load["jid"],
99             )
100             return False
101         raise
102     salt.payload.dump(
103         {key: load[key] for key in ["return", "retcode", "success"] if key in load},
104         salt.utils.atomicfile.atomic_open(os.path.join(hn_dir, RETURN_P), "w+b"),
105     )
106     if "out" in load:
107         salt.payload.dump(
108             load["out"],
109             salt.utils.atomicfile.atomic_open(os.path.join(hn_dir, OUT_P), "w+b"),
110         )
111 def save_load(jid, clear_load, minions=None, recurse_count=0):
112     if recurse_count &gt;= 5:
113         err = "save_load could not write job cache file after {} retries.".format(
114             recurse_count
115         )
116         log.error(err)
117         raise salt.exceptions.SaltCacheError(err)
118     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
119     try:
120         if not os.path.exists(jid_dir):
121             os.makedirs(jid_dir)
122     except OSError as exc:
123         if exc.errno == errno.EEXIST:
124             pass
125         else:
126             raise
127     try:
128         with salt.utils.files.fopen(os.path.join(jid_dir, LOAD_P), "w+b") as wfh:
129             salt.payload.dump(clear_load, wfh)
130     except OSError as exc:
131         log.warning("Could not write job invocation cache file: %s", exc)
132         time.sleep(0.1)
133         return save_load(
134             jid=jid, clear_load=clear_load, recurse_count=recurse_count + 1
135         )
136     if "tgt" in clear_load and clear_load["tgt"] != "":
137         if minions is None:
138             ckminions = salt.utils.minions.CkMinions(__opts__)
139             _res = ckminions.check_minions(
140                 clear_load["tgt"], clear_load.get("tgt_type", "glob")
141             )
142             minions = _res["minions"]
143         save_minions(jid, minions)
144 def save_minions(jid, minions, syndic_id=None):
145     minions = list(minions)
146     log.debug(
147         "Adding minions for job %s%s: %s",
148         jid,
149         " from syndic master '{}'".format(syndic_id) if syndic_id else "",
150         minions,
151     )
152     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
153     try:
154         if not os.path.exists(jid_dir):
155             os.makedirs(jid_dir)
156     except OSError as exc:
157         if exc.errno == errno.EEXIST:
158             pass
159         else:
160             raise
161     if syndic_id is not None:
162         minions_path = os.path.join(jid_dir, SYNDIC_MINIONS_P.format(syndic_id))
163     else:
164         minions_path = os.path.join(jid_dir, MINIONS_P)
165     try:
166         if not os.path.exists(jid_dir):
167             try:
168                 os.makedirs(jid_dir)
169             except OSError:
170                 pass
171         with salt.utils.files.fopen(minions_path, "w+b") as wfh:
172             salt.payload.dump(minions, wfh)
173     except OSError as exc:
174         log.error(
175             "Failed to write minion list %s to job cache file %s: %s",
176             minions,
177             minions_path,
178             exc,
179         )
180 def get_load(jid):
181     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
182     load_fn = os.path.join(jid_dir, LOAD_P)
183     if not os.path.exists(jid_dir) or not os.path.exists(load_fn):
184         return {}
185     ret = {}
186     load_p = os.path.join(jid_dir, LOAD_P)
187     num_tries = 5
188     for index in range(1, num_tries + 1):
189         with salt.utils.files.fopen(load_p, "rb") as rfh:
190             try:
191                 ret = salt.payload.load(rfh)
192                 break
193             except Exception as exc:  # pylint: disable=broad-except
194                 if index == num_tries:
195                     time.sleep(0.25)
196     else:
197         log.critical("Failed to unpack %s", load_p)
198         raise exc
199     if ret is None:
200         ret = {}
201     minions_cache = [os.path.join(jid_dir, MINIONS_P)]
202     minions_cache.extend(glob.glob(os.path.join(jid_dir, SYNDIC_MINIONS_P.format("*"))))
203     all_minions = set()
204     for minions_path in minions_cache:
205         log.debug("Reading minion list from %s", minions_path)
206         try:
207             with salt.utils.files.fopen(minions_path, "rb") as rfh:
208                 all_minions.update(salt.payload.load(rfh))
209         except OSError as exc:
210             salt.utils.files.process_read_exception(exc, minions_path)
211     if all_minions:
212         ret["Minions"] = sorted(all_minions)
213     return ret
214 def get_jid(jid):
215     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
216     ret = {}
217     if not os.path.isdir(jid_dir):
218         return ret
219     for fn_ in os.listdir(jid_dir):
220         if fn_.startswith("."):
221             continue
222         if fn_ not in ret:
223             retp = os.path.join(jid_dir, fn_, RETURN_P)
224             outp = os.path.join(jid_dir, fn_, OUT_P)
225             if not os.path.isfile(retp):
226                 continue
227             while fn_ not in ret:
228                 try:
229                     with salt.utils.files.fopen(retp, "rb") as rfh:
230                         ret_data = salt.payload.load(rfh)
231                     if not isinstance(ret_data, dict) or "return" not in ret_data:
232                         ret_data = {"return": ret_data}
233                     ret[fn_] = ret_data
234                     if os.path.isfile(outp):
235                         with salt.utils.files.fopen(outp, "rb") as rfh:
236                             ret[fn_]["out"] = salt.payload.load(rfh)
237                 except Exception as exc:  # pylint: disable=broad-except
238                     if "Permission denied:" in str(exc):
239                         raise
240     return ret
241 def get_jids():
242     ret = {}
243     for jid, job, _, _ in _walk_through(_job_dir()):
244         ret[jid] = salt.utils.jid.format_jid_instance(jid, job)
245         if __opts__.get("job_cache_store_endtime"):
246             endtime = get_endtime(jid)
247             if endtime:
248                 ret[jid]["EndTime"] = endtime
249     return ret
250 def get_jids_filter(count, filter_find_job=True):
251     keys = []
252     ret = []
253     for jid, job, _, _ in _walk_through(_job_dir()):
254         job = salt.utils.jid.format_jid_instance_ext(jid, job)
255         if filter_find_job and job["Function"] == "saltutil.find_job":
256             continue
257         i = bisect.bisect(keys, jid)
258         if len(keys) == count and i == 0:
259             continue
260         keys.insert(i, jid)
261         ret.insert(i, job)
262         if len(keys) &gt; count:
263             del keys[0]
264             del ret[0]
265     return ret
266 def clean_old_jobs():
267     if __opts__["keep_jobs"] != 0:
268         jid_root = _job_dir()
269         if not os.path.exists(jid_root):
270             return
271         dirs_to_remove = set()
272         for top in os.listdir(jid_root):
273             t_path = os.path.join(jid_root, top)
274             if not os.path.exists(t_path):
275                 continue
276             t_path_dirs = os.listdir(t_path)
277             if not t_path_dirs and t_path not in dirs_to_remove:
278                 dirs_to_remove.add(t_path)
279                 continue
280             for final in t_path_dirs:
281                 f_path = os.path.join(t_path, final)
282                 jid_file = os.path.join(f_path, "jid")
283                 if not os.path.isfile(jid_file) and os.path.exists(f_path):
284                     shutil.rmtree(f_path)
285                 elif os.path.isfile(jid_file):
286                     jid_ctime = os.stat(jid_file).st_ctime
287                     hours_difference = (time.time() - jid_ctime) / 3600.0
288                     if hours_difference &gt; __opts__["keep_jobs"] and os.path.exists(
289                         t_path
290                     ):
291                         try:
292                             shutil.rmtree(f_path)
293                         except OSError as err:
294                             log.error("Unable to remove %s: %s", f_path, err)
295         if dirs_to_remove:
296             for t_path in dirs_to_remove:
297                 t_path_ctime = os.stat(t_path).st_ctime
298                 hours_difference = (time.time() - t_path_ctime) / 3600.0
299                 if hours_difference &gt; __opts__["keep_jobs"]:
300                     shutil.rmtree(t_path)
301 def update_endtime(jid, time):
302     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
303         if not os.path.exists(jid_dir):
304             os.makedirs(jid_dir)
305         with salt.utils<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.files.fopen(os.path.join(jid_dir, ENDTIME), "w") as etfile:
306             etfile.write(salt.utils.stringutils.to_str(</b></font>time))
307     except OSError as exc:
308         log.warning("Could not write job invocation cache file: %s", exc)
309 def get_endtime(jid):
310     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
311     etpath = os.path.join(jid_dir, ENDTIME)
312     if not os.path.exists(etpath):
313         return False
314     with salt.utils.files.fopen(etpath, "r") as etfile:
315         endtime = salt.utils.stringutils.to_unicode(etfile.read()).strip("\n")
316     return endtime
317 def _reg_dir():
318     return os.path.join(__opts__["cachedir"], "thorium")
319 def save_reg(data):
320     reg_dir = _reg_dir()
321     regfile = os.path.join(reg_dir, "register")
322     try:
323         if not os.path.exists(reg_dir):
324             os.makedirs(reg_dir)
325     except OSError as exc:
326         if exc.errno == errno.EEXIST:
327             pass
328         else:
329             raise
330     try:
331         with salt.utils.files.fopen(regfile, "a") as fh_:
332             salt.utils.msgpack.dump(data, fh_)
333     except Exception:  # pylint: disable=broad-except
334         log.error("Could not write to msgpack file %s", __opts__["outdir"])
335         raise
336 def load_reg():
337     reg_dir = _reg_dir()
338     regfile = os.path.join(reg_dir, "register")
339     try:
340         with salt.utils.files.fopen(regfile, "r") as fh_:
341             return salt.utils.msgpack.load(fh_)
342     except Exception:  # pylint: disable=broad-except
343         log.error("Could not write to msgpack file %s", __opts__["outdir"])
344         raise
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>kubernetesmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import base64
2 import errno
3 import logging
4 import os.path
5 import signal
6 import sys
7 import tempfile
8 import time
9 from contextlib import contextmanager
10 import salt.utils.files
11 import salt.utils.platform
12 import salt.utils.templates
13 import salt.utils.yaml
14 from</b></font> salt.exceptions import CommandExecutionError, TimeoutError
15 try:
16     import kubernetes  # pylint: disable=import-self
17     import kubernetes.client
18     from kubernetes.client.rest import ApiException
19     from urllib3.exceptions import HTTPError
20     try:
21         from kubernetes.client import V1beta1Deployment as AppsV1beta1Deployment
22         from kubernetes.client import V1beta1DeploymentSpec as AppsV1beta1DeploymentSpec
23     except ImportError:
24         from kubernetes.client import AppsV1beta1Deployment
25         from kubernetes.client import AppsV1beta1DeploymentSpec
26     HAS_LIBS = True
27 except ImportError:
28     HAS_LIBS = False
29 log = logging.getLogger(__name__)
30 __virtualname__ = "kubernetes"
31 def __virtual__():
32     if HAS_LIBS:
33         return __virtualname__
34     return False, "python kubernetes library not found"
35 if not salt.utils.platform.is_windows():
36     @contextmanager
37     def _time_limit(seconds):
38         def signal_handler(signum, frame):
39             raise TimeoutError
40         signal.signal(signal.SIGALRM, signal_handler)
41         signal.alarm(seconds)
42         try:
43             yield
44         finally:
45             signal.alarm(0)
46     POLLING_TIME_LIMIT = 30
47 def _setup_conn_old(**kwargs):
48     host = __salt__["config.option"]("kubernetes.api_url", "http://localhost:8080")
49     username = __salt__["config.option"]("kubernetes.user")
50     password = __salt__["config.option"]("kubernetes.password")
51     ca_cert = __salt__["config.option"]("kubernetes.certificate-authority-data")
52     client_cert = __salt__["config.option"]("kubernetes.client-certificate-data")
53     client_key = __salt__["config.option"]("kubernetes.client-key-data")
54     ca_cert_file = __salt__["config.option"]("kubernetes.certificate-authority-file")
55     client_cert_file = __salt__["config.option"]("kubernetes.client-certificate-file")
56     client_key_file = __salt__["config.option"]("kubernetes.client-key-file")
57     if "api_url" in kwargs:
58         host = kwargs.get("api_url")
59     if "api_user" in kwargs:
60         username = kwargs.get("api_user")
61     if "api_password" in kwargs:
62         password = kwargs.get("api_password")
63     if "api_certificate_authority_file" in kwargs:
64         ca_cert_file = kwargs.get("api_certificate_authority_file")
65     if "api_client_certificate_file" in kwargs:
66         client_cert_file = kwargs.get("api_client_certificate_file")
67     if "api_client_key_file" in kwargs:
68         client_key_file = kwargs.get("api_client_key_file")
69     if (
70         kubernetes.client.configuration.host != host
71         or kubernetes.client.configuration.user != username
72         or kubernetes.client.configuration.password != password
73     ):
74         kubernetes.client.configuration.__init__()
75     kubernetes.client.configuration.host = host
76     kubernetes.client.configuration.user = username
77     kubernetes.client.configuration.passwd = password
78     if ca_cert_file:
79         kubernetes.client.configuration.ssl_ca_cert = ca_cert_file
80     elif ca_cert:
81         with tempfile.NamedTemporaryFile(prefix="salt-kube-", delete=False) as ca:
82             ca.write(base64.b64decode(ca_cert))
83             kubernetes.client.configuration.ssl_ca_cert = ca.name
84     else:
85         kubernetes.client.configuration.ssl_ca_cert = None
86     if client_cert_file:
87         kubernetes.client.configuration.cert_file = client_cert_file
88     elif client_cert:
89         with tempfile.NamedTemporaryFile(prefix="salt-kube-", delete=False) as c:
90             c.write(base64.b64decode(client_cert))
91             kubernetes.client.configuration.cert_file = c.name
92     else:
93         kubernetes.client.configuration.cert_file = None
94     if client_key_file:
95         kubernetes.client.configuration.key_file = client_key_file
96     elif client_key:
97         with tempfile.NamedTemporaryFile(prefix="salt-kube-", delete=False) as k:
98             k.write(base64.b64decode(client_key))
99             kubernetes.client.configuration.key_file = k.name
100     else:
101         kubernetes.client.configuration.key_file = None
102     return {}
103 def _setup_conn(**kwargs):
104     kubeconfig = kwargs.get("kubeconfig") or __salt__["config.option"](
105         "kubernetes.kubeconfig"
106     )
107     kubeconfig_data = kwargs.get("kubeconfig_data") or __salt__["config.option"](
108         "kubernetes.kubeconfig-data"
109     )
110     context = kwargs.get("context") or __salt__["config.option"]("kubernetes.context")
111     if (kubeconfig_data and not kubeconfig) or (
112         kubeconfig_data and kwargs.get("kubeconfig_data")
113     ):
114         with tempfile.NamedTemporaryFile(
115             prefix="salt-kubeconfig-", delete=False
116         ) as kcfg:
117             kcfg.write(base64.b64decode(kubeconfig_data))
118             kubeconfig = kcfg.name
119     if not (kubeconfig and context):
120         if kwargs.get("api_url") or __salt__["config.option"]("kubernetes.api_url"):
121             try:
122                 return _setup_conn_old(**kwargs)
123             except Exception:  # pylint: disable=broad-except
124                 raise CommandExecutionError(
125                     "Old style kubernetes configuration is only supported up to"
126                     " python-kubernetes 2.0.0"
127                 )
128         else:
129             raise CommandExecutionError(
130                 "Invalid kubernetes configuration. Parameter 'kubeconfig' and 'context'"
131                 " are required."
132             )
133     kubernetes.config.load_kube_config(config_file=kubeconfig, context=context)
134     return {"kubeconfig": kubeconfig, "context": context}
135 def _cleanup_old(**kwargs):
136     try:
137         ca = kubernetes.client.configuration.ssl_ca_cert
138         cert = kubernetes.client.configuration.cert_file
139         if (
140             cert
141             and os<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.path.exists(cert)
142             and os.path.basename(cert).startswith("salt-kube-")
143         ):
144         if (
145             key
146             and os<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.path.exists(key)
147             and os.path.basename(key).startswith("salt-kube-")
148         ):
149             salt.utils.files.safe_rm(</b></font>key)
150         if ca and os.path.exists(ca) and os.path.basename(ca).startswith("salt-kube-"):
151             salt.utils.files.safe_rm(ca)
152     except Exception:  # pylint: disable=broad-except
153         pass
154 def _cleanup(**kwargs):
155     if not kwargs:
156         return _cleanup_old(**kwargs)
157     if "kubeconfig" in kwargs:
158         kubeconfig = kwargs.get("kubeconfig")
159         if kubeconfig and os.path.basename(kubeconfig).startswith("salt-kubeconfig-"):
160             try:
161                 os.unlink(kubeconfig)
162             except OSError as err:
163                 if err.errno != errno.ENOENT:
164                     log.exception(err)
165 def ping(**kwargs):
166     status = True
167     try:
168         nodes(**kwargs)
169     except CommandExecutionError:
170         status = False
171     return status
172 def nodes(**kwargs):
173     cfg = _setup_conn(**kwargs)
174     try:
175         api_instance = kubernetes.client.CoreV1Api()
176         api_response = api_instance.list_node()
177         return [
178             k8s_node["metadata"]["name"]
179             for k8s_node in api_response.to_dict().get("items")
180         ]
181     except (ApiException, HTTPError) as exc:
182         if isinstance(exc, ApiException) and exc.status == 404:
183             return None
184         else:
185             log.exception("Exception when calling CoreV1Api-&gt;list_node")
186             raise CommandExecutionError(exc)
187     finally:
188         _cleanup(**cfg)
189 def node(name, **kwargs):
190     cfg = _setup_conn(**kwargs)
191     try:
192         api_instance = kubernetes.client.CoreV1Api()
193         api_response = api_instance.list_node()
194     except (ApiException, HTTPError) as exc:
195         if isinstance(exc, ApiException) and exc.status == 404:
196             return None
197         else:
198             log.exception("Exception when calling CoreV1Api-&gt;list_node")
199             raise CommandExecutionError(exc)
200     finally:
201         _cleanup(**cfg)
202     for k8s_node in api_response.items:
203         if k8s_node.metadata.name == name:
204             return k8s_node.to_dict()
205     return None
206 def node_labels(name, **kwargs):
207     match = node(name, **kwargs)
208     if match is not None:
209         return match["metadata"]["labels"]
210     return {}
211 def node_add_label(node_name, label_name, label_value, **kwargs):
212     cfg = _setup_conn(**kwargs)
213     try:
214         api_instance = kubernetes.client.CoreV1Api()
215         body = {"metadata": {"labels": {label_name: label_value}}}
216         api_response = api_instance.patch_node(node_name, body)
217         return api_response
218     except (ApiException, HTTPError) as exc:
219         if isinstance(exc, ApiException) and exc.status == 404:
220             return None
221         else:
222             log.exception("Exception when calling CoreV1Api-&gt;patch_node")
223             raise CommandExecutionError(exc)
224     finally:
225         _cleanup(**cfg)
226     return None
227 def node_remove_label(node_name, label_name, **kwargs):
228     cfg = _setup_conn(**kwargs)
229     try:
230         api_instance = kubernetes.client.CoreV1Api()
231         body = {"metadata": {"labels": {label_name: None}}}
232         api_response = api_instance.patch_node(node_name, body)
233         return api_response
234     except (ApiException, HTTPError) as exc:
235         if isinstance(exc, ApiException) and exc.status == 404:
236             return None
237         else:
238             log.exception("Exception when calling CoreV1Api-&gt;patch_node")
239             raise CommandExecutionError(exc)
240     finally:
241         _cleanup(**cfg)
242     return None
243 def namespaces(**kwargs):
244     cfg = _setup_conn(**kwargs)
245     try:
246         api_instance = kubernetes.client.CoreV1Api()
247         api_response = api_instance.list_namespace()
248         return [nms["metadata"]["name"] for nms in api_response.to_dict().get("items")]
249     except (ApiException, HTTPError) as exc:
250         if isinstance(exc, ApiException) and exc.status == 404:
251             return None
252         else:
253             log.exception("Exception when calling CoreV1Api-&gt;list_namespace")
254             raise CommandExecutionError(exc)
255     finally:
256         _cleanup(**cfg)
257 def deployments(namespace="default", **kwargs):
258     cfg = _setup_conn(**kwargs)
259     try:
260         api_instance = kubernetes.client.ExtensionsV1beta1Api()
261         api_response = api_instance.list_namespaced_deployment(namespace)
262         return [dep["metadata"]["name"] for dep in api_response.to_dict().get("items")]
263     except (ApiException, HTTPError) as exc:
264         if isinstance(exc, ApiException) and exc.status == 404:
265             return None
266         else:
267             log.exception(
268                 "Exception when calling "
269                 "ExtensionsV1beta1Api-&gt;list_namespaced_deployment"
270             )
271             raise CommandExecutionError(exc)
272     finally:
273         _cleanup(**cfg)
274 def services(namespace="default", **kwargs):
275     cfg = _setup_conn(**kwargs)
276     try:
277         api_instance = kubernetes.client.CoreV1Api()
278         api_response = api_instance.list_namespaced_service(namespace)
279         return [srv["metadata"]["name"] for srv in api_response.to_dict().get("items")]
280     except (ApiException, HTTPError) as exc:
281         if isinstance(exc, ApiException) and exc.status == 404:
282             return None
283         else:
284             log.exception("Exception when calling CoreV1Api-&gt;list_namespaced_service")
285             raise CommandExecutionError(exc)
286     finally:
287         _cleanup(**cfg)
288 def pods(namespace="default", **kwargs):
289     cfg = _setup_conn(**kwargs)
290     try:
291         api_instance = kubernetes.client.CoreV1Api()
292         api_response = api_instance.list_namespaced_pod(namespace)
293         return [pod["metadata"]["name"] for pod in api_response.to_dict().get("items")]
294     except (ApiException, HTTPError) as exc:
295         if isinstance(exc, ApiException) and exc.status == 404:
296             return None
297         else:
298             log.exception("Exception when calling CoreV1Api-&gt;list_namespaced_pod")
299             raise CommandExecutionError(exc)
300     finally:
301         _cleanup(**cfg)
302 def secrets(namespace="default", **kwargs):
303     cfg = _setup_conn(**kwargs)
304     try:
305         api_instance = kubernetes.client.CoreV1Api()
306         api_response = api_instance.list_namespaced_secret(namespace)
307         return [
308             secret["metadata"]["name"] for secret in api_response.to_dict().get("items")
309         ]
310     except (ApiException, HTTPError) as exc:
311         if isinstance(exc, ApiException) and exc.status == 404:
312             return None
313         else:
314             log.exception("Exception when calling CoreV1Api-&gt;list_namespaced_secret")
315             raise CommandExecutionError(exc)
316     finally:
317         _cleanup(**cfg)
318 def configmaps(namespace="default", **kwargs):
319     cfg = _setup_conn(**kwargs)
320     try:
321         api_instance = kubernetes.client.CoreV1Api()
322         api_response = api_instance.list_namespaced_config_map(namespace)
323         return [
324             secret["metadata"]["name"] for secret in api_response.to_dict().get("items")
325         ]
326     except (ApiException, HTTPError) as exc:
327         if isinstance(exc, ApiException) and exc.status == 404:
328             return None
329         else:
330             log.exception(
331                 "Exception when calling CoreV1Api-&gt;list_namespaced_config_map"
332             )
333             raise CommandExecutionError(exc)
334     finally:
335         _cleanup(**cfg)
336 def show_deployment(name, namespace="default", **kwargs):
337     cfg = _setup_conn(**kwargs)
338     try:
339         api_instance = kubernetes.client.ExtensionsV1beta1Api()
340         api_response = api_instance.read_namespaced_deployment(name, namespace)
341         return api_response.to_dict()
342     except (ApiException, HTTPError) as exc:
343         if isinstance(exc, ApiException) and exc.status == 404:
344             return None
345         else:
346             log.exception(
347                 "Exception when calling "
348                 "ExtensionsV1beta1Api-&gt;read_namespaced_deployment"
349             )
350             raise CommandExecutionError(exc)
351     finally:
352         _cleanup(**cfg)
353 def show_service(name, namespace="default", **kwargs):
354     cfg = _setup_conn(**kwargs)
355     try:
356         api_instance = kubernetes.client.CoreV1Api()
357         api_response = api_instance.read_namespaced_service(name, namespace)
358         return api_response.to_dict()
359     except (ApiException, HTTPError) as exc:
360         if isinstance(exc, ApiException) and exc.status == 404:
361             return None
362         else:
363             log.exception("Exception when calling CoreV1Api-&gt;read_namespaced_service")
364             raise CommandExecutionError(exc)
365     finally:
366         _cleanup(**cfg)
367 def show_pod(name, namespace="default", **kwargs):
368     cfg = _setup_conn(**kwargs)
369     try:
370         api_instance = kubernetes.client.CoreV1Api()
371         api_response = api_instance.read_namespaced_pod(name, namespace)
372         return api_response.to_dict()
373     except (ApiException, HTTPError) as exc:
374         if isinstance(exc, ApiException) and exc.status == 404:
375             return None
376         else:
377             log.exception("Exception when calling CoreV1Api-&gt;read_namespaced_pod")
378             raise CommandExecutionError(exc)
379     finally:
380         _cleanup(**cfg)
381 def show_namespace(name, **kwargs):
382     cfg = _setup_conn(**kwargs)
383     try:
384         api_instance = kubernetes.client.CoreV1Api()
385         api_response = api_instance.read_namespace(name)
386         return api_response.to_dict()
387     except (ApiException, HTTPError) as exc:
388         if isinstance(exc, ApiException) and exc.status == 404:
389             return None
390         else:
391             log.exception("Exception when calling CoreV1Api-&gt;read_namespace")
392             raise CommandExecutionError(exc)
393     finally:
394         _cleanup(**cfg)
395 def show_secret(name, namespace="default", decode=False, **kwargs):
396     cfg = _setup_conn(**kwargs)
397     try:
398         api_instance = kubernetes.client.CoreV1Api()
399         api_response = api_instance.read_namespaced_secret(name, namespace)
400         if api_response.data and (decode or decode == "True"):
401             for key in api_response.data:
402                 value = api_response.data[key]
403                 api_response.data[key] = base64.b64decode(value)
404         return api_response.to_dict()
405     except (ApiException, HTTPError) as exc:
406         if isinstance(exc, ApiException) and exc.status == 404:
407             return None
408         else:
409             log.exception("Exception when calling CoreV1Api-&gt;read_namespaced_secret")
410             raise CommandExecutionError(exc)
411     finally:
412         _cleanup(**cfg)
413 def show_configmap(name, namespace="default", **kwargs):
414     cfg = _setup_conn(**kwargs)
415     try:
416         api_instance = kubernetes.client.CoreV1Api()
417         api_response = api_instance.read_namespaced_config_map(name, namespace)
418         return api_response.to_dict()
419     except (ApiException, HTTPError) as exc:
420         if isinstance(exc, ApiException) and exc.status == 404:
421             return None
422         else:
423             log.exception(
424                 "Exception when calling CoreV1Api-&gt;read_namespaced_config_map"
425             )
426             raise CommandExecutionError(exc)
427     finally:
428         _cleanup(**cfg)
429 def delete_deployment(name, namespace="default", **kwargs):
430     cfg = _setup_conn(**kwargs)
431     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
432     try:
433         api_instance = kubernetes.client.ExtensionsV1beta1Api()
434         api_response = api_instance.delete_namespaced_deployment(
435             name=name, namespace=namespace, body=body
436         )
437         mutable_api_response = api_response.to_dict()
438         if not salt.utils.platform.is_windows():
439             try:
440                 with _time_limit(POLLING_TIME_LIMIT):
441                     while show_deployment(name, namespace) is not None:
442                         time.sleep(1)
443                     else:  # pylint: disable=useless-else-on-loop
444                         mutable_api_response["code"] = 200
445             except TimeoutError:
446                 pass
447         else:
448             for i in range(60):
449                 if show_deployment(name, namespace) is None:
450                     mutable_api_response["code"] = 200
451                     break
452                 else:
453                     time.sleep(1)
454         if mutable_api_response["code"] != 200:
455             log.warning(
456                 "Reached polling time limit. Deployment is not yet "
457                 "deleted, but we are backing off. Sorry, but you'll "
458                 "have to check manually."
459             )
460         return mutable_api_response
461     except (ApiException, HTTPError) as exc:
462         if isinstance(exc, ApiException) and exc.status == 404:
463             return None
464         else:
465             log.exception(
466                 "Exception when calling "
467                 "ExtensionsV1beta1Api-&gt;delete_namespaced_deployment"
468             )
469             raise CommandExecutionError(exc)
470     finally:
471         _cleanup(**cfg)
472 def delete_service(name, namespace="default", **kwargs):
473     cfg = _setup_conn(**kwargs)
474     try:
475         api_instance = kubernetes.client.CoreV1Api()
476         api_response = api_instance.delete_namespaced_service(
477             name=name, namespace=namespace
478         )
479         return api_response.to_dict()
480     except (ApiException, HTTPError) as exc:
481         if isinstance(exc, ApiException) and exc.status == 404:
482             return None
483         else:
484             log.exception("Exception when calling CoreV1Api-&gt;delete_namespaced_service")
485             raise CommandExecutionError(exc)
486     finally:
487         _cleanup(**cfg)
488 def delete_pod(name, namespace="default", **kwargs):
489     cfg = _setup_conn(**kwargs)
490     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
491     try:
492         api_instance = kubernetes.client.CoreV1Api()
493         api_response = api_instance.delete_namespaced_pod(
494             name=name, namespace=namespace, body=body
495         )
496         return api_response.to_dict()
497     except (ApiException, HTTPError) as exc:
498         if isinstance(exc, ApiException) and exc.status == 404:
499             return None
500         else:
501             log.exception("Exception when calling CoreV1Api-&gt;delete_namespaced_pod")
502             raise CommandExecutionError(exc)
503     finally:
504         _cleanup(**cfg)
505 def delete_namespace(name, **kwargs):
506     cfg = _setup_conn(**kwargs)
507     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
508     try:
509         api_instance = kubernetes.client.CoreV1Api()
510         api_response = api_instance.delete_namespace(name=name, body=body)
511         return api_response.to_dict()
512     except (ApiException, HTTPError) as exc:
513         if isinstance(exc, ApiException) and exc.status == 404:
514             return None
515         else:
516             log.exception("Exception when calling CoreV1Api-&gt;delete_namespace")
517             raise CommandExecutionError(exc)
518     finally:
519         _cleanup(**cfg)
520 def delete_secret(name, namespace="default", **kwargs):
521     cfg = _setup_conn(**kwargs)
522     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
523     try:
524         api_instance = kubernetes.client.CoreV1Api()
525         api_response = api_instance.delete_namespaced_secret(
526             name=name, namespace=namespace, body=body
527         )
528         return api_response.to_dict()
529     except (ApiException, HTTPError) as exc:
530         if isinstance(exc, ApiException) and exc.status == 404:
531             return None
532         else:
533             log.exception("Exception when calling CoreV1Api-&gt;delete_namespaced_secret")
534             raise CommandExecutionError(exc)
535     finally:
536         _cleanup(**cfg)
537 def delete_configmap(name, namespace="default", **kwargs):
538     cfg = _setup_conn(**kwargs)
539     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
540     try:
541         api_instance = kubernetes.client.CoreV1Api()
542         api_response = api_instance.delete_namespaced_config_map(
543             name=name, namespace=namespace, body=body
544         )
545         return api_response.to_dict()
546     except (ApiException, HTTPError) as exc:
547         if isinstance(exc, ApiException) and exc.status == 404:
548             return None
549         else:
550             log.exception(
551                 "Exception when calling CoreV1Api-&gt;delete_namespaced_config_map"
552             )
553             raise CommandExecutionError(exc)
554     finally:
555         _cleanup(**cfg)
556 def create_deployment(
557     name, namespace, metadata, spec, source, template, saltenv, **kwargs
558 ):
559     body = __create_object_body(
560         kind="Deployment",
561         obj_class=AppsV1beta1Deployment,
562         spec_creator=__dict_to_deployment_spec,
563         name=name,
564         namespace=namespace,
565         metadata=metadata,
566         spec=spec,
567         source=source,
568         template=template,
569         saltenv=saltenv,
570     )
571     cfg = _setup_conn(**kwargs)
572     try:
573         api_instance = kubernetes.client.ExtensionsV1beta1Api()
574         api_response = api_instance.create_namespaced_deployment(namespace, body)
575         return api_response.to_dict()
576     except (ApiException, HTTPError) as exc:
577         if isinstance(exc, ApiException) and exc.status == 404:
578             return None
579         else:
580             log.exception(
581                 "Exception when calling "
582                 "ExtensionsV1beta1Api-&gt;create_namespaced_deployment"
583             )
584             raise CommandExecutionError(exc)
585     finally:
586         _cleanup(**cfg)
587 def create_pod(name, namespace, metadata, spec, source, template, saltenv, **kwargs):
588     body = __create_object_body(
589         kind="Pod",
590         obj_class=kubernetes.client.V1Pod,
591         spec_creator=__dict_to_pod_spec,
592         name=name,
593         namespace=namespace,
594         metadata=metadata,
595         spec=spec,
596         source=source,
597         template=template,
598         saltenv=saltenv,
599     )
600     cfg = _setup_conn(**kwargs)
601     try:
602         api_instance = kubernetes.client.CoreV1Api()
603         api_response = api_instance.create_namespaced_pod(namespace, body)
604         return api_response.to_dict()
605     except (ApiException, HTTPError) as exc:
606         if isinstance(exc, ApiException) and exc.status == 404:
607             return None
608         else:
609             log.exception("Exception when calling CoreV1Api-&gt;create_namespaced_pod")
610             raise CommandExecutionError(exc)
611     finally:
612         _cleanup(**cfg)
613 def create_service(
614     name, namespace, metadata, spec, source, template, saltenv, **kwargs
615 ):
616     body = __create_object_body(
617         kind="Service",
618         obj_class=kubernetes.client.V1Service,
619         spec_creator=__dict_to_service_spec,
620         name=name,
621         namespace=namespace,
622         metadata=metadata,
623         spec=spec,
624         source=source,
625         template=template,
626         saltenv=saltenv,
627     )
628     cfg = _setup_conn(**kwargs)
629     try:
630         api_instance = kubernetes.client.CoreV1Api()
631         api_response = api_instance.create_namespaced_service(namespace, body)
632         return api_response.to_dict()
633     except (ApiException, HTTPError) as exc:
634         if isinstance(exc, ApiException) and exc.status == 404:
635             return None
636         else:
637             log.exception("Exception when calling CoreV1Api-&gt;create_namespaced_service")
638             raise CommandExecutionError(exc)
639     finally:
640         _cleanup(**cfg)
641 def create_secret(
642     name,
643     namespace="default",
644     data=None,
645     source=None,
646     template=None,
647     saltenv="base",
648     **kwargs
649 ):
650     if source:
651         data = __read_and_render_yaml_file(source, template, saltenv)
652     elif data is None:
653         data = {}
654     data = __enforce_only_strings_dict(data)
655     for key in data:
656         data[key] = base64.b64encode(data[key])
657     body = kubernetes.client.V1Secret(
658         metadata=__dict_to_object_meta(name, namespace, {}), data=data
659     )
660     cfg = _setup_conn(**kwargs)
661     try:
662         api_instance = kubernetes.client.CoreV1Api()
663         api_response = api_instance.create_namespaced_secret(namespace, body)
664         return api_response.to_dict()
665     except (ApiException, HTTPError) as exc:
666         if isinstance(exc, ApiException) and exc.status == 404:
667             return None
668         else:
669             log.exception("Exception when calling CoreV1Api-&gt;create_namespaced_secret")
670             raise CommandExecutionError(exc)
671     finally:
672         _cleanup(**cfg)
673 def create_configmap(
674     name, namespace, data, source=None, template=None, saltenv="base", **kwargs
675 ):
676     if source:
677         data = __read_and_render_yaml_file(source, template, saltenv)
678     elif data is None:
679         data = {}
680     data = __enforce_only_strings_dict(data)
681     body = kubernetes.client.V1ConfigMap(
682         metadata=__dict_to_object_meta(name, namespace, {}), data=data
683     )
684     cfg = _setup_conn(**kwargs)
685     try:
686         api_instance = kubernetes.client.CoreV1Api()
687         api_response = api_instance.create_namespaced_config_map(namespace, body)
688         return api_response.to_dict()
689     except (ApiException, HTTPError) as exc:
690         if isinstance(exc, ApiException) and exc.status == 404:
691             return None
692         else:
693             log.exception(
694                 "Exception when calling CoreV1Api-&gt;create_namespaced_config_map"
695             )
696             raise CommandExecutionError(exc)
697     finally:
698         _cleanup(**cfg)
699 def create_namespace(name, **kwargs):
700     meta_obj = kubernetes.client.V1ObjectMeta(name=name)
701     body = kubernetes.client.V1Namespace(metadata=meta_obj)
702     body.metadata.name = name
703     cfg = _setup_conn(**kwargs)
704     try:
705         api_instance = kubernetes.client.CoreV1Api()
706         api_response = api_instance.create_namespace(body)
707         return api_response.to_dict()
708     except (ApiException, HTTPError) as exc:
709         if isinstance(exc, ApiException) and exc.status == 404:
710             return None
711         else:
712             log.exception("Exception when calling CoreV1Api-&gt;create_namespace")
713             raise CommandExecutionError(exc)
714     finally:
715         _cleanup(**cfg)
716 def replace_deployment(
717     name, metadata, spec, source, template, saltenv, namespace="default", **kwargs
718 ):
719     body = __create_object_body(
720         kind="Deployment",
721         obj_class=AppsV1beta1Deployment,
722         spec_creator=__dict_to_deployment_spec,
723         name=name,
724         namespace=namespace,
725         metadata=metadata,
726         spec=spec,
727         source=source,
728         template=template,
729         saltenv=saltenv,
730     )
731     cfg = _setup_conn(**kwargs)
732     try:
733         api_instance = kubernetes.client.ExtensionsV1beta1Api()
734         api_response = api_instance.replace_namespaced_deployment(name, namespace, body)
735         return api_response.to_dict()
736     except (ApiException, HTTPError) as exc:
737         if isinstance(exc, ApiException) and exc.status == 404:
738             return None
739         else:
740             log.exception(
741                 "Exception when calling "
742                 "ExtensionsV1beta1Api-&gt;replace_namespaced_deployment"
743             )
744             raise CommandExecutionError(exc)
745     finally:
746         _cleanup(**cfg)
747 def replace_service(
748     name,
749     metadata,
750     spec,
751     source,
752     template,
753     old_service,
754     saltenv,
755     namespace="default",
756     **kwargs
757 ):
758     body = __create_object_body(
759         kind="Service",
760         obj_class=kubernetes.client.V1Service,
761         spec_creator=__dict_to_service_spec,
762         name=name,
763         namespace=namespace,
764         metadata=metadata,
765         spec=spec,
766         source=source,
767         template=template,
768         saltenv=saltenv,
769     )
770     body.spec.cluster_ip = old_service["spec"]["cluster_ip"]
771     body.metadata.resource_version = old_service["metadata"]["resource_version"]
772     cfg = _setup_conn(**kwargs)
773     try:
774         api_instance = kubernetes.client.CoreV1Api()
775         api_response = api_instance.replace_namespaced_service(name, namespace, body)
776         return api_response.to_dict()
777     except (ApiException, HTTPError) as exc:
778         if isinstance(exc, ApiException) and exc.status == 404:
779             return None
780         else:
781             log.exception(
782                 "Exception when calling CoreV1Api-&gt;replace_namespaced_service"
783             )
784             raise CommandExecutionError(exc)
785     finally:
786         _cleanup(**cfg)
787 def replace_secret(
788     name,
789     data,
790     source=None,
791     template=None,
792     saltenv="base",
793     namespace="default",
794     **kwargs
795 ):
796     if source:
797         data = __read_and_render_yaml_file(source, template, saltenv)
798     elif data is None:
799         data = {}
800     data = __enforce_only_strings_dict(data)
801     for key in data:
802         data[key] = base64.b64encode(data[key])
803     body = kubernetes.client.V1Secret(
804         metadata=__dict_to_object_meta(name, namespace, {}), data=data
805     )
806     cfg = _setup_conn(**kwargs)
807     try:
808         api_instance = kubernetes.client.CoreV1Api()
809         api_response = api_instance.replace_namespaced_secret(name, namespace, body)
810         return api_response.to_dict()
811     except (ApiException, HTTPError) as exc:
812         if isinstance(exc, ApiException) and exc.status == 404:
813             return None
814         else:
815             log.exception("Exception when calling CoreV1Api-&gt;replace_namespaced_secret")
816             raise CommandExecutionError(exc)
817     finally:
818         _cleanup(**cfg)
819 def replace_configmap(
820     name,
821     data,
822     source=None,
823     template=None,
824     saltenv="base",
825     namespace="default",
826     **kwargs
827 ):
828     if source:
829         data = __read_and_render_yaml_file(source, template, saltenv)
830     data = __enforce_only_strings_dict(data)
831     body = kubernetes.client.V1ConfigMap(
832         metadata=__dict_to_object_meta(name, namespace, {}), data=data
833     )
834     cfg = _setup_conn(**kwargs)
835     try:
836         api_instance = kubernetes.client.CoreV1Api()
837         api_response = api_instance.replace_namespaced_config_map(name, namespace, body)
838         return api_response.to_dict()
839     except (ApiException, HTTPError) as exc:
840         if isinstance(exc, ApiException) and exc.status == 404:
841             return None
842         else:
843             log.exception(
844                 "Exception when calling CoreV1Api-&gt;replace_namespaced_configmap"
845             )
846             raise CommandExecutionError(exc)
847     finally:
848         _cleanup(**cfg)
849 def __create_object_body(
850     kind,
851     obj_class,
852     spec_creator,
853     name,
854     namespace,
855     metadata,
856     spec,
857     source,
858     template,
859     saltenv,
860 ):
861     if source:
862         src_obj = __read_and_render_yaml_file(source, template, saltenv)
863         if (
864             not isinstance(src_obj, dict)
865             or "kind" not in src_obj
866             or src_obj["kind"] != kind
867         ):
868             raise CommandExecutionError(
869                 "The source file should define only a {} object".format(kind)
870             )
871         if "metadata" in src_obj:
872             metadata = src_obj["metadata"]
873         if "spec" in src_obj:
874             spec = src_obj["spec"]
875     return obj_class(
876         metadata=__dict_to_object_meta(name, namespace, metadata),
877         spec=spec_creator(spec),
878     )
879 def __read_and_render_yaml_file(source, template, saltenv):
880     sfn = __salt__["cp.cache_file"](source, saltenv)
881     if not sfn:
882         raise CommandExecutionError("Source file '{}' not found".format(source))
883     with salt.utils.files.fopen(sfn, "r") as src:
884         contents = src.read()
885         if template:
886             if template in salt.utils.templates.TEMPLATE_REGISTRY:
887                 data = salt.utils.templates.TEMPLATE_REGISTRY[template](
888                     contents,
889                     from_str=True,
890                     to_str=True,
891                     saltenv=saltenv,
892                     grains=__grains__,
893                     pillar=__pillar__,
894                     salt=__salt__,
895                     opts=__opts__,
896                 )
897                 if not data["result"]:
898                     raise CommandExecutionError(
899                         "Failed to render file path with error: {}".format(data["data"])
900                     )
901                 contents = data["data"].encode("utf-8")
902             else:
903                 raise CommandExecutionError(
904                     "Unknown template specified: {}".format(template)
905                 )
906         return salt.utils.yaml.safe_load(contents)
907 def __dict_to_object_meta(name, namespace, metadata):
908     meta_obj = kubernetes.client.V1ObjectMeta()
909     meta_obj.namespace = namespace
910     if "annotations" not in metadata:
911         metadata["annotations"] = {}
912     if "kubernetes.io/change-cause" not in metadata["annotations"]:
913         metadata["annotations"]["kubernetes.io/change-cause"] = " ".join(sys.argv)
914     for key, value in metadata.items():
915         if hasattr(meta_obj, key):
916             setattr(meta_obj, key, value)
917     if meta_obj.name != name:
918         log.warning(
919             "The object already has a name attribute, overwriting it with "
920             "the one defined inside of salt"
921         )
922         meta_obj.name = name
923     return meta_obj
924 def __dict_to_deployment_spec(spec):
925     spec_obj = AppsV1beta1DeploymentSpec(template=spec.get("template", ""))
926     for key, value in spec.items():
927         if hasattr(spec_obj, key):
928             setattr(spec_obj, key, value)
929     return spec_obj
930 def __dict_to_pod_spec(spec):
931     spec_obj = kubernetes.client.V1PodSpec()
932     for key, value in spec.items():
933         if hasattr(spec_obj, key):
934             setattr(spec_obj, key, value)
935     return spec_obj
936 def __dict_to_service_spec(spec):
937     spec_obj = kubernetes.client.V1ServiceSpec()
938     for key, value in spec.items():  # pylint: disable=too-many-nested-blocks
939         if key == "ports":
940             spec_obj.ports = []
941             for port in value:
942                 kube_port = kubernetes.client.V1ServicePort()
943                 if isinstance(port, dict):
944                     for port_key, port_value in port.items():
945                         if hasattr(kube_port, port_key):
946                             setattr(kube_port, port_key, port_value)
947                 else:
948                     kube_port.port = port
949                 spec_obj.ports.append(kube_port)
950         elif hasattr(spec_obj, key):
951             setattr(spec_obj, key, value)
952     return spec_obj
953 def __enforce_only_strings_dict(dictionary):
954     ret = {}
955     for key, value in dictionary.items():
956         ret[str(key)] = str(value)
957     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
