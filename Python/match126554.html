<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for local_cache.py &amp; kubernetesmod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for local_cache.py &amp; kubernetesmod.py
      </h3>
<h1 align="center">
        2.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>local_cache.py (4.288939%)<th>kubernetesmod.py (2.0518358%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(6-20)<td><a href="#" name="0">(46-60)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(463-464)<td><a href="#" name="1">(243-246)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(112-113)<td><a href="#" name="2">(237-240)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>local_cache.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import bisect
2 import errno
3 import glob
4 import logging
5 import os
6 import shutil
7 import time
8 import salt.exceptions
9 import salt.payload
10 import salt.utils.atomicfile
11 import salt.utils.files
12 import salt.utils.jid
13 import salt.utils.minions
14 import</b></font> salt.utils.msgpack
15 import salt.utils.stringutils
16 log = logging.getLogger(__name__)
17 LOAD_P = ".load.p"
18 MINIONS_P = ".minions.p"
19 SYNDIC_MINIONS_P = ".minions.{0}.p"
20 RETURN_P = "return.p"
21 OUT_P = "out.p"
22 ENDTIME = "endtime"
23 def _job_dir():
24     return os.path.join(__opts__["cachedir"], "jobs")
25 def _walk_through(job_dir):
26     for top in os.listdir(job_dir):
27         t_path = os.path.join(job_dir, top)
28         if not os.path.exists(t_path):
29             continue
30         for final in os.listdir(t_path):
31             load_path = os.path.join(t_path, final, LOAD_P)
32             if not os.path.isfile(load_path):
33                 continue
34             with salt.utils.files.fopen(load_path, "rb") as rfh:
35                 try:
36                     job = salt.payload.load(rfh)
37                 except Exception:  # pylint: disable=broad-except
38                     log.exception("Failed to deserialize %s", load_path)
39                     continue
40                 if not job:
41                     log.error(
42                         "Deserialization of job succeded but there is no data in %s",
43                         load_path,
44                     )
45                     continue
46                 jid = job["jid"]
47                 yield jid, job, t_path, final
48 def prep_jid(nocache=False, passed_jid=None, recurse_count=0):
49     if recurse_count &gt;= 5:
50         err = "prep_jid could not store a jid after {} tries.".format(recurse_count)
51         log.error(err)
52         raise salt.exceptions.SaltCacheError(err)
53     if passed_jid is None:  # this can be a None or an empty string.
54         jid = salt.utils.jid.gen_jid(__opts__)
55     else:
56         jid = passed_jid
57     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
58     if not os.path.isdir(jid_dir):
59         try:
60             os.makedirs(jid_dir)
61         except OSError:
62             time.sleep(0.1)
63             if passed_jid is None:
64 <a name="2"></a>                return prep_jid(nocache=nocache, recurse_count=recurse_count + 1)
65     try:
66         with salt.utils<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.files.fopen(os.path.join(jid_dir, "jid"), "wb+") as fn_:
67             fn_.write(salt.utils.stringutils.to_bytes(</b></font>jid))
68         if nocache:
69             with salt.utils.files.fopen(os.path.join(jid_dir, "nocache"), "wb+"):
70                 pass
71     except OSError:
72         log.warning("Could not write out jid file for job %s. Retrying.", jid)
73         time.sleep(0.1)
74         return prep_jid(
75             passed_jid=jid, nocache=nocache, recurse_count=recurse_count + 1
76         )
77     return jid
78 def returner(load):
79     if load["jid"] == "req":
80         load["jid"] = prep_jid(nocache=load.get("nocache", False))
81     jid_dir = salt.utils.jid.jid_dir(load["jid"], _job_dir(), __opts__["hash_type"])
82     if os.path.exists(os.path.join(jid_dir, "nocache")):
83         return
84     hn_dir = os.path.join(jid_dir, load["id"])
85     try:
86         os.makedirs(hn_dir)
87     except OSError as err:
88         if err.errno == errno.EEXIST:
89             log.error(
90                 "An extra return was detected from minion %s, please verify "
91                 "the minion, this could be a replay attack",
92                 load["id"],
93             )
94             return False
95         elif err.errno == errno.ENOENT:
96             log.error(
97                 "An inconsistency occurred, a job was received with a job id "
98                 "(%s) that is not present in the local cache",
99                 load["jid"],
100             )
101             return False
102         raise
103     salt.payload.dump(
104         {key: load[key] for key in ["return", "retcode", "success"] if key in load},
105         salt.utils.atomicfile.atomic_open(os.path.join(hn_dir, RETURN_P), "w+b"),
106     )
107     if "out" in load:
108         salt.payload.dump(
109             load["out"],
110             salt.utils.atomicfile.atomic_open(os.path.join(hn_dir, OUT_P), "w+b"),
111         )
112 def save_load(jid, clear_load, minions=None, recurse_count=0):
113     if recurse_count &gt;= 5:
114         err = "save_load could not write job cache file after {} retries.".format(
115             recurse_count
116         )
117         log.error(err)
118         raise salt.exceptions.SaltCacheError(err)
119     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
120     try:
121         if not os.path.exists(jid_dir):
122             os.makedirs(jid_dir)
123     except OSError as exc:
124         if exc.errno == errno.EEXIST:
125             pass
126         else:
127             raise
128     try:
129         with salt.utils.files.fopen(os.path.join(jid_dir, LOAD_P), "w+b") as wfh:
130             salt.payload.dump(clear_load, wfh)
131     except OSError as exc:
132         log.warning("Could not write job invocation cache file: %s", exc)
133         time.sleep(0.1)
134         return save_load(
135             jid=jid, clear_load=clear_load, recurse_count=recurse_count + 1
136         )
137     if "tgt" in clear_load and clear_load["tgt"] != "":
138         if minions is None:
139             ckminions = salt.utils.minions.CkMinions(__opts__)
140             _res = ckminions.check_minions(
141                 clear_load["tgt"], clear_load.get("tgt_type", "glob")
142             )
143             minions = _res["minions"]
144         save_minions(jid, minions)
145 def save_minions(jid, minions, syndic_id=None):
146     minions = list(minions)
147     log.debug(
148         "Adding minions for job %s%s: %s",
149         jid,
150         " from syndic master '{}'".format(syndic_id) if syndic_id else "",
151         minions,
152     )
153     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
154     try:
155         if not os.path.exists(jid_dir):
156             os.makedirs(jid_dir)
157     except OSError as exc:
158         if exc.errno == errno.EEXIST:
159             pass
160         else:
161             raise
162     if syndic_id is not None:
163         minions_path = os.path.join(jid_dir, SYNDIC_MINIONS_P.format(syndic_id))
164     else:
165         minions_path = os.path.join(jid_dir, MINIONS_P)
166     try:
167         if not os.path.exists(jid_dir):
168             try:
169                 os.makedirs(jid_dir)
170             except OSError:
171                 pass
172         with salt.utils.files.fopen(minions_path, "w+b") as wfh:
173             salt.payload.dump(minions, wfh)
174     except OSError as exc:
175         log.error(
176             "Failed to write minion list %s to job cache file %s: %s",
177             minions,
178             minions_path,
179             exc,
180         )
181 def get_load(jid):
182     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
183     load_fn = os.path.join(jid_dir, LOAD_P)
184     if not os.path.exists(jid_dir) or not os.path.exists(load_fn):
185         return {}
186     ret = {}
187     load_p = os.path.join(jid_dir, LOAD_P)
188     num_tries = 5
189     for index in range(1, num_tries + 1):
190         with salt.utils.files.fopen(load_p, "rb") as rfh:
191             try:
192                 ret = salt.payload.load(rfh)
193                 break
194             except Exception as exc:  # pylint: disable=broad-except
195                 if index == num_tries:
196                     time.sleep(0.25)
197     else:
198         log.critical("Failed to unpack %s", load_p)
199         raise exc
200     if ret is None:
201         ret = {}
202     minions_cache = [os.path.join(jid_dir, MINIONS_P)]
203     minions_cache.extend(glob.glob(os.path.join(jid_dir, SYNDIC_MINIONS_P.format("*"))))
204     all_minions = set()
205     for minions_path in minions_cache:
206         log.debug("Reading minion list from %s", minions_path)
207         try:
208             with salt.utils.files.fopen(minions_path, "rb") as rfh:
209                 all_minions.update(salt.payload.load(rfh))
210         except OSError as exc:
211             salt.utils.files.process_read_exception(exc, minions_path)
212     if all_minions:
213         ret["Minions"] = sorted(all_minions)
214     return ret
215 def get_jid(jid):
216     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
217     ret = {}
218     if not os.path.isdir(jid_dir):
219         return ret
220     for fn_ in os.listdir(jid_dir):
221         if fn_.startswith("."):
222             continue
223         if fn_ not in ret:
224             retp = os.path.join(jid_dir, fn_, RETURN_P)
225             outp = os.path.join(jid_dir, fn_, OUT_P)
226             if not os.path.isfile(retp):
227                 continue
228             while fn_ not in ret:
229                 try:
230                     with salt.utils.files.fopen(retp, "rb") as rfh:
231                         ret_data = salt.payload.load(rfh)
232                     if not isinstance(ret_data, dict) or "return" not in ret_data:
233                         ret_data = {"return": ret_data}
234                     ret[fn_] = ret_data
235                     if os.path.isfile(outp):
236                         with salt.utils.files.fopen(outp, "rb") as rfh:
237                             ret[fn_]["out"] = salt.payload.load(rfh)
238                 except Exception as exc:  # pylint: disable=broad-except
239                     if "Permission denied:" in str(exc):
240                         raise
241     return ret
242 def get_jids():
243     ret = {}
244     for jid, job, _, _ in _walk_through(_job_dir()):
245         ret[jid] = salt.utils.jid.format_jid_instance(jid, job)
246         if __opts__.get("job_cache_store_endtime"):
247             endtime = get_endtime(jid)
248             if endtime:
249                 ret[jid]["EndTime"] = endtime
250     return ret
251 def get_jids_filter(count, filter_find_job=True):
252     keys = []
253     ret = []
254     for jid, job, _, _ in _walk_through(_job_dir()):
255         job = salt.utils.jid.format_jid_instance_ext(jid, job)
256         if filter_find_job and job["Function"] == "saltutil.find_job":
257             continue
258         i = bisect.bisect(keys, jid)
259         if len(keys) == count and i == 0:
260             continue
261         keys.insert(i, jid)
262         ret.insert(i, job)
263         if len(keys) &gt; count:
264             del keys[0]
265             del ret[0]
266     return ret
267 def clean_old_jobs():
268     if __opts__["keep_jobs"] != 0:
269         jid_root = _job_dir()
270         if not os.path.exists(jid_root):
271             return
272         dirs_to_remove = set()
273         for top in os.listdir(jid_root):
274             t_path = os.path.join(jid_root, top)
275             if not os.path.exists(t_path):
276                 continue
277             t_path_dirs = os.listdir(t_path)
278             if not t_path_dirs and t_path not in dirs_to_remove:
279                 dirs_to_remove.add(t_path)
280                 continue
281             for final in t_path_dirs:
282                 f_path = os.path.join(t_path, final)
283                 jid_file = os.path.join(f_path, "jid")
284                 if not os.path.isfile(jid_file) and os.path.exists(f_path):
285                     shutil.rmtree(f_path)
286                 elif os.path.isfile(jid_file):
287                     jid_ctime = os.stat(jid_file).st_ctime
288                     hours_difference = (time.time() - jid_ctime) / 3600.0
289                     if hours_difference &gt; __opts__["keep_jobs"] and os.path.exists(
290                         t_path
291                     ):
292                         try:
293                             shutil.rmtree(f_path)
294                         except OSError as err:
295                             log.error("Unable to remove %s: %s", f_path, err)
296         if dirs_to_remove:
297             for t_path in dirs_to_remove:
298                 t_path_ctime = os.stat(t_path).st_ctime
299                 hours_difference = (time.time() - t_path_ctime) / 3600.0
300                 if hours_difference &gt; __opts__["keep_jobs"]:
301                     shutil.rmtree(t_path)
302 def update_endtime(jid, time):
303     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
304 <a name="1"></a>    try:
305         if not os.path.exists(jid_dir):
306             os.makedirs(jid_dir)
307         with salt.utils<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.files.fopen(os.path.join(jid_dir, ENDTIME), "w") as etfile:
308             etfile.write(salt.utils.stringutils.to_str(</b></font>time))
309     except OSError as exc:
310         log.warning("Could not write job invocation cache file: %s", exc)
311 def get_endtime(jid):
312     jid_dir = salt.utils.jid.jid_dir(jid, _job_dir(), __opts__["hash_type"])
313     etpath = os.path.join(jid_dir, ENDTIME)
314     if not os.path.exists(etpath):
315         return False
316     with salt.utils.files.fopen(etpath, "r") as etfile:
317         endtime = salt.utils.stringutils.to_unicode(etfile.read()).strip("\n")
318     return endtime
319 def _reg_dir():
320     return os.path.join(__opts__["cachedir"], "thorium")
321 def save_reg(data):
322     reg_dir = _reg_dir()
323     regfile = os.path.join(reg_dir, "register")
324     try:
325         if not os.path.exists(reg_dir):
326             os.makedirs(reg_dir)
327     except OSError as exc:
328         if exc.errno == errno.EEXIST:
329             pass
330         else:
331             raise
332     try:
333         with salt.utils.files.fopen(regfile, "a") as fh_:
334             salt.utils.msgpack.dump(data, fh_)
335     except Exception:  # pylint: disable=broad-except
336         log.error("Could not write to msgpack file %s", __opts__["outdir"])
337         raise
338 def load_reg():
339     reg_dir = _reg_dir()
340     regfile = os.path.join(reg_dir, "register")
341     try:
342         with salt.utils.files.fopen(regfile, "r") as fh_:
343             return salt.utils.msgpack.load(fh_)
344     except Exception:  # pylint: disable=broad-except
345         log.error("Could not write to msgpack file %s", __opts__["outdir"])
346         raise
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>kubernetesmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import base64
2 import errno
3 import logging
4 import os.path
5 import signal
6 import sys
7 import tempfile
8 import time
9 from contextlib import contextmanager
10 import salt.utils.files
11 import salt.utils.platform
12 import salt.utils.templates
13 import salt.utils.yaml
14 from</b></font> salt.exceptions import CommandExecutionError, TimeoutError
15 try:
16     import kubernetes  # pylint: disable=import-self
17     import kubernetes.client
18     from kubernetes.client.rest import ApiException
19     from urllib3.exceptions import HTTPError
20     try:
21         from kubernetes.client import V1beta1Deployment as AppsV1beta1Deployment
22         from kubernetes.client import V1beta1DeploymentSpec as AppsV1beta1DeploymentSpec
23     except ImportError:
24         from kubernetes.client import AppsV1beta1Deployment
25         from kubernetes.client import AppsV1beta1DeploymentSpec
26     HAS_LIBS = True
27 except ImportError:
28     HAS_LIBS = False
29 log = logging.getLogger(__name__)
30 __virtualname__ = "kubernetes"
31 def __virtual__():
32     if HAS_LIBS:
33         return __virtualname__
34     return False, "python kubernetes library not found"
35 if not salt.utils.platform.is_windows():
36     @contextmanager
37     def _time_limit(seconds):
38         def signal_handler(signum, frame):
39             raise TimeoutError
40         signal.signal(signal.SIGALRM, signal_handler)
41         signal.alarm(seconds)
42         try:
43             yield
44         finally:
45             signal.alarm(0)
46     POLLING_TIME_LIMIT = 30
47 def _setup_conn_old(**kwargs):
48     host = __salt__["config.option"]("kubernetes.api_url", "http://localhost:8080")
49     username = __salt__["config.option"]("kubernetes.user")
50     password = __salt__["config.option"]("kubernetes.password")
51     ca_cert = __salt__["config.option"]("kubernetes.certificate-authority-data")
52     client_cert = __salt__["config.option"]("kubernetes.client-certificate-data")
53     client_key = __salt__["config.option"]("kubernetes.client-key-data")
54     ca_cert_file = __salt__["config.option"]("kubernetes.certificate-authority-file")
55     client_cert_file = __salt__["config.option"]("kubernetes.client-certificate-file")
56     client_key_file = __salt__["config.option"]("kubernetes.client-key-file")
57     if "api_url" in kwargs:
58         host = kwargs.get("api_url")
59     if "api_user" in kwargs:
60         username = kwargs.get("api_user")
61     if "api_password" in kwargs:
62         password = kwargs.get("api_password")
63     if "api_certificate_authority_file" in kwargs:
64         ca_cert_file = kwargs.get("api_certificate_authority_file")
65     if "api_client_certificate_file" in kwargs:
66         client_cert_file = kwargs.get("api_client_certificate_file")
67     if "api_client_key_file" in kwargs:
68         client_key_file = kwargs.get("api_client_key_file")
69     if (
70         kubernetes.client.configuration.host != host
71         or kubernetes.client.configuration.user != username
72         or kubernetes.client.configuration.password != password
73     ):
74         kubernetes.client.configuration.__init__()
75     kubernetes.client.configuration.host = host
76     kubernetes.client.configuration.user = username
77     kubernetes.client.configuration.passwd = password
78     if ca_cert_file:
79         kubernetes.client.configuration.ssl_ca_cert = ca_cert_file
80     elif ca_cert:
81         with tempfile.NamedTemporaryFile(prefix="salt-kube-", delete=False) as ca:
82             ca.write(base64.b64decode(ca_cert))
83             kubernetes.client.configuration.ssl_ca_cert = ca.name
84     else:
85         kubernetes.client.configuration.ssl_ca_cert = None
86     if client_cert_file:
87         kubernetes.client.configuration.cert_file = client_cert_file
88     elif client_cert:
89         with tempfile.NamedTemporaryFile(prefix="salt-kube-", delete=False) as c:
90             c.write(base64.b64decode(client_cert))
91             kubernetes.client.configuration.cert_file = c.name
92     else:
93         kubernetes.client.configuration.cert_file = None
94     if client_key_file:
95         kubernetes.client.configuration.key_file = client_key_file
96     elif client_key:
97         with tempfile.NamedTemporaryFile(prefix="salt-kube-", delete=False) as k:
98             k.write(base64.b64decode(client_key))
99             kubernetes.client.configuration.key_file = k.name
100     else:
101         kubernetes.client.configuration.key_file = None
102     return {}
103 def _setup_conn(**kwargs):
104     kubeconfig = kwargs.get("kubeconfig") or __salt__["config.option"](
105         "kubernetes.kubeconfig"
106     )
107     kubeconfig_data = kwargs.get("kubeconfig_data") or __salt__["config.option"](
108         "kubernetes.kubeconfig-data"
109     )
110     context = kwargs.get("context") or __salt__["config.option"]("kubernetes.context")
111     if (kubeconfig_data and not kubeconfig) or (
112         kubeconfig_data and kwargs.get("kubeconfig_data")
113     ):
114         with tempfile.NamedTemporaryFile(
115             prefix="salt-kubeconfig-", delete=False
116         ) as kcfg:
117             kcfg.write(base64.b64decode(kubeconfig_data))
118             kubeconfig = kcfg.name
119     if not (kubeconfig and context):
120         if kwargs.get("api_url") or __salt__["config.option"]("kubernetes.api_url"):
121             try:
122                 return _setup_conn_old(**kwargs)
123             except Exception:  # pylint: disable=broad-except
124                 raise CommandExecutionError(
125                     "Old style kubernetes configuration is only supported up to"
126                     " python-kubernetes 2.0.0"
127                 )
128         else:
129             raise CommandExecutionError(
130                 "Invalid kubernetes configuration. Parameter 'kubeconfig' and 'context'"
131                 " are required."
132             )
133     kubernetes.config.load_kube_config(config_file=kubeconfig, context=context)
134     return {"kubeconfig": kubeconfig, "context": context}
135 def _cleanup_old(**kwargs):
136     try:
137         ca = kubernetes.client.configuration.ssl_ca_cert
138         cert = kubernetes.client.configuration.cert_file
139 <a name="2"></a>        key = kubernetes.client.configuration.key_file
140         if (
141             cert
142             and os<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.path.exists(cert)
143             and os.path.basename(cert).startswith("salt-kube-")
144         ):
145 <a name="1"></a>            salt.utils.files.safe_rm(</b></font>cert)
146         if (
147             key
148             and os<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.path.exists(key)
149             and os.path.basename(key).startswith("salt-kube-")
150         ):
151             salt.utils.files.safe_rm(</b></font>key)
152         if ca and os.path.exists(ca) and os.path.basename(ca).startswith("salt-kube-"):
153             salt.utils.files.safe_rm(ca)
154     except Exception:  # pylint: disable=broad-except
155         pass
156 def _cleanup(**kwargs):
157     if not kwargs:
158         return _cleanup_old(**kwargs)
159     if "kubeconfig" in kwargs:
160         kubeconfig = kwargs.get("kubeconfig")
161         if kubeconfig and os.path.basename(kubeconfig).startswith("salt-kubeconfig-"):
162             try:
163                 os.unlink(kubeconfig)
164             except OSError as err:
165                 if err.errno != errno.ENOENT:
166                     log.exception(err)
167 def ping(**kwargs):
168     status = True
169     try:
170         nodes(**kwargs)
171     except CommandExecutionError:
172         status = False
173     return status
174 def nodes(**kwargs):
175     cfg = _setup_conn(**kwargs)
176     try:
177         api_instance = kubernetes.client.CoreV1Api()
178         api_response = api_instance.list_node()
179         return [
180             k8s_node["metadata"]["name"]
181             for k8s_node in api_response.to_dict().get("items")
182         ]
183     except (ApiException, HTTPError) as exc:
184         if isinstance(exc, ApiException) and exc.status == 404:
185             return None
186         else:
187             log.exception("Exception when calling CoreV1Api-&gt;list_node")
188             raise CommandExecutionError(exc)
189     finally:
190         _cleanup(**cfg)
191 def node(name, **kwargs):
192     cfg = _setup_conn(**kwargs)
193     try:
194         api_instance = kubernetes.client.CoreV1Api()
195         api_response = api_instance.list_node()
196     except (ApiException, HTTPError) as exc:
197         if isinstance(exc, ApiException) and exc.status == 404:
198             return None
199         else:
200             log.exception("Exception when calling CoreV1Api-&gt;list_node")
201             raise CommandExecutionError(exc)
202     finally:
203         _cleanup(**cfg)
204     for k8s_node in api_response.items:
205         if k8s_node.metadata.name == name:
206             return k8s_node.to_dict()
207     return None
208 def node_labels(name, **kwargs):
209     match = node(name, **kwargs)
210     if match is not None:
211         return match["metadata"]["labels"]
212     return {}
213 def node_add_label(node_name, label_name, label_value, **kwargs):
214     cfg = _setup_conn(**kwargs)
215     try:
216         api_instance = kubernetes.client.CoreV1Api()
217         body = {"metadata": {"labels": {label_name: label_value}}}
218         api_response = api_instance.patch_node(node_name, body)
219         return api_response
220     except (ApiException, HTTPError) as exc:
221         if isinstance(exc, ApiException) and exc.status == 404:
222             return None
223         else:
224             log.exception("Exception when calling CoreV1Api-&gt;patch_node")
225             raise CommandExecutionError(exc)
226     finally:
227         _cleanup(**cfg)
228     return None
229 def node_remove_label(node_name, label_name, **kwargs):
230     cfg = _setup_conn(**kwargs)
231     try:
232         api_instance = kubernetes.client.CoreV1Api()
233         body = {"metadata": {"labels": {label_name: None}}}
234         api_response = api_instance.patch_node(node_name, body)
235         return api_response
236     except (ApiException, HTTPError) as exc:
237         if isinstance(exc, ApiException) and exc.status == 404:
238             return None
239         else:
240             log.exception("Exception when calling CoreV1Api-&gt;patch_node")
241             raise CommandExecutionError(exc)
242     finally:
243         _cleanup(**cfg)
244     return None
245 def namespaces(**kwargs):
246     cfg = _setup_conn(**kwargs)
247     try:
248         api_instance = kubernetes.client.CoreV1Api()
249         api_response = api_instance.list_namespace()
250         return [nms["metadata"]["name"] for nms in api_response.to_dict().get("items")]
251     except (ApiException, HTTPError) as exc:
252         if isinstance(exc, ApiException) and exc.status == 404:
253             return None
254         else:
255             log.exception("Exception when calling CoreV1Api-&gt;list_namespace")
256             raise CommandExecutionError(exc)
257     finally:
258         _cleanup(**cfg)
259 def deployments(namespace="default", **kwargs):
260     cfg = _setup_conn(**kwargs)
261     try:
262         api_instance = kubernetes.client.ExtensionsV1beta1Api()
263         api_response = api_instance.list_namespaced_deployment(namespace)
264         return [dep["metadata"]["name"] for dep in api_response.to_dict().get("items")]
265     except (ApiException, HTTPError) as exc:
266         if isinstance(exc, ApiException) and exc.status == 404:
267             return None
268         else:
269             log.exception(
270                 "Exception when calling "
271                 "ExtensionsV1beta1Api-&gt;list_namespaced_deployment"
272             )
273             raise CommandExecutionError(exc)
274     finally:
275         _cleanup(**cfg)
276 def services(namespace="default", **kwargs):
277     cfg = _setup_conn(**kwargs)
278     try:
279         api_instance = kubernetes.client.CoreV1Api()
280         api_response = api_instance.list_namespaced_service(namespace)
281         return [srv["metadata"]["name"] for srv in api_response.to_dict().get("items")]
282     except (ApiException, HTTPError) as exc:
283         if isinstance(exc, ApiException) and exc.status == 404:
284             return None
285         else:
286             log.exception("Exception when calling CoreV1Api-&gt;list_namespaced_service")
287             raise CommandExecutionError(exc)
288     finally:
289         _cleanup(**cfg)
290 def pods(namespace="default", **kwargs):
291     cfg = _setup_conn(**kwargs)
292     try:
293         api_instance = kubernetes.client.CoreV1Api()
294         api_response = api_instance.list_namespaced_pod(namespace)
295         return [pod["metadata"]["name"] for pod in api_response.to_dict().get("items")]
296     except (ApiException, HTTPError) as exc:
297         if isinstance(exc, ApiException) and exc.status == 404:
298             return None
299         else:
300             log.exception("Exception when calling CoreV1Api-&gt;list_namespaced_pod")
301             raise CommandExecutionError(exc)
302     finally:
303         _cleanup(**cfg)
304 def secrets(namespace="default", **kwargs):
305     cfg = _setup_conn(**kwargs)
306     try:
307         api_instance = kubernetes.client.CoreV1Api()
308         api_response = api_instance.list_namespaced_secret(namespace)
309         return [
310             secret["metadata"]["name"] for secret in api_response.to_dict().get("items")
311         ]
312     except (ApiException, HTTPError) as exc:
313         if isinstance(exc, ApiException) and exc.status == 404:
314             return None
315         else:
316             log.exception("Exception when calling CoreV1Api-&gt;list_namespaced_secret")
317             raise CommandExecutionError(exc)
318     finally:
319         _cleanup(**cfg)
320 def configmaps(namespace="default", **kwargs):
321     cfg = _setup_conn(**kwargs)
322     try:
323         api_instance = kubernetes.client.CoreV1Api()
324         api_response = api_instance.list_namespaced_config_map(namespace)
325         return [
326             secret["metadata"]["name"] for secret in api_response.to_dict().get("items")
327         ]
328     except (ApiException, HTTPError) as exc:
329         if isinstance(exc, ApiException) and exc.status == 404:
330             return None
331         else:
332             log.exception(
333                 "Exception when calling CoreV1Api-&gt;list_namespaced_config_map"
334             )
335             raise CommandExecutionError(exc)
336     finally:
337         _cleanup(**cfg)
338 def show_deployment(name, namespace="default", **kwargs):
339     cfg = _setup_conn(**kwargs)
340     try:
341         api_instance = kubernetes.client.ExtensionsV1beta1Api()
342         api_response = api_instance.read_namespaced_deployment(name, namespace)
343         return api_response.to_dict()
344     except (ApiException, HTTPError) as exc:
345         if isinstance(exc, ApiException) and exc.status == 404:
346             return None
347         else:
348             log.exception(
349                 "Exception when calling "
350                 "ExtensionsV1beta1Api-&gt;read_namespaced_deployment"
351             )
352             raise CommandExecutionError(exc)
353     finally:
354         _cleanup(**cfg)
355 def show_service(name, namespace="default", **kwargs):
356     cfg = _setup_conn(**kwargs)
357     try:
358         api_instance = kubernetes.client.CoreV1Api()
359         api_response = api_instance.read_namespaced_service(name, namespace)
360         return api_response.to_dict()
361     except (ApiException, HTTPError) as exc:
362         if isinstance(exc, ApiException) and exc.status == 404:
363             return None
364         else:
365             log.exception("Exception when calling CoreV1Api-&gt;read_namespaced_service")
366             raise CommandExecutionError(exc)
367     finally:
368         _cleanup(**cfg)
369 def show_pod(name, namespace="default", **kwargs):
370     cfg = _setup_conn(**kwargs)
371     try:
372         api_instance = kubernetes.client.CoreV1Api()
373         api_response = api_instance.read_namespaced_pod(name, namespace)
374         return api_response.to_dict()
375     except (ApiException, HTTPError) as exc:
376         if isinstance(exc, ApiException) and exc.status == 404:
377             return None
378         else:
379             log.exception("Exception when calling CoreV1Api-&gt;read_namespaced_pod")
380             raise CommandExecutionError(exc)
381     finally:
382         _cleanup(**cfg)
383 def show_namespace(name, **kwargs):
384     cfg = _setup_conn(**kwargs)
385     try:
386         api_instance = kubernetes.client.CoreV1Api()
387         api_response = api_instance.read_namespace(name)
388         return api_response.to_dict()
389     except (ApiException, HTTPError) as exc:
390         if isinstance(exc, ApiException) and exc.status == 404:
391             return None
392         else:
393             log.exception("Exception when calling CoreV1Api-&gt;read_namespace")
394             raise CommandExecutionError(exc)
395     finally:
396         _cleanup(**cfg)
397 def show_secret(name, namespace="default", decode=False, **kwargs):
398     cfg = _setup_conn(**kwargs)
399     try:
400         api_instance = kubernetes.client.CoreV1Api()
401         api_response = api_instance.read_namespaced_secret(name, namespace)
402         if api_response.data and (decode or decode == "True"):
403             for key in api_response.data:
404                 value = api_response.data[key]
405                 api_response.data[key] = base64.b64decode(value)
406         return api_response.to_dict()
407     except (ApiException, HTTPError) as exc:
408         if isinstance(exc, ApiException) and exc.status == 404:
409             return None
410         else:
411             log.exception("Exception when calling CoreV1Api-&gt;read_namespaced_secret")
412             raise CommandExecutionError(exc)
413     finally:
414         _cleanup(**cfg)
415 def show_configmap(name, namespace="default", **kwargs):
416     cfg = _setup_conn(**kwargs)
417     try:
418         api_instance = kubernetes.client.CoreV1Api()
419         api_response = api_instance.read_namespaced_config_map(name, namespace)
420         return api_response.to_dict()
421     except (ApiException, HTTPError) as exc:
422         if isinstance(exc, ApiException) and exc.status == 404:
423             return None
424         else:
425             log.exception(
426                 "Exception when calling CoreV1Api-&gt;read_namespaced_config_map"
427             )
428             raise CommandExecutionError(exc)
429     finally:
430         _cleanup(**cfg)
431 def delete_deployment(name, namespace="default", **kwargs):
432     cfg = _setup_conn(**kwargs)
433     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
434     try:
435         api_instance = kubernetes.client.ExtensionsV1beta1Api()
436         api_response = api_instance.delete_namespaced_deployment(
437             name=name, namespace=namespace, body=body
438         )
439         mutable_api_response = api_response.to_dict()
440         if not salt.utils.platform.is_windows():
441             try:
442                 with _time_limit(POLLING_TIME_LIMIT):
443                     while show_deployment(name, namespace) is not None:
444                         time.sleep(1)
445                     else:  # pylint: disable=useless-else-on-loop
446                         mutable_api_response["code"] = 200
447             except TimeoutError:
448                 pass
449         else:
450             for i in range(60):
451                 if show_deployment(name, namespace) is None:
452                     mutable_api_response["code"] = 200
453                     break
454                 else:
455                     time.sleep(1)
456         if mutable_api_response["code"] != 200:
457             log.warning(
458                 "Reached polling time limit. Deployment is not yet "
459                 "deleted, but we are backing off. Sorry, but you'll "
460                 "have to check manually."
461             )
462         return mutable_api_response
463     except (ApiException, HTTPError) as exc:
464         if isinstance(exc, ApiException) and exc.status == 404:
465             return None
466         else:
467             log.exception(
468                 "Exception when calling "
469                 "ExtensionsV1beta1Api-&gt;delete_namespaced_deployment"
470             )
471             raise CommandExecutionError(exc)
472     finally:
473         _cleanup(**cfg)
474 def delete_service(name, namespace="default", **kwargs):
475     cfg = _setup_conn(**kwargs)
476     try:
477         api_instance = kubernetes.client.CoreV1Api()
478         api_response = api_instance.delete_namespaced_service(
479             name=name, namespace=namespace
480         )
481         return api_response.to_dict()
482     except (ApiException, HTTPError) as exc:
483         if isinstance(exc, ApiException) and exc.status == 404:
484             return None
485         else:
486             log.exception("Exception when calling CoreV1Api-&gt;delete_namespaced_service")
487             raise CommandExecutionError(exc)
488     finally:
489         _cleanup(**cfg)
490 def delete_pod(name, namespace="default", **kwargs):
491     cfg = _setup_conn(**kwargs)
492     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
493     try:
494         api_instance = kubernetes.client.CoreV1Api()
495         api_response = api_instance.delete_namespaced_pod(
496             name=name, namespace=namespace, body=body
497         )
498         return api_response.to_dict()
499     except (ApiException, HTTPError) as exc:
500         if isinstance(exc, ApiException) and exc.status == 404:
501             return None
502         else:
503             log.exception("Exception when calling CoreV1Api-&gt;delete_namespaced_pod")
504             raise CommandExecutionError(exc)
505     finally:
506         _cleanup(**cfg)
507 def delete_namespace(name, **kwargs):
508     cfg = _setup_conn(**kwargs)
509     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
510     try:
511         api_instance = kubernetes.client.CoreV1Api()
512         api_response = api_instance.delete_namespace(name=name, body=body)
513         return api_response.to_dict()
514     except (ApiException, HTTPError) as exc:
515         if isinstance(exc, ApiException) and exc.status == 404:
516             return None
517         else:
518             log.exception("Exception when calling CoreV1Api-&gt;delete_namespace")
519             raise CommandExecutionError(exc)
520     finally:
521         _cleanup(**cfg)
522 def delete_secret(name, namespace="default", **kwargs):
523     cfg = _setup_conn(**kwargs)
524     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
525     try:
526         api_instance = kubernetes.client.CoreV1Api()
527         api_response = api_instance.delete_namespaced_secret(
528             name=name, namespace=namespace, body=body
529         )
530         return api_response.to_dict()
531     except (ApiException, HTTPError) as exc:
532         if isinstance(exc, ApiException) and exc.status == 404:
533             return None
534         else:
535             log.exception("Exception when calling CoreV1Api-&gt;delete_namespaced_secret")
536             raise CommandExecutionError(exc)
537     finally:
538         _cleanup(**cfg)
539 def delete_configmap(name, namespace="default", **kwargs):
540     cfg = _setup_conn(**kwargs)
541     body = kubernetes.client.V1DeleteOptions(orphan_dependents=True)
542     try:
543         api_instance = kubernetes.client.CoreV1Api()
544         api_response = api_instance.delete_namespaced_config_map(
545             name=name, namespace=namespace, body=body
546         )
547         return api_response.to_dict()
548     except (ApiException, HTTPError) as exc:
549         if isinstance(exc, ApiException) and exc.status == 404:
550             return None
551         else:
552             log.exception(
553                 "Exception when calling CoreV1Api-&gt;delete_namespaced_config_map"
554             )
555             raise CommandExecutionError(exc)
556     finally:
557         _cleanup(**cfg)
558 def create_deployment(
559     name, namespace, metadata, spec, source, template, saltenv, **kwargs
560 ):
561     body = __create_object_body(
562         kind="Deployment",
563         obj_class=AppsV1beta1Deployment,
564         spec_creator=__dict_to_deployment_spec,
565         name=name,
566         namespace=namespace,
567         metadata=metadata,
568         spec=spec,
569         source=source,
570         template=template,
571         saltenv=saltenv,
572     )
573     cfg = _setup_conn(**kwargs)
574     try:
575         api_instance = kubernetes.client.ExtensionsV1beta1Api()
576         api_response = api_instance.create_namespaced_deployment(namespace, body)
577         return api_response.to_dict()
578     except (ApiException, HTTPError) as exc:
579         if isinstance(exc, ApiException) and exc.status == 404:
580             return None
581         else:
582             log.exception(
583                 "Exception when calling "
584                 "ExtensionsV1beta1Api-&gt;create_namespaced_deployment"
585             )
586             raise CommandExecutionError(exc)
587     finally:
588         _cleanup(**cfg)
589 def create_pod(name, namespace, metadata, spec, source, template, saltenv, **kwargs):
590     body = __create_object_body(
591         kind="Pod",
592         obj_class=kubernetes.client.V1Pod,
593         spec_creator=__dict_to_pod_spec,
594         name=name,
595         namespace=namespace,
596         metadata=metadata,
597         spec=spec,
598         source=source,
599         template=template,
600         saltenv=saltenv,
601     )
602     cfg = _setup_conn(**kwargs)
603     try:
604         api_instance = kubernetes.client.CoreV1Api()
605         api_response = api_instance.create_namespaced_pod(namespace, body)
606         return api_response.to_dict()
607     except (ApiException, HTTPError) as exc:
608         if isinstance(exc, ApiException) and exc.status == 404:
609             return None
610         else:
611             log.exception("Exception when calling CoreV1Api-&gt;create_namespaced_pod")
612             raise CommandExecutionError(exc)
613     finally:
614         _cleanup(**cfg)
615 def create_service(
616     name, namespace, metadata, spec, source, template, saltenv, **kwargs
617 ):
618     body = __create_object_body(
619         kind="Service",
620         obj_class=kubernetes.client.V1Service,
621         spec_creator=__dict_to_service_spec,
622         name=name,
623         namespace=namespace,
624         metadata=metadata,
625         spec=spec,
626         source=source,
627         template=template,
628         saltenv=saltenv,
629     )
630     cfg = _setup_conn(**kwargs)
631     try:
632         api_instance = kubernetes.client.CoreV1Api()
633         api_response = api_instance.create_namespaced_service(namespace, body)
634         return api_response.to_dict()
635     except (ApiException, HTTPError) as exc:
636         if isinstance(exc, ApiException) and exc.status == 404:
637             return None
638         else:
639             log.exception("Exception when calling CoreV1Api-&gt;create_namespaced_service")
640             raise CommandExecutionError(exc)
641     finally:
642         _cleanup(**cfg)
643 def create_secret(
644     name,
645     namespace="default",
646     data=None,
647     source=None,
648     template=None,
649     saltenv="base",
650     **kwargs
651 ):
652     if source:
653         data = __read_and_render_yaml_file(source, template, saltenv)
654     elif data is None:
655         data = {}
656     data = __enforce_only_strings_dict(data)
657     for key in data:
658         data[key] = base64.b64encode(data[key])
659     body = kubernetes.client.V1Secret(
660         metadata=__dict_to_object_meta(name, namespace, {}), data=data
661     )
662     cfg = _setup_conn(**kwargs)
663     try:
664         api_instance = kubernetes.client.CoreV1Api()
665         api_response = api_instance.create_namespaced_secret(namespace, body)
666         return api_response.to_dict()
667     except (ApiException, HTTPError) as exc:
668         if isinstance(exc, ApiException) and exc.status == 404:
669             return None
670         else:
671             log.exception("Exception when calling CoreV1Api-&gt;create_namespaced_secret")
672             raise CommandExecutionError(exc)
673     finally:
674         _cleanup(**cfg)
675 def create_configmap(
676     name, namespace, data, source=None, template=None, saltenv="base", **kwargs
677 ):
678     if source:
679         data = __read_and_render_yaml_file(source, template, saltenv)
680     elif data is None:
681         data = {}
682     data = __enforce_only_strings_dict(data)
683     body = kubernetes.client.V1ConfigMap(
684         metadata=__dict_to_object_meta(name, namespace, {}), data=data
685     )
686     cfg = _setup_conn(**kwargs)
687     try:
688         api_instance = kubernetes.client.CoreV1Api()
689         api_response = api_instance.create_namespaced_config_map(namespace, body)
690         return api_response.to_dict()
691     except (ApiException, HTTPError) as exc:
692         if isinstance(exc, ApiException) and exc.status == 404:
693             return None
694         else:
695             log.exception(
696                 "Exception when calling CoreV1Api-&gt;create_namespaced_config_map"
697             )
698             raise CommandExecutionError(exc)
699     finally:
700         _cleanup(**cfg)
701 def create_namespace(name, **kwargs):
702     meta_obj = kubernetes.client.V1ObjectMeta(name=name)
703     body = kubernetes.client.V1Namespace(metadata=meta_obj)
704     body.metadata.name = name
705     cfg = _setup_conn(**kwargs)
706     try:
707         api_instance = kubernetes.client.CoreV1Api()
708         api_response = api_instance.create_namespace(body)
709         return api_response.to_dict()
710     except (ApiException, HTTPError) as exc:
711         if isinstance(exc, ApiException) and exc.status == 404:
712             return None
713         else:
714             log.exception("Exception when calling CoreV1Api-&gt;create_namespace")
715             raise CommandExecutionError(exc)
716     finally:
717         _cleanup(**cfg)
718 def replace_deployment(
719     name, metadata, spec, source, template, saltenv, namespace="default", **kwargs
720 ):
721     body = __create_object_body(
722         kind="Deployment",
723         obj_class=AppsV1beta1Deployment,
724         spec_creator=__dict_to_deployment_spec,
725         name=name,
726         namespace=namespace,
727         metadata=metadata,
728         spec=spec,
729         source=source,
730         template=template,
731         saltenv=saltenv,
732     )
733     cfg = _setup_conn(**kwargs)
734     try:
735         api_instance = kubernetes.client.ExtensionsV1beta1Api()
736         api_response = api_instance.replace_namespaced_deployment(name, namespace, body)
737         return api_response.to_dict()
738     except (ApiException, HTTPError) as exc:
739         if isinstance(exc, ApiException) and exc.status == 404:
740             return None
741         else:
742             log.exception(
743                 "Exception when calling "
744                 "ExtensionsV1beta1Api-&gt;replace_namespaced_deployment"
745             )
746             raise CommandExecutionError(exc)
747     finally:
748         _cleanup(**cfg)
749 def replace_service(
750     name,
751     metadata,
752     spec,
753     source,
754     template,
755     old_service,
756     saltenv,
757     namespace="default",
758     **kwargs
759 ):
760     body = __create_object_body(
761         kind="Service",
762         obj_class=kubernetes.client.V1Service,
763         spec_creator=__dict_to_service_spec,
764         name=name,
765         namespace=namespace,
766         metadata=metadata,
767         spec=spec,
768         source=source,
769         template=template,
770         saltenv=saltenv,
771     )
772     body.spec.cluster_ip = old_service["spec"]["cluster_ip"]
773     body.metadata.resource_version = old_service["metadata"]["resource_version"]
774     cfg = _setup_conn(**kwargs)
775     try:
776         api_instance = kubernetes.client.CoreV1Api()
777         api_response = api_instance.replace_namespaced_service(name, namespace, body)
778         return api_response.to_dict()
779     except (ApiException, HTTPError) as exc:
780         if isinstance(exc, ApiException) and exc.status == 404:
781             return None
782         else:
783             log.exception(
784                 "Exception when calling CoreV1Api-&gt;replace_namespaced_service"
785             )
786             raise CommandExecutionError(exc)
787     finally:
788         _cleanup(**cfg)
789 def replace_secret(
790     name,
791     data,
792     source=None,
793     template=None,
794     saltenv="base",
795     namespace="default",
796     **kwargs
797 ):
798     if source:
799         data = __read_and_render_yaml_file(source, template, saltenv)
800     elif data is None:
801         data = {}
802     data = __enforce_only_strings_dict(data)
803     for key in data:
804         data[key] = base64.b64encode(data[key])
805     body = kubernetes.client.V1Secret(
806         metadata=__dict_to_object_meta(name, namespace, {}), data=data
807     )
808     cfg = _setup_conn(**kwargs)
809     try:
810         api_instance = kubernetes.client.CoreV1Api()
811         api_response = api_instance.replace_namespaced_secret(name, namespace, body)
812         return api_response.to_dict()
813     except (ApiException, HTTPError) as exc:
814         if isinstance(exc, ApiException) and exc.status == 404:
815             return None
816         else:
817             log.exception("Exception when calling CoreV1Api-&gt;replace_namespaced_secret")
818             raise CommandExecutionError(exc)
819     finally:
820         _cleanup(**cfg)
821 def replace_configmap(
822     name,
823     data,
824     source=None,
825     template=None,
826     saltenv="base",
827     namespace="default",
828     **kwargs
829 ):
830     if source:
831         data = __read_and_render_yaml_file(source, template, saltenv)
832     data = __enforce_only_strings_dict(data)
833     body = kubernetes.client.V1ConfigMap(
834         metadata=__dict_to_object_meta(name, namespace, {}), data=data
835     )
836     cfg = _setup_conn(**kwargs)
837     try:
838         api_instance = kubernetes.client.CoreV1Api()
839         api_response = api_instance.replace_namespaced_config_map(name, namespace, body)
840         return api_response.to_dict()
841     except (ApiException, HTTPError) as exc:
842         if isinstance(exc, ApiException) and exc.status == 404:
843             return None
844         else:
845             log.exception(
846                 "Exception when calling CoreV1Api-&gt;replace_namespaced_configmap"
847             )
848             raise CommandExecutionError(exc)
849     finally:
850         _cleanup(**cfg)
851 def __create_object_body(
852     kind,
853     obj_class,
854     spec_creator,
855     name,
856     namespace,
857     metadata,
858     spec,
859     source,
860     template,
861     saltenv,
862 ):
863     if source:
864         src_obj = __read_and_render_yaml_file(source, template, saltenv)
865         if (
866             not isinstance(src_obj, dict)
867             or "kind" not in src_obj
868             or src_obj["kind"] != kind
869         ):
870             raise CommandExecutionError(
871                 "The source file should define only a {} object".format(kind)
872             )
873         if "metadata" in src_obj:
874             metadata = src_obj["metadata"]
875         if "spec" in src_obj:
876             spec = src_obj["spec"]
877     return obj_class(
878         metadata=__dict_to_object_meta(name, namespace, metadata),
879         spec=spec_creator(spec),
880     )
881 def __read_and_render_yaml_file(source, template, saltenv):
882     sfn = __salt__["cp.cache_file"](source, saltenv)
883     if not sfn:
884         raise CommandExecutionError("Source file '{}' not found".format(source))
885     with salt.utils.files.fopen(sfn, "r") as src:
886         contents = src.read()
887         if template:
888             if template in salt.utils.templates.TEMPLATE_REGISTRY:
889                 data = salt.utils.templates.TEMPLATE_REGISTRY[template](
890                     contents,
891                     from_str=True,
892                     to_str=True,
893                     saltenv=saltenv,
894                     grains=__grains__,
895                     pillar=__pillar__,
896                     salt=__salt__,
897                     opts=__opts__,
898                 )
899                 if not data["result"]:
900                     raise CommandExecutionError(
901                         "Failed to render file path with error: {}".format(data["data"])
902                     )
903                 contents = data["data"].encode("utf-8")
904             else:
905                 raise CommandExecutionError(
906                     "Unknown template specified: {}".format(template)
907                 )
908         return salt.utils.yaml.safe_load(contents)
909 def __dict_to_object_meta(name, namespace, metadata):
910     meta_obj = kubernetes.client.V1ObjectMeta()
911     meta_obj.namespace = namespace
912     if "annotations" not in metadata:
913         metadata["annotations"] = {}
914     if "kubernetes.io/change-cause" not in metadata["annotations"]:
915         metadata["annotations"]["kubernetes.io/change-cause"] = " ".join(sys.argv)
916     for key, value in metadata.items():
917         if hasattr(meta_obj, key):
918             setattr(meta_obj, key, value)
919     if meta_obj.name != name:
920         log.warning(
921             "The object already has a name attribute, overwriting it with "
922             "the one defined inside of salt"
923         )
924         meta_obj.name = name
925     return meta_obj
926 def __dict_to_deployment_spec(spec):
927     spec_obj = AppsV1beta1DeploymentSpec(template=spec.get("template", ""))
928     for key, value in spec.items():
929         if hasattr(spec_obj, key):
930             setattr(spec_obj, key, value)
931     return spec_obj
932 def __dict_to_pod_spec(spec):
933     spec_obj = kubernetes.client.V1PodSpec()
934     for key, value in spec.items():
935         if hasattr(spec_obj, key):
936             setattr(spec_obj, key, value)
937     return spec_obj
938 def __dict_to_service_spec(spec):
939     spec_obj = kubernetes.client.V1ServiceSpec()
940     for key, value in spec.items():  # pylint: disable=too-many-nested-blocks
941         if key == "ports":
942             spec_obj.ports = []
943             for port in value:
944                 kube_port = kubernetes.client.V1ServicePort()
945                 if isinstance(port, dict):
946                     for port_key, port_value in port.items():
947                         if hasattr(kube_port, port_key):
948                             setattr(kube_port, port_key, port_value)
949                 else:
950                     kube_port.port = port
951                 spec_obj.ports.append(kube_port)
952         elif hasattr(spec_obj, key):
953             setattr(spec_obj, key, value)
954     return spec_obj
955 def __enforce_only_strings_dict(dictionary):
956     ret = {}
957     for key, value in dictionary.items():
958         ret[str(key)] = str(value)
959     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
