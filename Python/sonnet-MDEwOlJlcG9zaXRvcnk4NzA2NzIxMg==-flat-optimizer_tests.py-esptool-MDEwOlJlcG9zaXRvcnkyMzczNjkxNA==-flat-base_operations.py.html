
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.401563610518834%, Tokens: 9</h2>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-optimizer_tests.py</h3>
            <pre><code>1  import itertools
2  from absl.testing import parameterized
3  import numpy as np
4  from sonnet.src import base
5  from sonnet.src import test_utils
6  import tensorflow as tf
7  import tree
8  class WrappedTFOptimizer(base.Optimizer):
9    wrapped = None
10    def __init__(self, optimizer: tf.optimizers.Optimizer):
11      super().__init__()
12      self.wrapped = optimizer
13    def __getattr__(self, name):
14      return getattr(self.wrapped, name)
15    def apply(self, updates, params):
16      self.wrapped.apply_gradients(zip(updates, params))
17  def is_tf_optimizer(optimizer):
18    return isinstance(optimizer, WrappedTFOptimizer)
19  class OptimizerTestBase(test_utils.TestCase):
20    def make_optimizer(self, *args, **kwargs):
21      raise NotImplementedError()
22    def testNoneUpdate(self):
23      parameters = [tf.Variable(1.), tf.Variable(2.)]
24      updates = [None, tf.constant(3.)]
25      optimizer = self.make_optimizer()
26      optimizer.apply(updates, parameters)
27      self.assertAllClose(1., parameters[0].numpy())
28    def testDifferentLengthUpdatesParams(self):
29      optimizer = self.make_optimizer()
30      if is_tf_optimizer(optimizer):
31        self.skipTest("TF optimizers don't check the lenghs of params/updates.")
<span onclick='openModal()' class='match'>32      parameters = [tf.Variable([1., 2.]), tf.Variable([3., 4.])]
33      updates = [tf.constant([5., 5.])]
</span>34      with self.assertRaisesRegex(
35          ValueError, "`updates` and `parameters` must be the same length."):
36        optimizer.apply(updates, parameters)
37    def testEmptyParams(self):
38      optimizer = self.make_optimizer()
39      if is_tf_optimizer(optimizer):
40        self.skipTest("TF optimizers don't error on empty params.")
41      with self.assertRaisesRegex(ValueError, "`parameters` cannot be empty."):
42        optimizer.apply([], [])
43    def testAllUpdatesNone(self):
44      parameters = [tf.Variable(1.), tf.Variable(2.)]
45      updates = [None, None]
46      optimizer = self.make_optimizer()
47      if is_tf_optimizer(optimizer):
48        msg = "No gradients provided for any variable"
49      else:
50        msg = "No updates provided for any parameter"
51      with self.assertRaisesRegex(ValueError, msg):
52        optimizer.apply(updates, parameters)
53    def testInconsistentDTypes(self):
54      optimizer = self.make_optimizer()
55      if is_tf_optimizer(optimizer):
56        self.skipTest("TF optimizers raise a cryptic error message here.")
57      parameters = [tf.Variable([1., 2.], name="param0")]
58      updates = [tf.constant([5, 5])]
59      with self.assertRaisesRegex(
60          ValueError, "DType of .* is not equal to that of parameter .*param0.*"):
61        optimizer.apply(updates, parameters)
62    def testUnsuppportedStrategyError(self):
63      strategy = tf.distribute.MirroredStrategy()
64      with strategy.scope():
65        parameters = [tf.Variable(1.0)]
66        updates = [tf.constant(0.1)]
67        optimizer = self.make_optimizer()
68        if is_tf_optimizer(optimizer):
69          self.skipTest("TF optimizers aren't restricted to Sonnet strategies.")
70      with self.assertRaisesRegex(
71          ValueError,
72          "Sonnet optimizers are not compatible with `MirroredStrategy`"):
73        strategy.run(lambda: optimizer.apply(updates, parameters))
74  class AbstractFuzzTest(test_utils.TestCase, parameterized.TestCase):
75    def _make_tf(self, learning_rate, momentum, use_nesterov):
76      raise NotImplementedError()
77    def _make_snt(self, learning_rate, momentum, use_nesterov):
78      raise NotImplementedError()
79    def assertParametersRemainClose(self, seed, config, num_steps=100, atol=1e-4):
80      tf_opt = self._make_tf(**config)
81      snt_opt = self._make_snt(**config)
82      data = _generate_dense_data(seed, num_steps)
83      tf_params = _apply_optimizer(data, tf_opt)
84      snt_params = _apply_optimizer(data, snt_opt)
85      assert tf_params and len(tf_params) == len(snt_params)
86      for step, (tf_param, snt_param) in enumerate(zip(tf_params, snt_params)):
87        msg = "TF and Sonnet diverged at step {}".format(step)
88        for tf_p, snt_p in zip(tf_param, snt_param):
89          self.assertEqual(tf_p.shape, snt_p.shape)
90          self.assertEqual(tf_p.dtype, snt_p.dtype)
91          self.assertAllClose(tf_p, snt_p, atol=atol, msg=msg)
92  def _generate_dense_data(seed, num_steps):
93    np.random.seed(seed=seed)
94    params = [
95        np.random.normal(size=(10, 10, 10)).astype(np.float32),
96        np.random.normal(size=(10, 10)).astype(np.float32),
97        np.random.normal(size=(10,)).astype(np.float32),
98    ]
99    per_step_grads = []
100    for _ in range(num_steps):
101      per_step_grads.append([
102          np.random.normal(size=(10, 10, 10)).astype(np.float32),
103          np.random.normal(size=(10, 10)).astype(np.float32),
104          np.random.normal(size=(10,)).astype(np.float32),
105      ])
106    return params, per_step_grads
107  def _apply_optimizer(data, apply_fn):
108    params, per_step_grads = data
109    params = [tf.Variable(p, name="rank{}".format(len(p.shape))) for p in params]
110    per_step_grads = tree.map_structure(tf.convert_to_tensor, per_step_grads)
111    param_vals = []
112    assert per_step_grads
113    for grads in per_step_grads:
114      apply_fn(grads, params)
115      param_vals.append([p.numpy() for p in params])
116    return param_vals
117  def named_product(**config):
118    keys = list(config.keys())
119    values = list(config.values())
120    configs = []
121    for val in itertools.product(*values):
122      config = dict(zip(keys, val))
123      name = ",".join("{}={}".format(k, v) for k, v in config.items())
124      configs.append((name, config))
125    return configs
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_operations.py</h3>
            <pre><code>1  import argparse
2  import json
3  import sys
4  from bitstring import BitStream
5  import esptool
6  from . import base_fields
7  from . import util
8  def add_common_commands(subparsers, efuses):
9      class ActionEfuseValuePair(argparse.Action):
10          def __init__(self, option_strings, dest, nargs=None, **kwargs):
11              self._nargs = nargs
12              self._choices = kwargs.get("efuse_choices")
13              self.efuses = kwargs.get("efuses")
14              del kwargs["efuse_choices"]
15              del kwargs["efuses"]
16              super(ActionEfuseValuePair, self).__init__(
17                  option_strings, dest, nargs=nargs, **kwargs
18              )
19          def __call__(self, parser, namespace, values, option_string=None):
20              def check_efuse_name(efuse_name, efuse_list):
21                  if efuse_name not in self._choices:
22                      raise esptool.FatalError(
23                          "Invalid the efuse name '{}'. "
24                          "Available the efuse names: {}".format(
25                              efuse_name, self._choices
26                          )
27                      )
28              efuse_value_pairs = {}
29              if len(values) > 1:
30                  if len(values) % 2:
31                      raise esptool.FatalError(
32                          "The list does not have a valid pair (name value) {}".format(
33                              values
34                          )
35                      )
36                  for i in range(0, len(values), 2):
37                      efuse_name, new_value = values[i : i + 2 :]
38                      check_efuse_name(efuse_name, self._choices)
39                      check_arg = base_fields.CheckArgValue(self.efuses, efuse_name)
40                      efuse_value_pairs[efuse_name] = check_arg(new_value)
41              else:
42                  efuse_name = values[0]
43                  check_efuse_name(efuse_name, self._choices)
44                  check_arg = base_fields.CheckArgValue(self.efuses, efuse_name)
45                  efuse_value_pairs[efuse_name] = check_arg(None)
46              setattr(namespace, self.dest, efuse_value_pairs)
47      burn = subparsers.add_parser(
48          "burn_efuse", help="Burn the efuse with the specified name"
49      )
50      burn.add_argument(
51          "name_value_pairs",
52          help="Name of efuse register and New value pairs to burn",
53          action=ActionEfuseValuePair,
54          nargs="+",
55          metavar="[EFUSE_NAME VALUE] [{} VALUE".format(
56              " VALUE] [".join([e.name for e in efuses.efuses])
57          ),
58          efuse_choices=[e.name for e in efuses.efuses]
59          + [name for e in efuses.efuses for name in e.alt_names if name != ""],
60          efuses=efuses,
61      )
62      read_protect_efuse = subparsers.add_parser(
63          "read_protect_efuse",
64          help="Disable readback for the efuse with the specified name",
65      )
66      read_protect_efuse.add_argument(
67          "efuse_name",
68          help="Name of efuse register to burn",
69          nargs="+",
70          choices=[e.name for e in efuses.efuses if e.read_disable_bit is not None]
71          + [
72              name
73              for e in efuses.efuses
74              if e.read_disable_bit is not None
75              for name in e.alt_names
76              if name != ""
77          ],
78      )
79      write_protect_efuse = subparsers.add_parser(
80          "write_protect_efuse",
81          help="Disable writing to the efuse with the specified name",
82      )
83      write_protect_efuse.add_argument(
84          "efuse_name",
85          help="Name of efuse register to burn",
86          nargs="+",
87          choices=[e.name for e in efuses.efuses if e.write_disable_bit is not None]
88          + [
89              name
90              for e in efuses.efuses
91              if e.write_disable_bit is not None
92              for name in e.alt_names
93              if name != ""
94          ],
95      )
96      burn_block_data = subparsers.add_parser(
97          "burn_block_data",
98          help="Burn non-key data to EFUSE blocks. "
99          "(Don't use this command to burn key data for Flash Encryption or "
100          "ESP32 Secure Boot V1, as the byte order of keys is swapped (use burn_key)).",
101      )
102      add_force_write_always(burn_block_data)
103      burn_block_data.add_argument(
104          "--offset", "-o", help="Byte offset in the efuse block", type=int, default=0
105      )
106      burn_block_data.add_argument(
107          "block",
108          help="Efuse block to burn.",
109          action="append",
110          choices=efuses.BURN_BLOCK_DATA_NAMES,
111      )
112      burn_block_data.add_argument(
113          "datafile",
114          help="File containing data to burn into the efuse block",
115          action="append",
116          type=argparse.FileType("rb"),
117      )
118      for _ in range(0, len(efuses.BURN_BLOCK_DATA_NAMES)):
119          burn_block_data.add_argument(
120              "block",
121              help="Efuse block to burn.",
122              metavar="BLOCK",
123              nargs="?",
124              action="append",
125              choices=efuses.BURN_BLOCK_DATA_NAMES,
126          )
127          burn_block_data.add_argument(
128              "datafile",
129              nargs="?",
130              help="File containing data to burn into the efuse block",
131              metavar="DATAFILE",
132              action="append",
133              type=argparse.FileType("rb"),
134          )
135      set_bit_cmd = subparsers.add_parser("burn_bit", help="Burn bit in the efuse block.")
136      add_force_write_always(set_bit_cmd)
137      set_bit_cmd.add_argument(
138          "block", help="Efuse block to burn.", choices=efuses.BURN_BLOCK_DATA_NAMES
139      )
140      set_bit_cmd.add_argument(
141          "bit_number",
142          help="Bit number in the efuse block [0..BLK_LEN-1]",
143          nargs="+",
144          type=int,
145      )
146      subparsers.add_parser(
147          "adc_info",
148          help="Display information about ADC calibration data stored in efuse.",
149      )
150      dump_cmd = subparsers.add_parser("dump", help="Dump raw hex values of all efuses")
151      dump_cmd.add_argument(
152          "--file_name",
153          help="Saves dump for each block into separate file. Provide the common "
154          "path name /path/blk.bin, it will create: blk0.bin, blk1.bin ... blkN.bin. "
155          "Use burn_block_data to write it back to another chip.",
156      )
157      summary_cmd = subparsers.add_parser(
158          "summary", help="Print human-readable summary of efuse values"
159      )
160      summary_cmd.add_argument(
161          "--format",
162          help="Select the summary format",
163          choices=["summary", "json"],
164          default="summary",
165      )
166      summary_cmd.add_argument(
167          "--file",
168          help="File to save the efuse summary",
169          type=argparse.FileType("w"),
170          default=sys.stdout,
171      )
172      execute_scripts = subparsers.add_parser(
173          "execute_scripts", help="Executes scripts to burn at one time."
174      )
175      execute_scripts.add_argument(
176          "scripts",
177          help="The special format of python scripts.",
178          nargs="+",
179          type=argparse.FileType("r"),
180      )
181      execute_scripts.add_argument(
182          "--index",
183          help="integer index. "
184          "It allows to retrieve unique data per chip from configfiles "
185          "and then burn them (ex. CUSTOM_MAC, UNIQUE_ID).",
186          type=int,
187      )
188      execute_scripts.add_argument(
189          "--configfiles",
190          help="List of configfiles with data",
191          nargs="?",
192          action="append",
193          type=argparse.FileType("r"),
194      )
195      check_error_cmd = subparsers.add_parser("check_error", help="Checks eFuse errors")
196      check_error_cmd.add_argument(
197          "--recovery",
198          help="Recovery of BLOCKs after encoding errors",
199          action="store_true",
200      )
201  def add_force_write_always(p):
202      p.add_argument(
203          "--force-write-always",
204          help="Write the efuse even if it looks like it's already been written, "
205          "or is write protected. Note that this option can't disable write protection, "
206          "or clear any bit which has already been set.",
207          action="store_true",
208      )
209  def add_show_sensitive_info_option(p):
210      p.add_argument(
211          "--show-sensitive-info",
212          help="Show data to be burned (may expose sensitive data). "
213          "Enabled if --debug is used.",
214          action="store_true",
215          default=False,
216      )
217  def summary(esp, efuses, args):
218      ROW_FORMAT = "%-50s %-50s%s = %s %s %s"
219      human_output = args.format == "summary"
220      json_efuse = {}
221      if args.file != sys.stdout:
222          print("Saving efuse values to " + args.file.name)
223      if human_output:
224          print(
225              ROW_FORMAT.replace("-50", "-12")
226              % (
227                  "EFUSE_NAME (Block)",
228                  "Description",
229                  "",
230                  "[Meaningful Value]",
231                  "[Readable/Writeable]",
232                  "(Hex Value)",
233              ),
234              file=args.file,
235          )
236          print("-" * 88, file=args.file)
237      for category in sorted(set(e.category for e in efuses), key=lambda c: c.title()):
238          if human_output:
239              print("%s fuses:" % category.title(), file=args.file)
240          for e in (e for e in efuses if e.category == category):
241              if e.efuse_type.startswith("bytes"):
242                  raw = ""
243              else:
244                  raw = "({})".format(e.get_bitstring())
245              (readable, writeable) = (e.is_readable(), e.is_writeable())
246              if readable and writeable:
247                  perms = "R/W"
248              elif readable:
249                  perms = "R/-"
250              elif writeable:
251                  perms = "-/W"
252              else:
253                  perms = "-/-"
254              base_value = e.get_meaning()
255              value = str(base_value)
256              if not readable:
257                  count_read_disable_bits = e.get_count_read_disable_bits()
258                  if count_read_disable_bits == 2:
259                      v = [value[: (len(value) // 2)], value[(len(value) // 2) :]]
260                      for i in range(count_read_disable_bits):
261                          if not e.is_readable(blk_part=i):
262                              v[i] = v[i].replace("0", "?")
263                      value = "".join(v)
264                  else:
265                      value = value.replace("0", "?")
266              if human_output:
267                  print(
268                      ROW_FORMAT
269                      % (
270                          e.get_info(),
271                          e.description[:50],
272                          "\n  " if len(value) > 20 else "",
273                          value,
274                          perms,
275                          raw,
276                      ),
277                      file=args.file,
278                  )
279                  desc_len = len(e.description[50:])
280                  if desc_len:
281                      desc_len += 50
282                      for i in range(50, desc_len, 50):
283                          print(
284                              "%-50s %-50s" % ("", e.description[i : (50 + i)]),
285                              file=args.file,
286                          )
287              if args.format == "json":
288                  json_efuse[e.name] = {
289                      "name": e.name,
290                      "value": base_value if readable else value,
291                      "readable": readable,
292                      "writeable": writeable,
293                      "description": e.description,
294                      "category": e.category,
295                      "block": e.block,
296                      "word": e.word,
297                      "pos": e.pos,
298                      "efuse_type": e.efuse_type,
299                      "bit_len": e.bit_len,
300                  }
301          if human_output:
302              print("", file=args.file)
303      if human_output:
304          print(efuses.summary(), file=args.file)
305          warnings = efuses.get_coding_scheme_warnings()
306          if warnings:
307              print(
308                  "WARNING: Coding scheme has encoding bit error warnings", file=args.file
309              )
310          if args.file != sys.stdout:
311              args.file.close()
312              print("Done")
313      if args.format == "json":
314          json.dump(json_efuse, args.file, sort_keys=True, indent=4)
315          print("")
316  def dump(esp, efuses, args):
317      if args.file_name:
318          for block in efuses.blocks:
319              file_dump_name = args.file_name
320              place_for_index = file_dump_name.find(".bin")
321              file_dump_name = (
322                  file_dump_name[:place_for_index]
323                  + str(block.id)
324                  + file_dump_name[place_for_index:]
325              )
326              print(file_dump_name)
327              with open(file_dump_name, "wb") as f:
328                  block.get_bitstring().byteswap()
329                  block.get_bitstring().tofile(f)
330  def burn_efuse(esp, efuses, args):
331      def print_attention(blocked_efuses_after_burn):
332          if len(blocked_efuses_after_burn):
333              print(
334                  "    ATTENTION! This BLOCK uses NOT the NONE coding scheme "
335                  "and after 'BURN', these efuses can not be burned in the feature:"
336              )
337              for i in range(0, len(blocked_efuses_after_burn), 5):
338                  print(
339                      "              ",
340                      "".join("{}".format(blocked_efuses_after_burn[i : i + 5 :])),
341                  )
342      efuse_name_list = [name for name in args.name_value_pairs.keys()]
343      burn_efuses_list = [efuses[name] for name in efuse_name_list]
344      old_value_list = [efuses[name].get_raw() for name in efuse_name_list]
345      new_value_list = [value for value in args.name_value_pairs.values()]
346      util.check_duplicate_name_in_list(efuse_name_list)
347      attention = ""
348      print("The efuses to burn:")
349      for block in efuses.blocks:
350          burn_list_a_block = [e for e in burn_efuses_list if e.block == block.id]
351          if len(burn_list_a_block):
352              print("  from BLOCK%d" % (block.id))
353              for field in burn_list_a_block:
354                  print("     - %s" % (field.name))
355                  if (
356                      efuses.blocks[field.block].get_coding_scheme()
357                      != efuses.REGS.CODING_SCHEME_NONE
358                  ):
359                      using_the_same_block_names = [
360                          e.name for e in efuses if e.block == field.block
361                      ]
362                      wr_names = [e.name for e in burn_list_a_block]
363                      blocked_efuses_after_burn = [
364                          name
365                          for name in using_the_same_block_names
366                          if name not in wr_names
367                      ]
368                      attention = " (see 'ATTENTION!' above)"
369              if attention:
370                  print_attention(blocked_efuses_after_burn)
371      print("\nBurning efuses{}:".format(attention))
372      for efuse, new_value in zip(burn_efuses_list, new_value_list):
373          print(
374              "\n    - '{}' ({}) {} -> {}".format(
375                  efuse.name,
376                  efuse.description,
377                  efuse.get_bitstring(),
378                  efuse.convert_to_bitstring(new_value),
379              )
380          )
381          efuse.save(new_value)
382      print()
383      if "ENABLE_SECURITY_DOWNLOAD" in efuse_name_list:
384          print(
385              "ENABLE_SECURITY_DOWNLOAD -> 1: eFuses will not be read back "
386              "for confirmation because this mode disables "
387              "any SRAM and register operations."
388          )
389          print("                               espefuse will not work.")
390          print("                               esptool can read/write only flash.")
391      if "DIS_DOWNLOAD_MODE" in efuse_name_list:
392          print(
393              "DIS_DOWNLOAD_MODE -> 1: eFuses will not be read back for "
394              "confirmation because this mode disables any communication with the chip."
395          )
396          print(
397              "                        espefuse/esptool will not work because "
398              "they will not be able to connect to the chip."
399          )
400      if (
401          esp.CHIP_NAME == "ESP32"
402          and esp.get_chip_revision() >= 300
403          and "UART_DOWNLOAD_DIS" in efuse_name_list
404      ):
405          print(
406              "UART_DOWNLOAD_DIS -> 1: eFuses will be read for confirmation, "
407              "but after that connection to the chip will become impossible."
408          )
409          print("                        espefuse/esptool will not work.")
410      if not efuses.burn_all(check_batch_mode=True):
411          return
412      print("Checking efuses...")
413      raise_error = False
414      for efuse, old_value, new_value in zip(
415          burn_efuses_list, old_value_list, new_value_list
416      ):
417          if not efuse.is_readable():
418              print(
419                  "Efuse %s is read-protected. Read back the burn value is not possible."
420                  % efuse.name
421              )
422          else:
423              new_value = efuse.convert_to_bitstring(new_value)
424              burned_value = efuse.get_bitstring()
425              if burned_value != new_value:
426                  print(
427                      burned_value,
428                      "->",
429                      new_value,
430                      "Efuse %s failed to burn. Protected?" % efuse.name,
431                  )
432                  raise_error = True
433      if raise_error:
434          raise esptool.FatalError("The burn was not successful.")
435      else:
436          print("Successful")
437  def read_protect_efuse(esp, efuses, args):
438      util.check_duplicate_name_in_list(args.efuse_name)
439      for efuse_name in args.efuse_name:
440          efuse = efuses[efuse_name]
441          if not efuse.is_readable():
442              print("Efuse %s is already read protected" % efuse.name)
443          else:
444              if esp.CHIP_NAME == "ESP32":
445                  if (
446                      efuse_name == "BLOCK2"
447                      and not efuses["ABS_DONE_0"].get()
448                      and esp.get_chip_revision() >= 300
449                  ):
450                      if efuses["ABS_DONE_1"].get():
451                          raise esptool.FatalError(
452                              "Secure Boot V2 is on (ABS_DONE_1 = True), "
453                              "BLOCK2 must be readable, stop this operation!"
454                          )
455                      else:
456                          print(
457                              "If Secure Boot V2 is used, BLOCK2 must be readable, "
458                              "please stop this operation!"
459                          )
460              elif esp.CHIP_NAME == "ESP32-C2":
461                  error = (
462                      not efuses["XTS_KEY_LENGTH_256"].get()
463                      and efuse_name == "BLOCK_KEY0"
464                  )
465                  error |= efuses["SECURE_BOOT_EN"].get() and efuse_name in [
466                      "BLOCK_KEY0",
467                      "BLOCK_KEY0_HI_128",
468                  ]
469                  if error:
470                      raise esptool.FatalError(
471                          "%s must be readable, stop this operation!" % efuse_name
472                      )
473              else:
474                  for block in efuses.Blocks.BLOCKS:
475                      block = efuses.Blocks.get(block)
476                      if block.name == efuse_name and block.key_purpose is not None:
477                          if not efuses[block.key_purpose].need_rd_protect(
478                              efuses[block.key_purpose].get()
479                          ):
480                              raise esptool.FatalError(
481                                  "%s must be readable, stop this operation!" % efuse_name
482                              )
483                          break
484              all_disabling = [
485                  e for e in efuses if e.read_disable_bit == efuse.read_disable_bit
486              ]
487              names = ", ".join(e.name for e in all_disabling)
488              print(
489                  "Permanently read-disabling efuse%s %s"
490                  % ("s" if len(all_disabling) > 1 else "", names)
491              )
492              efuse.disable_read()
493      if not efuses.burn_all(check_batch_mode=True):
494          return
495      print("Checking efuses...")
496      raise_error = False
497      for efuse_name in args.efuse_name:
498          efuse = efuses[efuse_name]
499          if efuse.is_readable():
500              print("Efuse %s is not read-protected." % efuse.name)
501              raise_error = True
502      if raise_error:
503          raise esptool.FatalError("The burn was not successful.")
504      else:
505          print("Successful")
506  def write_protect_efuse(esp, efuses, args):
507      util.check_duplicate_name_in_list(args.efuse_name)
508      for efuse_name in args.efuse_name:
509          efuse = efuses[efuse_name]
510          if not efuse.is_writeable():
511              print("Efuse %s is already write protected" % efuse.name)
512          else:
513              all_disabling = [
514                  e for e in efuses if e.write_disable_bit == efuse.write_disable_bit
515              ]
516              names = ", ".join(e.name for e in all_disabling)
517              print(
518                  "Permanently write-disabling efuse%s %s"
519                  % ("s" if len(all_disabling) > 1 else "", names)
520              )
521              efuse.disable_write()
522      if not efuses.burn_all(check_batch_mode=True):
523          return
524      print("Checking efuses...")
525      raise_error = False
526      for efuse_name in args.efuse_name:
527          efuse = efuses[efuse_name]
528          if efuse.is_writeable():
529              print("Efuse %s is not write-protected." % efuse.name)
530              raise_error = True
531      if raise_error:
532          raise esptool.FatalError("The burn was not successful.")
533      else:
534          print("Successful")
535  def burn_block_data(esp, efuses, args):
<span onclick='openModal()' class='match'>536      block_name_list = args.block[
537          0 : len([name for name in args.block if name is not None]) :
538      ]
539      datafile_list = args.datafile[
540          0 : len([name for name in args.datafile if name is not None]) :
</span>541      ]
542      efuses.force_write_always = args.force_write_always
543      util.check_duplicate_name_in_list(block_name_list)
544      if args.offset and len(block_name_list) > 1:
545          raise esptool.FatalError(
546              "The 'offset' option is not applicable when a few blocks are passed. "
547              "With 'offset', should only one block be used."
548          )
549      else:
550          offset = args.offset
551          if offset:
552              num_block = efuses.get_index_block_by_name(block_name_list[0])
553              block = efuses.blocks[num_block]
554              num_bytes = block.get_block_len()
555              if offset >= num_bytes:
556                  raise esptool.FatalError(
557                      "Invalid offset: the block%d only holds %d bytes."
558                      % (block.id, num_bytes)
559                  )
560      if len(block_name_list) != len(datafile_list):
561          raise esptool.FatalError(
562              "The number of block_name (%d) and datafile (%d) should be the same."
563              % (len(block_name_list), len(datafile_list))
564          )
565      for block_name, datafile in zip(block_name_list, datafile_list):
566          num_block = efuses.get_index_block_by_name(block_name)
567          block = efuses.blocks[num_block]
568          data = datafile.read()
569          num_bytes = block.get_block_len()
570          if offset != 0:
571              data = (b"\x00" * offset) + data
572              data = data + (b"\x00" * (num_bytes - len(data)))
573          if len(data) != num_bytes:
574              raise esptool.FatalError(
575                  "Data does not fit: the block%d size is %d bytes, "
576                  "data file is %d bytes, offset %d"
577                  % (block.id, num_bytes, len(data), offset)
578              )
579          print(
580              "[{:02}] {:20} size={:02} bytes, offset={:02} - > [{}].".format(
581                  block.id, block.name, len(data), offset, util.hexify(data, " ")
582              )
583          )
584          block.save(data)
585      if not efuses.burn_all(check_batch_mode=True):
586          return
587      print("Successful")
588  def burn_bit(esp, efuses, args):
589      efuses.force_write_always = args.force_write_always
590      num_block = efuses.get_index_block_by_name(args.block)
591      block = efuses.blocks[num_block]
592      data_block = BitStream(block.get_block_len() * 8)
593      data_block.set(0)
594      try:
595          data_block.set(True, args.bit_number)
596      except IndexError:
597          raise esptool.FatalError(
598              "%s has bit_number in [0..%d]" % (args.block, data_block.len - 1)
599          )
600      data_block.reverse()
601      print(
602          "bit_number:   "
603          "[%-03d]........................................................[0]"
604          % (data_block.len - 1)
605      )
606      print("BLOCK%-2d   :" % block.id, data_block)
607      block.print_block(data_block, "regs_to_write", debug=True)
608      block.save(data_block.bytes[::-1])
609      if not efuses.burn_all(check_batch_mode=True):
610          return
611      print("Successful")
612  def get_error_summary(efuses):
613      error_in_blocks = efuses.get_coding_scheme_warnings()
614      if not error_in_blocks:
615          return False
616      writable = True
617      for blk in efuses.blocks:
618          if blk.fail or blk.num_errors:
619              if blk.id == 0:
620                  for field in efuses:
621                      if field.block == blk.id and (field.fail or field.num_errors):
622                          wr = "writable" if field.is_writeable() else "not writable"
623                          writable &= wr == "writable"
624                          name = field.name
625                          val = field.get()
626                          print(f"BLOCK{field.block:<2}: {name:<40} = {val:<8} ({wr})")
627              else:
628                  wr = "writable" if blk.is_writeable() else "not writable"
629                  writable &= wr == "writable"
630                  name = f"{blk.name} [ERRORS:{blk.num_errors} FAIL:{int(blk.fail)}]"
631                  val = str(blk.get_bitstring())
632                  print(f"BLOCK{blk.id:<2}: {name:<40} = {val:<8} ({wr})")
633      if not writable and error_in_blocks:
634          print("Not all errors can be fixed because some fields are write-protected!")
635      return True
636  def check_error(esp, efuses, args):
637      error_in_blocks = get_error_summary(efuses)
638      if args.recovery and error_in_blocks:
639          confirmed = False
640          for block in reversed(efuses.blocks):
641              if block.fail or block.num_errors > 0:
642                  if not block.get_bitstring().all(False):
643                      block.save(block.get_bitstring().bytes[::-1])
644                      if not confirmed:
645                          confirmed = True
646                          efuses.confirm(
647                              "Recovery of block coding errors", args.do_not_confirm
648                          )
649                      block.burn()
650          if confirmed:
651              efuses.update_efuses()
652          error_in_blocks = get_error_summary(efuses)
653      if error_in_blocks:
654          raise esptool.FatalError("Error(s) were detected in eFuses")
655      print("No errors detected")
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-optimizer_tests.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_operations.py</div>
                </div>
                <div class="column column_space"><pre><code>32      parameters = [tf.Variable([1., 2.]), tf.Variable([3., 4.])]
33      updates = [tf.constant([5., 5.])]
</pre></code></div>
                <div class="column column_space"><pre><code>536      block_name_list = args.block[
537          0 : len([name for name in args.block if name is not None]) :
538      ]
539      datafile_list = args.datafile[
540          0 : len([name for name in args.datafile if name is not None]) :
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    