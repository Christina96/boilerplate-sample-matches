<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_udev.py & test_mac_keychain.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_udev.py & test_mac_keychain.py
      </h3>
      <h1 align="center">
        6.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_udev.py (11.764706%)<TH>test_mac_keychain.py (4.2704625%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match44279-0.html#0',2,'match44279-1.html#0',3)" NAME="0">(164-166)<TD><A HREF="javascript:ZweiFrames('match44279-0.html#0',2,'match44279-1.html#0',3)" NAME="0">(269-280)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_udev.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Pablo Su√°rez Hdez. &lt;psuarezhernandez@suse.de&gt;
&quot;&quot;&quot;


import salt.modules.udev as udev
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase


class UdevTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.modules.udev
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        return {udev: {}}

    # 'info' function tests: 1

    def test_info(self):
        &quot;&quot;&quot;
        Test if it returns the info of udev-created node in a dict
        &quot;&quot;&quot;
        cmd_out = {
            &quot;retcode&quot;: 0,
            &quot;stdout&quot;: (
                &quot;P: /devices/virtual/vc/vcsa7\n&quot;
                &quot;N: vcsa7\n&quot;
                &quot;E: DEVNAME=/dev/vcsa7\n&quot;
                &quot;E: DEVPATH=/devices/virtual/vc/vcsa7\n&quot;
                &quot;E: MAJOR=7\n&quot;
                &quot;E: MINOR=135\n&quot;
                &quot;E: SUBSYSTEM=vc\n&quot;
                &quot;\n&quot;
            ),
            &quot;stderr&quot;: &quot;&quot;,
        }

        ret = {
            &quot;E&quot;: {
                &quot;DEVNAME&quot;: &quot;/dev/vcsa7&quot;,
                &quot;DEVPATH&quot;: &quot;/devices/virtual/vc/vcsa7&quot;,
                &quot;MAJOR&quot;: 7,
                &quot;MINOR&quot;: 135,
                &quot;SUBSYSTEM&quot;: &quot;vc&quot;,
            },
            &quot;N&quot;: &quot;vcsa7&quot;,
            &quot;P&quot;: &quot;/devices/virtual/vc/vcsa7&quot;,
        }

        mock = MagicMock(return_value=cmd_out)
        with patch.dict(udev.__salt__, {&quot;cmd.run_all&quot;: mock}):
            data = udev.info(&quot;/dev/vcsa7&quot;)

            assert ret[&quot;P&quot;] == data[&quot;P&quot;]
            assert ret.get(&quot;N&quot;) == data.get(&quot;N&quot;)
            for key, value in data[&quot;E&quot;].items():
                assert ret[&quot;E&quot;][key] == value

    # 'exportdb' function tests: 1

    def test_exportdb(self):
        &quot;&quot;&quot;
        Test if it returns the all the udev database into a dict
        &quot;&quot;&quot;
        udev_data = &quot;&quot;&quot;
P: /devices/LNXSYSTM:00/LNXPWRBN:00
E: DEVPATH=/devices/LNXSYSTM:00/LNXPWRBN:00
E: DRIVER=button
E: MODALIAS=acpi:LNXPWRBN:
E: SUBSYSTEM=acpi

P: /devices/LNXSYSTM:00/LNXPWRBN:00/input/input2
E: DEVPATH=/devices/LNXSYSTM:00/LNXPWRBN:00/input/input2
E: EV=3
E: ID_FOR_SEAT=input-acpi-LNXPWRBN_00
E: ID_INPUT=1
E: ID_INPUT_KEY=1
E: ID_PATH=acpi-LNXPWRBN:00
E: ID_PATH_TAG=acpi-LNXPWRBN_00
E: KEY=10000000000000 0
E: MODALIAS=input:b0019v0000p0001e0000-e0,1,k74,ramlsfw
E: NAME=&quot;Power Button&quot;
E: PHYS=&quot;LNXPWRBN/button/input0&quot;
E: PRODUCT=19/0/1/0
E: PROP=0
E: SUBSYSTEM=input
E: TAGS=:seat:
E: USEC_INITIALIZED=2010022

P: /devices/LNXSYSTM:00/LNXPWRBN:00/input/input2/event2
N: input/event2
E: BACKSPACE=guess
E: DEVNAME=/dev/input/event2
E: DEVPATH=/devices/LNXSYSTM:00/LNXPWRBN:00/input/input2/event2
E: ID_INPUT=1
E: ID_INPUT_KEY=1
E: ID_PATH=acpi-LNXPWRBN:00
E: ID_PATH_TAG=acpi-LNXPWRBN_00
E: MAJOR=13
E: MINOR=66
E: SUBSYSTEM=input
E: TAGS=:power-switch:
E: USEC_INITIALIZED=2076101
E: XKBLAYOUT=us
E: XKBMODEL=pc105
    &quot;&quot;&quot;

        out = [
            {
                &quot;P&quot;: &quot;/devices/LNXSYSTM:00/LNXPWRBN:00&quot;,
                &quot;E&quot;: {
                    &quot;MODALIAS&quot;: &quot;acpi:LNXPWRBN:&quot;,
                    &quot;SUBSYSTEM&quot;: &quot;acpi&quot;,
                    &quot;DRIVER&quot;: &quot;button&quot;,
                    &quot;DEVPATH&quot;: &quot;/devices/LNXSYSTM:00/LNXPWRBN:00&quot;,
                },
            },
            {
                &quot;P&quot;: &quot;/devices/LNXSYSTM:00/LNXPWRBN:00/input/input2&quot;,
                &quot;E&quot;: {
                    &quot;SUBSYSTEM&quot;: &quot;input&quot;,
                    &quot;PRODUCT&quot;: &quot;19/0/1/0&quot;,
                    &quot;PHYS&quot;: '&quot;LNXPWRBN/button/input0&quot;',
                    &quot;NAME&quot;: '&quot;Power Button&quot;',
                    &quot;ID_INPUT&quot;: 1,
                    &quot;DEVPATH&quot;: &quot;/devices/LNXSYSTM:00/LNXPWRBN:00/input/input2&quot;,
                    &quot;MODALIAS&quot;: &quot;input:b0019v0000p0001e0000-e0,1,k74,ramlsfw&quot;,
                    &quot;ID_PATH_TAG&quot;: &quot;acpi-LNXPWRBN_00&quot;,
                    &quot;TAGS&quot;: &quot;:seat:&quot;,
                    &quot;PROP&quot;: 0,
                    &quot;ID_FOR_SEAT&quot;: &quot;input-acpi-LNXPWRBN_00&quot;,
                    &quot;KEY&quot;: &quot;10000000000000 0&quot;,
                    &quot;USEC_INITIALIZED&quot;: 2010022,
                    &quot;ID_PATH&quot;: &quot;acpi-LNXPWRBN:00&quot;,
                    &quot;EV&quot;: 3,
                    &quot;ID_INPUT_KEY&quot;: 1,
                },
            },
            {
                &quot;P&quot;: &quot;/devices/LNXSYSTM:00/LNXPWRBN:00/input/input2/event2&quot;,
                &quot;E&quot;: {
                    &quot;SUBSYSTEM&quot;: &quot;input&quot;,
                    &quot;XKBLAYOUT&quot;: &quot;us&quot;,
                    &quot;MAJOR&quot;: 13,
                    &quot;ID_INPUT&quot;: 1,
                    &quot;DEVPATH&quot;: &quot;/devices/LNXSYSTM:00/LNXPWRBN:00/input/input2/event2&quot;,
                    &quot;ID_PATH_TAG&quot;: &quot;acpi-LNXPWRBN_00&quot;,
                    &quot;DEVNAME&quot;: &quot;/dev/input/event2&quot;,
                    &quot;TAGS&quot;: &quot;:power-switch:&quot;,
                    &quot;BACKSPACE&quot;: &quot;guess&quot;,
                    &quot;MINOR&quot;: 66,
                    &quot;USEC_INITIALIZED&quot;: 2076101,
                    &quot;ID_PATH&quot;: &quot;acpi-LNXPWRBN:00&quot;,
                    &quot;XKBMODEL&quot;: &quot;pc105&quot;,
                    &quot;ID_INPUT_KEY&quot;: 1,
                },
                &quot;N&quot;: &quot;input/event2&quot;,
<A NAME="0"></A>            },
        ]

        mock <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match44279-1.html#0',3,'match44279-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: udev_data})
        with patch.dict(udev.__salt__, {&quot;cmd.run_all&quot;: mock}):
            data = udev.exportdb(</B></FONT>)
            assert data == [x for x in data if x]

            for d_idx, d_section in enumerate(data):
                assert out[d_idx][&quot;P&quot;] == d_section[&quot;P&quot;]
                assert out[d_idx].get(&quot;N&quot;) == d_section.get(&quot;N&quot;)
                for key, value in d_section[&quot;E&quot;].items():
                    assert out[d_idx][&quot;E&quot;][key] == value

    def test_normalize_info(self):
        &quot;&quot;&quot;
        Test if udevdb._normalize_info does not returns nested lists that contains only one item.

        :return:
        &quot;&quot;&quot;
        data = {&quot;key&quot;: [&quot;value&quot;, &quot;here&quot;], &quot;foo&quot;: [&quot;bar&quot;], &quot;some&quot;: &quot;data&quot;}
        assert udev._normalize_info(data) == {
            &quot;foo&quot;: &quot;bar&quot;,
            &quot;some&quot;: &quot;data&quot;,
            &quot;key&quot;: [&quot;value&quot;, &quot;here&quot;],
        }
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mac_keychain.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest
import salt.states.mac_keychain as keychain
from tests.support.mock import MagicMock, call, patch


@pytest.fixture
def configure_loader_modules():
    return {keychain: {}}


def test_install_cert():
    &quot;&quot;&quot;
    Test installing a certificate into the macOS keychain
    &quot;&quot;&quot;
    expected = {
        &quot;changes&quot;: {&quot;installed&quot;: &quot;Friendly Name&quot;},
        &quot;comment&quot;: &quot;&quot;,
        &quot;name&quot;: &quot;/path/to/cert.p12&quot;,
        &quot;result&quot;: True,
    }

    list_mock = MagicMock(return_value=[&quot;Cert1&quot;])
    friendly_mock = MagicMock(return_value=&quot;Friendly Name&quot;)
    install_mock = MagicMock(return_value=&quot;1 identity imported.&quot;)
    with patch.dict(
        keychain.__salt__,
        {
            &quot;keychain.list_certs&quot;: list_mock,
            &quot;keychain.get_friendly_name&quot;: friendly_mock,
            &quot;keychain.install&quot;: install_mock,
        },
    ):
        out = keychain.installed(&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        list_mock.assert_called_once_with(&quot;/Library/Keychains/System.keychain&quot;)
        friendly_mock.assert_called_once_with(&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        install_mock.assert_called_once_with(
            &quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;, &quot;/Library/Keychains/System.keychain&quot;
        )
        assert out == expected


def test_installed_cert():
    &quot;&quot;&quot;
    Test installing a certificate into the macOS keychain when it's
    already installed
    &quot;&quot;&quot;
    expected = {
        &quot;changes&quot;: {},
        &quot;comment&quot;: &quot;Friendly Name already installed.&quot;,
        &quot;name&quot;: &quot;/path/to/cert.p12&quot;,
        &quot;result&quot;: True,
    }

    list_mock = MagicMock(return_value=[&quot;Friendly Name&quot;])
    friendly_mock = MagicMock(return_value=&quot;Friendly Name&quot;)
    install_mock = MagicMock(return_value=&quot;1 identity imported.&quot;)
    hash_mock = MagicMock(return_value=&quot;ABCD&quot;)
    with patch.dict(
        keychain.__salt__,
        {
            &quot;keychain.list_certs&quot;: list_mock,
            &quot;keychain.get_friendly_name&quot;: friendly_mock,
            &quot;keychain.install&quot;: install_mock,
            &quot;keychain.get_hash&quot;: hash_mock,
        },
    ):
        out = keychain.installed(&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        list_mock.assert_called_once_with(&quot;/Library/Keychains/System.keychain&quot;)
        friendly_mock.assert_called_once_with(&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        assert not install_mock.called
        assert out == expected


def test_uninstall_cert():
    &quot;&quot;&quot;
    Test uninstalling a certificate into the macOS keychain when it's
    already installed
    &quot;&quot;&quot;
    expected = {
        &quot;changes&quot;: {&quot;uninstalled&quot;: &quot;Friendly Name&quot;},
        &quot;comment&quot;: &quot;&quot;,
        &quot;name&quot;: &quot;/path/to/cert.p12&quot;,
        &quot;result&quot;: True,
    }

    list_mock = MagicMock(return_value=[&quot;Friendly Name&quot;])
    friendly_mock = MagicMock(return_value=&quot;Friendly Name&quot;)
    uninstall_mock = MagicMock(return_value=&quot;1 identity imported.&quot;)
    with patch.dict(
        keychain.__salt__,
        {
            &quot;keychain.list_certs&quot;: list_mock,
            &quot;keychain.get_friendly_name&quot;: friendly_mock,
            &quot;keychain.uninstall&quot;: uninstall_mock,
        },
    ):
        out = keychain.uninstalled(&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        list_mock.assert_called_once_with(&quot;/Library/Keychains/System.keychain&quot;)
        friendly_mock.assert_called_once_with(&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        uninstall_mock.assert_called_once_with(
            &quot;Friendly Name&quot;, &quot;/Library/Keychains/System.keychain&quot;, None
        )
        assert out == expected


def test_uninstalled_cert():
    &quot;&quot;&quot;
    Test uninstalling a certificate into the macOS keychain when it's
    not installed
    &quot;&quot;&quot;
    expected = {
        &quot;changes&quot;: {},
        &quot;comment&quot;: &quot;Friendly Name already uninstalled.&quot;,
        &quot;name&quot;: &quot;/path/to/cert.p12&quot;,
        &quot;result&quot;: True,
    }

    list_mock = MagicMock(return_value=[&quot;Cert2&quot;])
    friendly_mock = MagicMock(return_value=&quot;Friendly Name&quot;)
    uninstall_mock = MagicMock(return_value=&quot;1 identity imported.&quot;)
    with patch.dict(
        keychain.__salt__,
        {
            &quot;keychain.list_certs&quot;: list_mock,
            &quot;keychain.get_friendly_name&quot;: friendly_mock,
            &quot;keychain.uninstall&quot;: uninstall_mock,
        },
    ):
        out = keychain.uninstalled(&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        list_mock.assert_called_once_with(&quot;/Library/Keychains/System.keychain&quot;)
        friendly_mock.assert_called_once_with(&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        assert not uninstall_mock.called
        assert out == expected


def test_default_keychain():
    &quot;&quot;&quot;
    Test setting the default keychain
    &quot;&quot;&quot;
    with patch(&quot;os.path.exists&quot;) as exists_mock:
        expected = {
            &quot;changes&quot;: {&quot;default&quot;: &quot;/path/to/chain.keychain&quot;},
            &quot;comment&quot;: &quot;&quot;,
            &quot;name&quot;: &quot;/path/to/chain.keychain&quot;,
            &quot;result&quot;: True,
        }

        exists_mock.return_value = True
        get_default_mock = MagicMock(return_value=&quot;/path/to/other.keychain&quot;)
        set_mock = MagicMock(return_value=&quot;&quot;)
        with patch.dict(
            keychain.__salt__,
            {
                &quot;keychain.get_default_keychain&quot;: get_default_mock,
                &quot;keychain.set_default_keychain&quot;: set_mock,
            },
        ):
            out = keychain.default_keychain(
                &quot;/path/to/chain.keychain&quot;, &quot;system&quot;, &quot;frank&quot;
            )
            get_default_mock.assert_called_once_with(&quot;frank&quot;, &quot;system&quot;)
            set_mock.assert_called_once_with(
                &quot;/path/to/chain.keychain&quot;, &quot;system&quot;, &quot;frank&quot;
            )
            assert out == expected


def test_default_keychain_set_already():
    &quot;&quot;&quot;
    Test setting the default keychain when it's already set
    &quot;&quot;&quot;
    with patch(&quot;os.path.exists&quot;) as exists_mock:
        expected = {
            &quot;changes&quot;: {},
            &quot;comment&quot;: &quot;/path/to/chain.keychain was already the default keychain.&quot;,
            &quot;name&quot;: &quot;/path/to/chain.keychain&quot;,
            &quot;result&quot;: True,
        }

        exists_mock.return_value = True
        get_default_mock = MagicMock(return_value=&quot;/path/to/chain.keychain&quot;)
        set_mock = MagicMock(return_value=&quot;&quot;)
        with patch.dict(
            keychain.__salt__,
            {
                &quot;keychain.get_default_keychain&quot;: get_default_mock,
                &quot;keychain.set_default_keychain&quot;: set_mock,
            },
        ):
            out = keychain.default_keychain(
                &quot;/path/to/chain.keychain&quot;, &quot;system&quot;, &quot;frank&quot;
            )
            get_default_mock.assert_called_once_with(&quot;frank&quot;, &quot;system&quot;)
            assert not set_mock.called
            assert out == expected


def test_default_keychain_missing():
    &quot;&quot;&quot;
    Test setting the default keychain when the keychain is missing
    &quot;&quot;&quot;
    with patch(&quot;os.path.exists&quot;) as exists_mock:
        expected = {
            &quot;changes&quot;: {},
            &quot;comment&quot;: &quot;Keychain not found at /path/to/cert.p12&quot;,
            &quot;name&quot;: &quot;/path/to/cert.p12&quot;,
            &quot;result&quot;: False,
        }

        exists_mock.return_value = False
        out = keychain.default_keychain(&quot;/path/to/cert.p12&quot;, &quot;system&quot;, &quot;frank&quot;)
        assert out == expected


def test_install_cert_salt_fileserver():
    &quot;&quot;&quot;
    Test installing a certificate into the macOS keychain from the salt
    fileserver
    &quot;&quot;&quot;
    expected = {
        &quot;changes&quot;: {&quot;installed&quot;: &quot;Friendly Name&quot;},
        &quot;comment&quot;: &quot;&quot;,
        &quot;name&quot;: &quot;salt://path/to/cert.p12&quot;,
        &quot;result&quot;: True,
    }

    list_mock = MagicMock(return_value=[&quot;Cert1&quot;])
    friendly_mock = MagicMock(return_value=&quot;Friendly Name&quot;)
    install_mock = MagicMock(return_value=&quot;1 identity imported.&quot;)
    cp_cache_mock = MagicMock(return_value=&quot;/tmp/path/to/cert.p12&quot;)
    with patch.dict(
        keychain.__salt__,
        {
            &quot;keychain.list_certs&quot;: list_mock,
            &quot;keychain.get_friendly_name&quot;: friendly_mock,
            &quot;keychain.install&quot;: install_mock,
            &quot;cp.cache_file&quot;: cp_cache_mock,
        },
    ):
        out = keychain.installed(&quot;salt://path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        list_mock.assert_called_once_with(&quot;/Library/Keychains/System.keychain&quot;)
        friendly_mock.assert_called_once_with(&quot;/tmp/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        install_mock.assert_called_once_with(
            &quot;/tmp/path/to/cert.p12&quot;,
            &quot;passw0rd&quot;,
            &quot;/Library/Keychains/System.keychain&quot;,
        )
        assert out == expected


def test_installed_cert_hash_different():
    &quot;&quot;&quot;
    Test installing a certificate into the macOS keychain when it's
    already installed but the certificate has changed
    &quot;&quot;&quot;
    expected = {
        &quot;changes&quot;: {&quot;installed&quot;: &quot;Friendly Name&quot;, &quot;uninstalled&quot;: &quot;Friendly Name&quot;},
        &quot;comment&quot;: (
            &quot;Found a certificate with the same name but different hash, removing it.\n&quot;
        ),
        &quot;name&quot;: &quot;/path/to/cert.p12&quot;,
        &quot;result&quot;: True,
    }

    list_mock = MagicMock(side_effect=[[&quot;Friendly Name&quot;], []])
<A NAME="0"></A>    friendly_mock = MagicMock(return_value=&quot;Friendly Name&quot;)
    install_mock = MagicMock(return_value=&quot;1 identity imported.&quot;)
    uninstall_mock = MagicMock(return_value=&quot;removed.&quot;)
    hash_mock <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44279-0.html#0',2,'match44279-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= MagicMock(side_effect=[&quot;ABCD&quot;, &quot;XYZ&quot;])
    with patch.dict(
        keychain.__salt__,
        {
            &quot;keychain.list_certs&quot;: list_mock,
            &quot;keychain.get_friendly_name&quot;: friendly_mock,
            &quot;keychain.install&quot;: install_mock,
            &quot;keychain.uninstall&quot;: uninstall_mock,
            &quot;keychain.get_hash&quot;: hash_mock,
        },
    ):
        out = keychain.installed(</B></FONT>&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        list_mock.assert_has_calls(
            calls=[
                call(&quot;/Library/Keychains/System.keychain&quot;),
                call(&quot;/Library/Keychains/System.keychain&quot;),
            ]
        )
        friendly_mock.assert_called_once_with(&quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;)
        install_mock.assert_called_once_with(
            &quot;/path/to/cert.p12&quot;, &quot;passw0rd&quot;, &quot;/Library/Keychains/System.keychain&quot;
        )
        uninstall_mock.assert_called_once_with(
            &quot;Friendly Name&quot;,
            &quot;/Library/Keychains/System.keychain&quot;,
            keychain_password=None,
        )
        assert out == expected
</PRE>
</div>
  </div>
</body>
</html>
