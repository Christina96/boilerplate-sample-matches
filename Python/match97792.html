<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for __init___43.py &amp; virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for __init___43.py &amp; virt_1.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>__init___43.py (8.4535055%)<th>virt_1.py (2.1915689%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(117-137)<td><a href="#" name="0">(4072-4091)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(7-29)<td><a href="#" name="1">(131-155)</a><td align="center"><font color="#f30000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(101-104)<td><a href="#" name="2">(438-441)</a><td align="center"><font color="#a20000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(618-622)<td><a href="#" name="3">(2955-2958)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(468-471)<td><a href="#" name="4">(6822-6827)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(354-359)<td><a href="#" name="5">(1465-1470)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(335-341)<td><a href="#" name="6">(214-224)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(265-270)<td><a href="#" name="7">(1512-1521)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(765-767)<td><a href="#" name="8">(1473-1475)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(255-259)<td><a href="#" name="9">(8720-8724)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(252-254)<td><a href="#" name="10">(6426-6430)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(193-202)<td><a href="#" name="11">(1594-1596)</a><td align="center"><font color="#8b0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___43.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import hashlib
2 import logging
3 import os
4 import shutil
5 import sys
6 import tarfile
7 import salt.cache
8 import salt.client
9 import salt.config
10 import salt.loader
11 import salt.syspaths as syspaths
12 import salt.utils.files
13 import salt.utils.http as http
14 import salt.utils.path
15 import salt.utils.platform
16 import salt.utils.win_functions
17 import salt.utils.yaml
18 from salt.template import compile_template
19 try:
20     import pwd
21     import</b></font> grp
22 except ImportError:
23     pass
24 log = logging.getLogger(__name__)
25 FILE_TYPES = ("c", "d", "g", "l", "r", "s", "m")
26 class SPMException(Exception):
27 class SPMInvocationError(SPMException):
28 class SPMPackageError(SPMException):
29 class SPMDatabaseError(SPMException):
30 class SPMOperationCanceled(SPMException):
31 class SPMClient:
32     def __init__(self, ui, opts=None):  # pylint: disable=W0231
33         self.ui = ui
34         if not opts:
35             opts = salt.config.spm_config(os.path.join(syspaths.CONFIG_DIR, "spm"))
36         self.opts = opts
37         self.db_prov = self.opts.get("spm_db_provider", "sqlite3")
38         self.files_prov = self.opts.get("spm_files_provider", "local")
39         self._prep_pkgdb()
40         self._prep_pkgfiles()
41         self.db_conn = None
42         self.files_conn = None
43         self._init()
44     def _prep_pkgdb(self):
45         self.pkgdb = salt.loader.pkgdb(self.opts)
46     def _prep_pkgfiles(self):
47     def _init(self):
48         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not self.db_conn:
49             self.db_conn = self._pkgdb_fun("init")
50         if not self.files_conn:
51             self.files_conn = self._pkgfiles_fun(</b></font>"init")
52     def _close(self):
53         if self.db_conn:
54             self.db_conn.close()
55     def run(self, args):
56         try:
57             if command == "install":
58                 self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._install(args)
59             elif command == "local":
60                 self._local(args)
61             elif command == "repo":
62                 self._repo(args)
63             elif command == "remove":
64                 self._remove(args)
65             elif command == "build":
66                 self._build(args)
67             elif command == "update_repo":
68                 self._download_repo_metadata(args)
69             elif command == "create_repo":
70                 self._create_repo(args)
71             elif command == "files":
72                 self._list_files(args)
73             elif command == "info":
74                 self._info(args)
75             elif command == "list":
76                 self._list(args)
77             elif command == "close":
78                 self._close(</b></font>)
79             else:
80                 raise SPMInvocationError("Invalid command '{}'".format(command))
81         except SPMException as exc:
82             self.ui.error(str(exc))
83     def _pkgdb_fun(self, func, *args, **kwargs):
84         try:
85             return getattr(getattr(self.pkgdb, self.db_prov), func)(*args, **kwargs)
86         except AttributeError:
87             return self.pkgdb["{}.{}".format(self.db_prov, func)](*args, **kwargs)
88     def _pkgfiles_fun(self, func, *args, **kwargs):
89         try:
90             return getattr(getattr(self.pkgfiles, self.files_prov), func)(
91                 *args, **kwargs
92             )
93         except AttributeError:
94             return self.pkgfiles["{}.{}".format(self.files_prov, func)](*args, **kwargs)
95     def _list(self, args):
96         args.pop(0)
97         command = args[0]
98         if command == "packages":
99             self._list_packages(args)
100         elif command == "files":
101             self._list_files(args)
102         elif command == "repos":
103             self._repo_list(args)
104         else:
105             raise SPMInvocationError("Invalid list command '{}'".format(command))
106     def _local(self, args):
107         args.pop(0)
108         command = args[0]
109         if command == "install":
110             self._local_install(args)
111         elif command == "files":
112             self._local_list_files(args)
113         elif command == "info":
114             self._local_info(args)
115         else:
116             raise SPMInvocationError("Invalid local command '{}'".format(command))
117     def _repo(self, args):
118         """
119         <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if command == "list":
120             self._repo_list(args)
121         elif command == "packages":
122             self._repo_packages(args)
123         elif command == "search":
124             self._repo_packages(args, search=True)
125         elif command == "update":
126             self._download_repo_metadata(args)
127         elif command == "create":
128             self._create_repo(</b></font>args)
129         else:
130             raise SPMInvocationError("Invalid repo command '{}'".format(command))
131     def _repo_packages(self, args, search=False):
132         """
133         List packages for one or more configured repos
134         """
135         packages = []
136         repo_metadata = self._get_repo_metadata()
137         for repo in repo_metadata:
138             for pkg in repo_metadata[repo]["packages"]:
139                 if args[1] in pkg:
140                     version = repo_metadata[repo]["packages"][pkg]["info"]["version"]
141                     release = repo_metadata[repo]["packages"][pkg]["info"]["release"]
142                     packages.append((pkg, version, release, repo))
143         for pkg in sorted(packages):
144             self.ui.status("{}\t{}-{}\t{}".format(pkg[0], pkg[1], pkg[2], pkg[3]))
145         return packages
146     def _repo_list(self, args):
147         """
148         List configured repos
149         This can be called either as a ``repo`` command or a ``list`` command
150         """
151         repo_metadata = self._get_repo_metadata()
152         for repo in repo_metadata:
153             self.ui.status(repo)
154     def _install(self, args):
155         """
156         Install a package from a repo
157         """
158         if len(args) &lt; 2:
159             raise SPMInvocationError("A package must be specified")
160         caller_opts = self.opts.copy()
161         caller_opts["file_client"] = "local"
162         self.caller = salt.client.Caller(mopts=caller_opts)
163         self.client = salt.client.get_local_client(self.opts["conf_file"])
164         cache = salt.cache.Cache(self.opts)
165         packages = args[1:]
166         file_map = {}
167         optional = []
168         recommended = []
169         for pkg in packages:
170             if pkg.endswith(".spm"):
171                     comps = pkg.split("-")
172                     comps = os.path.split("-".join(comps[</b></font>:-2]))
173                     pkg_name <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= comps[-1]
174                     formula_tar = tarfile.open(pkg, "r:bz2")
175                     formula_ref = formula_tar.extractfile("{}/FORMULA".format(pkg_name))
176                     formula_def = salt.</b></font>utils.yaml.safe_load(formula_ref)
177                     file_map[pkg_name] = pkg
178                         pkg_name=pkg_name, pkg_file=pkg, formula_def=formula_def
179                     )
180                     to_install<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.extend(to_)
181                     optional.extend(op_)
182                     recommended.extend(re_)
183                     formula_tar.close()
184                 else:
185                     raise SPMInvocationError("Package file {} not found".format(</b></font>pkg))
186             else:
187                 to_, op_, re_ = self._check_all_deps(pkg_name=pkg)
188                 to_install.extend(to_)
189                 optional.extend(op_)
190                 recommended.extend(re_)
191         optional = set(filter(len, optional))
192         if optional:
193             self.ui.status(
194                 "The following dependencies are optional:\n\t{}\n".format(
195                     "\n\t".join(optional)
196                 )
197             )
198         recommended = set(filter(len, recommended))
199         if recommended:
200             self.ui.status(
201                 "The following dependencies are recommended:\n\t{}\n".format(
202                     "\n\t".join(recommended)
203                 )
204             )
205         to_install = set(filter(len, to_install))
206         msg = "Installing packages:\n\t{}\n".format("\n\t".join(to_install))
207         if not self.opts["assume_yes"]:
208             self.ui.confirm(msg)
209         repo_metadata = self._get_repo_metadata()
210         dl_list = {}
211         for package in to_install:
212             if package in file_map:
213                 self._install_indv_pkg(package, file_map[package])
214             else:
215                 for repo in repo_metadata:
216                     repo_info = repo_metadata[repo]
217                     if package in repo_info["packages"]:
218                         dl_package = False
219                         repo_ver = repo_info["packages"][package]["info"]["version"]
220                         repo_rel = repo_info["packages"][package]["info"]["release"]
221                         repo_url = repo_info["info"]["url"]
222                         if package in dl_list:
223                             if repo_ver == dl_list[package]["version"]:
224                                 if repo_rel &gt; dl_list[package]["release"]:
225                                     dl_package = True
226                                 elif repo_rel == dl_list[package]["release"]:
227                                     if dl_list[package]["source"].startswith("file://"):
228                                         if not repo_url.startswith("file://"):
229                                             dl_package = True
230                             elif repo_ver &gt; dl_list[package]["version"]:
231                                 dl_package = True
232                         else:
233                             dl_package = True
234                         if dl_package is True:
235                             cache_path = os.path.join(self.opts["spm_cache_dir"], repo)
236                             dl_url = "{}/{}".format(
237                                 repo_info["info"]["url"],
238                                 repo_info<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["packages"][package]["filename"],
239                             )
240                             out_file = os.path.join(
241                                 cache_path, repo_info["packages"][package]["filename"]
242                             )
243                             dl_list[package] = {
244                                 "version"</b></font>: repo_ver,
245                                 "release": repo_rel,
246                                 "source": dl_url,
247                                 "dest_dir": cache_path,
248                                 "dest_file": out_file,
249                             }
250         for package in dl_list:
251             dl_url = dl_list[package]["source"]
252             cache_path = dl_list[package]["dest_dir"]
253             <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not os.path.exists(cache_path):
254                 os.makedirs(cache_path)
255             if dl_url.startswith("file://"):
256                 dl_url = dl_url.replace(</b></font>"file://", "")
257                 shutil.copyfile(dl_url, out_file)
258             else:
259                 with salt.utils.files.fopen(out_file, "wb") as outf:
260                     outf.write(
261                         self._query_http(dl_url, repo_info["info"], decode_body=False)
262                     )
263         for package in dl_list:
264             out_file = dl_list[package]["dest_file"]
265             self._install_indv_pkg(package, out_file)
266         return
267     def _local_install(self, args, pkg_name=None):
268         """
269         Install a package from a file
270         """
271         if len(args) &lt; 2:
272             raise SPMInvocationError("A package file must be specified")
273         self._install(args)
274     def _check_all_deps(self, pkg_name=None, pkg_file=None, formula_def=None):
275         """
276         Starting with one package, check all packages for dependencies
277         """
278         if pkg_file and not os.path.exists(pkg_file):
279             raise SPMInvocationError("Package file {} not found".format(pkg_file))
280         self.repo_metadata = self._get_repo_metadata()
281         if not formula_def:
282             for repo in self.repo_metadata:
283                 if not isinstance(self.repo_metadata[repo]["packages"], dict):
284                     continue
285                 if pkg_name in self.repo_metadata[repo]["packages"]:
286                     formula_def = self.repo_metadata[repo]["packages"][pkg_name]["info"]
287         if not formula_def:
288             raise SPMInvocationError("Unable to read formula for {}".format(pkg_name))
289         pkg_info = self._pkgdb_fun("info", pkg_name, self.db_conn)
290         pkgs_to_install = []
291         if pkg_info is None or self.opts["force"]:
292             pkgs_to_install.append(pkg_name)
293         elif pkg_info is not None and not self.opts["force"]:
294             raise SPMPackageError(
295                 "Package {} already installed, not installing again".format(
296                     formula_def["name"]
297                 )
298             )
299         optional_install = []
300         recommended_install = []
301         if (
302             "dependencies" in formula_def
303             or "optional" in formula_def
304             or "recommended" in formula_def
305         ):
306             self.avail_pkgs = {}
307             for repo in self.repo_metadata:
308                 if not isinstance(self.repo_metadata[repo]["packages"], dict):
309                     continue
310                 for pkg in self.repo_metadata[repo]["packages"]:
311                     self.avail_pkgs[pkg] = repo
312             needs, unavail, optional, recommended = self._resolve_deps(formula_def)
313             if len(unavail) &gt; 0:
314                 raise SPMPackageError(
315                     "Cannot install {}, the following dependencies are needed:\n\n{}".format(
316                         formula_def["name"], "\n".join(unavail)
317                     )
318                 )
319             if optional:
320                 optional_install.extend(optional)
321                 for dep_pkg in optional:
322                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
323                     msg = dep_pkg
324                     if isinstance(pkg_info, dict):
325                         msg = "{} [Installed]".format(dep_pkg)
326                     optional_install.append(msg)
327             if recommended:
328                 recommended_install.extend(recommended)
329                 for dep_pkg in recommended:
330                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
331                     msg = dep_pkg
332                     if isinstance(pkg_info, dict):
333                         msg = "{} [Installed]".format(dep_pkg)
334                     recommended_install.append(msg)
335             if needs:
336                 pkgs_to_install.extend(needs)
337                 for dep_pkg in needs:
338                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
339                     msg = dep_pkg
340                     if isinstance(pkg_info, dict):
341                         msg = "{} [Installed]".format(dep_pkg)
342         return pkgs_to_install, optional_install, recommended_install
343     def _install_indv_pkg(self, pkg_name, pkg_file):
344         Install one individual package
345         """
346         self.ui<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.status("... installing {}".format(pkg_name))
347         formula_tar = tarfile.open(pkg_file, "r:bz2")
348         formula_ref = formula_tar.extractfile("{}/FORMULA".format(pkg_name))
349         formula_def =</b></font> salt.utils.yaml.safe_load(formula_ref)
350         for field in ("version", "release", "summary", "description"):
351             if field not in formula_def:
352                 raise SPMPackageError(
353                     "Invalid package: the {} was not found".format(field)
354                 )
355         pkg_files = formula_tar.getmembers()
356         existing_files = self._pkgfiles_fun(
357             "check_existing", pkg_name, pkg_files, formula_def
358         )
359         if existing_files and not self.opts["force"]:
360             raise SPMPackageError(
361                 "Not installing {} due to existing files:\n\n{}".format(
362                     pkg_name, "\n".join(existing_files)
363                 )
364             )
365         self._pkgdb_fun("register_pkg", pkg_name, formula_def, self.db_conn)
366         if "pre_local_state" in formula_def:
367             high_data = self._render(formula_def["pre_local_state"], formula_def)
368             ret = self.caller.cmd("state.high", data=high_data)
369         if "pre_tgt_state" in formula_def:
370             log.debug("Executing pre_tgt_state script")
371             high_data = self._render(formula_def["pre_tgt_state"]["data"], formula_def)
372             tgt = formula_def["pre_tgt_state"]["tgt"]
373             ret = self.client.run_job(
374                 tgt=formula_def["pre_tgt_state"]["tgt"],
375                 fun="state.high",
376                 tgt_type=formula_def["pre_tgt_state"].get("tgt_type", "glob"),
377                 timout=self.opts["timeout"],
378                 data=high_data,
379             )
380         if salt.utils.platform.is_windows():
381             uname = gname = salt.utils.win_functions.get_current_user()
382             uname_sid = salt.utils.win_functions.get_sid_from_name(uname)
383             uid = self.opts.get("spm_uid", uname_sid)
384             gid = self.opts.get("spm_gid", uname_sid)
385         else:
386             uid = self.opts.get("spm_uid", os.getuid())
387             gid = self.opts.get("spm_gid", os.getgid())
388             uname = pwd.getpwuid(uid)[0]
389             gname = grp.getgrgid(gid)[0]
390         for member in pkg_files:
391             member.uid = uid
392             member.gid = gid
393             member.uname = uname
394             member.gname = gname
395             out_path = self._pkgfiles_fun(
396                 "install_file",
397                 pkg_name,
398                 formula_tar,
399                 member,
400                 formula_def,
401                 self.files_conn,
402             )
403             if out_path is not False:
404                 if member.isdir():
405                     digest = ""
406                 else:
407                     self._verbose(
408                         "Installing file {} to {}".format(member.name, out_path),
409                         log.trace,
410                     )
411                     file_hash = hashlib.sha1()
412                     digest = self._pkgfiles_fun(
413                         "hash_file",
414                         os.path.join(out_path, member.name),
415                         file_hash,
416                         self.files_conn,
417                     )
418                 self._pkgdb_fun(
419                     "register_file", pkg_name, member, out_path, digest, self.db_conn
420                 )
421         if "post_local_state" in formula_def:
422             log.debug("Executing post_local_state script")
423             high_data = self._render(formula_def["post_local_state"], formula_def)
424             self.caller.cmd("state.high", data=high_data)
425         if "post_tgt_state" in formula_def:
426             log.debug("Executing post_tgt_state script")
427             high_data = self._render(formula_def["post_tgt_state"]["data"], formula_def)
428             tgt = formula_def["post_tgt_state"]["tgt"]
429             ret = self.client.run_job(
430                 tgt=formula_def["post_tgt_state"]["tgt"],
431                 fun="state.high",
432                 tgt_type=formula_def["post_tgt_state"].get("tgt_type", "glob"),
433                 timout=self.opts["timeout"],
434                 data=high_data,
435             )
436         formula_tar.close()
437     def _resolve_deps(self, formula_def):
438         """
439         Return a list of packages which need to be installed, to resolve all
440         dependencies
441         """
442         pkg_info = self.pkgdb["{}.info".format(self.db_prov)](formula_def["name"])
443         if not isinstance(pkg_info, dict):
444             pkg_info = {}
445         can_has = {}
446         cant_has = []
447         if "dependencies" in formula_def and formula_def["dependencies"] is None:
448             formula_def["dependencies"] = ""
449         for dep in formula_def.get("dependencies", "").split(","):
450             dep = dep.strip()
451             if not dep:
452                 continue
453             if self.pkgdb["{}.info".format(self.db_prov)](dep):
454                 continue
455             if dep in self.avail_pkgs:
456                 can_has[dep] = self.avail_pkgs[dep]
457             else:
458                 cant_has.append(dep)
459         optional = formula_def.get("optional", "").split(",")
460         recommended = formula_def.get("recommended", "").split(",")
461         inspected = []
462         to_inspect = can_has.copy()
463         while len(to_inspect) &gt; 0:
464             dep = next(iter(to_inspect.keys()))
465             del to_inspect[dep]
466             if dep in inspected:
467                 continue
468             repo_contents = self.repo_metadata.get(can_has[dep], {})
469             repo_packages <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= repo_contents.get("packages", {})
470             dep_formula = repo_packages.get(dep, {}).get("info", {})
471             also_can, also_cant, opt_dep, rec_dep = self._resolve_deps(dep_formula)
472             can_has.update(</b></font>also_can)
473             cant_has = sorted(set(cant_has + also_cant))
474             optional = sorted(set(optional + opt_dep))
475             recommended = sorted(set(recommended + rec_dep))
476         return can_has, cant_has, optional, recommended
477     def _traverse_repos(self, callback, repo_name=None):
478         """
479         Traverse through all repo files and apply the functionality provided in
480         the callback to them
481         """
482         repo_files = []
483         if os.path.exists(self.opts["spm_repos_config"]):
484             repo_files.append(self.opts["spm_repos_config"])
485         for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(
486             "{}.d".format(self.opts["spm_repos_config"])
487         ):
488             for repo_file in filenames:
489                 if not repo_file.endswith(".repo"):
490                     continue
491                 repo_files.append(repo_file)
492         for repo_file in repo_files:
493             repo_path = "{}.d/{}".format(self.opts["spm_repos_config"], repo_file)
494             with salt.utils.files.fopen(repo_path) as rph:
495                 repo_data = salt.utils.yaml.safe_load(rph)
496                 for repo in repo_data:
497                     if repo_data[repo].get("enabled", True) is False:
498                         continue
499                     if repo_name is not None and repo != repo_name:
500                         continue
501                     callback(repo, repo_data[repo])
502     def _query_http(self, dl_path, repo_info, decode_body=True):
503         """
504         Download files via http
505         """
506         query = None
507         response = None
508         try:
509             if "username" in repo_info:
510                 try:
511                     if "password" in repo_info:
512                         query = http.query(
513                             dl_path,
514                             text=True,
515                             username=repo_info["username"],
516                             password=repo_info["password"],
517                             decode_body=decode_body,
518                         )
519                     else:
520                         raise SPMException(
521                             "Auth defined, but password is not set for username: '{}'".format(
522                                 repo_info["username"]
523                             )
524                         )
525                 except SPMException as exc:
526                     self.ui.error(str(exc))
527             else:
528                 query = http.query(dl_path, text=True, decode_body=decode_body)
529         except SPMException as exc:
530             self.ui.error(str(exc))
531         try:
532             if query:
533                 if "SPM-METADATA" in dl_path:
534                     response = salt.utils.yaml.safe_load(query.get("text", "{}"))
535                 else:
536                     response = query.get("text")
537             else:
538                 raise SPMException("Response is empty, please check for Errors above.")
539         except SPMException as exc:
540             self.ui.error(str(exc))
541         return response
542     def _download_repo_metadata(self, args):
543         """
544         Connect to all repos and download metadata
545         """
546         cache = salt.cache.Cache(self.opts, self.opts["spm_cache_dir"])
547         def _update_metadata(repo, repo_info):
548             dl_path = "{}/SPM-METADATA".format(repo_info["url"])
549             if dl_path.startswith("file://"):
550                 dl_path = dl_path.replace("file://", "")
551                 with salt.utils.files.fopen(dl_path, "r") as rpm:
552                     metadata = salt.utils.yaml.safe_load(rpm)
553             else:
554                 metadata = self._query_http(dl_path, repo_info)
555             cache.store(".", repo, metadata)
556         repo_name = args[1] if len(args) &gt; 1 else None
557         self._traverse_repos(_update_metadata, repo_name)
558     def _get_repo_metadata(self):
559         """
560         Return cached repo metadata
561         """
562         cache = salt.cache.Cache(self.opts, self.opts["spm_cache_dir"])
563         metadata = {}
564         def _read_metadata(repo, repo_info):
565             if cache.updated(".", repo) is None:
566                 log.warning("Updating repo metadata")
567                 self._download_repo_metadata({})
568             metadata[repo] = {
569                 "info": repo_info,
570                 "packages": cache.fetch(".", repo),
571             }
572         self._traverse_repos(_read_metadata)
573         return metadata
574     def _create_repo(self, args):
575         """
576         Scan a directory and create an SPM-METADATA file which describes
577         all of the SPM files in that directory.
578         """
579         if len(args) &lt; 2:
580             raise SPMInvocationError("A path to a directory must be specified")
581         if args[1] == ".":
582             repo_path = os.getcwdu()
583         else:
584             repo_path = args[1]
585         old_files = []
586         repo_metadata = {}
587         for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(repo_path):
588             for spm_file in filenames:
589                 if not spm_file.endswith(".spm"):
590                     continue
591                 spm_path = "{}/{}".format(repo_path, spm_file)
592                 if not tarfile.is_tarfile(spm_path):
593                 comps = spm_file.split("-")
594                 spm_name = "-".join(comps[:-2])
595                 spm_fh = tarfile<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.open(spm_path, "r:bz2")
596                 formula_handle = spm_fh.extractfile("{}/FORMULA".format(spm_name))
597                 formula_conf = salt.utils.yaml.safe_load(</b></font>formula_handle.read())
598                 use_formula = True
599                 if spm_name in repo_metadata:
600                     cur_info = repo_metadata[spm_name]["info"]
601                     new_info = formula_conf
602                     if int(new_info["version"]) == int(cur_info["version"]):
603                         if int(new_info["release"]) &lt; int(cur_info["release"]):
604                             use_formula = False
605                     elif int(new_info["version"]) &lt; int(cur_info["version"]):
606                         use_formula = False
607                     if use_formula is True:
608                         log.debug(
609                             "%s %s-%s had been added, but %s-%s will replace it",
610                             spm_name,
611                             cur_info["version"],
612                             cur_info["release"],
613                             new_info["version"],
614                             new_info["release"],
615                         )
616                         old_files.append(repo_metadata[spm_name]["filename"])
617                     else:
618                         log.debug(
619                             "%s %s-%s has been found, but is older than %s-%s",
620                             spm_name,
621                             new_info["version"],
622                             new_info["release"],
623                             cur_info["version"],
624                             cur_info["release"],
625                         )
626                         old_files.append(spm_file)
627                 if use_formula is True:
628                     log.debug(
629                         "adding %s-%s-%s to the repo",
630                         formula_conf["name"],
631                         formula_conf["version"],
632                         formula_conf["release"],
633                     )
634                     repo_metadata[spm_name] = {
635                         "info": formula_conf.copy(),
636                     }
637                     repo_metadata[spm_name]["filename"] = spm_file
638         metadata_filename = "{}/SPM-METADATA".format(repo_path)
639         with salt.utils.files.fopen(metadata_filename, "w") as mfh:
640             salt.utils.yaml.safe_dump(
641                 repo_metadata,
642                 mfh,
643                 indent=4,
644                 canonical=False,
645                 default_flow_style=False,
646             )
647         log.debug("Wrote %s", metadata_filename)
648         for file_ in old_files:
649             if self.opts["spm_repo_dups"] == "ignore":
650                 log.debug("%s will be left in the directory", file_)
651             elif self.opts["spm_repo_dups"] == "archive":
652                 if not os.path.exists("./archive"):
653                     try:
654                         os.makedirs("./archive")
655                         log.debug("%s has been archived", file_)
656                     except OSError:
657                         log.error("Unable to create archive directory")
658                 try:
659                     shutil.move(file_, "./archive")
660                 except OSError:
661                     log.error("Unable to archive %s", file_)
662             elif self.opts["spm_repo_dups"] == "delete":
663                 try:
664                     os.remove(file_)
665                     log.debug("%s has been deleted", file_)
666                 except OSError:
667                     log.error("Unable to delete %s", file_)
668                 except OSError:  # pylint: disable=duplicate-except
669                     pass
670     def _remove(self, args):
671         """
672         Remove a package
673         """
674         if len(args) &lt; 2:
675             raise SPMInvocationError("A package must be specified")
676         packages = args[1:]
677         msg = "Removing packages:\n\t{}".format("\n\t".join(packages))
678         if not self.opts["assume_yes"]:
679             self.ui.confirm(msg)
680         for package in packages:
681             self.ui.status("... removing {}".format(package))
682             if not self._pkgdb_fun("db_exists", self.opts["spm_db"]):
683                 raise SPMDatabaseError(
684                     "No database at {}, cannot remove {}".format(
685                         self.opts["spm_db"], package
686                     )
687                 )
688             pkg_info = self._pkgdb_fun("info", package, self.db_conn)
689             if pkg_info is None:
690                 raise SPMInvocationError("Package {} not installed".format(package))
691             files = self._pkgdb_fun("list_files", package, self.db_conn)
692             dirs = []
693             for filerow in files:
694                 if self._pkgfiles_fun("path_isdir", filerow[0]):
695                     dirs.append(filerow[0])
696                     continue
697                 file_hash = hashlib.sha1()
698                 digest = self._pkgfiles_fun(
699                     "hash_file", filerow[0], file_hash, self.files_conn
700                 )
701                 if filerow[1] == digest:
702                     self._verbose("Removing file {}".format(filerow[0]), log.trace)
703                     self._pkgfiles_fun("remove_file", filerow[0], self.files_conn)
704                 else:
705                     self._verbose("Not removing file {}".format(filerow[0]), log.trace)
706                 self._pkgdb_fun("unregister_file", filerow[0], package, self.db_conn)
707             for dir_ in sorted(dirs, reverse=True):
708                 self._pkgdb_fun("unregister_file", dir_, package, self.db_conn)
709                 try:
710                     self._verbose("Removing directory {}".format(dir_), log.trace)
711                     os.rmdir(dir_)
712                 except OSError:
713                     self._verbose(
714                         "Cannot remove directory {}, probably not empty".format(dir_),
715                         log.trace,
716                     )
717             self._pkgdb_fun("unregister_pkg", package, self.db_conn)
718     def _verbose(self, msg, level=log.debug):
719         """
720         Display verbose information
721         """
722         if self.opts.get("verbose", False) is True:
723             self.ui.status(msg)
724         level(msg)
725     def _local_info(self, args):
726         """
727         List info for a package file
728         """
729         if len(args) &lt; 2:
730             raise SPMInvocationError("A package filename must be specified")
731         pkg_file = args[1]
732         if not os.path.exists(pkg_file):
733             raise SPMInvocationError("Package file {} not found".format(pkg_file))
734         comps = pkg_file.split("-")
735         comps = "-".join(comps[:-2]).split("/")
736         name = comps[-1]
737         formula_tar = tarfile.open(pkg_file, "r:bz2")
738         formula_ref = formula_tar.extractfile("{}/FORMULA".format(name))
739         formula_def = salt.utils.yaml.safe_load(formula_ref)
740         self.ui.status(self._get_info(formula_def))
741         formula_tar.close()
742     def _info(self, args):
743         """
744         List info for a package
745         """
746         if len(args) &lt; 2:
747             raise SPMInvocationError("A package must be specified")
748         package = args[1]
749         pkg_info = self._pkgdb_fun("info", package, self.db_conn)
750         if pkg_info is None:
751             raise SPMPackageError("package {} not installed".format(package))
752         self.ui.status(self._get_info(pkg_info))
753     def _get_info(self, formula_def):
754         """
755         Get package info
756         """
757         fields = (
758             "name",
759             "os",
760             "os_family",
761             "release",
762             "version",
763             "dependencies",
764             "os_dependencies",
765             "os_family_dependencies",
766             "summary",
767             "description",
768         )
769         for item in fields:
770             if item not in formula_def:
771                 formula_def[item] = "None"
772         if "installed" not in formula_def:
773             formula_def["installed"] = "Not installed"
774         return (
775             "Name: {name}\n"
776             "Version: {version}\n"
777             "Release: {release}\n"
778             "Install Date: {installed}\n"
779             "Supported OSes: {os}\n"
780             "Supported OS families: {os_family}\n"
781             "Dependencies: {dependencies}\n"
782             "OS Dependencies: {os_dependencies}\n"
783             "OS Family Dependencies: {os_family_dependencies}\n"
784             "Summary: {summary}\n"
785             "Description:\n"
786             "{description}".format(**formula_def)
787         )
788     def _local_list_files(self, args):
789         """
790         List files for a package file
791         """
792         if len(args) &lt; 2:
793             raise SPMInvocationError("A package filename must be specified")
794         pkg_file = args[1]
795         if not os.path.exists(pkg_file):
796             raise SPMPackageError("Package file {} not found".format(pkg_file))
797         formula_tar = tarfile.open(pkg_file, "r:bz2")
798         pkg_files = formula_tar.getmembers()
799         for member in pkg_files:
800             self.ui.status(member.name)
801     def _list_packages(self, args):
802         """
803         List files for an installed package
804         """
805         packages = self._pkgdb_fun("list_packages", self.db_conn)
806         for package in packages:
807             if self.opts["verbose"]:
808                 status_msg = ",".join(package)
809             else:
810                 status_msg = package[0]
811             self.ui.status(status_msg)
812     def _list_files(self, args):
813         """
814         List files for an installed package
815         """
816         if len(args) &lt; 2:
817             raise SPMInvocationError("A package name must be specified")
818         package = args[-1]
819         files = self._pkgdb_fun("list_files", package, self.db_conn)
820         if files is None:
821             raise SPMPackageError("package {} not installed".format(package))
822         else:
823             for file_ in files:
824                 if self.opts["verbose"]:
825                     status_msg = ",".join(file_)
826                 else:
827                     status_msg = file_[0]
828                 self.ui.status(status_msg)
829     def _build(self, args):
830         """
831         Build a package
832         """
833         if len(args) &lt; 2:
834             raise SPMInvocationError("A path to a formula must be specified")
835         self.abspath = args[1].rstrip("/")
836         comps = self.abspath.split("/")
837         self.relpath = comps[-1]
838         formula_path = "{}/FORMULA".format(self.abspath)
839         if not os.path.exists(formula_path):
840             raise SPMPackageError("Formula file {} not found".format(formula_path))
841         with salt.utils.files.fopen(formula_path) as fp_:
842             formula_conf = salt.utils.yaml.safe_load(fp_)
843         for field in ("name", "version", "release", "summary", "description"):
844             if field not in formula_conf:
845                 raise SPMPackageError(
846                     "Invalid package: a {} must be defined".format(field)
847                 )
848         out_path = "{}/{}-{}-{}.spm".format(
849             self.opts["spm_build_dir"],
850             formula_conf["name"],
851             formula_conf["version"],
852             formula_conf["release"],
853         )
854         if not os.path.exists(self.opts["spm_build_dir"]):
855             os.mkdir(self.opts["spm_build_dir"])
856         self.formula_conf = formula_conf
857         formula_tar = tarfile.open(out_path, "w:bz2")
858         if "files" in formula_conf:
859             if isinstance(formula_conf["files"], list):
860                 formula_dir = tarfile.TarInfo(formula_conf["name"])
861                 formula_dir.type = tarfile.DIRTYPE
862                 formula_tar.addfile(formula_dir)
863                 for file_ in formula_conf["files"]:
864                     for ftype in FILE_TYPES:
865                         if file_.startswith("{}|".format(ftype)):
866                             file_ = file_.lstrip("{}|".format(ftype))
867                     formula_tar.add(
868                         os.path.join(os.getcwd(), file_),
869                         os.path.join(formula_conf["name"], file_),
870                     )
871         else:
872             try:
873                 formula_tar.add(
874                     formula_path, formula_conf["name"], filter=self._exclude
875                 )
876                 formula_tar.add(
877                     self.abspath, formula_conf["name"], filter=self._exclude
878                 )
879             except TypeError:
880                 formula_tar.add(
881                     formula_path, formula_conf["name"], exclude=self._exclude
882                 )
883                 formula_tar.add(
884                     self.abspath, formula_conf["name"], exclude=self._exclude
885                 )
886         formula_tar.close()
887         self.ui.status("Built package {}".format(out_path))
888     def _exclude(self, member):
889         """
890         Exclude based on opts
891         """
892         if isinstance(member, str):
893             return None
894         for item in self.opts["spm_build_exclude"]:
895             if member.name.startswith("{}/{}".format(self.formula_conf["name"], item)):
896                 return None
897             elif member.name.startswith("{}/{}".format(self.abspath, item)):
898                 return None
899         return member
900     def _render(self, data, formula_def):
901         """
902         Render a [pre|post]_local_state or [pre|post]_tgt_state script
903         """
904         renderer = formula_def.get("renderer", self.opts.get("renderer", "jinja|yaml"))
905         rend = salt.loader.render(self.opts, {})
906         blacklist = self.opts.get("renderer_blacklist")
907         whitelist = self.opts.get("renderer_whitelist")
908         template_vars = formula_def.copy()
909         template_vars["opts"] = self.opts.copy()
910         return compile_template(
911             ":string:",
912             rend,
913             renderer,
914             blacklist,
915             whitelist,
916             input_data=data,
917             **template_vars
918         )
919 class SPMUserInterface:
920     """
921     Handle user interaction with an SPMClient object
922     """
923     def status(self, msg):
924         """
925         Report an SPMClient status message
926         """
927         raise NotImplementedError()
928     def error(self, msg):
929         """
930         Report an SPM error message
931         """
932         raise NotImplementedError()
933     def confirm(self, action):
934         """
935         Get confirmation from the user before performing an SPMClient action.
936         Return if the action is confirmed, or raise SPMOperationCanceled(&lt;msg&gt;)
937         if canceled.
938         """
939         raise NotImplementedError()
940 class SPMCmdlineInterface(SPMUserInterface):
941     """
942     Command-line interface to SPMClient
943     """
944     def status(self, msg):
945         print(msg)
946     def error(self, msg):
947         print(msg, file=sys.stderr)
948     def confirm(self, action):
949         print(action)
950         res = input("Proceed? [N/y] ")
951         if not res.lower().startswith("y"):
952             raise SPMOperationCanceled("canceled")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Work with virtual machines managed by libvirt
3 :depends:
4     * libvirt Python module
5     * libvirt client
6     * qemu-img
7     * grep
8 Connection
9 ==========
10 The connection to the virtualization host can be either setup in the minion configuration,
11 pillar data or overridden for each individual call.
12 By default, the libvirt connection URL will be guessed: the first available libvirt
13 hypervisor driver will be used. This can be overridden like this:
14 .. code-block:: yaml
15     virt:
16       connection:
17         uri: lxc:///
18 If the connection requires an authentication like for ESXi, this can be defined in the
19 minion pillar data like this:
20 .. code-block:: yaml
21     virt:
22       connection:
23         uri: esx://10.1.1.101/?no_verify=1&amp;auto_answer=1
24         auth:
25           username: user
26           password: secret
27 Connecting with SSH protocol
28 ----------------------------
29 Libvirt can connect to remote hosts using SSH using one of the ``ssh``, ``libssh`` and
30 ``libssh2`` transports. Note that ``libssh2`` is likely to fail as it doesn't read the
31 ``known_hosts`` file. Libvirt may also have been built without ``libssh`` or ``libssh2``
32 support.
33 To use the SSH transport, on the minion setup an SSH agent with a key authorized on
34 the remote libvirt machine.
35 Per call connection setup
36 -------------------------
37 .. versionadded:: 2019.2.0
38 All the calls requiring the libvirt connection configuration as mentioned above can
39 override this configuration using ``connection``, ``username`` and ``password`` parameters.
40 This means that the following will list the domains on the local LXC libvirt driver,
41 whatever the ``virt:connection`` is.
42 .. code-block:: bash
43     salt 'hypervisor' virt.list_domains connection=lxc:///
44 The calls not using the libvirt connection setup are:
45 - ``seed_non_shared_migrate``
46 - ``virt_type``
47 - ``is_*hyper``
48 - all migration functions
49 - `libvirt ESX URI format &lt;http://libvirt.org/drvesx.html#uriformat&gt;`_
50 - `libvirt URI format &lt;http://libvirt.org/uri.html#URI_config&gt;`_
51 - `libvirt authentication configuration &lt;http://libvirt.org/auth.html#Auth_client_config&gt;`_
52 Units
53 ==========
54 .. _virt-units:
55 .. rubric:: Units specification
56 .. versionadded:: 3002
57 The string should contain a number optionally followed
58 by a unit. The number may have a decimal fraction. If
59 the unit is not given then MiB are set by default.
60 Units can optionally be given in IEC style (such as MiB),
61 although the standard single letter style (such as M) is
62 more convenient.
63 Valid units include:
64 ========== =====    ==========  ==========  ======
65 Standard   IEC      Standard    IEC
66   Unit     Unit     Name        Name        Factor
67 ========== =====    ==========  ==========  ======
68     B               Bytes                   1
69     K       KiB     Kilobytes   Kibibytes   2**10
70     M       MiB     Megabytes   Mebibytes   2**20
71     G       GiB     Gigabytes   Gibibytes   2**30
72     T       TiB     Terabytes   Tebibytes   2**40
73     P       PiB     Petabytes   Pebibytes   2**50
74     E       EiB     Exabytes    Exbibytes   2**60
75     Z       ZiB     Zettabytes  Zebibytes   2**70
76     Y       YiB     Yottabytes  Yobibytes   2**80
77 ========== =====    ==========  ==========  ======
78 Additional decimal based units:
79 ======  =======
80 Unit     Factor
81 ======  =======
82 KB      10**3
83 MB      10**6
84 GB      10**9
85 TB      10**12
86 PB      10**15
87 EB      10**18
88 ZB      10**21
89 YB      10**24
90 ======  =======
91 """
92 import base64
93 import collections
94 import copy
95 import datetime
96 import logging
97 import os
98 import shutil
99 import string  # pylint: disable=deprecated-module
100 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import subprocess
101 import sys
102 import time
103 import urllib.parse
104 from xml.etree import ElementTree
105 from xml.sax import saxutils
106 import jinja2.exceptions
107 import salt.utils.data
108 import salt.utils.files
109 import salt.utils.json
110 import salt.utils.path
111 import salt.utils.stringutils
112 import salt.utils.templates
113 import salt.utils.virt
114 import salt.utils.xmlutil as xmlutil
115 import salt.utils.yaml
116 from salt._compat import ipaddress
117 from salt.exceptions import CommandExecutionError, SaltInvocationError
118 try:
119     import libvirt  # pylint: disable=import-error
120     from</b></font> libvirt import libvirtError
121     HAS_LIBVIRT = True
122 except ImportError:
123     HAS_LIBVIRT = False
124 log = logging.getLogger(__name__)
125 JINJA = jinja2.Environment(
126     loader=jinja2.FileSystemLoader(
127         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "virt")
128     )
129 )
130 CACHE_DIR = "/var/lib/libvirt/saltinst"
131 VIRT_STATE_NAME_MAP = {
132     0: "running",
133     1: "running",
134     2: "running",
135     3: "paused",
136     4: "shutdown",
137     5: "shutdown",
138     6: "crashed",
139 }
140 def __virtual__():
141     if not HAS_LIBVIRT:
142         return (False, "Unable to locate or import python libvirt library.")
143     return "virt"
144 def __get_request_auth(username, password):
145     """
146     Get libvirt.openAuth callback with username, password values overriding
147     the configuration ones.
148     """
149     def __request_auth(credentials, user_data):
150         """Callback method passed to libvirt.openAuth().
151         The credentials argument is a list of credentials that libvirt
152         would like to request. An element of this list is a list containing
153         5 items (4 inputs, 1 output):
154           - the credential type, e.g. libvirt.VIR_CRED_AUTHNAME
155           - a prompt to be displayed to the user
156           - a challenge
157           - a default result for the request
158           - a place to store the actual result for the request
159         """
160         for credential in credentials:
161             if credential<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0] == libvirt.VIR_CRED_AUTHNAME:
162                 credential[4] = (
163                     username
164                     if username
165                     else __salt__["config.get"](
166                         "virt:connection:auth:username", credential[3]
167                     )
168                 )
169             elif credential[0] == libvirt.VIR_CRED_NOECHOPROMPT:
170                 credential[4] = (
171                     password</b></font>
172                     if password
173                     else __salt__["config.get"](
174                         "virt:connection:auth:password", credential[3]
175                     )
176                 )
177             else:
178                 log.info("Unhandled credential type: %s", credential[0])
179         return 0
180 def __get_conn(**kwargs):
181     """
182     Detects what type of dom this node is and attempts to connect to the
183     correct hypervisor via libvirt.
184     :param connection: libvirt connection URI, overriding defaults
185     :param username: username to connect with, overriding defaults
186     :param password: password to connect with, overriding defaults
187     """
188     username = kwargs.get("username", None)
189     password = kwargs.get("password", None)
190     conn_str = kwargs.get("connection", None)
191     if not conn_str:
192         conn_str = __salt__["config.get"]("virt:connection:uri", conn_str)
193     try:
194         auth_types = [
195             libvirt.VIR_CRED_AUTHNAME,
196             libvirt.VIR_CRED_NOECHOPROMPT,
197             libvirt.VIR_CRED_ECHOPROMPT,
198             libvirt.VIR_CRED_PASSPHRASE,
199             libvirt.VIR_CRED_EXTERNAL,
200         ]
201         conn = libvirt.openAuth(
202             conn_str, [auth_types, __get_request_auth(username, password), None], 0
203         )
204     except Exception:  # pylint: disable=broad-except
205         raise CommandExecutionError(
206             "Sorry, {} failed to open a connection to the hypervisor "
207             "software at {}".format(__grains__["fqdn"], conn_str)
208         )
209     return conn
210 def _get_domain(conn, *vms, **kwargs):
211     """
212     Return a domain object for the named VM or return domain object for all VMs.
213     :params conn: libvirt connection object
214     :param vms: list of domain names to look for
215     :param iterable: True to return an array in all cases
216     """
217     ret = list()
218     lookup_vms = list()
219     all_vms = []
220     if kwargs.get("active", True):
221         for id_ in conn.listDomainsID():
222             all_vms.append(conn.lookupByID(id_).name())
223     if kwargs.get("inactive", True):
224         for id_ in conn.listDefinedDomains():
225             all_vms.append(id_)
226     if vms and not all_vms:
227         raise CommandExecutionError("No virtual machines found.")
228     if vms:
229         for name in vms:
230             if name not in all_vms:
231                 raise CommandExecutionError(
232                     'The VM "{name}" is not present'.format(name=name)
233                 )
234             else:
235                 lookup_vms.append(name)
236     else:
237         lookup_vms = list(all_vms)
238     for name in lookup_vms:
239         ret.append(conn.lookupByName(name))
240     return len(ret) == 1 and not kwargs.get("iterable") and ret[0] or ret
241 def _parse_qemu_img_info(info):
242     """
243     Parse qemu-img info JSON output into disk infos dictionary
244     """
245     raw_infos = salt.utils.json.loads(info)
246     disks = []
247     for disk_infos in raw_infos:
248         disk = {
249             "file": disk_infos["filename"],
250             "file format": disk_infos["format"],
251             "disk size": disk_infos["actual-size"],
252             "virtual size": disk_infos["virtual-size"],
253             "cluster size": disk_infos["cluster-size"]
254             if "cluster-size" in disk_infos
255             else None,
256         }
257         if "full-backing-filename" in disk_infos.keys():
258             disk["backing file"] = format(disk_infos["full-backing-filename"])
259         if "snapshots" in disk_infos.keys():
260             disk["snapshots"] = [
261                 {
262                     "id": snapshot["id"],
263                     "tag": snapshot["name"],
264                     "vmsize": snapshot["vm-state-size"],
265                     "date": datetime.datetime.fromtimestamp(
266                         float(
267                             "{}.{}".format(snapshot["date-sec"], snapshot["date-nsec"])
268                         )
269                     ).isoformat(),
270                     "vmclock": datetime.datetime.utcfromtimestamp(
271                         float(
272                             "{}.{}".format(
273                                 snapshot["vm-clock-sec"], snapshot["vm-clock-nsec"]
274                             )
275                         )
276                     )
277                     .time()
278                     .isoformat(),
279                 }
280                 for snapshot in disk_infos["snapshots"]
281             ]
282         disks.append(disk)
283     for disk in disks:
284         if "backing file" in disk.keys():
285             candidates = [
286                 info
287                 for info in disks
288                 if "file" in info.keys() and info["file"] == disk["backing file"]
289             ]
290             if candidates:
291                 disk["backing file"] = candidates[0]
292     return disks[0]
293 def _get_uuid(dom):
294     """
295     Return a uuid from the named vm
296     CLI Example:
297     .. code-block:: bash
298         salt '*' virt.get_uuid &lt;domain&gt;
299     """
300     return ElementTree.fromstring(get_xml(dom)).find("uuid").text
301 def _get_on_poweroff(dom):
302     """
303     Return `on_poweroff` setting from the named vm
304     CLI Example:
305     .. code-block:: bash
306         salt '*' virt.get_on_restart &lt;domain&gt;
307     """
308     node = ElementTree.fromstring(get_xml(dom)).find("on_poweroff")
309     return node.text if node is not None else ""
310 def _get_on_reboot(dom):
311     """
312     Return `on_reboot` setting from the named vm
313     CLI Example:
314     .. code-block:: bash
315         salt '*' virt.get_on_reboot &lt;domain&gt;
316     """
317     node = ElementTree.fromstring(get_xml(dom)).find("on_reboot")
318     return node.text if node is not None else ""
319 def _get_on_crash(dom):
320     """
321     Return `on_crash` setting from the named vm
322     CLI Example:
323     .. code-block:: bash
324         salt '*' virt.get_on_crash &lt;domain&gt;
325     """
326     node = ElementTree.fromstring(get_xml(dom)).find("on_crash")
327     return node.text if node is not None else ""
328 def _get_nics(dom):
329     """
330     Get domain network interfaces from a libvirt domain object.
331     """
332     nics = {}
333     doc = ElementTree.fromstring(dom.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
334     for iface_node in doc.findall("devices/interface"):
335         nic["type"] = iface_node.get("type")
336         for v_node in iface_node:
337             <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if v_node.tag == "mac":
338                 nic["mac"] = v_node.get("address")
339             if v_node.tag == "model":
340                 nic["model"] = v_node.get(</b></font>"type")
341             if v_node.tag == "target":
342                 nic["target"] = v_node.get("dev")
343             if re.match("(driver|source|address)", v_node.tag):
344                 temp = {}
345                 for key, value in v_node.attrib.items():
346                     temp[key] = value
347                 nic[v_node.tag] = temp
348             if v_node.tag == "virtualport":
349                 temp = {}
350                 temp["type"] = v_node.get("type")
351                 for key, value in v_node.attrib.items():
352                     temp[key] = value
353                 nic["virtualport"] = temp
354         if "mac" not in nic:
355             continue
356         nics[nic["mac"]] = nic
357     return nics
358 def _get_graphics(dom):
359     """
360     Get domain graphics from a libvirt domain object.
361     """
362     out = {
363         "autoport": "None",
364         "keymap": "None",
365         "listen": "None",
366         "port": "None",
367         "type": "None",
368     }
369     doc = ElementTree.fromstring(dom.XMLDesc(0))
370     for g_node in doc.findall("devices/graphics"):
371         for key, value in g_node.attrib.items():
372             out[key] = value
373     return out
374 def _get_loader(dom):
375     """
376     Get domain loader from a libvirt domain object.
377     """
378     out = {"path": "None"}
379     doc = ElementTree.fromstring(dom.XMLDesc(0))
380     for g_node in doc.findall("os/loader"):
381         out["path"] = g_node.text
382         for key, value in g_node.attrib.items():
383             out[key] = value
384     return out
385 def _get_disks(conn, dom):
386     """
387     Get domain disks from a libvirt domain object.
388     """
389     disks = {}
390     doc = ElementTree.fromstring(dom.XMLDesc(0))
391     all_volumes = _get_all_volumes_paths(conn)
392     for elem in doc.findall("devices/disk"):
393         source = elem.find("source")
394         if source is None:
395             continue
396         target = elem.find("target")
397         driver = elem.find("driver")
398         if target is None:
399             continue
400         qemu_target = None
401         extra_properties = None
402         if "dev" in target.attrib:
403             disk_type = elem.get("type")
404             def _get_disk_volume_data(pool_name, volume_name):
405                 qemu_target = "{}/{}".format(pool_name, volume_name)
406                 pool = conn.storagePoolLookupByName(pool_name)
407                 extra_properties = {}
408                 try:
409                     vol = pool.storageVolLookupByName(volume_name)
410                     vol_info = vol.info()
411                     extra_properties = {
412                         "virtual size": vol_info[1],
413                         "disk size": vol_info[2],
414                     }
415                     backing_files = [
416                         {
417                             "file": node.find("source").get("file"),
418                             "file format": node.find("format").get("type"),
419                         }
420                         for node in elem.findall(".//backingStore[source]")
421                     ]
422                     if backing_files:
423                         extra_properties["backing file"] = backing_files[0]
424                         parent = extra_properties["backing file"]
425                         for sub_backing_file in backing_files[1:]:
426                             parent["backing file"] = sub_backing_file
427                             parent = sub_backing_file
428                     else:
429                         vol_desc = ElementTree.fromstring(vol.XMLDesc())
430                         backing_path = vol_desc.find("./backingStore/path")
431                         backing_format = vol_desc.find("./backingStore/format")
432                         if backing_path is not None:
433                             extra_properties["backing file"] = {
434                                 "file": backing_path.text
435                             }
436                             if backing_format is not None:
437                                 extra_properties["backing file"][
438                                     "file format"
439                                 ] = backing_format.get("type")
440                 except libvirt.libvirtError:
441                     log.info(
442                         "Couldn't extract all volume informations: pool is likely not"
443                         " running or refreshed"
444                     )
445                 return (qemu_target, extra_properties)
446             if disk_type == "file":
447                 qemu_target = source.get("file", "")
448                 if qemu_target.startswith("/dev/zvol/"):
449                     disks[target.get("dev")] = {"file": qemu_target, "zfs": True}
450                     continue
451                 if qemu_target in all_volumes.keys():
452                     volume = all_volumes[qemu_target]
453                     qemu_target, extra_properties = _get_disk_volume_data(
454                         volume["pool"], volume["name"]
455                     )
456                 elif elem.get("device", "disk") != "cdrom":
457                     try:
458                         process = subprocess.Popen(
459                             [
460                                 "qemu-img",
461                                 "info",
462                                 "-U",
463                                 "--output",
464                                 "json",
465                                 "--backing-chain",
466                                 qemu_target,
467                             ],
468                             shell=False,
469                             stdout=subprocess.PIPE,
470                             stderr=subprocess.PIPE,
471                         )
472                         stdout, stderr = process.communicate()
473                         if process.returncode == 0:
474                             qemu_output = salt.utils.stringutils.to_str(stdout)
475                             output = _parse_qemu_img_info(qemu_output)
476                             extra_properties = output
477                         else:
478                             extra_properties = {"error": stderr}
479                     except FileNotFoundError:
480                         extra_properties = {"error": "qemu-img not found"}
481             elif disk_type == "block":
482                 qemu_target = source.get("dev", "")
483                 if qemu_target in all_volumes.keys():
484                     volume = all_volumes[qemu_target]
485                     qemu_target, extra_properties = _get_disk_volume_data(
486                         volume["pool"], volume["name"]
487                     )
488             elif disk_type == "network":
489                 qemu_target = source.get("protocol")
490                 source_name = source.get("name")
491                 if source_name:
492                     qemu_target = "{}:{}".format(qemu_target, source_name)
493                 if source.get("protocol") in ["rbd", "gluster"]:
494                     for pool_i in conn.listAllStoragePools():
495                         pool_i_xml = ElementTree.fromstring(pool_i.XMLDesc())
496                         name_node = pool_i_xml.find("source/name")
497                         if name_node is not None and source_name.startswith(
498                             "{}/".format(name_node.text)
499                         ):
500                             qemu_target = "{}{}".format(
501                                 pool_i.name(), source_name[len(name_node.text) :]
502                             )
503                             break
504                 if elem.get("device", "disk") == "cdrom":
505                     host_node = source.find("host")
506                     if host_node is not None:
507                         hostname = host_node.get("name")
508                         port = host_node.get("port")
509                         qemu_target = urllib.parse.urlunparse(
510                             (
511                                 source.get("protocol"),
512                                 "{}:{}".format(hostname, port) if port else hostname,
513                                 source_name,
514                                 "",
515                                 saxutils.unescape(source.get("query", "")),
516                                 "",
517                             )
518                         )
519             elif disk_type == "volume":
520                 pool_name = source.get("pool")
521                 volume_name = source.get("volume")
522                 qemu_target, extra_properties = _get_disk_volume_data(
523                     pool_name, volume_name
524                 )
525             if not qemu_target:
526                 continue
527             disk = {
528                 "file": qemu_target,
529                 "type": elem.get("device"),
530             }
531             if driver is not None and "type" in driver.attrib:
532                 disk["file format"] = driver.get("type")
533             if extra_properties:
534                 disk.update(extra_properties)
535             disks[target.get("dev")] = disk
536     return disks
537 def _libvirt_creds():
538     """
539     Returns the user and group that the disk images should be owned by
540     """
541     g_cmd = ["grep", "^\\s*group", "/etc/libvirt/qemu.conf"]
542     u_cmd = ["grep", "^\\s*user", "/etc/libvirt/qemu.conf"]
543     try:
544         stdout = subprocess.Popen(g_cmd, stdout=subprocess.PIPE).communicate()[0]
545         group = salt.utils.stringutils.to_str(stdout).split('"')[1]
546     except IndexError:
547         group = "root"
548     try:
549         stdout = subprocess.Popen(u_cmd, stdout=subprocess.PIPE).communicate()[0]
550         user = salt.utils.stringutils.to_str(stdout).split('"')[1]
551     except IndexError:
552         user = "root"
553     return {"user": user, "group": group}
554 def _migrate(dom, dst_uri, **kwargs):
555     """
556     Migrate the domain object from its current host to the destination
557     host given by URI.
558     :param dom: domain object to migrate
559     :param dst_uri: destination URI
560     :param kwargs:
561         - live:            Use live migration. Default value is True.
562         - persistent:      Leave the domain persistent on destination host.
563                            Default value is True.
564         - undefinesource:  Undefine the domain on the source host.
565                            Default value is True.
566         - offline:         If set to True it will migrate the domain definition
567                            without starting the domain on destination and without
568                            stopping it on source host. Default value is False.
569         - max_bandwidth:   The maximum bandwidth (in MiB/s) that will be used.
570         - max_downtime:    Set maximum tolerable downtime for live-migration.
571                            The value represents a number of milliseconds the guest
572                            is allowed to be down at the end of live migration.
573         - parallel_connections: Specify a number of parallel network connections
574                            to be used to send memory pages to the destination host.
575         - compressed:      Activate compression.
576         - comp_methods:    A comma-separated list of compression methods. Supported
577                            methods are "mt" and "xbzrle" and can be  used in any
578                            combination. QEMU defaults to "xbzrle".
579         - comp_mt_level:   Set compression level. Values are in range from 0 to 9,
580                            where 1 is maximum speed and 9 is  maximum compression.
581         - comp_mt_threads: Set number of compress threads on source host.
582         - comp_mt_dthreads: Set number of decompress threads on target host.
583         - comp_xbzrle_cache: Set the size of page cache for xbzrle compression in bytes.
584         - copy_storage:    Migrate non-shared storage. It must be one of the following
585                            values: all (full disk copy) or incremental (Incremental copy)
586         - postcopy:        Enable the use of post-copy migration.
587         - postcopy_bandwidth: The maximum bandwidth allowed in post-copy phase. (MiB/s)
588         - username:        Username to connect with target host
589         - password:        Password to connect with target host
590     """
591     flags = 0
592     params = {}
593     migrated_state = libvirt.VIR_DOMAIN_RUNNING_MIGRATED
594     if kwargs.get("live", True):
595         flags |= libvirt.VIR_MIGRATE_LIVE
596     if kwargs.get("persistent", True):
597         flags |= libvirt.VIR_MIGRATE_PERSIST_DEST
598     if kwargs.get("undefinesource", True):
599         flags |= libvirt.VIR_MIGRATE_UNDEFINE_SOURCE
600     max_bandwidth = kwargs.get("max_bandwidth")
601     if max_bandwidth:
602         try:
603             bandwidth_value = int(max_bandwidth)
604         except ValueError:
605             raise SaltInvocationError(
606                 "Invalid max_bandwidth value: {}".format(max_bandwidth)
607             )
608         dom.migrateSetMaxSpeed(bandwidth_value)
609     max_downtime = kwargs.get("max_downtime")
610     if max_downtime:
611         try:
612             downtime_value = int(max_downtime)
613         except ValueError:
614             raise SaltInvocationError(
615                 "Invalid max_downtime value: {}".format(max_downtime)
616             )
617         dom.migrateSetMaxDowntime(downtime_value)
618     if kwargs.get("offline") is True:
619         flags |= libvirt.VIR_MIGRATE_OFFLINE
620         migrated_state = libvirt.VIR_DOMAIN_RUNNING_UNPAUSED
621     if kwargs.get("compressed") is True:
622         flags |= libvirt.VIR_MIGRATE_COMPRESSED
623     comp_methods = kwargs.get("comp_methods")
624     if comp_methods:
625         params[libvirt.VIR_MIGRATE_PARAM_COMPRESSION] = comp_methods.split(",")
626     comp_options = {
627         "comp_mt_level": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL,
628         "comp_mt_threads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS,
629         "comp_mt_dthreads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS,
630         "comp_xbzrle_cache": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE,
631     }
632     for (comp_option, param_key) in comp_options.items():
633         comp_option_value = kwargs.get(comp_option)
634         if comp_option_value:
635             try:
636                 params[param_key] = int(comp_option_value)
637             except ValueError:
638                 raise SaltInvocationError("Invalid {} value".format(comp_option))
639     parallel_connections = kwargs.get("parallel_connections")
640     if parallel_connections:
641         try:
642             params[libvirt.VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS] = int(
643                 parallel_connections
644             )
645         except ValueError:
646             raise SaltInvocationError("Invalid parallel_connections value")
647         flags |= libvirt.VIR_MIGRATE_PARALLEL
648     if __salt__["config.get"]("virt:tunnel"):
649         if parallel_connections:
650             raise SaltInvocationError(
651                 "Parallel migration isn't compatible with tunneled migration"
652             )
653         flags |= libvirt.VIR_MIGRATE_PEER2PEER
654         flags |= libvirt.VIR_MIGRATE_TUNNELLED
655     if kwargs.get("postcopy") is True:
656         flags |= libvirt.VIR_MIGRATE_POSTCOPY
657     postcopy_bandwidth = kwargs.get("postcopy_bandwidth")
658     if postcopy_bandwidth:
659         try:
660             postcopy_bandwidth_value = int(postcopy_bandwidth)
661         except ValueError:
662             raise SaltInvocationError("Invalid postcopy_bandwidth value")
663         dom.migrateSetMaxSpeed(
664             postcopy_bandwidth_value,
665             flags=libvirt.VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY,
666         )
667     copy_storage = kwargs.get("copy_storage")
668     if copy_storage:
669         if copy_storage == "all":
670             flags |= libvirt.VIR_MIGRATE_NON_SHARED_DISK
671         elif copy_storage in ["inc", "incremental"]:
672             flags |= libvirt.VIR_MIGRATE_NON_SHARED_INC
673         else:
674             raise SaltInvocationError("invalid copy_storage value")
675     try:
676         state = False
677         dst_conn = __get_conn(
678             connection=dst_uri,
679             username=kwargs.get("username"),
680             password=kwargs.get("password"),
681         )
682         new_dom = dom.migrate3(dconn=dst_conn, params=params, flags=flags)
683         if new_dom:
684             state = new_dom.state()
685         dst_conn.close()
686         return state and migrated_state in state
687     except libvirt.libvirtError as err:
688         dst_conn.close()
689         raise CommandExecutionError(err.get_error_message())
690 def _get_volume_path(pool, volume_name):
691     """
692     Get the path to a volume. If the volume doesn't exist, compute its path from the pool one.
693     """
694     if volume_name in pool.listVolumes():
695         volume = pool.storageVolLookupByName(volume_name)
696         volume_xml = ElementTree.fromstring(volume.XMLDesc())
697         return volume_xml.find("./target/path").text
698     pool_xml = ElementTree.fromstring(pool.XMLDesc())
699     pool_path = pool_xml.find("./target/path").text
700     return pool_path + "/" + volume_name
701 def _disk_from_pool(conn, pool, pool_xml, volume_name):
702     """
703     Create a disk definition out of the pool XML and volume name.
704     The aim of this function is to replace the volume-based definition when not handled by libvirt.
705     It returns the disk Jinja context to be used when creating the VM
706     """
707     pool_type = pool_xml.get("type")
708     disk_context = {}
709     if pool_type in ["dir", "netfs", "fs"]:
710         disk_context["type"] = "file"
711         disk_context["source_file"] = _get_volume_path(pool, volume_name)
712     elif pool_type in ["logical", "disk", "iscsi", "scsi"]:
713         disk_context["type"] = "block"
714         disk_context["format"] = "raw"
715         disk_context["source_file"] = _get_volume_path(pool, volume_name)
716     elif pool_type in ["rbd", "gluster", "sheepdog"]:
717         disk_context["type"] = "network"
718         disk_context["protocol"] = pool_type
719         disk_context["hosts"] = [
720             {"name": host.get("name"), "port": host.get("port")}
721             for host in pool_xml.findall(".//host")
722         ]
723         dir_node = pool_xml.find("./source/dir")
724         name_node = pool_xml.find("./source/name")
725         if name_node is not None:
726             disk_context["volume"] = "{}/{}".format(name_node.text, volume_name)
727         auth_node = pool_xml.find("./source/auth")
728         if auth_node is not None:
729             username = auth_node.get("username")
730             secret_node = auth_node.find("./secret")
731             usage = secret_node.get("usage")
732             if not usage:
733                 uuid = secret_node.get("uuid")
734                 usage = conn.secretLookupByUUIDString(uuid).usageID()
735             disk_context["auth"] = {
736                 "type": "ceph",
737                 "username": username,
738                 "usage": usage,
739             }
740     return disk_context
741 def _handle_unit(s, def_unit="m"):
742     """
743     Handle the unit conversion, return the value in bytes
744     """
745     m = re.match(r"(?P&lt;value&gt;[0-9.]*)\s*(?P&lt;unit&gt;.*)$", str(s).strip())
746     value = m.group("value")
747     unit = m.group("unit").lower() or def_unit
748     try:
749         value = int(value)
750     except ValueError:
751         try:
752             value = float(value)
753         except ValueError:
754             raise SaltInvocationError("invalid number")
755     dec = False
756     if re.match(r"[kmgtpezy]b$", unit):
757         dec = True
758     elif not re.match(r"(b|[kmgtpezy](ib)?)$", unit):
759         raise SaltInvocationError("invalid units")
760     p = "bkmgtpezy".index(unit[0])
761     value *= 10 ** (p * 3) if dec else 2 ** (p * 10)
762     return int(value)
763 def nesthash(value=None):
764     """
765     create default dict that allows arbitrary level of nesting
766     """
767     return collections.defaultdict(nesthash, value or {})
768 def _gen_xml(
769     conn,
770     name,
771     cpu,
772     mem,
773     diskp,
774     nicp,
775     hypervisor,
776     os_type,
777     arch,
778     graphics=None,
779     boot=None,
780     boot_dev=None,
781     numatune=None,
782     hypervisor_features=None,
783     clock=None,
784     serials=None,
785     consoles=None,
786     stop_on_reboot=False,
787     host_devices=None,
788     **kwargs
789 ):
790     """
791     Generate the XML string to define a libvirt VM
792     """
793     context = {
794         "hypervisor": hypervisor,
795         "name": name,
796         "hypervisor_features": hypervisor_features or {},
797         "clock": clock or {},
798         "on_reboot": "destroy" if stop_on_reboot else "restart",
799     }
800     context["to_kib"] = lambda v: int(_handle_unit(v) / 1024)
801     context["yesno"] = lambda v: "yes" if v else "no"
802     context["mem"] = nesthash()
803     if isinstance(mem, int):
804         context["mem"]["boot"] = mem
805         context["mem"]["current"] = mem
806     elif isinstance(mem, dict):
807         context["mem"] = nesthash(mem)
808     context["cpu"] = nesthash()
809     context["cputune"] = nesthash()
810     if isinstance(cpu, int):
811         context["cpu"]["maximum"] = str(cpu)
812     elif isinstance(cpu, dict):
813         context["cpu"] = nesthash(cpu)
814     if clock:
815         offset = "utc" if clock.get("utc", True) else "localtime"
816         if "timezone" in clock:
817             offset = "timezone"
818         context["clock"]["offset"] = offset
819     if hypervisor in ["qemu", "kvm"]:
820         context["numatune"] = numatune if numatune else {}
821         context["controller_model"] = False
822     elif hypervisor == "vmware":
823         context["controller_model"] = "lsilogic"
824     if graphics:
825         if "listen" not in graphics:
826             graphics["listen"] = {"type": "address", "address": "0.0.0.0"}
827         elif (
828             "address" not in graphics["listen"]
829             and graphics["listen"]["type"] == "address"
830         ):
831             graphics["listen"]["address"] = "0.0.0.0"
832         if graphics.get("type", "none") == "none":
833             graphics = None
834     context["graphics"] = graphics
835     context["boot_dev"] = boot_dev.split() if boot_dev is not None else ["hd"]
836     context["boot"] = boot if boot else {}
837     efi_value = context["boot"].get("efi", None) if boot else None
838     if efi_value is True:
839         context["boot"]["os_attrib"] = "firmware='efi'"
840     elif efi_value is not None and type(efi_value) != bool:
841         raise SaltInvocationError("Invalid efi value")
842     if os_type == "xen":
843         if __grains__["os_family"] == "Suse":
844             if not boot or not boot.get("kernel", None):
845                 paths = [
846                     path
847                     for path in ["/usr/share", "/usr/lib"]
848                     if os.path.exists(path + "/grub2/x86_64-xen/grub.xen")
849                 ]
850                 if not paths:
851                     raise CommandExecutionError("grub-x86_64-xen needs to be installed")
852                 context["boot"]["kernel"] = paths[0] + "/grub2/x86_64-xen/grub.xen"
853                 context["boot_dev"] = []
854     default_port = 23023
855     default_chardev_type = "tcp"
856     chardev_types = ["serial", "console"]
857     for chardev_type in chardev_types:
858         context[chardev_type + "s"] = []
859         parameter_value = locals()[chardev_type + "s"]
860         if parameter_value is not None:
861             for chardev in parameter_value:
862                 chardev_context = chardev
863                 chardev_context["type"] = chardev.get("type", default_chardev_type)
864                 if chardev_context["type"] == "tcp":
865                     chardev_context["port"] = chardev.get("port", default_port)
866                     chardev_context["protocol"] = chardev.get("protocol", "telnet")
867                 context[chardev_type + "s"].append(chardev_context)
868     context["disks"] = []
869     disk_bus_map = {"virtio": "vd", "xen": "xvd", "fdc": "fd", "ide": "hd"}
870     targets = []
871     for i, disk in enumerate(diskp):
872         prefix = disk_bus_map.get(disk["model"], "sd")
873         disk_context = {
874             "device": disk.get("device", "disk"),
875             "target_dev": _get_disk_target(targets, len(diskp), prefix),
876             "disk_bus": disk["model"],
877             "format": disk.get("format", "raw"),
878             "index": str(i),
879             "io": disk.get("io", "native"),
880             "iothread": disk.get("iothread_id", None),
881         }
882         targets.append(disk_context["target_dev"])
883         if disk.get("source_file"):
884             url = urllib.parse.urlparse(disk["source_file"])
885             if not url.scheme or not url.hostname:
886                 disk_context["source_file"] = disk["source_file"]
887                 disk_context["type"] = "file"
888             elif url.scheme in ["http", "https", "ftp", "ftps", "tftp"]:
889                 disk_context["type"] = "network"
890                 disk_context["protocol"] = url.scheme
891                 disk_context["volume"] = url.path
892                 disk_context["query"] = saxutils.escape(url.query)
893                 disk_context["hosts"] = [{"name": url.hostname, "port": url.port}]
894         elif disk.get("pool"):
895             disk_context["volume"] = disk["filename"]
896             pool = conn.storagePoolLookupByName(disk["pool"])
897             pool_xml = ElementTree.fromstring(pool.XMLDesc())
898             pool_type = pool_xml.get("type")
899             if hypervisor == "xen" or pool_type in ["rbd", "gluster", "sheepdog"]:
900                 disk_context.update(
901                     _disk_from_pool(conn, pool, pool_xml, disk_context["volume"])
902                 )
903             else:
904                 if pool_type in ["disk", "logical"]:
905                     disk_context["format"] = "raw"
906                 disk_context["type"] = "volume"
907                 disk_context["pool"] = disk["pool"]
908         else:
909             disk_context["type"] = "file"
910         if hypervisor in ["qemu", "kvm", "bhyve", "xen"]:
911             disk_context["address"] = False
912             disk_context["driver"] = True
913         elif hypervisor in ["esxi", "vmware"]:
914             disk_context["address"] = True
915             disk_context["driver"] = False
916         context["disks"].append(disk_context)
917     context["nics"] = nicp
918     hostdev_context = []
919     try:
920         for hostdev_name in host_devices or []:
921             hostdevice = conn.nodeDeviceLookupByName(hostdev_name)
922             doc = ElementTree.fromstring(hostdevice.XMLDesc())
923             if "pci" in hostdevice.listCaps():
924                 hostdev_context.append(
925                     {
926                         "type": "pci",
927                         "domain": "0x{:04x}".format(
928                             int(doc.find("./capability[@type='pci']/domain").text)
929                         ),
930                         "bus": "0x{:02x}".format(
931                             int(doc.find("./capability[@type='pci']/bus").text)
932                         ),
933                         "slot": "0x{:02x}".format(
934                             int(doc.find("./capability[@type='pci']/slot").text)
935                         ),
936                         "function": "0x{}".format(
937                             doc.find("./capability[@type='pci']/function").text
938                         ),
939                     }
940                 )
941             elif "usb_device" in hostdevice.listCaps():
942                 vendor_id = doc.find(".//vendor").get("id")
943                 product_id = doc.find(".//product").get("id")
944                 hostdev_context.append(
945                     {"type": "usb", "vendor": vendor_id, "product": product_id}
946                 )
947     except libvirt.libvirtError as err:
948         conn.close()
949         raise CommandExecutionError(
950             "Failed to get host devices: " + err.get_error_message()
951         )
952     context["hostdevs"] = hostdev_context
953     context["os_type"] = os_type
954     context["arch"] = arch
955     fn_ = "libvirt_domain.jinja"
956     try:
957         template = JINJA.get_template(fn_)
958     except jinja2.exceptions.TemplateNotFound:
959         log.error("Could not load template %s", fn_)
960         return ""
961     return template.render(**context)
962 def _gen_vol_xml(
963     name,
964     size,
965     format=None,
966     allocation=0,
967     type=None,
968     permissions=None,
969     backing_store=None,
970     nocow=False,
971 ):
972     """
973     Generate the XML string to define a libvirt storage volume
974     """
975     size = int(size) * 1024  # MB
976     context = {
977         "type": type,
978         "name": name,
979         "target": {"permissions": permissions, "nocow": nocow},
980         "format": format,
981         "size": str(size),
982         "allocation": str(int(allocation) * 1024),
983         "backingStore": backing_store,
984     }
985     fn_ = "libvirt_volume.jinja"
986     try:
987         template = JINJA.get_template(fn_)
988     except jinja2.exceptions.TemplateNotFound:
989         log.error("Could not load template %s", fn_)
990         return ""
991     return template.render(**context)
992 def _gen_net_xml(
993     name,
994     bridge,
995     forward,
996     vport,
997     tag=None,
998     ip_configs=None,
999     mtu=None,
1000     domain=None,
1001     nat=None,
1002     interfaces=None,
1003     addresses=None,
1004     physical_function=None,
1005     dns=None,
1006 ):
1007     """
1008     Generate the XML string to define a libvirt network
1009     """
1010     if isinstance(vport, str):
1011         vport_context = {"type": vport}
1012     else:
1013         vport_context = vport
1014     if isinstance(tag, (str, int)):
1015         tag_context = {"tags": [{"id": tag}]}
1016     else:
1017         tag_context = tag
1018     addresses_context = []
1019     if addresses:
1020         matches = [
1021             re.fullmatch(r"([0-9]+):([0-9A-Fa-f]+):([0-9A-Fa-f]+)\.([0-9])", addr)
1022             for addr in addresses.lower().split(" ")
1023         ]
1024         addresses_context = [
1025             {
1026                 "domain": m.group(1),
1027                 "bus": m.group(2),
1028                 "slot": m.group(3),
1029                 "function": m.group(4),
1030             }
1031             for m in matches
1032             if m
1033         ]
1034     context = {
1035         "name": name,
1036         "bridge": bridge,
1037         "mtu": mtu,
1038         "domain": domain,
1039         "forward": forward,
1040         "nat": nat,
1041         "interfaces": interfaces.split(" ") if interfaces else [],
1042         "addresses": addresses_context,
1043         "pf": physical_function,
1044         "vport": vport_context,
1045         "vlan": tag_context,
1046         "dns": dns,
1047         "ip_configs": [
1048             {
1049                 "address": ipaddress.ip_network(config["cidr"]),
1050                 "dhcp_ranges": config.get("dhcp_ranges", []),
1051                 "hosts": config.get("hosts", {}),
1052                 "bootp": config.get("bootp", {}),
1053                 "tftp": config.get("tftp"),
1054             }
1055             for config in ip_configs or []
1056         ],
1057         "yesno": lambda v: "yes" if v else "no",
1058     }
1059     fn_ = "libvirt_network.jinja"
1060     try:
1061         template = JINJA.get_template(fn_)
1062     except jinja2.exceptions.TemplateNotFound:
1063         log.error("Could not load template %s", fn_)
1064         return ""
1065     return template.render(**context)
1066 def _gen_pool_xml(
1067     name,
1068     ptype,
1069     target=None,
1070     permissions=None,
1071     source_devices=None,
1072     source_dir=None,
1073     source_adapter=None,
1074     source_hosts=None,
1075     source_auth=None,
1076     source_name=None,
1077     source_format=None,
1078     source_initiator=None,
1079 ):
1080     """
1081     Generate the XML string to define a libvirt storage pool
1082     """
1083     hosts = [host.split(":") for host in source_hosts or []]
1084     source = None
1085     if any(
1086         [
1087             source_devices,
1088             source_dir,
1089             source_adapter,
1090             hosts,
1091             source_auth,
1092             source_name,
1093             source_format,
1094             source_initiator,
1095         ]
1096     ):
1097         source = {
1098             "devices": source_devices or [],
1099             "dir": source_dir
1100             if source_format != "cifs" or not source_dir
1101             else source_dir.lstrip("/"),
1102             "adapter": source_adapter,
1103             "hosts": [
1104                 {"name": host[0], "port": host[1] if len(host) &gt; 1 else None}
1105                 for host in hosts
1106             ],
1107             "auth": source_auth,
1108             "name": source_name,
1109             "format": source_format,
1110             "initiator": source_initiator,
1111         }
1112     context = {
1113         "name": name,
1114         "ptype": ptype,
1115         "target": {"path": target, "permissions": permissions},
1116         "source": source,
1117     }
1118     fn_ = "libvirt_pool.jinja"
1119     try:
1120         template = JINJA.get_template(fn_)
1121     except jinja2.exceptions.TemplateNotFound:
1122         log.error("Could not load template %s", fn_)
1123         return ""
1124     return template.render(**context)
1125 def _gen_secret_xml(auth_type, usage, description):
1126     """
1127     Generate a libvirt secret definition XML
1128     """
1129     context = {
1130         "type": auth_type,
1131         "usage": usage,
1132         "description": description,
1133     }
1134     fn_ = "libvirt_secret.jinja"
1135     try:
1136         template = JINJA.get_template(fn_)
1137     except jinja2.exceptions.TemplateNotFound:
1138         log.error("Could not load template %s", fn_)
1139         return ""
1140     return template.render(**context)
1141 def _get_images_dir():
1142     """
1143     Extract the images dir from the configuration. First attempts to
1144     find legacy virt.images, then tries virt:images.
1145     """
1146     img_dir = __salt__["config.get"]("virt:images")
1147     log.debug("Image directory from config option `virt:images` is %s", img_dir)
1148     return img_dir
1149 def _zfs_image_create(
1150     vm_name,
1151     pool,
1152     disk_name,
1153     hostname_property_name,
1154     sparse_volume,
1155     disk_size,
1156     disk_image_name,
1157 ):
1158     """
1159     Clones an existing image, or creates a new one.
1160     When cloning an image, disk_image_name refers to the source
1161     of the clone. If not specified, disk_size is used for creating
1162     a new zvol, and sparse_volume determines whether to create
1163     a thin provisioned volume.
1164     The cloned or new volume can have a ZFS property set containing
1165     the vm_name. Use hostname_property_name for specifying the key
1166     of this ZFS property.
1167     """
1168     if not disk_image_name and not disk_size:
1169         raise CommandExecutionError(
1170             "Unable to create new disk {}, please specify"
1171             " the disk image name or disk size argument".format(disk_name)
1172         )
1173     if not pool:
1174         raise CommandExecutionError(
1175             "Unable to create new disk {}, please specify the disk pool name".format(
1176                 disk_name
1177             )
1178         )
1179     destination_fs = os.path.join(pool, "{}.{}".format(vm_name, disk_name))
1180     log.debug("Image destination will be %s", destination_fs)
1181     existing_disk = __salt__["zfs.list"](name=pool)
1182     if "error" in existing_disk:
1183         raise CommandExecutionError(
1184             "Unable to create new disk {}. {}".format(
1185                 destination_fs, existing_disk["error"]
1186             )
1187         )
1188     elif destination_fs in existing_disk:
1189         log.info("ZFS filesystem %s already exists. Skipping creation", destination_fs)
1190         blockdevice_path = os.path.join("/dev/zvol", pool, vm_name)
1191         return blockdevice_path
1192     properties = {}
1193     if hostname_property_name:
1194         properties[hostname_property_name] = vm_name
1195     if disk_image_name:
1196         __salt__["zfs.clone"](
1197             name_a=disk_image_name, name_b=destination_fs, properties=properties
1198         )
1199     elif disk_size:
1200         __salt__["zfs.create"](
1201             name=destination_fs,
1202             properties=properties,
1203             volume_size=disk_size,
1204             sparse=sparse_volume,
1205         )
1206     blockdevice_path = os.path.join(
1207         "/dev/zvol", pool, "{}.{}".format(vm_name, disk_name)
1208     )
1209     log.debug("Image path will be %s", blockdevice_path)
1210     return blockdevice_path
1211 def _qemu_image_create(disk, create_overlay=False, saltenv="base"):
1212     """
1213     Create the image file using specified disk_size or/and disk_image
1214     Return path to the created image file
1215     """
1216     disk_size = disk.get("size", None)
1217     disk_image = disk.get("image", None)
1218     if not disk_size and not disk_image:
1219         raise CommandExecutionError(
1220             "Unable to create new disk {}, please specify"
1221             " disk size and/or disk image argument".format(disk["filename"])
1222         )
1223     img_dest = disk["source_file"]
1224     img_dir = os.path.dirname(img_dest)
1225     log.debug("Image destination directory is %s", img_dir)
1226     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if not os.path.exists(img_dir):
1227         os.makedirs(img_dir)
1228     if disk_image:
1229         log.debug("Create disk from specified image %s", disk_image)
1230         qcow2 = False
1231         if salt.utils.path<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.which("qemu-img"):
1232             res = __salt__["cmd.run"]('qemu-img info "{}"'.format(sfn))
1233             imageinfo = salt.utils.yaml.safe_load(</b></font>res)
1234             qcow2 = imageinfo["file format"] == "qcow2"
1235         try:
1236             if create_overlay and qcow2:
1237                 log.info("Cloning qcow2 image %s using copy on write", sfn)
1238                 __salt__["cmd.run"](
1239                     'qemu-img create -f qcow2 -o backing_file="{}" "{}"'.format(
1240                         sfn, img_dest
1241                     ).split()
1242                 )
1243             else:
1244                 log.debug("Copying %s to %s", sfn, img_dest)
1245                 salt.utils.files.copyfile(sfn, img_dest)
1246             mask = salt.utils.files.get_umask()
1247             if disk_size and qcow2:
1248                 log.debug("Resize qcow2 image to %sM", disk_size)
1249                 __salt__["cmd.run"](
1250                     'qemu-img resize "{}" {}M'.format(img_dest, disk_size)
1251                 )
1252             log.debug("Apply umask and remove exec bit")
1253             mode = (0o0777 ^ mask) &amp; 0o0666
1254             os.chmod(img_dest, mode)
1255         except OSError as err:
1256             raise CommandExecutionError(
1257                 "Problem while copying image. {} - {}".format(disk_image, err)
1258             )
1259     else:
1260         try:
1261             if disk_size:
1262                 log<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.debug("Create empty image with size %sM", disk_size)
1263                 __salt__["cmd.run"](
1264                     'qemu-img create -f {} "{}" {}M'.format(
1265                         disk.get("format", "qcow2"), img_dest, disk_size
1266                     )
1267                 )
1268             else:
1269                 raise CommandExecutionError(
1270                     "Unable to create new disk {},"
1271                     " please specify &lt;size&gt; argument".format(</b></font>img_dest)
1272                 )
1273             log.debug("Apply umask and remove exec bit")
1274             mode = (0o0777 ^ mask) &amp; 0o0666
1275             os.chmod(img_dest, mode)
1276         except OSError as err:
1277             raise CommandExecutionError(
1278                 "Problem while creating volume {} - {}".format(img_dest, err)
1279             )
1280     return img_dest
1281 def _seed_image(seed_cmd, img_path, name, config, install, pub_key, priv_key):
1282     """
1283     Helper function to seed an existing image. Note that this doesn't
1284     handle volumes.
1285     """
1286     log.debug("Seeding image")
1287     __salt__[seed_cmd](
1288         img_path,
1289         id_=name,
1290         config=config,
1291         install=install,
1292         pub_key=pub_key,
1293         priv_key=priv_key,
1294     )
1295 def _disk_volume_create(conn, disk, seeder=None, saltenv="base"):
1296     """
1297     Create a disk volume for use in a VM
1298     """
1299     if disk.get("overlay_image"):
1300         raise SaltInvocationError(
1301             "Disk overlay_image property is not supported when creating volumes,"
1302             "use backing_store_path and backing_store_format instead."
1303         )
1304     pool = conn.storagePoolLookupByName(disk["pool"])
1305     if disk["filename"] in pool.listVolumes():
1306         return
1307     pool_type = ElementTree.fromstring(pool.XMLDesc()).get("type")
1308     backing_path = disk.get("backing_store_path")
1309     backing_format = disk.get("backing_store_format")
1310     backing_store = None
1311     if (
1312         backing_path
1313         and backing_format
1314         and (disk.get("format") == "qcow2" or pool_type == "logical")
1315     ):
1316         backing_store = {"path": backing_path, "format": backing_format}
1317     if backing_store and disk.get("image"):
1318         raise SaltInvocationError(
1319             "Using a template image with a backing store is not possible, "
1320             "choose either of them."
1321         )
1322     vol_xml = _gen_vol_xml(
1323         disk["filename"],
1324         disk.get("size", 0),
1325         format=disk.get("format"),
1326         backing_store=backing_store,
1327     _define_vol_xml_str(conn, vol_xml, disk.get("pool"))
1328     <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if disk.get("image"):
1329         log.debug("Caching disk template image: %s", disk.get("image"))
1330         cached_path = __salt__["cp.cache_file"](disk.get(</b></font>"image"), saltenv)
1331         if seeder:
1332             seeder(cached_path)
1333         _volume_upload(
1334             conn,
1335             disk["pool"],
1336             disk["filename"],
1337             cached_path,
1338             sparse=disk.get("format") == "qcow2",
1339         )
1340 def _disk_profile(conn, profile, hypervisor, disks, vm_name):
1341     """
1342     Gather the disk profile from the config or apply the default based
1343     on the active hypervisor
1344     This is the ``default`` profile for KVM/QEMU, which can be
1345     overridden in the configuration:
1346     .. code-block:: yaml
1347         virt:
1348           disk:
1349             default:
1350               - system:
1351                   size: 8192
1352                   format: qcow2
1353                   model: virtio
1354     Example profile for KVM/QEMU with two disks, first is created
1355     from specified image, the second is empty:
1356     .. code-block:: yaml
1357         virt:
1358           disk:
1359             two_disks:
1360               - system:
1361                   size: 8192
1362                   format: qcow2
1363                   model: virtio
1364                   image: http://path/to/image.qcow2
1365               - lvm:
1366                   size: 32768
1367                   format: qcow2
1368                   model: virtio
1369     The ``format`` and ``model`` parameters are optional, and will
1370     default to whatever is best suitable for the active hypervisor.
1371     """
1372     default = [{"system": {"size": 8192}}]
1373     if hypervisor == "vmware":
1374         overlay = {"format": "vmdk", "model": "scsi", "device": "disk"}
1375     elif hypervisor in ["qemu", "kvm"]:
1376         overlay = {"device": "disk", "model": "virtio"}
1377     elif hypervisor == "xen":
1378         overlay = {"device": "disk", "model": "xen"}
1379     elif hypervisor == "bhyve":
1380         overlay = {"format": "raw", "model": "virtio", "sparse_volume": False}
1381     else:
1382         overlay = {}
1383     disklist = []
1384     if profile:
1385         disklist = copy.deepcopy(
1386             __salt__["config.get"]("virt:disk", {}).get(profile, default)
1387         )
1388         disklist = [dict(d, name=name) for disk in disklist for name, d in disk.items()]
1389     if disks:
1390         for udisk in disks:
1391             if "name" in udisk:
1392                 found = [disk for disk in disklist if udisk["name"] == disk["name"]]
1393                 if found:
1394                     found[0].update(udisk)
1395                 else:
1396                     disklist.append(udisk)
1397     pool_caps = _pool_capabilities(conn)
1398     for disk in disklist:
1399         if disk.get("device", "disk") == "cdrom" and "model" not in disk:
1400             disk["model"] = "ide"
1401         for key, val in overlay.items():
1402             if key not in disk:
1403                 disk[key] = val
1404         if disk.get("source_file") and os.path.exists(disk["source_file"]):
1405             disk["filename"] = os.path.basename(disk["source_file"])
1406             if not disk.get("format"):
1407                 disk["format"] = (
1408                     "qcow2" if disk.get("device", "disk") != "cdrom" else "raw"
1409                 )
1410         elif vm_name and disk.get("device", "disk") == "disk":
1411             _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps)
1412     return disklist
1413 def _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps):
1414     """
1415     Compute the disk file name and update it in the disk value.
1416     """
1417     disk["filename"] = "{}_{}".format(vm_name, disk["name"])
1418     base_dir = disk.get("pool", None)
1419     if hypervisor in ["qemu", "kvm", "xen"]:
1420         if not base_dir:
1421             base_dir = _get_images_dir()
1422         if base_dir not in conn.listStoragePools():
1423             if not disk.get("format"):
1424                 disk["format"] = "qcow2"
1425             disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1426             disk["source_file"] = os.path.join(base_dir, disk["filename"])
1427         else:
1428             if "pool" not in disk:
1429                 disk["pool"] = base_dir
1430             pool_obj = conn.storagePoolLookupByName(base_dir)
1431             pool_xml = ElementTree.fromstring(pool_obj.XMLDesc())
1432             pool_type = pool_xml.get("type")
1433             if pool_type == "disk":
1434                 device = pool_xml.find("./source/device").get("path")
1435                 all_volumes = pool_obj.listVolumes()
1436                 if disk.get("source_file") not in all_volumes:
1437                     indexes = [
1438                         int(re.sub("[a-z]+", "", vol_name)) for vol_name in all_volumes
1439                     ] or [0]
1440                     index = min(
1441                         idx for idx in range(1, max(indexes) + 2) if idx not in indexes
1442                     )
1443                     disk["filename"] = "{}{}".format(os.path.basename(device), index)
1444             if disk.get("source_file"):
1445                 if not disk.get("source_file") in pool_obj.listVolumes():
1446                     raise SaltInvocationError(
1447                         "{} volume doesn't exist in pool {}".format(
1448                             disk.get("source_file"), base_dir
1449                         )
1450                     )
1451                 disk["filename"] = disk["source_file"]
1452                 del disk["source_file"]
1453             if not disk.get("format"):
1454                 volume_options = (
1455                     [
1456                         type_caps.get("options", {}).get("volume", {})
1457                         for type_caps in pool_caps.get("pool_types")
1458                         if type_caps["name"] == pool_type
1459                     ]
1460                     or [{}]
1461                 )[0]
1462                 if "qcow2" in volume_options.get("targetFormatType", []):
1463                     disk["format"] = "qcow2"
1464                 else:
1465                     disk["format"] = volume_options.get("default_format", None)
1466     elif hypervisor == "bhyve" and vm_name:
1467         disk["filename"] = "{}.{}".format(vm_name, disk["name"])
1468         disk["source_file"] = os.path.join(
1469             "/dev/zvol", base_dir or "", disk["filename"]
1470         )
1471     elif hypervisor in ["esxi", "vmware"]:
1472         if not base_dir:
1473             base_dir = __salt__["config.get"]("virt:storagepool", "[0] ")
1474         disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1475         disk["source_file"] = "{}{}".format(base_dir, disk["filename"])
1476 def _complete_nics(interfaces, hypervisor):
1477     """
1478     Complete missing data for network interfaces.
1479     """
1480     vmware_overlay = {"type": "bridge", "source": "DEFAULT", "model": "e1000"}
1481     kvm_overlay = {"type": "bridge", "source": "br0", "model": "virtio"}
1482     xen_overlay = {"type": "bridge", "source": "br0", "model": None}
1483     bhyve_overlay = {"type": "bridge", "source": "bridge0", "model": "virtio"}
1484     overlays = {
1485         "xen": xen_overlay,
1486         "kvm": kvm_overlay,
1487         "qemu": kvm_overlay,
1488         "vmware": vmware_overlay,
1489         "bhyve": bhyve_overlay,
1490     }
1491     def _normalize_net_types(attributes):
1492         """
1493         Guess which style of definition:
1494             bridge: br0
1495              or
1496             network: net0
1497              or
1498             type: network
1499             source: net0
1500         """
1501         for type_ in ["bridge", "network"]:
1502             if type_ in attributes:
1503                 attributes["type"] = type_
1504                 attributes["source"] = attributes.pop(type_)
1505         attributes["type"] = attributes.get("type", None)
1506         attributes["source"] = attributes.get("source", None)
1507     def _apply_default_overlay(attributes):
1508         """
1509         Apply the default overlay to attributes
1510         """
1511         for key, value in overlays[hypervisor].items():
1512             if key not in attributes or not attributes[key]:
1513                 attributes[key] = value
1514     for interface in interfaces:
1515         _normalize_net_types(interface)
1516         if hypervisor in overlays:
1517             _apply_default_overlay(interface)
1518     return interfaces
1519 def _nic_profile(profile_name, hypervisor):
1520     """
1521     Compute NIC data based on profile
1522     """
1523     config_data = __salt__["config.get"]("virt:nic", {}).get(
1524         profile_name, [{"eth0": {}}]
1525     )
1526     interfaces = []
1527     def append_dict_profile_to_interface_list(profile_dict):
1528         """
1529         Append dictionary profile data to interfaces list
1530         """
1531         for interface_name, attributes in profile_dict.items():
1532             attributes["name"] = interface_name
1533             interfaces.append(attributes)
1534     if isinstance(config_data, dict):
1535         append_dict_profile_to_interface_list(config_data)
1536     elif isinstance(config_data, list):
1537         for interface in config_data:
1538             if isinstance(interface, dict):
1539                 if len(interface) == 1:
1540                     append_dict_profile_to_interface_list(interface)
1541                 else:
1542                     interfaces.append(interface)
1543     return _complete_nics(interfaces, hypervisor)
1544 def _get_merged_nics(hypervisor, profile, interfaces=None):
1545     """
1546     Get network devices from the profile and merge uer defined ones with them.
1547     """
1548     nicp = _nic_profile(profile, hypervisor) if profile else []
1549     log.debug("NIC profile is %s", nicp)
1550     if interfaces:
1551         users_nics = _complete_nics(interfaces, hypervisor)
1552         for unic in users_nics:
1553             found = [nic for nic in nicp if nic["name"] == unic["name"]]
1554             if found:
1555                 found[0].update(unic)
1556             else:
1557                 nicp.append(unic)
1558         log.debug("Merged NICs: %s", nicp)
1559     return nicp
1560 def _handle_remote_boot_params(orig_boot):
1561     """
1562     Checks if the boot parameters contain a remote path. If so, it will copy
1563     the parameters, download the files specified in the remote path, and return
1564     a new dictionary with updated paths containing the canonical path to the
1565     kernel and/or initrd
1566     :param orig_boot: The original boot parameters passed to the init or update
1567     functions.
1568     """
1569     saltinst_dir = None
1570     new_boot = orig_boot.copy()
1571     keys = orig_boot.keys()
1572     cases = [
1573         {"efi"},
1574         {"kernel", "initrd", "efi"},
1575         {"kernel", "initrd", "cmdline", "efi"},
1576         {"loader", "nvram"},
1577         {"kernel", "initrd"},
1578         {"kernel", "initrd", "cmdline"},
1579         {"kernel", "initrd", "loader", "nvram"},
1580         {"kernel", "initrd", "cmdline", "loader", "nvram"},
1581     ]
1582     if keys in cases:
1583         for key in keys:
1584             if key == "efi" and type(orig_boot.get(key)) == bool:
1585                 new_boot[key] = orig_boot.get(key)
1586             elif orig_boot.get(key) is not None and salt.utils.virt.check_remote(
1587                 orig_boot.get(key)
1588             ):
1589                 if saltinst_dir is None:
1590                     os.makedirs(CACHE_DIR)
1591                     saltinst_dir = CACHE_DIR
1592                 new_boot[key] = salt.utils.virt.download_remote(
1593                     orig_boot.get(key), saltinst_dir
1594                 )
1595         return new_boot
1596     else:
1597         raise SaltInvocationError(
1598             "Invalid boot parameters,It has to follow this combination: [(kernel,"
1599             " initrd) or/and cmdline] or/and [(loader, nvram) or efi]"
1600         )
1601 def _handle_efi_param(boot, desc):
1602     """
1603     Checks if boot parameter contains efi boolean value, if so, handles the firmware attribute.
1604     :param boot: The boot parameters passed to the init or update functions.
1605     :param desc: The XML description of that domain.
1606     :return: A boolean value.
1607     """
1608     efi_value = boot.get("efi", None) if boot else None
1609     parent_tag = desc.find("os")
1610     os_attrib = parent_tag.attrib
1611     if efi_value is False and os_attrib != {}:
1612         parent_tag.attrib.pop("firmware", None)
1613         return True
1614     elif type(efi_value) == bool and os_attrib == {}:
1615         if efi_value is True and parent_tag.find("loader") is None:
1616             parent_tag.set("firmware", "efi")
1617             return True
1618         if efi_value is False and parent_tag.find("loader") is not None:
1619             parent_tag.remove(parent_tag.find("loader"))
1620             parent_tag.remove(parent_tag.find("nvram"))
1621             return True
1622     elif type(efi_value) != bool:
1623         raise SaltInvocationError("Invalid efi value")
1624     return False
1625 def init(
1626     name,
1627     cpu,
1628     mem,
1629     nic="default",
1630     interfaces=None,
1631     hypervisor=None,
1632     start=True,  # pylint: disable=redefined-outer-name
1633     disk="default",
1634     disks=None,
1635     saltenv="base",
1636     seed=True,
1637     install=True,
1638     pub_key=None,
1639     priv_key=None,
1640     seed_cmd="seed.apply",
1641     graphics=None,
1642     os_type=None,
1643     arch=None,
1644     boot=None,
1645     boot_dev=None,
1646     numatune=None,
1647     hypervisor_features=None,
1648     clock=None,
1649     serials=None,
1650     consoles=None,
1651     stop_on_reboot=False,
1652     host_devices=None,
1653     **kwargs
1654 ):
1655     """
1656     Initialize a new vm
1657     :param name: name of the virtual machine to create
1658     :param cpu:
1659         Number of virtual CPUs to assign to the virtual machine or a dictionary with detailed information to configure
1660         cpu model and topology, numa node tuning, cpu tuning and iothreads allocation. The structure of the dictionary is
1661         documented in :ref:`init-cpu-def`.
1662         .. code-block:: yaml
1663              cpu:
1664                placement: static
1665                cpuset: 0-11
1666                current: 5
1667                maximum: 12
1668                vcpus:
1669                  0:
1670                    enabled: True
1671                    hotpluggable: False
1672                    order: 1
1673                  1:
1674                    enabled: False
1675                    hotpluggable: True
1676                match: minimum
1677                mode: custom
1678                check: full
1679                vendor: Intel
1680                model:
1681                  name: core2duo
1682                  fallback: allow
1683                  vendor_id: GenuineIntel
1684                topology:
1685                  sockets: 1
1686                  cores: 12
1687                  threads: 1
1688                cache:
1689                  level: 3
1690                  mode: emulate
1691                features:
1692                  lahf: optional
1693                  pcid: require
1694                numa:
1695                  0:
1696                     cpus: 0-3
1697                     memory: 1g
1698                     discard: True
1699                     distances:
1700                       0: 10     # sibling id : value
1701                       1: 21
1702                       2: 31
1703                       3: 41
1704                  1:
1705                     cpus: 4-6
1706                     memory: 1g
1707                     memAccess: shared
1708                     distances:
1709                       0: 21
1710                       1: 10
1711                       2: 21
1712                       3: 31
1713                tuning:
1714                     vcpupin:
1715                       0: 1-4,^2  # vcpuid : cpuset
1716                       1: 0,1
1717                       2: 2,3
1718                       3: 0,4
1719                     emulatorpin: 1-3
1720                     iothreadpin:
1721                       1: 5,6    # iothread id: cpuset
1722                       2: 7,8
1723                     shares: 2048
1724                     period: 1000000
1725                     quota: -1
1726                     global_period: 1000000
1727                     global_quota: -1
1728                     emulator_period: 1000000
1729                     emulator_quota: -1
1730                     iothread_period: 1000000
1731                     iothread_quota: -1
1732                     vcpusched:
1733                       - scheduler: fifo
1734                         priority: 1
1735                         vcpus: 0,3-5
1736                       - scheduler: rr
1737                         priority: 3
1738                     iothreadsched:
1739                       - scheduler: idle
1740                       - scheduler: batch
1741                         iothreads: 2,3
1742                     emulatorsched:
1743                       - scheduler: batch
1744                     cachetune:
1745                       0-3:      # vcpus set
1746                         0:      # cache id
1747                           level: 3
1748                           type: both
1749                           size: 4
1750                         1:
1751                           level: 3
1752                           type: both
1753                           size: 6
1754                         monitor:
1755                           1: 3
1756                           0-3: 3
1757                       4-5:
1758                         monitor:
1759                           4: 3  # vcpus: level
1760                           5: 3
1761                     memorytune:
1762                       0-3:      # vcpus set
1763                         0: 60   # node id: bandwidth
1764                       4-5:
1765                         0: 60
1766                iothreads: 4
1767         .. versionadded:: 3003
1768     :param mem: Amount of memory to allocate to the virtual machine in MiB. Since 3002, a dictionary can be used to
1769         contain detailed configuration which support memory allocation or tuning. Supported parameters are ``boot``,
1770         ``current``, ``max``, ``slots``, ``hard_limit``, ``soft_limit``, ``swap_hard_limit``, ``min_guarantee``,
1771         ``hugepages`` ,  ``nosharepages``, ``locked``, ``source``, ``access``, ``allocation`` and ``discard``. The structure
1772         of the dictionary is documented in  :ref:`init-mem-def`. Both decimal and binary base are supported. Detail unit
1773         specification is documented  in :ref:`virt-units`. Please note that the value for ``slots`` must be an integer.
1774         .. code-block:: python
1775             {
1776                 'boot': 1g,
1777                 'current': 1g,
1778                 'max': 1g,
1779                 'slots': 10,
1780                 'hard_limit': '1024',
1781                 'soft_limit': '512m',
1782                 'swap_hard_limit': '1g',
1783                 'min_guarantee': '512mib',
1784                 'hugepages': [{'nodeset': '0-3,^2', 'size': '1g'}, {'nodeset': '2', 'size': '2m'}],
1785                 'nosharepages': True,
1786                 'locked': True,
1787                 'source': 'file',
1788                 'access': 'shared',
1789                 'allocation': 'immediate',
1790                 'discard': True
1791             }
1792         .. versionchanged:: 3002
1793     :param nic: NIC profile to use (Default: ``'default'``).
1794                 The profile interfaces can be customized / extended with the interfaces parameter.
1795                 If set to ``None``, no profile will be used.
1796     :param interfaces:
1797         List of dictionaries providing details on the network interfaces to create.
1798         These data are merged with the ones from the nic profile. The structure of
1799         each dictionary is documented in :ref:`init-nic-def`.
1800         .. versionadded:: 2019.2.0
1801     :param hypervisor: the virtual machine type. By default the value will be computed according
1802                        to the virtual host capabilities.
1803     :param start: ``True`` to start the virtual machine after having defined it (Default: ``True``)
1804     :param disk: Disk profile to use (Default: ``'default'``). If set to ``None``, no profile will be used.
1805     :param disks: List of dictionaries providing details on the disk devices to create.
1806                   These data are merged with the ones from the disk profile. The structure of
1807                   each dictionary is documented in :ref:`init-disk-def`.
1808                   .. versionadded:: 2019.2.0
1809     :param saltenv: Fileserver environment (Default: ``'base'``).
1810                     See :mod:`cp module for more details &lt;salt.modules.cp&gt;`
1811     :param seed: ``True`` to seed the disk image. Only used when the ``image`` parameter is provided.
1812                  (Default: ``True``)
1813     :param install: install salt minion if absent (Default: ``True``)
1814     :param pub_key: public key to seed with (Default: ``None``)
1815     :param priv_key: public key to seed with (Default: ``None``)
1816     :param seed_cmd: Salt command to execute to seed the image. (Default: ``'seed.apply'``)
1817     :param graphics:
1818         Dictionary providing details on the graphics device to create. (Default: ``None``)
1819         See :ref:`init-graphics-def` for more details on the possible values.
1820         .. versionadded:: 2019.2.0
1821     :param os_type:
1822         type of virtualization as found in the ``//os/type`` element of the libvirt definition.
1823         The default value is taken from the host capabilities, with a preference for ``hvm``.
1824         .. versionadded:: 2019.2.0
1825     :param arch:
1826         architecture of the virtual machine. The default value is taken from the host capabilities,
1827         but ``x86_64`` is prefed over ``i686``.
1828         .. versionadded:: 2019.2.0
1829     :param config: minion configuration to use when seeding.
1830                    See :mod:`seed module for more details &lt;salt.modules.seed&gt;`
1831     :param boot_dev: String of space-separated devices to boot from (Default: ``'hd'``)
1832     :param connection: libvirt connection URI, overriding defaults
1833                        .. versionadded:: 2019.2.0
1834     :param username: username to connect with, overriding defaults
1835                      .. versionadded:: 2019.2.0
1836     :param password: password to connect with, overriding defaults
1837                      .. versionadded:: 2019.2.0
1838     :param stop_on_reboot:
1839         If set to ``True`` the guest will stop instead of rebooting.
1840         This is specially useful when creating a virtual machine with an installation cdrom or
1841         an autoinstallation needing a special first boot configuration.
1842         Defaults to ``False``
1843         .. versionadded:: 3003
1844     :param boot:
1845         Specifies kernel, initial ramdisk and kernel command line parameters for the virtual machine.
1846         This is an optional parameter, all of the keys are optional within the dictionary. The structure of
1847         the dictionary is documented in :ref:`init-boot-def`. If a remote path is provided to kernel or initrd,
1848         salt will handle the downloading of the specified remote file and modify the XML accordingly.
1849         To boot VM with UEFI, specify loader and nvram path or specify 'efi': ``True`` if your libvirtd version
1850         is &gt;= 5.2.0 and QEMU &gt;= 3.0.0.
1851         .. versionadded:: 3000
1852         .. code-block:: python
1853             {
1854                 'kernel': '/root/f8-i386-vmlinuz',
1855                 'initrd': '/root/f8-i386-initrd',
1856                 'cmdline': 'console=ttyS0 ks=http://example.com/f8-i386/os/',
1857                 'loader': '/usr/share/OVMF/OVMF_CODE.fd',
1858                 'nvram': '/usr/share/OVMF/OVMF_VARS.ms.fd'
1859             }
1860     :param boot_dev:
1861         Space separated list of devices to boot from sorted by decreasing priority.
1862         Values can be ``hd``, ``fd``, ``cdrom`` or ``network``.
1863         By default, the value will ``"hd"``.
1864     :param numatune:
1865         The optional numatune element provides details of how to tune the performance of a NUMA host via controlling NUMA
1866         policy for domain process. The optional ``memory`` element specifies how to allocate memory for the domain process
1867         on a NUMA host. ``memnode`` elements can specify memory allocation policies per each guest NUMA node. The definition
1868         used in the dictionary can be found at :ref:`init-cpu-def`.
1869         .. versionadded:: 3003
1870         .. code-block:: python
1871             {
1872                 'memory': {'mode': 'strict', 'nodeset': '0-11'},
1873                 'memnodes': {0: {'mode': 'strict', 'nodeset': 1}, 1: {'mode': 'preferred', 'nodeset': 2}}
1874             }
1875     :param hypervisor_features:
1876         Enable or disable hypervisor-specific features on the virtual machine.
1877         .. versionadded:: 3003
1878         .. code-block:: yaml
1879             hypervisor_features:
1880               kvm-hint-dedicated: True
1881     :param clock:
1882         Configure the guest clock.
1883         The value is a dictionary with the following keys:
1884         adjustment
1885             time adjustment in seconds or ``reset``
1886         utc
1887             set to ``False`` to use the host local time as the guest clock. Defaults to ``True``.
1888         timezone
1889             synchronize the guest to the correspding timezone
1890         timers
1891             a dictionary associating the timer name with its configuration.
1892             This configuration is a dictionary with the properties ``track``, ``tickpolicy``,
1893             ``catchup``, ``frequency``, ``mode``, ``present``, ``slew``, ``threshold`` and ``limit``.
1894             See `libvirt time keeping documentation &lt;https://libvirt.org/formatdomain.html#time-keeping&gt;`_ for the possible values.
1895         .. versionadded:: 3003
1896         Set the clock to local time using an offset in seconds
1897         .. code-block:: yaml
1898             clock:
1899               adjustment: 3600
1900               utc: False
1901         Set the clock to a specific time zone:
1902         .. code-block:: yaml
1903             clock:
1904               timezone: CEST
1905         Tweak guest timers:
1906         .. code-block:: yaml
1907             clock:
1908               timers:
1909                 tsc:
1910                   frequency: 3504000000
1911                   mode: native
1912                 rtc:
1913                   track: wall
1914                   tickpolicy: catchup
1915                   slew: 4636
1916                   threshold: 123
1917                   limit: 2342
1918                 hpet:
1919                   present: False
1920     :param serials:
1921         Dictionary providing details on the serials connection to create. (Default: ``None``)
1922         See :ref:`init-chardevs-def` for more details on the possible values.
1923         .. versionadded:: 3003
1924     :param consoles:
1925         Dictionary providing details on the consoles device to create. (Default: ``None``)
1926         See :ref:`init-chardevs-def` for more details on the possible values.
1927         .. versionadded:: 3003
1928     :param host_devices:
1929         List of host devices to passthrough to the guest.
1930         The value is a list of device names as provided by the :py:func:`~salt.modules.virt.node_devices` function.
1931         (Default: ``None``)
1932         .. versionadded:: 3003
1933     .. _init-cpu-def:
1934     .. rubric:: cpu parameters definition
1935     The cpu parameters dictionary can contain the following properties:
1936     cpuset
1937         a comma-separated list of physical CPU numbers that domain process and virtual CPUs can be pinned to by default.
1938         eg. ``1-4,^3`` cpuset 3 is excluded.
1939     current
1940         the number of virtual cpus available at startup
1941     placement
1942         indicate the CPU placement mode for domain process. the value can be either ``static`` or ``auto``
1943     vcpus
1944         specify the state of individual vcpu. Possible attribute for each individual vcpu include: ``id``, ``enabled``,
1945         ``hotpluggable`` and ``order``. Valid ``ids`` are from 0 to the maximum vCPU count minus 1. ``enabled`` takes
1946         boolean values which controls the state of the vcpu. ``hotpluggable`` take boolean value which controls whether
1947         given vCPU can be hotplugged and hotunplugged. ``order`` takes an integer value which specifies the order to add
1948         the online vCPUs.
1949     match
1950         The cpu attribute ``match`` attribute specifies how strictly the virtual CPU provided to the guest matches the CPU
1951         requirements, possible values are ``minimum``, ``exact`` or ``strict``.
1952     check
1953         Optional cpu attribute ``check`` attribute can be used to request a specific way of checking whether the virtual
1954         CPU matches the specification, possible values are ``none``, ``partial`` and ``full``.
1955     mode
1956         Optional cpu attribute ``mode`` attribute may be used to make it easier to configure a guest CPU to be as close
1957         to host CPU as possible, possible values are ``custom``, ``host-model`` and ``host-passthrough``.
1958     model
1959         specifies CPU model requested by the guest. An optional ``fallback`` attribute can be used to forbid libvirt falls
1960         back to the closest model supported by the hypervisor, possible values are ``allow`` or ``forbid``. ``vendor_id``
1961         attribute can be used to set the vendor id seen by the guest, the length must be exactly 12 characters long.
1962     vendor
1963         specifies CPU vendor requested by the guest.
1964     topology
1965         specifies requested topology of virtual CPU provided to the guest. Four possible attributes , ``sockets``, ``dies``,
1966         ``cores``, and ``threads``, accept non-zero positive integer values. They refer to the number of CPU sockets per
1967         NUMA node, number of dies per socket, number of cores per die, and number of threads per core, respectively.
1968     features
1969         A dictionary contains a set of cpu features to fine-tune features provided by the selected CPU model. Use cpu
1970         feature ``name`` as the key and the ``policy`` as the value. ``policy`` Attribute takes ``force``, ``require``,
1971         ``optional``, ``disable`` or ``forbid``.
1972     cache
1973         describes the virtual CPU cache. Optional attribute ``level`` takes an integer value which describes cache level
1974         ``mode`` attribute supported three possible values: ``emulate``, ``passthrough``, ``disable``
1975     numa
1976         specify the guest numa topology. ``cell`` element specifies a NUMA cell or a NUMA node, ``cpus`` specifies the
1977         CPU or range of CPUs that are part of the node, ``memory`` specifies the size of the node memory. All cells
1978         should have ``id`` attribute in case referring to some cell is necessary in the code. optional attribute
1979         ``memAccess`` control whether the memory is to be mapped as ``shared`` or ``private``, ``discard`` attribute which
1980         fine tunes the discard feature for given numa node, possible values are ``True`` or ``False``.  ``distances``
1981         element define the distance between NUMA cells and ``sibling`` sub-element is used to specify the distance value
1982         between sibling NUMA cells.
1983     vcpupin
1984         The optional vcpupin element specifies which of host's physical CPUs the domain vCPU will be pinned to.
1985     emulatorpin
1986         The optional emulatorpin element specifies which of host physical CPUs the "emulator", a subset of a domain not
1987         including vCPU or iothreads will be pinned to.
1988     iothreadpin
1989         The optional iothreadpin element specifies which of host physical CPUs the IOThreads will be pinned to.
1990     shares
1991         The optional shares element specifies the proportional weighted share for the domain.
1992     period
1993         The optional period element specifies the enforcement interval (unit: microseconds).
1994     quota
1995         The optional quota element specifies the maximum allowed bandwidth (unit: microseconds).
1996     global_period
1997         The optional global_period element specifies the enforcement CFS scheduler interval (unit: microseconds) for the
1998         whole domain in contrast with period which enforces the interval per vCPU.
1999     global_quota
2000         The optional global_quota element specifies the maximum allowed bandwidth (unit: microseconds) within a period
2001         for the whole domain.
2002     emulator_period
2003         The optional emulator_period element specifies the enforcement interval (unit: microseconds).
2004     emulator_quota
2005         The optional emulator_quota element specifies the maximum allowed bandwidth (unit: microseconds) for domain's
2006         emulator threads (those excluding vCPUs).
2007     iothread_period
2008         The optional iothread_period element specifies the enforcement interval (unit: microseconds) for IOThreads.
2009     iothread_quota
2010         The optional iothread_quota element specifies the maximum allowed bandwidth (unit: microseconds) for IOThreads.
2011     vcpusched
2012         specify the scheduler type for vCPUs.
2013         The value is a list of dictionaries with the ``scheduler`` key (values ``batch``, ``idle``, ``fifo``, ``rr``)
2014         and the optional ``priority`` and ``vcpus`` keys. The ``priority`` value usually is a positive integer and the
2015         ``vcpus`` value is a cpu set like ``1-4,^3,6`` or simply the vcpu id.
2016     iothreadsched
2017         specify the scheduler type for IO threads.
2018         The value is a list of dictionaries with the ``scheduler`` key (values ``batch``, ``idle``, ``fifo``, ``rr``)
2019         and the optional ``priority`` and ``vcpus`` keys. The ``priority`` value usually is a positive integer and the
2020         ``vcpus`` value is a cpu set like ``1-4,^3,6`` or simply the vcpu id.
2021     emulatorsched
2022         specify the scheduler type (values batch, idle, fifo, rr) for particular the emulator.
2023         The value is a dictionary with the ``scheduler`` key (values ``batch``, ``idle``, ``fifo``, ``rr``)
2024         and the optional ``priority`` and ``vcpus`` keys. The ``priority`` value usually is a positive integer.
2025     cachetune
2026         Optional cachetune element can control allocations for CPU caches using the resctrl on the host.
2027     monitor
2028         The optional element monitor creates the cache monitor(s) for current cache allocation.
2029     memorytune
2030         Optional memorytune element can control allocations for memory bandwidth using the resctrl on the host.
2031     iothreads
2032         Number of threads for supported disk devices to perform I/O requests. iothread id will be numbered from 1 to
2033         the provided number (Default: None).
2034     .. _init-boot-def:
2035     .. rubric:: Boot parameters definition
2036     The boot parameters dictionary can contains the following properties:
2037     kernel
2038         The URL or path to the kernel to run the virtual machine with.
2039     initrd
2040         The URL or path to the initrd file to run the virtual machine with.
2041     cmdline
2042         The parameters to pass to the kernel provided in the `kernel` property.
2043     loader
2044         The path to the UEFI binary loader to use.
2045         .. versionadded:: 3001
2046     nvram
2047         The path to the UEFI data template. The file will be copied when creating the virtual machine.
2048         .. versionadded:: 3001
2049     efi
2050        A boolean value.
2051        .. versionadded:: 3001
2052     .. _init-mem-def:
2053     .. rubric:: Memory parameter definition
2054     Memory parameter can contain the following properties:
2055     boot
2056         The maximum allocation of memory for the guest at boot time
2057     current
2058         The actual allocation of memory for the guest
2059     max
2060         The run time maximum memory allocation of the guest
2061     slots
2062          specifies the number of slots available for adding memory to the guest
2063     hard_limit
2064         the maximum memory the guest can use
2065     soft_limit
2066         memory limit to enforce during memory contention
2067     swap_hard_limit
2068         the maximum memory plus swap the guest can use
2069     min_guarantee
2070         the guaranteed minimum memory allocation for the guest
2071     hugepages
2072         memory allocated using ``hugepages`` instead of the normal native page size. It takes a list of
2073         dictionaries with ``nodeset`` and ``size`` keys.
2074         For example ``"hugepages": [{"nodeset": "1-4,^3", "size": "2m"}, {"nodeset": "3", "size": "1g"}]``.
2075     nosharepages
2076         boolean value to instruct hypervisor to disable shared pages (memory merge, KSM) for this domain
2077     locked
2078         boolean value that allows memory pages belonging to the domain will be locked in host's memory and the host will
2079         not be allowed to swap them out, which might be required for some workloads such as real-time.
2080     source
2081         possible values are ``file`` which utilizes file memorybacking, ``anonymous`` by default and ``memfd`` backing.
2082         (QEMU/KVM only)
2083     access
2084         specify if the memory is to be ``shared`` or ``private``. This can be overridden per numa node by memAccess.
2085     allocation
2086         specify when to allocate the memory by supplying either ``immediate`` or ``ondemand``.
2087     discard
2088         boolean value to ensure the memory content is discarded just before guest shuts down (or when DIMM module is
2089         unplugged). Please note that this is just an optimization and is not guaranteed to work in all cases
2090         (e.g. when hypervisor crashes). (QEMU/KVM only)
2091     .. _init-nic-def:
2092     .. rubric:: Network Interfaces Definitions
2093     Network interfaces dictionaries can contain the following properties:
2094     name
2095         Name of the network interface. This is only used as a key to merge with the profile data
2096     type
2097         Network type. One of ``'bridge'``, ``'network'``
2098     source
2099         The network source, typically the bridge or network name
2100     mac
2101         The desired mac address, computed if ``None`` (Default: ``None``).
2102     model
2103         The network card model (Default: depends on the hypervisor)
2104     .. _init-disk-def:
2105     .. rubric:: Disks Definitions
2106     Disk dictionaries can contain the following properties:
2107     name
2108         Name of the disk. This is mostly used in the name of the disk image and as a key to merge
2109         with the profile data.
2110     format
2111         Format of the disk image, like ``'qcow2'``, ``'raw'``, ``'vmdk'``.
2112         (Default: depends on the hypervisor)
2113     size
2114         Disk size in MiB
2115     pool
2116         Path to the folder or name of the pool where disks should be created.
2117         (Default: depends on hypervisor and the virt:storagepool configuration)
2118         .. versionchanged:: 3001
2119         If the value contains no '/', it is considered a pool name where to create a volume.
2120         Using volumes will be mandatory for some pools types like rdb, iscsi, etc.
2121     model
2122         One of the disk busses allowed by libvirt (Default: depends on hypervisor)
2123         See the libvirt `disk element`_ documentation for the allowed bus types.
2124     image
2125         Path to the image to use for the disk. If no image is provided, an empty disk will be created
2126         (Default: ``None``)
2127         Note that some pool types do not support uploading an image. This list can evolve with libvirt
2128         versions.
2129     overlay_image
2130         ``True`` to create a QCOW2 disk image with ``image`` as backing file. If ``False``
2131         the file pointed to by the ``image`` property will simply be copied. (Default: ``False``)
2132         .. versionchanged:: 3001
2133         This property is only valid on path-based disks, not on volumes. To create a volume with a
2134         backing store, set the ``backing_store_path`` and ``backing_store_format`` properties.
2135     backing_store_path
2136         Path to the backing store image to use. This can also be the name of a volume to use as
2137         backing store within the same pool.
2138         .. versionadded:: 3001
2139     backing_store_format
2140         Image format of the disk or volume to use as backing store. This property is mandatory when
2141         using ``backing_store_path`` to avoid `problems &lt;https://libvirt.org/kbase/backing_chains.html#troubleshooting&gt;`_
2142         .. versionadded:: 3001
2143     source_file
2144         Absolute path to the disk image to use. Not to be confused with ``image`` parameter. This
2145         parameter is useful to use disk images that are created outside of this module. Can also
2146         be ``None`` for devices that have no associated image like cdroms.
2147         .. versionchanged:: 3001
2148         For volume disks, this can be the name of a volume already existing in the storage pool.
2149     device
2150         Type of device of the disk. Can be one of 'disk', 'cdrom', 'floppy' or 'lun'.
2151         (Default: ``'disk'``)
2152     hostname_property
2153         When using ZFS volumes, setting this value to a ZFS property ID will make Salt store the name of the
2154         virtual machine inside this property. (Default: ``None``)
2155     sparse_volume
2156         Boolean to specify whether to use a thin provisioned ZFS volume.
2157         Example profile for a bhyve VM with two ZFS disks. The first is
2158         cloned from the specified image. The second disk is a thin
2159         provisioned volume.
2160         .. code-block:: yaml
2161             virt:
2162               disk:
2163                 two_zvols:
2164                   - system:
2165                       image: zroot/bhyve/CentOS-7-x86_64-v1@v1.0.5
2166                       hostname_property: virt:hostname
2167                       pool: zroot/bhyve/guests
2168                   - data:
2169                       pool: tank/disks
2170                       size: 20G
2171                       hostname_property: virt:hostname
2172                       sparse_volume: True
2173     io
2174         I/O control policy. String value amongst ``native``, ``threads`` and ``io_uring``.
2175         (Default: ``native``)
2176         .. versionadded:: 3003
2177     iothread_id
2178         I/O thread id to assign the disk to.
2179         (Default: none assigned)
2180         .. versionadded:: 3003
2181     .. _init-graphics-def:
2182     .. rubric:: Graphics Definition
2183     The graphics dictionary can have the following properties:
2184     type
2185         Graphics type. The possible values are ``none``, ``'spice'``, ``'vnc'`` and other values
2186         allowed as a libvirt graphics type (Default: ``None``)
2187         See the libvirt `graphics element`_ documentation for more details on the possible types.
2188     port
2189         Port to export the graphics on for ``vnc``, ``spice`` and ``rdp`` types.
2190     tls_port
2191         Port to export the graphics over a secured connection for ``spice`` type.
2192     listen
2193         Dictionary defining on what address to listen on for ``vnc``, ``spice`` and ``rdp``.
2194         It has a ``type`` property with ``address`` and ``None`` as possible values, and an
2195         ``address`` property holding the IP or hostname to listen on.
2196         By default, not setting the ``listen`` part of the dictionary will default to
2197         listen on all addresses.
2198     .. _init-chardevs-def:
2199     .. rubric:: Serials and Consoles Definitions
2200     Serial dictionaries can contain the following properties:
2201     type
2202         Type of the serial connection, like ``'tcp'``, ``'pty'``, ``'file'``, ``'udp'``, ``'dev'``,
2203         ``'pipe'``, ``'unix'``.
2204     path
2205         Path to the source device. Can be a log file, a host character device to pass through,
2206         a unix socket, a named pipe path.
2207     host
2208         The serial UDP or TCP host name.
2209         (Default: 23023)
2210     port
2211         The serial UDP or TCP port number.
2212         (Default: 23023)
2213     protocol
2214         Name of the TCP connection protocol.
2215         (Default: telnet)
2216     tls
2217         Boolean value indicating whether to use hypervisor TLS certificates environment for TCP devices.
2218     target_port
2219         The guest device port number starting from 0
2220     target_type
2221         The guest device type. Common values are ``serial``, ``virtio`` or ``usb-serial``, but more are documented in
2222         `the libvirt documentation &lt;https://libvirt.org/formatdomain.html#consoles-serial-parallel-channel-devices&gt;`_.
2223     .. rubric:: CLI Example
2224     .. code-block:: bash
2225         salt 'hypervisor' virt.init vm_name 4 512 salt://path/to/image.raw
2226         salt 'hypervisor' virt.init vm_name 4 512 /var/lib/libvirt/images/img.raw
2227         salt 'hypervisor' virt.init vm_name 4 512 nic=profile disk=profile
2228     The disk images will be created in an image folder within the directory
2229     defined by the ``virt:images`` option. Its default value is
2230     ``/srv/salt-images/`` but this can changed with such a configuration:
2231     .. code-block:: yaml
2232         virt:
2233             images: /data/my/vm/images/
2234     .. _disk element: https://libvirt.org/formatdomain.html#elementsDisks
2235     .. _graphics element: https://libvirt.org/formatdomain.html#elementsGraphics
2236     """
2237     try:
2238         conn = __get_conn(**kwargs)
2239         caps = _capabilities(conn)
2240         os_types = sorted({guest["os_type"] for guest in caps["guests"]})
2241         arches = sorted({guest["arch"]["name"] for guest in caps["guests"]})
2242         virt_hypervisor = hypervisor
2243         if not virt_hypervisor:
2244             hypervisors = sorted(
2245                 {
2246                     x
2247                     for y in [
2248                         guest["arch"]["domains"].keys() for guest in caps["guests"]
2249                     ]
2250                     for x in y
2251                 }
2252             )
2253             if len(hypervisors) == 0:
2254                 raise SaltInvocationError("No supported hypervisors were found")
2255             virt_hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
2256         virt_hypervisor = "vmware" if virt_hypervisor == "esxi" else virt_hypervisor
2257         log.debug("Using hypervisor %s", virt_hypervisor)
2258         nicp = _get_merged_nics(virt_hypervisor, nic, interfaces)
2259         diskp = _disk_profile(conn, disk, virt_hypervisor, disks, name)
2260         for _disk in diskp:
2261             if _disk.get("device", "disk") == "cdrom":
2262                 continue
2263             log.debug("Creating disk for VM [ %s ]: %s", name, _disk)
2264             if virt_hypervisor == "vmware":
2265                 if "image" in _disk:
2266                     raise SaltInvocationError(
2267                         "virt.init does not support image "
2268                         "template in conjunction with esxi hypervisor"
2269                     )
2270                 else:
2271                     log.debug("Generating libvirt XML for %s", _disk)
2272                     volume_name = "{}/{}".format(name, _disk["name"])
2273                     filename = "{}.{}".format(volume_name, _disk["format"])
2274                     vol_xml = _gen_vol_xml(
2275                         filename, _disk["size"], format=_disk["format"]
2276                     )
2277                     _define_vol_xml_str(conn, vol_xml, pool=_disk.get("pool"))
2278             elif virt_hypervisor in ["qemu", "kvm", "xen"]:
2279                 def seeder(path):
2280                     _seed_image(
2281                         seed_cmd,
2282                         path,
2283                         name,
2284                         kwargs.get("config"),
2285                         install,
2286                         pub_key,
2287                         priv_key,
2288                     )
2289                 create_overlay = _disk.get("overlay_image", False)
2290                 format = _disk.get("format")
2291                 if _disk.get("source_file"):
2292                     if os.path.exists(_disk["source_file"]):
2293                         img_dest = _disk["source_file"]
2294                     else:
2295                         img_dest = _qemu_image_create(_disk, create_overlay, saltenv)
2296                 else:
2297                     _disk_volume_create(conn, _disk, seeder if seed else None, saltenv)
2298                     img_dest = None
2299                 if seed and img_dest and _disk.get("image", None):
2300                     seeder(img_dest)
2301             elif hypervisor in ["bhyve"]:
2302                 img_dest = _zfs_image_create(
2303                     vm_name=name,
2304                     pool=_disk.get("pool"),
2305                     disk_name=_disk.get("name"),
2306                     disk_size=_disk.get("size"),
2307                     disk_image_name=_disk.get("image"),
2308                     hostname_property_name=_disk.get("hostname_property"),
2309                     sparse_volume=_disk.get("sparse_volume"),
2310                 )
2311             else:
2312                 raise SaltInvocationError(
2313                     "Unsupported hypervisor when handling disk image: {}".format(
2314                         virt_hypervisor
2315                     )
2316                 )
2317         log.debug("Generating VM XML")
2318         if os_type is None:
2319             os_type = "hvm" if "hvm" in os_types else os_types[0]
2320         if arch is None:
2321             arch = "x86_64" if "x86_64" in arches else arches[0]
2322         if boot is not None:
2323             boot = _handle_remote_boot_params(boot)
2324         vm_xml = _gen_xml(
2325             conn,
2326             name,
2327             cpu,
2328             mem,
2329             diskp,
2330             nicp,
2331             virt_hypervisor,
2332             os_type,
2333             arch,
2334             graphics,
2335             boot,
2336             boot_dev,
2337             numatune,
2338             hypervisor_features,
2339             clock,
2340             serials,
2341             consoles,
2342             stop_on_reboot,
2343             host_devices,
2344             **kwargs
2345         )
2346         log.debug("New virtual machine definition: %s", vm_xml)
2347         conn.defineXML(vm_xml)
2348     except libvirt.libvirtError as err:
2349         conn.close()
2350         raise CommandExecutionError(err.get_error_message())
2351     if start:
2352         log.debug("Starting VM %s", name)
2353         _get_domain(conn, name).create()
2354     conn.close()
2355     return True
2356 def _disks_equal(disk1, disk2):
2357     """
2358     Test if two disk elements should be considered like the same device
2359     """
2360     target1 = disk1.find("target")
2361     target2 = disk2.find("target")
2362     disk1_dict = xmlutil.to_dict(disk1, True)
2363     source1_dict = disk1_dict.get("source", {})
2364     source2_dict <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= disk2_dict.get("source", {})
2365     io1 = disk1_dict.get("driver", {}).get("io", "native")
2366     io2 = disk2_dict.get("driver", {}).get(</b></font>"io", "native")
2367     if source1_dict:
2368         source1_dict.pop("index", None)
2369     if source2_dict:
2370         source2_dict.pop("index", None)
2371     return (
2372         source1_dict == source2_dict
2373         and target1 is not None
2374         and target2 is not None
2375         and target1.get("bus") == target2.get("bus")
2376         and disk1.get("device", "disk") == disk2.get("device", "disk")
2377         and target1.get("dev") == target2.get("dev")
2378         and io1 == io2
2379     )
2380 def _nics_equal(nic1, nic2):
2381     """
2382     Test if two interface elements should be considered like the same device
2383     """
2384     def _filter_nic(nic):
2385         """
2386         Filter out elements to ignore when comparing nics
2387         """
2388         source_node = nic.find("source")
2389         source_attrib = source_node.attrib if source_node is not None else {}
2390         source_type = "network" if "network" in source_attrib else nic.attrib["type"]
2391         source_getters = {
2392             "network": lambda n: n.get("network"),
2393             "bridge": lambda n: n.get("bridge"),
2394             "direct": lambda n: n.get("dev"),
2395             "hostdev": lambda n: _format_pci_address(n.find("address")),
2396         }
2397         return {
2398             "type": source_type,
2399             "source": source_getters[source_type](source_node)
2400             if source_node is not None
2401             else None,
2402             "model": nic.find("model").attrib["type"]
2403             if nic.find("model") is not None
2404             else None,
2405         }
2406     def _get_mac(nic):
2407         return (
2408             nic.find("mac").attrib["address"].lower()
2409             if nic.find("mac") is not None
2410             else None
2411         )
2412     mac1 = _get_mac(nic1)
2413     mac2 = _get_mac(nic2)
2414     macs_equal = not mac1 or not mac2 or mac1 == mac2
2415     return _filter_nic(nic1) == _filter_nic(nic2) and macs_equal
2416 def _graphics_equal(gfx1, gfx2):
2417     """
2418     Test if two graphics devices should be considered the same device
2419     """
2420     def _filter_graphics(gfx):
2421         """
2422         When the domain is running, the graphics element may contain additional properties
2423         with the default values. This function will strip down the default values.
2424         """
2425         gfx_copy = copy.deepcopy(gfx)
2426         defaults = [
2427             {"node": ".", "attrib": "port", "values": ["5900", "-1"]},
2428             {"node": ".", "attrib": "address", "values": ["127.0.0.1"]},
2429             {"node": "listen", "attrib": "address", "values": ["127.0.0.1"]},
2430         ]
2431         for default in defaults:
2432             node = gfx_copy.find(default["node"])
2433             attrib = default["attrib"]
2434             if node is not None and (
2435                 attrib in node.attrib and node.attrib[attrib] in default["values"]
2436             ):
2437                 node.attrib.pop(attrib)
2438         return gfx_copy
2439     return xmlutil.to_dict(_filter_graphics(gfx1), True) == xmlutil.to_dict(
2440         _filter_graphics(gfx2), True
2441     )
2442 def _hostdevs_equal(dev1, dev2):
2443     """
2444     Test if two hostdevs devices should be considered the same device
2445     """
2446     def _filter_hostdevs(dev):
2447         """
2448         When the domain is running, the hostdevs element may contain additional properties.
2449         This function will only keep the ones we care about
2450         """
2451         type_ = dev.get("type")
2452         definition = {
2453             "type": type_,
2454         }
2455         if type_ == "pci":
2456             address_node = dev.find("./source/address")
2457             for attr in ["domain", "bus", "slot", "function"]:
2458                 definition[attr] = address_node.get(attr)
2459         elif type_ == "usb":
2460             for attr in ["vendor", "product"]:
2461                 definition[attr] = dev.find("./source/" + attr).get("id")
2462         return definition
2463     return _filter_hostdevs(dev1) == _filter_hostdevs(dev2)
2464 def _diff_lists(old, new, comparator):
2465     """
2466     Compare lists to extract the changes
2467     :param old: old list
2468     :param new: new list
2469     :return: a dictionary with ``unchanged``, ``new``, ``deleted`` and ``sorted`` keys
2470     The sorted list is the union of unchanged and new lists, but keeping the original
2471     order from the new list.
2472     """
2473     def _remove_indent(node):
2474         """
2475         Remove the XML indentation to compare XML trees more easily
2476         """
2477         node_copy = copy.deepcopy(node)
2478         node_copy.text = None
2479         for item in node_copy.iter():
2480             item.tail = None
2481         return node_copy
2482     diff = {"unchanged": [], "new": [], "deleted": [], "sorted": []}
2483     old_devices = copy.deepcopy(old)
2484     for new_item in new:
2485         found = [
2486             item
2487             for item in old_devices
2488             if comparator(_remove_indent(item), _remove_indent(new_item))
2489         ]
2490         if found:
2491             old_devices.remove(found[0])
2492             diff["unchanged"].append(found[0])
2493             diff["sorted"].append(found[0])
2494         else:
2495             diff["new"].append(new_item)
2496             diff["sorted"].append(new_item)
2497     diff["deleted"] = old_devices
2498     return diff
2499 def _get_disk_target(targets, disks_count, prefix):
2500     """
2501     Compute the disk target name for a given prefix.
2502     :param targets: the list of already computed targets
2503     :param disks: the number of disks
2504     :param prefix: the prefix of the target name, i.e. "hd"
2505     """
2506     for i in range(disks_count):
2507         ret = "{}{}".format(prefix, string.ascii_lowercase[i])
2508         if ret not in targets:
2509             return ret
2510     return None
2511 def _diff_disk_lists(old, new):
2512     """
2513     Compare disk definitions to extract the changes and fix target devices
2514     :param old: list of ElementTree nodes representing the old disks
2515     :param new: list of ElementTree nodes representing the new disks
2516     """
2517     targets = []
2518     prefixes = ["fd", "hd", "vd", "sd", "xvd", "ubd"]
2519     for disk in new:
2520         target_node = disk.find("target")
2521         target = target_node.get("dev")
2522         prefix = [item for item in prefixes if target.startswith(item)][0]
2523         new_target = _get_disk_target(targets, len(new), prefix)
2524         target_node.set("dev", new_target)
2525         targets.append(new_target)
2526     return _diff_lists(old, new, _disks_equal)
2527 def _diff_interface_lists(old, new):
2528     """
2529     Compare network interface definitions to extract the changes
2530     :param old: list of ElementTree nodes representing the old interfaces
2531     :param new: list of ElementTree nodes representing the new interfaces
2532     """
2533     return _diff_lists(old, new, _nics_equal)
2534 def _diff_graphics_lists(old, new):
2535     """
2536     Compare graphic devices definitions to extract the changes
2537     :param old: list of ElementTree nodes representing the old graphic devices
2538     :param new: list of ElementTree nodes representing the new graphic devices
2539     """
2540     return _diff_lists(old, new, _graphics_equal)
2541 def _diff_hostdev_lists(old, new):
2542     """
2543     Compare hostdev devices definitions to extract the changes
2544     :param old: list of ElementTree nodes representing the old hostdev devices
2545     :param new: list of ElementTree nodes representing the new hostdev devices
2546     """
2547     return _diff_lists(old, new, _hostdevs_equal)
2548 def _expand_cpuset(cpuset):
2549     """
2550     Expand the libvirt cpuset and nodeset values into a list of cpu/node IDs
2551     """
2552     if cpuset is None:
2553         return None
2554     if isinstance(cpuset, int):
2555         return str(cpuset)
2556     result = set()
2557     toremove = set()
2558     for part in cpuset.split(","):
2559         m = re.match("([0-9]+)-([0-9]+)", part)
2560         if m:
2561             result |= set(range(int(m.group(1)), int(m.group(2)) + 1))
2562         elif part.startswith("^"):
2563             toremove.add(int(part[1:]))
2564         else:
2565             result.add(int(part))
2566     cpus = list(result - toremove)
2567     cpus.sort()
2568     cpus = [str(cpu) for cpu in cpus]
2569     return ",".join(cpus)
2570 def _normalize_cpusets(desc, data):
2571     """
2572     Expand the cpusets that can't be expanded by the change_xml() function,
2573     namely the ones that are used as keys and in the middle of the XPath expressions.
2574     """
2575     xpaths = ["cputune/cachetune", "cputune/cachetune/monitor", "cputune/memorytune"]
2576     for xpath in xpaths:
2577         nodes = desc.findall(xpath)
2578         for node in nodes:
2579             node.set("vcpus", _expand_cpuset(node.get("vcpus")))
2580     if not isinstance(data.get("cpu"), dict):
2581         return
2582     tuning = data["cpu"].get("tuning", {})
2583     for child in ["cachetune", "memorytune"]:
2584         if tuning.get(child):
2585             new_item = dict()
2586             for cpuset, value in tuning[child].items():
2587                 if child == "cachetune" and value.get("monitor"):
2588                     value["monitor"] = {
2589                         _expand_cpuset(monitor_cpus): monitor
2590                         for monitor_cpus, monitor in value["monitor"].items()
2591                     }
2592                 new_item[_expand_cpuset(cpuset)] = value
2593             tuning[child] = new_item
2594 def _serial_or_concole_equal(old, new):
2595     def _filter_serial_or_concole(item):
2596         """
2597         Filter out elements to ignore when comparing items
2598         """
2599         return {
2600             "type": item.attrib["type"],
2601             "port": item.find("source").get("service")
2602             if item.find("source") is not None
2603             else None,
2604             "protocol": item.find("protocol").get("type")
2605             if item.find("protocol") is not None
2606             else None,
2607         }
2608     return _filter_serial_or_concole(old) == _filter_serial_or_concole(new)
2609 def _diff_serial_lists(old, new):
2610     """
2611     Compare serial definitions to extract the changes
2612     :param old: list of ElementTree nodes representing the old serials
2613     :param new: list of ElementTree nodes representing the new serials
2614     """
2615     return _diff_lists(old, new, _serial_or_concole_equal)
2616 def _diff_console_lists(old, new):
2617     """
2618     Compare console definitions to extract the changes
2619     :param old: list of ElementTree nodes representing the old consoles
2620     :param new: list of ElementTree nodes representing the new consoles
2621     """
2622     return _diff_lists(old, new, _serial_or_concole_equal)
2623 def _format_pci_address(node):
2624     return "{}:{}:{}.{}".format(
2625         node.get("domain").replace("0x", ""),
2626         node.get("bus").replace("0x", ""),
2627         node.get("slot").replace("0x", ""),
2628         node.get("function").replace("0x", ""),
2629     )
2630 def _almost_equal(current, new):
2631     """
2632     return True if the parameters are numbers that are almost
2633     """
2634     if current is None or new is None:
2635         return False
2636     return abs(current - new) / current &lt; 1e-03
2637 def _compute_device_changes(old_xml, new_xml, to_skip):
2638     """
2639     Compute the device changes between two domain XML definitions.
2640     """
2641     devices_node = old_xml.find("devices")
2642     changes = {}
2643     for dev_type in to_skip:
2644         changes[dev_type] = {}
2645         if not to_skip[dev_type]:
2646             old = devices_node.findall(dev_type)
2647             new = new_xml.findall("devices/{}".format(dev_type))
2648             changes[dev_type] = globals()["_diff_{}_lists".format(dev_type)](old, new)
2649     return changes
2650 def _get_pci_addresses(node):
2651     """
2652     Get all the pci addresses in the node in 0000:00:00.0 form
2653     """
2654     return {_format_pci_address(address) for address in node.findall(".//address")}
2655 def _correct_networks(conn, desc):
2656     """
2657     Adjust the interface devices matching existing networks.
2658     Returns the network interfaces XML definition as string mapped to the new device node.
2659     """
2660     networks = [ElementTree.fromstring(net.XMLDesc()) for net in conn.listAllNetworks()]
2661     nics = desc.findall("devices/interface")
2662     device_map = {}
2663     for nic in nics:
2664         if nic.get("type") == "hostdev":
2665             addr = _get_pci_addresses(nic.find("source"))
2666             matching_nets = [
2667                 net
2668                 for net in networks
2669                 if net.find("forward").get("mode") == "hostdev"
2670                 and addr &amp; _get_pci_addresses(net)
2671             ]
2672             if matching_nets:
2673                 old_xml = ElementTree.tostring(nic)
2674                 nic.set("type", "network")
2675                 nic.find("source").set("network", matching_nets[0].find("name").text)
2676                 device_map[nic] = old_xml
2677     return device_map
2678 def _update_live(domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test):
2679     """
2680     Perform the live update of a domain.
2681     """
2682     status = {}
2683     errors = []
2684     if not domain.isActive():
2685         return status, errors
2686     commands = []
2687     if cpu and (isinstance(cpu, int) or isinstance(cpu, dict) and cpu.get("maximum")):
2688         new_cpu = cpu.get("maximum") if isinstance(cpu, dict) else cpu
2689         if old_cpu != new_cpu and new_cpu is not None:
2690             commands.append(
2691                 {
2692                     "device": "cpu",
2693                     "cmd": "setVcpusFlags",
2694                     "args": [new_cpu, libvirt.VIR_DOMAIN_AFFECT_LIVE],
2695                 }
2696             )
2697     if mem:
2698         if isinstance(mem, dict):
2699             new_mem = (
2700                 int(_handle_unit(mem.get("current")) / 1024)
2701                 if "current" in mem
2702                 else None
2703             )
2704         elif isinstance(mem, int):
2705             new_mem = int(mem * 1024)
2706         if not _almost_equal(old_mem, new_mem) and new_mem is not None:
2707             commands.append(
2708                 {
2709                     "device": "mem",
2710                     "cmd": "setMemoryFlags",
2711                     "args": [new_mem, libvirt.VIR_DOMAIN_AFFECT_LIVE],
2712                 }
2713             )
2714     old_desc = ElementTree.fromstring(domain.XMLDesc(0))
2715     changed_devices = {"interface": _correct_networks(domain.connect(), old_desc)}
2716     changes = _compute_device_changes(old_desc, new_desc, to_skip)
2717     removable_changes = []
2718     new_disks = []
2719     for new_disk in changes["disk"].get("new", []):
2720         device = new_disk.get("device", "disk")
2721         if device not in ["cdrom", "floppy"]:
2722             new_disks.append(new_disk)
2723             continue
2724         target_dev = new_disk.find("target").get("dev")
2725         matching = [
2726             old_disk
2727             for old_disk in changes["disk"].get("deleted", [])
2728             if old_disk.get("device", "disk") == device
2729             and old_disk.find("target").get("dev") == target_dev
2730         ]
2731         if not matching:
2732             new_disks.append(new_disk)
2733         else:
2734             updated_disk = matching[0]
2735             changes["disk"]["deleted"].remove(updated_disk)
2736             removable_changes.append(updated_disk)
2737             source_node = updated_disk.find("source")
2738             new_source_node = new_disk.find("source")
2739             source_file = (
2740                 new_source_node.get("file") if new_source_node is not None else None
2741             )
2742             updated_disk.set("type", "file")
2743             if source_node is not None:
2744                 updated_disk.remove(source_node)
2745             if source_file:
2746                 ElementTree.SubElement(
2747                     updated_disk, "source", attrib={"file": source_file}
2748                 )
2749     changes["disk"]["new"] = new_disks
2750     for dev_type in ["disk", "interface", "hostdev"]:
2751         for added in changes[dev_type].get("new", []):
2752             commands.append(
2753                 {
2754                     "device": dev_type,
2755                     "cmd": "attachDevice",
2756                     "args": [xmlutil.element_to_str(added)],
2757                 }
2758             )
2759         for removed in changes[dev_type].get("deleted", []):
2760             removed_def = changed_devices.get(dev_type, {}).get(
2761                 removed, ElementTree.tostring(removed)
2762             )
2763             commands.append(
2764                 {
2765                     "device": dev_type,
2766                     "cmd": "detachDevice",
2767                     "args": [salt.utils.stringutils.to_str(removed_def)],
2768                 }
2769             )
2770     for updated_disk in removable_changes:
2771         commands.append(
2772             {
2773                 "device": "disk",
2774                 "cmd": "updateDeviceFlags",
2775                 "args": [xmlutil.element_to_str(updated_disk)],
2776             }
2777         )
2778     for cmd in commands:
2779         try:
2780             ret = 0 if test else getattr(domain, cmd["cmd"])(*cmd["args"])
2781             device_type = cmd["device"]
2782             if device_type in ["cpu", "mem"]:
2783                 status[device_type] = not ret
2784             else:
2785                 actions = {
2786                     "attachDevice": "attached",
2787                     "detachDevice": "detached",
2788                     "updateDeviceFlags": "updated",
2789                 }
2790                 device_status = status.setdefault(device_type, {})
2791                 cmd_status = device_status.setdefault(actions[cmd["cmd"]], [])
2792                 cmd_status.append(cmd["args"][0])
2793         except libvirt.libvirtError as err:
2794             errors.append(str(err))
2795     return status, errors
2796 def update(
2797     name,
2798     cpu=0,
2799     mem=0,
2800     disk_profile=None,
2801     disks=None,
2802     nic_profile=None,
2803     interfaces=None,
2804     graphics=None,
2805     live=True,
2806     boot=None,
2807     numatune=None,
2808     test=False,
2809     boot_dev=None,
2810     hypervisor_features=None,
2811     clock=None,
2812     serials=None,
2813     consoles=None,
2814     stop_on_reboot=False,
2815     host_devices=None,
2816     **kwargs
2817 ):
2818     """
2819     Update the definition of an existing domain.
2820     :param name: Name of the domain to update
2821     :param cpu:
2822         Number of virtual CPUs to assign to the virtual machine or a dictionary with detailed information to configure
2823         cpu model and topology, numa node tuning, cpu tuning and iothreads allocation. The structure of the dictionary is
2824         documented in :ref:`init-cpu-def`.
2825         To update any cpu parameters specify the new values to the corresponding tag. To remove any element or attribute,
2826         specify ``None`` object. Please note that ``None`` object is mapped to ``null`` in yaml, use ``null`` in sls file
2827         instead.
2828     :param mem: Amount of memory to allocate to the virtual machine in MiB. Since 3002, a dictionary can be used to
2829         contain detailed configuration which support memory allocation or tuning. Supported parameters are ``boot``,
2830         ``current``, ``max``, ``slots``, ``hard_limit``, ``soft_limit``, ``swap_hard_limit``, ``min_guarantee``,
2831         ``hugepages`` ,  ``nosharepages``, ``locked``, ``source``, ``access``, ``allocation`` and ``discard``. The structure
2832         of the dictionary is documented in  :ref:`init-mem-def`. Both decimal and binary base are supported. Detail unit
2833         specification is documented  in :ref:`virt-units`. Please note that the value for ``slots`` must be an integer.
2834         To remove any parameters, pass a None object, for instance: 'soft_limit': ``None``. Please note  that ``None``
2835         is mapped to ``null`` in sls file, pass ``null`` in sls file instead.
2836         .. code-block:: yaml
2837             - mem:
2838                 hard_limit: null
2839                 soft_limit: null
2840         .. versionchanged:: 3002
2841     :param disk_profile: disk profile to use
2842     :param disks:
2843         Disk definitions as documented in the :func:`init` function.
2844         If neither the profile nor this parameter are defined, the disk devices
2845         will not be changed. However to clear disks set this parameter to empty list.
2846     :param nic_profile: network interfaces profile to use
2847     :param interfaces:
2848         Network interface definitions as documented in the :func:`init` function.
2849         If neither the profile nor this parameter are defined, the interface devices
2850         will not be changed. However to clear network interfaces set this parameter
2851         to empty list.
2852     :param graphics:
2853         The new graphics definition as defined in :ref:`init-graphics-def`. If not set,
2854         the graphics will not be changed. To remove a graphics device, set this parameter
2855         to ``{'type': 'none'}``.
2856     :param live:
2857         ``False`` to avoid trying to live update the definition. In such a case, the
2858         new definition is applied at the next start of the virtual machine. If ``True``,
2859         not all aspects of the definition can be live updated, but as much as possible
2860         will be attempted. (Default: ``True``)
2861     :param connection: libvirt connection URI, overriding defaults
2862     :param username: username to connect with, overriding defaults
2863     :param password: password to connect with, overriding defaults
2864     :param boot:
2865         Specifies kernel, initial ramdisk and kernel command line parameters for the virtual machine.
2866         This is an optional parameter, all of the keys are optional within the dictionary.
2867         Refer to :ref:`init-boot-def` for the complete boot parameter description.
2868         To update any boot parameters, specify the new path for each. To remove any boot parameters, pass ``None`` object,
2869         for instance: 'kernel': ``None``. To switch back to BIOS boot, specify ('loader': ``None`` and 'nvram': ``None``)
2870         or 'efi': ``False``. Please note that ``None`` is mapped to ``null`` in sls file, pass ``null`` in sls file instead.
2871         SLS file Example:
2872         .. code-block:: yaml
2873             - boot:
2874                 loader: null
2875                 nvram: null
2876         .. versionadded:: 3000
2877     :param boot_dev:
2878         Space separated list of devices to boot from sorted by decreasing priority.
2879         Values can be ``hd``, ``fd``, ``cdrom`` or ``network``.
2880         By default, the value will ``"hd"``.
2881         .. versionadded:: 3002
2882     :param numatune:
2883         The optional numatune element provides details of how to tune the performance of a NUMA host via controlling NUMA
2884         policy for domain process. The optional ``memory`` element specifies how to allocate memory for the domain process
2885         on a NUMA host. ``memnode`` elements can specify memory allocation policies per each guest NUMA node. The definition
2886         used in the dictionary can be found at :ref:`init-cpu-def`.
2887         To update any numatune parameters, specify the new value. To remove any ``numatune`` parameters, pass a None object,
2888         for instance: 'numatune': ``None``. Please note that ``None`` is mapped to ``null`` in sls file, pass ``null`` in
2889         sls file instead.
2890         .. versionadded:: 3003
2891     :param serials:
2892         Dictionary providing details on the serials connection to create. (Default: ``None``)
2893         See :ref:`init-chardevs-def` for more details on the possible values.
2894         .. versionadded:: 3003
2895     :param consoles:
2896         Dictionary providing details on the consoles device to create. (Default: ``None``)
2897         See :ref:`init-chardevs-def` for more details on the possible values.
2898         .. versionadded:: 3003
2899     :param stop_on_reboot:
2900         If set to ``True`` the guest will stop instead of rebooting.
2901         This is specially useful when creating a virtual machine with an installation cdrom or
2902         an autoinstallation needing a special first boot configuration.
2903         Defaults to ``False``
2904         .. versionadded:: 3003
2905     :param test: run in dry-run mode if set to True
2906         .. versionadded:: 3001
2907     :param hypervisor_features:
2908         Enable or disable hypervisor-specific features on the virtual machine.
2909         .. versionadded:: 3003
2910         .. code-block:: yaml
2911             hypervisor_features:
2912               kvm-hint-dedicated: True
2913     :param clock:
2914         Configure the guest clock.
2915         The value is a dictionary with the following keys:
2916         adjustment
2917             time adjustment in seconds or ``reset``
2918         utc
2919             set to ``False`` to use the host local time as the guest clock. Defaults to ``True``.
2920         timezone
2921             synchronize the guest to the correspding timezone
2922         timers
2923             a dictionary associating the timer name with its configuration.
2924             This configuration is a dictionary with the properties ``track``, ``tickpolicy``,
2925             ``catchup``, ``frequency``, ``mode``, ``present``, ``slew``, ``threshold`` and ``limit``.
2926             See `libvirt time keeping documentation &lt;https://libvirt.org/formatdomain.html#time-keeping&gt;`_ for the possible values.
2927         .. versionadded:: 3003
2928         Set the clock to local time using an offset in seconds
2929         .. code-block:: yaml
2930             clock:
2931               adjustment: 3600
2932               utc: False
2933         Set the clock to a specific time zone:
2934         .. code-block:: yaml
2935             clock:
2936               timezone: CEST
2937         Tweak guest timers:
2938         .. code-block:: yaml
2939             clock:
2940               timers:
2941                 tsc:
2942                   frequency: 3504000000
2943                   mode: native
2944                 rtc:
2945                   track: wall
2946                   tickpolicy: catchup
2947                   slew: 4636
2948                   threshold: 123
2949                   limit: 2342
2950                 hpet:
2951                   present: False
2952     :param host_devices:
2953         List of host devices to passthrough to the guest.
2954         The value is a list of device names as provided by the :py:func:`~salt.modules.virt.node_devices` function.
2955         (Default: ``None``)
2956         .. versionadded:: 3003
2957     :return:
2958         Returns a dictionary indicating the status of what has been done. It is structured in
2959         the following way:
2960         .. code-block:: python
2961             {
2962               'definition': True,
2963               'cpu': True,
2964               'mem': True,
2965               'disks': {'attached': [list of actually attached disks],
2966                         'detached': [list of actually detached disks]},
2967               'nics': {'attached': [list of actually attached nics],
2968                        'detached': [list of actually detached nics]},
2969               'errors': ['error messages for failures']
2970             }
2971     .. versionadded:: 2019.2.0
2972     CLI Example:
2973     .. code-block:: bash
2974         salt '*' virt.update domain cpu=2 mem=1024
2975     """
2976     status = {
2977         "definition": False,
2978         "disk": {"attached": [], "detached": [], "updated": []},
2979         "interface": {"attached": [], "detached": []},
2980     }
2981     conn = __get_conn(**kwargs)
2982     domain = _get_domain(conn, name)
2983     desc = ElementTree.fromstring(domain.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
2984     need_update = False
2985     hypervisor = desc.get("type")
2986     all_disks = _disk_profile(conn, disk_profile, hypervisor, disks, name)
2987     if boot is not None:
2988         boot = _handle_remote_boot_params(boot)
2989         if boot.get("efi", None) is not None:
2990             need_update = _handle_efi_param(boot, desc)
2991     new_desc = ElementTree.fromstring(
2992         _gen_xml(
2993             conn,
2994             name,
2995             cpu,
2996             mem or 0,
2997             all_disks,
2998             _get_merged_nics(hypervisor, nic_profile, interfaces),
2999             hypervisor,
3000             domain.OSType(),
3001             desc.find(".//os/type").get("arch"),
3002             graphics,
3003             boot,
3004             boot_dev,
3005             numatune,
3006             serials=serials,
3007             consoles=consoles,
3008             stop_on_reboot=stop_on_reboot,
3009             host_devices=host_devices,
3010             **kwargs
3011         )
3012     )
3013     if clock:
3014         offset = "utc" if clock.get("utc", True) else "localtime"
3015         if "timezone" in clock:
3016             offset = "timezone"
3017         clock["offset"] = offset
3018     def _set_loader(node, value):
3019         salt.utils.xmlutil.set_node_text(node, value)
3020         if value is not None:
3021             node.set("readonly", "yes")
3022             node.set("type", "pflash")
3023     def _set_nvram(node, value):
3024         node.set("template", value)
3025     def _set_with_byte_unit(attr_name=None):
3026         def _setter(node, value):
3027             if attr_name:
3028                 node.set(attr_name, str(value))
3029             else:
3030                 node.text = str(value)
3031             node.set("unit", "bytes")
3032         return _setter
3033     def _get_with_unit(node):
3034         unit = node.get("unit", "KiB")
3035         unit = unit if unit != "bytes" else "b"
3036         value = node.get("memory") or node.get("size") or node.text
3037         return _handle_unit("{}{}".format(value, unit)) if value else None
3038     def _set_vcpu(node, value):
3039         node.text = str(value)
3040         node.set("current", str(value))
3041     old_mem = int(_get_with_unit(desc.find("memory")) / 1024)
3042     old_cpu = int(desc.find("./vcpu").text)
3043     def _yesno_attribute(path, xpath, attr_name, ignored=None):
3044         return xmlutil.attribute(
3045             path, xpath, attr_name, ignored, lambda v: "yes" if v else "no"
3046         )
3047     def _memory_parameter(path, xpath, attr_name=None, ignored=None):
3048         entry = {
3049             "path": path,
3050             "xpath": xpath,
3051             "convert": _handle_unit,
3052             "get": _get_with_unit,
3053             "set": _set_with_byte_unit(attr_name),
3054             "equals": _almost_equal,
3055         }
3056         if attr_name:
3057             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
3058         return entry
3059     def _cpuset_parameter(path, xpath, attr_name=None, ignored=None):
3060         def _set_cpuset(node, value):
3061             if attr_name:
3062                 node.set(attr_name, value)
3063             else:
3064                 node.text = value
3065         entry = {
3066             "path": path,
3067             "xpath": xpath,
3068             "convert": _expand_cpuset,
3069             "get": lambda n: _expand_cpuset(n.get(attr_name) if attr_name else n.text),
3070             "set": _set_cpuset,
3071         }
3072         if attr_name:
3073             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
3074         return entry
3075     data = {k: v for k, v in locals().items() if bool(v)}
3076     data["stop_on_reboot"] = stop_on_reboot
3077     if boot_dev:
3078         data["boot_dev"] = boot_dev.split()
3079     timer_names = [
3080         "platform",
3081         "hpet",
3082         "kvmclock",
3083         "pit",
3084         "rtc",
3085         "tsc",
3086         "hypervclock",
3087         "armvtimer",
3088     ]
3089     if data.get("clock", {}).get("timers"):
3090         attributes = [
3091             "track",
3092             "tickpolicy",
3093             "frequency",
3094             "mode",
3095             "present",
3096             "slew",
3097             "threshold",
3098             "limit",
3099         ]
3100         for timer in data["clock"]["timers"].values():
3101             for attribute in attributes:
3102                 if attribute not in timer:
3103                     timer[attribute] = None
3104         for timer_name in timer_names:
3105             if timer_name not in data["clock"]["timers"]:
3106                 data["clock"]["timers"][timer_name] = None
3107     _normalize_cpusets(desc, data)
3108     params_mapping = [
3109         {
3110             "path": "stop_on_reboot",
3111             "xpath": "on_reboot",
3112             "convert": lambda v: "destroy" if v else "restart",
3113         },
3114         {"path": "boot:kernel", "xpath": "os/kernel"},
3115         {"path": "boot:initrd", "xpath": "os/initrd"},
3116         {"path": "boot:cmdline", "xpath": "os/cmdline"},
3117         {"path": "boot:loader", "xpath": "os/loader", "set": _set_loader},
3118         {"path": "boot:nvram", "xpath": "os/nvram", "set": _set_nvram},
3119         _memory_parameter("mem", "memory"),
3120         _memory_parameter("mem", "currentMemory"),
3121         _memory_parameter("mem:max", "maxMemory"),
3122         _memory_parameter("mem:boot", "memory"),
3123         _memory_parameter("mem:current", "currentMemory"),
3124         xmlutil.attribute("mem:slots", "maxMemory", "slots", ["unit"]),
3125         _memory_parameter("mem:hard_limit", "memtune/hard_limit"),
3126         _memory_parameter("mem:soft_limit", "memtune/soft_limit"),
3127         _memory_parameter("mem:swap_hard_limit", "memtune/swap_hard_limit"),
3128         _memory_parameter("mem:min_guarantee", "memtune/min_guarantee"),
3129         xmlutil.attribute("boot_dev:{dev}", "os/boot[$dev]", "dev"),
3130         _memory_parameter(
3131             "mem:hugepages:{id}:size",
3132             "memoryBacking/hugepages/page[$id]",
3133             "size",
3134             ["unit", "nodeset"],
3135         ),
3136         _cpuset_parameter(
3137             "mem:hugepages:{id}:nodeset", "memoryBacking/hugepages/page[$id]", "nodeset"
3138         ),
3139         {
3140             "path": "mem:nosharepages",
3141             "xpath": "memoryBacking/nosharepages",
3142             "get": lambda n: n is not None,
3143             "set": lambda n, v: None,
3144         },
3145         {
3146             "path": "mem:locked",
3147             "xpath": "memoryBacking/locked",
3148             "get": lambda n: n is not None,
3149             "set": lambda n, v: None,
3150         },
3151         xmlutil.attribute("mem:source", "memoryBacking/source", "type"),
3152         xmlutil.attribute("mem:access", "memoryBacking/access", "mode"),
3153         xmlutil.attribute("mem:allocation", "memoryBacking/allocation", "mode"),
3154         {"path": "mem:discard", "xpath": "memoryBacking/discard"},
3155         {
3156             "path": "cpu",
3157             "xpath": "vcpu",
3158             "get": lambda n: int(n.text),
3159             "set": _set_vcpu,
3160         },
3161         {"path": "cpu:maximum", "xpath": "vcpu", "get": lambda n: int(n.text)},
3162         xmlutil.attribute("cpu:placement", "vcpu", "placement"),
3163         _cpuset_parameter("cpu:cpuset", "vcpu", "cpuset"),
3164         xmlutil.attribute("cpu:current", "vcpu", "current"),
3165         xmlutil.attribute("cpu:match", "cpu", "match"),
3166         xmlutil.attribute("cpu:mode", "cpu", "mode"),
3167         xmlutil.attribute("cpu:check", "cpu", "check"),
3168         {"path": "cpu:model:name", "xpath": "cpu/model"},
3169         xmlutil.attribute("cpu:model:fallback", "cpu/model", "fallback"),
3170         xmlutil.attribute("cpu:model:vendor_id", "cpu/model", "vendor_id"),
3171         {"path": "cpu:vendor", "xpath": "cpu/vendor"},
3172         xmlutil.attribute("cpu:topology:sockets", "cpu/topology", "sockets"),
3173         xmlutil.attribute("cpu:topology:cores", "cpu/topology", "cores"),
3174         xmlutil.attribute("cpu:topology:threads", "cpu/topology", "threads"),
3175         xmlutil.attribute("cpu:cache:level", "cpu/cache", "level"),
3176         xmlutil.attribute("cpu:cache:mode", "cpu/cache", "mode"),
3177         xmlutil.attribute(
3178             "cpu:features:{id}", "cpu/feature[@name='$id']", "policy", ["name"]
3179         ),
3180         _yesno_attribute(
3181             "cpu:vcpus:{id}:enabled", "vcpus/vcpu[@id='$id']", "enabled", ["id"]
3182         ),
3183         _yesno_attribute(
3184             "cpu:vcpus:{id}:hotpluggable",
3185             "vcpus/vcpu[@id='$id']",
3186             "hotpluggable",
3187             ["id"],
3188         ),
3189         xmlutil.int_attribute(
3190             "cpu:vcpus:{id}:order", "vcpus/vcpu[@id='$id']", "order", ["id"]
3191         ),
3192         _cpuset_parameter(
3193             "cpu:numa:{id}:cpus", "cpu/numa/cell[@id='$id']", "cpus", ["id"]
3194         ),
3195         _memory_parameter(
3196             "cpu:numa:{id}:memory", "cpu/numa/cell[@id='$id']", "memory", ["id"]
3197         ),
3198         _yesno_attribute(
3199             "cpu:numa:{id}:discard", "cpu/numa/cell[@id='$id']", "discard", ["id"]
3200         ),
3201         xmlutil.attribute(
3202             "cpu:numa:{id}:memAccess", "cpu/numa/cell[@id='$id']", "memAccess", ["id"]
3203         ),
3204         xmlutil.attribute(
3205             "cpu:numa:{id}:distances:{sid}",
3206             "cpu/numa/cell[@id='$id']/distances/sibling[@id='$sid']",
3207             "value",
3208             ["id"],
3209         ),
3210         {"path": "cpu:iothreads", "xpath": "iothreads"},
3211         {"path": "cpu:tuning:shares", "xpath": "cputune/shares"},
3212         {"path": "cpu:tuning:period", "xpath": "cputune/period"},
3213         {"path": "cpu:tuning:quota", "xpath": "cputune/quota"},
3214         {"path": "cpu:tuning:global_period", "xpath": "cputune/global_period"},
3215         {"path": "cpu:tuning:global_quota", "xpath": "cputune/global_quota"},
3216         {"path": "cpu:tuning:emulator_period", "xpath": "cputune/emulator_period"},
3217         {"path": "cpu:tuning:emulator_quota", "xpath": "cputune/emulator_quota"},
3218         {"path": "cpu:tuning:iothread_period", "xpath": "cputune/iothread_period"},
3219         {"path": "cpu:tuning:iothread_quota", "xpath": "cputune/iothread_quota"},
3220         _cpuset_parameter(
3221             "cpu:tuning:vcpupin:{id}",
3222             "cputune/vcpupin[@vcpu='$id']",
3223             "cpuset",
3224             ["vcpu"],
3225         ),
3226         _cpuset_parameter("cpu:tuning:emulatorpin", "cputune/emulatorpin", "cpuset"),
3227         _cpuset_parameter(
3228             "cpu:tuning:iothreadpin:{id}",
3229             "cputune/iothreadpin[@iothread='$id']",
3230             "cpuset",
3231             ["iothread"],
3232         ),
3233         xmlutil.attribute(
3234             "cpu:tuning:vcpusched:{id}:scheduler",
3235             "cputune/vcpusched[$id]",
3236             "scheduler",
3237             ["priority", "vcpus"],
3238         ),
3239         xmlutil.attribute(
3240             "cpu:tuning:vcpusched:{id}:priority", "cputune/vcpusched[$id]", "priority"
3241         ),
3242         _cpuset_parameter(
3243             "cpu:tuning:vcpusched:{id}:vcpus", "cputune/vcpusched[$id]", "vcpus"
3244         ),
3245         xmlutil.attribute(
3246             "cpu:tuning:iothreadsched:{id}:scheduler",
3247             "cputune/iothreadsched[$id]",
3248             "scheduler",
3249             ["priority", "iothreads"],
3250         ),
3251         xmlutil.attribute(
3252             "cpu:tuning:iothreadsched:{id}:priority",
3253             "cputune/iothreadsched[$id]",
3254             "priority",
3255         ),
3256         _cpuset_parameter(
3257             "cpu:tuning:iothreadsched:{id}:iothreads",
3258             "cputune/iothreadsched[$id]",
3259             "iothreads",
3260         ),
3261         xmlutil.attribute(
3262             "cpu:tuning:emulatorsched:scheduler",
3263             "cputune/emulatorsched",
3264             "scheduler",
3265             ["priority"],
3266         ),
3267         xmlutil.attribute(
3268             "cpu:tuning:emulatorsched:priority", "cputune/emulatorsched", "priority"
3269         ),
3270         xmlutil.attribute(
3271             "cpu:tuning:cachetune:{id}:monitor:{sid}",
3272             "cputune/cachetune[@vcpus='$id']/monitor[@vcpus='$sid']",
3273             "level",
3274             ["vcpus"],
3275         ),
3276         xmlutil.attribute(
3277             "cpu:tuning:memorytune:{id}:{sid}",
3278             "cputune/memorytune[@vcpus='$id']/node[@id='$sid']",
3279             "bandwidth",
3280             ["id", "vcpus"],
3281         ),
3282         xmlutil.attribute("clock:offset", "clock", "offset"),
3283         xmlutil.attribute("clock:adjustment", "clock", "adjustment", convert=str),
3284         xmlutil.attribute("clock:timezone", "clock", "timezone"),
3285     ]
3286     for timer in timer_names:
3287         params_mapping += [
3288             xmlutil<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.attribute(
3289                 "clock:timers:{}:track".format(timer),
3290                 "clock/timer[@name='{}']".format(timer),
3291                 "track",
3292                 ["name"],
3293             ),
3294             xmlutil.attribute(
3295                 "clock:timers:{}:tickpolicy".format(timer),
3296                 "clock/timer[@name='{}']".format(timer),
3297                 "tickpolicy",
3298                 ["name"],
3299             ),
3300             xmlutil.int_attribute(
3301                 "clock:timers:{}:frequency".format(timer),
3302                 "clock/timer[@name='{}']".format(timer),
3303                 "frequency",
3304                 ["name"],
3305             ),
3306             xmlutil.attribute(
3307                 "clock:timers:{}:mode".format(</b></font>timer),
3308                 "clock/timer[@name='{}']".format(timer),
3309                 "mode",
3310                 ["name"],
3311             ),
3312             _yesno_attribute(
3313                 "clock:timers:{}:present".format(timer),
3314                 "clock/timer[@name='{}']".format(timer),
3315                 "present",
3316                 ["name"],
3317             ),
3318         ]
3319         for attr in ["slew", "threshold", "limit"]:
3320             params_mapping.append(
3321                 xmlutil.int_attribute(
3322                     "clock:timers:{}:{}".format(timer, attr),
3323                     "clock/timer[@name='{}']/catchup".format(timer),
3324                     attr,
3325                 )
3326             )
3327     for attr in ["level", "type", "size"]:
3328         params_mapping.append(
3329             xmlutil.attribute(
3330                 "cpu:tuning:cachetune:{id}:{sid}:" + attr,
3331                 "cputune/cachetune[@vcpus='$id']/cache[@id='$sid']",
3332                 attr,
3333                 ["id", "unit", "vcpus"],
3334             )
3335         )
3336     if hypervisor in ["qemu", "kvm"]:
3337         params_mapping += [
3338             xmlutil.attribute("numatune:memory:mode", "numatune/memory", "mode"),
3339             _cpuset_parameter("numatune:memory:nodeset", "numatune/memory", "nodeset"),
3340             xmlutil.attribute(
3341                 "numatune:memnodes:{id}:mode",
3342                 "numatune/memnode[@cellid='$id']",
3343                 "mode",
3344                 ["cellid"],
3345             ),
3346             _cpuset_parameter(
3347                 "numatune:memnodes:{id}:nodeset",
3348                 "numatune/memnode[@cellid='$id']",
3349                 "nodeset",
3350                 ["cellid"],
3351             ),
3352             xmlutil.attribute(
3353                 "hypervisor_features:kvm-hint-dedicated",
3354                 "features/kvm/hint-dedicated",
3355                 "state",
3356                 convert=lambda v: "on" if v else "off",
3357             ),
3358         ]
3359     need_update = (
3360         salt.utils.xmlutil.change_xml(desc, data, params_mapping) or need_update
3361     )
3362     devices_node = desc.find("devices")
3363     func_locals = locals()
3364     def _skip_update(names):
3365         return all(func_locals.get(n) is None for n in names)
3366     to_skip = {
3367         "disk": _skip_update(["disks", "disk_profile"]),
3368         "interface": _skip_update(["interfaces", "nic_profile"]),
3369         "graphics": _skip_update(["graphics"]),
3370         "serial": _skip_update(["serials"]),
3371         "console": _skip_update(["consoles"]),
3372         "hostdev": _skip_update(["host_devices"]),
3373     }
3374     changes = _compute_device_changes(desc, new_desc, to_skip)
3375     for dev_type in changes:
3376         if not to_skip[dev_type]:
3377             old = devices_node.findall(dev_type)
3378             if changes[dev_type].get("deleted") or changes[dev_type].get("new"):
3379                 for item in old:
3380                     devices_node.remove(item)
3381                 devices_node.extend(changes[dev_type]["sorted"])
3382                 need_update = True
3383     if need_update:
3384         try:
3385             if changes["disk"]:
3386                 for idx, item in enumerate(changes["disk"]["sorted"]):
3387                     source_file = all_disks[idx].get("source_file")
3388                     if all_disks[idx].get("device", "disk") == "cdrom":
3389                         continue
3390                     if (
3391                         item in changes["disk"]["new"]
3392                         and source_file
3393                         and not os.path.exists(source_file)
3394                     ):
3395                         _qemu_image_create(all_disks[idx])
3396                     elif item in changes["disk"]["new"] and not source_file:
3397                         _disk_volume_create(conn, all_disks[idx])
3398             if not test:
3399                 xml_desc = xmlutil.element_to_str(desc)
3400                 log.debug("Update virtual machine definition: %s", xml_desc)
3401                 conn.defineXML(xml_desc)
3402             status["definition"] = True
3403         except libvirt.libvirtError as err:
3404             conn.close()
3405             raise err
3406     if live:
3407         live_status, errors = _update_live(
3408             domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test
3409         )
3410         status.update(live_status)
3411         if errors:
3412             status_errors = status.setdefault("errors", [])
3413             status_errors += errors
3414     conn.close()
3415     return status
3416 def list_domains(**kwargs):
3417     """
3418     Return a list of available domains.
3419     :param connection: libvirt connection URI, overriding defaults
3420         .. versionadded:: 2019.2.0
3421     :param username: username to connect with, overriding defaults
3422         .. versionadded:: 2019.2.0
3423     :param password: password to connect with, overriding defaults
3424         .. versionadded:: 2019.2.0
3425     CLI Example:
3426     .. code-block:: bash
3427         salt '*' virt.list_domains
3428     """
3429     vms = []
3430     conn = __get_conn(**kwargs)
3431     for dom in _get_domain(conn, iterable=True):
3432         vms.append(dom.name())
3433     conn.close()
3434     return vms
3435 def list_active_vms(**kwargs):
3436     """
3437     Return a list of names for active virtual machine on the minion
3438     :param connection: libvirt connection URI, overriding defaults
3439         .. versionadded:: 2019.2.0
3440     :param username: username to connect with, overriding defaults
3441         .. versionadded:: 2019.2.0
3442     :param password: password to connect with, overriding defaults
3443         .. versionadded:: 2019.2.0
3444     CLI Example:
3445     .. code-block:: bash
3446         salt '*' virt.list_active_vms
3447     """
3448     vms = []
3449     conn = __get_conn(**kwargs)
3450     for dom in _get_domain(conn, iterable=True, inactive=False):
3451         vms.append(dom.name())
3452     conn.close()
3453     return vms
3454 def list_inactive_vms(**kwargs):
3455     """
3456     Return a list of names for inactive virtual machine on the minion
3457     :param connection: libvirt connection URI, overriding defaults
3458         .. versionadded:: 2019.2.0
3459     :param username: username to connect with, overriding defaults
3460         .. versionadded:: 2019.2.0
3461     :param password: password to connect with, overriding defaults
3462         .. versionadded:: 2019.2.0
3463     CLI Example:
3464     .. code-block:: bash
3465         salt '*' virt.list_inactive_vms
3466     """
3467     vms = []
3468     conn = __get_conn(**kwargs)
3469     for dom in _get_domain(conn, iterable=True, active=False):
3470         vms.append(dom.name())
3471     conn.close()
3472     return vms
3473 def vm_info(vm_=None, **kwargs):
3474     """
3475     Return detailed information about the vms on this hyper in a
3476     list of dicts:
3477     :param vm_: name of the domain
3478     :param connection: libvirt connection URI, overriding defaults
3479         .. versionadded:: 2019.2.0
3480     :param username: username to connect with, overriding defaults
3481         .. versionadded:: 2019.2.0
3482     :param password: password to connect with, overriding defaults
3483         .. versionadded:: 2019.2.0
3484     .. code-block:: python
3485         [
3486             'your-vm': {
3487                 'cpu': &lt;int&gt;,
3488                 'maxMem': &lt;int&gt;,
3489                 'mem': &lt;int&gt;,
3490                 'state': '&lt;state&gt;',
3491                 'cputime' &lt;int&gt;
3492                 },
3493             ...
3494             ]
3495     If you pass a VM name in as an argument then it will return info
3496     for just the named VM, otherwise it will return all VMs.
3497     CLI Example:
3498     .. code-block:: bash
3499         salt '*' virt.vm_info
3500     """
3501     def _info(conn, dom):
3502         """
3503         Compute the infos of a domain
3504         """
3505         raw = dom.info()
3506         return {
3507             "cpu": raw[3],
3508             "cputime": int(raw[4]),
3509             "disks": _get_disks(conn, dom),
3510             "graphics": _get_graphics(dom),
3511             "nics": _get_nics(dom),
3512             "uuid": _get_uuid(dom),
3513             "loader": _get_loader(dom),
3514             "on_crash": _get_on_crash(dom),
3515             "on_reboot": _get_on_reboot(dom),
3516             "on_poweroff": _get_on_poweroff(dom),
3517             "maxMem": int(raw[1]),
3518             "mem": int(raw[2]),
3519             "state": VIRT_STATE_NAME_MAP.get(raw[0], "unknown"),
3520         }
3521     info = {}
3522     conn = __get_conn(**kwargs)
3523     if vm_:
3524         info[vm_] = _info(conn, _get_domain(conn, vm_))
3525     else:
3526         for domain in _get_domain(conn, iterable=True):
3527             info[domain.name()] = _info(conn, domain)
3528     conn.close()
3529     return info
3530 def vm_state(vm_=None, **kwargs):
3531     """
3532     Return list of all the vms and their state.
3533     If you pass a VM name in as an argument then it will return info
3534     for just the named VM, otherwise it will return all VMs.
3535     :param vm_: name of the domain
3536     :param connection: libvirt connection URI, overriding defaults
3537         .. versionadded:: 2019.2.0
3538     :param username: username to connect with, overriding defaults
3539         .. versionadded:: 2019.2.0
3540     :param password: password to connect with, overriding defaults
3541         .. versionadded:: 2019.2.0
3542     CLI Example:
3543     .. code-block:: bash
3544         salt '*' virt.vm_state &lt;domain&gt;
3545     """
3546     def _info(dom):
3547         """
3548         Compute domain state
3549         """
3550         state = ""
3551         raw = dom.info()
3552         state = VIRT_STATE_NAME_MAP.get(raw[0], "unknown")
3553         return state
3554     info = {}
3555     conn = __get_conn(**kwargs)
3556     if vm_:
3557         info[vm_] = _info(_get_domain(conn, vm_))
3558     else:
3559         for domain in _get_domain(conn, iterable=True):
3560             info[domain.name()] = _info(domain)
3561     conn.close()
3562     return info
3563 def _node_info(conn):
3564     """
3565     Internal variant of node_info taking a libvirt connection as parameter
3566     """
3567     raw = conn.getInfo()
3568     info = {
3569         "cpucores": raw[6],
3570         "cpumhz": raw[3],
3571         "cpumodel": str(raw[0]),
3572         "cpus": raw[2],
3573         "cputhreads": raw[7],
3574         "numanodes": raw[4],
3575         "phymemory": raw[1],
3576         "sockets": raw[5],
3577     }
3578     return info
3579 def node_info(**kwargs):
3580     """
3581     Return a dict with information about this node
3582     :param connection: libvirt connection URI, overriding defaults
3583         .. versionadded:: 2019.2.0
3584     :param username: username to connect with, overriding defaults
3585         .. versionadded:: 2019.2.0
3586     :param password: password to connect with, overriding defaults
3587         .. versionadded:: 2019.2.0
3588     CLI Example:
3589     .. code-block:: bash
3590         salt '*' virt.node_info
3591     """
3592     conn = __get_conn(**kwargs)
3593     info = _node_info(conn)
3594     conn.close()
3595     return info
3596 def _node_devices(conn):
3597     """
3598     List the host available devices, using an established connection.
3599     :param conn: the libvirt connection handle to use.
3600     .. versionadded:: 3003
3601     """
3602     devices = conn.listAllDevices()
3603     devices_infos = []
3604     for dev in devices:
3605         root = ElementTree.fromstring(dev.XMLDesc())
3606         if not set(dev.listCaps()) &amp; {"pci", "usb_device", "net"}:
3607             continue
3608         infos = {
3609             "caps": " ".join(dev.listCaps()),
3610         }
3611         if "net" in dev.listCaps():
3612             parent = root.find(".//parent").text
3613             if parent == "computer":
3614                 continue
3615             infos.update(
3616                 {
3617                     "name": root.find(".//interface").text,
3618                     "address": root.find(".//address").text,
3619                     "device name": parent,
3620                     "state": root.find(".//link").get("state"),
3621                 }
3622             )
3623             devices_infos.append(infos)
3624             continue
3625         vendor_node = root.find(".//vendor")
3626         vendor_id = vendor_node.get("id").lower()
3627         product_node = root.find(".//product")
3628         product_id = product_node.get("id").lower()
3629         infos.update(
3630             {"name": dev.name(), "vendor_id": vendor_id, "product_id": product_id}
3631         )
3632         if vendor_node.text:
3633             infos["vendor"] = vendor_node.text
3634         if product_node.text:
3635             infos["product"] = product_node.text
3636         if "pci" in dev.listCaps():
3637             infos["address"] = "{:04x}:{:02x}:{:02x}.{}".format(
3638                 int(root.find(".//domain").text),
3639                 int(root.find(".//bus").text),
3640                 int(root.find(".//slot").text),
3641                 root.find(".//function").text,
3642             )
3643             class_node = root.find(".//class")
3644             if class_node is not None:
3645                 infos["PCI class"] = class_node.text
3646             vf_addresses = [
3647                 _format_pci_address(vf)
3648                 for vf in root.findall(
3649                     "./capability[@type='pci']/capability[@type='virt_functions']/address"
3650                 )
3651             ]
3652             if vf_addresses:
3653                 infos["virtual functions"] = vf_addresses
3654             pf = root.find(
3655                 "./capability[@type='pci']/capability[@type='phys_function']/address"
3656             )
3657             if pf is not None:
3658                 infos["physical function"] = _format_pci_address(pf)
3659         elif "usb_device" in dev.listCaps():
3660             infos["address"] = "{:03}:{:03}".format(
3661                 int(root.find(".//bus").text), int(root.find(".//device").text)
3662             )
3663         linux_usb_host = vendor_id == "0x1d6b" and product_id in [
3664             "0x0001",
3665             "0x0002",
3666             "0x0003",
3667         ]
3668         if (
3669             root.find(".//capability[@type='pci-bridge']") is None
3670             and not linux_usb_host
3671         ):
3672             devices_infos.append(infos)
3673     return devices_infos
3674 def node_devices(**kwargs):
3675     """
3676     List the host available devices.
3677     :param connection: libvirt connection URI, overriding defaults
3678     :param username: username to connect with, overriding defaults
3679     :param password: password to connect with, overriding defaults
3680     .. versionadded:: 3003
3681     """
3682     conn = __get_conn(**kwargs)
3683     devs = _node_devices(conn)
3684     conn.close()
3685     return devs
3686 def get_nics(vm_, **kwargs):
3687     """
3688     Return info about the network interfaces of a named vm
3689     :param vm_: name of the domain
3690     :param connection: libvirt connection URI, overriding defaults
3691         .. versionadded:: 2019.2.0
3692     :param username: username to connect with, overriding defaults
3693         .. versionadded:: 2019.2.0
3694     :param password: password to connect with, overriding defaults
3695         .. versionadded:: 2019.2.0
3696     CLI Example:
3697     .. code-block:: bash
3698         salt '*' virt.get_nics &lt;domain&gt;
3699     """
3700     conn = __get_conn(**kwargs)
3701     nics = _get_nics(_get_domain(conn, vm_))
3702     conn.close()
3703     return nics
3704 def get_macs(vm_, **kwargs):
3705     """
3706     Return a list off MAC addresses from the named vm
3707     :param vm_: name of the domain
3708     :param connection: libvirt connection URI, overriding defaults
3709         .. versionadded:: 2019.2.0
3710     :param username: username to connect with, overriding defaults
3711         .. versionadded:: 2019.2.0
3712     :param password: password to connect with, overriding defaults
3713         .. versionadded:: 2019.2.0
3714     CLI Example:
3715     .. code-block:: bash
3716         salt '*' virt.get_macs &lt;domain&gt;
3717     """
3718     doc = ElementTree.fromstring(get_xml(vm_, **kwargs))
3719     return [node.get("address") for node in doc.findall("devices/interface/mac")]
3720 def get_graphics(vm_, **kwargs):
3721     """
3722     Returns the information on vnc for a given vm
3723     :param vm_: name of the domain
3724     :param connection: libvirt connection URI, overriding defaults
3725         .. versionadded:: 2019.2.0
3726     :param username: username to connect with, overriding defaults
3727         .. versionadded:: 2019.2.0
3728     :param password: password to connect with, overriding defaults
3729         .. versionadded:: 2019.2.0
3730     CLI Example:
3731     .. code-block:: bash
3732         salt '*' virt.get_graphics &lt;domain&gt;
3733     """
3734     conn = __get_conn(**kwargs)
3735     graphics = _get_graphics(_get_domain(conn, vm_))
3736     conn.close()
3737     return graphics
3738 def get_loader(vm_, **kwargs):
3739     """
3740     Returns the information on the loader for a given vm
3741     :param vm_: name of the domain
3742     :param connection: libvirt connection URI, overriding defaults
3743     :param username: username to connect with, overriding defaults
3744     :param password: password to connect with, overriding defaults
3745     CLI Example:
3746     .. code-block:: bash
3747         salt '*' virt.get_loader &lt;domain&gt;
3748     .. versionadded:: 2019.2.0
3749     """
3750     conn = __get_conn(**kwargs)
3751     try:
3752         loader = _get_loader(_get_domain(conn, vm_))
3753         return loader
3754     finally:
3755         conn.close()
3756 def get_disks(vm_, **kwargs):
3757     """
3758     Return the disks of a named vm
3759     :param vm_: name of the domain
3760     :param connection: libvirt connection URI, overriding defaults
3761         .. versionadded:: 2019.2.0
3762     :param username: username to connect with, overriding defaults
3763         .. versionadded:: 2019.2.0
3764     :param password: password to connect with, overriding defaults
3765         .. versionadded:: 2019.2.0
3766     CLI Example:
3767     .. code-block:: bash
3768         salt '*' virt.get_disks &lt;domain&gt;
3769     """
3770     conn = __get_conn(**kwargs)
3771     disks = _get_disks(conn, _get_domain(conn, vm_))
3772     conn.close()
3773     return disks
3774 def setmem(vm_, memory, config=False, **kwargs):
3775     """
3776     Changes the amount of memory allocated to VM. The VM must be shutdown
3777     for this to work.
3778     :param vm_: name of the domain
3779     :param memory: memory amount to set in MB
3780     :param config: if True then libvirt will be asked to modify the config as well
3781     :param connection: libvirt connection URI, overriding defaults
3782         .. versionadded:: 2019.2.0
3783     :param username: username to connect with, overriding defaults
3784         .. versionadded:: 2019.2.0
3785     :param password: password to connect with, overriding defaults
3786         .. versionadded:: 2019.2.0
3787     CLI Example:
3788     .. code-block:: bash
3789         salt '*' virt.setmem &lt;domain&gt; &lt;size&gt;
3790         salt '*' virt.setmem my_domain 768
3791     """
3792     conn = __get_conn(**kwargs)
3793     dom = _get_domain(conn, vm_)
3794     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
3795         return False
3796     flags = libvirt.VIR_DOMAIN_MEM_MAXIMUM
3797     if config:
3798         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
3799     ret1 = dom.setMemoryFlags(memory * 1024, flags)
3800     ret2 = dom.setMemoryFlags(memory * 1024, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
3801     conn.close()
3802     return ret1 == ret2 == 0
3803 def setvcpus(vm_, vcpus, config=False, **kwargs):
3804     """
3805     Changes the amount of vcpus allocated to VM. The VM must be shutdown
3806     for this to work.
3807     If config is True then we ask libvirt to modify the config as well
3808     :param vm_: name of the domain
3809     :param vcpus: integer representing the number of CPUs to be assigned
3810     :param config: if True then libvirt will be asked to modify the config as well
3811     :param connection: libvirt connection URI, overriding defaults
3812         .. versionadded:: 2019.2.0
3813     :param username: username to connect with, overriding defaults
3814         .. versionadded:: 2019.2.0
3815     :param password: password to connect with, overriding defaults
3816         .. versionadded:: 2019.2.0
3817     CLI Example:
3818     .. code-block:: bash
3819         salt '*' virt.setvcpus &lt;domain&gt; &lt;amount&gt;
3820         salt '*' virt.setvcpus my_domain 4
3821     """
3822     conn = __get_conn(**kwargs)
3823     dom = _get_domain(conn, vm_)
3824     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
3825         return False
3826     flags = libvirt.VIR_DOMAIN_VCPU_MAXIMUM
3827     if config:
3828         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
3829     ret1 = dom.setVcpusFlags(vcpus, flags)
3830     ret2 = dom.setVcpusFlags(vcpus, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
3831     conn.close()
3832     return ret1 == ret2 == 0
3833 def _freemem(conn):
3834     """
3835     Internal variant of freemem taking a libvirt connection as parameter
3836     """
3837     mem = conn.getInfo()[1]
3838     mem -= 256
3839     for dom in _get_domain(conn, iterable=True):
3840         if dom.ID() &gt; 0:
3841             mem -= dom.info()[2] / 1024
3842     return mem
3843 def freemem(**kwargs):
3844     """
3845     Return an int representing the amount of memory (in MB) that has not
3846     been given to virtual machines on this node
3847     :param connection: libvirt connection URI, overriding defaults
3848         .. versionadded:: 2019.2.0
3849     :param username: username to connect with, overriding defaults
3850         .. versionadded:: 2019.2.0
3851     :param password: password to connect with, overriding defaults
3852         .. versionadded:: 2019.2.0
3853     CLI Example:
3854     .. code-block:: bash
3855         salt '*' virt.freemem
3856     """
3857     conn = __get_conn(**kwargs)
3858     mem = _freemem(conn)
3859     conn.close()
3860     return mem
3861 def _freecpu(conn):
3862     """
3863     Internal variant of freecpu taking a libvirt connection as parameter
3864     """
3865     cpus = conn.getInfo()[2]
3866     for dom in _get_domain(conn, iterable=True):
3867         if dom.ID() &gt; 0:
3868             cpus -= dom.info()[3]
3869     return cpus
3870 def freecpu(**kwargs):
3871     """
3872     Return an int representing the number of unallocated cpus on this
3873     hypervisor
3874     :param connection: libvirt connection URI, overriding defaults
3875         .. versionadded:: 2019.2.0
3876     :param username: username to connect with, overriding defaults
3877         .. versionadded:: 2019.2.0
3878     :param password: password to connect with, overriding defaults
3879         .. versionadded:: 2019.2.0
3880     CLI Example:
3881     .. code-block:: bash
3882         salt '*' virt.freecpu
3883     """
3884     conn = __get_conn(**kwargs)
3885     cpus = _freecpu(conn)
3886     conn.close()
3887     return cpus
3888 def full_info(**kwargs):
3889     """
3890     Return the node_info, vm_info and freemem
3891     :param connection: libvirt connection URI, overriding defaults
3892         .. versionadded:: 2019.2.0
3893     :param username: username to connect with, overriding defaults
3894         .. versionadded:: 2019.2.0
3895     :param password: password to connect with, overriding defaults
3896         .. versionadded:: 2019.2.0
3897     CLI Example:
3898     .. code-block:: bash
3899         salt '*' virt.full_info
3900     """
3901     conn = __get_conn(**kwargs)
3902     info = {
3903         "freecpu": _freecpu(conn),
3904         "freemem": _freemem(conn),
3905         "node_info": _node_info(conn),
3906         "vm_info": vm_info(),
3907     }
3908     conn.close()
3909     return info
3910 def get_xml(vm_, **kwargs):
3911     """
3912     Returns the XML for a given vm
3913     :param vm_: domain name
3914     :param connection: libvirt connection URI, overriding defaults
3915         .. versionadded:: 2019.2.0
3916     :param username: username to connect with, overriding defaults
3917         .. versionadded:: 2019.2.0
3918     :param password: password to connect with, overriding defaults
3919         .. versionadded:: 2019.2.0
3920     CLI Example:
3921     .. code-block:: bash
3922         salt '*' virt.get_xml &lt;domain&gt;
3923     """
3924     conn = __get_conn(**kwargs)
3925     xml_desc = (
3926         vm_.XMLDesc(0)
3927         if isinstance(vm_, libvirt.virDomain)
3928         else _get_domain(conn, vm_).XMLDesc(0)
3929     )
3930     conn.close()
3931     return xml_desc
3932 def get_profiles(hypervisor=None, **kwargs):
3933     """
3934     Return the virt profiles for hypervisor.
3935     Currently there are profiles for:
3936     - nic
3937     - disk
3938     :param hypervisor: override the default machine type.
3939     :param connection: libvirt connection URI, overriding defaults
3940         .. versionadded:: 2019.2.0
3941     :param username: username to connect with, overriding defaults
3942         .. versionadded:: 2019.2.0
3943     :param password: password to connect with, overriding defaults
3944         .. versionadded:: 2019.2.0
3945     CLI Example:
3946     .. code-block:: bash
3947         salt '*' virt.get_profiles
3948         salt '*' virt.get_profiles hypervisor=vmware
3949     """
3950     conn = __get_conn(**kwargs)
3951     caps = _capabilities(conn)
3952     hypervisors = sorted(
3953         {
3954             x
3955             for y in [guest["arch"]["domains"].keys() for guest in caps["guests"]]
3956             for x in y
3957         }
3958     )
3959     if len(hypervisors) == 0:
3960         raise SaltInvocationError("No supported hypervisors were found")
3961     if not hypervisor:
3962         hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
3963     ret = {
3964         "disk": {"default": _disk_profile(conn, "default", hypervisor, [], None)},
3965         "nic": {"default": _nic_profile("default", hypervisor)},
3966     }
3967     virtconf = __salt__["config.get"]("virt", {})
3968     for profile in virtconf.get("disk", []):
3969         ret["disk"][profile] = _disk_profile(conn, profile, hypervisor, [], None)
3970     for profile in virtconf.get("nic", []):
3971         ret["nic"][profile] = _nic_profile(profile, hypervisor)
3972     return ret
3973 def shutdown(vm_, **kwargs):
3974     """
3975     Send a soft shutdown signal to the named vm
3976     :param vm_: domain name
3977     :param connection: libvirt connection URI, overriding defaults
3978         .. versionadded:: 2019.2.0
3979     :param username: username to connect with, overriding defaults
3980         .. versionadded:: 2019.2.0
3981     :param password: password to connect with, overriding defaults
3982         .. versionadded:: 2019.2.0
3983     CLI Example:
3984     .. code-block:: bash
3985         salt '*' virt.shutdown &lt;domain&gt;
3986     """
3987     conn = __get_conn(**kwargs)
3988     dom = _get_domain(conn, vm_)
3989     ret = dom.shutdown() == 0
3990     conn.close()
3991     return ret
3992 def pause(vm_, **kwargs):
3993     """
3994     Pause the named vm
3995     :param vm_: domain name
3996     :param connection: libvirt connection URI, overriding defaults
3997         .. versionadded:: 2019.2.0
3998     :param username: username to connect with, overriding defaults
3999         .. versionadded:: 2019.2.0
4000     :param password: password to connect with, overriding defaults
4001         .. versionadded:: 2019.2.0
4002     CLI Example:
4003     .. code-block:: bash
4004         salt '*' virt.pause &lt;domain&gt;
4005     """
4006     conn = __get_conn(**kwargs)
4007     dom = _get_domain(conn, vm_)
4008     ret = dom.suspend() == 0
4009     conn.close()
4010     return ret
4011 def resume(vm_, **kwargs):
4012     """
4013     Resume the named vm
4014     :param vm_: domain name
4015     :param connection: libvirt connection URI, overriding defaults
4016         .. versionadded:: 2019.2.0
4017     :param username: username to connect with, overriding defaults
4018         .. versionadded:: 2019.2.0
4019     :param password: password to connect with, overriding defaults
4020         .. versionadded:: 2019.2.0
4021     CLI Example:
4022     .. code-block:: bash
4023         salt '*' virt.resume &lt;domain&gt;
4024     """
4025     conn = __get_conn(**kwargs)
4026     dom = _get_domain(conn, vm_)
4027     ret = dom.resume() == 0
4028     conn.close()
4029     return ret
4030 def start(name, **kwargs):
4031     """
4032     Start a defined domain
4033     :param vm_: domain name
4034     :param connection: libvirt connection URI, overriding defaults
4035         .. versionadded:: 2019.2.0
4036     :param username: username to connect with, overriding defaults
4037         .. versionadded:: 2019.2.0
4038     :param password: password to connect with, overriding defaults
4039         .. versionadded:: 2019.2.0
4040     CLI Example:
4041     .. code-block:: bash
4042         salt '*' virt.start &lt;domain&gt;
4043     """
4044     conn = __get_conn(**kwargs)
4045     ret = _get_domain(conn, name).create() == 0
4046     conn.close()
4047     return ret
4048 def stop(name, **kwargs):
4049     """
4050     Hard power down the virtual machine, this is equivalent to pulling the power.
4051     :param vm_: domain name
4052     :param connection: libvirt connection URI, overriding defaults
4053         .. versionadded:: 2019.2.0
4054     :param username: username to connect with, overriding defaults
4055         .. versionadded:: 2019.2.0
4056     :param password: password to connect with, overriding defaults
4057         .. versionadded:: 2019.2.0
4058     CLI Example:
4059     .. code-block:: bash
4060         salt '*' virt.stop &lt;domain&gt;
4061     """
4062     conn = __get_conn(**kwargs)
4063     ret = _get_domain(conn, name).destroy() == 0
4064     conn.close()
4065     return ret
4066 def reboot(name, **kwargs):
4067     """
4068     Reboot a domain via ACPI request
4069     :param vm_: domain name
4070     :param connection: libvirt connection URI, overriding defaults
4071         .. versionadded:: 2019.2.0
4072     :param username: username to connect with, overriding defaults
4073         .. versionadded:: 2019.2.0
4074     :param password: password to connect with, overriding defaults
4075         .. versionadded:: 2019.2.0
4076     CLI Example:
4077     .. code-block:: bash
4078         salt '*' virt.reboot &lt;domain&gt;
4079     """
4080     conn = __get_conn(**kwargs)
4081     ret = _get_domain(conn, name).reboot(libvirt.VIR_DOMAIN_REBOOT_DEFAULT) == 0
4082     conn.close()
4083     return ret
4084 def reset(vm_, **kwargs):
4085     """
4086     Reset a VM by emulating the reset button on a physical machine
4087     :param vm_: domain name
4088     :param connection: libvirt connection URI, overriding defaults
4089         .. versionadded:: 2019.2.0
4090     :param username: username to connect with, overriding defaults
4091         .. versionadded:: 2019.2.0
4092     :param password: password to connect with, overriding defaults
4093         .. versionadded:: 2019.2.0
4094     CLI Example:
4095     .. code-block:: bash
4096         salt '*' virt.reset &lt;domain&gt;
4097     """
4098     conn = __get_conn(**kwargs)
4099     dom = _get_domain(conn, vm_)
4100     ret = dom.reset(0) == 0
4101     conn.close()
4102     return ret
4103 def ctrl_alt_del(vm_, **kwargs):
4104     """
4105     Sends CTRL+ALT+DEL to a VM
4106     :param vm_: domain name
4107     :param connection: libvirt connection URI, overriding defaults
4108         .. versionadded:: 2019.2.0
4109     :param username: username to connect with, overriding defaults
4110         .. versionadded:: 2019.2.0
4111     :param password: password to connect with, overriding defaults
4112         .. versionadded:: 2019.2.0
4113     CLI Example:
4114     .. code-block:: bash
4115         salt '*' virt.ctrl_alt_del &lt;domain&gt;
4116     """
4117     conn = __get_conn(**kwargs)
4118     dom = _get_domain(conn, vm_)
4119     ret = dom.sendKey(0, 0, [29, 56, 111], 3, 0) == 0
4120     conn.close()
4121     return ret
4122 def create_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
4123     """
4124     Start a transient domain based on the XML passed to the function
4125     :param xml: libvirt XML definition of the domain
4126     :param connection: libvirt connection URI, overriding defaults
4127         .. versionadded:: 2019.2.0
4128     :param username: username to connect with, overriding defaults
4129         .. versionadded:: 2019.2.0
4130     :param password: password to connect with, overriding defaults
4131         .. versionadded:: 2019.2.0
4132     CLI Example:
4133     .. code-block:: bash
4134         salt '*' virt.create_xml_str &lt;XML in string format&gt;
4135     """
4136     conn = __get_conn(**kwargs)
4137     ret = conn.createXML(xml, 0) is not None
4138     conn.close()
4139     return ret
4140 def create_xml_path(path, **kwargs):
4141     """
4142     Start a transient domain based on the XML-file path passed to the function
4143     :param path: path to a file containing the libvirt XML definition of the domain
4144     :param connection: libvirt connection URI, overriding defaults
4145         .. versionadded:: 2019.2.0
4146     :param username: username to connect with, overriding defaults
4147         .. versionadded:: 2019.2.0
4148     :param password: password to connect with, overriding defaults
4149         .. versionadded:: 2019.2.0
4150     CLI Example:
4151     .. code-block:: bash
4152         salt '*' virt.create_xml_path &lt;path to XML file on the node&gt;
4153     """
4154     try:
4155         with salt.utils.files.fopen(path, "r") as fp_:
4156             return create_xml_str(
4157                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
4158             )
4159     except OSError:
4160         return False
4161 def define_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
4162     """
4163     Define a persistent domain based on the XML passed to the function
4164     :param xml: libvirt XML definition of the domain
4165     :param connection: libvirt connection URI, overriding defaults
4166         .. versionadded:: 2019.2.0
4167     :param username: username to connect with, overriding defaults
4168         .. versionadded:: 2019.2.0
4169     :param password: password to connect with, overriding defaults
4170         .. versionadded:: 2019.2.0
4171     CLI Example:
4172     .. code-block:: bash
4173         salt '*' virt.define_xml_str &lt;XML in string format&gt;
4174     """
4175     conn = __get_conn(**kwargs)
4176     ret = conn.defineXML(xml) is not None
4177     conn.close()
4178     return ret
4179 def define_xml_path(path, **kwargs):
4180     """
4181     Define a persistent domain based on the XML-file path passed to the function
4182     :param path: path to a file containing the libvirt XML definition of the domain
4183     :param connection: libvirt connection URI, overriding defaults
4184         .. versionadded:: 2019.2.0
4185     :param username: username to connect with, overriding defaults
4186         .. versionadded:: 2019.2.0
4187     :param password: password to connect with, overriding defaults
4188         .. versionadded:: 2019.2.0
4189     CLI Example:
4190     .. code-block:: bash
4191         salt '*' virt.define_xml_path &lt;path to XML file on the node&gt;
4192     """
4193     try:
4194         with salt.utils.files.fopen(path, "r") as fp_:
4195             return define_xml_str(
4196                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
4197             )
4198     except OSError:
4199         return False
4200 def _define_vol_xml_str(conn, xml, pool=None):  # pylint: disable=redefined-outer-name
4201     """
4202     Same function than define_vml_xml_str but using an already opened libvirt connection
4203     """
4204     default_pool = "default" if conn.getType() != "ESX" else "0"
4205     poolname = (
4206         pool if pool else __salt__["config.get"]("virt:storagepool", default_pool)
4207     )
4208     pool = conn.storagePoolLookupByName(str(poolname))
4209     ret = pool.createXML(xml, 0) is not None
4210     return ret
4211 def define_vol_xml_str(
4212     xml, pool=None, **kwargs
4213 ):  # pylint: disable=redefined-outer-name
4214     """
4215     Define a volume based on the XML passed to the function
4216     :param xml: libvirt XML definition of the storage volume
4217     :param pool:
4218         storage pool name to define the volume in.
4219         If defined, this parameter will override the configuration setting.
4220         .. versionadded:: 3001
4221     :param connection: libvirt connection URI, overriding defaults
4222         .. versionadded:: 2019.2.0
4223     :param username: username to connect with, overriding defaults
4224         .. versionadded:: 2019.2.0
4225     :param password: password to connect with, overriding defaults
4226         .. versionadded:: 2019.2.0
4227     CLI Example:
4228     .. code-block:: bash
4229         salt '*' virt.define_vol_xml_str &lt;XML in string format&gt;
4230     The storage pool where the disk image will be defined is ``default``
4231     unless changed with the pool parameter or a configuration like this:
4232     .. code-block:: yaml
4233         virt:
4234             storagepool: mine
4235     """
4236     conn = __get_conn(**kwargs)
4237     ret = False
4238     try:
4239         ret = _define_vol_xml_str(conn, xml, pool=pool)
4240     except libvirtError as err:
4241         raise CommandExecutionError(err.get_error_message())
4242     finally:
4243         conn.close()
4244     return ret
4245 def define_vol_xml_path(path, pool=None, **kwargs):
4246     """
4247     Define a volume based on the XML-file path passed to the function
4248     :param path: path to a file containing the libvirt XML definition of the volume
4249     :param pool:
4250         storage pool name to define the volume in.
4251         If defined, this parameter will override the configuration setting.
4252         .. versionadded:: 3001
4253     :param connection: libvirt connection URI, overriding defaults
4254         .. versionadded:: 2019.2.0
4255     :param username: username to connect with, overriding defaults
4256         .. versionadded:: 2019.2.0
4257     :param password: password to connect with, overriding defaults
4258         .. versionadded:: 2019.2.0
4259     CLI Example:
4260     .. code-block:: bash
4261         salt '*' virt.define_vol_xml_path &lt;path to XML file on the node&gt;
4262     """
4263     try:
4264         with salt.utils.files.fopen(path, "r") as fp_:
4265             return define_vol_xml_str(
4266                 salt.utils.stringutils.to_unicode(fp_.read()), pool=pool, **kwargs
4267             )
4268     except OSError:
4269         return False
4270 def migrate(vm_, target, **kwargs):
4271     """
4272     Shared storage migration
4273     :param vm_: domain name
4274     :param target: target libvirt URI or host name
4275     :param kwargs:
4276         - live:            Use live migration. Default value is True.
4277         - persistent:      Leave the domain persistent on destination host.
4278                            Default value is True.
4279         - undefinesource:  Undefine the domain on the source host.
4280                            Default value is True.
4281         - offline:         If set to True it will migrate the domain definition
4282                            without starting the domain on destination and without
4283                            stopping it on source host. Default value is False.
4284         - max_bandwidth:   The maximum bandwidth (in MiB/s) that will be used.
4285         - max_downtime:    Set maximum tolerable downtime for live-migration.
4286                            The value represents a number of milliseconds the guest
4287                            is allowed to be down at the end of live migration.
4288         - parallel_connections: Specify a number of parallel network connections
4289                            to be used to send memory pages to the destination host.
4290         - compressed:      Activate compression.
4291         - comp_methods:    A comma-separated list of compression methods. Supported
4292                            methods are "mt" and "xbzrle" and can be  used in any
4293                            combination. QEMU defaults to "xbzrle".
4294         - comp_mt_level:   Set compression level. Values are in range from 0 to 9,
4295                            where 1 is maximum speed and 9 is  maximum compression.
4296         - comp_mt_threads: Set number of compress threads on source host.
4297         - comp_mt_dthreads: Set number of decompress threads on target host.
4298         - comp_xbzrle_cache: Set the size of page cache for xbzrle compression in bytes.
4299         - copy_storage:    Migrate non-shared storage. It must be one of the following
4300                            values: all (full disk copy) or incremental (Incremental copy)
4301         - postcopy:        Enable the use of post-copy migration.
4302         - postcopy_bandwidth: The maximum bandwidth allowed in post-copy phase. (MiB/s)
4303         - username:        Username to connect with target host
4304         - password:        Password to connect with target host
4305         .. versionadded:: 3002
4306     CLI Example:
4307     .. code-block:: bash
4308         salt '*' virt.migrate &lt;domain&gt; &lt;target hypervisor URI&gt;
4309         salt src virt.migrate guest qemu+ssh://dst/system
4310         salt src virt.migrate guest qemu+tls://dst/system
4311         salt src virt.migrate guest qemu+tcp://dst/system
4312     A tunnel data migration can be performed by setting this in the
4313     configuration:
4314     .. code-block:: yaml
4315         virt:
4316             tunnel: True
4317     For more details on tunnelled data migrations, report to
4318     https://libvirt.org/migration.html#transporttunnel
4319     """
4320     conn = __get_conn()
4321     dom = _get_domain(conn, vm_)
4322     if not urllib.parse.urlparse(target).scheme:
4323         proto = "qemu"
4324         dst_uri = "{}://{}/system".format(proto, target)
4325     else:
4326         dst_uri = target
4327     ret = _migrate(dom, dst_uri, **kwargs)
4328     conn.close()
4329     return ret
4330 def migrate_start_postcopy(vm_):
4331     """
4332     Starts post-copy migration. This function has to be called
4333     while live migration is in progress and it has been initiated
4334     with the `postcopy=True` option.
4335     CLI Example:
4336     .. code-block:: bash
4337         salt '*' virt.migrate_start_postcopy &lt;domain&gt;
4338     """
4339     conn = __get_conn()
4340     dom = _get_domain(conn, vm_)
4341     try:
4342         dom.migrateStartPostCopy()
4343     except libvirt.libvirtError as err:
4344         conn.close()
4345         raise CommandExecutionError(err.get_error_message())
4346     conn.close()
4347 def seed_non_shared_migrate(disks, force=False):
4348     """
4349     Non shared migration requires that the disks be present on the migration
4350     destination, pass the disks information via this function, to the
4351     migration destination before executing the migration.
4352     :param disks: the list of disk data as provided by virt.get_disks
4353     :param force: skip checking the compatibility of source and target disk
4354                   images if True. (default: False)
4355     CLI Example:
4356     .. code-block:: bash
4357         salt '*' virt.seed_non_shared_migrate &lt;disks&gt;
4358     """
4359     for _, data in disks.items():
4360         fn_ = data["file"]
4361         form = data["file format"]
4362         size = data["virtual size"].split()[1][1:]
4363         if os.path.isfile(fn_) and not force:
4364             pre = salt.utils.yaml.safe_load(
4365                 subprocess.Popen(
4366                     ["qemu-img", "info", "arch"], stdout=subprocess.PIPE
4367                 ).communicate()[0]
4368             )
4369             if (
4370                 pre["file format"] != data["file format"]
4371                 and pre["virtual size"] != data["virtual size"]
4372             ):
4373                 return False
4374         if not os.path.isdir(os.path.dirname(fn_)):
4375             os.makedirs(os.path.dirname(fn_))
4376         if os.path.isfile(fn_):
4377             os.remove(fn_)
4378         subprocess.call(["qemu-img", "create", "-f", form, fn_, size])
4379         creds = _libvirt_creds()
4380         subprocess.call(["chown", "{user}:{group}".format(**creds), fn_])
4381     return True
4382 def set_autostart(vm_, state="on", **kwargs):
4383     """
4384     Set the autostart flag on a VM so that the VM will start with the host
4385     system on reboot.
4386     :param vm_: domain name
4387     :param state: 'on' to auto start the pool, anything else to mark the
4388                   pool not to be started when the host boots
4389     :param connection: libvirt connection URI, overriding defaults
4390         .. versionadded:: 2019.2.0
4391     :param username: username to connect with, overriding defaults
4392         .. versionadded:: 2019.2.0
4393     :param password: password to connect with, overriding defaults
4394         .. versionadded:: 2019.2.0
4395     CLI Example:
4396     .. code-block:: bash
4397         salt "*" virt.set_autostart &lt;domain&gt; &lt;on | off&gt;
4398     """
4399     conn = __get_conn(**kwargs)
4400     dom = _get_domain(conn, vm_)
4401     ret = False
4402     if state == "on":
4403         ret = dom.setAutostart(1) == 0
4404     elif state == "off":
4405         ret = dom.setAutostart(0) == 0
4406     conn.close()
4407     return ret
4408 def undefine(vm_, **kwargs):
4409     """
4410     Remove a defined vm, this does not purge the virtual machine image, and
4411     this only works if the vm is powered down
4412     :param vm_: domain name
4413     :param connection: libvirt connection URI, overriding defaults
4414         .. versionadded:: 2019.2.0
4415     :param username: username to connect with, overriding defaults
4416         .. versionadded:: 2019.2.0
4417     :param password: password to connect with, overriding defaults
4418         .. versionadded:: 2019.2.0
4419     CLI Example:
4420     .. code-block:: bash
4421         salt '*' virt.undefine &lt;domain&gt;
4422     """
4423     conn = __get_conn(**kwargs)
4424     dom = _get_domain(conn, vm_)
4425     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
4426         ret = dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM) == 0
4427     else:
4428         ret = dom.undefine() == 0
4429     conn.close()
4430     return ret
4431 def purge(vm_, dirs=False, removables=False, **kwargs):
4432     """
4433     Recursively destroy and delete a persistent virtual machine, pass True for
4434     dir's to also delete the directories containing the virtual machine disk
4435     images - USE WITH EXTREME CAUTION!
4436     :param vm_: domain name
4437     :param dirs: pass True to remove containing directories
4438     :param removables: pass True to remove removable devices
4439         .. versionadded:: 2019.2.0
4440     :param connection: libvirt connection URI, overriding defaults
4441         .. versionadded:: 2019.2.0
4442     :param username: username to connect with, overriding defaults
4443         .. versionadded:: 2019.2.0
4444     :param password: password to connect with, overriding defaults
4445         .. versionadded:: 2019.2.0
4446     CLI Example:
4447     .. code-block:: bash
4448         salt '*' virt.purge &lt;domain&gt;
4449     """
4450     conn = __get_conn(**kwargs)
4451     dom = _get_domain(conn, vm_)
4452     disks = _get_disks(conn, dom)
4453     if (
4454         VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown"
4455         and dom.destroy() != 0
4456     ):
4457         return False
4458     directories = set()
4459     for disk in disks:
4460         if not removables and disks[disk]["type"] in ["cdrom", "floppy"]:
4461             continue
4462         if disks[disk].get("zfs", False):
4463             time.sleep(3)
4464             fs_name = disks[disk]["file"][len("/dev/zvol/") :]
4465             log.info("Destroying VM ZFS volume %s", fs_name)
4466             __salt__["zfs.destroy"](name=fs_name, force=True)
4467         elif os.path.exists(disks[disk]["file"]):
4468             os.remove(disks[disk]["file"])
4469             directories.add(os.path.dirname(disks[disk]["file"]))
4470         else:
4471             matcher = re.match("^(?P&lt;pool&gt;[^/]+)/(?P&lt;volume&gt;.*)$", disks[disk]["file"])
4472             if matcher:
4473                 pool_name = matcher.group("pool")
4474                 pool = None
4475                 if pool_name in conn.listStoragePools():
4476                     pool = conn.storagePoolLookupByName(pool_name)
4477                 if pool and matcher.group("volume") in pool.listVolumes():
4478                     volume = pool.storageVolLookupByName(matcher.group("volume"))
4479                     volume.delete()
4480     if dirs:
4481         for dir_ in directories:
4482             shutil.rmtree(dir_)
4483     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
4484         try:
4485             dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM)
4486         except Exception:  # pylint: disable=broad-except
4487             dom.undefine()
4488     else:
4489         dom.undefine()
4490     conn.close()
4491     return True
4492 def virt_type():
4493     """
4494     Returns the virtual machine type as a string
4495     CLI Example:
4496     .. code-block:: bash
4497         salt '*' virt.virt_type
4498     """
4499     return __grains__["virtual"]
4500 def _is_kvm_hyper():
4501     """
4502     Returns a bool whether or not this node is a KVM hypervisor
4503     """
4504     if not os.path.exists("/dev/kvm"):
4505         return False
4506     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
4507 def _is_xen_hyper():
4508     """
4509     Returns a bool whether or not this node is a XEN hypervisor
4510     """
4511     try:
4512         if __grains__["virtual_subtype"] != "Xen Dom0":
4513             return False
4514     except KeyError:
4515         return False
4516     try:
4517         with salt.utils.files.fopen("/proc/modules") as fp_:
4518             if "xen_" not in salt.utils.stringutils.to_unicode(fp_.read()):
4519                 return False
4520     except OSError:
4521         return False
4522     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
4523 def get_hypervisor():
4524     """
4525     Returns the name of the hypervisor running on this node or ``None``.
4526     Detected hypervisors:
4527     - kvm
4528     - xen
4529     - bhyve
4530     CLI Example:
4531     .. code-block:: bash
4532         salt '*' virt.get_hypervisor
4533     .. versionadded:: 2019.2.0
4534         the function and the ``kvm``, ``xen`` and ``bhyve`` hypervisors support
4535     """
4536     hypervisors = ["kvm", "xen", "bhyve"]
4537     result = [
4538         hyper
4539         for hyper in hypervisors
4540         if getattr(sys.modules[__name__], "_is_{}_hyper".format(hyper))()
4541     ]
4542     return result[0] if result else None
4543 def _is_bhyve_hyper():
4544     sysctl_cmd = "sysctl hw.vmm.create"
4545     vmm_enabled = False
4546     try:
4547         stdout = subprocess.Popen(
4548             ["sysctl", "hw.vmm.create"], stdout=subprocess.PIPE
4549         ).communicate()[0]
4550         vmm_enabled = len(salt.utils.stringutils.to_str(stdout).split('"')[1]) != 0
4551     except IndexError:
4552         pass
4553     return vmm_enabled
4554 def is_hyper():
4555     """
4556     Returns a bool whether or not this node is a hypervisor of any kind
4557     CLI Example:
4558     .. code-block:: bash
4559         salt '*' virt.is_hyper
4560     """
4561     if HAS_LIBVIRT:
4562         return _is_xen_hyper() or _is_kvm_hyper() or _is_bhyve_hyper()
4563     return False
4564 def vm_cputime(vm_=None, **kwargs):
4565     """
4566     Return cputime used by the vms on this hyper in a
4567     list of dicts:
4568     :param vm_: domain name
4569     :param connection: libvirt connection URI, overriding defaults
4570         .. versionadded:: 2019.2.0
4571     :param username: username to connect with, overriding defaults
4572         .. versionadded:: 2019.2.0
4573     :param password: password to connect with, overriding defaults
4574         .. versionadded:: 2019.2.0
4575     .. code-block:: python
4576         [
4577             'your-vm': {
4578                 'cputime' &lt;int&gt;
4579                 'cputime_percent' &lt;int&gt;
4580                 },
4581             ...
4582             ]
4583     If you pass a VM name in as an argument then it will return info
4584     for just the named VM, otherwise it will return all VMs.
4585     CLI Example:
4586     .. code-block:: bash
4587         salt '*' virt.vm_cputime
4588     """
4589     conn = __get_conn(**kwargs)
4590     host_cpus = conn.getInfo()[2]
4591     def _info(dom):
4592         """
4593         Compute cputime info of a domain
4594         """
4595         raw = dom.info()
4596         vcpus = int(raw[3])
4597         cputime = int(raw[4])
4598         cputime_percent = 0
4599         if cputime:
4600             cputime_percent = (1.0e-7 * cputime / host_cpus) / vcpus
4601         return {
4602             "cputime": int(raw[4]),
4603             "cputime_percent": int("{:.0f}".format(cputime_percent)),
4604         }
4605     info = {}
4606     if vm_:
4607         info[vm_] = _info(_get_domain(conn, vm_))
4608     else:
4609         for domain in _get_domain(conn, iterable=True):
4610             info[domain.name()] = _info(domain)
4611     conn.close()
4612     return info
4613 def vm_netstats(vm_=None, **kwargs):
4614     """
4615     Return combined network counters used by the vms on this hyper in a
4616     list of dicts:
4617     :param vm_: domain name
4618     :param connection: libvirt connection URI, overriding defaults
4619         .. versionadded:: 2019.2.0
4620     :param username: username to connect with, overriding defaults
4621         .. versionadded:: 2019.2.0
4622     :param password: password to connect with, overriding defaults
4623         .. versionadded:: 2019.2.0
4624     .. code-block:: python
4625         [
4626             'your-vm': {
4627                 'rx_bytes'   : 0,
4628                 'rx_packets' : 0,
4629                 'rx_errs'    : 0,
4630                 'rx_drop'    : 0,
4631                 'tx_bytes'   : 0,
4632                 'tx_packets' : 0,
4633                 'tx_errs'    : 0,
4634                 'tx_drop'    : 0
4635                 },
4636             ...
4637             ]
4638     If you pass a VM name in as an argument then it will return info
4639     for just the named VM, otherwise it will return all VMs.
4640     CLI Example:
4641     .. code-block:: bash
4642         salt '*' virt.vm_netstats
4643     """
4644     def _info(dom):
4645         """
4646         Compute network stats of a domain
4647         """
4648         nics = _get_nics(dom)
4649         ret = {
4650             "rx_bytes": 0,
4651             "rx_packets": 0,
4652             "rx_errs": 0,
4653             "rx_drop": 0,
4654             "tx_bytes": 0,
4655             "tx_packets": 0,
4656             "tx_errs": 0,
4657             "tx_drop": 0,
4658         }
4659         for attrs in nics.values():
4660             if "target" in attrs:
4661                 dev = attrs["target"]
4662                 stats = dom.interfaceStats(dev)
4663                 ret["rx_bytes"] += stats[0]
4664                 ret["rx_packets"] += stats[1]
4665                 ret["rx_errs"] += stats[2]
4666                 ret["rx_drop"] += stats[3]
4667                 ret["tx_bytes"] += stats[4]
4668                 ret["tx_packets"] += stats[5]
4669                 ret["tx_errs"] += stats[6]
4670                 ret["tx_drop"] += stats[7]
4671         return ret
4672     info = {}
4673     conn = __get_conn(**kwargs)
4674     if vm_:
4675         info[vm_] = _info(_get_domain(conn, vm_))
4676     else:
4677         for domain in _get_domain(conn, iterable=True):
4678             info[domain.name()] = _info(domain)
4679     conn.close()
4680     return info
4681 def vm_diskstats(vm_=None, **kwargs):
4682     """
4683     Return disk usage counters used by the vms on this hyper in a
4684     list of dicts:
4685     :param vm_: domain name
4686     :param connection: libvirt connection URI, overriding defaults
4687         .. versionadded:: 2019.2.0
4688     :param username: username to connect with, overriding defaults
4689         .. versionadded:: 2019.2.0
4690     :param password: password to connect with, overriding defaults
4691         .. versionadded:: 2019.2.0
4692     .. code-block:: python
4693         [
4694             'your-vm': {
4695                 'rd_req'   : 0,
4696                 'rd_bytes' : 0,
4697                 'wr_req'   : 0,
4698                 'wr_bytes' : 0,
4699                 'errs'     : 0
4700                 },
4701             ...
4702             ]
4703     If you pass a VM name in as an argument then it will return info
4704     for just the named VM, otherwise it will return all VMs.
4705     CLI Example:
4706     .. code-block:: bash
4707         salt '*' virt.vm_blockstats
4708     """
4709     def get_disk_devs(dom):
4710         """
4711         Extract the disk devices names from the domain XML definition
4712         """
4713         doc = ElementTree.fromstring(get_xml(dom, **kwargs))
4714         return [target.get("dev") for target in doc.findall("devices/disk/target")]
4715     def _info(dom):
4716         """
4717         Compute the disk stats of a domain
4718         """
4719         disks = get_disk_devs(dom)
4720         ret = {"rd_req": 0, "rd_bytes": 0, "wr_req": 0, "wr_bytes": 0, "errs": 0}
4721         for disk in disks:
4722             stats = dom.blockStats(disk)
4723             ret["rd_req"] += stats[0]
4724             ret["rd_bytes"] += stats[1]
4725             ret["wr_req"] += stats[2]
4726             ret["wr_bytes"] += stats[3]
4727             ret["errs"] += stats[4]
4728         return ret
4729     info = {}
4730     conn = __get_conn(**kwargs)
4731     if vm_:
4732         info[vm_] = _info(_get_domain(conn, vm_))
4733     else:
4734         for domain in _get_domain(conn, iterable=True, inactive=False):
4735             info[domain.name()] = _info(domain)
4736     conn.close()
4737     return info
4738 def _parse_snapshot_description(vm_snapshot, unix_time=False):
4739     """
4740     Parse XML doc and return a dict with the status values.
4741     :param xmldoc:
4742     :return:
4743     """
4744     ret = dict()
4745     tree = ElementTree.fromstring(vm_snapshot.getXMLDesc())
4746     for node in tree:
4747         if node.tag == "name":
4748             ret["name"] = node.text
4749         elif node.tag == "creationTime":
4750             ret["created"] = (
4751                 datetime.datetime.fromtimestamp(float(node.text)).isoformat(" ")
4752                 if not unix_time
4753                 else float(node.text)
4754             )
4755         elif node.tag == "state":
4756             ret["running"] = node.text == "running"
4757     ret["current"] = vm_snapshot.isCurrent() == 1
4758     return ret
4759 def list_snapshots(domain=None, **kwargs):
4760     """
4761     List available snapshots for certain vm or for all.
4762     :param domain: domain name
4763     :param connection: libvirt connection URI, overriding defaults
4764         .. versionadded:: 2019.2.0
4765     :param username: username to connect with, overriding defaults
4766         .. versionadded:: 2019.2.0
4767     :param password: password to connect with, overriding defaults
4768         .. versionadded:: 2019.2.0
4769     .. versionadded:: 2016.3.0
4770     CLI Example:
4771     .. code-block:: bash
4772         salt '*' virt.list_snapshots
4773         salt '*' virt.list_snapshots &lt;domain&gt;
4774     """
4775     ret = dict()
4776     conn = __get_conn(**kwargs)
4777     for vm_domain in _get_domain(conn, *(domain and [domain] or list()), iterable=True):
4778         ret[vm_domain.name()] = [
4779             _parse_snapshot_description(snap) for snap in vm_domain.listAllSnapshots()
4780         ] or "N/A"
4781     conn.close()
4782     return ret
4783 def snapshot(domain, name=None, suffix=None, **kwargs):
4784     """
4785     Create a snapshot of a VM.
4786     :param domain: domain name
4787     :param name: Name of the snapshot. If the name is omitted, then will be used original domain
4788                  name with ISO 8601 time as a suffix.
4789     :param suffix: Add suffix for the new name. Useful in states, where such snapshots
4790                    can be distinguished from manually created.
4791     :param connection: libvirt connection URI, overriding defaults
4792         .. versionadded:: 2019.2.0
4793     :param username: username to connect with, overriding defaults
4794         .. versionadded:: 2019.2.0
4795     :param password: password to connect with, overriding defaults
4796         .. versionadded:: 2019.2.0
4797     .. versionadded:: 2016.3.0
4798     CLI Example:
4799     .. code-block:: bash
4800         salt '*' virt.snapshot &lt;domain&gt;
4801     """
4802     if name and name.lower() == domain.lower():
4803         raise CommandExecutionError(
4804             "Virtual Machine {name} is already defined. "
4805             "Please choose another name for the snapshot".format(name=name)
4806         )
4807     if not name:
4808         name = "{domain}-{tsnap}".format(
4809             domain=domain, tsnap=time.strftime("%Y%m%d-%H%M%S", time.localtime())
4810         )
4811     if suffix:
4812         name = "{name}-{suffix}".format(name=name, suffix=suffix)
4813     doc = ElementTree.Element("domainsnapshot")
4814     n_name = ElementTree.SubElement(doc, "name")
4815     n_name.text = name
4816     conn = __get_conn(**kwargs)
4817     _get_domain(conn, domain).snapshotCreateXML(xmlutil.element_to_str(doc))
4818     conn.close()
4819     return {"name": name}
4820 def delete_snapshots(name, *names, **kwargs):
4821     """
4822     Delete one or more snapshots of the given VM.
4823     :param name: domain name
4824     :param names: names of the snapshots to remove
4825     :param connection: libvirt connection URI, overriding defaults
4826         .. versionadded:: 2019.2.0
4827     :param username: username to connect with, overriding defaults
4828         .. versionadded:: 2019.2.0
4829     :param password: password to connect with, overriding defaults
4830         .. versionadded:: 2019.2.0
4831     .. versionadded:: 2016.3.0
4832     CLI Example:
4833     .. code-block:: bash
4834         salt '*' virt.delete_snapshots &lt;domain&gt; all=True
4835         salt '*' virt.delete_snapshots &lt;domain&gt; &lt;snapshot&gt;
4836         salt '*' virt.delete_snapshots &lt;domain&gt; &lt;snapshot1&gt; &lt;snapshot2&gt; ...
4837     """
4838     deleted = dict()
4839     conn = __get_conn(**kwargs)
4840     domain = _get_domain(conn, name)
4841     for snap in domain.listAllSnapshots():
4842         if snap.getName() in names or not names:
4843             deleted[snap.getName()] = _parse_snapshot_description(snap)
4844             snap.delete()
4845     conn.close()
4846     available = {
4847         name: [_parse_snapshot_description(snap) for snap in domain.listAllSnapshots()]
4848         or "N/A"
4849     }
4850     return {"available": available, "deleted": deleted}
4851 def revert_snapshot(name, vm_snapshot=None, cleanup=False, **kwargs):
4852     """
4853     Revert snapshot to the previous from current (if available) or to the specific.
4854     :param name: domain name
4855     :param vm_snapshot: name of the snapshot to revert
4856     :param cleanup: Remove all newer than reverted snapshots. Values: True or False (default False).
4857     :param connection: libvirt connection URI, overriding defaults
4858         .. versionadded:: 2019.2.0
4859     :param username: username to connect with, overriding defaults
4860         .. versionadded:: 2019.2.0
4861     :param password: password to connect with, overriding defaults
4862         .. versionadded:: 2019.2.0
4863     .. versionadded:: 2016.3.0
4864     CLI Example:
4865     .. code-block:: bash
4866         salt '*' virt.revert &lt;domain&gt;
4867         salt '*' virt.revert &lt;domain&gt; &lt;snapshot&gt;
4868     """
4869     ret = dict()
4870     conn = __get_conn(**kwargs)
4871     domain = _get_domain(conn, name)
4872     snapshots = domain.listAllSnapshots()
4873     _snapshots = list()
4874     for snap_obj in snapshots:
4875         _snapshots.append(
4876             {
4877                 "idx": _parse_snapshot_description(snap_obj, unix_time=True)["created"],
4878                 "ptr": snap_obj,
4879             }
4880         )
4881     snapshots = [
4882         w_ptr["ptr"]
4883         for w_ptr in sorted(_snapshots, key=lambda item: item["idx"], reverse=True)
4884     ]
4885     del _snapshots
4886     if not snapshots:
4887         conn.close()
4888         raise CommandExecutionError("No snapshots found")
4889     elif len(snapshots) == 1:
4890         conn.close()
4891         raise CommandExecutionError(
4892             "Cannot revert to itself: only one snapshot is available."
4893         )
4894     snap = None
4895     for p_snap in snapshots:
4896         if not vm_snapshot:
4897             if p_snap.isCurrent() and snapshots[snapshots.index(p_snap) + 1 :]:
4898                 snap = snapshots[snapshots.index(p_snap) + 1 :][0]
4899                 break
4900         elif p_snap.getName() == vm_snapshot:
4901             snap = p_snap
4902             break
4903     if not snap:
4904         conn.close()
4905         raise CommandExecutionError(
4906             snapshot
4907             and 'Snapshot "{}" not found'.format(vm_snapshot)
4908             or "No more previous snapshots available"
4909         )
4910     elif snap.isCurrent():
4911         conn.close()
4912         raise CommandExecutionError("Cannot revert to the currently running snapshot.")
4913     domain.revertToSnapshot(snap)
4914     ret["reverted"] = snap.getName()
4915     if cleanup:
4916         delete = list()
4917         for p_snap in snapshots:
4918             if p_snap.getName() != snap.getName():
4919                 delete.append(p_snap.getName())
4920                 p_snap.delete()
4921             else:
4922                 break
4923         ret["deleted"] = delete
4924     else:
4925         ret["deleted"] = "N/A"
4926     conn.close()
4927     return ret
4928 def _caps_add_machine(machines, node):
4929     """
4930     Parse the &lt;machine&gt; element of the host capabilities and add it
4931     to the machines list.
4932     """
4933     maxcpus = node.get("maxCpus")
4934     canonical = node.get("canonical")
4935     name = node.text
4936     alternate_name = ""
4937     if canonical:
4938         alternate_name = name
4939         name = canonical
4940     machine = machines.get(name)
4941     if not machine:
4942         machine = {"alternate_names": []}
4943         if maxcpus:
4944             machine["maxcpus"] = int(maxcpus)
4945         machines[name] = machine
4946     if alternate_name:
4947         machine["alternate_names"].append(alternate_name)
4948 def _parse_caps_guest(guest):
4949     """
4950     Parse the &lt;guest&gt; element of the connection capabilities XML
4951     """
4952     arch_node = guest.find("arch")
4953     result = {
4954         "os_type": guest.find("os_type").text,
4955         "arch": {"name": arch_node.get("name"), "machines": {}, "domains": {}},
4956     }
4957     child = None
4958     for child in arch_node:
4959         if child.tag == "wordsize":
4960             result["arch"]["wordsize"] = int(child.text)
4961         elif child.tag == "emulator":
4962             result["arch"]["emulator"] = child.text
4963         elif child.tag == "machine":
4964             _caps_add_machine(result["arch"]["machines"], child)
4965         elif child.tag == "domain":
4966             domain_type = child.get("type")
4967             domain = {"emulator": None, "machines": {}}
4968             emulator_node = child.find("emulator")
4969             if emulator_node is not None:
4970                 domain["emulator"] = emulator_node.text
4971             for machine in child.findall("machine"):
4972                 _caps_add_machine(domain["machines"], machine)
4973             result["arch"]["domains"][domain_type] = domain
4974     features_nodes = guest.find("features")
4975     if features_nodes is not None and child is not None:
4976         result["features"] = {
4977             child.tag: {
4978                 "toggle": child.get("toggle", "no") == "yes",
4979                 "default": child.get("default", "on") == "on",
4980             }
4981             for child in features_nodes
4982         }
4983     return result
4984 def _parse_caps_cell(cell):
4985     """
4986     Parse the &lt;cell&gt; nodes of the connection capabilities XML output.
4987     """
4988     result = {"id": int(cell.get("id"))}
4989     mem_node = cell.find("memory")
4990     if mem_node is not None:
4991         unit = mem_node.get("unit", "KiB")
4992         memory = mem_node.text
4993         result["memory"] = "{} {}".format(memory, unit)
4994     pages = [
4995         {
4996             "size": "{} {}".format(page.get("size"), page.get("unit", "KiB")),
4997             "available": int(page.text),
4998         }
4999         for page in cell.findall("pages")
5000     ]
5001     if pages:
5002         result["pages"] = pages
5003     distances = {
5004         int(distance.get("id")): int(distance.get("value"))
5005         for distance in cell.findall("distances/sibling")
5006     }
5007     if distances:
5008         result["distances"] = distances
5009     cpus = []
5010     for cpu_node in cell.findall("cpus/cpu"):
5011         cpu = {"id": int(cpu_node.get("id"))}
5012         socket_id = cpu_node.get("socket_id")
5013         if socket_id:
5014             cpu["socket_id"] = int(socket_id)
5015         core_id = cpu_node.get("core_id")
5016         if core_id:
5017             cpu["core_id"] = int(core_id)
5018         siblings = cpu_node.get("siblings")
5019         if siblings:
5020             cpu["siblings"] = siblings
5021         cpus.append(cpu)
5022     if cpus:
5023         result["cpus"] = cpus
5024     return result
5025 def _parse_caps_bank(bank):
5026     """
5027     Parse the &lt;bank&gt; element of the connection capabilities XML.
5028     """
5029     result = {
5030         "id": int(bank.get("id")),
5031         "level": int(bank.get("level")),
5032         "type": bank.get("type"),
5033         "size": "{} {}".format(bank.get("size"), bank.get("unit")),
5034         "cpus": bank.get("cpus"),
5035     controls = []
5036     for control in bank<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("control"):
5037         unit = control.get("unit")
5038         result_control = {
5039             "granularity": "{} {}".format(control.get("granularity"), unit),
5040             "type": control.</b></font>get("type"),
5041             "maxAllocs": int(control.get("maxAllocs")),
5042         }
5043         minimum = control.get("min")
5044         if minimum:
5045             result_control["min"] = "{} {}".format(minimum, unit)
5046         controls.append(result_control)
5047     if controls:
5048         result["controls"] = controls
5049     return result
5050 def _parse_caps_host(host):
5051     """
5052     Parse the &lt;host&gt; element of the connection capabilities XML.
5053     """
5054     result = {}
5055     for child in host:
5056         if child.tag == "uuid":
5057             result["uuid"] = child.text
5058         elif child.tag == "cpu":
5059             cpu = {
5060                 "arch": child.find("arch").text
5061                 if child.find("arch") is not None
5062                 else None,
5063                 "model": child.find("model").text
5064                 if child.find("model") is not None
5065                 else None,
5066                 "vendor": child.find("vendor").text
5067                 if child.find("vendor") is not None
5068                 else None,
5069                 "features": [
5070                     feature.get("name") for feature in child.findall("feature")
5071                 ],
5072                 "pages": [
5073                     {"size": "{} {}".format(page.get("size"), page.get("unit", "KiB"))}
5074                     for page in child.findall("pages")
5075                 ],
5076             }
5077             microcode = child.find("microcode")
5078             if microcode is not None:
5079                 cpu["microcode"] = microcode.get("version")
5080             topology = child.find("topology")
5081             if topology is not None:
5082                 cpu["sockets"] = int(topology.get("sockets"))
5083                 cpu["cores"] = int(topology.get("cores"))
5084                 cpu["threads"] = int(topology.get("threads"))
5085             result["cpu"] = cpu
5086         elif child.tag == "power_management":
5087             result["power_management"] = [node.tag for node in child]
5088         elif child.tag == "migration_features":
5089             result["migration"] = {
5090                 "live": child.find("live") is not None,
5091                 "transports": [
5092                     node.text for node in child.findall("uri_transports/uri_transport")
5093                 ],
5094             }
5095         elif child.tag == "topology":
5096             result["topology"] = {
5097                 "cells": [
5098                     _parse_caps_cell(cell) for cell in child.findall("cells/cell")
5099                 ]
5100             }
5101         elif child.tag == "cache":
5102             result["cache"] = {
5103                 "banks": [_parse_caps_bank(bank) for bank in child.findall("bank")]
5104             }
5105     result["security"] = [
5106         {
5107             "model": secmodel.find("model").text
5108             if secmodel.find("model") is not None
5109             else None,
5110             "doi": secmodel.find("doi").text
5111             if secmodel.find("doi") is not None
5112             else None,
5113             "baselabels": [
5114                 {"type": label.get("type"), "label": label.text}
5115                 for label in secmodel.findall("baselabel")
5116             ],
5117         }
5118         for secmodel in host.findall("secmodel")
5119     ]
5120     return result
5121 def _capabilities(conn):
5122     """
5123     Return the hypervisor connection capabilities.
5124     :param conn: opened libvirt connection to use
5125     """
5126     caps = ElementTree.fromstring(conn.getCapabilities())
5127     return {
5128         "host": _parse_caps_host(caps.find("host")),
5129         "guests": [_parse_caps_guest(guest) for guest in caps.findall("guest")],
5130     }
5131 def capabilities(**kwargs):
5132     """
5133     Return the hypervisor connection capabilities.
5134     :param connection: libvirt connection URI, overriding defaults
5135     :param username: username to connect with, overriding defaults
5136     :param password: password to connect with, overriding defaults
5137     .. versionadded:: 2019.2.0
5138     CLI Example:
5139     .. code-block:: bash
5140         salt '*' virt.capabilities
5141     """
5142     conn = __get_conn(**kwargs)
5143     try:
5144         caps = _capabilities(conn)
5145     except libvirt.libvirtError as err:
5146         raise CommandExecutionError(str(err))
5147     finally:
5148         conn.close()
5149     return caps
5150 def _parse_caps_enum(node):
5151     """
5152     Return a tuple containing the name of the enum and the possible values
5153     """
5154     return (node.get("name"), [value.text for value in node.findall("value")])
5155 def _parse_caps_cpu(node):
5156     """
5157     Parse the &lt;cpu&gt; element of the domain capabilities
5158     """
5159     result = {}
5160     for mode in node.findall("mode"):
5161         if not mode.get("supported") == "yes":
5162             continue
5163         name = mode.get("name")
5164         if name == "host-passthrough":
5165             result[name] = True
5166         elif name == "host-model":
5167             host_model = {}
5168             model_node = mode.find("model")
5169             if model_node is not None:
5170                 model = {"name": model_node.text}
5171                 vendor_id = model_node.get("vendor_id")
5172                 if vendor_id:
5173                     model["vendor_id"] = vendor_id
5174                 fallback = model_node.get("fallback")
5175                 if fallback:
5176                     model["fallback"] = fallback
5177                 host_model["model"] = model
5178             vendor = (
5179                 mode.find("vendor").text if mode.find("vendor") is not None else None
5180             )
5181             if vendor:
5182                 host_model["vendor"] = vendor
5183             features = {
5184                 feature.get("name"): feature.get("policy")
5185                 for feature in mode.findall("feature")
5186             }
5187             if features:
5188                 host_model["features"] = features
5189             result[name] = host_model
5190         elif name == "custom":
5191             custom_model = {}
5192             models = {
5193                 model.text: model.get("usable") for model in mode.findall("model")
5194             }
5195             if models:
5196                 custom_model["models"] = models
5197             result[name] = custom_model
5198     return result
5199 def _parse_caps_devices_features(node):
5200     """
5201     Parse the devices or features list of the domain capatilities
5202     """
5203     result = {}
5204     for child in node:
5205         if child.get("supported") == "yes":
5206             enums = [_parse_caps_enum(node) for node in child.findall("enum")]
5207             result[child.tag] = {item[0]: item[1] for item in enums if item[0]}
5208     return result
5209 def _parse_caps_loader(node):
5210     """
5211     Parse the &lt;loader&gt; element of the domain capabilities.
5212     """
5213     enums = [_parse_caps_enum(enum) for enum in node.findall("enum")]
5214     result = {item[0]: item[1] for item in enums if item[0]}
5215     values = [child.text for child in node.findall("value")]
5216     if values:
5217         result["values"] = values
5218     return result
5219 def _parse_domain_caps(caps):
5220     """
5221     Parse the XML document of domain capabilities into a structure.
5222     """
5223     result = {
5224         "emulator": caps.find("path").text if caps.find("path") is not None else None,
5225         "domain": caps.find("domain").text if caps.find("domain") is not None else None,
5226         "machine": caps.find("machine").text
5227         if caps.find("machine") is not None
5228         else None,
5229         "arch": caps.find("arch").text if caps.find("arch") is not None else None,
5230     }
5231     for child in caps:
5232         if child.tag == "vcpu" and child.get("max"):
5233             result["max_vcpus"] = int(child.get("max"))
5234         elif child.tag == "iothreads":
5235             result["iothreads"] = child.get("supported") == "yes"
5236         elif child.tag == "os":
5237             result["os"] = {}
5238             loader_node = child.find("loader")
5239             if loader_node is not None and loader_node.get("supported") == "yes":
5240                 loader = _parse_caps_loader(loader_node)
5241                 result["os"]["loader"] = loader
5242         elif child.tag == "cpu":
5243             cpu = _parse_caps_cpu(child)
5244             if cpu:
5245                 result["cpu"] = cpu
5246         elif child.tag == "devices":
5247             devices = _parse_caps_devices_features(child)
5248             if devices:
5249                 result["devices"] = devices
5250         elif child.tag == "features":
5251             features = _parse_caps_devices_features(child)
5252             if features:
5253                 result["features"] = features
5254     return result
5255 def domain_capabilities(emulator=None, arch=None, machine=None, domain=None, **kwargs):
5256     """
5257     Return the domain capabilities given an emulator, architecture, machine or virtualization type.
5258     .. versionadded:: 2019.2.0
5259     :param emulator: return the capabilities for the given emulator binary
5260     :param arch: return the capabilities for the given CPU architecture
5261     :param machine: return the capabilities for the given emulated machine type
5262     :param domain: return the capabilities for the given virtualization type.
5263     :param connection: libvirt connection URI, overriding defaults
5264     :param username: username to connect with, overriding defaults
5265     :param password: password to connect with, overriding defaults
5266     The list of the possible emulator, arch, machine and domain can be found in
5267     the host capabilities output.
5268     If none of the parameters is provided, the libvirt default one is returned.
5269     CLI Example:
5270     .. code-block:: bash
5271         salt '*' virt.domain_capabilities arch='x86_64' domain='kvm'
5272     """
5273     conn = __get_conn(**kwargs)
5274     result = []
5275     try:
5276         caps = ElementTree.fromstring(
5277             conn.getDomainCapabilities(emulator, arch, machine, domain, 0)
5278         )
5279         result = _parse_domain_caps(caps)
5280     finally:
5281         conn.close()
5282     return result
5283 def all_capabilities(**kwargs):
5284     """
5285     Return the host and domain capabilities in a single call.
5286     .. versionadded:: 3001
5287     :param connection: libvirt connection URI, overriding defaults
5288     :param username: username to connect with, overriding defaults
5289     :param password: password to connect with, overriding defaults
5290     CLI Example:
5291     .. code-block:: bash
5292         salt '*' virt.all_capabilities
5293     """
5294     conn = __get_conn(**kwargs)
5295     try:
5296         host_caps = ElementTree.fromstring(conn.getCapabilities())
5297         domains = [
5298             [
5299                 (
5300                     guest.get("arch", {}).get("name", None),
5301                     key,
5302                     guest.get("arch", {}).get("emulator", None),
5303                 )
5304                 for key in guest.get("arch", {}).get("domains", {}).keys()
5305             ]
5306             for guest in [
5307                 _parse_caps_guest(guest) for guest in host_caps.findall("guest")
5308             ]
5309         ]
5310         flattened = [pair for item in (x for x in domains) for pair in item]
5311         result = {
5312             "host": {
5313                 "host": _parse_caps_host(host_caps.find("host")),
5314                 "guests": [
5315                     _parse_caps_guest(guest) for guest in host_caps.findall("guest")
5316                 ],
5317             },
5318             "domains": [
5319                 _parse_domain_caps(
5320                     ElementTree.fromstring(
5321                         conn.getDomainCapabilities(emulator, arch, None, domain)
5322                     )
5323                 )
5324                 for (arch, domain, emulator) in flattened
5325             ],
5326         }
5327         return result
5328     finally:
5329         conn.close()
5330 def cpu_baseline(full=False, migratable=False, out="libvirt", **kwargs):
5331     """
5332     Return the optimal 'custom' CPU baseline config for VM's on this minion
5333     .. versionadded:: 2016.3.0
5334     :param full: Return all CPU features rather than the ones on top of the closest CPU model
5335     :param migratable: Exclude CPU features that are unmigratable (libvirt 2.13+)
5336     :param out: 'libvirt' (default) for usable libvirt XML definition, 'salt' for nice dict
5337     :param connection: libvirt connection URI, overriding defaults
5338         .. versionadded:: 2019.2.0
5339     :param username: username to connect with, overriding defaults
5340         .. versionadded:: 2019.2.0
5341     :param password: password to connect with, overriding defaults
5342         .. versionadded:: 2019.2.0
5343     CLI Example:
5344     .. code-block:: bash
5345         salt '*' virt.cpu_baseline
5346     """
5347     conn = __get_conn(**kwargs)
5348     caps = ElementTree<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.fromstring(conn.getCapabilities())
5349     cpu = caps.find("host/cpu")
5350     host_cpu_def = xmlutil.element_to_str(cpu)
5351     log.debug("Host CPU model definition: %s", host_cpu_def)
5352     flags =</b></font> 0
5353     if migratable:
5354         if getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_MIGRATABLE", False):
5355             flags += libvirt.VIR_CONNECT_BASELINE_CPU_MIGRATABLE
5356         else:
5357             conn.close()
5358             raise ValueError
5359     if full and getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
5360         flags += libvirt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES
5361     cpu = ElementTree.fromstring(conn.baselineCPU([host_cpu_def], flags))
5362     conn.close()
5363     if full and not getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
5364         with salt.utils.files.fopen("/usr/share/libvirt/cpu_map.xml", "r") as cpu_map:
5365             cpu_map = ElementTree.parse(cpu_map)
5366         cpu_model = cpu.find("model").text
5367         while cpu_model:
5368             cpu_map_models = cpu_map.findall("arch/model")
5369             cpu_specs = [
5370                 el
5371                 for el in cpu_map_models
5372                 if el.get("name") == cpu_model and bool(len(el))
5373             ]
5374             if not cpu_specs:
5375                 raise ValueError("Model {} not found in CPU map".format(cpu_model))
5376             elif len(cpu_specs) &gt; 1:
5377                 raise ValueError(
5378                     "Multiple models {} found in CPU map".format(cpu_model)
5379                 )
5380             cpu_specs = cpu_specs[0]
5381             model_node = cpu_specs.find("model")
5382             if model_node is None:
5383                 cpu_model = None
5384             else:
5385                 cpu_model = model_node.get("name")
5386             cpu.extend([feature for feature in cpu_specs.findall("feature")])
5387     if out == "salt":
5388         return {
5389             "model": cpu.find("model").text,
5390             "vendor": cpu.find("vendor").text,
5391             "features": [feature.get("name") for feature in cpu.findall("feature")],
5392         }
5393     return ElementTree.tostring(cpu)
5394 def network_define(
5395     name,
5396     bridge,
5397     forward,
5398     ipv4_config=None,
5399     ipv6_config=None,
5400     vport=None,
5401     tag=None,
5402     autostart=True,
5403     start=True,
5404     mtu=None,
5405     domain=None,
5406     nat=None,
5407     interfaces=None,
5408     addresses=None,
5409     physical_function=None,
5410     dns=None,
5411     **kwargs
5412 ):
5413     """
5414     Create libvirt network.
5415     :param name: Network name.
5416     :param bridge: Bridge name.
5417     :param forward: Forward mode (bridge, router, nat).
5418         .. versionchanged:: 3003
5419            a ``None`` value creates an isolated network with no forwarding at all
5420     :param vport: Virtualport type.
5421         The value can also be a dictionary with ``type`` and ``parameters`` keys.
5422         The ``parameters`` value is a dictionary of virtual port parameters.
5423         .. code-block:: yaml
5424           - vport:
5425               type: openvswitch
5426               parameters:
5427                 interfaceid: 09b11c53-8b5c-4eeb-8f00-d84eaa0aaa4f
5428         .. versionchanged:: 3003
5429            possible dictionary value
5430     :param tag: Vlan tag.
5431         The value can also be a dictionary with the ``tags`` and optional ``trunk`` keys.
5432         ``trunk`` is a boolean value indicating whether to use VLAN trunking.
5433         ``tags`` is a list of dictionaries with keys ``id`` and ``nativeMode``.
5434         The ``nativeMode`` value can be one of ``tagged`` or ``untagged``.
5435         .. code-block:: yaml
5436           - tag:
5437               trunk: True
5438               tags:
5439                 - id: 42
5440                   nativeMode: untagged
5441                 - id: 47
5442         .. versionchanged:: 3003
5443            possible dictionary value
5444     :param autostart: Network autostart (default True).
5445     :param start: Network start (default True).
5446     :param ipv4_config: IP v4 configuration.
5447         Dictionary describing the IP v4 setup like IP range and
5448         a possible DHCP configuration. The structure is documented
5449         in net-define-ip_.
5450         .. versionadded:: 3000
5451     :type ipv4_config: dict or None
5452     :param ipv6_config: IP v6 configuration.
5453         Dictionary describing the IP v6 setup like IP range and
5454         a possible DHCP configuration. The structure is documented
5455         in net-define-ip_.
5456         .. versionadded:: 3000
5457     :type ipv6_config: dict or None
5458     :param connection: libvirt connection URI, overriding defaults.
5459     :param username: username to connect with, overriding defaults.
5460     :param password: password to connect with, overriding defaults.
5461     :param mtu: size of the Maximum Transmission Unit (MTU) of the network.
5462         (default ``None``)
5463         .. versionadded:: 3003
5464     :param domain: DNS domain name of the DHCP server.
5465         The value is a dictionary with a mandatory ``name`` property and an optional ``localOnly`` boolean one.
5466         (default ``None``)
5467         .. code-block:: yaml
5468           - domain:
5469               name: lab.acme.org
5470               localOnly: True
5471         .. versionadded:: 3003
5472     :param nat: addresses and ports to route in NAT forward mode.
5473         The value is a dictionary with optional keys ``address`` and ``port``.
5474         Both values are a dictionary with ``start`` and ``end`` values.
5475         (default ``None``)
5476         .. code-block:: yaml
5477           - forward: nat
5478           - nat:
5479               address:
5480                 start: 1.2.3.4
5481                 end: 1.2.3.10
5482               port:
5483                 start: 500
5484                 end: 1000
5485         .. versionadded:: 3003
5486     :param interfaces: whitespace separated list of network interfaces devices that can be used for this network.
5487         (default ``None``)
5488         .. code-block:: yaml
5489           - forward: passthrough
5490           - interfaces: "eth10 eth11 eth12"
5491         .. versionadded:: 3003
5492     :param addresses: whitespace separated list of addresses of PCI devices that can be used for this network in `hostdev` forward mode.
5493         (default ``None``)
5494         .. code-block:: yaml
5495           - forward: hostdev
5496           - interfaces: "0000:04:00.1 0000:e3:01.2"
5497         .. versionadded:: 3003
5498     :param physical_function: device name of the physical interface to use in ``hostdev`` forward mode.
5499         (default ``None``)
5500         .. code-block:: yaml
5501           - forward: hostdev
5502           - physical_function: "eth0"
5503         .. versionadded:: 3003
5504     :param dns: virtual network DNS configuration.
5505         The value is a dictionary described in net-define-dns_.
5506         (default ``None``)
5507         .. code-block:: yaml
5508           - dns:
5509               forwarders:
5510                 - domain: example.com
5511                   addr: 192.168.1.1
5512                 - addr: 8.8.8.8
5513                 - domain: www.example.com
5514               txt:
5515                 example.com: "v=spf1 a -all"
5516                 _http.tcp.example.com: "name=value,paper=A4"
5517               hosts:
5518                 192.168.1.2:
5519                   - mirror.acme.lab
5520                   - test.acme.lab
5521               srvs:
5522                 - name: ldap
5523                   protocol: tcp
5524                   domain: ldapserver.example.com
5525                   target: .
5526                   port: 389
5527                   priority: 1
5528                   weight: 10
5529         .. versionadded:: 3003
5530     .. _net-define-ip:
5531     .. rubric:: IP configuration definition
5532     Both the IPv4 and IPv6 configuration dictionaries can contain the following properties:
5533     cidr
5534         CIDR notation for the network. For example '192.168.124.0/24'
5535     dhcp_ranges
5536         A list of dictionaries with ``'start'`` and ``'end'`` properties.
5537     hosts
5538         A list of dictionaries with ``ip`` property and optional ``name``, ``mac`` and ``id`` properties.
5539         .. versionadded:: 3003
5540     bootp
5541         A dictionary with a ``file`` property and an optional ``server`` one.
5542         .. versionadded:: 3003
5543     tftp
5544         The path to the TFTP root directory to serve.
5545         .. versionadded:: 3003
5546     .. _net-define-dns:
5547     .. rubric:: DNS configuration definition
5548     The DNS configuration dictionary contains the following optional properties:
5549     forwarders
5550         List of alternate DNS forwarders to use.
5551         Each item is a dictionary with the optional ``domain`` and ``addr`` keys.
5552         If both are provided, the requests to the domain are forwarded to the server at the ``addr``.
5553         If only ``domain`` is provided the requests matching this domain will be resolved locally.
5554         If only ``addr`` is provided all requests will be forwarded to this DNS server.
5555     txt:
5556         Dictionary of TXT fields to set.
5557     hosts:
5558         Dictionary of host DNS entries.
5559         The key is the IP of the host, and the value is a list of hostnames for it.
5560     srvs:
5561         List of SRV DNS entries.
5562         Each entry is a dictionary with the mandatory ``name`` and ``protocol`` keys.
5563         Entries can also have ``target``, ``port``, ``priority``, ``domain`` and ``weight`` optional properties.
5564     CLI Example:
5565     .. code-block:: bash
5566         salt '*' virt.network_define network main bridge openvswitch
5567     .. versionadded:: 2019.2.0
5568     """
5569     conn = __get_conn(**kwargs)
5570     vport = kwargs.get("vport", None)
5571     tag = kwargs.get("tag", None)
5572     net_xml = _gen_net_xml(
5573         name,
5574         bridge,
5575         forward,
5576         vport,
5577         tag=tag,
5578         ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
5579         mtu=mtu,
5580         domain=domain,
5581         nat=nat,
5582         interfaces=interfaces,
5583         addresses=addresses,
5584         physical_function=physical_function,
5585         dns=dns,
5586     )
5587     try:
5588         conn.networkDefineXML(net_xml)
5589     except libvirt.libvirtError as err:
5590         log.warning(err)
5591         conn.close()
5592         raise err  # a real error we should report upwards
5593     try:
5594         network = conn.networkLookupByName(name)
5595     except libvirt.libvirtError as err:
5596         log.warning(err)
5597         conn.close()
5598         raise err  # a real error we should report upwards
5599     if network is None:
5600         conn.close()
5601         return False
5602     if (start or autostart) and network.isActive() != 1:
5603         network.create()
5604     if autostart and network.autostart() != 1:
5605         network.setAutostart(int(autostart))
5606     elif not autostart and network.autostart() == 1:
5607         network.setAutostart(int(autostart))
5608     conn.close()
5609     return True
5610 def _remove_empty_xml_node(node):
5611     """
5612     Remove the nodes with no children, no text and no attribute
5613     """
5614     for child in node:
5615         if not child.tail and not child.text and not child.items() and not child:
5616             node.remove(child)
5617         else:
5618             _remove_empty_xml_node(child)
5619     return node
5620 def network_update(
5621     name,
5622     bridge,
5623     forward,
5624     ipv4_config=None,
5625     ipv6_config=None,
5626     vport=None,
5627     tag=None,
5628     mtu=None,
5629     domain=None,
5630     nat=None,
5631     interfaces=None,
5632     addresses=None,
5633     physical_function=None,
5634     dns=None,
5635     test=False,
5636     **kwargs
5637 ):
5638     """
5639     Update a virtual network if needed.
5640     :param name: Network name.
5641     :param bridge: Bridge name.
5642     :param forward: Forward mode (bridge, router, nat).
5643         A ``None`` value creates an isolated network with no forwarding at all.
5644     :param vport: Virtualport type.
5645         The value can also be a dictionary with ``type`` and ``parameters`` keys.
5646         The ``parameters`` value is a dictionary of virtual port parameters.
5647         .. code-block:: yaml
5648           - vport:
5649               type: openvswitch
5650               parameters:
5651                 interfaceid: 09b11c53-8b5c-4eeb-8f00-d84eaa0aaa4f
5652     :param tag: Vlan tag.
5653         The value can also be a dictionary with the ``tags`` and optional ``trunk`` keys.
5654         ``trunk`` is a boolean value indicating whether to use VLAN trunking.
5655         ``tags`` is a list of dictionaries with keys ``id`` and ``nativeMode``.
5656         The ``nativeMode`` value can be one of ``tagged`` or ``untagged``.
5657         .. code-block:: yaml
5658           - tag:
5659               trunk: True
5660               tags:
5661                 - id: 42
5662                   nativeMode: untagged
5663                 - id: 47
5664     :param ipv4_config: IP v4 configuration.
5665         Dictionary describing the IP v4 setup like IP range and
5666         a possible DHCP configuration. The structure is documented
5667         in net-define-ip_.
5668     :type ipv4_config: dict or None
5669     :param ipv6_config: IP v6 configuration.
5670         Dictionary describing the IP v6 setup like IP range and
5671         a possible DHCP configuration. The structure is documented
5672         in net-define-ip_.
5673     :type ipv6_config: dict or None
5674     :param connection: libvirt connection URI, overriding defaults.
5675     :param username: username to connect with, overriding defaults.
5676     :param password: password to connect with, overriding defaults.
5677     :param mtu: size of the Maximum Transmission Unit (MTU) of the network.
5678         (default ``None``)
5679     :param domain: DNS domain name of the DHCP server.
5680         The value is a dictionary with a mandatory ``name`` property and an optional ``localOnly`` boolean one.
5681         (default ``None``)
5682         .. code-block:: yaml
5683           - domain:
5684               name: lab.acme.org
5685               localOnly: True
5686     :param nat: addresses and ports to route in NAT forward mode.
5687         The value is a dictionary with optional keys ``address`` and ``port``.
5688         Both values are a dictionary with ``start`` and ``end`` values.
5689         (default ``None``)
5690         .. code-block:: yaml
5691           - forward: nat
5692           - nat:
5693               address:
5694                 start: 1.2.3.4
5695                 end: 1.2.3.10
5696               port:
5697                 start: 500
5698                 end: 1000
5699     :param interfaces: whitespace separated list of network interfaces devices that can be used for this network.
5700         (default ``None``)
5701         .. code-block:: yaml
5702           - forward: passthrough
5703           - interfaces: "eth10 eth11 eth12"
5704     :param addresses: whitespace separated list of addresses of PCI devices that can be used for this network in `hostdev` forward mode.
5705         (default ``None``)
5706         .. code-block:: yaml
5707           - forward: hostdev
5708           - interfaces: "0000:04:00.1 0000:e3:01.2"
5709     :param physical_function: device name of the physical interface to use in ``hostdev`` forward mode.
5710         (default ``None``)
5711         .. code-block:: yaml
5712           - forward: hostdev
5713           - physical_function: "eth0"
5714     :param dns: virtual network DNS configuration.
5715         The value is a dictionary described in net-define-dns_.
5716         (default ``None``)
5717         .. code-block:: yaml
5718           - dns:
5719               forwarders:
5720                 - domain: example.com
5721                   addr: 192.168.1.1
5722                 - addr: 8.8.8.8
5723                 - domain: www.example.com
5724               txt:
5725                 example.com: "v=spf1 a -all"
5726                 _http.tcp.example.com: "name=value,paper=A4"
5727               hosts:
5728                 192.168.1.2:
5729                   - mirror.acme.lab
5730                   - test.acme.lab
5731               srvs:
5732                 - name: ldap
5733                   protocol: tcp
5734                   domain: ldapserver.example.com
5735                   target: .
5736                   port: 389
5737                   priority: 1
5738                   weight: 10
5739     .. versionadded:: 3003
5740     """
5741     conn = __get_conn(**kwargs)
5742     needs_update = False
5743     try:
5744         net = conn.networkLookupByName(name)
5745         old_xml = ElementTree.fromstring(net.XMLDesc())
5746         new_xml = ElementTree.fromstring(
5747             _gen_net_xml(
5748                 name,
5749                 bridge,
5750                 forward,
5751                 vport,
5752                 tag=tag,
5753                 ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
5754                 mtu=mtu,
5755                 domain=domain,
5756                 nat=nat,
5757                 interfaces=interfaces,
5758                 addresses=addresses,
5759                 physical_function=physical_function,
5760                 dns=dns,
5761             )
5762         )
5763         elements_to_copy = ["uuid", "mac"]
5764         for to_copy in elements_to_copy:
5765             element = old_xml.find(to_copy)
5766             if element is not None:
5767                 new_xml.insert(1, element)
5768         old_xml.attrib.pop("connections", None)
5769         if old_xml.find("forward/pf") is not None:
5770             forward_node = old_xml.find("forward")
5771             address_nodes = forward_node.findall("address")
5772             for node in address_nodes:
5773                 forward_node.remove(node)
5774         default_bridge_attribs = {"stp": "on", "delay": "0"}
5775         old_bridge_node = old_xml.find("bridge")
5776         if old_bridge_node is not None:
5777             for key, value in default_bridge_attribs.items():
5778                 if old_bridge_node.get(key, None) == value:
5779                     old_bridge_node.attrib.pop(key, None)
5780             old_forward = (
5781                 old_xml.find("forward").get("mode")
5782                 if old_xml.find("forward") is not None
5783                 else None
5784             )
5785             if (
5786                 old_forward == forward
5787                 and forward in ["nat", "route", "open", None]
5788                 and bridge is None
5789                 and old_bridge_node.get("name", "").startswith("virbr")
5790             ):
5791                 old_bridge_node.attrib.pop("name", None)
5792         ipv4_nodes = [
5793             node
5794             for node in old_xml.findall("ip")
5795             if node.get("family", "ipv4") == "ipv4"
5796         ]
5797         for ip_node in ipv4_nodes:
5798             netmask = ip_node.attrib.pop("netmask", None)
5799             if netmask:
5800                 address = ipaddress.ip_network(
5801                     "{}/{}".format(ip_node.get("address"), netmask), strict=False
5802                 )
5803                 ip_node.set("prefix", str(address.prefixlen))
5804         for doc in [old_xml, new_xml]:
5805             for node in doc.findall("ip"):
5806                 if "family" not in node.keys():
5807                     node.set("family", "ipv4")
5808         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
5809         xmlutil.strip_spaces(new_xml)
5810         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
5811         if needs_update and not test:
5812             conn.networkDefineXML(xmlutil.element_to_str(new_xml))
5813     finally:
5814         conn.close()
5815     return needs_update
5816 def list_networks(**kwargs):
5817     """
5818     List all virtual networks.
5819     :param connection: libvirt connection URI, overriding defaults
5820     :param username: username to connect with, overriding defaults
5821     :param password: password to connect with, overriding defaults
5822     .. versionadded:: 2019.2.0
5823     CLI Example:
5824     .. code-block:: bash
5825        salt '*' virt.list_networks
5826     """
5827     conn = __get_conn(**kwargs)
5828     try:
5829         return [net.name() for net in conn.listAllNetworks()]
5830     finally:
5831         conn.close()
5832 def network_info(name=None, **kwargs):
5833     """
5834     Return information on a virtual network provided its name.
5835     :param name: virtual network name
5836     :param connection: libvirt connection URI, overriding defaults
5837     :param username: username to connect with, overriding defaults
5838     :param password: password to connect with, overriding defaults
5839     If no name is provided, return the infos for all defined virtual networks.
5840     .. versionadded:: 2019.2.0
5841     CLI Example:
5842     .. code-block:: bash
5843         salt '*' virt.network_info default
5844     """
5845     result = {}
5846     conn = __get_conn(**kwargs)
5847     def _net_get_leases(net):
5848         """
5849         Get all DHCP leases for a network
5850         """
5851         leases = net.DHCPLeases()
5852         for lease in leases:
5853             if lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV4:
5854                 lease["type"] = "ipv4"
5855             elif lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV6:
5856                 lease["type"] = "ipv6"
5857             else:
5858                 lease["type"] = "unknown"
5859         return leases
5860     def _net_get_bridge(net):
5861         """
5862         Get the bridge of the network or None
5863         """
5864         try:
5865             return net.bridgeName()
5866         except libvirt.libvirtError as err:
5867             return None
5868     try:
5869         nets = [
5870             net for net in conn.listAllNetworks() if name is None or net.name() == name
5871         ]
5872         result = {
5873             net.name(): {
5874                 "uuid": net.UUIDString(),
5875                 "bridge": _net_get_bridge(net),
5876                 "autostart": net.autostart(),
5877                 "active": net.isActive(),
5878                 "persistent": net.isPersistent(),
5879                 "leases": _net_get_leases(net),
5880             }
5881             for net in nets
5882         }
5883     except libvirt.libvirtError as err:
5884         log.debug("Silenced libvirt error: %s", err)
5885     finally:
5886         conn.close()
5887     return result
5888 def network_get_xml(name, **kwargs):
5889     """
5890     Return the XML definition of a virtual network
5891     :param name: libvirt network name
5892     :param connection: libvirt connection URI, overriding defaults
5893     :param username: username to connect with, overriding defaults
5894     :param password: password to connect with, overriding defaults
5895     .. versionadded:: 3000
5896     CLI Example:
5897     .. code-block:: bash
5898         salt '*' virt.network_get_xml default
5899     """
5900     conn = __get_conn(**kwargs)
5901     try:
5902         return conn.networkLookupByName(name).XMLDesc()
5903     finally:
5904         conn.close()
5905 def network_start(name, **kwargs):
5906     """
5907     Start a defined virtual network.
5908     :param name: virtual network name
5909     :param connection: libvirt connection URI, overriding defaults
5910     :param username: username to connect with, overriding defaults
5911     :param password: password to connect with, overriding defaults
5912     .. versionadded:: 2019.2.0
5913     CLI Example:
5914     .. code-block:: bash
5915         salt '*' virt.network_start default
5916     """
5917     conn = __get_conn(**kwargs)
5918     try:
5919         net = conn.networkLookupByName(name)
5920         return not bool(net.create())
5921     finally:
5922         conn.close()
5923 def network_stop(name, **kwargs):
5924     """
5925     Stop a defined virtual network.
5926     :param name: virtual network name
5927     :param connection: libvirt connection URI, overriding defaults
5928     :param username: username to connect with, overriding defaults
5929     :param password: password to connect with, overriding defaults
5930     .. versionadded:: 2019.2.0
5931     CLI Example:
5932     .. code-block:: bash
5933         salt '*' virt.network_stop default
5934     """
5935     conn = __get_conn(**kwargs)
5936     try:
5937         net = conn.networkLookupByName(name)
5938         return not bool(net.destroy())
5939     finally:
5940         conn.close()
5941 def network_undefine(name, **kwargs):
5942     """
5943     Remove a defined virtual network. This does not stop the virtual network.
5944     :param name: virtual network name
5945     :param connection: libvirt connection URI, overriding defaults
5946     :param username: username to connect with, overriding defaults
5947     :param password: password to connect with, overriding defaults
5948     .. versionadded:: 2019.2.0
5949     CLI Example:
5950     .. code-block:: bash
5951         salt '*' virt.network_undefine default
5952     """
5953     conn = __get_conn(**kwargs)
5954     try:
5955         net = conn.networkLookupByName(name)
5956         return not bool(net.undefine())
5957     finally:
5958         conn.close()
5959 def network_set_autostart(name, state="on", **kwargs):
5960     """
5961     Set the autostart flag on a virtual network so that the network
5962     will start with the host system on reboot.
5963     :param name: virtual network name
5964     :param state: 'on' to auto start the network, anything else to mark the
5965                   virtual network not to be started when the host boots
5966     :param connection: libvirt connection URI, overriding defaults
5967     :param username: username to connect with, overriding defaults
5968     :param password: password to connect with, overriding defaults
5969     .. versionadded:: 2019.2.0
5970     CLI Example:
5971     .. code-block:: bash
5972         salt "*" virt.network_set_autostart &lt;pool&gt; &lt;on | off&gt;
5973     """
5974     conn = __get_conn(**kwargs)
5975     try:
5976         net = conn.networkLookupByName(name)
5977         return not bool(net.setAutostart(1 if state == "on" else 0))
5978     finally:
5979         conn.close()
5980 def _parse_pools_caps(doc):
5981     """
5982     Parse libvirt pool capabilities XML
5983     """
5984     def _parse_pool_caps(pool):
5985         pool_caps = {
5986             "name": pool.get("type"),
5987             "supported": pool.get("supported", "no") == "yes",
5988         }
5989         for option_kind in ["pool", "vol"]:
5990             options = {}
5991             default_format_node = pool.find(
5992                 "{}Options/defaultFormat".format(option_kind)
5993             )
5994             if default_format_node is not None:
5995                 options["default_format"] = default_format_node.get("type")
5996             options_enums = {
5997                 enum.get("name"): [value.text for value in enum.findall("value")]
5998                 for enum in pool.findall("{}Options/enum".format(option_kind))
5999             }
6000             if options_enums:
6001                 options.update(options_enums)
6002             if options:
6003                 if "options" not in pool_caps:
6004                     pool_caps["options"] = {}
6005                 kind = option_kind if option_kind != "vol" else "volume"
6006                 pool_caps["options"][kind] = options
6007         return pool_caps
6008     return [_parse_pool_caps(pool) for pool in doc.findall("pool")]
6009 def _pool_capabilities(conn):
6010     """
6011     Return the hypervisor connection storage pool capabilities.
6012     :param conn: opened libvirt connection to use
6013     """
6014     has_pool_capabilities = bool(getattr(conn, "getStoragePoolCapabilities", None))
6015     if has_pool_capabilities:
6016         caps = ElementTree.fromstring(conn.getStoragePoolCapabilities())
6017         pool_types = _parse_pools_caps(caps)
6018     else:
6019         all_hypervisors = ["xen", "kvm", "bhyve"]
6020         images_formats = [
6021             "none",
6022             "raw",
6023             "dir",
6024             "bochs",
6025             "cloop",
6026             "dmg",
6027             "iso",
6028             "vpc",
6029             "vdi",
6030             "fat",
6031             "vhd",
6032             "ploop",
6033             "cow",
6034             "qcow",
6035             "qcow2",
6036             "qed",
6037             "vmdk",
6038         ]
6039         common_drivers = [
6040             {
6041                 "name": "fs",
6042                 "default_source_format": "auto",
6043                 "source_formats": [
6044                     "auto",
6045                     "ext2",
6046                     "ext3",
6047                     "ext4",
6048                     "ufs",
6049                     "iso9660",
6050                     "udf",
6051                     "gfs",
6052                     "gfs2",
6053                     "vfat",
6054                     "hfs+",
6055                     "xfs",
6056                     "ocfs2",
6057                 ],
6058                 "default_target_format": "raw",
6059                 "target_formats": images_formats,
6060             },
6061             {
6062                 "name": "dir",
6063                 "default_target_format": "raw",
6064                 "target_formats": images_formats,
6065             },
6066             {"name": "iscsi"},
6067             {"name": "scsi"},
6068             {
6069                 "name": "logical",
6070                 "default_source_format": "lvm2",
6071                 "source_formats": ["unknown", "lvm2"],
6072             },
6073             {
6074                 "name": "netfs",
6075                 "default_source_format": "auto",
6076                 "source_formats": ["auto", "nfs", "glusterfs", "cifs"],
6077                 "default_target_format": "raw",
6078                 "target_formats": images_formats,
6079             },
6080             {
6081                 "name": "disk",
6082                 "default_source_format": "unknown",
6083                 "source_formats": [
6084                     "unknown",
6085                     "dos",
6086                     "dvh",
6087                     "gpt",
6088                     "mac",
6089                     "bsd",
6090                     "pc98",
6091                     "sun",
6092                     "lvm2",
6093                 ],
6094                 "default_target_format": "none",
6095                 "target_formats": [
6096                     "none",
6097                     "linux",
6098                     "fat16",
6099                     "fat32",
6100                     "linux-swap",
6101                     "linux-lvm",
6102                     "linux-raid",
6103                     "extended",
6104                 ],
6105             },
6106             {"name": "mpath"},
6107             {"name": "rbd", "default_target_format": "raw", "target_formats": []},
6108             {
6109                 "name": "sheepdog",
6110                 "version": 10000,
6111                 "hypervisors": ["kvm"],
6112                 "default_target_format": "raw",
6113                 "target_formats": images_formats,
6114             },
6115             {
6116                 "name": "gluster",
6117                 "version": 1002000,
6118                 "hypervisors": ["kvm"],
6119                 "default_target_format": "raw",
6120                 "target_formats": images_formats,
6121             },
6122             {"name": "zfs", "version": 1002008, "hypervisors": ["bhyve"]},
6123             {
6124                 "name": "iscsi-direct",
6125                 "version": 4007000,
6126                 "hypervisors": ["kvm", "xen"],
6127             },
6128         ]
6129         libvirt_version = conn.getLibVersion()
6130         hypervisor = get_hypervisor()
6131         def _get_backend_output(backend):
6132             output = {
6133                 "name": backend["name"],
6134                 "supported": (
6135                     not backend.get("version") or libvirt_version &gt;= backend["version"]
6136                 )
6137                 and hypervisor in backend.get("hypervisors", all_hypervisors),
6138                 "options": {
6139                     "pool": {
6140                         "default_format": backend.get("default_source_format"),
6141                         "sourceFormatType": backend.get("source_formats"),
6142                     },
6143                     "volume": {
6144                         "default_format": backend.get("default_target_format"),
6145                         "targetFormatType": backend.get("target_formats"),
6146                     },
6147                 },
6148             }
6149             for option_kind in ["pool", "volume"]:
6150                 if not [
6151                     value
6152                     for value in output["options"][option_kind].values()
6153                     if value is not None
6154                 ]:
6155                     del output["options"][option_kind]
6156             if not output["options"]:
6157                 del output["options"]
6158             return output
6159         pool_types = [_get_backend_output(backend) for backend in common_drivers]
6160     return {
6161         "computed": not has_pool_capabilities,
6162         "pool_types": pool_types,
6163     }
6164 def pool_capabilities(**kwargs):
6165     """
6166     Return the hypervisor connection storage pool capabilities.
6167     The returned data are either directly extracted from libvirt or computed.
6168     In the latter case some pool types could be listed as supported while they
6169     are not. To distinguish between the two cases, check the value of the ``computed`` property.
6170     :param connection: libvirt connection URI, overriding defaults
6171     :param username: username to connect with, overriding defaults
6172     :param password: password to connect with, overriding defaults
6173     .. versionadded:: 3000
6174     CLI Example:
6175     .. code-block:: bash
6176         salt '*' virt.pool_capabilities
6177     """
6178     try:
6179         conn = __get_conn(**kwargs)
6180         return _pool_capabilities(conn)
6181     finally:
6182         conn.close()
6183 def pool_define(
6184     name,
6185     ptype,
6186     target=None,
6187     permissions=None,
6188     source_devices=None,
6189     source_dir=None,
6190     source_initiator=None,
6191     source_adapter=None,
6192     source_hosts=None,
6193     source_auth=None,
6194     source_name=None,
6195     source_format=None,
6196     transient=False,
6197     start=True,  # pylint: disable=redefined-outer-name
6198     **kwargs
6199 ):
6200     """
6201     Create libvirt pool.
6202     :param name: Pool name
6203     :param ptype:
6204         Pool type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_  for the
6205         possible values.
6206     :param target: Pool full path target
6207     :param permissions:
6208         Permissions to set on the target folder. This is mostly used for filesystem-based
6209         pool types. See :ref:`pool-define-permissions` for more details on this structure.
6210     :param source_devices:
6211         List of source devices for pools backed by physical devices. (Default: ``None``)
6212         Each item in the list is a dictionary with ``path`` and optionally ``part_separator``
6213         keys. The path is the qualified name for iSCSI devices.
6214         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
6215         for more information on the use of ``part_separator``
6216     :param source_dir:
6217         Path to the source directory for pools of type ``dir``, ``netfs`` or ``gluster``.
6218         (Default: ``None``)
6219     :param source_initiator:
6220         Initiator IQN for libiscsi-direct pool types. (Default: ``None``)
6221         .. versionadded:: 3000
6222     :param source_adapter:
6223         SCSI source definition. The value is a dictionary with ``type``, ``name``, ``parent``,
6224         ``managed``, ``parent_wwnn``, ``parent_wwpn``, ``parent_fabric_wwn``, ``wwnn``, ``wwpn``
6225         and ``parent_address`` keys.
6226         The ``parent_address`` value is a dictionary with ``unique_id`` and ``address`` keys.
6227         The address represents a PCI address and is itself a dictionary with ``domain``, ``bus``,
6228         ``slot`` and ``function`` properties.
6229         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
6230         for the meaning and possible values of these properties.
6231     :param source_hosts:
6232         List of source for pools backed by storage from remote servers. Each item is the hostname
6233         optionally followed by the port separated by a colon. (Default: ``None``)
6234     :param source_auth:
6235         Source authentication details. (Default: ``None``)
6236         The value is a dictionary with ``type``, ``username`` and ``secret`` keys. The type
6237         can be one of ``ceph`` for Ceph RBD or ``chap`` for iSCSI sources.
6238         The ``secret`` value links to a libvirt secret object. It is a dictionary with
6239         ``type`` and ``value`` keys. The type value can be either ``uuid`` or ``usage``.
6240         Examples:
6241         .. code-block:: python
6242             source_auth={
6243                 'type': 'ceph',
6244                 'username': 'admin',
6245                 'secret': {
6246                     'type': 'uuid',
6247                     'value': '2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'
6248                 }
6249             }
6250         .. code-block:: python
6251             source_auth={
6252                 'type': 'chap',
6253                 'username': 'myname',
6254                 'secret': {
6255                     'type': 'usage',
6256                     'value': 'mycluster_myname'
6257                 }
6258             }
6259         Since 3000, instead the source authentication can only contain ``username``
6260         and ``password`` properties. In this case the libvirt secret will be defined and used.
6261         For Ceph authentications a base64 encoded key is expected.
6262     :param source_name:
6263         Identifier of name-based sources.
6264     :param source_format:
6265         String representing the source format. The possible values are depending on the
6266         source type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_ for
6267         the possible values.
6268     :param start: Pool start (default True)
6269     :param transient:
6270         When ``True``, the pool will be automatically undefined after being stopped.
6271         Note that a transient pool will force ``start`` to ``True``. (Default: ``False``)
6272     :param connection: libvirt connection URI, overriding defaults
6273     :param username: username to connect with, overriding defaults
6274     :param password: password to connect with, overriding defaults
6275     .. _pool-define-permissions:
6276     .. rubric:: Permissions definition
6277     The permissions are described by a dictionary containing the following keys:
6278     mode
6279         The octal representation of the permissions. (Default: `0711`)
6280     owner
6281         the numeric user ID of the owner. (Default: from the parent folder)
6282     group
6283         the numeric ID of the group. (Default: from the parent folder)
6284     label
6285         the SELinux label. (Default: `None`)
6286     .. rubric:: CLI Example:
6287     Local folder pool:
6288     .. code-block:: bash
6289         salt '*' virt.pool_define somepool dir target=/srv/mypool \
6290                                   permissions="{'mode': '0744' 'ower': 107, 'group': 107 }"
6291     CIFS backed pool:
6292     .. code-block:: bash
6293         salt '*' virt.pool_define myshare netfs source_format=cifs \
6294                                   source_dir=samba_share source_hosts="['example.com']" target=/mnt/cifs
6295     .. versionadded:: 2019.2.0
6296     """
6297     conn = __get_conn(**kwargs)
6298     auth = _pool_set_secret(conn, ptype, name, source_auth)
6299     pool_xml = _gen_pool_xml(
6300         name,
6301         ptype,
6302         target,
6303         permissions=permissions,
6304         source_devices=source_devices,
6305         source_dir=source_dir,
6306         source_adapter=source_adapter,
6307         source_hosts=source_hosts,
6308         source_auth=auth,
6309         source_name=source_name,
6310         source_format=source_format,
6311         source_initiator=source_initiator,
6312     )
6313     try:
6314         if transient:
6315             pool = conn.storagePoolCreateXML(pool_xml)
6316         else:
6317             pool = conn.storagePoolDefineXML(pool_xml)
6318             if start:
6319                 pool.create()
6320     except libvirt.libvirtError as err:
6321         raise err  # a real error we should report upwards
6322     finally:
6323         conn.close()
6324     return True
6325 def _pool_set_secret(
6326     conn, pool_type, pool_name, source_auth, uuid=None, usage=None, test=False
6327 ):
6328     secret_types = {"rbd": "ceph", "iscsi": "chap", "iscsi-direct": "chap"}
6329     secret_type = secret_types.get(pool_type)
6330     auth = source_auth
6331     if source_auth and "username" in source_auth and "password" in source_auth:
6332         if secret_type:
6333             secret = None
6334             try:
6335                 if usage:
6336                     usage_type = (
6337                         libvirt.VIR_SECRET_USAGE_TYPE_CEPH
6338                         if secret_type == "ceph"
6339                         else libvirt.VIR_SECRET_USAGE_TYPE_ISCSI
6340                     )
6341                     secret = conn.secretLookupByUsage(usage_type, usage)
6342                 elif uuid:
6343                     secret = conn.secretLookupByUUIDString(uuid)
6344             except libvirt.libvirtError as err:
6345                 log.info("Secret not found: %s", err.get_error_message())
6346             if not secret:
6347                 description = "Passphrase for {} pool created by Salt".format(pool_name)
6348                 if not usage:
6349                     usage = "pool_{}".format(pool_name)
6350                 secret_xml = _gen_secret_xml(secret_type, usage, description)
6351                 if not test:
6352                     secret = conn.secretDefineXML(secret_xml)
6353             password = auth["password"]
6354             if pool_type == "rbd":
6355                 password = base64.b64decode(salt.utils.stringutils.to_bytes(password))
6356             if not test:
6357                 secret.setValue(password)
6358             auth["type"] = secret_type
6359             auth["secret"] = {
6360                 "type": "uuid" if uuid else "usage",
6361                 "value": uuid if uuid else usage,
6362             }
6363     return auth
6364 def pool_update(
6365     name,
6366     ptype,
6367     target=None,
6368     permissions=None,
6369     source_devices=None,
6370     source_dir=None,
6371     source_initiator=None,
6372     source_adapter=None,
6373     source_hosts=None,
6374     source_auth=None,
6375     source_name=None,
6376     source_format=None,
6377     test=False,
6378     **kwargs
6379 ):
6380     """
6381     Update a libvirt storage pool if needed.
6382     If called with test=True, this is also reporting whether an update would be performed.
6383     :param name: Pool name
6384     :param ptype:
6385         Pool type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_  for the
6386         possible values.
6387     :param target: Pool full path target
6388     :param permissions:
6389         Permissions to set on the target folder. This is mostly used for filesystem-based
6390         pool types. See :ref:`pool-define-permissions` for more details on this structure.
6391     :param source_devices:
6392         List of source devices for pools backed by physical devices. (Default: ``None``)
6393         Each item in the list is a dictionary with ``path`` and optionally ``part_separator``
6394         keys. The path is the qualified name for iSCSI devices.
6395         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
6396         for more information on the use of ``part_separator``
6397     :param source_dir:
6398         Path to the source directory for pools of type ``dir``, ``netfs`` or ``gluster``.
6399         (Default: ``None``)
6400     :param source_initiator:
6401         Initiator IQN for libiscsi-direct pool types. (Default: ``None``)
6402         .. versionadded:: 3000
6403     :param source_adapter:
6404         SCSI source definition. The value is a dictionary with ``type``, ``name``, ``parent``,
6405         ``managed``, ``parent_wwnn``, ``parent_wwpn``, ``parent_fabric_wwn``, ``wwnn``, ``wwpn``
6406         and ``parent_address`` keys.
6407         The ``parent_address`` value is a dictionary with ``unique_id`` and ``address`` keys.
6408         The address represents a PCI address and is itself a dictionary with ``domain``, ``bus``,
6409         ``slot`` and ``function`` properties.
6410         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
6411         for the meaning and possible values of these properties.
6412     :param source_hosts:
6413         List of source for pools backed by storage from remote servers. Each item is the hostname
6414         optionally followed by the port separated by a colon. (Default: ``None``)
6415     :param source_auth:
6416         Source authentication details. (Default: ``None``)
6417         The value is a dictionary with ``type``, ``username`` and ``secret`` keys. The type
6418         can be one of ``ceph`` for Ceph RBD or ``chap`` for iSCSI sources.
6419         The ``secret`` value links to a libvirt secret object. It is a dictionary with
6420         ``type`` and ``value`` keys. The type value can be either ``uuid`` or ``usage``.
6421         Examples:
6422         .. code-block:: python
6423             source_auth={
6424                 'type': 'ceph',
6425                 'username': 'admin',
6426                 'secret': {
6427                     'type': 'uuid',
6428                     'uuid': '2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'
6429                 }
6430             }
6431         .. code-block:: python
6432             source_auth={
6433                 'type': 'chap',
6434                 'username': 'myname',
6435                 'secret': {
6436                     'type': 'usage',
6437                     'uuid': 'mycluster_myname'
6438                 }
6439             }
6440         Since 3000, instead the source authentication can only contain ``username``
6441         and ``password`` properties. In this case the libvirt secret will be defined and used.
6442         For Ceph authentications a base64 encoded key is expected.
6443     :param source_name:
6444         Identifier of name-based sources.
6445     :param source_format:
6446         String representing the source format. The possible values are depending on the
6447         source type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_ for
6448         the possible values.
6449     :param test: run in dry-run mode if set to True
6450     :param connection: libvirt connection URI, overriding defaults
6451     :param username: username to connect with, overriding defaults
6452     :param password: password to connect with, overriding defaults
6453     .. rubric:: Example:
6454     Local folder pool:
6455     .. code-block:: bash
6456         salt '*' virt.pool_update somepool dir target=/srv/mypool \
6457                                   permissions="{'mode': '0744' 'ower': 107, 'group': 107 }"
6458     CIFS backed pool:
6459     .. code-block:: bash
6460         salt '*' virt.pool_update myshare netfs source_format=cifs \
6461                                   source_dir=samba_share source_hosts="['example.com']" target=/mnt/cifs
6462     .. versionadded:: 3000
6463     """
6464     conn = __get_conn(**kwargs)
6465     needs_update = False
6466     try:
6467         pool = conn.storagePoolLookupByName(name)
6468         old_xml = ElementTree.fromstring(pool.XMLDesc())
6469         secret_node = old_xml.find("source/auth/secret")
6470         usage = secret_node.get("usage") if secret_node is not None else None
6471         uuid = secret_node.get("uuid") if secret_node is not None else None
6472         auth = _pool_set_secret(
6473             conn, ptype, name, source_auth, uuid=uuid, usage=usage, test=test
6474         )
6475         new_xml = ElementTree.fromstring(
6476             _gen_pool_xml(
6477                 name,
6478                 ptype,
6479                 target,
6480                 permissions=permissions,
6481                 source_devices=source_devices,
6482                 source_dir=source_dir,
6483                 source_initiator=source_initiator,
6484                 source_adapter=source_adapter,
6485                 source_hosts=source_hosts,
6486                 source_auth=auth,
6487                 source_name=source_name,
6488                 source_format=source_format,
6489             )
6490         )
6491         elements_to_copy = ["available", "allocation", "capacity", "uuid"]
6492         for to_copy in elements_to_copy:
6493             element = old_xml.find(to_copy)
6494             new_xml.insert(1, element)
6495         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
6496         xmlutil.strip_spaces(new_xml)
6497         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
6498         if needs_update and not test:
6499             conn.storagePoolDefineXML(xmlutil.element_to_str(new_xml))
6500     finally:
6501         conn.close()
6502     return needs_update
6503 def list_pools(**kwargs):
6504     """
6505     List all storage pools.
6506     :param connection: libvirt connection URI, overriding defaults
6507     :param username: username to connect with, overriding defaults
6508     :param password: password to connect with, overriding defaults
6509     .. versionadded:: 2019.2.0
6510     CLI Example:
6511     .. code-block:: bash
6512         salt '*' virt.list_pools
6513     """
6514     conn = __get_conn(**kwargs)
6515     try:
6516         return [pool.name() for pool in conn.listAllStoragePools()]
6517     finally:
6518         conn.close()
6519 def pool_info(name=None, **kwargs):
6520     """
6521     Return information on a storage pool provided its name.
6522     :param name: libvirt storage pool name
6523     :param connection: libvirt connection URI, overriding defaults
6524     :param username: username to connect with, overriding defaults
6525     :param password: password to connect with, overriding defaults
6526     If no name is provided, return the infos for all defined storage pools.
6527     .. versionadded:: 2019.2.0
6528     CLI Example:
6529     .. code-block:: bash
6530         salt '*' virt.pool_info default
6531     """
6532     result = {}
6533     conn = __get_conn(**kwargs)
6534     def _pool_extract_infos(pool):
6535         """
6536         Format the pool info dictionary
6537         :param pool: the libvirt pool object
6538         """
6539         states = ["inactive", "building", "running", "degraded", "inaccessible"]
6540         infos = pool.info()
6541         state = states[infos[0]] if infos[0] &lt; len(states) else "unknown"
6542         desc = ElementTree.fromstring(pool.XMLDesc())
6543         path_node = desc.find("target/path")
6544         return {
6545             "uuid": pool.UUIDString(),
6546             "state": state,
6547             "capacity": infos[1],
6548             "allocation": infos[2],
6549             "free": infos[3],
6550             "autostart": pool.autostart(),
6551             "persistent": pool.isPersistent(),
6552             "target_path": path_node.text if path_node is not None else None,
6553             "type": desc.get("type"),
6554         }
6555     try:
6556         pools = [
6557             pool
6558             for pool in conn.listAllStoragePools()
6559             if name is None or pool.name() == name
6560         ]
6561         result = {pool.name(): _pool_extract_infos(pool) for pool in pools}
6562     except libvirt.libvirtError as err:
6563         log.debug("Silenced libvirt error: %s", err)
6564     finally:
6565         conn.close()
6566     return result
6567 def pool_get_xml(name, **kwargs):
6568     """
6569     Return the XML definition of a virtual storage pool
6570     :param name: libvirt storage pool name
6571     :param connection: libvirt connection URI, overriding defaults
6572     :param username: username to connect with, overriding defaults
6573     :param password: password to connect with, overriding defaults
6574     .. versionadded:: 3000
6575     CLI Example:
6576     .. code-block:: bash
6577         salt '*' virt.pool_get_xml default
6578     """
6579     conn = __get_conn(**kwargs)
6580     try:
6581         return conn.storagePoolLookupByName(name).XMLDesc()
6582     finally:
6583         conn.close()
6584 def pool_start(name, **kwargs):
6585     """
6586     Start a defined libvirt storage pool.
6587     :param name: libvirt storage pool name
6588     :param connection: libvirt connection URI, overriding defaults
6589     :param username: username to connect with, overriding defaults
6590     :param password: password to connect with, overriding defaults
6591     .. versionadded:: 2019.2.0
6592     CLI Example:
6593     .. code-block:: bash
6594         salt '*' virt.pool_start default
6595     """
6596     conn = __get_conn(**kwargs)
6597     try:
6598         pool = conn.storagePoolLookupByName(name)
6599         return not bool(pool.create())
6600     finally:
6601         conn.close()
6602 def pool_build(name, **kwargs):
6603     """
6604     Build a defined libvirt storage pool.
6605     :param name: libvirt storage pool name
6606     :param connection: libvirt connection URI, overriding defaults
6607     :param username: username to connect with, overriding defaults
6608     :param password: password to connect with, overriding defaults
6609     .. versionadded:: 2019.2.0
6610     CLI Example:
6611     .. code-block:: bash
6612         salt '*' virt.pool_build default
6613     """
6614     conn = __get_conn(**kwargs)
6615     try:
6616         pool = conn.storagePoolLookupByName(name)
6617         return not bool(pool.build())
6618     finally:
6619         conn.close()
6620 def pool_stop(name, **kwargs):
6621     """
6622     Stop a defined libvirt storage pool.
6623     :param name: libvirt storage pool name
6624     :param connection: libvirt connection URI, overriding defaults
6625     :param username: username to connect with, overriding defaults
6626     :param password: password to connect with, overriding defaults
6627     .. versionadded:: 2019.2.0
6628     CLI Example:
6629     .. code-block:: bash
6630         salt '*' virt.pool_stop default
6631     """
6632     conn = __get_conn(**kwargs)
6633     try:
6634         pool = conn.storagePoolLookupByName(name)
6635         return not bool(pool.destroy())
6636     finally:
6637         conn.close()
6638 def pool_undefine(name, **kwargs):
6639     """
6640     Remove a defined libvirt storage pool. The pool needs to be stopped before calling.
6641     :param name: libvirt storage pool name
6642     :param connection: libvirt connection URI, overriding defaults
6643     :param username: username to connect with, overriding defaults
6644     :param password: password to connect with, overriding defaults
6645     .. versionadded:: 2019.2.0
6646     CLI Example:
6647     .. code-block:: bash
6648         salt '*' virt.pool_undefine default
6649     """
6650     conn = __get_conn(**kwargs)
6651     try:
6652         pool = conn.storagePoolLookupByName(name)
6653         desc = ElementTree.fromstring(pool.XMLDesc())
6654         auth_node = desc.find("source/auth")
6655         if auth_node is not None:
6656             auth_types = {
6657                 "ceph": libvirt.VIR_SECRET_USAGE_TYPE_CEPH,
6658                 "iscsi": libvirt.VIR_SECRET_USAGE_TYPE_ISCSI,
6659             }
6660             secret_type = auth_types[auth_node.get("type")]
6661             secret_usage = auth_node.find("secret").get("usage")
6662             if secret_type and "pool_{}".format(name) == secret_usage:
6663                 secret = conn.secretLookupByUsage(secret_type, secret_usage)
6664                 secret.undefine()
6665         return not bool(pool.undefine())
6666     finally:
6667         conn.close()
6668 def pool_delete(name, **kwargs):
6669     """
6670     Delete the resources of a defined libvirt storage pool.
6671     :param name: libvirt storage pool name
6672     :param connection: libvirt connection URI, overriding defaults
6673     :param username: username to connect with, overriding defaults
6674     :param password: password to connect with, overriding defaults
6675     .. versionadded:: 2019.2.0
6676     CLI Example:
6677     .. code-block:: bash
6678         salt '*' virt.pool_delete default
6679     """
6680     conn = __get_conn(**kwargs)
6681     try:
6682         pool = conn.storagePoolLookupByName(name)
6683         return not bool(pool.delete(libvirt.VIR_STORAGE_POOL_DELETE_NORMAL))
6684     finally:
6685         conn.close()
6686 def pool_refresh(name, **kwargs):
6687     """
6688     Refresh a defined libvirt storage pool.
6689     :param name: libvirt storage pool name
6690     :param connection: libvirt connection URI, overriding defaults
6691     :param username: username to connect with, overriding defaults
6692     :param password: password to connect with, overriding defaults
6693     .. versionadded:: 2019.2.0
6694     CLI Example:
6695     .. code-block:: bash
6696         salt '*' virt.pool_refresh default
6697     """
6698     conn = __get_conn(**kwargs)
6699     try:
6700         pool = conn.storagePoolLookupByName(name)
6701         return not bool(pool.refresh())
6702     finally:
6703         conn.close()
6704 def pool_set_autostart(name, state="on", **kwargs):
6705     """
6706     Set the autostart flag on a libvirt storage pool so that the storage pool
6707     will start with the host system on reboot.
6708     :param name: libvirt storage pool name
6709     :param state: 'on' to auto start the pool, anything else to mark the
6710                   pool not to be started when the host boots
6711     :param connection: libvirt connection URI, overriding defaults
6712     :param username: username to connect with, overriding defaults
6713     :param password: password to connect with, overriding defaults
6714     .. versionadded:: 2019.2.0
6715     CLI Example:
6716     .. code-block:: bash
6717         salt "*" virt.pool_set_autostart &lt;pool&gt; &lt;on | off&gt;
6718     """
6719     conn = __get_conn(**kwargs)
6720     try:
6721         pool = conn.storagePoolLookupByName(name)
6722         return not bool(pool.setAutostart(1 if state == "on" else 0))
6723     finally:
6724         conn.close()
6725 def pool_list_volumes(name, **kwargs):
6726     """
6727     List the volumes contained in a defined libvirt storage pool.
6728     :param name: libvirt storage pool name
6729     :param connection: libvirt connection URI, overriding defaults
6730     :param username: username to connect with, overriding defaults
6731     :param password: password to connect with, overriding defaults
6732     .. versionadded:: 2019.2.0
6733     CLI Example:
6734     .. code-block:: bash
6735         salt "*" virt.pool_list_volumes &lt;pool&gt;
6736     """
6737     conn = __get_conn(**kwargs)
6738     try:
6739         pool = conn.storagePoolLookupByName(name)
6740         return pool.listVolumes()
6741     finally:
6742         conn.close()
6743 def _get_storage_vol(conn, pool, vol):
6744     """
6745     Helper function getting a storage volume. Will throw a libvirtError
6746     if the pool or the volume couldn't be found.
6747     :param conn: libvirt connection object to use
6748     :param pool: pool name
6749     :param vol: volume name
6750     """
6751     pool_obj = conn.storagePoolLookupByName(pool)
6752     return pool_obj.storageVolLookupByName(vol)
6753 def _is_valid_volume(vol):
6754     """
6755     Checks whether a volume is valid for further use since those may have disappeared since
6756     the last pool refresh.
6757     """
6758     try:
6759         def discarder(ctxt, error):  # pylint: disable=unused-argument
6760             log.debug("Ignore libvirt error: %s", error[2])
6761         libvirt.registerErrorHandler(discarder, None)
6762         vol.info()
6763         libvirt.registerErrorHandler(None, None)
6764         return True
6765     except libvirt.libvirtError as err:
6766         return False
6767 def _get_all_volumes_paths(conn):
6768     """
6769     Extract the path, name, pool name and backing stores path of all volumes.
6770     :param conn: libvirt connection to use
6771     """
6772     pools = [
6773         pool
6774         for pool in conn.listAllStoragePools()
6775         if pool.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
6776     ]
6777     volumes = {}
6778     for pool in pools:
6779         pool_volumes = {
6780             volume.path(): {
6781                 "pool": pool.name(),
6782                 "name": volume.name(),
6783                 "backing_stores": [
6784                     path.text
6785                     for path in ElementTree.fromstring(volume.XMLDesc()).findall(
6786                         ".//backingStore/path"
6787                     )
6788                 ],
6789             }
6790             for volume in pool.listAllVolumes()
6791             if _is_valid_volume(volume)
6792         }
6793         volumes.update(pool_volumes)
6794     return volumes
6795 def volume_infos(pool=None, volume=None, **kwargs):
6796     """
6797     Provide details on a storage volume. If no volume name is provided, the infos
6798     all the volumes contained in the pool are provided. If no pool is provided,
6799     the infos of the volumes of all pools are output.
6800     :param pool: libvirt storage pool name (default: ``None``)
6801     :param volume: name of the volume to get infos from (default: ``None``)
6802     :param connection: libvirt connection URI, overriding defaults
6803     :param username: username to connect with, overriding defaults
6804     :param password: password to connect with, overriding defaults
6805     .. versionadded:: 3000
6806     CLI Example:
6807     .. code-block:: bash
6808         salt "*" virt.volume_infos &lt;pool&gt; &lt;volume&gt;
6809     """
6810     result = {}
6811     conn = __get_conn(**kwargs)
6812     try:
6813         backing_stores = _get_all_volumes_paths(conn)
6814         try:
6815             domains = _get_domain(conn)
6816             domains_list = domains if isinstance(domains, list) else [domains]
6817         except CommandExecutionError:
6818             domains_list = []
6819         disks = {
6820             domain.name(): {
6821                 node.get("file")
6822                 for node in ElementTree.fromstring(domain.XMLDesc(0)).findall(
6823                     ".//disk/source/[@file]"
6824                 )
6825             }
6826             for domain in domains_list
6827         }
6828         def _volume_extract_infos(vol):
6829             """
6830             Format the volume info dictionary
6831             :param vol: the libvirt storage volume object.
6832             """
6833             types <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= ["file", "block", "dir", "network", "netdir", "ploop"]
6834             infos = vol.info()
6835             vol_xml = ElementTree.fromstring(vol.XMLDesc())
6836             backing_store_path = vol_xml.</b></font>find("./backingStore/path")
6837             backing_store_format = vol_xml.find("./backingStore/format")
6838             backing_store = None
6839             if backing_store_path is not None:
6840                 backing_store = {
6841                     "path": backing_store_path.text,
6842                     "format": backing_store_format.get("type")
6843                     if backing_store_format is not None
6844                     else None,
6845                 }
6846             format_node = vol_xml.find("./target/format")
6847             used_by = []
6848             if vol.path():
6849                 as_backing_store = {
6850                     path
6851                     for (path, volume) in backing_stores.items()
6852                     if vol.path() in volume.get("backing_stores")
6853                 }
6854                 used_by = [
6855                     vm_name
6856                     for (vm_name, vm_disks) in disks.items()
6857                     if vm_disks &amp; as_backing_store or vol.path() in vm_disks
6858                 ]
6859             return {
6860                 "type": types[infos[0]] if infos[0] &lt; len(types) else "unknown",
6861                 "key": vol.key(),
6862                 "path": vol.path(),
6863                 "capacity": infos[1],
6864                 "allocation": infos[2],
6865                 "used_by": used_by,
6866                 "backing_store": backing_store,
6867                 "format": format_node.get("type") if format_node is not None else None,
6868             }
6869         pools = [
6870             obj
6871             for obj in conn.listAllStoragePools()
6872             if (pool is None or obj.name() == pool)
6873             and obj.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
6874         ]
6875         vols = {
6876             pool_obj.name(): {
6877                 vol.name(): _volume_extract_infos(vol)
6878                 for vol in pool_obj.listAllVolumes()
6879                 if (volume is None or vol.name() == volume) and _is_valid_volume(vol)
6880             }
6881             for pool_obj in pools
6882         }
6883         return {pool_name: volumes for (pool_name, volumes) in vols.items() if volumes}
6884     except libvirt.libvirtError as err:
6885         log.debug("Silenced libvirt error: %s", err)
6886     finally:
6887         conn.close()
6888     return result
6889 def volume_delete(pool, volume, **kwargs):
6890     """
6891     Delete a libvirt managed volume.
6892     :param pool: libvirt storage pool name
6893     :param volume: name of the volume to delete
6894     :param connection: libvirt connection URI, overriding defaults
6895     :param username: username to connect with, overriding defaults
6896     :param password: password to connect with, overriding defaults
6897     .. versionadded:: 3000
6898     CLI Example:
6899     .. code-block:: bash
6900         salt "*" virt.volume_delete &lt;pool&gt; &lt;volume&gt;
6901     """
6902     conn = __get_conn(**kwargs)
6903     try:
6904         vol = _get_storage_vol(conn, pool, volume)
6905         return not bool(vol.delete())
6906     finally:
6907         conn.close()
6908 def volume_define(
6909     pool,
6910     name,
6911     size,
6912     allocation=0,
6913     format=None,
6914     type=None,
6915     permissions=None,
6916     backing_store=None,
6917     nocow=False,
6918     **kwargs
6919 ):
6920     """
6921     Create libvirt volume.
6922     :param pool: name of the pool to create the volume in
6923     :param name: name of the volume to define
6924     :param size: capacity of the volume to define in MiB
6925     :param allocation: allocated size of the volume in MiB. Defaults to 0.
6926     :param format:
6927         volume format. The allowed values are depending on the pool type.
6928         Check the virt.pool_capabilities output for the possible values and the default.
6929     :param type:
6930         type of the volume. One of file, block, dir, network, netdiri, ploop or None.
6931         By default, the type is guessed by libvirt from the pool type.
6932     :param permissions:
6933         Permissions to set on the target folder. This is mostly used for filesystem-based
6934         pool types. See :ref:`pool-define-permissions` for more details on this structure.
6935     :param backing_store:
6936         dictionary describing a backing file for the volume. It must contain a ``path``
6937         property pointing to the base volume and a ``format`` property defining the format
6938         of the base volume.
6939         The base volume format will not be guessed for security reasons and is thus mandatory.
6940     :param nocow: disable COW for the volume.
6941     :param connection: libvirt connection URI, overriding defaults
6942     :param username: username to connect with, overriding defaults
6943     :param password: password to connect with, overriding defaults
6944     .. rubric:: CLI Example:
6945     Volume on ESX:
6946     .. code-block:: bash
6947         salt '*' virt.volume_define "[local-storage]" myvm/myvm.vmdk vmdk 8192
6948     QCow2 volume with backing file:
6949     .. code-block:: bash
6950         salt '*' virt.volume_define default myvm.qcow2 qcow2 8192 \
6951                             permissions="{'mode': '0775', 'owner': '123', 'group': '345'"}" \
6952                             backing_store="{'path': '/path/to/base.img', 'format': 'raw'}" \
6953                             nocow=True
6954     .. versionadded:: 3001
6955     """
6956     ret = False
6957     try:
6958         conn = __get_conn(**kwargs)
6959         pool_obj = conn.storagePoolLookupByName(pool)
6960         pool_type = ElementTree.fromstring(pool_obj.XMLDesc()).get("type")
6961         new_allocation = allocation
6962         if pool_type == "logical" and size != allocation:
6963             new_allocation = size
6964         xml = _gen_vol_xml(
6965             name,
6966             size,
6967             format=format,
6968             allocation=new_allocation,
6969             type=type,
6970             permissions=permissions,
6971             backing_store=backing_store,
6972             nocow=nocow,
6973         )
6974         ret = _define_vol_xml_str(conn, xml, pool=pool)
6975     except libvirt.libvirtError as err:
6976         raise CommandExecutionError(err.get_error_message())
6977     finally:
6978         conn.close()
6979     return ret
6980 def _volume_upload(conn, pool, volume, file, offset=0, length=0, sparse=False):
6981     """
6982     Function performing the heavy duty for volume_upload but using an already
6983     opened libvirt connection.
6984     """
6985     def handler(stream, nbytes, opaque):
6986         return os.read(opaque, nbytes)
6987     def holeHandler(stream, opaque):
6988         """
6989         Taken from the sparsestream.py libvirt-python example.
6990         """
6991         fd = opaque
6992         cur = os.lseek(fd, 0, os.SEEK_CUR)
6993         try:
6994             data = os.lseek(fd, cur, os.SEEK_DATA)
6995         except OSError as e:
6996             if e.errno != 6:
6997                 raise e
6998             else:
6999                 data = -1
7000         if data &lt; 0:
7001             inData = False
7002             eof = os.lseek(fd, 0, os.SEEK_END)
7003             if eof &lt; cur:
7004                 raise RuntimeError("Current position in file after EOF: {}".format(cur))
7005             sectionLen = eof - cur
7006         else:
7007             if data &gt; cur:
7008                 inData = False
7009                 sectionLen = data - cur
7010             else:
7011                 inData = True
7012                 hole = os.lseek(fd, data, os.SEEK_HOLE)
7013                 if hole &lt; 0:
7014                     raise RuntimeError("No trailing hole")
7015                 if hole == data:
7016                     raise RuntimeError("Impossible happened")
7017                 else:
7018                     sectionLen = hole - data
7019         os.lseek(fd, cur, os.SEEK_SET)
7020         return [inData, sectionLen]
7021     def skipHandler(stream, length, opaque):
7022         return os.lseek(opaque, length, os.SEEK_CUR)
7023     stream = None
7024     fd = None
7025     ret = False
7026     try:
7027         pool_obj = conn.storagePoolLookupByName(pool)
7028         vol_obj = pool_obj.storageVolLookupByName(volume)
7029         stream = conn.newStream()
7030         fd = os.open(file, os.O_RDONLY)
7031         vol_obj.upload(
7032             stream,
7033             offset,
7034             length,
7035             libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM if sparse else 0,
7036         )
7037         if sparse:
7038             stream.sparseSendAll(handler, holeHandler, skipHandler, fd)
7039         else:
7040             stream.sendAll(handler, fd)
7041         ret = True
7042     except libvirt.libvirtError as err:
7043         raise CommandExecutionError(err.get_error_message())
7044     finally:
7045         if fd:
7046             try:
7047                 os.close(fd)
7048             except OSError as err:
7049                 if stream:
7050                     stream.abort()
7051                 if ret:
7052                     raise CommandExecutionError(
7053                         "Failed to close file: {}".format(err.strerror)
7054                     )
7055         if stream:
7056             try:
7057                 stream.finish()
7058             except libvirt.libvirtError as err:
7059                 if ret:
7060                     raise CommandExecutionError(
7061                         "Failed to finish stream: {}".format(err.get_error_message())
7062                     )
7063     return ret
7064 def volume_upload(pool, volume, file, offset=0, length=0, sparse=False, **kwargs):
7065     """
7066     Create libvirt volume.
7067     :param pool: name of the pool to create the volume in
7068     :param name: name of the volume to define
7069     :param file: the file to upload to the volume
7070     :param offset: where to start writing the data in the volume
7071     :param length: amount of bytes to transfer to the volume
7072     :param sparse: set to True to preserve data sparsiness.
7073     :param connection: libvirt connection URI, overriding defaults
7074     :param username: username to connect with, overriding defaults
7075     :param password: password to connect with, overriding defaults
7076     .. rubric:: CLI Example:
7077     .. code-block:: bash
7078         salt '*' virt.volume_upload default myvm.qcow2 /path/to/disk.qcow2
7079     .. versionadded:: 3001
7080     """
7081     conn = __get_conn(**kwargs)
7082     ret = False
7083     try:
7084         ret = _volume_upload(
7085             conn, pool, volume, file, offset=offset, length=length, sparse=sparse
7086         )
7087     finally:
7088         conn.close()
7089     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
