<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for __init___43.py &amp; virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for __init___43.py &amp; virt_1.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>__init___43.py (8.4535055%)<th>virt_1.py (2.1915689%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(117-137)<td><a href="#" name="0">(4072-4091)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(7-29)<td><a href="#" name="1">(131-155)</a><td align="center"><font color="#f30000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(101-104)<td><a href="#" name="2">(438-441)</a><td align="center"><font color="#a20000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(618-622)<td><a href="#" name="3">(2955-2958)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(468-471)<td><a href="#" name="4">(6822-6827)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(354-359)<td><a href="#" name="5">(1465-1470)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(335-341)<td><a href="#" name="6">(214-224)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(265-270)<td><a href="#" name="7">(1512-1521)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(765-767)<td><a href="#" name="8">(1473-1475)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(255-259)<td><a href="#" name="9">(8720-8724)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(252-254)<td><a href="#" name="10">(6426-6430)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(193-202)<td><a href="#" name="11">(1594-1596)</a><td align="center"><font color="#8b0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___43.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import hashlib
2 import logging
3 import os
4 import shutil
5 import sys
6 import tarfile
7 import salt.cache
8 import salt.client
9 import salt.config
10 import salt.loader
11 import salt.syspaths as syspaths
12 import salt.utils.files
13 import salt.utils.http as http
14 import salt.utils.path
15 import salt.utils.platform
16 import salt.utils.win_functions
17 import salt.utils.yaml
18 from salt.template import compile_template
19 try:
20     import pwd
21     import</b></font> grp
22 except ImportError:
23     pass
24 log = logging.getLogger(__name__)
25 FILE_TYPES = ("c", "d", "g", "l", "r", "s", "m")
26 class SPMException(Exception):
27 class SPMInvocationError(SPMException):
28 class SPMPackageError(SPMException):
29 class SPMDatabaseError(SPMException):
30 class SPMOperationCanceled(SPMException):
31 class SPMClient:
32     def __init__(self, ui, opts=None):  # pylint: disable=W0231
33         self.ui = ui
34         if not opts:
35             opts = salt.config.spm_config(os.path.join(syspaths.CONFIG_DIR, "spm"))
36         self.opts = opts
37         self.db_prov = self.opts.get("spm_db_provider", "sqlite3")
38         self.files_prov = self.opts.get("spm_files_provider", "local")
39         self._prep_pkgdb()
40         self._prep_pkgfiles()
41         self.db_conn = None
42         self.files_conn = None
43         self._init()
44     def _prep_pkgdb(self):
45         self.pkgdb = salt.loader.pkgdb(self.opts)
46     def _prep_pkgfiles(self):
47 <a name="2"></a>        self.pkgfiles = salt.loader.pkgfiles(self.opts)
48     def _init(self):
49         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not self.db_conn:
50             self.db_conn = self._pkgdb_fun("init")
51         if not self.files_conn:
52             self.files_conn = self._pkgfiles_fun(</b></font>"init")
53     def _close(self):
54         if self.db_conn:
55             self.db_conn.close()
56     def run(self, args):
57 <a name="0"></a>        command = args[0]
58         try:
59             if command == "install":
60                 self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._install(args)
61             elif command == "local":
62                 self._local(args)
63             elif command == "repo":
64                 self._repo(args)
65             elif command == "remove":
66                 self._remove(args)
67             elif command == "build":
68                 self._build(args)
69             elif command == "update_repo":
70                 self._download_repo_metadata(args)
71             elif command == "create_repo":
72                 self._create_repo(args)
73             elif command == "files":
74                 self._list_files(args)
75             elif command == "info":
76                 self._info(args)
77             elif command == "list":
78                 self._list(args)
79             elif command == "close":
80                 self._close(</b></font>)
81             else:
82                 raise SPMInvocationError("Invalid command '{}'".format(command))
83         except SPMException as exc:
84             self.ui.error(str(exc))
85     def _pkgdb_fun(self, func, *args, **kwargs):
86         try:
87             return getattr(getattr(self.pkgdb, self.db_prov), func)(*args, **kwargs)
88         except AttributeError:
89             return self.pkgdb["{}.{}".format(self.db_prov, func)](*args, **kwargs)
90     def _pkgfiles_fun(self, func, *args, **kwargs):
91         try:
92             return getattr(getattr(self.pkgfiles, self.files_prov), func)(
93                 *args, **kwargs
94             )
95         except AttributeError:
96             return self.pkgfiles["{}.{}".format(self.files_prov, func)](*args, **kwargs)
97     def _list(self, args):
98         args.pop(0)
99         command = args[0]
100         if command == "packages":
101             self._list_packages(args)
102         elif command == "files":
103             self._list_files(args)
104         elif command == "repos":
105             self._repo_list(args)
106         else:
107             raise SPMInvocationError("Invalid list command '{}'".format(command))
108     def _local(self, args):
109         args.pop(0)
110         command = args[0]
111         if command == "install":
112             self._local_install(args)
113         elif command == "files":
114             self._local_list_files(args)
115         elif command == "info":
116             self._local_info(args)
117         else:
118             raise SPMInvocationError("Invalid local command '{}'".format(command))
119     def _repo(self, args):
120         <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if command == "list":
121             self._repo_list(args)
122         elif command == "packages":
123             self._repo_packages(args)
124         elif command == "search":
125             self._repo_packages(args, search=True)
126         elif command == "update":
127             self._download_repo_metadata(args)
128         elif command == "create":
129             self._create_repo(</b></font>args)
130         else:
131             raise SPMInvocationError("Invalid repo command '{}'".format(command))
132     def _repo_packages(self, args, search=False):
133         packages = []
134         repo_metadata = self._get_repo_metadata()
135         for repo in repo_metadata:
136             for pkg in repo_metadata[repo]["packages"]:
137                 if args[1] in pkg:
138                     version = repo_metadata[repo]["packages"][pkg]["info"]["version"]
139                     release = repo_metadata[repo]["packages"][pkg]["info"]["release"]
140                     packages.append((pkg, version, release, repo))
141         for pkg in sorted(packages):
142             self.ui.status("{}\t{}-{}\t{}".format(pkg[0], pkg[1], pkg[2], pkg[3]))
143         return packages
144     def _repo_list(self, args):
145         repo_metadata = self._get_repo_metadata()
146         for repo in repo_metadata:
147             self.ui.status(repo)
148     def _install(self, args):
149         if len(args) &lt; 2:
150             raise SPMInvocationError("A package must be specified")
151         caller_opts = self.opts.copy()
152         caller_opts["file_client"] = "local"
153         self.caller = salt.client.Caller(mopts=caller_opts)
154         self.client = salt.client.get_local_client(self.opts["conf_file"])
155         cache = salt.cache.Cache(self.opts)
156         packages = args[1:]
157         file_map = {}
158         optional = []
159         recommended = []
160 <a name="10"></a>        to_install = []
161         for pkg in packages:
162             if pkg.endswith(".spm"):
163 <a name="9"></a>                if self<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._pkgfiles_fun("path_exists", pkg):
164                     comps = pkg.split("-")
165                     comps = os.path.split("-".join(comps[</b></font>:-2]))
166                     pkg_name <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= comps[-1]
167                     formula_tar = tarfile.open(pkg, "r:bz2")
168                     formula_ref = formula_tar.extractfile("{}/FORMULA".format(pkg_name))
169                     formula_def = salt.</b></font>utils.yaml.safe_load(formula_ref)
170                     file_map[pkg_name] = pkg
171 <a name="7"></a>                    to_, op_, re_ = self._check_all_deps(
172                         pkg_name=pkg_name, pkg_file=pkg, formula_def=formula_def
173                     )
174                     to_install<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.extend(to_)
175                     optional.extend(op_)
176                     recommended.extend(re_)
177                     formula_tar.close()
178                 else:
179                     raise SPMInvocationError("Package file {} not found".format(</b></font>pkg))
180             else:
181                 to_, op_, re_ = self._check_all_deps(pkg_name=pkg)
182                 to_install.extend(to_)
183                 optional.extend(op_)
184                 recommended.extend(re_)
185         optional = set(filter(len, optional))
186         if optional:
187             self.ui.status(
188                 "The following dependencies are optional:\n\t{}\n".format(
189                     "\n\t".join(optional)
190                 )
191             )
192         recommended = set(filter(len, recommended))
193         if recommended:
194             self.ui.status(
195                 "The following dependencies are recommended:\n\t{}\n".format(
196                     "\n\t".join(recommended)
197                 )
198             )
199         to_install = set(filter(len, to_install))
200         msg = "Installing packages:\n\t{}\n".format("\n\t".join(to_install))
201         if not self.opts["assume_yes"]:
202             self.ui.confirm(msg)
203         repo_metadata = self._get_repo_metadata()
204         dl_list = {}
205         for package in to_install:
206             if package in file_map:
207                 self._install_indv_pkg(package, file_map[package])
208             else:
209                 for repo in repo_metadata:
210                     repo_info = repo_metadata[repo]
211                     if package in repo_info["packages"]:
212                         dl_package = False
213                         repo_ver = repo_info["packages"][package]["info"]["version"]
214                         repo_rel = repo_info["packages"][package]["info"]["release"]
215                         repo_url = repo_info["info"]["url"]
216                         if package in dl_list:
217                             if repo_ver == dl_list[package]["version"]:
218                                 if repo_rel &gt; dl_list[package]["release"]:
219                                     dl_package = True
220                                 elif repo_rel == dl_list[package]["release"]:
221                                     if dl_list[package]["source"].startswith("file://"):
222                                         if not repo_url.startswith("file://"):
223                                             dl_package = True
224                             elif repo_ver &gt; dl_list[package]["version"]:
225                                 dl_package = True
226                         else:
227                             dl_package = True
228                         if dl_package is True:
229                             cache_path = os.path.join(self.opts["spm_cache_dir"], repo)
230                             dl_url = "{}/{}".format(
231                                 repo_info["info"]["url"],
232                                 repo_info<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["packages"][package]["filename"],
233                             )
234                             out_file = os.path.join(
235                                 cache_path, repo_info["packages"][package]["filename"]
236                             )
237                             dl_list[package] = {
238                                 "version"</b></font>: repo_ver,
239                                 "release": repo_rel,
240                                 "source": dl_url,
241                                 "dest_dir": cache_path,
242                                 "dest_file": out_file,
243                             }
244         for package in dl_list:
245             dl_url = dl_list[package]["source"]
246             cache_path = dl_list[package]["dest_dir"]
247 <a name="5"></a>            out_file = dl_list[package]["dest_file"]
248             <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not os.path.exists(cache_path):
249                 os.makedirs(cache_path)
250             if dl_url.startswith("file://"):
251                 dl_url = dl_url.replace(</b></font>"file://", "")
252                 shutil.copyfile(dl_url, out_file)
253             else:
254                 with salt.utils.files.fopen(out_file, "wb") as outf:
255                     outf.write(
256                         self._query_http(dl_url, repo_info["info"], decode_body=False)
257                     )
258         for package in dl_list:
259             out_file = dl_list[package]["dest_file"]
260             self._install_indv_pkg(package, out_file)
261         return
262     def _local_install(self, args, pkg_name=None):
263         if len(args) &lt; 2:
264             raise SPMInvocationError("A package file must be specified")
265         self._install(args)
266     def _check_all_deps(self, pkg_name=None, pkg_file=None, formula_def=None):
267         if pkg_file and not os.path.exists(pkg_file):
268             raise SPMInvocationError("Package file {} not found".format(pkg_file))
269         self.repo_metadata = self._get_repo_metadata()
270         if not formula_def:
271             for repo in self.repo_metadata:
272                 if not isinstance(self.repo_metadata[repo]["packages"], dict):
273                     continue
274                 if pkg_name in self.repo_metadata[repo]["packages"]:
275                     formula_def = self.repo_metadata[repo]["packages"][pkg_name]["info"]
276         if not formula_def:
277             raise SPMInvocationError("Unable to read formula for {}".format(pkg_name))
278         pkg_info = self._pkgdb_fun("info", pkg_name, self.db_conn)
279         pkgs_to_install = []
280         if pkg_info is None or self.opts["force"]:
281             pkgs_to_install.append(pkg_name)
282         elif pkg_info is not None and not self.opts["force"]:
283             raise SPMPackageError(
284                 "Package {} already installed, not installing again".format(
285                     formula_def["name"]
286                 )
287             )
288         optional_install = []
289         recommended_install = []
290         if (
291             "dependencies" in formula_def
292             or "optional" in formula_def
293             or "recommended" in formula_def
294         ):
295             self.avail_pkgs = {}
296             for repo in self.repo_metadata:
297                 if not isinstance(self.repo_metadata[repo]["packages"], dict):
298                     continue
299                 for pkg in self.repo_metadata[repo]["packages"]:
300                     self.avail_pkgs[pkg] = repo
301             needs, unavail, optional, recommended = self._resolve_deps(formula_def)
302             if len(unavail) &gt; 0:
303                 raise SPMPackageError(
304                     "Cannot install {}, the following dependencies are needed:\n\n{}".format(
305                         formula_def["name"], "\n".join(unavail)
306                     )
307                 )
308             if optional:
309                 optional_install.extend(optional)
310                 for dep_pkg in optional:
311                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
312                     msg = dep_pkg
313                     if isinstance(pkg_info, dict):
314                         msg = "{} [Installed]".format(dep_pkg)
315                     optional_install.append(msg)
316             if recommended:
317                 recommended_install.extend(recommended)
318                 for dep_pkg in recommended:
319                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
320                     msg = dep_pkg
321                     if isinstance(pkg_info, dict):
322                         msg = "{} [Installed]".format(dep_pkg)
323                     recommended_install.append(msg)
324             if needs:
325                 pkgs_to_install.extend(needs)
326                 for dep_pkg in needs:
327                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
328                     msg = dep_pkg
329                     if isinstance(pkg_info, dict):
330                         msg = "{} [Installed]".format(dep_pkg)
331         return pkgs_to_install, optional_install, recommended_install
332     def _install_indv_pkg(self, pkg_name, pkg_file):
333 <a name="4"></a>        """
334         Install one individual package
335         self.ui<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.status("... installing {}".format(pkg_name))
336         formula_tar = tarfile.open(pkg_file, "r:bz2")
337         formula_ref = formula_tar.extractfile("{}/FORMULA".format(pkg_name))
338         formula_def =</b></font> salt.utils.yaml.safe_load(formula_ref)
339         for field in ("version", "release", "summary", "description"):
340             if field not in formula_def:
341                 raise SPMPackageError(
342                     "Invalid package: the {} was not found".format(field)
343                 )
344         pkg_files = formula_tar.getmembers()
345         existing_files = self._pkgfiles_fun(
346             "check_existing", pkg_name, pkg_files, formula_def
347         )
348         if existing_files and not self.opts["force"]:
349             raise SPMPackageError(
350                 "Not installing {} due to existing files:\n\n{}".format(
351                     pkg_name, "\n".join(existing_files)
352                 )
353             )
354         self._pkgdb_fun("register_pkg", pkg_name, formula_def, self.db_conn)
355         if "pre_local_state" in formula_def:
356             high_data = self._render(formula_def["pre_local_state"], formula_def)
357             ret = self.caller.cmd("state.high", data=high_data)
358         if "pre_tgt_state" in formula_def:
359             log.debug("Executing pre_tgt_state script")
360             high_data = self._render(formula_def["pre_tgt_state"]["data"], formula_def)
361             tgt = formula_def["pre_tgt_state"]["tgt"]
362             ret = self.client.run_job(
363                 tgt=formula_def["pre_tgt_state"]["tgt"],
364                 fun="state.high",
365                 tgt_type=formula_def["pre_tgt_state"].get("tgt_type", "glob"),
366                 timout=self.opts["timeout"],
367                 data=high_data,
368             )
369         if salt.utils.platform.is_windows():
370             uname = gname = salt.utils.win_functions.get_current_user()
371             uname_sid = salt.utils.win_functions.get_sid_from_name(uname)
372             uid = self.opts.get("spm_uid", uname_sid)
373             gid = self.opts.get("spm_gid", uname_sid)
374         else:
375             uid = self.opts.get("spm_uid", os.getuid())
376             gid = self.opts.get("spm_gid", os.getgid())
377             uname = pwd.getpwuid(uid)[0]
378             gname = grp.getgrgid(gid)[0]
379         for member in pkg_files:
380             member.uid = uid
381             member.gid = gid
382             member.uname = uname
383             member.gname = gname
384             out_path = self._pkgfiles_fun(
385                 "install_file",
386                 pkg_name,
387                 formula_tar,
388                 member,
389                 formula_def,
390                 self.files_conn,
391             )
392             if out_path is not False:
393                 if member.isdir():
394                     digest = ""
395                 else:
396                     self._verbose(
397                         "Installing file {} to {}".format(member.name, out_path),
398                         log.trace,
399                     )
400                     file_hash = hashlib.sha1()
401                     digest = self._pkgfiles_fun(
402                         "hash_file",
403                         os.path.join(out_path, member.name),
404                         file_hash,
405                         self.files_conn,
406                     )
407                 self._pkgdb_fun(
408                     "register_file", pkg_name, member, out_path, digest, self.db_conn
409                 )
410         if "post_local_state" in formula_def:
411             log.debug("Executing post_local_state script")
412             high_data = self._render(formula_def["post_local_state"], formula_def)
413             self.caller.cmd("state.high", data=high_data)
414         if "post_tgt_state" in formula_def:
415             log.debug("Executing post_tgt_state script")
416             high_data = self._render(formula_def["post_tgt_state"]["data"], formula_def)
417             tgt = formula_def["post_tgt_state"]["tgt"]
418             ret = self.client.run_job(
419                 tgt=formula_def["post_tgt_state"]["tgt"],
420                 fun="state.high",
421                 tgt_type=formula_def["post_tgt_state"].get("tgt_type", "glob"),
422                 timout=self.opts["timeout"],
423                 data=high_data,
424             )
425         formula_tar.close()
426     def _resolve_deps(self, formula_def):
427         pkg_info = self.pkgdb["{}.info".format(self.db_prov)](formula_def["name"])
428         if not isinstance(pkg_info, dict):
429             pkg_info = {}
430         can_has = {}
431         cant_has = []
432         if "dependencies" in formula_def and formula_def["dependencies"] is None:
433             formula_def["dependencies"] = ""
434         for dep in formula_def.get("dependencies", "").split(","):
435             dep = dep.strip()
436             if not dep:
437                 continue
438             if self.pkgdb["{}.info".format(self.db_prov)](dep):
439                 continue
440             if dep in self.avail_pkgs:
441                 can_has[dep] = self.avail_pkgs[dep]
442             else:
443                 cant_has.append(dep)
444         optional = formula_def.get("optional", "").split(",")
445         recommended = formula_def.get("recommended", "").split(",")
446         inspected = []
447         to_inspect = can_has.copy()
448         while len(to_inspect) &gt; 0:
449             dep = next(iter(to_inspect.keys()))
450             del to_inspect[dep]
451             if dep in inspected:
452                 continue
453 <a name="3"></a>            inspected.append(dep)
454             repo_contents = self.repo_metadata.get(can_has[dep], {})
455             repo_packages <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= repo_contents.get("packages", {})
456             dep_formula = repo_packages.get(dep, {}).get("info", {})
457             also_can, also_cant, opt_dep, rec_dep = self._resolve_deps(dep_formula)
458             can_has.update(</b></font>also_can)
459             cant_has = sorted(set(cant_has + also_cant))
460             optional = sorted(set(optional + opt_dep))
461             recommended = sorted(set(recommended + rec_dep))
462         return can_has, cant_has, optional, recommended
463     def _traverse_repos(self, callback, repo_name=None):
464         repo_files = []
465         if os.path.exists(self.opts["spm_repos_config"]):
466             repo_files.append(self.opts["spm_repos_config"])
467         for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(
468             "{}.d".format(self.opts["spm_repos_config"])
469         ):
470             for repo_file in filenames:
471                 if not repo_file.endswith(".repo"):
472                     continue
473                 repo_files.append(repo_file)
474         for repo_file in repo_files:
475             repo_path = "{}.d/{}".format(self.opts["spm_repos_config"], repo_file)
476             with salt.utils.files.fopen(repo_path) as rph:
477                 repo_data = salt.utils.yaml.safe_load(rph)
478                 for repo in repo_data:
479                     if repo_data[repo].get("enabled", True) is False:
480                         continue
481                     if repo_name is not None and repo != repo_name:
482                         continue
483                     callback(repo, repo_data[repo])
484     def _query_http(self, dl_path, repo_info, decode_body=True):
485         query = None
486         response = None
487         try:
488             if "username" in repo_info:
489                 try:
490                     if "password" in repo_info:
491                         query = http.query(
492                             dl_path,
493                             text=True,
494                             username=repo_info["username"],
495                             password=repo_info["password"],
496                             decode_body=decode_body,
497                         )
498                     else:
499                         raise SPMException(
500                             "Auth defined, but password is not set for username: '{}'".format(
501                                 repo_info["username"]
502                             )
503                         )
504                 except SPMException as exc:
505                     self.ui.error(str(exc))
506             else:
507                 query = http.query(dl_path, text=True, decode_body=decode_body)
508         except SPMException as exc:
509             self.ui.error(str(exc))
510         try:
511             if query:
512                 if "SPM-METADATA" in dl_path:
513                     response = salt.utils.yaml.safe_load(query.get("text", "{}"))
514                 else:
515                     response = query.get("text")
516             else:
517                 raise SPMException("Response is empty, please check for Errors above.")
518         except SPMException as exc:
519             self.ui.error(str(exc))
520         return response
521     def _download_repo_metadata(self, args):
522         cache = salt.cache.Cache(self.opts, self.opts["spm_cache_dir"])
523         def _update_metadata(repo, repo_info):
524             dl_path = "{}/SPM-METADATA".format(repo_info["url"])
525             if dl_path.startswith("file://"):
526                 dl_path = dl_path.replace("file://", "")
527                 with salt.utils.files.fopen(dl_path, "r") as rpm:
528                     metadata = salt.utils.yaml.safe_load(rpm)
529             else:
530                 metadata = self._query_http(dl_path, repo_info)
531             cache.store(".", repo, metadata)
532         repo_name = args[1] if len(args) &gt; 1 else None
533         self._traverse_repos(_update_metadata, repo_name)
534     def _get_repo_metadata(self):
535         cache = salt.cache.Cache(self.opts, self.opts["spm_cache_dir"])
536         metadata = {}
537         def _read_metadata(repo, repo_info):
538             if cache.updated(".", repo) is None:
539                 log.warning("Updating repo metadata")
540                 self._download_repo_metadata({})
541             metadata[repo] = {
542                 "info": repo_info,
543                 "packages": cache.fetch(".", repo),
544             }
545         self._traverse_repos(_read_metadata)
546         return metadata
547     def _create_repo(self, args):
548         if len(args) &lt; 2:
549             raise SPMInvocationError("A path to a directory must be specified")
550         if args[1] == ".":
551             repo_path = os.getcwdu()
552         else:
553             repo_path = args[1]
554         old_files = []
555         repo_metadata = {}
556         for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(repo_path):
557             for spm_file in filenames:
558                 if not spm_file.endswith(".spm"):
559                     continue
560                 spm_path = "{}/{}".format(repo_path, spm_file)
561                 if not tarfile.is_tarfile(spm_path):
562 <a name="8"></a>                    continue
563                 comps = spm_file.split("-")
564                 spm_name = "-".join(comps[:-2])
565                 spm_fh = tarfile<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.open(spm_path, "r:bz2")
566                 formula_handle = spm_fh.extractfile("{}/FORMULA".format(spm_name))
567                 formula_conf = salt.utils.yaml.safe_load(</b></font>formula_handle.read())
568                 use_formula = True
569                 if spm_name in repo_metadata:
570                     cur_info = repo_metadata[spm_name]["info"]
571                     new_info = formula_conf
572                     if int(new_info["version"]) == int(cur_info["version"]):
573                         if int(new_info["release"]) &lt; int(cur_info["release"]):
574                             use_formula = False
575                     elif int(new_info["version"]) &lt; int(cur_info["version"]):
576                         use_formula = False
577                     if use_formula is True:
578                         log.debug(
579                             "%s %s-%s had been added, but %s-%s will replace it",
580                             spm_name,
581                             cur_info["version"],
582                             cur_info["release"],
583                             new_info["version"],
584                             new_info["release"],
585                         )
586                         old_files.append(repo_metadata[spm_name]["filename"])
587                     else:
588                         log.debug(
589                             "%s %s-%s has been found, but is older than %s-%s",
590                             spm_name,
591                             new_info["version"],
592                             new_info["release"],
593                             cur_info["version"],
594                             cur_info["release"],
595                         )
596                         old_files.append(spm_file)
597                 if use_formula is True:
598                     log.debug(
599                         "adding %s-%s-%s to the repo",
600                         formula_conf["name"],
601                         formula_conf["version"],
602                         formula_conf["release"],
603                     )
604                     repo_metadata[spm_name] = {
605                         "info": formula_conf.copy(),
606                     }
607                     repo_metadata[spm_name]["filename"] = spm_file
608         metadata_filename = "{}/SPM-METADATA".format(repo_path)
609         with salt.utils.files.fopen(metadata_filename, "w") as mfh:
610             salt.utils.yaml.safe_dump(
611                 repo_metadata,
612                 mfh,
613                 indent=4,
614                 canonical=False,
615                 default_flow_style=False,
616             )
617         log.debug("Wrote %s", metadata_filename)
618         for file_ in old_files:
619             if self.opts["spm_repo_dups"] == "ignore":
620                 log.debug("%s will be left in the directory", file_)
621             elif self.opts["spm_repo_dups"] == "archive":
622                 if not os.path.exists("./archive"):
623                     try:
624                         os.makedirs("./archive")
625                         log.debug("%s has been archived", file_)
626                     except OSError:
627                         log.error("Unable to create archive directory")
628                 try:
629                     shutil.move(file_, "./archive")
630                 except OSError:
631                     log.error("Unable to archive %s", file_)
632             elif self.opts["spm_repo_dups"] == "delete":
633                 try:
634                     os.remove(file_)
635                     log.debug("%s has been deleted", file_)
636                 except OSError:
637                     log.error("Unable to delete %s", file_)
638                 except OSError:  # pylint: disable=duplicate-except
639                     pass
640     def _remove(self, args):
641         if len(args) &lt; 2:
642             raise SPMInvocationError("A package must be specified")
643         packages = args[1:]
644         msg = "Removing packages:\n\t{}".format("\n\t".join(packages))
645         if not self.opts["assume_yes"]:
646             self.ui.confirm(msg)
647         for package in packages:
648             self.ui.status("... removing {}".format(package))
649             if not self._pkgdb_fun("db_exists", self.opts["spm_db"]):
650                 raise SPMDatabaseError(
651                     "No database at {}, cannot remove {}".format(
652                         self.opts["spm_db"], package
653                     )
654                 )
655             pkg_info = self._pkgdb_fun("info", package, self.db_conn)
656             if pkg_info is None:
657                 raise SPMInvocationError("Package {} not installed".format(package))
658             files = self._pkgdb_fun("list_files", package, self.db_conn)
659             dirs = []
660             for filerow in files:
661                 if self._pkgfiles_fun("path_isdir", filerow[0]):
662                     dirs.append(filerow[0])
663                     continue
664                 file_hash = hashlib.sha1()
665                 digest = self._pkgfiles_fun(
666                     "hash_file", filerow[0], file_hash, self.files_conn
667                 )
668                 if filerow[1] == digest:
669                     self._verbose("Removing file {}".format(filerow[0]), log.trace)
670                     self._pkgfiles_fun("remove_file", filerow[0], self.files_conn)
671                 else:
672                     self._verbose("Not removing file {}".format(filerow[0]), log.trace)
673                 self._pkgdb_fun("unregister_file", filerow[0], package, self.db_conn)
674             for dir_ in sorted(dirs, reverse=True):
675                 self._pkgdb_fun("unregister_file", dir_, package, self.db_conn)
676                 try:
677                     self._verbose("Removing directory {}".format(dir_), log.trace)
678                     os.rmdir(dir_)
679                 except OSError:
680                     self._verbose(
681                         "Cannot remove directory {}, probably not empty".format(dir_),
682                         log.trace,
683                     )
684             self._pkgdb_fun("unregister_pkg", package, self.db_conn)
685     def _verbose(self, msg, level=log.debug):
686         if self.opts.get("verbose", False) is True:
687             self.ui.status(msg)
688         level(msg)
689     def _local_info(self, args):
690         if len(args) &lt; 2:
691             raise SPMInvocationError("A package filename must be specified")
692         pkg_file = args[1]
693         if not os.path.exists(pkg_file):
694             raise SPMInvocationError("Package file {} not found".format(pkg_file))
695         comps = pkg_file.split("-")
696         comps = "-".join(comps[:-2]).split("/")
697         name = comps[-1]
698         formula_tar = tarfile.open(pkg_file, "r:bz2")
699         formula_ref = formula_tar.extractfile("{}/FORMULA".format(name))
700         formula_def = salt.utils.yaml.safe_load(formula_ref)
701         self.ui.status(self._get_info(formula_def))
702         formula_tar.close()
703     def _info(self, args):
704         if len(args) &lt; 2:
705             raise SPMInvocationError("A package must be specified")
706         package = args[1]
707         pkg_info = self._pkgdb_fun("info", package, self.db_conn)
708         if pkg_info is None:
709             raise SPMPackageError("package {} not installed".format(package))
710         self.ui.status(self._get_info(pkg_info))
711     def _get_info(self, formula_def):
712         fields = (
713             "name",
714             "os",
715             "os_family",
716             "release",
717             "version",
718             "dependencies",
719             "os_dependencies",
720             "os_family_dependencies",
721             "summary",
722             "description",
723         )
724         for item in fields:
725             if item not in formula_def:
726                 formula_def[item] = "None"
727         if "installed" not in formula_def:
728             formula_def["installed"] = "Not installed"
729         return (
730             "Name: {name}\n"
731             "Version: {version}\n"
732             "Release: {release}\n"
733             "Install Date: {installed}\n"
734             "Supported OSes: {os}\n"
735             "Supported OS families: {os_family}\n"
736             "Dependencies: {dependencies}\n"
737             "OS Dependencies: {os_dependencies}\n"
738             "OS Family Dependencies: {os_family_dependencies}\n"
739             "Summary: {summary}\n"
740             "Description:\n"
741             "{description}".format(**formula_def)
742         )
743     def _local_list_files(self, args):
744         if len(args) &lt; 2:
745             raise SPMInvocationError("A package filename must be specified")
746         pkg_file = args[1]
747         if not os.path.exists(pkg_file):
748             raise SPMPackageError("Package file {} not found".format(pkg_file))
749         formula_tar = tarfile.open(pkg_file, "r:bz2")
750         pkg_files = formula_tar.getmembers()
751         for member in pkg_files:
752             self.ui.status(member.name)
753     def _list_packages(self, args):
754         packages = self._pkgdb_fun("list_packages", self.db_conn)
755         for package in packages:
756             if self.opts["verbose"]:
757                 status_msg = ",".join(package)
758             else:
759                 status_msg = package[0]
760             self.ui.status(status_msg)
761     def _list_files(self, args):
762         if len(args) &lt; 2:
763             raise SPMInvocationError("A package name must be specified")
764         package = args[-1]
765         files = self._pkgdb_fun("list_files", package, self.db_conn)
766         if files is None:
767             raise SPMPackageError("package {} not installed".format(package))
768         else:
769             for file_ in files:
770                 if self.opts["verbose"]:
771                     status_msg = ",".join(file_)
772                 else:
773                     status_msg = file_[0]
774                 self.ui.status(status_msg)
775     def _build(self, args):
776         if len(args) &lt; 2:
777             raise SPMInvocationError("A path to a formula must be specified")
778         self.abspath = args[1].rstrip("/")
779         comps = self.abspath.split("/")
780         self.relpath = comps[-1]
781         formula_path = "{}/FORMULA".format(self.abspath)
782         if not os.path.exists(formula_path):
783             raise SPMPackageError("Formula file {} not found".format(formula_path))
784         with salt.utils.files.fopen(formula_path) as fp_:
785             formula_conf = salt.utils.yaml.safe_load(fp_)
786         for field in ("name", "version", "release", "summary", "description"):
787             if field not in formula_conf:
788                 raise SPMPackageError(
789                     "Invalid package: a {} must be defined".format(field)
790                 )
791         out_path = "{}/{}-{}-{}.spm".format(
792             self.opts["spm_build_dir"],
793             formula_conf["name"],
794             formula_conf["version"],
795             formula_conf["release"],
796         )
797         if not os.path.exists(self.opts["spm_build_dir"]):
798             os.mkdir(self.opts["spm_build_dir"])
799         self.formula_conf = formula_conf
800         formula_tar = tarfile.open(out_path, "w:bz2")
801         if "files" in formula_conf:
802             if isinstance(formula_conf["files"], list):
803                 formula_dir = tarfile.TarInfo(formula_conf["name"])
804                 formula_dir.type = tarfile.DIRTYPE
805                 formula_tar.addfile(formula_dir)
806                 for file_ in formula_conf["files"]:
807                     for ftype in FILE_TYPES:
808                         if file_.startswith("{}|".format(ftype)):
809                             file_ = file_.lstrip("{}|".format(ftype))
810                     formula_tar.add(
811                         os.path.join(os.getcwd(), file_),
812                         os.path.join(formula_conf["name"], file_),
813                     )
814         else:
815             try:
816                 formula_tar.add(
817                     formula_path, formula_conf["name"], filter=self._exclude
818                 )
819                 formula_tar.add(
820                     self.abspath, formula_conf["name"], filter=self._exclude
821                 )
822             except TypeError:
823                 formula_tar.add(
824                     formula_path, formula_conf["name"], exclude=self._exclude
825                 )
826                 formula_tar.add(
827                     self.abspath, formula_conf["name"], exclude=self._exclude
828                 )
829         formula_tar.close()
830         self.ui.status("Built package {}".format(out_path))
831     def _exclude(self, member):
832         if isinstance(member, str):
833             return None
834         for item in self.opts["spm_build_exclude"]:
835             if member.name.startswith("{}/{}".format(self.formula_conf["name"], item)):
836                 return None
837             elif member.name.startswith("{}/{}".format(self.abspath, item)):
838                 return None
839         return member
840     def _render(self, data, formula_def):
841         renderer = formula_def.get("renderer", self.opts.get("renderer", "jinja|yaml"))
842         rend = salt.loader.render(self.opts, {})
843         blacklist = self.opts.get("renderer_blacklist")
844         whitelist = self.opts.get("renderer_whitelist")
845         template_vars = formula_def.copy()
846         template_vars["opts"] = self.opts.copy()
847         return compile_template(
848             ":string:",
849             rend,
850             renderer,
851             blacklist,
852             whitelist,
853             input_data=data,
854             **template_vars
855         )
856 class SPMUserInterface:
857     def status(self, msg):
858         raise NotImplementedError()
859     def error(self, msg):
860         raise NotImplementedError()
861     def confirm(self, action):
862         raise NotImplementedError()
863 class SPMCmdlineInterface(SPMUserInterface):
864     def status(self, msg):
865         print(msg)
866     def error(self, msg):
867         print(msg, file=sys.stderr)
868     def confirm(self, action):
869         print(action)
870         res = input("Proceed? [N/y] ")
871         if not res.lower().startswith("y"):
872             raise SPMOperationCanceled("canceled")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import collections
3 import copy
4 import datetime
5 import logging
6 import os
7 <a name="1"></a>import re
8 import shutil
9 import string  # pylint: disable=deprecated-module
10 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import subprocess
11 import sys
12 import time
13 import urllib.parse
14 from xml.etree import ElementTree
15 from xml.sax import saxutils
16 import jinja2.exceptions
17 import salt.utils.data
18 import salt.utils.files
19 import salt.utils.json
20 import salt.utils.path
21 import salt.utils.stringutils
22 import salt.utils.templates
23 import salt.utils.virt
24 import salt.utils.xmlutil as xmlutil
25 import salt.utils.yaml
26 from salt._compat import ipaddress
27 from salt.exceptions import CommandExecutionError, SaltInvocationError
28 try:
29     import libvirt  # pylint: disable=import-error
30     from</b></font> libvirt import libvirtError
31     HAS_LIBVIRT = True
32 except ImportError:
33     HAS_LIBVIRT = False
34 log = logging.getLogger(__name__)
35 JINJA = jinja2.Environment(
36     loader=jinja2.FileSystemLoader(
37         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "virt")
38     )
39 )
40 CACHE_DIR = "/var/lib/libvirt/saltinst"
41 VIRT_STATE_NAME_MAP = {
42     0: "running",
43     1: "running",
44     2: "running",
45     3: "paused",
46     4: "shutdown",
47     5: "shutdown",
48     6: "crashed",
49 }
50 def __virtual__():
51     if not HAS_LIBVIRT:
52         return (False, "Unable to locate or import python libvirt library.")
53     return "virt"
54 def __get_request_auth(username, password):
55     def __request_auth(credentials, user_data):
56         for credential in credentials:
57             if credential<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0] == libvirt.VIR_CRED_AUTHNAME:
58                 credential[4] = (
59                     username
60                     if username
61                     else __salt__["config.get"](
62                         "virt:connection:auth:username", credential[3]
63                     )
64                 )
65             elif credential[0] == libvirt.VIR_CRED_NOECHOPROMPT:
66                 credential[4] = (
67                     password</b></font>
68                     if password
69                     else __salt__["config.get"](
70                         "virt:connection:auth:password", credential[3]
71                     )
72                 )
73             else:
74                 log.info("Unhandled credential type: %s", credential[0])
75         return 0
76 def __get_conn(**kwargs):
77     username = kwargs.get("username", None)
78     password = kwargs.get("password", None)
79     conn_str = kwargs.get("connection", None)
80     if not conn_str:
81         conn_str = __salt__["config.get"]("virt:connection:uri", conn_str)
82     try:
83         auth_types = [
84             libvirt.VIR_CRED_AUTHNAME,
85             libvirt.VIR_CRED_NOECHOPROMPT,
86             libvirt.VIR_CRED_ECHOPROMPT,
87             libvirt.VIR_CRED_PASSPHRASE,
88             libvirt.VIR_CRED_EXTERNAL,
89         ]
90         conn = libvirt.openAuth(
91             conn_str, [auth_types, __get_request_auth(username, password), None], 0
92         )
93     except Exception:  # pylint: disable=broad-except
94         raise CommandExecutionError(
95             "Sorry, {} failed to open a connection to the hypervisor "
96             "software at {}".format(__grains__["fqdn"], conn_str)
97         )
98     return conn
99 def _get_domain(conn, *vms, **kwargs):
100     ret = list()
101     lookup_vms = list()
102     all_vms = []
103     if kwargs.get("active", True):
104         for id_ in conn.listDomainsID():
105             all_vms.append(conn.lookupByID(id_).name())
106     if kwargs.get("inactive", True):
107         for id_ in conn.listDefinedDomains():
108             all_vms.append(id_)
109     if vms and not all_vms:
110         raise CommandExecutionError("No virtual machines found.")
111     if vms:
112         for name in vms:
113             if name not in all_vms:
114                 raise CommandExecutionError(
115                     'The VM "{name}" is not present'.format(name=name)
116                 )
117             else:
118                 lookup_vms.append(name)
119     else:
120         lookup_vms = list(all_vms)
121     for name in lookup_vms:
122         ret.append(conn.lookupByName(name))
123     return len(ret) == 1 and not kwargs.get("iterable") and ret[0] or ret
124 def _parse_qemu_img_info(info):
125     raw_infos = salt.utils.json.loads(info)
126     disks = []
127     for disk_infos in raw_infos:
128         disk = {
129             "file": disk_infos["filename"],
130             "file format": disk_infos["format"],
131             "disk size": disk_infos["actual-size"],
132             "virtual size": disk_infos["virtual-size"],
133             "cluster size": disk_infos["cluster-size"]
134             if "cluster-size" in disk_infos
135             else None,
136         }
137         if "full-backing-filename" in disk_infos.keys():
138             disk["backing file"] = format(disk_infos["full-backing-filename"])
139         if "snapshots" in disk_infos.keys():
140             disk["snapshots"] = [
141                 {
142                     "id": snapshot["id"],
143                     "tag": snapshot["name"],
144                     "vmsize": snapshot["vm-state-size"],
145                     "date": datetime.datetime.fromtimestamp(
146                         float(
147                             "{}.{}".format(snapshot["date-sec"], snapshot["date-nsec"])
148                         )
149                     ).isoformat(),
150                     "vmclock": datetime.datetime.utcfromtimestamp(
151                         float(
152                             "{}.{}".format(
153                                 snapshot["vm-clock-sec"], snapshot["vm-clock-nsec"]
154                             )
155                         )
156                     )
157                     .time()
158                     .isoformat(),
159                 }
160                 for snapshot in disk_infos["snapshots"]
161             ]
162         disks.append(disk)
163     for disk in disks:
164         if "backing file" in disk.keys():
165             candidates = [
166                 info
167                 for info in disks
168                 if "file" in info.keys() and info["file"] == disk["backing file"]
169             ]
170             if candidates:
171                 disk["backing file"] = candidates[0]
172     return disks[0]
173 def _get_uuid(dom):
174     return ElementTree.fromstring(get_xml(dom)).find("uuid").text
175 def _get_on_poweroff(dom):
176     node = ElementTree.fromstring(get_xml(dom)).find("on_poweroff")
177     return node.text if node is not None else ""
178 def _get_on_reboot(dom):
179     node = ElementTree.fromstring(get_xml(dom)).find("on_reboot")
180     return node.text if node is not None else ""
181 def _get_on_crash(dom):
182     node = ElementTree.fromstring(get_xml(dom)).find("on_crash")
183     return node.text if node is not None else ""
184 def _get_nics(dom):
185     nics = {}
186     doc = ElementTree.fromstring(dom.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
187     for iface_node in doc.findall("devices/interface"):
188 <a name="2"></a>        nic = {}
189         nic["type"] = iface_node.get("type")
190         for v_node in iface_node:
191             <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if v_node.tag == "mac":
192                 nic["mac"] = v_node.get("address")
193             if v_node.tag == "model":
194                 nic["model"] = v_node.get(</b></font>"type")
195             if v_node.tag == "target":
196                 nic["target"] = v_node.get("dev")
197             if re.match("(driver|source|address)", v_node.tag):
198                 temp = {}
199                 for key, value in v_node.attrib.items():
200                     temp[key] = value
201                 nic[v_node.tag] = temp
202             if v_node.tag == "virtualport":
203                 temp = {}
204                 temp["type"] = v_node.get("type")
205                 for key, value in v_node.attrib.items():
206                     temp[key] = value
207                 nic["virtualport"] = temp
208         if "mac" not in nic:
209             continue
210         nics[nic["mac"]] = nic
211     return nics
212 def _get_graphics(dom):
213     out = {
214         "autoport": "None",
215         "keymap": "None",
216         "listen": "None",
217         "port": "None",
218         "type": "None",
219     }
220     doc = ElementTree.fromstring(dom.XMLDesc(0))
221     for g_node in doc.findall("devices/graphics"):
222         for key, value in g_node.attrib.items():
223             out[key] = value
224     return out
225 def _get_loader(dom):
226     out = {"path": "None"}
227     doc = ElementTree.fromstring(dom.XMLDesc(0))
228     for g_node in doc.findall("os/loader"):
229         out["path"] = g_node.text
230         for key, value in g_node.attrib.items():
231             out[key] = value
232     return out
233 def _get_disks(conn, dom):
234     disks = {}
235     doc = ElementTree.fromstring(dom.XMLDesc(0))
236     all_volumes = _get_all_volumes_paths(conn)
237     for elem in doc.findall("devices/disk"):
238         source = elem.find("source")
239         if source is None:
240             continue
241         target = elem.find("target")
242         driver = elem.find("driver")
243         if target is None:
244             continue
245         qemu_target = None
246         extra_properties = None
247         if "dev" in target.attrib:
248             disk_type = elem.get("type")
249             def _get_disk_volume_data(pool_name, volume_name):
250                 qemu_target = "{}/{}".format(pool_name, volume_name)
251                 pool = conn.storagePoolLookupByName(pool_name)
252                 extra_properties = {}
253                 try:
254                     vol = pool.storageVolLookupByName(volume_name)
255                     vol_info = vol.info()
256                     extra_properties = {
257                         "virtual size": vol_info[1],
258                         "disk size": vol_info[2],
259                     }
260                     backing_files = [
261                         {
262                             "file": node.find("source").get("file"),
263                             "file format": node.find("format").get("type"),
264                         }
265                         for node in elem.findall(".//backingStore[source]")
266                     ]
267                     if backing_files:
268                         extra_properties["backing file"] = backing_files[0]
269                         parent = extra_properties["backing file"]
270                         for sub_backing_file in backing_files[1:]:
271                             parent["backing file"] = sub_backing_file
272                             parent = sub_backing_file
273                     else:
274                         vol_desc = ElementTree.fromstring(vol.XMLDesc())
275                         backing_path = vol_desc.find("./backingStore/path")
276                         backing_format = vol_desc.find("./backingStore/format")
277                         if backing_path is not None:
278                             extra_properties["backing file"] = {
279                                 "file": backing_path.text
280                             }
281                             if backing_format is not None:
282                                 extra_properties["backing file"][
283                                     "file format"
284                                 ] = backing_format.get("type")
285                 except libvirt.libvirtError:
286                     log.info(
287                         "Couldn't extract all volume informations: pool is likely not"
288                         " running or refreshed"
289                     )
290                 return (qemu_target, extra_properties)
291             if disk_type == "file":
292                 qemu_target = source.get("file", "")
293                 if qemu_target.startswith("/dev/zvol/"):
294                     disks[target.get("dev")] = {"file": qemu_target, "zfs": True}
295                     continue
296                 if qemu_target in all_volumes.keys():
297                     volume = all_volumes[qemu_target]
298                     qemu_target, extra_properties = _get_disk_volume_data(
299                         volume["pool"], volume["name"]
300                     )
301                 elif elem.get("device", "disk") != "cdrom":
302                     try:
303                         process = subprocess.Popen(
304                             [
305                                 "qemu-img",
306                                 "info",
307                                 "-U",
308                                 "--output",
309                                 "json",
310                                 "--backing-chain",
311                                 qemu_target,
312                             ],
313                             shell=False,
314                             stdout=subprocess.PIPE,
315                             stderr=subprocess.PIPE,
316                         )
317                         stdout, stderr = process.communicate()
318                         if process.returncode == 0:
319                             qemu_output = salt.utils.stringutils.to_str(stdout)
320                             output = _parse_qemu_img_info(qemu_output)
321                             extra_properties = output
322                         else:
323                             extra_properties = {"error": stderr}
324                     except FileNotFoundError:
325                         extra_properties = {"error": "qemu-img not found"}
326             elif disk_type == "block":
327                 qemu_target = source.get("dev", "")
328                 if qemu_target in all_volumes.keys():
329                     volume = all_volumes[qemu_target]
330                     qemu_target, extra_properties = _get_disk_volume_data(
331                         volume["pool"], volume["name"]
332                     )
333             elif disk_type == "network":
334                 qemu_target = source.get("protocol")
335                 source_name = source.get("name")
336                 if source_name:
337                     qemu_target = "{}:{}".format(qemu_target, source_name)
338                 if source.get("protocol") in ["rbd", "gluster"]:
339                     for pool_i in conn.listAllStoragePools():
340                         pool_i_xml = ElementTree.fromstring(pool_i.XMLDesc())
341                         name_node = pool_i_xml.find("source/name")
342                         if name_node is not None and source_name.startswith(
343                             "{}/".format(name_node.text)
344                         ):
345                             qemu_target = "{}{}".format(
346                                 pool_i.name(), source_name[len(name_node.text) :]
347                             )
348                             break
349                 if elem.get("device", "disk") == "cdrom":
350                     host_node = source.find("host")
351                     if host_node is not None:
352                         hostname = host_node.get("name")
353                         port = host_node.get("port")
354                         qemu_target = urllib.parse.urlunparse(
355                             (
356                                 source.get("protocol"),
357                                 "{}:{}".format(hostname, port) if port else hostname,
358                                 source_name,
359                                 "",
360                                 saxutils.unescape(source.get("query", "")),
361                                 "",
362                             )
363                         )
364             elif disk_type == "volume":
365                 pool_name = source.get("pool")
366                 volume_name = source.get("volume")
367                 qemu_target, extra_properties = _get_disk_volume_data(
368                     pool_name, volume_name
369                 )
370             if not qemu_target:
371                 continue
372             disk = {
373                 "file": qemu_target,
374                 "type": elem.get("device"),
375             }
376             if driver is not None and "type" in driver.attrib:
377                 disk["file format"] = driver.get("type")
378             if extra_properties:
379                 disk.update(extra_properties)
380             disks[target.get("dev")] = disk
381     return disks
382 def _libvirt_creds():
383     g_cmd = ["grep", "^\\s*group", "/etc/libvirt/qemu.conf"]
384     u_cmd = ["grep", "^\\s*user", "/etc/libvirt/qemu.conf"]
385     try:
386         stdout = subprocess.Popen(g_cmd, stdout=subprocess.PIPE).communicate()[0]
387         group = salt.utils.stringutils.to_str(stdout).split('"')[1]
388     except IndexError:
389         group = "root"
390     try:
391         stdout = subprocess.Popen(u_cmd, stdout=subprocess.PIPE).communicate()[0]
392         user = salt.utils.stringutils.to_str(stdout).split('"')[1]
393     except IndexError:
394         user = "root"
395     return {"user": user, "group": group}
396 def _migrate(dom, dst_uri, **kwargs):
397     flags = 0
398     params = {}
399     migrated_state = libvirt.VIR_DOMAIN_RUNNING_MIGRATED
400     if kwargs.get("live", True):
401         flags |= libvirt.VIR_MIGRATE_LIVE
402     if kwargs.get("persistent", True):
403         flags |= libvirt.VIR_MIGRATE_PERSIST_DEST
404     if kwargs.get("undefinesource", True):
405         flags |= libvirt.VIR_MIGRATE_UNDEFINE_SOURCE
406     max_bandwidth = kwargs.get("max_bandwidth")
407     if max_bandwidth:
408         try:
409             bandwidth_value = int(max_bandwidth)
410         except ValueError:
411             raise SaltInvocationError(
412                 "Invalid max_bandwidth value: {}".format(max_bandwidth)
413             )
414         dom.migrateSetMaxSpeed(bandwidth_value)
415     max_downtime = kwargs.get("max_downtime")
416     if max_downtime:
417         try:
418             downtime_value = int(max_downtime)
419         except ValueError:
420             raise SaltInvocationError(
421                 "Invalid max_downtime value: {}".format(max_downtime)
422             )
423         dom.migrateSetMaxDowntime(downtime_value)
424     if kwargs.get("offline") is True:
425         flags |= libvirt.VIR_MIGRATE_OFFLINE
426         migrated_state = libvirt.VIR_DOMAIN_RUNNING_UNPAUSED
427     if kwargs.get("compressed") is True:
428         flags |= libvirt.VIR_MIGRATE_COMPRESSED
429     comp_methods = kwargs.get("comp_methods")
430     if comp_methods:
431         params[libvirt.VIR_MIGRATE_PARAM_COMPRESSION] = comp_methods.split(",")
432     comp_options = {
433         "comp_mt_level": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL,
434         "comp_mt_threads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS,
435         "comp_mt_dthreads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS,
436         "comp_xbzrle_cache": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE,
437     }
438     for (comp_option, param_key) in comp_options.items():
439         comp_option_value = kwargs.get(comp_option)
440         if comp_option_value:
441             try:
442                 params[param_key] = int(comp_option_value)
443             except ValueError:
444                 raise SaltInvocationError("Invalid {} value".format(comp_option))
445     parallel_connections = kwargs.get("parallel_connections")
446     if parallel_connections:
447         try:
448             params[libvirt.VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS] = int(
449                 parallel_connections
450             )
451         except ValueError:
452             raise SaltInvocationError("Invalid parallel_connections value")
453         flags |= libvirt.VIR_MIGRATE_PARALLEL
454     if __salt__["config.get"]("virt:tunnel"):
455         if parallel_connections:
456             raise SaltInvocationError(
457                 "Parallel migration isn't compatible with tunneled migration"
458             )
459         flags |= libvirt.VIR_MIGRATE_PEER2PEER
460         flags |= libvirt.VIR_MIGRATE_TUNNELLED
461     if kwargs.get("postcopy") is True:
462         flags |= libvirt.VIR_MIGRATE_POSTCOPY
463     postcopy_bandwidth = kwargs.get("postcopy_bandwidth")
464     if postcopy_bandwidth:
465         try:
466             postcopy_bandwidth_value = int(postcopy_bandwidth)
467         except ValueError:
468             raise SaltInvocationError("Invalid postcopy_bandwidth value")
469         dom.migrateSetMaxSpeed(
470             postcopy_bandwidth_value,
471             flags=libvirt.VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY,
472         )
473     copy_storage = kwargs.get("copy_storage")
474     if copy_storage:
475         if copy_storage == "all":
476             flags |= libvirt.VIR_MIGRATE_NON_SHARED_DISK
477         elif copy_storage in ["inc", "incremental"]:
478             flags |= libvirt.VIR_MIGRATE_NON_SHARED_INC
479         else:
480             raise SaltInvocationError("invalid copy_storage value")
481     try:
482         state = False
483         dst_conn = __get_conn(
484             connection=dst_uri,
485             username=kwargs.get("username"),
486             password=kwargs.get("password"),
487         )
488         new_dom = dom.migrate3(dconn=dst_conn, params=params, flags=flags)
489         if new_dom:
490             state = new_dom.state()
491         dst_conn.close()
492         return state and migrated_state in state
493     except libvirt.libvirtError as err:
494         dst_conn.close()
495         raise CommandExecutionError(err.get_error_message())
496 def _get_volume_path(pool, volume_name):
497     if volume_name in pool.listVolumes():
498         volume = pool.storageVolLookupByName(volume_name)
499         volume_xml = ElementTree.fromstring(volume.XMLDesc())
500         return volume_xml.find("./target/path").text
501     pool_xml = ElementTree.fromstring(pool.XMLDesc())
502     pool_path = pool_xml.find("./target/path").text
503     return pool_path + "/" + volume_name
504 def _disk_from_pool(conn, pool, pool_xml, volume_name):
505     pool_type = pool_xml.get("type")
506     disk_context = {}
507     if pool_type in ["dir", "netfs", "fs"]:
508         disk_context["type"] = "file"
509         disk_context["source_file"] = _get_volume_path(pool, volume_name)
510     elif pool_type in ["logical", "disk", "iscsi", "scsi"]:
511         disk_context["type"] = "block"
512         disk_context["format"] = "raw"
513         disk_context["source_file"] = _get_volume_path(pool, volume_name)
514     elif pool_type in ["rbd", "gluster", "sheepdog"]:
515         disk_context["type"] = "network"
516         disk_context["protocol"] = pool_type
517         disk_context["hosts"] = [
518             {"name": host.get("name"), "port": host.get("port")}
519             for host in pool_xml.findall(".//host")
520         ]
521         dir_node = pool_xml.find("./source/dir")
522         name_node = pool_xml.find("./source/name")
523         if name_node is not None:
524             disk_context["volume"] = "{}/{}".format(name_node.text, volume_name)
525         auth_node = pool_xml.find("./source/auth")
526         if auth_node is not None:
527             username = auth_node.get("username")
528             secret_node = auth_node.find("./secret")
529             usage = secret_node.get("usage")
530             if not usage:
531                 uuid = secret_node.get("uuid")
532                 usage = conn.secretLookupByUUIDString(uuid).usageID()
533             disk_context["auth"] = {
534                 "type": "ceph",
535                 "username": username,
536                 "usage": usage,
537             }
538     return disk_context
539 def _handle_unit(s, def_unit="m"):
540     m = re.match(r"(?P&lt;value&gt;[0-9.]*)\s*(?P&lt;unit&gt;.*)$", str(s).strip())
541     value = m.group("value")
542     unit = m.group("unit").lower() or def_unit
543     try:
544         value = int(value)
545     except ValueError:
546         try:
547             value = float(value)
548         except ValueError:
549             raise SaltInvocationError("invalid number")
550     dec = False
551     if re.match(r"[kmgtpezy]b$", unit):
552         dec = True
553     elif not re.match(r"(b|[kmgtpezy](ib)?)$", unit):
554         raise SaltInvocationError("invalid units")
555     p = "bkmgtpezy".index(unit[0])
556     value *= 10 ** (p * 3) if dec else 2 ** (p * 10)
557     return int(value)
558 def nesthash(value=None):
559     return collections.defaultdict(nesthash, value or {})
560 def _gen_xml(
561     conn,
562     name,
563     cpu,
564     mem,
565     diskp,
566     nicp,
567     hypervisor,
568     os_type,
569     arch,
570     graphics=None,
571     boot=None,
572     boot_dev=None,
573     numatune=None,
574     hypervisor_features=None,
575     clock=None,
576     serials=None,
577     consoles=None,
578     stop_on_reboot=False,
579     host_devices=None,
580     **kwargs
581 ):
582     context = {
583         "hypervisor": hypervisor,
584         "name": name,
585         "hypervisor_features": hypervisor_features or {},
586         "clock": clock or {},
587         "on_reboot": "destroy" if stop_on_reboot else "restart",
588     }
589     context["to_kib"] = lambda v: int(_handle_unit(v) / 1024)
590     context["yesno"] = lambda v: "yes" if v else "no"
591     context["mem"] = nesthash()
592     if isinstance(mem, int):
593         context["mem"]["boot"] = mem
594         context["mem"]["current"] = mem
595     elif isinstance(mem, dict):
596         context["mem"] = nesthash(mem)
597     context["cpu"] = nesthash()
598     context["cputune"] = nesthash()
599     if isinstance(cpu, int):
600         context["cpu"]["maximum"] = str(cpu)
601     elif isinstance(cpu, dict):
602         context["cpu"] = nesthash(cpu)
603     if clock:
604         offset = "utc" if clock.get("utc", True) else "localtime"
605         if "timezone" in clock:
606             offset = "timezone"
607         context["clock"]["offset"] = offset
608     if hypervisor in ["qemu", "kvm"]:
609         context["numatune"] = numatune if numatune else {}
610         context["controller_model"] = False
611     elif hypervisor == "vmware":
612         context["controller_model"] = "lsilogic"
613     if graphics:
614         if "listen" not in graphics:
615             graphics["listen"] = {"type": "address", "address": "0.0.0.0"}
616         elif (
617             "address" not in graphics["listen"]
618             and graphics["listen"]["type"] == "address"
619         ):
620             graphics["listen"]["address"] = "0.0.0.0"
621         if graphics.get("type", "none") == "none":
622             graphics = None
623     context["graphics"] = graphics
624     context["boot_dev"] = boot_dev.split() if boot_dev is not None else ["hd"]
625     context["boot"] = boot if boot else {}
626     efi_value = context["boot"].get("efi", None) if boot else None
627     if efi_value is True:
628         context["boot"]["os_attrib"] = "firmware='efi'"
629     elif efi_value is not None and type(efi_value) != bool:
630         raise SaltInvocationError("Invalid efi value")
631     if os_type == "xen":
632         if __grains__["os_family"] == "Suse":
633             if not boot or not boot.get("kernel", None):
634                 paths = [
635                     path
636                     for path in ["/usr/share", "/usr/lib"]
637                     if os.path.exists(path + "/grub2/x86_64-xen/grub.xen")
638                 ]
639                 if not paths:
640                     raise CommandExecutionError("grub-x86_64-xen needs to be installed")
641                 context["boot"]["kernel"] = paths[0] + "/grub2/x86_64-xen/grub.xen"
642                 context["boot_dev"] = []
643     default_port = 23023
644     default_chardev_type = "tcp"
645     chardev_types = ["serial", "console"]
646     for chardev_type in chardev_types:
647         context[chardev_type + "s"] = []
648         parameter_value = locals()[chardev_type + "s"]
649         if parameter_value is not None:
650             for chardev in parameter_value:
651                 chardev_context = chardev
652                 chardev_context["type"] = chardev.get("type", default_chardev_type)
653                 if chardev_context["type"] == "tcp":
654                     chardev_context["port"] = chardev.get("port", default_port)
655                     chardev_context["protocol"] = chardev.get("protocol", "telnet")
656                 context[chardev_type + "s"].append(chardev_context)
657     context["disks"] = []
658     disk_bus_map = {"virtio": "vd", "xen": "xvd", "fdc": "fd", "ide": "hd"}
659     targets = []
660     for i, disk in enumerate(diskp):
661         prefix = disk_bus_map.get(disk["model"], "sd")
662         disk_context = {
663             "device": disk.get("device", "disk"),
664             "target_dev": _get_disk_target(targets, len(diskp), prefix),
665             "disk_bus": disk["model"],
666             "format": disk.get("format", "raw"),
667             "index": str(i),
668             "io": disk.get("io", "native"),
669             "iothread": disk.get("iothread_id", None),
670         }
671         targets.append(disk_context["target_dev"])
672         if disk.get("source_file"):
673             url = urllib.parse.urlparse(disk["source_file"])
674             if not url.scheme or not url.hostname:
675                 disk_context["source_file"] = disk["source_file"]
676                 disk_context["type"] = "file"
677             elif url.scheme in ["http", "https", "ftp", "ftps", "tftp"]:
678                 disk_context["type"] = "network"
679                 disk_context["protocol"] = url.scheme
680                 disk_context["volume"] = url.path
681                 disk_context["query"] = saxutils.escape(url.query)
682                 disk_context["hosts"] = [{"name": url.hostname, "port": url.port}]
683         elif disk.get("pool"):
684             disk_context["volume"] = disk["filename"]
685             pool = conn.storagePoolLookupByName(disk["pool"])
686             pool_xml = ElementTree.fromstring(pool.XMLDesc())
687             pool_type = pool_xml.get("type")
688             if hypervisor == "xen" or pool_type in ["rbd", "gluster", "sheepdog"]:
689                 disk_context.update(
690                     _disk_from_pool(conn, pool, pool_xml, disk_context["volume"])
691                 )
692             else:
693                 if pool_type in ["disk", "logical"]:
694                     disk_context["format"] = "raw"
695                 disk_context["type"] = "volume"
696                 disk_context["pool"] = disk["pool"]
697         else:
698             disk_context["type"] = "file"
699         if hypervisor in ["qemu", "kvm", "bhyve", "xen"]:
700             disk_context["address"] = False
701             disk_context["driver"] = True
702         elif hypervisor in ["esxi", "vmware"]:
703             disk_context["address"] = True
704             disk_context["driver"] = False
705         context["disks"].append(disk_context)
706     context["nics"] = nicp
707     hostdev_context = []
708     try:
709         for hostdev_name in host_devices or []:
710             hostdevice = conn.nodeDeviceLookupByName(hostdev_name)
711             doc = ElementTree.fromstring(hostdevice.XMLDesc())
712             if "pci" in hostdevice.listCaps():
713                 hostdev_context.append(
714                     {
715                         "type": "pci",
716                         "domain": "0x{:04x}".format(
717                             int(doc.find("./capability[@type='pci']/domain").text)
718                         ),
719                         "bus": "0x{:02x}".format(
720                             int(doc.find("./capability[@type='pci']/bus").text)
721                         ),
722                         "slot": "0x{:02x}".format(
723                             int(doc.find("./capability[@type='pci']/slot").text)
724                         ),
725                         "function": "0x{}".format(
726                             doc.find("./capability[@type='pci']/function").text
727                         ),
728                     }
729                 )
730             elif "usb_device" in hostdevice.listCaps():
731                 vendor_id = doc.find(".//vendor").get("id")
732                 product_id = doc.find(".//product").get("id")
733                 hostdev_context.append(
734                     {"type": "usb", "vendor": vendor_id, "product": product_id}
735                 )
736     except libvirt.libvirtError as err:
737         conn.close()
738         raise CommandExecutionError(
739             "Failed to get host devices: " + err.get_error_message()
740         )
741     context["hostdevs"] = hostdev_context
742     context["os_type"] = os_type
743     context["arch"] = arch
744     fn_ = "libvirt_domain.jinja"
745     try:
746         template = JINJA.get_template(fn_)
747     except jinja2.exceptions.TemplateNotFound:
748         log.error("Could not load template %s", fn_)
749         return ""
750     return template.render(**context)
751 def _gen_vol_xml(
752     name,
753     size,
754     format=None,
755     allocation=0,
756     type=None,
757     permissions=None,
758     backing_store=None,
759     nocow=False,
760 ):
761     size = int(size) * 1024  # MB
762     context = {
763         "type": type,
764         "name": name,
765         "target": {"permissions": permissions, "nocow": nocow},
766         "format": format,
767         "size": str(size),
768         "allocation": str(int(allocation) * 1024),
769         "backingStore": backing_store,
770     }
771     fn_ = "libvirt_volume.jinja"
772     try:
773         template = JINJA.get_template(fn_)
774     except jinja2.exceptions.TemplateNotFound:
775         log.error("Could not load template %s", fn_)
776         return ""
777     return template.render(**context)
778 def _gen_net_xml(
779     name,
780     bridge,
781     forward,
782     vport,
783     tag=None,
784     ip_configs=None,
785     mtu=None,
786     domain=None,
787     nat=None,
788     interfaces=None,
789     addresses=None,
790     physical_function=None,
791     dns=None,
792 ):
793     if isinstance(vport, str):
794         vport_context = {"type": vport}
795     else:
796         vport_context = vport
797     if isinstance(tag, (str, int)):
798         tag_context = {"tags": [{"id": tag}]}
799     else:
800         tag_context = tag
801     addresses_context = []
802     if addresses:
803         matches = [
804             re.fullmatch(r"([0-9]+):([0-9A-Fa-f]+):([0-9A-Fa-f]+)\.([0-9])", addr)
805             for addr in addresses.lower().split(" ")
806         ]
807         addresses_context = [
808             {
809                 "domain": m.group(1),
810                 "bus": m.group(2),
811                 "slot": m.group(3),
812                 "function": m.group(4),
813             }
814             for m in matches
815             if m
816         ]
817     context = {
818         "name": name,
819         "bridge": bridge,
820         "mtu": mtu,
821         "domain": domain,
822         "forward": forward,
823         "nat": nat,
824         "interfaces": interfaces.split(" ") if interfaces else [],
825         "addresses": addresses_context,
826         "pf": physical_function,
827         "vport": vport_context,
828         "vlan": tag_context,
829         "dns": dns,
830         "ip_configs": [
831             {
832                 "address": ipaddress.ip_network(config["cidr"]),
833                 "dhcp_ranges": config.get("dhcp_ranges", []),
834                 "hosts": config.get("hosts", {}),
835                 "bootp": config.get("bootp", {}),
836                 "tftp": config.get("tftp"),
837             }
838             for config in ip_configs or []
839         ],
840         "yesno": lambda v: "yes" if v else "no",
841     }
842     fn_ = "libvirt_network.jinja"
843     try:
844         template = JINJA.get_template(fn_)
845     except jinja2.exceptions.TemplateNotFound:
846         log.error("Could not load template %s", fn_)
847         return ""
848     return template.render(**context)
849 def _gen_pool_xml(
850     name,
851     ptype,
852     target=None,
853     permissions=None,
854     source_devices=None,
855     source_dir=None,
856     source_adapter=None,
857     source_hosts=None,
858     source_auth=None,
859     source_name=None,
860     source_format=None,
861     source_initiator=None,
862 ):
863     hosts = [host.split(":") for host in source_hosts or []]
864     source = None
865     if any(
866         [
867             source_devices,
868             source_dir,
869             source_adapter,
870             hosts,
871             source_auth,
872             source_name,
873             source_format,
874             source_initiator,
875         ]
876     ):
877         source = {
878             "devices": source_devices or [],
879             "dir": source_dir
880             if source_format != "cifs" or not source_dir
881             else source_dir.lstrip("/"),
882             "adapter": source_adapter,
883             "hosts": [
884                 {"name": host[0], "port": host[1] if len(host) &gt; 1 else None}
885                 for host in hosts
886             ],
887             "auth": source_auth,
888             "name": source_name,
889             "format": source_format,
890             "initiator": source_initiator,
891         }
892     context = {
893         "name": name,
894         "ptype": ptype,
895         "target": {"path": target, "permissions": permissions},
896         "source": source,
897     }
898     fn_ = "libvirt_pool.jinja"
899     try:
900         template = JINJA.get_template(fn_)
901     except jinja2.exceptions.TemplateNotFound:
902         log.error("Could not load template %s", fn_)
903         return ""
904     return template.render(**context)
905 def _gen_secret_xml(auth_type, usage, description):
906     context = {
907         "type": auth_type,
908         "usage": usage,
909         "description": description,
910     }
911     fn_ = "libvirt_secret.jinja"
912     try:
913         template = JINJA.get_template(fn_)
914     except jinja2.exceptions.TemplateNotFound:
915         log.error("Could not load template %s", fn_)
916         return ""
917     return template.render(**context)
918 def _get_images_dir():
919     img_dir = __salt__["config.get"]("virt:images")
920     log.debug("Image directory from config option `virt:images` is %s", img_dir)
921     return img_dir
922 def _zfs_image_create(
923     vm_name,
924     pool,
925     disk_name,
926     hostname_property_name,
927     sparse_volume,
928     disk_size,
929     disk_image_name,
930 ):
931     if not disk_image_name and not disk_size:
932         raise CommandExecutionError(
933             "Unable to create new disk {}, please specify"
934             " the disk image name or disk size argument".format(disk_name)
935         )
936     if not pool:
937         raise CommandExecutionError(
938             "Unable to create new disk {}, please specify the disk pool name".format(
939                 disk_name
940             )
941         )
942     destination_fs = os.path.join(pool, "{}.{}".format(vm_name, disk_name))
943     log.debug("Image destination will be %s", destination_fs)
944     existing_disk = __salt__["zfs.list"](name=pool)
945     if "error" in existing_disk:
946         raise CommandExecutionError(
947             "Unable to create new disk {}. {}".format(
948                 destination_fs, existing_disk["error"]
949             )
950         )
951     elif destination_fs in existing_disk:
952         log.info("ZFS filesystem %s already exists. Skipping creation", destination_fs)
953         blockdevice_path = os.path.join("/dev/zvol", pool, vm_name)
954         return blockdevice_path
955     properties = {}
956     if hostname_property_name:
957         properties[hostname_property_name] = vm_name
958     if disk_image_name:
959         __salt__["zfs.clone"](
960             name_a=disk_image_name, name_b=destination_fs, properties=properties
961         )
962     elif disk_size:
963         __salt__["zfs.create"](
964             name=destination_fs,
965             properties=properties,
966             volume_size=disk_size,
967             sparse=sparse_volume,
968         )
969     blockdevice_path = os.path.join(
970         "/dev/zvol", pool, "{}.{}".format(vm_name, disk_name)
971     )
972     log.debug("Image path will be %s", blockdevice_path)
973     return blockdevice_path
974 def _qemu_image_create(disk, create_overlay=False, saltenv="base"):
975     disk_size = disk.get("size", None)
976     disk_image = disk.get("image", None)
977     if not disk_size and not disk_image:
978         raise CommandExecutionError(
979             "Unable to create new disk {}, please specify"
980             " disk size and/or disk image argument".format(disk["filename"])
981         )
982     img_dest = disk["source_file"]
983 <a name="5"></a>    log.debug("Image destination will be %s", img_dest)
984     img_dir = os.path.dirname(img_dest)
985     log.debug("Image destination directory is %s", img_dir)
986     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if not os.path.exists(img_dir):
987         os.makedirs(img_dir)
988     if disk_image:
989         log.debug("Create disk from specified image %s", disk_image)
990 <a name="8"></a>        sfn = __salt__["cp.cache_file"](</b></font>disk_image, saltenv)
991         qcow2 = False
992         if salt.utils.path<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.which("qemu-img"):
993             res = __salt__["cmd.run"]('qemu-img info "{}"'.format(sfn))
994             imageinfo = salt.utils.yaml.safe_load(</b></font>res)
995             qcow2 = imageinfo["file format"] == "qcow2"
996         try:
997             if create_overlay and qcow2:
998                 log.info("Cloning qcow2 image %s using copy on write", sfn)
999                 __salt__["cmd.run"](
1000                     'qemu-img create -f qcow2 -o backing_file="{}" "{}"'.format(
1001                         sfn, img_dest
1002                     ).split()
1003                 )
1004             else:
1005                 log.debug("Copying %s to %s", sfn, img_dest)
1006                 salt.utils.files.copyfile(sfn, img_dest)
1007             mask = salt.utils.files.get_umask()
1008             if disk_size and qcow2:
1009                 log.debug("Resize qcow2 image to %sM", disk_size)
1010                 __salt__["cmd.run"](
1011                     'qemu-img resize "{}" {}M'.format(img_dest, disk_size)
1012                 )
1013             log.debug("Apply umask and remove exec bit")
1014             mode = (0o0777 ^ mask) &amp; 0o0666
1015             os.chmod(img_dest, mode)
1016         except OSError as err:
1017             raise CommandExecutionError(
1018                 "Problem while copying image. {} - {}".format(disk_image, err)
1019             )
1020     else:
1021         try:
1022 <a name="7"></a>            mask = salt.utils.files.get_umask()
1023             if disk_size:
1024                 log<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.debug("Create empty image with size %sM", disk_size)
1025                 __salt__["cmd.run"](
1026                     'qemu-img create -f {} "{}" {}M'.format(
1027                         disk.get("format", "qcow2"), img_dest, disk_size
1028                     )
1029                 )
1030             else:
1031                 raise CommandExecutionError(
1032                     "Unable to create new disk {},"
1033                     " please specify &lt;size&gt; argument".format(</b></font>img_dest)
1034                 )
1035             log.debug("Apply umask and remove exec bit")
1036             mode = (0o0777 ^ mask) &amp; 0o0666
1037             os.chmod(img_dest, mode)
1038         except OSError as err:
1039             raise CommandExecutionError(
1040                 "Problem while creating volume {} - {}".format(img_dest, err)
1041             )
1042     return img_dest
1043 def _seed_image(seed_cmd, img_path, name, config, install, pub_key, priv_key):
1044     log.debug("Seeding image")
1045     __salt__[seed_cmd](
1046         img_path,
1047         id_=name,
1048         config=config,
1049         install=install,
1050         pub_key=pub_key,
1051         priv_key=priv_key,
1052     )
1053 def _disk_volume_create(conn, disk, seeder=None, saltenv="base"):
1054     if disk.get("overlay_image"):
1055         raise SaltInvocationError(
1056             "Disk overlay_image property is not supported when creating volumes,"
1057             "use backing_store_path and backing_store_format instead."
1058         )
1059     pool = conn.storagePoolLookupByName(disk["pool"])
1060     if disk["filename"] in pool.listVolumes():
1061         return
1062     pool_type = ElementTree.fromstring(pool.XMLDesc()).get("type")
1063     backing_path = disk.get("backing_store_path")
1064     backing_format = disk.get("backing_store_format")
1065     backing_store = None
1066     if (
1067         backing_path
1068         and backing_format
1069         and (disk.get("format") == "qcow2" or pool_type == "logical")
1070     ):
1071         backing_store = {"path": backing_path, "format": backing_format}
1072     if backing_store and disk.get("image"):
1073         raise SaltInvocationError(
1074             "Using a template image with a backing store is not possible, "
1075             "choose either of them."
1076         )
1077     vol_xml = _gen_vol_xml(
1078         disk["filename"],
1079         disk.get("size", 0),
1080         format=disk.get("format"),
1081         backing_store=backing_store,
1082 <a name="11"></a>    )
1083     _define_vol_xml_str(conn, vol_xml, disk.get("pool"))
1084     <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if disk.get("image"):
1085         log.debug("Caching disk template image: %s", disk.get("image"))
1086         cached_path = __salt__["cp.cache_file"](disk.get(</b></font>"image"), saltenv)
1087         if seeder:
1088             seeder(cached_path)
1089         _volume_upload(
1090             conn,
1091             disk["pool"],
1092             disk["filename"],
1093             cached_path,
1094             sparse=disk.get("format") == "qcow2",
1095         )
1096 def _disk_profile(conn, profile, hypervisor, disks, vm_name):
1097     default = [{"system": {"size": 8192}}]
1098     if hypervisor == "vmware":
1099         overlay = {"format": "vmdk", "model": "scsi", "device": "disk"}
1100     elif hypervisor in ["qemu", "kvm"]:
1101         overlay = {"device": "disk", "model": "virtio"}
1102     elif hypervisor == "xen":
1103         overlay = {"device": "disk", "model": "xen"}
1104     elif hypervisor == "bhyve":
1105         overlay = {"format": "raw", "model": "virtio", "sparse_volume": False}
1106     else:
1107         overlay = {}
1108     disklist = []
1109     if profile:
1110         disklist = copy.deepcopy(
1111             __salt__["config.get"]("virt:disk", {}).get(profile, default)
1112         )
1113         disklist = [dict(d, name=name) for disk in disklist for name, d in disk.items()]
1114     if disks:
1115         for udisk in disks:
1116             if "name" in udisk:
1117                 found = [disk for disk in disklist if udisk["name"] == disk["name"]]
1118                 if found:
1119                     found[0].update(udisk)
1120                 else:
1121                     disklist.append(udisk)
1122     pool_caps = _pool_capabilities(conn)
1123     for disk in disklist:
1124         if disk.get("device", "disk") == "cdrom" and "model" not in disk:
1125             disk["model"] = "ide"
1126         for key, val in overlay.items():
1127             if key not in disk:
1128                 disk[key] = val
1129         if disk.get("source_file") and os.path.exists(disk["source_file"]):
1130             disk["filename"] = os.path.basename(disk["source_file"])
1131             if not disk.get("format"):
1132                 disk["format"] = (
1133                     "qcow2" if disk.get("device", "disk") != "cdrom" else "raw"
1134                 )
1135         elif vm_name and disk.get("device", "disk") == "disk":
1136             _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps)
1137     return disklist
1138 def _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps):
1139     disk["filename"] = "{}_{}".format(vm_name, disk["name"])
1140     base_dir = disk.get("pool", None)
1141     if hypervisor in ["qemu", "kvm", "xen"]:
1142         if not base_dir:
1143             base_dir = _get_images_dir()
1144         if base_dir not in conn.listStoragePools():
1145             if not disk.get("format"):
1146                 disk["format"] = "qcow2"
1147             disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1148             disk["source_file"] = os.path.join(base_dir, disk["filename"])
1149         else:
1150             if "pool" not in disk:
1151                 disk["pool"] = base_dir
1152             pool_obj = conn.storagePoolLookupByName(base_dir)
1153             pool_xml = ElementTree.fromstring(pool_obj.XMLDesc())
1154             pool_type = pool_xml.get("type")
1155             if pool_type == "disk":
1156                 device = pool_xml.find("./source/device").get("path")
1157                 all_volumes = pool_obj.listVolumes()
1158                 if disk.get("source_file") not in all_volumes:
1159                     indexes = [
1160                         int(re.sub("[a-z]+", "", vol_name)) for vol_name in all_volumes
1161                     ] or [0]
1162                     index = min(
1163                         idx for idx in range(1, max(indexes) + 2) if idx not in indexes
1164                     )
1165                     disk["filename"] = "{}{}".format(os.path.basename(device), index)
1166             if disk.get("source_file"):
1167                 if not disk.get("source_file") in pool_obj.listVolumes():
1168                     raise SaltInvocationError(
1169                         "{} volume doesn't exist in pool {}".format(
1170                             disk.get("source_file"), base_dir
1171                         )
1172                     )
1173                 disk["filename"] = disk["source_file"]
1174                 del disk["source_file"]
1175             if not disk.get("format"):
1176                 volume_options = (
1177                     [
1178                         type_caps.get("options", {}).get("volume", {})
1179                         for type_caps in pool_caps.get("pool_types")
1180                         if type_caps["name"] == pool_type
1181                     ]
1182                     or [{}]
1183                 )[0]
1184                 if "qcow2" in volume_options.get("targetFormatType", []):
1185                     disk["format"] = "qcow2"
1186                 else:
1187                     disk["format"] = volume_options.get("default_format", None)
1188     elif hypervisor == "bhyve" and vm_name:
1189         disk["filename"] = "{}.{}".format(vm_name, disk["name"])
1190         disk["source_file"] = os.path.join(
1191             "/dev/zvol", base_dir or "", disk["filename"]
1192         )
1193     elif hypervisor in ["esxi", "vmware"]:
1194         if not base_dir:
1195             base_dir = __salt__["config.get"]("virt:storagepool", "[0] ")
1196         disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1197         disk["source_file"] = "{}{}".format(base_dir, disk["filename"])
1198 def _complete_nics(interfaces, hypervisor):
1199     vmware_overlay = {"type": "bridge", "source": "DEFAULT", "model": "e1000"}
1200     kvm_overlay = {"type": "bridge", "source": "br0", "model": "virtio"}
1201     xen_overlay = {"type": "bridge", "source": "br0", "model": None}
1202     bhyve_overlay = {"type": "bridge", "source": "bridge0", "model": "virtio"}
1203     overlays = {
1204         "xen": xen_overlay,
1205         "kvm": kvm_overlay,
1206         "qemu": kvm_overlay,
1207         "vmware": vmware_overlay,
1208         "bhyve": bhyve_overlay,
1209     }
1210     def _normalize_net_types(attributes):
1211         for type_ in ["bridge", "network"]:
1212             if type_ in attributes:
1213                 attributes["type"] = type_
1214                 attributes["source"] = attributes.pop(type_)
1215         attributes["type"] = attributes.get("type", None)
1216         attributes["source"] = attributes.get("source", None)
1217     def _apply_default_overlay(attributes):
1218         for key, value in overlays[hypervisor].items():
1219             if key not in attributes or not attributes[key]:
1220                 attributes[key] = value
1221     for interface in interfaces:
1222         _normalize_net_types(interface)
1223         if hypervisor in overlays:
1224             _apply_default_overlay(interface)
1225     return interfaces
1226 def _nic_profile(profile_name, hypervisor):
1227     config_data = __salt__["config.get"]("virt:nic", {}).get(
1228         profile_name, [{"eth0": {}}]
1229     )
1230     interfaces = []
1231     def append_dict_profile_to_interface_list(profile_dict):
1232         for interface_name, attributes in profile_dict.items():
1233             attributes["name"] = interface_name
1234             interfaces.append(attributes)
1235     if isinstance(config_data, dict):
1236         append_dict_profile_to_interface_list(config_data)
1237     elif isinstance(config_data, list):
1238         for interface in config_data:
1239             if isinstance(interface, dict):
1240                 if len(interface) == 1:
1241                     append_dict_profile_to_interface_list(interface)
1242                 else:
1243                     interfaces.append(interface)
1244     return _complete_nics(interfaces, hypervisor)
1245 def _get_merged_nics(hypervisor, profile, interfaces=None):
1246     nicp = _nic_profile(profile, hypervisor) if profile else []
1247     log.debug("NIC profile is %s", nicp)
1248     if interfaces:
1249         users_nics = _complete_nics(interfaces, hypervisor)
1250         for unic in users_nics:
1251             found = [nic for nic in nicp if nic["name"] == unic["name"]]
1252             if found:
1253                 found[0].update(unic)
1254             else:
1255                 nicp.append(unic)
1256         log.debug("Merged NICs: %s", nicp)
1257     return nicp
1258 def _handle_remote_boot_params(orig_boot):
1259     saltinst_dir = None
1260     new_boot = orig_boot.copy()
1261     keys = orig_boot.keys()
1262     cases = [
1263         {"efi"},
1264         {"kernel", "initrd", "efi"},
1265         {"kernel", "initrd", "cmdline", "efi"},
1266         {"loader", "nvram"},
1267         {"kernel", "initrd"},
1268         {"kernel", "initrd", "cmdline"},
1269         {"kernel", "initrd", "loader", "nvram"},
1270         {"kernel", "initrd", "cmdline", "loader", "nvram"},
1271     ]
1272     if keys in cases:
1273         for key in keys:
1274             if key == "efi" and type(orig_boot.get(key)) == bool:
1275                 new_boot[key] = orig_boot.get(key)
1276             elif orig_boot.get(key) is not None and salt.utils.virt.check_remote(
1277                 orig_boot.get(key)
1278             ):
1279                 if saltinst_dir is None:
1280                     os.makedirs(CACHE_DIR)
1281                     saltinst_dir = CACHE_DIR
1282                 new_boot[key] = salt.utils.virt.download_remote(
1283                     orig_boot.get(key), saltinst_dir
1284                 )
1285         return new_boot
1286     else:
1287         raise SaltInvocationError(
1288             "Invalid boot parameters,It has to follow this combination: [(kernel,"
1289             " initrd) or/and cmdline] or/and [(loader, nvram) or efi]"
1290         )
1291 def _handle_efi_param(boot, desc):
1292     efi_value = boot.get("efi", None) if boot else None
1293     parent_tag = desc.find("os")
1294     os_attrib = parent_tag.attrib
1295     if efi_value is False and os_attrib != {}:
1296         parent_tag.attrib.pop("firmware", None)
1297         return True
1298     elif type(efi_value) == bool and os_attrib == {}:
1299         if efi_value is True and parent_tag.find("loader") is None:
1300             parent_tag.set("firmware", "efi")
1301             return True
1302         if efi_value is False and parent_tag.find("loader") is not None:
1303             parent_tag.remove(parent_tag.find("loader"))
1304             parent_tag.remove(parent_tag.find("nvram"))
1305             return True
1306     elif type(efi_value) != bool:
1307         raise SaltInvocationError("Invalid efi value")
1308     return False
1309 def init(
1310     name,
1311     cpu,
1312     mem,
1313     nic="default",
1314     interfaces=None,
1315     hypervisor=None,
1316     start=True,  # pylint: disable=redefined-outer-name
1317     disk="default",
1318     disks=None,
1319     saltenv="base",
1320     seed=True,
1321     install=True,
1322     pub_key=None,
1323     priv_key=None,
1324     seed_cmd="seed.apply",
1325     graphics=None,
1326     os_type=None,
1327     arch=None,
1328     boot=None,
1329     boot_dev=None,
1330     numatune=None,
1331     hypervisor_features=None,
1332     clock=None,
1333     serials=None,
1334     consoles=None,
1335     stop_on_reboot=False,
1336     host_devices=None,
1337     **kwargs
1338 ):
1339     try:
1340         conn = __get_conn(**kwargs)
1341         caps = _capabilities(conn)
1342         os_types = sorted({guest["os_type"] for guest in caps["guests"]})
1343         arches = sorted({guest["arch"]["name"] for guest in caps["guests"]})
1344         virt_hypervisor = hypervisor
1345         if not virt_hypervisor:
1346             hypervisors = sorted(
1347                 {
1348                     x
1349                     for y in [
1350                         guest["arch"]["domains"].keys() for guest in caps["guests"]
1351                     ]
1352                     for x in y
1353                 }
1354             )
1355             if len(hypervisors) == 0:
1356                 raise SaltInvocationError("No supported hypervisors were found")
1357             virt_hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
1358         virt_hypervisor = "vmware" if virt_hypervisor == "esxi" else virt_hypervisor
1359         log.debug("Using hypervisor %s", virt_hypervisor)
1360         nicp = _get_merged_nics(virt_hypervisor, nic, interfaces)
1361         diskp = _disk_profile(conn, disk, virt_hypervisor, disks, name)
1362         for _disk in diskp:
1363             if _disk.get("device", "disk") == "cdrom":
1364                 continue
1365             log.debug("Creating disk for VM [ %s ]: %s", name, _disk)
1366             if virt_hypervisor == "vmware":
1367                 if "image" in _disk:
1368                     raise SaltInvocationError(
1369                         "virt.init does not support image "
1370                         "template in conjunction with esxi hypervisor"
1371                     )
1372                 else:
1373                     log.debug("Generating libvirt XML for %s", _disk)
1374                     volume_name = "{}/{}".format(name, _disk["name"])
1375                     filename = "{}.{}".format(volume_name, _disk["format"])
1376                     vol_xml = _gen_vol_xml(
1377                         filename, _disk["size"], format=_disk["format"]
1378                     )
1379                     _define_vol_xml_str(conn, vol_xml, pool=_disk.get("pool"))
1380             elif virt_hypervisor in ["qemu", "kvm", "xen"]:
1381                 def seeder(path):
1382                     _seed_image(
1383                         seed_cmd,
1384                         path,
1385                         name,
1386                         kwargs.get("config"),
1387                         install,
1388                         pub_key,
1389                         priv_key,
1390                     )
1391                 create_overlay = _disk.get("overlay_image", False)
1392                 format = _disk.get("format")
1393                 if _disk.get("source_file"):
1394                     if os.path.exists(_disk["source_file"]):
1395                         img_dest = _disk["source_file"]
1396                     else:
1397                         img_dest = _qemu_image_create(_disk, create_overlay, saltenv)
1398                 else:
1399                     _disk_volume_create(conn, _disk, seeder if seed else None, saltenv)
1400                     img_dest = None
1401                 if seed and img_dest and _disk.get("image", None):
1402                     seeder(img_dest)
1403             elif hypervisor in ["bhyve"]:
1404                 img_dest = _zfs_image_create(
1405                     vm_name=name,
1406                     pool=_disk.get("pool"),
1407                     disk_name=_disk.get("name"),
1408                     disk_size=_disk.get("size"),
1409                     disk_image_name=_disk.get("image"),
1410                     hostname_property_name=_disk.get("hostname_property"),
1411                     sparse_volume=_disk.get("sparse_volume"),
1412                 )
1413             else:
1414                 raise SaltInvocationError(
1415                     "Unsupported hypervisor when handling disk image: {}".format(
1416                         virt_hypervisor
1417                     )
1418                 )
1419         log.debug("Generating VM XML")
1420         if os_type is None:
1421             os_type = "hvm" if "hvm" in os_types else os_types[0]
1422         if arch is None:
1423             arch = "x86_64" if "x86_64" in arches else arches[0]
1424         if boot is not None:
1425             boot = _handle_remote_boot_params(boot)
1426         vm_xml = _gen_xml(
1427             conn,
1428             name,
1429             cpu,
1430             mem,
1431             diskp,
1432             nicp,
1433             virt_hypervisor,
1434             os_type,
1435             arch,
1436             graphics,
1437             boot,
1438             boot_dev,
1439             numatune,
1440             hypervisor_features,
1441             clock,
1442             serials,
1443             consoles,
1444             stop_on_reboot,
1445             host_devices,
1446             **kwargs
1447         )
1448         log.debug("New virtual machine definition: %s", vm_xml)
1449         conn.defineXML(vm_xml)
1450     except libvirt.libvirtError as err:
1451         conn.close()
1452         raise CommandExecutionError(err.get_error_message())
1453     if start:
1454         log.debug("Starting VM %s", name)
1455         _get_domain(conn, name).create()
1456     conn.close()
1457     return True
1458 def _disks_equal(disk1, disk2):
1459     target1 = disk1.find("target")
1460     target2 = disk2.find("target")
1461     disk1_dict = xmlutil.to_dict(disk1, True)
1462 <a name="3"></a>    disk2_dict = xmlutil.to_dict(disk2, True)
1463     source1_dict = disk1_dict.get("source", {})
1464     source2_dict <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= disk2_dict.get("source", {})
1465     io1 = disk1_dict.get("driver", {}).get("io", "native")
1466     io2 = disk2_dict.get("driver", {}).get(</b></font>"io", "native")
1467     if source1_dict:
1468         source1_dict.pop("index", None)
1469     if source2_dict:
1470         source2_dict.pop("index", None)
1471     return (
1472         source1_dict == source2_dict
1473         and target1 is not None
1474         and target2 is not None
1475         and target1.get("bus") == target2.get("bus")
1476         and disk1.get("device", "disk") == disk2.get("device", "disk")
1477         and target1.get("dev") == target2.get("dev")
1478         and io1 == io2
1479     )
1480 def _nics_equal(nic1, nic2):
1481     def _filter_nic(nic):
1482         source_node = nic.find("source")
1483         source_attrib = source_node.attrib if source_node is not None else {}
1484         source_type = "network" if "network" in source_attrib else nic.attrib["type"]
1485         source_getters = {
1486             "network": lambda n: n.get("network"),
1487             "bridge": lambda n: n.get("bridge"),
1488             "direct": lambda n: n.get("dev"),
1489             "hostdev": lambda n: _format_pci_address(n.find("address")),
1490         }
1491         return {
1492             "type": source_type,
1493             "source": source_getters[source_type](source_node)
1494             if source_node is not None
1495             else None,
1496             "model": nic.find("model").attrib["type"]
1497             if nic.find("model") is not None
1498             else None,
1499         }
1500     def _get_mac(nic):
1501         return (
1502             nic.find("mac").attrib["address"].lower()
1503             if nic.find("mac") is not None
1504             else None
1505         )
1506     mac1 = _get_mac(nic1)
1507     mac2 = _get_mac(nic2)
1508     macs_equal = not mac1 or not mac2 or mac1 == mac2
1509     return _filter_nic(nic1) == _filter_nic(nic2) and macs_equal
1510 def _graphics_equal(gfx1, gfx2):
1511     def _filter_graphics(gfx):
1512         gfx_copy = copy.deepcopy(gfx)
1513         defaults = [
1514             {"node": ".", "attrib": "port", "values": ["5900", "-1"]},
1515             {"node": ".", "attrib": "address", "values": ["127.0.0.1"]},
1516             {"node": "listen", "attrib": "address", "values": ["127.0.0.1"]},
1517         ]
1518         for default in defaults:
1519             node = gfx_copy.find(default["node"])
1520             attrib = default["attrib"]
1521             if node is not None and (
1522                 attrib in node.attrib and node.attrib[attrib] in default["values"]
1523             ):
1524                 node.attrib.pop(attrib)
1525         return gfx_copy
1526     return xmlutil.to_dict(_filter_graphics(gfx1), True) == xmlutil.to_dict(
1527         _filter_graphics(gfx2), True
1528     )
1529 def _hostdevs_equal(dev1, dev2):
1530     def _filter_hostdevs(dev):
1531         type_ = dev.get("type")
1532         definition = {
1533             "type": type_,
1534         }
1535         if type_ == "pci":
1536             address_node = dev.find("./source/address")
1537             for attr in ["domain", "bus", "slot", "function"]:
1538                 definition[attr] = address_node.get(attr)
1539         elif type_ == "usb":
1540             for attr in ["vendor", "product"]:
1541                 definition[attr] = dev.find("./source/" + attr).get("id")
1542         return definition
1543     return _filter_hostdevs(dev1) == _filter_hostdevs(dev2)
1544 def _diff_lists(old, new, comparator):
1545     def _remove_indent(node):
1546         node_copy = copy.deepcopy(node)
1547         node_copy.text = None
1548         for item in node_copy.iter():
1549             item.tail = None
1550         return node_copy
1551     diff = {"unchanged": [], "new": [], "deleted": [], "sorted": []}
1552     old_devices = copy.deepcopy(old)
1553     for new_item in new:
1554         found = [
1555             item
1556             for item in old_devices
1557             if comparator(_remove_indent(item), _remove_indent(new_item))
1558         ]
1559         if found:
1560             old_devices.remove(found[0])
1561             diff["unchanged"].append(found[0])
1562             diff["sorted"].append(found[0])
1563         else:
1564             diff["new"].append(new_item)
1565             diff["sorted"].append(new_item)
1566     diff["deleted"] = old_devices
1567     return diff
1568 def _get_disk_target(targets, disks_count, prefix):
1569     for i in range(disks_count):
1570         ret = "{}{}".format(prefix, string.ascii_lowercase[i])
1571         if ret not in targets:
1572             return ret
1573     return None
1574 def _diff_disk_lists(old, new):
1575     targets = []
1576     prefixes = ["fd", "hd", "vd", "sd", "xvd", "ubd"]
1577     for disk in new:
1578         target_node = disk.find("target")
1579         target = target_node.get("dev")
1580         prefix = [item for item in prefixes if target.startswith(item)][0]
1581         new_target = _get_disk_target(targets, len(new), prefix)
1582         target_node.set("dev", new_target)
1583         targets.append(new_target)
1584     return _diff_lists(old, new, _disks_equal)
1585 def _diff_interface_lists(old, new):
1586     return _diff_lists(old, new, _nics_equal)
1587 def _diff_graphics_lists(old, new):
1588     return _diff_lists(old, new, _graphics_equal)
1589 def _diff_hostdev_lists(old, new):
1590     return _diff_lists(old, new, _hostdevs_equal)
1591 def _expand_cpuset(cpuset):
1592     if cpuset is None:
1593         return None
1594     if isinstance(cpuset, int):
1595         return str(cpuset)
1596     result = set()
1597     toremove = set()
1598     for part in cpuset.split(","):
1599         m = re.match("([0-9]+)-([0-9]+)", part)
1600         if m:
1601             result |= set(range(int(m.group(1)), int(m.group(2)) + 1))
1602         elif part.startswith("^"):
1603             toremove.add(int(part[1:]))
1604         else:
1605             result.add(int(part))
1606     cpus = list(result - toremove)
1607     cpus.sort()
1608     cpus = [str(cpu) for cpu in cpus]
1609     return ",".join(cpus)
1610 def _normalize_cpusets(desc, data):
1611     xpaths = ["cputune/cachetune", "cputune/cachetune/monitor", "cputune/memorytune"]
1612     for xpath in xpaths:
1613         nodes = desc.findall(xpath)
1614         for node in nodes:
1615             node.set("vcpus", _expand_cpuset(node.get("vcpus")))
1616     if not isinstance(data.get("cpu"), dict):
1617         return
1618     tuning = data["cpu"].get("tuning", {})
1619     for child in ["cachetune", "memorytune"]:
1620         if tuning.get(child):
1621             new_item = dict()
1622             for cpuset, value in tuning[child].items():
1623                 if child == "cachetune" and value.get("monitor"):
1624                     value["monitor"] = {
1625                         _expand_cpuset(monitor_cpus): monitor
1626                         for monitor_cpus, monitor in value["monitor"].items()
1627                     }
1628                 new_item[_expand_cpuset(cpuset)] = value
1629             tuning[child] = new_item
1630 def _serial_or_concole_equal(old, new):
1631     def _filter_serial_or_concole(item):
1632         return {
1633             "type": item.attrib["type"],
1634             "port": item.find("source").get("service")
1635             if item.find("source") is not None
1636             else None,
1637             "protocol": item.find("protocol").get("type")
1638             if item.find("protocol") is not None
1639             else None,
1640         }
1641     return _filter_serial_or_concole(old) == _filter_serial_or_concole(new)
1642 def _diff_serial_lists(old, new):
1643     return _diff_lists(old, new, _serial_or_concole_equal)
1644 def _diff_console_lists(old, new):
1645     return _diff_lists(old, new, _serial_or_concole_equal)
1646 def _format_pci_address(node):
1647     return "{}:{}:{}.{}".format(
1648         node.get("domain").replace("0x", ""),
1649         node.get("bus").replace("0x", ""),
1650         node.get("slot").replace("0x", ""),
1651         node.get("function").replace("0x", ""),
1652     )
1653 def _almost_equal(current, new):
1654     if current is None or new is None:
1655         return False
1656     return abs(current - new) / current &lt; 1e-03
1657 def _compute_device_changes(old_xml, new_xml, to_skip):
1658     devices_node = old_xml.find("devices")
1659     changes = {}
1660     for dev_type in to_skip:
1661         changes[dev_type] = {}
1662         if not to_skip[dev_type]:
1663             old = devices_node.findall(dev_type)
1664             new = new_xml.findall("devices/{}".format(dev_type))
1665             changes[dev_type] = globals()["_diff_{}_lists".format(dev_type)](old, new)
1666     return changes
1667 def _get_pci_addresses(node):
1668     return {_format_pci_address(address) for address in node.findall(".//address")}
1669 def _correct_networks(conn, desc):
1670     networks = [ElementTree.fromstring(net.XMLDesc()) for net in conn.listAllNetworks()]
1671     nics = desc.findall("devices/interface")
1672     device_map = {}
1673     for nic in nics:
1674         if nic.get("type") == "hostdev":
1675             addr = _get_pci_addresses(nic.find("source"))
1676             matching_nets = [
1677                 net
1678                 for net in networks
1679                 if net.find("forward").get("mode") == "hostdev"
1680                 and addr &amp; _get_pci_addresses(net)
1681             ]
1682             if matching_nets:
1683                 old_xml = ElementTree.tostring(nic)
1684                 nic.set("type", "network")
1685                 nic.find("source").set("network", matching_nets[0].find("name").text)
1686                 device_map[nic] = old_xml
1687     return device_map
1688 def _update_live(domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test):
1689     status = {}
1690     errors = []
1691     if not domain.isActive():
1692         return status, errors
1693     commands = []
1694     if cpu and (isinstance(cpu, int) or isinstance(cpu, dict) and cpu.get("maximum")):
1695         new_cpu = cpu.get("maximum") if isinstance(cpu, dict) else cpu
1696         if old_cpu != new_cpu and new_cpu is not None:
1697             commands.append(
1698                 {
1699                     "device": "cpu",
1700                     "cmd": "setVcpusFlags",
1701                     "args": [new_cpu, libvirt.VIR_DOMAIN_AFFECT_LIVE],
1702                 }
1703             )
1704     if mem:
1705         if isinstance(mem, dict):
1706             new_mem = (
1707                 int(_handle_unit(mem.get("current")) / 1024)
1708                 if "current" in mem
1709                 else None
1710             )
1711         elif isinstance(mem, int):
1712             new_mem = int(mem * 1024)
1713         if not _almost_equal(old_mem, new_mem) and new_mem is not None:
1714             commands.append(
1715                 {
1716                     "device": "mem",
1717                     "cmd": "setMemoryFlags",
1718                     "args": [new_mem, libvirt.VIR_DOMAIN_AFFECT_LIVE],
1719                 }
1720             )
1721     old_desc = ElementTree.fromstring(domain.XMLDesc(0))
1722     changed_devices = {"interface": _correct_networks(domain.connect(), old_desc)}
1723     changes = _compute_device_changes(old_desc, new_desc, to_skip)
1724     removable_changes = []
1725     new_disks = []
1726     for new_disk in changes["disk"].get("new", []):
1727         device = new_disk.get("device", "disk")
1728         if device not in ["cdrom", "floppy"]:
1729             new_disks.append(new_disk)
1730             continue
1731         target_dev = new_disk.find("target").get("dev")
1732         matching = [
1733             old_disk
1734             for old_disk in changes["disk"].get("deleted", [])
1735             if old_disk.get("device", "disk") == device
1736             and old_disk.find("target").get("dev") == target_dev
1737         ]
1738         if not matching:
1739             new_disks.append(new_disk)
1740         else:
1741             updated_disk = matching[0]
1742             changes["disk"]["deleted"].remove(updated_disk)
1743             removable_changes.append(updated_disk)
1744             source_node = updated_disk.find("source")
1745             new_source_node = new_disk.find("source")
1746             source_file = (
1747                 new_source_node.get("file") if new_source_node is not None else None
1748             )
1749             updated_disk.set("type", "file")
1750             if source_node is not None:
1751                 updated_disk.remove(source_node)
1752             if source_file:
1753                 ElementTree.SubElement(
1754                     updated_disk, "source", attrib={"file": source_file}
1755                 )
1756     changes["disk"]["new"] = new_disks
1757     for dev_type in ["disk", "interface", "hostdev"]:
1758         for added in changes[dev_type].get("new", []):
1759             commands.append(
1760                 {
1761                     "device": dev_type,
1762                     "cmd": "attachDevice",
1763                     "args": [xmlutil.element_to_str(added)],
1764                 }
1765             )
1766         for removed in changes[dev_type].get("deleted", []):
1767             removed_def = changed_devices.get(dev_type, {}).get(
1768                 removed, ElementTree.tostring(removed)
1769             )
1770             commands.append(
1771                 {
1772                     "device": dev_type,
1773                     "cmd": "detachDevice",
1774                     "args": [salt.utils.stringutils.to_str(removed_def)],
1775                 }
1776             )
1777     for updated_disk in removable_changes:
1778         commands.append(
1779             {
1780                 "device": "disk",
1781                 "cmd": "updateDeviceFlags",
1782                 "args": [xmlutil.element_to_str(updated_disk)],
1783             }
1784         )
1785     for cmd in commands:
1786         try:
1787             ret = 0 if test else getattr(domain, cmd["cmd"])(*cmd["args"])
1788             device_type = cmd["device"]
1789             if device_type in ["cpu", "mem"]:
1790                 status[device_type] = not ret
1791             else:
1792                 actions = {
1793                     "attachDevice": "attached",
1794                     "detachDevice": "detached",
1795                     "updateDeviceFlags": "updated",
1796                 }
1797                 device_status = status.setdefault(device_type, {})
1798                 cmd_status = device_status.setdefault(actions[cmd["cmd"]], [])
1799                 cmd_status.append(cmd["args"][0])
1800         except libvirt.libvirtError as err:
1801             errors.append(str(err))
1802     return status, errors
1803 def update(
1804     name,
1805     cpu=0,
1806     mem=0,
1807     disk_profile=None,
1808     disks=None,
1809     nic_profile=None,
1810     interfaces=None,
1811     graphics=None,
1812     live=True,
1813     boot=None,
1814     numatune=None,
1815     test=False,
1816     boot_dev=None,
1817     hypervisor_features=None,
1818     clock=None,
1819     serials=None,
1820     consoles=None,
1821     stop_on_reboot=False,
1822     host_devices=None,
1823     **kwargs
1824 ):
1825     status = {
1826         "definition": False,
1827         "disk": {"attached": [], "detached": [], "updated": []},
1828         "interface": {"attached": [], "detached": []},
1829     }
1830     conn = __get_conn(**kwargs)
1831     domain = _get_domain(conn, name)
1832     desc = ElementTree.fromstring(domain.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
1833     need_update = False
1834     hypervisor = desc.get("type")
1835     all_disks = _disk_profile(conn, disk_profile, hypervisor, disks, name)
1836     if boot is not None:
1837         boot = _handle_remote_boot_params(boot)
1838         if boot.get("efi", None) is not None:
1839             need_update = _handle_efi_param(boot, desc)
1840     new_desc = ElementTree.fromstring(
1841         _gen_xml(
1842             conn,
1843             name,
1844             cpu,
1845             mem or 0,
1846             all_disks,
1847             _get_merged_nics(hypervisor, nic_profile, interfaces),
1848             hypervisor,
1849             domain.OSType(),
1850             desc.find(".//os/type").get("arch"),
1851             graphics,
1852             boot,
1853             boot_dev,
1854             numatune,
1855             serials=serials,
1856             consoles=consoles,
1857             stop_on_reboot=stop_on_reboot,
1858             host_devices=host_devices,
1859             **kwargs
1860         )
1861     )
1862     if clock:
1863         offset = "utc" if clock.get("utc", True) else "localtime"
1864         if "timezone" in clock:
1865             offset = "timezone"
1866         clock["offset"] = offset
1867     def _set_loader(node, value):
1868         salt.utils.xmlutil.set_node_text(node, value)
1869         if value is not None:
1870             node.set("readonly", "yes")
1871             node.set("type", "pflash")
1872     def _set_nvram(node, value):
1873         node.set("template", value)
1874     def _set_with_byte_unit(attr_name=None):
1875         def _setter(node, value):
1876             if attr_name:
1877                 node.set(attr_name, str(value))
1878             else:
1879                 node.text = str(value)
1880             node.set("unit", "bytes")
1881         return _setter
1882     def _get_with_unit(node):
1883         unit = node.get("unit", "KiB")
1884         unit = unit if unit != "bytes" else "b"
1885         value = node.get("memory") or node.get("size") or node.text
1886         return _handle_unit("{}{}".format(value, unit)) if value else None
1887     def _set_vcpu(node, value):
1888         node.text = str(value)
1889         node.set("current", str(value))
1890     old_mem = int(_get_with_unit(desc.find("memory")) / 1024)
1891     old_cpu = int(desc.find("./vcpu").text)
1892     def _yesno_attribute(path, xpath, attr_name, ignored=None):
1893         return xmlutil.attribute(
1894             path, xpath, attr_name, ignored, lambda v: "yes" if v else "no"
1895         )
1896     def _memory_parameter(path, xpath, attr_name=None, ignored=None):
1897         entry = {
1898             "path": path,
1899             "xpath": xpath,
1900             "convert": _handle_unit,
1901             "get": _get_with_unit,
1902             "set": _set_with_byte_unit(attr_name),
1903             "equals": _almost_equal,
1904         }
1905         if attr_name:
1906             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
1907         return entry
1908     def _cpuset_parameter(path, xpath, attr_name=None, ignored=None):
1909         def _set_cpuset(node, value):
1910             if attr_name:
1911                 node.set(attr_name, value)
1912             else:
1913                 node.text = value
1914         entry = {
1915             "path": path,
1916             "xpath": xpath,
1917             "convert": _expand_cpuset,
1918             "get": lambda n: _expand_cpuset(n.get(attr_name) if attr_name else n.text),
1919             "set": _set_cpuset,
1920         }
1921         if attr_name:
1922             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
1923         return entry
1924     data = {k: v for k, v in locals().items() if bool(v)}
1925     data["stop_on_reboot"] = stop_on_reboot
1926     if boot_dev:
1927         data["boot_dev"] = boot_dev.split()
1928     timer_names = [
1929         "platform",
1930         "hpet",
1931         "kvmclock",
1932         "pit",
1933         "rtc",
1934         "tsc",
1935         "hypervclock",
1936         "armvtimer",
1937     ]
1938     if data.get("clock", {}).get("timers"):
1939         attributes = [
1940             "track",
1941             "tickpolicy",
1942             "frequency",
1943             "mode",
1944             "present",
1945             "slew",
1946             "threshold",
1947             "limit",
1948         ]
1949         for timer in data["clock"]["timers"].values():
1950             for attribute in attributes:
1951                 if attribute not in timer:
1952                     timer[attribute] = None
1953         for timer_name in timer_names:
1954             if timer_name not in data["clock"]["timers"]:
1955                 data["clock"]["timers"][timer_name] = None
1956     _normalize_cpusets(desc, data)
1957     params_mapping = [
1958         {
1959             "path": "stop_on_reboot",
1960             "xpath": "on_reboot",
1961             "convert": lambda v: "destroy" if v else "restart",
1962         },
1963         {"path": "boot:kernel", "xpath": "os/kernel"},
1964         {"path": "boot:initrd", "xpath": "os/initrd"},
1965         {"path": "boot:cmdline", "xpath": "os/cmdline"},
1966         {"path": "boot:loader", "xpath": "os/loader", "set": _set_loader},
1967         {"path": "boot:nvram", "xpath": "os/nvram", "set": _set_nvram},
1968         _memory_parameter("mem", "memory"),
1969         _memory_parameter("mem", "currentMemory"),
1970         _memory_parameter("mem:max", "maxMemory"),
1971         _memory_parameter("mem:boot", "memory"),
1972         _memory_parameter("mem:current", "currentMemory"),
1973         xmlutil.attribute("mem:slots", "maxMemory", "slots", ["unit"]),
1974         _memory_parameter("mem:hard_limit", "memtune/hard_limit"),
1975         _memory_parameter("mem:soft_limit", "memtune/soft_limit"),
1976         _memory_parameter("mem:swap_hard_limit", "memtune/swap_hard_limit"),
1977         _memory_parameter("mem:min_guarantee", "memtune/min_guarantee"),
1978         xmlutil.attribute("boot_dev:{dev}", "os/boot[$dev]", "dev"),
1979         _memory_parameter(
1980             "mem:hugepages:{id}:size",
1981             "memoryBacking/hugepages/page[$id]",
1982             "size",
1983             ["unit", "nodeset"],
1984         ),
1985         _cpuset_parameter(
1986             "mem:hugepages:{id}:nodeset", "memoryBacking/hugepages/page[$id]", "nodeset"
1987         ),
1988         {
1989             "path": "mem:nosharepages",
1990             "xpath": "memoryBacking/nosharepages",
1991             "get": lambda n: n is not None,
1992             "set": lambda n, v: None,
1993         },
1994         {
1995             "path": "mem:locked",
1996             "xpath": "memoryBacking/locked",
1997             "get": lambda n: n is not None,
1998             "set": lambda n, v: None,
1999         },
2000         xmlutil.attribute("mem:source", "memoryBacking/source", "type"),
2001         xmlutil.attribute("mem:access", "memoryBacking/access", "mode"),
2002         xmlutil.attribute("mem:allocation", "memoryBacking/allocation", "mode"),
2003         {"path": "mem:discard", "xpath": "memoryBacking/discard"},
2004         {
2005             "path": "cpu",
2006             "xpath": "vcpu",
2007             "get": lambda n: int(n.text),
2008             "set": _set_vcpu,
2009         },
2010         {"path": "cpu:maximum", "xpath": "vcpu", "get": lambda n: int(n.text)},
2011         xmlutil.attribute("cpu:placement", "vcpu", "placement"),
2012         _cpuset_parameter("cpu:cpuset", "vcpu", "cpuset"),
2013         xmlutil.attribute("cpu:current", "vcpu", "current"),
2014         xmlutil.attribute("cpu:match", "cpu", "match"),
2015         xmlutil.attribute("cpu:mode", "cpu", "mode"),
2016         xmlutil.attribute("cpu:check", "cpu", "check"),
2017         {"path": "cpu:model:name", "xpath": "cpu/model"},
2018         xmlutil.attribute("cpu:model:fallback", "cpu/model", "fallback"),
2019         xmlutil.attribute("cpu:model:vendor_id", "cpu/model", "vendor_id"),
2020         {"path": "cpu:vendor", "xpath": "cpu/vendor"},
2021         xmlutil.attribute("cpu:topology:sockets", "cpu/topology", "sockets"),
2022         xmlutil.attribute("cpu:topology:cores", "cpu/topology", "cores"),
2023         xmlutil.attribute("cpu:topology:threads", "cpu/topology", "threads"),
2024         xmlutil.attribute("cpu:cache:level", "cpu/cache", "level"),
2025         xmlutil.attribute("cpu:cache:mode", "cpu/cache", "mode"),
2026         xmlutil.attribute(
2027             "cpu:features:{id}", "cpu/feature[@name='$id']", "policy", ["name"]
2028         ),
2029         _yesno_attribute(
2030             "cpu:vcpus:{id}:enabled", "vcpus/vcpu[@id='$id']", "enabled", ["id"]
2031         ),
2032         _yesno_attribute(
2033             "cpu:vcpus:{id}:hotpluggable",
2034             "vcpus/vcpu[@id='$id']",
2035             "hotpluggable",
2036             ["id"],
2037         ),
2038         xmlutil.int_attribute(
2039             "cpu:vcpus:{id}:order", "vcpus/vcpu[@id='$id']", "order", ["id"]
2040         ),
2041         _cpuset_parameter(
2042             "cpu:numa:{id}:cpus", "cpu/numa/cell[@id='$id']", "cpus", ["id"]
2043         ),
2044         _memory_parameter(
2045             "cpu:numa:{id}:memory", "cpu/numa/cell[@id='$id']", "memory", ["id"]
2046         ),
2047         _yesno_attribute(
2048             "cpu:numa:{id}:discard", "cpu/numa/cell[@id='$id']", "discard", ["id"]
2049         ),
2050         xmlutil.attribute(
2051             "cpu:numa:{id}:memAccess", "cpu/numa/cell[@id='$id']", "memAccess", ["id"]
2052         ),
2053         xmlutil.attribute(
2054             "cpu:numa:{id}:distances:{sid}",
2055             "cpu/numa/cell[@id='$id']/distances/sibling[@id='$sid']",
2056             "value",
2057             ["id"],
2058         ),
2059         {"path": "cpu:iothreads", "xpath": "iothreads"},
2060         {"path": "cpu:tuning:shares", "xpath": "cputune/shares"},
2061         {"path": "cpu:tuning:period", "xpath": "cputune/period"},
2062         {"path": "cpu:tuning:quota", "xpath": "cputune/quota"},
2063         {"path": "cpu:tuning:global_period", "xpath": "cputune/global_period"},
2064         {"path": "cpu:tuning:global_quota", "xpath": "cputune/global_quota"},
2065         {"path": "cpu:tuning:emulator_period", "xpath": "cputune/emulator_period"},
2066         {"path": "cpu:tuning:emulator_quota", "xpath": "cputune/emulator_quota"},
2067         {"path": "cpu:tuning:iothread_period", "xpath": "cputune/iothread_period"},
2068         {"path": "cpu:tuning:iothread_quota", "xpath": "cputune/iothread_quota"},
2069         _cpuset_parameter(
2070             "cpu:tuning:vcpupin:{id}",
2071             "cputune/vcpupin[@vcpu='$id']",
2072             "cpuset",
2073             ["vcpu"],
2074         ),
2075         _cpuset_parameter("cpu:tuning:emulatorpin", "cputune/emulatorpin", "cpuset"),
2076         _cpuset_parameter(
2077             "cpu:tuning:iothreadpin:{id}",
2078             "cputune/iothreadpin[@iothread='$id']",
2079             "cpuset",
2080             ["iothread"],
2081         ),
2082         xmlutil.attribute(
2083             "cpu:tuning:vcpusched:{id}:scheduler",
2084             "cputune/vcpusched[$id]",
2085             "scheduler",
2086             ["priority", "vcpus"],
2087         ),
2088         xmlutil.attribute(
2089             "cpu:tuning:vcpusched:{id}:priority", "cputune/vcpusched[$id]", "priority"
2090         ),
2091         _cpuset_parameter(
2092             "cpu:tuning:vcpusched:{id}:vcpus", "cputune/vcpusched[$id]", "vcpus"
2093         ),
2094         xmlutil.attribute(
2095             "cpu:tuning:iothreadsched:{id}:scheduler",
2096             "cputune/iothreadsched[$id]",
2097             "scheduler",
2098             ["priority", "iothreads"],
2099         ),
2100         xmlutil.attribute(
2101             "cpu:tuning:iothreadsched:{id}:priority",
2102             "cputune/iothreadsched[$id]",
2103             "priority",
2104         ),
2105         _cpuset_parameter(
2106             "cpu:tuning:iothreadsched:{id}:iothreads",
2107             "cputune/iothreadsched[$id]",
2108             "iothreads",
2109         ),
2110         xmlutil.attribute(
2111             "cpu:tuning:emulatorsched:scheduler",
2112             "cputune/emulatorsched",
2113             "scheduler",
2114             ["priority"],
2115         ),
2116         xmlutil.attribute(
2117             "cpu:tuning:emulatorsched:priority", "cputune/emulatorsched", "priority"
2118         ),
2119         xmlutil.attribute(
2120             "cpu:tuning:cachetune:{id}:monitor:{sid}",
2121             "cputune/cachetune[@vcpus='$id']/monitor[@vcpus='$sid']",
2122             "level",
2123             ["vcpus"],
2124         ),
2125         xmlutil.attribute(
2126             "cpu:tuning:memorytune:{id}:{sid}",
2127             "cputune/memorytune[@vcpus='$id']/node[@id='$sid']",
2128             "bandwidth",
2129             ["id", "vcpus"],
2130         ),
2131         xmlutil.attribute("clock:offset", "clock", "offset"),
2132         xmlutil.attribute("clock:adjustment", "clock", "adjustment", convert=str),
2133         xmlutil.attribute("clock:timezone", "clock", "timezone"),
2134     ]
2135 <a name="0"></a>
2136     for timer in timer_names:
2137         params_mapping += [
2138             xmlutil<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.attribute(
2139                 "clock:timers:{}:track".format(timer),
2140                 "clock/timer[@name='{}']".format(timer),
2141                 "track",
2142                 ["name"],
2143             ),
2144             xmlutil.attribute(
2145                 "clock:timers:{}:tickpolicy".format(timer),
2146                 "clock/timer[@name='{}']".format(timer),
2147                 "tickpolicy",
2148                 ["name"],
2149             ),
2150             xmlutil.int_attribute(
2151                 "clock:timers:{}:frequency".format(timer),
2152                 "clock/timer[@name='{}']".format(timer),
2153                 "frequency",
2154                 ["name"],
2155             ),
2156             xmlutil.attribute(
2157                 "clock:timers:{}:mode".format(</b></font>timer),
2158                 "clock/timer[@name='{}']".format(timer),
2159                 "mode",
2160                 ["name"],
2161             ),
2162             _yesno_attribute(
2163                 "clock:timers:{}:present".format(timer),
2164                 "clock/timer[@name='{}']".format(timer),
2165                 "present",
2166                 ["name"],
2167             ),
2168         ]
2169         for attr in ["slew", "threshold", "limit"]:
2170             params_mapping.append(
2171                 xmlutil.int_attribute(
2172                     "clock:timers:{}:{}".format(timer, attr),
2173                     "clock/timer[@name='{}']/catchup".format(timer),
2174                     attr,
2175                 )
2176             )
2177     for attr in ["level", "type", "size"]:
2178         params_mapping.append(
2179             xmlutil.attribute(
2180                 "cpu:tuning:cachetune:{id}:{sid}:" + attr,
2181                 "cputune/cachetune[@vcpus='$id']/cache[@id='$sid']",
2182                 attr,
2183                 ["id", "unit", "vcpus"],
2184             )
2185         )
2186     if hypervisor in ["qemu", "kvm"]:
2187         params_mapping += [
2188             xmlutil.attribute("numatune:memory:mode", "numatune/memory", "mode"),
2189             _cpuset_parameter("numatune:memory:nodeset", "numatune/memory", "nodeset"),
2190             xmlutil.attribute(
2191                 "numatune:memnodes:{id}:mode",
2192                 "numatune/memnode[@cellid='$id']",
2193                 "mode",
2194                 ["cellid"],
2195             ),
2196             _cpuset_parameter(
2197                 "numatune:memnodes:{id}:nodeset",
2198                 "numatune/memnode[@cellid='$id']",
2199                 "nodeset",
2200                 ["cellid"],
2201             ),
2202             xmlutil.attribute(
2203                 "hypervisor_features:kvm-hint-dedicated",
2204                 "features/kvm/hint-dedicated",
2205                 "state",
2206                 convert=lambda v: "on" if v else "off",
2207             ),
2208         ]
2209     need_update = (
2210         salt.utils.xmlutil.change_xml(desc, data, params_mapping) or need_update
2211     )
2212     devices_node = desc.find("devices")
2213     func_locals = locals()
2214     def _skip_update(names):
2215         return all(func_locals.get(n) is None for n in names)
2216     to_skip = {
2217         "disk": _skip_update(["disks", "disk_profile"]),
2218         "interface": _skip_update(["interfaces", "nic_profile"]),
2219         "graphics": _skip_update(["graphics"]),
2220         "serial": _skip_update(["serials"]),
2221         "console": _skip_update(["consoles"]),
2222         "hostdev": _skip_update(["host_devices"]),
2223     }
2224     changes = _compute_device_changes(desc, new_desc, to_skip)
2225     for dev_type in changes:
2226         if not to_skip[dev_type]:
2227             old = devices_node.findall(dev_type)
2228             if changes[dev_type].get("deleted") or changes[dev_type].get("new"):
2229                 for item in old:
2230                     devices_node.remove(item)
2231                 devices_node.extend(changes[dev_type]["sorted"])
2232                 need_update = True
2233     if need_update:
2234         try:
2235             if changes["disk"]:
2236                 for idx, item in enumerate(changes["disk"]["sorted"]):
2237                     source_file = all_disks[idx].get("source_file")
2238                     if all_disks[idx].get("device", "disk") == "cdrom":
2239                         continue
2240                     if (
2241                         item in changes["disk"]["new"]
2242                         and source_file
2243                         and not os.path.exists(source_file)
2244                     ):
2245                         _qemu_image_create(all_disks[idx])
2246                     elif item in changes["disk"]["new"] and not source_file:
2247                         _disk_volume_create(conn, all_disks[idx])
2248             if not test:
2249                 xml_desc = xmlutil.element_to_str(desc)
2250                 log.debug("Update virtual machine definition: %s", xml_desc)
2251                 conn.defineXML(xml_desc)
2252             status["definition"] = True
2253         except libvirt.libvirtError as err:
2254             conn.close()
2255             raise err
2256     if live:
2257         live_status, errors = _update_live(
2258             domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test
2259         )
2260         status.update(live_status)
2261         if errors:
2262             status_errors = status.setdefault("errors", [])
2263             status_errors += errors
2264     conn.close()
2265     return status
2266 def list_domains(**kwargs):
2267     vms = []
2268     conn = __get_conn(**kwargs)
2269     for dom in _get_domain(conn, iterable=True):
2270         vms.append(dom.name())
2271     conn.close()
2272     return vms
2273 def list_active_vms(**kwargs):
2274     vms = []
2275     conn = __get_conn(**kwargs)
2276     for dom in _get_domain(conn, iterable=True, inactive=False):
2277         vms.append(dom.name())
2278     conn.close()
2279     return vms
2280 def list_inactive_vms(**kwargs):
2281     vms = []
2282     conn = __get_conn(**kwargs)
2283     for dom in _get_domain(conn, iterable=True, active=False):
2284         vms.append(dom.name())
2285     conn.close()
2286     return vms
2287 def vm_info(vm_=None, **kwargs):
2288     def _info(conn, dom):
2289         raw = dom.info()
2290         return {
2291             "cpu": raw[3],
2292             "cputime": int(raw[4]),
2293             "disks": _get_disks(conn, dom),
2294             "graphics": _get_graphics(dom),
2295             "nics": _get_nics(dom),
2296             "uuid": _get_uuid(dom),
2297             "loader": _get_loader(dom),
2298             "on_crash": _get_on_crash(dom),
2299             "on_reboot": _get_on_reboot(dom),
2300             "on_poweroff": _get_on_poweroff(dom),
2301             "maxMem": int(raw[1]),
2302             "mem": int(raw[2]),
2303             "state": VIRT_STATE_NAME_MAP.get(raw[0], "unknown"),
2304         }
2305     info = {}
2306     conn = __get_conn(**kwargs)
2307     if vm_:
2308         info[vm_] = _info(conn, _get_domain(conn, vm_))
2309     else:
2310         for domain in _get_domain(conn, iterable=True):
2311             info[domain.name()] = _info(conn, domain)
2312     conn.close()
2313     return info
2314 def vm_state(vm_=None, **kwargs):
2315     def _info(dom):
2316         state = ""
2317         raw = dom.info()
2318         state = VIRT_STATE_NAME_MAP.get(raw[0], "unknown")
2319         return state
2320     info = {}
2321     conn = __get_conn(**kwargs)
2322     if vm_:
2323         info[vm_] = _info(_get_domain(conn, vm_))
2324     else:
2325         for domain in _get_domain(conn, iterable=True):
2326             info[domain.name()] = _info(domain)
2327     conn.close()
2328     return info
2329 def _node_info(conn):
2330     raw = conn.getInfo()
2331     info = {
2332         "cpucores": raw[6],
2333         "cpumhz": raw[3],
2334         "cpumodel": str(raw[0]),
2335         "cpus": raw[2],
2336         "cputhreads": raw[7],
2337         "numanodes": raw[4],
2338         "phymemory": raw[1],
2339         "sockets": raw[5],
2340     }
2341     return info
2342 def node_info(**kwargs):
2343     conn = __get_conn(**kwargs)
2344     info = _node_info(conn)
2345     conn.close()
2346     return info
2347 def _node_devices(conn):
2348     devices = conn.listAllDevices()
2349     devices_infos = []
2350     for dev in devices:
2351         root = ElementTree.fromstring(dev.XMLDesc())
2352         if not set(dev.listCaps()) &amp; {"pci", "usb_device", "net"}:
2353             continue
2354         infos = {
2355             "caps": " ".join(dev.listCaps()),
2356         }
2357         if "net" in dev.listCaps():
2358             parent = root.find(".//parent").text
2359             if parent == "computer":
2360                 continue
2361             infos.update(
2362                 {
2363                     "name": root.find(".//interface").text,
2364                     "address": root.find(".//address").text,
2365                     "device name": parent,
2366                     "state": root.find(".//link").get("state"),
2367                 }
2368             )
2369             devices_infos.append(infos)
2370             continue
2371         vendor_node = root.find(".//vendor")
2372         vendor_id = vendor_node.get("id").lower()
2373         product_node = root.find(".//product")
2374         product_id = product_node.get("id").lower()
2375         infos.update(
2376             {"name": dev.name(), "vendor_id": vendor_id, "product_id": product_id}
2377         )
2378         if vendor_node.text:
2379             infos["vendor"] = vendor_node.text
2380         if product_node.text:
2381             infos["product"] = product_node.text
2382         if "pci" in dev.listCaps():
2383             infos["address"] = "{:04x}:{:02x}:{:02x}.{}".format(
2384                 int(root.find(".//domain").text),
2385                 int(root.find(".//bus").text),
2386                 int(root.find(".//slot").text),
2387                 root.find(".//function").text,
2388             )
2389             class_node = root.find(".//class")
2390             if class_node is not None:
2391                 infos["PCI class"] = class_node.text
2392             vf_addresses = [
2393                 _format_pci_address(vf)
2394                 for vf in root.findall(
2395                     "./capability[@type='pci']/capability[@type='virt_functions']/address"
2396                 )
2397             ]
2398             if vf_addresses:
2399                 infos["virtual functions"] = vf_addresses
2400             pf = root.find(
2401                 "./capability[@type='pci']/capability[@type='phys_function']/address"
2402             )
2403             if pf is not None:
2404                 infos["physical function"] = _format_pci_address(pf)
2405         elif "usb_device" in dev.listCaps():
2406             infos["address"] = "{:03}:{:03}".format(
2407                 int(root.find(".//bus").text), int(root.find(".//device").text)
2408             )
2409         linux_usb_host = vendor_id == "0x1d6b" and product_id in [
2410             "0x0001",
2411             "0x0002",
2412             "0x0003",
2413         ]
2414         if (
2415             root.find(".//capability[@type='pci-bridge']") is None
2416             and not linux_usb_host
2417         ):
2418             devices_infos.append(infos)
2419     return devices_infos
2420 def node_devices(**kwargs):
2421     conn = __get_conn(**kwargs)
2422     devs = _node_devices(conn)
2423     conn.close()
2424     return devs
2425 def get_nics(vm_, **kwargs):
2426     conn = __get_conn(**kwargs)
2427     nics = _get_nics(_get_domain(conn, vm_))
2428     conn.close()
2429     return nics
2430 def get_macs(vm_, **kwargs):
2431     doc = ElementTree.fromstring(get_xml(vm_, **kwargs))
2432     return [node.get("address") for node in doc.findall("devices/interface/mac")]
2433 def get_graphics(vm_, **kwargs):
2434     conn = __get_conn(**kwargs)
2435     graphics = _get_graphics(_get_domain(conn, vm_))
2436     conn.close()
2437     return graphics
2438 def get_loader(vm_, **kwargs):
2439     conn = __get_conn(**kwargs)
2440     try:
2441         loader = _get_loader(_get_domain(conn, vm_))
2442         return loader
2443     finally:
2444         conn.close()
2445 def get_disks(vm_, **kwargs):
2446     conn = __get_conn(**kwargs)
2447     disks = _get_disks(conn, _get_domain(conn, vm_))
2448     conn.close()
2449     return disks
2450 def setmem(vm_, memory, config=False, **kwargs):
2451     conn = __get_conn(**kwargs)
2452     dom = _get_domain(conn, vm_)
2453     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
2454         return False
2455     flags = libvirt.VIR_DOMAIN_MEM_MAXIMUM
2456     if config:
2457         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
2458     ret1 = dom.setMemoryFlags(memory * 1024, flags)
2459     ret2 = dom.setMemoryFlags(memory * 1024, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
2460     conn.close()
2461     return ret1 == ret2 == 0
2462 def setvcpus(vm_, vcpus, config=False, **kwargs):
2463     conn = __get_conn(**kwargs)
2464     dom = _get_domain(conn, vm_)
2465     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
2466         return False
2467     flags = libvirt.VIR_DOMAIN_VCPU_MAXIMUM
2468     if config:
2469         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
2470     ret1 = dom.setVcpusFlags(vcpus, flags)
2471     ret2 = dom.setVcpusFlags(vcpus, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
2472     conn.close()
2473     return ret1 == ret2 == 0
2474 def _freemem(conn):
2475     mem = conn.getInfo()[1]
2476     mem -= 256
2477     for dom in _get_domain(conn, iterable=True):
2478         if dom.ID() &gt; 0:
2479             mem -= dom.info()[2] / 1024
2480     return mem
2481 def freemem(**kwargs):
2482     conn = __get_conn(**kwargs)
2483     mem = _freemem(conn)
2484     conn.close()
2485     return mem
2486 def _freecpu(conn):
2487     cpus = conn.getInfo()[2]
2488     for dom in _get_domain(conn, iterable=True):
2489         if dom.ID() &gt; 0:
2490             cpus -= dom.info()[3]
2491     return cpus
2492 def freecpu(**kwargs):
2493     conn = __get_conn(**kwargs)
2494     cpus = _freecpu(conn)
2495     conn.close()
2496     return cpus
2497 def full_info(**kwargs):
2498     conn = __get_conn(**kwargs)
2499     info = {
2500         "freecpu": _freecpu(conn),
2501         "freemem": _freemem(conn),
2502         "node_info": _node_info(conn),
2503         "vm_info": vm_info(),
2504     }
2505     conn.close()
2506     return info
2507 def get_xml(vm_, **kwargs):
2508     conn = __get_conn(**kwargs)
2509     xml_desc = (
2510         vm_.XMLDesc(0)
2511         if isinstance(vm_, libvirt.virDomain)
2512         else _get_domain(conn, vm_).XMLDesc(0)
2513     )
2514     conn.close()
2515     return xml_desc
2516 def get_profiles(hypervisor=None, **kwargs):
2517     conn = __get_conn(**kwargs)
2518     caps = _capabilities(conn)
2519     hypervisors = sorted(
2520         {
2521             x
2522             for y in [guest["arch"]["domains"].keys() for guest in caps["guests"]]
2523             for x in y
2524         }
2525     )
2526     if len(hypervisors) == 0:
2527         raise SaltInvocationError("No supported hypervisors were found")
2528     if not hypervisor:
2529         hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
2530     ret = {
2531         "disk": {"default": _disk_profile(conn, "default", hypervisor, [], None)},
2532         "nic": {"default": _nic_profile("default", hypervisor)},
2533     }
2534     virtconf = __salt__["config.get"]("virt", {})
2535     for profile in virtconf.get("disk", []):
2536         ret["disk"][profile] = _disk_profile(conn, profile, hypervisor, [], None)
2537     for profile in virtconf.get("nic", []):
2538         ret["nic"][profile] = _nic_profile(profile, hypervisor)
2539     return ret
2540 def shutdown(vm_, **kwargs):
2541     conn = __get_conn(**kwargs)
2542     dom = _get_domain(conn, vm_)
2543     ret = dom.shutdown() == 0
2544     conn.close()
2545     return ret
2546 def pause(vm_, **kwargs):
2547     conn = __get_conn(**kwargs)
2548     dom = _get_domain(conn, vm_)
2549     ret = dom.suspend() == 0
2550     conn.close()
2551     return ret
2552 def resume(vm_, **kwargs):
2553     conn = __get_conn(**kwargs)
2554     dom = _get_domain(conn, vm_)
2555     ret = dom.resume() == 0
2556     conn.close()
2557     return ret
2558 def start(name, **kwargs):
2559     conn = __get_conn(**kwargs)
2560     ret = _get_domain(conn, name).create() == 0
2561     conn.close()
2562     return ret
2563 def stop(name, **kwargs):
2564     conn = __get_conn(**kwargs)
2565     ret = _get_domain(conn, name).destroy() == 0
2566     conn.close()
2567     return ret
2568 def reboot(name, **kwargs):
2569     conn = __get_conn(**kwargs)
2570     ret = _get_domain(conn, name).reboot(libvirt.VIR_DOMAIN_REBOOT_DEFAULT) == 0
2571     conn.close()
2572     return ret
2573 def reset(vm_, **kwargs):
2574     conn = __get_conn(**kwargs)
2575     dom = _get_domain(conn, vm_)
2576     ret = dom.reset(0) == 0
2577     conn.close()
2578     return ret
2579 def ctrl_alt_del(vm_, **kwargs):
2580     conn = __get_conn(**kwargs)
2581     dom = _get_domain(conn, vm_)
2582     ret = dom.sendKey(0, 0, [29, 56, 111], 3, 0) == 0
2583     conn.close()
2584     return ret
2585 def create_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
2586     conn = __get_conn(**kwargs)
2587     ret = conn.createXML(xml, 0) is not None
2588     conn.close()
2589     return ret
2590 def create_xml_path(path, **kwargs):
2591     try:
2592         with salt.utils.files.fopen(path, "r") as fp_:
2593             return create_xml_str(
2594                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
2595             )
2596     except OSError:
2597         return False
2598 def define_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
2599     conn = __get_conn(**kwargs)
2600     ret = conn.defineXML(xml) is not None
2601     conn.close()
2602     return ret
2603 def define_xml_path(path, **kwargs):
2604     try:
2605         with salt.utils.files.fopen(path, "r") as fp_:
2606             return define_xml_str(
2607                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
2608             )
2609     except OSError:
2610         return False
2611 def _define_vol_xml_str(conn, xml, pool=None):  # pylint: disable=redefined-outer-name
2612     default_pool = "default" if conn.getType() != "ESX" else "0"
2613     poolname = (
2614         pool if pool else __salt__["config.get"]("virt:storagepool", default_pool)
2615     )
2616     pool = conn.storagePoolLookupByName(str(poolname))
2617     ret = pool.createXML(xml, 0) is not None
2618     return ret
2619 def define_vol_xml_str(
2620     xml, pool=None, **kwargs
2621 ):  # pylint: disable=redefined-outer-name
2622     conn = __get_conn(**kwargs)
2623     ret = False
2624     try:
2625         ret = _define_vol_xml_str(conn, xml, pool=pool)
2626     except libvirtError as err:
2627         raise CommandExecutionError(err.get_error_message())
2628     finally:
2629         conn.close()
2630     return ret
2631 def define_vol_xml_path(path, pool=None, **kwargs):
2632     try:
2633         with salt.utils.files.fopen(path, "r") as fp_:
2634             return define_vol_xml_str(
2635                 salt.utils.stringutils.to_unicode(fp_.read()), pool=pool, **kwargs
2636             )
2637     except OSError:
2638         return False
2639 def migrate(vm_, target, **kwargs):
2640     conn = __get_conn()
2641     dom = _get_domain(conn, vm_)
2642     if not urllib.parse.urlparse(target).scheme:
2643         proto = "qemu"
2644         dst_uri = "{}://{}/system".format(proto, target)
2645     else:
2646         dst_uri = target
2647     ret = _migrate(dom, dst_uri, **kwargs)
2648     conn.close()
2649     return ret
2650 def migrate_start_postcopy(vm_):
2651     conn = __get_conn()
2652     dom = _get_domain(conn, vm_)
2653     try:
2654         dom.migrateStartPostCopy()
2655     except libvirt.libvirtError as err:
2656         conn.close()
2657         raise CommandExecutionError(err.get_error_message())
2658     conn.close()
2659 def seed_non_shared_migrate(disks, force=False):
2660     for _, data in disks.items():
2661         fn_ = data["file"]
2662         form = data["file format"]
2663         size = data["virtual size"].split()[1][1:]
2664         if os.path.isfile(fn_) and not force:
2665             pre = salt.utils.yaml.safe_load(
2666                 subprocess.Popen(
2667                     ["qemu-img", "info", "arch"], stdout=subprocess.PIPE
2668                 ).communicate()[0]
2669             )
2670             if (
2671                 pre["file format"] != data["file format"]
2672                 and pre["virtual size"] != data["virtual size"]
2673             ):
2674                 return False
2675         if not os.path.isdir(os.path.dirname(fn_)):
2676             os.makedirs(os.path.dirname(fn_))
2677         if os.path.isfile(fn_):
2678             os.remove(fn_)
2679         subprocess.call(["qemu-img", "create", "-f", form, fn_, size])
2680         creds = _libvirt_creds()
2681         subprocess.call(["chown", "{user}:{group}".format(**creds), fn_])
2682     return True
2683 def set_autostart(vm_, state="on", **kwargs):
2684     conn = __get_conn(**kwargs)
2685     dom = _get_domain(conn, vm_)
2686     ret = False
2687     if state == "on":
2688         ret = dom.setAutostart(1) == 0
2689     elif state == "off":
2690         ret = dom.setAutostart(0) == 0
2691     conn.close()
2692     return ret
2693 def undefine(vm_, **kwargs):
2694     conn = __get_conn(**kwargs)
2695     dom = _get_domain(conn, vm_)
2696     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
2697         ret = dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM) == 0
2698     else:
2699         ret = dom.undefine() == 0
2700     conn.close()
2701     return ret
2702 def purge(vm_, dirs=False, removables=False, **kwargs):
2703     conn = __get_conn(**kwargs)
2704     dom = _get_domain(conn, vm_)
2705     disks = _get_disks(conn, dom)
2706     if (
2707         VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown"
2708         and dom.destroy() != 0
2709     ):
2710         return False
2711     directories = set()
2712     for disk in disks:
2713         if not removables and disks[disk]["type"] in ["cdrom", "floppy"]:
2714             continue
2715         if disks[disk].get("zfs", False):
2716             time.sleep(3)
2717             fs_name = disks[disk]["file"][len("/dev/zvol/") :]
2718             log.info("Destroying VM ZFS volume %s", fs_name)
2719             __salt__["zfs.destroy"](name=fs_name, force=True)
2720         elif os.path.exists(disks[disk]["file"]):
2721             os.remove(disks[disk]["file"])
2722             directories.add(os.path.dirname(disks[disk]["file"]))
2723         else:
2724             matcher = re.match("^(?P&lt;pool&gt;[^/]+)/(?P&lt;volume&gt;.*)$", disks[disk]["file"])
2725             if matcher:
2726                 pool_name = matcher.group("pool")
2727                 pool = None
2728                 if pool_name in conn.listStoragePools():
2729                     pool = conn.storagePoolLookupByName(pool_name)
2730                 if pool and matcher.group("volume") in pool.listVolumes():
2731                     volume = pool.storageVolLookupByName(matcher.group("volume"))
2732                     volume.delete()
2733     if dirs:
2734         for dir_ in directories:
2735             shutil.rmtree(dir_)
2736     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
2737         try:
2738             dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM)
2739         except Exception:  # pylint: disable=broad-except
2740             dom.undefine()
2741     else:
2742         dom.undefine()
2743     conn.close()
2744     return True
2745 def virt_type():
2746     return __grains__["virtual"]
2747 def _is_kvm_hyper():
2748     if not os.path.exists("/dev/kvm"):
2749         return False
2750     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
2751 def _is_xen_hyper():
2752     try:
2753         if __grains__["virtual_subtype"] != "Xen Dom0":
2754             return False
2755     except KeyError:
2756         return False
2757     try:
2758         with salt.utils.files.fopen("/proc/modules") as fp_:
2759             if "xen_" not in salt.utils.stringutils.to_unicode(fp_.read()):
2760                 return False
2761     except OSError:
2762         return False
2763     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
2764 def get_hypervisor():
2765     hypervisors = ["kvm", "xen", "bhyve"]
2766     result = [
2767         hyper
2768         for hyper in hypervisors
2769         if getattr(sys.modules[__name__], "_is_{}_hyper".format(hyper))()
2770     ]
2771     return result[0] if result else None
2772 def _is_bhyve_hyper():
2773     sysctl_cmd = "sysctl hw.vmm.create"
2774     vmm_enabled = False
2775     try:
2776         stdout = subprocess.Popen(
2777             ["sysctl", "hw.vmm.create"], stdout=subprocess.PIPE
2778         ).communicate()[0]
2779         vmm_enabled = len(salt.utils.stringutils.to_str(stdout).split('"')[1]) != 0
2780     except IndexError:
2781         pass
2782     return vmm_enabled
2783 def is_hyper():
2784     if HAS_LIBVIRT:
2785         return _is_xen_hyper() or _is_kvm_hyper() or _is_bhyve_hyper()
2786     return False
2787 def vm_cputime(vm_=None, **kwargs):
2788     conn = __get_conn(**kwargs)
2789     host_cpus = conn.getInfo()[2]
2790     def _info(dom):
2791         raw = dom.info()
2792         vcpus = int(raw[3])
2793         cputime = int(raw[4])
2794         cputime_percent = 0
2795         if cputime:
2796             cputime_percent = (1.0e-7 * cputime / host_cpus) / vcpus
2797         return {
2798             "cputime": int(raw[4]),
2799             "cputime_percent": int("{:.0f}".format(cputime_percent)),
2800         }
2801     info = {}
2802     if vm_:
2803         info[vm_] = _info(_get_domain(conn, vm_))
2804     else:
2805         for domain in _get_domain(conn, iterable=True):
2806             info[domain.name()] = _info(domain)
2807     conn.close()
2808     return info
2809 def vm_netstats(vm_=None, **kwargs):
2810     def _info(dom):
2811         nics = _get_nics(dom)
2812         ret = {
2813             "rx_bytes": 0,
2814             "rx_packets": 0,
2815             "rx_errs": 0,
2816             "rx_drop": 0,
2817             "tx_bytes": 0,
2818             "tx_packets": 0,
2819             "tx_errs": 0,
2820             "tx_drop": 0,
2821         }
2822         for attrs in nics.values():
2823             if "target" in attrs:
2824                 dev = attrs["target"]
2825                 stats = dom.interfaceStats(dev)
2826                 ret["rx_bytes"] += stats[0]
2827                 ret["rx_packets"] += stats[1]
2828                 ret["rx_errs"] += stats[2]
2829                 ret["rx_drop"] += stats[3]
2830                 ret["tx_bytes"] += stats[4]
2831                 ret["tx_packets"] += stats[5]
2832                 ret["tx_errs"] += stats[6]
2833                 ret["tx_drop"] += stats[7]
2834         return ret
2835     info = {}
2836     conn = __get_conn(**kwargs)
2837     if vm_:
2838         info[vm_] = _info(_get_domain(conn, vm_))
2839     else:
2840         for domain in _get_domain(conn, iterable=True):
2841             info[domain.name()] = _info(domain)
2842     conn.close()
2843     return info
2844 def vm_diskstats(vm_=None, **kwargs):
2845     def get_disk_devs(dom):
2846         doc = ElementTree.fromstring(get_xml(dom, **kwargs))
2847         return [target.get("dev") for target in doc.findall("devices/disk/target")]
2848     def _info(dom):
2849         disks = get_disk_devs(dom)
2850         ret = {"rd_req": 0, "rd_bytes": 0, "wr_req": 0, "wr_bytes": 0, "errs": 0}
2851         for disk in disks:
2852             stats = dom.blockStats(disk)
2853             ret["rd_req"] += stats[0]
2854             ret["rd_bytes"] += stats[1]
2855             ret["wr_req"] += stats[2]
2856             ret["wr_bytes"] += stats[3]
2857             ret["errs"] += stats[4]
2858         return ret
2859     info = {}
2860     conn = __get_conn(**kwargs)
2861     if vm_:
2862         info[vm_] = _info(_get_domain(conn, vm_))
2863     else:
2864         for domain in _get_domain(conn, iterable=True, inactive=False):
2865             info[domain.name()] = _info(domain)
2866     conn.close()
2867     return info
2868 def _parse_snapshot_description(vm_snapshot, unix_time=False):
2869     ret = dict()
2870     tree = ElementTree.fromstring(vm_snapshot.getXMLDesc())
2871     for node in tree:
2872         if node.tag == "name":
2873             ret["name"] = node.text
2874         elif node.tag == "creationTime":
2875             ret["created"] = (
2876                 datetime.datetime.fromtimestamp(float(node.text)).isoformat(" ")
2877                 if not unix_time
2878                 else float(node.text)
2879             )
2880         elif node.tag == "state":
2881             ret["running"] = node.text == "running"
2882     ret["current"] = vm_snapshot.isCurrent() == 1
2883     return ret
2884 def list_snapshots(domain=None, **kwargs):
2885     ret = dict()
2886     conn = __get_conn(**kwargs)
2887     for vm_domain in _get_domain(conn, *(domain and [domain] or list()), iterable=True):
2888         ret[vm_domain.name()] = [
2889             _parse_snapshot_description(snap) for snap in vm_domain.listAllSnapshots()
2890         ] or "N/A"
2891     conn.close()
2892     return ret
2893 def snapshot(domain, name=None, suffix=None, **kwargs):
2894     if name and name.lower() == domain.lower():
2895         raise CommandExecutionError(
2896             "Virtual Machine {name} is already defined. "
2897             "Please choose another name for the snapshot".format(name=name)
2898         )
2899     if not name:
2900         name = "{domain}-{tsnap}".format(
2901             domain=domain, tsnap=time.strftime("%Y%m%d-%H%M%S", time.localtime())
2902         )
2903     if suffix:
2904         name = "{name}-{suffix}".format(name=name, suffix=suffix)
2905     doc = ElementTree.Element("domainsnapshot")
2906     n_name = ElementTree.SubElement(doc, "name")
2907     n_name.text = name
2908     conn = __get_conn(**kwargs)
2909     _get_domain(conn, domain).snapshotCreateXML(xmlutil.element_to_str(doc))
2910     conn.close()
2911     return {"name": name}
2912 def delete_snapshots(name, *names, **kwargs):
2913     deleted = dict()
2914     conn = __get_conn(**kwargs)
2915     domain = _get_domain(conn, name)
2916     for snap in domain.listAllSnapshots():
2917         if snap.getName() in names or not names:
2918             deleted[snap.getName()] = _parse_snapshot_description(snap)
2919             snap.delete()
2920     conn.close()
2921     available = {
2922         name: [_parse_snapshot_description(snap) for snap in domain.listAllSnapshots()]
2923         or "N/A"
2924     }
2925     return {"available": available, "deleted": deleted}
2926 def revert_snapshot(name, vm_snapshot=None, cleanup=False, **kwargs):
2927     ret = dict()
2928     conn = __get_conn(**kwargs)
2929     domain = _get_domain(conn, name)
2930     snapshots = domain.listAllSnapshots()
2931     _snapshots = list()
2932     for snap_obj in snapshots:
2933         _snapshots.append(
2934             {
2935                 "idx": _parse_snapshot_description(snap_obj, unix_time=True)["created"],
2936                 "ptr": snap_obj,
2937             }
2938         )
2939     snapshots = [
2940         w_ptr["ptr"]
2941         for w_ptr in sorted(_snapshots, key=lambda item: item["idx"], reverse=True)
2942     ]
2943     del _snapshots
2944     if not snapshots:
2945         conn.close()
2946         raise CommandExecutionError("No snapshots found")
2947     elif len(snapshots) == 1:
2948         conn.close()
2949         raise CommandExecutionError(
2950             "Cannot revert to itself: only one snapshot is available."
2951         )
2952     snap = None
2953     for p_snap in snapshots:
2954         if not vm_snapshot:
2955             if p_snap.isCurrent() and snapshots[snapshots.index(p_snap) + 1 :]:
2956                 snap = snapshots[snapshots.index(p_snap) + 1 :][0]
2957                 break
2958         elif p_snap.getName() == vm_snapshot:
2959             snap = p_snap
2960             break
2961     if not snap:
2962         conn.close()
2963         raise CommandExecutionError(
2964             snapshot
2965             and 'Snapshot "{}" not found'.format(vm_snapshot)
2966             or "No more previous snapshots available"
2967         )
2968     elif snap.isCurrent():
2969         conn.close()
2970         raise CommandExecutionError("Cannot revert to the currently running snapshot.")
2971     domain.revertToSnapshot(snap)
2972     ret["reverted"] = snap.getName()
2973     if cleanup:
2974         delete = list()
2975         for p_snap in snapshots:
2976             if p_snap.getName() != snap.getName():
2977                 delete.append(p_snap.getName())
2978                 p_snap.delete()
2979             else:
2980                 break
2981         ret["deleted"] = delete
2982     else:
2983         ret["deleted"] = "N/A"
2984     conn.close()
2985     return ret
2986 def _caps_add_machine(machines, node):
2987     maxcpus = node.get("maxCpus")
2988     canonical = node.get("canonical")
2989     name = node.text
2990     alternate_name = ""
2991     if canonical:
2992         alternate_name = name
2993         name = canonical
2994     machine = machines.get(name)
2995     if not machine:
2996         machine = {"alternate_names": []}
2997         if maxcpus:
2998             machine["maxcpus"] = int(maxcpus)
2999         machines[name] = machine
3000     if alternate_name:
3001         machine["alternate_names"].append(alternate_name)
3002 def _parse_caps_guest(guest):
3003     arch_node = guest.find("arch")
3004     result = {
3005         "os_type": guest.find("os_type").text,
3006         "arch": {"name": arch_node.get("name"), "machines": {}, "domains": {}},
3007     }
3008     child = None
3009     for child in arch_node:
3010         if child.tag == "wordsize":
3011             result["arch"]["wordsize"] = int(child.text)
3012         elif child.tag == "emulator":
3013             result["arch"]["emulator"] = child.text
3014         elif child.tag == "machine":
3015             _caps_add_machine(result["arch"]["machines"], child)
3016         elif child.tag == "domain":
3017             domain_type = child.get("type")
3018             domain = {"emulator": None, "machines": {}}
3019             emulator_node = child.find("emulator")
3020             if emulator_node is not None:
3021                 domain["emulator"] = emulator_node.text
3022             for machine in child.findall("machine"):
3023                 _caps_add_machine(domain["machines"], machine)
3024             result["arch"]["domains"][domain_type] = domain
3025     features_nodes = guest.find("features")
3026     if features_nodes is not None and child is not None:
3027         result["features"] = {
3028             child.tag: {
3029                 "toggle": child.get("toggle", "no") == "yes",
3030                 "default": child.get("default", "on") == "on",
3031             }
3032             for child in features_nodes
3033         }
3034     return result
3035 def _parse_caps_cell(cell):
3036     result = {"id": int(cell.get("id"))}
3037     mem_node = cell.find("memory")
3038     if mem_node is not None:
3039         unit = mem_node.get("unit", "KiB")
3040         memory = mem_node.text
3041         result["memory"] = "{} {}".format(memory, unit)
3042     pages = [
3043         {
3044             "size": "{} {}".format(page.get("size"), page.get("unit", "KiB")),
3045             "available": int(page.text),
3046         }
3047         for page in cell.findall("pages")
3048     ]
3049     if pages:
3050         result["pages"] = pages
3051     distances = {
3052         int(distance.get("id")): int(distance.get("value"))
3053         for distance in cell.findall("distances/sibling")
3054     }
3055     if distances:
3056         result["distances"] = distances
3057     cpus = []
3058     for cpu_node in cell.findall("cpus/cpu"):
3059         cpu = {"id": int(cpu_node.get("id"))}
3060         socket_id = cpu_node.get("socket_id")
3061         if socket_id:
3062             cpu["socket_id"] = int(socket_id)
3063         core_id = cpu_node.get("core_id")
3064         if core_id:
3065             cpu["core_id"] = int(core_id)
3066         siblings = cpu_node.get("siblings")
3067         if siblings:
3068             cpu["siblings"] = siblings
3069         cpus.append(cpu)
3070     if cpus:
3071         result["cpus"] = cpus
3072     return result
3073 def _parse_caps_bank(bank):
3074     result = {
3075         "id": int(bank.get("id")),
3076         "level": int(bank.get("level")),
3077         "type": bank.get("type"),
3078         "size": "{} {}".format(bank.get("size"), bank.get("unit")),
3079         "cpus": bank.get("cpus"),
3080 <a name="10"></a>    }
3081     controls = []
3082     for control in bank<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("control"):
3083         unit = control.get("unit")
3084         result_control = {
3085             "granularity": "{} {}".format(control.get("granularity"), unit),
3086             "type": control.</b></font>get("type"),
3087             "maxAllocs": int(control.get("maxAllocs")),
3088         }
3089         minimum = control.get("min")
3090         if minimum:
3091             result_control["min"] = "{} {}".format(minimum, unit)
3092         controls.append(result_control)
3093     if controls:
3094         result["controls"] = controls
3095     return result
3096 def _parse_caps_host(host):
3097     result = {}
3098     for child in host:
3099         if child.tag == "uuid":
3100             result["uuid"] = child.text
3101         elif child.tag == "cpu":
3102             cpu = {
3103                 "arch": child.find("arch").text
3104                 if child.find("arch") is not None
3105                 else None,
3106                 "model": child.find("model").text
3107                 if child.find("model") is not None
3108                 else None,
3109                 "vendor": child.find("vendor").text
3110                 if child.find("vendor") is not None
3111                 else None,
3112                 "features": [
3113                     feature.get("name") for feature in child.findall("feature")
3114                 ],
3115                 "pages": [
3116                     {"size": "{} {}".format(page.get("size"), page.get("unit", "KiB"))}
3117                     for page in child.findall("pages")
3118                 ],
3119             }
3120             microcode = child.find("microcode")
3121             if microcode is not None:
3122                 cpu["microcode"] = microcode.get("version")
3123             topology = child.find("topology")
3124             if topology is not None:
3125                 cpu["sockets"] = int(topology.get("sockets"))
3126                 cpu["cores"] = int(topology.get("cores"))
3127                 cpu["threads"] = int(topology.get("threads"))
3128             result["cpu"] = cpu
3129         elif child.tag == "power_management":
3130             result["power_management"] = [node.tag for node in child]
3131         elif child.tag == "migration_features":
3132             result["migration"] = {
3133                 "live": child.find("live") is not None,
3134                 "transports": [
3135                     node.text for node in child.findall("uri_transports/uri_transport")
3136                 ],
3137             }
3138         elif child.tag == "topology":
3139             result["topology"] = {
3140                 "cells": [
3141                     _parse_caps_cell(cell) for cell in child.findall("cells/cell")
3142                 ]
3143             }
3144         elif child.tag == "cache":
3145             result["cache"] = {
3146                 "banks": [_parse_caps_bank(bank) for bank in child.findall("bank")]
3147             }
3148     result["security"] = [
3149         {
3150             "model": secmodel.find("model").text
3151             if secmodel.find("model") is not None
3152             else None,
3153             "doi": secmodel.find("doi").text
3154             if secmodel.find("doi") is not None
3155             else None,
3156             "baselabels": [
3157                 {"type": label.get("type"), "label": label.text}
3158                 for label in secmodel.findall("baselabel")
3159             ],
3160         }
3161         for secmodel in host.findall("secmodel")
3162     ]
3163     return result
3164 def _capabilities(conn):
3165     caps = ElementTree.fromstring(conn.getCapabilities())
3166     return {
3167         "host": _parse_caps_host(caps.find("host")),
3168         "guests": [_parse_caps_guest(guest) for guest in caps.findall("guest")],
3169     }
3170 def capabilities(**kwargs):
3171     conn = __get_conn(**kwargs)
3172     try:
3173         caps = _capabilities(conn)
3174     except libvirt.libvirtError as err:
3175         raise CommandExecutionError(str(err))
3176     finally:
3177         conn.close()
3178     return caps
3179 def _parse_caps_enum(node):
3180     return (node.get("name"), [value.text for value in node.findall("value")])
3181 def _parse_caps_cpu(node):
3182     result = {}
3183     for mode in node.findall("mode"):
3184         if not mode.get("supported") == "yes":
3185             continue
3186         name = mode.get("name")
3187         if name == "host-passthrough":
3188             result[name] = True
3189         elif name == "host-model":
3190             host_model = {}
3191             model_node = mode.find("model")
3192             if model_node is not None:
3193                 model = {"name": model_node.text}
3194                 vendor_id = model_node.get("vendor_id")
3195                 if vendor_id:
3196                     model["vendor_id"] = vendor_id
3197                 fallback = model_node.get("fallback")
3198                 if fallback:
3199                     model["fallback"] = fallback
3200                 host_model["model"] = model
3201             vendor = (
3202                 mode.find("vendor").text if mode.find("vendor") is not None else None
3203             )
3204             if vendor:
3205                 host_model["vendor"] = vendor
3206             features = {
3207                 feature.get("name"): feature.get("policy")
3208                 for feature in mode.findall("feature")
3209             }
3210             if features:
3211                 host_model["features"] = features
3212             result[name] = host_model
3213         elif name == "custom":
3214             custom_model = {}
3215             models = {
3216                 model.text: model.get("usable") for model in mode.findall("model")
3217             }
3218             if models:
3219                 custom_model["models"] = models
3220             result[name] = custom_model
3221     return result
3222 def _parse_caps_devices_features(node):
3223     result = {}
3224     for child in node:
3225         if child.get("supported") == "yes":
3226             enums = [_parse_caps_enum(node) for node in child.findall("enum")]
3227             result[child.tag] = {item[0]: item[1] for item in enums if item[0]}
3228     return result
3229 def _parse_caps_loader(node):
3230     enums = [_parse_caps_enum(enum) for enum in node.findall("enum")]
3231     result = {item[0]: item[1] for item in enums if item[0]}
3232     values = [child.text for child in node.findall("value")]
3233     if values:
3234         result["values"] = values
3235     return result
3236 def _parse_domain_caps(caps):
3237     result = {
3238         "emulator": caps.find("path").text if caps.find("path") is not None else None,
3239         "domain": caps.find("domain").text if caps.find("domain") is not None else None,
3240         "machine": caps.find("machine").text
3241         if caps.find("machine") is not None
3242         else None,
3243         "arch": caps.find("arch").text if caps.find("arch") is not None else None,
3244     }
3245     for child in caps:
3246         if child.tag == "vcpu" and child.get("max"):
3247             result["max_vcpus"] = int(child.get("max"))
3248         elif child.tag == "iothreads":
3249             result["iothreads"] = child.get("supported") == "yes"
3250         elif child.tag == "os":
3251             result["os"] = {}
3252             loader_node = child.find("loader")
3253             if loader_node is not None and loader_node.get("supported") == "yes":
3254                 loader = _parse_caps_loader(loader_node)
3255                 result["os"]["loader"] = loader
3256         elif child.tag == "cpu":
3257             cpu = _parse_caps_cpu(child)
3258             if cpu:
3259                 result["cpu"] = cpu
3260         elif child.tag == "devices":
3261             devices = _parse_caps_devices_features(child)
3262             if devices:
3263                 result["devices"] = devices
3264         elif child.tag == "features":
3265             features = _parse_caps_devices_features(child)
3266             if features:
3267                 result["features"] = features
3268     return result
3269 def domain_capabilities(emulator=None, arch=None, machine=None, domain=None, **kwargs):
3270     conn = __get_conn(**kwargs)
3271     result = []
3272     try:
3273         caps = ElementTree.fromstring(
3274             conn.getDomainCapabilities(emulator, arch, machine, domain, 0)
3275         )
3276         result = _parse_domain_caps(caps)
3277     finally:
3278         conn.close()
3279     return result
3280 def all_capabilities(**kwargs):
3281     conn = __get_conn(**kwargs)
3282     try:
3283         host_caps = ElementTree.fromstring(conn.getCapabilities())
3284         domains = [
3285             [
3286                 (
3287                     guest.get("arch", {}).get("name", None),
3288                     key,
3289                     guest.get("arch", {}).get("emulator", None),
3290                 )
3291                 for key in guest.get("arch", {}).get("domains", {}).keys()
3292             ]
3293             for guest in [
3294                 _parse_caps_guest(guest) for guest in host_caps.findall("guest")
3295             ]
3296         ]
3297         flattened = [pair for item in (x for x in domains) for pair in item]
3298         result = {
3299             "host": {
3300                 "host": _parse_caps_host(host_caps.find("host")),
3301                 "guests": [
3302                     _parse_caps_guest(guest) for guest in host_caps.findall("guest")
3303                 ],
3304             },
3305             "domains": [
3306                 _parse_domain_caps(
3307                     ElementTree.fromstring(
3308                         conn.getDomainCapabilities(emulator, arch, None, domain)
3309                     )
3310                 )
3311                 for (arch, domain, emulator) in flattened
3312             ],
3313         }
3314         return result
3315     finally:
3316         conn.close()
3317 def cpu_baseline(full=False, migratable=False, out="libvirt", **kwargs):
3318     conn = __get_conn(**kwargs)
3319     caps = ElementTree<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.fromstring(conn.getCapabilities())
3320     cpu = caps.find("host/cpu")
3321     host_cpu_def = xmlutil.element_to_str(cpu)
3322     log.debug("Host CPU model definition: %s", host_cpu_def)
3323     flags =</b></font> 0
3324     if migratable:
3325         if getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_MIGRATABLE", False):
3326             flags += libvirt.VIR_CONNECT_BASELINE_CPU_MIGRATABLE
3327         else:
3328             conn.close()
3329             raise ValueError
3330     if full and getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
3331         flags += libvirt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES
3332     cpu = ElementTree.fromstring(conn.baselineCPU([host_cpu_def], flags))
3333     conn.close()
3334     if full and not getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
3335         with salt.utils.files.fopen("/usr/share/libvirt/cpu_map.xml", "r") as cpu_map:
3336             cpu_map = ElementTree.parse(cpu_map)
3337         cpu_model = cpu.find("model").text
3338         while cpu_model:
3339             cpu_map_models = cpu_map.findall("arch/model")
3340             cpu_specs = [
3341                 el
3342                 for el in cpu_map_models
3343                 if el.get("name") == cpu_model and bool(len(el))
3344             ]
3345             if not cpu_specs:
3346                 raise ValueError("Model {} not found in CPU map".format(cpu_model))
3347             elif len(cpu_specs) &gt; 1:
3348                 raise ValueError(
3349                     "Multiple models {} found in CPU map".format(cpu_model)
3350                 )
3351             cpu_specs = cpu_specs[0]
3352             model_node = cpu_specs.find("model")
3353             if model_node is None:
3354                 cpu_model = None
3355             else:
3356                 cpu_model = model_node.get("name")
3357             cpu.extend([feature for feature in cpu_specs.findall("feature")])
3358     if out == "salt":
3359         return {
3360             "model": cpu.find("model").text,
3361             "vendor": cpu.find("vendor").text,
3362             "features": [feature.get("name") for feature in cpu.findall("feature")],
3363         }
3364     return ElementTree.tostring(cpu)
3365 def network_define(
3366     name,
3367     bridge,
3368     forward,
3369     ipv4_config=None,
3370     ipv6_config=None,
3371     vport=None,
3372     tag=None,
3373     autostart=True,
3374     start=True,
3375     mtu=None,
3376     domain=None,
3377     nat=None,
3378     interfaces=None,
3379     addresses=None,
3380     physical_function=None,
3381     dns=None,
3382     **kwargs
3383 ):
3384     conn = __get_conn(**kwargs)
3385     vport = kwargs.get("vport", None)
3386     tag = kwargs.get("tag", None)
3387     net_xml = _gen_net_xml(
3388         name,
3389         bridge,
3390         forward,
3391         vport,
3392         tag=tag,
3393         ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
3394         mtu=mtu,
3395         domain=domain,
3396         nat=nat,
3397         interfaces=interfaces,
3398         addresses=addresses,
3399         physical_function=physical_function,
3400         dns=dns,
3401     )
3402     try:
3403         conn.networkDefineXML(net_xml)
3404     except libvirt.libvirtError as err:
3405         log.warning(err)
3406         conn.close()
3407         raise err  # a real error we should report upwards
3408     try:
3409         network = conn.networkLookupByName(name)
3410     except libvirt.libvirtError as err:
3411         log.warning(err)
3412         conn.close()
3413         raise err  # a real error we should report upwards
3414     if network is None:
3415         conn.close()
3416         return False
3417     if (start or autostart) and network.isActive() != 1:
3418         network.create()
3419     if autostart and network.autostart() != 1:
3420         network.setAutostart(int(autostart))
3421     elif not autostart and network.autostart() == 1:
3422         network.setAutostart(int(autostart))
3423     conn.close()
3424     return True
3425 def _remove_empty_xml_node(node):
3426     for child in node:
3427         if not child.tail and not child.text and not child.items() and not child:
3428             node.remove(child)
3429         else:
3430             _remove_empty_xml_node(child)
3431     return node
3432 def network_update(
3433     name,
3434     bridge,
3435     forward,
3436     ipv4_config=None,
3437     ipv6_config=None,
3438     vport=None,
3439     tag=None,
3440     mtu=None,
3441     domain=None,
3442     nat=None,
3443     interfaces=None,
3444     addresses=None,
3445     physical_function=None,
3446     dns=None,
3447     test=False,
3448     **kwargs
3449 ):
3450     conn = __get_conn(**kwargs)
3451     needs_update = False
3452     try:
3453         net = conn.networkLookupByName(name)
3454         old_xml = ElementTree.fromstring(net.XMLDesc())
3455         new_xml = ElementTree.fromstring(
3456             _gen_net_xml(
3457                 name,
3458                 bridge,
3459                 forward,
3460                 vport,
3461                 tag=tag,
3462                 ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
3463                 mtu=mtu,
3464                 domain=domain,
3465                 nat=nat,
3466                 interfaces=interfaces,
3467                 addresses=addresses,
3468                 physical_function=physical_function,
3469                 dns=dns,
3470             )
3471         )
3472         elements_to_copy = ["uuid", "mac"]
3473         for to_copy in elements_to_copy:
3474             element = old_xml.find(to_copy)
3475             if element is not None:
3476                 new_xml.insert(1, element)
3477         old_xml.attrib.pop("connections", None)
3478         if old_xml.find("forward/pf") is not None:
3479             forward_node = old_xml.find("forward")
3480             address_nodes = forward_node.findall("address")
3481             for node in address_nodes:
3482                 forward_node.remove(node)
3483         default_bridge_attribs = {"stp": "on", "delay": "0"}
3484         old_bridge_node = old_xml.find("bridge")
3485         if old_bridge_node is not None:
3486             for key, value in default_bridge_attribs.items():
3487                 if old_bridge_node.get(key, None) == value:
3488                     old_bridge_node.attrib.pop(key, None)
3489             old_forward = (
3490                 old_xml.find("forward").get("mode")
3491                 if old_xml.find("forward") is not None
3492                 else None
3493             )
3494             if (
3495                 old_forward == forward
3496                 and forward in ["nat", "route", "open", None]
3497                 and bridge is None
3498                 and old_bridge_node.get("name", "").startswith("virbr")
3499             ):
3500                 old_bridge_node.attrib.pop("name", None)
3501         ipv4_nodes = [
3502             node
3503             for node in old_xml.findall("ip")
3504             if node.get("family", "ipv4") == "ipv4"
3505         ]
3506         for ip_node in ipv4_nodes:
3507             netmask = ip_node.attrib.pop("netmask", None)
3508             if netmask:
3509                 address = ipaddress.ip_network(
3510                     "{}/{}".format(ip_node.get("address"), netmask), strict=False
3511                 )
3512                 ip_node.set("prefix", str(address.prefixlen))
3513         for doc in [old_xml, new_xml]:
3514             for node in doc.findall("ip"):
3515                 if "family" not in node.keys():
3516                     node.set("family", "ipv4")
3517         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
3518         xmlutil.strip_spaces(new_xml)
3519         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
3520         if needs_update and not test:
3521             conn.networkDefineXML(xmlutil.element_to_str(new_xml))
3522     finally:
3523         conn.close()
3524     return needs_update
3525 def list_networks(**kwargs):
3526     conn = __get_conn(**kwargs)
3527     try:
3528         return [net.name() for net in conn.listAllNetworks()]
3529     finally:
3530         conn.close()
3531 def network_info(name=None, **kwargs):
3532     result = {}
3533     conn = __get_conn(**kwargs)
3534     def _net_get_leases(net):
3535         leases = net.DHCPLeases()
3536         for lease in leases:
3537             if lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV4:
3538                 lease["type"] = "ipv4"
3539             elif lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV6:
3540                 lease["type"] = "ipv6"
3541             else:
3542                 lease["type"] = "unknown"
3543         return leases
3544     def _net_get_bridge(net):
3545         try:
3546             return net.bridgeName()
3547         except libvirt.libvirtError as err:
3548             return None
3549     try:
3550         nets = [
3551             net for net in conn.listAllNetworks() if name is None or net.name() == name
3552         ]
3553         result = {
3554             net.name(): {
3555                 "uuid": net.UUIDString(),
3556                 "bridge": _net_get_bridge(net),
3557                 "autostart": net.autostart(),
3558                 "active": net.isActive(),
3559                 "persistent": net.isPersistent(),
3560                 "leases": _net_get_leases(net),
3561             }
3562             for net in nets
3563         }
3564     except libvirt.libvirtError as err:
3565         log.debug("Silenced libvirt error: %s", err)
3566     finally:
3567         conn.close()
3568     return result
3569 def network_get_xml(name, **kwargs):
3570     conn = __get_conn(**kwargs)
3571     try:
3572         return conn.networkLookupByName(name).XMLDesc()
3573     finally:
3574         conn.close()
3575 def network_start(name, **kwargs):
3576     conn = __get_conn(**kwargs)
3577     try:
3578         net = conn.networkLookupByName(name)
3579         return not bool(net.create())
3580     finally:
3581         conn.close()
3582 def network_stop(name, **kwargs):
3583     conn = __get_conn(**kwargs)
3584     try:
3585         net = conn.networkLookupByName(name)
3586         return not bool(net.destroy())
3587     finally:
3588         conn.close()
3589 def network_undefine(name, **kwargs):
3590     conn = __get_conn(**kwargs)
3591     try:
3592         net = conn.networkLookupByName(name)
3593         return not bool(net.undefine())
3594     finally:
3595         conn.close()
3596 def network_set_autostart(name, state="on", **kwargs):
3597     conn = __get_conn(**kwargs)
3598     try:
3599         net = conn.networkLookupByName(name)
3600         return not bool(net.setAutostart(1 if state == "on" else 0))
3601     finally:
3602         conn.close()
3603 def _parse_pools_caps(doc):
3604     def _parse_pool_caps(pool):
3605         pool_caps = {
3606             "name": pool.get("type"),
3607             "supported": pool.get("supported", "no") == "yes",
3608         }
3609         for option_kind in ["pool", "vol"]:
3610             options = {}
3611             default_format_node = pool.find(
3612                 "{}Options/defaultFormat".format(option_kind)
3613             )
3614             if default_format_node is not None:
3615                 options["default_format"] = default_format_node.get("type")
3616             options_enums = {
3617                 enum.get("name"): [value.text for value in enum.findall("value")]
3618                 for enum in pool.findall("{}Options/enum".format(option_kind))
3619             }
3620             if options_enums:
3621                 options.update(options_enums)
3622             if options:
3623                 if "options" not in pool_caps:
3624                     pool_caps["options"] = {}
3625                 kind = option_kind if option_kind != "vol" else "volume"
3626                 pool_caps["options"][kind] = options
3627         return pool_caps
3628     return [_parse_pool_caps(pool) for pool in doc.findall("pool")]
3629 def _pool_capabilities(conn):
3630     has_pool_capabilities = bool(getattr(conn, "getStoragePoolCapabilities", None))
3631     if has_pool_capabilities:
3632         caps = ElementTree.fromstring(conn.getStoragePoolCapabilities())
3633         pool_types = _parse_pools_caps(caps)
3634     else:
3635         all_hypervisors = ["xen", "kvm", "bhyve"]
3636         images_formats = [
3637             "none",
3638             "raw",
3639             "dir",
3640             "bochs",
3641             "cloop",
3642             "dmg",
3643             "iso",
3644             "vpc",
3645             "vdi",
3646             "fat",
3647             "vhd",
3648             "ploop",
3649             "cow",
3650             "qcow",
3651             "qcow2",
3652             "qed",
3653             "vmdk",
3654         ]
3655         common_drivers = [
3656             {
3657                 "name": "fs",
3658                 "default_source_format": "auto",
3659                 "source_formats": [
3660                     "auto",
3661                     "ext2",
3662                     "ext3",
3663                     "ext4",
3664                     "ufs",
3665                     "iso9660",
3666                     "udf",
3667                     "gfs",
3668                     "gfs2",
3669                     "vfat",
3670                     "hfs+",
3671                     "xfs",
3672                     "ocfs2",
3673                 ],
3674                 "default_target_format": "raw",
3675                 "target_formats": images_formats,
3676             },
3677             {
3678                 "name": "dir",
3679                 "default_target_format": "raw",
3680                 "target_formats": images_formats,
3681             },
3682             {"name": "iscsi"},
3683             {"name": "scsi"},
3684             {
3685                 "name": "logical",
3686                 "default_source_format": "lvm2",
3687                 "source_formats": ["unknown", "lvm2"],
3688             },
3689             {
3690                 "name": "netfs",
3691                 "default_source_format": "auto",
3692                 "source_formats": ["auto", "nfs", "glusterfs", "cifs"],
3693                 "default_target_format": "raw",
3694                 "target_formats": images_formats,
3695             },
3696             {
3697                 "name": "disk",
3698                 "default_source_format": "unknown",
3699                 "source_formats": [
3700                     "unknown",
3701                     "dos",
3702                     "dvh",
3703                     "gpt",
3704                     "mac",
3705                     "bsd",
3706                     "pc98",
3707                     "sun",
3708                     "lvm2",
3709                 ],
3710                 "default_target_format": "none",
3711                 "target_formats": [
3712                     "none",
3713                     "linux",
3714                     "fat16",
3715                     "fat32",
3716                     "linux-swap",
3717                     "linux-lvm",
3718                     "linux-raid",
3719                     "extended",
3720                 ],
3721             },
3722             {"name": "mpath"},
3723             {"name": "rbd", "default_target_format": "raw", "target_formats": []},
3724             {
3725                 "name": "sheepdog",
3726                 "version": 10000,
3727                 "hypervisors": ["kvm"],
3728                 "default_target_format": "raw",
3729                 "target_formats": images_formats,
3730             },
3731             {
3732                 "name": "gluster",
3733                 "version": 1002000,
3734                 "hypervisors": ["kvm"],
3735                 "default_target_format": "raw",
3736                 "target_formats": images_formats,
3737             },
3738             {"name": "zfs", "version": 1002008, "hypervisors": ["bhyve"]},
3739             {
3740                 "name": "iscsi-direct",
3741                 "version": 4007000,
3742                 "hypervisors": ["kvm", "xen"],
3743             },
3744         ]
3745         libvirt_version = conn.getLibVersion()
3746         hypervisor = get_hypervisor()
3747         def _get_backend_output(backend):
3748             output = {
3749                 "name": backend["name"],
3750                 "supported": (
3751                     not backend.get("version") or libvirt_version &gt;= backend["version"]
3752                 )
3753                 and hypervisor in backend.get("hypervisors", all_hypervisors),
3754                 "options": {
3755                     "pool": {
3756                         "default_format": backend.get("default_source_format"),
3757                         "sourceFormatType": backend.get("source_formats"),
3758                     },
3759                     "volume": {
3760                         "default_format": backend.get("default_target_format"),
3761                         "targetFormatType": backend.get("target_formats"),
3762                     },
3763                 },
3764             }
3765             for option_kind in ["pool", "volume"]:
3766                 if not [
3767                     value
3768                     for value in output["options"][option_kind].values()
3769                     if value is not None
3770                 ]:
3771                     del output["options"][option_kind]
3772             if not output["options"]:
3773                 del output["options"]
3774             return output
3775         pool_types = [_get_backend_output(backend) for backend in common_drivers]
3776     return {
3777         "computed": not has_pool_capabilities,
3778         "pool_types": pool_types,
3779     }
3780 def pool_capabilities(**kwargs):
3781     try:
3782         conn = __get_conn(**kwargs)
3783         return _pool_capabilities(conn)
3784     finally:
3785         conn.close()
3786 def pool_define(
3787     name,
3788     ptype,
3789     target=None,
3790     permissions=None,
3791     source_devices=None,
3792     source_dir=None,
3793     source_initiator=None,
3794     source_adapter=None,
3795     source_hosts=None,
3796     source_auth=None,
3797     source_name=None,
3798     source_format=None,
3799     transient=False,
3800     start=True,  # pylint: disable=redefined-outer-name
3801     **kwargs
3802 ):
3803     conn = __get_conn(**kwargs)
3804     auth = _pool_set_secret(conn, ptype, name, source_auth)
3805     pool_xml = _gen_pool_xml(
3806         name,
3807         ptype,
3808         target,
3809         permissions=permissions,
3810         source_devices=source_devices,
3811         source_dir=source_dir,
3812         source_adapter=source_adapter,
3813         source_hosts=source_hosts,
3814         source_auth=auth,
3815         source_name=source_name,
3816         source_format=source_format,
3817         source_initiator=source_initiator,
3818     )
3819     try:
3820         if transient:
3821             pool = conn.storagePoolCreateXML(pool_xml)
3822         else:
3823             pool = conn.storagePoolDefineXML(pool_xml)
3824             if start:
3825                 pool.create()
3826     except libvirt.libvirtError as err:
3827         raise err  # a real error we should report upwards
3828     finally:
3829         conn.close()
3830     return True
3831 def _pool_set_secret(
3832     conn, pool_type, pool_name, source_auth, uuid=None, usage=None, test=False
3833 ):
3834     secret_types = {"rbd": "ceph", "iscsi": "chap", "iscsi-direct": "chap"}
3835     secret_type = secret_types.get(pool_type)
3836     auth = source_auth
3837     if source_auth and "username" in source_auth and "password" in source_auth:
3838         if secret_type:
3839             secret = None
3840             try:
3841                 if usage:
3842                     usage_type = (
3843                         libvirt.VIR_SECRET_USAGE_TYPE_CEPH
3844                         if secret_type == "ceph"
3845                         else libvirt.VIR_SECRET_USAGE_TYPE_ISCSI
3846                     )
3847                     secret = conn.secretLookupByUsage(usage_type, usage)
3848                 elif uuid:
3849                     secret = conn.secretLookupByUUIDString(uuid)
3850             except libvirt.libvirtError as err:
3851                 log.info("Secret not found: %s", err.get_error_message())
3852             if not secret:
3853                 description = "Passphrase for {} pool created by Salt".format(pool_name)
3854                 if not usage:
3855                     usage = "pool_{}".format(pool_name)
3856                 secret_xml = _gen_secret_xml(secret_type, usage, description)
3857                 if not test:
3858                     secret = conn.secretDefineXML(secret_xml)
3859             password = auth["password"]
3860             if pool_type == "rbd":
3861                 password = base64.b64decode(salt.utils.stringutils.to_bytes(password))
3862             if not test:
3863                 secret.setValue(password)
3864             auth["type"] = secret_type
3865             auth["secret"] = {
3866                 "type": "uuid" if uuid else "usage",
3867                 "value": uuid if uuid else usage,
3868             }
3869     return auth
3870 def pool_update(
3871     name,
3872     ptype,
3873     target=None,
3874     permissions=None,
3875     source_devices=None,
3876     source_dir=None,
3877     source_initiator=None,
3878     source_adapter=None,
3879     source_hosts=None,
3880     source_auth=None,
3881     source_name=None,
3882     source_format=None,
3883     test=False,
3884     **kwargs
3885 ):
3886     conn = __get_conn(**kwargs)
3887     needs_update = False
3888     try:
3889         pool = conn.storagePoolLookupByName(name)
3890         old_xml = ElementTree.fromstring(pool.XMLDesc())
3891         secret_node = old_xml.find("source/auth/secret")
3892         usage = secret_node.get("usage") if secret_node is not None else None
3893         uuid = secret_node.get("uuid") if secret_node is not None else None
3894         auth = _pool_set_secret(
3895             conn, ptype, name, source_auth, uuid=uuid, usage=usage, test=test
3896         )
3897         new_xml = ElementTree.fromstring(
3898             _gen_pool_xml(
3899                 name,
3900                 ptype,
3901                 target,
3902                 permissions=permissions,
3903                 source_devices=source_devices,
3904                 source_dir=source_dir,
3905                 source_initiator=source_initiator,
3906                 source_adapter=source_adapter,
3907                 source_hosts=source_hosts,
3908                 source_auth=auth,
3909                 source_name=source_name,
3910                 source_format=source_format,
3911             )
3912         )
3913         elements_to_copy = ["available", "allocation", "capacity", "uuid"]
3914         for to_copy in elements_to_copy:
3915             element = old_xml.find(to_copy)
3916             new_xml.insert(1, element)
3917         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
3918         xmlutil.strip_spaces(new_xml)
3919         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
3920         if needs_update and not test:
3921             conn.storagePoolDefineXML(xmlutil.element_to_str(new_xml))
3922     finally:
3923         conn.close()
3924     return needs_update
3925 def list_pools(**kwargs):
3926     conn = __get_conn(**kwargs)
3927     try:
3928         return [pool.name() for pool in conn.listAllStoragePools()]
3929     finally:
3930         conn.close()
3931 def pool_info(name=None, **kwargs):
3932     result = {}
3933     conn = __get_conn(**kwargs)
3934     def _pool_extract_infos(pool):
3935         states = ["inactive", "building", "running", "degraded", "inaccessible"]
3936         infos = pool.info()
3937         state = states[infos[0]] if infos[0] &lt; len(states) else "unknown"
3938         desc = ElementTree.fromstring(pool.XMLDesc())
3939         path_node = desc.find("target/path")
3940         return {
3941             "uuid": pool.UUIDString(),
3942             "state": state,
3943             "capacity": infos[1],
3944             "allocation": infos[2],
3945             "free": infos[3],
3946             "autostart": pool.autostart(),
3947             "persistent": pool.isPersistent(),
3948             "target_path": path_node.text if path_node is not None else None,
3949             "type": desc.get("type"),
3950         }
3951     try:
3952         pools = [
3953             pool
3954             for pool in conn.listAllStoragePools()
3955             if name is None or pool.name() == name
3956         ]
3957         result = {pool.name(): _pool_extract_infos(pool) for pool in pools}
3958     except libvirt.libvirtError as err:
3959         log.debug("Silenced libvirt error: %s", err)
3960     finally:
3961         conn.close()
3962     return result
3963 def pool_get_xml(name, **kwargs):
3964     conn = __get_conn(**kwargs)
3965     try:
3966         return conn.storagePoolLookupByName(name).XMLDesc()
3967     finally:
3968         conn.close()
3969 def pool_start(name, **kwargs):
3970     conn = __get_conn(**kwargs)
3971     try:
3972         pool = conn.storagePoolLookupByName(name)
3973         return not bool(pool.create())
3974     finally:
3975         conn.close()
3976 def pool_build(name, **kwargs):
3977     conn = __get_conn(**kwargs)
3978     try:
3979         pool = conn.storagePoolLookupByName(name)
3980         return not bool(pool.build())
3981     finally:
3982         conn.close()
3983 def pool_stop(name, **kwargs):
3984     conn = __get_conn(**kwargs)
3985     try:
3986         pool = conn.storagePoolLookupByName(name)
3987         return not bool(pool.destroy())
3988     finally:
3989         conn.close()
3990 def pool_undefine(name, **kwargs):
3991     conn = __get_conn(**kwargs)
3992     try:
3993         pool = conn.storagePoolLookupByName(name)
3994         desc = ElementTree.fromstring(pool.XMLDesc())
3995         auth_node = desc.find("source/auth")
3996         if auth_node is not None:
3997             auth_types = {
3998                 "ceph": libvirt.VIR_SECRET_USAGE_TYPE_CEPH,
3999                 "iscsi": libvirt.VIR_SECRET_USAGE_TYPE_ISCSI,
4000             }
4001             secret_type = auth_types[auth_node.get("type")]
4002             secret_usage = auth_node.find("secret").get("usage")
4003             if secret_type and "pool_{}".format(name) == secret_usage:
4004                 secret = conn.secretLookupByUsage(secret_type, secret_usage)
4005                 secret.undefine()
4006         return not bool(pool.undefine())
4007     finally:
4008         conn.close()
4009 def pool_delete(name, **kwargs):
4010     conn = __get_conn(**kwargs)
4011     try:
4012         pool = conn.storagePoolLookupByName(name)
4013         return not bool(pool.delete(libvirt.VIR_STORAGE_POOL_DELETE_NORMAL))
4014     finally:
4015         conn.close()
4016 def pool_refresh(name, **kwargs):
4017     conn = __get_conn(**kwargs)
4018     try:
4019         pool = conn.storagePoolLookupByName(name)
4020         return not bool(pool.refresh())
4021     finally:
4022         conn.close()
4023 def pool_set_autostart(name, state="on", **kwargs):
4024     conn = __get_conn(**kwargs)
4025     try:
4026         pool = conn.storagePoolLookupByName(name)
4027         return not bool(pool.setAutostart(1 if state == "on" else 0))
4028     finally:
4029         conn.close()
4030 def pool_list_volumes(name, **kwargs):
4031     conn = __get_conn(**kwargs)
4032     try:
4033         pool = conn.storagePoolLookupByName(name)
4034         return pool.listVolumes()
4035     finally:
4036         conn.close()
4037 def _get_storage_vol(conn, pool, vol):
4038     pool_obj = conn.storagePoolLookupByName(pool)
4039     return pool_obj.storageVolLookupByName(vol)
4040 def _is_valid_volume(vol):
4041     try:
4042         def discarder(ctxt, error):  # pylint: disable=unused-argument
4043             log.debug("Ignore libvirt error: %s", error[2])
4044         libvirt.registerErrorHandler(discarder, None)
4045         vol.info()
4046         libvirt.registerErrorHandler(None, None)
4047         return True
4048     except libvirt.libvirtError as err:
4049         return False
4050 def _get_all_volumes_paths(conn):
4051     pools = [
4052         pool
4053         for pool in conn.listAllStoragePools()
4054         if pool.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
4055     ]
4056     volumes = {}
4057     for pool in pools:
4058         pool_volumes = {
4059             volume.path(): {
4060                 "pool": pool.name(),
4061                 "name": volume.name(),
4062                 "backing_stores": [
4063                     path.text
4064                     for path in ElementTree.fromstring(volume.XMLDesc()).findall(
4065                         ".//backingStore/path"
4066                     )
4067                 ],
4068             }
4069             for volume in pool.listAllVolumes()
4070             if _is_valid_volume(volume)
4071         }
4072         volumes.update(pool_volumes)
4073     return volumes
4074 def volume_infos(pool=None, volume=None, **kwargs):
4075     result = {}
4076     conn = __get_conn(**kwargs)
4077     try:
4078         backing_stores = _get_all_volumes_paths(conn)
4079         try:
4080             domains = _get_domain(conn)
4081             domains_list = domains if isinstance(domains, list) else [domains]
4082         except CommandExecutionError:
4083             domains_list = []
4084         disks = {
4085             domain.name(): {
4086                 node.get("file")
4087                 for node in ElementTree.fromstring(domain.XMLDesc(0)).findall(
4088                     ".//disk/source/[@file]"
4089                 )
4090             }
4091             for domain in domains_list
4092         }
4093         def _volume_extract_infos(vol):
4094             types <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= ["file", "block", "dir", "network", "netdir", "ploop"]
4095             infos = vol.info()
4096             vol_xml = ElementTree.fromstring(vol.XMLDesc())
4097             backing_store_path = vol_xml.</b></font>find("./backingStore/path")
4098             backing_store_format = vol_xml.find("./backingStore/format")
4099             backing_store = None
4100             if backing_store_path is not None:
4101                 backing_store = {
4102                     "path": backing_store_path.text,
4103                     "format": backing_store_format.get("type")
4104                     if backing_store_format is not None
4105                     else None,
4106                 }
4107             format_node = vol_xml.find("./target/format")
4108             used_by = []
4109             if vol.path():
4110                 as_backing_store = {
4111                     path
4112                     for (path, volume) in backing_stores.items()
4113                     if vol.path() in volume.get("backing_stores")
4114                 }
4115                 used_by = [
4116                     vm_name
4117                     for (vm_name, vm_disks) in disks.items()
4118                     if vm_disks &amp; as_backing_store or vol.path() in vm_disks
4119                 ]
4120             return {
4121                 "type": types[infos[0]] if infos[0] &lt; len(types) else "unknown",
4122                 "key": vol.key(),
4123                 "path": vol.path(),
4124                 "capacity": infos[1],
4125                 "allocation": infos[2],
4126                 "used_by": used_by,
4127                 "backing_store": backing_store,
4128                 "format": format_node.get("type") if format_node is not None else None,
4129             }
4130         pools = [
4131             obj
4132             for obj in conn.listAllStoragePools()
4133             if (pool is None or obj.name() == pool)
4134             and obj.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
4135         ]
4136         vols = {
4137             pool_obj.name(): {
4138                 vol.name(): _volume_extract_infos(vol)
4139                 for vol in pool_obj.listAllVolumes()
4140                 if (volume is None or vol.name() == volume) and _is_valid_volume(vol)
4141             }
4142             for pool_obj in pools
4143         }
4144         return {pool_name: volumes for (pool_name, volumes) in vols.items() if volumes}
4145     except libvirt.libvirtError as err:
4146         log.debug("Silenced libvirt error: %s", err)
4147     finally:
4148         conn.close()
4149     return result
4150 def volume_delete(pool, volume, **kwargs):
4151     conn = __get_conn(**kwargs)
4152     try:
4153         vol = _get_storage_vol(conn, pool, volume)
4154         return not bool(vol.delete())
4155     finally:
4156         conn.close()
4157 def volume_define(
4158     pool,
4159     name,
4160     size,
4161     allocation=0,
4162     format=None,
4163     type=None,
4164     permissions=None,
4165     backing_store=None,
4166     nocow=False,
4167     **kwargs
4168 ):
4169     ret = False
4170     try:
4171         conn = __get_conn(**kwargs)
4172         pool_obj = conn.storagePoolLookupByName(pool)
4173         pool_type = ElementTree.fromstring(pool_obj.XMLDesc()).get("type")
4174         new_allocation = allocation
4175         if pool_type == "logical" and size != allocation:
4176             new_allocation = size
4177         xml = _gen_vol_xml(
4178             name,
4179             size,
4180             format=format,
4181             allocation=new_allocation,
4182             type=type,
4183             permissions=permissions,
4184             backing_store=backing_store,
4185             nocow=nocow,
4186         )
4187         ret = _define_vol_xml_str(conn, xml, pool=pool)
4188     except libvirt.libvirtError as err:
4189         raise CommandExecutionError(err.get_error_message())
4190     finally:
4191         conn.close()
4192     return ret
4193 def _volume_upload(conn, pool, volume, file, offset=0, length=0, sparse=False):
4194     def handler(stream, nbytes, opaque):
4195         return os.read(opaque, nbytes)
4196     def holeHandler(stream, opaque):
4197         fd = opaque
4198         cur = os.lseek(fd, 0, os.SEEK_CUR)
4199         try:
4200             data = os.lseek(fd, cur, os.SEEK_DATA)
4201         except OSError as e:
4202             if e.errno != 6:
4203                 raise e
4204             else:
4205                 data = -1
4206         if data &lt; 0:
4207             inData = False
4208             eof = os.lseek(fd, 0, os.SEEK_END)
4209             if eof &lt; cur:
4210                 raise RuntimeError("Current position in file after EOF: {}".format(cur))
4211             sectionLen = eof - cur
4212         else:
4213             if data &gt; cur:
4214                 inData = False
4215                 sectionLen = data - cur
4216             else:
4217                 inData = True
4218                 hole = os.lseek(fd, data, os.SEEK_HOLE)
4219                 if hole &lt; 0:
4220                     raise RuntimeError("No trailing hole")
4221                 if hole == data:
4222                     raise RuntimeError("Impossible happened")
4223                 else:
4224                     sectionLen = hole - data
4225         os.lseek(fd, cur, os.SEEK_SET)
4226         return [inData, sectionLen]
4227     def skipHandler(stream, length, opaque):
4228         return os.lseek(opaque, length, os.SEEK_CUR)
4229     stream = None
4230     fd = None
4231     ret = False
4232     try:
4233         pool_obj = conn.storagePoolLookupByName(pool)
4234         vol_obj = pool_obj.storageVolLookupByName(volume)
4235         stream = conn.newStream()
4236         fd = os.open(file, os.O_RDONLY)
4237         vol_obj.upload(
4238             stream,
4239             offset,
4240             length,
4241             libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM if sparse else 0,
4242         )
4243         if sparse:
4244             stream.sparseSendAll(handler, holeHandler, skipHandler, fd)
4245         else:
4246             stream.sendAll(handler, fd)
4247         ret = True
4248     except libvirt.libvirtError as err:
4249         raise CommandExecutionError(err.get_error_message())
4250     finally:
4251         if fd:
4252             try:
4253                 os.close(fd)
4254             except OSError as err:
4255                 if stream:
4256                     stream.abort()
4257                 if ret:
4258                     raise CommandExecutionError(
4259                         "Failed to close file: {}".format(err.strerror)
4260                     )
4261         if stream:
4262             try:
4263                 stream.finish()
4264             except libvirt.libvirtError as err:
4265                 if ret:
4266                     raise CommandExecutionError(
4267                         "Failed to finish stream: {}".format(err.get_error_message())
4268                     )
4269     return ret
4270 def volume_upload(pool, volume, file, offset=0, length=0, sparse=False, **kwargs):
4271     conn = __get_conn(**kwargs)
4272     ret = False
4273     try:
4274         ret = _volume_upload(
4275             conn, pool, volume, file, offset=offset, length=length, sparse=sparse
4276         )
4277     finally:
4278         conn.close()
4279     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
