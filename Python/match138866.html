<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for __init___57.py &amp; test_pydsl.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for __init___57.py &amp; test_pydsl.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>__init___57.py (1.5297906%)<th>test_pydsl.py (7.4901447%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-22)<td><a href="#" name="0">(1-18)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1070-1076)<td><a href="#" name="1">(294-299)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1178-1183)<td><a href="#" name="2">(112-118)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(203-205)<td><a href="#" name="3">(165-167)</a><td align="center"><font color="#c30000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___57.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
2 import glob
3 import logging
4 import multiprocessing
5 import os
6 import signal
7 import time
8 import traceback
9 from itertools import groupby
10 import salt.client
11 import salt.config
12 import salt.loader
13 import salt.syspaths
14 import salt.utils.args
15 import salt.utils.cloud
16 import salt.utils.context
17 import</b></font> salt.utils.crypt
18 import salt.utils.data
19 import salt.utils.dictupdate
20 import salt.utils.files
21 import salt.utils.user
22 import salt.utils.verify
23 import salt.utils.yaml
24 from salt.exceptions import (
25     SaltCloudConfigError,
26     SaltCloudException,
27     SaltCloudNotFound,
28     SaltCloudSystemExit,
29 )
30 from salt.template import compile_template
31 try:
32     import Cryptodome.Random
33 except ImportError:
34     try:
35         import Crypto.Random  # nosec
36     except ImportError:
37         pass  # pycrypto &lt; 2.1
38 log = logging.getLogger(__name__)
39 def communicator(func):
40     def _call(queue, args, kwargs):
41         kwargs["queue"] = queue
42         ret = None
43         try:
44             ret = func(*args, **kwargs)
45             queue.put("END")
46         except KeyboardInterrupt as ex:
47             trace = traceback.format_exc()
48             queue.put("KEYBOARDINT")
49             queue.put("Keyboard interrupt")
50             queue.put("{}\n{}\n".format(ex, trace))
51         except Exception as ex:  # pylint: disable=broad-except
52             trace = traceback.format_exc()
53             queue.put("ERROR")
54             queue.put("Exception")
55             queue.put("{}\n{}\n".format(ex, trace))
56         except SystemExit as ex:
57             trace = traceback.format_exc()
58             queue.put("ERROR")
59             queue.put("System exit")
60             queue.put("{}\n{}\n".format(ex, trace))
61         return ret
62     return _call
63 def enter_mainloop(
64     target,
65     mapped_args=None,
66     args=None,
67     kwargs=None,
68     pool=None,
69     pool_size=None,
70     callback=None,
71     queue=None,
72 ):
73     if not kwargs:
74         kwargs = {}
75     if not pool_size:
76         pool_size = 1
77     if not pool:
78         pool = multiprocessing.Pool(pool_size)
79     if not queue:
80         manager = multiprocessing.Manager()
81         queue = manager.Queue()
82     if mapped_args is not None and not mapped_args:
83         msg = (
84             "We are called to asynchronously execute {}"
85             " but we do no have anything to execute, weird,"
86             " we bail out".format(target)
87         )
88         log.error(msg)
89         raise SaltCloudSystemExit("Exception caught\n{}".format(msg))
90     elif mapped_args is not None:
91         iterable = [[queue, [arg], kwargs] for arg in mapped_args]
92         ret = pool.map(func=target, iterable=iterable)
93     else:
94         ret = pool.apply(target, [queue, args, kwargs])
95     while True:
96         test = queue.get()
97         if test in ["ERROR", "KEYBOARDINT"]:
98             type_ = queue.get()
99             trace = queue.get()
100             msg = "Caught {}, terminating workers\n".format(type_)
101             msg += "TRACE: {}\n".format(trace)
102             log.error(msg)
103             pool.terminate()
104             pool.join()
105             raise SaltCloudSystemExit("Exception caught\n{}".format(msg))
106         elif test in ["END"] or (callback and callback(test)):
107             pool.close()
108             pool.join()
109             break
110         else:
111             time.sleep(0.125)
112     return ret
113 class CloudClient:
114     def __init__(self, path=None, opts=None, config_dir=None, pillars=None):
115         if opts:
116             self.opts = opts
117         else:
118             self.opts = salt.config.cloud_config(path)
119         v_dirs = [self.opts["cachedir"]]
120         salt.utils.verify.verify_env(v_dirs, salt.utils.user.get_user())
121         if pillars:
122             for name, provider in pillars.pop("providers", {}).items():
123                 driver = provider["driver"]
124                 provider["profiles"] = {}
125                 self.opts["providers"].update({name: {driver: provider}})
126             for name, profile in pillars.pop("profiles", {}).items():
127                 provider = profile["provider"].split(":")[0]
128                 profile["provider"] = "{}:{}".format(provider, driver)
129                 profile["profile"] = name
130                 self<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.opts["profiles"].update({name: profile})
131                 self.opts["providers"][provider][driver]["profiles"].update(
132                     {name</b></font>: profile}
133                 )
134             for name, map_dct in pillars.pop("maps", {}).items():
135                 if "maps" not in self.opts:
136                     self.opts["maps"] = {}
137                 self.opts["maps"][name] = map_dct
138             self.opts.update(pillars)
139     def _opts_defaults(self, **kwargs):
140         opts = salt.config.DEFAULT_CLOUD_OPTS.copy()
141         opts.update(self.opts.copy())
142         opts["parallel"] = False
143         opts["keep_tmp"] = False
144         opts["deploy"] = True
145         opts["update_bootstrap"] = False
146         opts["show_deploy_args"] = False
147         opts["script_args"] = ""
148         if "kwargs" in kwargs:
149             opts.update(kwargs["kwargs"])
150         opts.update(kwargs)
151         profile = opts.get("profile", None)
152         if profile:
153             tmp_profiles = opts.get("profiles", {}).copy()
154             for _profile in [a for a in tmp_profiles]:
155                 if not _profile == profile:
156                     tmp_profiles.pop(_profile)
157             providers = [
158                 a.get("provider", "").split(":")[0]
159                 for a in tmp_profiles.values()
160                 if a.get("provider", "")
161             ]
162             if providers:
163                 _providers = opts.get("providers", {})
164                 for provider in _providers.copy():
165                     if provider not in providers:
166                         _providers.pop(provider)
167         return opts
168     def low(self, fun, low):
169         l_fun = getattr(self, fun)
170         f_call = salt.utils.args.format_call(l_fun, low)
171         return l_fun(*f_call.get("args", ()), **f_call.get("kwargs", {}))
172     def list_sizes(self, provider=None):
173         mapper = salt.cloud.Map(self._opts_defaults())
174         return salt.utils.data.simple_types_filter(mapper.size_list(provider))
175     def list_images(self, provider=None):
176         mapper = salt.cloud.Map(self._opts_defaults())
177         return salt.utils.data.simple_types_filter(mapper.image_list(provider))
178     def list_locations(self, provider=None):
179         mapper = salt.cloud.Map(self._opts_defaults())
180         return salt.utils.data.simple_types_filter(mapper.location_list(provider))
181     def query(self, query_type="list_nodes"):
182         mapper = salt.cloud.Map(self._opts_defaults())
183         mapper.opts["selected_query_option"] = "list_nodes"
184         return mapper.map_providers_parallel(query_type)
185     def full_query(self, query_type="list_nodes_full"):
186         mapper = salt.cloud.Map(self._opts_defaults())
187         mapper.opts["selected_query_option"] = "list_nodes_full"
188         return mapper.map_providers_parallel(query_type)
189     def select_query(self, query_type="list_nodes_select"):
190         mapper = salt.cloud.Map(self._opts_defaults())
191         mapper.opts["selected_query_option"] = "list_nodes_select"
192         return mapper.map_providers_parallel(query_type)
193     def min_query(self, query_type="list_nodes_min"):
194         mapper = salt.cloud.Map(self._opts_defaults())
195         mapper.opts["selected_query_option"] = "list_nodes_min"
196         return mapper.map_providers_parallel(query_type)
197     def profile(self, profile, names, vm_overrides=None, **kwargs):
198         if not vm_overrides:
199             vm_overrides = {}
200         kwargs["profile"] = profile
201         mapper = salt.cloud.Map(self._opts_defaults(**kwargs))
202         if isinstance(names, str):
203             names = names.split(",")
204         return salt.utils.data.simple_types_filter(
205             mapper.run_profile(profile, names, vm_overrides=vm_overrides)
206         )
207     def map_run(self, path=None, **kwargs):
208         kwarg = {}
209         if path:
210             kwarg["map"] = path
211         kwarg.update(kwargs)
212         mapper = salt.cloud.Map(self._opts_defaults(**kwarg))
213         dmap = mapper.map_data()
214         return salt.utils.data.simple_types_filter(mapper.run_map(dmap))
215     def destroy(self, names):
216         mapper = salt.cloud.Map(self._opts_defaults(destroy=True))
217         if isinstance(names, str):
218             names = names.split(",")
219         return salt.utils.data.simple_types_filter(mapper.destroy(names))
220     def create(self, provider, names, **kwargs):
221         mapper = salt.cloud.Map(self._opts_defaults())
222         providers = self.opts["providers"]
223         if provider in providers:
224             provider += ":{}".format(next(iter(providers[provider].keys())))
225         else:
226             return False
227         if isinstance(names, str):
228             names = names.split(",")
229         ret = {}
230         for name in names:
231             vm_ = kwargs.copy()
232             vm_["name"] = name
233             vm_["driver"] = provider
234             vm_["profile"] = None
235             vm_["provider"] = provider
236             ret[name] = salt.utils.data.simple_types_filter(mapper.create(vm_))
237         return ret
238     def extra_action(self, names, provider, action, **kwargs):
239         mapper = salt.cloud.Map(self._opts_defaults())
240         providers = mapper.map_providers_parallel()
241         if provider in providers:
242             provider += ":{}".format(next(iter(providers[provider].keys())))
243         else:
244             return False
245         if isinstance(names, str):
246             names = names.split(",")
247         ret = {}
248         for name in names:
249             extra_ = kwargs.copy()
250             extra_["name"] = name
251             extra_["provider"] = provider
252             extra_["profile"] = None
253             extra_["action"] = action
254             ret[name] = salt.utils.data.simple_types_filter(mapper.extras(extra_))
255         return ret
256     def action(
257         self,
258         fun=None,
259         cloudmap=None,
260         names=None,
261         provider=None,
262         instance=None,
263         kwargs=None,
264     ):
265         if kwargs is None:
266             kwargs = {}
267         mapper = salt.cloud.Map(self._opts_defaults(action=fun, names=names, **kwargs))
268         if instance:
269             if names:
270                 raise SaltCloudConfigError(
271                     "Please specify either a list of 'names' or a single "
272                     "'instance', but not both."
273                 )
274             names = [instance]
275         if names and not provider:
276             self.opts["action"] = fun
277             return mapper.do_action(names, kwargs)
278         if provider and not names:
279             return mapper.do_function(provider, fun, kwargs)
280         else:
281             raise SaltCloudConfigError(
282                 "Either an instance (or list of names) or a provider must be "
283                 "specified, but not both."
284             )
285 class Cloud:
286     def __init__(self, opts):
287         self.opts = opts
288         self.clouds = salt.loader.clouds(self.opts)
289         self.__filter_non_working_providers()
290         self.__cached_provider_queries = {}
291     def get_configured_providers(self):
292         providers = set()
293         for alias, drivers in self.opts["providers"].items():
294             if len(drivers) &gt; 1:
295                 for driver in drivers:
296                     providers.add("{}:{}".format(alias, driver))
297                 continue
298             providers.add(alias)
299         return providers
300     def lookup_providers(self, lookup):
301         if lookup is None:
302             lookup = "all"
303         if lookup == "all":
304             providers = set()
305             for alias, drivers in self.opts["providers"].items():
306                 for driver in drivers:
307                     providers.add((alias, driver))
308             if not providers:
309                 raise SaltCloudSystemExit("There are no cloud providers configured.")
310             return providers
311         if ":" in lookup:
312             alias, driver = lookup.split(":")
313             if (
314                 alias not in self.opts["providers"]
315                 or driver not in self.opts["providers"][alias]
316             ):
317                 raise SaltCloudSystemExit(
318                     "No cloud providers matched '{}'. Available: {}".format(
319                         lookup, ", ".join(self.get_configured_providers())
320                     )
321                 )
322         providers = set()
323         for alias, drivers in self.opts["providers"].items():
324             for driver in drivers:
325                 if lookup in (alias, driver):
326                     providers.add((alias, driver))
327         if not providers:
328             raise SaltCloudSystemExit(
329                 "No cloud providers matched '{}'. Available selections: {}".format(
330                     lookup, ", ".join(self.get_configured_providers())
331                 )
332             )
333         return providers
334     def lookup_profiles(self, provider, lookup):
335         if provider is None:
336             provider = "all"
337         if lookup is None:
338             lookup = "all"
339         if lookup == "all":
340             profiles = set()
341             provider_profiles = set()
342             for alias, info in self.opts["profiles"].items():
343                 providers = info.get("provider")
344                 if providers:
345                     given_prov_name = providers.split(":")[0]
346                     salt_prov_name = providers.split(":")[1]
347                     if given_prov_name == provider:
348                         provider_profiles.add((alias, given_prov_name))
349                     elif salt_prov_name == provider:
350                         provider_profiles.add((alias, salt_prov_name))
351                     profiles.add((alias, given_prov_name))
352             if not profiles:
353                 raise SaltCloudSystemExit("There are no cloud profiles configured.")
354             if provider != "all":
355                 return provider_profiles
356             return profiles
357     def map_providers(self, query="list_nodes", cached=False):
358         if cached is True and query in self.__cached_provider_queries:
359             return self.__cached_provider_queries[query]
360         pmap = {}
361         for alias, drivers in self.opts["providers"].items():
362             for driver, details in drivers.items():
363                 fun = "{}.{}".format(driver, query)
364                 if fun not in self.clouds:
365                     log.error("Public cloud provider %s is not available", driver)
366                     continue
367                 if alias not in pmap:
368                     pmap[alias] = {}
369                 try:
370                     with salt.utils.context.func_globals_inject(
371                         self.clouds[fun],
372                         __active_provider_name__=":".join([alias, driver]),
373                     ):
374                         pmap[alias][driver] = self.clouds[fun]()
375                 except Exception as err:  # pylint: disable=broad-except
376                     log.debug(
377                         "Failed to execute '%s()' while querying for running nodes: %s",
378                         fun,
379                         err,
380                         exc_info_on_loglevel=logging.DEBUG,
381                     )
382                     pmap[alias][driver] = []
383         self.__cached_provider_queries[query] = pmap
384         return pmap
385     def map_providers_parallel(self, query="list_nodes", cached=False):
386         if cached is True and query in self.__cached_provider_queries:
387             return self.__cached_provider_queries[query]
388         opts = self.opts.copy()
389         multiprocessing_data = []
390         opts["providers"] = self._optimize_providers(opts["providers"])
391         for alias, drivers in opts["providers"].items():
392             this_query = query
393             for driver, details in drivers.items():
394                 if (
395                     opts.get("selected_query_option") is None
396                     and "{}.list_nodes_min".format(driver) in self.clouds
397                 ):
398                     this_query = "list_nodes_min"
399                 fun = "{}.{}".format(driver, this_query)
400                 if fun not in self.clouds:
401                     log.error("Public cloud provider %s is not available", driver)
402                     continue
403                 multiprocessing_data.append(
404                     {
405                         "fun": fun,
406                         "opts": opts,
407                         "query": this_query,
408                         "alias": alias,
409                         "driver": driver,
410                     }
411                 )
412         output = {}
413         if not multiprocessing_data:
414             return output
415         data_count = len(multiprocessing_data)
416         pool = multiprocessing.Pool(
417             data_count &lt; 10 and data_count or 10, init_pool_worker
418         )
419         parallel_pmap = enter_mainloop(
420             _run_parallel_map_providers_query, multiprocessing_data, pool=pool
421         )
422         for alias, driver, details in parallel_pmap:
423             if not details:
424                 continue
425             if alias not in output:
426                 output[alias] = {}
427             output[alias][driver] = details
428         self.__cached_provider_queries[query] = output
429         return output
430     def get_running_by_names(
431         self, names, query="list_nodes", cached=False, profile=None
432     ):
433         if isinstance(names, str):
434             names = [names]
435         matches = {}
436         handled_drivers = {}
437         mapped_providers = self.map_providers_parallel(query, cached=cached)
438         for alias, drivers in mapped_providers.items():
439             for driver, vms in drivers.items():
440                 if driver not in handled_drivers:
441                     handled_drivers[driver] = alias
442                 if (
443                     profile
444                     and alias
445                     not in self.opts["profiles"][profile]["provider"].split(":")[0]
446                 ):
447                     continue
448                 for vm_name, details in vms.items():
449                     if vm_name not in names:
450                         continue
451                     elif (
452                         driver == "ec2"
453                         and "aws" in handled_drivers
454                         and "aws" in matches[handled_drivers["aws"]]
455                         and vm_name in matches[handled_drivers["aws"]]["aws"]
456                     ):
457                         continue
458                     elif (
459                         driver == "aws"
460                         and "ec2" in handled_drivers
461                         and "ec2" in matches[handled_drivers["ec2"]]
462                         and vm_name in matches[handled_drivers["ec2"]]["ec2"]
463                     ):
464                         continue
465                     if alias not in matches:
466                         matches[alias] = {}
467                     if driver not in matches[alias]:
468                         matches[alias][driver] = {}
469                     matches[alias][driver][vm_name] = details
470         return matches
471     def _optimize_providers(self, providers):
472         new_providers = {}
473         provider_by_driver = {}
474         for alias, driver in providers.items():
475             for name, data in driver.items():
476                 if name not in provider_by_driver:
477                     provider_by_driver[name] = {}
478                 provider_by_driver[name][alias] = data
479         for driver, providers_data in provider_by_driver.items():
480             fun = "{}.optimize_providers".format(driver)
481             if fun not in self.clouds:
482                 log.debug("The '%s' cloud driver is unable to be optimized.", driver)
483                 for name, prov_data in providers_data.items():
484                     if name not in new_providers:
485                         new_providers[name] = {}
486                     new_providers[name][driver] = prov_data
487                 continue
488             new_data = self.clouds[fun](providers_data)
489             if new_data:
490                 for name, prov_data in new_data.items():
491                     if name not in new_providers:
492                         new_providers[name] = {}
493                     new_providers[name][driver] = prov_data
494         return new_providers
495     def location_list(self, lookup="all"):
496         data = {}
497         lookups = self.lookup_providers(lookup)
498         if not lookups:
499             return data
500         for alias, driver in lookups:
501             fun = "{}.avail_locations".format(driver)
502             if fun not in self.clouds:
503                 log.debug(
504                     "The '%s' cloud driver defined under '%s' provider "
505                     "alias is unable to get the locations information",
506                     driver,
507                     alias,
508                 )
509                 continue
510             if alias not in data:
511                 data[alias] = {}
512             try:
513                 with salt.utils.context.func_globals_inject(
514                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
515                 ):
516                     data[alias][driver] = self.clouds[fun]()
517             except Exception as err:  # pylint: disable=broad-except
518                 log.error(
519                     "Failed to get the output of '%s()': %s",
520                     fun,
521                     err,
522                     exc_info_on_loglevel=logging.DEBUG,
523                 )
524         return data
525     def image_list(self, lookup="all"):
526         data = {}
527         lookups = self.lookup_providers(lookup)
528         if not lookups:
529             return data
530         for alias, driver in lookups:
531             fun = "{}.avail_images".format(driver)
532             if fun not in self.clouds:
533                 log.debug(
534                     "The '%s' cloud driver defined under '%s' provider "
535                     "alias is unable to get the images information",
536                     driver,
537                     alias,
538                 )
539                 continue
540             if alias not in data:
541                 data[alias] = {}
542             try:
543                 with salt.utils.context.func_globals_inject(
544                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
545                 ):
546                     data[alias][driver] = self.clouds[fun]()
547             except Exception as err:  # pylint: disable=broad-except
548                 log.error(
549                     "Failed to get the output of '%s()': %s",
550                     fun,
551                     err,
552                     exc_info_on_loglevel=logging.DEBUG,
553                 )
554         return data
555     def size_list(self, lookup="all"):
556         data = {}
557         lookups = self.lookup_providers(lookup)
558         if not lookups:
559             return data
560         for alias, driver in lookups:
561             fun = "{}.avail_sizes".format(driver)
562             if fun not in self.clouds:
563                 log.debug(
564                     "The '%s' cloud driver defined under '%s' provider "
565                     "alias is unable to get the sizes information",
566                     driver,
567                     alias,
568                 )
569                 continue
570             if alias not in data:
571                 data[alias] = {}
572             try:
573                 with salt.utils.context.func_globals_inject(
574                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
575                 ):
576                     data[alias][driver] = self.clouds[fun]()
577             except Exception as err:  # pylint: disable=broad-except
578                 log.error(
579                     "Failed to get the output of '%s()': %s",
580                     fun,
581                     err,
582                     exc_info_on_loglevel=logging.DEBUG,
583                 )
584         return data
585     def provider_list(self, lookup="all"):
586         data = {}
587         lookups = self.lookup_providers(lookup)
588         if not lookups:
589             return data
590         for alias, driver in lookups:
591             if alias not in data:
592                 data[alias] = {}
593             if driver not in data[alias]:
594                 data[alias][driver] = {}
595         return data
596     def profile_list(self, provider, lookup="all"):
597         data = {}
598         lookups = self.lookup_profiles(provider, lookup)
599         if not lookups:
600             return data
601         for alias, driver in lookups:
602             if alias not in data:
603                 data[alias] = {}
604             if driver not in data[alias]:
605                 data[alias][driver] = {}
606         return data
607     def create_all(self):
608         ret = []
609         for vm_name, vm_details in self.opts["profiles"].items():
610             ret.append({vm_name: self.create(vm_details)})
611         return ret
612     def destroy(self, names, cached=False):
613         processed = {}
614         names = set(names)
615         matching = self.get_running_by_names(names, cached=cached)
616         vms_to_destroy = set()
617         parallel_data = []
618         for alias, drivers in matching.items():
619             for driver, vms in drivers.items():
620                 for name in vms:
621                     if name in names:
622                         vms_to_destroy.add((alias, driver, name))
623                         if self.opts["parallel"]:
624                             parallel_data.append(
625                                 {
626                                     "opts": self.opts,
627                                     "name": name,
628                                     "alias": alias,
629                                     "driver": driver,
630                                 }
631                             )
632         if self.opts["parallel"] and parallel_data:
633             if "pool_size" in self.opts:
634                 pool_size = self.opts["pool_size"]
635             else:
636                 pool_size = len(parallel_data)
637             log.info("Destroying in parallel mode; Cloud pool size: %s", pool_size)
638             output_multip = enter_mainloop(
639                 _destroy_multiprocessing, parallel_data, pool_size=pool_size
640             )
641             ret_multip = {}
642             for obj in output_multip:
643                 ret_multip.update(obj)
644             for obj in parallel_data:
645                 alias = obj["alias"]
646                 driver = obj["driver"]
647                 name = obj["name"]
648                 if alias not in processed:
649                     processed[alias] = {}
650                 if driver not in processed[alias]:
651                     processed[alias][driver] = {}
652                 processed[alias][driver][name] = ret_multip[name]
653                 if name in names:
654                     names.remove(name)
655         else:
656             log.info("Destroying in non-parallel mode.")
657             for alias, driver, name in vms_to_destroy:
658                 fun = "{}.destroy".format(driver)
659                 with salt.utils.context.func_globals_inject(
660                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
661                 ):
662                     ret = self.clouds[fun](name)
663                 if alias not in processed:
664                     processed[alias] = {}
665                 if driver not in processed[alias]:
666                     processed[alias][driver] = {}
667                 processed[alias][driver][name] = ret
668                 if name in names:
669                     names.remove(name)
670         for alias, driver, name in vms_to_destroy:
671             ret = processed[alias][driver][name]
672             if not ret:
673                 continue
674             vm_ = {
675                 "name": name,
676                 "profile": None,
677                 "provider": ":".join([alias, driver]),
678                 "driver": driver,
679             }
680             minion_dict = salt.config.get_cloud_config_value(
681                 "minion", vm_, self.opts, default={}
682             )
683             key_file = os.path.join(
684                 self.opts["pki_dir"], "minions", minion_dict.get("id", name)
685             )
686             globbed_key_file = glob.glob("{}.*".format(key_file))
687             if not os.path.isfile(key_file) and not globbed_key_file:
688                 if isinstance(ret, dict) and "newname" in ret:
689                     salt.utils.cloud.remove_key(self.opts["pki_dir"], ret["newname"])
690                 continue
691             if os.path.isfile(key_file) and not globbed_key_file:
692                 salt.utils.cloud.remove_key(
693                     self.opts["pki_dir"], os.path.basename(key_file)
694                 )
695                 continue
696             if (
697                 not os<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.isfile(key_file)
698                 and globbed_key_file
699                 and len(globbed_key_file) == 1
700             ):
701                 salt.utils.cloud.remove_key(
702                     self.opts["pki_dir"], os.path.basename(globbed_key_file[</b></font>0])
703                 )
704                 continue
705             print(
706                 "There are several minion keys who's name starts "
707                 "with '{}'. We need to ask you which one should be "
708                 "deleted:".format(name)
709             )
710             while True:
711                 for idx, filename in enumerate(globbed_key_file):
712                     print(" {}: {}".format(idx, os.path.basename(filename)))
713                 selection = input("Which minion key should be deleted(number)? ")
714                 try:
715                     selection = int(selection)
716                 except ValueError:
717                     print("'{}' is not a valid selection.".format(selection))
718                 try:
719                     filename = os.path.basename(globbed_key_file.pop(selection))
720                 except Exception:  # pylint: disable=broad-except
721                     continue
722                 delete = input("Delete '{}'? [Y/n]? ".format(filename))
723                 if delete == "" or delete.lower().startswith("y"):
724                     salt.utils.cloud.remove_key(self.opts["pki_dir"], filename)
725                     print("Deleted '{}'".format(filename))
726                     break
727                 print("Did not delete '{}'".format(filename))
728                 break
729         if names and not processed:
730             raise SaltCloudSystemExit(
731                 "The following VM's were not found: {}".format(", ".join(names))
732             )
733         elif names and processed:
734             processed["Not Found"] = names
735         elif not processed:
736             raise SaltCloudSystemExit("No machines were destroyed!")
737         return processed
738     def reboot(self, names):
739         ret = []
740         pmap = self.map_providers_parallel()
741         acts = {}
742         for prov, nodes in pmap.items():
743             acts[prov] = []
744             for node in nodes:
745                 if node in names:
746                     acts[prov].append(node)
747         for prov, names_ in acts.items():
748             fun = "{}.reboot".format(prov)
749             for name in names_:
750                 ret.append({name: self.clouds[fun](name)})
751         return ret
752     def create(self, vm_, local_master=True):
753         output = {}
754         minion_dict = salt.config.get_cloud_config_value(
755             "minion", vm_, self.opts, default={}
756         )
757         alias, driver = vm_["provider"].split(":")
758         fun = "{}.create".format(driver)
759         if fun not in self.clouds:
760             log.error(
761                 "Creating '%s' using '%s' as the provider "
762                 "cannot complete since '%s' is not available",
763                 vm_["name"],
764                 vm_["provider"],
765                 driver,
766             )
767             return
768         deploy = salt.config.get_cloud_config_value("deploy", vm_, self.opts)
769         make_master = salt.config.get_cloud_config_value("make_master", vm_, self.opts)
770         if deploy:
771             if not make_master and "master" not in minion_dict:
772                 log.warning(
773                     "There's no master defined on the '%s' VM settings.", vm_["name"]
774             if "pub_key" not in vm_ and "priv_key" not in vm_:
775                 log.debug("Generating minion keys for '%s'", vm_<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["name"])
776                 priv, pub = salt.utils.cloud.gen_keys(
777                     salt.config.get_cloud_config_value("keysize", vm_, self.opts)
778                 )
779                 vm_["pub_key"] = pub
780                 vm_[</b></font>"priv_key"] = priv
781         else:
782             vm_["pub_key"] = None
783             vm_["priv_key"] = None
784         key_id = minion_dict.get("id", vm_["name"])
785         domain = vm_.get("domain")
786         if vm_.get("use_fqdn") and domain:
787             minion_dict["append_domain"] = domain
788         if "append_domain" in minion_dict:
789             key_id = ".".join([key_id, minion_dict["append_domain"]])
790         if make_master is True and "master_pub" not in vm_ and "master_pem" not in vm_:
791             log.debug("Generating the master keys for '%s'", vm_["name"])
792             master_priv, master_pub = salt.utils.cloud.gen_keys(
793                 salt.config.get_cloud_config_value("keysize", vm_, self.opts)
794             )
795             vm_["master_pub"] = master_pub
796             vm_["master_pem"] = master_priv
797         if local_master is True and deploy is True:
798             salt.utils.cloud.accept_key(self.opts["pki_dir"], vm_["pub_key"], key_id)
799         vm_["os"] = salt.config.get_cloud_config_value("script", vm_, self.opts)
800         try:
801             vm_["inline_script"] = salt.config.get_cloud_config_value(
802                 "inline_script", vm_, self.opts
803             )
804         except KeyError:
805             pass
806         try:
807             alias, driver = vm_["provider"].split(":")
808             func = "{}.create".format(driver)
809             with salt.utils.context.func_globals_inject(
810                 self.clouds[fun], __active_provider_name__=":".join([alias, driver])
811             ):
812                 output = self.clouds[func](vm_)
813             if output is not False and "sync_after_install" in self.opts:
814                 if self.opts["sync_after_install"] not in (
815                     "all",
816                     "modules",
817                     "states",
818                     "grains",
819                 ):
820                     log.error("Bad option for sync_after_install")
821                     return output
822                 time.sleep(3)
823                 start = int(time.time())
824                 while int(time.time()) &lt; start + 60:
825                     mopts_ = salt.config.DEFAULT_MASTER_OPTS
826                     conf_path = "/".join(self.opts["conf_file"].split("/")[:-1])
827                     mopts_.update(
828                         salt.config.master_config(os.path.join(conf_path, "master"))
829                     )
830                     with salt.client.get_local_client(mopts=mopts_) as client:
831                         ret = client.cmd(
832                             vm_["name"],
833                             "saltutil.sync_{}".format(self.opts["sync_after_install"]),
834                             timeout=self.opts["timeout"],
835                         )
836                         if ret:
837                             log.info(
838                                 "Synchronized the following dynamic modules: %s", ret
839                             )
840                             break
841         except KeyError as exc:
842             log.exception(
843                 "Failed to create VM %s. Configuration value %s needs to be set",
844                 vm_["name"],
845                 exc,
846             )
847         try:
848             opt_map = self.opts["map"]
849         except KeyError:
850             opt_map = False
851         if self.opts["parallel"] and self.opts["start_action"] and not opt_map:
852             log.info("Running %s on %s", self.opts["start_action"], vm_["name"])
853             with salt.client.get_local_client(mopts=self.opts) as client:
854                 action_out = client.cmd(
855                     vm_["name"],
856                     self.opts["start_action"],
857                     timeout=self.opts["timeout"] * 60,
858                 )
859             output["ret"] = action_out
860         return output
861     @staticmethod
862     def vm_config(name, main, provider, profile, overrides):
863         vm = main.copy()
864         vm = salt.utils.dictupdate.update(vm, provider)
865         vm = salt.utils.dictupdate.update(vm, profile)
866         vm.update(overrides)
867         vm["name"] = name
868         return vm
869     def extras(self, extra_):
870         output = {}
871         alias, driver = extra_["provider"].split(":")
872         fun = "{}.{}".format(driver, extra_["action"])
873         if fun not in self.clouds:
874             log.error(
875                 "Creating '%s' using '%s' as the provider "
876                 "cannot complete since '%s' is not available",
877                 extra_["name"],
878                 extra_["provider"],
879                 driver,
880             )
881             return
882         try:
883             with salt.utils.context.func_globals_inject(
884                 self.clouds[fun], __active_provider_name__=extra_["provider"]
885             ):
886                 output = self.clouds[fun](**extra_)
887         except KeyError as exc:
888             log.exception(
889                 "Failed to perform %s.%s on %s. Configuration value %s needs to be set",
890                 extra_["provider"],
891                 extra_["action"],
892                 extra_["name"],
893                 exc,
894             )
895         return output
896     def run_profile(self, profile, names, vm_overrides=None):
897         if profile not in self.opts["profiles"]:
898             msg = "Profile {} is not defined".format(profile)
899             log.error(msg)
900             return {"Error": msg}
901         ret = {}
902         if not vm_overrides:
903             vm_overrides = {}
904         try:
905             with salt.utils.files.fopen(self.opts["conf_file"], "r") as mcc:
906                 main_cloud_config = salt.utils.yaml.safe_load(mcc)
907             if not main_cloud_config:
908                 main_cloud_config = {}
909         except KeyError:
910             main_cloud_config = {}
911         except OSError:
912             main_cloud_config = {}
913         if main_cloud_config is None:
914             main_cloud_config = {}
915         mapped_providers = self.map_providers_parallel()
916         profile_details = self.opts["profiles"][profile]
917         vms = {}
918         for prov, val in mapped_providers.items():
919             prov_name = next(iter(val))
920             for node in mapped_providers[prov][prov_name]:
921                 vms[node] = mapped_providers[prov][prov_name][node]
922                 vms[node]["provider"] = prov
923                 vms[node]["driver"] = prov_name
924         alias, driver = profile_details["provider"].split(":")
925         provider_details = self.opts["providers"][alias][driver].copy()
926         del provider_details["profiles"]
927         for name in names:
928             if name in vms:
929                 prov = vms[name]["provider"]
930                 driv = vms[name]["driver"]
931                 msg = "{} already exists under {}:{}".format(name, prov, driv)
932                 log.error(msg)
933                 ret[name] = {"Error": msg}
934                 continue
935             vm_ = self.vm_config(
936                 name,
937                 main_cloud_config,
938                 provider_details,
939                 profile_details,
940                 vm_overrides,
941             )
942             if self.opts["parallel"]:
943                 process = multiprocessing.Process(target=self.create, args=(vm_,))
944                 process.start()
945                 ret[name] = {
946                     "Provisioning": "VM being provisioned in parallel. PID: {}".format(
947                         process.pid
948                     )
949                 }
950                 continue
951             try:
952                 ret[name] = self.create(vm_)
953                 if not ret[name]:
954                     ret[name] = {"Error": "Failed to deploy VM"}
955                     if len(names) == 1:
956                         raise SaltCloudSystemExit("Failed to deploy VM")
957                     continue
958                 if self.opts.get("show_deploy_args", False) is False:
959                     ret[name].pop("deploy_kwargs", None)
960             except (SaltCloudSystemExit, SaltCloudConfigError) as exc:
961                 if len(names) == 1:
962                     raise
963                 ret[name] = {"Error": str(exc)}
964         return ret
965     def do_action(self, names, kwargs):
966         ret = {}
967         invalid_functions = {}
968         names = set(names)
969         for alias, drivers in self.map_providers_parallel().items():
970             if not names:
971                 break
972             for driver, vms in drivers.items():
973                 if not names:
974                     break
975                 valid_function = True
976                 fun = "{}.{}".format(driver, self.opts["action"])
977                 if fun not in self.clouds:
978                     log.info("'%s()' is not available. Not actioning...", fun)
979                     valid_function = False
980                 for vm_name, vm_details in vms.items():
981                     if not names:
982                         break
983                     if vm_name not in names:
984                         if not isinstance(vm_details, dict):
985                             vm_details = {}
986                         if "id" in vm_details and vm_details["id"] in names:
987                             vm_name = vm_details["id"]
988                         else:
989                             log.debug(
990                                 "vm:%s in provider:%s is not in name list:'%s'",
991                                 vm_name,
992                                 driver,
993                                 names,
994                             )
995                             continue
996                     if valid_function is False:
997                         if invalid_functions.get(fun) is None:
998                             invalid_functions.update({fun: []})
999                         invalid_functions[fun].append(vm_name)
1000                         continue
1001                     with salt.utils.context.func_globals_inject(
1002                         self.clouds[fun],
1003                         __active_provider_name__=":".join([alias, driver]),
1004                     ):
1005                         if alias not in ret:
1006                             ret[alias] = {}
1007                         if driver not in ret[alias]:
1008                             ret[alias][driver] = {}
1009                         kwargs = salt.utils.args.clean_kwargs(**kwargs)
1010                         if kwargs:
1011                             ret[alias][driver][vm_name] = self.clouds[fun](
1012                                 vm_name, kwargs, call="action"
1013                             )
1014                         else:
1015                             ret[alias][driver][vm_name] = self.clouds[fun](
1016                                 vm_name, call="action"
1017                             )
1018                         names.remove(vm_name)
1019         missing_vms = set()
1020         if invalid_functions:
1021             ret["Invalid Actions"] = invalid_functions
1022             invalid_func_vms = set()
1023             for key, val in invalid_functions.items():
1024                 invalid_func_vms = invalid_func_vms.union(set(val))
1025             missing_vms = names.difference(invalid_func_vms)
1026             if missing_vms:
1027                 ret["Not Found"] = list(missing_vms)
1028                 ret["Not Actioned/Not Running"] = list(names)
1029         if not names:
1030             return ret
1031         if missing_vms:
1032             return ret
1033         ret["Not Actioned/Not Running"] = list(names)
1034         ret["Not Found"] = list(names)
1035         return ret
1036     def do_function(self, prov, func, kwargs):
1037         matches = self.lookup_providers(prov)
1038         if len(matches) &gt; 1:
1039             raise SaltCloudSystemExit(
1040                 "More than one results matched '{}'. Please specify one of: {}".format(
1041                     prov,
1042                     ", ".join(
1043                         ["{}:{}".format(alias, driver) for (alias, driver) in matches]
1044                     ),
1045                 )
1046             )
1047         alias, driver = matches.pop()
1048         fun = "{}.{}".format(driver, func)
1049         if fun not in self.clouds:
1050             raise SaltCloudSystemExit(
1051                 "The '{}' cloud provider alias, for the '{}' driver, does "
1052                 "not define the function '{}'".format(alias, driver, func)
1053             )
1054         log.debug("Trying to execute '%s' with the following kwargs: %s", fun, kwargs)
1055         with salt.utils.context.func_globals_inject(
1056             self.clouds[fun], __active_provider_name__=":".join([alias, driver])
1057         ):
1058             if kwargs:
1059                 return {
1060                     alias: {driver: self.clouds[fun](call="function", kwargs=kwargs)}
1061                 }
1062             return {alias: {driver: self.clouds[fun](call="function")}}
1063     def __filter_non_working_providers(self):
1064         for alias, drivers in self.opts["providers"].copy().items():
1065             for driver in drivers.copy():
1066                 fun = "{}.get_configured_provider".format(driver)
1067                 if fun not in self.clouds:
1068                     log.warning(
1069                         "The cloud driver, '%s', configured under the "
1070                         "'%s' cloud provider alias, could not be loaded. "
1071                         "Please check your provider configuration files and "
1072                         "ensure all required dependencies are installed "
1073                         "for the '%s' driver.\n"
1074                         "In rare cases, this could indicate the '%s()' "
1075                         "function could not be found.\nRemoving '%s' from "
1076                         "the available providers list",
1077                         driver,
1078                         alias,
1079                         driver,
1080                         fun,
1081                         driver,
1082                     )
1083                     self.opts["providers"][alias].pop(driver)
1084                     if alias not in self.opts["providers"]:
1085                         continue
1086                     if not self.opts["providers"][alias]:
1087                         self.opts["providers"].pop(alias)
1088                     continue
1089                 with salt.utils.context.func_globals_inject(
1090                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
1091                 ):
1092                     if self.clouds[fun]() is False:
1093                         log.warning(
1094                             "The cloud driver, '%s', configured under the "
1095                             "'%s' cloud provider alias is not properly "
1096                             "configured. Removing it from the available "
1097                             "providers list.",
1098                             driver,
1099                             alias,
1100                         )
1101                         self.opts["providers"][alias].pop(driver)
1102             if alias not in self.opts["providers"]:
1103                 continue
1104             if not self.opts["providers"][alias]:
1105                 self.opts["providers"].pop(alias)
1106 class Map(Cloud):
1107     def __init__(self, opts):
1108         Cloud.__init__(self, opts)
1109         self.rendered_map = self.read()
1110     def interpolated_map(self, query="list_nodes", cached=False):
1111         rendered_map = self.read().copy()
1112         interpolated_map = {}
1113         for profile, mapped_vms in rendered_map.items():
1114             names = set(mapped_vms)
1115             if profile not in self.opts["profiles"]:
1116                 if "Errors" not in interpolated_map:
1117                     interpolated_map["Errors"] = {}
1118                 msg = (
1119                     "No provider for the mapped '{}' profile was found. "
1120                     "Skipped VMS: {}".format(profile, ", ".join(names))
1121                 )
1122                 log.info(msg)
1123                 interpolated_map["Errors"][profile] = msg
1124                 continue
1125             matching = self.get_running_by_names(names, query, cached)
1126             for alias, drivers in matching.items():
1127                 for driver, vms in drivers.items():
1128                     for vm_name, vm_details in vms.items():
1129                         if alias not in interpolated_map:
1130                             interpolated_map[alias] = {}
1131                         if driver not in interpolated_map[alias]:
1132                             interpolated_map[alias][driver] = {}
1133                         interpolated_map[alias][driver][vm_name] = vm_details
1134                         try:
1135                             names.remove(vm_name)
1136                         except KeyError:
1137                             pass
1138             if not names:
1139                 continue
1140             profile_details = self.opts["profiles"][profile]
1141             alias, driver = profile_details["provider"].split(":")
1142             for vm_name in names:
1143                 if alias not in interpolated_map:
1144                     interpolated_map[alias] = {}
1145                 if driver not in interpolated_map[alias]:
1146                     interpolated_map[alias][driver] = {}
1147                 interpolated_map[alias][driver][vm_name] = "Absent"
1148         return interpolated_map
1149     def delete_map(self, query=None):
1150         query_map = self.interpolated_map(query=query)
1151         for alias, drivers in query_map.copy().items():
1152             if alias == "Errors":
1153                 continue
1154             for driver, vms in drivers.copy().items():
1155                 for vm_name, vm_details in vms.copy().items():
1156                     if vm_details == "Absent":
1157                         query_map[alias][driver].pop(vm_name)
1158                 if not query_map[alias][driver]:
1159                     query_map[alias].pop(driver)
1160             if not query_map[alias]:
1161                 query_map.pop(alias)
1162         return query_map
1163     def get_vmnames_by_action(self, action):
1164         query_map = self.interpolated_map("list_nodes")
1165         matching_states = {
1166             "start": ["stopped"],
1167             "stop": ["running", "active"],
1168             "reboot": ["running", "active"],
1169         }
1170         vm_names = []
1171         for alias, drivers in query_map.items():
1172             for driver, vms in drivers.items():
1173                 for vm_name, vm_details in vms.items():
1174                     try:
1175                         state_action = matching_states[action]
1176                     except KeyError:
1177                         log.error(
1178                             "The use of '%s' as an action is not supported "
1179                             "in this context. Only 'start', 'stop', and "
1180                             "'reboot' are supported options.",
1181                             action,
1182                         )
1183                         raise SaltCloudException()
1184                     if (
1185                         vm_details != "Absent"
1186                         and vm_details["state"].lower() in state_action
1187                     ):
1188                         vm_names.append(vm_name)
1189         return vm_names
1190     def read(self):
1191         map_ = None
1192         if self.opts.get("map", None) is None:
1193             if self.opts.get("map_data", None) is None:
1194                 if self.opts.get("map_pillar", None) is None:
1195                     pass
1196                 elif self.opts.get("map_pillar") not in self.opts.get("maps"):
1197                     log.error(
1198                         "The specified map not found in pillar at 'cloud:maps:%s'",
1199                         self.opts["map_pillar"],
1200                     )
1201                     raise SaltCloudNotFound()
1202                 else:
1203                     map_ = self.opts["maps"][self.opts.get("map_pillar")]
1204             else:
1205                 map_ = self.opts["map_data"]
1206         else:
1207             local_minion_opts = copy.deepcopy(self.opts)
1208             local_minion_opts["file_client"] = "local"
1209             self.minion = salt.minion.MasterMinion(local_minion_opts)
1210             if not os.path.isfile(self.opts["map"]):
1211                 if not (self.opts["map"]).startswith("salt://"):
1212                     log.error(
1213                         "The specified map file does not exist: '%s'", self.opts["map"]
1214                     )
1215                     raise SaltCloudNotFound()
1216             if (self.opts["map"]).startswith("salt://"):
1217                 cached_map = self.minion.functions["cp.cache_file"](self.opts["map"])
1218             else:
1219                 cached_map = self.opts["map"]
1220             try:
1221                 renderer = self.opts.get("renderer", "jinja|yaml")
1222                 rend = salt.loader.render(self.opts, {})
1223                 blacklist = self.opts.get("renderer_blacklist")
1224                 whitelist = self.opts.get("renderer_whitelist")
1225                 map_ = compile_template(
1226                     cached_map, rend, renderer, blacklist, whitelist
1227                 )
1228             except Exception as exc:  # pylint: disable=broad-except
1229                 log.error(
1230                     "Rendering map %s failed, render error:\n%s",
1231                     self.opts["map"],
1232                     exc,
1233                     exc_info_on_loglevel=logging.DEBUG,
1234                 )
1235                 return {}
1236             if "include" in map_:
1237                 map_ = salt.config.include_config(map_, self.opts["map"], verbose=False)
1238         if not map_:
1239             return {}
1240         for profile, mapped in map_.copy().items():
1241             if isinstance(mapped, (list, tuple)):
1242                 entries = {}
1243                 for mapping in mapped:
1244                     if isinstance(mapping, str):
1245                         mapping = {mapping: None}
1246                     for name, overrides in mapping.items():
1247                         if overrides is None or isinstance(overrides, bool):
1248                             overrides = {}
1249                         try:
1250                             overrides.setdefault("name", name)
1251                         except AttributeError:
1252                             log.error(
1253                                 "Cannot use 'name' as a minion id in a cloud map as it"
1254                                 " is a reserved word. Please change 'name' to a"
1255                                 " different minion id reference."
1256                             )
1257                             return {}
1258                         entries[name] = overrides
1259                 map_[profile] = entries
1260                 continue
1261             if isinstance(mapped, dict):
1262                 entries = {}
1263                 for name, overrides in mapped.items():
1264                     overrides.setdefault("name", name)
1265                     entries[name] = overrides
1266                 map_[profile] = entries
1267                 continue
1268             if isinstance(mapped, str):
1269                 mapped = [mapped]
1270             map_[profile] = {}
1271             for name in mapped:
1272                 map_[profile][name] = {"name": name}
1273         return map_
1274     def _has_loop(self, dmap, seen=None, val=None):
1275         if seen is None:
1276             for values in dmap["create"].values():
1277                 seen = []
1278                 try:
1279                     machines = values["requires"]
1280                 except KeyError:
1281                     machines = []
1282                 for machine in machines:
1283                     if self._has_loop(dmap, seen=list(seen), val=machine):
1284                         return True
1285         else:
1286             if val in seen:
1287                 return True
1288             seen.append(val)
1289             try:
1290                 machines = dmap["create"][val]["requires"]
1291             except KeyError:
1292                 machines = []
1293             for machine in machines:
1294                 if self._has_loop(dmap, seen=list(seen), val=machine):
1295                     return True
1296         return False
1297     def _calcdep(self, dmap, machine, data, level):
1298         try:
1299             deplist = data["requires"]
1300         except KeyError:
1301             return level
1302         levels = []
1303         for name in deplist:
1304             try:
1305                 data = dmap["create"][name]
1306             except KeyError:
1307                 try:
1308                     data = dmap["existing"][name]
1309                 except KeyError:
1310                     msg = "Missing dependency in cloud map"
1311                     log.error(msg)
1312                     raise SaltCloudException(msg)
1313             levels.append(self._calcdep(dmap, name, data, level))
1314         level = max(levels) + 1
1315         return level
1316     def map_data(self, cached=False):
1317         ret = {"create": {}}
1318         pmap = self.map_providers_parallel(cached=cached)
1319         exist = set()
1320         defined = set()
1321         rendered_map = copy.deepcopy(self.rendered_map)
1322         for profile_name, nodes in rendered_map.items():
1323             if profile_name not in self.opts["profiles"]:
1324                 msg = (
1325                     "The required profile, '{}', defined in the map "
1326                     "does not exist. The defined nodes, {}, will not "
1327                     "be created.".format(
1328                         profile_name, ", ".join("'{}'".format(node) for node in nodes)
1329                     )
1330                 )
1331                 log.error(msg)
1332                 if "errors" not in ret:
1333                     ret["errors"] = {}
1334                 ret["errors"][profile_name] = msg
1335                 continue
1336             profile_data = self.opts["profiles"].get(profile_name)
1337             for nodename, overrides in nodes.items():
1338                 if (
1339                     "provider" in overrides
1340                     and overrides["provider"] != profile_data["provider"]
1341                 ):
1342                     alias, driver = overrides.get("provider").split(":")
1343                 else:
1344                     alias, driver = profile_data.get("provider").split(":")
1345                 provider_details = copy.deepcopy(self.opts["providers"][alias][driver])
1346                 del provider_details["profiles"]
1347                 salt.utils.dictupdate.update(provider_details, profile_data)
1348                 nodedata = copy.deepcopy(provider_details)
1349                 for setting in ("grains", "master", "minion", "volumes", "requires"):
1350                     deprecated = "map_{}".format(setting)
1351                     if deprecated in overrides:
1352                         log.warning(
1353                             "The use of '%s' on the '%s' mapping has "
1354                             "been deprecated. The preferred way now is to "
1355                             "just define '%s'. For now, salt-cloud will do "
1356                             "the proper thing and convert the deprecated "
1357                             "mapping into the preferred one.",
1358                             deprecated,
1359                             nodename,
1360                             setting,
1361                         )
1362                         overrides[setting] = overrides.pop(deprecated)
1363                 if (
1364                     "minion" in overrides
1365                     and "minion" in nodedata
1366                     and "grains" in overrides["minion"]
1367                     and "grains" in nodedata["minion"]
1368                 ):
1369                     nodedata["minion"]["grains"].update(overrides["minion"]["grains"])
1370                     del overrides["minion"]["grains"]
1371                     if not overrides["minion"]:
1372                         del overrides["minion"]
1373                 nodedata = salt.utils.dictupdate.update(nodedata, overrides)
1374                 ret["create"][nodename] = nodedata
1375                 alias, driver = nodedata["provider"].split(":")
1376                 defined.add((alias, driver, nodename))
1377         def get_matching_by_name(name):
1378             matches = {}
1379             for alias, drivers in pmap.items():
1380                 for driver, vms in drivers.items():
1381                     for vm_name, details in vms.items():
1382                         if vm_name == name and driver not in matches:
1383                             matches[driver] = details["state"]
1384             return matches
1385         for alias, drivers in pmap.items():
1386             for driver, vms in drivers.items():
1387                 for name, details in vms.items():
1388                     exist.add((alias, driver, name))
1389                     if name not in ret["create"]:
1390                         continue
1391                     matching = get_matching_by_name(name)
1392                     if not matching:
1393                         continue
1394                     for item in matching:
1395                         if name not in ret["create"]:
1396                             break
1397                         log.warning(
1398                             "%r already exists, removing from the create map.", name
1399                         )
1400                         if "existing" not in ret:
1401                             ret["existing"] = {}
1402                         ret["existing"][name] = ret["create"].pop(name)
1403         if "hard" in self.opts and self.opts["hard"]:
1404             if self.opts["enable_hard_maps"] is False:
1405                 raise SaltCloudSystemExit(
1406                     "The --hard map can be extremely dangerous to use, "
1407                     "and therefore must explicitly be enabled in the main "
1408                     "configuration file, by setting 'enable_hard_maps' "
1409                     "to True"
1410                 )
1411             ret["destroy"] = exist.difference(defined)
1412         return ret
1413     def run_map(self, dmap):
1414         if self._has_loop(dmap):
1415             msg = "Uh-oh, that cloud map has a dependency loop!"
1416             log.error(msg)
1417             raise SaltCloudException(msg)
1418         for key, val in dmap["create"].items():
1419             log.info("Calculating dependencies for %s", key)
1420             level = 0
1421             level = self._calcdep(dmap, key, val, level)
1422             log.debug("Got execution order %s for %s", level, key)
1423             dmap["create"][key]["level"] = level
1424         try:
1425             existing_list = dmap["existing"].items()
1426         except KeyError:
1427             existing_list = {}.items()
1428         for key, val in existing_list:
1429             log.info("Calculating dependencies for %s", key)
1430             level = 0
1431             level = self._calcdep(dmap, key, val, level)
1432             log.debug("Got execution order %s for %s", level, key)
1433             dmap["existing"][key]["level"] = level
1434         create_list = sorted(dmap["create"].items(), key=lambda x: x[1]["level"])
1435         output = {}
1436         if self.opts["parallel"]:
1437             parallel_data = []
1438         master_name = None
1439         master_minion_name = None
1440         master_host = None
1441         master_finger = None
1442         try:
1443             master_name, master_profile = next(
1444                 (
1445                     (name, profile)
1446                     for name, profile in create_list
1447                     if profile.get("make_master", False) is True
1448                 )
1449             )
1450             master_minion_name = master_name
1451             log.debug("Creating new master '%s'", master_name)
1452             if (
1453                 salt.config.get_cloud_config_value("deploy", master_profile, self.opts)
1454                 is False
1455             ):
1456                 raise SaltCloudSystemExit(
1457                     "Cannot proceed with 'make_master' when salt deployment "
1458                     "is disabled(ex: --no-deploy)."
1459                 )
1460             log.debug("Generating master keys for '%s'", master_profile["name"])
1461             priv, pub = salt.utils.cloud.gen_keys(
1462                 salt.config.get_cloud_config_value("keysize", master_profile, self.opts)
1463             )
1464             master_profile["master_pub"] = pub
1465             master_profile["master_pem"] = priv
1466             master_temp_pub = salt.utils.files.mkstemp()
1467             with salt.utils.files.fopen(master_temp_pub, "w") as mtp:
1468                 mtp.write(pub)
1469             master_finger = salt.utils.crypt.pem_finger(
1470                 master_temp_pub, sum_type=self.opts["hash_type"]
1471             )
1472             os.unlink(master_temp_pub)
1473             if master_profile.get("make_minion", True) is True:
1474                 master_profile.setdefault("minion", {})
1475                 if "id" in master_profile["minion"]:
1476                     master_minion_name = master_profile["minion"]["id"]
1477                 if "master" not in master_profile["minion"]:
1478                     master_profile["minion"]["master"] = "127.0.0.1"
1479                     if master_finger is not None:
1480                         master_profile["master_finger"] = master_finger
1481             for name, profile in create_list:
1482                 make_minion = salt.config.get_cloud_config_value(
1483                     "make_minion", profile, self.opts, default=True
1484                 )
1485                 if make_minion is False:
1486                     continue
1487                 log.debug("Generating minion keys for '%s'", profile["name"])
1488                 priv, pub = salt.utils.cloud.gen_keys(
1489                     salt.config.get_cloud_config_value("keysize", profile, self.opts)
1490                 )
1491                 profile["pub_key"] = pub
1492                 profile["priv_key"] = priv
1493                 master_profile.setdefault("preseed_minion_keys", {})
1494                 master_profile["preseed_minion_keys"].update({name: pub})
1495             local_master = False
1496             if (
1497                 master_profile["minion"].get("local_master", False)
1498                 and master_profile["minion"].get("master", None) is not None
1499             ):
1500                 local_master = True
1501             out = self.create(master_profile, local_master=local_master)
1502             if not isinstance(out, dict):
1503                 log.debug("Master creation details is not a dictionary: %s", out)
1504             elif "Errors" in out:
1505                 raise SaltCloudSystemExit(
1506                     "An error occurred while creating the master, not "
1507                     "continuing: {}".format(out["Errors"])
1508                 )
1509             deploy_kwargs = (
1510                 self.opts.get("show_deploy_args", False) is True
1511                 and
1512                 out.get("deploy_kwargs", {})
1513                 or
1514                 out.pop("deploy_kwargs", {})
1515             )
1516             master_host = deploy_kwargs.get(
1517                 "salt_host", deploy_kwargs.get("host", None)
1518             )
1519             if master_host is None:
1520                 raise SaltCloudSystemExit(
1521                     "Host for new master {} was not found, aborting map".format(
1522                         master_name
1523                     )
1524                 )
1525             output[master_name] = out
1526         except StopIteration:
1527             log.debug("No make_master found in map")
1528             master_pub = os.path.join(self.opts["pki_dir"], "master.pub")
1529             if os.path.isfile(master_pub):
1530                 master_finger = salt.utils.crypt.pem_finger(
1531                     master_pub, sum_type=self.opts["hash_type"]
1532                 )
1533         opts = self.opts.copy()
1534         if self.opts["parallel"]:
1535             log.info(
1536                 "Since parallel deployment is in use, ssh console output "
1537                 "is disabled. All ssh output will be logged though"
1538             )
1539             opts["display_ssh_output"] = False
1540         local_master = master_name is None
1541         for name, profile in create_list:
1542             if name in (master_name, master_minion_name):
1543                 continue
1544             if (
1545                 "minion" in profile
1546                 and profile["minion"].get("local_master", False)
1547                 and profile["minion"].get("master", None) is not None
1548             ):
1549                 local_master = True
1550             if master_finger is not None and local_master is False:
1551                 profile["master_finger"] = master_finger
1552             if master_host is not None:
1553                 profile.setdefault("minion", {})
1554                 profile["minion"].setdefault("master", master_host)
1555             if self.opts["parallel"]:
1556                 parallel_data.append(
1557                     {
1558                         "opts": opts,
1559                         "name": name,
1560                         "profile": profile,
1561                         "local_master": local_master,
1562                     }
1563                 )
1564                 continue
1565             try:
1566                 output[name] = self.create(profile, local_master=local_master)
1567                 if (
1568                     self.opts.get("show_deploy_args", False) is False
1569                     and "deploy_kwargs" in output
1570                     and isinstance(output[name], dict)
1571                 ):
1572                     output[name].pop("deploy_kwargs", None)
1573             except SaltCloudException as exc:
1574                 log.error(
1575                     "Failed to deploy '%s'. Error: %s",
1576                     name,
1577                     exc,
1578                     exc_info_on_loglevel=logging.DEBUG,
1579                 )
1580                 output[name] = {"Error": str(exc)}
1581         for name in dmap.get("destroy", ()):
1582             output[name] = self.destroy(name)
1583         if self.opts["parallel"] and parallel_data:
1584             if "pool_size" in self.opts:
1585                 pool_size = self.opts["pool_size"]
1586             else:
1587                 pool_size = len(parallel_data)
1588             log.info("Cloud pool size: %s", pool_size)
1589             output_multip = enter_mainloop(
1590                 _create_multiprocessing, parallel_data, pool_size=pool_size
1591             )
1592             if self.opts["start_action"]:
1593                 actionlist = []
1594                 grp = -1
1595                 for key, val in groupby(dmap["create"].values(), lambda x: x["level"]):
1596                     actionlist.append([])
1597                     grp += 1
1598                     for item in val:
1599                         actionlist[grp].append(item["name"])
1600                 out = {}
1601                 for group in actionlist:
1602                     log.info(
1603                         "Running %s on %s", self.opts["start_action"], ", ".join(group)
1604                     )
1605                     with salt.client.get_local_client() as client:
1606                         out.update(
1607                             client.cmd(
1608                                 ",".join(group),
1609                                 self.opts["start_action"],
1610                                 timeout=self.opts["timeout"] * 60,
1611                                 tgt_type="list",
1612                             )
1613                         )
1614                 for obj in output_multip:
1615                     next(iter(obj.values()))["ret"] = out[next(iter(obj.keys()))]
1616                     output.update(obj)
1617             else:
1618                 for obj in output_multip:
1619                     output.update(obj)
1620         return output
1621 def init_pool_worker():
1622     signal.signal(signal.SIGINT, signal.SIG_IGN)
1623 def create_multiprocessing(parallel_data, queue=None):
1624     salt.utils.crypt.reinit_crypto()
1625     parallel_data["opts"]["output"] = "json"
1626     cloud = Cloud(parallel_data["opts"])
1627     try:
1628         output = cloud.create(
1629             parallel_data["profile"], local_master=parallel_data["local_master"]
1630         )
1631     except SaltCloudException as exc:
1632         log.error(
1633             "Failed to deploy '%s'. Error: %s",
1634             parallel_data["name"],
1635             exc,
1636             exc_info_on_loglevel=logging.DEBUG,
1637         )
1638         return {parallel_data["name"]: {"Error": str(exc)}}
1639     if parallel_data["opts"].get("show_deploy_args", False) is False and isinstance(
1640         output, dict
1641     ):
1642         output.pop("deploy_kwargs", None)
1643     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
1644 def destroy_multiprocessing(parallel_data, queue=None):
1645     salt.utils.crypt.reinit_crypto()
1646     parallel_data["opts"]["output"] = "json"
1647     clouds = salt.loader.clouds(parallel_data["opts"])
1648     try:
1649         fun = clouds["{}.destroy".format(parallel_data["driver"])]
1650         with salt.utils.context.func_globals_inject(
1651             fun,
1652             __active_provider_name__=":".join(
1653                 [parallel_data["alias"], parallel_data["driver"]]
1654             ),
1655         ):
1656             output = fun(parallel_data["name"])
1657     except SaltCloudException as exc:
1658         log.error(
1659             "Failed to destroy %s. Error: %s",
1660             parallel_data["name"],
1661             exc,
1662             exc_info_on_loglevel=logging.DEBUG,
1663         )
1664         return {parallel_data["name"]: {"Error": str(exc)}}
1665     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
1666 def run_parallel_map_providers_query(data, queue=None):
1667     salt.utils.crypt.reinit_crypto()
1668     cloud = Cloud(data["opts"])
1669     try:
1670         with salt.utils.context.func_globals_inject(
1671             cloud.clouds[data["fun"]],
1672             __active_provider_name__=":".join([data["alias"], data["driver"]]),
1673         ):
1674             return (
1675                 data["alias"],
1676                 data["driver"],
1677                 salt.utils.data.simple_types_filter(cloud.clouds[data["fun"]]()),
1678             )
1679     except Exception as err:  # pylint: disable=broad-except
1680         log.debug(
1681             "Failed to execute '%s()' while querying for running nodes: %s",
1682             data["fun"],
1683             err,
1684             exc_info_on_loglevel=logging.DEBUG,
1685         )
1686         return data["alias"], data["driver"], ()
1687 def _run_parallel_map_providers_query(*args, **kw):
1688     return communicator(run_parallel_map_providers_query)(*args[0], **kw)
1689 def _destroy_multiprocessing(*args, **kw):
1690     return communicator(destroy_multiprocessing)(*args[0], **kw)
1691 def _create_multiprocessing(*args, **kw):
1692     return communicator(create_multiprocessing)(*args[0], **kw)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pydsl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import io
2 import os
3 import shutil
4 import sys
5 import tempfile
6 import textwrap
7 import pytest
8 import salt.config
9 import salt.loader
10 import salt.utils.files
11 import salt.utils.versions
12 from salt.state import HighState
13 from salt.utils.pydsl import PyDslError
14 from tests.support.helpers import with_tempdir
15 from tests.support.runtests import RUNTIME_VARS
16 from</b></font> tests.support.unit import TestCase
17 REQUISITES = ["require", "require_in", "use", "use_in", "watch", "watch_in"]
18 class CommonTestCaseBoilerplate(TestCase):
19     def setUp(self):
20         self.root_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
21         self.addCleanup(shutil.rmtree, self.root_dir, ignore_errors=True)
22         self.state_tree_dir = os.path.join(self.root_dir, "state_tree")
23         self.cache_dir = os.path.join(self.root_dir, "cachedir")
24         if not os.path.isdir(self.root_dir):
25             os.makedirs(self.root_dir)
26         if not os.path.isdir(self.state_tree_dir):
27             os.makedirs(self.state_tree_dir)
28         if not os.path.isdir(self.cache_dir):
29             os.makedirs(self.cache_dir)
30         self.config = salt.config.minion_config(None)
31         self.config["root_dir"] = self.root_dir
32         self.config["state_events"] = False
33         self.config["id"] = "match"
34         self.config["file_client"] = "local"
35         self.config["file_roots"] = dict(base=[self.state_tree_dir])
36         self.config["cachedir"] = self.cache_dir
37         self.config["test"] = False
38         self.config["grains"] = salt.loader.grains(self.config)
39         self.HIGHSTATE = HighState(self.config)
40         self.HIGHSTATE.push_active()
41     def tearDown(self):
42         try:
43             self.HIGHSTATE.pop_active()
44         except IndexError:
45             pass
46         del self.config
47         del self.HIGHSTATE
48     def state_highstate(self, state, dirpath):
49         opts = copy.copy(self.config)
50         opts["file_roots"] = dict(base=[dirpath])
51         HIGHSTATE = HighState(opts)
52         HIGHSTATE.push_active()
53         try:
54             high, errors = HIGHSTATE.render_highstate(state)
55             if errors:
56                 import pprint
57                 pprint.pprint("\n".join(errors))
58                 pprint.pprint(high)
59             out = HIGHSTATE.state.call_high(high)
60         finally:
61             HIGHSTATE.pop_active()
62 class PyDSLRendererTestCase(CommonTestCaseBoilerplate):
63     def render_sls(self, content, sls="", saltenv="base", **kws):
64         if "env" in kws:
65             kws.pop("env")
66         return self.HIGHSTATE.state.rend["pydsl"](
67             io.StringIO(content), saltenv=saltenv, sls=sls, **kws
68         )
69     @pytest.mark.slow_test
70     def test_state_declarations(self):
71         result = self.render_sls(
72             textwrap.dedent(
73             )
74         )
75         self.assertTrue("A" in result and "X" in result)
76         A_cmd = result["A"]["cmd"]
77         self.assertEqual(A_cmd[1]["name"], "ls -la")
78         self.assertEqual(A_cmd[2]["cwd"], "/var/tmp")
79         self.assertEqual(A_cmd[3]<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["shell"], "/bin/bash")
80         A_service = result["A"]["service"]
81         self.assertEqual(A_service[0], "running")
82         self.assertEqual(A_service[1]["name"], "apache")
83         X_cmd = result[</b></font>"X"]["cmd"]
84         self.assertEqual(X_cmd[0], "run")
85         self.assertEqual(X_cmd[1]["name"], "echo hello world")
86         self.assertEqual(X_cmd[2]["cwd"], "/")
87         del result["A"]
88         del result["X"]
89         self.assertEqual(len(result), 2)
90         s_iter = iter(result.values())
91         try:
92             s = next(s_iter)["file"]
93         except KeyError:
94             s = next(s_iter)["file"]
95         self.assertEqual(s[0], "managed")
96         self.assertEqual(s[1]["name"], "myfile.txt")
97         self.assertEqual(s[2]["source"], "salt://path/to/file")
98     @pytest.mark.slow_test
99     def test_requisite_declarations(self):
100         result = self.render_sls(
101             textwrap.dedent(
102             )
103         )
104         self.assertEqual(len(result), 6)
105         self.assertTrue(set("X A B G H".split()).issubset(set(result.keys())))
106         b = result["B"]["cmd"]
107         self.assertEqual(b[0], "run")
108         self.assertEqual(b[1]["name"], "ls -la")
109         self.assertEqual(b[3]["require"][0]["cmd"], "X")
110         self.assertEqual(b[4]["require"][0]["cmd"], "A")
111         self.assertEqual(b[5]["watch"]<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0]["service"], "G")
112         self.assertEqual(result["G"]["service"][2]["watch_in"][0]["cmd"], "A")
113         self.assertEqual(result[</b></font>"H"]["cmd"][1]["require_in"][0]["cmd"], "echo hello")
114     @pytest.mark.slow_test
115     def test_include_extend(self):
116         result = self.render_sls(
117             textwrap.dedent(
118             )
119         )
120         self.assertEqual(len(result), 4)
121         self.assertEqual(
122             result["include"],
123             [
124                 {"base": sls}
125                 for sls in ("some.sls.file", "another.sls.file", "more.sls.file")
126             ],
127         )
128         extend = result["extend"]
129         self.assertEqual(extend["X"]["cmd"][0], "run")
130         self.assertEqual(extend["X"]["cmd"][1]["cwd"], "/a/b/c")
131         self.assertEqual(extend["Y"]["file"][0], "managed")
132         self.assertEqual(extend["Y"]["file"][1]["name"], "a_file.txt")
133         self.assertEqual(len(extend["Z"]["service"]), 1)
134         self.assertEqual(extend["Z"]["service"][0]["watch"][0]["file"], "A")
135         self.assertEqual(result["B"]["cmd"][0], "run")
136         self.assertTrue("A" not in result)
137         self.assertEqual(extend["A"]["cmd"][0], "run")
138     @pytest.mark.slow_test
139     def test_cmd_call(self):
140         result = self.HIGHSTATE.state.call_template_str(
141             textwrap.dedent(
142             )
143         )
144         ret = next(result[k] for k in result.keys() if "do_something" in k)
145         changes = ret["changes"]
146         self.assertEqual(
147             changes, dict(a=1, b=2, args=(3,), kws=dict(x=1, y=2), some_var=12345)
148         )
149         ret = next(result[k] for k in result.keys() if "-G_" in k)
150         self.assertEqual(ret["changes"]["stdout"], "this is state G")
151     @pytest.mark.slow_test
152     def test_multiple_state_func_in_state_mod(self):
153         with self.assertRaisesRegex(PyDslError, "Multiple state functions"):
154             self.render_sls(
155                 textwrap.dedent(
156                 )
157             )
158     @pytest.mark.slow_test
159     def test_no_state_func_in_state_mod(self):
160         with self.assertRaisesRegex(PyDslError, "No state function specified"):
161             self.render_sls(
162                 textwrap.dedent(
163                 )
164             )
165     @pytest.mark.slow_test
166     def test_load_highstate(self):
167         result = self.render_sls(
168             textwrap.dedent(
169             )
170         )
171         self.assertEqual(len(result), 3)
172         self.assertEqual(result["A"]["cmd"][0], "run")
173         self.assertIn({"cwd": "/"}, result["A"]["cmd"])
174         self.assertIn({"name": "echo hello world"}, result["A"]["cmd"])
175         self.assertEqual(len(result["A"]<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["cmd"]), 4)
176         self.assertEqual(len(result["B"]["pkg"]), 1)
177         self.assertEqual(result["B"]["pkg"][0], "installed")
178         self.assertEqual(result[</b></font>"B"]["service"][0], "running")
179         self.assertIn({"require": [{"pkg": "B"}]}, result["B"]["service"])
180         self.assertIn({"watch": [{"cmd": "A"}]}, result["B"]["service"])
181         self.assertEqual(len(result["B"]["service"]), 3)
182     @pytest.mark.slow_test
183     def test_ordered_states(self):
184         result = self.render_sls(
185             textwrap.dedent(
186             )
187         )
188         self.assertEqual(len(result["B"]["cmd"]), 3)
189         self.assertEqual(result["A"]["cmd"][1]["require"][0]["cmd"], "B")
190         self.assertEqual(result["C"]["cmd"][1]["require"][0]["cmd"], "A")
191         self.assertEqual(result["B"]["file"][1]["require"][0]["cmd"], "C")
192     @with_tempdir()
193     @pytest.mark.slow_test
194     def test_pipe_through_stateconf(self, dirpath):
195         output = os.path.join(dirpath, "output")
196         write_to(
197             os.path.join(dirpath, "xxx.sls"),
198             textwrap.dedent(
199                     output.replace("\\", "/")
200                 )
201             ),
202         )
203         write_to(
204             os.path.join(dirpath, "yyy.sls"),
205             textwrap.dedent(
206                     output.replace("\\", "/")
207                 )
208             ),
209         )
210         write_to(
211             os.path.join(dirpath, "aaa.sls"),
212             textwrap.dedent(
213                     output.replace("\\", "/")
214                 )
215             ),
216         )
217         self.state_highstate({"base": ["aaa"]}, dirpath)
218         with salt.utils.files.fopen(output, "r") as f:
219             self.assertEqual("".join(f.read().split()), "XYZABCDEF")
220     @with_tempdir()
221     @pytest.mark.slow_test
222     def test_compile_time_state_execution(self, dirpath):
223         if not sys.stdin.isatty():
224             self.skipTest("Not attached to a TTY")
225         write_to(
226             os.path.join(dirpath, "aaa.sls"),
227             textwrap.dedent(
228                     dirpath.replace("\\", "/")
229                 )
230             ),
231         )
232         self.state_highstate({"base": ["aaa"]}, dirpath)
233         with salt.utils.files.fopen(os.path.join(dirpath, "yyy.txt"), "rt") as f:
234             self.assertEqual(f.read(), "hehe" + os.linesep + "hoho" + os.linesep)
235         with salt.utils.files.fopen(os.path.join(dirpath, "xxx.txt"), "rt") as f:
236             self.assertEqual(f.read(), "hehe" + os.linesep)
237     @with_tempdir()
238     @pytest.mark.slow_test
239     def test_nested_high_state_execution(self, dirpath):
240         output = os.path.join(dirpath, "output")
241         write_to(
242             os.path.join(dirpath, "aaa.sls"),
243             textwrap.dedent(
244             ),
245         )
246         write_to(
247             os.path.join(dirpath, "bbb.sls"),
248             textwrap.dedent(
249             ),
250         )
251         write_to(
252             os.path.join(dirpath, "ccc.sls"),
253             textwrap.dedent(
254             ),
255         )
256         self.state_highstate({"base": ["aaa"]}, dirpath)
257     @with_tempdir()
258     @pytest.mark.slow_test
259     def test_repeat_includes(self, dirpath):
260         output = os.path.join(dirpath, "output")
261         write_to(
262             os.path.join(dirpath, "b.sls"),
263             textwrap.dedent(
264             ),
265         )
266         write_to(
267             os.path.join(dirpath, "c.sls"),
268             textwrap.dedent(
269             ),
270         )
271         write_to(
272             os.path.join(dirpath, "d.sls"),
273             textwrap.dedent(
274             ),
275         )
276         write_to(
277             os.path.join(dirpath, "e.sls"),
278             textwrap.dedent(
279             ),
280         )
281         self.state_highstate({"base": ["b"]}, dirpath)
282         self.state_highstate({"base": ["c", "d"]}, dirpath)
283 def write_to(fpath, content):
284     with salt.utils.files.fopen(fpath, "w") as f:
285         f.write(content)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
