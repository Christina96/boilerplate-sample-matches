<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for httputil_test.py &amp; test_process_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for httputil_test.py &amp; test_process_1.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>httputil_test.py (2.2257552%)<th>test_process_1.py (0.9478673%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(261-264)<td><a href="#" name="0">(734-736)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>httputil_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado.httputil import url_concat, parse_multipart_form_data, HTTPHeaders, format_timestamp, HTTPServerRequest, parse_request_start_line, parse_cookie
3 from salt.ext.tornado.escape import utf8, native_str
4 from salt.ext.tornado.log import gen_log
5 from salt.ext.tornado.testing import ExpectLog
6 from salt.ext.tornado.test.util import unittest
7 import copy
8 import datetime
9 import logging
10 import pickle
11 import time
12 class TestUrlConcat(unittest.TestCase):
13     def test_url_concat_no_query_params(self):
14         url = url_concat(
15             "https://localhost/path",
16             [('y', 'y'), ('z', 'z')],
17         )
18         self.assertEqual(url, "https://localhost/path?y=y&amp;z=z")
19     def test_url_concat_encode_args(self):
20         url = url_concat(
21             "https://localhost/path",
22             [('y', '/y'), ('z', 'z')],
23         )
24         self.assertEqual(url, "https://localhost/path?y=%2Fy&amp;z=z")
25     def test_url_concat_trailing_q(self):
26         url = url_concat(
27             "https://localhost/path?",
28             [('y', 'y'), ('z', 'z')],
29         )
30         self.assertEqual(url, "https://localhost/path?y=y&amp;z=z")
31     def test_url_concat_q_with_no_trailing_amp(self):
32         url = url_concat(
33             "https://localhost/path?x",
34             [('y', 'y'), ('z', 'z')],
35         )
36         self.assertEqual(url, "https://localhost/path?x=&amp;y=y&amp;z=z")
37     def test_url_concat_trailing_amp(self):
38         url = url_concat(
39             "https://localhost/path?x&amp;",
40             [('y', 'y'), ('z', 'z')],
41         )
42         self.assertEqual(url, "https://localhost/path?x=&amp;y=y&amp;z=z")
43     def test_url_concat_mult_params(self):
44         url = url_concat(
45             "https://localhost/path?a=1&amp;b=2",
46             [('y', 'y'), ('z', 'z')],
47         )
48         self.assertEqual(url, "https://localhost/path?a=1&amp;b=2&amp;y=y&amp;z=z")
49     def test_url_concat_no_params(self):
50         url = url_concat(
51             "https://localhost/path?r=1&amp;t=2",
52             [],
53         )
54         self.assertEqual(url, "https://localhost/path?r=1&amp;t=2")
55     def test_url_concat_none_params(self):
56         url = url_concat(
57             "https://localhost/path?r=1&amp;t=2",
58             None,
59         )
60         self.assertEqual(url, "https://localhost/path?r=1&amp;t=2")
61     def test_url_concat_with_frag(self):
62         url = url_concat(
63             "https://localhost/path#tab",
64             [('y', 'y')],
65         )
66         self.assertEqual(url, "https://localhost/path?y=y#tab")
67     def test_url_concat_multi_same_params(self):
68         url = url_concat(
69             "https://localhost/path",
70             [('y', 'y1'), ('y', 'y2')],
71         )
72         self.assertEqual(url, "https://localhost/path?y=y1&amp;y=y2")
73     def test_url_concat_multi_same_query_params(self):
74         url = url_concat(
75             "https://localhost/path?r=1&amp;r=2",
76             [('y', 'y')],
77         )
78         self.assertEqual(url, "https://localhost/path?r=1&amp;r=2&amp;y=y")
79     def test_url_concat_dict_params(self):
80         url = url_concat(
81             "https://localhost/path",
82             dict(y='y'),
83         )
84         self.assertEqual(url, "https://localhost/path?y=y")
85 class MultipartFormDataTest(unittest.TestCase):
86     def test_file_upload(self):
87         data = b"""\
88 --1234
89 Content-Disposition: form-data; name="files"; filename="ab.txt"
90 Foo
91 --1234--""".replace(b"\n", b"\r\n")
92         args = {}
93         files = {}
94         parse_multipart_form_data(b"1234", data, args, files)
95         file = files["files"][0]
96         self.assertEqual(file["filename"], "ab.txt")
97         self.assertEqual(file["body"], b"Foo")
98     def test_unquoted_names(self):
99         data = b"""\
100 --1234
101 Content-Disposition: form-data; name=files; filename=ab.txt
102 Foo
103 --1234--""".replace(b"\n", b"\r\n")
104         args = {}
105         files = {}
106         parse_multipart_form_data(b"1234", data, args, files)
107         file = files["files"][0]
108         self.assertEqual(file["filename"], "ab.txt")
109         self.assertEqual(file["body"], b"Foo")
110     def test_special_filenames(self):
111         filenames = ['a;b.txt',
112                      'a"b.txt',
113                      'a";b.txt',
114                      'a;"b.txt',
115                      'a";";.txt',
116                      'a\\"b.txt',
117                      'a\\b.txt',
118                      ]
119         for filename in filenames:
120             logging.debug("trying filename %r", filename)
121             data = """\
122 --1234
123 Content-Disposition: form-data; name="files"; filename="%s"
124 Foo
125 --1234--""" % filename.replace('\\', '\\\\').replace('"', '\\"')
126             data = utf8(data.replace("\n", "\r\n"))
127             args = {}
128             files = {}
129             parse_multipart_form_data(b"1234", data, args, files)
130             file = files["files"][0]
131             self.assertEqual(file["filename"], filename)
132             self.assertEqual(file["body"], b"Foo")
133     def test_boundary_starts_and_ends_with_quotes(self):
134         data = b'''\
135 --1234
136 Content-Disposition: form-data; name="files"; filename="ab.txt"
137 Foo
138 --1234--'''.replace(b"\n", b"\r\n")
139         args = {}
140         files = {}
141         parse_multipart_form_data(b'"1234"', data, args, files)
142         file = files["files"][0]
143         self.assertEqual(file["filename"], "ab.txt")
144         self.assertEqual(file["body"], b"Foo")
145     def test_missing_headers(self):
146         data = b'''\
147 --1234
148 Foo
149 --1234--'''.replace(b"\n", b"\r\n")
150         args = {}
151         files = {}
152         with ExpectLog(gen_log, "multipart/form-data missing headers"):
153             parse_multipart_form_data(b"1234", data, args, files)
154         self.assertEqual(files, {})
155     def test_invalid_content_disposition(self):
156         data = b'''\
157 --1234
158 Content-Disposition: invalid; name="files"; filename="ab.txt"
159 Foo
160 --1234--'''.replace(b"\n", b"\r\n")
161         args = {}
162         files = {}
163         with ExpectLog(gen_log, "Invalid multipart/form-data"):
164             parse_multipart_form_data(b"1234", data, args, files)
165         self.assertEqual(files, {})
166     def test_line_does_not_end_with_correct_line_break(self):
167         data = b'''\
168 --1234
169 Content-Disposition: form-data; name="files"; filename="ab.txt"
170 Foo--1234--'''.replace(b"\n", b"\r\n")
171         args = {}
172         files = {}
173         with ExpectLog(gen_log, "Invalid multipart/form-data"):
174             parse_multipart_form_data(b"1234", data, args, files)
175         self.assertEqual(files, {})
176     def test_content_disposition_header_without_name_parameter(self):
177         data = b"""\
178 --1234
179 Content-Disposition: form-data; filename="ab.txt"
180 Foo
181 --1234--""".replace(b"\n", b"\r\n")
182         args = {}
183         files = {}
184         with ExpectLog(gen_log, "multipart/form-data value missing name"):
185             parse_multipart_form_data(b"1234", data, args, files)
186         self.assertEqual(files, {})
187     def test_data_after_final_boundary(self):
188         data = b"""\
189 --1234
190 Content-Disposition: form-data; name="files"; filename="ab.txt"
191 Foo
192 --1234--
193 """.replace(b"\n", b"\r\n")
194         self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(headers.get_list("asdf"), ["qwer zxcv"])
195         self.assertEqual(headers["Foo"], "bar baz,even more lines")
196         self.assertEqual(headers.get_list("foo"), ["bar baz", "even more lines"])
197         self.assertEqual(</b></font>sorted(list(headers.get_all())),
198                          [("Asdf", "qwer zxcv"),
199                           ("Foo", "bar baz"),
200                           ("Foo", "even more lines")])
201     def test_unicode_newlines(self):
202         newlines = [
203             u'\u001b',  # VERTICAL TAB
204             u'\u001c',  # FILE SEPARATOR
205             u'\u001d',  # GROUP SEPARATOR
206             u'\u001e',  # RECORD SEPARATOR
207             u'\u0085',  # NEXT LINE
208             u'\u2028',  # LINE SEPARATOR
209             u'\u2029',  # PARAGRAPH SEPARATOR
210         ]
211         for newline in newlines:
212             for encoding in ['utf8', 'latin1']:
213                 try:
214                     try:
215                         encoded = newline.encode(encoding)
216                     except UnicodeEncodeError:
217                         continue
218                     data = b'Cookie: foo=' + encoded + b'bar'
219                     headers = HTTPHeaders.parse(
220                         native_str(data.decode('latin1')))
221                     expected = [('Cookie', 'foo=' +
222                                  native_str(encoded.decode('latin1')) + 'bar')]
223                     self.assertEqual(
224                         expected, list(headers.get_all()))
225                 except Exception:
226                     gen_log.warning("failed while trying %r in %s",
227                                     newline, encoding)
228                     raise
229     def test_optional_cr(self):
230         headers = HTTPHeaders.parse(
231             'CRLF: crlf\r\nLF: lf\nCR: cr\rMore: more\r\n')
232         self.assertEqual(sorted(headers.get_all()),
233                          [('Cr', 'cr\rMore: more'),
234                           ('Crlf', 'crlf'),
235                           ('Lf', 'lf'),
236                           ])
237     def test_copy(self):
238         all_pairs = [('A', '1'), ('A', '2'), ('B', 'c')]
239         h1 = HTTPHeaders()
240         for k, v in all_pairs:
241             h1.add(k, v)
242         h2 = h1.copy()
243         h3 = copy.copy(h1)
244         h4 = copy.deepcopy(h1)
245         for headers in [h1, h2, h3, h4]:
246             self.assertEqual(list(sorted(headers.get_all())), all_pairs)
247         for headers in [h2, h3, h4]:
248             self.assertIsNot(headers, h1)
249             self.assertIsNot(headers.get_list('A'), h1.get_list('A'))
250     def test_pickle_roundtrip(self):
251         headers = HTTPHeaders()
252         headers.add('Set-Cookie', 'a=b')
253         headers.add('Set-Cookie', 'c=d')
254         headers.add('Content-Type', 'text/html')
255         pickled = pickle.dumps(headers)
256         unpickled = pickle.loads(pickled)
257         self.assertEqual(sorted(headers.get_all()), sorted(unpickled.get_all()))
258         self.assertEqual(sorted(headers.items()), sorted(unpickled.items()))
259     def test_setdefault(self):
260         headers = HTTPHeaders()
261         headers['foo'] = 'bar'
262         self.assertEqual(headers.setdefault('foo', 'baz'), 'bar')
263         self.assertEqual(headers['foo'], 'bar')
264         self.assertEqual(headers.setdefault('quux', 'xyzzy'), 'xyzzy')
265         self.assertEqual(headers['quux'], 'xyzzy')
266         self.assertEqual(sorted(headers.get_all()), [('Foo', 'bar'), ('Quux', 'xyzzy')])
267     def test_string(self):
268         headers = HTTPHeaders()
269         headers.add("Foo", "1")
270         headers.add("Foo", "2")
271         headers.add("Foo", "3")
272         headers2 = HTTPHeaders.parse(str(headers))
273         self.assertEquals(headers, headers2)
274 class FormatTimestampTest(unittest.TestCase):
275     TIMESTAMP = 1359312200.503611
276     EXPECTED = 'Sun, 27 Jan 2013 18:43:20 GMT'
277     def check(self, value):
278         self.assertEqual(format_timestamp(value), self.EXPECTED)
279     def test_unix_time_float(self):
280         self.check(self.TIMESTAMP)
281     def test_unix_time_int(self):
282         self.check(int(self.TIMESTAMP))
283     def test_struct_time(self):
284         self.check(time.gmtime(self.TIMESTAMP))
285     def test_time_tuple(self):
286         tup = tuple(time.gmtime(self.TIMESTAMP))
287         self.assertEqual(9, len(tup))
288         self.check(tup)
289     def test_datetime(self):
290         self.check(datetime.datetime.utcfromtimestamp(self.TIMESTAMP))
291 class HTTPServerRequestTest(unittest.TestCase):
292     def test_default_constructor(self):
293         HTTPServerRequest(uri='/')
294     def test_body_is_a_byte_string(self):
295         requets = HTTPServerRequest(uri='/')
296         self.assertIsInstance(requets.body, bytes)
297 class ParseRequestStartLineTest(unittest.TestCase):
298     METHOD = "GET"
299     PATH = "/foo"
300     VERSION = "HTTP/1.1"
301     def test_parse_request_start_line(self):
302         start_line = " ".join([self.METHOD, self.PATH, self.VERSION])
303         parsed_start_line = parse_request_start_line(start_line)
304         self.assertEqual(parsed_start_line.method, self.METHOD)
305         self.assertEqual(parsed_start_line.path, self.PATH)
306         self.assertEqual(parsed_start_line.version, self.VERSION)
307 class ParseCookieTest(unittest.TestCase):
308     def test_python_cookies(self):
309         """
310         Test cases copied from Python's Lib/test/test_http_cookies.py
311         """
312         self.assertEqual(parse_cookie('chips=ahoy; vienna=finger'), {'chips': 'ahoy', 'vienna': 'finger'})
313         self.assertEqual(
314             parse_cookie('keebler="E=mc2; L=\\"Loves\\"; fudge=\\012;"'),
315             {'keebler': '"E=mc2', 'L': '\\"Loves\\"', 'fudge': '\\012', '': '"'}
316         )
317         self.assertEqual(parse_cookie('keebler=E=mc2'), {'keebler': 'E=mc2'})
318         self.assertEqual(parse_cookie('key:term=value:term'), {'key:term': 'value:term'})
319         self.assertEqual(parse_cookie('a=b; c=[; d=r; f=h'), {'a': 'b', 'c': '[', 'd': 'r', 'f': 'h'})
320     def test_cookie_edgecases(self):
321         self.assertEqual(parse_cookie('a=b; Domain=example.com'), {'a': 'b', 'Domain': 'example.com'})
322         self.assertEqual(parse_cookie('a=b; h=i; a=c'), {'a': 'c', 'h': 'i'})
323     def test_invalid_cookies(self):
324         """
325         Cookie strings that go against RFC6265 but browsers will send if set
326         via document.cookie.
327         """
328         self.assertIn('django_language', parse_cookie('abc=def; unnamed; django_language=en').keys())
329         self.assertEqual(parse_cookie('a=b; "; c=d'), {'a': 'b', '': '"', 'c': 'd'})
330         self.assertEqual(parse_cookie('a b c=d e = f; gh=i'), {'a b c': 'd e = f', 'gh': 'i'})
331         self.assertEqual(parse_cookie('a   b,c&lt;&gt;@:/[]?{}=d  "  =e,f g'), {'a   b,c&lt;&gt;@:/[]?{}': 'd  "  =e,f g'})
332         self.assertEqual(parse_cookie('saint=André Bessette'), {'saint': native_str('André Bessette')})
333         self.assertEqual(parse_cookie('  =  b  ;  ;  =  ;   c  =  ;  '), {'': 'b', 'c': ''})
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_process_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import functools
3 import io
4 import multiprocessing
5 import os
6 import signal
7 import sys
8 import tempfile
9 import threading
10 import time
11 import warnings
12 import pytest
13 import salt.utils.platform
14 import salt.utils.process
15 from salt.utils.versions import warn_until_date
16 from tests.support.mock import patch
17 from tests.support.unit import TestCase, skipIf
18 HAS_PSUTIL = False
19 try:
20     import psutil
21     HAS_PSUTIL = True
22 except ImportError:
23     pass
24 def die(func):
25     """
26     Add proc title
27     """
28     @functools.wraps(func)
29     def wrapper(self):
30         name = func.__name__[5:]
31         def _die():
32             salt.utils.process.appendproctitle("test_{}".format(name))
33         attrname = "die_" + name
34         setattr(self, attrname, _die)
35         self.addCleanup(delattr, self, attrname)
36     return wrapper
37 def incr(func):
38     """
39     Increment counter
40     """
41     @functools.wraps(func)
42     def wrapper(self):
43         name = func.__name__[5:]
44         def _incr(counter, num):
45             salt.utils.process.appendproctitle("test_{}".format(name))
46             for _ in range(0, num):
47                 counter.value += 1
48         attrname = "incr_" + name
49         setattr(self, attrname, _incr)
50         self.addCleanup(delattr, self, attrname)
51     return wrapper
52 def spin(func):
53     """
54     Spin indefinitely
55     """
56     @functools.wraps(func)
57     def wrapper(self):
58         name = func.__name__[5:]
59         def _spin():
60             salt.utils.process.appendproctitle("test_{}".format(name))
61             while True:
62                 time.sleep(1)
63         attrname = "spin_" + name
64         setattr(self, attrname, _spin)
65         self.addCleanup(delattr, self, attrname)
66     return wrapper
67 class TestProcessManager(TestCase):
68     @spin
69     @pytest.mark.slow_test
70     def test_basic(self):
71         """
72         Make sure that the process is alive 2s later
73         """
74         process_manager = salt.utils.process.ProcessManager()
75         self.addCleanup(process_manager.terminate)
76         process_manager.add_process(self.spin_basic)
77         initial_pid = next(iter(process_manager._process_map.keys()))
78         time.sleep(2)
79         process_manager.check_children()
80         assert initial_pid == next(iter(process_manager._process_map.keys()))
81     @spin
82     def test_kill(self):
83         process_manager = salt.utils.process.ProcessManager()
84         self.addCleanup(process_manager.terminate)
85         process_manager.add_process(self.spin_kill)
86         initial_pid = next(iter(process_manager._process_map.keys()))
87         if salt.utils.platform.is_windows():
88             os.kill(initial_pid, signal.SIGTERM)
89         else:
90             os.kill(initial_pid, signal.SIGKILL)
91         time.sleep(0.1)
92         process_manager.check_children()
93         assert initial_pid != next(iter(process_manager._process_map.keys()))
94     @die
95     def test_restarting(self):
96         """
97         Make sure that the process is alive 2s later
98         """
99         process_manager = salt.utils.process.ProcessManager()
100         self.addCleanup(process_manager.terminate)
101         process_manager.add_process(self.die_restarting)
102         initial_pid = next(iter(process_manager._process_map.keys()))
103         time.sleep(2)
104         process_manager.check_children()
105         assert initial_pid != next(iter(process_manager._process_map.keys()))
106     @incr
107     def test_counter(self):
108         counter = multiprocessing.Value("i", 0)
109         process_manager = salt.utils.process.ProcessManager()
110         self.addCleanup(process_manager.terminate)
111         process_manager.add_process(self.incr_counter, args=(counter, 2))
112         time.sleep(1)
113         process_manager.check_children()
114         time.sleep(1)
115         assert counter.value == 4
116 class TestThreadPool(TestCase):
117     @pytest.mark.slow_test
118     def test_basic(self):
119         """
120         Make sure the threadpool can do things
121         """
122         def incr_counter(counter):
123             counter.value += 1
124         counter = multiprocessing.Value("i", 0)
125         pool = salt.utils.process.ThreadPool()
126         sent = pool.fire_async(incr_counter, args=(counter,))
127         self.assertTrue(sent)
128         time.sleep(1)  # Sleep to let the threads do things
129         self.assertEqual(counter.value, 1)
130         self.assertEqual(pool._job_queue.qsize(), 0)
131     @pytest.mark.slow_test
132     def test_full_queue(self):
133         """
134         Make sure that a full threadpool acts as we expect
135         """
136         def incr_counter(counter):
137             counter.value += 1
138         counter = multiprocessing.Value("i", 0)
139         pool = salt.utils.process.ThreadPool(0, 1)
140         sent = pool.fire_async(incr_counter, args=(counter,))
141         self.assertTrue(sent)
142         sent = pool.fire_async(incr_counter, args=(counter,))
143         self.assertFalse(sent)
144         time.sleep(1)  # Sleep to let the threads do things
145         self.assertEqual(counter.value, 0)
146         self.assertEqual(pool._job_queue.qsize(), 1)
147 class TestProcess(TestCase):
148     def test_daemonize_if(self):
149         with patch("sys.argv", ["salt-call"]):
150             ret = salt.utils.process.daemonize_if({})
151             self.assertEqual(None, ret)
152         ret = salt.utils.process.daemonize_if({"multiprocessing": False})
153         self.assertEqual(None, ret)
154         with patch("sys.platform", "win"):
155             ret = salt.utils.process.daemonize_if({})
156             self.assertEqual(None, ret)
157         with patch("salt.utils.process.daemonize"), patch("sys.platform", "linux2"):
158             salt.utils.process.daemonize_if({})
159             self.assertTrue(salt.utils.process.daemonize.called)
160 class TestProcessCallbacks(TestCase):
161     @staticmethod
162     def process_target(evt):
163         evt.set()
164     def test_callbacks(self):
165         "Validate Process call after fork and finalize methods"
166         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
167         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
168         with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
169             evt = multiprocessing.Event()
170             proc = salt.utils.process.Process(target=self.process_target, args=(evt,))
171             proc.run()
172             assert evt.is_set()
173         mb.assert_called()
174         ma.assert_called()
175     def test_callbacks_called_when_run_overridden(self):
176         "Validate Process sub classes call after fork and finalize methods when run is overridden"
177         class MyProcess(salt.utils.process.Process):
178             def __init__(self):
179                 super().__init__()
180                 self.evt = multiprocessing.Event()
181             def run(self):
182                 self.evt.set()
183         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
184         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
185         with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
186             proc = MyProcess()
187             proc.run()
188             assert proc.evt.is_set()
189         ma.assert_called()
190         mb.assert_called()
191 @skipIf(not HAS_PSUTIL, "Missing psutil")
192 class TestSignalHandlingProcess(TestCase):
193     @classmethod
194     def Process(cls, pid):
195         raise psutil.NoSuchProcess(pid)
196     @classmethod
197     def target(cls):
198         os.kill(os.getpid(), signal.SIGTERM)
199     @classmethod
200     def children(cls, *args, **kwargs):
201         raise psutil.NoSuchProcess(1)
202     def test_process_does_not_exist(self):
203         try:
204             with patch("psutil.Process", self.Process):
205                 proc = salt.utils.process.SignalHandlingProcess(target=self.target)
206                 proc.start()
207         except psutil.NoSuchProcess:
208             assert False, "psutil.NoSuchProcess raised"
209     def test_process_children_do_not_exist(self):
210         try:
211             with patch("psutil.Process.children", self.children):
212                 proc = salt.utils.process.SignalHandlingProcess(target=self.target)
213                 proc.start()
214         except psutil.NoSuchProcess:
215             assert False, "psutil.NoSuchProcess raised"
216     @staticmethod
217     def run_forever_sub_target(evt):
218         "Used by run_forever_target to create a sub-process"
219         while not evt.is_set():
220             time.sleep(1)
221     @staticmethod
222     def run_forever_target(sub_target, evt):
223         "A target that will run forever or until an event is set"
224         p = multiprocessing.Process(target=sub_target, args=(evt,))
225         p.start()
226         p.join()
227     @staticmethod
228     def kill_target_sub_proc():
229         pid = os.fork()
230         if pid == 0:
231             return
232         pid = os.fork()
233         if pid == 0:
234             return
235         time.sleep(0.1)
236         try:
237             os.kill(os.getpid(), signal.SIGINT)
238         except KeyboardInterrupt:
239             pass
240     @skipIf(sys.platform.startswith("win"), "No os.fork on Windows")
241     @pytest.mark.slow_test
242     def test_signal_processing_regression_test(self):
243         evt = multiprocessing.Event()
244         sh_proc = salt.utils.process.SignalHandlingProcess(
245             target=self.run_forever_target, args=(self.run_forever_sub_target, evt)
246         )
247         sh_proc.start()
248         proc = multiprocessing.Process(target=self.kill_target_sub_proc)
249         proc.start()
250         proc.join()
251         try:
252             assert sh_proc.is_alive()
253         finally:
254             evt.set()
255             sh_proc.join()
256     @staticmethod
257     def no_op_target():
258         pass
259     @staticmethod
260     def pid_setting_target(sub_target, val, evt):
261         val.value = os.getpid()
262         p = multiprocessing.Process(target=sub_target, args=(evt,))
263         p.start()
264         p.join()
265     @skipIf(sys.platform.startswith("win"), "Required signals not supported on windows")
266     @pytest.mark.slow_test
267     def test_signal_processing_handle_signals_called(self):
268         "Validate SignalHandlingProcess handles signals"
269         evt = multiprocessing.Event()
270         val = multiprocessing.Value("i", 0)
271         proc = salt.utils.process.SignalHandlingProcess(
272             target=self.pid_setting_target,
273             args=(self.run_forever_sub_target, val, evt),
274         )
275         proc.start()
276         proc2 = multiprocessing.Process(
277             target=self.run_forever_target,
278             args=(self.run_forever_sub_target, evt),
279         )
280         proc2.start()
281         while not val.value:
282             time.sleep(0.3)
283         assert not proc.signal_handled()
284         os.kill(val.value, signal.SIGTERM)
285         start = time.time()
286         while time.time() - start &lt; 10:
287             if proc.signal_handled():
288                 break
289             time.sleep(0.3)
290         try:
291             assert proc.signal_handled()
292             proc.join(1)
293             assert proc2.is_alive()
294         finally:
295             evt.set()
296             proc2.join(30)
297             proc.join(30)
298 class TestSignalHandlingProcessCallbacks(TestCase):
299     @staticmethod
300     def process_target(evt):
301         evt.set()
302     def test_callbacks(self):
303         "Validate SignalHandlingProcess call after fork and finalize methods"
304         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
305         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
306         sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
307         evt = multiprocessing.Event()
308         with patch(sig_to_mock):
309             with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
310                 sh_proc = salt.utils.process.SignalHandlingProcess(
311                     target=self.process_target, args=(evt,)
312                 )
313                 sh_proc.run()
314                 assert evt.is_set()
315         ma.assert_called()
316         mb.assert_called()
317     def test_callbacks_called_when_run_overridden(self):
318         "Validate SignalHandlingProcess sub classes call after fork and finalize methods when run is overridden"
319         class MyProcess(salt.utils.process.SignalHandlingProcess):
320             def __init__(self):
321                 super().__init__()
322                 self.evt = multiprocessing.Event()
323             def run(self):
324                 self.evt.set()
325         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
326         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
327         sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
328         with patch(sig_to_mock):
329             with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
330                 sh_proc = MyProcess()
331                 sh_proc.run()
332                 assert sh_proc.evt.is_set()
333         ma.assert_called()
334         mb.assert_called()
335 class TestDup2(TestCase):
336     def test_dup2_no_fileno(self):
337         "The dup2 method does not fail on streams without fileno support"
338         f1 = io.StringIO("some initial text data")
339         f2 = io.StringIO("some initial other text data")
340         with self.assertRaises(io.UnsupportedOperation):
341             f1.fileno()
342         with patch("os.dup2") as dup_mock:
343             try:
344                 salt.utils.process.dup2(f1, f2)
345             except io.UnsupportedOperation:
346                 assert False, "io.UnsupportedOperation was raised"
347         assert not dup_mock.called
348 def null_target():
349     pass
350 def event_target(event):
351     while True:
352         if event.wait(5):
353             break
354 class TestProcessList(TestCase):
355     @staticmethod
356     def wait_for_proc(proc, timeout=10):
357         start = time.time()
358         while proc.is_alive():
359             if time.time() - start &gt; timeout:
360                 raise Exception("Process did not finishe before timeout")
361             time.sleep(0.3)
362     @pytest.mark.slow_test
363     def test_process_list_process(self):
364         plist = salt.utils.process.SubprocessList()
365         proc = multiprocessing.Process(target=null_target)
366         proc.start()
367         plist.add(proc)
368         assert proc in plist.processes
369         self.wait_for_proc(proc)
370         assert not proc.is_alive()
371         plist.cleanup()
372         assert proc not in plist.processes
373     def test_process_list_thread(self):
374         plist = salt.utils.process.SubprocessList()
375         thread = threading.Thread(target=null_target)
376         thread.start()
377         plist.add(thread)
378         assert thread in plist.processes
379         self.wait_for_proc(thread)
380         assert not thread.is_alive()
381         plist.cleanup()
382         assert thread not in plist.processes
383     @pytest.mark.slow_test
384     def test_process_list_cleanup(self):
385         plist = salt.utils.process.SubprocessList()
386         event = multiprocessing.Event()
387         proc = multiprocessing.Process(target=event_target, args=[event])
388         proc.start()
389         plist.add(proc)
390         assert proc in plist.processes
391         plist.cleanup()
392         event.set()
393         assert proc in plist.processes
394         self.wait_for_proc(proc)
395         assert not proc.is_alive()
396         plist.cleanup()
397         assert proc not in plist.processes
398 class TestDeprecatedClassNames(TestCase):
399     @staticmethod
400     def process_target():
401         pass
402     @staticmethod
403     def patched_warn_until_date(current_date):
404         def _patched_warn_until_date(
405             date,
406             message,
407             category=DeprecationWarning,
408             stacklevel=None,
409             _current_date=current_date,
410             _dont_call_warnings=False,
411         ):
412             stacklevel = 4
413             return warn_until_date(
414                 date,
415                 message,
416                 category=category,
417                 stacklevel=stacklevel,
418                 _current_date=_current_date,
419                 _dont_call_warnings=_dont_call_warnings,
420             )
421         return _patched_warn_until_date
422     def test_multiprocessing_process_warning(self):
423         warnings.filterwarnings("always", "", DeprecationWarning, __name__)
424         fake_utcnow = datetime.date(2021, 1, 1)
425         proc = None
426         try:
427             with patch(
428                 "salt.utils.versions.warn_until_date",
429                 self.patched_warn_until_date(fake_utcnow),
430             ):
431                 with warnings.catch_warnings(record=True) as recorded_warnings:
432                     proc = salt.utils.process.MultiprocessingProcess(
433                         target=self.process_target
434                     )
435                     self.assertEqual(
436                         "Please stop using 'salt.utils.process.MultiprocessingProcess' "
437                         "and instead use 'salt.utils.process.Process'. "
438                         "'salt.utils.process.MultiprocessingProcess' will go away "
439                         "after 2022-01-01.",
440                         str(recorded_warnings[0].message),
441                     )
442         finally:
443             if proc is not None:
444                 del proc
445     def test_multiprocessing_process_runtime_error(self):
446         fake_utcnow = datetime.date(2022, 1, 1)
447         proc = None
448         try:
449             with patch(
450                 "salt.utils.versions.warn_until_date",
451                 self.patched_warn_until_date(fake_utcnow),
452             ):
453                 with self.assertRaisesRegex(
454                     RuntimeError,
455                     r"Please stop using 'salt.utils.process.MultiprocessingProcess' "
456                     r"and instead use 'salt.utils.process.Process'. "
457                     r"'salt.utils.process.MultiprocessingProcess' will go away "
458                     r"after 2022-01-01. "
459                     r"This warning\(now exception\) triggered on "
460                     r"filename '(.*)test_process.py', line number ([\d]+), is "
461                     r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
462                     r"Please remove the warning.",
463                 ):
464                     proc = salt.utils.process.MultiprocessingProcess(
465                         target=self.process_target
466                     )
467         finally:
468             if proc is not None:
469                 del proc
470     def test_signal_handling_multiprocessing_process_warning(self):
471         warnings.filterwarnings("always", "", DeprecationWarning, __name__)
472         fake_utcnow = datetime.date(2021, 1, 1)
473         proc = None
474         try:
475             with patch(
476                 "salt.utils.versions.warn_until_date",
477                 self.patched_warn_until_date(fake_utcnow),
478             ):
479                 with warnings.catch_warnings(record=True) as recorded_warnings:
480                     proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
481                         target=self.process_target
482                     )
483                     self.assertEqual(
484                         "Please stop using"
485                         " 'salt.utils.process.SignalHandlingMultiprocessingProcess' and"
486                         " instead use 'salt.utils.process.SignalHandlingProcess'."
487                         " 'salt.utils.process.SignalHandlingMultiprocessingProcess'"
488                         " will go away after 2022-01-01.",
489                         str(recorded_warnings[0].message),
490                     )
491         finally:
492             if proc is not None:
493                 del proc
494     def test_signal_handling_multiprocessing_process_runtime_error(self):
495         fake_utcnow = datetime.date(2022, 1, 1)
496         proc = None
497         try:
498             with patch(
499                 "salt.utils.versions.warn_until_date",
500                 self.patched_warn_until_date(fake_utcnow),
501             ):
502                 with self.assertRaisesRegex(
503                     RuntimeError,
504                     r"Please stop using"
505                     r" 'salt.utils.process.SignalHandlingMultiprocessingProcess' "
506                     r"and instead use 'salt.utils.process.SignalHandlingProcess'. "
507                     r"'salt.utils.process.SignalHandlingMultiprocessingProcess' will go"
508                     r" away "
509                     r"after 2022-01-01. "
510                     r"This warning\(now exception\) triggered on "
511                     r"filename '(.*)test_process.py', line number ([\d]+), is "
512                     r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
513                     r"Please remove the warning.",
514                 ):
515                     proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
516                         target=self.process_target
517                     )
518         finally:
519             if proc is not None:
520                 del proc
521 class CMORProcessHelper:
522     def __init__(self, file_name):
523         self._lock = threading.Lock()
524         self._running = True
525         self._queue = multiprocessing.Queue()
526         self._ret_queue = multiprocessing.Queue()
527         self._process = multiprocessing.Process(
528             target=self.test_process,
529             args=(file_name, self._queue, self._ret_queue),
530             daemon=True,
531         )
532         self._process.start()
533     def __enter__(self):
534         return self
535     def __exit__(self, exc_type, exc_val, exc_tb):
536         self.stop()
537     def claim(self):
538         try:
539             self._lock.acquire()
540             if self._running:
541                 self._queue.put("claim")
542                 return self._ret_queue.get(timeout=10)
543         finally:
544             self._lock.release()
545     def stop(self):
546         try:
547             self._lock.acquire()
548             if self._running:
549                 self._running = False
550                 self._queue.put("stop")
551                 self._process.join(timeout=10)
552                 self._queue.close()
553                 self._ret_queue.close()
554         finally:
555             self._lock.release()
556     @property
557     def pid(self):
558         return self._process.pid
559     @staticmethod
560     def test_process(file_name, queue, ret_queue):
561         while True:
562             action = queue.get()
563             if action == "claim":
564                 ret_queue.put(
565                     salt.utils.process.claim_mantle_of_responsibility(file_name)
566                 )
567             elif action == "stop":
568                 return
569 @skipIf(not HAS_PSUTIL, "Missing psutil")
570 class TestGetProcessInfo(TestCase):
571     def setUp(self):
572         handle, self.cmor_test_file_path = tempfile.mkstemp()
573         os.close(handle)
574         self.addCleanup(os.unlink, self.cmor_test_file_path)
575     def test_this_process(self):
576         this_process_info = salt.utils.process.get_process_info()
577         self.assertEqual(
578             this_process_info, salt.utils.process.get_process_info(os.getpid())
579         )
580         self.assertIsNotNone(this_process_info)
581             self.assertIn(key, this_process_info)
582         raw_process_info = psutil<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Process(os.getpid())
583         self.assertEqual(this_process_info["pid"], os.getpid())
584         self.assertEqual(this_process_info["name"], raw_process_info.name(</b></font>))
585         self.assertEqual(
586             this_process_info["start_time"], raw_process_info.create_time()
587         )
588     def test_random_processes(self):
589         for _ in range(3):
590             with CMORProcessHelper(self.cmor_test_file_path) as p1:
591                 pid = p1.pid
592                 self.assertIsInstance(salt.utils.process.get_process_info(pid), dict)
593             self.assertIsNone(salt.utils.process.get_process_info(pid))
594 @skipIf(not HAS_PSUTIL, "Missing psutil")
595 class TestClaimMantleOfResponsibility(TestCase):
596     def setUp(self):
597         handle, self.cmor_test_file_path = tempfile.mkstemp()
598         os.close(handle)
599         self.addCleanup(os.unlink, self.cmor_test_file_path)
600     def test_simple_claim_no_psutil(self):
601         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
602     def test_simple_claim(self):
603         for _ in range(5):
604             self.assertTrue(
605                 salt.utils.process.claim_mantle_of_responsibility(
606                     self.cmor_test_file_path
607                 )
608             )
609     def test_multiple_processes(self):
610         with CMORProcessHelper(self.cmor_test_file_path) as p1:
611             self.assertTrue(p1.claim())
612             self.assertFalse(
613                 salt.utils.process.claim_mantle_of_responsibility(
614                     self.cmor_test_file_path
615                 )
616             )
617             with CMORProcessHelper(self.cmor_test_file_path) as p2:
618                 for _ in range(3):
619                     self.assertFalse(p2.claim())
620             self.assertTrue(p1.claim())
621         with CMORProcessHelper(self.cmor_test_file_path) as p1:
622             self.assertTrue(p1.claim())
623             self.assertFalse(
624                 salt.utils.process.claim_mantle_of_responsibility(
625                     self.cmor_test_file_path
626                 )
627             )
628         self.assertTrue(
629             salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
630         )
631 @skipIf(not HAS_PSUTIL, "Missing psutil")
632 class TestCheckMantleOfResponsibility(TestCase):
633     def setUp(self):
634         handle, self.cmor_test_file_path = tempfile.mkstemp()
635         os.close(handle)
636         self.addCleanup(os.unlink, self.cmor_test_file_path)
637     def test_simple_claim_no_psutil(self):
638         self.assertIsNone(
639             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
640         )
641     def test_simple_claim(self):
642         self.assertIsNone(
643             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
644         )
645         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
646         pid = salt.utils.process.get_process_info()["pid"]
647         self.assertEqual(
648             pid,
649             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path),
650         )
651     def test_multiple_processes(self):
652         self.assertIsNone(
653             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
654         )
655         with CMORProcessHelper(self.cmor_test_file_path) as p1:
656             self.assertTrue(p1.claim())
657             random_pid = salt.utils.process.check_mantle_of_responsibility(
658                 self.cmor_test_file_path
659             )
660             self.assertIsInstance(random_pid, int)
661             with CMORProcessHelper(self.cmor_test_file_path) as p2:
662                 for _ in range(3):
663                     self.assertFalse(p2.claim())
664                 self.assertEqual(
665                     random_pid,
666                     salt.utils.process.check_mantle_of_responsibility(
667                         self.cmor_test_file_path
668                     ),
669                 )
670         self.assertIsNone(
671             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
672         )
673         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
674         pid = salt.utils.process.get_process_info()["pid"]
675         self.assertEqual(
676             pid,
677             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path),
678         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
