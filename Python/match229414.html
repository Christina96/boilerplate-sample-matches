<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for httputil_test.py &amp; test_process_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for httputil_test.py &amp; test_process_1.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>httputil_test.py (2.2257552%)<th>test_process_1.py (0.9478673%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(261-264)<td><a href="#" name="0">(734-736)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>httputil_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado.httputil import url_concat, parse_multipart_form_data, HTTPHeaders, format_timestamp, HTTPServerRequest, parse_request_start_line, parse_cookie
3 from salt.ext.tornado.escape import utf8, native_str
4 from salt.ext.tornado.log import gen_log
5 from salt.ext.tornado.testing import ExpectLog
6 from salt.ext.tornado.test.util import unittest
7 import copy
8 import datetime
9 import logging
10 import pickle
11 import time
12 class TestUrlConcat(unittest.TestCase):
13     def test_url_concat_no_query_params(self):
14         url = url_concat(
15             "https://localhost/path",
16             [('y', 'y'), ('z', 'z')],
17         )
18         self.assertEqual(url, "https://localhost/path?y=y&amp;z=z")
19     def test_url_concat_encode_args(self):
20         url = url_concat(
21             "https://localhost/path",
22             [('y', '/y'), ('z', 'z')],
23         )
24         self.assertEqual(url, "https://localhost/path?y=%2Fy&amp;z=z")
25     def test_url_concat_trailing_q(self):
26         url = url_concat(
27             "https://localhost/path?",
28             [('y', 'y'), ('z', 'z')],
29         )
30         self.assertEqual(url, "https://localhost/path?y=y&amp;z=z")
31     def test_url_concat_q_with_no_trailing_amp(self):
32         url = url_concat(
33             "https://localhost/path?x",
34             [('y', 'y'), ('z', 'z')],
35         )
36         self.assertEqual(url, "https://localhost/path?x=&amp;y=y&amp;z=z")
37     def test_url_concat_trailing_amp(self):
38         url = url_concat(
39             "https://localhost/path?x&amp;",
40             [('y', 'y'), ('z', 'z')],
41         )
42         self.assertEqual(url, "https://localhost/path?x=&amp;y=y&amp;z=z")
43     def test_url_concat_mult_params(self):
44         url = url_concat(
45             "https://localhost/path?a=1&amp;b=2",
46             [('y', 'y'), ('z', 'z')],
47         )
48         self.assertEqual(url, "https://localhost/path?a=1&amp;b=2&amp;y=y&amp;z=z")
49     def test_url_concat_no_params(self):
50         url = url_concat(
51             "https://localhost/path?r=1&amp;t=2",
52             [],
53         )
54         self.assertEqual(url, "https://localhost/path?r=1&amp;t=2")
55     def test_url_concat_none_params(self):
56         url = url_concat(
57             "https://localhost/path?r=1&amp;t=2",
58             None,
59         )
60         self.assertEqual(url, "https://localhost/path?r=1&amp;t=2")
61     def test_url_concat_with_frag(self):
62         url = url_concat(
63             "https://localhost/path#tab",
64             [('y', 'y')],
65         )
66         self.assertEqual(url, "https://localhost/path?y=y#tab")
67     def test_url_concat_multi_same_params(self):
68         url = url_concat(
69             "https://localhost/path",
70             [('y', 'y1'), ('y', 'y2')],
71         )
72         self.assertEqual(url, "https://localhost/path?y=y1&amp;y=y2")
73     def test_url_concat_multi_same_query_params(self):
74         url = url_concat(
75             "https://localhost/path?r=1&amp;r=2",
76             [('y', 'y')],
77         )
78         self.assertEqual(url, "https://localhost/path?r=1&amp;r=2&amp;y=y")
79     def test_url_concat_dict_params(self):
80         url = url_concat(
81             "https://localhost/path",
82             dict(y='y'),
83         )
84         self.assertEqual(url, "https://localhost/path?y=y")
85 class MultipartFormDataTest(unittest.TestCase):
86     def test_file_upload(self):
87         data = b"""\
88 --1234
89 Content-Disposition: form-data; name="files"; filename="ab.txt"
90 Foo
91 --1234--""".replace(b"\n", b"\r\n")
92         args = {}
93         files = {}
94         parse_multipart_form_data(b"1234", data, args, files)
95         file = files["files"][0]
96         self.assertEqual(file["filename"], "ab.txt")
97         self.assertEqual(file["body"], b"Foo")
98     def test_unquoted_names(self):
99         data = b"""\
100 --1234
101 Content-Disposition: form-data; name=files; filename=ab.txt
102 Foo
103 --1234--""".replace(b"\n", b"\r\n")
104         args = {}
105         files = {}
106         parse_multipart_form_data(b"1234", data, args, files)
107         file = files["files"][0]
108         self.assertEqual(file["filename"], "ab.txt")
109         self.assertEqual(file["body"], b"Foo")
110     def test_special_filenames(self):
111         filenames = ['a;b.txt',
112                      'a"b.txt',
113                      'a";b.txt',
114                      'a;"b.txt',
115                      'a";";.txt',
116                      'a\\"b.txt',
117                      'a\\b.txt',
118                      ]
119         for filename in filenames:
120             logging.debug("trying filename %r", filename)
121             data = """\
122 --1234
123 Content-Disposition: form-data; name="files"; filename="%s"
124 Foo
125 --1234--""" % filename.replace('\\', '\\\\').replace('"', '\\"')
126             data = utf8(data.replace("\n", "\r\n"))
127             args = {}
128             files = {}
129             parse_multipart_form_data(b"1234", data, args, files)
130             file = files["files"][0]
131             self.assertEqual(file["filename"], filename)
132             self.assertEqual(file["body"], b"Foo")
133     def test_boundary_starts_and_ends_with_quotes(self):
134         data = b'''\
135 --1234
136 Content-Disposition: form-data; name="files"; filename="ab.txt"
137 Foo
138 --1234--'''.replace(b"\n", b"\r\n")
139         args = {}
140         files = {}
141         parse_multipart_form_data(b'"1234"', data, args, files)
142         file = files["files"][0]
143         self.assertEqual(file["filename"], "ab.txt")
144         self.assertEqual(file["body"], b"Foo")
145     def test_missing_headers(self):
146         data = b'''\
147 --1234
148 Foo
149 --1234--'''.replace(b"\n", b"\r\n")
150         args = {}
151         files = {}
152         with ExpectLog(gen_log, "multipart/form-data missing headers"):
153             parse_multipart_form_data(b"1234", data, args, files)
154         self.assertEqual(files, {})
155     def test_invalid_content_disposition(self):
156         data = b'''\
157 --1234
158 Content-Disposition: invalid; name="files"; filename="ab.txt"
159 Foo
160 --1234--'''.replace(b"\n", b"\r\n")
161         args = {}
162         files = {}
163         with ExpectLog(gen_log, "Invalid multipart/form-data"):
164             parse_multipart_form_data(b"1234", data, args, files)
165         self.assertEqual(files, {})
166     def test_line_does_not_end_with_correct_line_break(self):
167         data = b'''\
168 --1234
169 Content-Disposition: form-data; name="files"; filename="ab.txt"
170 Foo--1234--'''.replace(b"\n", b"\r\n")
171         args = {}
172         files = {}
173         with ExpectLog(gen_log, "Invalid multipart/form-data"):
174             parse_multipart_form_data(b"1234", data, args, files)
175         self.assertEqual(files, {})
176     def test_content_disposition_header_without_name_parameter(self):
177         data = b"""\
178 --1234
179 Content-Disposition: form-data; filename="ab.txt"
180 Foo
181 --1234--""".replace(b"\n", b"\r\n")
182         args = {}
183         files = {}
184         with ExpectLog(gen_log, "multipart/form-data value missing name"):
185             parse_multipart_form_data(b"1234", data, args, files)
186         self.assertEqual(files, {})
187     def test_data_after_final_boundary(self):
188         data = b"""\
189 --1234
190 Content-Disposition: form-data; name="files"; filename="ab.txt"
191 Foo
192 --1234--
193         self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(headers.get_list("asdf"), ["qwer zxcv"])
194         self.assertEqual(headers["Foo"], "bar baz,even more lines")
195         self.assertEqual(headers.get_list("foo"), ["bar baz", "even more lines"])
196         self.assertEqual(</b></font>sorted(list(headers.get_all())),
197                          [("Asdf", "qwer zxcv"),
198                           ("Foo", "bar baz"),
199                           ("Foo", "even more lines")])
200     def test_unicode_newlines(self):
201         newlines = [
202             u'\u001b',  # VERTICAL TAB
203             u'\u001c',  # FILE SEPARATOR
204             u'\u001d',  # GROUP SEPARATOR
205             u'\u001e',  # RECORD SEPARATOR
206             u'\u0085',  # NEXT LINE
207             u'\u2028',  # LINE SEPARATOR
208             u'\u2029',  # PARAGRAPH SEPARATOR
209         ]
210         for newline in newlines:
211             for encoding in ['utf8', 'latin1']:
212                 try:
213                     try:
214                         encoded = newline.encode(encoding)
215                     except UnicodeEncodeError:
216                         continue
217                     data = b'Cookie: foo=' + encoded + b'bar'
218                     headers = HTTPHeaders.parse(
219                         native_str(data.decode('latin1')))
220                     expected = [('Cookie', 'foo=' +
221                                  native_str(encoded.decode('latin1')) + 'bar')]
222                     self.assertEqual(
223                         expected, list(headers.get_all()))
224                 except Exception:
225                     gen_log.warning("failed while trying %r in %s",
226                                     newline, encoding)
227                     raise
228     def test_optional_cr(self):
229         headers = HTTPHeaders.parse(
230             'CRLF: crlf\r\nLF: lf\nCR: cr\rMore: more\r\n')
231         self.assertEqual(sorted(headers.get_all()),
232                          [('Cr', 'cr\rMore: more'),
233                           ('Crlf', 'crlf'),
234                           ('Lf', 'lf'),
235                           ])
236     def test_copy(self):
237         all_pairs = [('A', '1'), ('A', '2'), ('B', 'c')]
238         h1 = HTTPHeaders()
239         for k, v in all_pairs:
240             h1.add(k, v)
241         h2 = h1.copy()
242         h3 = copy.copy(h1)
243         h4 = copy.deepcopy(h1)
244         for headers in [h1, h2, h3, h4]:
245             self.assertEqual(list(sorted(headers.get_all())), all_pairs)
246         for headers in [h2, h3, h4]:
247             self.assertIsNot(headers, h1)
248             self.assertIsNot(headers.get_list('A'), h1.get_list('A'))
249     def test_pickle_roundtrip(self):
250         headers = HTTPHeaders()
251         headers.add('Set-Cookie', 'a=b')
252         headers.add('Set-Cookie', 'c=d')
253         headers.add('Content-Type', 'text/html')
254         pickled = pickle.dumps(headers)
255         unpickled = pickle.loads(pickled)
256         self.assertEqual(sorted(headers.get_all()), sorted(unpickled.get_all()))
257         self.assertEqual(sorted(headers.items()), sorted(unpickled.items()))
258     def test_setdefault(self):
259         headers = HTTPHeaders()
260         headers['foo'] = 'bar'
261         self.assertEqual(headers.setdefault('foo', 'baz'), 'bar')
262         self.assertEqual(headers['foo'], 'bar')
263         self.assertEqual(headers.setdefault('quux', 'xyzzy'), 'xyzzy')
264         self.assertEqual(headers['quux'], 'xyzzy')
265         self.assertEqual(sorted(headers.get_all()), [('Foo', 'bar'), ('Quux', 'xyzzy')])
266     def test_string(self):
267         headers = HTTPHeaders()
268         headers.add("Foo", "1")
269         headers.add("Foo", "2")
270         headers.add("Foo", "3")
271         headers2 = HTTPHeaders.parse(str(headers))
272         self.assertEquals(headers, headers2)
273 class FormatTimestampTest(unittest.TestCase):
274     TIMESTAMP = 1359312200.503611
275     EXPECTED = 'Sun, 27 Jan 2013 18:43:20 GMT'
276     def check(self, value):
277         self.assertEqual(format_timestamp(value), self.EXPECTED)
278     def test_unix_time_float(self):
279         self.check(self.TIMESTAMP)
280     def test_unix_time_int(self):
281         self.check(int(self.TIMESTAMP))
282     def test_struct_time(self):
283         self.check(time.gmtime(self.TIMESTAMP))
284     def test_time_tuple(self):
285         tup = tuple(time.gmtime(self.TIMESTAMP))
286         self.assertEqual(9, len(tup))
287         self.check(tup)
288     def test_datetime(self):
289         self.check(datetime.datetime.utcfromtimestamp(self.TIMESTAMP))
290 class HTTPServerRequestTest(unittest.TestCase):
291     def test_default_constructor(self):
292         HTTPServerRequest(uri='/')
293     def test_body_is_a_byte_string(self):
294         requets = HTTPServerRequest(uri='/')
295         self.assertIsInstance(requets.body, bytes)
296 class ParseRequestStartLineTest(unittest.TestCase):
297     METHOD = "GET"
298     PATH = "/foo"
299     VERSION = "HTTP/1.1"
300     def test_parse_request_start_line(self):
301         start_line = " ".join([self.METHOD, self.PATH, self.VERSION])
302         parsed_start_line = parse_request_start_line(start_line)
303         self.assertEqual(parsed_start_line.method, self.METHOD)
304         self.assertEqual(parsed_start_line.path, self.PATH)
305         self.assertEqual(parsed_start_line.version, self.VERSION)
306 class ParseCookieTest(unittest.TestCase):
307     def test_python_cookies(self):
308         self.assertEqual(parse_cookie('chips=ahoy; vienna=finger'), {'chips': 'ahoy', 'vienna': 'finger'})
309         self.assertEqual(
310             parse_cookie('keebler="E=mc2; L=\\"Loves\\"; fudge=\\012;"'),
311             {'keebler': '"E=mc2', 'L': '\\"Loves\\"', 'fudge': '\\012', '': '"'}
312         )
313         self.assertEqual(parse_cookie('keebler=E=mc2'), {'keebler': 'E=mc2'})
314         self.assertEqual(parse_cookie('key:term=value:term'), {'key:term': 'value:term'})
315         self.assertEqual(parse_cookie('a=b; c=[; d=r; f=h'), {'a': 'b', 'c': '[', 'd': 'r', 'f': 'h'})
316     def test_cookie_edgecases(self):
317         self.assertEqual(parse_cookie('a=b; Domain=example.com'), {'a': 'b', 'Domain': 'example.com'})
318         self.assertEqual(parse_cookie('a=b; h=i; a=c'), {'a': 'c', 'h': 'i'})
319     def test_invalid_cookies(self):
320         self.assertIn('django_language', parse_cookie('abc=def; unnamed; django_language=en').keys())
321         self.assertEqual(parse_cookie('a=b; "; c=d'), {'a': 'b', '': '"', 'c': 'd'})
322         self.assertEqual(parse_cookie('a b c=d e = f; gh=i'), {'a b c': 'd e = f', 'gh': 'i'})
323         self.assertEqual(parse_cookie('a   b,c&lt;&gt;@:/[]?{}=d  "  =e,f g'), {'a   b,c&lt;&gt;@:/[]?{}': 'd  "  =e,f g'})
324         self.assertEqual(parse_cookie('saint=André Bessette'), {'saint': native_str('André Bessette')})
325         self.assertEqual(parse_cookie('  =  b  ;  ;  =  ;   c  =  ;  '), {'': 'b', 'c': ''})
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_process_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import functools
3 import io
4 import multiprocessing
5 import os
6 import signal
7 import sys
8 import tempfile
9 import threading
10 import time
11 import warnings
12 import pytest
13 import salt.utils.platform
14 import salt.utils.process
15 from salt.utils.versions import warn_until_date
16 from tests.support.mock import patch
17 from tests.support.unit import TestCase, skipIf
18 HAS_PSUTIL = False
19 try:
20     import psutil
21     HAS_PSUTIL = True
22 except ImportError:
23     pass
24 def die(func):
25     @functools.wraps(func)
26     def wrapper(self):
27         name = func.__name__[5:]
28         def _die():
29             salt.utils.process.appendproctitle("test_{}".format(name))
30         attrname = "die_" + name
31         setattr(self, attrname, _die)
32         self.addCleanup(delattr, self, attrname)
33     return wrapper
34 def incr(func):
35     @functools.wraps(func)
36     def wrapper(self):
37         name = func.__name__[5:]
38         def _incr(counter, num):
39             salt.utils.process.appendproctitle("test_{}".format(name))
40             for _ in range(0, num):
41                 counter.value += 1
42         attrname = "incr_" + name
43         setattr(self, attrname, _incr)
44         self.addCleanup(delattr, self, attrname)
45     return wrapper
46 def spin(func):
47     @functools.wraps(func)
48     def wrapper(self):
49         name = func.__name__[5:]
50         def _spin():
51             salt.utils.process.appendproctitle("test_{}".format(name))
52             while True:
53                 time.sleep(1)
54         attrname = "spin_" + name
55         setattr(self, attrname, _spin)
56         self.addCleanup(delattr, self, attrname)
57     return wrapper
58 class TestProcessManager(TestCase):
59     @spin
60     @pytest.mark.slow_test
61     def test_basic(self):
62         process_manager = salt.utils.process.ProcessManager()
63         self.addCleanup(process_manager.terminate)
64         process_manager.add_process(self.spin_basic)
65         initial_pid = next(iter(process_manager._process_map.keys()))
66         time.sleep(2)
67         process_manager.check_children()
68         assert initial_pid == next(iter(process_manager._process_map.keys()))
69     @spin
70     def test_kill(self):
71         process_manager = salt.utils.process.ProcessManager()
72         self.addCleanup(process_manager.terminate)
73         process_manager.add_process(self.spin_kill)
74         initial_pid = next(iter(process_manager._process_map.keys()))
75         if salt.utils.platform.is_windows():
76             os.kill(initial_pid, signal.SIGTERM)
77         else:
78             os.kill(initial_pid, signal.SIGKILL)
79         time.sleep(0.1)
80         process_manager.check_children()
81         assert initial_pid != next(iter(process_manager._process_map.keys()))
82     @die
83     def test_restarting(self):
84         process_manager = salt.utils.process.ProcessManager()
85         self.addCleanup(process_manager.terminate)
86         process_manager.add_process(self.die_restarting)
87         initial_pid = next(iter(process_manager._process_map.keys()))
88         time.sleep(2)
89         process_manager.check_children()
90         assert initial_pid != next(iter(process_manager._process_map.keys()))
91     @incr
92     def test_counter(self):
93         counter = multiprocessing.Value("i", 0)
94         process_manager = salt.utils.process.ProcessManager()
95         self.addCleanup(process_manager.terminate)
96         process_manager.add_process(self.incr_counter, args=(counter, 2))
97         time.sleep(1)
98         process_manager.check_children()
99         time.sleep(1)
100         assert counter.value == 4
101 class TestThreadPool(TestCase):
102     @pytest.mark.slow_test
103     def test_basic(self):
104         def incr_counter(counter):
105             counter.value += 1
106         counter = multiprocessing.Value("i", 0)
107         pool = salt.utils.process.ThreadPool()
108         sent = pool.fire_async(incr_counter, args=(counter,))
109         self.assertTrue(sent)
110         time.sleep(1)  # Sleep to let the threads do things
111         self.assertEqual(counter.value, 1)
112         self.assertEqual(pool._job_queue.qsize(), 0)
113     @pytest.mark.slow_test
114     def test_full_queue(self):
115         def incr_counter(counter):
116             counter.value += 1
117         counter = multiprocessing.Value("i", 0)
118         pool = salt.utils.process.ThreadPool(0, 1)
119         sent = pool.fire_async(incr_counter, args=(counter,))
120         self.assertTrue(sent)
121         sent = pool.fire_async(incr_counter, args=(counter,))
122         self.assertFalse(sent)
123         time.sleep(1)  # Sleep to let the threads do things
124         self.assertEqual(counter.value, 0)
125         self.assertEqual(pool._job_queue.qsize(), 1)
126 class TestProcess(TestCase):
127     def test_daemonize_if(self):
128         with patch("sys.argv", ["salt-call"]):
129             ret = salt.utils.process.daemonize_if({})
130             self.assertEqual(None, ret)
131         ret = salt.utils.process.daemonize_if({"multiprocessing": False})
132         self.assertEqual(None, ret)
133         with patch("sys.platform", "win"):
134             ret = salt.utils.process.daemonize_if({})
135             self.assertEqual(None, ret)
136         with patch("salt.utils.process.daemonize"), patch("sys.platform", "linux2"):
137             salt.utils.process.daemonize_if({})
138             self.assertTrue(salt.utils.process.daemonize.called)
139 class TestProcessCallbacks(TestCase):
140     @staticmethod
141     def process_target(evt):
142         evt.set()
143     def test_callbacks(self):
144         "Validate Process call after fork and finalize methods"
145         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
146         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
147         with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
148             evt = multiprocessing.Event()
149             proc = salt.utils.process.Process(target=self.process_target, args=(evt,))
150             proc.run()
151             assert evt.is_set()
152         mb.assert_called()
153         ma.assert_called()
154     def test_callbacks_called_when_run_overridden(self):
155         "Validate Process sub classes call after fork and finalize methods when run is overridden"
156         class MyProcess(salt.utils.process.Process):
157             def __init__(self):
158                 super().__init__()
159                 self.evt = multiprocessing.Event()
160             def run(self):
161                 self.evt.set()
162         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
163         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
164         with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
165             proc = MyProcess()
166             proc.run()
167             assert proc.evt.is_set()
168         ma.assert_called()
169         mb.assert_called()
170 @skipIf(not HAS_PSUTIL, "Missing psutil")
171 class TestSignalHandlingProcess(TestCase):
172     @classmethod
173     def Process(cls, pid):
174         raise psutil.NoSuchProcess(pid)
175     @classmethod
176     def target(cls):
177         os.kill(os.getpid(), signal.SIGTERM)
178     @classmethod
179     def children(cls, *args, **kwargs):
180         raise psutil.NoSuchProcess(1)
181     def test_process_does_not_exist(self):
182         try:
183             with patch("psutil.Process", self.Process):
184                 proc = salt.utils.process.SignalHandlingProcess(target=self.target)
185                 proc.start()
186         except psutil.NoSuchProcess:
187             assert False, "psutil.NoSuchProcess raised"
188     def test_process_children_do_not_exist(self):
189         try:
190             with patch("psutil.Process.children", self.children):
191                 proc = salt.utils.process.SignalHandlingProcess(target=self.target)
192                 proc.start()
193         except psutil.NoSuchProcess:
194             assert False, "psutil.NoSuchProcess raised"
195     @staticmethod
196     def run_forever_sub_target(evt):
197         "Used by run_forever_target to create a sub-process"
198         while not evt.is_set():
199             time.sleep(1)
200     @staticmethod
201     def run_forever_target(sub_target, evt):
202         "A target that will run forever or until an event is set"
203         p = multiprocessing.Process(target=sub_target, args=(evt,))
204         p.start()
205         p.join()
206     @staticmethod
207     def kill_target_sub_proc():
208         pid = os.fork()
209         if pid == 0:
210             return
211         pid = os.fork()
212         if pid == 0:
213             return
214         time.sleep(0.1)
215         try:
216             os.kill(os.getpid(), signal.SIGINT)
217         except KeyboardInterrupt:
218             pass
219     @skipIf(sys.platform.startswith("win"), "No os.fork on Windows")
220     @pytest.mark.slow_test
221     def test_signal_processing_regression_test(self):
222         evt = multiprocessing.Event()
223         sh_proc = salt.utils.process.SignalHandlingProcess(
224             target=self.run_forever_target, args=(self.run_forever_sub_target, evt)
225         )
226         sh_proc.start()
227         proc = multiprocessing.Process(target=self.kill_target_sub_proc)
228         proc.start()
229         proc.join()
230         try:
231             assert sh_proc.is_alive()
232         finally:
233             evt.set()
234             sh_proc.join()
235     @staticmethod
236     def no_op_target():
237         pass
238     @staticmethod
239     def pid_setting_target(sub_target, val, evt):
240         val.value = os.getpid()
241         p = multiprocessing.Process(target=sub_target, args=(evt,))
242         p.start()
243         p.join()
244     @skipIf(sys.platform.startswith("win"), "Required signals not supported on windows")
245     @pytest.mark.slow_test
246     def test_signal_processing_handle_signals_called(self):
247         "Validate SignalHandlingProcess handles signals"
248         evt = multiprocessing.Event()
249         val = multiprocessing.Value("i", 0)
250         proc = salt.utils.process.SignalHandlingProcess(
251             target=self.pid_setting_target,
252             args=(self.run_forever_sub_target, val, evt),
253         )
254         proc.start()
255         proc2 = multiprocessing.Process(
256             target=self.run_forever_target,
257             args=(self.run_forever_sub_target, evt),
258         )
259         proc2.start()
260         while not val.value:
261             time.sleep(0.3)
262         assert not proc.signal_handled()
263         os.kill(val.value, signal.SIGTERM)
264         start = time.time()
265         while time.time() - start &lt; 10:
266             if proc.signal_handled():
267                 break
268             time.sleep(0.3)
269         try:
270             assert proc.signal_handled()
271             proc.join(1)
272             assert proc2.is_alive()
273         finally:
274             evt.set()
275             proc2.join(30)
276             proc.join(30)
277 class TestSignalHandlingProcessCallbacks(TestCase):
278     @staticmethod
279     def process_target(evt):
280         evt.set()
281     def test_callbacks(self):
282         "Validate SignalHandlingProcess call after fork and finalize methods"
283         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
284         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
285         sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
286         evt = multiprocessing.Event()
287         with patch(sig_to_mock):
288             with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
289                 sh_proc = salt.utils.process.SignalHandlingProcess(
290                     target=self.process_target, args=(evt,)
291                 )
292                 sh_proc.run()
293                 assert evt.is_set()
294         ma.assert_called()
295         mb.assert_called()
296     def test_callbacks_called_when_run_overridden(self):
297         "Validate SignalHandlingProcess sub classes call after fork and finalize methods when run is overridden"
298         class MyProcess(salt.utils.process.SignalHandlingProcess):
299             def __init__(self):
300                 super().__init__()
301                 self.evt = multiprocessing.Event()
302             def run(self):
303                 self.evt.set()
304         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
305         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
306         sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
307         with patch(sig_to_mock):
308             with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
309                 sh_proc = MyProcess()
310                 sh_proc.run()
311                 assert sh_proc.evt.is_set()
312         ma.assert_called()
313         mb.assert_called()
314 class TestDup2(TestCase):
315     def test_dup2_no_fileno(self):
316         "The dup2 method does not fail on streams without fileno support"
317         f1 = io.StringIO("some initial text data")
318         f2 = io.StringIO("some initial other text data")
319         with self.assertRaises(io.UnsupportedOperation):
320             f1.fileno()
321         with patch("os.dup2") as dup_mock:
322             try:
323                 salt.utils.process.dup2(f1, f2)
324             except io.UnsupportedOperation:
325                 assert False, "io.UnsupportedOperation was raised"
326         assert not dup_mock.called
327 def null_target():
328     pass
329 def event_target(event):
330     while True:
331         if event.wait(5):
332             break
333 class TestProcessList(TestCase):
334     @staticmethod
335     def wait_for_proc(proc, timeout=10):
336         start = time.time()
337         while proc.is_alive():
338             if time.time() - start &gt; timeout:
339                 raise Exception("Process did not finishe before timeout")
340             time.sleep(0.3)
341     @pytest.mark.slow_test
342     def test_process_list_process(self):
343         plist = salt.utils.process.SubprocessList()
344         proc = multiprocessing.Process(target=null_target)
345         proc.start()
346         plist.add(proc)
347         assert proc in plist.processes
348         self.wait_for_proc(proc)
349         assert not proc.is_alive()
350         plist.cleanup()
351         assert proc not in plist.processes
352     def test_process_list_thread(self):
353         plist = salt.utils.process.SubprocessList()
354         thread = threading.Thread(target=null_target)
355         thread.start()
356         plist.add(thread)
357         assert thread in plist.processes
358         self.wait_for_proc(thread)
359         assert not thread.is_alive()
360         plist.cleanup()
361         assert thread not in plist.processes
362     @pytest.mark.slow_test
363     def test_process_list_cleanup(self):
364         plist = salt.utils.process.SubprocessList()
365         event = multiprocessing.Event()
366         proc = multiprocessing.Process(target=event_target, args=[event])
367         proc.start()
368         plist.add(proc)
369         assert proc in plist.processes
370         plist.cleanup()
371         event.set()
372         assert proc in plist.processes
373         self.wait_for_proc(proc)
374         assert not proc.is_alive()
375         plist.cleanup()
376         assert proc not in plist.processes
377 class TestDeprecatedClassNames(TestCase):
378     @staticmethod
379     def process_target():
380         pass
381     @staticmethod
382     def patched_warn_until_date(current_date):
383         def _patched_warn_until_date(
384             date,
385             message,
386             category=DeprecationWarning,
387             stacklevel=None,
388             _current_date=current_date,
389             _dont_call_warnings=False,
390         ):
391             stacklevel = 4
392             return warn_until_date(
393                 date,
394                 message,
395                 category=category,
396                 stacklevel=stacklevel,
397                 _current_date=_current_date,
398                 _dont_call_warnings=_dont_call_warnings,
399             )
400         return _patched_warn_until_date
401     def test_multiprocessing_process_warning(self):
402         warnings.filterwarnings("always", "", DeprecationWarning, __name__)
403         fake_utcnow = datetime.date(2021, 1, 1)
404         proc = None
405         try:
406             with patch(
407                 "salt.utils.versions.warn_until_date",
408                 self.patched_warn_until_date(fake_utcnow),
409             ):
410                 with warnings.catch_warnings(record=True) as recorded_warnings:
411                     proc = salt.utils.process.MultiprocessingProcess(
412                         target=self.process_target
413                     )
414                     self.assertEqual(
415                         "Please stop using 'salt.utils.process.MultiprocessingProcess' "
416                         "and instead use 'salt.utils.process.Process'. "
417                         "'salt.utils.process.MultiprocessingProcess' will go away "
418                         "after 2022-01-01.",
419                         str(recorded_warnings[0].message),
420                     )
421         finally:
422             if proc is not None:
423                 del proc
424     def test_multiprocessing_process_runtime_error(self):
425         fake_utcnow = datetime.date(2022, 1, 1)
426         proc = None
427         try:
428             with patch(
429                 "salt.utils.versions.warn_until_date",
430                 self.patched_warn_until_date(fake_utcnow),
431             ):
432                 with self.assertRaisesRegex(
433                     RuntimeError,
434                     r"Please stop using 'salt.utils.process.MultiprocessingProcess' "
435                     r"and instead use 'salt.utils.process.Process'. "
436                     r"'salt.utils.process.MultiprocessingProcess' will go away "
437                     r"after 2022-01-01. "
438                     r"This warning\(now exception\) triggered on "
439                     r"filename '(.*)test_process.py', line number ([\d]+), is "
440                     r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
441                     r"Please remove the warning.",
442                 ):
443                     proc = salt.utils.process.MultiprocessingProcess(
444                         target=self.process_target
445                     )
446         finally:
447             if proc is not None:
448                 del proc
449     def test_signal_handling_multiprocessing_process_warning(self):
450         warnings.filterwarnings("always", "", DeprecationWarning, __name__)
451         fake_utcnow = datetime.date(2021, 1, 1)
452         proc = None
453         try:
454             with patch(
455                 "salt.utils.versions.warn_until_date",
456                 self.patched_warn_until_date(fake_utcnow),
457             ):
458                 with warnings.catch_warnings(record=True) as recorded_warnings:
459                     proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
460                         target=self.process_target
461                     )
462                     self.assertEqual(
463                         "Please stop using"
464                         " 'salt.utils.process.SignalHandlingMultiprocessingProcess' and"
465                         " instead use 'salt.utils.process.SignalHandlingProcess'."
466                         " 'salt.utils.process.SignalHandlingMultiprocessingProcess'"
467                         " will go away after 2022-01-01.",
468                         str(recorded_warnings[0].message),
469                     )
470         finally:
471             if proc is not None:
472                 del proc
473     def test_signal_handling_multiprocessing_process_runtime_error(self):
474         fake_utcnow = datetime.date(2022, 1, 1)
475         proc = None
476         try:
477             with patch(
478                 "salt.utils.versions.warn_until_date",
479                 self.patched_warn_until_date(fake_utcnow),
480             ):
481                 with self.assertRaisesRegex(
482                     RuntimeError,
483                     r"Please stop using"
484                     r" 'salt.utils.process.SignalHandlingMultiprocessingProcess' "
485                     r"and instead use 'salt.utils.process.SignalHandlingProcess'. "
486                     r"'salt.utils.process.SignalHandlingMultiprocessingProcess' will go"
487                     r" away "
488                     r"after 2022-01-01. "
489                     r"This warning\(now exception\) triggered on "
490                     r"filename '(.*)test_process.py', line number ([\d]+), is "
491                     r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
492                     r"Please remove the warning.",
493                 ):
494                     proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
495                         target=self.process_target
496                     )
497         finally:
498             if proc is not None:
499                 del proc
500 class CMORProcessHelper:
501     def __init__(self, file_name):
502         self._lock = threading.Lock()
503         self._running = True
504         self._queue = multiprocessing.Queue()
505         self._ret_queue = multiprocessing.Queue()
506         self._process = multiprocessing.Process(
507             target=self.test_process,
508             args=(file_name, self._queue, self._ret_queue),
509             daemon=True,
510         )
511         self._process.start()
512     def __enter__(self):
513         return self
514     def __exit__(self, exc_type, exc_val, exc_tb):
515         self.stop()
516     def claim(self):
517         try:
518             self._lock.acquire()
519             if self._running:
520                 self._queue.put("claim")
521                 return self._ret_queue.get(timeout=10)
522         finally:
523             self._lock.release()
524     def stop(self):
525         try:
526             self._lock.acquire()
527             if self._running:
528                 self._running = False
529                 self._queue.put("stop")
530                 self._process.join(timeout=10)
531                 self._queue.close()
532                 self._ret_queue.close()
533         finally:
534             self._lock.release()
535     @property
536     def pid(self):
537         return self._process.pid
538     @staticmethod
539     def test_process(file_name, queue, ret_queue):
540         while True:
541             action = queue.get()
542             if action == "claim":
543                 ret_queue.put(
544                     salt.utils.process.claim_mantle_of_responsibility(file_name)
545                 )
546             elif action == "stop":
547                 return
548 @skipIf(not HAS_PSUTIL, "Missing psutil")
549 class TestGetProcessInfo(TestCase):
550     def setUp(self):
551         handle, self.cmor_test_file_path = tempfile.mkstemp()
552         os.close(handle)
553         self.addCleanup(os.unlink, self.cmor_test_file_path)
554     def test_this_process(self):
555         this_process_info = salt.utils.process.get_process_info()
556         self.assertEqual(
557             this_process_info, salt.utils.process.get_process_info(os.getpid())
558         )
559         self.assertIsNotNone(this_process_info)
560 <a name="0"></a>        for key in ("pid", "name", "start_time"):
561             self.assertIn(key, this_process_info)
562         raw_process_info = psutil<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Process(os.getpid())
563         self.assertEqual(this_process_info["pid"], os.getpid())
564         self.assertEqual(this_process_info["name"], raw_process_info.name(</b></font>))
565         self.assertEqual(
566             this_process_info["start_time"], raw_process_info.create_time()
567         )
568     def test_random_processes(self):
569         for _ in range(3):
570             with CMORProcessHelper(self.cmor_test_file_path) as p1:
571                 pid = p1.pid
572                 self.assertIsInstance(salt.utils.process.get_process_info(pid), dict)
573             self.assertIsNone(salt.utils.process.get_process_info(pid))
574 @skipIf(not HAS_PSUTIL, "Missing psutil")
575 class TestClaimMantleOfResponsibility(TestCase):
576     def setUp(self):
577         handle, self.cmor_test_file_path = tempfile.mkstemp()
578         os.close(handle)
579         self.addCleanup(os.unlink, self.cmor_test_file_path)
580     def test_simple_claim_no_psutil(self):
581         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
582     def test_simple_claim(self):
583         for _ in range(5):
584             self.assertTrue(
585                 salt.utils.process.claim_mantle_of_responsibility(
586                     self.cmor_test_file_path
587                 )
588             )
589     def test_multiple_processes(self):
590         with CMORProcessHelper(self.cmor_test_file_path) as p1:
591             self.assertTrue(p1.claim())
592             self.assertFalse(
593                 salt.utils.process.claim_mantle_of_responsibility(
594                     self.cmor_test_file_path
595                 )
596             )
597             with CMORProcessHelper(self.cmor_test_file_path) as p2:
598                 for _ in range(3):
599                     self.assertFalse(p2.claim())
600             self.assertTrue(p1.claim())
601         with CMORProcessHelper(self.cmor_test_file_path) as p1:
602             self.assertTrue(p1.claim())
603             self.assertFalse(
604                 salt.utils.process.claim_mantle_of_responsibility(
605                     self.cmor_test_file_path
606                 )
607             )
608         self.assertTrue(
609             salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
610         )
611 @skipIf(not HAS_PSUTIL, "Missing psutil")
612 class TestCheckMantleOfResponsibility(TestCase):
613     def setUp(self):
614         handle, self.cmor_test_file_path = tempfile.mkstemp()
615         os.close(handle)
616         self.addCleanup(os.unlink, self.cmor_test_file_path)
617     def test_simple_claim_no_psutil(self):
618         self.assertIsNone(
619             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
620         )
621     def test_simple_claim(self):
622         self.assertIsNone(
623             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
624         )
625         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
626         pid = salt.utils.process.get_process_info()["pid"]
627         self.assertEqual(
628             pid,
629             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path),
630         )
631     def test_multiple_processes(self):
632         self.assertIsNone(
633             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
634         )
635         with CMORProcessHelper(self.cmor_test_file_path) as p1:
636             self.assertTrue(p1.claim())
637             random_pid = salt.utils.process.check_mantle_of_responsibility(
638                 self.cmor_test_file_path
639             )
640             self.assertIsInstance(random_pid, int)
641             with CMORProcessHelper(self.cmor_test_file_path) as p2:
642                 for _ in range(3):
643                     self.assertFalse(p2.claim())
644                 self.assertEqual(
645                     random_pid,
646                     salt.utils.process.check_mantle_of_responsibility(
647                         self.cmor_test_file_path
648                     ),
649                 )
650         self.assertIsNone(
651             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
652         )
653         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
654         pid = salt.utils.process.get_process_info()["pid"]
655         self.assertEqual(
656             pid,
657             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path),
658         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
