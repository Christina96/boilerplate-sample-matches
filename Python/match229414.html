<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for httputil_test.py &amp; test_process_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for httputil_test.py &amp; test_process_1.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>httputil_test.py (2.2257552%)<th>test_process_1.py (0.9478673%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(261-264)<td><a href="#" name="0">(734-736)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>httputil_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
from __future__ import absolute_import, division, print_function
from salt.ext.tornado.httputil import url_concat, parse_multipart_form_data, HTTPHeaders, format_timestamp, HTTPServerRequest, parse_request_start_line, parse_cookie
from salt.ext.tornado.escape import utf8, native_str
from salt.ext.tornado.log import gen_log
from salt.ext.tornado.testing import ExpectLog
from salt.ext.tornado.test.util import unittest
import copy
import datetime
import logging
import pickle
import time
class TestUrlConcat(unittest.TestCase):
    def test_url_concat_no_query_params(self):
        url = url_concat(
            "https://localhost/path",
            [('y', 'y'), ('z', 'z')],
        )
        self.assertEqual(url, "https://localhost/path?y=y&amp;z=z")
    def test_url_concat_encode_args(self):
        url = url_concat(
            "https://localhost/path",
            [('y', '/y'), ('z', 'z')],
        )
        self.assertEqual(url, "https://localhost/path?y=%2Fy&amp;z=z")
    def test_url_concat_trailing_q(self):
        url = url_concat(
            "https://localhost/path?",
            [('y', 'y'), ('z', 'z')],
        )
        self.assertEqual(url, "https://localhost/path?y=y&amp;z=z")
    def test_url_concat_q_with_no_trailing_amp(self):
        url = url_concat(
            "https://localhost/path?x",
            [('y', 'y'), ('z', 'z')],
        )
        self.assertEqual(url, "https://localhost/path?x=&amp;y=y&amp;z=z")
    def test_url_concat_trailing_amp(self):
        url = url_concat(
            "https://localhost/path?x&amp;",
            [('y', 'y'), ('z', 'z')],
        )
        self.assertEqual(url, "https://localhost/path?x=&amp;y=y&amp;z=z")
    def test_url_concat_mult_params(self):
        url = url_concat(
            "https://localhost/path?a=1&amp;b=2",
            [('y', 'y'), ('z', 'z')],
        )
        self.assertEqual(url, "https://localhost/path?a=1&amp;b=2&amp;y=y&amp;z=z")
    def test_url_concat_no_params(self):
        url = url_concat(
            "https://localhost/path?r=1&amp;t=2",
            [],
        )
        self.assertEqual(url, "https://localhost/path?r=1&amp;t=2")
    def test_url_concat_none_params(self):
        url = url_concat(
            "https://localhost/path?r=1&amp;t=2",
            None,
        )
        self.assertEqual(url, "https://localhost/path?r=1&amp;t=2")
    def test_url_concat_with_frag(self):
        url = url_concat(
            "https://localhost/path#tab",
            [('y', 'y')],
        )
        self.assertEqual(url, "https://localhost/path?y=y#tab")
    def test_url_concat_multi_same_params(self):
        url = url_concat(
            "https://localhost/path",
            [('y', 'y1'), ('y', 'y2')],
        )
        self.assertEqual(url, "https://localhost/path?y=y1&amp;y=y2")
    def test_url_concat_multi_same_query_params(self):
        url = url_concat(
            "https://localhost/path?r=1&amp;r=2",
            [('y', 'y')],
        )
        self.assertEqual(url, "https://localhost/path?r=1&amp;r=2&amp;y=y")
    def test_url_concat_dict_params(self):
        url = url_concat(
            "https://localhost/path",
            dict(y='y'),
        )
        self.assertEqual(url, "https://localhost/path?y=y")
class MultipartFormDataTest(unittest.TestCase):
    def test_file_upload(self):
        data = b"""\
--1234
Content-Disposition: form-data; name="files"; filename="ab.txt"
Foo
--1234--""".replace(b"\n", b"\r\n")
        args = {}
        files = {}
        parse_multipart_form_data(b"1234", data, args, files)
        file = files["files"][0]
        self.assertEqual(file["filename"], "ab.txt")
        self.assertEqual(file["body"], b"Foo")
    def test_unquoted_names(self):
        data = b"""\
--1234
Content-Disposition: form-data; name=files; filename=ab.txt
Foo
--1234--""".replace(b"\n", b"\r\n")
        args = {}
        files = {}
        parse_multipart_form_data(b"1234", data, args, files)
        file = files["files"][0]
        self.assertEqual(file["filename"], "ab.txt")
        self.assertEqual(file["body"], b"Foo")
    def test_special_filenames(self):
        filenames = ['a;b.txt',
                     'a"b.txt',
                     'a";b.txt',
                     'a;"b.txt',
                     'a";";.txt',
                     'a\\"b.txt',
                     'a\\b.txt',
                     ]
        for filename in filenames:
            logging.debug("trying filename %r", filename)
            data = """\
--1234
Content-Disposition: form-data; name="files"; filename="%s"
Foo
--1234--""" % filename.replace('\\', '\\\\').replace('"', '\\"')
            data = utf8(data.replace("\n", "\r\n"))
            args = {}
            files = {}
            parse_multipart_form_data(b"1234", data, args, files)
            file = files["files"][0]
            self.assertEqual(file["filename"], filename)
            self.assertEqual(file["body"], b"Foo")
    def test_boundary_starts_and_ends_with_quotes(self):
        data = b'''\
--1234
Content-Disposition: form-data; name="files"; filename="ab.txt"
Foo
--1234--'''.replace(b"\n", b"\r\n")
        args = {}
        files = {}
        parse_multipart_form_data(b'"1234"', data, args, files)
        file = files["files"][0]
        self.assertEqual(file["filename"], "ab.txt")
        self.assertEqual(file["body"], b"Foo")
    def test_missing_headers(self):
        data = b'''\
--1234
Foo
--1234--'''.replace(b"\n", b"\r\n")
        args = {}
        files = {}
        with ExpectLog(gen_log, "multipart/form-data missing headers"):
            parse_multipart_form_data(b"1234", data, args, files)
        self.assertEqual(files, {})
    def test_invalid_content_disposition(self):
        data = b'''\
--1234
Content-Disposition: invalid; name="files"; filename="ab.txt"
Foo
--1234--'''.replace(b"\n", b"\r\n")
        args = {}
        files = {}
        with ExpectLog(gen_log, "Invalid multipart/form-data"):
            parse_multipart_form_data(b"1234", data, args, files)
        self.assertEqual(files, {})
    def test_line_does_not_end_with_correct_line_break(self):
        data = b'''\
--1234
Content-Disposition: form-data; name="files"; filename="ab.txt"
Foo--1234--'''.replace(b"\n", b"\r\n")
        args = {}
        files = {}
        with ExpectLog(gen_log, "Invalid multipart/form-data"):
            parse_multipart_form_data(b"1234", data, args, files)
        self.assertEqual(files, {})
    def test_content_disposition_header_without_name_parameter(self):
        data = b"""\
--1234
Content-Disposition: form-data; filename="ab.txt"
Foo
--1234--""".replace(b"\n", b"\r\n")
        args = {}
        files = {}
        with ExpectLog(gen_log, "multipart/form-data value missing name"):
            parse_multipart_form_data(b"1234", data, args, files)
        self.assertEqual(files, {})
    def test_data_after_final_boundary(self):
        data = b"""\
--1234
Content-Disposition: form-data; name="files"; filename="ab.txt"
Foo
--1234--
""".replace(b"\n", b"\r\n")
        args = {}
        files = {}
        parse_multipart_form_data(b"1234", data, args, files)
        file = files["files"][0]
        self.assertEqual(file["filename"], "ab.txt")
        self.assertEqual(file["body"], b"Foo")
class HTTPHeadersTest(unittest.TestCase):
    def test_multi_line(self):
        data = """\
Foo: bar
 baz
Asdf: qwer
\tzxcv
Foo: even
     more
     lines
        headers = HTTPHeaders.parse(data)
        self.assertEqual(headers["asdf"], "qwer zxcv")
        self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(headers.get_list("asdf"), ["qwer zxcv"])
        self.assertEqual(headers["Foo"], "bar baz,even more lines")
        self.assertEqual(headers.get_list("foo"), ["bar baz", "even more lines"])
        self.assertEqual(</b></font>sorted(list(headers.get_all())),
                         [("Asdf", "qwer zxcv"),
                          ("Foo", "bar baz"),
                          ("Foo", "even more lines")])
    def test_unicode_newlines(self):
        newlines = [
            u'\u001b',  # VERTICAL TAB
            u'\u001c',  # FILE SEPARATOR
            u'\u001d',  # GROUP SEPARATOR
            u'\u001e',  # RECORD SEPARATOR
            u'\u0085',  # NEXT LINE
            u'\u2028',  # LINE SEPARATOR
            u'\u2029',  # PARAGRAPH SEPARATOR
        ]
        for newline in newlines:
            for encoding in ['utf8', 'latin1']:
                try:
                    try:
                        encoded = newline.encode(encoding)
                    except UnicodeEncodeError:
                        continue
                    data = b'Cookie: foo=' + encoded + b'bar'
                    headers = HTTPHeaders.parse(
                        native_str(data.decode('latin1')))
                    expected = [('Cookie', 'foo=' +
                                 native_str(encoded.decode('latin1')) + 'bar')]
                    self.assertEqual(
                        expected, list(headers.get_all()))
                except Exception:
                    gen_log.warning("failed while trying %r in %s",
                                    newline, encoding)
                    raise
    def test_optional_cr(self):
        headers = HTTPHeaders.parse(
            'CRLF: crlf\r\nLF: lf\nCR: cr\rMore: more\r\n')
        self.assertEqual(sorted(headers.get_all()),
                         [('Cr', 'cr\rMore: more'),
                          ('Crlf', 'crlf'),
                          ('Lf', 'lf'),
                          ])
    def test_copy(self):
        all_pairs = [('A', '1'), ('A', '2'), ('B', 'c')]
        h1 = HTTPHeaders()
        for k, v in all_pairs:
            h1.add(k, v)
        h2 = h1.copy()
        h3 = copy.copy(h1)
        h4 = copy.deepcopy(h1)
        for headers in [h1, h2, h3, h4]:
            self.assertEqual(list(sorted(headers.get_all())), all_pairs)
        for headers in [h2, h3, h4]:
            self.assertIsNot(headers, h1)
            self.assertIsNot(headers.get_list('A'), h1.get_list('A'))
    def test_pickle_roundtrip(self):
        headers = HTTPHeaders()
        headers.add('Set-Cookie', 'a=b')
        headers.add('Set-Cookie', 'c=d')
        headers.add('Content-Type', 'text/html')
        pickled = pickle.dumps(headers)
        unpickled = pickle.loads(pickled)
        self.assertEqual(sorted(headers.get_all()), sorted(unpickled.get_all()))
        self.assertEqual(sorted(headers.items()), sorted(unpickled.items()))
    def test_setdefault(self):
        headers = HTTPHeaders()
        headers['foo'] = 'bar'
        self.assertEqual(headers.setdefault('foo', 'baz'), 'bar')
        self.assertEqual(headers['foo'], 'bar')
        self.assertEqual(headers.setdefault('quux', 'xyzzy'), 'xyzzy')
        self.assertEqual(headers['quux'], 'xyzzy')
        self.assertEqual(sorted(headers.get_all()), [('Foo', 'bar'), ('Quux', 'xyzzy')])
    def test_string(self):
        headers = HTTPHeaders()
        headers.add("Foo", "1")
        headers.add("Foo", "2")
        headers.add("Foo", "3")
        headers2 = HTTPHeaders.parse(str(headers))
        self.assertEquals(headers, headers2)
class FormatTimestampTest(unittest.TestCase):
    TIMESTAMP = 1359312200.503611
    EXPECTED = 'Sun, 27 Jan 2013 18:43:20 GMT'
    def check(self, value):
        self.assertEqual(format_timestamp(value), self.EXPECTED)
    def test_unix_time_float(self):
        self.check(self.TIMESTAMP)
    def test_unix_time_int(self):
        self.check(int(self.TIMESTAMP))
    def test_struct_time(self):
        self.check(time.gmtime(self.TIMESTAMP))
    def test_time_tuple(self):
        tup = tuple(time.gmtime(self.TIMESTAMP))
        self.assertEqual(9, len(tup))
        self.check(tup)
    def test_datetime(self):
        self.check(datetime.datetime.utcfromtimestamp(self.TIMESTAMP))
class HTTPServerRequestTest(unittest.TestCase):
    def test_default_constructor(self):
        HTTPServerRequest(uri='/')
    def test_body_is_a_byte_string(self):
        requets = HTTPServerRequest(uri='/')
        self.assertIsInstance(requets.body, bytes)
class ParseRequestStartLineTest(unittest.TestCase):
    METHOD = "GET"
    PATH = "/foo"
    VERSION = "HTTP/1.1"
    def test_parse_request_start_line(self):
        start_line = " ".join([self.METHOD, self.PATH, self.VERSION])
        parsed_start_line = parse_request_start_line(start_line)
        self.assertEqual(parsed_start_line.method, self.METHOD)
        self.assertEqual(parsed_start_line.path, self.PATH)
        self.assertEqual(parsed_start_line.version, self.VERSION)
class ParseCookieTest(unittest.TestCase):
    def test_python_cookies(self):
        """
        Test cases copied from Python's Lib/test/test_http_cookies.py
        """
        self.assertEqual(parse_cookie('chips=ahoy; vienna=finger'), {'chips': 'ahoy', 'vienna': 'finger'})
        self.assertEqual(
            parse_cookie('keebler="E=mc2; L=\\"Loves\\"; fudge=\\012;"'),
            {'keebler': '"E=mc2', 'L': '\\"Loves\\"', 'fudge': '\\012', '': '"'}
        )
        self.assertEqual(parse_cookie('keebler=E=mc2'), {'keebler': 'E=mc2'})
        self.assertEqual(parse_cookie('key:term=value:term'), {'key:term': 'value:term'})
        self.assertEqual(parse_cookie('a=b; c=[; d=r; f=h'), {'a': 'b', 'c': '[', 'd': 'r', 'f': 'h'})
    def test_cookie_edgecases(self):
        self.assertEqual(parse_cookie('a=b; Domain=example.com'), {'a': 'b', 'Domain': 'example.com'})
        self.assertEqual(parse_cookie('a=b; h=i; a=c'), {'a': 'c', 'h': 'i'})
    def test_invalid_cookies(self):
        """
        Cookie strings that go against RFC6265 but browsers will send if set
        via document.cookie.
        """
        self.assertIn('django_language', parse_cookie('abc=def; unnamed; django_language=en').keys())
        self.assertEqual(parse_cookie('a=b; "; c=d'), {'a': 'b', '': '"', 'c': 'd'})
        self.assertEqual(parse_cookie('a b c=d e = f; gh=i'), {'a b c': 'd e = f', 'gh': 'i'})
        self.assertEqual(parse_cookie('a   b,c&lt;&gt;@:/[]?{}=d  "  =e,f g'), {'a   b,c&lt;&gt;@:/[]?{}': 'd  "  =e,f g'})
        self.assertEqual(parse_cookie('saint=André Bessette'), {'saint': native_str('André Bessette')})
        self.assertEqual(parse_cookie('  =  b  ;  ;  =  ;   c  =  ;  '), {'': 'b', 'c': ''})
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_process_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import datetime
import functools
import io
import multiprocessing
import os
import signal
import sys
import tempfile
import threading
import time
import warnings
import pytest
import salt.utils.platform
import salt.utils.process
from salt.utils.versions import warn_until_date
from tests.support.mock import patch
from tests.support.unit import TestCase, skipIf
HAS_PSUTIL = False
try:
    import psutil
    HAS_PSUTIL = True
except ImportError:
    pass
def die(func):
    """
    Add proc title
    """
    @functools.wraps(func)
    def wrapper(self):
        name = func.__name__[5:]
        def _die():
            salt.utils.process.appendproctitle("test_{}".format(name))
        attrname = "die_" + name
        setattr(self, attrname, _die)
        self.addCleanup(delattr, self, attrname)
    return wrapper
def incr(func):
    """
    Increment counter
    """
    @functools.wraps(func)
    def wrapper(self):
        name = func.__name__[5:]
        def _incr(counter, num):
            salt.utils.process.appendproctitle("test_{}".format(name))
            for _ in range(0, num):
                counter.value += 1
        attrname = "incr_" + name
        setattr(self, attrname, _incr)
        self.addCleanup(delattr, self, attrname)
    return wrapper
def spin(func):
    """
    Spin indefinitely
    """
    @functools.wraps(func)
    def wrapper(self):
        name = func.__name__[5:]
        def _spin():
            salt.utils.process.appendproctitle("test_{}".format(name))
            while True:
                time.sleep(1)
        attrname = "spin_" + name
        setattr(self, attrname, _spin)
        self.addCleanup(delattr, self, attrname)
    return wrapper
class TestProcessManager(TestCase):
    @spin
    @pytest.mark.slow_test
    def test_basic(self):
        """
        Make sure that the process is alive 2s later
        """
        process_manager = salt.utils.process.ProcessManager()
        self.addCleanup(process_manager.terminate)
        process_manager.add_process(self.spin_basic)
        initial_pid = next(iter(process_manager._process_map.keys()))
        time.sleep(2)
        process_manager.check_children()
        assert initial_pid == next(iter(process_manager._process_map.keys()))
    @spin
    def test_kill(self):
        process_manager = salt.utils.process.ProcessManager()
        self.addCleanup(process_manager.terminate)
        process_manager.add_process(self.spin_kill)
        initial_pid = next(iter(process_manager._process_map.keys()))
        if salt.utils.platform.is_windows():
            os.kill(initial_pid, signal.SIGTERM)
        else:
            os.kill(initial_pid, signal.SIGKILL)
        time.sleep(0.1)
        process_manager.check_children()
        assert initial_pid != next(iter(process_manager._process_map.keys()))
    @die
    def test_restarting(self):
        """
        Make sure that the process is alive 2s later
        """
        process_manager = salt.utils.process.ProcessManager()
        self.addCleanup(process_manager.terminate)
        process_manager.add_process(self.die_restarting)
        initial_pid = next(iter(process_manager._process_map.keys()))
        time.sleep(2)
        process_manager.check_children()
        assert initial_pid != next(iter(process_manager._process_map.keys()))
    @incr
    def test_counter(self):
        counter = multiprocessing.Value("i", 0)
        process_manager = salt.utils.process.ProcessManager()
        self.addCleanup(process_manager.terminate)
        process_manager.add_process(self.incr_counter, args=(counter, 2))
        time.sleep(1)
        process_manager.check_children()
        time.sleep(1)
        assert counter.value == 4
class TestThreadPool(TestCase):
    @pytest.mark.slow_test
    def test_basic(self):
        """
        Make sure the threadpool can do things
        """
        def incr_counter(counter):
            counter.value += 1
        counter = multiprocessing.Value("i", 0)
        pool = salt.utils.process.ThreadPool()
        sent = pool.fire_async(incr_counter, args=(counter,))
        self.assertTrue(sent)
        time.sleep(1)  # Sleep to let the threads do things
        self.assertEqual(counter.value, 1)
        self.assertEqual(pool._job_queue.qsize(), 0)
    @pytest.mark.slow_test
    def test_full_queue(self):
        """
        Make sure that a full threadpool acts as we expect
        """
        def incr_counter(counter):
            counter.value += 1
        counter = multiprocessing.Value("i", 0)
        pool = salt.utils.process.ThreadPool(0, 1)
        sent = pool.fire_async(incr_counter, args=(counter,))
        self.assertTrue(sent)
        sent = pool.fire_async(incr_counter, args=(counter,))
        self.assertFalse(sent)
        time.sleep(1)  # Sleep to let the threads do things
        self.assertEqual(counter.value, 0)
        self.assertEqual(pool._job_queue.qsize(), 1)
class TestProcess(TestCase):
    def test_daemonize_if(self):
        with patch("sys.argv", ["salt-call"]):
            ret = salt.utils.process.daemonize_if({})
            self.assertEqual(None, ret)
        ret = salt.utils.process.daemonize_if({"multiprocessing": False})
        self.assertEqual(None, ret)
        with patch("sys.platform", "win"):
            ret = salt.utils.process.daemonize_if({})
            self.assertEqual(None, ret)
        with patch("salt.utils.process.daemonize"), patch("sys.platform", "linux2"):
            salt.utils.process.daemonize_if({})
            self.assertTrue(salt.utils.process.daemonize.called)
class TestProcessCallbacks(TestCase):
    @staticmethod
    def process_target(evt):
        evt.set()
    def test_callbacks(self):
        "Validate Process call after fork and finalize methods"
        teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
        log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
        with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
            evt = multiprocessing.Event()
            proc = salt.utils.process.Process(target=self.process_target, args=(evt,))
            proc.run()
            assert evt.is_set()
        mb.assert_called()
        ma.assert_called()
    def test_callbacks_called_when_run_overridden(self):
        "Validate Process sub classes call after fork and finalize methods when run is overridden"
        class MyProcess(salt.utils.process.Process):
            def __init__(self):
                super().__init__()
                self.evt = multiprocessing.Event()
            def run(self):
                self.evt.set()
        teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
        log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
        with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
            proc = MyProcess()
            proc.run()
            assert proc.evt.is_set()
        ma.assert_called()
        mb.assert_called()
@skipIf(not HAS_PSUTIL, "Missing psutil")
class TestSignalHandlingProcess(TestCase):
    @classmethod
    def Process(cls, pid):
        raise psutil.NoSuchProcess(pid)
    @classmethod
    def target(cls):
        os.kill(os.getpid(), signal.SIGTERM)
    @classmethod
    def children(cls, *args, **kwargs):
        raise psutil.NoSuchProcess(1)
    def test_process_does_not_exist(self):
        try:
            with patch("psutil.Process", self.Process):
                proc = salt.utils.process.SignalHandlingProcess(target=self.target)
                proc.start()
        except psutil.NoSuchProcess:
            assert False, "psutil.NoSuchProcess raised"
    def test_process_children_do_not_exist(self):
        try:
            with patch("psutil.Process.children", self.children):
                proc = salt.utils.process.SignalHandlingProcess(target=self.target)
                proc.start()
        except psutil.NoSuchProcess:
            assert False, "psutil.NoSuchProcess raised"
    @staticmethod
    def run_forever_sub_target(evt):
        "Used by run_forever_target to create a sub-process"
        while not evt.is_set():
            time.sleep(1)
    @staticmethod
    def run_forever_target(sub_target, evt):
        "A target that will run forever or until an event is set"
        p = multiprocessing.Process(target=sub_target, args=(evt,))
        p.start()
        p.join()
    @staticmethod
    def kill_target_sub_proc():
        pid = os.fork()
        if pid == 0:
            return
        pid = os.fork()
        if pid == 0:
            return
        time.sleep(0.1)
        try:
            os.kill(os.getpid(), signal.SIGINT)
        except KeyboardInterrupt:
            pass
    @skipIf(sys.platform.startswith("win"), "No os.fork on Windows")
    @pytest.mark.slow_test
    def test_signal_processing_regression_test(self):
        evt = multiprocessing.Event()
        sh_proc = salt.utils.process.SignalHandlingProcess(
            target=self.run_forever_target, args=(self.run_forever_sub_target, evt)
        )
        sh_proc.start()
        proc = multiprocessing.Process(target=self.kill_target_sub_proc)
        proc.start()
        proc.join()
        try:
            assert sh_proc.is_alive()
        finally:
            evt.set()
            sh_proc.join()
    @staticmethod
    def no_op_target():
        pass
    @staticmethod
    def pid_setting_target(sub_target, val, evt):
        val.value = os.getpid()
        p = multiprocessing.Process(target=sub_target, args=(evt,))
        p.start()
        p.join()
    @skipIf(sys.platform.startswith("win"), "Required signals not supported on windows")
    @pytest.mark.slow_test
    def test_signal_processing_handle_signals_called(self):
        "Validate SignalHandlingProcess handles signals"
        evt = multiprocessing.Event()
        val = multiprocessing.Value("i", 0)
        proc = salt.utils.process.SignalHandlingProcess(
            target=self.pid_setting_target,
            args=(self.run_forever_sub_target, val, evt),
        )
        proc.start()
        proc2 = multiprocessing.Process(
            target=self.run_forever_target,
            args=(self.run_forever_sub_target, evt),
        )
        proc2.start()
        while not val.value:
            time.sleep(0.3)
        assert not proc.signal_handled()
        os.kill(val.value, signal.SIGTERM)
        start = time.time()
        while time.time() - start &lt; 10:
            if proc.signal_handled():
                break
            time.sleep(0.3)
        try:
            assert proc.signal_handled()
            proc.join(1)
            assert proc2.is_alive()
        finally:
            evt.set()
            proc2.join(30)
            proc.join(30)
class TestSignalHandlingProcessCallbacks(TestCase):
    @staticmethod
    def process_target(evt):
        evt.set()
    def test_callbacks(self):
        "Validate SignalHandlingProcess call after fork and finalize methods"
        teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
        log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
        sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
        evt = multiprocessing.Event()
        with patch(sig_to_mock):
            with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
                sh_proc = salt.utils.process.SignalHandlingProcess(
                    target=self.process_target, args=(evt,)
                )
                sh_proc.run()
                assert evt.is_set()
        ma.assert_called()
        mb.assert_called()
    def test_callbacks_called_when_run_overridden(self):
        "Validate SignalHandlingProcess sub classes call after fork and finalize methods when run is overridden"
        class MyProcess(salt.utils.process.SignalHandlingProcess):
            def __init__(self):
                super().__init__()
                self.evt = multiprocessing.Event()
            def run(self):
                self.evt.set()
        teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
        log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
        sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
        with patch(sig_to_mock):
            with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
                sh_proc = MyProcess()
                sh_proc.run()
                assert sh_proc.evt.is_set()
        ma.assert_called()
        mb.assert_called()
class TestDup2(TestCase):
    def test_dup2_no_fileno(self):
        "The dup2 method does not fail on streams without fileno support"
        f1 = io.StringIO("some initial text data")
        f2 = io.StringIO("some initial other text data")
        with self.assertRaises(io.UnsupportedOperation):
            f1.fileno()
        with patch("os.dup2") as dup_mock:
            try:
                salt.utils.process.dup2(f1, f2)
            except io.UnsupportedOperation:
                assert False, "io.UnsupportedOperation was raised"
        assert not dup_mock.called
def null_target():
    pass
def event_target(event):
    while True:
        if event.wait(5):
            break
class TestProcessList(TestCase):
    @staticmethod
    def wait_for_proc(proc, timeout=10):
        start = time.time()
        while proc.is_alive():
            if time.time() - start &gt; timeout:
                raise Exception("Process did not finishe before timeout")
            time.sleep(0.3)
    @pytest.mark.slow_test
    def test_process_list_process(self):
        plist = salt.utils.process.SubprocessList()
        proc = multiprocessing.Process(target=null_target)
        proc.start()
        plist.add(proc)
        assert proc in plist.processes
        self.wait_for_proc(proc)
        assert not proc.is_alive()
        plist.cleanup()
        assert proc not in plist.processes
    def test_process_list_thread(self):
        plist = salt.utils.process.SubprocessList()
        thread = threading.Thread(target=null_target)
        thread.start()
        plist.add(thread)
        assert thread in plist.processes
        self.wait_for_proc(thread)
        assert not thread.is_alive()
        plist.cleanup()
        assert thread not in plist.processes
    @pytest.mark.slow_test
    def test_process_list_cleanup(self):
        plist = salt.utils.process.SubprocessList()
        event = multiprocessing.Event()
        proc = multiprocessing.Process(target=event_target, args=[event])
        proc.start()
        plist.add(proc)
        assert proc in plist.processes
        plist.cleanup()
        event.set()
        assert proc in plist.processes
        self.wait_for_proc(proc)
        assert not proc.is_alive()
        plist.cleanup()
        assert proc not in plist.processes
class TestDeprecatedClassNames(TestCase):
    @staticmethod
    def process_target():
        pass
    @staticmethod
    def patched_warn_until_date(current_date):
        def _patched_warn_until_date(
            date,
            message,
            category=DeprecationWarning,
            stacklevel=None,
            _current_date=current_date,
            _dont_call_warnings=False,
        ):
            stacklevel = 4
            return warn_until_date(
                date,
                message,
                category=category,
                stacklevel=stacklevel,
                _current_date=_current_date,
                _dont_call_warnings=_dont_call_warnings,
            )
        return _patched_warn_until_date
    def test_multiprocessing_process_warning(self):
        warnings.filterwarnings("always", "", DeprecationWarning, __name__)
        fake_utcnow = datetime.date(2021, 1, 1)
        proc = None
        try:
            with patch(
                "salt.utils.versions.warn_until_date",
                self.patched_warn_until_date(fake_utcnow),
            ):
                with warnings.catch_warnings(record=True) as recorded_warnings:
                    proc = salt.utils.process.MultiprocessingProcess(
                        target=self.process_target
                    )
                    self.assertEqual(
                        "Please stop using 'salt.utils.process.MultiprocessingProcess' "
                        "and instead use 'salt.utils.process.Process'. "
                        "'salt.utils.process.MultiprocessingProcess' will go away "
                        "after 2022-01-01.",
                        str(recorded_warnings[0].message),
                    )
        finally:
            if proc is not None:
                del proc
    def test_multiprocessing_process_runtime_error(self):
        fake_utcnow = datetime.date(2022, 1, 1)
        proc = None
        try:
            with patch(
                "salt.utils.versions.warn_until_date",
                self.patched_warn_until_date(fake_utcnow),
            ):
                with self.assertRaisesRegex(
                    RuntimeError,
                    r"Please stop using 'salt.utils.process.MultiprocessingProcess' "
                    r"and instead use 'salt.utils.process.Process'. "
                    r"'salt.utils.process.MultiprocessingProcess' will go away "
                    r"after 2022-01-01. "
                    r"This warning\(now exception\) triggered on "
                    r"filename '(.*)test_process.py', line number ([\d]+), is "
                    r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
                    r"Please remove the warning.",
                ):
                    proc = salt.utils.process.MultiprocessingProcess(
                        target=self.process_target
                    )
        finally:
            if proc is not None:
                del proc
    def test_signal_handling_multiprocessing_process_warning(self):
        warnings.filterwarnings("always", "", DeprecationWarning, __name__)
        fake_utcnow = datetime.date(2021, 1, 1)
        proc = None
        try:
            with patch(
                "salt.utils.versions.warn_until_date",
                self.patched_warn_until_date(fake_utcnow),
            ):
                with warnings.catch_warnings(record=True) as recorded_warnings:
                    proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
                        target=self.process_target
                    )
                    self.assertEqual(
                        "Please stop using"
                        " 'salt.utils.process.SignalHandlingMultiprocessingProcess' and"
                        " instead use 'salt.utils.process.SignalHandlingProcess'."
                        " 'salt.utils.process.SignalHandlingMultiprocessingProcess'"
                        " will go away after 2022-01-01.",
                        str(recorded_warnings[0].message),
                    )
        finally:
            if proc is not None:
                del proc
    def test_signal_handling_multiprocessing_process_runtime_error(self):
        fake_utcnow = datetime.date(2022, 1, 1)
        proc = None
        try:
            with patch(
                "salt.utils.versions.warn_until_date",
                self.patched_warn_until_date(fake_utcnow),
            ):
                with self.assertRaisesRegex(
                    RuntimeError,
                    r"Please stop using"
                    r" 'salt.utils.process.SignalHandlingMultiprocessingProcess' "
                    r"and instead use 'salt.utils.process.SignalHandlingProcess'. "
                    r"'salt.utils.process.SignalHandlingMultiprocessingProcess' will go"
                    r" away "
                    r"after 2022-01-01. "
                    r"This warning\(now exception\) triggered on "
                    r"filename '(.*)test_process.py', line number ([\d]+), is "
                    r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
                    r"Please remove the warning.",
                ):
                    proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
                        target=self.process_target
                    )
        finally:
            if proc is not None:
                del proc
class CMORProcessHelper:
    def __init__(self, file_name):
        self._lock = threading.Lock()
        self._running = True
        self._queue = multiprocessing.Queue()
        self._ret_queue = multiprocessing.Queue()
        self._process = multiprocessing.Process(
            target=self.test_process,
            args=(file_name, self._queue, self._ret_queue),
            daemon=True,
        )
        self._process.start()
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.stop()
    def claim(self):
        try:
            self._lock.acquire()
            if self._running:
                self._queue.put("claim")
                return self._ret_queue.get(timeout=10)
        finally:
            self._lock.release()
    def stop(self):
        try:
            self._lock.acquire()
            if self._running:
                self._running = False
                self._queue.put("stop")
                self._process.join(timeout=10)
                self._queue.close()
                self._ret_queue.close()
        finally:
            self._lock.release()
    @property
    def pid(self):
        return self._process.pid
    @staticmethod
    def test_process(file_name, queue, ret_queue):
        while True:
            action = queue.get()
            if action == "claim":
                ret_queue.put(
                    salt.utils.process.claim_mantle_of_responsibility(file_name)
                )
            elif action == "stop":
                return
@skipIf(not HAS_PSUTIL, "Missing psutil")
class TestGetProcessInfo(TestCase):
    def setUp(self):
        handle, self.cmor_test_file_path = tempfile.mkstemp()
        os.close(handle)
        self.addCleanup(os.unlink, self.cmor_test_file_path)
    def test_this_process(self):
        this_process_info = salt.utils.process.get_process_info()
        self.assertEqual(
            this_process_info, salt.utils.process.get_process_info(os.getpid())
        )
        self.assertIsNotNone(this_process_info)
            self.assertIn(key, this_process_info)
        raw_process_info = psutil<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Process(os.getpid())
        self.assertEqual(this_process_info["pid"], os.getpid())
        self.assertEqual(this_process_info["name"], raw_process_info.name(</b></font>))
        self.assertEqual(
            this_process_info["start_time"], raw_process_info.create_time()
        )
    def test_random_processes(self):
        for _ in range(3):
            with CMORProcessHelper(self.cmor_test_file_path) as p1:
                pid = p1.pid
                self.assertIsInstance(salt.utils.process.get_process_info(pid), dict)
            self.assertIsNone(salt.utils.process.get_process_info(pid))
@skipIf(not HAS_PSUTIL, "Missing psutil")
class TestClaimMantleOfResponsibility(TestCase):
    def setUp(self):
        handle, self.cmor_test_file_path = tempfile.mkstemp()
        os.close(handle)
        self.addCleanup(os.unlink, self.cmor_test_file_path)
    def test_simple_claim_no_psutil(self):
        salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
    def test_simple_claim(self):
        for _ in range(5):
            self.assertTrue(
                salt.utils.process.claim_mantle_of_responsibility(
                    self.cmor_test_file_path
                )
            )
    def test_multiple_processes(self):
        with CMORProcessHelper(self.cmor_test_file_path) as p1:
            self.assertTrue(p1.claim())
            self.assertFalse(
                salt.utils.process.claim_mantle_of_responsibility(
                    self.cmor_test_file_path
                )
            )
            with CMORProcessHelper(self.cmor_test_file_path) as p2:
                for _ in range(3):
                    self.assertFalse(p2.claim())
            self.assertTrue(p1.claim())
        with CMORProcessHelper(self.cmor_test_file_path) as p1:
            self.assertTrue(p1.claim())
            self.assertFalse(
                salt.utils.process.claim_mantle_of_responsibility(
                    self.cmor_test_file_path
                )
            )
        self.assertTrue(
            salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
        )
@skipIf(not HAS_PSUTIL, "Missing psutil")
class TestCheckMantleOfResponsibility(TestCase):
    def setUp(self):
        handle, self.cmor_test_file_path = tempfile.mkstemp()
        os.close(handle)
        self.addCleanup(os.unlink, self.cmor_test_file_path)
    def test_simple_claim_no_psutil(self):
        self.assertIsNone(
            salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
        )
    def test_simple_claim(self):
        self.assertIsNone(
            salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
        )
        salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
        pid = salt.utils.process.get_process_info()["pid"]
        self.assertEqual(
            pid,
            salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path),
        )
    def test_multiple_processes(self):
        self.assertIsNone(
            salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
        )
        with CMORProcessHelper(self.cmor_test_file_path) as p1:
            self.assertTrue(p1.claim())
            random_pid = salt.utils.process.check_mantle_of_responsibility(
                self.cmor_test_file_path
            )
            self.assertIsInstance(random_pid, int)
            with CMORProcessHelper(self.cmor_test_file_path) as p2:
                for _ in range(3):
                    self.assertFalse(p2.claim())
                self.assertEqual(
                    random_pid,
                    salt.utils.process.check_mantle_of_responsibility(
                        self.cmor_test_file_path
                    ),
                )
        self.assertIsNone(
            salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
        )
        salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
        pid = salt.utils.process.get_process_info()["pid"]
        self.assertEqual(
            pid,
            salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path),
        )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
