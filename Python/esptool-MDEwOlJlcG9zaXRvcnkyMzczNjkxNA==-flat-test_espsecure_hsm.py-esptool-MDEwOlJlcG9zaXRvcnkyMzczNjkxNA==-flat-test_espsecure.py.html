
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espsecure_hsm.py</h3>
            <pre><code>1  import configparser
2  import os
3  import os.path
4  import sys
5  import tempfile
6  from collections import namedtuple
7  from conftest import need_to_install_package_err
8  try:
9      import espsecure
10      import pkcs11
11  except ImportError:
12      need_to_install_package_err()
13  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
14  TOKEN_PIN = "1234"
15  TOKEN_PIN_SO = "123456"
16  class EspSecureHSMTestCase:
17      @classmethod
18      def setup_class(self):
19          self.cleanup_files = []  # keep a list of files _open()ed by each test case
20      @classmethod
21      def teardown_class(self):
22          for f in self.cleanup_files:
23              f.close()
24      def _open(self, image_file):
25          f = open(os.path.join(TEST_DIR, "secure_images", image_file), "rb")
26          self.cleanup_files.append(f)
27          return f
28      def get_pkcs11lib(self):
29          if sys.maxsize > 2**32:
30              WINDOWS_SOFTHSM = "c:/SoftHSM2/lib/softhsm2-x64.dll"
31          else:
32              WINDOWS_SOFTHSM = "c:/SoftHSM2/lib/softhsm2.dll"
33          LIBS = [
34              "/usr/local/lib/softhsm/libsofthsm2.so",  # macOS or local build
35              "/usr/lib/softhsm/libsofthsm2.so",  # Debian
36              "/usr/lib/x86_64-linux-gnu/softhsm/libsofthsm2.so",  # Ubuntu 16.04
37              WINDOWS_SOFTHSM,  # Windows
38          ]
39          for lib in LIBS:
40              if os.path.isfile(lib):
41                  print("Using lib:", lib)
42                  return lib
43          return None
44      def softhsm_setup_token(self, filename, token_label):
45          self.pkcs11_lib = self.get_pkcs11lib()
46          if self.pkcs11_lib is None:
47              print("PKCS11 lib does not exist")
48              sys.exit(-1)
49          lib = pkcs11.lib(self.pkcs11_lib)
50          token = lib.get_token(token_label=token_label)
51          slot = token.slot.slot_id
52          session = token.open(rw=True, user_pin=TOKEN_PIN)
53          keyID = (0x0,)
54          label = "Private Key for Digital Signature"
55          label_pubkey = "Public Key for Digital Signature"
56          pubTemplate = [
57              (pkcs11.Attribute.CLASS, pkcs11.constants.ObjectClass.PUBLIC_KEY),
58              (pkcs11.Attribute.TOKEN, True),
59              (pkcs11.Attribute.PRIVATE, False),
60              (pkcs11.Attribute.MODULUS_BITS, 0x0C00),
61              (pkcs11.Attribute.PUBLIC_EXPONENT, (0x01, 0x00, 0x01)),
62              (pkcs11.Attribute.ENCRYPT, True),
63              (pkcs11.Attribute.VERIFY, True),
64              (pkcs11.Attribute.VERIFY_RECOVER, True),
65              (pkcs11.Attribute.WRAP, True),
66              (pkcs11.Attribute.LABEL, label_pubkey),
67              (pkcs11.Attribute.ID, keyID),
68          ]
69          privTemplate = [
70              (pkcs11.Attribute.CLASS, pkcs11.constants.ObjectClass.PRIVATE_KEY),
71              (pkcs11.Attribute.TOKEN, True),
72              (pkcs11.Attribute.PRIVATE, True),
73              (pkcs11.Attribute.DECRYPT, True),
74              (pkcs11.Attribute.SIGN, True),
75              (pkcs11.Attribute.SENSITIVE, True),
76              (pkcs11.Attribute.SIGN_RECOVER, True),
77              (pkcs11.Attribute.LABEL, label),
78              (pkcs11.Attribute.UNWRAP, True),
79              (pkcs11.Attribute.ID, keyID),
80          ]
81          session.generate_keypair(
82              pkcs11.KeyType.RSA,
83              3072,
84              private_template=privTemplate,
85              public_template=pubTemplate,
86          )
87          configfile = os.path.join(TEST_DIR, "secure_images", filename)
88          config = configparser.ConfigParser()
89          section = "hsm_config"
90          config.add_section(section)
91          config.set(section, "pkcs11_lib", self.pkcs11_lib)
92          config.set(section, "credentials", TOKEN_PIN)
93          config.set(section, "slot", str(slot))
94          config.set(section, "label", label)
95          config.set(section, "label_pubkey", label_pubkey)
96          with open(configfile, "w") as c:
97              config.write(c)
98          session.close()
99  class TestSigning(EspSecureHSMTestCase):
100      VerifyArgs = namedtuple(
101          "verify_signature_args", ["version", "hsm", "hsm_config", "keyfile", "datafile"]
102      )
103      SignArgs = namedtuple(
104          "sign_data_args",
105          [
106              "version",
107              "keyfile",
108              "output",
109              "append_signatures",
110              "hsm",
111              "hsm_config",
112              "pub_key",
113              "signature",
114              "datafile",
115          ],
116      )
117      def test_sign_v2_hsm(self):
118          self.softhsm_setup_token("softhsm_v2.ini", "softhsm-test-token")
119          with tempfile.NamedTemporaryFile() as output_file:
120              args = self.SignArgs(
121                  "2",
122                  None,
123                  output_file.name,
124                  False,
125                  True,
126                  os.path.join(TEST_DIR, "secure_images", "softhsm_v2.ini"),
127                  None,
128                  None,
129                  self._open("bootloader_unsigned_v2.bin"),
130              )
131              espsecure.sign_data(args)
132              args = self.VerifyArgs(
133                  "2",
134                  True,
135                  os.path.join(TEST_DIR, "secure_images", "softhsm_v2.ini"),
136                  None,
137                  output_file,
138              )
139              espsecure.verify_signature(args)
140      def test_sign_v2_hsm_append_signatures_multiple_steps(self):
141          self.softhsm_setup_token("softhsm_v2_1.ini", "softhsm-test-token-1")
142          with tempfile.NamedTemporaryFile() as output_file1:
<span onclick='openModal()' class='match'>143              args = self.SignArgs(
144                  "2",
145                  None,
146                  output_file1.name,
147                  True,
</span>148                  True,
149                  os.path.join(TEST_DIR, "secure_images", "softhsm_v2_1.ini"),
150                  None,
151                  None,
152                  self._open("bootloader_unsigned_v2.bin"),
153              )
154              espsecure.sign_data(args)
155              self.softhsm_setup_token("softhsm_v2_2.ini", "softhsm-test-token-2")
156              with tempfile.NamedTemporaryFile() as output_file2:
157                  args = self.SignArgs(
158                      "2",
159                      None,
160                      output_file2.name,
161                      True,
162                      True,
163                      os.path.join(TEST_DIR, "secure_images", "softhsm_v2_2.ini"),
164                      None,
165                      None,
166                      self._open(output_file1.name),
167                  )
168                  espsecure.sign_data(args)
169                  self.softhsm_setup_token("softhsm_v2_3.ini", "softhsm-test-token-3")
170                  with tempfile.NamedTemporaryFile() as output_file3:
171                      args = self.SignArgs(
172                          "2",
173                          None,
174                          output_file3.name,
175                          True,
176                          True,
177                          os.path.join(TEST_DIR, "secure_images", "softhsm_v2_3.ini"),
178                          None,
179                          None,
180                          self._open(output_file2.name),
181                      )
182                      espsecure.sign_data(args)
183                      args = self.VerifyArgs(
184                          "2",
185                          True,
186                          os.path.join(TEST_DIR, "secure_images", "softhsm_v2_1.ini"),
187                          None,
188                          output_file3,
189                      )
190                      espsecure.verify_signature(args)
191                      output_file3.seek(0)
192                      args = self.VerifyArgs(
193                          "2",
194                          True,
195                          os.path.join(TEST_DIR, "secure_images", "softhsm_v2_2.ini"),
196                          None,
197                          output_file3,
198                      )
199                      espsecure.verify_signature(args)
200                      output_file3.seek(0)
201                      args = self.VerifyArgs(
202                          "2",
203                          True,
204                          os.path.join(TEST_DIR, "secure_images", "softhsm_v2_3.ini"),
205                          None,
206                          output_file3,
207                      )
208                      espsecure.verify_signature(args)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espsecure.py</h3>
            <pre><code>1  import binascii
2  import io
3  import os
4  import os.path
5  import subprocess
6  import sys
7  import tempfile
8  from collections import namedtuple
9  from conftest import need_to_install_package_err
10  import pytest
11  try:
12      import esptool
13      import espsecure
14  except ImportError:
15      need_to_install_package_err()
16  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
17  @pytest.mark.host_test
18  class EspSecureTestCase:
19      def run_espsecure(self, args):
20          cmd = [sys.executable, "-m", "espsecure"] + args.split(" ")
21          print("\nExecuting {}...".format(" ".join(cmd)))
22          try:
23              output = subprocess.check_output(
24                  [str(s) for s in cmd], cwd=TEST_DIR, stderr=subprocess.STDOUT
25              )
26              output = output.decode("utf-8")
27              print(output)
28              return output
29          except subprocess.CalledProcessError as e:
30              print(e.output.decode("utf-8"))
31              raise e
32      @classmethod
33      def setup_class(self):
34          self.cleanup_files = []  # keep a list of files _open()ed by each test case
35      @classmethod
36      def teardown_class(self):
37          for f in self.cleanup_files:
38              f.close()
39      def _open(self, image_file):
40          f = open(os.path.join(TEST_DIR, "secure_images", image_file), "rb")
41          self.cleanup_files.append(f)
42          return f
43  class TestESP32SecureBootloader(EspSecureTestCase):
44      def test_digest_bootloader(self):
45          DBArgs = namedtuple(
46              "digest_bootloader_args", ["keyfile", "output", "iv", "image"]
47          )
48          try:
49              output_file = tempfile.NamedTemporaryFile(delete=False)
50              output_file.close()
51              args = DBArgs(
52                  self._open("256bit_key.bin"),
53                  output_file.name,
54                  self._open("256bit_iv.bin"),
55                  self._open("bootloader.bin"),
56              )
57              espsecure.digest_secure_bootloader(args)
58              with open(output_file.name, "rb") as of:
59                  with self._open("bootloader_digested.bin") as ef:
60                      assert ef.read() == of.read()
61          finally:
62              os.unlink(output_file.name)
63      def test_digest_rsa_public_key(self):
64          DigestRSAArgs = namedtuple("digest_rsa_public_key_args", ["keyfile", "output"])
65          try:
66              output_file = tempfile.NamedTemporaryFile(delete=False)
67              output_file.close()
68              args = DigestRSAArgs(
69                  self._open("rsa_secure_boot_signing_key.pem"), output_file.name
70              )
71              espsecure.digest_rsa_public_key(args)
72              with open(output_file.name, "rb") as of:
73                  with self._open("rsa_public_key_digest.bin") as ef:
74                      assert ef.read() == of.read()
75          finally:
76              os.unlink(output_file.name)
77  class TestSigning(EspSecureTestCase):
78      VerifyArgs = namedtuple(
79          "verify_signature_args", ["version", "hsm", "hsm_config", "keyfile", "datafile"]
80      )
81      SignArgs = namedtuple(
82          "sign_data_args",
83          [
84              "version",
85              "keyfile",
86              "output",
87              "append_signatures",
88              "hsm",
89              "hsm_config",
90              "pub_key",
91              "signature",
92              "datafile",
93          ],
94      )
95      ExtractKeyArgs = namedtuple(
96          "extract_public_key_args", ["version", "keyfile", "public_keyfile"]
97      )
98      GenerateKeyArgs = namedtuple("generate_key_args", ["version", "scheme", "keyfile"])
99      def test_key_generation_v1(self):
100          with tempfile.TemporaryDirectory() as keydir:
101              keyfile_name = os.path.join(keydir, "key.pem")
102              self.run_espsecure(f"generate_signing_key --version 1 {keyfile_name}")
103      def test_key_generation_v2(self):
104          with tempfile.TemporaryDirectory() as keydir:
105              keyfile_name = os.path.join(keydir, "key.pem")
106              self.run_espsecure(f"generate_signing_key --version 2 {keyfile_name}")
107      def _test_sign_v1_data(self, key_name):
108          try:
109              output_file = tempfile.NamedTemporaryFile(delete=False)
110              output_file.close()
111              args = self.SignArgs(
112                  "1",
113                  [self._open(key_name)],
114                  output_file.name,
115                  False,
116                  False,
117                  None,
118                  None,
119                  None,
120                  self._open("bootloader.bin"),
121              )
122              espsecure.sign_data(args)
123              with open(output_file.name, "rb") as of:
124                  with self._open("bootloader_signed.bin") as ef:
125                      assert ef.read() == of.read()
126          finally:
127              os.unlink(output_file.name)
128      def test_sign_v1_data(self):
129          self._test_sign_v1_data("ecdsa_secure_boot_signing_key.pem")
130      def test_sign_v1_data_pkcs8(self):
131          self._test_sign_v1_data("ecdsa_secure_boot_signing_key_pkcs8.pem")
132      def test_sign_v1_with_pre_calculated_signature(self):
133          signing_pubkey = "ecdsa_secure_boot_signing_pubkey.pem"
134          pre_calculated_signature = "pre_calculated_bootloader_signature.bin"
135          try:
136              output_file = tempfile.NamedTemporaryFile(delete=False)
137              args = self.SignArgs(
138                  "1",
139                  None,
140                  output_file.name,
141                  False,
142                  False,
143                  None,
144                  [self._open(signing_pubkey)],
145                  [self._open(pre_calculated_signature)],
146                  self._open("bootloader.bin"),
147              )
148              espsecure.sign_data(args)
149              args = self.VerifyArgs(
150                  "1", False, None, self._open(signing_pubkey), output_file
151              )
152              espsecure.verify_signature(args)
153          finally:
154              output_file.close()
155              os.unlink(output_file.name)
156      def test_sign_v2_data(self):
157          signing_keys = [
158              "rsa_secure_boot_signing_key.pem",
159              "ecdsa192_secure_boot_signing_key.pem",
160              "ecdsa_secure_boot_signing_key.pem",
161          ]
162          for key in signing_keys:
163              try:
164                  output_file = tempfile.NamedTemporaryFile(delete=False)
165                  args = self.SignArgs(
166                      "2",
167                      [self._open(key)],
168                      output_file.name,
169                      False,
170                      False,
171                      None,
172                      None,
173                      None,
174                      self._open("bootloader_unsigned_v2.bin"),
175                  )
176                  espsecure.sign_data(args)
177                  args = self.VerifyArgs("2", False, None, self._open(key), output_file)
178                  espsecure.verify_signature(args)
179              finally:
180                  output_file.close()
181                  os.unlink(output_file.name)
182      def test_sign_v2_multiple_keys(self):
183          try:
184              output_file = tempfile.NamedTemporaryFile(delete=False)
185              args = self.SignArgs(
186                  "2",
187                  [
188                      self._open("rsa_secure_boot_signing_key.pem"),
189                      self._open("rsa_secure_boot_signing_key2.pem"),
190                      self._open("rsa_secure_boot_signing_key3.pem"),
191                  ],
192                  output_file.name,
193                  False,
194                  False,
195                  None,
196                  None,
197                  None,
198                  self._open("bootloader_unsigned_v2.bin"),
199              )
200              espsecure.sign_data(args)
201              args = self.VerifyArgs(
202                  "2",
203                  False,
204                  None,
205                  self._open("rsa_secure_boot_signing_key3.pem"),
206                  output_file,
207              )
208              espsecure.verify_signature(args)
209              output_file.seek(0)
210              args = self.VerifyArgs(
211                  "2",
212                  False,
213                  None,
214                  self._open("rsa_secure_boot_signing_key2.pem"),
215                  output_file,
216              )
217              espsecure.verify_signature(args)
218              output_file.seek(0)
219              args = self.VerifyArgs(
220                  "2",
221                  False,
222                  None,
223                  self._open("rsa_secure_boot_signing_key.pem"),
224                  output_file,
225              )
226              espsecure.verify_signature(args)
227          finally:
228              output_file.close()
229              os.unlink(output_file.name)
230      def test_sign_v2_append_signatures(self):
231          try:
232              output_file = tempfile.NamedTemporaryFile(delete=False)
233              args = self.SignArgs(
234                  "2",
235                  [
236                      self._open("rsa_secure_boot_signing_key2.pem"),
237                      self._open("rsa_secure_boot_signing_key3.pem"),
238                  ],
239                  output_file.name,
240                  True,
241                  False,
242                  None,
243                  None,
244                  None,
245                  self._open("bootloader_signed_v2.bin"),
246              )
247              espsecure.sign_data(args)
248              args = self.VerifyArgs(
249                  "2",
250                  False,
251                  None,
252                  self._open("rsa_secure_boot_signing_key.pem"),
253                  output_file,
254              )
255              espsecure.verify_signature(args)
256              output_file.seek(0)
257              args = self.VerifyArgs(
258                  "2",
259                  False,
260                  None,
261                  self._open("rsa_secure_boot_signing_key2.pem"),
262                  output_file,
263              )
264              espsecure.verify_signature(args)
265              output_file.seek(0)
266              args = self.VerifyArgs(
267                  "2",
268                  False,
269                  None,
270                  self._open("rsa_secure_boot_signing_key3.pem"),
271                  output_file,
272              )
273              espsecure.verify_signature(args)
274          finally:
275              output_file.close()
276              os.unlink(output_file.name)
277      def test_sign_v2_append_signatures_multiple_steps(self):
278          try:
279              output_file1 = tempfile.NamedTemporaryFile(delete=False)
280              output_file2 = tempfile.NamedTemporaryFile(delete=False)
281              args = self.SignArgs(
282                  "2",
283                  [self._open("rsa_secure_boot_signing_key2.pem")],
284                  output_file1.name,
285                  True,
286                  False,
287                  None,
288                  None,
289                  None,
290                  self._open("bootloader_signed_v2.bin"),
291              )
292              espsecure.sign_data(args)
293              args = self.SignArgs(
294                  "2",
295                  [self._open("rsa_secure_boot_signing_key3.pem")],
296                  output_file2.name,
297                  True,
298                  False,
299                  None,
300                  None,
301                  None,
302                  output_file1,
303              )
304              espsecure.sign_data(args)
305              args = self.VerifyArgs(
306                  "2",
307                  False,
308                  None,
309                  self._open("rsa_secure_boot_signing_key.pem"),
310                  output_file2,
311              )
312              espsecure.verify_signature(args)
313              output_file2.seek(0)
314              args = self.VerifyArgs(
315                  "2",
316                  False,
317                  None,
318                  self._open("rsa_secure_boot_signing_key2.pem"),
319                  output_file2,
320              )
321              espsecure.verify_signature(args)
322              output_file2.seek(0)
323              args = self.VerifyArgs(
324                  "2",
325                  False,
326                  None,
327                  self._open("rsa_secure_boot_signing_key3.pem"),
328                  output_file2,
329              )
330              espsecure.verify_signature(args)
331          finally:
332              output_file1.close()
333              os.unlink(output_file1.name)
334              output_file2.close()
335              os.unlink(output_file2.name)
336      def test_sign_v2_with_pre_calculated_signature(self):
337          signing_keys = [
338              "rsa_secure_boot_signing_pubkey.pem",
339              "ecdsa192_secure_boot_signing_pubkey.pem",
340              "ecdsa_secure_boot_signing_pubkey.pem",
341          ]
342          pre_calculated_signatures = [
343              "pre_calculated_bootloader_signature_rsa.bin",
344              "pre_calculated_bootloader_signature_ecdsa192.bin",
345              "pre_calculated_bootloader_signature_ecdsa256.bin",
346          ]
347          for pub_key, signature in zip(signing_keys, pre_calculated_signatures):
348              try:
349                  output_file = tempfile.NamedTemporaryFile(delete=False)
<span onclick='openModal()' class='match'>350                  args = self.SignArgs(
351                      "2",
352                      None,
353                      output_file.name,
354                      False,
</span>355                      False,
356                      None,
357                      [self._open(pub_key)],
358                      [self._open(signature)],
359                      self._open("bootloader_unsigned_v2.bin"),
360                  )
361                  espsecure.sign_data(args)
362                  args = self.VerifyArgs(
363                      "2", False, None, self._open(pub_key), output_file
364                  )
365                  espsecure.verify_signature(args)
366              finally:
367                  output_file.close()
368                  os.unlink(output_file.name)
369      def test_sign_v2_with_multiple_pre_calculated_signatures(self):
370          signing_pubkeys = [
371              "rsa_secure_boot_signing_pubkey.pem",
372              "rsa_secure_boot_signing_pubkey.pem",
373              "rsa_secure_boot_signing_pubkey.pem",
374          ]
375          pre_calculated_signatures = [
376              "pre_calculated_bootloader_signature_rsa.bin",
377              "pre_calculated_bootloader_signature_rsa.bin",
378              "pre_calculated_bootloader_signature_rsa.bin",
379          ]
380          try:
381              output_file = tempfile.NamedTemporaryFile(delete=False)
382              args = self.SignArgs(
383                  "2",
384                  None,
385                  output_file.name,
386                  False,
387                  False,
388                  None,
389                  [self._open(pub_key) for pub_key in signing_pubkeys],
390                  [self._open(signature) for signature in pre_calculated_signatures],
391                  self._open("bootloader_unsigned_v2.bin"),
392              )
393              espsecure.sign_data(args)
394              args = self.VerifyArgs(
395                  "2", False, None, self._open(signing_pubkeys[0]), output_file
396              )
397              espsecure.verify_signature(args)
398          finally:
399              output_file.close()
400              os.unlink(output_file.name)
401      def test_verify_signature_signing_key(self):
402          args = self.VerifyArgs(
403              "1",
404              False,
405              None,
406              self._open("ecdsa_secure_boot_signing_key.pem"),
407              self._open("bootloader_signed.bin"),
408          )
409          espsecure.verify_signature(args)
410          args = self.VerifyArgs(
411              "2",
412              False,
413              None,
414              self._open("rsa_secure_boot_signing_key.pem"),
415              self._open("bootloader_signed_v2.bin"),
416          )
417          espsecure.verify_signature(args)
418          args = self.VerifyArgs(
419              "2",
420              False,
421              None,
422              self._open("ecdsa_secure_boot_signing_key.pem"),
423              self._open("bootloader_signed_v2_ecdsa256.bin"),
424          )
425          espsecure.verify_signature(args)
426          args = self.VerifyArgs(
427              "2",
428              False,
429              None,
430              self._open("ecdsa192_secure_boot_signing_key.pem"),
431              self._open("bootloader_signed_v2_ecdsa192.bin"),
432          )
433          espsecure.verify_signature(args)
434          args = self.VerifyArgs(
435              "1",
436              False,
437              None,
438              self._open("ecdsa_secure_boot_signing_key2.pem"),
439              self._open("bootloader_signed.bin"),
440          )
441          with pytest.raises(esptool.FatalError) as cm:
442              espsecure.verify_signature(args)
443          assert "Signature is not valid" in str(cm.value)
444          args = self.VerifyArgs(
445              "2",
446              False,
447              None,
448              self._open("rsa_secure_boot_signing_key2.pem"),
449              self._open("bootloader_signed_v2.bin"),
450          )
451          with pytest.raises(esptool.FatalError) as cm:
452              espsecure.verify_signature(args)
453          assert "Signature could not be verified with the provided key." in str(cm.value)
454          args = self.VerifyArgs(
455              "2",
456              False,
457              None,
458              self._open("ecdsa_secure_boot_signing_key.pem"),
459              self._open("bootloader_signed.bin"),
460          )
461          with pytest.raises(esptool.FatalError) as cm:
462              espsecure.verify_signature(args)
463          assert "Invalid datafile" in str(cm.value)
464          args = self.VerifyArgs(
465              "2",
466              False,
467              None,
468              self._open("ecdsa_secure_boot_signing_key2.pem"),
469              self._open("bootloader_signed_v2_ecdsa256.bin"),
470          )
471          with pytest.raises(esptool.FatalError) as cm:
472              espsecure.verify_signature(args)
473          assert "Signature could not be verified with the provided key." in str(cm.value)
474          args = self.VerifyArgs(
475              "2",
476              False,
477              None,
478              self._open("ecdsa192_secure_boot_signing_key2.pem"),
479              self._open("bootloader_signed_v2_ecdsa192.bin"),
480          )
481          with pytest.raises(esptool.FatalError) as cm:
482              espsecure.verify_signature(args)
483          assert "Signature could not be verified with the provided key." in str(cm.value)
484          args = self.VerifyArgs(
485              "2",
486              False,
487              None,
488              self._open("rsa_secure_boot_signing_key4.pem"),
489              self._open("bootloader_multi_signed_v2.bin"),
490          )
491          with pytest.raises(esptool.FatalError) as cm:
492              espsecure.verify_signature(args)
493          assert "Signature could not be verified with the provided key." in str(cm.value)
494      def test_verify_signature_public_key(self):
495          args = self.VerifyArgs(
496              "1",
497              False,
498              None,
499              self._open("ecdsa_secure_boot_signing_pubkey.pem"),
500              self._open("bootloader_signed.bin"),
501          )
502          espsecure.verify_signature(args)
503          args = self.VerifyArgs(
504              "2",
505              False,
506              None,
507              self._open("rsa_secure_boot_signing_pubkey.pem"),
508              self._open("bootloader_signed_v2.bin"),
509          )
510          espsecure.verify_signature(args)
511          args = self.VerifyArgs(
512              "2",
513              False,
514              None,
515              self._open("ecdsa_secure_boot_signing_pubkey.pem"),
516              self._open("bootloader_signed_v2_ecdsa256.bin"),
517          )
518          espsecure.verify_signature(args)
519          args = self.VerifyArgs(
520              "2",
521              False,
522              None,
523              self._open("ecdsa192_secure_boot_signing_pubkey.pem"),
524              self._open("bootloader_signed_v2_ecdsa192.bin"),
525          )
526          espsecure.verify_signature(args)
527          args = self.VerifyArgs(
528              "1",
529              False,
530              None,
531              self._open("ecdsa_secure_boot_signing_pubkey2.pem"),
532              self._open("bootloader_signed.bin"),
533          )
534          with pytest.raises(esptool.FatalError) as cm:
535              espsecure.verify_signature(args)
536          assert "Signature is not valid" in str(cm.value)
537          args = self.VerifyArgs(
538              "2",
539              False,
540              None,
541              self._open("rsa_secure_boot_signing_pubkey2.pem"),
542              self._open("bootloader_signed_v2.bin"),
543          )
544          with pytest.raises(esptool.FatalError) as cm:
545              espsecure.verify_signature(args)
546          assert "Signature could not be verified with the provided key." in str(cm.value)
547          args = self.VerifyArgs(
548              "2",
549              False,
550              None,
551              self._open("ecdsa_secure_boot_signing_pubkey2.pem"),
552              self._open("bootloader_signed_v2_ecdsa256.bin"),
553          )
554          with pytest.raises(esptool.FatalError) as cm:
555              espsecure.verify_signature(args)
556          assert "Signature could not be verified with the provided key." in str(cm.value)
557          args = self.VerifyArgs(
558              "2",
559              False,
560              None,
561              self._open("ecdsa192_secure_boot_signing_pubkey2.pem"),
562              self._open("bootloader_signed_v2_ecdsa192.bin"),
563          )
564          with pytest.raises(esptool.FatalError) as cm:
565              espsecure.verify_signature(args)
566          assert "Signature could not be verified with the provided key." in str(cm.value)
567          args = self.VerifyArgs(
568              "2",
569              False,
570              None,
571              self._open("rsa_secure_boot_signing_pubkey4.pem"),
572              self._open("bootloader_multi_signed_v2.bin"),
573          )
574          with pytest.raises(esptool.FatalError) as cm:
575              espsecure.verify_signature(args)
576          assert "Signature could not be verified with the provided key." in str(cm.value)
577      def test_extract_binary_public_key(self):
578          with tempfile.NamedTemporaryFile() as pub_keyfile, tempfile.NamedTemporaryFile() as pub_keyfile2:  # noqa E501
579              args = self.ExtractKeyArgs(
580                  "1", self._open("ecdsa_secure_boot_signing_key.pem"), pub_keyfile
581              )
582              espsecure.extract_public_key(args)
583              args = self.ExtractKeyArgs(
584                  "1", self._open("ecdsa_secure_boot_signing_key2.pem"), pub_keyfile2
585              )
586              espsecure.extract_public_key(args)
587              pub_keyfile.seek(0)
588              pub_keyfile2.seek(0)
589              args = self.VerifyArgs(
590                  "1", False, None, pub_keyfile, self._open("bootloader_signed.bin")
591              )
592              espsecure.verify_signature(args)
593              args = self.VerifyArgs(
594                  "1", False, None, pub_keyfile2, self._open("bootloader_signed.bin")
595              )
596              with pytest.raises(esptool.FatalError) as cm:
597                  espsecure.verify_signature(args)
598              assert "Signature is not valid" in str(cm.value)
599      def test_generate_and_extract_key_v2(self):
600          with tempfile.TemporaryDirectory() as keydir:
601              keyfile_name = os.path.join(keydir, "key.pem")
602              for scheme in ["rsa3072", "ecdsa192", "ecdsa256"]:
603                  args = self.GenerateKeyArgs("2", scheme, keyfile_name)
604                  espsecure.generate_signing_key(args)
605                  with tempfile.NamedTemporaryFile() as pub_keyfile, open(
606                      keyfile_name, "rb"
607                  ) as keyfile:
608                      args = self.ExtractKeyArgs("2", keyfile, pub_keyfile)
609                      espsecure.extract_public_key(args)
610                  os.remove(keyfile_name)
611  class TestFlashEncryption(EspSecureTestCase):
612      EncryptArgs = namedtuple(
613          "encrypt_flash_data_args",
614          [
615              "keyfile",
616              "output",
617              "address",
618              "flash_crypt_conf",
619              "aes_xts",
620              "plaintext_file",
621          ],
622      )
623      DecryptArgs = namedtuple(
624          "decrypt_flash_data_args",
625          [
626              "keyfile",
627              "output",
628              "address",
629              "flash_crypt_conf",
630              "aes_xts",
631              "encrypted_file",
632          ],
633      )
634      def _test_encrypt_decrypt(
635          self,
636          input_plaintext,
637          expected_ciphertext,
638          key_path,
639          offset,
640          flash_crypt_conf=0xF,
641          aes_xts=None,
642      ):
643          original_plaintext = self._open(input_plaintext)
644          keyfile = self._open(key_path)
645          ciphertext = io.BytesIO()
646          args = self.EncryptArgs(
647              keyfile, ciphertext, offset, flash_crypt_conf, aes_xts, original_plaintext
648          )
649          espsecure.encrypt_flash_data(args)
650          original_plaintext.seek(0)
651          assert original_plaintext.read() != ciphertext.getvalue()
652          with self._open(expected_ciphertext) as f:
653              assert f.read() == ciphertext.getvalue()
654          ciphertext.seek(0)
655          keyfile.seek(0)
656          plaintext = io.BytesIO()
657          args = self.DecryptArgs(
658              keyfile, plaintext, offset, flash_crypt_conf, aes_xts, ciphertext
659          )
660          espsecure.decrypt_flash_data(args)
661          original_plaintext.seek(0)
662          assert original_plaintext.read() == plaintext.getvalue()
663  class TestESP32FlashEncryption(TestFlashEncryption):
664      def test_encrypt_decrypt_bootloader(self):
665          self._test_encrypt_decrypt(
666              "bootloader.bin", "bootloader-encrypted.bin", "256bit_key.bin", 0x1000, 0xF
667          )
668      def test_encrypt_decrypt_app(self):
669          self._test_encrypt_decrypt(
670              "hello-world-signed.bin",
671              "hello-world-signed-encrypted.bin",
672              "ef-flashencryption-key.bin",
673              0x20000,
674              0xF,
675          )
676      def test_encrypt_decrypt_non_default_conf(self):
677          for conf in [0x0, 0x3, 0x9, 0xC]:
678              self._test_encrypt_decrypt(
679                  "bootloader.bin",
680                  f"bootloader-encrypted-conf{conf:x}.bin",
681                  "256bit_key.bin",
682                  0x1000,
683                  conf,
684              )
685  class TestAesXtsFlashEncryption(TestFlashEncryption):
686      def test_encrypt_decrypt_bootloader(self):
687          self._test_encrypt_decrypt(
688              "bootloader.bin",
689              "bootloader-encrypted-aes-xts.bin",
690              "256bit_key.bin",
691              0x1000,
692              aes_xts=True,
693          )
694      def test_encrypt_decrypt_app(self):
695          self._test_encrypt_decrypt(
696              "hello-world-signed.bin",
697              "hello-world-signed-encrypted-aes-xts.bin",
698              "ef-flashencryption-key.bin",
699              0x20000,
700              aes_xts=True,
701          )
702      def test_encrypt_decrypt_app_512_bit_key(self):
703          self._test_encrypt_decrypt(
704              "hello-world-signed.bin",
705              "hello-world-signed-encrypted-aes-xts-256.bin",
706              "512bit_key.bin",
707              0x10000,
708              aes_xts=True,
709          )
710      def test_padding(self):
711          plaintext = binascii.unhexlify(
712              "c33b7c49f12a969a9bb45af5f660b73f"
713              "3b372685012da570df1cf99d1a82eabb"
714              "fdf6aa16b9675bd8a2f95e871513e175"
715              "3bc89f57986ecfb2707a3d3b59a46968"
716              "5e6609d2e9c21d4b2310571175e6e3de"
717              "2656ee22243f557b925ef39ff782ab56"
718              "f821e6859ee852000daae7c03a7c77ce"
719              "58744f15fbdf0ad4ae6e964aedd6316a"
720              "cf0e36935eef895cd14a60fe682fb971"
721              "eb239eae38b770bdf969017c9decfd91"
722              "b7c60329fb0c896684f0e7415f99dec1"
723              "da0572fac360a3e6d7219973a7de07e5"
724              "33b5abfdf5917ed5bfe54d660a6f5047"
725              "32fdb8d07259bfcdc67da87293857c11"
726              "427b2bae5f00da4a4b2b00b588ff5109"
727              "4c41f07f02f680f8826841b43da3f25b"
728          )
729          plaintext_file = io.BytesIO(plaintext)
730          ciphertext_full_block = io.BytesIO()
731          keyfile = self._open("256bit_key.bin")
732          address = 0x1000
733          encrypt_args_padded = self.EncryptArgs(
734              keyfile, ciphertext_full_block, address, None, "aes_xts", plaintext_file
735          )
736          espsecure.encrypt_flash_data(encrypt_args_padded)
737          bytes_per_encrypt = [16, 32, 64, 128]
738          for b in bytes_per_encrypt:
739              ciphertext = io.BytesIO()
740              num_enc_calls = len(plaintext) // b
741              for i in range(0, num_enc_calls):
742                  keyfile.seek(0)
743                  offset = b * i
744                  plaintext_sub = io.BytesIO(plaintext[offset : offset + b])
745                  encrypt_args = self.EncryptArgs(
746                      keyfile,
747                      ciphertext,
748                      address + offset,
749                      None,
750                      "aes_xts",
751                      plaintext_sub,
752                  )
753                  espsecure.encrypt_flash_data(encrypt_args)
754              assert ciphertext_full_block.getvalue() == ciphertext.getvalue()
755  class TestDigest(EspSecureTestCase):
756      def test_digest_private_key(self):
757          with tempfile.NamedTemporaryFile() as f:
758              outfile_name = f.name
759          self.run_espsecure(
760              "digest_private_key "
761              "--keyfile secure_images/ecdsa_secure_boot_signing_key.pem "
762              f"{outfile_name}"
763          )
764          with open(outfile_name, "rb") as f:
765              assert f.read() == binascii.unhexlify(
766                  "7b7b53708fc89d5e0b2df2571fb8f9d778f61a422ff1101a22159c4b34aad0aa"
767              )
768      def test_digest_private_key_with_invalid_output(self, capsys):
769          fname = "secure_images/ecdsa_secure_boot_signing_key.pem"
770          with pytest.raises(subprocess.CalledProcessError):
771              self.run_espsecure(f"digest_private_key --keyfile {fname} {fname}")
772          output = capsys.readouterr().out
773          assert "should not be the same!" in output
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espsecure_hsm.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espsecure.py</div>
                </div>
                <div class="column column_space"><pre><code>143              args = self.SignArgs(
144                  "2",
145                  None,
146                  output_file1.name,
147                  True,
</pre></code></div>
                <div class="column column_space"><pre><code>350                  args = self.SignArgs(
351                      "2",
352                      None,
353                      output_file.name,
354                      False,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    