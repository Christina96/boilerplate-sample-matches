
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.56844547563805%, Tokens: 9</h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-fields.py</h3>
            <pre><code>1  import binascii
2  import struct
3  import time
4  from bitstring import BitArray
5  import esptool
6  import reedsolo
7  from .mem_definition import EfuseDefineBlocks, EfuseDefineFields, EfuseDefineRegisters
8  from .. import base_fields
9  from .. import util
10  class EfuseBlock(base_fields.EfuseBlockBase):
11      def len_of_burn_unit(self):
12          return 8 * 4
13      def __init__(self, parent, param, skip_read=False):
14          parent.read_coding_scheme()
15          super(EfuseBlock, self).__init__(parent, param, skip_read=skip_read)
16      def apply_coding_scheme(self):
17          data = self.get_raw(from_read=False)[::-1]
18          if len(data) < self.len_of_burn_unit():
19              add_empty_bytes = self.len_of_burn_unit() - len(data)
20              data = data + (b"\x00" * add_empty_bytes)
21          if self.get_coding_scheme() == self.parent.REGS.CODING_SCHEME_RS:
22              rs = reedsolo.RSCodec(12)
23              encoded_data = rs.encode([x for x in data])
24              words = struct.unpack("<" + "I" * 11, encoded_data)
25          else:
26              words = struct.unpack("<" + ("I" * (len(data) // 4)), data)
27          return words
28  class EspEfuses(base_fields.EspEfusesBase):
29      debug = False
30      do_not_confirm = False
31      def __init__(self, esp, skip_connect=False, debug=False, do_not_confirm=False):
32          self.Blocks = EfuseDefineBlocks()
33          self.Fields = EfuseDefineFields()
34          self.REGS = EfuseDefineRegisters
35          self.BURN_BLOCK_DATA_NAMES = self.Blocks.get_burn_block_data_names()
36          self.BLOCKS_FOR_KEYS = self.Blocks.get_blocks_for_keys()
37          self._esp = esp
38          self.debug = debug
39          self.do_not_confirm = do_not_confirm
40          if esp.CHIP_NAME != "ESP32-C2":
41              raise esptool.FatalError(
42                  "Expected the 'esp' param for ESP32-C2 chip but got for '%s'."
43                  % (esp.CHIP_NAME)
44              )
45          if not skip_connect:
46              flags = self._esp.get_security_info()["flags"]
47              GET_SECURITY_INFO_FLAG_SECURE_DOWNLOAD_ENABLE = 1 << 2
48              if flags & GET_SECURITY_INFO_FLAG_SECURE_DOWNLOAD_ENABLE:
49                  raise esptool.FatalError(
50                      "Secure Download Mode is enabled. The tool can not read eFuses."
51                  )
52          self.blocks = [
53              EfuseBlock(self, self.Blocks.get(block), skip_read=skip_connect)
54              for block in self.Blocks.BLOCKS
55          ]
56          if not skip_connect:
57              self.get_coding_scheme_warnings()
58          self.efuses = [EfuseField.convert(self, efuse) for efuse in self.Fields.EFUSES]
59          self.efuses += [
60              EfuseField.convert(self, efuse) for efuse in self.Fields.KEYBLOCKS
61          ]
62          if skip_connect:
63              self.efuses += [
64                  EfuseField.convert(self, efuse)
65                  for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
66              ]
67          else:
68              if self["BLK_VERSION_MINOR"].get() == 1:
69                  self.efuses += [
70                      EfuseField.convert(self, efuse)
71                      for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
72                  ]
73      def __getitem__(self, efuse_name):
74          for e in self.efuses:
75              if efuse_name == e.name or any(x == efuse_name for x in e.alt_names):
76                  return e
77          new_fields = False
78          for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES:
79              if efuse.name == efuse_name or any(
80                  x == efuse_name for x in efuse.alt_names
81              ):
82                  self.efuses += [
83                      EfuseField.convert(self, efuse)
84                      for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
85                  ]
86                  new_fields = True
87          if new_fields:
88              for e in self.efuses:
89                  if efuse_name == e.name or any(x == efuse_name for x in e.alt_names):
90                      return e
91          raise KeyError
92      def read_coding_scheme(self):
93          self.coding_scheme = self.REGS.CODING_SCHEME_RS
94      def print_status_regs(self):
95          print("")
96          self.blocks[0].print_block(self.blocks[0].err_bitarray, "err__regs", debug=True)
97          print(
98              "{:27} 0x{:08x}".format(
99                  "EFUSE_RD_RS_ERR_REG", self.read_reg(self.REGS.EFUSE_RD_RS_ERR_REG)
100              )
101          )
102      def efuse_controller_setup(self):
103          self.set_efuse_timing()
104          self.clear_pgm_registers()
105          self.wait_efuse_idle()
106      def write_efuses(self, block):
107          self.efuse_program(block)
108          return self.get_coding_scheme_warnings(silent=True)
109      def clear_pgm_registers(self):
110          self.wait_efuse_idle()
111          for r in range(
112              self.REGS.EFUSE_PGM_DATA0_REG, self.REGS.EFUSE_PGM_DATA0_REG + 32, 4
113          ):
114              self.write_reg(r, 0)
115      def wait_efuse_idle(self):
116          deadline = time.time() + self.REGS.EFUSE_BURN_TIMEOUT
117          while time.time() < deadline:
118              if self.read_reg(self.REGS.EFUSE_STATUS_REG) & 0x7 == 1:
119                  return
120          raise esptool.FatalError(
121              "Timed out waiting for Efuse controller command to complete"
122          )
123      def efuse_program(self, block):
124          self.wait_efuse_idle()
125          self.write_reg(self.REGS.EFUSE_CONF_REG, self.REGS.EFUSE_WRITE_OP_CODE)
126          self.write_reg(self.REGS.EFUSE_CMD_REG, self.REGS.EFUSE_PGM_CMD | (block << 2))
127          self.wait_efuse_idle()
128          self.clear_pgm_registers()
129          self.efuse_read()
130      def efuse_read(self):
131          self.wait_efuse_idle()
132          self.write_reg(self.REGS.EFUSE_CONF_REG, self.REGS.EFUSE_READ_OP_CODE)
133          try:
134              self.write_reg(
135                  self.REGS.EFUSE_CMD_REG, self.REGS.EFUSE_READ_CMD, delay_after_us=1000
136              )
137              self.wait_efuse_idle()
138          except esptool.FatalError:
139              secure_download_mode_before = self._esp.secure_download_mode
140              try:
141                  self._esp = self.reconnect_chip(self._esp)
142              except esptool.FatalError:
143                  print("Can not re-connect to the chip")
144                  if not self["DIS_DOWNLOAD_MODE"].get() and self[
145                      "DIS_DOWNLOAD_MODE"
146                  ].get(from_read=False):
147                      print(
148                          "This is the correct behavior as we are actually burning "
149                          "DIS_DOWNLOAD_MODE which disables the connection to the chip"
150                      )
151                      print("DIS_DOWNLOAD_MODE is enabled")
152                      print("Successful")
153                      exit(0)  # finish without errors
154                  raise
155              print("Established a connection with the chip")
156              if self._esp.secure_download_mode and not secure_download_mode_before:
157                  print("Secure download mode is enabled")
158                  if not self["ENABLE_SECURITY_DOWNLOAD"].get() and self[
159                      "ENABLE_SECURITY_DOWNLOAD"
160                  ].get(from_read=False):
161                      print(
162                          "espefuse tool can not continue to work in Secure download mode"
163                      )
164                      print("ENABLE_SECURITY_DOWNLOAD is enabled")
165                      print("Successful")
166                      exit(0)  # finish without errors
167              raise
168      def set_efuse_timing(self):
169          xtal_freq = self.get_crystal_freq()
170          if xtal_freq not in [26, 40]:
171              raise esptool.FatalError(
172                  "The eFuse supports only xtal=26M and 40M (xtal was %d)" % xtal_freq
173              )
174          self.update_reg(self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_NUM_M, 0xFF)
175          self.update_reg(
176              self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_CLK_DIV_M, 0x28
177          )
178          self.update_reg(
179              self.REGS.EFUSE_WR_TIM_CONF1_REG, self.REGS.EFUSE_PWR_ON_NUM_M, 0x3000
180          )
181          self.update_reg(
182              self.REGS.EFUSE_WR_TIM_CONF2_REG, self.REGS.EFUSE_PWR_OFF_NUM_M, 0x190
183          )
184          tpgm_inactive_val = 200 if xtal_freq == 40 else 130
185          self.update_reg(
186              self.REGS.EFUSE_WR_TIM_CONF0_REG,
187              self.REGS.EFUSE_TPGM_INACTIVE_M,
188              tpgm_inactive_val,
189          )
190      def get_coding_scheme_warnings(self, silent=False):
191          old_addr_reg = 0
192          reg_value = 0
193          ret_fail = False
194          for block in self.blocks:
195              if block.id == 0:
196                  words = [
197                      self.read_reg(self.REGS.EFUSE_RD_REPEAT_ERR_REG + offs * 4)
198                      for offs in range(1)
199                  ]
200                  block.err_bitarray.pos = 0
201                  for word in reversed(words):
202                      block.err_bitarray.overwrite(BitArray("uint:32=%d" % word))
203                  block.num_errors = block.err_bitarray.count(True)
204                  block.fail = block.num_errors != 0
205              else:
206                  addr_reg, err_num_mask, err_num_offs, fail_bit = self.REGS.BLOCK_ERRORS[
207                      block.id
208                  ]
209                  if err_num_mask is None or err_num_offs is None or fail_bit is None:
210                      continue
211                  if addr_reg != old_addr_reg:
212                      old_addr_reg = addr_reg
213                      reg_value = self.read_reg(addr_reg)
214                  block.fail = reg_value & (1 << fail_bit) != 0
215                  block.num_errors = (reg_value >> err_num_offs) & err_num_mask
216              ret_fail |= block.fail
217              if not silent and (block.fail or block.num_errors):
218                  print(
219                      "Error(s) in BLOCK%d [ERRORS:%d FAIL:%d]"
220                      % (block.id, block.num_errors, block.fail)
221                  )
222          if (self.debug or ret_fail) and not silent:
223              self.print_status_regs()
224          return ret_fail
225      def summary(self):
226          return ""
<span onclick='openModal()' class='match'>227  class EfuseField(base_fields.EfuseFieldBase):
228      @staticmethod
229      def convert(parent, efuse):
230          return {
231              "mac": EfuseMacField,
232              "keypurpose": EfuseKeyPurposeField,
233              "t_sensor": EfuseTempSensor,
234              "adc_tp": EfuseAdcPointCalibration,
235          }.get(efuse.class_type, EfuseField)(parent, efuse)
236  class EfuseTempSensor(EfuseField):
</span>237      def get(self, from_read=True):
238          value = self.get_bitstring(from_read)
239          sig = -1 if value[0] else 1
240          return sig * value[1:].uint * 0.1
241  class EfuseAdcPointCalibration(EfuseField):
242      def get(self, from_read=True):
243          STEP_SIZE = 4
244          value = self.get_bitstring(from_read)
245          sig = -1 if value[0] else 1
246          return sig * value[1:].uint * STEP_SIZE
247  class EfuseMacField(EfuseField):
248      def check_format(self, new_value_str):
249          if new_value_str is None:
250              raise esptool.FatalError(
251                  "Required MAC Address in AA:CD:EF:01:02:03 format!"
252              )
253          if new_value_str.count(":") != 5:
254              raise esptool.FatalError(
255                  "MAC Address needs to be a 6-byte hexadecimal format "
256                  "separated by colons (:)!"
257              )
258          hexad = new_value_str.replace(":", "")
259          if len(hexad) != 12:
260              raise esptool.FatalError(
261                  "MAC Address needs to be a 6-byte hexadecimal number "
262                  "(12 hexadecimal characters)!"
263              )
264          bindata = binascii.unhexlify(hexad)
265          if esptool.util.byte(bindata, 0) & 0x01:
266              raise esptool.FatalError("Custom MAC must be a unicast MAC!")
267          return bindata
268      def check(self):
269          errs, fail = self.parent.get_block_errors(self.block)
270          if errs != 0 or fail:
271              output = "Block%d has ERRORS:%d FAIL:%d" % (self.block, errs, fail)
272          else:
273              output = "OK"
274          return "(" + output + ")"
275      def get(self, from_read=True):
276          if self.name == "CUSTOM_MAC":
277              mac = self.get_raw(from_read)[::-1]
278          else:
279              mac = self.get_raw(from_read)
280          return "%s %s" % (util.hexify(mac, ":"), self.check())
281      def save(self, new_value):
282          def print_field(e, new_value):
283              print(
284                  "    - '{}' ({}) {} -> {}".format(
285                      e.name, e.description, e.get_bitstring(), new_value
286                  )
287              )
288          if self.name == "CUSTOM_MAC":
289              bitarray_mac = self.convert_to_bitstring(new_value)
290              print_field(self, bitarray_mac)
291              super(EfuseMacField, self).save(new_value)
292          else:
293              raise esptool.FatalError("Writing Factory MAC address is not supported")
294  class EfuseKeyPurposeField(EfuseField):
295      KEY_PURPOSES = [
296          ("USER",                                        0, None),      # User purposes (software-only use)
297          ("XTS_AES_128_KEY",                             1, None),      # (whole 256bits) flash/PSRAM encryption
298          ("XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS", 2, None),      # (lo 128bits) flash/PSRAM encryption
299          ("SECURE_BOOT_DIGEST",                          3, "DIGEST"),
300      ]
301      KEY_PURPOSES_NAME = [name[0] for name in KEY_PURPOSES]
302      DIGEST_KEY_PURPOSES = [name[0] for name in KEY_PURPOSES if name[2] == "DIGEST"]
</code></pre>
        </div>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-conv_test.py</h3>
            <pre><code>1  from absl.testing import parameterized
2  import numpy as np
3  from sonnet.src import conv
4  from sonnet.src import initializers
5  from sonnet.src import test_utils
6  import tensorflow as tf
7  def create_constant_initializers(w, b, with_bias):
8    if with_bias:
9      return {
10          "w_init": initializers.Constant(w),
11          "b_init": initializers.Constant(b)
12      }
13    else:
14      return {"w_init": initializers.Constant(w)}
15  class ConvTest(test_utils.TestCase, parameterized.TestCase):
16    def testPaddingFunctionReached(self):
17      self.reached = False
18      def padding_func(*unused_args):
19        padding_func.called = True
20        return [0, 0]
21      conv1 = conv.ConvND(
22          num_spatial_dims=2,
23          output_channels=1,
24          kernel_shape=3,
25          stride=1,
26          padding=padding_func,
27          data_format="NHWC",
28          **create_constant_initializers(1.0, 1.0, True))
29      conv1(tf.ones([1, 5, 5, 1], dtype=tf.float32))
30      self.assertEqual(conv1.conv_padding, "VALID")
31      self.assertEqual(conv1.padding_func, padding_func)
32      self.assertTrue(getattr(padding_func, "called", False))
33    @parameterized.parameters(0, 4)
34    def testIncorrectN(self, n):
35      with self.assertRaisesRegex(
36          ValueError,
37          "We only support convoltion operations for num_spatial_dims=1, 2 or 3"):
38        conv.ConvND(
39            num_spatial_dims=n,
40            output_channels=1,
41            kernel_shape=3,
42            data_format="NHWC")
43    def testInitializerKeysInvalidWithoutBias(self):
44      with self.assertRaisesRegex(ValueError, "b_init must be None"):
45        conv.ConvND(
46            num_spatial_dims=2,
47            output_channels=1,
48            kernel_shape=3,
49            data_format="NHWC",
50            with_bias=False,
51            b_init=tf.zeros_initializer())
52    def testIncorrectRankInput(self):
53      c = conv.ConvND(
54          num_spatial_dims=2,
55          output_channels=1,
56          kernel_shape=3,
57          data_format="NHWC")
58      with self.assertRaisesRegex(ValueError, "Shape .* must have rank 4"):
59        c(tf.ones([2, 4, 4]))
60    @parameterized.parameters(tf.float32, tf.float64)
61    def testDefaultInitializers(self, dtype):
62      if "TPU" in self.device_types and dtype == tf.float64:
63        self.skipTest("Double precision not supported on TPU.")
64      conv1 = conv.ConvND(
65          num_spatial_dims=2,
66          output_channels=1,
67          kernel_shape=16,
68          stride=1,
69          padding="VALID",
70          data_format="NHWC")
71      out = conv1(tf.random.normal([8, 64, 64, 1], dtype=dtype))
72      self.assertAllEqual(out.shape, [8, 49, 49, 1])
73      self.assertEqual(out.dtype, dtype)
74      err = 0.2 if self.primary_device == "TPU" else 0.1
75      self.assertNear(out.numpy().std(), 0.87, err=err)
76    @parameterized.named_parameters(
77        ("SamePaddingUseBias", True, "SAME"),
78        ("SamePaddingNoBias", False, "SAME"),
79        ("samePaddingUseBias", True, "same"),
80        ("samePaddingNoBias", False, "same"),
81        ("ValidPaddingNoBias", False, "VALID"),
82        ("ValidPaddingUseBias", True, "VALID"),
83        ("validPaddingNoBias", False, "valid"),
84        ("validPaddingUseBias", True, "valid"),
85    )
86    def testFunction(self, with_bias, padding):
87      conv1 = conv.ConvND(
88          num_spatial_dims=2,
89          output_channels=1,
90          kernel_shape=3,
91          stride=1,
92          padding=padding,
93          with_bias=with_bias,
94          data_format="NHWC",
95          **create_constant_initializers(1.0, 1.0, with_bias))
96      conv2 = conv.ConvND(
97          num_spatial_dims=2,
98          output_channels=1,
99          kernel_shape=3,
100          stride=1,
101          padding=padding,
102          with_bias=with_bias,
103          data_format="NHWC",
104          **create_constant_initializers(1.0, 1.0, with_bias))
105      defun_conv = tf.function(conv2)
106      iterations = 5
107      for _ in range(iterations):
108        x = tf.random.uniform([1, 5, 5, 1])
109        y1 = conv1(x)
110        y2 = defun_conv(x)
111        self.assertAllClose(self.evaluate(y1), self.evaluate(y2), atol=1e-4)
112    def testUnknownBatchSizeNHWC(self):
113      x = tf.TensorSpec([None, 5, 5, 3], dtype=tf.float32)
114      c = conv.ConvND(
115          num_spatial_dims=2,
116          output_channels=2,
117          kernel_shape=3,
118          data_format="NHWC")
119      defun_conv = tf.function(c).get_concrete_function(x)
120      out1 = defun_conv(tf.ones([3, 5, 5, 3]))
121      self.assertEqual(out1.shape, [3, 5, 5, 2])
122      out2 = defun_conv(tf.ones([5, 5, 5, 3]))
123      self.assertEqual(out2.shape, [5, 5, 5, 2])
124    def testUnknownBatchSizeNCHW(self):
125      if self.primary_device == "CPU":
126        self.skipTest("NCHW not supported on CPU")
127      x = tf.TensorSpec([None, 3, 5, 5], dtype=tf.float32)
128      c = conv.ConvND(
129          num_spatial_dims=2,
130          output_channels=2,
131          kernel_shape=3,
132          data_format="NCHW")
133      defun_conv = tf.function(c).get_concrete_function(x)
134      out1 = defun_conv(tf.ones([3, 3, 5, 5]))
135      self.assertEqual(out1.shape, [3, 2, 5, 5])
136      out2 = defun_conv(tf.ones([5, 3, 5, 5]))
137      self.assertEqual(out2.shape, [5, 2, 5, 5])
138    @parameterized.parameters(True, False)
139    def testUnknownChannels(self, autograph):
140      x = tf.TensorSpec([3, 3, 3, None], dtype=tf.float32)
141      c = conv.ConvND(
142          num_spatial_dims=2,
143          output_channels=1,
144          kernel_shape=3,
145          data_format="NHWC")
146      defun_conv = tf.function(c, autograph=autograph)
147      with self.assertRaisesRegex(ValueError,
148                                  "The number of input channels must be known"):
149        defun_conv.get_concrete_function(x)
150    def testUnknownSpatialDims(self):
151      x = tf.TensorSpec([3, None, None, 3], dtype=tf.float32)
152      c = conv.ConvND(
153          num_spatial_dims=2,
154          output_channels=1,
155          kernel_shape=3,
156          data_format="NHWC")
157      defun_conv = tf.function(c).get_concrete_function(x)
158      out = defun_conv(tf.ones([3, 5, 5, 3]))
159      expected_out = c(tf.ones([3, 5, 5, 3]))
160      self.assertEqual(out.shape, [3, 5, 5, 1])
161      self.assertAllEqual(self.evaluate(out), self.evaluate(expected_out))
162      out = defun_conv(tf.ones([3, 4, 4, 3]))
163      expected_out = c(tf.ones([3, 4, 4, 3]))
164      self.assertEqual(out.shape, [3, 4, 4, 1])
165      self.assertAllEqual(self.evaluate(out), self.evaluate(expected_out))
166  class Conv2DTest(test_utils.TestCase, parameterized.TestCase):
167    @parameterized.parameters(True, False)
168    def testComputationPaddingSame(self, with_bias):
169      expected_out = [[4, 6, 6, 6, 4], [6, 9, 9, 9, 6], [6, 9, 9, 9, 6],
170                      [6, 9, 9, 9, 6], [4, 6, 6, 6, 4]]
171      conv1 = conv.Conv2D(
172          output_channels=1,
173          kernel_shape=3,
174          stride=1,
175          padding="SAME",
176          with_bias=with_bias,
177          **create_constant_initializers(1.0, 1.0, with_bias))
178      out = conv1(tf.ones([1, 5, 5, 1], dtype=tf.float32))
179      self.assertEqual(out.shape, [1, 5, 5, 1])
180      out = tf.squeeze(out, axis=(0, 3))
181      expected_out = np.asarray(expected_out, dtype=np.float32)
182      if with_bias:
183        expected_out += 1
184      self.assertAllClose(self.evaluate(out), expected_out)
185    @parameterized.parameters(True, False)
186    def testComputationPaddingValid(self, with_bias):
187      expected_out = [[9, 9, 9], [9, 9, 9], [9, 9, 9]]
188      conv1 = conv.Conv2D(
189          output_channels=1,
190          kernel_shape=3,
191          stride=1,
192          padding="VALID",
193          with_bias=with_bias,
194          **create_constant_initializers(1.0, 1.0, with_bias))
195      out = conv1(tf.ones([1, 5, 5, 1], dtype=tf.float32))
196      self.assertEqual(out.shape, [1, 3, 3, 1])
197      out = tf.squeeze(out, axis=(0, 3))
198      expected_out = np.asarray(expected_out, dtype=np.float32)
199      if with_bias:
200        expected_out += 1
201      self.assertAllClose(self.evaluate(out), expected_out)
<span onclick='openModal()' class='match'>202  class Conv1DTest(test_utils.TestCase, parameterized.TestCase):
203    @parameterized.parameters(True, False)
204    def testComputationPaddingSame(self, with_bias):
205      expected_out = [2, 3, 3, 3, 2]
206      conv1 = conv.Conv1D(
207          output_channels=1,
208          kernel_shape=3,
209          stride=1,
210          padding="SAME",
211          with_bias=with_bias,
212          **create_constant_initializers(1.0, 1.0, with_bias))
213      out = conv1(tf.ones([1, 5, 1], dtype=tf.float32))
214      self.assertEqual(out.shape, [1, 5, 1])
215      out = tf.squeeze(out, axis=(0, 2))
216      expected_out = np.asarray(expected_out, dtype=np.float32)
217      if with_bias:
218        expected_out += 1
219      self.assertAllClose(self.evaluate(out), expected_out)
220    @parameterized.parameters(True, False)
221    def testComputationPaddingValid(self, with_bias):
222      expected_out = [3, 3, 3]
223      expected_out = np.asarray(expected_out, dtype=np.float32)
224      if with_bias:
225        expected_out += 1
226      conv1 = conv.Conv1D(
227          output_channels=1,
228          kernel_shape=3,
229          stride=1,
230          padding="VALID",
231          with_bias=with_bias,
232          **create_constant_initializers(1.0, 1.0, with_bias))
233      out = conv1(tf.ones([1, 5, 1], dtype=tf.float32))
234      self.assertEqual(out.shape, [1, 3, 1])
235      out = tf.squeeze(out, axis=(0, 2))
236      self.assertAllClose(self.evaluate(out), expected_out)
237  class Conv3DTest(test_utils.TestCase, parameterized.TestCase):
</span>238    @parameterized.parameters(True, False)
239    def testComputationPaddingSame(self, with_bias):
240      expected_out = np.asarray([
241          9, 13, 13, 13, 9, 13, 19, 19, 19, 13, 13, 19, 19, 19, 13, 13, 19, 19,
242          19, 13, 9, 13, 13, 13, 9, 13, 19, 19, 19, 13, 19, 28, 28, 28, 19, 19,
243          28, 28, 28, 19, 19, 28, 28, 28, 19, 13, 19, 19, 19, 13, 13, 19, 19, 19,
244          13, 19, 28, 28, 28, 19, 19, 28, 28, 28, 19, 19, 28, 28, 28, 19, 13, 19,
245          19, 19, 13, 13, 19, 19, 19, 13, 19, 28, 28, 28, 19, 19, 28, 28, 28, 19,
246          19, 28, 28, 28, 19, 13, 19, 19, 19, 13, 9, 13, 13, 13, 9, 13, 19, 19,
247          19, 13, 13, 19, 19, 19, 13, 13, 19, 19, 19, 13, 9, 13, 13, 13, 9
248      ]).reshape((5, 5, 5))
249      if not with_bias:
250        expected_out -= 1
251      conv1 = conv.Conv3D(
252          output_channels=1,
253          kernel_shape=3,
254          stride=1,
255          padding="SAME",
256          with_bias=with_bias,
257          **create_constant_initializers(1.0, 1.0, with_bias))
258      out = conv1(tf.ones([1, 5, 5, 5, 1], dtype=tf.float32))
259      self.assertEqual(out.shape, [1, 5, 5, 5, 1])
260      out = tf.squeeze(out, axis=(0, 4))
261      self.assertAllClose(self.evaluate(out), expected_out)
262    @parameterized.parameters(True, False)
263    def testComputationPaddingValid(self, with_bias):
264      expected_out = np.asarray([
265          28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
266          28, 28, 28, 28, 28, 28, 28, 28, 28
267      ]).reshape((3, 3, 3))
268      if not with_bias:
269        expected_out -= 1
270      conv1 = conv.Conv3D(
271          output_channels=1,
272          kernel_shape=3,
273          stride=1,
274          padding="VALID",
275          with_bias=with_bias,
276          **create_constant_initializers(1.0, 1.0, with_bias))
277      out = conv1(tf.ones([1, 5, 5, 5, 1], dtype=tf.float32))
278      self.assertEqual(out.shape, [1, 3, 3, 3, 1])
279      out = tf.squeeze(out, axis=(0, 4))
280      self.assertAllClose(self.evaluate(out), expected_out)
281  if __name__ == "__main__":
282    tf.test.main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-fields.py</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-conv_test.py</div>
                <div class="column column_space"><pre><code>227  class EfuseField(base_fields.EfuseFieldBase):
228      @staticmethod
229      def convert(parent, efuse):
230          return {
231              "mac": EfuseMacField,
232              "keypurpose": EfuseKeyPurposeField,
233              "t_sensor": EfuseTempSensor,
234              "adc_tp": EfuseAdcPointCalibration,
235          }.get(efuse.class_type, EfuseField)(parent, efuse)
236  class EfuseTempSensor(EfuseField):
</pre></code></div>
                <div class="column column_space"><pre><code>202  class Conv1DTest(test_utils.TestCase, parameterized.TestCase):
203    @parameterized.parameters(True, False)
204    def testComputationPaddingSame(self, with_bias):
205      expected_out = [2, 3, 3, 3, 2]
206      conv1 = conv.Conv1D(
207          output_channels=1,
208          kernel_shape=3,
209          stride=1,
210          padding="SAME",
211          with_bias=with_bias,
212          **create_constant_initializers(1.0, 1.0, with_bias))
213      out = conv1(tf.ones([1, 5, 1], dtype=tf.float32))
214      self.assertEqual(out.shape, [1, 5, 1])
215      out = tf.squeeze(out, axis=(0, 2))
216      expected_out = np.asarray(expected_out, dtype=np.float32)
217      if with_bias:
218        expected_out += 1
219      self.assertAllClose(self.evaluate(out), expected_out)
220    @parameterized.parameters(True, False)
221    def testComputationPaddingValid(self, with_bias):
222      expected_out = [3, 3, 3]
223      expected_out = np.asarray(expected_out, dtype=np.float32)
224      if with_bias:
225        expected_out += 1
226      conv1 = conv.Conv1D(
227          output_channels=1,
228          kernel_shape=3,
229          stride=1,
230          padding="VALID",
231          with_bias=with_bias,
232          **create_constant_initializers(1.0, 1.0, with_bias))
233      out = conv1(tf.ones([1, 5, 1], dtype=tf.float32))
234      self.assertEqual(out.shape, [1, 3, 1])
235      out = tf.squeeze(out, axis=(0, 2))
236      self.assertAllClose(self.evaluate(out), expected_out)
237  class Conv3DTest(test_utils.TestCase, parameterized.TestCase):
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    