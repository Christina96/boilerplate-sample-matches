
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.646586345381527%, Tokens: 9</h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-stickertools.py</h3>
            <pre><code>1  import glob
2  import io
3  import os
4  import random
5  from os import remove
6  try:
7      import cv2
8  except ImportError:
9      cv2 = None
10  try:
11      import numpy as np
12  except ImportError:
13      np = None
14  try:
15      from PIL import Image, ImageDraw
16  except ImportError:
17      pass
18  from telethon.errors import PeerIdInvalidError, YouBlockedUserError
19  from telethon.tl.functions.messages import UploadMediaRequest
20  from telethon.tl.types import (
21      DocumentAttributeFilename,
22      DocumentAttributeSticker,
23      InputPeerSelf,
24  )
25  from telethon.utils import get_input_document
26  from . import (
27      KANGING_STR,
28      LOGS,
29      asst,
30      async_searcher,
31      bash,
32      con,
33      functions,
34      get_string,
35      inline_mention,
36      mediainfo,
37      quotly,
38      types,
39      udB,
40      ultroid_cmd,
41  )
42  @ultroid_cmd(pattern="packkang")
43  async def pack_kangish(_):
44      _e = await _.get_reply_message()
45      local = None
46      try:
47          cmdtext = _.text.split(maxsplit=1)[1]
48      except IndexError:
49          cmdtext = None
50      if cmdtext and os.path.isdir(cmdtext):
51          local = True
52      elif not (_e and _e.sticker and _e.file.mime_type == "image/webp"):
53          return await _.eor(get_string("sts_4"))
54      msg = await _.eor(get_string("com_1"))
55      _packname = cmdtext or f"Ultroid Kang Pack By {_.sender_id}"
56      typee = None
57      if not local:
58          _id = _e.media.document.attributes[1].stickerset.id
59          _hash = _e.media.document.attributes[1].stickerset.access_hash
60          _get_stiks = await _.client(
61              functions.messages.GetStickerSetRequest(
62                  stickerset=types.InputStickerSetID(id=_id, access_hash=_hash), hash=0
63              )
64          )
65          docs = _get_stiks.documents
66      else:
67          docs = []
68          exte = files[-1]
69          if exte.endswith(".tgs"):
70              typee = "anim"
71          elif exte.endswith(".webm"):
72              typee = "vid"
73          count = 0
74          for file in files:
75              if file.endswith((".tgs", ".webm")):
76                  count += 1
77                  upl = await asst.upload_file(file)
78                  docs.append(await asst(UploadMediaRequest(InputPeerSelf(), upl)))
79                  if count % 5 == 0:
80                      await msg.edit(f"`Uploaded {count} files.`")
81      stiks = []
82      for i in docs:
83          x = get_input_document(i)
84          stiks.append(
85              types.InputStickerSetItem(
86                  document=x,
87                  emoji=random.choice(["üòê", "üëç", "üòÇ"])
88                  if local
89                  else (i.attributes[1]).alt,
90              )
91          )
92      try:
93          short_name = "ult_" + _packname.replace(" ", "_") + str(_.id)
94          _r_e_s = await asst(
95              functions.stickers.CreateStickerSetRequest(
96                  user_id=_.sender_id,
97                  title=_packname,
98                  short_name=f"{short_name}_by_{asst.me.username}",
99                  animated=typee == "anim",
100                  videos=typee == "vid",
101                  stickers=stiks,
102              )
103          )
104      except PeerIdInvalidError:
105          return await msg.eor(
106              f"Hey {inline_mention(_.sender)} send `/start` to @{asst.me.username} and later try this command again.."
107          )
108      except BaseException as er:
109          LOGS.exception(er)
110          return await msg.eor(str(er))
111      await msg.eor(
112          get_string("sts_5").format(f"https://t.me/addstickers/{_r_e_s.set.short_name}"),
113      )
114  @ultroid_cmd(
115      pattern="kang",
116  )
117  async def hehe(args):
118      ultroid_bot = args.client
119      xx = await args.eor(get_string("com_1"))
120      user = ultroid_bot.me
121      username = user.username
122      username = f"@{username}" if username else user.first_name
123      message = await args.get_reply_message()
124      photo = None
125      is_anim, is_vid = False, False
126      emoji = None
127      if not message:
128          return await xx.eor(get_string("sts_6"))
129      if message.photo:
130          photo = io.BytesIO()
131          photo = await ultroid_bot.download_media(message.photo, photo)
132      elif message.file and "image" in message.file.mime_type.split("/"):
133          photo = io.BytesIO()
134          await ultroid_bot.download_file(message.media.document, photo)
135          if (
136              DocumentAttributeFilename(file_name="sticker.webp")
137              in message.media.document.attributes
138          ):
139              emoji = message.media.document.attributes[1].alt
140      elif message.file and "video" in message.file.mime_type.split("/"):
141          xy = await message.download_media()
142          if (message.file.duration or 0) <= 10:
143              is_vid = True
144              photo = await con.create_webm(xy)
145          else:
146              y = cv2.VideoCapture(xy)
147              heh, lol = y.read()
148              cv2.imwrite("ult.webp", lol)
149              photo = "ult.webp"
150      elif message.file and "tgsticker" in message.file.mime_type:
151          await ultroid_bot.download_file(
152              message.media.document,
153              "AnimatedSticker.tgs",
154          )
155          attributes = message.media.document.attributes
156          for attribute in attributes:
157              if isinstance(attribute, DocumentAttributeSticker):
158                  emoji = attribute.alt
159          is_anim = True
160          photo = 1
161      elif message.message:
162          photo = await quotly.create_quotly(message)
163      else:
164          return await xx.edit(get_string("com_4"))
165      if not udB.get_key("language") or udB.get_key("language") == "en":
166          ra = random.choice(KANGING_STR)
167      else:
168          ra = get_string("sts_11")
169      await xx.edit(f"`{ra}`")
170      if photo:
171          splat = args.text.split()
172          pack = 1
173          if not emoji:
174              emoji = "üèµ"
175          if len(splat) == 3:
176              pack = splat[2]  # User sent ultroid_both
177              emoji = splat[1]
178          elif len(splat) == 2:
179              if splat[1].isnumeric():
180                  pack = int(splat[1])
181              else:
182                  emoji = splat[1]
183          packname = f"ult_{user.id}_{pack}"
184          packnick = f"{username}'s Pack {pack}"
185          cmd = "/newpack"
186          file = io.BytesIO()
187          if is_vid:
188              packname += "_vid"
189              packnick += " (Video)"
190              cmd = "/newvideo"
191          elif is_anim:
192              packname += "_anim"
193              packnick += " (Animated)"
194              cmd = "/newanimated"
195          else:
196              image = con.resize_photo_sticker(photo)
197              file.name = "sticker.png"
198              image.save(file, "PNG")
199          response = await async_searcher(f"http://t.me/addstickers/{packname}")
200          htmlstr = response.split("\n")
201          if (
202              "  A <strong>Telegram</strong> user has created the <strong>Sticker&nbsp;Set</strong>."
203              not in htmlstr
204          ):
205              async with ultroid_bot.conversation("@Stickers") as conv:
206                  try:
207                      await conv.send_message("/addsticker")
208                  except YouBlockedUserError:
209                      LOGS.info("Unblocking @Stickers for kang...")
210                      await ultroid_bot(functions.contacts.UnblockRequest("stickers"))
211                      await conv.send_message("/addsticker")
212                  await conv.get_response()
213                  await conv.send_message(packname)
214                  x = await conv.get_response()
215                  if x.text.startswith("Alright! Now send me the video sticker."):
216                      await conv.send_file(photo, force_document=True)
217                      x = await conv.get_response()
218                  t = "50" if (is_anim or is_vid) else "120"
219                  while t in x.message:
220                      pack += 1
221                      packname = f"ult_{user.id}_{pack}"
222                      packnick = f"{username}'s Pack {pack}"
223                      if is_anim:
224                          packname += "_anim"
225                          packnick += " (Animated)"
226                      elif is_vid:
227                          packnick += " (Video)"
228                          packname += "_vid"
229                      await xx.edit(get_string("sts_13").format(pack))
230                      await conv.send_message("/addsticker")
231                      await conv.get_response()
232                      await conv.send_message(packname)
233                      x = await conv.get_response()
234                      if x.text.startswith("Alright! Now send me the video sticker."):
235                          await conv.send_file(photo, force_document=True)
236                          x = await conv.get_response()
<span onclick='openModal()' class='match'>237                      if x.text in ["Invalid pack selected.", "Invalid set selected."]:
238                          await conv.send_message(cmd)
239                          await conv.get_response()
240                          await conv.send_message(packnick)
241                          await conv.get_response()
</span>242                          if is_anim:
243                              await conv.send_file("AnimatedSticker.tgs")
244                              remove("AnimatedSticker.tgs")
245                          else:
246                              if is_vid:
247                                  file = photo
248                              else:
249                                  file.seek(0)
250                              await conv.send_file(file, force_document=True)
251                          await conv.get_response()
252                          await conv.send_message(emoji)
253                          await conv.get_response()
254                          await conv.send_message("/publish")
255                          if is_anim:
256                              await conv.get_response()
257                              await conv.send_message(f"<{packnick}>")
258                          await conv.get_response()
259                          await conv.send_message("/skip")
260                          await conv.get_response()
261                          await conv.send_message(packname)
262                          await conv.get_response()
263                          await xx.edit(
264                              get_string("sts_7").format(packname),
265                              parse_mode="md",
266                          )
267                          return
268                  if is_anim:
269                      await conv.send_file("AnimatedSticker.tgs")
270                      remove("AnimatedSticker.tgs")
271                  elif "send me an emoji" not in x.message:
272                      if is_vid:
273                          file = photo
274                      else:
275                          file.seek(0)
276                      await conv.send_file(file, force_document=True)
277                      rsp = await conv.get_response()
278                      if "Sorry, the file type is invalid." in rsp.text:
279                          await xx.edit(
280                              get_string("sts_8"),
281                          )
282                          return
283                  await conv.send_message(emoji)
284                  await conv.get_response()
285                  await conv.send_message("/done")
286                  await conv.get_response()
287                  await ultroid_bot.send_read_acknowledge(conv.chat_id)
288          else:
289              await xx.edit("`Brewing a new Pack...`")
290              async with ultroid_bot.conversation("Stickers") as conv:
291                  await conv.send_message(cmd)
292                  await conv.get_response()
293                  await conv.send_message(packnick)
294                  await conv.get_response()
295                  if is_anim:
296                      await conv.send_file("AnimatedSticker.tgs")
297                      remove("AnimatedSticker.tgs")
298                  else:
299                      if is_vid:
300                          file = photo
301                      else:
302                          file.seek(0)
303                      await conv.send_file(file, force_document=True)
304                  rsp = await conv.get_response()
305                  if "Sorry, the file type is invalid." in rsp.text:
306                      await xx.edit(
307                          get_string("sts_8"),
308                      )
309                      return
310                  await conv.send_message(emoji)
311                  await conv.get_response()
312                  await conv.send_message("/publish")
313                  if is_anim:
314                      await conv.get_response()
315                      await conv.send_message(f"<{packnick}>")
316                  await conv.get_response()
317                  await conv.send_message("/skip")
318                  await conv.get_response()
319                  await conv.send_message(packname)
320                  await conv.get_response()
321                  await ultroid_bot.send_read_acknowledge(conv.chat_id)
322          await xx.edit(
323              get_string("sts_12").format(emoji, packname),
324              parse_mode="md",
325          )
326          try:
327              os.remove(photo)
328          except BaseException:
329              pass
330  @ultroid_cmd(
331      pattern="round$",
332  )
333  async def ultdround(event):
334      ureply = await event.get_reply_message()
335      xx = await event.eor(get_string("com_1"))
336      if not (ureply and (ureply.media)):
337          await xx.edit(get_string("sts_10"))
338          return
339      ultt = await ureply.download_media()
340      file = await con.convert(
341          ultt,
342          convert_to="png",
343          allowed_formats=["jpg", "jpeg", "png"],
344          outname="round",
345          remove_old=True,
346      )
347      img = Image.open(file).convert("RGB")
348      npImage = np.array(img)
349      h, w = img.size
350      alpha = Image.new("L", img.size, 0)
351      draw = ImageDraw.Draw(alpha)
352      draw.pieslice([0, 0, h, w], 0, 360, fill=255)
353      npAlpha = np.array(alpha)
354      npImage = np.dstack((npImage, npAlpha))
355      Image.fromarray(npImage).save("ult.webp")
356      await event.client.send_file(
357          event.chat_id,
358          "ult.webp",
359          force_document=False,
360          reply_to=event.reply_to_msg_id,
361      )
362      await xx.delete()
363      os.remove(file)
364      os.remove("ult.webp")
365  @ultroid_cmd(
366      pattern="destroy$",
367  )
368  async def ultdestroy(event):
369      ult = await event.get_reply_message()
370      if not (ult and ult.media and "animated" in mediainfo(ult.media)):
371          return await event.eor(get_string("sts_2"))
372      await event.client.download_media(ult, "ultroid.tgs")
373      xx = await event.eor(get_string("com_1"))
374      await bash("lottie_convert.py ultroid.tgs json.json")
375      with open("json.json") as json:
376          jsn = json.read()
377      jsn = (
378          jsn.replace("[100]", "[200]")
379          .replace("[10]", "[40]")
380          .replace("[-1]", "[-10]")
381          .replace("[0]", "[15]")
382          .replace("[1]", "[20]")
383          .replace("[2]", "[17]")
384          .replace("[3]", "[40]")
385          .replace("[4]", "[37]")
386          .replace("[5]", "[60]")
387          .replace("[6]", "[70]")
388          .replace("[7]", "[40]")
389          .replace("[8]", "[37]")
390          .replace("[9]", "[110]")
391      )
392      open("json.json", "w").write(jsn)
393      file = await con.animated_sticker("json.json", "ultroid.tgs")
394      if file:
395          await event.client.send_file(
396              event.chat_id,
397              file="ultroid.tgs",
398              force_document=False,
399              reply_to=event.reply_to_msg_id,
400          )
401      await xx.delete()
402      os.remove("json.json")
403  @ultroid_cmd(
404      pattern="tiny$",
405  )
406  async def ultiny(event):
407      reply = await event.get_reply_message()
408      if not (reply and (reply.media)):
409          await event.eor(get_string("sts_10"))
410          return
411      xx = await event.eor(get_string("com_1"))
412      ik = await reply.download_media()
413      im1 = Image.open("resources/extras/ultroid_blank.png")
414      if ik.endswith(".tgs"):
415          await con.animated_sticker(ik, "json.json")
416          with open("json.json") as json:
417              jsn = json.read()
418          jsn = jsn.replace("512", "2000")
419          open("json.json", "w").write(jsn)
420          await con.animated_sticker("json.json", "ult.tgs")
421          file = "ult.tgs"
422          os.remove("json.json")
423      elif ik.endswith((".gif", ".webm", ".mp4")):
424          iik = cv2.VideoCapture(ik)
425          dani, busy = iik.read()
426          cv2.imwrite("i.png", busy)
427          fil = "i.png"
428          im = Image.open(fil)
429          z, d = im.size
430          if z == d:
431              xxx, yyy = 200, 200
432          else:
433              t = z + d
434              a = z / t
435              b = d / t
436              aa = (a * 100) - 50
437              bb = (b * 100) - 50
438              xxx = 200 + 5 * aa
439              yyy = 200 + 5 * bb
440          k = im.resize((int(xxx), int(yyy)))
441          k.save("k.png", format="PNG", optimize=True)
442          im2 = Image.open("k.png")
443          back_im = im1.copy()
444          back_im.paste(im2, (150, 0))
445          back_im.save("o.webp", "WEBP", quality=95)
446          file = "o.webp"
447          os.remove(fil)
448          os.remove("k.png")
449      else:
450          im = Image.open(ik)
451          z, d = im.size
452          if z == d:
453              xxx, yyy = 200, 200
454          else:
455              t = z + d
456              a = z / t
457              b = d / t
458              aa = (a * 100) - 50
459              bb = (b * 100) - 50
460              xxx = 200 + 5 * aa
461              yyy = 200 + 5 * bb
462          k = im.resize((int(xxx), int(yyy)))
463          k.save("k.png", format="PNG", optimize=True)
464          im2 = Image.open("k.png")
465          back_im = im1.copy()
466          back_im.paste(im2, (150, 0))
467          back_im.save("o.webp", "WEBP", quality=95)
468          file = "o.webp"
469          os.remove("k.png")
470      if os.path.exists(file):
471          await event.client.send_file(
472              event.chat_id, file, reply_to=event.reply_to_msg_id
473          )
474          os.remove(file)
475      await xx.delete()
476      os.remove(ik)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espsecure.py</h3>
            <pre><code>1  import binascii
2  import io
3  import os
4  import os.path
5  import subprocess
6  import sys
7  import tempfile
8  from collections import namedtuple
9  from conftest import need_to_install_package_err
10  import pytest
11  try:
12      import esptool
13      import espsecure
14  except ImportError:
15      need_to_install_package_err()
16  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
17  @pytest.mark.host_test
18  class EspSecureTestCase:
19      def run_espsecure(self, args):
20          cmd = [sys.executable, "-m", "espsecure"] + args.split(" ")
21          print("\nExecuting {}...".format(" ".join(cmd)))
22          try:
23              output = subprocess.check_output(
24                  [str(s) for s in cmd], cwd=TEST_DIR, stderr=subprocess.STDOUT
25              )
26              output = output.decode("utf-8")
27              print(output)
28              return output
29          except subprocess.CalledProcessError as e:
30              print(e.output.decode("utf-8"))
31              raise e
32      @classmethod
33      def setup_class(self):
34          self.cleanup_files = []  # keep a list of files _open()ed by each test case
35      @classmethod
36      def teardown_class(self):
37          for f in self.cleanup_files:
38              f.close()
39      def _open(self, image_file):
40          f = open(os.path.join(TEST_DIR, "secure_images", image_file), "rb")
41          self.cleanup_files.append(f)
42          return f
43  class TestESP32SecureBootloader(EspSecureTestCase):
44      def test_digest_bootloader(self):
45          DBArgs = namedtuple(
46              "digest_bootloader_args", ["keyfile", "output", "iv", "image"]
47          )
48          try:
49              output_file = tempfile.NamedTemporaryFile(delete=False)
50              output_file.close()
51              args = DBArgs(
52                  self._open("256bit_key.bin"),
53                  output_file.name,
54                  self._open("256bit_iv.bin"),
55                  self._open("bootloader.bin"),
56              )
57              espsecure.digest_secure_bootloader(args)
58              with open(output_file.name, "rb") as of:
59                  with self._open("bootloader_digested.bin") as ef:
60                      assert ef.read() == of.read()
61          finally:
62              os.unlink(output_file.name)
63      def test_digest_rsa_public_key(self):
64          DigestRSAArgs = namedtuple("digest_rsa_public_key_args", ["keyfile", "output"])
65          try:
66              output_file = tempfile.NamedTemporaryFile(delete=False)
67              output_file.close()
68              args = DigestRSAArgs(
69                  self._open("rsa_secure_boot_signing_key.pem"), output_file.name
70              )
71              espsecure.digest_rsa_public_key(args)
72              with open(output_file.name, "rb") as of:
73                  with self._open("rsa_public_key_digest.bin") as ef:
74                      assert ef.read() == of.read()
75          finally:
76              os.unlink(output_file.name)
77  class TestSigning(EspSecureTestCase):
78      VerifyArgs = namedtuple(
79          "verify_signature_args", ["version", "hsm", "hsm_config", "keyfile", "datafile"]
80      )
81      SignArgs = namedtuple(
82          "sign_data_args",
83          [
84              "version",
85              "keyfile",
86              "output",
87              "append_signatures",
88              "hsm",
89              "hsm_config",
90              "pub_key",
91              "signature",
92              "datafile",
93          ],
94      )
95      ExtractKeyArgs = namedtuple(
96          "extract_public_key_args", ["version", "keyfile", "public_keyfile"]
97      )
98      GenerateKeyArgs = namedtuple("generate_key_args", ["version", "scheme", "keyfile"])
99      def test_key_generation_v1(self):
100          with tempfile.TemporaryDirectory() as keydir:
101              keyfile_name = os.path.join(keydir, "key.pem")
102              self.run_espsecure(f"generate_signing_key --version 1 {keyfile_name}")
103      def test_key_generation_v2(self):
104          with tempfile.TemporaryDirectory() as keydir:
105              keyfile_name = os.path.join(keydir, "key.pem")
106              self.run_espsecure(f"generate_signing_key --version 2 {keyfile_name}")
107      def _test_sign_v1_data(self, key_name):
108          try:
109              output_file = tempfile.NamedTemporaryFile(delete=False)
110              output_file.close()
111              args = self.SignArgs(
112                  "1",
113                  [self._open(key_name)],
114                  output_file.name,
115                  False,
116                  False,
117                  None,
118                  None,
119                  None,
120                  self._open("bootloader.bin"),
121              )
122              espsecure.sign_data(args)
123              with open(output_file.name, "rb") as of:
124                  with self._open("bootloader_signed.bin") as ef:
125                      assert ef.read() == of.read()
126          finally:
127              os.unlink(output_file.name)
128      def test_sign_v1_data(self):
129          self._test_sign_v1_data("ecdsa_secure_boot_signing_key.pem")
130      def test_sign_v1_data_pkcs8(self):
131          self._test_sign_v1_data("ecdsa_secure_boot_signing_key_pkcs8.pem")
132      def test_sign_v1_with_pre_calculated_signature(self):
133          signing_pubkey = "ecdsa_secure_boot_signing_pubkey.pem"
134          pre_calculated_signature = "pre_calculated_bootloader_signature.bin"
135          try:
136              output_file = tempfile.NamedTemporaryFile(delete=False)
137              args = self.SignArgs(
138                  "1",
139                  None,
140                  output_file.name,
141                  False,
142                  False,
143                  None,
144                  [self._open(signing_pubkey)],
145                  [self._open(pre_calculated_signature)],
146                  self._open("bootloader.bin"),
147              )
148              espsecure.sign_data(args)
149              args = self.VerifyArgs(
150                  "1", False, None, self._open(signing_pubkey), output_file
151              )
152              espsecure.verify_signature(args)
153          finally:
154              output_file.close()
155              os.unlink(output_file.name)
156      def test_sign_v2_data(self):
157          signing_keys = [
158              "rsa_secure_boot_signing_key.pem",
159              "ecdsa192_secure_boot_signing_key.pem",
160              "ecdsa_secure_boot_signing_key.pem",
161          ]
162          for key in signing_keys:
163              try:
164                  output_file = tempfile.NamedTemporaryFile(delete=False)
165                  args = self.SignArgs(
166                      "2",
167                      [self._open(key)],
168                      output_file.name,
169                      False,
170                      False,
171                      None,
172                      None,
173                      None,
174                      self._open("bootloader_unsigned_v2.bin"),
175                  )
176                  espsecure.sign_data(args)
177                  args = self.VerifyArgs("2", False, None, self._open(key), output_file)
178                  espsecure.verify_signature(args)
179              finally:
180                  output_file.close()
181                  os.unlink(output_file.name)
182      def test_sign_v2_multiple_keys(self):
183          try:
184              output_file = tempfile.NamedTemporaryFile(delete=False)
185              args = self.SignArgs(
186                  "2",
187                  [
188                      self._open("rsa_secure_boot_signing_key.pem"),
189                      self._open("rsa_secure_boot_signing_key2.pem"),
190                      self._open("rsa_secure_boot_signing_key3.pem"),
191                  ],
192                  output_file.name,
193                  False,
194                  False,
195                  None,
196                  None,
197                  None,
198                  self._open("bootloader_unsigned_v2.bin"),
199              )
200              espsecure.sign_data(args)
201              args = self.VerifyArgs(
202                  "2",
203                  False,
204                  None,
205                  self._open("rsa_secure_boot_signing_key3.pem"),
206                  output_file,
207              )
208              espsecure.verify_signature(args)
209              output_file.seek(0)
210              args = self.VerifyArgs(
211                  "2",
212                  False,
213                  None,
214                  self._open("rsa_secure_boot_signing_key2.pem"),
215                  output_file,
216              )
217              espsecure.verify_signature(args)
218              output_file.seek(0)
219              args = self.VerifyArgs(
220                  "2",
221                  False,
222                  None,
223                  self._open("rsa_secure_boot_signing_key.pem"),
224                  output_file,
225              )
226              espsecure.verify_signature(args)
227          finally:
228              output_file.close()
229              os.unlink(output_file.name)
230      def test_sign_v2_append_signatures(self):
231          try:
232              output_file = tempfile.NamedTemporaryFile(delete=False)
233              args = self.SignArgs(
234                  "2",
235                  [
236                      self._open("rsa_secure_boot_signing_key2.pem"),
237                      self._open("rsa_secure_boot_signing_key3.pem"),
238                  ],
239                  output_file.name,
240                  True,
241                  False,
242                  None,
243                  None,
244                  None,
245                  self._open("bootloader_signed_v2.bin"),
246              )
247              espsecure.sign_data(args)
248              args = self.VerifyArgs(
249                  "2",
250                  False,
251                  None,
252                  self._open("rsa_secure_boot_signing_key.pem"),
253                  output_file,
254              )
255              espsecure.verify_signature(args)
256              output_file.seek(0)
257              args = self.VerifyArgs(
258                  "2",
259                  False,
260                  None,
261                  self._open("rsa_secure_boot_signing_key2.pem"),
262                  output_file,
263              )
264              espsecure.verify_signature(args)
265              output_file.seek(0)
266              args = self.VerifyArgs(
267                  "2",
268                  False,
269                  None,
270                  self._open("rsa_secure_boot_signing_key3.pem"),
271                  output_file,
272              )
273              espsecure.verify_signature(args)
274          finally:
275              output_file.close()
276              os.unlink(output_file.name)
277      def test_sign_v2_append_signatures_multiple_steps(self):
278          try:
279              output_file1 = tempfile.NamedTemporaryFile(delete=False)
280              output_file2 = tempfile.NamedTemporaryFile(delete=False)
281              args = self.SignArgs(
282                  "2",
283                  [self._open("rsa_secure_boot_signing_key2.pem")],
284                  output_file1.name,
285                  True,
286                  False,
287                  None,
288                  None,
289                  None,
290                  self._open("bootloader_signed_v2.bin"),
291              )
292              espsecure.sign_data(args)
293              args = self.SignArgs(
294                  "2",
295                  [self._open("rsa_secure_boot_signing_key3.pem")],
296                  output_file2.name,
297                  True,
298                  False,
299                  None,
300                  None,
301                  None,
302                  output_file1,
303              )
304              espsecure.sign_data(args)
305              args = self.VerifyArgs(
306                  "2",
307                  False,
308                  None,
309                  self._open("rsa_secure_boot_signing_key.pem"),
310                  output_file2,
311              )
312              espsecure.verify_signature(args)
313              output_file2.seek(0)
314              args = self.VerifyArgs(
315                  "2",
316                  False,
317                  None,
318                  self._open("rsa_secure_boot_signing_key2.pem"),
319                  output_file2,
320              )
321              espsecure.verify_signature(args)
322              output_file2.seek(0)
323              args = self.VerifyArgs(
324                  "2",
325                  False,
326                  None,
327                  self._open("rsa_secure_boot_signing_key3.pem"),
328                  output_file2,
329              )
330              espsecure.verify_signature(args)
331          finally:
332              output_file1.close()
333              os.unlink(output_file1.name)
334              output_file2.close()
335              os.unlink(output_file2.name)
336      def test_sign_v2_with_pre_calculated_signature(self):
337          signing_keys = [
338              "rsa_secure_boot_signing_pubkey.pem",
339              "ecdsa192_secure_boot_signing_pubkey.pem",
340              "ecdsa_secure_boot_signing_pubkey.pem",
341          ]
342          pre_calculated_signatures = [
343              "pre_calculated_bootloader_signature_rsa.bin",
344              "pre_calculated_bootloader_signature_ecdsa192.bin",
345              "pre_calculated_bootloader_signature_ecdsa256.bin",
346          ]
347          for pub_key, signature in zip(signing_keys, pre_calculated_signatures):
348              try:
349                  output_file = tempfile.NamedTemporaryFile(delete=False)
350                  args = self.SignArgs(
351                      "2",
352                      None,
<span onclick='openModal()' class='match'>353                      output_file.name,
354                      False,
355                      False,
356                      None,
357                      [self._open(pub_key)],
358                      [self._open(signature)],
359                      self._open("bootloader_unsigned_v2.bin"),
360                  )
361                  espsecure.sign_data(args)
</span>362                  args = self.VerifyArgs(
363                      "2", False, None, self._open(pub_key), output_file
364                  )
365                  espsecure.verify_signature(args)
366              finally:
367                  output_file.close()
368                  os.unlink(output_file.name)
369      def test_sign_v2_with_multiple_pre_calculated_signatures(self):
370          signing_pubkeys = [
371              "rsa_secure_boot_signing_pubkey.pem",
372              "rsa_secure_boot_signing_pubkey.pem",
373              "rsa_secure_boot_signing_pubkey.pem",
374          ]
375          pre_calculated_signatures = [
376              "pre_calculated_bootloader_signature_rsa.bin",
377              "pre_calculated_bootloader_signature_rsa.bin",
378              "pre_calculated_bootloader_signature_rsa.bin",
379          ]
380          try:
381              output_file = tempfile.NamedTemporaryFile(delete=False)
382              args = self.SignArgs(
383                  "2",
384                  None,
385                  output_file.name,
386                  False,
387                  False,
388                  None,
389                  [self._open(pub_key) for pub_key in signing_pubkeys],
390                  [self._open(signature) for signature in pre_calculated_signatures],
391                  self._open("bootloader_unsigned_v2.bin"),
392              )
393              espsecure.sign_data(args)
394              args = self.VerifyArgs(
395                  "2", False, None, self._open(signing_pubkeys[0]), output_file
396              )
397              espsecure.verify_signature(args)
398          finally:
399              output_file.close()
400              os.unlink(output_file.name)
401      def test_verify_signature_signing_key(self):
402          args = self.VerifyArgs(
403              "1",
404              False,
405              None,
406              self._open("ecdsa_secure_boot_signing_key.pem"),
407              self._open("bootloader_signed.bin"),
408          )
409          espsecure.verify_signature(args)
410          args = self.VerifyArgs(
411              "2",
412              False,
413              None,
414              self._open("rsa_secure_boot_signing_key.pem"),
415              self._open("bootloader_signed_v2.bin"),
416          )
417          espsecure.verify_signature(args)
418          args = self.VerifyArgs(
419              "2",
420              False,
421              None,
422              self._open("ecdsa_secure_boot_signing_key.pem"),
423              self._open("bootloader_signed_v2_ecdsa256.bin"),
424          )
425          espsecure.verify_signature(args)
426          args = self.VerifyArgs(
427              "2",
428              False,
429              None,
430              self._open("ecdsa192_secure_boot_signing_key.pem"),
431              self._open("bootloader_signed_v2_ecdsa192.bin"),
432          )
433          espsecure.verify_signature(args)
434          args = self.VerifyArgs(
435              "1",
436              False,
437              None,
438              self._open("ecdsa_secure_boot_signing_key2.pem"),
439              self._open("bootloader_signed.bin"),
440          )
441          with pytest.raises(esptool.FatalError) as cm:
442              espsecure.verify_signature(args)
443          assert "Signature is not valid" in str(cm.value)
444          args = self.VerifyArgs(
445              "2",
446              False,
447              None,
448              self._open("rsa_secure_boot_signing_key2.pem"),
449              self._open("bootloader_signed_v2.bin"),
450          )
451          with pytest.raises(esptool.FatalError) as cm:
452              espsecure.verify_signature(args)
453          assert "Signature could not be verified with the provided key." in str(cm.value)
454          args = self.VerifyArgs(
455              "2",
456              False,
457              None,
458              self._open("ecdsa_secure_boot_signing_key.pem"),
459              self._open("bootloader_signed.bin"),
460          )
461          with pytest.raises(esptool.FatalError) as cm:
462              espsecure.verify_signature(args)
463          assert "Invalid datafile" in str(cm.value)
464          args = self.VerifyArgs(
465              "2",
466              False,
467              None,
468              self._open("ecdsa_secure_boot_signing_key2.pem"),
469              self._open("bootloader_signed_v2_ecdsa256.bin"),
470          )
471          with pytest.raises(esptool.FatalError) as cm:
472              espsecure.verify_signature(args)
473          assert "Signature could not be verified with the provided key." in str(cm.value)
474          args = self.VerifyArgs(
475              "2",
476              False,
477              None,
478              self._open("ecdsa192_secure_boot_signing_key2.pem"),
479              self._open("bootloader_signed_v2_ecdsa192.bin"),
480          )
481          with pytest.raises(esptool.FatalError) as cm:
482              espsecure.verify_signature(args)
483          assert "Signature could not be verified with the provided key." in str(cm.value)
484          args = self.VerifyArgs(
485              "2",
486              False,
487              None,
488              self._open("rsa_secure_boot_signing_key4.pem"),
489              self._open("bootloader_multi_signed_v2.bin"),
490          )
491          with pytest.raises(esptool.FatalError) as cm:
492              espsecure.verify_signature(args)
493          assert "Signature could not be verified with the provided key." in str(cm.value)
494      def test_verify_signature_public_key(self):
495          args = self.VerifyArgs(
496              "1",
497              False,
498              None,
499              self._open("ecdsa_secure_boot_signing_pubkey.pem"),
500              self._open("bootloader_signed.bin"),
501          )
502          espsecure.verify_signature(args)
503          args = self.VerifyArgs(
504              "2",
505              False,
506              None,
507              self._open("rsa_secure_boot_signing_pubkey.pem"),
508              self._open("bootloader_signed_v2.bin"),
509          )
510          espsecure.verify_signature(args)
511          args = self.VerifyArgs(
512              "2",
513              False,
514              None,
515              self._open("ecdsa_secure_boot_signing_pubkey.pem"),
516              self._open("bootloader_signed_v2_ecdsa256.bin"),
517          )
518          espsecure.verify_signature(args)
519          args = self.VerifyArgs(
520              "2",
521              False,
522              None,
523              self._open("ecdsa192_secure_boot_signing_pubkey.pem"),
524              self._open("bootloader_signed_v2_ecdsa192.bin"),
525          )
526          espsecure.verify_signature(args)
527          args = self.VerifyArgs(
528              "1",
529              False,
530              None,
531              self._open("ecdsa_secure_boot_signing_pubkey2.pem"),
532              self._open("bootloader_signed.bin"),
533          )
534          with pytest.raises(esptool.FatalError) as cm:
535              espsecure.verify_signature(args)
536          assert "Signature is not valid" in str(cm.value)
537          args = self.VerifyArgs(
538              "2",
539              False,
540              None,
541              self._open("rsa_secure_boot_signing_pubkey2.pem"),
542              self._open("bootloader_signed_v2.bin"),
543          )
544          with pytest.raises(esptool.FatalError) as cm:
545              espsecure.verify_signature(args)
546          assert "Signature could not be verified with the provided key." in str(cm.value)
547          args = self.VerifyArgs(
548              "2",
549              False,
550              None,
551              self._open("ecdsa_secure_boot_signing_pubkey2.pem"),
552              self._open("bootloader_signed_v2_ecdsa256.bin"),
553          )
554          with pytest.raises(esptool.FatalError) as cm:
555              espsecure.verify_signature(args)
556          assert "Signature could not be verified with the provided key." in str(cm.value)
557          args = self.VerifyArgs(
558              "2",
559              False,
560              None,
561              self._open("ecdsa192_secure_boot_signing_pubkey2.pem"),
562              self._open("bootloader_signed_v2_ecdsa192.bin"),
563          )
564          with pytest.raises(esptool.FatalError) as cm:
565              espsecure.verify_signature(args)
566          assert "Signature could not be verified with the provided key." in str(cm.value)
567          args = self.VerifyArgs(
568              "2",
569              False,
570              None,
571              self._open("rsa_secure_boot_signing_pubkey4.pem"),
572              self._open("bootloader_multi_signed_v2.bin"),
573          )
574          with pytest.raises(esptool.FatalError) as cm:
575              espsecure.verify_signature(args)
576          assert "Signature could not be verified with the provided key." in str(cm.value)
577      def test_extract_binary_public_key(self):
578          with tempfile.NamedTemporaryFile() as pub_keyfile, tempfile.NamedTemporaryFile() as pub_keyfile2:  # noqa E501
579              args = self.ExtractKeyArgs(
580                  "1", self._open("ecdsa_secure_boot_signing_key.pem"), pub_keyfile
581              )
582              espsecure.extract_public_key(args)
583              args = self.ExtractKeyArgs(
584                  "1", self._open("ecdsa_secure_boot_signing_key2.pem"), pub_keyfile2
585              )
586              espsecure.extract_public_key(args)
587              pub_keyfile.seek(0)
588              pub_keyfile2.seek(0)
589              args = self.VerifyArgs(
590                  "1", False, None, pub_keyfile, self._open("bootloader_signed.bin")
591              )
592              espsecure.verify_signature(args)
593              args = self.VerifyArgs(
594                  "1", False, None, pub_keyfile2, self._open("bootloader_signed.bin")
595              )
596              with pytest.raises(esptool.FatalError) as cm:
597                  espsecure.verify_signature(args)
598              assert "Signature is not valid" in str(cm.value)
599      def test_generate_and_extract_key_v2(self):
600          with tempfile.TemporaryDirectory() as keydir:
601              keyfile_name = os.path.join(keydir, "key.pem")
602              for scheme in ["rsa3072", "ecdsa192", "ecdsa256"]:
603                  args = self.GenerateKeyArgs("2", scheme, keyfile_name)
604                  espsecure.generate_signing_key(args)
605                  with tempfile.NamedTemporaryFile() as pub_keyfile, open(
606                      keyfile_name, "rb"
607                  ) as keyfile:
608                      args = self.ExtractKeyArgs("2", keyfile, pub_keyfile)
609                      espsecure.extract_public_key(args)
610                  os.remove(keyfile_name)
611  class TestFlashEncryption(EspSecureTestCase):
612      EncryptArgs = namedtuple(
613          "encrypt_flash_data_args",
614          [
615              "keyfile",
616              "output",
617              "address",
618              "flash_crypt_conf",
619              "aes_xts",
620              "plaintext_file",
621          ],
622      )
623      DecryptArgs = namedtuple(
624          "decrypt_flash_data_args",
625          [
626              "keyfile",
627              "output",
628              "address",
629              "flash_crypt_conf",
630              "aes_xts",
631              "encrypted_file",
632          ],
633      )
634      def _test_encrypt_decrypt(
635          self,
636          input_plaintext,
637          expected_ciphertext,
638          key_path,
639          offset,
640          flash_crypt_conf=0xF,
641          aes_xts=None,
642      ):
643          original_plaintext = self._open(input_plaintext)
644          keyfile = self._open(key_path)
645          ciphertext = io.BytesIO()
646          args = self.EncryptArgs(
647              keyfile, ciphertext, offset, flash_crypt_conf, aes_xts, original_plaintext
648          )
649          espsecure.encrypt_flash_data(args)
650          original_plaintext.seek(0)
651          assert original_plaintext.read() != ciphertext.getvalue()
652          with self._open(expected_ciphertext) as f:
653              assert f.read() == ciphertext.getvalue()
654          ciphertext.seek(0)
655          keyfile.seek(0)
656          plaintext = io.BytesIO()
657          args = self.DecryptArgs(
658              keyfile, plaintext, offset, flash_crypt_conf, aes_xts, ciphertext
659          )
660          espsecure.decrypt_flash_data(args)
661          original_plaintext.seek(0)
662          assert original_plaintext.read() == plaintext.getvalue()
663  class TestESP32FlashEncryption(TestFlashEncryption):
664      def test_encrypt_decrypt_bootloader(self):
665          self._test_encrypt_decrypt(
666              "bootloader.bin", "bootloader-encrypted.bin", "256bit_key.bin", 0x1000, 0xF
667          )
668      def test_encrypt_decrypt_app(self):
669          self._test_encrypt_decrypt(
670              "hello-world-signed.bin",
671              "hello-world-signed-encrypted.bin",
672              "ef-flashencryption-key.bin",
673              0x20000,
674              0xF,
675          )
676      def test_encrypt_decrypt_non_default_conf(self):
677          for conf in [0x0, 0x3, 0x9, 0xC]:
678              self._test_encrypt_decrypt(
679                  "bootloader.bin",
680                  f"bootloader-encrypted-conf{conf:x}.bin",
681                  "256bit_key.bin",
682                  0x1000,
683                  conf,
684              )
685  class TestAesXtsFlashEncryption(TestFlashEncryption):
686      def test_encrypt_decrypt_bootloader(self):
687          self._test_encrypt_decrypt(
688              "bootloader.bin",
689              "bootloader-encrypted-aes-xts.bin",
690              "256bit_key.bin",
691              0x1000,
692              aes_xts=True,
693          )
694      def test_encrypt_decrypt_app(self):
695          self._test_encrypt_decrypt(
696              "hello-world-signed.bin",
697              "hello-world-signed-encrypted-aes-xts.bin",
698              "ef-flashencryption-key.bin",
699              0x20000,
700              aes_xts=True,
701          )
702      def test_encrypt_decrypt_app_512_bit_key(self):
703          self._test_encrypt_decrypt(
704              "hello-world-signed.bin",
705              "hello-world-signed-encrypted-aes-xts-256.bin",
706              "512bit_key.bin",
707              0x10000,
708              aes_xts=True,
709          )
710      def test_padding(self):
711          plaintext = binascii.unhexlify(
712              "c33b7c49f12a969a9bb45af5f660b73f"
713              "3b372685012da570df1cf99d1a82eabb"
714              "fdf6aa16b9675bd8a2f95e871513e175"
715              "3bc89f57986ecfb2707a3d3b59a46968"
716              "5e6609d2e9c21d4b2310571175e6e3de"
717              "2656ee22243f557b925ef39ff782ab56"
718              "f821e6859ee852000daae7c03a7c77ce"
719              "58744f15fbdf0ad4ae6e964aedd6316a"
720              "cf0e36935eef895cd14a60fe682fb971"
721              "eb239eae38b770bdf969017c9decfd91"
722              "b7c60329fb0c896684f0e7415f99dec1"
723              "da0572fac360a3e6d7219973a7de07e5"
724              "33b5abfdf5917ed5bfe54d660a6f5047"
725              "32fdb8d07259bfcdc67da87293857c11"
726              "427b2bae5f00da4a4b2b00b588ff5109"
727              "4c41f07f02f680f8826841b43da3f25b"
728          )
729          plaintext_file = io.BytesIO(plaintext)
730          ciphertext_full_block = io.BytesIO()
731          keyfile = self._open("256bit_key.bin")
732          address = 0x1000
733          encrypt_args_padded = self.EncryptArgs(
734              keyfile, ciphertext_full_block, address, None, "aes_xts", plaintext_file
735          )
736          espsecure.encrypt_flash_data(encrypt_args_padded)
737          bytes_per_encrypt = [16, 32, 64, 128]
738          for b in bytes_per_encrypt:
739              ciphertext = io.BytesIO()
740              num_enc_calls = len(plaintext) // b
741              for i in range(0, num_enc_calls):
742                  keyfile.seek(0)
743                  offset = b * i
744                  plaintext_sub = io.BytesIO(plaintext[offset : offset + b])
745                  encrypt_args = self.EncryptArgs(
746                      keyfile,
747                      ciphertext,
748                      address + offset,
749                      None,
750                      "aes_xts",
751                      plaintext_sub,
752                  )
753                  espsecure.encrypt_flash_data(encrypt_args)
754              assert ciphertext_full_block.getvalue() == ciphertext.getvalue()
755  class TestDigest(EspSecureTestCase):
756      def test_digest_private_key(self):
757          with tempfile.NamedTemporaryFile() as f:
758              outfile_name = f.name
759          self.run_espsecure(
760              "digest_private_key "
761              "--keyfile secure_images/ecdsa_secure_boot_signing_key.pem "
762              f"{outfile_name}"
763          )
764          with open(outfile_name, "rb") as f:
765              assert f.read() == binascii.unhexlify(
766                  "7b7b53708fc89d5e0b2df2571fb8f9d778f61a422ff1101a22159c4b34aad0aa"
767              )
768      def test_digest_private_key_with_invalid_output(self, capsys):
769          fname = "secure_images/ecdsa_secure_boot_signing_key.pem"
770          with pytest.raises(subprocess.CalledProcessError):
771              self.run_espsecure(f"digest_private_key --keyfile {fname} {fname}")
772          output = capsys.readouterr().out
773          assert "should not be the same!" in output
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-stickertools.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espsecure.py</div>
                </div>
                <div class="column column_space"><pre><code>237                      if x.text in ["Invalid pack selected.", "Invalid set selected."]:
238                          await conv.send_message(cmd)
239                          await conv.get_response()
240                          await conv.send_message(packnick)
241                          await conv.get_response()
</pre></code></div>
                <div class="column column_space"><pre><code>353                      output_file.name,
354                      False,
355                      False,
356                      None,
357                      [self._open(pub_key)],
358                      [self._open(signature)],
359                      self._open("bootloader_unsigned_v2.bin"),
360                  )
361                  espsecure.sign_data(args)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    