
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-tools.py</h3>
            <pre><code>1  import json
2  import math
3  import os
4  import random
5  import re
6  import secrets
7  import ssl
8  from io import BytesIO
9  from json.decoder import JSONDecodeError
10  from traceback import format_exc
11  import requests
12  from .. import *
13  from ..exceptions import DependencyMissingError
14  from . import some_random_headers
15  from .helper import async_searcher, bash, run_async
16  try:
17      import certifi
18  except ImportError:
19      certifi = None
20  try:
21      from PIL import Image, ImageDraw, ImageFont
22  except ImportError:
23      Image, ImageDraw, ImageFont = None, None, None
24      LOGS.info("PIL not installed!")
25  from urllib.parse import quote, unquote
26  from telethon import Button
27  from telethon.tl.types import DocumentAttributeAudio, DocumentAttributeVideo
28  if run_as_module:
29      from ..dB.filestore_db import get_stored_msg, store_msg
30  try:
31      import numpy as np
32  except ImportError:
33      np = None
34  try:
35      from telegraph import Telegraph
36  except ImportError:
37      Telegraph = None
38  try:
39      from bs4 import BeautifulSoup
40  except ImportError:
41      BeautifulSoup = None
42  async def get_ofox(codename):
43      ofox_baseurl = "https://api.orangefox.download/v3/"
44      releases = await async_searcher(
45          ofox_baseurl + "releases?codename=" + codename, re_json=True
46      )
47      device = await async_searcher(
48          ofox_baseurl + "devices/get?codename=" + codename, re_json=True
49      )
50      return device, releases
51  def _unquote_text(text):
52      return text.replace("'", unquote("%5C%27")).replace('"', unquote("%5C%22"))
53  def json_parser(data, indent=None, ascii=False):
54      parsed = {}
55      try:
56          if isinstance(data, str):
57              parsed = json.loads(str(data))
58              if indent:
59                  parsed = json.dumps(
60                      json.loads(str(data)), indent=indent, ensure_ascii=ascii
61                  )
62          elif isinstance(data, dict):
63              parsed = data
64              if indent:
65                  parsed = json.dumps(data, indent=indent, ensure_ascii=ascii)
66      except JSONDecodeError:
67          parsed = eval(data)
68      return parsed
69  async def is_url_ok(url: str):
70      try:
71          return await async_searcher(url, head=True)
72      except BaseException as er:
73          LOGS.debug(er)
74          return False
75  async def metadata(file):
76      out, _ = await bash(f'mediainfo "{_unquote_text(file)}" --Output=JSON')
77      if _ and _.endswith("NOT_FOUND"):
78          raise DependencyMissingError(
79              f"'{_}' is not installed!\nInstall it to use this command."
80          )
81      data = {}
82      _info = json.loads(out)["media"]["track"]
83      info = _info[0]
84      if info.get("Format") in ["GIF", "PNG"]:
85          return {
86              "height": _info[1]["Height"],
87              "width": _info[1]["Width"],
88              "bitrate": _info[1].get("BitRate", 320),
89          }
90      if info.get("AudioCount"):
91          data["title"] = info.get("Title", file)
92          data["performer"] = info.get("Performer") or udB.get_key("artist") or ""
93      if info.get("VideoCount"):
94          data["height"] = int(float(_info[1].get("Height", 720)))
95          data["width"] = int(float(_info[1].get("Width", 1280)))
96          data["bitrate"] = int(_info[1].get("BitRate", 320))
97      data["duration"] = int(float(info.get("Duration", 0)))
98      return data
99  async def set_attributes(file):
100      data = await metadata(file)
101      if not data:
102          return None
103      if "width" in data:
104          return [
105              DocumentAttributeVideo(
106                  duration=data.get("duration", 0),
107                  w=data.get("width", 512),
108                  h=data.get("height", 512),
109                  supports_streaming=True,
110              )
111          ]
112      ext = "." + file.split(".")[-1]
113      return [
114          DocumentAttributeAudio(
115              duration=data.get("duration", 0),
116              title=data.get("title", file.split("/")[-1].replace(ext, "")),
117              performer=data.get("performer"),
118          )
119      ]
120  def get_msg_button(texts: str):
121      btn = []
122      for z in re.findall("\\[(.*?)\\|(.*?)\\]", texts):
123          text, url = z
124          urls = url.split("|")
125          url = urls[0]
126          if len(urls) > 1:
127              btn[-1].append([text, url])
128          else:
129              btn.append([[text, url]])
130      txt = texts
131      for z in re.findall("\\[.+?\\|.+?\\]", texts):
132          txt = txt.replace(z, "")
133      return txt.strip(), btn
134  def create_tl_btn(button: list):
135      btn = []
136      for z in button:
137          if len(z) > 1:
138              kk = [Button.url(x, y.strip()) for x, y in z]
139              btn.append(kk)
140          else:
141              btn.append([Button.url(z[0][0], z[0][1].strip())])
142      return btn
143  def format_btn(buttons: list):
144      txt = ""
145      for i in buttons:
146          a = 0
147          for i in i:
148              if hasattr(i.button, "url"):
149                  a += 1
150                  if a > 1:
151                      txt += f"[{i.button.text} | {i.button.url} | same]"
152                  else:
153                      txt += f"[{i.button.text} | {i.button.url}]"
154      _, btn = get_msg_button(txt)
155      return btn
156  async def saavn_search(query: str):
157      try:
158          data = await async_searcher(
159              url=f"https://saavn-api.vercel.app/search/{query.replace(' ', '%20')}",
160              re_json=True,
161          )
162      except BaseException:
163          data = None
164      return data
165  _webupload_cache = {}
166  async def webuploader(chat_id: int, msg_id: int, uploader: str):
<span onclick='openModal()' class='match'>167      file = _webupload_cache[int(chat_id)][int(msg_id)]
168      sites = {
</span>169          "anonfiles": {"url": "https://api.anonfiles.com/upload", "json": True},
170          "siasky": {"url": "https://siasky.net/skynet/skyfile", "json": True},
171          "file.io": {"url": "https://file.io", "json": True},
172          "bayfiles": {"url": "https://api.bayfiles.com/upload", "json": True},
173          "x0.at": {"url": "https://x0.at/", "json": False},
174          "transfer": {"url": "https://transfer.sh", "json": False},
175      }
176      if uploader and uploader in sites:
177          url = sites[uploader]["url"]
178          json = sites[uploader]["json"]
179      with open(file, "rb") as data:
180          status = await async_searcher(
181              url, data={"file": data.read()}, post=True, re_json=json
182          )
183      if isinstance(status, dict):
184          if "skylink" in status:
185              return f"https://siasky.net/{status['skylink']}"
186          if status["status"] == 200 or status["status"] is True:
187              try:
188                  link = status["link"]
189              except KeyError:
190                  link = status["data"]["file"]["url"]["short"]
191              return link
192      del _webupload_cache[int(chat_id)][int(msg_id)]
193      return status
194  def get_all_files(path, extension=None):
195      filelist = []
196      for root, dirs, files in os.walk(path):
197          for file in files:
198              if not (extension and not file.endswith(extension)):
199                  filelist.append(os.path.join(root, file))
200      return sorted(filelist)
201  def text_set(text):
202      lines = []
203      if len(text) <= 55:
204          lines.append(text)
205      else:
206          all_lines = text.split("\n")
207          for line in all_lines:
208              if len(line) <= 55:
209                  lines.append(line)
210              else:
211                  k = len(line) // 55
212                  for z in range(1, k + 2):
213                      lines.append(line[((z - 1) * 55) : (z * 55)])
214      return lines[:25]
215  class LogoHelper:
216      @staticmethod
217      def get_text_size(text, image, font):
218          im = Image.new("RGB", (image.width, image.height))
219          draw = ImageDraw.Draw(im)
220          return draw.textsize(text, font)
221      @staticmethod
222      def find_font_size(text, font, image, target_width_ratio):
223          tested_font_size = 100
224          tested_font = ImageFont.truetype(font, tested_font_size)
225          observed_width, observed_height = LogoHelper.get_text_size(
226              text, image, tested_font
227          )
228          estimated_font_size = (
229              tested_font_size / (observed_width / image.width) * target_width_ratio
230          )
231          return round(estimated_font_size)
232      @staticmethod
233      def make_logo(imgpath, text, funt, **args):
234          fill = args.get("fill")
235          width_ratio = args.get("width_ratio") or 0.7
236          stroke_width = int(args.get("stroke_width"))
237          stroke_fill = args.get("stroke_fill")
238          img = Image.open(imgpath)
239          width, height = img.size
240          draw = ImageDraw.Draw(img)
241          font_size = LogoHelper.find_font_size(text, funt, img, width_ratio)
242          font = ImageFont.truetype(funt, font_size)
243          w, h = draw.textsize(text, font=font)
244          draw.text(
245              ((width - w) / 2, (height - h) / 2),
246              text,
247              font=font,
248              fill=fill,
249              stroke_width=stroke_width,
250              stroke_fill=stroke_fill,
251          )
252          file_name = check_filename("logo.png")
253          img.save(file_name, "PNG")
254          return file_name
255  async def get_paste(data: str, extension: str = "txt"):
256      ssl_context = ssl.create_default_context(cafile=certifi.where())
257      json = {"content": data, "extension": extension}
258      key = await async_searcher(
259          url="https://spaceb.in/api/v1/documents/",
260          json=json,
261          ssl=ssl_context,
262          post=True,
263          re_json=True,
264      )
265      try:
266          return True, key["payload"]["id"]
267      except KeyError:
268          if "the length must be between 2 and 400000." in key["error"]:
269              return await get_paste(data[-400000:], extension=extension)
270          return False, key["error"]
271      except Exception as e:
272          LOGS.info(e)
273          return None, str(e)
274  async def get_google_images(query):
275      soup = BeautifulSoup(
276          await async_searcher(
277              "https://google.com/search",
278              params={"q": query, "tbm": "isch"},
279              headers={"User-Agent": random.choice(some_random_headers)},
280          ),
281          "lxml",
282      )
283      google_images = []
284      all_script_tags = soup.select("script")
285      matched_images_data = "".join(
286          re.findall(r"AF_initDataCallback\(([^<]+)\);", str(all_script_tags))
287      )
288      matched_images_data_fix = json.dumps(matched_images_data)
289      matched_images_data_json = json.loads(matched_images_data_fix)
290      matched_google_image_data = re.findall(
291          r"\"b-GRID_STATE0\"(.*)sideChannel:\s?{}}", matched_images_data_json
292      )
293      matched_google_images_thumbnails = ", ".join(
294          re.findall(
295              r"\[\"(https\:\/\/encrypted-tbn0\.gstatic\.com\/images\?.*?)\",\d+,\d+\]",
296              str(matched_google_image_data),
297          )
298      ).split(", ")
299      thumbnails = [
300          bytes(bytes(thumbnail, "ascii").decode("unicode-escape"), "ascii").decode(
301              "unicode-escape"
302          )
303          for thumbnail in matched_google_images_thumbnails
304      ]
305      removed_matched_google_images_thumbnails = re.sub(
306          r"\[\"(https\:\/\/encrypted-tbn0\.gstatic\.com\/images\?.*?)\",\d+,\d+\]",
307          "",
308          str(matched_google_image_data),
309      )
310      matched_google_full_resolution_images = re.findall(
311          r"(?:'|,),\[\"(https:|http.*?)\",\d+,\d+\]",
312          removed_matched_google_images_thumbnails,
313      )
314      full_res_images = [
315          bytes(bytes(img, "ascii").decode("unicode-escape"), "ascii").decode(
316              "unicode-escape"
317          )
318          for img in matched_google_full_resolution_images
319      ]
320      for index, (metadata, thumbnail, original) in enumerate(
321          zip(soup.select(".isv-r.PNCib.MSM1fd.BUooTd"), thumbnails, full_res_images),
322          start=1,
323      ):
324          google_images.append(
325              {
326                  "title": metadata.select_one(".VFACy.kGQAp.sMi44c.lNHeqe.WGvvNb")[
327                      "title"
328                  ],
329                  "link": metadata.select_one(".VFACy.kGQAp.sMi44c.lNHeqe.WGvvNb")[
330                      "href"
331                  ],
332                  "source": metadata.select_one(".fxgdke").text,
333                  "thumbnail": thumbnail,
334                  "original": original,
335              }
336          )
337      random.shuffle(google_images)
338      return google_images
339  async def get_chatbot_reply(message):
340      chatbot_base = "https://kuki-api-lac.vercel.app/message={}"
341      req_link = chatbot_base.format(
342          message,
343      )
344      try:
345          return (await async_searcher(req_link, re_json=True)).get("reply")
346      except Exception:
347          LOGS.info(f"**ERROR:**`{format_exc()}`")
348  def check_filename(filroid):
349      if os.path.exists(filroid):
350          no = 1
351          while True:
352              ult = "{0}_{2}{1}".format(*os.path.splitext(filroid) + (no,))
353              if os.path.exists(ult):
354                  no += 1
355              else:
356                  return ult
357      return filroid
358  async def genss(file):
359      return (await metadata(file)).get("duration")
360  async def duration_s(file, stime):
361      tsec = await genss(file)
362      x = round(tsec / 5)
363      y = round(tsec / 5 + int(stime))
364      pin = stdr(x)
365      pon = stdr(y) if y < tsec else stdr(tsec)
366      return pin, pon
367  def stdr(seconds):
368      minutes, seconds = divmod(seconds, 60)
369      hours, minutes = divmod(minutes, 60)
370      if len(str(minutes)) == 1:
371          minutes = "0" + str(minutes)
372      if len(str(hours)) == 1:
373          hours = "0" + str(hours)
374      if len(str(seconds)) == 1:
375          seconds = "0" + str(seconds)
376      return (
377          ((str(hours) + ":") if hours else "00:")
378          + ((str(minutes) + ":") if minutes else "00:")
379          + ((str(seconds)) if seconds else "")
380      )
381  def order_points(pts):
382      "get the required points"
383      rect = np.zeros((4, 2), dtype="float32")
384      s = pts.sum(axis=1)
385      rect[0] = pts[np.argmin(s)]
386      rect[2] = pts[np.argmax(s)]
387      diff = np.diff(pts, axis=1)
388      rect[1] = pts[np.argmin(diff)]
389      rect[3] = pts[np.argmax(diff)]
390      return rect
391  def four_point_transform(image, pts):
392      try:
393          import cv2
394      except ImportError:
395          raise DependencyMissingError("This function needs 'cv2' to be installed.")
396      rect = order_points(pts)
397      (tl, tr, br, bl) = rect
398      widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
399      widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
400      maxWidth = max(int(widthA), int(widthB))
401      heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
402      heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
403      maxHeight = max(int(heightA), int(heightB))
404      dst = np.array(
405          [[0, 0], [maxWidth - 1, 0], [maxWidth - 1, maxHeight - 1], [0, maxHeight - 1]],
406          dtype="float32",
407      )
408      M = cv2.getPerspectiveTransform(rect, dst)
409      return cv2.warpPerspective(image, M, (maxWidth, maxHeight))
410  TELEGRAPH = []
411  def telegraph_client():
412      if not Telegraph:
413          LOGS.info("'Telegraph' is not Installed!")
414          return
415      if TELEGRAPH:
416          return TELEGRAPH[0]
417      from .. import udB, ultroid_bot
418      token = udB.get_key("_TELEGRAPH_TOKEN")
419      TelegraphClient = Telegraph(token)
420      if token:
421          TELEGRAPH.append(TelegraphClient)
422          return TelegraphClient
423      gd_name = ultroid_bot.full_name
424      short_name = gd_name[:30]
425      profile_url = (
426          f"https://t.me/{ultroid_bot.me.username}"
427          if ultroid_bot.me.username
428          else "https://t.me/TeamUltroid"
429      )
430      try:
431          TelegraphClient.create_account(
432              short_name=short_name, author_name=gd_name, author_url=profile_url
433          )
434      except Exception as er:
435          if "SHORT_NAME_TOO_LONG" in str(er):
436              TelegraphClient.create_account(
437                  short_name="ultroiduser", author_name=gd_name, author_url=profile_url
438              )
439          else:
440              LOGS.exception(er)
441              return
442      udB.set_key("_TELEGRAPH_TOKEN", TelegraphClient.get_access_token())
443      TELEGRAPH.append(TelegraphClient)
444      return TelegraphClient
445  @run_async
446  def make_html_telegraph(title, html=""):
447      telegraph = telegraph_client()
448      page = telegraph.create_page(
449          title=title,
450          html_content=html,
451      )
452      return page["url"]
453  async def Carbon(
454      code,
455      base_url="https://carbonara.solopov.dev/api/cook",
456      file_name="ultroid",
457      download=False,
458      rayso=False,
459      **kwargs,
460  ):
461      if rayso:
462          base_url = "https://rayso-api-desvhu-33.koyeb.app/generate"
463          kwargs["text"] = code
464          kwargs["theme"] = kwargs.get("theme", "breeze")
465          kwargs["darkMode"] = kwargs.get("darkMode", True)
466          kwargs["title"] = kwargs.get("title", "Ultroid")
467      else:
468          kwargs["code"] = code
469      con = await async_searcher(base_url, post=True, json=kwargs, re_content=True)
470      if not download:
471          file = BytesIO(con)
472          file.name = file_name + ".jpg"
473      else:
474          try:
475              return json_parser(con.decode())
476          except Exception:
477              pass
478          file = file_name + ".jpg"
479          with open(file, "wb") as f:
480              f.write(con)
481      return file
482  async def get_file_link(msg):
483      from .. import udB
484      msg_id = await msg.forward_to(udB.get_key("LOG_CHANNEL"))
485      await msg_id.reply(
486          "**Message has been stored to generate a shareable link. Do not delete it.**"
487      )
488      msg_id = msg_id.id
489      msg_hash = secrets.token_hex(nbytes=8)
490      store_msg(msg_hash, msg_id)
491      return msg_hash
492  async def get_stored_file(event, hash):
493      from .. import udB
494      msg_id = get_stored_msg(hash)
495      if not msg_id:
496          return
497      try:
498          msg = await asst.get_messages(udB.get_key("LOG_CHANNEL"), ids=msg_id)
499      except Exception as er:
500          LOGS.warning(f"FileStore, Error: {er}")
501          return
502      if not msg_id:
503          return await asst.send_message(
504              event.chat_id, "__Message was deleted by owner!__", reply_to=event.id
505          )
506      await asst.send_message(event.chat_id, msg.text, file=msg.media, reply_to=event.id)
507  def _package_rpc(text, lang_src="auto", lang_tgt="auto"):
508      GOOGLE_TTS_RPC = ["MkEWBc"]
509      parameter = [[text.strip(), lang_src, lang_tgt, True], [1]]
510      escaped_parameter = json.dumps(parameter, separators=(",", ":"))
511      rpc = [[[random.choice(GOOGLE_TTS_RPC), escaped_parameter, None, "generic"]]]
512      espaced_rpc = json.dumps(rpc, separators=(",", ":"))
513      freq = "f.req={}&".format(quote(espaced_rpc))
514      return freq
515  def translate(*args, **kwargs):
516      headers = {
517          "Referer": "https://translate.google.co.in",
518          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) "
519          "AppleWebKit/537.36 (KHTML, like Gecko) "
520          "Chrome/47.0.2526.106 Safari/537.36",
521          "Content-Type": "application/x-www-form-urlencoded;charset=utf-8",
522      }
523      x = requests.post(
524          "https://translate.google.co.in/_/TranslateWebserverUi/data/batchexecute",
525          headers=headers,
526          data=_package_rpc(*args, **kwargs),
527      ).text
528      response = ""
529      data = json.loads(json.loads(x[4:])[0][2])[1][0][0]
530      subind = data[-2]
531      if not subind:
532          subind = data[-1]
533      for i in subind:
534          response += i[0]
535      return response
536  def cmd_regex_replace(cmd):
537      return (
538          cmd.replace("$", "")
539          .replace("?(.*)", "")
540          .replace("(.*)", "")
541          .replace("(?: |)", "")
542          .replace("| ", "")
543          .replace("( |)", "")
544          .replace("?((.|//)*)", "")
545          .replace("?P<shortname>\\w+", "")
546          .replace("(", "")
547          .replace(")", "")
548          .replace("?(\\d+)", "")
549      )
550  class LottieException(Exception):
551      ...
552  class TgConverter:
553      @staticmethod
554      async def animated_sticker(file, out_path="sticker.tgs", throw=False, remove=False):
555          if out_path.endswith("webp"):
556              er, out = await bash(
557                  f"lottie_convert.py --webp-quality 100 --webp-skip-frames 100 '{file}' '{out_path}'"
558              )
559          else:
560              er, out = await bash(f"lottie_convert.py '{file}' '{out_path}'")
561          if er and throw:
562              raise LottieException(er)
563          if remove:
564              os.remove(file)
565          if os.path.exists(out_path):
566              return out_path
567      @staticmethod
568      async def animated_to_gif(file, out_path="gif.gif"):
569          await bash(
570              f"lottie_convert.py '{_unquote_text(file)}' '{_unquote_text(out_path)}'"
571          )
572          return out_path
573      @staticmethod
574      def resize_photo_sticker(photo):
575          image = Image.open(photo)
576          if (image.width and image.height) < 512:
577              size1 = image.width
578              size2 = image.height
579              if image.width > image.height:
580                  scale = 512 / size1
581                  size1new = 512
582                  size2new = size2 * scale
583              else:
584                  scale = 512 / size2
585                  size1new = size1 * scale
586                  size2new = 512
587              size1new = math.floor(size1new)
588              size2new = math.floor(size2new)
589              sizenew = (size1new, size2new)
590              image = image.resize(sizenew)
591          else:
592              maxsize = (512, 512)
593              image.thumbnail(maxsize)
594          return image
595      @staticmethod
596      async def ffmpeg_convert(input_, output, remove=False):
597          if output.endswith(".webm"):
598              return await TgConverter.create_webm(
599                  input_, name=output[:-5], remove=remove
600              )
601          if output.endswith(".gif"):
602              await bash(f"ffmpeg -i '{input_}' -an -sn -c:v copy '{output}.mp4' -y")
603          else:
604              await bash(f"ffmpeg -i '{input_}' '{output}' -y")
605          if remove:
606              os.remove(input_)
607          if os.path.exists(output):
608              return output
609      @staticmethod
610      async def create_webm(file, name="video", remove=False):
611          _ = await metadata(file)
612          name += ".webm"
613          h, w = _["height"], _["width"]
614          if h == w and h != 512:
615              h, w = 512, 512
616          if h != 512 or w != 512:
617              if h > w:
618                  h, w = 512, -1
619              if w > h:
620                  h, w = -1, 512
621          await bash(
622              f'ffmpeg -i "{file}" -preset fast -an -to 00:00:03 -crf 30 -bufsize 256k -b:v {_["bitrate"]} -vf "scale={w}:{h},fps=30" -c:v libvpx-vp9 "{name}" -y'
623          )
624          if remove:
625              os.remove(file)
626          return name
627      @staticmethod
628      def to_image(input_, name, remove=False):
629          try:
630              import cv2
631          except ImportError:
632              raise DependencyMissingError("This function needs 'cv2' to be installed.")
633          img = cv2.VideoCapture(input_)
634          ult, roid = img.read()
635          cv2.imwrite(name, roid)
636          if remove:
637              os.remove(input_)
638          return name
639      @staticmethod
640      async def convert(
641          input_file,
642          outname="converted",
643          convert_to=None,
644          allowed_formats=[],
645          remove_old=True,
646      ):
647          if "." in input_file:
648              ext = input_file.split(".")[-1].lower()
649          else:
650              return input_file
651          if (
652              ext in allowed_formats
653              or ext == convert_to
654              or not (convert_to or allowed_formats)
655          ):
656              return input_file
657          def recycle_type(exte):
658              return convert_to == exte or exte in allowed_formats
659          if ext == "tgs":
660              for extn in ["webp", "json", "png", "mp4", "gif"]:
661                  if recycle_type(extn):
662                      name = outname + "." + extn
663                      return await TgConverter.animated_sticker(
664                          input_file, name, remove=remove_old
665                      )
666              if recycle_type("webm"):
667                  input_file = await TgConverter.convert(
668                      input_file, convert_to="gif", remove_old=remove_old
669                  )
670                  return await TgConverter.create_webm(input_file, outname, remove=True)
671          elif ext == "json":
672              if recycle_type("tgs"):
673                  name = outname + ".tgs"
674                  return await TgConverter.animated_sticker(
675                      input_file, name, remove=remove_old
676                  )
677          elif ext in ["webm", "mp4", "gif"]:
678              for exte in ["webm", "mp4", "gif"]:
679                  if recycle_type(exte):
680                      name = outname + "." + exte
681                      return await TgConverter.ffmpeg_convert(
682                          input_file, name, remove=remove_old
683                      )
684              for exte in ["png", "jpg", "jpeg", "webp"]:
685                  if recycle_type(exte):
686                      name = outname + "." + exte
687                      return TgConverter.to_image(input_file, name, remove=remove_old)
688          elif ext in ["jpg", "jpeg", "png", "webp"]:
689              for extn in ["png", "webp", "ico"]:
690                  if recycle_type(extn):
691                      img = Image.open(input_file)
692                      name = outname + "." + extn
693                      img.save(name, extn.upper())
694                      if remove_old:
695                          os.remove(input_file)
696                      return name
697              for extn in ["webm", "gif", "mp4"]:
698                  if recycle_type(extn):
699                      name = outname + "." + extn
700                      if extn == "webm":
701                          input_file = await TgConverter.convert(
702                              input_file,
703                              convert_to="png",
704                              remove_old=remove_old,
705                          )
706                      return await TgConverter.ffmpeg_convert(
707                          input_file, name, remove=True if extn == "webm" else remove_old
708                      )
709  def _get_value(stri):
710      try:
711          value = eval(stri.strip())
712      except Exception as er:
713          from .. import LOGS
714          LOGS.debug(er)
715          value = stri.strip()
716      return value
717  def safe_load(file, *args, **kwargs):
718      if isinstance(file, str):
719          read = file.split("\n")
720      else:
721          read = file.readlines()
722      out = {}
723      for line in read:
724          if ":" in line:  # Ignores Empty & Invalid lines
725              spli = line.split(":", maxsplit=1)
726              key = spli[0].strip()
727              value = _get_value(spli[1])
728              out.update({key: value or []})
729          elif "-" in line:
730              spli = line.split("-", maxsplit=1)
731              where = out[list(out.keys())[-1]]
732              if isinstance(where, list):
733                  value = _get_value(spli[1])
734                  if value:
735                      where.append(value)
736      return out
737  def get_chat_and_msgid(link):
738      matches = re.findall("https:\\/\\/t\\.me\\/(c\\/|)(.*)\\/(.*)", link)
739      if not matches:
740          return None, None
741      _, chat, msg_id = matches[0]
742      if chat.isdigit():
743          chat = int("-100" + chat)
744      return chat, int(msg_id)
</code></pre>
        </div>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-inlinestuff.py</h3>
            <pre><code>1  import base64
2  import inspect
3  from datetime import datetime
4  from html import unescape
5  from random import choice
6  from re import compile as re_compile
7  from bs4 import BeautifulSoup as bs
8  from telethon import Button
9  from telethon.tl.alltlobjects import LAYER, tlobjects
10  from telethon.tl.types import DocumentAttributeAudio as Audio
11  from telethon.tl.types import InputWebDocument as wb
12  from pyUltroid.fns.misc import google_search
13  from pyUltroid.fns.tools import (
14      _webupload_cache,
15      async_searcher,
16      get_ofox,
17      saavn_search,
18      webuploader,
19  )
20  from . import *
21  from . import _ult_cache
22  SUP_BUTTONS = [
23      [
24          Button.url("• Repo •", url="https://github.com/TeamUltroid/Ultroid"),
25          Button.url("• Support •", url="t.me/UltroidSupportChat"),
26      ],
27  ]
28  ofox = "https://graph.org/file/231f0049fcd722824f13b.jpg"
29  gugirl = "https://graph.org/file/0df54ae4541abca96aa11.jpg"
30  ultpic = "https://graph.org/file/4136aa1650bc9d4109cc5.jpg"
31  apis = [
32      "QUl6YVN5QXlEQnNZM1dSdEI1WVBDNmFCX3c4SkF5NlpkWE5jNkZV",
33      "QUl6YVN5QkYwenhMbFlsUE1wOXh3TVFxVktDUVJxOERnZHJMWHNn",
34      "QUl6YVN5RGRPS253blB3VklRX2xiSDVzWUU0Rm9YakFLSVFWMERR",
35  ]
36  @in_pattern("ofox", owner=True)
37  async def _(e):
38      try:
39          match = e.text.split(" ", maxsplit=1)[1]
40      except IndexError:
41          kkkk = e.builder.article(
42              title="Enter Device Codename",
43              thumb=wb(ofox, 0, "image/jpeg", []),
44              text="**OFᴏx🦊Rᴇᴄᴏᴠᴇʀʏ**\n\nYou didn't search anything",
45              buttons=Button.switch_inline("Sᴇᴀʀᴄʜ Aɢᴀɪɴ", query="ofox ", same_peer=True),
46          )
47          return await e.answer([kkkk])
48      device, releases = await get_ofox(match)
49      if device.get("detail") is None:
50          fox = []
51          fullname = device["full_name"]
52          codename = device["codename"]
53          str(device["supported"])
54          maintainer = device["maintainer"]["name"]
55          link = f"https://orangefox.download/device/{codename}"
56          for data in releases["data"]:
57              release = data["type"]
58              version = data["version"]
59              size = humanbytes(data["size"])
60              release_date = datetime.utcfromtimestamp(data["date"]).strftime("%Y-%m-%d")
61              text = f"[\xad]({ofox})**OʀᴀɴɢᴇFᴏx Rᴇᴄᴏᴠᴇʀʏ Fᴏʀ**\n\n"
62              text += f"`  Fᴜʟʟ Nᴀᴍᴇ: {fullname}`\n"
63              text += f"`  Cᴏᴅᴇɴᴀᴍᴇ: {codename}`\n"
64              text += f"`  Mᴀɪɴᴛᴀɪɴᴇʀ: {maintainer}`\n"
65              text += f"`  Bᴜɪʟᴅ Tʏᴘᴇ: {release}`\n"
66              text += f"`  Vᴇʀsɪᴏɴ: {version}`\n"
67              text += f"`  Sɪᴢᴇ: {size}`\n"
68              text += f"`  Bᴜɪʟᴅ Dᴀᴛᴇ: {release_date}`"
69              fox.append(
70                  await e.builder.article(
71                      title=f"{fullname}",
72                      description=f"{version}\n{release_date}",
73                      text=text,
74                      thumb=wb(ofox, 0, "image/jpeg", []),
75                      link_preview=True,
76                      buttons=[
77                          Button.url("Dᴏᴡɴʟᴏᴀᴅ", url=f"{link}"),
78                          Button.switch_inline(
79                              "Sᴇᴀʀᴄʜ Aɢᴀɪɴ", query="ofox ", same_peer=True
80                          ),
81                      ],
82                  )
83              )
84          await e.answer(
85              fox, switch_pm="OrangeFox Recovery Search.", switch_pm_param="start"
86          )
87      else:
88          await e.answer(
89              [], switch_pm="OrangeFox Recovery Search.", switch_pm_param="start"
90          )
91  @in_pattern("fl2lnk ?(.*)", owner=True)
92  async def _(e):
93      match = e.pattern_match.group(1)
94      chat_id, msg_id = match.split(":")
95      filename = _webupload_cache[int(chat_id)][int(msg_id)]
96      if "/" in filename:
97          filename = filename.split("/")[-1]
98      __cache = f"{chat_id}:{msg_id}"
99      buttons = [
100          [
101              Button.inline("anonfiles", data=f"flanonfiles//{__cache}"),
102              Button.inline("transfer", data=f"fltransfer//{__cache}"),
103          ],
104          [
105              Button.inline("bayfiles", data=f"flbayfiles//{__cache}"),
106              Button.inline("x0.at", data=f"flx0.at//{__cache}"),
107          ],
108          [
109              Button.inline("file.io", data=f"flfile.io//{__cache}"),
110              Button.inline("siasky", data=f"flsiasky//{__cache}"),
111          ],
112      ]
113      try:
114          lnk = [
115              await e.builder.article(
116                  title=f"Upload {filename}",
117                  text=f"**File:**\n{filename}",
118                  buttons=buttons,
119              )
120          ]
121      except BaseException as er:
122          LOGS.exception(er)
123          lnk = [
124              await e.builder.article(
125                  title="fl2lnk",
126                  text="File not found",
127              )
128          ]
129      await e.answer(lnk, switch_pm="File to Link.", switch_pm_param="start")
130  @callback(
131      re_compile(
132          "fl(.*)",
133      ),
134      owner=True,
135  )
136  async def _(e):
137      t = (e.data).decode("UTF-8")
138      data = t[2:]
139      host = data.split("//")[0]
140      chat_id, msg_id = data.split("//")[1].split(":")
<span onclick='openModal()' class='match'>141      filename = _webupload_cache[int(chat_id)][int(msg_id)]
142      if "/" in filename:
</span>143          filename = filename.split("/")[-1]
144      await e.edit(f"Uploading `{filename}` on {host}")
145      link = (await webuploader(chat_id, msg_id, host)).strip().replace("\n", "")
146      await e.edit(f"Uploaded `{filename}` on {host}.", buttons=Button.url("View", link))
147  @in_pattern("repo", owner=True)
148  async def repo(e):
149      res = [
150          await e.builder.article(
151              title="Ultroid Userbot",
152              description="Userbot | Telethon",
153              thumb=wb(ultpic, 0, "image/jpeg", []),
154              text="• **ULTROID USERBOT** •",
155              buttons=SUP_BUTTONS,
156          ),
157      ]
158      await e.answer(res, switch_pm="Ultroid Repo.", switch_pm_param="start")
159  @in_pattern("go", owner=True)
160  async def gsearch(q_event):
161      try:
162          match = q_event.text.split(maxsplit=1)[1]
163      except IndexError:
164          return await q_event.answer(
165              [], switch_pm="Google Search. Enter a query!", switch_pm_param="start"
166          )
167      searcher = []
168      gresults = await google_search(match)
169      for i in gresults:
170          try:
171              title = i["title"]
172              link = i["link"]
173              desc = i["description"]
174              searcher.append(
175                  await q_event.builder.article(
176                      title=title,
177                      description=desc,
178                      thumb=wb(gugirl, 0, "image/jpeg", []),
179                      text=f"**Gᴏᴏɢʟᴇ Sᴇᴀʀᴄʜ**\n\n**••Tɪᴛʟᴇ••**\n`{title}`\n\n**••Dᴇsᴄʀɪᴘᴛɪᴏɴ••**\n`{desc}`",
180                      link_preview=False,
181                      buttons=[
182                          [Button.url("Lɪɴᴋ", url=f"{link}")],
183                          [
184                              Button.switch_inline(
185                                  "Sᴇᴀʀᴄʜ Aɢᴀɪɴ",
186                                  query="go ",
187                                  same_peer=True,
188                              ),
189                              Button.switch_inline(
190                                  "Sʜᴀʀᴇ",
191                                  query=f"go {match}",
192                                  same_peer=False,
193                              ),
194                          ],
195                      ],
196                  ),
197              )
198          except IndexError:
199              break
200      await q_event.answer(searcher, switch_pm="Google Search.", switch_pm_param="start")
201  @in_pattern("mods", owner=True)
202  async def _(e):
203      try:
204          quer = e.text.split(" ", maxsplit=1)[1]
205      except IndexError:
206          return await e.answer(
207              [], switch_pm="Mod Apps Search. Enter app name!", switch_pm_param="start"
208          )
209      start = 0 * 3 + 1
210      da = base64.b64decode(choice(apis)).decode("ascii")
211      url = f"https://www.googleapis.com/customsearch/v1?key={da}&cx=25b3b50edb928435b&q={quer}&start={start}"
212      data = await async_searcher(url, re_json=True)
213      search_items = data.get("items", [])
214      modss = []
215      for a in search_items:
216          title = a.get("title")
217          desc = a.get("snippet")
218          link = a.get("link")
219          text = f"**••Tɪᴛʟᴇ••** `{title}`\n\n"
220          text += f"**Dᴇsᴄʀɪᴘᴛɪᴏɴ** `{desc}`"
221          modss.append(
222              await e.builder.article(
223                  title=title,
224                  description=desc,
225                  text=text,
226                  link_preview=True,
227                  buttons=[
228                      [Button.url("Dᴏᴡɴʟᴏᴀᴅ", url=f"{link}")],
229                      [
230                          Button.switch_inline(
231                              "Mᴏʀᴇ Mᴏᴅs",
232                              query="mods ",
233                              same_peer=True,
234                          ),
235                          Button.switch_inline(
236                              "Sʜᴀʀᴇ",
237                              query=f"mods {quer}",
238                              same_peer=False,
239                          ),
240                      ],
241                  ],
242              ),
243          )
244      await e.answer(modss, switch_pm="Search Mod Applications.", switch_pm_param="start")
245  APP_CACHE = {}
246  RECENTS = {}
247  PLAY_API = "https://googleplay.onrender.com/api/apps?q="
248  @in_pattern("app", owner=True)
249  async def _(e):
250      try:
251          f = e.text.split(maxsplit=1)[1].lower()
252      except IndexError:
253          get_string("instu_1")
254          res = []
255          if APP_CACHE and RECENTS.get(e.sender_id):
256              res.extend(
257                  APP_CACHE[a][0] for a in RECENTS[e.sender_id] if APP_CACHE.get(a)
258              )
259          return await e.answer(
260              res, switch_pm=get_string("instu_2"), switch_pm_param="start"
261          )
262      try:
263          return await e.answer(
264              APP_CACHE[f], switch_pm="Application Searcher.", switch_pm_param="start"
265          )
266      except KeyError:
267          pass
268      foles = []
269      url = PLAY_API + f.replace(" ", "+")
270      aap = await async_searcher(url, re_json=True)
271      for z in aap["results"][:50]:
272          url = "https://play.google.com/store/apps/details?id=" + z["appId"]
273          name = z["title"]
274          desc = unescape(z["summary"])[:300].replace("<br>", "\n") + "..."
275          dev = z["developer"]["devId"]
276          text = f"**••Aᴘᴘ Nᴀᴍᴇ••** [{name}]({url})\n"
277          text += f"**••Dᴇᴠᴇʟᴏᴘᴇʀ••** `{dev}`\n"
278          text += f"**••Dᴇsᴄʀɪᴘᴛɪᴏɴ••**\n`{desc}`"
279          foles.append(
280              await e.builder.article(
281                  title=name,
282                  description=dev,
283                  thumb=wb(z["icon"], 0, "image/jpeg", []),
284                  text=text,
285                  link_preview=True,
286                  buttons=[
287                      [Button.url("Lɪɴᴋ", url=url)],
288                      [
289                          Button.switch_inline(
290                              "Mᴏʀᴇ Aᴘᴘs",
291                              query="app ",
292                              same_peer=True,
293                          ),
294                          Button.switch_inline(
295                              "Sʜᴀʀᴇ",
296                              query=f"app {f}",
297                              same_peer=False,
298                          ),
299                      ],
300                  ],
301              ),
302          )
303      APP_CACHE.update({f: foles})
304      if RECENTS.get(e.sender_id):
305          RECENTS[e.sender_id].append(f)
306      else:
307          RECENTS.update({e.sender_id: [f]})
308      await e.answer(foles, switch_pm="Application Searcher.", switch_pm_param="start")
309  PISTON_URI = "https://emkc.org/api/v2/piston/"
310  PISTON_LANGS = {}
311  @in_pattern("run", owner=True)
312  async def piston_run(event):
313      try:
314          lang = event.text.split()[1]
315          code = event.text.split(maxsplit=2)[2]
316      except IndexError:
317          result = await event.builder.article(
318              title="Bad Query",
319              description="Usage: [Language] [code]",
320              thumb=wb(
321                  "https://graph.org/file/e33c57fc5f1044547e4d8.jpg", 0, "image/jpeg", []
322              ),
323              text=f'**Inline Usage**\n\n`@{asst.me.username} run python print("hello world")`\n\n[Language List](https://graph.org/Ultroid-09-01-6)',
324          )
325          return await event.answer([result])
326      if not PISTON_LANGS:
327          se = await async_searcher(f"{PISTON_URI}runtimes", re_json=True)
328          PISTON_LANGS.update({lang.pop("language"): lang for lang in se})
329      if lang in PISTON_LANGS.keys():
330          version = PISTON_LANGS[lang]["version"]
331      else:
332          result = await event.builder.article(
333              title="Unsupported Language",
334              description="Usage: [Language] [code]",
335              thumb=wb(
336                  "https://graph.org/file/e33c57fc5f1044547e4d8.jpg", 0, "image/jpeg", []
337              ),
338              text=f'**Inline Usage**\n\n`@{asst.me.username} run python print("hello world")`\n\n[Language List](https://graph.org/Ultroid-09-01-6)',
339          )
340          return await event.answer([result])
341      output = await async_searcher(
342          f"{PISTON_URI}execute",
343          post=True,
344          json={
345              "language": lang,
346              "version": version,
347              "files": [{"content": code}],
348          },
349          re_json=True,
350      )
351      output = output["run"]["output"] or get_string("instu_4")
352      if len(output) > 3000:
353          output = f"{output[:3000]}..."
354      result = await event.builder.article(
355          title="Result",
356          description=output,
357          text=f"• **Language:**\n`{lang}`\n\n• **Code:**\n`{code}`\n\n• **Result:**\n`{output}`",
358          thumb=wb(
359              "https://graph.org/file/871ee4a481f58117dccc4.jpg", 0, "image/jpeg", []
360          ),
361          buttons=Button.switch_inline("Fork", query=event.text, same_peer=True),
362      )
363      await event.answer([result], switch_pm="• Piston •", switch_pm_param="start")
364  FDROID_ = {}
365  @in_pattern("fdroid", owner=True)
366  async def do_magic(event):
367      try:
368          match = event.text.split(" ", maxsplit=1)[1].lower()
369      except IndexError:
370          return await event.answer(
371              [], switch_pm="Enter Query to Search", switch_pm_param="start"
372          )
373      if FDROID_.get(match):
374          return await event.answer(
375              FDROID_[match], switch_pm=f"• Results for {match}", switch_pm_param="start"
376          )
377      link = "https://search.f-droid.org/?q=" + match.replace(" ", "+")
378      content = await async_searcher(link, re_content=True)
379      BSC = bs(content, "html.parser", from_encoding="utf-8")
380      ress = []
381      for dat in BSC.find_all("a", "package-header")[:10]:
382          image = dat.find("img", "package-icon")["src"]
383          if image.endswith("/"):
384              image = "https://graph.org/file/a8dd4a92c5a53a89d0eff.jpg"
385          title = dat.find("h4", "package-name").text.strip()
386          desc = dat.find("span", "package-summary").text.strip()
387          text = f"• **Name :** `{title}`\n\n"
388          text += f"• **Description :** `{desc}`\n"
389          text += f"• **License :** `{dat.find('span', 'package-license').text.strip()}`"
390          imga = wb(image, 0, "image/jpeg", [])
391          ress.append(
392              await event.builder.article(
393                  title=title,
394                  type="photo",
395                  description=desc,
396                  text=text,
397                  content=imga,
398                  thumb=imga,
399                  include_media=True,
400                  buttons=[
401                      Button.inline(
402                          "• Download •", "fd" + dat["href"].split("packages/")[-1]
403                      ),
404                      Button.switch_inline("• Share •", query=event.text),
405                  ],
406              )
407          )
408      msg = f"Showing {len(ress)} Results!" if ress else "No Results Found"
409      FDROID_.update({match: ress})
410      await event.answer(ress, switch_pm=msg, switch_pm_param="start")
411  _bearer_collected = [
412      "AAAAAAAAAAAAAAAAAAAAALIKKgEAAAAA1DRuS%2BI7ZRKiagD6KHYmreaXomo%3DP5Vaje4UTtEkODg0fX7nCh5laSrchhtLxeyEqxXpv0w9ZKspLD",
413      "AAAAAAAAAAAAAAAAAAAAAL5iUAEAAAAAmo6FYRjqdKlI3cNziIm%2BHUQB9Xs%3DS31pj0mxARMTOk2g9dvQ1yP9wknvY4FPBPUlE00smJcncw4dPR",
414      "AAAAAAAAAAAAAAAAAAAAAN6sVgEAAAAAMMjMMWrwgGyv7YQOWN%2FSAsO5SGM%3Dg8MG9Jq93Rlllaok6eht7HvRCruN4Vpzp4NaVsZaaHHWSTzKI8",
415  ]
416  @in_pattern("twitter", owner=True)
417  async def twitter_search(event):
418      try:
419          match = event.text.split(maxsplit=1)[1].lower()
420      except IndexError:
421          return await event.answer(
422              [], switch_pm="Enter Query to Search", switch_pm_param="start"
423          )
424      try:
425          return await event.answer(
426              _ult_cache["twitter"][match],
427              switch_pm="• Twitter Search •",
428              switch_pm_param="start",
429          )
430      except KeyError:
431          pass
432      headers = {"Authorization": f"bearer {choice(_bearer_collected)}"}
433      res = await async_searcher(
434          f"https://api.twitter.com/1.1/users/search.json?q={match}",
435          headers=headers,
436          re_json=True,
437      )
438      reso = []
439      for user in res:
440          thumb = wb(user["profile_image_url_https"], 0, "image/jpeg", [])
441          if user.get("profile_banner_url"):
442              url = user["profile_banner_url"]
443              text = f"[\xad]({url})• **Name :** `{user['name']}`\n"
444          else:
445              text = f"• **Name :** `{user['name']}`\n"
446          text += f"• **Description :** `{user['description']}`\n"
447          text += f"• **Username :** `@{user['screen_name']}`\n"
448          text += f"• **Followers :** `{user['followers_count']}`    • **Following :** `{user['friends_count']}`\n"
449          pro_ = "https://twitter.com/" + user["screen_name"]
450          text += f"• **Link :** [Click Here]({pro_})\n_"
451          reso.append(
452              await event.builder.article(
453                  title=user["name"],
454                  description=user["description"],
455                  url=pro_,
456                  text=text,
457                  thumb=thumb,
458              )
459          )
460      swi_ = f"🐦 Showing {len(reso)} Results!" if reso else "No User Found :("
461      await event.answer(reso, switch_pm=swi_, switch_pm_param="start")
462      if _ult_cache.get("twitter"):
463          _ult_cache["twitter"].update({match: reso})
464      else:
465          _ult_cache.update({"twitter": {match: reso}})
466  _savn_cache = {}
467  @in_pattern("saavn", owner=True)
468  async def savn_s(event):
469      try:
470          query = event.text.split(maxsplit=1)[1].lower()
471      except IndexError:
472          return await event.answer(
473              [], switch_pm="Enter Query to search 🔍", switch_pm_param="start"
474          )
475      if query in _savn_cache:
476          return await event.answer(
477              _savn_cache[query],
478              switch_pm=f"Showing Results for {query}",
479              switch_pm_param="start",
480          )
481      results = await saavn_search(query)
482      swi = "🎵 Saavn Search" if results else "No Results Found!"
483      res = []
484      for song in results:
485          thumb = wb(song["image"], 0, "image/jpeg", [])
486          text = f"• **Title :** {song['title']}"
487          text += f"\n• **Year :** {song['year']}"
488          text += f"\n• **Lang :** {song['language']}"
489          text += f"\n• **Artist :** {song['artists']}"
490          text += f"\n• **Release Date :** {song['release_date']}"
491          res.append(
492              await event.builder.article(
493                  title=song["title"],
494                  description=song["artists"],
495                  type="audio",
496                  text=text,
497                  include_media=True,
498                  buttons=Button.switch_inline(
499                      "Search Again 🔍", query="saavn", same_peer=True
500                  ),
501                  thumb=thumb,
502                  content=wb(
503                      song["url"],
504                      0,
505                      "audio/mp4",
506                      [
507                          Audio(
508                              title=song["title"],
509                              duration=int(song["duration"]),
510                              performer=song["artists"],
511                          )
512                      ],
513                  ),
514              )
515          )
516      await event.answer(res, switch_pm=swi, switch_pm_param="start")
517      _savn_cache.update({query: res})
518  @in_pattern("tl", owner=True)
519  async def inline_tl(ult):
520      try:
521          match = ult.text.split(maxsplit=1)[1]
522      except IndexError:
523          text = f"**Telegram TlObjects Searcher.**\n__(Don't use if you don't know what it is!)__\n\n• Example Usage\n`@{asst.me.username} tl GetFullUserRequest`"
524          return await ult.answer(
525              [
526                  await ult.builder.article(
527                      title="How to Use?",
528                      description="Tl Searcher by Ultroid",
529                      url="https://t.me/TeamUltroid",
530                      text=text,
531                  )
532              ],
533              switch_pm="Tl Search 🔍",
534              switch_pm_param="start",
535          )
536      res = []
537      for key in tlobjects.values():
538          if match.lower() in key.__name__.lower():
539              tyyp = "Function" if "tl.functions." in str(key) else "Type"
540              text = f"**Name:** `{key.__name__}`\n"
541              text += f"**Category:** `{tyyp}`\n"
542              text += f"\n`from {key.__module__} import {key.__name__}`\n\n"
543              if args := str(inspect.signature(key))[1:][:-1]:
544                  text += "**Parameter:**\n"
545                  for para in args.split(","):
546                      text += " " * 4 + "`" + para + "`\n"
547              text += f"\n**Layer:** `{LAYER}`"
548              res.append(
549                  await ult.builder.article(
550                      title=key.__name__,
551                      description=tyyp,
552                      url="https://t.me/TeamUltroid",
553                      text=text[:4000],
554                  )
555              )
556      mo = f"Showing {len(res)} results!" if res else f"No Results for {match}!"
557      await ult.answer(res[:50], switch_pm=mo, switch_pm_param="start")
558  InlinePlugin.update(
559      {
560          "Pʟᴀʏ Sᴛᴏʀᴇ Aᴘᴘs": "app telegram",
561          "Mᴏᴅᴅᴇᴅ Aᴘᴘs": "mods minecraft",
562          "Sᴇᴀʀᴄʜ Oɴ Gᴏᴏɢʟᴇ": "go TeamUltroid",
563          "WʜɪSᴘᴇʀ": "wspr @username Hello🎉",
564          "YᴏᴜTᴜʙᴇ Dᴏᴡɴʟᴏᴀᴅᴇʀ": "yt Ed Sheeran Perfect",
565          "Piston Eval": "run javascript console.log('Hello Ultroid')",
566          "OʀᴀɴɢᴇFᴏx🦊": "ofox beryllium",
567          "Tᴡɪᴛᴛᴇʀ Usᴇʀ": "twitter theultroid",
568          "Fᴅʀᴏɪᴅ Sᴇᴀʀᴄʜ": "fdroid telegram",
569          "Sᴀᴀᴠɴ sᴇᴀʀᴄʜ": "saavn",
570          "Tʟ Sᴇᴀʀᴄʜ": "tl",
571      }
572  )
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-tools.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-inlinestuff.py</div>
                </div>
                <div class="column column_space"><pre><code>167      file = _webupload_cache[int(chat_id)][int(msg_id)]
168      sites = {
</pre></code></div>
                <div class="column column_space"><pre><code>141      filename = _webupload_cache[int(chat_id)][int(msg_id)]
142      if "/" in filename:
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    