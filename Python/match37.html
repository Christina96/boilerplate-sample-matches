<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for test_sequence.py &amp; test_tree.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_sequence.py &amp; test_tree.py
      </h3>
<h1 align="center">
        15.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_sequence.py (13.162808%)<th>test_tree.py (19.304491%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(2091-2097)<td><a href="#" name="0">(209-214)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(2047-2053)<td><a href="#" name="1">(383-386)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(2098-2102)<td><a href="#" name="2">(215-218)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(2054-2058)<td><a href="#" name="3">(191-194)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1380-1384)<td><a href="#" name="4">(1113-1123)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1345-1349)<td><a href="#" name="5">(1003-1010)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(1100-1106)<td><a href="#" name="6">(1073-1082)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(2065-2069)<td><a href="#" name="7">(218-221)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(802-807)<td><a href="#" name="8">(629-633)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(174-179)<td><a href="#" name="9">(669-676)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1825-1827)<td><a href="#" name="10">(198-201)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1371-1376)<td><a href="#" name="11">(778-785)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(1336-1341)<td><a href="#" name="12">(622-627)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(1080-1086)<td><a href="#" name="13">(975-978)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(821-826)<td><a href="#" name="14">(1338-1345)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(208-211)<td><a href="#" name="15">(447-451)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(2115-2122)<td><a href="#" name="16">(725-727)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(2071-2078)<td><a href="#" name="17">(723-725)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(1265-1277)<td><a href="#" name="18">(407-412)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(1010-1015)<td><a href="#" name="19">(910-915)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(773-777)<td><a href="#" name="20">(1380-1385)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(411-422)<td><a href="#" name="21">(251-257)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(2085-2090)<td><a href="#" name="22">(997-999)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(2041-2046)<td><a href="#" name="23">(843-846)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(1662-1669)<td><a href="#" name="24">(991-995)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(1620-1627)<td><a href="#" name="25">(764-767)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(1087-1090)<td><a href="#" name="26">(1052-1059)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(811-816)<td><a href="#" name="27">(637-639)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(740-743)<td><a href="#" name="28">(262-266)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(530-535)<td><a href="#" name="29">(277-280)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(304-307)<td><a href="#" name="30">(303-306)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3ea99f"><font color="#3ea99f">-</font><td><a href="#" name="31">(280-282)<td><a href="#" name="31">(33-36)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#5b8daf")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5b8daf"><font color="#5b8daf">-</font><td><a href="#" name="32">(2109-2112)<td><a href="#" name="32">(269-272)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#736aff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#736aff"><font color="#736aff">-</font><td><a href="#" name="33">(1930-1935)<td><a href="#" name="33">(1019-1023)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#827d6b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#827d6b"><font color="#827d6b">-</font><td><a href="#" name="34">(1841-1848)<td><a href="#" name="34">(162-167)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#41a317")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#41a317"><font color="#41a317">-</font><td><a href="#" name="35">(1800-1807)<td><a href="#" name="35">(658-662)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#ff00ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ff00ff"><font color="#ff00ff">-</font><td><a href="#" name="36">(1672-1676)<td><a href="#" name="36">(651-655)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#810541")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#810541"><font color="#810541">-</font><td><a href="#" name="37">(1592-1596)<td><a href="#" name="37">(792-796)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#348781")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#348781"><font color="#348781">-</font><td><a href="#" name="38">(1587-1592)<td><a href="#" name="38">(663-666)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#152dc6")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#152dc6"><font color="#152dc6">-</font><td><a href="#" name="39">(1238-1243)<td><a href="#" name="39">(1041-1049)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#347235")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#347235"><font color="#347235">-</font><td><a href="#" name="40">(992-997)<td><a href="#" name="40">(1263-1273)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#f87a17")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f87a17"><font color="#f87a17">-</font><td><a href="#" name="41">(831-834)<td><a href="#" name="41">(643-644)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#c57717")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c57717"><font color="#c57717">-</font><td><a href="#" name="42">(602-612)<td><a href="#" name="42">(891-896)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#c22817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c22817"><font color="#c22817">-</font><td><a href="#" name="43">(515-519)<td><a href="#" name="43">(424-428)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#a057a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#a057a5"><font color="#a057a5">-</font><td><a href="#" name="44">(391-396)<td><a href="#" name="44">(603-608)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#549748")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#549748"><font color="#549748">-</font><td><a href="#" name="45">(327-329)<td><a href="#" name="45">(37-40)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#668b8b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#668b8b"><font color="#668b8b">-</font><td><a href="#" name="46">(262-269)<td><a href="#" name="46">(201-205)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#d16587")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#d16587"><font color="#d16587">-</font><td><a href="#" name="47">(145-150)<td><a href="#" name="47">(420-423)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#c57726")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c57726"><font color="#c57726">-</font><td><a href="#" name="48">(129-134)<td><a href="#" name="48">(413-417)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#8e35ef")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8e35ef"><font color="#8e35ef">-</font><td><a href="#" name="49">(19-39)<td><a href="#" name="49">(9-27)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_sequence.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
# ----------------------------------------------------------------------------
# Copyright (c) 2013--, scikit-bio development team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
# ----------------------------------------------------------------------------

import copy
import functools
import itertools
import re
from types import GeneratorType
from collections.abc import Hashable
from unittest import TestCase, main
<a name="49"></a>
import numpy as np
import numpy.testing as npt
<font color="#8e35ef"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import pandas as pd
import scipy.spatial.distance

import skbio.sequence.distance
from skbio import Sequence, DNA
from skbio.util import assert_data_frame_almost_equal
from skbio.sequence._sequence import (_single_index_to_slice, _is_single_index,
                                      _as_slice_if_single_index)
from skbio.util._testing import ReallyEqualMixin
from skbio.metadata._testing import (MetadataMixinTests,
                                     IntervalMetadataMixinTests,
                                     PositionalMetadataMixinTests)
from skbio.metadata import IntervalMetadata


class SequenceSubclass(Sequence):
    """Used for testing purposes."""
    pass


class</b></font> SequenceSubclassTwo(Sequence):
    """Used for testing purposes."""
    pass


class TestSequenceMetadata(TestCase, ReallyEqualMixin, MetadataMixinTests):
    def setUp(self):
        self._metadata_constructor_ = functools.partial(Sequence, '')


class TestSequencePositionalMetadata(TestCase, ReallyEqualMixin,
                                     PositionalMetadataMixinTests):
    def setUp(self):
        def factory(axis_len, positional_metadata=None):
            return Sequence('Z' * axis_len,
                            positional_metadata=positional_metadata)
        self._positional_metadata_constructor_ = factory


class TestSequenceIntervalMetadata(TestCase, ReallyEqualMixin,
                                   IntervalMetadataMixinTests):
    def setUp(self):
        super()._set_up()

        def factory(axis_len, interval_metadata=None):
            return Sequence('Z' * axis_len,
                            interval_metadata=interval_metadata)
        self._interval_metadata_constructor_ = factory


class TestSequenceBase(TestCase):
    def setUp(self):
        self.sequence_kinds = frozenset([
            str, Sequence,
            lambda s: np.frombuffer(s.encode('ascii'), dtype='|S1'),
            lambda s: np.frombuffer(s.encode('ascii'), dtype=np.uint8)])


class TestSequence(TestSequenceBase, ReallyEqualMixin):
    def setUp(self):
        super(TestSequence, self).setUp()

        self.lowercase_seq = Sequence('AAAAaaaa', lowercase='key')

        def empty_generator():
            yield from ()

        self.getitem_empty_indices = [
            [],
            (),
            {},
            empty_generator(),
            # ndarray of implicit float dtype
            np.array([]),
            np.array([], dtype=int)]

    def test_concat_bad_how(self):
        seq1 = seq2 = Sequence("123")
        with self.assertRaises(ValueError):
            Sequence.concat([seq1, seq2], how='foo')

    def test_concat_on_subclass(self):
        seq1 = SequenceSubclass("123")
        seq2 = Sequence("123")
        result = SequenceSubclass.concat([seq1, seq2])
        self.assertIs(type(result), SequenceSubclass)
        self.assertEqual(result, SequenceSubclass("123123"))

    def test_concat_on_empty_iterator(self):
        result = SequenceSubclass.concat((_ for _ in []))
        self.assertIs(type(result), SequenceSubclass)
        self.assertEqual(result, SequenceSubclass(""))

    def test_concat_on_bad_subclass(self):
        seq1 = Sequence("123")
        seq2 = SequenceSubclassTwo("123")
        with self.assertRaises(TypeError):
            SequenceSubclass.concat([seq1, seq2])

    def test_concat_interval_metadata(self):
        seq1 = Sequence("1234")
        seq1.interval_metadata.add(
            [(0, 2)], [(True, False)], {'gene': 'sagA'})
        seq2 = Sequence("5678")
        seq2.interval_metadata.add(
            [(1, 3)], [(False, True)], {'gene': 'sagB'})
        obs = Sequence.concat([seq1, seq2])
<a name="48"></a>        exp = Sequence('12345678')
        exp.interval_metadata.add(
            [(0, 2)], [(True, False)], {'gene': 'sagA'})
        exp.interval_metadata<font color="#c57726"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add(
            [(5, 7)], [(False, True)], {'gene': 'sagB'})
        self.assertEqual(exp, obs)

    def test_concat_one_seq_has_none_interval_metadata(self):
        seq1 =</b></font> Sequence("1234")
        seq1.interval_metadata.add(
            [(0, 2)], [(True, False)], {'gene': 'sagA'})
        seq2 = Sequence("5678")
        seq3 = Sequence("910")
        seq3.interval_metadata.add(
            [(1, 3)], [(False, True)], {'gene': 'sagB'})
        obs = Sequence.concat([seq1, seq2, seq3])
<a name="47"></a>        exp = Sequence('12345678910')
        exp.interval_metadata.add(
            [(0, 2)], [(True, False)], {'gene': 'sagA'})
        exp.interval_metadata<font color="#d16587"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add(
            [(9, 11)], [(False, True)], {'gene': 'sagB'})
        self.assertEqual(exp, obs)

    def test_concat_default_how(self):
        seq1 =</b></font> Sequence("1234", positional_metadata={'a': [1]*4})
        seq2 = Sequence("5678", positional_metadata={'a': [2]*4})
        seqbad = Sequence("9", positional_metadata={'b': [9]})
        result1 = Sequence.concat([seq1, seq2])
        result2 = Sequence.concat([seq1, seq2], how='strict')
        self.assertEqual(result1, result2)
        with self.assertRaisesRegex(ValueError,
                                    r'.*positional.*metadata.*inner.*outer.*'):
            Sequence.concat([seq1, seq2, seqbad])

    def test_concat_strict_simple(self):
        expected = Sequence(
            "12345678", positional_metadata={'a': [1, 1, 1, 1, 2, 2, 2, 2]})
        seq1 = Sequence("1234", positional_metadata={'a': [1]*4})
        seq2 = Sequence("5678", positional_metadata={'a': [2]*4})
        result = Sequence.concat([seq1, seq2], how='strict')
        self.assertEqual(result, expected)
        self.assertFalse(result.metadata)

    def test_concat_strict_many(self):
        odd_key = frozenset()
<a name="9"></a>        expected = Sequence("13579",
                            positional_metadata={'a': list('skbio'),
                                                 odd_key: [1, 2, 3, 4, 5]})
        result = Sequence<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.concat([
                Sequence("1", positional_metadata={'a': ['s'], odd_key: [1]}),
                Sequence("3", positional_metadata={'a': ['k'], odd_key: [2]}),
                Sequence("5", positional_metadata={'a': ['b'], odd_key: [3]}),
                Sequence("7", positional_metadata={'a': ['i'], odd_key: [4]}),
                Sequence(</b></font>"9", positional_metadata={'a': ['o'], odd_key: [5]})
            ], how='strict')
        self.assertEqual(result, expected)
        self.assertFalse(result.metadata)

    def test_concat_strict_fail(self):
        seq1 = Sequence("1", positional_metadata={'a': [1]})
        seq2 = Sequence("2", positional_metadata={'b': [2]})
        with self.assertRaisesRegex(ValueError,
                                    r'.*positional.*metadata.*inner.*outer.*'):
            Sequence.concat([seq1, seq2], how='strict')

    def test_concat_outer_simple(self):
        seq1 = Sequence("1234")
        seq2 = Sequence("5678")
        result = Sequence.concat([seq1, seq2], how='outer')
        self.assertEqual(result, Sequence("12345678"))
        self.assertFalse(result.metadata)

    def test_concat_outer_missing(self):
        a = {}
        b = {}
        seq1 = Sequence("12", positional_metadata={'a': ['1', '2']})
        seq2 = Sequence("34", positional_metadata={'b': [3, 4], 'c': [a, b]})
        seq3 = Sequence("56")
        seq4 = Sequence("78", positional_metadata={'a': [7, 8]})
<a name="15"></a>        seq5 = Sequence("90", positional_metadata={'b': [9, 0]})

        result = Sequence.concat([seq1, seq2, seq3, seq4, seq5], how='outer')
        expected = Sequence<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("1234567890", positional_metadata={
                                'a': ['1', '2', np.nan, np.nan, np.nan, np.nan,
                                      7, 8, np.nan, np.nan],
                                'b': [np.nan, np.nan, 3, 4, np.nan, np.</b></font>nan,
                                      np.nan, np.nan, 9, 0],
                                'c': [np.nan, np.nan, a, b, np.nan, np.nan,
                                      np.nan, np.nan, np.nan, np.nan]
                            })
        self.assertEqual(result, expected)
        self.assertFalse(result.metadata)

    def test_concat_inner_simple(self):
        seq1 = Sequence("1234")
        seq2 = Sequence("5678", positional_metadata={'discarded': [1] * 4})
        result = Sequence.concat([seq1, seq2], how='inner')
        self.assertEqual(result, Sequence("12345678"))
        self.assertFalse(result.metadata)

    def test_concat_inner_missing(self):
        seq1 = Sequence("12", positional_metadata={'a': ['1', '2'],
                                                   'c': [{}, {}]})
        seq2 = Sequence("34", positional_metadata={'a': [3, 4], 'b': [3, 4]})
        seq3 = Sequence("56", positional_metadata={'a': [5, 6], 'b': [5, 6]})

        result = Sequence.concat([seq1, seq2, seq3], how='inner')
        expected = Sequence("123456", positional_metadata={'a': ['1', '2', 3,
                                                                 4, 5, 6]})
        self.assertEqual(result, expected)
        self.assertFalse(result.metadata)

    def test_init_default_parameters(self):
        seq = Sequence('.ABC123xyz-')

        npt.assert_equal(seq.values, np.array('.ABC123xyz-', dtype='c'))
        self.assertEqual('.ABC123xyz-', str(seq))
        self.assertFalse(seq.metadata)
        self.assertEqual(seq.metadata, {})
        assert_data_frame_almost_equal(seq.positional_metadata,
                                       pd.DataFrame(index=range(11)))
        self.assertEqual(seq.interval_metadata,
                         IntervalMetadata(len(seq)))

    def test_init_nondefault_parameters(self):
        s = '.ABC123xyz-'
        im = IntervalMetadata(len(s))
        im.add([(0, 1)], metadata={'gene': 'sagA'})
        seq = Sequence(s,
                       metadata={'id': 'foo', 'description': 'bar baz'},
                       positional_metadata={'quality': range(11)},
                       interval_metadata=im)

<a name="46"></a>        self.assertEqual(seq.interval_metadata, im)

        npt.assert_equal(seq.values, np.array('.ABC123xyz-', dtype='c'))
        self.assertEqual(s, str<font color="#668b8b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq))

        self.assertTrue(seq.metadata)
        self.assertEqual(seq.metadata, {'id': 'foo', 'description': 'bar baz'})

        assert_data_frame_almost_equal(
            seq.positional_metadata,
            pd.DataFrame(</b></font>{'quality': range(11)}, index=range(11)))

    def test_init_empty_sequence(self):
        # Test constructing an empty sequence using each supported input type.
        for s in (b'',  # bytes
                  '',  # unicode
                  np.array('', dtype='c'),  # char vector
                  np.frombuffer(b'', dtype=np.uint8),  # byte vec
<a name="31"></a>                  Sequence('')):  # another Sequence object
            seq = Sequence(s)

            self<font color="#3ea99f"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIsInstance(seq.values, np.ndarray)
            self.assertEqual(seq.values.dtype, '|S1')
            self.assertEqual(seq.values.shape, (0</b></font>, ))
            npt.assert_equal(seq.values, np.array('', dtype='c'))
            self.assertEqual(str(seq), '')
            self.assertEqual(len(seq), 0)

            self.assertFalse(seq.metadata)
            self.assertEqual(seq.metadata, {})

            self.assertEqual(seq.interval_metadata,
                             IntervalMetadata(0))

            assert_data_frame_almost_equal(seq.positional_metadata,
                                           pd.DataFrame(index=range(0)))

    def test_init_single_character_sequence(self):
        for s in (b'A',
                  'A',
                  np.array('A', dtype='c'),
                  np.frombuffer(b'A', dtype=np.uint8),
<a name="30"></a>                  Sequence('A')):
            seq = Sequence(s)

            self.assertIsInstance<font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq.values, np.ndarray)
            self.assertEqual(seq.values.dtype, '|S1')
            self.assertEqual(seq.values.shape, (1,))
            npt.</b></font>assert_equal(seq.values, np.array('A', dtype='c'))
            self.assertEqual(str(seq), 'A')
            self.assertEqual(len(seq), 1)

            self.assertFalse(seq.metadata)
            self.assertEqual(seq.metadata, {})

            self.assertEqual(seq.interval_metadata,
                             IntervalMetadata(1))
            assert_data_frame_almost_equal(seq.positional_metadata,
                                           pd.DataFrame(index=range(1)))

    def test_init_multiple_character_sequence(self):
        for s in (b'.ABC\t123  xyz-',
                  '.ABC\t123  xyz-',
                  np.array('.ABC\t123  xyz-', dtype='c'),
                  np.frombuffer(b'.ABC\t123  xyz-', dtype=np.uint8),
<a name="45"></a>                  Sequence('.ABC\t123  xyz-')):
            seq = Sequence(s)

            self<font color="#549748"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIsInstance(seq.values, np.ndarray)
            self.assertEqual(seq.values.dtype, '|S1')
            self.assertEqual(seq.values.</b></font>shape, (14,))
            npt.assert_equal(seq.values,
                             np.array('.ABC\t123  xyz-', dtype='c'))
            self.assertEqual(str(seq), '.ABC\t123  xyz-')
            self.assertEqual(len(seq), 14)

            self.assertFalse(seq.metadata)
            self.assertEqual(seq.metadata, {})

            self.assertEqual(seq.interval_metadata,
                             IntervalMetadata(14))
            assert_data_frame_almost_equal(seq.positional_metadata,
                                           pd.DataFrame(index=range(14)))

    def test_init_from_sequence_object(self):
        # We're testing this in its simplest form in other tests. This test
        # exercises more complicated cases of building a sequence from another
        # sequence.

        # just the sequence, no other metadata
        seq = Sequence('ACGT')
        self.assertEqual(Sequence(seq), seq)

        # sequence with metadata should have everything propagated
        seq = Sequence('ACGT',
                       metadata={'id': 'foo', 'description': 'bar baz'},
                       positional_metadata={'quality': range(4)})
        seq.interval_metadata.add([(0, 1)], metadata={'gene': 'sagA'})
        self.assertEqual(Sequence(seq), seq)

        # should be able to override metadata
        im = IntervalMetadata(4)
        im.add([(0, 2)], metadata={'gene': 'sagB'})
        self.assertEqual(
            Sequence(seq, metadata={'id': 'abc', 'description': '123'},
                     positional_metadata={'quality': [42] * 4},
                     interval_metadata=im),
            Sequence('ACGT', metadata={'id': 'abc', 'description': '123'},
                     positional_metadata={'quality': [42] * 4},
                     interval_metadata=im))

        # subclasses work too
        im = IntervalMetadata(4)
        im.add([(0, 2)], metadata={'gene': 'sagB'})
        seq = SequenceSubclass('ACGT',
                               metadata={'id': 'foo',
                                         'description': 'bar baz'},
                               positional_metadata={'quality': range(4)},
                               interval_metadata=im)

        self.assertEqual(
            Sequence(seq),
            Sequence('ACGT', metadata={'id': 'foo', 'description': 'bar baz'},
                     positional_metadata={'quality': range(4)},
                     interval_metadata=im))

    def test_init_from_non_descendant_sequence_object(self):
        seq = SequenceSubclass('ACGT')
        with self.assertRaises(TypeError) as cm:
<a name="44"></a>            SequenceSubclassTwo(seq)

        error = str(cm.exception)
        self<font color="#a057a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIn("SequenceSubclass", error)
        self.assertIn("SequenceSubclassTwo", error)
        self.assertIn("cast", error)

    def test_init_from_contiguous_sequence_bytes_view(self):
        bytes = np.array([65</b></font>, 42, 66, 42, 65], dtype=np.uint8)
        view = bytes[:3]
        seq = Sequence(view)

        # sequence should be what we'd expect
        self.assertEqual(seq, Sequence('A*B'))

        # we shouldn't own the memory because no copy should have been made
        self.assertFalse(seq._owns_bytes)

        # can't mutate view because it isn't writeable anymore
        with self.assertRaises(ValueError):
<a name="21"></a>            view[1] = 100

        # sequence shouldn't have changed
        self<font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq, Sequence('A*B'))

        # mutate bytes (*not* the view)
        bytes[0] = 99

        # Sequence changed because we are only able to make the view read-only,
        # not its source (bytes). This is somewhat inconsistent behavior that
        # is (to the best of our knowledge) outside our control.
        self.assertEqual(seq, Sequence('c*B'))

    def test_init_from_noncontiguous_sequence_bytes_view(self):
        bytes = np.array([65</b></font>, 42, 66, 42, 65], dtype=np.uint8)
        view = bytes[::2]
        seq = Sequence(view)

        # sequence should be what we'd expect
        self.assertEqual(seq, Sequence('ABA'))

        # we should own the memory because a copy should have been made
        self.assertTrue(seq._owns_bytes)

        # mutate bytes and its view
        bytes[0] = 99
        view[1] = 100

        # sequence shouldn't have changed
        self.assertEqual(seq, Sequence('ABA'))

    def test_init_no_copy_of_sequence(self):
        bytes = np.array([65, 66, 65], dtype=np.uint8)
        seq = Sequence(bytes)

        # should share the same memory
        self.assertIs(seq._bytes, bytes)

        # shouldn't be able to mutate the Sequence object's internals by
        # mutating the shared memory
        with self.assertRaises(ValueError):
            bytes[1] = 42

    def test_init_invalid_sequence(self):
        # invalid dtype (numpy.ndarray input)
        with self.assertRaises(TypeError):
            # int64
            Sequence(np.array([1, 2, 3]))
        with self.assertRaises(TypeError):
            # |S21
            Sequence(np.array([1, "23", 3]))
        with self.assertRaises(TypeError):
            # object
            Sequence(np.array([1, {}, ()]))

        # invalid input type (non-numpy.ndarray input)
        with self.assertRaisesRegex(TypeError, r'tuple'):
            Sequence(('a', 'b', 'c'))
        with self.assertRaisesRegex(TypeError, r'list'):
            Sequence(['a', 'b', 'c'])
        with self.assertRaisesRegex(TypeError, r'set'):
            Sequence({'a', 'b', 'c'})
        with self.assertRaisesRegex(TypeError, r'dict'):
            Sequence({'a': 42, 'b': 43, 'c': 44})
        with self.assertRaisesRegex(TypeError, r'int'):
            Sequence(42)
        with self.assertRaisesRegex(TypeError, r'float'):
            Sequence(4.2)
        with self.assertRaisesRegex(TypeError, r'int64'):
            Sequence(np.int_(50))
        with self.assertRaisesRegex(TypeError, r'float64'):
            Sequence(np.float_(50))
        with self.assertRaisesRegex(TypeError, r'Foo'):
            class Foo:
                pass
            Sequence(Foo())

        # out of ASCII range
        with self.assertRaises(UnicodeEncodeError):
            Sequence('abc\u1F30')

    def test_values_property(self):
        # Property tests are only concerned with testing the interface
        # provided by the property: that it can be accessed, can't be
        # reassigned or mutated in place, and that the correct type is
        # returned. More extensive testing of border cases (e.g., different
        # sequence lengths or input types, odd characters, etc.) are performed
        # in Sequence.__init__ tests.

        seq = Sequence('ACGT')

        # should get back a numpy.ndarray of '|S1' dtype
        self.assertIsInstance(seq.values, np.ndarray)
        self.assertEqual(seq.values.dtype, '|S1')
        npt.assert_equal(seq.values, np.array('ACGT', dtype='c'))

        # test that we can't mutate the property
        with self.assertRaises(ValueError):
            seq.values[1] = 'A'

        # test that we can't set the property
        with self.assertRaises(AttributeError):
            seq.values = np.array("GGGG", dtype='c')

<a name="43"></a>    def test_sequence_numpy_compatibility(self):
        seq = Sequence('abc123')

        array = np<font color="#c22817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.asarray(seq)

        self.assertIsInstance(array, np.ndarray)
        self.assertEqual(array.dtype, '|S1')
        npt.assert_equal(array, np.array(</b></font>'abc123', dtype='c'))
        npt.assert_equal(array, seq.values)

        with self.assertRaises(ValueError):
            array[1] = 'B'

    def test_observed_chars_property(self):
        self.assertEqual(Sequence('').observed_chars, set())
<a name="29"></a>        self.assertEqual(Sequence('x').observed_chars, {'x'})
        self.assertEqual(Sequence('xYz').observed_chars, {'x', 'Y', 'z'})
        self.assertEqual(Sequence('zzz').observed_chars, {'z'})
        self.assertEqual(Sequence('xYzxxZz')<font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.observed_chars,
                         {'x', 'Y', 'z', 'Z'})
        self.assertEqual(Sequence('\t   ').observed_chars, {' ', '\t'})

        im = IntervalMetadata(6)
        im.add([(0</b></font>, 2)], metadata={'gene': 'sagB'})
        self.assertEqual(
            Sequence('aabbcc', metadata={'foo': 'bar'},
                     positional_metadata={'foo': range(6)},
                     interval_metadata=im).observed_chars,
            {'a', 'b', 'c'})

        with self.assertRaises(AttributeError):
            Sequence('ACGT').observed_chars = {'a', 'b', 'c'}

    def test_eq_and_ne(self):
        seq_a = Sequence("A")
        seq_b = Sequence("B")

        im = IntervalMetadata(1)
        im.add([(0, 1)], metadata={'gene': 'sagA'})
        im2 = IntervalMetadata(1)
        im.add([(0, 1)], metadata={'gene': 'sagB'})

        self.assertTrue(seq_a == seq_a)
        self.assertTrue(Sequence("a") == Sequence("a"))
        self.assertTrue(Sequence("a", metadata={'id': 'b'}) ==
                        Sequence("a", metadata={'id': 'b'}))
        self.assertTrue(Sequence("a",
                                 metadata={'id': 'b', 'description': 'c'}) ==
                        Sequence("a",
                                 metadata={'id': 'b', 'description': 'c'}))
        self.assertTrue(Sequence("a", metadata={'id': 'b', 'description': 'c'},
                                 positional_metadata={'quality': [1]},
                                 interval_metadata=im) ==
                        Sequence("a", metadata={'id': 'b', 'description': 'c'},
                                 positional_metadata={'quality': [1]},
                                 interval_metadata=im))

        self.assertTrue(seq_a != seq_b)
        self.assertTrue(SequenceSubclass("a") != Sequence("a"))
        self.assertTrue(Sequence("a") != Sequence("b"))
        self.assertTrue(Sequence("a") != Sequence("a", metadata={'id': 'b'}))
        self.assertTrue(Sequence("a", metadata={'id': 'c'}) !=
                        Sequence("a",
                                 metadata={'id': 'c', 'description': 't'}))
        self.assertTrue(Sequence("a", positional_metadata={'quality': [1]}) !=
                        Sequence("a"))
        self.assertTrue(Sequence("a", interval_metadata=im) !=
                        Sequence("a"))

        self.assertTrue(Sequence("a", positional_metadata={'quality': [1]}) !=
                        Sequence("a", positional_metadata={'quality': [2]}))
        self.assertTrue(Sequence("a", interval_metadata=im) !=
                        Sequence("a", interval_metadata=im2))

        self.assertTrue(Sequence("c", positional_metadata={'quality': [3]}) !=
                        Sequence("b", positional_metadata={'quality': [3]}))
        self.assertTrue(Sequence("c", interval_metadata=im) !=
                        Sequence("b", interval_metadata=im))
        self.assertTrue(Sequence("a", metadata={'id': 'b'}) !=
                        Sequence("c", metadata={'id': 'b'}))

    def test_eq_sequences_without_metadata_compare_equal(self):
        self.assertTrue(Sequence('') == Sequence(''))
        self.assertTrue(Sequence('z') == Sequence('z'))
        self.assertTrue(
            Sequence('ACGT') == Sequence('ACGT'))

<a name="42"></a>    def test_eq_sequences_with_metadata_compare_equal(self):
        seq1 = Sequence('ACGT', metadata={'id': 'foo', 'desc': 'abc'},
                        positional_metadata={'qual': [1, 2, 3, 4]})
        seq2 = Sequence('ACGT', metadata<font color="#c57717"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'id': 'foo', 'desc': 'abc'},
                        positional_metadata={'qual': [1, 2, 3, 4]})
        self.assertTrue(seq1 == seq2)

        # order shouldn't matter
        self.assertTrue(seq2 == seq1)

    def test_eq_sequences_from_different_sources_compare_equal(self):
        # sequences that have the same data but are constructed from different
        # types of data should compare equal
        im =</b></font> IntervalMetadata(4)
        im.add([(0, 2)], metadata={'gene': 'sagB'})
        seq1 = Sequence('ACGT', metadata={'id': 'foo', 'desc': 'abc'},
                        positional_metadata={'quality': (1, 2, 3, 4)},
                        interval_metadata=im)
        seq2 = Sequence(np.array([65, 67, 71, 84], dtype=np.uint8),
                        metadata={'id': 'foo', 'desc': 'abc'},
                        positional_metadata={'quality': np.array([1, 2, 3,
                                                                  4])},
                        interval_metadata=im)
        self.assertTrue(seq1 == seq2)

    def test_eq_type_mismatch(self):
        seq1 = Sequence('ACGT')
        seq2 = SequenceSubclass('ACGT')
        self.assertFalse(seq1 == seq2)

    def test_eq_positional_metadata_mismatch(self):
        # both provided
        seq1 = Sequence('ACGT', positional_metadata={'quality': [1, 2, 3, 4]})
        seq2 = Sequence('ACGT', positional_metadata={'quality': [1, 2, 3, 5]})
        self.assertFalse(seq1 == seq2)

        # one provided
        seq1 = Sequence('ACGT', positional_metadata={'quality': [1, 2, 3, 4]})
        seq2 = Sequence('ACGT')
        self.assertFalse(seq1 == seq2)

    def test_eq_interval_metadata_mismatch(self):
        im1 = IntervalMetadata(4)
        im1.add([(0, 3)], metadata={'gene': 'sagA'})
        im2 = IntervalMetadata(4)
        im2.add([(0, 2)], metadata={'gene': 'sagA'})
        # both provided
        seq1 = Sequence('ACGT', interval_metadata=im1)
        seq2 = Sequence('ACGT', interval_metadata=im2)
        self.assertFalse(seq1 == seq2)

        # one provided
        seq1 = Sequence('ACGT', interval_metadata=im1)
        seq2 = Sequence('ACGT')
        self.assertFalse(seq1 == seq2)

    def test_eq_sequence_mismatch(self):
        seq1 = Sequence('ACGT')
        seq2 = Sequence('TGCA')
        self.assertFalse(seq1 == seq2)

    def test_getitem_gives_new_sequence(self):
        seq = Sequence("Sequence string !1@2#3?.,")
        self.assertFalse(seq is seq[:])

    def test_getitem_drops_interval_metadata(self):
        s = "Sequence string !1@2#3?.,"
        seq = Sequence(s, metadata={'id': 'id', 'description': 'dsc'})
        seq.interval_metadata.add([(0, 3)], metadata={'gene': 'sagA'})

        eseq = Sequence('Se', metadata={'id': 'id', 'description': 'dsc'})
        self.assertEqual(seq[:2], eseq)

    def test_getitem_with_int_has_positional_metadata(self):
        s = "Sequence string !1@2#3?.,"
        length = len(s)
        seq = Sequence(s, metadata={'id': 'id', 'description': 'dsc'},
                       positional_metadata={'quality': np.arange(length)})

        eseq = Sequence("S", {'id': 'id', 'description': 'dsc'},
                        positional_metadata={'quality': np.array([0])})
        self.assertEqual(seq[0], eseq)

        eseq = Sequence(",", metadata={'id': 'id', 'description': 'dsc'},
                        positional_metadata={'quality':
                                             np.array([len(seq) - 1])})
        self.assertEqual(seq[len(seq) - 1], eseq)

        eseq = Sequence("t", metadata={'id': 'id', 'description': 'dsc'},
                        positional_metadata={'quality': [10]})
        self.assertEqual(seq[10], eseq)

    def test_single_index_to_slice(self):
        a = [1, 2, 3, 4]
        self.assertEqual(slice(0, 1), _single_index_to_slice(0))
        self.assertEqual([1], a[_single_index_to_slice(0)])
        self.assertEqual(slice(-1, None),
                         _single_index_to_slice(-1))
        self.assertEqual([4], a[_single_index_to_slice(-1)])

    def test_is_single_index(self):
        self.assertTrue(_is_single_index(0))
        self.assertFalse(_is_single_index(True))
        self.assertFalse(_is_single_index(bool()))
        self.assertFalse(_is_single_index('a'))

    def test_as_slice_if_single_index(self):
        self.assertEqual(slice(0, 1), _as_slice_if_single_index(0))
        slice_obj = slice(2, 3)
        self.assertIs(slice_obj,
                      _as_slice_if_single_index(slice_obj))

    def test_slice_positional_metadata(self):
        seq = Sequence('ABCDEFGHIJ',
                       positional_metadata={'foo': np.arange(10),
                                            'bar': np.arange(100, 110)})
        self.assertTrue(pd.DataFrame({'foo': [0], 'bar': [100]}).equals(
                        seq._slice_positional_metadata(0)))
        self.assertTrue(pd.DataFrame({'foo': [0], 'bar': [100]}).equals(
                        seq._slice_positional_metadata(slice(0, 1))))
        self.assertTrue(pd.DataFrame({'foo': [0, 1],
                                      'bar': [100, 101]}).equals(
                        seq._slice_positional_metadata(slice(0, 2))))
        self.assertTrue(pd.DataFrame(
            {'foo': [9], 'bar': [109]}, index=[9]).equals(
                seq._slice_positional_metadata(9)))

    def test_getitem_with_int_no_positional_metadata(self):
        seq = Sequence("Sequence string !1@2#3?.,",
                       metadata={'id': 'id2', 'description': 'no_qual'})

        eseq = Sequence("t", metadata={'id': 'id2', 'description': 'no_qual'})
        self.assertEqual(seq[10], eseq)

    def test_getitem_with_slice_has_positional_metadata(self):
        s = "0123456789abcdef"
        length = len(s)
        seq = Sequence(s, metadata={'id': 'id3', 'description': 'dsc3'},
<a name="28"></a>                       positional_metadata={'quality': np.arange(length)})

        eseq = Sequence("012", metadata={'id': 'id3', 'description': 'dsc3'},
                        positional_metadata<font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'quality': np.arange(3)})
        self.assertEqual(seq[0:3], eseq)
        self.assertEqual(seq[:3], eseq)
        self.assertEqual(seq[</b></font>:3:1], eseq)

        eseq = Sequence("def", metadata={'id': 'id3', 'description': 'dsc3'},
                        positional_metadata={'quality': [13, 14, 15]})
        self.assertEqual(seq[-3:], eseq)
        self.assertEqual(seq[-3::1], eseq)

        eseq = Sequence("02468ace",
                        metadata={'id': 'id3', 'description': 'dsc3'},
                        positional_metadata={'quality': [0, 2, 4, 6, 8, 10,
                                                         12, 14]})
        self.assertEqual(seq[0:length:2], eseq)
        self.assertEqual(seq[::2], eseq)

        eseq = Sequence(s[::-1], metadata={'id': 'id3', 'description': 'dsc3'},
                        positional_metadata={'quality':
                                             np.arange(length)[::-1]})
        self.assertEqual(seq[length::-1], eseq)
        self.assertEqual(seq[::-1], eseq)

        eseq = Sequence('fdb97531',
                        metadata={'id': 'id3', 'description': 'dsc3'},
                        positional_metadata={'quality': [15, 13, 11, 9, 7, 5,
                                                         3, 1]})
        self.assertEqual(seq[length::-2], eseq)
        self.assertEqual(seq[::-2], eseq)

<a name="20"></a>        self.assertEqual(seq[0:500:], seq)

        eseq = Sequence('', metadata={'id': 'id3', 'description': 'dsc3'},
                        positional_metadata={<font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'quality':
                                             np.array([], dtype=np.int64)})
        self.assertEqual(seq[length:0], eseq)
        self.assertEqual(seq[-length:0], eseq)
        self.assertEqual(seq[</b></font>1:0], eseq)

        eseq = Sequence("0", metadata={'id': 'id3', 'description': 'dsc3'},
                        positional_metadata={'quality': [0]})
        self.assertEqual(seq[0:1], eseq)
        self.assertEqual(seq[0:1:1], eseq)
        self.assertEqual(seq[-length::-1], eseq)

    def test_getitem_with_slice_no_positional_metadata(self):
        s = "0123456789abcdef"
        length = len(s)
        seq = Sequence(s, metadata={'id': 'id4', 'description': 'no_qual4'})

        eseq = Sequence("02468ace",
                        metadata={'id': 'id4', 'description': 'no_qual4'})
        self.assertEqual(seq[0:length:2], eseq)
        self.assertEqual(seq[::2], eseq)

    def test_getitem_with_tuple_of_mixed_with_positional_metadata(self):
        s = "0123456789abcdef"
        length = len(s)
        seq = Sequence(s, metadata={'id': 'id5', 'description': 'dsc5'},
<a name="8"></a>                       positional_metadata={'quality': np.arange(length)})

        eseq = Sequence("00000", metadata={'id': 'id5', 'description': 'dsc5'},
                        positional_metadata={'quality': [<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, 0, 0, 0, 0]})
        self.assertEqual(seq[0, 0, 0, 0, 0], eseq)
        self.assertEqual(seq[0, 0:1, 0, 0, 0], eseq)
        self.assertEqual(seq[0, 0:1, 0, -length::-1, 0, 1:0], eseq)
        self.assertEqual(seq[0:1, 0:1, 0:1, 0:1, 0:1], eseq)
        self.assertEqual(seq[</b></font>0:1, 0, 0, 0, 0], eseq)
<a name="27"></a>
        eseq = Sequence("0123fed9",
                        metadata={'id': 'id5', 'description': 'dsc5'},
                        positional_metadata={'quality': [<font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, 1, 2, 3, 15, 14,
                                                         13, 9]})
        self.assertEqual(seq[0, 1, 2, 3, 15, 14, 13, 9], eseq)
        self.assertEqual(seq[0, 1, 2, 3, :-4:-1, 9], eseq)
        self.assertEqual(seq[0:4, :-4:-1, 9, 1:0], eseq)
        self.assertEqual(seq[</b></font>0:4, :-4:-1, 9:10], eseq)

<a name="14"></a>    def test_getitem_with_tuple_of_mixed_no_positional_metadata(self):
        seq = Sequence("0123456789abcdef",
                       metadata={'id': 'id6', 'description': 'no_qual6'})
        eseq = Sequence<font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("0123fed9",
                        metadata={'id': 'id6', 'description': 'no_qual6'})
        self.assertEqual(seq[0, 1, 2, 3, 15, 14, 13, 9], eseq)
        self.assertEqual(seq[0, 1, 2, 3, :-4:-1, 9], eseq)
        self.assertEqual(seq[0:4, :-4:-1, 9], eseq)
        self.assertEqual(seq[</b></font>0:4, :-4:-1, 9:10], eseq)

<a name="41"></a>    def test_getitem_with_tuple_of_mixed_no_metadata(self):
        seq = Sequence("0123456789abcdef")
        eseq = Sequence("0123fed9")
        self<font color="#f87a17"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq[0, 1, 2, 3, 15, 14, 13, 9], eseq)
        self.assertEqual(seq[0, 1, 2, 3, :-4:-1, 9], eseq)
        self.assertEqual(seq[0:4, :-4:-1, 9], eseq)
        self.assertEqual(seq[</b></font>0:4, :-4:-1, 9:10], eseq)

    def test_getitem_with_iterable_of_mixed_has_positional_metadata(self):
        s = "0123456789abcdef"
        length = len(s)
        seq = Sequence(s, metadata={'id': 'id7', 'description': 'dsc7'},
                       positional_metadata={'quality': np.arange(length)})

        def generator():
            yield slice(0, 4)
            yield slice(200, 400)
            yield -1
            yield slice(-2, -4, -1)
            yield 9

        eseq = Sequence("0123fed9",
                        metadata={'id': 'id7', 'description': 'dsc7'},
                        positional_metadata={'quality': [0, 1, 2, 3, 15, 14,
                                                         13, 9]})
        self.assertEqual(seq[[0, 1, 2, 3, 15, 14, 13, 9]], eseq)
        self.assertEqual(seq[generator()], eseq)
        self.assertEqual(seq[[slice(0, 4), slice(None, -4, -1), 9]], eseq)
        self.assertEqual(seq[
            [slice(0, 4), slice(None, -4, -1), slice(9, 10)]], eseq)

    def test_getitem_with_iterable_of_mixed_no_positional_metadata(self):
        s = "0123456789abcdef"
        seq = Sequence(s, metadata={'id': 'id7', 'description': 'dsc7'})

        def generator():
            yield slice(0, 4)
            yield slice(200, 400)
            yield slice(None, -4, -1)
            yield 9

        eseq = Sequence("0123fed9",
                        metadata={'id': 'id7', 'description': 'dsc7'})
        self.assertEqual(seq[[0, 1, 2, 3, 15, 14, 13, 9]], eseq)
        self.assertEqual(seq[generator()], eseq)
        self.assertEqual(seq[[slice(0, 4), slice(None, -4, -1), 9]], eseq)
        self.assertEqual(seq[
            [slice(0, 4), slice(None, -4, -1), slice(9, 10)]], eseq)

    def test_getitem_with_numpy_index_has_positional_metadata(self):
        s = "0123456789abcdef"
        length = len(s)
        seq = Sequence(s, metadata={'id': 'id9', 'description': 'dsc9'},
                       positional_metadata={'quality': np.arange(length)})

        eseq = Sequence("0123fed9",
                        metadata={'id': 'id9', 'description': 'dsc9'},
                        positional_metadata={'quality': [0, 1, 2, 3, 15, 14,
                                                         13, 9]})
        self.assertEqual(seq[np.array([0, 1, 2, 3, 15, 14, 13, 9])], eseq)

    def test_getitem_with_numpy_index_no_positional_metadata(self):
        s = "0123456789abcdef"
        seq = Sequence(s, metadata={'id': 'id10', 'description': 'dsc10'})

        eseq = Sequence("0123fed9",
                        metadata={'id': 'id10', 'description': 'dsc10'})
        self.assertEqual(seq[np.array([0, 1, 2, 3, 15, 14, 13, 9])], eseq)

    def test_getitem_with_empty_indices_empty_seq_no_pos_metadata(self):
        s = ""
        seq = Sequence(s, metadata={'id': 'id10', 'description': 'dsc10'})

        eseq = Sequence('', metadata={'id': 'id10', 'description': 'dsc10'})

        tested = 0
        for index in self.getitem_empty_indices:
            tested += 1
            self.assertEqual(seq[index], eseq)
        self.assertEqual(tested, 6)

    def test_getitem_with_empty_indices_non_empty_seq_no_pos_metadata(self):
        s = "0123456789abcdef"
        seq = Sequence(s, metadata={'id': 'id10', 'description': 'dsc10'})

        eseq = Sequence('', metadata={'id': 'id10', 'description': 'dsc10'})

        tested = 0
        for index in self.getitem_empty_indices:
            tested += 1
            self.assertEqual(seq[index], eseq)
        self.assertEqual(tested, 6)

    def test_getitem_with_boolean_vector_has_qual(self):
        s = "0123456789abcdef"
        length = len(s)
        seq = Sequence(s, metadata={'id': 'id11', 'description': 'dsc11'},
                       positional_metadata={'quality': np.arange(length)})

        eseq = Sequence("13579bdf",
                        metadata={'id': 'id11', 'description': 'dsc11'},
                        positional_metadata={'quality': [1, 3, 5, 7, 9, 11,
                                                         13, 15]})

        self.assertEqual(seq[np.array([False, True] * 8)], eseq)
        self.assertEqual(seq[[False, True] * 8], eseq)

    def test_getitem_with_boolean_vector_no_positional_metadata(self):
        s = "0123456789abcdef"
        seq = Sequence(s, metadata={'id': 'id11', 'description': 'dsc11'})

        eseq = Sequence("13579bdf",
                        metadata={'id': 'id11', 'description': 'dsc11'})

        self.assertEqual(seq[np.array([False, True] * 8)], eseq)

    def test_getitem_with_invalid(self):
        seq = Sequence("123456",
                       metadata={'id': 'idm', 'description': 'description'},
                       positional_metadata={'quality': [1, 2, 3, 4, 5, 6]})

        with self.assertRaises(IndexError):
            seq['not an index']

        with self.assertRaises(IndexError):
            seq[['1', '2']]

        with self.assertRaises(IndexError):
            seq[[1, slice(1, 2), 'a']]

        with self.assertRaises(IndexError):
            seq[[1, slice(1, 2), True]]

        with self.assertRaises(IndexError):
            seq[True]

        with self.assertRaises(IndexError):
            seq[np.array([True, False])]

        with self.assertRaises(IndexError):
            seq[999]

        with self.assertRaises(IndexError):
            seq[0, 0, 999]

        # numpy 1.8.1 and 1.9.2 raise different error types
        # (ValueError, IndexError).
        with self.assertRaises(Exception):
            seq[100 * [True, False, True]]

    def test_getitem_empty_positional_metadata(self):
        seq = Sequence('ACGT')
        seq.positional_metadata  # This will create empty positional_metadata
        self.assertEqual(Sequence('A'), seq[0])

    def test_len(self):
        self.assertEqual(len(Sequence("")), 0)
        self.assertEqual(len(Sequence("a")), 1)
        self.assertEqual(len(Sequence("abcdef")), 6)

    def test_nonzero(self):
<a name="40"></a>        # blank
        self.assertFalse(Sequence(""))
        self.assertFalse(Sequence("",
                                  metadata={<font color="#347235"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'id': 'foo'},
                                  positional_metadata={'quality': range(0)}))
        # single
        self.assertTrue(Sequence("A"))
        self.assertTrue(Sequence("A",
                                 metadata={'id'</b></font>: 'foo'},
                                 positional_metadata={'quality': range(1)}))
        # multi
        self.assertTrue(Sequence("ACGT"))
        self.assertTrue(Sequence("ACGT",
                                 metadata={'id': 'foo'},
                                 positional_metadata={'quality': range(4)}))

    def test_contains(self):
        seq = Sequence("#@ACGT,24.13**02")
<a name="19"></a>        tested = 0
        for c in self.sequence_kinds:
            tested += 1
            self<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertTrue(c(',24') in seq)
            self.assertTrue(c('*') in seq)
            self.assertTrue(c('') in seq)

            self.assertFalse(c("$") in seq)
            self.assertFalse(</b></font>c("AGT") in seq)

        self.assertEqual(tested, 4)

    def test_contains_sequence_subclass(self):
        with self.assertRaises(TypeError):
            SequenceSubclass("A") in Sequence("AAA")

        self.assertTrue(SequenceSubclass("A").values in Sequence("AAA"))

    def test_hash(self):
        with self.assertRaises(TypeError):
            hash(Sequence("ABCDEFG"))
        self.assertNotIsInstance(Sequence("ABCDEFG"), Hashable)

    def test_iter_has_positional_metadata(self):
        tested = False
        seq = Sequence("0123456789", metadata={'id': 'a', 'desc': 'b'},
                       positional_metadata={'qual': np.arange(10)})
        for i, s in enumerate(seq):
            tested = True
            self.assertEqual(s, Sequence(str(i),
                                         metadata={'id': 'a', 'desc': 'b'},
                                         positional_metadata={'qual': [i]}))
        self.assertTrue(tested)

    def test_iter_no_positional_metadata(self):
        tested = False
        seq = Sequence("0123456789", metadata={'id': 'a', 'desc': 'b'})
        for i, s in enumerate(seq):
            tested = True
            self.assertEqual(s, Sequence(str(i),
                                         metadata={'id': 'a', 'desc': 'b'}))
        self.assertTrue(tested)

    def test_reversed_has_positional_metadata(self):
        tested = False
        seq = Sequence("0123456789", metadata={'id': 'a', 'desc': 'b'},
                       positional_metadata={'qual': np.arange(10)})
        for i, s in enumerate(reversed(seq)):
            tested = True
            self.assertEqual(s, Sequence(str(9 - i),
                                         metadata={'id': 'a', 'desc': 'b'},
                                         positional_metadata={'qual':
                                                              [9 - i]}))
        self.assertTrue(tested)

    def test_reversed_no_positional_metadata(self):
        tested = False
        seq = Sequence("0123456789", metadata={'id': 'a', 'desc': 'b'})
        for i, s in enumerate(reversed(seq)):
            tested = True
            self.assertEqual(s, Sequence(str(9 - i),
                                         metadata={'id': 'a', 'desc': 'b'}))
        self.assertTrue(tested)

    def test_repr(self):
        # basic sanity checks -- more extensive testing of formatting and
        # special cases is performed in SequenceReprDoctests below. here we
        # only test that pieces of the repr are present. these tests also
        # exercise coverage in case doctests stop counting towards coverage in
        # the future
<a name="13"></a>
        # minimal
        obs = repr(Sequence(''))
        self<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(obs.count('\n'), 4)
        self.assertTrue(obs.startswith('Sequence'))
        self.assertIn('length: 0', obs)
        self.assertTrue(obs.endswith('-'))
<a name="26"></a>
        # no metadata
        obs =</b></font> repr(Sequence('ACGT'))
        self<font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(obs.count('\n'), 5)
        self.assertTrue(obs.startswith('Sequence'))
        self.assertIn('length: 4', obs)
        self.assertTrue(obs.</b></font>endswith('0 ACGT'))

        # metadata and positional metadata of mixed types
        obs = repr(
            Sequence(
                'ACGT',
                metadata={'foo': 'bar', b'bar': 33.33, None: True, False: {},
<a name="6"></a>                          (1, 2): 3, 'acb' * 100: "'", 10: 11},
                positional_metadata={'foo': range(4),
                                     42: ['a', 'b', [], 'c']}))
        self<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(obs.count('\n'), 16)
        self.assertTrue(obs.startswith('Sequence'))
        self.assertIn('None: True', obs)
        self.assertIn('\'foo\': \'bar\'', obs)
        self.assertIn('42: &lt;dtype: object&gt;', obs)
        self.assertIn('\'foo\': &lt;dtype: int64&gt;', obs)
        self.</b></font>assertIn('length: 4', obs)
        self.assertTrue(obs.endswith('0 ACGT'))

        # sequence spanning &gt; 5 lines
        obs = repr(Sequence('A' * 301))
        self.assertEqual(obs.count('\n'), 9)
        self.assertTrue(obs.startswith('Sequence'))
        self.assertIn('length: 301', obs)
        self.assertIn('...', obs)
        self.assertTrue(obs.endswith('300 A'))

    def test_str(self):
        self.assertEqual(str(Sequence("GATTACA")), "GATTACA")
        self.assertEqual(str(Sequence("ACCGGTACC")), "ACCGGTACC")
        self.assertEqual(str(Sequence("GREG")), "GREG")
        self.assertEqual(
            str(Sequence("ABC",
                         positional_metadata={'quality': [1, 2, 3]})),
            "ABC")
        self.assertIs(type(str(Sequence("A"))), str)

    def test_count(self):
        def construct_char_array(s):
            return np.frombuffer(s.encode('ascii'), dtype='|S1')

        def construct_uint8_array(s):
            return np.frombuffer(s.encode('ascii'), dtype=np.uint8)

        seq = Sequence("1234567899876555")
        tested = 0
        for c in self.sequence_kinds:
            tested += 1
            self.assertEqual(seq.count(c('4')), 1)
            self.assertEqual(seq.count(c('8')), 2)
            self.assertEqual(seq.count(c('5')), 4)
            self.assertEqual(seq.count(c('555')), 1)
            self.assertEqual(seq.count(c('555'), 0, 4), 0)
            self.assertEqual(seq.count(c('555'), start=0, end=4), 0)
            self.assertEqual(seq.count(c('5'), start=10), 3)
            self.assertEqual(seq.count(c('5'), end=10), 1)

            with self.assertRaises(ValueError):
                seq.count(c(''))

        self.assertEqual(tested, 4)

    def test_count_on_subclass(self):
        with self.assertRaises(TypeError) as cm:
            Sequence("abcd").count(SequenceSubclass("a"))

        self.assertIn("Sequence", str(cm.exception))
        self.assertIn("SequenceSubclass", str(cm.exception))

    def test_replace_sanity(self):
        seq = Sequence('AAGCATGCCCTTTACATTTG')
        index = self._make_index('10011011001111110111')
        obs = seq.replace(index, '_')
        exp = Sequence('_AG__T__CC______T___')
        self.assertEqual(obs, exp)

    def test_replace_index_array(self):
        seq = Sequence('TCGGGTGTTGTGCAACCACC')
        for _type in list, tuple, np.array, pd.Series:
            index = _type([0, 2, 5, 8, 9])
            obs = seq.replace(index, '-')
            exp = Sequence('-C-GG-GT--TGCAACCACC')
            self.assertEqual(obs, exp)

    def test_replace_iterable_slices(self):
        seq = Sequence('CATTATGGACCCAGCGTGCC')
        slices = (slice(0, 5), slice(8, 12), slice(15, 17))
        mixed_slices = (0, 1, 2, 3, 4, slice(8, 12), 15, 16)
        for _type in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
                      lambda x: pd.Series(tuple(x))):
            index = (_type(slices), _type(mixed_slices))
            obs_slices = seq.replace(index[0], '-')
            obs_mixed = seq.replace(index[1], '-')
            exp = Sequence('-----TGG----AGC--GCC')
            self.assertEqual(obs_slices, exp)
            self.assertEqual(obs_mixed, exp)

    def test_replace_index_in_positional_metadata(self):
        positional_metadata = {'where': self._make_index('001110110'
                                                         '10001110000')}
        seq = Sequence('AAGATTGATACCACAGTTGT',
                       positional_metadata=positional_metadata)
        obs = seq.replace('where', '-')
        exp = Sequence('AA---T--T-CCA---TTGT',
                       positional_metadata=positional_metadata)
        self.assertEqual(obs, exp)

    def test_replace_does_not_mutate_original(self):
        seq = Sequence('ATCG')
        index = self._make_index('0011')
        seq.replace(index, '-')
        obs = seq
        exp = Sequence('ATCG')
        self.assertEqual(obs, exp)

    def test_replace_with_metadata(self):
        seq = Sequence('GCACGGCAAGAAGCGCCCCA',
                       metadata={'NM': 'Kestrel Gorlick'},
                       positional_metadata={'diff':
                                            list('01100001110010001100')})
        seq.interval_metadata.add([(0, 1)], metadata={'gene': 'sagA'})

        index = self._make_index('01100001110010001100')
        obs = seq.replace(index, '-')
        exp = Sequence('G--CGGC---AA-CGC--CA',
                       metadata={'NM': 'Kestrel Gorlick'},
                       positional_metadata={'diff':
                                            list('01100001110010001100')})
        exp.interval_metadata.add([(0, 1)], metadata={'gene': 'sagA'})

        self.assertEqual(obs, exp)

    def test_replace_with_subclass(self):
        seq = DNA('CGACAACCGATGTGCTGTAA')
        index = self._make_index('10101000111111110011')
        obs = seq.replace(index, '-')
        exp = DNA('-G-C-ACC--------GT--')
        self.assertEqual(obs, exp)

    def test_replace_with_bytes(self):
        seq = Sequence('ABC123')

        obs = seq.replace([1, 3, 5], b'*')

        self.assertEqual(obs, Sequence('A*C*2*'))
<a name="39"></a>
    def test_replace_invalid_char_for_type_error(self):
        seq = DNA('TAAACGGAACGCTACGTCTG')
        index <font color="#152dc6"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self._make_index('01000001101011001001')
        with self.assertRaisesRegex(ValueError, r"Invalid character.*'F'"):
            seq.replace(index, 'F')

    def test_replace_invalid_char_error(self):
        seq =</b></font> Sequence('GGGAGCTAGA')
        index = self._make_index('1000101110')
        with self.assertRaisesRegex(UnicodeEncodeError,
                                    r"can't encode character.*not in "
                                    r"range\(128\)"):
            seq.replace(index, '\uFFFF')

    def test_replace_non_single_character_error(self):
        seq = Sequence('CCGAACTGTC')
        index = self._make_index('1100110011')
        with self.assertRaisesRegex(TypeError, r'string of length 2 found'):
            seq.replace(index, 'AB')

    def _make_index(self, bools):
        return [bool(int(char)) for char in bools]

    def test_lowercase_mungeable_key(self):
        # NOTE: This test relies on Sequence._munge_to_index_array working
        # properly. If the internal implementation of the lowercase method
<a name="18"></a>        # changes to no longer use _munge_to_index_array, this test may need
        # to be updated to cover cases currently covered by
        # _munge_to_index_array
        self.assertEqual('AAAAaaaa', self<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.lowercase_seq.lowercase('key'))

    def test_lowercase_array_key(self):
        # NOTE: This test relies on Sequence._munge_to_index_array working
        # properly. If the internal implementation of the lowercase method
        # changes to no longer use _munge_to_index_array, this test may need
        # to be updated to cover cases currently covered by
        # _munge_to_index_array
        self.assertEqual('aaAAaaaa',
                         self.lowercase_seq.lowercase(
                             np.array([True, True, False, False, True, True,
                                       True, True])))
        self.</b></font>assertEqual('AaAAaAAA',
                         self.lowercase_seq.lowercase([1, 4]))

    def test_matches(self):
        tested = 0
        for constructor in self.sequence_kinds:
            tested += 1
            seq1 = Sequence("AACCEEGG")
            seq2 = constructor("ABCDEFGH")
            expected = np.array([True, False] * 4)
            npt.assert_equal(seq1.matches(seq2), expected)

        self.assertEqual(tested, 4)

    def test_matches_on_subclass(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = SequenceSubclass("ABCDEFGH")

        with self.assertRaises(TypeError):
            seq1.matches(seq2)

    def test_matches_unequal_length(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = Sequence("TOOLONGTOCOMPARE")

        with self.assertRaises(ValueError):
            seq1.matches(seq2)

    def test_mismatches(self):
        tested = 0
        for constructor in self.sequence_kinds:
            tested += 1
            seq1 = Sequence("AACCEEGG")
            seq2 = constructor("ABCDEFGH")
            expected = np.array([False, True] * 4)
            npt.assert_equal(seq1.mismatches(seq2), expected)

        self.assertEqual(tested, 4)

    def test_mismatches_on_subclass(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = SequenceSubclass("ABCDEFGH")

        with self.assertRaises(TypeError):
            seq1.mismatches(seq2)

    def test_mismatches_unequal_length(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = Sequence("TOOLONGTOCOMPARE")

        with self.assertRaises(ValueError):
            seq1.mismatches(seq2)

    def test_mismatch_frequency(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = Sequence("ABCDEFGH")
<a name="12"></a>        seq3 = Sequence("TTTTTTTT")

        self.assertIs(type(seq1.mismatch_frequency(seq1)), int)
        self<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq1.mismatch_frequency(seq1), 0)
        self.assertEqual(seq1.mismatch_frequency(seq2), 4)
        self.assertEqual(seq1.mismatch_frequency(seq3), 8)

    def test_mismatch_frequency_relative(self):
        seq1 =</b></font> Sequence("AACCEEGG")
<a name="5"></a>        seq2 = Sequence("ABCDEFGH")
        seq3 = Sequence("TTTTTTTT")

        self.assertIs(type<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq1.mismatch_frequency(seq1, relative=True)),
                      float)
        self.assertEqual(seq1.mismatch_frequency(seq1, relative=True), 0.0)
        self.assertEqual(seq1.mismatch_frequency(seq2, relative=True), 0.5)
        self.assertEqual(seq1.mismatch_frequency(seq3, relative=</b></font>True), 1.0)

    def test_mismatch_frequency_unequal_length(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = Sequence("TOOLONGTOCOMPARE")

        with self.assertRaises(ValueError):
            seq1.mismatch_frequency(seq2)

    def test_mismatch_frequence_on_subclass(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = SequenceSubclass("ABCDEFGH")

        with self.assertRaises(TypeError):
            seq1.mismatch_frequency(seq2)

    def test_match_frequency(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = Sequence("ABCDEFGH")
<a name="11"></a>        seq3 = Sequence("TTTTTTTT")

        self.assertIs(type(seq1.match_frequency(seq1)), int)
        self<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq1.match_frequency(seq1), 8)
        self.assertEqual(seq1.match_frequency(seq2), 4)
        self.assertEqual(seq1.match_frequency(seq3), 0)

    def test_match_frequency_relative(self):
        seq1 =</b></font> Sequence("AACCEEGG")
<a name="4"></a>        seq2 = Sequence("ABCDEFGH")
        seq3 = Sequence("TTTTTTTT")

        self.assertIs(type<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq1.match_frequency(seq1, relative=True)),
                      float)
        self.assertEqual(seq1.match_frequency(seq1, relative=True), 1.0)
        self.assertEqual(seq1.match_frequency(seq2, relative=True), 0.5)
        self.assertEqual(seq1.match_frequency(seq3, relative=</b></font>True), 0.0)

    def test_match_frequency_unequal_length(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = Sequence("TOOLONGTOCOMPARE")

        with self.assertRaises(ValueError):
            seq1.match_frequency(seq2)

    def test_match_frequency_on_subclass(self):
        seq1 = Sequence("AACCEEGG")
        seq2 = SequenceSubclass("ABCDEFGH")

        with self.assertRaises(TypeError):
            seq1.match_frequency(seq2)

    def test_index(self):
        tested = 0
        for c in self.sequence_kinds:
            tested += 1
            seq = Sequence("ABCDEFG@@ABCDFOO")
            self.assertEqual(seq.index(c("A")), 0)
            self.assertEqual(seq.index(c("@")), 7)
            self.assertEqual(seq.index(c("@@")), 7)

            with self.assertRaises(ValueError):
                seq.index("A", start=1, end=5)

        self.assertEqual(tested, 4)

    def test_index_on_subclass(self):
        with self.assertRaises(TypeError):
            Sequence("ABCDEFG").index(SequenceSubclass("A"))

        self.assertEqual(
            SequenceSubclass("ABCDEFG").index(SequenceSubclass("A")), 0)

    def test_frequencies_empty_sequence(self):
        seq = Sequence('')

        self.assertEqual(seq.frequencies(), {})
        self.assertEqual(seq.frequencies(relative=True), {})

        self.assertEqual(seq.frequencies(chars=set()), {})
        self.assertEqual(seq.frequencies(chars=set(), relative=True), {})

        self.assertEqual(seq.frequencies(chars={'a', 'b'}), {'a': 0, 'b': 0})

        # use npt.assert_equal to explicitly handle nan comparisons
        npt.assert_equal(seq.frequencies(chars={'a', 'b'}, relative=True),
                         {'a': np.nan, 'b': np.nan})

    def test_frequencies_observed_chars(self):
        seq = Sequence('x')
        self.assertEqual(seq.frequencies(), {'x': 1})
        self.assertEqual(seq.frequencies(relative=True), {'x': 1.0})

        seq = Sequence('xYz')
        self.assertEqual(seq.frequencies(), {'x': 1, 'Y': 1, 'z': 1})
        self.assertEqual(seq.frequencies(relative=True),
                         {'x': 1/3, 'Y': 1/3, 'z': 1/3})

        seq = Sequence('zzz')
        self.assertEqual(seq.frequencies(), {'z': 3})
        self.assertEqual(seq.frequencies(relative=True), {'z': 1.0})

        seq = Sequence('xYzxxZz')
        self.assertEqual(seq.frequencies(), {'x': 3, 'Y': 1, 'Z': 1, 'z': 2})
        self.assertEqual(seq.frequencies(relative=True),
                         {'x': 3/7, 'Y': 1/7, 'Z': 1/7, 'z': 2/7})

        seq = Sequence('\t   ')
        self.assertEqual(seq.frequencies(), {'\t': 1, ' ': 3})
        self.assertEqual(seq.frequencies(relative=True), {'\t': 1/4, ' ': 3/4})

        seq = Sequence('aabbcc', metadata={'foo': 'bar'},
                       positional_metadata={'foo': range(6)})
        self.assertEqual(seq.frequencies(), {'a': 2, 'b': 2, 'c': 2})
        self.assertEqual(seq.frequencies(relative=True),
                         {'a': 2/6, 'b': 2/6, 'c': 2/6})

    def test_frequencies_specified_chars(self):
        seq = Sequence('abcbca')

        self.assertEqual(seq.frequencies(chars=set()), {})
        self.assertEqual(seq.frequencies(chars=set(), relative=True), {})

        self.assertEqual(seq.frequencies(chars='a'), {'a': 2})
        self.assertEqual(seq.frequencies(chars='a', relative=True), {'a': 2/6})

        self.assertEqual(seq.frequencies(chars={'a'}), {'a': 2})
        self.assertEqual(seq.frequencies(chars={'a'}, relative=True),
                         {'a': 2/6})

        self.assertEqual(seq.frequencies(chars={'a', 'b'}), {'a': 2, 'b': 2})
        self.assertEqual(seq.frequencies(chars={'a', 'b'}, relative=True),
                         {'a': 2/6, 'b': 2/6})

        self.assertEqual(seq.frequencies(chars={'a', 'b', 'd'}),
                         {'a': 2, 'b': 2, 'd': 0})
        self.assertEqual(seq.frequencies(chars={'a', 'b', 'd'}, relative=True),
                         {'a': 2/6, 'b': 2/6, 'd': 0.0})

        self.assertEqual(seq.frequencies(chars={'x', 'y', 'z'}),
                         {'x': 0, 'y': 0, 'z': 0})
        self.assertEqual(seq.frequencies(chars={'x', 'y', 'z'}, relative=True),
                         {'x': 0.0, 'y': 0.0, 'z': 0.0})

    def test_frequencies_chars_varied_type(self):
        seq = Sequence('zabczzzabcz')

        # single character case (shortcut)
        chars = b'z'
        self.assertEqual(seq.frequencies(chars=chars), {b'z': 5})
        self.assertEqual(seq.frequencies(chars=chars, relative=True),
                         {b'z': 5/11})

        chars = 'z'
        self.assertEqual(seq.frequencies(chars=chars), {'z': 5})
        self.assertEqual(seq.frequencies(chars=chars, relative=True),
                         {'z': 5/11})

        chars = np.frombuffer('z'.encode('ascii'), dtype='|S1')[0]
        self.assertEqual(seq.frequencies(chars=chars), {b'z': 5})
        self.assertEqual(seq.frequencies(chars=chars, relative=True),
                         {b'z': 5/11})

        # set of characters, some present, some not
        chars = {b'x', b'z'}
        self.assertEqual(seq.frequencies(chars=chars), {b'x': 0, b'z': 5})
        self.assertEqual(seq.frequencies(chars=chars, relative=True),
                         {b'x': 0.0, b'z': 5/11})

        chars = {'x', 'z'}
        self.assertEqual(seq.frequencies(chars=chars), {'x': 0, 'z': 5})
        self.assertEqual(seq.frequencies(chars=chars, relative=True),
                         {'x': 0.0, 'z': 5/11})

        chars = {
            np.frombuffer('x'.encode('ascii'), dtype='|S1')[0],
            np.frombuffer('z'.encode('ascii'), dtype='|S1')[0]
        }
        self.assertEqual(seq.frequencies(chars=chars), {b'x': 0, b'z': 5})
        self.assertEqual(seq.frequencies(chars=chars, relative=True),
                         {b'x': 0.0, b'z': 5/11})

    def test_frequencies_equivalent_to_kmer_frequencies_k_of_1(self):
        seq = Sequence('abcabc')

        exp = {'a': 2, 'b': 2, 'c': 2}
        self.assertEqual(seq.frequencies(chars=None), exp)
        self.assertEqual(seq.kmer_frequencies(k=1), exp)

        exp = {'a': 2/6, 'b': 2/6, 'c': 2/6}
        self.assertEqual(seq.frequencies(chars=None, relative=True), exp)
        self.assertEqual(seq.kmer_frequencies(k=1, relative=True), exp)

    def test_frequencies_passing_observed_chars_equivalent_to_default(self):
        seq = Sequence('abcabc')

        exp = {'a': 2, 'b': 2, 'c': 2}
        self.assertEqual(seq.frequencies(chars=None), exp)
        self.assertEqual(seq.frequencies(chars=seq.observed_chars), exp)

        exp = {'a': 2/6, 'b': 2/6, 'c': 2/6}
        self.assertEqual(seq.frequencies(chars=None, relative=True), exp)
        self.assertEqual(
            seq.frequencies(chars=seq.observed_chars, relative=True),
            exp)

    def test_frequencies_invalid_chars(self):
        seq = Sequence('abcabc')

        with self.assertRaisesRegex(ValueError, r'0 characters'):
            seq.frequencies(chars='')

        with self.assertRaisesRegex(ValueError, r'0 characters'):
            seq.frequencies(chars={''})

        with self.assertRaisesRegex(ValueError, r'2 characters'):
            seq.frequencies(chars='ab')

        with self.assertRaisesRegex(ValueError, r'2 characters'):
            seq.frequencies(chars={'b', 'ab'})

        with self.assertRaisesRegex(TypeError, r'string.*NoneType'):
            seq.frequencies(chars={'a', None})

        with self.assertRaisesRegex(ValueError, r'outside the range'):
            seq.frequencies(chars='\u1F30')

        with self.assertRaisesRegex(ValueError, r'outside the range'):
            seq.frequencies(chars={'c', '\u1F30'})

        with self.assertRaisesRegex(TypeError, r'set.*int'):
            seq.frequencies(chars=42)

    def _compare_kmers_results(self, observed, expected):
        for obs, exp in itertools.zip_longest(observed, expected,
                                              fillvalue=None):
<a name="38"></a>            self.assertEqual(obs, exp)

    def test_iter_kmers(self):
        seq = Sequence('GATTACA', positional_metadata<font color="#348781"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'quality': range(7)})

<a name="37"></a>        expected = [
            Sequence('G', positional_metadata={'quality': [0]}),
            Sequence('A', positional_metadata={'quality': [1]}),
            Sequence(</b></font>'T', positional_metadata<font color="#810541"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'quality': [2]}),
            Sequence('T', positional_metadata={'quality': [3]}),
            Sequence('A', positional_metadata={'quality': [4]}),
            Sequence('C', positional_metadata={'quality': [5]}),
            Sequence(</b></font>'A', positional_metadata={'quality': [6]})
        ]
        self._compare_kmers_results(
            seq.iter_kmers(1, overlap=False), expected)

        expected = [
            Sequence('GA', positional_metadata={'quality': [0, 1]}),
            Sequence('TT', positional_metadata={'quality': [2, 3]}),
            Sequence('AC', positional_metadata={'quality': [4, 5]})
        ]
        self._compare_kmers_results(
            seq.iter_kmers(2, overlap=False), expected)

        expected = [
            Sequence('GAT', positional_metadata={'quality': [0, 1, 2]}),
            Sequence('TAC', positional_metadata={'quality': [3, 4, 5]})
        ]
        self._compare_kmers_results(
            seq.iter_kmers(3, overlap=False), expected)

        expected = [
<a name="25"></a>            Sequence('GATTACA',
                     positional_metadata={'quality': [0, 1, 2, 3, 4, 5, 6]})
        ]
        self<font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._compare_kmers_results(
            seq.iter_kmers(7, overlap=False), expected)

        expected = []
        self._compare_kmers_results(
            seq.iter_kmers(8, overlap=False), expected)

        self.assertIs(</b></font>type(seq.iter_kmers(1)), GeneratorType)

    def test_iter_kmers_no_positional_metadata(self):
        seq = Sequence('GATTACA')

        expected = [
            Sequence('G'),
            Sequence('A'),
            Sequence('T'),
            Sequence('T'),
            Sequence('A'),
            Sequence('C'),
            Sequence('A')
        ]
        self._compare_kmers_results(
            seq.iter_kmers(1, overlap=False), expected)

        expected = [
            Sequence('GA'),
            Sequence('TT'),
            Sequence('AC')
        ]
        self._compare_kmers_results(
            seq.iter_kmers(2, overlap=False), expected)

        expected = [
            Sequence('GAT'),
            Sequence('TAC')
        ]
        self._compare_kmers_results(
            seq.iter_kmers(3, overlap=False), expected)

<a name="24"></a>        expected = [
            Sequence('GATTACA')
        ]
        self<font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._compare_kmers_results(
            seq.iter_kmers(7, overlap=False), expected)

        expected = []
        self._compare_kmers_results(
            seq.iter_kmers(8, overlap=False), expected)

<a name="36"></a>        self.assertIs(</b></font>type(seq.iter_kmers(1)), GeneratorType)

    def test_iter_kmers_with_overlap(self):
        seq = Sequence('GATTACA', positional_metadata={<font color="#ff00ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'quality': range(7)})
        expected = [
            Sequence('G', positional_metadata={'quality': [0]}),
            Sequence('A', positional_metadata={'quality': [1]}),
            Sequence('T', positional_metadata=</b></font>{'quality': [2]}),
            Sequence('T', positional_metadata={'quality': [3]}),
            Sequence('A', positional_metadata={'quality': [4]}),
            Sequence('C', positional_metadata={'quality': [5]}),
            Sequence('A', positional_metadata={'quality': [6]})
        ]
        self._compare_kmers_results(
            seq.iter_kmers(1, overlap=True), expected)

        expected = [
            Sequence('GA', positional_metadata={'quality': [0, 1]}),
            Sequence('AT', positional_metadata={'quality': [1, 2]}),
            Sequence('TT', positional_metadata={'quality': [2, 3]}),
            Sequence('TA', positional_metadata={'quality': [3, 4]}),
            Sequence('AC', positional_metadata={'quality': [4, 5]}),
            Sequence('CA', positional_metadata={'quality': [5, 6]})
        ]
        self._compare_kmers_results(
            seq.iter_kmers(2, overlap=True), expected)

        expected = [
            Sequence('GAT', positional_metadata={'quality': [0, 1, 2]}),
            Sequence('ATT', positional_metadata={'quality': [1, 2, 3]}),
            Sequence('TTA', positional_metadata={'quality': [2, 3, 4]}),
            Sequence('TAC', positional_metadata={'quality': [3, 4, 5]}),
            Sequence('ACA', positional_metadata={'quality': [4, 5, 6]})
        ]
        self._compare_kmers_results(
            seq.iter_kmers(3, overlap=True), expected)

        expected = [
            Sequence('GATTACA',
                     positional_metadata={'quality': [0, 1, 2, 3, 4, 5, 6]})
        ]
        self._compare_kmers_results(
            seq.iter_kmers(7, overlap=True), expected)

        expected = []
        self._compare_kmers_results(
            seq.iter_kmers(8, overlap=True), expected)

        self.assertIs(type(seq.iter_kmers(1)), GeneratorType)

    def test_iter_kmers_with_overlap_no_positional_metadata(self):
        seq = Sequence('GATTACA')
        expected = [
            Sequence('G'),
            Sequence('A'),
            Sequence('T'),
            Sequence('T'),
            Sequence('A'),
            Sequence('C'),
            Sequence('A')
        ]
        self._compare_kmers_results(
            seq.iter_kmers(1, overlap=True), expected)

        expected = [
            Sequence('GA'),
            Sequence('AT'),
            Sequence('TT'),
            Sequence('TA'),
            Sequence('AC'),
            Sequence('CA')
        ]
        self._compare_kmers_results(
            seq.iter_kmers(2, overlap=True), expected)

        expected = [
            Sequence('GAT'),
            Sequence('ATT'),
            Sequence('TTA'),
            Sequence('TAC'),
            Sequence('ACA')
        ]
        self._compare_kmers_results(
            seq.iter_kmers(3, overlap=True), expected)

        expected = [
            Sequence('GATTACA')
        ]
        self._compare_kmers_results(
            seq.iter_kmers(7, overlap=True), expected)

        expected = []
        self._compare_kmers_results(
            seq.iter_kmers(8, overlap=True), expected)

        self.assertIs(type(seq.iter_kmers(1)), GeneratorType)

    def test_iter_kmers_invalid_k(self):
        seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})

        with self.assertRaises(ValueError):
            list(seq.iter_kmers(0))

        with self.assertRaises(ValueError):
            list(seq.iter_kmers(-42))

    def test_iter_kmers_invalid_k_no_positional_metadata(self):
        seq = Sequence('GATTACA')

        with self.assertRaises(ValueError):
            list(seq.iter_kmers(0))

        with self.assertRaises(ValueError):
            list(seq.iter_kmers(-42))

    def test_iter_kmers_different_sequences(self):
        seq = Sequence('HE..--..LLO',
                       metadata={'id': 'hello', 'desc': 'gapped hello'},
                       positional_metadata={'quality': range(11)})
        expected = [
            Sequence('HE.', positional_metadata={'quality': [0, 1, 2]},
                     metadata={'id': 'hello', 'desc': 'gapped hello'}),
            Sequence('.--', positional_metadata={'quality': [3, 4, 5]},
                     metadata={'id': 'hello', 'desc': 'gapped hello'}),
            Sequence('..L', positional_metadata={'quality': [6, 7, 8]},
                     metadata={'id': 'hello', 'desc': 'gapped hello'})
        ]
        self._compare_kmers_results(seq.iter_kmers(3, overlap=False), expected)
<a name="35"></a>
    def test_iter_kmers_different_sequences_no_positional_metadata(self):
        seq = Sequence('HE..--..LLO',
                       metadata<font color="#41a317"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'id': 'hello', 'desc': 'gapped hello'})
        expected = [
            Sequence('HE.',
                     metadata={'id': 'hello', 'desc': 'gapped hello'}),
            Sequence('.--',
                     metadata={'id': 'hello', 'desc': 'gapped hello'}),
            Sequence('..L',
                     metadata=</b></font>{'id': 'hello', 'desc': 'gapped hello'})
        ]
        self._compare_kmers_results(seq.iter_kmers(3, overlap=False), expected)

    def test_iter_kmers_empty_sequence(self):
        seq = Sequence('')
        expected = []
        self._compare_kmers_results(seq.iter_kmers(3, overlap=False), expected)

    def test_iter_kmers_empty_sequence_with_positional_metadata(self):
        seq = Sequence('', positional_metadata={'quality': []})
        expected = []
        self._compare_kmers_results(seq.iter_kmers(3, overlap=False), expected)

    def test_kmer_frequencies_empty_sequence(self):
<a name="10"></a>        seq = Sequence('')

        self.assertEqual(seq.kmer_frequencies(1), {})
        self<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq.kmer_frequencies(1, overlap=False), {})
        self.assertEqual(seq.kmer_frequencies(1, relative=True), {})
        self.assertEqual(seq.kmer_frequencies(1, relative=</b></font>True, overlap=False),
                         {})

    def test_kmer_frequencies(self):
        seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})

        # overlap = True
        expected = {'G': 1, 'A': 3, 'T': 2, 'C': 1}
        self.assertEqual(seq.kmer_frequencies(1, overlap=True), expected)

        expected = {'GAT': 1, 'ATT': 1, 'TTA': 1, 'TAC': 1, 'ACA': 1}
<a name="34"></a>        self.assertEqual(seq.kmer_frequencies(3, overlap=True), expected)

        expected = {}
        self.assertEqual(seq.kmer_frequencies(8, overlap<font color="#827d6b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=True), expected)

        # overlap = False
        expected = {'GAT': 1, 'TAC': 1}
        self.assertEqual(seq.kmer_frequencies(3, overlap=False), expected)

        expected = {'GATTACA': 1}
        self.assertEqual(</b></font>seq.kmer_frequencies(7, overlap=False), expected)

        expected = {}
        self.assertEqual(seq.kmer_frequencies(8, overlap=False), expected)

    def test_kmer_frequencies_relative(self):
        seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})

        # overlap = True
        expected = {'A': 3/7, 'C': 1/7, 'G': 1/7, 'T': 2/7}
        self.assertEqual(seq.kmer_frequencies(1, overlap=True, relative=True),
                         expected)

        expected = {'GAT': 1/5, 'ATT': 1/5, 'TTA': 1/5, 'TAC': 1/5, 'ACA': 1/5}
        self.assertEqual(seq.kmer_frequencies(3, overlap=True, relative=True),
                         expected)

        expected = {}
        self.assertEqual(seq.kmer_frequencies(8, overlap=True, relative=True),
                         expected)

        # overlap = False
        expected = {'GAT': 1/2, 'TAC': 1/2}
        self.assertEqual(seq.kmer_frequencies(3, overlap=False, relative=True),
                         expected)

        expected = {'GATTACA': 1.0}
        self.assertEqual(seq.kmer_frequencies(7, overlap=False, relative=True),
                         expected)

        expected = {}
        self.assertEqual(seq.kmer_frequencies(8, overlap=False, relative=True),
                         expected)

    def test_kmer_frequencies_floating_point_precision(self):
        # Test that a sequence having no variation in k-words yields a
        # frequency of exactly 1.0. Note that it is important to use
        # self.assertEqual here instead of self.assertAlmostEqual because we
        # want to test for exactly 1.0. A previous implementation of
        # Sequence.kmer_frequencies(relative=True) added (1 / num_words) for
        # each occurrence of a k-word to compute the frequencies (see
        # https://github.com/biocore/scikit-bio/issues/801). In certain cases,
        # this yielded a frequency slightly less than 1.0 due to roundoff
        # error. The test case here uses a sequence with 10 characters that are
        # all identical and computes k-word frequencies with k=1. This test
        # case exposes the roundoff error present in the previous
        # implementation because there are 10 k-words (which are all
        # identical), so 1/10 added 10 times yields a number slightly less than
        # 1.0. This occurs because 1/10 cannot be represented exactly as a
        # floating point number.
        seq = Sequence('AAAAAAAAAA')
        self.assertEqual(seq.kmer_frequencies(1, relative=True), {'A': 1.0})

    def test_find_with_regex(self):
        seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})
        pat = re.compile('(T+A)(CA)')

        obs = list(seq.find_with_regex(pat))
        exp = [slice(2, 5), slice(5, 7)]
        self.assertEqual(obs, exp)

        self.assertIs(type(seq.find_with_regex(pat)), GeneratorType)

    def test_find_with_regex_string_as_input(self):
        seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})
        pat = '(T+A)(CA)'

        obs = list(seq.find_with_regex(pat))
        exp = [slice(2, 5), slice(5, 7)]
        self.assertEqual(obs, exp)

        self.assertIs(type(seq.find_with_regex(pat)), GeneratorType)

    def test_find_with_regex_no_groups(self):
        seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})
        pat = re.compile('(FOO)')
        self.assertEqual(list(seq.find_with_regex(pat)), [])

    def test_find_with_regex_ignore_no_difference(self):
<a name="33"></a>        seq = Sequence('..ABCDEFG..')
        pat = "([A-Z]+)"
        exp = [slice(2, 9)]
        self.assertEqual(list(seq<font color="#736aff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.find_with_regex(pat)), exp)

        obs = seq.find_with_regex(
            pat, ignore=np.array([1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                                 dtype=bool))
        self.assertEqual(</b></font>list(obs), exp)

    def test_find_with_regex_ignore(self):
        obs = Sequence('A..A..BBAAB.A..AB..A.').find_with_regex(
            "(A+)", ignore=np.array([0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1,
                                     1, 0, 0, 1, 1, 0, 1], dtype=bool))

        self.assertEqual(list(obs), [slice(0, 4), slice(8, 10), slice(12, 16),
                                     slice(19, 20)])

    def test_find_with_regex_ignore_index_array(self):
        obs = Sequence('A..A..BBAAB.A..AB..A.').find_with_regex(
            "(A+)", ignore=np.array([1, 2, 4, 5, 11, 13, 14, 17, 18, 20]))

        self.assertEqual(list(obs), [slice(0, 4), slice(8, 10), slice(12, 16),
                                     slice(19, 20)])

    def test_iter_contiguous_index_array(self):
        s = Sequence("0123456789abcdef")
        for c in list, tuple, np.array, pd.Series:
            exp = [Sequence("0123"), Sequence("89ab")]
            obs = s.iter_contiguous(c([0, 1, 2, 3, 8, 9, 10, 11]))
            self.assertEqual(list(obs), exp)

    def test_iter_contiguous_boolean_vector(self):
        s = Sequence("0123456789abcdef")
        for c in list, tuple, np.array, pd.Series:
            exp = [Sequence("0123"), Sequence("89ab")]
            obs = s.iter_contiguous(c(([True] * 4 + [False] * 4) * 2))
            self.assertEqual(list(obs), exp)

    def test_iter_contiguous_iterable_slices(self):
        def spaced_out():
            yield slice(0, 4)
            yield slice(8, 12)

        def contiguous():
            yield slice(0, 4)
            yield slice(4, 8)
            yield slice(12, 16)

        s = Sequence("0123456789abcdef")
        for c in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
                  lambda x: pd.Series(tuple(x))):
            exp = [Sequence("0123"), Sequence("89ab")]
            obs = s.iter_contiguous(c(spaced_out()))
            self.assertEqual(list(obs), exp)

            exp = [Sequence("01234567"), Sequence("cdef")]
            obs = s.iter_contiguous(c(contiguous()))
            self.assertEqual(list(obs), exp)

    def test_iter_contiguous_with_max_length(self):
        s = Sequence("0123456789abcdef")
        for c in list, tuple, np.array, pd.Series:
            exp = [Sequence("234"), Sequence("678"), Sequence("abc")]
            obs = s.iter_contiguous(c([True, False, True, True] * 4),
                                    min_length=3)
            self.assertEqual(list(obs), exp)

            exp = [Sequence("0"), Sequence("234"), Sequence("678"),
                   Sequence("abc"), Sequence("ef")]
            obs1 = list(s.iter_contiguous(c([True, False, True, True] * 4),
                                          min_length=1))

            obs2 = list(s.iter_contiguous(c([True, False, True, True] * 4)))
            self.assertEqual(obs1, obs2)
            self.assertEqual(obs1, exp)

    def test_iter_contiguous_with_invert(self):
        def spaced_out():
            yield slice(0, 4)
            yield slice(8, 12)

        def contiguous():
            yield slice(0, 4)
            yield slice(4, 8)
            yield slice(12, 16)

        s = Sequence("0123456789abcdef")
        for c in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
                  lambda x: pd.Series(tuple(x))):
            exp = [Sequence("4567"), Sequence("cdef")]
            obs = s.iter_contiguous(c(spaced_out()), invert=True)
            self.assertEqual(list(obs), exp)

            exp = [Sequence("89ab")]
            obs = s.iter_contiguous(c(contiguous()), invert=True)
            self.assertEqual(list(obs), exp)

    def test_copy_without_metadata(self):
        # shallow vs deep copy with sequence only should be equivalent
        for copy_method in copy.copy, copy.deepcopy:
            seq = Sequence('ACGT')
            seq_copy = copy_method(seq)

            self.assertEqual(seq_copy, seq)
            self.assertIsNot(seq_copy, seq)
            self.assertIsNot(seq_copy._bytes, seq._bytes)

    def test_copy_with_metadata_shallow(self):
        seq = Sequence('ACGT', metadata={'foo': [1]},
                       positional_metadata={'bar': [[], [], [], []],
<a name="23"></a>                                            'baz': [42, 42, 42, 42]})
        seq.interval_metadata.add([(0, 3)], metadata={'gene': ['sagA']})

        seq_copy = copy<font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.copy(seq)

        self.assertEqual(seq_copy, seq)
<a name="1"></a>        self.assertIsNot(seq_copy, seq)
        self.assertIsNot(seq_copy._bytes, seq._bytes)
        self.assertIsNot(seq_copy.</b></font>_metadata, seq._metadata)
        self.assertIsNot<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq_copy._positional_metadata,
                         seq._positional_metadata)
        self.assertIsNot(seq_copy._positional_metadata.values,
                         seq._positional_metadata.values)
<a name="3"></a>        self.assertIs(seq_copy._metadata['foo'], seq._metadata['foo'])
        self.assertIs(seq_copy._positional_metadata.loc[0, 'bar'],
                      seq.</b></font>_positional_metadata.loc[0, 'bar'])
        self.assertIsNot<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq_copy.interval_metadata, seq.interval_metadata)
        self.assertIsNot(seq_copy.interval_metadata._intervals[0],
                         seq.interval_metadata._intervals[0])
        self.assertIsNot(seq_copy.interval_metadata._intervals[0].metadata,
                         seq.interval_metadata._intervals[</b></font>0].metadata)
        self.assertIs(
            seq_copy.interval_metadata._intervals[0].metadata['gene'],
            seq.interval_metadata._intervals[0].metadata['gene'])
<a name="7"></a>        seq_copy.metadata['foo'].append(2)
        seq_copy.metadata['foo2'] = 42

        self.assertEqual(seq_copy<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.metadata, {'foo': [1, 2], 'foo2': 42})
        self.assertEqual(seq.metadata, {'foo': [1, 2]})

<a name="17"></a>        seq_copy.positional_metadata.loc[0, 'bar'].append(1)
        seq_copy.positional_metadata.loc[</b></font>0, 'baz'] = 43

        assert_data_frame_almost_equal<font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
            seq_copy.positional_metadata,
            pd.DataFrame({'bar': [[1], [], [], []],
                          'baz': [43, 42, 42, 42]}))
        assert_data_frame_almost_equal(
            seq.positional_metadata,
            pd.DataFrame({'bar': [[1], [], [], []],
                          'baz': [42</b></font>, 42, 42, 42]}))

    def test_copy_with_metadata_deep(self):
        seq = Sequence('ACGT', metadata={'foo': [1]},
<a name="22"></a>                       positional_metadata={'bar': [[], [], [], []],
                                            'baz': [42, 42, 42, 42]})
        seq.interval_metadata.add([(0, 3)], metadata={'gene': ['sagA']})
        seq_copy = copy.deepcopy<font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq)

        self.assertEqual(seq_copy, seq)
<a name="0"></a>        self.assertIsNot(seq_copy, seq)
        self.assertIsNot(seq_copy._bytes, seq._bytes)
        self.assertIsNot(seq_copy._metadata, seq.</b></font>_metadata)
        self.assertIsNot(seq_copy<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._positional_metadata,
                         seq._positional_metadata)
        self.assertIsNot(seq_copy._positional_metadata.values,
                         seq._positional_metadata.values)
<a name="2"></a>        self.assertIsNot(seq_copy._metadata['foo'], seq._metadata['foo'])
        self.assertIsNot(seq_copy._positional_metadata.loc[0, 'bar'],
                         seq._positional_metadata.</b></font>loc[0, 'bar'])
        self.assertIsNot<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq_copy.interval_metadata, seq.interval_metadata)
        self.assertIsNot(seq_copy.interval_metadata._intervals[0],
                         seq.interval_metadata._intervals[0])
        self.assertIsNot(seq_copy.interval_metadata._intervals[0].metadata,
                         seq.interval_metadata._intervals[</b></font>0].metadata)
        self.assertIsNot(
            seq_copy.interval_metadata._intervals[0].metadata['gene'],
            seq.interval_metadata._intervals[0].metadata['gene'])
<a name="32"></a>        seq_copy.metadata['foo'].append(2)
        seq_copy.metadata['foo2'] = 42

        self<font color="#5b8daf"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq_copy.metadata, {'foo': [1, 2], 'foo2': 42})
        self.assertEqual(seq.metadata, {'foo': [1]})

<a name="16"></a>        seq_copy.positional_metadata.loc[</b></font>0, 'bar'].append(1)
        seq_copy.positional_metadata.loc[0, 'baz'] = 43

        assert_data_frame_almost_equal<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
            seq_copy.positional_metadata,
            pd.DataFrame({'bar': [[1], [], [], []],
                          'baz': [43, 42, 42, 42]}))
        assert_data_frame_almost_equal(
            seq.positional_metadata,
            pd.DataFrame({'bar': [[], [], [], []],
                          'baz': [42</b></font>, 42, 42, 42]}))

    def test_copy_preserves_read_only_flag_on_bytes(self):
        seq = Sequence('ACGT')
        seq_copy = copy.copy(seq)

        with self.assertRaises(ValueError):
            seq_copy._bytes[0] = 'B'

    def test_deepcopy_memo_is_respected(self):
        # basic test to ensure deepcopy's memo is passed through to recursive
        # deepcopy calls
        seq = Sequence('ACGT', metadata={'foo': 'bar'})
        memo = {}
        copy.deepcopy(seq, memo)
        self.assertGreater(len(memo), 2)

    def test_munge_to_index_array_valid_index_array(self):
        s = Sequence('123456')

        for c in list, tuple, np.array, pd.Series:
            exp = np.array([1, 2, 3], dtype=int)
            obs = s._munge_to_index_array(c([1, 2, 3]))
            npt.assert_equal(obs, exp)

            exp = np.array([1, 3, 5], dtype=int)
            obs = s._munge_to_index_array(c([1, 3, 5]))
            npt.assert_equal(obs, exp)

    def test_munge_to_index_array_invalid_index_array(self):
        s = Sequence("12345678")
        for c in list, tuple, np.array, pd.Series:
            with self.assertRaises(ValueError):
                s._munge_to_index_array(c([3, 2, 1]))

            with self.assertRaises(ValueError):
                s._munge_to_index_array(c([5, 6, 7, 2]))

            with self.assertRaises(ValueError):
                s._munge_to_index_array(c([0, 1, 2, 1]))

    def test_munge_to_index_array_valid_bool_array(self):
        s = Sequence('123456')

        for c in list, tuple, np.array, pd.Series:
            exp = np.array([2, 3, 5], dtype=int)
            obs = s._munge_to_index_array(
                c([False, False, True, True, False, True]))
            npt.assert_equal(obs, exp)

            exp = np.array([], dtype=int)
            obs = s._munge_to_index_array(
                c([False] * 6))
            npt.assert_equal(obs, exp)

            exp = np.arange(6)
            obs = s._munge_to_index_array(
                c([True] * 6))
            npt.assert_equal(obs, exp)

    def test_munge_to_index_array_invalid_bool_array(self):
        s = Sequence('123456')

        for c in (list, tuple, lambda x: np.array(x, dtype=bool),
                  lambda x: pd.Series(x, dtype=bool)):

            with self.assertRaises(ValueError):
                s._munge_to_index_array(c([]))

            with self.assertRaises(ValueError):
                s._munge_to_index_array(c([True]))

            with self.assertRaises(ValueError):
                s._munge_to_index_array(c([True] * 10))

    def test_munge_to_index_array_valid_iterable(self):
        s = Sequence('')

        def slices_only():
            return (slice(i, i+1) for i in range(0, 10, 2))

        def mixed():
            return (slice(i, i+1) if i % 2 == 0 else i for i in range(10))

        def unthinkable():
            for i in range(10):
                if i % 3 == 0:
                    yield slice(i, i+1)
                elif i % 3 == 1:
                    yield i
                else:
                    yield np.array([i], dtype=int)
        for c in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
                  lambda x: pd.Series(tuple(x))):
            exp = np.arange(10, dtype=int)
            obs = s._munge_to_index_array(c(mixed()))
            npt.assert_equal(obs, exp)

            exp = np.arange(10, dtype=int)
            obs = s._munge_to_index_array(c(unthinkable()))
            npt.assert_equal(obs, exp)

            exp = np.arange(10, step=2, dtype=int)
            obs = s._munge_to_index_array(c(slices_only()))
            npt.assert_equal(obs, exp)

    def test_munge_to_index_array_invalid_iterable(self):
        s = Sequence('')

        def bad1():
            yield "r"
            yield [1, 2, 3]

        def bad2():
            yield 1
            yield 'str'

        def bad3():
            yield False
            yield True
            yield 2

        def bad4():
            yield np.array([False, True])
            yield slice(2, 5)

        for c in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
                  lambda x: pd.Series(tuple(x))):

            with self.assertRaises(TypeError):
                s._munge_to_index_array(bad1())

            with self.assertRaises(TypeError):
                s._munge_to_index_array(bad2())

            with self.assertRaises(TypeError):
                s._munge_to_index_array(bad3())

            with self.assertRaises(TypeError):
                s._munge_to_index_array(bad4())

    def test_munge_to_index_array_valid_string(self):
        seq = Sequence('ACGTACGT',
                       positional_metadata={'introns': [False, True, True,
                                                        False, False, True,
                                                        False, False]})
        npt.assert_equal(np.array([1, 2, 5]),
                         seq._munge_to_index_array('introns'))

        seq.positional_metadata['exons'] = ~seq.positional_metadata['introns']
        npt.assert_equal(np.array([0, 3, 4, 6, 7]),
                         seq._munge_to_index_array('exons'))

    def test_munge_to_index_array_invalid_string(self):
        seq_str = 'ACGT'
        seq = Sequence(seq_str,
                       positional_metadata={'quality': range(len(seq_str))})

        with self.assertRaisesRegex(ValueError,
                                    r"No positional metadata associated with "
                                    "key 'introns'"):
            seq._munge_to_index_array('introns')

        with self.assertRaisesRegex(TypeError,
                                    r"Column 'quality' in positional metadata "
                                    "does not correspond to a boolean "
                                    "vector"):
            seq._munge_to_index_array('quality')

    def test_munge_to_bytestring_return_bytes(self):
        seq = Sequence('')
        m = 'dummy_method'
        str_inputs = ('', 'a', 'acgt')
        unicode_inputs = ('', 'a', 'acgt')
        byte_inputs = (b'', b'a', b'acgt')
        seq_inputs = (Sequence(''), Sequence('a'), Sequence('acgt'))
        all_inputs = str_inputs + unicode_inputs + byte_inputs + seq_inputs
        all_expected = [b'', b'a', b'acgt'] * 4

        for input_, expected in zip(all_inputs, all_expected):
            observed = seq._munge_to_bytestring(input_, m)
            self.assertEqual(observed, expected)
            self.assertIs(type(observed), bytes)

    def test_munge_to_bytestring_unicode_out_of_ascii_range(self):
        seq = Sequence('')
        all_inputs = ('\x80', 'abc\x80', '\x80abc')
        for input_ in all_inputs:
            with self.assertRaisesRegex(UnicodeEncodeError,
                                        r"'ascii' codec can't encode character"
                                        r".*in position.*: ordinal not in"
                                        r" range\(128\)"):
                seq._munge_to_bytestring(input_, 'dummy_method')


class TestDistance(TestSequenceBase):
    def test_mungeable_inputs_to_sequence(self):
        def metric(a, b):
            self.assertEqual(a, Sequence("abcdef"))
            self.assertEqual(b, Sequence("12bcef"))
            return 42.0

        for constructor in self.sequence_kinds:
            seq1 = Sequence("abcdef")
            seq2 = constructor("12bcef")

            distance = seq1.distance(seq2, metric=metric)

            self.assertEqual(distance, 42.0)

    def test_mungeable_inputs_to_sequence_subclass(self):
        def metric(a, b):
            self.assertEqual(a, SequenceSubclass("abcdef"))
            self.assertEqual(b, SequenceSubclass("12bcef"))
            return -42.0

        sequence_kinds = frozenset([
            str, SequenceSubclass,
            lambda s: np.frombuffer(s.encode('ascii'), dtype='|S1'),
            lambda s: np.frombuffer(s.encode('ascii'), dtype=np.uint8)])

        for constructor in sequence_kinds:
            seq1 = SequenceSubclass("abcdef")
            seq2 = constructor("12bcef")

            distance = seq1.distance(seq2, metric=metric)

            self.assertEqual(distance, -42.0)

    def test_sequence_type_mismatch(self):
        seq1 = SequenceSubclass("abcdef")
        seq2 = Sequence("12bcef")

        with self.assertRaisesRegex(TypeError,
                                    r'SequenceSubclass.*Sequence.*`distance`'):
            seq1.distance(seq2)

        with self.assertRaisesRegex(TypeError,
                                    r'Sequence.*SequenceSubclass.*`distance`'):
            seq2.distance(seq1)

    def test_munging_invalid_characters_to_self_type(self):
        with self.assertRaisesRegex(ValueError, r'Invalid characters.*X'):
            DNA("ACGT").distance("WXYZ")

    def test_munging_invalid_type_to_self_type(self):
        with self.assertRaises(TypeError):
            Sequence("ACGT").distance(42)

    def test_return_type_coercion(self):
        def metric(a, b):
            return 42

        distance = Sequence('abc').distance('cba', metric=metric)

        self.assertIsInstance(distance, float)

    def test_invalid_return_type(self):
        def metric(a, b):
            return 'too far'

        with self.assertRaisesRegex(ValueError, r'string.*float'):
            Sequence('abc').distance('cba', metric=metric)

    def test_arbitrary_metric(self):
        def metric(x, y):
            return len(x) ** 2 + len(y) ** 2

        seq1 = Sequence("12345678")
        seq2 = Sequence("1234")

        distance = seq1.distance(seq2, metric=metric)

        self.assertEqual(distance, 80.0)

    def test_scipy_hamming_metric_with_metadata(self):
        # test for #1254
        seqs1 = [
            Sequence("ACGT"),
            Sequence("ACGT", metadata={'id': 'abc'}),
            Sequence("ACGT", positional_metadata={'qual': range(4)})
        ]
        seqs2 = [
            Sequence("AAAA"),
            Sequence("AAAA", metadata={'id': 'def'}),
            Sequence("AAAA", positional_metadata={'qual': range(4, 8)})
        ]

        for seqs in seqs1, seqs2:
            for seq1, seq2 in itertools.product(seqs, repeat=2):
                distance = seq1.distance(seq2,
                                         metric=scipy.spatial.distance.hamming)
                self.assertEqual(distance, 0.0)

        for seq1, seq2 in itertools.product(seqs1, seqs2):
            distance = seq1.distance(seq2,
                                     metric=scipy.spatial.distance.hamming)
            self.assertEqual(distance, 0.75)

    def test_default_metric_with_metadata(self):
        # test for #1254
        seqs1 = [
            Sequence("ACGT"),
            Sequence("ACGT", metadata={'id': 'abc'}),
            Sequence("ACGT", positional_metadata={'qual': range(4)})
        ]
        seqs2 = [
            Sequence("AAAA"),
            Sequence("AAAA", metadata={'id': 'def'}),
            Sequence("AAAA", positional_metadata={'qual': range(4, 8)})
        ]

        for seqs in seqs1, seqs2:
            for seq1, seq2 in itertools.product(seqs, repeat=2):
                distance = seq1.distance(seq2)
                self.assertEqual(distance, 0.0)

        for seq1, seq2 in itertools.product(seqs1, seqs2):
            distance = seq1.distance(seq2)
            self.assertEqual(distance, 0.75)

    def test_default_metric_matches_hamming(self):
        seq1 = Sequence("abcdef")
        seq2 = Sequence("12bcef")
        seq_wrong = Sequence("abcdefghijklmnop")

        distance1 = seq1.distance(seq2)
        distance2 = skbio.sequence.distance.hamming(seq1, seq2)

        self.assertEqual(distance1, distance2)

        with self.assertRaises(ValueError):
            seq1.distance(seq_wrong)

        with self.assertRaises(ValueError):
            seq_wrong.distance(seq1)


# NOTE: this must be a *separate* class for doctests only (no unit tests). nose
# will not run the unit tests otherwise
#
# these doctests exercise the correct formatting of Sequence's repr in a
# variety of situations. they are more extensive than the unit tests above
# (TestSequence.test_repr) but cannot be relied upon for coverage (the unit
# tests take care of this)
class SequenceReprDoctests:
    r"""&gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from skbio import Sequence

    Empty (minimal) sequence:

    &gt;&gt;&gt; Sequence('')
    Sequence
    -------------
    Stats:
        length: 0
    -------------

    Single character sequence:

    &gt;&gt;&gt; Sequence('G')
    Sequence
    -------------
    Stats:
        length: 1
    -------------
    0 G

    Multicharacter sequence:

    &gt;&gt;&gt; Sequence('ACGT')
    Sequence
    -------------
    Stats:
        length: 4
    -------------
    0 ACGT

    Full single line:

    &gt;&gt;&gt; Sequence('A' * 60)
    Sequence
    -------------------------------------------------------------------
    Stats:
        length: 60
    -------------------------------------------------------------------
    0 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA

    Full single line with 1 character overflow:

    &gt;&gt;&gt; Sequence('A' * 61)
    Sequence
    --------------------------------------------------------------------
    Stats:
        length: 61
    --------------------------------------------------------------------
    0  AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    60 A

    Two full lines:

    &gt;&gt;&gt; Sequence('T' * 120)
    Sequence
    --------------------------------------------------------------------
    Stats:
        length: 120
    --------------------------------------------------------------------
    0  TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT
    60 TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT

    Two full lines with 1 character overflow:

    &gt;&gt;&gt; Sequence('T' * 121)
    Sequence
    ---------------------------------------------------------------------
    Stats:
        length: 121
    ---------------------------------------------------------------------
    0   TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT
    60  TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT
    120 T

    Five full lines (maximum amount of information):

    &gt;&gt;&gt; Sequence('A' * 300)
    Sequence
    ---------------------------------------------------------------------
    Stats:
        length: 300
    ---------------------------------------------------------------------
    0   AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    60  AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    120 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    180 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    240 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA

    Six lines starts "summarized" output:

    &gt;&gt;&gt; Sequence('A' * 301)
    Sequence
    ---------------------------------------------------------------------
    Stats:
        length: 301
    ---------------------------------------------------------------------
    0   AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    60  AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    ...
    240 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    300 A

    A naive algorithm would assume the width of the first column (noting
    position) based on the sequence's length alone. This can be off by one if
    the last position (in the last line) has a shorter width than the width
    calculated from the sequence's length. This test case ensures that only a
    single space is inserted between position 99960 and the first sequence
    chunk:

    &gt;&gt;&gt; Sequence('A' * 100000)
    Sequence
    -----------------------------------------------------------------------
    Stats:
        length: 100000
    -----------------------------------------------------------------------
    0     AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    60    AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    ...
    99900 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    99960 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA

    The largest sequence that can be displayed using six chunks per line:

    &gt;&gt;&gt; Sequence('A' * 100020)
    Sequence
    -----------------------------------------------------------------------
    Stats:
        length: 100020
    -----------------------------------------------------------------------
    0     AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    60    AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    ...
    99900 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    99960 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA

    A single character longer than the previous sequence causes the optimal
    number of chunks per line to be 5:

    &gt;&gt;&gt; Sequence('A' * 100021)
    Sequence
    -------------------------------------------------------------
    Stats:
        length: 100021
    -------------------------------------------------------------
    0      AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    50     AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    ...
    99950  AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
    100000 AAAAAAAAAA AAAAAAAAAA A

    Wide range of characters (locale-independent):

    &gt;&gt;&gt; import string
    &gt;&gt;&gt; Sequence((string.ascii_letters + string.punctuation + string.digits +
    ...          'a space') * 567)
    Sequence
    -----------------------------------------------------------------------
    Stats:
        length: 57267
    -----------------------------------------------------------------------
    0     abcdefghij klmnopqrst uvwxyzABCD EFGHIJKLMN OPQRSTUVWX YZ!"#$%&amp;'(
    60    )*+,-./:;&lt; =&gt;?@[\]^_` {|}~012345 6789a spac eabcdefghi jklmnopqrs
    ...
    57180 opqrstuvwx yzABCDEFGH IJKLMNOPQR STUVWXYZ!" #$%&amp;'()*+, -./:;&lt;=&gt;?@
    57240 [\]^_`{|}~ 0123456789 a space

    Supply horrendous metadata, positional, and interval metadata to
    exercise a variety of metadata formatting cases and rules. Sorting
    should be by type, then by value within each type (Python 3
    doesn't allow sorting of mixed types):

    &gt;&gt;&gt; metadata = {
    ...     # str key, str value
    ...     'abc': 'some description',
    ...     # int value
    ...     'foo': 42,
    ...     # unsupported type (dict) value
    ...     'bar': {},
    ...     # int key, wrapped str (single line)
    ...     42: 'some words to test text wrapping and such... yada yada yada '
    ...         'yada yada yada yada yada.',
    ...     # bool key, wrapped str (multi-line)
    ...     True: 'abc ' * 34,
    ...     # float key, truncated str (too long)
    ...     42.5: 'abc ' * 200,
    ...     # unsupported type (tuple) key, unsupported type (list) value
    ...     ('foo', 'bar'): [1, 2, 3],
    ...     # bytes key, single long word that wraps
    ...     b'long word': 'abc' * 30,
    ...     # truncated key (too long), None value
    ...     'too long of a key name to display in repr': None,
    ...     # wrapped bytes value (has b'' prefix)
    ...     'bytes wrapped value': b'abcd' * 25,
    ...     # float value
    ...     0.1: 99.9999,
    ...     # bool value
    ...     43: False,
    ...     # None key, complex value
    ...     None: complex(-1.0, 0.0),
    ...     # nested quotes
    ...     10: '"\''
    ... }
    &gt;&gt;&gt; positional_metadata = pd.DataFrame({
    ...     # str key, int list value
    ...     'foo': [1, 2, 3, 4],
    ...     # float key, float list value
    ...     42.5: [2.5, 3.0, 4.2, -0.00001],
    ...     # int key, object list value
    ...     42: [[], 4, 5, {}],
    ...     # truncated key (too long), bool list value
    ...     'abc' * 90: [True, False, False, True],
    ...     # None key
    ...     None: range(4)})
    &gt;&gt;&gt; positional_metadata = positional_metadata.reindex(
    ...     columns=['foo', 42.5, 42, 'abc' * 90, None])
    &gt;&gt;&gt; interval_metadata = IntervalMetadata(4)
    &gt;&gt;&gt; _ = interval_metadata.add([(0, 2), (1, 3)],
    ...                           [(False, True), (False, False)],
    ...                           {'gene': 'p53'})
    &gt;&gt;&gt; _ = interval_metadata.add([(1, 4)])
    &gt;&gt;&gt; Sequence('ACGT', metadata=metadata,
    ...          positional_metadata=positional_metadata,
    ...          interval_metadata=interval_metadata)
    Sequence
    -----------------------------------------------------------------------
    Metadata:
        None: (-1+0j)
        True: 'abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc
               abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc
               abc abc abc abc '
        b'long word': 'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabca
                       bcabcabcabcabcabcabcabcabcabcabcabcabc'
        0.1: 99.9999
        42.5: &lt;class 'str'&gt;
        10: '"\''
        42: 'some words to test text wrapping and such... yada yada yada
             yada yada yada yada yada.'
        43: False
        'abc': 'some description'
        'bar': &lt;class 'dict'&gt;
        'bytes wrapped value': b'abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdab
                                 cdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd
                                 abcdabcdabcdabcd'
        'foo': 42
        &lt;class 'str'&gt;: None
        &lt;class 'tuple'&gt;: &lt;class 'list'&gt;
    Positional metadata:
        'foo': &lt;dtype: int64&gt;
        42.5: &lt;dtype: float64&gt;
        42: &lt;dtype: object&gt;
        &lt;class 'str'&gt;: &lt;dtype: bool&gt;
        None: &lt;dtype: int64&gt;
    Interval metadata:
        2 interval features
    Stats:
        length: 4
    -----------------------------------------------------------------------
    0 ACGT

    """
    pass


if __name__ == "__main__":
    main()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_tree.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
# ----------------------------------------------------------------------------
# Copyright (c) 2013--, scikit-bio development team.
#
# Distributed under the terms of the Modified BSD License.
#
<a name="49"></a># The full license is in the file COPYING.txt, distributed with this software.
# ----------------------------------------------------------------------------

<font color="#8e35ef"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import io
from unittest import TestCase, main
from collections import defaultdict

import numpy as np
import numpy.testing as npt
from scipy.stats import pearsonr

from skbio import DistanceMatrix, TreeNode
from skbio.tree import (DuplicateNodeError, NoLengthError,
                        TreeError, MissingNodeError, NoParentError)
from skbio.util import RepresentationWarning


class TreeNodeSubclass(TreeNode):
    pass


class</b></font> TreeTests(TestCase):

    def setUp(self):
<a name="31"></a>        """Prep the self"""
        self.simple_t = TreeNode.read(io.StringIO("((a,b)i1,(c,d)i2)root;"))
        nodes = dict([(x, TreeNode(x)) for x in 'abcdefgh'])
        nodes['a']<font color="#3ea99f"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(nodes['b'])
<a name="45"></a>        nodes['b'].append(nodes['c'])
        nodes['c'].append(nodes['d'])
        nodes['c'].</b></font>append(nodes['e'])
        nodes['c']<font color="#549748"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(nodes['f'])
        nodes['f'].append(nodes['g'])
        nodes['a'].append(nodes['h'])
        self.</b></font>TreeRoot = nodes['a']

        def rev_f(items):
            items.reverse()

        def rotate_f(items):
            tmp = items[-1]
            items[1:] = items[:-1]
            items[0] = tmp

        self.rev_f = rev_f
        self.rotate_f = rotate_f
        self.complex_tree = TreeNode.read(io.StringIO(
            "(((a,b)int1,(x,y,(w,z)int2,(c,d)int3)int4),(e,f)int5);"))

    def test_bug_issue_1416(self):
        tree = TreeNode.read(['(((a,b,f,g),c),d);'])
        new_tree = tree.shear(['a', 'b', 'c', 'f'])

        exp = {'a', 'b', 'c', 'f'}
        obs = {n.name for n in new_tree.tips()}

        self.assertEqual(obs, exp)
        self.assertEqual(id(new_tree), id(new_tree.children[0].parent))
        self.assertEqual(id(new_tree), id(new_tree.children[1].parent))

    def test_observed_node_counts(self):
        """returns observed nodes counts given vector of otu observation counts
        """
        # no OTUs observed
        otu_counts = {}
        expected = defaultdict(int)
        self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
                         expected)
        # error on zero count(s)
        otu_counts = {'a': 0}
        self.assertRaises(ValueError, self.simple_t.observed_node_counts,
                          otu_counts)
        otu_counts = {'a': 0, 'b': 0, 'c': 0, 'd': 0}
        self.assertRaises(ValueError, self.simple_t.observed_node_counts,
                          otu_counts)

        # all OTUs observed once
        otu_counts = {'a': 1, 'b': 1, 'c': 1, 'd': 1}
        expected = defaultdict(int)
        expected[self.simple_t.find('root')] = 4
        expected[self.simple_t.find('i1')] = 2
        expected[self.simple_t.find('i2')] = 2
        expected[self.simple_t.find('a')] = 1
        expected[self.simple_t.find('b')] = 1
        expected[self.simple_t.find('c')] = 1
        expected[self.simple_t.find('d')] = 1
        self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
                         expected)

        # some OTUs observed twice
        otu_counts = {'a': 2, 'b': 1, 'c': 1, 'd': 1}
        expected = defaultdict(int)
        expected[self.simple_t.find('root')] = 5
        expected[self.simple_t.find('i1')] = 3
        expected[self.simple_t.find('i2')] = 2
        expected[self.simple_t.find('a')] = 2
        expected[self.simple_t.find('b')] = 1
        expected[self.simple_t.find('c')] = 1
        expected[self.simple_t.find('d')] = 1
        self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
                         expected)

        otu_counts = {'a': 2, 'b': 1, 'c': 1, 'd': 2}
        expected = defaultdict(int)
        expected[self.simple_t.find('root')] = 6
        expected[self.simple_t.find('i1')] = 3
        expected[self.simple_t.find('i2')] = 3
        expected[self.simple_t.find('a')] = 2
        expected[self.simple_t.find('b')] = 1
        expected[self.simple_t.find('c')] = 1
        expected[self.simple_t.find('d')] = 2
        self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
                         expected)

        # some OTUs observed, others not observed
        otu_counts = {'a': 2, 'b': 1}
        expected = defaultdict(int)
        expected[self.simple_t.find('root')] = 3
        expected[self.simple_t.find('i1')] = 3
        expected[self.simple_t.find('a')] = 2
        expected[self.simple_t.find('b')] = 1
        self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
                         expected)

        otu_counts = {'d': 1}
        expected = defaultdict(int)
        expected[self.simple_t.find('root')] = 1
        expected[self.simple_t.find('i2')] = 1
        expected[self.simple_t.find('d')] = 1
        self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
                         expected)

        # error on non-tips
        otu_counts = {'a': 2, 'e': 1}
        self.assertRaises(MissingNodeError, self.simple_t.observed_node_counts,
                          otu_counts)
        otu_counts = {'a': 2, 'i1': 1}
        self.assertRaises(MissingNodeError, self.simple_t.observed_node_counts,
                          otu_counts)

        # test with another tree
        otu_counts = {}
        expected = defaultdict(int)
        self.assertEqual(self.complex_tree.observed_node_counts(otu_counts),
                         expected)

        otu_counts = {'e': 42, 'f': 1}
        expected[self.complex_tree.root()] = 43
        expected[self.complex_tree.find('int5')] = 43
        expected[self.complex_tree.find('e')] = 42
        expected[self.complex_tree.find('f')] = 1
        self.assertEqual(self.complex_tree.observed_node_counts(otu_counts),
                         expected)
<a name="34"></a>
    def test_count(self):
        """Get node counts"""
        exp <font color="#827d6b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= 7
        obs = self.simple_t.count()
        self.assertEqual(obs, exp)

        exp = 4
        obs = self.simple_t.count(</b></font>tips=True)
        self.assertEqual(obs, exp)

    def test_copy(self):
        """copy a tree"""
        self.simple_t.children[0].length = 1.2
        self.simple_t.children[1].children[0].length = 0.5
        cp = self.simple_t.copy()
        gen = zip(cp.traverse(include_self=True),
                  self.simple_t.traverse(include_self=True))

        for a, b in gen:
            self.assertIsNot(a, b)
            self.assertEqual(a.name, b.name)
            self.assertEqual(a.length, b.length)

    def test_append(self):
        """Append a node to a tree"""
        second_tree = TreeNode.read(io.StringIO("(x,y)z;"))
        self.simple_t.append(second_tree)

<a name="3"></a>        self.assertEqual(self.simple_t.children[0].name, 'i1')
        self.assertEqual(self.simple_t.children[1].name, 'i2')
        self.assertEqual(self.simple_t.children[2].name, 'z')
        self.assertEqual(len<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(self.simple_t.children), 3)
        self.assertEqual(self.simple_t.children[2].children[0].name, 'x')
        self.assertEqual(self.simple_t.children[2].children[1].name, 'y')
        self.</b></font>assertEqual(second_tree.parent, self.simple_t)
<a name="10"></a>
    def test_extend(self):
        """Extend a few nodes"""
<a name="46"></a>        second_tree = TreeNode<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read(io.StringIO("(x1,y1)z1;"))
        third_tree = TreeNode.read(io.StringIO("(x2,y2)z2;"))
        first_tree = TreeNode.read(io.StringIO("(x1,y1)z1;"))
        fourth_tree =</b></font> TreeNode.read<font color="#668b8b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(io.StringIO("(x2,y2)z2;"))
        self.simple_t.extend([second_tree, third_tree])

        first_tree.extend(fourth_tree.children)
        self.assertEqual(</b></font>0, len(fourth_tree.children))
<a name="0"></a>        self.assertEqual(first_tree.children[0].name, 'x1')
        self.assertEqual(first_tree.children[1].name, 'y1')
        self.assertEqual(first_tree.children[2].name, 'x2')
        self.assertEqual(first_tree.children<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[3].name, 'y2')

        self.assertEqual(self.simple_t.children[0].name, 'i1')
<a name="2"></a>        self.assertEqual(self.simple_t.children[1].name, 'i2')
        self.assertEqual(self.simple_t.children[2].name, 'z1')
        self.</b></font>assertEqual(self.simple_t.children[3].name, 'z2')
<a name="7"></a>        self.assertEqual(len<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(self.simple_t.children), 4)
        self.assertEqual(self.simple_t.children[2].children[0].name, 'x1')
        self.assertEqual(self.simple_t.children[2].children[1].name, 'y1')
        self.</b></font>assertEqual(self.simple_t.children[3]<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.children[0].name, 'x2')
        self.assertEqual(self.simple_t.children[3].children[1].name, 'y2')
        self.assertIs(second_tree.parent, self.simple_t)
        self.</b></font>assertIs(third_tree.parent, self.simple_t)

    def test_extend_empty(self):
        """Extend on the empty case should work"""
        self.simple_t.extend([])
        self.assertEqual(self.simple_t.children[0].name, 'i1')
        self.assertEqual(self.simple_t.children[1].name, 'i2')
        self.assertEqual(len(self.simple_t.children), 2)

    def test_iter(self):
        """iter wraps children"""
        exp = ['i1', 'i2']
        obs = [n.name for n in self.simple_t]
        self.assertEqual(obs, exp)

    def test_gops(self):
        """Basic TreeNode operations should work as expected"""
        p = TreeNode()
        self.assertEqual(str(p), ';\n')
        p.name = 'abc'
        self.assertEqual(str(p), 'abc;\n')
        p.length = 3
        self.assertEqual(str(p), 'abc:3;\n')  # don't suppress branch from root
        q = TreeNode()
        p.append(q)
        self.assertEqual(str(p), '()abc:3;\n')
        r = TreeNode()
<a name="21"></a>        q.append(r)
        self.assertEqual(str(p), '(())abc:3;\n')
        r.name = 'xyz'
        self<font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(str(p), '((xyz))abc:3;\n')
        q.length = 2
        self.assertEqual(str(p), '((xyz):2)abc:3;\n')

    def test_pop(self):
        """Pop off a node"""
        second_tree = TreeNode.read(io.</b></font>StringIO("(x1,y1)z1;"))
        third_tree = TreeNode.read(io.StringIO("(x2,y2)z2;"))
<a name="28"></a>        self.simple_t.extend([second_tree, third_tree])

        i1 = self.simple_t.pop(0)
        z2 <font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.simple_t.pop()

        self.assertEqual(i1.name, 'i1')
        self.assertEqual(z2.name, 'z2')
<a name="32"></a>        self.assertEqual(i1.</b></font>children[0].name, 'a')
        self.assertEqual(i1.children[1].name, 'b')
        self.assertEqual(z2.children[0].name, 'x2')
        self<font color="#5b8daf"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(z2.children[1].name, 'y2')

        self.assertEqual(self.simple_t.children[0].name, 'i2')
        self.</b></font>assertEqual(self.simple_t.children[1].name, 'z1')
        self.assertEqual(len(self.simple_t.children), 2)
<a name="29"></a>
    def test_remove(self):
        """Remove nodes"""
        self.assertTrue(self.simple_t.remove(self.simple_t<font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.children[0]))
        self.assertEqual(len(self.simple_t.children), 1)
        n = TreeNode()
        self.assertFalse(self.simple_t.</b></font>remove(n))

    def test_remove_deleted(self):
        """Remove nodes by function"""
        def f(node):
            return node.name in ['b', 'd']

        self.simple_t.remove_deleted(f)
        exp = "((a)i1,(c)i2)root;\n"
        obs = str(self.simple_t)
        self.assertEqual(obs, exp)

    def test_adopt(self):
        """Adopt a node!"""
        n1 = TreeNode(name='n1')
        n2 = TreeNode(name='n2')
        n3 = TreeNode(name='n3')

        self.simple_t._adopt(n1)
        self.simple_t.children[-1]._adopt(n2)
<a name="30"></a>        n2._adopt(n3)

        # adopt doesn't update .children
        self.assertEqual(len<font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(self.simple_t.children), 2)

        self.assertIs(n1.parent, self.simple_t)
        self.assertIs(n2.parent, self.simple_t.children[</b></font>-1])
        self.assertIs(n3.parent, n2)

    def test_remove_node(self):
        """Remove a node by index"""
        n = self.simple_t._remove_node(-1)
        self.assertEqual(n.parent, None)
        self.assertEqual(len(self.simple_t.children), 1)
        self.assertEqual(len(n.children), 2)
        self.assertNotIn(n, self.simple_t.children)

    def test_shear_prune_parent_dropped(self):
        bugtree = "((a,b),((c,d),(e,f)));"
        to_keep = ['c', 'd']
        exp = "(c,d);\n"
        obs = str(TreeNode.read(io.StringIO(bugtree)).shear(to_keep))
        self.assertEqual(obs, exp)

    def test_prune_nested_single_descendent(self):
        bugtree = "(((a,b)));"
        exp = "(a,b);\n"
        t = TreeNode.read(io.StringIO(bugtree))
        t.prune()
        obs = str(t)
        self.assertEqual(obs, exp)

    def test_prune_root_single_desc(self):
        t = TreeNode.read(["((a,b)c)extra;"])
        exp = "(a,b)c;\n"
        t.prune()
        self.assertEqual(str(t), exp)

    def test_prune(self):
        """Collapse single descendent nodes"""
        # check the identity case
        cp = self.simple_t.copy()
        self.simple_t.prune()

        gen = zip(cp.traverse(include_self=True),
                  self.simple_t.traverse(include_self=True))

        for a, b in gen:
            self.assertIsNot(a, b)
            self.assertEqual(a.name, b.name)
            self.assertEqual(a.length, b.length)

        # create a single descendent by removing tip 'a'
        n = self.simple_t.children[0]
        n.remove(n.children[0])
        self.simple_t.prune()

        self.assertEqual(len(self.simple_t.children), 2)
        self.assertEqual(self.simple_t.children[0].name, 'i2')
        self.assertEqual(self.simple_t.children[1].name, 'b')

    def test_prune_length(self):
        """Collapse single descendent nodes"""
        # check the identity case
        cp = self.simple_t.copy()
        self.simple_t.prune()

        gen = zip(cp.traverse(include_self=True),
                  self.simple_t.traverse(include_self=True))

        for a, b in gen:
            self.assertIsNot(a, b)
            self.assertEqual(a.name, b.name)
            self.assertEqual(a.length, b.length)

        for n in self.simple_t.traverse():
            n.length = 1.0

        # create a single descendent by removing tip 'a'
        n = self.simple_t.children[0]
<a name="1"></a>        n.remove(n.children[0])
        self.simple_t.prune()

        self.assertEqual(len<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(self.simple_t.children), 2)
        self.assertEqual(self.simple_t.children[0].name, 'i2')
        self.assertEqual(self.simple_t.children[1].name, 'b')
        self.assertEqual(self.simple_t.children[1].</b></font>length, 2.0)

    def test_subset(self):
        """subset should return set of leaves that descends from node"""
        t = self.simple_t
        self.assertEqual(t.subset(), frozenset('abcd'))
        c = t.children[0]
        self.assertEqual(c.subset(), frozenset('ab'))
        leaf = c.children[1]
        self.assertEqual(leaf.subset(), frozenset(''))

    def test_subsets(self):
        """subsets should return all subsets descending from a set"""
        t = self.simple_t
        self.assertEqual(t.subsets(), frozenset(
            [frozenset('ab'), frozenset('cd')]))

    def test_is_tip(self):
<a name="18"></a>        """see if we're a tip or not"""
        self.assertFalse(self.simple_t.is_tip())
        self.assertFalse(self.simple_t.children[0].is_tip())
        self.assertTrue(self.simple_t.children[0].children<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0].is_tip())

    def test_is_root(self):
<a name="48"></a>        """see if we're at the root or not"""
        self.assertTrue(self.simple_t.is_root())
        self.assertFalse(self.simple_t.</b></font>children[0].is_root())
        self<font color="#c57726"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertFalse(self.simple_t.children[0].children[0].is_root())

    def test_root(self):
        """Get the root!"""
<a name="47"></a>        root =</b></font> self.simple_t
        self.assertIs(root, self.simple_t.root())
        self.assertIs(root, self.simple_t.children[0].root())
        self<font color="#d16587"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertIs(root, self.simple_t.children[1].children[1].root())
<a name="43"></a>
    def test_invalidate_lookup_caches(self):
        root =</b></font> self.simple_t
        root<font color="#c22817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.create_caches()
        self.assertNotEqual(root._tip_cache, {})
        self.assertNotEqual(root._non_tip_cache, {})
        root.invalidate_caches()
        self.assertEqual(</b></font>root._tip_cache, {})
        self.assertEqual(root._non_tip_cache, {})

    def test_invalidate_attr_caches(self):
        tree = TreeNode.read(io.StringIO("((a,b,(c,d)e)f,(g,h)i)root;"))

        def f(n):
            return [n.name] if n.is_tip() else []

        tree.cache_attr(f, 'tip_names')
        tree.invalidate_caches()
        for n in tree.traverse(include_self=True):
            self.assertFalse(hasattr(n, 'tip_names'))

    def test_create_caches_duplicate_tip_names(self):
        with self.assertRaises(DuplicateNodeError):
<a name="15"></a>            TreeNode.read(io.StringIO('(a, a);')).create_caches()

    def test_find_all(self):
        t = TreeNode.read(io.StringIO<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("((a,b)c,((d,e)c)c,(f,(g,h)c)a)root;"))
        exp = [t.children[0],
               t.children[1].children[0],
               t.children[1],
               t.children[2].children[</b></font>1]]
        obs = t.find_all('c')
        self.assertEqual(obs, exp)

        identity = t.find_all(t)
        self.assertEqual(len(identity), 1)
        self.assertEqual(identity[0], t)

        identity_name = t.find_all('root')
        self.assertEqual(len(identity_name), 1)
        self.assertEqual(identity_name[0], t)

        exp = [t.children[2],
               t.children[0].children[0]]
        obs = t.find_all('a')
        self.assertEqual(obs, exp)

        with self.assertRaises(MissingNodeError):
            t.find_all('missing')

    def test_find(self):
        """Find a node in a tree"""
        t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f);"))
        exp = t.children[0]
        obs = t.find('c')
        self.assertEqual(obs, exp)

        exp = t.children[0].children[1]
        obs = t.find('b')
        self.assertEqual(obs, exp)

        with self.assertRaises(MissingNodeError):
            t.find('does not exist')

    def test_find_cache_bug(self):
        """First implementation did not force the cache to be at the root"""
        t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f,(g,h)f);"))
        exp_tip_cache_keys = set(['a', 'b', 'd', 'e', 'g', 'h'])
        exp_non_tip_cache_keys = set(['c', 'f'])
        tip_a = t.children[0].children[0]
        tip_a.create_caches()
        self.assertEqual(tip_a._tip_cache, {})
        self.assertEqual(set(t._tip_cache), exp_tip_cache_keys)
        self.assertEqual(set(t._non_tip_cache), exp_non_tip_cache_keys)
        self.assertEqual(t._non_tip_cache['f'], [t.children[1], t.children[2]])

    def test_find_by_id(self):
        """Find a node by id"""
        t1 = TreeNode.read(io.StringIO("((,),(,,));"))
        t2 = TreeNode.read(io.StringIO("((,),(,,));"))

        exp = t1.children[1]
        obs = t1.find_by_id(6)  # right inner node with 3 children
        self.assertEqual(obs, exp)

        exp = t2.children[1]
        obs = t2.find_by_id(6)  # right inner node with 3 children
        self.assertEqual(obs, exp)

        with self.assertRaises(MissingNodeError):
            t1.find_by_id(100)

    def test_find_by_func(self):
        """Find nodes by a function"""
        t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f);"))

        def func(x):
            return x.parent == t.find('c')

        exp = ['a', 'b']
        obs = [n.name for n in t.find_by_func(func)]
        self.assertEqual(obs, exp)

    def test_ancestors(self):
        """Get all the ancestors"""
        exp = ['i1', 'root']
        obs = self.simple_t.children[0].children[0].ancestors()
        self.assertEqual([o.name for o in obs], exp)

        exp = ['root']
        obs = self.simple_t.children[0].ancestors()
        self.assertEqual([o.name for o in obs], exp)

        exp = []
        obs = self.simple_t.ancestors()
        self.assertEqual([o.name for o in obs], exp)

    def test_siblings(self):
        """Get the siblings"""
        exp = []
        obs = self.simple_t.siblings()
        self.assertEqual(obs, exp)

        exp = ['i2']
        obs = self.simple_t.children[0].siblings()
        self.assertEqual([o.name for o in obs], exp)

        exp = ['c']
        obs = self.simple_t.children[1].children[1].siblings()
        self.assertEqual([o.name for o in obs], exp)

        self.simple_t.append(TreeNode(name="foo"))
        self.simple_t.append(TreeNode(name="bar"))
        exp = ['i1', 'foo', 'bar']
        obs = self.simple_t.children[1].siblings()
        self.assertEqual([o.name for o in obs], exp)

    def test_ascii_art(self):
        """Make some ascii trees"""
        # unlabeled internal node
        tr = TreeNode.read(io.StringIO("(B:0.2,(C:0.3,D:0.4):0.6)F;"))
        obs = tr.ascii_art(show_internal=True, compact=False)
        exp = ("          /-B\n"
               "-F-------|\n"
               "         |          /-C\n"
               "          \\--------|\n"
               "                    \\-D")
        self.assertEqual(obs, exp)
        obs = tr.ascii_art(show_internal=True, compact=True)
        exp = ("-F------- /-B\n"
               "          \\-------- /-C\n"
               "                    \\-D")
        self.assertEqual(obs, exp)
        obs = tr.ascii_art(show_internal=False, compact=False)
        exp = ("          /-B\n"
               "---------|\n"
               "         |          /-C\n"
               "          \\--------|\n"
               "                    \\-D")
        self.assertEqual(obs, exp)

    def test_ascii_art_with_support(self):
        """Make some ascii trees with support values"""
        tr = TreeNode.read(io.StringIO("(B:0.2,(C:0.3,D:0.4)90:0.6)F;"))
        exp = "          /-B\n-F-------|\n         |          /-C\n         "\
              " \\90------|\n                    \\-D"
        obs = tr.ascii_art(show_internal=True, compact=False)
        self.assertEqual(obs, exp)
        tr.assign_supports()
        obs = tr.ascii_art(show_internal=True, compact=False)
        self.assertEqual(obs, exp)
        tr = TreeNode.read(io.StringIO("((A,B)75,(C,D)'80:spA');"))
        exp = "                    /-A\n          /75------|\n         |    "\
              "      \\-B\n---------|\n         |          /-C\n          \\"\
              "80:spA--|\n                    \\-D"
        obs = tr.ascii_art(show_internal=True, compact=False)
        self.assertEqual(obs, exp)
        tr.assign_supports()
        obs = tr.ascii_art(show_internal=True, compact=False)
<a name="44"></a>        self.assertEqual(obs, exp)

    def test_ascii_art_three_children(self):
        obs = TreeNode.read(io<font color="#a057a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.StringIO('(a,(b,c,d));')).ascii_art()
        self.assertEqual(obs, exp_ascii_art_three_children)

    def test_accumulate_to_ancestor(self):
        """Get the distance from a node to its ancestor"""
        t = TreeNode.read(io.</b></font>StringIO(
            "((a:0.1,b:0.2)c:0.3,(d:0.4,e)f:0.5)root;"))
        a = t.find('a')
        b = t.find('b')
        exp_to_root = 0.1 + 0.3
        obs_to_root = a.accumulate_to_ancestor(t)
        self.assertEqual(obs_to_root, exp_to_root)

        with self.assertRaises(NoParentError):
            a.accumulate_to_ancestor(b)

<a name="12"></a>    def test_distance_nontip(self):
        # example derived from issue #807, credit @wwood
        tstr = "((A:1.0,B:2.0)'g__genus1':3.0)root;"
        tree = TreeNode<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read(io.StringIO(tstr))
        self.assertEqual(tree.find('A').distance(tree.find('g__genus1')), 1.0)

    def test_distance(self):
<a name="8"></a>        """Get the distance between two nodes"""
        t =</b></font> TreeNode.read(io.StringIO(
            "((a:0.1,b:0.2)c:0.3,(d:0.4,e)f:0.5)root;"))
        tips = sorted([n for n in t.tips()], key=lambda x: x<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.name)

        npt.assert_almost_equal(tips[0].distance(tips[0]), 0.0)
        npt.assert_almost_equal(tips[0].distance(tips[1]), 0.3)
        npt.assert_almost_equal(tips[</b></font>0].distance(tips[2]), 1.3)
<a name="27"></a>        with self.assertRaises(NoLengthError):
            tips[0].distance(tips[3])

        npt.assert_almost_equal(tips<font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[1].distance(tips[0]), 0.3)
        npt.assert_almost_equal(tips[1].distance(tips[1]), 0.0)
        npt.assert_almost_equal(tips[</b></font>1].distance(tips[2]), 1.4)
<a name="41"></a>        with self.assertRaises(NoLengthError):
            tips[1].distance(tips[3])

        self<font color="#f87a17"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(tips[2].distance(tips[0]), 1.3)
        self.assertEqual(tips[2].distance(tips[</b></font>1]), 1.4)
        self.assertEqual(tips[2].distance(tips[2]), 0.0)
        with self.assertRaises(NoLengthError):
            tips[2].distance(tips[3])
<a name="36"></a>
    def test_lowest_common_ancestor(self):
        """TreeNode lowestCommonAncestor should return LCA for set of tips"""
        t1 = TreeNode.read(io<font color="#ff00ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.StringIO("((a,(b,c)d)e,f,(g,h)i)j;"))
        t2 = t1.copy()
        t3 = t1.copy()
        t4 = t1.copy()
<a name="35"></a>        input1 =</b></font> ['a']  # return self
        input2 = ['a', 'b']  # return e
        input3 = ['b', 'c']  # return d
        input4 <font color="#41a317"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= ['a', 'h', 'g']  # return j
        exp1 = t1.find('a')
<a name="38"></a>        exp2 = t2.find('e')
        exp3 = t3.find('d')
        exp4 =</b></font> t4
        obs1 <font color="#348781"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= t1.lowest_common_ancestor(input1)
        obs2 = t2.lowest_common_ancestor(input2)
        obs3 = t3.lowest_common_ancestor(input3)
<a name="9"></a>        obs4 = t4.lowest_common_ancestor(</b></font>input4)
        self.assertEqual(obs1, exp1)
        self.assertEqual(obs2, exp2)
        self<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(obs3, exp3)
        self.assertEqual(obs4, exp4)

        # verify multiple calls work
        t_mul = t1.copy()
        exp_1 = t_mul.find('d')
        exp_2 = t_mul.find('i')
        obs_1 = t_mul.lowest_common_ancestor(</b></font>['b', 'c'])
        obs_2 = t_mul.lowest_common_ancestor(['g', 'h'])
        self.assertEqual(obs_1, exp_1)
        self.assertEqual(obs_2, exp_2)

        # empty case
        with self.assertRaises(ValueError):
            t1.lowest_common_ancestor([])

    def test_get_max_distance(self):
        """get_max_distance should get max tip distance across tree"""
        tree = TreeNode.read(io.StringIO(
            "((a:0.1,b:0.2)c:0.3,(d:0.4,e:0.5)f:0.6)root;"))
        dist, nodes = tree.get_max_distance()
        npt.assert_almost_equal(dist, 1.6)
        self.assertEqual(sorted([n.name for n in nodes]), ['b', 'e'])

    def test_set_max_distance(self):
        """set_max_distance sets MaxDistTips across tree"""
        tree = TreeNode.read(io.StringIO(
            "((a:0.1,b:0.2)c:0.3,(d:0.4,e:0.5)f:0.6)root;"))
        tree._set_max_distance()
        tip_a, tip_b = tree.MaxDistTips
        self.assertEqual(tip_a[0] + tip_b[0], 1.6)
        self.assertEqual(sorted([tip_a[1].name, tip_b[1].name]), ['b', 'e'])

    def test_set_max_distance_tie_bug(self):
        """Corresponds to #1077"""
        s = io.StringIO("((a:1,b:1)c:2,(d:3,e:4)f:5)root;")
        t = TreeNode.read(s)

        exp = ((3.0, t.find('a')), (9.0, t.find('e')))

        # the above tree would trigger an exception in max. The central issue
        # was that the data being passed to max were a tuple of tuple:
        # ((left_d, left_n), (right_d, right_n))
        # the call to max would break in this scenario as it would fall onto
        # idx 1 of each tuple to assess the "max".
        t._set_max_distance()

        self.assertEqual(t.MaxDistTips, exp)

    def test_set_max_distance_inplace_modification_bug(self):
        """Corresponds to #1223"""
<a name="17"></a>        s = io.StringIO("((a:1,b:1)c:2,(d:3,e:4)f:5)root;")
        t = TreeNode.read(s)
<a name="16"></a>
        exp = [((0.0, t.find<font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>('a')), (0.0, t.find('a'))),
               ((0.0, t.find('b')), (0.0, t.find('b'))),
               ((1.0, t.</b></font>find<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>('a')), (1.0, t.find('b'))),
               ((0.0, t.find('d')), (0.0, t.find('d'))),
               ((0.0, t.</b></font>find('e')), (0.0, t.find('e'))),
               ((3.0, t.find('d')), (4.0, t.find('e'))),
               ((3.0, t.find('a')), (9.0, t.find('e')))]

        t._set_max_distance()

        self.assertEqual([n.MaxDistTips for n in t.postorder()], exp)

    def test_shear(self):
        """Shear the nodes"""
        t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
        obs = str(t.shear(['G', 'M']))
        exp = '(G:3.0,M:3.7);\n'
        self.assertEqual(obs, exp)

    def test_compare_tip_distances(self):
        t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
        t2 = TreeNode.read(io.StringIO('(((H:1,G:1,O:1):2,R:3):1,X:4);'))
        obs = t.compare_tip_distances(t2)
        # note: common taxa are H, G, R (only)
        m1 = np.array([[0, 2, 6.5], [2, 0, 6.5], [6.5, 6.5, 0]])
        m2 = np.array([[0, 2, 6], [2, 0, 6], [6, 6, 0]])
        r = pearsonr(m1.flat, m2.flat)[0]
        self.assertAlmostEqual(obs, (1 - r) / 2)

    def test_compare_tip_distances_sample(self):
        t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
        t2 = TreeNode.read(io.StringIO('(((H:1,G:1,O:1):2,R:3):1,X:4);'))
        obs = t.compare_tip_distances(t2, sample=3, shuffle_f=sorted)
        # note: common taxa are H, G, R (only)
        m1 = np.array([[0, 2, 6.5], [2, 0, 6.5], [6.5, 6.5, 0]])
        m2 = np.array([[0, 2, 6], [2, 0, 6], [6, 6, 0]])
        r = pearsonr(m1.flat, m2.flat)[0]
        self.assertAlmostEqual(obs, (1 - r) / 2)
<a name="25"></a>
        # 4 common taxa, still picking H, G, R
        s = '((H:1,G:1):2,(R:0.5,M:0.7,Q:5):3);'
        t = TreeNode<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read(io.StringIO(s))
        s3 = '(((H:1,G:1,O:1):2,R:3,Q:10):1,X:4);'
        t3 = TreeNode.read(io.StringIO(s3))
        obs = t.compare_tip_distances(</b></font>t3, sample=3, shuffle_f=sorted)

    def test_compare_tip_distances_no_common_tips(self):
        t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
        t2 = TreeNode.read(io.StringIO('(((Z:1,Y:1,X:1):2,W:3):1,V:4);'))

        with self.assertRaises(ValueError):
            t.compare_tip_distances(t2)
<a name="11"></a>
    def test_compare_tip_distances_single_common_tip(self):
        t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
        t2 = TreeNode<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read(io.StringIO('(((R:1,Y:1,X:1):2,W:3):1,V:4);'))

        self.assertEqual(t.compare_tip_distances(t2), 1)
        self.assertEqual(t2.compare_tip_distances(t), 1)

    def test_tip_tip_distances_endpoints(self):
        """Test getting specifc tip distances  with tipToTipDistances"""
        t =</b></font> TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
        nodes = [t.find('H'), t.find('G'), t.find('M')]
        names = ['H', 'G', 'M']
        exp = DistanceMatrix(np.array([[0, 2.0, 6.7],
<a name="37"></a>                                       [2.0, 0, 6.7],
                                       [6.7, 6.7, 0.0]]), ['H', 'G', 'M'])

        obs <font color="#810541"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= t.tip_tip_distances(endpoints=names)
        self.assertEqual(obs, exp)

        obs = t.tip_tip_distances(endpoints=nodes)
        self.assertEqual(</b></font>obs, exp)

    def test_tip_tip_distances_non_tip_endpoints(self):
        t = TreeNode.read(io.StringIO('((H:1,G:1)foo:2,(R:0.5,M:0.7):3);'))
        with self.assertRaises(ValueError):
            t.tip_tip_distances(endpoints=['foo'])

    def test_tip_tip_distances_no_length(self):
        t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f);"))
        exp_t = TreeNode.read(io.StringIO("((a:0,b:0)c:0,(d:0,e:0)f:0);"))
        exp_t_dm = exp_t.tip_tip_distances()

        t_dm = npt.assert_warns(RepresentationWarning, t.tip_tip_distances)
        self.assertEqual(t_dm, exp_t_dm)

        for node in t.preorder():
            self.assertIs(node.length, None)

    def test_tip_tip_distances_missing_length(self):
        t = TreeNode.read(io.StringIO("((a,b:6)c:4,(d,e:0)f);"))
        exp_t = TreeNode.read(io.StringIO("((a:0,b:6)c:4,(d:0,e:0)f:0);"))
        exp_t_dm = exp_t.tip_tip_distances()

        t_dm = npt.assert_warns(RepresentationWarning, t.tip_tip_distances)
        self.assertEqual(t_dm, exp_t_dm)

    def test_neighbors(self):
        """Get neighbors of a node"""
        t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f);"))
        exp = t.children
        obs = t.neighbors()
        self.assertEqual(obs, exp)

        exp = t.children[0].children + [t]
        obs = t.children[0].neighbors()
        self.assertEqual(obs, exp)

        exp = [t.children[0].children[0]] + [t]
        obs = t.children[0].neighbors(ignore=t.children[0].children[1])
        self.assertEqual(obs, exp)

        exp = [t.children[0]]
        obs = t.children[0].children[0].neighbors()
        self.assertEqual(obs, exp)
<a name="23"></a>
    def test_has_children(self):
        """Test if has children"""
        t = TreeNode.read(io<font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.StringIO("((a,b)c,(d,e)f);"))
        self.assertTrue(t.has_children())
        self.assertTrue(t.children[0].has_children())
        self.</b></font>assertTrue(t.children[1].has_children())
        self.assertFalse(t.children[0].children[0].has_children())
        self.assertFalse(t.children[0].children[1].has_children())
        self.assertFalse(t.children[1].children[0].has_children())
        self.assertFalse(t.children[1].children[1].has_children())

    def test_tips(self):
        """Tip traversal of tree"""
        exp = ['a', 'b', 'c', 'd']
        obs = [n.name for n in self.simple_t.tips()]
        self.assertEqual(obs, exp)
        obs2 = [n.name for n in self.simple_t.traverse(False, False)]
        self.assertEqual(obs2, exp)

    def test_tips_self(self):
        """ See issue #1509 """
        tree = TreeNode.read(['(c, (b,a)x)y;'])
        ts = list(tree.find('c').tips(include_self=True))
        self.assertEqual(len(ts), 1)
        t = ts[0]
        self.assertEqual(t.name, 'c')
        self.assertTrue(t.is_tip())

    def test_pre_and_postorder(self):
        """Pre and post order traversal of the tree"""
        exp = ['root', 'i1', 'a', 'b', 'i1', 'i2', 'c', 'd', 'i2', 'root']
        obs = [n.name for n in self.simple_t.pre_and_postorder()]
        self.assertEqual(obs, exp)
        obs2 = [n.name for n in self.simple_t.traverse(True, True)]
        self.assertEqual(obs2, exp)

    def test_pre_and_postorder_no_children(self):
        t = TreeNode('brofist')

        # include self
        exp = ['brofist']
        obs = [n.name for n in t.pre_and_postorder()]
        self.assertEqual(obs, exp)

        # do not include self
        obs = list(t.pre_and_postorder(include_self=False))
        self.assertEqual(obs, [])
<a name="42"></a>
    def test_levelorder(self):
        """Test level order traversal of the tree"""
        exp <font color="#c57717"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= ['root', 'i1', 'i2', 'a', 'b', 'c', 'd']
        obs = [n.name for n in self.simple_t.levelorder()]
        self.assertEqual(obs, exp)

    def test_bifurcate(self):
        t1 =</b></font> TreeNode.read(io.StringIO('(((a,b),c),(d,e));'))
        t2 = TreeNode.read(io.StringIO('((a,b,c));'))
        t3 = t2.copy()

        t1.bifurcate()
        t2.bifurcate()
        t3.bifurcate(insert_length=0)

        self.assertEqual(str(t1), '(((a,b),c),(d,e));\n')
        self.assertEqual(str(t2), '((c,(a,b)));\n')
        self.assertEqual(str(t3), '((c,(a,b):0));\n')
<a name="19"></a>
    def test_bifurcate_with_subclass(self):
        tree = TreeNodeSubclass()
        tree<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(TreeNodeSubclass())
        tree.append(TreeNodeSubclass())
        tree.append(TreeNodeSubclass())
        tree.append(TreeNodeSubclass())

        tree.bifurcate(</b></font>)

        for node in tree.traverse():
            self.assertIs(type(node), TreeNodeSubclass)

    def test_index_tree_single_node(self):
        """index_tree handles single node tree"""
        t1 = TreeNode.read(io.StringIO('root;'))
        id_index, child_index = t1.index_tree()
        self.assertEqual(id_index[0], t1)
        npt.assert_equal(child_index, np.array([[]]))

    def test_index_tree(self):
        """index_tree should produce correct index and node map"""
        # test for first tree: contains singleton outgroup
        t1 = TreeNode.read(io.StringIO('(((a,b),c),(d,e));'))
        t2 = TreeNode.read(io.StringIO('(((a,b),(c,d)),(e,f));'))
        t3 = TreeNode.read(io.StringIO('(((a,b,c),(d)),(e,f));'))

        id_1, child_1 = t1.index_tree()
        nodes_1 = [n.id for n in t1.traverse(self_before=False,
                   self_after=True)]
        self.assertEqual(nodes_1, [0, 1, 2, 3, 6, 4, 5, 7, 8])
        npt.assert_equal(child_1, np.array([[2, 0, 1], [6, 2, 3], [7, 4, 5],
                                            [8, 6, 7]]))

        # test for second tree: strictly bifurcating
        id_2, child_2 = t2.index_tree()
        nodes_2 = [n.id for n in t2.traverse(self_before=False,
                   self_after=True)]
        self.assertEqual(nodes_2, [0, 1, 4, 2, 3, 5, 8, 6, 7, 9, 10])
        npt.assert_equal(child_2, np.array([[4, 0, 1], [5, 2, 3],
                                            [8, 4, 5], [9, 6, 7],
                                            [10, 8, 9]]))

        # test for third tree: contains trifurcation and single-child parent
        id_3, child_3 = t3.index_tree()
        nodes_3 = [n.id for n in t3.traverse(self_before=False,
                   self_after=True)]
        self.assertEqual(nodes_3, [0, 1, 2, 4, 3, 5, 8, 6, 7, 9, 10])
        npt.assert_equal(child_3, np.array([[4, 0, 2], [5, 3, 3], [8, 4, 5],
                                            [9, 6, 7], [10, 8, 9]]))

    def test_root_at(self):
        """Form a new root"""
        t = TreeNode.read(io.StringIO("(((a,b)c,(d,e)f)g,h)i;"))
        with self.assertRaises(TreeError):
            t.root_at(t.find('h'))

        exp = "(a,b,((d,e)f,(h)g)c)root;\n"
        rooted = t.root_at('c')
        obs = str(rooted)
        self.assertEqual(obs, exp)

    def test_root_at_midpoint(self):
        """Root at the midpoint"""
        tree1 = self.TreeRoot
<a name="13"></a>        for n in tree1.traverse():
            n.length = 1

        result = tree1<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.root_at_midpoint()
        self.assertEqual(result.distance(result.find('e')), 1.5)
        self.assertEqual(result.distance(result.find('g')), 2.5)
        exp_dist =</b></font> tree1.tip_tip_distances()
        obs_dist = result.tip_tip_distances()
        self.assertEqual(obs_dist, exp_dist)

    def test_root_at_midpoint_no_lengths(self):
        # should get same tree back (a copy)
        nwk = '(a,b)c;\n'
        t = TreeNode.read(io.StringIO(nwk))
        obs = t.root_at_midpoint()
        self.assertEqual(str(obs), nwk)
<a name="24"></a>
    def test_root_at_midpoint_tie(self):
        nwk = "(((a:1,b:1)c:2,(d:3,e:4)f:5),g:1)root;"
        t = TreeNode<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read(io.StringIO(nwk))
        exp = "((d:3,e:4)f:2,((a:1,b:1)c:2,(g:1)):3)root;"
        texp = TreeNode.read(io.StringIO(exp))
<a name="22"></a>
        obs = t.root_at_midpoint(</b></font>)

        for o, e in zip<font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(obs.traverse(), texp.traverse()):
            self.assertEqual(o.name, e.name)
            self.assertEqual(o.length, e.</b></font>length)
<a name="5"></a>
    def test_compare_subsets(self):
        """compare_subsets should return the fraction of shared subsets"""
        t = TreeNode.read<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(io.StringIO('((H,G),(R,M));'))
        t2 = TreeNode.read(io.StringIO('(((H,G),R),M);'))
        t4 = TreeNode.read(io.StringIO('(((H,G),(O,R)),X);'))

        result = t.compare_subsets(t)
        self.assertEqual(result, 0)

        result =</b></font> t2.compare_subsets(t2)
        self.assertEqual(result, 0)

        result = t.compare_subsets(t2)
        self.assertEqual(result, 0.5)

<a name="33"></a>        result = t.compare_subsets(t4)
        self.assertEqual(result, 1 - 2. / 5)

        result = t<font color="#736aff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.compare_subsets(t4, exclude_absent_taxa=True)
        self.assertEqual(result, 1 - 2. / 3)

        result = t.compare_subsets(self.TreeRoot, exclude_absent_taxa=True)
        self.assertEqual(</b></font>result, 1)

        result = t.compare_subsets(self.TreeRoot)
        self.assertEqual(result, 1)

    def test_compare_rfd(self):
        """compare_rfd should return the Robinson Foulds distance"""
        t = TreeNode.read(io.StringIO('((H,G),(R,M));'))
        t2 = TreeNode.read(io.StringIO('(((H,G),R),M);'))
        t4 = TreeNode.read(io.StringIO('(((H,G),(O,R)),X);'))

        obs = t.compare_rfd(t2)
        exp = 2.0
        self.assertEqual(obs, exp)

<a name="39"></a>        self.assertEqual(t.compare_rfd(t2), t2.compare_rfd(t))

        obs = t.compare_rfd(t2, proportion=True)
        exp <font color="#152dc6"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= 0.5
        self.assertEqual(obs, exp)

        with self.assertRaises(ValueError):
            t.compare_rfd(t4)

    def test_assign_ids(self):
        """Assign IDs to the tree"""
<a name="26"></a>        t1 =</b></font> TreeNode.read(io.StringIO("(((a,b),c),(e,f),(g));"))
        t2 = TreeNode.read(io.StringIO("(((a,b),c),(e,f),(g));"))
        t3 = TreeNode.read(io.StringIO("((g),(e,f),(c,(a,b)));"))
        t1_copy = t1<font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.copy()

        t1.assign_ids()
        t2.assign_ids()
        t3.assign_ids()
        t1_copy.assign_ids()

        self.assertEqual([(</b></font>n.name, n.id) for n in t1.traverse()],
                         [(n.name, n.id) for n in t2.traverse()])
        self.assertEqual([(n.name, n.id) for n in t1.traverse()],
                         [(n.name, n.id) for n in t1_copy.traverse()])
        self.assertNotEqual([(n.name, n.id) for n in t1.traverse()],
                            [(n.name, n.id) for n in t3.traverse()])

    def test_assign_ids_index_tree(self):
        """assign_ids and index_tree should assign the same IDs"""
        t1 = TreeNode.read(io.StringIO('(((a,b),c),(d,e));'))
        t2 = TreeNode.read(io.StringIO('(((a,b),(c,d)),(e,f));'))
<a name="6"></a>        t3 = TreeNode.read(io.StringIO('(((a,b,c),(d)),(e,f));'))
        t1_copy = t1.copy()
        t2_copy = t2.copy()
        t3_copy = t3<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.copy()

        t1.assign_ids()
        t1_copy.index_tree()
        t2.assign_ids()
        t2_copy.index_tree()
        t3.assign_ids()
        t3_copy.index_tree()

        self.assertEqual([n.</b></font>id for n in t1.traverse()],
                         [n.id for n in t1_copy.traverse()])
        self.assertEqual([n.id for n in t2.traverse()],
                         [n.id for n in t2_copy.traverse()])
        self.assertEqual([n.id for n in t3.traverse()],
                         [n.id for n in t3_copy.traverse()])

    def test_unrooted_deepcopy(self):
        """Do an unrooted_copy"""
        t = TreeNode.read(io.StringIO("((a,(b,c)d)e,(f,g)h)i;"))
        exp = "(b,c,(a,((f,g)h)e)d)root;\n"
        obs = t.find('d').unrooted_deepcopy()
        self.assertEqual(str(obs), exp)

        t_ids = {id(n) for n in t.traverse()}
        obs_ids = {id(n) for n in obs.traverse()}

        self.assertEqual(t_ids.intersection(obs_ids), set())

    def test_descending_branch_length(self):
        """Calculate descending branch_length"""
        tr = TreeNode.read(io.StringIO(
            "(((A:.1,B:1.2)C:.6,(D:.9,E:.6)F:.9)G:2.4,(H:.4,I:.5)J:1.3)K;"))
        tdbl = tr.descending_branch_length()
        sdbl = tr.descending_branch_length(['A', 'E'])
        npt.assert_almost_equal(tdbl, 8.9)
        npt.assert_almost_equal(sdbl, 2.2)
        self.assertRaises(ValueError, tr.descending_branch_length,
<a name="4"></a>                          ['A', 'DNE'])
        self.assertRaises(ValueError, tr.descending_branch_length, ['A', 'C'])

        tr = TreeNode.read<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(io.StringIO(
            "(((A,B:1.2)C:.6,(D:.9,E:.6)F:.9)G:2.4,(H:.4,I:.5)J:1.3)K;"))
        tdbl = tr.descending_branch_length()
        npt.assert_almost_equal(tdbl, 8.8)

        tr = TreeNode.read(io.StringIO(
            "(((A,B:1.2)C:.6,(D:.9,E:.6)F)G:2.4,(H:.4,I:.5)J:1.3)K;"))
        tdbl = tr.descending_branch_length()
        npt.assert_almost_equal(tdbl, 7.9)

        tr =</b></font> TreeNode.read(io.StringIO(
            "(((A,B:1.2)C:.6,(D:.9,E:.6)F)G:2.4,(H:.4,I:.5)J:1.3)K;"))
        tdbl = tr.descending_branch_length(['A', 'D', 'E'])
        npt.assert_almost_equal(tdbl, 2.1)

        tr = TreeNode.read(io.StringIO(
            "(((A,B:1.2)C:.6,(D:.9,E:.6)F:.9)G:2.4,(H:.4,I:.5)J:1.3)K;"))
        tdbl = tr.descending_branch_length(['I', 'D', 'E'])
        npt.assert_almost_equal(tdbl, 6.6)

        # test with a situation where we have unnamed internal nodes
        tr = TreeNode.read(io.StringIO(
            "(((A,B:1.2):.6,(D:.9,E:.6)F):2.4,(H:.4,I:.5)J:1.3);"))
        tdbl = tr.descending_branch_length()
        npt.assert_almost_equal(tdbl, 7.9)

    def test_to_array(self):
        """Convert a tree to arrays"""
        t = TreeNode.read(io.StringIO(
            '(((a:1,b:2,c:3)x:4,(d:5)y:6)z:7,(e:8,f:9)z:10);'))
        id_index, child_index = t.index_tree()
        arrayed = t.to_array()

        self.assertEqual(id_index, arrayed['id_index'])
        npt.assert_equal(child_index, arrayed['child_index'])

        exp = np.array([1, 2, 3, 5, 4, 6, 8, 9, 7, 10, np.nan])
        obs = arrayed['length']
        npt.assert_equal(obs, exp)

        exp = np.array(['a', 'b', 'c', 'd', 'x',
                        'y', 'e', 'f', 'z', 'z', None])
        obs = arrayed['name']
        npt.assert_equal(obs, exp)

        exp = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
        obs = arrayed['id']
        npt.assert_equal(obs, exp)

    def test_to_array_attrs(self):
        t = TreeNode.read(io.StringIO(
            '(((a:1,b:2,c:3)x:4,(d:5)y:6)z:7,(e:8,f:9)z:10);'))
        id_index, child_index = t.index_tree()
        arrayed = t.to_array(attrs=[('name', object)])

        # should only have id_index, child_index, and name since we specified
        # attrs
        self.assertEqual(len(arrayed), 3)

        self.assertEqual(id_index, arrayed['id_index'])
        npt.assert_equal(child_index, arrayed['child_index'])

        exp = np.array(['a', 'b', 'c', 'd', 'x',
                        'y', 'e', 'f', 'z', 'z', None])
        obs = arrayed['name']
        npt.assert_equal(obs, exp)

        # invalid attrs
        with self.assertRaises(AttributeError):
            t.to_array(attrs=[('name', object), ('brofist', int)])

    def test_to_array_nan_length_value(self):
        t = TreeNode.read(io.StringIO("((a:1, b:2)c:3)root;"))
        indexed = t.to_array(nan_length_value=None)
        npt.assert_equal(indexed['length'],
                         np.array([1, 2, 3, np.nan], dtype=float))
        indexed = t.to_array(nan_length_value=0.0)
        npt.assert_equal(indexed['length'],
                         np.array([1, 2, 3, 0.0], dtype=float))
        indexed = t.to_array(nan_length_value=42.0)
        npt.assert_equal(indexed['length'],
                         np.array([1, 2, 3, 42.0], dtype=float))

        t = TreeNode.read(io.StringIO("((a:1, b:2)c:3)root:4;"))
        indexed = t.to_array(nan_length_value=42.0)
        npt.assert_equal(indexed['length'],
                         np.array([1, 2, 3, 4], dtype=float))

        t = TreeNode.read(io.StringIO("((a:1, b:2)c)root;"))
        indexed = t.to_array(nan_length_value=42.0)
        npt.assert_equal(indexed['length'],
                         np.array([1, 2, 42.0, 42.0], dtype=float))

    def test_from_taxonomy(self):
        input_lineages = {'1': ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
                          '2': ['a', 'b', 'c', None, None, 'x', 'y'],
                          '3': ['h', 'i', 'j', 'k', 'l', 'm', 'n'],
                          '4': ['h', 'i', 'j', 'k', 'l', 'm', 'q'],
                          '5': ['h', 'i', 'j', 'k', 'l', 'm', 'n']}
        exp = TreeNode.read(io.StringIO(
            "((((((((1)g)f)e)d,((((2)y)x)))c)b)a,"
            "(((((((3,5)n,(4)q)m)l)k)j)i)h);"))

        root = TreeNode.from_taxonomy(input_lineages.items())

        self.assertIs(type(root), TreeNode)

        self.assertEqual(root.compare_subsets(exp), 0.0)

        root = TreeNodeSubclass.from_taxonomy(input_lineages.items())

        self.assertIs(type(root), TreeNodeSubclass)

    def test_to_taxonomy(self):
        input_lineages = {'1': ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
                          '2': ['a', 'b', 'c', None, None, 'x', 'y'],
                          '3': ['h', 'i', 'j', 'k', 'l', 'm', 'n'],
                          '4': ['h', 'i', 'j', 'k', 'l', 'm', 'q'],
                          '5': ['h', 'i', 'j', 'k', 'l', 'm', 'n']}
        tree = TreeNode.from_taxonomy(input_lineages.items())
        exp = sorted(input_lineages.items())
        obs = [(n.name, lin) for n, lin in tree.to_taxonomy(allow_empty=True)]
        self.assertEqual(sorted(obs), exp)

    def test_to_taxonomy_filter(self):
        input_lineages = {'1': ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
                          '2': ['a', 'b', 'c', None, None, 'x', 'y'],
                          '3': ['h', 'i', 'j', 'k', 'l'],  # test jagged
                          '4': ['h', 'i', 'j', 'k', 'l', 'm', 'q'],
                          '5': ['h', 'i', 'j', 'k', 'l', 'm', 'n']}
        tree = TreeNode.from_taxonomy(input_lineages.items())

        def f(node, lin):
            return 'k' in lin or 'x' in lin

        exp = [('2', ['a', 'b', 'c', 'x', 'y']),
               ('3', ['h', 'i', 'j', 'k', 'l']),
               ('4', ['h', 'i', 'j', 'k', 'l', 'm', 'q']),
               ('5', ['h', 'i', 'j', 'k', 'l', 'm', 'n'])]
        obs = [(n.name, lin) for n, lin in tree.to_taxonomy(filter_f=f)]
        self.assertEqual(sorted(obs), exp)

    def test_linkage_matrix(self):
        # Ensure matches: http://www.southampton.ac.uk/~re1u06/teaching/upgma/
        id_list = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
        linkage = np.asarray([[1.0,  5.0,  1.0,  2.0],
                              [0.0,  3.0,  8.0,  2.0],
<a name="40"></a>                              [6.0,  7.0, 12.5,  3.0],
                              [8.0,  9.0, 16.5,  5.0],
                              [2.0, 10.0, 29.0,  6.0],
                              [<font color="#347235"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>4.0, 11.0, 34.0,  7.0]])

        tree = TreeNode.from_linkage_matrix(linkage, id_list)

        self.assertIs(type(tree), TreeNode)

        self.assertEqual("(E:17.0,(C:14.5,((A:4.0,D:4.0):4.25,(G:6.25,(B:0.5,"
                         "F:0.5):5.75):2.0):6.25):2.5);\n",
                         str(tree))

        tree = TreeNodeSubclass.</b></font>from_linkage_matrix(linkage, id_list)

        self.assertIs(type(tree), TreeNodeSubclass)

    def test_shuffle_invalid_iter(self):
        shuffler = self.simple_t.shuffle(n=-1)
        with self.assertRaises(ValueError):
            next(shuffler)

    def test_shuffle_n_2(self):
        exp = ["((a,b)i1,(d,c)i2)root;\n",
               "((a,b)i1,(c,d)i2)root;\n",
               "((a,b)i1,(d,c)i2)root;\n",
               "((a,b)i1,(c,d)i2)root;\n",
               "((a,b)i1,(d,c)i2)root;\n"]

        obs_g = self.simple_t.shuffle(k=2, shuffle_f=self.rev_f, n=np.inf)
        obs = [str(next(obs_g)) for i in range(5)]
        self.assertEqual(obs, exp)

    def test_shuffle_n_none(self):
        exp = ["((d,c)i1,(b,a)i2)root;\n",
               "((a,b)i1,(c,d)i2)root;\n",
               "((d,c)i1,(b,a)i2)root;\n",
               "((a,b)i1,(c,d)i2)root;\n"]
        obs_g = self.simple_t.shuffle(shuffle_f=self.rev_f, n=4)
        obs = [str(next(obs_g)) for i in range(4)]
        self.assertEqual(obs, exp)

    def test_shuffle_complex(self):
        exp = ["(((a,b)int1,(x,y,(w,z)int2,(f,e)int3)int4),(d,c)int5);\n",
               "(((a,b)int1,(x,y,(w,z)int2,(c,d)int3)int4),(e,f)int5);\n",
               "(((a,b)int1,(x,y,(w,z)int2,(f,e)int3)int4),(d,c)int5);\n",
               "(((a,b)int1,(x,y,(w,z)int2,(c,d)int3)int4),(e,f)int5);\n"]

        obs_g = self.complex_tree.shuffle(shuffle_f=self.rev_f,
                                          names=['c', 'd', 'e', 'f'], n=4)
        obs = [str(next(obs_g)) for i in range(4)]
        self.assertEqual(obs, exp)

    def test_shuffle_names(self):
        exp = ["((c,a)i1,(b,d)i2)root;\n",
               "((b,c)i1,(a,d)i2)root;\n",
               "((a,b)i1,(c,d)i2)root;\n",
               "((c,a)i1,(b,d)i2)root;\n"]

        obs_g = self.simple_t.shuffle(names=['a', 'b', 'c'],
                                      shuffle_f=self.rotate_f, n=np.inf)
        obs = [str(next(obs_g)) for i in range(4)]
        self.assertEqual(obs, exp)

    def test_shuffle_raises(self):
        with self.assertRaises(ValueError):
            next(self.simple_t.shuffle(k=1))

        with self.assertRaises(ValueError):
            next(self.simple_t.shuffle(k=5, names=['a', 'b']))

        with self.assertRaises(MissingNodeError):
            next(self.simple_t.shuffle(names=['x', 'y']))

    def test_assign_supports(self):
<a name="14"></a>        """Extract support values of internal nodes."""
        # test nodes with support values alone as labels
        tree = TreeNode.read(['((a,b)75,(c,d)90);'])
        tree.assign_supports<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>()
        node1, node2 = tree.children
        # check if internal nodes are assigned correct support values
        self.assertEqual(node1.support, 75)
        self.assertEqual(node2.support, 90)
        # check if original node names are cleared
        self.assertIsNone(node1.name)
        self.assertIsNone(node2.</b></font>name)
        # check if support values are not assigned to root and tips
        self.assertIsNone(tree.support)
        for taxon in ('a', 'b', 'c', 'd'):
            self.assertIsNone(tree.find(taxon).support)

        # test nodes with support values and branch lengths
        tree = TreeNode.read(['((a,b)0.85:1.23,(c,d)0.95:4.56);'])
        tree.assign_supports()
        node1, node2 = tree.children
        self.assertEqual(node1.support, 0.85)
        self.assertEqual(node2.support, 0.95)

        # test whether integer or float support values can be correctly parsed
        tree = TreeNode.read(['((a,b)75,(c,d)80.0,(e,f)97.5,(g,h)0.95);'])
        tree.assign_supports()
        node1, node2, node3, node4 = tree.children
        self.assertTrue(isinstance(node1.support, int))
        self.assertEqual(node1.support, 75)
        self.assertTrue(isinstance(node2.support, float))
        self.assertEqual(node2.support, 80.0)
        self.assertTrue(isinstance(node3.support, float))
        self.assertEqual(node3.support, 97.5)
        self.assertTrue(isinstance(node4.support, float))
        self.assertEqual(node4.support, 0.95)

        # test support values that are negative or scientific notation (not a
        # common scenario but can happen)
        tree = TreeNode.read(['((a,b)-1.23,(c,d)1.23e-4);'])
        tree.assign_supports()
        node1, node2 = tree.children
        self.assertEqual(node1.support, -1.23)
<a name="20"></a>        self.assertEqual(node2.support, 0.000123)

        # test nodes with support and extra label
        tree = TreeNode.read([<font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>'((a,b)\'80:X\',(c,d)\'60:Y\');'])
        tree.assign_supports()
        node1, node2 = tree.children
        self.assertEqual(node1.support, 80)
        self.assertEqual(node1.name, 'X')
        self.assertEqual(node2.</b></font>support, 60)
        self.assertEqual(node2.name, 'Y')

        # test nodes without label, with non-numeric label, and with branch
        # length only
        tree = TreeNode.read(['((a,b),(c,d)x,(e,f):1.0);'])
        tree.assign_supports()
        for node in tree.children:
            self.assertIsNone(node.support)

    def test_unpack(self):
        """Unpack an internal node."""
        # test unpacking a node without branch length
        tree = TreeNode.read(['((c,d)a,(e,f)b);'])
        tree.find('b').unpack()
        exp = '((c,d)a,e,f);\n'
        self.assertEqual(str(tree), exp)

        # test unpacking a node with branch length
        tree = TreeNode.read(['((c:2.0,d:3.0)a:1.0,(e:2.0,f:1.0)b:2.0);'])
        tree.find('b').unpack()
        exp = '((c:2.0,d:3.0)a:1.0,e:4.0,f:3.0);'
        self.assertEqual(str(tree).rstrip(), exp)

        # test attempting to unpack root
        tree = TreeNode.read(['((d,e)b,(f,g)c)a;'])
        msg = 'Cannot unpack root.'
        with self.assertRaisesRegex(TreeError, msg):
            tree.find('a').unpack()

        # test attempting to unpack tip
        msg = 'Cannot unpack tip.'
        with self.assertRaisesRegex(TreeError, msg):
            tree.find('d').unpack()

    def test_unpack_by_func(self):
        """Unpack internal nodes of a tree by a function."""
        # unpack internal nodes with branch length &lt;= 1.0
        def func(x):
            return x.length &lt;= 1.0

        # will unpack node 'a', but not tip 'e'
        # will add the branch length of 'a' to its child nodes 'c' and 'd'
        tree = TreeNode.read(['((c:2,d:3)a:1,(e:1,f:2)b:2);'])
        tree.unpack_by_func(func)
        exp = '((e:1.0,f:2.0)b:2.0,c:3.0,d:4.0);'
        self.assertEqual(str(tree).rstrip(), exp)

        # unpack internal nodes with branch length &lt; 2.01
        # will unpack both 'a' and 'b'
        tree = TreeNode.read(['((c:2,d:3)a:1,(e:1,f:2)b:2);'])
        tree.unpack_by_func(lambda x: x.length &lt;= 2.0)
        exp = '(c:3.0,d:4.0,e:3.0,f:4.0);'
        self.assertEqual(str(tree).rstrip(), exp)

        # unpack two nested nodes 'a' and 'c' simultaneously
        tree = TreeNode.read(['(((e:3,f:2)c:1,d:3)a:1,b:4);'])
        tree.unpack_by_func(lambda x: x.length &lt;= 2.0)
        exp = '(b:4.0,d:4.0,e:5.0,f:4.0);'
        self.assertEqual(str(tree).rstrip(), exp)

        # test a complicated scenario (unpacking nodes 'g', 'h' and 'm')
        def func(x):
            return x.length &lt; 2.0
        tree = TreeNode.read(['(((a:1.04,b:2.32,c:1.44)d:3.20,'
                              '(e:3.91,f:2.47)g:1.21)h:1.75,'
                              '(i:4.14,(j:2.06,k:1.58)l:3.32)m:0.77);'])
        tree.unpack_by_func(func)
        exp = ('((a:1.04,b:2.32,c:1.44)d:4.95,e:6.87,f:5.43,i:4.91,'
               '(j:2.06,k:1.58)l:4.09);')
        self.assertEqual(str(tree).rstrip(), exp)

        # unpack nodes with support &lt; 75
        def func(x):
            return x.support &lt; 75
        tree = TreeNode.read(['(((a,b)85,(c,d)78)75,(e,(f,g)64)80);'])
        tree.assign_supports()
        tree.unpack_by_func(func)
        exp = '(((a,b)85,(c,d)78)75,(e,f,g)80);'
        self.assertEqual(str(tree).rstrip(), exp)

        # unpack nodes with support &lt; 85
        tree = TreeNode.read(['(((a,b)85,(c,d)78)75,(e,(f,g)64)80);'])
        tree.assign_supports()
        tree.unpack_by_func(lambda x: x.support &lt; 85)
        exp = '((a,b)85,c,d,e,f,g);'
        self.assertEqual(str(tree).rstrip(), exp)

        # unpack nodes with support &lt; 0.95
        tree = TreeNode.read(['(((a,b)0.97,(c,d)0.98)1.0,(e,(f,g)0.88)0.96);'])
        tree.assign_supports()
        tree.unpack_by_func(lambda x: x.support &lt; 0.95)
        exp = '(((a,b)0.97,(c,d)0.98)1.0,(e,f,g)0.96);'
        self.assertEqual(str(tree).rstrip(), exp)

        # test a case where there are branch lengths, none support values and
        # node labels
        tree = TreeNode.read(['(((a:1.02,b:0.33)85:0.12,(c:0.86,d:2.23)'
                              '70:3.02)75:0.95,(e:1.43,(f:1.69,g:1.92)64:0.20)'
                              'node:0.35)root;'])
        tree.assign_supports()
        tree.unpack_by_func(lambda x: x.support is not None and x.support &lt; 75)
        exp = ('(((a:1.02,b:0.33)85:0.12,c:3.88,d:5.25)75:0.95,'
               '(e:1.43,f:1.89,g:2.12)node:0.35)root;')
        self.assertEqual(str(tree).rstrip(), exp)


sample = """
(
(
xyz:0.28124,
(
def:0.24498,
mno:0.03627)
:0.17710)
:0.04870,

abc:0.05925,
(
ghi:0.06914,
jkl:0.13776)
:0.09853);
"""

node_data_sample = """
(
(
xyz:0.28124,
(
def:0.24498,
mno:0.03627)
'A':0.17710)
B:0.04870,

abc:0.05925,
(
ghi:0.06914,
jkl:0.13776)
C:0.09853);
"""

minimal = "();"
no_names = "((,),(,));"
missing_tip_name = "((a,b),(c,));"

empty = '();'
single = '(abc:3);'
double = '(abc:3, def:4);'
onenest = '(abc:3, (def:4, ghi:5):6 );'
nodedata = '(abc:3, (def:4, ghi:5)jkl:6 );'

exp_ascii_art_three_children = r"""          /-a
         |
---------|          /-b
         |         |
          \--------|--c
                   |
                    \-d"""


if __name__ == '__main__':
    main()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
