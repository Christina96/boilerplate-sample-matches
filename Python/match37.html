<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_sequence.py &amp; test_tree.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_sequence.py &amp; test_tree.py
      </h3>
<h1 align="center">
        15.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_sequence.py (13.162808%)<th>test_tree.py (19.304491%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(2091-2097)<td><a href="#" name="0">(209-214)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(2047-2053)<td><a href="#" name="1">(383-386)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(2098-2102)<td><a href="#" name="2">(215-218)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(2054-2058)<td><a href="#" name="3">(191-194)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1380-1384)<td><a href="#" name="4">(1113-1123)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1345-1349)<td><a href="#" name="5">(1003-1010)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(1100-1106)<td><a href="#" name="6">(1073-1082)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(2065-2069)<td><a href="#" name="7">(218-221)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(802-807)<td><a href="#" name="8">(629-633)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(174-179)<td><a href="#" name="9">(669-676)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1825-1827)<td><a href="#" name="10">(198-201)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1371-1376)<td><a href="#" name="11">(778-785)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(1336-1341)<td><a href="#" name="12">(622-627)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(1080-1086)<td><a href="#" name="13">(975-978)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(821-826)<td><a href="#" name="14">(1338-1345)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(208-211)<td><a href="#" name="15">(447-451)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(2115-2122)<td><a href="#" name="16">(725-727)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(2071-2078)<td><a href="#" name="17">(723-725)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(1265-1277)<td><a href="#" name="18">(407-412)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(1010-1015)<td><a href="#" name="19">(910-915)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(773-777)<td><a href="#" name="20">(1380-1385)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(411-422)<td><a href="#" name="21">(251-257)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(2085-2090)<td><a href="#" name="22">(997-999)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(2041-2046)<td><a href="#" name="23">(843-846)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(1662-1669)<td><a href="#" name="24">(991-995)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(1620-1627)<td><a href="#" name="25">(764-767)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(1087-1090)<td><a href="#" name="26">(1052-1059)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(811-816)<td><a href="#" name="27">(637-639)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(740-743)<td><a href="#" name="28">(262-266)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(530-535)<td><a href="#" name="29">(277-280)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(304-307)<td><a href="#" name="30">(303-306)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3ea99f"><font color="#3ea99f">-</font><td><a href="#" name="31">(280-282)<td><a href="#" name="31">(33-36)</a><td align="center"><font color="#9d0000">13</font>
<tr onclick='openModal("#5b8daf")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5b8daf"><font color="#5b8daf">-</font><td><a href="#" name="32">(2109-2112)<td><a href="#" name="32">(269-272)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#736aff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#736aff"><font color="#736aff">-</font><td><a href="#" name="33">(1930-1935)<td><a href="#" name="33">(1019-1023)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#827d6b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#827d6b"><font color="#827d6b">-</font><td><a href="#" name="34">(1841-1848)<td><a href="#" name="34">(162-167)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#41a317")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#41a317"><font color="#41a317">-</font><td><a href="#" name="35">(1800-1807)<td><a href="#" name="35">(658-662)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#ff00ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ff00ff"><font color="#ff00ff">-</font><td><a href="#" name="36">(1672-1676)<td><a href="#" name="36">(651-655)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#810541")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#810541"><font color="#810541">-</font><td><a href="#" name="37">(1592-1596)<td><a href="#" name="37">(792-796)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#348781")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#348781"><font color="#348781">-</font><td><a href="#" name="38">(1587-1592)<td><a href="#" name="38">(663-666)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#152dc6")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#152dc6"><font color="#152dc6">-</font><td><a href="#" name="39">(1238-1243)<td><a href="#" name="39">(1041-1049)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#347235")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#347235"><font color="#347235">-</font><td><a href="#" name="40">(992-997)<td><a href="#" name="40">(1263-1273)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#f87a17")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f87a17"><font color="#f87a17">-</font><td><a href="#" name="41">(831-834)<td><a href="#" name="41">(643-644)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#c57717")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c57717"><font color="#c57717">-</font><td><a href="#" name="42">(602-612)<td><a href="#" name="42">(891-896)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#c22817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c22817"><font color="#c22817">-</font><td><a href="#" name="43">(515-519)<td><a href="#" name="43">(424-428)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#a057a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#a057a5"><font color="#a057a5">-</font><td><a href="#" name="44">(391-396)<td><a href="#" name="44">(603-608)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#549748")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#549748"><font color="#549748">-</font><td><a href="#" name="45">(327-329)<td><a href="#" name="45">(37-40)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#668b8b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#668b8b"><font color="#668b8b">-</font><td><a href="#" name="46">(262-269)<td><a href="#" name="46">(201-205)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#d16587")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#d16587"><font color="#d16587">-</font><td><a href="#" name="47">(145-150)<td><a href="#" name="47">(420-423)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#c57726")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c57726"><font color="#c57726">-</font><td><a href="#" name="48">(129-134)<td><a href="#" name="48">(413-417)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#8e35ef")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8e35ef"><font color="#8e35ef">-</font><td><a href="#" name="49">(19-39)<td><a href="#" name="49">(9-27)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_sequence.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import functools
3 import itertools
4 import re
5 from types import GeneratorType
6 from collections.abc import Hashable
7 from unittest import TestCase, main
8 import numpy as np
9 import numpy.testing as npt
10 <font color="#8e35ef"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import pandas as pd
11 import scipy.spatial.distance
12 import skbio.sequence.distance
13 from skbio import Sequence, DNA
14 from skbio.util import assert_data_frame_almost_equal
15 from skbio.sequence._sequence import (_single_index_to_slice, _is_single_index,
16                                       _as_slice_if_single_index)
17 from skbio.util._testing import ReallyEqualMixin
18 from skbio.metadata._testing import (MetadataMixinTests,
19                                      IntervalMetadataMixinTests,
20                                      PositionalMetadataMixinTests)
21 from skbio.metadata import IntervalMetadata
22 class SequenceSubclass(Sequence):
23     pass
24 class</b></font> SequenceSubclassTwo(Sequence):
25     pass
26 class TestSequenceMetadata(TestCase, ReallyEqualMixin, MetadataMixinTests):
27     def setUp(self):
28         self._metadata_constructor_ = functools.partial(Sequence, '')
29 class TestSequencePositionalMetadata(TestCase, ReallyEqualMixin,
30                                      PositionalMetadataMixinTests):
31     def setUp(self):
32         def factory(axis_len, positional_metadata=None):
33             return Sequence('Z' * axis_len,
34                             positional_metadata=positional_metadata)
35         self._positional_metadata_constructor_ = factory
36 class TestSequenceIntervalMetadata(TestCase, ReallyEqualMixin,
37                                    IntervalMetadataMixinTests):
38     def setUp(self):
39         super()._set_up()
40         def factory(axis_len, interval_metadata=None):
41             return Sequence('Z' * axis_len,
42                             interval_metadata=interval_metadata)
43         self._interval_metadata_constructor_ = factory
44 class TestSequenceBase(TestCase):
45     def setUp(self):
46         self.sequence_kinds = frozenset([
47             str, Sequence,
48             lambda s: np.frombuffer(s.encode('ascii'), dtype='|S1'),
49             lambda s: np.frombuffer(s.encode('ascii'), dtype=np.uint8)])
50 class TestSequence(TestSequenceBase, ReallyEqualMixin):
51     def setUp(self):
52         super(TestSequence, self).setUp()
53         self.lowercase_seq = Sequence('AAAAaaaa', lowercase='key')
54         def empty_generator():
55             yield from ()
56         self.getitem_empty_indices = [
57             [],
58             (),
59             {},
60             empty_generator(),
61             np.array([]),
62             np.array([], dtype=int)]
63     def test_concat_bad_how(self):
64         seq1 = seq2 = Sequence("123")
65         with self.assertRaises(ValueError):
66             Sequence.concat([seq1, seq2], how='foo')
67     def test_concat_on_subclass(self):
68         seq1 = SequenceSubclass("123")
69         seq2 = Sequence("123")
70         result = SequenceSubclass.concat([seq1, seq2])
71         self.assertIs(type(result), SequenceSubclass)
72         self.assertEqual(result, SequenceSubclass("123123"))
73     def test_concat_on_empty_iterator(self):
74         result = SequenceSubclass.concat((_ for _ in []))
75         self.assertIs(type(result), SequenceSubclass)
76         self.assertEqual(result, SequenceSubclass(""))
77     def test_concat_on_bad_subclass(self):
78         seq1 = Sequence("123")
79         seq2 = SequenceSubclassTwo("123")
80         with self.assertRaises(TypeError):
81             SequenceSubclass.concat([seq1, seq2])
82     def test_concat_interval_metadata(self):
83         seq1 = Sequence("1234")
84         seq1.interval_metadata.add(
85             [(0, 2)], [(True, False)], {'gene': 'sagA'})
86         seq2 = Sequence("5678")
87         seq2.interval_metadata.add(
88             [(1, 3)], [(False, True)], {'gene': 'sagB'})
89         obs = Sequence.concat([seq1, seq2])
90         exp.interval_metadata.add(
91             [(0, 2)], [(True, False)], {'gene': 'sagA'})
92         exp.interval_metadata<font color="#c57726"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add(
93             [(5, 7)], [(False, True)], {'gene': 'sagB'})
94         self.assertEqual(exp, obs)
95     def test_concat_one_seq_has_none_interval_metadata(self):
96         seq1 =</b></font> Sequence("1234")
97         seq1.interval_metadata.add(
98             [(0, 2)], [(True, False)], {'gene': 'sagA'})
99         seq2 = Sequence("5678")
100         seq3 = Sequence("910")
101         seq3.interval_metadata.add(
102             [(1, 3)], [(False, True)], {'gene': 'sagB'})
103         obs = Sequence.concat([seq1, seq2, seq3])
104         exp.interval_metadata.add(
105             [(0, 2)], [(True, False)], {'gene': 'sagA'})
106         exp.interval_metadata<font color="#d16587"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add(
107             [(9, 11)], [(False, True)], {'gene': 'sagB'})
108         self.assertEqual(exp, obs)
109     def test_concat_default_how(self):
110         seq1 =</b></font> Sequence("1234", positional_metadata={'a': [1]*4})
111         seq2 = Sequence("5678", positional_metadata={'a': [2]*4})
112         seqbad = Sequence("9", positional_metadata={'b': [9]})
113         result1 = Sequence.concat([seq1, seq2])
114         result2 = Sequence.concat([seq1, seq2], how='strict')
115         self.assertEqual(result1, result2)
116         with self.assertRaisesRegex(ValueError,
117                                     r'.*positional.*metadata.*inner.*outer.*'):
118             Sequence.concat([seq1, seq2, seqbad])
119     def test_concat_strict_simple(self):
120         expected = Sequence(
121             "12345678", positional_metadata={'a': [1, 1, 1, 1, 2, 2, 2, 2]})
122         seq1 = Sequence("1234", positional_metadata={'a': [1]*4})
123         seq2 = Sequence("5678", positional_metadata={'a': [2]*4})
124         result = Sequence.concat([seq1, seq2], how='strict')
125         self.assertEqual(result, expected)
126         self.assertFalse(result.metadata)
127     def test_concat_strict_many(self):
128         odd_key = frozenset()
129                             positional_metadata={'a': list('skbio'),
130                                                  odd_key: [1, 2, 3, 4, 5]})
131         result = Sequence<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.concat([
132                 Sequence("1", positional_metadata={'a': ['s'], odd_key: [1]}),
133                 Sequence("3", positional_metadata={'a': ['k'], odd_key: [2]}),
134                 Sequence("5", positional_metadata={'a': ['b'], odd_key: [3]}),
135                 Sequence("7", positional_metadata={'a': ['i'], odd_key: [4]}),
136                 Sequence(</b></font>"9", positional_metadata={'a': ['o'], odd_key: [5]})
137             ], how='strict')
138         self.assertEqual(result, expected)
139         self.assertFalse(result.metadata)
140     def test_concat_strict_fail(self):
141         seq1 = Sequence("1", positional_metadata={'a': [1]})
142         seq2 = Sequence("2", positional_metadata={'b': [2]})
143         with self.assertRaisesRegex(ValueError,
144                                     r'.*positional.*metadata.*inner.*outer.*'):
145             Sequence.concat([seq1, seq2], how='strict')
146     def test_concat_outer_simple(self):
147         seq1 = Sequence("1234")
148         seq2 = Sequence("5678")
149         result = Sequence.concat([seq1, seq2], how='outer')
150         self.assertEqual(result, Sequence("12345678"))
151         self.assertFalse(result.metadata)
152     def test_concat_outer_missing(self):
153         a = {}
154         b = {}
155         seq1 = Sequence("12", positional_metadata={'a': ['1', '2']})
156         seq2 = Sequence("34", positional_metadata={'b': [3, 4], 'c': [a, b]})
157         seq3 = Sequence("56")
158         seq4 = Sequence("78", positional_metadata={'a': [7, 8]})
159         result = Sequence.concat([seq1, seq2, seq3, seq4, seq5], how='outer')
160         expected = Sequence<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("1234567890", positional_metadata={
161                                 'a': ['1', '2', np.nan, np.nan, np.nan, np.nan,
162                                       7, 8, np.nan, np.nan],
163                                 'b': [np.nan, np.nan, 3, 4, np.nan, np.</b></font>nan,
164                                       np.nan, np.nan, 9, 0],
165                                 'c': [np.nan, np.nan, a, b, np.nan, np.nan,
166                                       np.nan, np.nan, np.nan, np.nan]
167                             })
168         self.assertEqual(result, expected)
169         self.assertFalse(result.metadata)
170     def test_concat_inner_simple(self):
171         seq1 = Sequence("1234")
172         seq2 = Sequence("5678", positional_metadata={'discarded': [1] * 4})
173         result = Sequence.concat([seq1, seq2], how='inner')
174         self.assertEqual(result, Sequence("12345678"))
175         self.assertFalse(result.metadata)
176     def test_concat_inner_missing(self):
177         seq1 = Sequence("12", positional_metadata={'a': ['1', '2'],
178                                                    'c': [{}, {}]})
179         seq2 = Sequence("34", positional_metadata={'a': [3, 4], 'b': [3, 4]})
180         seq3 = Sequence("56", positional_metadata={'a': [5, 6], 'b': [5, 6]})
181         result = Sequence.concat([seq1, seq2, seq3], how='inner')
182         expected = Sequence("123456", positional_metadata={'a': ['1', '2', 3,
183                                                                  4, 5, 6]})
184         self.assertEqual(result, expected)
185         self.assertFalse(result.metadata)
186     def test_init_default_parameters(self):
187         seq = Sequence('.ABC123xyz-')
188         npt.assert_equal(seq.values, np.array('.ABC123xyz-', dtype='c'))
189         self.assertEqual('.ABC123xyz-', str(seq))
190         self.assertFalse(seq.metadata)
191         self.assertEqual(seq.metadata, {})
192         assert_data_frame_almost_equal(seq.positional_metadata,
193                                        pd.DataFrame(index=range(11)))
194         self.assertEqual(seq.interval_metadata,
195                          IntervalMetadata(len(seq)))
196     def test_init_nondefault_parameters(self):
197         s = '.ABC123xyz-'
198         im = IntervalMetadata(len(s))
199         im.add([(0, 1)], metadata={'gene': 'sagA'})
200         seq = Sequence(s,
201                        metadata={'id': 'foo', 'description': 'bar baz'},
202                        positional_metadata={'quality': range(11)},
203                        interval_metadata=im)
204         npt.assert_equal(seq.values, np.array('.ABC123xyz-', dtype='c'))
205         self.assertEqual(s, str<font color="#668b8b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq))
206         self.assertTrue(seq.metadata)
207         self.assertEqual(seq.metadata, {'id': 'foo', 'description': 'bar baz'})
208         assert_data_frame_almost_equal(
209             seq.positional_metadata,
210             pd.DataFrame(</b></font>{'quality': range(11)}, index=range(11)))
211     def test_init_empty_sequence(self):
212         for s in (b'',  # bytes
213                   '',  # unicode
214                   np.array('', dtype='c'),  # char vector
215                   np.frombuffer(b'', dtype=np.uint8),  # byte vec
216             seq = Sequence(s)
217             self<font color="#3ea99f"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIsInstance(seq.values, np.ndarray)
218             self.assertEqual(seq.values.dtype, '|S1')
219             self.assertEqual(seq.values.shape, (0</b></font>, ))
220             npt.assert_equal(seq.values, np.array('', dtype='c'))
221             self.assertEqual(str(seq), '')
222             self.assertEqual(len(seq), 0)
223             self.assertFalse(seq.metadata)
224             self.assertEqual(seq.metadata, {})
225             self.assertEqual(seq.interval_metadata,
226                              IntervalMetadata(0))
227             assert_data_frame_almost_equal(seq.positional_metadata,
228                                            pd.DataFrame(index=range(0)))
229     def test_init_single_character_sequence(self):
230         for s in (b'A',
231                   'A',
232                   np.array('A', dtype='c'),
233                   np.frombuffer(b'A', dtype=np.uint8),
234             seq = Sequence(s)
235             self.assertIsInstance<font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq.values, np.ndarray)
236             self.assertEqual(seq.values.dtype, '|S1')
237             self.assertEqual(seq.values.shape, (1,))
238             npt.</b></font>assert_equal(seq.values, np.array('A', dtype='c'))
239             self.assertEqual(str(seq), 'A')
240             self.assertEqual(len(seq), 1)
241             self.assertFalse(seq.metadata)
242             self.assertEqual(seq.metadata, {})
243             self.assertEqual(seq.interval_metadata,
244                              IntervalMetadata(1))
245             assert_data_frame_almost_equal(seq.positional_metadata,
246                                            pd.DataFrame(index=range(1)))
247     def test_init_multiple_character_sequence(self):
248         for s in (b'.ABC\t123  xyz-',
249                   '.ABC\t123  xyz-',
250                   np.array('.ABC\t123  xyz-', dtype='c'),
251                   np.frombuffer(b'.ABC\t123  xyz-', dtype=np.uint8),
252             seq = Sequence(s)
253             self<font color="#549748"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIsInstance(seq.values, np.ndarray)
254             self.assertEqual(seq.values.dtype, '|S1')
255             self.assertEqual(seq.values.</b></font>shape, (14,))
256             npt.assert_equal(seq.values,
257                              np.array('.ABC\t123  xyz-', dtype='c'))
258             self.assertEqual(str(seq), '.ABC\t123  xyz-')
259             self.assertEqual(len(seq), 14)
260             self.assertFalse(seq.metadata)
261             self.assertEqual(seq.metadata, {})
262             self.assertEqual(seq.interval_metadata,
263                              IntervalMetadata(14))
264             assert_data_frame_almost_equal(seq.positional_metadata,
265                                            pd.DataFrame(index=range(14)))
266     def test_init_from_sequence_object(self):
267         seq = Sequence('ACGT')
268         self.assertEqual(Sequence(seq), seq)
269         seq = Sequence('ACGT',
270                        metadata={'id': 'foo', 'description': 'bar baz'},
271                        positional_metadata={'quality': range(4)})
272         seq.interval_metadata.add([(0, 1)], metadata={'gene': 'sagA'})
273         self.assertEqual(Sequence(seq), seq)
274         im = IntervalMetadata(4)
275         im.add([(0, 2)], metadata={'gene': 'sagB'})
276         self.assertEqual(
277             Sequence(seq, metadata={'id': 'abc', 'description': '123'},
278                      positional_metadata={'quality': [42] * 4},
279                      interval_metadata=im),
280             Sequence('ACGT', metadata={'id': 'abc', 'description': '123'},
281                      positional_metadata={'quality': [42] * 4},
282                      interval_metadata=im))
283         im = IntervalMetadata(4)
284         im.add([(0, 2)], metadata={'gene': 'sagB'})
285         seq = SequenceSubclass('ACGT',
286                                metadata={'id': 'foo',
287                                          'description': 'bar baz'},
288                                positional_metadata={'quality': range(4)},
289                                interval_metadata=im)
290         self.assertEqual(
291             Sequence(seq),
292             Sequence('ACGT', metadata={'id': 'foo', 'description': 'bar baz'},
293                      positional_metadata={'quality': range(4)},
294                      interval_metadata=im))
295     def test_init_from_non_descendant_sequence_object(self):
296         seq = SequenceSubclass('ACGT')
297         with self.assertRaises(TypeError) as cm:
298         error = str(cm.exception)
299         self<font color="#a057a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertIn("SequenceSubclass", error)
300         self.assertIn("SequenceSubclassTwo", error)
301         self.assertIn("cast", error)
302     def test_init_from_contiguous_sequence_bytes_view(self):
303         bytes = np.array([65</b></font>, 42, 66, 42, 65], dtype=np.uint8)
304         view = bytes[:3]
305         seq = Sequence(view)
306         self.assertEqual(seq, Sequence('A*B'))
307         self.assertFalse(seq._owns_bytes)
308         with self.assertRaises(ValueError):
309         self<font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq, Sequence('A*B'))
310         bytes[0] = 99
311         self.assertEqual(seq, Sequence('c*B'))
312     def test_init_from_noncontiguous_sequence_bytes_view(self):
313         bytes = np.array([65</b></font>, 42, 66, 42, 65], dtype=np.uint8)
314         view = bytes[::2]
315         seq = Sequence(view)
316         self.assertEqual(seq, Sequence('ABA'))
317         self.assertTrue(seq._owns_bytes)
318         bytes[0] = 99
319         view[1] = 100
320         self.assertEqual(seq, Sequence('ABA'))
321     def test_init_no_copy_of_sequence(self):
322         bytes = np.array([65, 66, 65], dtype=np.uint8)
323         seq = Sequence(bytes)
324         self.assertIs(seq._bytes, bytes)
325         with self.assertRaises(ValueError):
326             bytes[1] = 42
327     def test_init_invalid_sequence(self):
328         with self.assertRaises(TypeError):
329             Sequence(np.array([1, 2, 3]))
330         with self.assertRaises(TypeError):
331             Sequence(np.array([1, "23", 3]))
332         with self.assertRaises(TypeError):
333             Sequence(np.array([1, {}, ()]))
334         with self.assertRaisesRegex(TypeError, r'tuple'):
335             Sequence(('a', 'b', 'c'))
336         with self.assertRaisesRegex(TypeError, r'list'):
337             Sequence(['a', 'b', 'c'])
338         with self.assertRaisesRegex(TypeError, r'set'):
339             Sequence({'a', 'b', 'c'})
340         with self.assertRaisesRegex(TypeError, r'dict'):
341             Sequence({'a': 42, 'b': 43, 'c': 44})
342         with self.assertRaisesRegex(TypeError, r'int'):
343             Sequence(42)
344         with self.assertRaisesRegex(TypeError, r'float'):
345             Sequence(4.2)
346         with self.assertRaisesRegex(TypeError, r'int64'):
347             Sequence(np.int_(50))
348         with self.assertRaisesRegex(TypeError, r'float64'):
349             Sequence(np.float_(50))
350         with self.assertRaisesRegex(TypeError, r'Foo'):
351             class Foo:
352                 pass
353             Sequence(Foo())
354         with self.assertRaises(UnicodeEncodeError):
355             Sequence('abc\u1F30')
356     def test_values_property(self):
357         seq = Sequence('ACGT')
358         self.assertIsInstance(seq.values, np.ndarray)
359         self.assertEqual(seq.values.dtype, '|S1')
360         npt.assert_equal(seq.values, np.array('ACGT', dtype='c'))
361         with self.assertRaises(ValueError):
362             seq.values[1] = 'A'
363         with self.assertRaises(AttributeError):
364             seq.values = np.array("GGGG", dtype='c')
365         seq = Sequence('abc123')
366         array = np<font color="#c22817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.asarray(seq)
367         self.assertIsInstance(array, np.ndarray)
368         self.assertEqual(array.dtype, '|S1')
369         npt.assert_equal(array, np.array(</b></font>'abc123', dtype='c'))
370         npt.assert_equal(array, seq.values)
371         with self.assertRaises(ValueError):
372             array[1] = 'B'
373     def test_observed_chars_property(self):
374         self.assertEqual(Sequence('').observed_chars, set())
375         self.assertEqual(Sequence('xYz').observed_chars, {'x', 'Y', 'z'})
376         self.assertEqual(Sequence('zzz').observed_chars, {'z'})
377         self.assertEqual(Sequence('xYzxxZz')<font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.observed_chars,
378                          {'x', 'Y', 'z', 'Z'})
379         self.assertEqual(Sequence('\t   ').observed_chars, {' ', '\t'})
380         im = IntervalMetadata(6)
381         im.add([(0</b></font>, 2)], metadata={'gene': 'sagB'})
382         self.assertEqual(
383             Sequence('aabbcc', metadata={'foo': 'bar'},
384                      positional_metadata={'foo': range(6)},
385                      interval_metadata=im).observed_chars,
386             {'a', 'b', 'c'})
387         with self.assertRaises(AttributeError):
388             Sequence('ACGT').observed_chars = {'a', 'b', 'c'}
389     def test_eq_and_ne(self):
390         seq_a = Sequence("A")
391         seq_b = Sequence("B")
392         im = IntervalMetadata(1)
393         im.add([(0, 1)], metadata={'gene': 'sagA'})
394         im2 = IntervalMetadata(1)
395         im.add([(0, 1)], metadata={'gene': 'sagB'})
396         self.assertTrue(seq_a == seq_a)
397         self.assertTrue(Sequence("a") == Sequence("a"))
398         self.assertTrue(Sequence("a", metadata={'id': 'b'}) ==
399                         Sequence("a", metadata={'id': 'b'}))
400         self.assertTrue(Sequence("a",
401                                  metadata={'id': 'b', 'description': 'c'}) ==
402                         Sequence("a",
403                                  metadata={'id': 'b', 'description': 'c'}))
404         self.assertTrue(Sequence("a", metadata={'id': 'b', 'description': 'c'},
405                                  positional_metadata={'quality': [1]},
406                                  interval_metadata=im) ==
407                         Sequence("a", metadata={'id': 'b', 'description': 'c'},
408                                  positional_metadata={'quality': [1]},
409                                  interval_metadata=im))
410         self.assertTrue(seq_a != seq_b)
411         self.assertTrue(SequenceSubclass("a") != Sequence("a"))
412         self.assertTrue(Sequence("a") != Sequence("b"))
413         self.assertTrue(Sequence("a") != Sequence("a", metadata={'id': 'b'}))
414         self.assertTrue(Sequence("a", metadata={'id': 'c'}) !=
415                         Sequence("a",
416                                  metadata={'id': 'c', 'description': 't'}))
417         self.assertTrue(Sequence("a", positional_metadata={'quality': [1]}) !=
418                         Sequence("a"))
419         self.assertTrue(Sequence("a", interval_metadata=im) !=
420                         Sequence("a"))
421         self.assertTrue(Sequence("a", positional_metadata={'quality': [1]}) !=
422                         Sequence("a", positional_metadata={'quality': [2]}))
423         self.assertTrue(Sequence("a", interval_metadata=im) !=
424                         Sequence("a", interval_metadata=im2))
425         self.assertTrue(Sequence("c", positional_metadata={'quality': [3]}) !=
426                         Sequence("b", positional_metadata={'quality': [3]}))
427         self.assertTrue(Sequence("c", interval_metadata=im) !=
428                         Sequence("b", interval_metadata=im))
429         self.assertTrue(Sequence("a", metadata={'id': 'b'}) !=
430                         Sequence("c", metadata={'id': 'b'}))
431     def test_eq_sequences_without_metadata_compare_equal(self):
432         self.assertTrue(Sequence('') == Sequence(''))
433         self.assertTrue(Sequence('z') == Sequence('z'))
434         self.assertTrue(
435             Sequence('ACGT') == Sequence('ACGT'))
436         seq1 = Sequence('ACGT', metadata={'id': 'foo', 'desc': 'abc'},
437                         positional_metadata={'qual': [1, 2, 3, 4]})
438         seq2 = Sequence('ACGT', metadata<font color="#c57717"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'id': 'foo', 'desc': 'abc'},
439                         positional_metadata={'qual': [1, 2, 3, 4]})
440         self.assertTrue(seq1 == seq2)
441         self.assertTrue(seq2 == seq1)
442     def test_eq_sequences_from_different_sources_compare_equal(self):
443         im =</b></font> IntervalMetadata(4)
444         im.add([(0, 2)], metadata={'gene': 'sagB'})
445         seq1 = Sequence('ACGT', metadata={'id': 'foo', 'desc': 'abc'},
446                         positional_metadata={'quality': (1, 2, 3, 4)},
447                         interval_metadata=im)
448         seq2 = Sequence(np.array([65, 67, 71, 84], dtype=np.uint8),
449                         metadata={'id': 'foo', 'desc': 'abc'},
450                         positional_metadata={'quality': np.array([1, 2, 3,
451                                                                   4])},
452                         interval_metadata=im)
453         self.assertTrue(seq1 == seq2)
454     def test_eq_type_mismatch(self):
455         seq1 = Sequence('ACGT')
456         seq2 = SequenceSubclass('ACGT')
457         self.assertFalse(seq1 == seq2)
458     def test_eq_positional_metadata_mismatch(self):
459         seq1 = Sequence('ACGT', positional_metadata={'quality': [1, 2, 3, 4]})
460         seq2 = Sequence('ACGT', positional_metadata={'quality': [1, 2, 3, 5]})
461         self.assertFalse(seq1 == seq2)
462         seq1 = Sequence('ACGT', positional_metadata={'quality': [1, 2, 3, 4]})
463         seq2 = Sequence('ACGT')
464         self.assertFalse(seq1 == seq2)
465     def test_eq_interval_metadata_mismatch(self):
466         im1 = IntervalMetadata(4)
467         im1.add([(0, 3)], metadata={'gene': 'sagA'})
468         im2 = IntervalMetadata(4)
469         im2.add([(0, 2)], metadata={'gene': 'sagA'})
470         seq1 = Sequence('ACGT', interval_metadata=im1)
471         seq2 = Sequence('ACGT', interval_metadata=im2)
472         self.assertFalse(seq1 == seq2)
473         seq1 = Sequence('ACGT', interval_metadata=im1)
474         seq2 = Sequence('ACGT')
475         self.assertFalse(seq1 == seq2)
476     def test_eq_sequence_mismatch(self):
477         seq1 = Sequence('ACGT')
478         seq2 = Sequence('TGCA')
479         self.assertFalse(seq1 == seq2)
480     def test_getitem_gives_new_sequence(self):
481         seq = Sequence("Sequence string !1@2#3?.,")
482         self.assertFalse(seq is seq[:])
483     def test_getitem_drops_interval_metadata(self):
484         s = "Sequence string !1@2#3?.,"
485         seq = Sequence(s, metadata={'id': 'id', 'description': 'dsc'})
486         seq.interval_metadata.add([(0, 3)], metadata={'gene': 'sagA'})
487         eseq = Sequence('Se', metadata={'id': 'id', 'description': 'dsc'})
488         self.assertEqual(seq[:2], eseq)
489     def test_getitem_with_int_has_positional_metadata(self):
490         s = "Sequence string !1@2#3?.,"
491         length = len(s)
492         seq = Sequence(s, metadata={'id': 'id', 'description': 'dsc'},
493                        positional_metadata={'quality': np.arange(length)})
494         eseq = Sequence("S", {'id': 'id', 'description': 'dsc'},
495                         positional_metadata={'quality': np.array([0])})
496         self.assertEqual(seq[0], eseq)
497         eseq = Sequence(",", metadata={'id': 'id', 'description': 'dsc'},
498                         positional_metadata={'quality':
499                                              np.array([len(seq) - 1])})
500         self.assertEqual(seq[len(seq) - 1], eseq)
501         eseq = Sequence("t", metadata={'id': 'id', 'description': 'dsc'},
502                         positional_metadata={'quality': [10]})
503         self.assertEqual(seq[10], eseq)
504     def test_single_index_to_slice(self):
505         a = [1, 2, 3, 4]
506         self.assertEqual(slice(0, 1), _single_index_to_slice(0))
507         self.assertEqual([1], a[_single_index_to_slice(0)])
508         self.assertEqual(slice(-1, None),
509                          _single_index_to_slice(-1))
510         self.assertEqual([4], a[_single_index_to_slice(-1)])
511     def test_is_single_index(self):
512         self.assertTrue(_is_single_index(0))
513         self.assertFalse(_is_single_index(True))
514         self.assertFalse(_is_single_index(bool()))
515         self.assertFalse(_is_single_index('a'))
516     def test_as_slice_if_single_index(self):
517         self.assertEqual(slice(0, 1), _as_slice_if_single_index(0))
518         slice_obj = slice(2, 3)
519         self.assertIs(slice_obj,
520                       _as_slice_if_single_index(slice_obj))
521     def test_slice_positional_metadata(self):
522         seq = Sequence('ABCDEFGHIJ',
523                        positional_metadata={'foo': np.arange(10),
524                                             'bar': np.arange(100, 110)})
525         self.assertTrue(pd.DataFrame({'foo': [0], 'bar': [100]}).equals(
526                         seq._slice_positional_metadata(0)))
527         self.assertTrue(pd.DataFrame({'foo': [0], 'bar': [100]}).equals(
528                         seq._slice_positional_metadata(slice(0, 1))))
529         self.assertTrue(pd.DataFrame({'foo': [0, 1],
530                                       'bar': [100, 101]}).equals(
531                         seq._slice_positional_metadata(slice(0, 2))))
532         self.assertTrue(pd.DataFrame(
533             {'foo': [9], 'bar': [109]}, index=[9]).equals(
534                 seq._slice_positional_metadata(9)))
535     def test_getitem_with_int_no_positional_metadata(self):
536         seq = Sequence("Sequence string !1@2#3?.,",
537                        metadata={'id': 'id2', 'description': 'no_qual'})
538         eseq = Sequence("t", metadata={'id': 'id2', 'description': 'no_qual'})
539         self.assertEqual(seq[10], eseq)
540     def test_getitem_with_slice_has_positional_metadata(self):
541         s = "0123456789abcdef"
542         length = len(s)
543         seq = Sequence(s, metadata={'id': 'id3', 'description': 'dsc3'},
544         eseq = Sequence("012", metadata={'id': 'id3', 'description': 'dsc3'},
545                         positional_metadata<font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'quality': np.arange(3)})
546         self.assertEqual(seq[0:3], eseq)
547         self.assertEqual(seq[:3], eseq)
548         self.assertEqual(seq[</b></font>:3:1], eseq)
549         eseq = Sequence("def", metadata={'id': 'id3', 'description': 'dsc3'},
550                         positional_metadata={'quality': [13, 14, 15]})
551         self.assertEqual(seq[-3:], eseq)
552         self.assertEqual(seq[-3::1], eseq)
553         eseq = Sequence("02468ace",
554                         metadata={'id': 'id3', 'description': 'dsc3'},
555                         positional_metadata={'quality': [0, 2, 4, 6, 8, 10,
556                                                          12, 14]})
557         self.assertEqual(seq[0:length:2], eseq)
558         self.assertEqual(seq[::2], eseq)
559         eseq = Sequence(s[::-1], metadata={'id': 'id3', 'description': 'dsc3'},
560                         positional_metadata={'quality':
561                                              np.arange(length)[::-1]})
562         self.assertEqual(seq[length::-1], eseq)
563         self.assertEqual(seq[::-1], eseq)
564         eseq = Sequence('fdb97531',
565                         metadata={'id': 'id3', 'description': 'dsc3'},
566                         positional_metadata={'quality': [15, 13, 11, 9, 7, 5,
567                                                          3, 1]})
568         self.assertEqual(seq[length::-2], eseq)
569         self.assertEqual(seq[::-2], eseq)
570         eseq = Sequence('', metadata={'id': 'id3', 'description': 'dsc3'},
571                         positional_metadata={<font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'quality':
572                                              np.array([], dtype=np.int64)})
573         self.assertEqual(seq[length:0], eseq)
574         self.assertEqual(seq[-length:0], eseq)
575         self.assertEqual(seq[</b></font>1:0], eseq)
576         eseq = Sequence("0", metadata={'id': 'id3', 'description': 'dsc3'},
577                         positional_metadata={'quality': [0]})
578         self.assertEqual(seq[0:1], eseq)
579         self.assertEqual(seq[0:1:1], eseq)
580         self.assertEqual(seq[-length::-1], eseq)
581     def test_getitem_with_slice_no_positional_metadata(self):
582         s = "0123456789abcdef"
583         length = len(s)
584         seq = Sequence(s, metadata={'id': 'id4', 'description': 'no_qual4'})
585         eseq = Sequence("02468ace",
586                         metadata={'id': 'id4', 'description': 'no_qual4'})
587         self.assertEqual(seq[0:length:2], eseq)
588         self.assertEqual(seq[::2], eseq)
589     def test_getitem_with_tuple_of_mixed_with_positional_metadata(self):
590         s = "0123456789abcdef"
591         length = len(s)
592         seq = Sequence(s, metadata={'id': 'id5', 'description': 'dsc5'},
593         eseq = Sequence("00000", metadata={'id': 'id5', 'description': 'dsc5'},
594                         positional_metadata={'quality': [<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, 0, 0, 0, 0]})
595         self.assertEqual(seq[0, 0, 0, 0, 0], eseq)
596         self.assertEqual(seq[0, 0:1, 0, 0, 0], eseq)
597         self.assertEqual(seq[0, 0:1, 0, -length::-1, 0, 1:0], eseq)
598         self.assertEqual(seq[0:1, 0:1, 0:1, 0:1, 0:1], eseq)
599         self.assertEqual(seq[</b></font>0:1, 0, 0, 0, 0], eseq)
600         eseq = Sequence("0123fed9",
601                         metadata={'id': 'id5', 'description': 'dsc5'},
602                         positional_metadata={'quality': [<font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, 1, 2, 3, 15, 14,
603                                                          13, 9]})
604         self.assertEqual(seq[0, 1, 2, 3, 15, 14, 13, 9], eseq)
605         self.assertEqual(seq[0, 1, 2, 3, :-4:-1, 9], eseq)
606         self.assertEqual(seq[0:4, :-4:-1, 9, 1:0], eseq)
607         self.assertEqual(seq[</b></font>0:4, :-4:-1, 9:10], eseq)
608         seq = Sequence("0123456789abcdef",
609                        metadata={'id': 'id6', 'description': 'no_qual6'})
610         eseq = Sequence<font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("0123fed9",
611                         metadata={'id': 'id6', 'description': 'no_qual6'})
612         self.assertEqual(seq[0, 1, 2, 3, 15, 14, 13, 9], eseq)
613         self.assertEqual(seq[0, 1, 2, 3, :-4:-1, 9], eseq)
614         self.assertEqual(seq[0:4, :-4:-1, 9], eseq)
615         self.assertEqual(seq[</b></font>0:4, :-4:-1, 9:10], eseq)
616         seq = Sequence("0123456789abcdef")
617         eseq = Sequence("0123fed9")
618         self<font color="#f87a17"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq[0, 1, 2, 3, 15, 14, 13, 9], eseq)
619         self.assertEqual(seq[0, 1, 2, 3, :-4:-1, 9], eseq)
620         self.assertEqual(seq[0:4, :-4:-1, 9], eseq)
621         self.assertEqual(seq[</b></font>0:4, :-4:-1, 9:10], eseq)
622     def test_getitem_with_iterable_of_mixed_has_positional_metadata(self):
623         s = "0123456789abcdef"
624         length = len(s)
625         seq = Sequence(s, metadata={'id': 'id7', 'description': 'dsc7'},
626                        positional_metadata={'quality': np.arange(length)})
627         def generator():
628             yield slice(0, 4)
629             yield slice(200, 400)
630             yield -1
631             yield slice(-2, -4, -1)
632             yield 9
633         eseq = Sequence("0123fed9",
634                         metadata={'id': 'id7', 'description': 'dsc7'},
635                         positional_metadata={'quality': [0, 1, 2, 3, 15, 14,
636                                                          13, 9]})
637         self.assertEqual(seq[[0, 1, 2, 3, 15, 14, 13, 9]], eseq)
638         self.assertEqual(seq[generator()], eseq)
639         self.assertEqual(seq[[slice(0, 4), slice(None, -4, -1), 9]], eseq)
640         self.assertEqual(seq[
641             [slice(0, 4), slice(None, -4, -1), slice(9, 10)]], eseq)
642     def test_getitem_with_iterable_of_mixed_no_positional_metadata(self):
643         s = "0123456789abcdef"
644         seq = Sequence(s, metadata={'id': 'id7', 'description': 'dsc7'})
645         def generator():
646             yield slice(0, 4)
647             yield slice(200, 400)
648             yield slice(None, -4, -1)
649             yield 9
650         eseq = Sequence("0123fed9",
651                         metadata={'id': 'id7', 'description': 'dsc7'})
652         self.assertEqual(seq[[0, 1, 2, 3, 15, 14, 13, 9]], eseq)
653         self.assertEqual(seq[generator()], eseq)
654         self.assertEqual(seq[[slice(0, 4), slice(None, -4, -1), 9]], eseq)
655         self.assertEqual(seq[
656             [slice(0, 4), slice(None, -4, -1), slice(9, 10)]], eseq)
657     def test_getitem_with_numpy_index_has_positional_metadata(self):
658         s = "0123456789abcdef"
659         length = len(s)
660         seq = Sequence(s, metadata={'id': 'id9', 'description': 'dsc9'},
661                        positional_metadata={'quality': np.arange(length)})
662         eseq = Sequence("0123fed9",
663                         metadata={'id': 'id9', 'description': 'dsc9'},
664                         positional_metadata={'quality': [0, 1, 2, 3, 15, 14,
665                                                          13, 9]})
666         self.assertEqual(seq[np.array([0, 1, 2, 3, 15, 14, 13, 9])], eseq)
667     def test_getitem_with_numpy_index_no_positional_metadata(self):
668         s = "0123456789abcdef"
669         seq = Sequence(s, metadata={'id': 'id10', 'description': 'dsc10'})
670         eseq = Sequence("0123fed9",
671                         metadata={'id': 'id10', 'description': 'dsc10'})
672         self.assertEqual(seq[np.array([0, 1, 2, 3, 15, 14, 13, 9])], eseq)
673     def test_getitem_with_empty_indices_empty_seq_no_pos_metadata(self):
674         s = ""
675         seq = Sequence(s, metadata={'id': 'id10', 'description': 'dsc10'})
676         eseq = Sequence('', metadata={'id': 'id10', 'description': 'dsc10'})
677         tested = 0
678         for index in self.getitem_empty_indices:
679             tested += 1
680             self.assertEqual(seq[index], eseq)
681         self.assertEqual(tested, 6)
682     def test_getitem_with_empty_indices_non_empty_seq_no_pos_metadata(self):
683         s = "0123456789abcdef"
684         seq = Sequence(s, metadata={'id': 'id10', 'description': 'dsc10'})
685         eseq = Sequence('', metadata={'id': 'id10', 'description': 'dsc10'})
686         tested = 0
687         for index in self.getitem_empty_indices:
688             tested += 1
689             self.assertEqual(seq[index], eseq)
690         self.assertEqual(tested, 6)
691     def test_getitem_with_boolean_vector_has_qual(self):
692         s = "0123456789abcdef"
693         length = len(s)
694         seq = Sequence(s, metadata={'id': 'id11', 'description': 'dsc11'},
695                        positional_metadata={'quality': np.arange(length)})
696         eseq = Sequence("13579bdf",
697                         metadata={'id': 'id11', 'description': 'dsc11'},
698                         positional_metadata={'quality': [1, 3, 5, 7, 9, 11,
699                                                          13, 15]})
700         self.assertEqual(seq[np.array([False, True] * 8)], eseq)
701         self.assertEqual(seq[[False, True] * 8], eseq)
702     def test_getitem_with_boolean_vector_no_positional_metadata(self):
703         s = "0123456789abcdef"
704         seq = Sequence(s, metadata={'id': 'id11', 'description': 'dsc11'})
705         eseq = Sequence("13579bdf",
706                         metadata={'id': 'id11', 'description': 'dsc11'})
707         self.assertEqual(seq[np.array([False, True] * 8)], eseq)
708     def test_getitem_with_invalid(self):
709         seq = Sequence("123456",
710                        metadata={'id': 'idm', 'description': 'description'},
711                        positional_metadata={'quality': [1, 2, 3, 4, 5, 6]})
712         with self.assertRaises(IndexError):
713             seq['not an index']
714         with self.assertRaises(IndexError):
715             seq[['1', '2']]
716         with self.assertRaises(IndexError):
717             seq[[1, slice(1, 2), 'a']]
718         with self.assertRaises(IndexError):
719             seq[[1, slice(1, 2), True]]
720         with self.assertRaises(IndexError):
721             seq[True]
722         with self.assertRaises(IndexError):
723             seq[np.array([True, False])]
724         with self.assertRaises(IndexError):
725             seq[999]
726         with self.assertRaises(IndexError):
727             seq[0, 0, 999]
728         with self.assertRaises(Exception):
729             seq[100 * [True, False, True]]
730     def test_getitem_empty_positional_metadata(self):
731         seq = Sequence('ACGT')
732         seq.positional_metadata  # This will create empty positional_metadata
733         self.assertEqual(Sequence('A'), seq[0])
734     def test_len(self):
735         self.assertEqual(len(Sequence("")), 0)
736         self.assertEqual(len(Sequence("a")), 1)
737         self.assertEqual(len(Sequence("abcdef")), 6)
738     def test_nonzero(self):
739         self.assertFalse(Sequence(""))
740         self.assertFalse(Sequence("",
741                                   metadata={<font color="#347235"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'id': 'foo'},
742                                   positional_metadata={'quality': range(0)}))
743         self.assertTrue(Sequence("A"))
744         self.assertTrue(Sequence("A",
745                                  metadata={'id'</b></font>: 'foo'},
746                                  positional_metadata={'quality': range(1)}))
747         self.assertTrue(Sequence("ACGT"))
748         self.assertTrue(Sequence("ACGT",
749                                  metadata={'id': 'foo'},
750                                  positional_metadata={'quality': range(4)}))
751     def test_contains(self):
752         seq = Sequence("#@ACGT,24.13**02")
753         for c in self.sequence_kinds:
754             tested += 1
755             self<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertTrue(c(',24') in seq)
756             self.assertTrue(c('*') in seq)
757             self.assertTrue(c('') in seq)
758             self.assertFalse(c("$") in seq)
759             self.assertFalse(</b></font>c("AGT") in seq)
760         self.assertEqual(tested, 4)
761     def test_contains_sequence_subclass(self):
762         with self.assertRaises(TypeError):
763             SequenceSubclass("A") in Sequence("AAA")
764         self.assertTrue(SequenceSubclass("A").values in Sequence("AAA"))
765     def test_hash(self):
766         with self.assertRaises(TypeError):
767             hash(Sequence("ABCDEFG"))
768         self.assertNotIsInstance(Sequence("ABCDEFG"), Hashable)
769     def test_iter_has_positional_metadata(self):
770         tested = False
771         seq = Sequence("0123456789", metadata={'id': 'a', 'desc': 'b'},
772                        positional_metadata={'qual': np.arange(10)})
773         for i, s in enumerate(seq):
774             tested = True
775             self.assertEqual(s, Sequence(str(i),
776                                          metadata={'id': 'a', 'desc': 'b'},
777                                          positional_metadata={'qual': [i]}))
778         self.assertTrue(tested)
779     def test_iter_no_positional_metadata(self):
780         tested = False
781         seq = Sequence("0123456789", metadata={'id': 'a', 'desc': 'b'})
782         for i, s in enumerate(seq):
783             tested = True
784             self.assertEqual(s, Sequence(str(i),
785                                          metadata={'id': 'a', 'desc': 'b'}))
786         self.assertTrue(tested)
787     def test_reversed_has_positional_metadata(self):
788         tested = False
789         seq = Sequence("0123456789", metadata={'id': 'a', 'desc': 'b'},
790                        positional_metadata={'qual': np.arange(10)})
791         for i, s in enumerate(reversed(seq)):
792             tested = True
793             self.assertEqual(s, Sequence(str(9 - i),
794                                          metadata={'id': 'a', 'desc': 'b'},
795                                          positional_metadata={'qual':
796                                                               [9 - i]}))
797         self.assertTrue(tested)
798     def test_reversed_no_positional_metadata(self):
799         tested = False
800         seq = Sequence("0123456789", metadata={'id': 'a', 'desc': 'b'})
801         for i, s in enumerate(reversed(seq)):
802             tested = True
803             self.assertEqual(s, Sequence(str(9 - i),
804                                          metadata={'id': 'a', 'desc': 'b'}))
805         self.assertTrue(tested)
806     def test_repr(self):
807         obs = repr(Sequence(''))
808         self<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(obs.count('\n'), 4)
809         self.assertTrue(obs.startswith('Sequence'))
810         self.assertIn('length: 0', obs)
811         self.assertTrue(obs.endswith('-'))
812         obs =</b></font> repr(Sequence('ACGT'))
813         self<font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(obs.count('\n'), 5)
814         self.assertTrue(obs.startswith('Sequence'))
815         self.assertIn('length: 4', obs)
816         self.assertTrue(obs.</b></font>endswith('0 ACGT'))
817         obs = repr(
818             Sequence(
819                 'ACGT',
820                 metadata={'foo': 'bar', b'bar': 33.33, None: True, False: {},
821                 positional_metadata={'foo': range(4),
822                                      42: ['a', 'b', [], 'c']}))
823         self<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(obs.count('\n'), 16)
824         self.assertTrue(obs.startswith('Sequence'))
825         self.assertIn('None: True', obs)
826         self.assertIn('\'foo\': \'bar\'', obs)
827         self.assertIn('42: &lt;dtype: object&gt;', obs)
828         self.assertIn('\'foo\': &lt;dtype: int64&gt;', obs)
829         self.</b></font>assertIn('length: 4', obs)
830         self.assertTrue(obs.endswith('0 ACGT'))
831         obs = repr(Sequence('A' * 301))
832         self.assertEqual(obs.count('\n'), 9)
833         self.assertTrue(obs.startswith('Sequence'))
834         self.assertIn('length: 301', obs)
835         self.assertIn('...', obs)
836         self.assertTrue(obs.endswith('300 A'))
837     def test_str(self):
838         self.assertEqual(str(Sequence("GATTACA")), "GATTACA")
839         self.assertEqual(str(Sequence("ACCGGTACC")), "ACCGGTACC")
840         self.assertEqual(str(Sequence("GREG")), "GREG")
841         self.assertEqual(
842             str(Sequence("ABC",
843                          positional_metadata={'quality': [1, 2, 3]})),
844             "ABC")
845         self.assertIs(type(str(Sequence("A"))), str)
846     def test_count(self):
847         def construct_char_array(s):
848             return np.frombuffer(s.encode('ascii'), dtype='|S1')
849         def construct_uint8_array(s):
850             return np.frombuffer(s.encode('ascii'), dtype=np.uint8)
851         seq = Sequence("1234567899876555")
852         tested = 0
853         for c in self.sequence_kinds:
854             tested += 1
855             self.assertEqual(seq.count(c('4')), 1)
856             self.assertEqual(seq.count(c('8')), 2)
857             self.assertEqual(seq.count(c('5')), 4)
858             self.assertEqual(seq.count(c('555')), 1)
859             self.assertEqual(seq.count(c('555'), 0, 4), 0)
860             self.assertEqual(seq.count(c('555'), start=0, end=4), 0)
861             self.assertEqual(seq.count(c('5'), start=10), 3)
862             self.assertEqual(seq.count(c('5'), end=10), 1)
863             with self.assertRaises(ValueError):
864                 seq.count(c(''))
865         self.assertEqual(tested, 4)
866     def test_count_on_subclass(self):
867         with self.assertRaises(TypeError) as cm:
868             Sequence("abcd").count(SequenceSubclass("a"))
869         self.assertIn("Sequence", str(cm.exception))
870         self.assertIn("SequenceSubclass", str(cm.exception))
871     def test_replace_sanity(self):
872         seq = Sequence('AAGCATGCCCTTTACATTTG')
873         index = self._make_index('10011011001111110111')
874         obs = seq.replace(index, '_')
875         exp = Sequence('_AG__T__CC______T___')
876         self.assertEqual(obs, exp)
877     def test_replace_index_array(self):
878         seq = Sequence('TCGGGTGTTGTGCAACCACC')
879         for _type in list, tuple, np.array, pd.Series:
880             index = _type([0, 2, 5, 8, 9])
881             obs = seq.replace(index, '-')
882             exp = Sequence('-C-GG-GT--TGCAACCACC')
883             self.assertEqual(obs, exp)
884     def test_replace_iterable_slices(self):
885         seq = Sequence('CATTATGGACCCAGCGTGCC')
886         slices = (slice(0, 5), slice(8, 12), slice(15, 17))
887         mixed_slices = (0, 1, 2, 3, 4, slice(8, 12), 15, 16)
888         for _type in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
889                       lambda x: pd.Series(tuple(x))):
890             index = (_type(slices), _type(mixed_slices))
891             obs_slices = seq.replace(index[0], '-')
892             obs_mixed = seq.replace(index[1], '-')
893             exp = Sequence('-----TGG----AGC--GCC')
894             self.assertEqual(obs_slices, exp)
895             self.assertEqual(obs_mixed, exp)
896     def test_replace_index_in_positional_metadata(self):
897         positional_metadata = {'where': self._make_index('001110110'
898                                                          '10001110000')}
899         seq = Sequence('AAGATTGATACCACAGTTGT',
900                        positional_metadata=positional_metadata)
901         obs = seq.replace('where', '-')
902         exp = Sequence('AA---T--T-CCA---TTGT',
903                        positional_metadata=positional_metadata)
904         self.assertEqual(obs, exp)
905     def test_replace_does_not_mutate_original(self):
906         seq = Sequence('ATCG')
907         index = self._make_index('0011')
908         seq.replace(index, '-')
909         obs = seq
910         exp = Sequence('ATCG')
911         self.assertEqual(obs, exp)
912     def test_replace_with_metadata(self):
913         seq = Sequence('GCACGGCAAGAAGCGCCCCA',
914                        metadata={'NM': 'Kestrel Gorlick'},
915                        positional_metadata={'diff':
916                                             list('01100001110010001100')})
917         seq.interval_metadata.add([(0, 1)], metadata={'gene': 'sagA'})
918         index = self._make_index('01100001110010001100')
919         obs = seq.replace(index, '-')
920         exp = Sequence('G--CGGC---AA-CGC--CA',
921                        metadata={'NM': 'Kestrel Gorlick'},
922                        positional_metadata={'diff':
923                                             list('01100001110010001100')})
924         exp.interval_metadata.add([(0, 1)], metadata={'gene': 'sagA'})
925         self.assertEqual(obs, exp)
926     def test_replace_with_subclass(self):
927         seq = DNA('CGACAACCGATGTGCTGTAA')
928         index = self._make_index('10101000111111110011')
929         obs = seq.replace(index, '-')
930         exp = DNA('-G-C-ACC--------GT--')
931         self.assertEqual(obs, exp)
932     def test_replace_with_bytes(self):
933         seq = Sequence('ABC123')
934         obs = seq.replace([1, 3, 5], b'*')
935         self.assertEqual(obs, Sequence('A*C*2*'))
936     def test_replace_invalid_char_for_type_error(self):
937         seq = DNA('TAAACGGAACGCTACGTCTG')
938         index <font color="#152dc6"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self._make_index('01000001101011001001')
939         with self.assertRaisesRegex(ValueError, r"Invalid character.*'F'"):
940             seq.replace(index, 'F')
941     def test_replace_invalid_char_error(self):
942         seq =</b></font> Sequence('GGGAGCTAGA')
943         index = self._make_index('1000101110')
944         with self.assertRaisesRegex(UnicodeEncodeError,
945                                     r"can't encode character.*not in "
946                                     r"range\(128\)"):
947             seq.replace(index, '\uFFFF')
948     def test_replace_non_single_character_error(self):
949         seq = Sequence('CCGAACTGTC')
950         index = self._make_index('1100110011')
951         with self.assertRaisesRegex(TypeError, r'string of length 2 found'):
952             seq.replace(index, 'AB')
953     def _make_index(self, bools):
954         return [bool(int(char)) for char in bools]
955     def test_lowercase_mungeable_key(self):
956         self.assertEqual('AAAAaaaa', self<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.lowercase_seq.lowercase('key'))
957     def test_lowercase_array_key(self):
958         self.assertEqual('aaAAaaaa',
959                          self.lowercase_seq.lowercase(
960                              np.array([True, True, False, False, True, True,
961                                        True, True])))
962         self.</b></font>assertEqual('AaAAaAAA',
963                          self.lowercase_seq.lowercase([1, 4]))
964     def test_matches(self):
965         tested = 0
966         for constructor in self.sequence_kinds:
967             tested += 1
968             seq1 = Sequence("AACCEEGG")
969             seq2 = constructor("ABCDEFGH")
970             expected = np.array([True, False] * 4)
971             npt.assert_equal(seq1.matches(seq2), expected)
972         self.assertEqual(tested, 4)
973     def test_matches_on_subclass(self):
974         seq1 = Sequence("AACCEEGG")
975         seq2 = SequenceSubclass("ABCDEFGH")
976         with self.assertRaises(TypeError):
977             seq1.matches(seq2)
978     def test_matches_unequal_length(self):
979         seq1 = Sequence("AACCEEGG")
980         seq2 = Sequence("TOOLONGTOCOMPARE")
981         with self.assertRaises(ValueError):
982             seq1.matches(seq2)
983     def test_mismatches(self):
984         tested = 0
985         for constructor in self.sequence_kinds:
986             tested += 1
987             seq1 = Sequence("AACCEEGG")
988             seq2 = constructor("ABCDEFGH")
989             expected = np.array([False, True] * 4)
990             npt.assert_equal(seq1.mismatches(seq2), expected)
991         self.assertEqual(tested, 4)
992     def test_mismatches_on_subclass(self):
993         seq1 = Sequence("AACCEEGG")
994         seq2 = SequenceSubclass("ABCDEFGH")
995         with self.assertRaises(TypeError):
996             seq1.mismatches(seq2)
997     def test_mismatches_unequal_length(self):
998         seq1 = Sequence("AACCEEGG")
999         seq2 = Sequence("TOOLONGTOCOMPARE")
1000         with self.assertRaises(ValueError):
1001             seq1.mismatches(seq2)
1002     def test_mismatch_frequency(self):
1003         seq1 = Sequence("AACCEEGG")
1004         seq2 = Sequence("ABCDEFGH")
1005         self.assertIs(type(seq1.mismatch_frequency(seq1)), int)
1006         self<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq1.mismatch_frequency(seq1), 0)
1007         self.assertEqual(seq1.mismatch_frequency(seq2), 4)
1008         self.assertEqual(seq1.mismatch_frequency(seq3), 8)
1009     def test_mismatch_frequency_relative(self):
1010         seq1 =</b></font> Sequence("AACCEEGG")
1011         seq3 = Sequence("TTTTTTTT")
1012         self.assertIs(type<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq1.mismatch_frequency(seq1, relative=True)),
1013                       float)
1014         self.assertEqual(seq1.mismatch_frequency(seq1, relative=True), 0.0)
1015         self.assertEqual(seq1.mismatch_frequency(seq2, relative=True), 0.5)
1016         self.assertEqual(seq1.mismatch_frequency(seq3, relative=</b></font>True), 1.0)
1017     def test_mismatch_frequency_unequal_length(self):
1018         seq1 = Sequence("AACCEEGG")
1019         seq2 = Sequence("TOOLONGTOCOMPARE")
1020         with self.assertRaises(ValueError):
1021             seq1.mismatch_frequency(seq2)
1022     def test_mismatch_frequence_on_subclass(self):
1023         seq1 = Sequence("AACCEEGG")
1024         seq2 = SequenceSubclass("ABCDEFGH")
1025         with self.assertRaises(TypeError):
1026             seq1.mismatch_frequency(seq2)
1027     def test_match_frequency(self):
1028         seq1 = Sequence("AACCEEGG")
1029         seq2 = Sequence("ABCDEFGH")
1030         self.assertIs(type(seq1.match_frequency(seq1)), int)
1031         self<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq1.match_frequency(seq1), 8)
1032         self.assertEqual(seq1.match_frequency(seq2), 4)
1033         self.assertEqual(seq1.match_frequency(seq3), 0)
1034     def test_match_frequency_relative(self):
1035         seq1 =</b></font> Sequence("AACCEEGG")
1036         seq3 = Sequence("TTTTTTTT")
1037         self.assertIs(type<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq1.match_frequency(seq1, relative=True)),
1038                       float)
1039         self.assertEqual(seq1.match_frequency(seq1, relative=True), 1.0)
1040         self.assertEqual(seq1.match_frequency(seq2, relative=True), 0.5)
1041         self.assertEqual(seq1.match_frequency(seq3, relative=</b></font>True), 0.0)
1042     def test_match_frequency_unequal_length(self):
1043         seq1 = Sequence("AACCEEGG")
1044         seq2 = Sequence("TOOLONGTOCOMPARE")
1045         with self.assertRaises(ValueError):
1046             seq1.match_frequency(seq2)
1047     def test_match_frequency_on_subclass(self):
1048         seq1 = Sequence("AACCEEGG")
1049         seq2 = SequenceSubclass("ABCDEFGH")
1050         with self.assertRaises(TypeError):
1051             seq1.match_frequency(seq2)
1052     def test_index(self):
1053         tested = 0
1054         for c in self.sequence_kinds:
1055             tested += 1
1056             seq = Sequence("ABCDEFG@@ABCDFOO")
1057             self.assertEqual(seq.index(c("A")), 0)
1058             self.assertEqual(seq.index(c("@")), 7)
1059             self.assertEqual(seq.index(c("@@")), 7)
1060             with self.assertRaises(ValueError):
1061                 seq.index("A", start=1, end=5)
1062         self.assertEqual(tested, 4)
1063     def test_index_on_subclass(self):
1064         with self.assertRaises(TypeError):
1065             Sequence("ABCDEFG").index(SequenceSubclass("A"))
1066         self.assertEqual(
1067             SequenceSubclass("ABCDEFG").index(SequenceSubclass("A")), 0)
1068     def test_frequencies_empty_sequence(self):
1069         seq = Sequence('')
1070         self.assertEqual(seq.frequencies(), {})
1071         self.assertEqual(seq.frequencies(relative=True), {})
1072         self.assertEqual(seq.frequencies(chars=set()), {})
1073         self.assertEqual(seq.frequencies(chars=set(), relative=True), {})
1074         self.assertEqual(seq.frequencies(chars={'a', 'b'}), {'a': 0, 'b': 0})
1075         npt.assert_equal(seq.frequencies(chars={'a', 'b'}, relative=True),
1076                          {'a': np.nan, 'b': np.nan})
1077     def test_frequencies_observed_chars(self):
1078         seq = Sequence('x')
1079         self.assertEqual(seq.frequencies(), {'x': 1})
1080         self.assertEqual(seq.frequencies(relative=True), {'x': 1.0})
1081         seq = Sequence('xYz')
1082         self.assertEqual(seq.frequencies(), {'x': 1, 'Y': 1, 'z': 1})
1083         self.assertEqual(seq.frequencies(relative=True),
1084                          {'x': 1/3, 'Y': 1/3, 'z': 1/3})
1085         seq = Sequence('zzz')
1086         self.assertEqual(seq.frequencies(), {'z': 3})
1087         self.assertEqual(seq.frequencies(relative=True), {'z': 1.0})
1088         seq = Sequence('xYzxxZz')
1089         self.assertEqual(seq.frequencies(), {'x': 3, 'Y': 1, 'Z': 1, 'z': 2})
1090         self.assertEqual(seq.frequencies(relative=True),
1091                          {'x': 3/7, 'Y': 1/7, 'Z': 1/7, 'z': 2/7})
1092         seq = Sequence('\t   ')
1093         self.assertEqual(seq.frequencies(), {'\t': 1, ' ': 3})
1094         self.assertEqual(seq.frequencies(relative=True), {'\t': 1/4, ' ': 3/4})
1095         seq = Sequence('aabbcc', metadata={'foo': 'bar'},
1096                        positional_metadata={'foo': range(6)})
1097         self.assertEqual(seq.frequencies(), {'a': 2, 'b': 2, 'c': 2})
1098         self.assertEqual(seq.frequencies(relative=True),
1099                          {'a': 2/6, 'b': 2/6, 'c': 2/6})
1100     def test_frequencies_specified_chars(self):
1101         seq = Sequence('abcbca')
1102         self.assertEqual(seq.frequencies(chars=set()), {})
1103         self.assertEqual(seq.frequencies(chars=set(), relative=True), {})
1104         self.assertEqual(seq.frequencies(chars='a'), {'a': 2})
1105         self.assertEqual(seq.frequencies(chars='a', relative=True), {'a': 2/6})
1106         self.assertEqual(seq.frequencies(chars={'a'}), {'a': 2})
1107         self.assertEqual(seq.frequencies(chars={'a'}, relative=True),
1108                          {'a': 2/6})
1109         self.assertEqual(seq.frequencies(chars={'a', 'b'}), {'a': 2, 'b': 2})
1110         self.assertEqual(seq.frequencies(chars={'a', 'b'}, relative=True),
1111                          {'a': 2/6, 'b': 2/6})
1112         self.assertEqual(seq.frequencies(chars={'a', 'b', 'd'}),
1113                          {'a': 2, 'b': 2, 'd': 0})
1114         self.assertEqual(seq.frequencies(chars={'a', 'b', 'd'}, relative=True),
1115                          {'a': 2/6, 'b': 2/6, 'd': 0.0})
1116         self.assertEqual(seq.frequencies(chars={'x', 'y', 'z'}),
1117                          {'x': 0, 'y': 0, 'z': 0})
1118         self.assertEqual(seq.frequencies(chars={'x', 'y', 'z'}, relative=True),
1119                          {'x': 0.0, 'y': 0.0, 'z': 0.0})
1120     def test_frequencies_chars_varied_type(self):
1121         seq = Sequence('zabczzzabcz')
1122         chars = b'z'
1123         self.assertEqual(seq.frequencies(chars=chars), {b'z': 5})
1124         self.assertEqual(seq.frequencies(chars=chars, relative=True),
1125                          {b'z': 5/11})
1126         chars = 'z'
1127         self.assertEqual(seq.frequencies(chars=chars), {'z': 5})
1128         self.assertEqual(seq.frequencies(chars=chars, relative=True),
1129                          {'z': 5/11})
1130         chars = np.frombuffer('z'.encode('ascii'), dtype='|S1')[0]
1131         self.assertEqual(seq.frequencies(chars=chars), {b'z': 5})
1132         self.assertEqual(seq.frequencies(chars=chars, relative=True),
1133                          {b'z': 5/11})
1134         chars = {b'x', b'z'}
1135         self.assertEqual(seq.frequencies(chars=chars), {b'x': 0, b'z': 5})
1136         self.assertEqual(seq.frequencies(chars=chars, relative=True),
1137                          {b'x': 0.0, b'z': 5/11})
1138         chars = {'x', 'z'}
1139         self.assertEqual(seq.frequencies(chars=chars), {'x': 0, 'z': 5})
1140         self.assertEqual(seq.frequencies(chars=chars, relative=True),
1141                          {'x': 0.0, 'z': 5/11})
1142         chars = {
1143             np.frombuffer('x'.encode('ascii'), dtype='|S1')[0],
1144             np.frombuffer('z'.encode('ascii'), dtype='|S1')[0]
1145         }
1146         self.assertEqual(seq.frequencies(chars=chars), {b'x': 0, b'z': 5})
1147         self.assertEqual(seq.frequencies(chars=chars, relative=True),
1148                          {b'x': 0.0, b'z': 5/11})
1149     def test_frequencies_equivalent_to_kmer_frequencies_k_of_1(self):
1150         seq = Sequence('abcabc')
1151         exp = {'a': 2, 'b': 2, 'c': 2}
1152         self.assertEqual(seq.frequencies(chars=None), exp)
1153         self.assertEqual(seq.kmer_frequencies(k=1), exp)
1154         exp = {'a': 2/6, 'b': 2/6, 'c': 2/6}
1155         self.assertEqual(seq.frequencies(chars=None, relative=True), exp)
1156         self.assertEqual(seq.kmer_frequencies(k=1, relative=True), exp)
1157     def test_frequencies_passing_observed_chars_equivalent_to_default(self):
1158         seq = Sequence('abcabc')
1159         exp = {'a': 2, 'b': 2, 'c': 2}
1160         self.assertEqual(seq.frequencies(chars=None), exp)
1161         self.assertEqual(seq.frequencies(chars=seq.observed_chars), exp)
1162         exp = {'a': 2/6, 'b': 2/6, 'c': 2/6}
1163         self.assertEqual(seq.frequencies(chars=None, relative=True), exp)
1164         self.assertEqual(
1165             seq.frequencies(chars=seq.observed_chars, relative=True),
1166             exp)
1167     def test_frequencies_invalid_chars(self):
1168         seq = Sequence('abcabc')
1169         with self.assertRaisesRegex(ValueError, r'0 characters'):
1170             seq.frequencies(chars='')
1171         with self.assertRaisesRegex(ValueError, r'0 characters'):
1172             seq.frequencies(chars={''})
1173         with self.assertRaisesRegex(ValueError, r'2 characters'):
1174             seq.frequencies(chars='ab')
1175         with self.assertRaisesRegex(ValueError, r'2 characters'):
1176             seq.frequencies(chars={'b', 'ab'})
1177         with self.assertRaisesRegex(TypeError, r'string.*NoneType'):
1178             seq.frequencies(chars={'a', None})
1179         with self.assertRaisesRegex(ValueError, r'outside the range'):
1180             seq.frequencies(chars='\u1F30')
1181         with self.assertRaisesRegex(ValueError, r'outside the range'):
1182             seq.frequencies(chars={'c', '\u1F30'})
1183         with self.assertRaisesRegex(TypeError, r'set.*int'):
1184             seq.frequencies(chars=42)
1185     def _compare_kmers_results(self, observed, expected):
1186         for obs, exp in itertools.zip_longest(observed, expected,
1187                                               fillvalue=None):
1188     def test_iter_kmers(self):
1189         seq = Sequence('GATTACA', positional_metadata<font color="#348781"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'quality': range(7)})
1190             Sequence('G', positional_metadata={'quality': [0]}),
1191             Sequence('A', positional_metadata={'quality': [1]}),
1192             Sequence(</b></font>'T', positional_metadata<font color="#810541"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'quality': [2]}),
1193             Sequence('T', positional_metadata={'quality': [3]}),
1194             Sequence('A', positional_metadata={'quality': [4]}),
1195             Sequence('C', positional_metadata={'quality': [5]}),
1196             Sequence(</b></font>'A', positional_metadata={'quality': [6]})
1197         ]
1198         self._compare_kmers_results(
1199             seq.iter_kmers(1, overlap=False), expected)
1200         expected = [
1201             Sequence('GA', positional_metadata={'quality': [0, 1]}),
1202             Sequence('TT', positional_metadata={'quality': [2, 3]}),
1203             Sequence('AC', positional_metadata={'quality': [4, 5]})
1204         ]
1205         self._compare_kmers_results(
1206             seq.iter_kmers(2, overlap=False), expected)
1207         expected = [
1208             Sequence('GAT', positional_metadata={'quality': [0, 1, 2]}),
1209             Sequence('TAC', positional_metadata={'quality': [3, 4, 5]})
1210         ]
1211         self._compare_kmers_results(
1212             seq.iter_kmers(3, overlap=False), expected)
1213         expected = [
1214                      positional_metadata={'quality': [0, 1, 2, 3, 4, 5, 6]})
1215         ]
1216         self<font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._compare_kmers_results(
1217             seq.iter_kmers(7, overlap=False), expected)
1218         expected = []
1219         self._compare_kmers_results(
1220             seq.iter_kmers(8, overlap=False), expected)
1221         self.assertIs(</b></font>type(seq.iter_kmers(1)), GeneratorType)
1222     def test_iter_kmers_no_positional_metadata(self):
1223         seq = Sequence('GATTACA')
1224         expected = [
1225             Sequence('G'),
1226             Sequence('A'),
1227             Sequence('T'),
1228             Sequence('T'),
1229             Sequence('A'),
1230             Sequence('C'),
1231             Sequence('A')
1232         ]
1233         self._compare_kmers_results(
1234             seq.iter_kmers(1, overlap=False), expected)
1235         expected = [
1236             Sequence('GA'),
1237             Sequence('TT'),
1238             Sequence('AC')
1239         ]
1240         self._compare_kmers_results(
1241             seq.iter_kmers(2, overlap=False), expected)
1242         expected = [
1243             Sequence('GAT'),
1244             Sequence('TAC')
1245         ]
1246         self._compare_kmers_results(
1247             seq.iter_kmers(3, overlap=False), expected)
1248             Sequence('GATTACA')
1249         ]
1250         self<font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._compare_kmers_results(
1251             seq.iter_kmers(7, overlap=False), expected)
1252         expected = []
1253         self._compare_kmers_results(
1254             seq.iter_kmers(8, overlap=False), expected)
1255     def test_iter_kmers_with_overlap(self):
1256         seq = Sequence('GATTACA', positional_metadata={<font color="#ff00ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'quality': range(7)})
1257         expected = [
1258             Sequence('G', positional_metadata={'quality': [0]}),
1259             Sequence('A', positional_metadata={'quality': [1]}),
1260             Sequence('T', positional_metadata=</b></font>{'quality': [2]}),
1261             Sequence('T', positional_metadata={'quality': [3]}),
1262             Sequence('A', positional_metadata={'quality': [4]}),
1263             Sequence('C', positional_metadata={'quality': [5]}),
1264             Sequence('A', positional_metadata={'quality': [6]})
1265         ]
1266         self._compare_kmers_results(
1267             seq.iter_kmers(1, overlap=True), expected)
1268         expected = [
1269             Sequence('GA', positional_metadata={'quality': [0, 1]}),
1270             Sequence('AT', positional_metadata={'quality': [1, 2]}),
1271             Sequence('TT', positional_metadata={'quality': [2, 3]}),
1272             Sequence('TA', positional_metadata={'quality': [3, 4]}),
1273             Sequence('AC', positional_metadata={'quality': [4, 5]}),
1274             Sequence('CA', positional_metadata={'quality': [5, 6]})
1275         ]
1276         self._compare_kmers_results(
1277             seq.iter_kmers(2, overlap=True), expected)
1278         expected = [
1279             Sequence('GAT', positional_metadata={'quality': [0, 1, 2]}),
1280             Sequence('ATT', positional_metadata={'quality': [1, 2, 3]}),
1281             Sequence('TTA', positional_metadata={'quality': [2, 3, 4]}),
1282             Sequence('TAC', positional_metadata={'quality': [3, 4, 5]}),
1283             Sequence('ACA', positional_metadata={'quality': [4, 5, 6]})
1284         ]
1285         self._compare_kmers_results(
1286             seq.iter_kmers(3, overlap=True), expected)
1287         expected = [
1288             Sequence('GATTACA',
1289                      positional_metadata={'quality': [0, 1, 2, 3, 4, 5, 6]})
1290         ]
1291         self._compare_kmers_results(
1292             seq.iter_kmers(7, overlap=True), expected)
1293         expected = []
1294         self._compare_kmers_results(
1295             seq.iter_kmers(8, overlap=True), expected)
1296         self.assertIs(type(seq.iter_kmers(1)), GeneratorType)
1297     def test_iter_kmers_with_overlap_no_positional_metadata(self):
1298         seq = Sequence('GATTACA')
1299         expected = [
1300             Sequence('G'),
1301             Sequence('A'),
1302             Sequence('T'),
1303             Sequence('T'),
1304             Sequence('A'),
1305             Sequence('C'),
1306             Sequence('A')
1307         ]
1308         self._compare_kmers_results(
1309             seq.iter_kmers(1, overlap=True), expected)
1310         expected = [
1311             Sequence('GA'),
1312             Sequence('AT'),
1313             Sequence('TT'),
1314             Sequence('TA'),
1315             Sequence('AC'),
1316             Sequence('CA')
1317         ]
1318         self._compare_kmers_results(
1319             seq.iter_kmers(2, overlap=True), expected)
1320         expected = [
1321             Sequence('GAT'),
1322             Sequence('ATT'),
1323             Sequence('TTA'),
1324             Sequence('TAC'),
1325             Sequence('ACA')
1326         ]
1327         self._compare_kmers_results(
1328             seq.iter_kmers(3, overlap=True), expected)
1329         expected = [
1330             Sequence('GATTACA')
1331         ]
1332         self._compare_kmers_results(
1333             seq.iter_kmers(7, overlap=True), expected)
1334         expected = []
1335         self._compare_kmers_results(
1336             seq.iter_kmers(8, overlap=True), expected)
1337         self.assertIs(type(seq.iter_kmers(1)), GeneratorType)
1338     def test_iter_kmers_invalid_k(self):
1339         seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})
1340         with self.assertRaises(ValueError):
1341             list(seq.iter_kmers(0))
1342         with self.assertRaises(ValueError):
1343             list(seq.iter_kmers(-42))
1344     def test_iter_kmers_invalid_k_no_positional_metadata(self):
1345         seq = Sequence('GATTACA')
1346         with self.assertRaises(ValueError):
1347             list(seq.iter_kmers(0))
1348         with self.assertRaises(ValueError):
1349             list(seq.iter_kmers(-42))
1350     def test_iter_kmers_different_sequences(self):
1351         seq = Sequence('HE..--..LLO',
1352                        metadata={'id': 'hello', 'desc': 'gapped hello'},
1353                        positional_metadata={'quality': range(11)})
1354         expected = [
1355             Sequence('HE.', positional_metadata={'quality': [0, 1, 2]},
1356                      metadata={'id': 'hello', 'desc': 'gapped hello'}),
1357             Sequence('.--', positional_metadata={'quality': [3, 4, 5]},
1358                      metadata={'id': 'hello', 'desc': 'gapped hello'}),
1359             Sequence('..L', positional_metadata={'quality': [6, 7, 8]},
1360                      metadata={'id': 'hello', 'desc': 'gapped hello'})
1361         ]
1362         self._compare_kmers_results(seq.iter_kmers(3, overlap=False), expected)
1363     def test_iter_kmers_different_sequences_no_positional_metadata(self):
1364         seq = Sequence('HE..--..LLO',
1365                        metadata<font color="#41a317"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={'id': 'hello', 'desc': 'gapped hello'})
1366         expected = [
1367             Sequence('HE.',
1368                      metadata={'id': 'hello', 'desc': 'gapped hello'}),
1369             Sequence('.--',
1370                      metadata={'id': 'hello', 'desc': 'gapped hello'}),
1371             Sequence('..L',
1372                      metadata=</b></font>{'id': 'hello', 'desc': 'gapped hello'})
1373         ]
1374         self._compare_kmers_results(seq.iter_kmers(3, overlap=False), expected)
1375     def test_iter_kmers_empty_sequence(self):
1376         seq = Sequence('')
1377         expected = []
1378         self._compare_kmers_results(seq.iter_kmers(3, overlap=False), expected)
1379     def test_iter_kmers_empty_sequence_with_positional_metadata(self):
1380         seq = Sequence('', positional_metadata={'quality': []})
1381         expected = []
1382         self._compare_kmers_results(seq.iter_kmers(3, overlap=False), expected)
1383     def test_kmer_frequencies_empty_sequence(self):
1384         self.assertEqual(seq.kmer_frequencies(1), {})
1385         self<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq.kmer_frequencies(1, overlap=False), {})
1386         self.assertEqual(seq.kmer_frequencies(1, relative=True), {})
1387         self.assertEqual(seq.kmer_frequencies(1, relative=</b></font>True, overlap=False),
1388                          {})
1389     def test_kmer_frequencies(self):
1390         seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})
1391         expected = {'G': 1, 'A': 3, 'T': 2, 'C': 1}
1392         self.assertEqual(seq.kmer_frequencies(1, overlap=True), expected)
1393         expected = {'GAT': 1, 'ATT': 1, 'TTA': 1, 'TAC': 1, 'ACA': 1}
1394         expected = {}
1395         self.assertEqual(seq.kmer_frequencies(8, overlap<font color="#827d6b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=True), expected)
1396         expected = {'GAT': 1, 'TAC': 1}
1397         self.assertEqual(seq.kmer_frequencies(3, overlap=False), expected)
1398         expected = {'GATTACA': 1}
1399         self.assertEqual(</b></font>seq.kmer_frequencies(7, overlap=False), expected)
1400         expected = {}
1401         self.assertEqual(seq.kmer_frequencies(8, overlap=False), expected)
1402     def test_kmer_frequencies_relative(self):
1403         seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})
1404         expected = {'A': 3/7, 'C': 1/7, 'G': 1/7, 'T': 2/7}
1405         self.assertEqual(seq.kmer_frequencies(1, overlap=True, relative=True),
1406                          expected)
1407         expected = {'GAT': 1/5, 'ATT': 1/5, 'TTA': 1/5, 'TAC': 1/5, 'ACA': 1/5}
1408         self.assertEqual(seq.kmer_frequencies(3, overlap=True, relative=True),
1409                          expected)
1410         expected = {}
1411         self.assertEqual(seq.kmer_frequencies(8, overlap=True, relative=True),
1412                          expected)
1413         expected = {'GAT': 1/2, 'TAC': 1/2}
1414         self.assertEqual(seq.kmer_frequencies(3, overlap=False, relative=True),
1415                          expected)
1416         expected = {'GATTACA': 1.0}
1417         self.assertEqual(seq.kmer_frequencies(7, overlap=False, relative=True),
1418                          expected)
1419         expected = {}
1420         self.assertEqual(seq.kmer_frequencies(8, overlap=False, relative=True),
1421                          expected)
1422     def test_kmer_frequencies_floating_point_precision(self):
1423         seq = Sequence('AAAAAAAAAA')
1424         self.assertEqual(seq.kmer_frequencies(1, relative=True), {'A': 1.0})
1425     def test_find_with_regex(self):
1426         seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})
1427         pat = re.compile('(T+A)(CA)')
1428         obs = list(seq.find_with_regex(pat))
1429         exp = [slice(2, 5), slice(5, 7)]
1430         self.assertEqual(obs, exp)
1431         self.assertIs(type(seq.find_with_regex(pat)), GeneratorType)
1432     def test_find_with_regex_string_as_input(self):
1433         seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})
1434         pat = '(T+A)(CA)'
1435         obs = list(seq.find_with_regex(pat))
1436         exp = [slice(2, 5), slice(5, 7)]
1437         self.assertEqual(obs, exp)
1438         self.assertIs(type(seq.find_with_regex(pat)), GeneratorType)
1439     def test_find_with_regex_no_groups(self):
1440         seq = Sequence('GATTACA', positional_metadata={'quality': range(7)})
1441         pat = re.compile('(FOO)')
1442         self.assertEqual(list(seq.find_with_regex(pat)), [])
1443     def test_find_with_regex_ignore_no_difference(self):
1444         pat = "([A-Z]+)"
1445         exp = [slice(2, 9)]
1446         self.assertEqual(list(seq<font color="#736aff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.find_with_regex(pat)), exp)
1447         obs = seq.find_with_regex(
1448             pat, ignore=np.array([1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
1449                                  dtype=bool))
1450         self.assertEqual(</b></font>list(obs), exp)
1451     def test_find_with_regex_ignore(self):
1452         obs = Sequence('A..A..BBAAB.A..AB..A.').find_with_regex(
1453             "(A+)", ignore=np.array([0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1,
1454                                      1, 0, 0, 1, 1, 0, 1], dtype=bool))
1455         self.assertEqual(list(obs), [slice(0, 4), slice(8, 10), slice(12, 16),
1456                                      slice(19, 20)])
1457     def test_find_with_regex_ignore_index_array(self):
1458         obs = Sequence('A..A..BBAAB.A..AB..A.').find_with_regex(
1459             "(A+)", ignore=np.array([1, 2, 4, 5, 11, 13, 14, 17, 18, 20]))
1460         self.assertEqual(list(obs), [slice(0, 4), slice(8, 10), slice(12, 16),
1461                                      slice(19, 20)])
1462     def test_iter_contiguous_index_array(self):
1463         s = Sequence("0123456789abcdef")
1464         for c in list, tuple, np.array, pd.Series:
1465             exp = [Sequence("0123"), Sequence("89ab")]
1466             obs = s.iter_contiguous(c([0, 1, 2, 3, 8, 9, 10, 11]))
1467             self.assertEqual(list(obs), exp)
1468     def test_iter_contiguous_boolean_vector(self):
1469         s = Sequence("0123456789abcdef")
1470         for c in list, tuple, np.array, pd.Series:
1471             exp = [Sequence("0123"), Sequence("89ab")]
1472             obs = s.iter_contiguous(c(([True] * 4 + [False] * 4) * 2))
1473             self.assertEqual(list(obs), exp)
1474     def test_iter_contiguous_iterable_slices(self):
1475         def spaced_out():
1476             yield slice(0, 4)
1477             yield slice(8, 12)
1478         def contiguous():
1479             yield slice(0, 4)
1480             yield slice(4, 8)
1481             yield slice(12, 16)
1482         s = Sequence("0123456789abcdef")
1483         for c in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
1484                   lambda x: pd.Series(tuple(x))):
1485             exp = [Sequence("0123"), Sequence("89ab")]
1486             obs = s.iter_contiguous(c(spaced_out()))
1487             self.assertEqual(list(obs), exp)
1488             exp = [Sequence("01234567"), Sequence("cdef")]
1489             obs = s.iter_contiguous(c(contiguous()))
1490             self.assertEqual(list(obs), exp)
1491     def test_iter_contiguous_with_max_length(self):
1492         s = Sequence("0123456789abcdef")
1493         for c in list, tuple, np.array, pd.Series:
1494             exp = [Sequence("234"), Sequence("678"), Sequence("abc")]
1495             obs = s.iter_contiguous(c([True, False, True, True] * 4),
1496                                     min_length=3)
1497             self.assertEqual(list(obs), exp)
1498             exp = [Sequence("0"), Sequence("234"), Sequence("678"),
1499                    Sequence("abc"), Sequence("ef")]
1500             obs1 = list(s.iter_contiguous(c([True, False, True, True] * 4),
1501                                           min_length=1))
1502             obs2 = list(s.iter_contiguous(c([True, False, True, True] * 4)))
1503             self.assertEqual(obs1, obs2)
1504             self.assertEqual(obs1, exp)
1505     def test_iter_contiguous_with_invert(self):
1506         def spaced_out():
1507             yield slice(0, 4)
1508             yield slice(8, 12)
1509         def contiguous():
1510             yield slice(0, 4)
1511             yield slice(4, 8)
1512             yield slice(12, 16)
1513         s = Sequence("0123456789abcdef")
1514         for c in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
1515                   lambda x: pd.Series(tuple(x))):
1516             exp = [Sequence("4567"), Sequence("cdef")]
1517             obs = s.iter_contiguous(c(spaced_out()), invert=True)
1518             self.assertEqual(list(obs), exp)
1519             exp = [Sequence("89ab")]
1520             obs = s.iter_contiguous(c(contiguous()), invert=True)
1521             self.assertEqual(list(obs), exp)
1522     def test_copy_without_metadata(self):
1523         for copy_method in copy.copy, copy.deepcopy:
1524             seq = Sequence('ACGT')
1525             seq_copy = copy_method(seq)
1526             self.assertEqual(seq_copy, seq)
1527             self.assertIsNot(seq_copy, seq)
1528             self.assertIsNot(seq_copy._bytes, seq._bytes)
1529     def test_copy_with_metadata_shallow(self):
1530         seq = Sequence('ACGT', metadata={'foo': [1]},
1531                        positional_metadata={'bar': [[], [], [], []],
1532         seq.interval_metadata.add([(0, 3)], metadata={'gene': ['sagA']})
1533         seq_copy = copy<font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.copy(seq)
1534         self.assertEqual(seq_copy, seq)
1535         self.assertIsNot(seq_copy._bytes, seq._bytes)
1536         self.assertIsNot(seq_copy.</b></font>_metadata, seq._metadata)
1537         self.assertIsNot<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq_copy._positional_metadata,
1538                          seq._positional_metadata)
1539         self.assertIsNot(seq_copy._positional_metadata.values,
1540                          seq._positional_metadata.values)
1541         self.assertIs(seq_copy._positional_metadata.loc[0, 'bar'],
1542                       seq.</b></font>_positional_metadata.loc[0, 'bar'])
1543         self.assertIsNot<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq_copy.interval_metadata, seq.interval_metadata)
1544         self.assertIsNot(seq_copy.interval_metadata._intervals[0],
1545                          seq.interval_metadata._intervals[0])
1546         self.assertIsNot(seq_copy.interval_metadata._intervals[0].metadata,
1547                          seq.interval_metadata._intervals[</b></font>0].metadata)
1548         self.assertIs(
1549             seq_copy.interval_metadata._intervals[0].metadata['gene'],
1550             seq.interval_metadata._intervals[0].metadata['gene'])
1551         seq_copy.metadata['foo2'] = 42
1552         self.assertEqual(seq_copy<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.metadata, {'foo': [1, 2], 'foo2': 42})
1553         self.assertEqual(seq.metadata, {'foo': [1, 2]})
1554         seq_copy.positional_metadata.loc[</b></font>0, 'baz'] = 43
1555         assert_data_frame_almost_equal<font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
1556             seq_copy.positional_metadata,
1557             pd.DataFrame({'bar': [[1], [], [], []],
1558                           'baz': [43, 42, 42, 42]}))
1559         assert_data_frame_almost_equal(
1560             seq.positional_metadata,
1561             pd.DataFrame({'bar': [[1], [], [], []],
1562                           'baz': [42</b></font>, 42, 42, 42]}))
1563     def test_copy_with_metadata_deep(self):
1564         seq = Sequence('ACGT', metadata={'foo': [1]},
1565                                             'baz': [42, 42, 42, 42]})
1566         seq.interval_metadata.add([(0, 3)], metadata={'gene': ['sagA']})
1567         seq_copy = copy.deepcopy<font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq)
1568         self.assertEqual(seq_copy, seq)
1569         self.assertIsNot(seq_copy._bytes, seq._bytes)
1570         self.assertIsNot(seq_copy._metadata, seq.</b></font>_metadata)
1571         self.assertIsNot(seq_copy<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._positional_metadata,
1572                          seq._positional_metadata)
1573         self.assertIsNot(seq_copy._positional_metadata.values,
1574                          seq._positional_metadata.values)
1575         self.assertIsNot(seq_copy._positional_metadata.loc[0, 'bar'],
1576                          seq._positional_metadata.</b></font>loc[0, 'bar'])
1577         self.assertIsNot<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(seq_copy.interval_metadata, seq.interval_metadata)
1578         self.assertIsNot(seq_copy.interval_metadata._intervals[0],
1579                          seq.interval_metadata._intervals[0])
1580         self.assertIsNot(seq_copy.interval_metadata._intervals[0].metadata,
1581                          seq.interval_metadata._intervals[</b></font>0].metadata)
1582         self.assertIsNot(
1583             seq_copy.interval_metadata._intervals[0].metadata['gene'],
1584             seq.interval_metadata._intervals[0].metadata['gene'])
1585         seq_copy.metadata['foo2'] = 42
1586         self<font color="#5b8daf"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(seq_copy.metadata, {'foo': [1, 2], 'foo2': 42})
1587         self.assertEqual(seq.metadata, {'foo': [1]})
1588         seq_copy.positional_metadata.loc[0, 'baz'] = 43
1589         assert_data_frame_almost_equal<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
1590             seq_copy.positional_metadata,
1591             pd.DataFrame({'bar': [[1], [], [], []],
1592                           'baz': [43, 42, 42, 42]}))
1593         assert_data_frame_almost_equal(
1594             seq.positional_metadata,
1595             pd.DataFrame({'bar': [[], [], [], []],
1596                           'baz': [42</b></font>, 42, 42, 42]}))
1597     def test_copy_preserves_read_only_flag_on_bytes(self):
1598         seq = Sequence('ACGT')
1599         seq_copy = copy.copy(seq)
1600         with self.assertRaises(ValueError):
1601             seq_copy._bytes[0] = 'B'
1602     def test_deepcopy_memo_is_respected(self):
1603         seq = Sequence('ACGT', metadata={'foo': 'bar'})
1604         memo = {}
1605         copy.deepcopy(seq, memo)
1606         self.assertGreater(len(memo), 2)
1607     def test_munge_to_index_array_valid_index_array(self):
1608         s = Sequence('123456')
1609         for c in list, tuple, np.array, pd.Series:
1610             exp = np.array([1, 2, 3], dtype=int)
1611             obs = s._munge_to_index_array(c([1, 2, 3]))
1612             npt.assert_equal(obs, exp)
1613             exp = np.array([1, 3, 5], dtype=int)
1614             obs = s._munge_to_index_array(c([1, 3, 5]))
1615             npt.assert_equal(obs, exp)
1616     def test_munge_to_index_array_invalid_index_array(self):
1617         s = Sequence("12345678")
1618         for c in list, tuple, np.array, pd.Series:
1619             with self.assertRaises(ValueError):
1620                 s._munge_to_index_array(c([3, 2, 1]))
1621             with self.assertRaises(ValueError):
1622                 s._munge_to_index_array(c([5, 6, 7, 2]))
1623             with self.assertRaises(ValueError):
1624                 s._munge_to_index_array(c([0, 1, 2, 1]))
1625     def test_munge_to_index_array_valid_bool_array(self):
1626         s = Sequence('123456')
1627         for c in list, tuple, np.array, pd.Series:
1628             exp = np.array([2, 3, 5], dtype=int)
1629             obs = s._munge_to_index_array(
1630                 c([False, False, True, True, False, True]))
1631             npt.assert_equal(obs, exp)
1632             exp = np.array([], dtype=int)
1633             obs = s._munge_to_index_array(
1634                 c([False] * 6))
1635             npt.assert_equal(obs, exp)
1636             exp = np.arange(6)
1637             obs = s._munge_to_index_array(
1638                 c([True] * 6))
1639             npt.assert_equal(obs, exp)
1640     def test_munge_to_index_array_invalid_bool_array(self):
1641         s = Sequence('123456')
1642         for c in (list, tuple, lambda x: np.array(x, dtype=bool),
1643                   lambda x: pd.Series(x, dtype=bool)):
1644             with self.assertRaises(ValueError):
1645                 s._munge_to_index_array(c([]))
1646             with self.assertRaises(ValueError):
1647                 s._munge_to_index_array(c([True]))
1648             with self.assertRaises(ValueError):
1649                 s._munge_to_index_array(c([True] * 10))
1650     def test_munge_to_index_array_valid_iterable(self):
1651         s = Sequence('')
1652         def slices_only():
1653             return (slice(i, i+1) for i in range(0, 10, 2))
1654         def mixed():
1655             return (slice(i, i+1) if i % 2 == 0 else i for i in range(10))
1656         def unthinkable():
1657             for i in range(10):
1658                 if i % 3 == 0:
1659                     yield slice(i, i+1)
1660                 elif i % 3 == 1:
1661                     yield i
1662                 else:
1663                     yield np.array([i], dtype=int)
1664         for c in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
1665                   lambda x: pd.Series(tuple(x))):
1666             exp = np.arange(10, dtype=int)
1667             obs = s._munge_to_index_array(c(mixed()))
1668             npt.assert_equal(obs, exp)
1669             exp = np.arange(10, dtype=int)
1670             obs = s._munge_to_index_array(c(unthinkable()))
1671             npt.assert_equal(obs, exp)
1672             exp = np.arange(10, step=2, dtype=int)
1673             obs = s._munge_to_index_array(c(slices_only()))
1674             npt.assert_equal(obs, exp)
1675     def test_munge_to_index_array_invalid_iterable(self):
1676         s = Sequence('')
1677         def bad1():
1678             yield "r"
1679             yield [1, 2, 3]
1680         def bad2():
1681             yield 1
1682             yield 'str'
1683         def bad3():
1684             yield False
1685             yield True
1686             yield 2
1687         def bad4():
1688             yield np.array([False, True])
1689             yield slice(2, 5)
1690         for c in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),
1691                   lambda x: pd.Series(tuple(x))):
1692             with self.assertRaises(TypeError):
1693                 s._munge_to_index_array(bad1())
1694             with self.assertRaises(TypeError):
1695                 s._munge_to_index_array(bad2())
1696             with self.assertRaises(TypeError):
1697                 s._munge_to_index_array(bad3())
1698             with self.assertRaises(TypeError):
1699                 s._munge_to_index_array(bad4())
1700     def test_munge_to_index_array_valid_string(self):
1701         seq = Sequence('ACGTACGT',
1702                        positional_metadata={'introns': [False, True, True,
1703                                                         False, False, True,
1704                                                         False, False]})
1705         npt.assert_equal(np.array([1, 2, 5]),
1706                          seq._munge_to_index_array('introns'))
1707         seq.positional_metadata['exons'] = ~seq.positional_metadata['introns']
1708         npt.assert_equal(np.array([0, 3, 4, 6, 7]),
1709                          seq._munge_to_index_array('exons'))
1710     def test_munge_to_index_array_invalid_string(self):
1711         seq_str = 'ACGT'
1712         seq = Sequence(seq_str,
1713                        positional_metadata={'quality': range(len(seq_str))})
1714         with self.assertRaisesRegex(ValueError,
1715                                     r"No positional metadata associated with "
1716                                     "key 'introns'"):
1717             seq._munge_to_index_array('introns')
1718         with self.assertRaisesRegex(TypeError,
1719                                     r"Column 'quality' in positional metadata "
1720                                     "does not correspond to a boolean "
1721                                     "vector"):
1722             seq._munge_to_index_array('quality')
1723     def test_munge_to_bytestring_return_bytes(self):
1724         seq = Sequence('')
1725         m = 'dummy_method'
1726         str_inputs = ('', 'a', 'acgt')
1727         unicode_inputs = ('', 'a', 'acgt')
1728         byte_inputs = (b'', b'a', b'acgt')
1729         seq_inputs = (Sequence(''), Sequence('a'), Sequence('acgt'))
1730         all_inputs = str_inputs + unicode_inputs + byte_inputs + seq_inputs
1731         all_expected = [b'', b'a', b'acgt'] * 4
1732         for input_, expected in zip(all_inputs, all_expected):
1733             observed = seq._munge_to_bytestring(input_, m)
1734             self.assertEqual(observed, expected)
1735             self.assertIs(type(observed), bytes)
1736     def test_munge_to_bytestring_unicode_out_of_ascii_range(self):
1737         seq = Sequence('')
1738         all_inputs = ('\x80', 'abc\x80', '\x80abc')
1739         for input_ in all_inputs:
1740             with self.assertRaisesRegex(UnicodeEncodeError,
1741                                         r"'ascii' codec can't encode character"
1742                                         r".*in position.*: ordinal not in"
1743                                         r" range\(128\)"):
1744                 seq._munge_to_bytestring(input_, 'dummy_method')
1745 class TestDistance(TestSequenceBase):
1746     def test_mungeable_inputs_to_sequence(self):
1747         def metric(a, b):
1748             self.assertEqual(a, Sequence("abcdef"))
1749             self.assertEqual(b, Sequence("12bcef"))
1750             return 42.0
1751         for constructor in self.sequence_kinds:
1752             seq1 = Sequence("abcdef")
1753             seq2 = constructor("12bcef")
1754             distance = seq1.distance(seq2, metric=metric)
1755             self.assertEqual(distance, 42.0)
1756     def test_mungeable_inputs_to_sequence_subclass(self):
1757         def metric(a, b):
1758             self.assertEqual(a, SequenceSubclass("abcdef"))
1759             self.assertEqual(b, SequenceSubclass("12bcef"))
1760             return -42.0
1761         sequence_kinds = frozenset([
1762             str, SequenceSubclass,
1763             lambda s: np.frombuffer(s.encode('ascii'), dtype='|S1'),
1764             lambda s: np.frombuffer(s.encode('ascii'), dtype=np.uint8)])
1765         for constructor in sequence_kinds:
1766             seq1 = SequenceSubclass("abcdef")
1767             seq2 = constructor("12bcef")
1768             distance = seq1.distance(seq2, metric=metric)
1769             self.assertEqual(distance, -42.0)
1770     def test_sequence_type_mismatch(self):
1771         seq1 = SequenceSubclass("abcdef")
1772         seq2 = Sequence("12bcef")
1773         with self.assertRaisesRegex(TypeError,
1774                                     r'SequenceSubclass.*Sequence.*`distance`'):
1775             seq1.distance(seq2)
1776         with self.assertRaisesRegex(TypeError,
1777                                     r'Sequence.*SequenceSubclass.*`distance`'):
1778             seq2.distance(seq1)
1779     def test_munging_invalid_characters_to_self_type(self):
1780         with self.assertRaisesRegex(ValueError, r'Invalid characters.*X'):
1781             DNA("ACGT").distance("WXYZ")
1782     def test_munging_invalid_type_to_self_type(self):
1783         with self.assertRaises(TypeError):
1784             Sequence("ACGT").distance(42)
1785     def test_return_type_coercion(self):
1786         def metric(a, b):
1787             return 42
1788         distance = Sequence('abc').distance('cba', metric=metric)
1789         self.assertIsInstance(distance, float)
1790     def test_invalid_return_type(self):
1791         def metric(a, b):
1792             return 'too far'
1793         with self.assertRaisesRegex(ValueError, r'string.*float'):
1794             Sequence('abc').distance('cba', metric=metric)
1795     def test_arbitrary_metric(self):
1796         def metric(x, y):
1797             return len(x) ** 2 + len(y) ** 2
1798         seq1 = Sequence("12345678")
1799         seq2 = Sequence("1234")
1800         distance = seq1.distance(seq2, metric=metric)
1801         self.assertEqual(distance, 80.0)
1802     def test_scipy_hamming_metric_with_metadata(self):
1803         seqs1 = [
1804             Sequence("ACGT"),
1805             Sequence("ACGT", metadata={'id': 'abc'}),
1806             Sequence("ACGT", positional_metadata={'qual': range(4)})
1807         ]
1808         seqs2 = [
1809             Sequence("AAAA"),
1810             Sequence("AAAA", metadata={'id': 'def'}),
1811             Sequence("AAAA", positional_metadata={'qual': range(4, 8)})
1812         ]
1813         for seqs in seqs1, seqs2:
1814             for seq1, seq2 in itertools.product(seqs, repeat=2):
1815                 distance = seq1.distance(seq2,
1816                                          metric=scipy.spatial.distance.hamming)
1817                 self.assertEqual(distance, 0.0)
1818         for seq1, seq2 in itertools.product(seqs1, seqs2):
1819             distance = seq1.distance(seq2,
1820                                      metric=scipy.spatial.distance.hamming)
1821             self.assertEqual(distance, 0.75)
1822     def test_default_metric_with_metadata(self):
1823         seqs1 = [
1824             Sequence("ACGT"),
1825             Sequence("ACGT", metadata={'id': 'abc'}),
1826             Sequence("ACGT", positional_metadata={'qual': range(4)})
1827         ]
1828         seqs2 = [
1829             Sequence("AAAA"),
1830             Sequence("AAAA", metadata={'id': 'def'}),
1831             Sequence("AAAA", positional_metadata={'qual': range(4, 8)})
1832         ]
1833         for seqs in seqs1, seqs2:
1834             for seq1, seq2 in itertools.product(seqs, repeat=2):
1835                 distance = seq1.distance(seq2)
1836                 self.assertEqual(distance, 0.0)
1837         for seq1, seq2 in itertools.product(seqs1, seqs2):
1838             distance = seq1.distance(seq2)
1839             self.assertEqual(distance, 0.75)
1840     def test_default_metric_matches_hamming(self):
1841         seq1 = Sequence("abcdef")
1842         seq2 = Sequence("12bcef")
1843         seq_wrong = Sequence("abcdefghijklmnop")
1844         distance1 = seq1.distance(seq2)
1845         distance2 = skbio.sequence.distance.hamming(seq1, seq2)
1846         self.assertEqual(distance1, distance2)
1847         with self.assertRaises(ValueError):
1848             seq1.distance(seq_wrong)
1849         with self.assertRaises(ValueError):
1850             seq_wrong.distance(seq1)
1851 class SequenceReprDoctests:
1852     r"""&gt;&gt;&gt; import pandas as pd
1853     &gt;&gt;&gt; from skbio import Sequence
1854     Empty (minimal) sequence:
1855     &gt;&gt;&gt; Sequence('')
1856     Sequence
1857     -------------
1858     Stats:
1859         length: 0
1860     -------------
1861     Single character sequence:
1862     &gt;&gt;&gt; Sequence('G')
1863     Sequence
1864     -------------
1865     Stats:
1866         length: 1
1867     -------------
1868     0 G
1869     Multicharacter sequence:
1870     &gt;&gt;&gt; Sequence('ACGT')
1871     Sequence
1872     -------------
1873     Stats:
1874         length: 4
1875     -------------
1876     0 ACGT
1877     Full single line:
1878     &gt;&gt;&gt; Sequence('A' * 60)
1879     Sequence
1880     -------------------------------------------------------------------
1881     Stats:
1882         length: 60
1883     -------------------------------------------------------------------
1884     0 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1885     Full single line with 1 character overflow:
1886     &gt;&gt;&gt; Sequence('A' * 61)
1887     Sequence
1888     --------------------------------------------------------------------
1889     Stats:
1890         length: 61
1891     --------------------------------------------------------------------
1892     0  AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1893     60 A
1894     Two full lines:
1895     &gt;&gt;&gt; Sequence('T' * 120)
1896     Sequence
1897     --------------------------------------------------------------------
1898     Stats:
1899         length: 120
1900     --------------------------------------------------------------------
1901     0  TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT
1902     60 TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT
1903     Two full lines with 1 character overflow:
1904     &gt;&gt;&gt; Sequence('T' * 121)
1905     Sequence
1906     ---------------------------------------------------------------------
1907     Stats:
1908         length: 121
1909     ---------------------------------------------------------------------
1910     0   TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT
1911     60  TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT TTTTTTTTTT
1912     120 T
1913     Five full lines (maximum amount of information):
1914     &gt;&gt;&gt; Sequence('A' * 300)
1915     Sequence
1916     ---------------------------------------------------------------------
1917     Stats:
1918         length: 300
1919     ---------------------------------------------------------------------
1920     0   AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1921     60  AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1922     120 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1923     180 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1924     240 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1925     Six lines starts "summarized" output:
1926     &gt;&gt;&gt; Sequence('A' * 301)
1927     Sequence
1928     ---------------------------------------------------------------------
1929     Stats:
1930         length: 301
1931     ---------------------------------------------------------------------
1932     0   AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1933     60  AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1934     ...
1935     240 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1936     300 A
1937     A naive algorithm would assume the width of the first column (noting
1938     position) based on the sequence's length alone. This can be off by one if
1939     the last position (in the last line) has a shorter width than the width
1940     calculated from the sequence's length. This test case ensures that only a
1941     single space is inserted between position 99960 and the first sequence
1942     chunk:
1943     &gt;&gt;&gt; Sequence('A' * 100000)
1944     Sequence
1945     -----------------------------------------------------------------------
1946     Stats:
1947         length: 100000
1948     -----------------------------------------------------------------------
1949     0     AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1950     60    AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1951     ...
1952     99900 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1953     99960 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1954     The largest sequence that can be displayed using six chunks per line:
1955     &gt;&gt;&gt; Sequence('A' * 100020)
1956     Sequence
1957     -----------------------------------------------------------------------
1958     Stats:
1959         length: 100020
1960     -----------------------------------------------------------------------
1961     0     AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1962     60    AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1963     ...
1964     99900 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1965     99960 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1966     A single character longer than the previous sequence causes the optimal
1967     number of chunks per line to be 5:
1968     &gt;&gt;&gt; Sequence('A' * 100021)
1969     Sequence
1970     -------------------------------------------------------------
1971     Stats:
1972         length: 100021
1973     -------------------------------------------------------------
1974     0      AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1975     50     AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1976     ...
1977     99950  AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA AAAAAAAAAA
1978     100000 AAAAAAAAAA AAAAAAAAAA A
1979     Wide range of characters (locale-independent):
1980     &gt;&gt;&gt; import string
1981     &gt;&gt;&gt; Sequence((string.ascii_letters + string.punctuation + string.digits +
1982     ...          'a space') * 567)
1983     Sequence
1984     -----------------------------------------------------------------------
1985     Stats:
1986         length: 57267
1987     -----------------------------------------------------------------------
1988     0     abcdefghij klmnopqrst uvwxyzABCD EFGHIJKLMN OPQRSTUVWX YZ!"#$%&amp;'(
1989     60    )*+,-./:;&lt; =&gt;?@[\]^_` {|}~012345 6789a spac eabcdefghi jklmnopqrs
1990     ...
1991     57180 opqrstuvwx yzABCDEFGH IJKLMNOPQR STUVWXYZ!" #$%&amp;'()*+, -./:;&lt;=&gt;?@
1992     57240 [\]^_`{|}~ 0123456789 a space
1993     Supply horrendous metadata, positional, and interval metadata to
1994     exercise a variety of metadata formatting cases and rules. Sorting
1995     should be by type, then by value within each type (Python 3
1996     doesn't allow sorting of mixed types):
1997     &gt;&gt;&gt; metadata = {
1998     ...     # str key, str value
1999     ...     'abc': 'some description',
2000     ...     # int value
2001     ...     'foo': 42,
2002     ...     # unsupported type (dict) value
2003     ...     'bar': {},
2004     ...     # int key, wrapped str (single line)
2005     ...     42: 'some words to test text wrapping and such... yada yada yada '
2006     ...         'yada yada yada yada yada.',
2007     ...     # bool key, wrapped str (multi-line)
2008     ...     True: 'abc ' * 34,
2009     ...     # float key, truncated str (too long)
2010     ...     42.5: 'abc ' * 200,
2011     ...     # unsupported type (tuple) key, unsupported type (list) value
2012     ...     ('foo', 'bar'): [1, 2, 3],
2013     ...     # bytes key, single long word that wraps
2014     ...     b'long word': 'abc' * 30,
2015     ...     # truncated key (too long), None value
2016     ...     'too long of a key name to display in repr': None,
2017     ...     # wrapped bytes value (has b'' prefix)
2018     ...     'bytes wrapped value': b'abcd' * 25,
2019     ...     # float value
2020     ...     0.1: 99.9999,
2021     ...     # bool value
2022     ...     43: False,
2023     ...     # None key, complex value
2024     ...     None: complex(-1.0, 0.0),
2025     ...     # nested quotes
2026     ...     10: '"\''
2027     ... }
2028     &gt;&gt;&gt; positional_metadata = pd.DataFrame({
2029     ...     # str key, int list value
2030     ...     'foo': [1, 2, 3, 4],
2031     ...     # float key, float list value
2032     ...     42.5: [2.5, 3.0, 4.2, -0.00001],
2033     ...     # int key, object list value
2034     ...     42: [[], 4, 5, {}],
2035     ...     # truncated key (too long), bool list value
2036     ...     'abc' * 90: [True, False, False, True],
2037     ...     # None key
2038     ...     None: range(4)})
2039     &gt;&gt;&gt; positional_metadata = positional_metadata.reindex(
2040     ...     columns=['foo', 42.5, 42, 'abc' * 90, None])
2041     &gt;&gt;&gt; interval_metadata = IntervalMetadata(4)
2042     &gt;&gt;&gt; _ = interval_metadata.add([(0, 2), (1, 3)],
2043     ...                           [(False, True), (False, False)],
2044     ...                           {'gene': 'p53'})
2045     &gt;&gt;&gt; _ = interval_metadata.add([(1, 4)])
2046     &gt;&gt;&gt; Sequence('ACGT', metadata=metadata,
2047     ...          positional_metadata=positional_metadata,
2048     ...          interval_metadata=interval_metadata)
2049     Sequence
2050     -----------------------------------------------------------------------
2051     Metadata:
2052         None: (-1+0j)
2053         True: 'abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc
2054                abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc
2055                abc abc abc abc '
2056         b'long word': 'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabca
2057                        bcabcabcabcabcabcabcabcabcabcabcabcabc'
2058         0.1: 99.9999
2059         42.5: &lt;class 'str'&gt;
2060         10: '"\''
2061         42: 'some words to test text wrapping and such... yada yada yada
2062              yada yada yada yada yada.'
2063         43: False
2064         'abc': 'some description'
2065         'bar': &lt;class 'dict'&gt;
2066         'bytes wrapped value': b'abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdab
2067                                  cdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd
2068                                  abcdabcdabcdabcd'
2069         'foo': 42
2070         &lt;class 'str'&gt;: None
2071         &lt;class 'tuple'&gt;: &lt;class 'list'&gt;
2072     Positional metadata:
2073         'foo': &lt;dtype: int64&gt;
2074         42.5: &lt;dtype: float64&gt;
2075         42: &lt;dtype: object&gt;
2076         &lt;class 'str'&gt;: &lt;dtype: bool&gt;
2077         None: &lt;dtype: int64&gt;
2078     Interval metadata:
2079         2 interval features
2080     Stats:
2081         length: 4
2082     -----------------------------------------------------------------------
2083     0 ACGT
2084     """
2085 <font color="#8e35ef"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import io
2086 from unittest import TestCase, main
2087 from collections import defaultdict
2088 import numpy as np
2089 import numpy.testing as npt
2090 from scipy.stats import pearsonr
2091 from skbio import DistanceMatrix, TreeNode
2092 from skbio.tree import (DuplicateNodeError, NoLengthError,
2093                         TreeError, MissingNodeError, NoParentError)
2094 from skbio.util import RepresentationWarning
2095 class TreeNodeSubclass(TreeNode):
2096     pass
2097 class</b></font> TreeTests(TestCase):
2098     def setUp(self):
2099         self.simple_t = TreeNode.read(io.StringIO("((a,b)i1,(c,d)i2)root;"))
2100         nodes = dict([(x, TreeNode(x)) for x in 'abcdefgh'])
2101         nodes['a']<font color="#3ea99f"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(nodes['b'])
2102         nodes['c'].append(nodes['d'])
2103         nodes['c'].</b></font>append(nodes['e'])
2104         nodes['c']<font color="#549748"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(nodes['f'])
2105         nodes['f'].append(nodes['g'])
2106         nodes['a'].append(nodes['h'])
2107         self.</b></font>TreeRoot = nodes['a']
2108         def rev_f(items):
2109             items.reverse()
2110         def rotate_f(items):
2111             tmp = items[-1]
2112             items[1:] = items[:-1]
2113             items[0] = tmp
2114         self.rev_f = rev_f
2115         self.rotate_f = rotate_f
2116         self.complex_tree = TreeNode.read(io.StringIO(
2117             "(((a,b)int1,(x,y,(w,z)int2,(c,d)int3)int4),(e,f)int5);"))
2118     def test_bug_issue_1416(self):
2119         tree = TreeNode.read(['(((a,b,f,g),c),d);'])
2120         new_tree = tree.shear(['a', 'b', 'c', 'f'])
2121         exp = {'a', 'b', 'c', 'f'}
2122         obs = {n.name for n in new_tree.tips()}
2123         self.assertEqual(obs, exp)
2124         self.assertEqual(id(new_tree), id(new_tree.children[0].parent))
2125         self.assertEqual(id(new_tree), id(new_tree.children[1].parent))
2126     def test_observed_node_counts(self):
2127         """returns observed nodes counts given vector of otu observation counts
2128         """
2129         otu_counts = {}
2130         expected = defaultdict(int)
2131         self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
2132                          expected)
2133         otu_counts = {'a': 0}
2134         self.assertRaises(ValueError, self.simple_t.observed_node_counts,
2135                           otu_counts)
2136         otu_counts = {'a': 0, 'b': 0, 'c': 0, 'd': 0}
2137         self.assertRaises(ValueError, self.simple_t.observed_node_counts,
2138                           otu_counts)
2139         otu_counts = {'a': 1, 'b': 1, 'c': 1, 'd': 1}
2140         expected = defaultdict(int)
2141         expected[self.simple_t.find('root')] = 4
2142         expected[self.simple_t.find('i1')] = 2
2143         expected[self.simple_t.find('i2')] = 2
2144         expected[self.simple_t.find('a')] = 1
2145         expected[self.simple_t.find('b')] = 1
2146         expected[self.simple_t.find('c')] = 1
2147         expected[self.simple_t.find('d')] = 1
2148         self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
2149                          expected)
2150         otu_counts = {'a': 2, 'b': 1, 'c': 1, 'd': 1}
2151         expected = defaultdict(int)
2152         expected[self.simple_t.find('root')] = 5
2153         expected[self.simple_t.find('i1')] = 3
2154         expected[self.simple_t.find('i2')] = 2
2155         expected[self.simple_t.find('a')] = 2
2156         expected[self.simple_t.find('b')] = 1
2157         expected[self.simple_t.find('c')] = 1
2158         expected[self.simple_t.find('d')] = 1
2159         self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
2160                          expected)
2161         otu_counts = {'a': 2, 'b': 1, 'c': 1, 'd': 2}
2162         expected = defaultdict(int)
2163         expected[self.simple_t.find('root')] = 6
2164         expected[self.simple_t.find('i1')] = 3
2165         expected[self.simple_t.find('i2')] = 3
2166         expected[self.simple_t.find('a')] = 2
2167         expected[self.simple_t.find('b')] = 1
2168         expected[self.simple_t.find('c')] = 1
2169         expected[self.simple_t.find('d')] = 2
2170         self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
2171                          expected)
2172         otu_counts = {'a': 2, 'b': 1}
2173         expected = defaultdict(int)
2174         expected[self.simple_t.find('root')] = 3
2175         expected[self.simple_t.find('i1')] = 3
2176         expected[self.simple_t.find('a')] = 2
2177         expected[self.simple_t.find('b')] = 1
2178         self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
2179                          expected)
2180         otu_counts = {'d': 1}
2181         expected = defaultdict(int)
2182         expected[self.simple_t.find('root')] = 1
2183         expected[self.simple_t.find('i2')] = 1
2184         expected[self.simple_t.find('d')] = 1
2185         self.assertEqual(self.simple_t.observed_node_counts(otu_counts),
2186                          expected)
2187         otu_counts = {'a': 2, 'e': 1}
2188         self.assertRaises(MissingNodeError, self.simple_t.observed_node_counts,
2189                           otu_counts)
2190         otu_counts = {'a': 2, 'i1': 1}
2191         self.assertRaises(MissingNodeError, self.simple_t.observed_node_counts,
2192                           otu_counts)
2193         otu_counts = {}
2194         expected = defaultdict(int)
2195         self.assertEqual(self.complex_tree.observed_node_counts(otu_counts),
2196                          expected)
2197         otu_counts = {'e': 42, 'f': 1}
2198         expected[self.complex_tree.root()] = 43
2199         expected[self.complex_tree.find('int5')] = 43
2200         expected[self.complex_tree.find('e')] = 42
2201         expected[self.complex_tree.find('f')] = 1
2202         self.assertEqual(self.complex_tree.observed_node_counts(otu_counts),
2203                          expected)
2204     def test_count(self):
2205         exp <font color="#827d6b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= 7
2206         obs = self.simple_t.count()
2207         self.assertEqual(obs, exp)
2208         exp = 4
2209         obs = self.simple_t.count(</b></font>tips=True)
2210         self.assertEqual(obs, exp)
2211     def test_copy(self):
2212         self.simple_t.children[0].length = 1.2
2213         self.simple_t.children[1].children[0].length = 0.5
2214         cp = self.simple_t.copy()
2215         gen = zip(cp.traverse(include_self=True),
2216                   self.simple_t.traverse(include_self=True))
2217         for a, b in gen:
2218             self.assertIsNot(a, b)
2219             self.assertEqual(a.name, b.name)
2220             self.assertEqual(a.length, b.length)
2221     def test_append(self):
2222         second_tree = TreeNode.read(io.StringIO("(x,y)z;"))
2223         self.simple_t.append(second_tree)
2224         self.assertEqual(self.simple_t.children[1].name, 'i2')
2225         self.assertEqual(self.simple_t.children[2].name, 'z')
2226         self.assertEqual(len<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(self.simple_t.children), 3)
2227         self.assertEqual(self.simple_t.children[2].children[0].name, 'x')
2228         self.assertEqual(self.simple_t.children[2].children[1].name, 'y')
2229         self.</b></font>assertEqual(second_tree.parent, self.simple_t)
2230     def test_extend(self):
2231         third_tree = TreeNode.read(io.StringIO("(x2,y2)z2;"))
2232         first_tree = TreeNode.read(io.StringIO("(x1,y1)z1;"))
2233         fourth_tree =</b></font> TreeNode.read<font color="#668b8b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(io.StringIO("(x2,y2)z2;"))
2234         self.simple_t.extend([second_tree, third_tree])
2235         first_tree.extend(fourth_tree.children)
2236         self.assertEqual(</b></font>0, len(fourth_tree.children))
2237         self.assertEqual(first_tree.children[1].name, 'y1')
2238         self.assertEqual(first_tree.children[2].name, 'x2')
2239         self.assertEqual(first_tree.children<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[3].name, 'y2')
2240         self.assertEqual(self.simple_t.children[0].name, 'i1')
2241         self.assertEqual(self.simple_t.children[2].name, 'z1')
2242         self.</b></font>assertEqual(self.simple_t.children[3].name, 'z2')
2243         self.assertEqual(self.simple_t.children[2].children[0].name, 'x1')
2244         self.assertEqual(self.simple_t.children[2].children[1].name, 'y1')
2245         self.</b></font>assertEqual(self.simple_t.children[3]<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.children[0].name, 'x2')
2246         self.assertEqual(self.simple_t.children[3].children[1].name, 'y2')
2247         self.assertIs(second_tree.parent, self.simple_t)
2248         self.</b></font>assertIs(third_tree.parent, self.simple_t)
2249     def test_extend_empty(self):
2250         self.simple_t.extend([])
2251         self.assertEqual(self.simple_t.children[0].name, 'i1')
2252         self.assertEqual(self.simple_t.children[1].name, 'i2')
2253         self.assertEqual(len(self.simple_t.children), 2)
2254     def test_iter(self):
2255         exp = ['i1', 'i2']
2256         obs = [n.name for n in self.simple_t]
2257         self.assertEqual(obs, exp)
2258     def test_gops(self):
2259         p = TreeNode()
2260         self.assertEqual(str(p), ';\n')
2261         p.name = 'abc'
2262         self.assertEqual(str(p), 'abc;\n')
2263         p.length = 3
2264         self.assertEqual(str(p), 'abc:3;\n')  # don't suppress branch from root
2265         q = TreeNode()
2266         p.append(q)
2267         self.assertEqual(str(p), '()abc:3;\n')
2268         r = TreeNode()
2269         self.assertEqual(str(p), '(())abc:3;\n')
2270         r.name = 'xyz'
2271         self<font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(str(p), '((xyz))abc:3;\n')
2272         q.length = 2
2273         self.assertEqual(str(p), '((xyz):2)abc:3;\n')
2274     def test_pop(self):
2275         second_tree = TreeNode.read(io.</b></font>StringIO("(x1,y1)z1;"))
2276         third_tree = TreeNode.read(io.StringIO("(x2,y2)z2;"))
2277         i1 = self.simple_t.pop(0)
2278         z2 <font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.simple_t.pop()
2279         self.assertEqual(i1.name, 'i1')
2280         self.assertEqual(z2.name, 'z2')
2281         self.assertEqual(i1.children[1].name, 'b')
2282         self.assertEqual(z2.children[0].name, 'x2')
2283         self<font color="#5b8daf"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(z2.children[1].name, 'y2')
2284         self.assertEqual(self.simple_t.children[0].name, 'i2')
2285         self.</b></font>assertEqual(self.simple_t.children[1].name, 'z1')
2286         self.assertEqual(len(self.simple_t.children), 2)
2287     def test_remove(self):
2288         self.assertTrue(self.simple_t.remove(self.simple_t<font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.children[0]))
2289         self.assertEqual(len(self.simple_t.children), 1)
2290         n = TreeNode()
2291         self.assertFalse(self.simple_t.</b></font>remove(n))
2292     def test_remove_deleted(self):
2293         def f(node):
2294             return node.name in ['b', 'd']
2295         self.simple_t.remove_deleted(f)
2296         exp = "((a)i1,(c)i2)root;\n"
2297         obs = str(self.simple_t)
2298         self.assertEqual(obs, exp)
2299     def test_adopt(self):
2300         n1 = TreeNode(name='n1')
2301         n2 = TreeNode(name='n2')
2302         n3 = TreeNode(name='n3')
2303         self.simple_t._adopt(n1)
2304         self.simple_t.children[-1]._adopt(n2)
2305         self.assertEqual(len<font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(self.simple_t.children), 2)
2306         self.assertIs(n1.parent, self.simple_t)
2307         self.assertIs(n2.parent, self.simple_t.children[</b></font>-1])
2308         self.assertIs(n3.parent, n2)
2309     def test_remove_node(self):
2310         n = self.simple_t._remove_node(-1)
2311         self.assertEqual(n.parent, None)
2312         self.assertEqual(len(self.simple_t.children), 1)
2313         self.assertEqual(len(n.children), 2)
2314         self.assertNotIn(n, self.simple_t.children)
2315     def test_shear_prune_parent_dropped(self):
2316         bugtree = "((a,b),((c,d),(e,f)));"
2317         to_keep = ['c', 'd']
2318         exp = "(c,d);\n"
2319         obs = str(TreeNode.read(io.StringIO(bugtree)).shear(to_keep))
2320         self.assertEqual(obs, exp)
2321     def test_prune_nested_single_descendent(self):
2322         bugtree = "(((a,b)));"
2323         exp = "(a,b);\n"
2324         t = TreeNode.read(io.StringIO(bugtree))
2325         t.prune()
2326         obs = str(t)
2327         self.assertEqual(obs, exp)
2328     def test_prune_root_single_desc(self):
2329         t = TreeNode.read(["((a,b)c)extra;"])
2330         exp = "(a,b)c;\n"
2331         t.prune()
2332         self.assertEqual(str(t), exp)
2333     def test_prune(self):
2334         cp = self.simple_t.copy()
2335         self.simple_t.prune()
2336         gen = zip(cp.traverse(include_self=True),
2337                   self.simple_t.traverse(include_self=True))
2338         for a, b in gen:
2339             self.assertIsNot(a, b)
2340             self.assertEqual(a.name, b.name)
2341             self.assertEqual(a.length, b.length)
2342         n = self.simple_t.children[0]
2343         n.remove(n.children[0])
2344         self.simple_t.prune()
2345         self.assertEqual(len(self.simple_t.children), 2)
2346         self.assertEqual(self.simple_t.children[0].name, 'i2')
2347         self.assertEqual(self.simple_t.children[1].name, 'b')
2348     def test_prune_length(self):
2349         cp = self.simple_t.copy()
2350         self.simple_t.prune()
2351         gen = zip(cp.traverse(include_self=True),
2352                   self.simple_t.traverse(include_self=True))
2353         for a, b in gen:
2354             self.assertIsNot(a, b)
2355             self.assertEqual(a.name, b.name)
2356             self.assertEqual(a.length, b.length)
2357         for n in self.simple_t.traverse():
2358             n.length = 1.0
2359         n = self.simple_t.children[0]
2360         self.simple_t.prune()
2361         self.assertEqual(len<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(self.simple_t.children), 2)
2362         self.assertEqual(self.simple_t.children[0].name, 'i2')
2363         self.assertEqual(self.simple_t.children[1].name, 'b')
2364         self.assertEqual(self.simple_t.children[1].</b></font>length, 2.0)
2365     def test_subset(self):
2366         t = self.simple_t
2367         self.assertEqual(t.subset(), frozenset('abcd'))
2368         c = t.children[0]
2369         self.assertEqual(c.subset(), frozenset('ab'))
2370         leaf = c.children[1]
2371         self.assertEqual(leaf.subset(), frozenset(''))
2372     def test_subsets(self):
2373         t = self.simple_t
2374         self.assertEqual(t.subsets(), frozenset(
2375             [frozenset('ab'), frozenset('cd')]))
2376     def test_is_tip(self):
2377         self.assertFalse(self.simple_t.is_tip())
2378         self.assertFalse(self.simple_t.children[0].is_tip())
2379         self.assertTrue(self.simple_t.children[0].children<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0].is_tip())
2380     def test_is_root(self):
2381         self.assertTrue(self.simple_t.is_root())
2382         self.assertFalse(self.simple_t.</b></font>children[0].is_root())
2383         self<font color="#c57726"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertFalse(self.simple_t.children[0].children[0].is_root())
2384     def test_root(self):
2385         self.assertIs(root, self.simple_t.root())
2386         self.assertIs(root, self.simple_t.children[0].root())
2387         self<font color="#d16587"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertIs(root, self.simple_t.children[1].children[1].root())
2388     def test_invalidate_lookup_caches(self):
2389         root =</b></font> self.simple_t
2390         root<font color="#c22817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.create_caches()
2391         self.assertNotEqual(root._tip_cache, {})
2392         self.assertNotEqual(root._non_tip_cache, {})
2393         root.invalidate_caches()
2394         self.assertEqual(</b></font>root._tip_cache, {})
2395         self.assertEqual(root._non_tip_cache, {})
2396     def test_invalidate_attr_caches(self):
2397         tree = TreeNode.read(io.StringIO("((a,b,(c,d)e)f,(g,h)i)root;"))
2398         def f(n):
2399             return [n.name] if n.is_tip() else []
2400         tree.cache_attr(f, 'tip_names')
2401         tree.invalidate_caches()
2402         for n in tree.traverse(include_self=True):
2403             self.assertFalse(hasattr(n, 'tip_names'))
2404     def test_create_caches_duplicate_tip_names(self):
2405         with self.assertRaises(DuplicateNodeError):
2406     def test_find_all(self):
2407         t = TreeNode.read(io.StringIO<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("((a,b)c,((d,e)c)c,(f,(g,h)c)a)root;"))
2408         exp = [t.children[0],
2409                t.children[1].children[0],
2410                t.children[1],
2411                t.children[2].children[</b></font>1]]
2412         obs = t.find_all('c')
2413         self.assertEqual(obs, exp)
2414         identity = t.find_all(t)
2415         self.assertEqual(len(identity), 1)
2416         self.assertEqual(identity[0], t)
2417         identity_name = t.find_all('root')
2418         self.assertEqual(len(identity_name), 1)
2419         self.assertEqual(identity_name[0], t)
2420         exp = [t.children[2],
2421                t.children[0].children[0]]
2422         obs = t.find_all('a')
2423         self.assertEqual(obs, exp)
2424         with self.assertRaises(MissingNodeError):
2425             t.find_all('missing')
2426     def test_find(self):
2427         t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f);"))
2428         exp = t.children[0]
2429         obs = t.find('c')
2430         self.assertEqual(obs, exp)
2431         exp = t.children[0].children[1]
2432         obs = t.find('b')
2433         self.assertEqual(obs, exp)
2434         with self.assertRaises(MissingNodeError):
2435             t.find('does not exist')
2436     def test_find_cache_bug(self):
2437         t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f,(g,h)f);"))
2438         exp_tip_cache_keys = set(['a', 'b', 'd', 'e', 'g', 'h'])
2439         exp_non_tip_cache_keys = set(['c', 'f'])
2440         tip_a = t.children[0].children[0]
2441         tip_a.create_caches()
2442         self.assertEqual(tip_a._tip_cache, {})
2443         self.assertEqual(set(t._tip_cache), exp_tip_cache_keys)
2444         self.assertEqual(set(t._non_tip_cache), exp_non_tip_cache_keys)
2445         self.assertEqual(t._non_tip_cache['f'], [t.children[1], t.children[2]])
2446     def test_find_by_id(self):
2447         t1 = TreeNode.read(io.StringIO("((,),(,,));"))
2448         t2 = TreeNode.read(io.StringIO("((,),(,,));"))
2449         exp = t1.children[1]
2450         obs = t1.find_by_id(6)  # right inner node with 3 children
2451         self.assertEqual(obs, exp)
2452         exp = t2.children[1]
2453         obs = t2.find_by_id(6)  # right inner node with 3 children
2454         self.assertEqual(obs, exp)
2455         with self.assertRaises(MissingNodeError):
2456             t1.find_by_id(100)
2457     def test_find_by_func(self):
2458         t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f);"))
2459         def func(x):
2460             return x.parent == t.find('c')
2461         exp = ['a', 'b']
2462         obs = [n.name for n in t.find_by_func(func)]
2463         self.assertEqual(obs, exp)
2464     def test_ancestors(self):
2465         exp = ['i1', 'root']
2466         obs = self.simple_t.children[0].children[0].ancestors()
2467         self.assertEqual([o.name for o in obs], exp)
2468         exp = ['root']
2469         obs = self.simple_t.children[0].ancestors()
2470         self.assertEqual([o.name for o in obs], exp)
2471         exp = []
2472         obs = self.simple_t.ancestors()
2473         self.assertEqual([o.name for o in obs], exp)
2474     def test_siblings(self):
2475         exp = []
2476         obs = self.simple_t.siblings()
2477         self.assertEqual(obs, exp)
2478         exp = ['i2']
2479         obs = self.simple_t.children[0].siblings()
2480         self.assertEqual([o.name for o in obs], exp)
2481         exp = ['c']
2482         obs = self.simple_t.children[1].children[1].siblings()
2483         self.assertEqual([o.name for o in obs], exp)
2484         self.simple_t.append(TreeNode(name="foo"))
2485         self.simple_t.append(TreeNode(name="bar"))
2486         exp = ['i1', 'foo', 'bar']
2487         obs = self.simple_t.children[1].siblings()
2488         self.assertEqual([o.name for o in obs], exp)
2489     def test_ascii_art(self):
2490         tr = TreeNode.read(io.StringIO("(B:0.2,(C:0.3,D:0.4):0.6)F;"))
2491         obs = tr.ascii_art(show_internal=True, compact=False)
2492         exp = ("          /-B\n"
2493                "-F-------|\n"
2494                "         |          /-C\n"
2495                "          \\--------|\n"
2496                "                    \\-D")
2497         self.assertEqual(obs, exp)
2498         obs = tr.ascii_art(show_internal=True, compact=True)
2499         exp = ("-F------- /-B\n"
2500                "          \\-------- /-C\n"
2501                "                    \\-D")
2502         self.assertEqual(obs, exp)
2503         obs = tr.ascii_art(show_internal=False, compact=False)
2504         exp = ("          /-B\n"
2505                "---------|\n"
2506                "         |          /-C\n"
2507                "          \\--------|\n"
2508                "                    \\-D")
2509         self.assertEqual(obs, exp)
2510     def test_ascii_art_with_support(self):
2511         tr = TreeNode.read(io.StringIO("(B:0.2,(C:0.3,D:0.4)90:0.6)F;"))
2512         exp = "          /-B\n-F-------|\n         |          /-C\n         "\
2513               " \\90------|\n                    \\-D"
2514         obs = tr.ascii_art(show_internal=True, compact=False)
2515         self.assertEqual(obs, exp)
2516         tr.assign_supports()
2517         obs = tr.ascii_art(show_internal=True, compact=False)
2518         self.assertEqual(obs, exp)
2519         tr = TreeNode.read(io.StringIO("((A,B)75,(C,D)'80:spA');"))
2520         exp = "                    /-A\n          /75------|\n         |    "\
2521               "      \\-B\n---------|\n         |          /-C\n          \\"\
2522               "80:spA--|\n                    \\-D"
2523         obs = tr.ascii_art(show_internal=True, compact=False)
2524         self.assertEqual(obs, exp)
2525         tr.assign_supports()
2526         obs = tr.ascii_art(show_internal=True, compact=False)
2527     def test_ascii_art_three_children(self):
2528         obs = TreeNode.read(io<font color="#a057a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.StringIO('(a,(b,c,d));')).ascii_art()
2529         self.assertEqual(obs, exp_ascii_art_three_children)
2530     def test_accumulate_to_ancestor(self):
2531         t = TreeNode.read(io.</b></font>StringIO(
2532             "((a:0.1,b:0.2)c:0.3,(d:0.4,e)f:0.5)root;"))
2533         a = t.find('a')
2534         b = t.find('b')
2535         exp_to_root = 0.1 + 0.3
2536         obs_to_root = a.accumulate_to_ancestor(t)
2537         self.assertEqual(obs_to_root, exp_to_root)
2538         with self.assertRaises(NoParentError):
2539             a.accumulate_to_ancestor(b)
2540         tstr = "((A:1.0,B:2.0)'g__genus1':3.0)root;"
2541         tree = TreeNode<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read(io.StringIO(tstr))
2542         self.assertEqual(tree.find('A').distance(tree.find('g__genus1')), 1.0)
2543     def test_distance(self):
2544         t =</b></font> TreeNode.read(io.StringIO(
2545             "((a:0.1,b:0.2)c:0.3,(d:0.4,e)f:0.5)root;"))
2546         tips = sorted([n for n in t.tips()], key=lambda x: x<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.name)
2547         npt.assert_almost_equal(tips[0].distance(tips[0]), 0.0)
2548         npt.assert_almost_equal(tips[0].distance(tips[1]), 0.3)
2549         npt.assert_almost_equal(tips[</b></font>0].distance(tips[2]), 1.3)
2550             tips[0].distance(tips[3])
2551         npt.assert_almost_equal(tips<font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[1].distance(tips[0]), 0.3)
2552         npt.assert_almost_equal(tips[1].distance(tips[1]), 0.0)
2553         npt.assert_almost_equal(tips[</b></font>1].distance(tips[2]), 1.4)
2554             tips[1].distance(tips[3])
2555         self<font color="#f87a17"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(tips[2].distance(tips[0]), 1.3)
2556         self.assertEqual(tips[2].distance(tips[</b></font>1]), 1.4)
2557         self.assertEqual(tips[2].distance(tips[2]), 0.0)
2558         with self.assertRaises(NoLengthError):
2559             tips[2].distance(tips[3])
2560     def test_lowest_common_ancestor(self):
2561         t1 = TreeNode.read(io<font color="#ff00ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.StringIO("((a,(b,c)d)e,f,(g,h)i)j;"))
2562         t2 = t1.copy()
2563         t3 = t1.copy()
2564         t4 = t1.copy()
2565         input2 = ['a', 'b']  # return e
2566         input3 = ['b', 'c']  # return d
2567         input4 <font color="#41a317"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= ['a', 'h', 'g']  # return j
2568         exp1 = t1.find('a')
2569         exp3 = t3.find('d')
2570         exp4 =</b></font> t4
2571         obs1 <font color="#348781"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= t1.lowest_common_ancestor(input1)
2572         obs2 = t2.lowest_common_ancestor(input2)
2573         obs3 = t3.lowest_common_ancestor(input3)
2574         self.assertEqual(obs1, exp1)
2575         self.assertEqual(obs2, exp2)
2576         self<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(obs3, exp3)
2577         self.assertEqual(obs4, exp4)
2578         t_mul = t1.copy()
2579         exp_1 = t_mul.find('d')
2580         exp_2 = t_mul.find('i')
2581         obs_1 = t_mul.lowest_common_ancestor(</b></font>['b', 'c'])
2582         obs_2 = t_mul.lowest_common_ancestor(['g', 'h'])
2583         self.assertEqual(obs_1, exp_1)
2584         self.assertEqual(obs_2, exp_2)
2585         with self.assertRaises(ValueError):
2586             t1.lowest_common_ancestor([])
2587     def test_get_max_distance(self):
2588         tree = TreeNode.read(io.StringIO(
2589             "((a:0.1,b:0.2)c:0.3,(d:0.4,e:0.5)f:0.6)root;"))
2590         dist, nodes = tree.get_max_distance()
2591         npt.assert_almost_equal(dist, 1.6)
2592         self.assertEqual(sorted([n.name for n in nodes]), ['b', 'e'])
2593     def test_set_max_distance(self):
2594         tree = TreeNode.read(io.StringIO(
2595             "((a:0.1,b:0.2)c:0.3,(d:0.4,e:0.5)f:0.6)root;"))
2596         tree._set_max_distance()
2597         tip_a, tip_b = tree.MaxDistTips
2598         self.assertEqual(tip_a[0] + tip_b[0], 1.6)
2599         self.assertEqual(sorted([tip_a[1].name, tip_b[1].name]), ['b', 'e'])
2600     def test_set_max_distance_tie_bug(self):
2601         s = io.StringIO("((a:1,b:1)c:2,(d:3,e:4)f:5)root;")
2602         t = TreeNode.read(s)
2603         exp = ((3.0, t.find('a')), (9.0, t.find('e')))
2604         t._set_max_distance()
2605         self.assertEqual(t.MaxDistTips, exp)
2606     def test_set_max_distance_inplace_modification_bug(self):
2607         t = TreeNode.read(s)
2608         exp = [((0.0, t.find<font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>('a')), (0.0, t.find('a'))),
2609                ((0.0, t.find('b')), (0.0, t.find('b'))),
2610                ((1.0, t.</b></font>find<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>('a')), (1.0, t.find('b'))),
2611                ((0.0, t.find('d')), (0.0, t.find('d'))),
2612                ((0.0, t.</b></font>find('e')), (0.0, t.find('e'))),
2613                ((3.0, t.find('d')), (4.0, t.find('e'))),
2614                ((3.0, t.find('a')), (9.0, t.find('e')))]
2615         t._set_max_distance()
2616         self.assertEqual([n.MaxDistTips for n in t.postorder()], exp)
2617     def test_shear(self):
2618         t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
2619         obs = str(t.shear(['G', 'M']))
2620         exp = '(G:3.0,M:3.7);\n'
2621         self.assertEqual(obs, exp)
2622     def test_compare_tip_distances(self):
2623         t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
2624         t2 = TreeNode.read(io.StringIO('(((H:1,G:1,O:1):2,R:3):1,X:4);'))
2625         obs = t.compare_tip_distances(t2)
2626         m1 = np.array([[0, 2, 6.5], [2, 0, 6.5], [6.5, 6.5, 0]])
2627         m2 = np.array([[0, 2, 6], [2, 0, 6], [6, 6, 0]])
2628         r = pearsonr(m1.flat, m2.flat)[0]
2629         self.assertAlmostEqual(obs, (1 - r) / 2)
2630     def test_compare_tip_distances_sample(self):
2631         t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
2632         t2 = TreeNode.read(io.StringIO('(((H:1,G:1,O:1):2,R:3):1,X:4);'))
2633         obs = t.compare_tip_distances(t2, sample=3, shuffle_f=sorted)
2634         m1 = np.array([[0, 2, 6.5], [2, 0, 6.5], [6.5, 6.5, 0]])
2635         m2 = np.array([[0, 2, 6], [2, 0, 6], [6, 6, 0]])
2636         r = pearsonr(m1.flat, m2.flat)[0]
2637         self.assertAlmostEqual(obs, (1 - r) / 2)
2638         s = '((H:1,G:1):2,(R:0.5,M:0.7,Q:5):3);'
2639         t = TreeNode<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read(io.StringIO(s))
2640         s3 = '(((H:1,G:1,O:1):2,R:3,Q:10):1,X:4);'
2641         t3 = TreeNode.read(io.StringIO(s3))
2642         obs = t.compare_tip_distances(</b></font>t3, sample=3, shuffle_f=sorted)
2643     def test_compare_tip_distances_no_common_tips(self):
2644         t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
2645         t2 = TreeNode.read(io.StringIO('(((Z:1,Y:1,X:1):2,W:3):1,V:4);'))
2646         with self.assertRaises(ValueError):
2647             t.compare_tip_distances(t2)
2648     def test_compare_tip_distances_single_common_tip(self):
2649         t = TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
2650         t2 = TreeNode<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read(io.StringIO('(((R:1,Y:1,X:1):2,W:3):1,V:4);'))
2651         self.assertEqual(t.compare_tip_distances(t2), 1)
2652         self.assertEqual(t2.compare_tip_distances(t), 1)
2653     def test_tip_tip_distances_endpoints(self):
2654         t =</b></font> TreeNode.read(io.StringIO('((H:1,G:1):2,(R:0.5,M:0.7):3);'))
2655         nodes = [t.find('H'), t.find('G'), t.find('M')]
2656         names = ['H', 'G', 'M']
2657         exp = DistanceMatrix(np.array([[0, 2.0, 6.7],
2658                                        [6.7, 6.7, 0.0]]), ['H', 'G', 'M'])
2659         obs <font color="#810541"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= t.tip_tip_distances(endpoints=names)
2660         self.assertEqual(obs, exp)
2661         obs = t.tip_tip_distances(endpoints=nodes)
2662         self.assertEqual(</b></font>obs, exp)
2663     def test_tip_tip_distances_non_tip_endpoints(self):
2664         t = TreeNode.read(io.StringIO('((H:1,G:1)foo:2,(R:0.5,M:0.7):3);'))
2665         with self.assertRaises(ValueError):
2666             t.tip_tip_distances(endpoints=['foo'])
2667     def test_tip_tip_distances_no_length(self):
2668         t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f);"))
2669         exp_t = TreeNode.read(io.StringIO("((a:0,b:0)c:0,(d:0,e:0)f:0);"))
2670         exp_t_dm = exp_t.tip_tip_distances()
2671         t_dm = npt.assert_warns(RepresentationWarning, t.tip_tip_distances)
2672         self.assertEqual(t_dm, exp_t_dm)
2673         for node in t.preorder():
2674             self.assertIs(node.length, None)
2675     def test_tip_tip_distances_missing_length(self):
2676         t = TreeNode.read(io.StringIO("((a,b:6)c:4,(d,e:0)f);"))
2677         exp_t = TreeNode.read(io.StringIO("((a:0,b:6)c:4,(d:0,e:0)f:0);"))
2678         exp_t_dm = exp_t.tip_tip_distances()
2679         t_dm = npt.assert_warns(RepresentationWarning, t.tip_tip_distances)
2680         self.assertEqual(t_dm, exp_t_dm)
2681     def test_neighbors(self):
2682         t = TreeNode.read(io.StringIO("((a,b)c,(d,e)f);"))
2683         exp = t.children
2684         obs = t.neighbors()
2685         self.assertEqual(obs, exp)
2686         exp = t.children[0].children + [t]
2687         obs = t.children[0].neighbors()
2688         self.assertEqual(obs, exp)
2689         exp = [t.children[0].children[0]] + [t]
2690         obs = t.children[0].neighbors(ignore=t.children[0].children[1])
2691         self.assertEqual(obs, exp)
2692         exp = [t.children[0]]
2693         obs = t.children[0].children[0].neighbors()
2694         self.assertEqual(obs, exp)
2695     def test_has_children(self):
2696         t = TreeNode.read(io<font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.StringIO("((a,b)c,(d,e)f);"))
2697         self.assertTrue(t.has_children())
2698         self.assertTrue(t.children[0].has_children())
2699         self.</b></font>assertTrue(t.children[1].has_children())
2700         self.assertFalse(t.children[0].children[0].has_children())
2701         self.assertFalse(t.children[0].children[1].has_children())
2702         self.assertFalse(t.children[1].children[0].has_children())
2703         self.assertFalse(t.children[1].children[1].has_children())
2704     def test_tips(self):
2705         exp = ['a', 'b', 'c', 'd']
2706         obs = [n.name for n in self.simple_t.tips()]
2707         self.assertEqual(obs, exp)
2708         obs2 = [n.name for n in self.simple_t.traverse(False, False)]
2709         self.assertEqual(obs2, exp)
2710     def test_tips_self(self):
2711         tree = TreeNode.read(['(c, (b,a)x)y;'])
2712         ts = list(tree.find('c').tips(include_self=True))
2713         self.assertEqual(len(ts), 1)
2714         t = ts[0]
2715         self.assertEqual(t.name, 'c')
2716         self.assertTrue(t.is_tip())
2717     def test_pre_and_postorder(self):
2718         exp = ['root', 'i1', 'a', 'b', 'i1', 'i2', 'c', 'd', 'i2', 'root']
2719         obs = [n.name for n in self.simple_t.pre_and_postorder()]
2720         self.assertEqual(obs, exp)
2721         obs2 = [n.name for n in self.simple_t.traverse(True, True)]
2722         self.assertEqual(obs2, exp)
2723     def test_pre_and_postorder_no_children(self):
2724         t = TreeNode('brofist')
2725         exp = ['brofist']
2726         obs = [n.name for n in t.pre_and_postorder()]
2727         self.assertEqual(obs, exp)
2728         obs = list(t.pre_and_postorder(include_self=False))
2729         self.assertEqual(obs, [])
2730     def test_levelorder(self):
2731         exp <font color="#c57717"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= ['root', 'i1', 'i2', 'a', 'b', 'c', 'd']
2732         obs = [n.name for n in self.simple_t.levelorder()]
2733         self.assertEqual(obs, exp)
2734     def test_bifurcate(self):
2735         t1 =</b></font> TreeNode.read(io.StringIO('(((a,b),c),(d,e));'))
2736         t2 = TreeNode.read(io.StringIO('((a,b,c));'))
2737         t3 = t2.copy()
2738         t1.bifurcate()
2739         t2.bifurcate()
2740         t3.bifurcate(insert_length=0)
2741         self.assertEqual(str(t1), '(((a,b),c),(d,e));\n')
2742         self.assertEqual(str(t2), '((c,(a,b)));\n')
2743         self.assertEqual(str(t3), '((c,(a,b):0));\n')
2744     def test_bifurcate_with_subclass(self):
2745         tree = TreeNodeSubclass()
2746         tree<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(TreeNodeSubclass())
2747         tree.append(TreeNodeSubclass())
2748         tree.append(TreeNodeSubclass())
2749         tree.append(TreeNodeSubclass())
2750         tree.bifurcate(</b></font>)
2751         for node in tree.traverse():
2752             self.assertIs(type(node), TreeNodeSubclass)
2753     def test_index_tree_single_node(self):
2754         t1 = TreeNode.read(io.StringIO('root;'))
2755         id_index, child_index = t1.index_tree()
2756         self.assertEqual(id_index[0], t1)
2757         npt.assert_equal(child_index, np.array([[]]))
2758     def test_index_tree(self):
2759         t1 = TreeNode.read(io.StringIO('(((a,b),c),(d,e));'))
2760         t2 = TreeNode.read(io.StringIO('(((a,b),(c,d)),(e,f));'))
2761         t3 = TreeNode.read(io.StringIO('(((a,b,c),(d)),(e,f));'))
2762         id_1, child_1 = t1.index_tree()
2763         nodes_1 = [n.id for n in t1.traverse(self_before=False,
2764                    self_after=True)]
2765         self.assertEqual(nodes_1, [0, 1, 2, 3, 6, 4, 5, 7, 8])
2766         npt.assert_equal(child_1, np.array([[2, 0, 1], [6, 2, 3], [7, 4, 5],
2767                                             [8, 6, 7]]))
2768         id_2, child_2 = t2.index_tree()
2769         nodes_2 = [n.id for n in t2.traverse(self_before=False,
2770                    self_after=True)]
2771         self.assertEqual(nodes_2, [0, 1, 4, 2, 3, 5, 8, 6, 7, 9, 10])
2772         npt.assert_equal(child_2, np.array([[4, 0, 1], [5, 2, 3],
2773                                             [8, 4, 5], [9, 6, 7],
2774                                             [10, 8, 9]]))
2775         id_3, child_3 = t3.index_tree()
2776         nodes_3 = [n.id for n in t3.traverse(self_before=False,
2777                    self_after=True)]
2778         self.assertEqual(nodes_3, [0, 1, 2, 4, 3, 5, 8, 6, 7, 9, 10])
2779         npt.assert_equal(child_3, np.array([[4, 0, 2], [5, 3, 3], [8, 4, 5],
2780                                             [9, 6, 7], [10, 8, 9]]))
2781     def test_root_at(self):
2782         t = TreeNode.read(io.StringIO("(((a,b)c,(d,e)f)g,h)i;"))
2783         with self.assertRaises(TreeError):
2784             t.root_at(t.find('h'))
2785         exp = "(a,b,((d,e)f,(h)g)c)root;\n"
2786         rooted = t.root_at('c')
2787         obs = str(rooted)
2788         self.assertEqual(obs, exp)
2789     def test_root_at_midpoint(self):
2790         tree1 = self.TreeRoot
2791             n.length = 1
2792         result = tree1<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.root_at_midpoint()
2793         self.assertEqual(result.distance(result.find('e')), 1.5)
2794         self.assertEqual(result.distance(result.find('g')), 2.5)
2795         exp_dist =</b></font> tree1.tip_tip_distances()
2796         obs_dist = result.tip_tip_distances()
2797         self.assertEqual(obs_dist, exp_dist)
2798     def test_root_at_midpoint_no_lengths(self):
2799         nwk = '(a,b)c;\n'
2800         t = TreeNode.read(io.StringIO(nwk))
2801         obs = t.root_at_midpoint()
2802         self.assertEqual(str(obs), nwk)
2803     def test_root_at_midpoint_tie(self):
2804         nwk = "(((a:1,b:1)c:2,(d:3,e:4)f:5),g:1)root;"
2805         t = TreeNode<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read(io.StringIO(nwk))
2806         exp = "((d:3,e:4)f:2,((a:1,b:1)c:2,(g:1)):3)root;"
2807         texp = TreeNode.read(io.StringIO(exp))
2808         obs = t.root_at_midpoint(</b></font>)
2809         for o, e in zip<font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(obs.traverse(), texp.traverse()):
2810             self.assertEqual(o.name, e.name)
2811             self.assertEqual(o.length, e.</b></font>length)
2812     def test_compare_subsets(self):
2813         t = TreeNode.read<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(io.StringIO('((H,G),(R,M));'))
2814         t2 = TreeNode.read(io.StringIO('(((H,G),R),M);'))
2815         t4 = TreeNode.read(io.StringIO('(((H,G),(O,R)),X);'))
2816         result = t.compare_subsets(t)
2817         self.assertEqual(result, 0)
2818         result =</b></font> t2.compare_subsets(t2)
2819         self.assertEqual(result, 0)
2820         result = t.compare_subsets(t2)
2821         self.assertEqual(result, 0.5)
2822         self.assertEqual(result, 1 - 2. / 5)
2823         result = t<font color="#736aff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.compare_subsets(t4, exclude_absent_taxa=True)
2824         self.assertEqual(result, 1 - 2. / 3)
2825         result = t.compare_subsets(self.TreeRoot, exclude_absent_taxa=True)
2826         self.assertEqual(</b></font>result, 1)
2827         result = t.compare_subsets(self.TreeRoot)
2828         self.assertEqual(result, 1)
2829     def test_compare_rfd(self):
2830         t = TreeNode.read(io.StringIO('((H,G),(R,M));'))
2831         t2 = TreeNode.read(io.StringIO('(((H,G),R),M);'))
2832         t4 = TreeNode.read(io.StringIO('(((H,G),(O,R)),X);'))
2833         obs = t.compare_rfd(t2)
2834         exp = 2.0
2835         self.assertEqual(obs, exp)
2836         obs = t.compare_rfd(t2, proportion=True)
2837         exp <font color="#152dc6"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= 0.5
2838         self.assertEqual(obs, exp)
2839         with self.assertRaises(ValueError):
2840             t.compare_rfd(t4)
2841     def test_assign_ids(self):
2842         t2 = TreeNode.read(io.StringIO("(((a,b),c),(e,f),(g));"))
2843         t3 = TreeNode.read(io.StringIO("((g),(e,f),(c,(a,b)));"))
2844         t1_copy = t1<font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.copy()
2845         t1.assign_ids()
2846         t2.assign_ids()
2847         t3.assign_ids()
2848         t1_copy.assign_ids()
2849         self.assertEqual([(</b></font>n.name, n.id) for n in t1.traverse()],
2850                          [(n.name, n.id) for n in t2.traverse()])
2851         self.assertEqual([(n.name, n.id) for n in t1.traverse()],
2852                          [(n.name, n.id) for n in t1_copy.traverse()])
2853         self.assertNotEqual([(n.name, n.id) for n in t1.traverse()],
2854                             [(n.name, n.id) for n in t3.traverse()])
2855     def test_assign_ids_index_tree(self):
2856         t1 = TreeNode.read(io.StringIO('(((a,b),c),(d,e));'))
2857         t2 = TreeNode.read(io.StringIO('(((a,b),(c,d)),(e,f));'))
2858         t1_copy = t1.copy()
2859         t2_copy = t2.copy()
2860         t3_copy = t3<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.copy()
2861         t1.assign_ids()
2862         t1_copy.index_tree()
2863         t2.assign_ids()
2864         t2_copy.index_tree()
2865         t3.assign_ids()
2866         t3_copy.index_tree()
2867         self.assertEqual([n.</b></font>id for n in t1.traverse()],
2868                          [n.id for n in t1_copy.traverse()])
2869         self.assertEqual([n.id for n in t2.traverse()],
2870                          [n.id for n in t2_copy.traverse()])
2871         self.assertEqual([n.id for n in t3.traverse()],
2872                          [n.id for n in t3_copy.traverse()])
2873     def test_unrooted_deepcopy(self):
2874         t = TreeNode.read(io.StringIO("((a,(b,c)d)e,(f,g)h)i;"))
2875         exp = "(b,c,(a,((f,g)h)e)d)root;\n"
2876         obs = t.find('d').unrooted_deepcopy()
2877         self.assertEqual(str(obs), exp)
2878         t_ids = {id(n) for n in t.traverse()}
2879         obs_ids = {id(n) for n in obs.traverse()}
2880         self.assertEqual(t_ids.intersection(obs_ids), set())
2881     def test_descending_branch_length(self):
2882         tr = TreeNode.read(io.StringIO(
2883             "(((A:.1,B:1.2)C:.6,(D:.9,E:.6)F:.9)G:2.4,(H:.4,I:.5)J:1.3)K;"))
2884         tdbl = tr.descending_branch_length()
2885         sdbl = tr.descending_branch_length(['A', 'E'])
2886         npt.assert_almost_equal(tdbl, 8.9)
2887         npt.assert_almost_equal(sdbl, 2.2)
2888         self.assertRaises(ValueError, tr.descending_branch_length,
2889         self.assertRaises(ValueError, tr.descending_branch_length, ['A', 'C'])
2890         tr = TreeNode.read<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(io.StringIO(
2891             "(((A,B:1.2)C:.6,(D:.9,E:.6)F:.9)G:2.4,(H:.4,I:.5)J:1.3)K;"))
2892         tdbl = tr.descending_branch_length()
2893         npt.assert_almost_equal(tdbl, 8.8)
2894         tr = TreeNode.read(io.StringIO(
2895             "(((A,B:1.2)C:.6,(D:.9,E:.6)F)G:2.4,(H:.4,I:.5)J:1.3)K;"))
2896         tdbl = tr.descending_branch_length()
2897         npt.assert_almost_equal(tdbl, 7.9)
2898         tr =</b></font> TreeNode.read(io.StringIO(
2899             "(((A,B:1.2)C:.6,(D:.9,E:.6)F)G:2.4,(H:.4,I:.5)J:1.3)K;"))
2900         tdbl = tr.descending_branch_length(['A', 'D', 'E'])
2901         npt.assert_almost_equal(tdbl, 2.1)
2902         tr = TreeNode.read(io.StringIO(
2903             "(((A,B:1.2)C:.6,(D:.9,E:.6)F:.9)G:2.4,(H:.4,I:.5)J:1.3)K;"))
2904         tdbl = tr.descending_branch_length(['I', 'D', 'E'])
2905         npt.assert_almost_equal(tdbl, 6.6)
2906         tr = TreeNode.read(io.StringIO(
2907             "(((A,B:1.2):.6,(D:.9,E:.6)F):2.4,(H:.4,I:.5)J:1.3);"))
2908         tdbl = tr.descending_branch_length()
2909         npt.assert_almost_equal(tdbl, 7.9)
2910     def test_to_array(self):
2911         t = TreeNode.read(io.StringIO(
2912             '(((a:1,b:2,c:3)x:4,(d:5)y:6)z:7,(e:8,f:9)z:10);'))
2913         id_index, child_index = t.index_tree()
2914         arrayed = t.to_array()
2915         self.assertEqual(id_index, arrayed['id_index'])
2916         npt.assert_equal(child_index, arrayed['child_index'])
2917         exp = np.array([1, 2, 3, 5, 4, 6, 8, 9, 7, 10, np.nan])
2918         obs = arrayed['length']
2919         npt.assert_equal(obs, exp)
2920         exp = np.array(['a', 'b', 'c', 'd', 'x',
2921                         'y', 'e', 'f', 'z', 'z', None])
2922         obs = arrayed['name']
2923         npt.assert_equal(obs, exp)
2924         exp = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
2925         obs = arrayed['id']
2926         npt.assert_equal(obs, exp)
2927     def test_to_array_attrs(self):
2928         t = TreeNode.read(io.StringIO(
2929             '(((a:1,b:2,c:3)x:4,(d:5)y:6)z:7,(e:8,f:9)z:10);'))
2930         id_index, child_index = t.index_tree()
2931         arrayed = t.to_array(attrs=[('name', object)])
2932         self.assertEqual(len(arrayed), 3)
2933         self.assertEqual(id_index, arrayed['id_index'])
2934         npt.assert_equal(child_index, arrayed['child_index'])
2935         exp = np.array(['a', 'b', 'c', 'd', 'x',
2936                         'y', 'e', 'f', 'z', 'z', None])
2937         obs = arrayed['name']
2938         npt.assert_equal(obs, exp)
2939         with self.assertRaises(AttributeError):
2940             t.to_array(attrs=[('name', object), ('brofist', int)])
2941     def test_to_array_nan_length_value(self):
2942         t = TreeNode.read(io.StringIO("((a:1, b:2)c:3)root;"))
2943         indexed = t.to_array(nan_length_value=None)
2944         npt.assert_equal(indexed['length'],
2945                          np.array([1, 2, 3, np.nan], dtype=float))
2946         indexed = t.to_array(nan_length_value=0.0)
2947         npt.assert_equal(indexed['length'],
2948                          np.array([1, 2, 3, 0.0], dtype=float))
2949         indexed = t.to_array(nan_length_value=42.0)
2950         npt.assert_equal(indexed['length'],
2951                          np.array([1, 2, 3, 42.0], dtype=float))
2952         t = TreeNode.read(io.StringIO("((a:1, b:2)c:3)root:4;"))
2953         indexed = t.to_array(nan_length_value=42.0)
2954         npt.assert_equal(indexed['length'],
2955                          np.array([1, 2, 3, 4], dtype=float))
2956         t = TreeNode.read(io.StringIO("((a:1, b:2)c)root;"))
2957         indexed = t.to_array(nan_length_value=42.0)
2958         npt.assert_equal(indexed['length'],
2959                          np.array([1, 2, 42.0, 42.0], dtype=float))
2960     def test_from_taxonomy(self):
2961         input_lineages = {'1': ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
2962                           '2': ['a', 'b', 'c', None, None, 'x', 'y'],
2963                           '3': ['h', 'i', 'j', 'k', 'l', 'm', 'n'],
2964                           '4': ['h', 'i', 'j', 'k', 'l', 'm', 'q'],
2965                           '5': ['h', 'i', 'j', 'k', 'l', 'm', 'n']}
2966         exp = TreeNode.read(io.StringIO(
2967             "((((((((1)g)f)e)d,((((2)y)x)))c)b)a,"
2968             "(((((((3,5)n,(4)q)m)l)k)j)i)h);"))
2969         root = TreeNode.from_taxonomy(input_lineages.items())
2970         self.assertIs(type(root), TreeNode)
2971         self.assertEqual(root.compare_subsets(exp), 0.0)
2972         root = TreeNodeSubclass.from_taxonomy(input_lineages.items())
2973         self.assertIs(type(root), TreeNodeSubclass)
2974     def test_to_taxonomy(self):
2975         input_lineages = {'1': ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
2976                           '2': ['a', 'b', 'c', None, None, 'x', 'y'],
2977                           '3': ['h', 'i', 'j', 'k', 'l', 'm', 'n'],
2978                           '4': ['h', 'i', 'j', 'k', 'l', 'm', 'q'],
2979                           '5': ['h', 'i', 'j', 'k', 'l', 'm', 'n']}
2980         tree = TreeNode.from_taxonomy(input_lineages.items())
2981         exp = sorted(input_lineages.items())
2982         obs = [(n.name, lin) for n, lin in tree.to_taxonomy(allow_empty=True)]
2983         self.assertEqual(sorted(obs), exp)
2984     def test_to_taxonomy_filter(self):
2985         input_lineages = {'1': ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
2986                           '2': ['a', 'b', 'c', None, None, 'x', 'y'],
2987                           '3': ['h', 'i', 'j', 'k', 'l'],  # test jagged
2988                           '4': ['h', 'i', 'j', 'k', 'l', 'm', 'q'],
2989                           '5': ['h', 'i', 'j', 'k', 'l', 'm', 'n']}
2990         tree = TreeNode.from_taxonomy(input_lineages.items())
2991         def f(node, lin):
2992             return 'k' in lin or 'x' in lin
2993         exp = [('2', ['a', 'b', 'c', 'x', 'y']),
2994                ('3', ['h', 'i', 'j', 'k', 'l']),
2995                ('4', ['h', 'i', 'j', 'k', 'l', 'm', 'q']),
2996                ('5', ['h', 'i', 'j', 'k', 'l', 'm', 'n'])]
2997         obs = [(n.name, lin) for n, lin in tree.to_taxonomy(filter_f=f)]
2998         self.assertEqual(sorted(obs), exp)
2999     def test_linkage_matrix(self):
3000         id_list = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
3001         linkage = np.asarray([[1.0,  5.0,  1.0,  2.0],
3002                               [0.0,  3.0,  8.0,  2.0],
3003                               [8.0,  9.0, 16.5,  5.0],
3004                               [2.0, 10.0, 29.0,  6.0],
3005                               [<font color="#347235"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>4.0, 11.0, 34.0,  7.0]])
3006         tree = TreeNode.from_linkage_matrix(linkage, id_list)
3007         self.assertIs(type(tree), TreeNode)
3008         self.assertEqual("(E:17.0,(C:14.5,((A:4.0,D:4.0):4.25,(G:6.25,(B:0.5,"
3009                          "F:0.5):5.75):2.0):6.25):2.5);\n",
3010                          str(tree))
3011         tree = TreeNodeSubclass.</b></font>from_linkage_matrix(linkage, id_list)
3012         self.assertIs(type(tree), TreeNodeSubclass)
3013     def test_shuffle_invalid_iter(self):
3014         shuffler = self.simple_t.shuffle(n=-1)
3015         with self.assertRaises(ValueError):
3016             next(shuffler)
3017     def test_shuffle_n_2(self):
3018         exp = ["((a,b)i1,(d,c)i2)root;\n",
3019                "((a,b)i1,(c,d)i2)root;\n",
3020                "((a,b)i1,(d,c)i2)root;\n",
3021                "((a,b)i1,(c,d)i2)root;\n",
3022                "((a,b)i1,(d,c)i2)root;\n"]
3023         obs_g = self.simple_t.shuffle(k=2, shuffle_f=self.rev_f, n=np.inf)
3024         obs = [str(next(obs_g)) for i in range(5)]
3025         self.assertEqual(obs, exp)
3026     def test_shuffle_n_none(self):
3027         exp = ["((d,c)i1,(b,a)i2)root;\n",
3028                "((a,b)i1,(c,d)i2)root;\n",
3029                "((d,c)i1,(b,a)i2)root;\n",
3030                "((a,b)i1,(c,d)i2)root;\n"]
3031         obs_g = self.simple_t.shuffle(shuffle_f=self.rev_f, n=4)
3032         obs = [str(next(obs_g)) for i in range(4)]
3033         self.assertEqual(obs, exp)
3034     def test_shuffle_complex(self):
3035         exp = ["(((a,b)int1,(x,y,(w,z)int2,(f,e)int3)int4),(d,c)int5);\n",
3036                "(((a,b)int1,(x,y,(w,z)int2,(c,d)int3)int4),(e,f)int5);\n",
3037                "(((a,b)int1,(x,y,(w,z)int2,(f,e)int3)int4),(d,c)int5);\n",
3038                "(((a,b)int1,(x,y,(w,z)int2,(c,d)int3)int4),(e,f)int5);\n"]
3039         obs_g = self.complex_tree.shuffle(shuffle_f=self.rev_f,
3040                                           names=['c', 'd', 'e', 'f'], n=4)
3041         obs = [str(next(obs_g)) for i in range(4)]
3042         self.assertEqual(obs, exp)
3043     def test_shuffle_names(self):
3044         exp = ["((c,a)i1,(b,d)i2)root;\n",
3045                "((b,c)i1,(a,d)i2)root;\n",
3046                "((a,b)i1,(c,d)i2)root;\n",
3047                "((c,a)i1,(b,d)i2)root;\n"]
3048         obs_g = self.simple_t.shuffle(names=['a', 'b', 'c'],
3049                                       shuffle_f=self.rotate_f, n=np.inf)
3050         obs = [str(next(obs_g)) for i in range(4)]
3051         self.assertEqual(obs, exp)
3052     def test_shuffle_raises(self):
3053         with self.assertRaises(ValueError):
3054             next(self.simple_t.shuffle(k=1))
3055         with self.assertRaises(ValueError):
3056             next(self.simple_t.shuffle(k=5, names=['a', 'b']))
3057         with self.assertRaises(MissingNodeError):
3058             next(self.simple_t.shuffle(names=['x', 'y']))
3059     def test_assign_supports(self):
3060         tree = TreeNode.read(['((a,b)75,(c,d)90);'])
3061         tree.assign_supports<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>()
3062         node1, node2 = tree.children
3063         self.assertEqual(node1.support, 75)
3064         self.assertEqual(node2.support, 90)
3065         self.assertIsNone(node1.name)
3066         self.assertIsNone(node2.</b></font>name)
3067         self.assertIsNone(tree.support)
3068         for taxon in ('a', 'b', 'c', 'd'):
3069             self.assertIsNone(tree.find(taxon).support)
3070         tree = TreeNode.read(['((a,b)0.85:1.23,(c,d)0.95:4.56);'])
3071         tree.assign_supports()
3072         node1, node2 = tree.children
3073         self.assertEqual(node1.support, 0.85)
3074         self.assertEqual(node2.support, 0.95)
3075         tree = TreeNode.read(['((a,b)75,(c,d)80.0,(e,f)97.5,(g,h)0.95);'])
3076         tree.assign_supports()
3077         node1, node2, node3, node4 = tree.children
3078         self.assertTrue(isinstance(node1.support, int))
3079         self.assertEqual(node1.support, 75)
3080         self.assertTrue(isinstance(node2.support, float))
3081         self.assertEqual(node2.support, 80.0)
3082         self.assertTrue(isinstance(node3.support, float))
3083         self.assertEqual(node3.support, 97.5)
3084         self.assertTrue(isinstance(node4.support, float))
3085         self.assertEqual(node4.support, 0.95)
3086         tree = TreeNode.read(['((a,b)-1.23,(c,d)1.23e-4);'])
3087         tree.assign_supports()
3088         node1, node2 = tree.children
3089         self.assertEqual(node1.support, -1.23)
3090         tree = TreeNode.read([<font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>'((a,b)\'80:X\',(c,d)\'60:Y\');'])
3091         tree.assign_supports()
3092         node1, node2 = tree.children
3093         self.assertEqual(node1.support, 80)
3094         self.assertEqual(node1.name, 'X')
3095         self.assertEqual(node2.</b></font>support, 60)
3096         self.assertEqual(node2.name, 'Y')
3097         tree = TreeNode.read(['((a,b),(c,d)x,(e,f):1.0);'])
3098         tree.assign_supports()
3099         for node in tree.children:
3100             self.assertIsNone(node.support)
3101     def test_unpack(self):
3102         tree = TreeNode.read(['((c,d)a,(e,f)b);'])
3103         tree.find('b').unpack()
3104         exp = '((c,d)a,e,f);\n'
3105         self.assertEqual(str(tree), exp)
3106         tree = TreeNode.read(['((c:2.0,d:3.0)a:1.0,(e:2.0,f:1.0)b:2.0);'])
3107         tree.find('b').unpack()
3108         exp = '((c:2.0,d:3.0)a:1.0,e:4.0,f:3.0);'
3109         self.assertEqual(str(tree).rstrip(), exp)
3110         tree = TreeNode.read(['((d,e)b,(f,g)c)a;'])
3111         msg = 'Cannot unpack root.'
3112         with self.assertRaisesRegex(TreeError, msg):
3113             tree.find('a').unpack()
3114         msg = 'Cannot unpack tip.'
3115         with self.assertRaisesRegex(TreeError, msg):
3116             tree.find('d').unpack()
3117     def test_unpack_by_func(self):
3118         def func(x):
3119             return x.length &lt;= 1.0
3120         tree = TreeNode.read(['((c:2,d:3)a:1,(e:1,f:2)b:2);'])
3121         tree.unpack_by_func(func)
3122         exp = '((e:1.0,f:2.0)b:2.0,c:3.0,d:4.0);'
3123         self.assertEqual(str(tree).rstrip(), exp)
3124         tree = TreeNode.read(['((c:2,d:3)a:1,(e:1,f:2)b:2);'])
3125         tree.unpack_by_func(lambda x: x.length &lt;= 2.0)
3126         exp = '(c:3.0,d:4.0,e:3.0,f:4.0);'
3127         self.assertEqual(str(tree).rstrip(), exp)
3128         tree = TreeNode.read(['(((e:3,f:2)c:1,d:3)a:1,b:4);'])
3129         tree.unpack_by_func(lambda x: x.length &lt;= 2.0)
3130         exp = '(b:4.0,d:4.0,e:5.0,f:4.0);'
3131         self.assertEqual(str(tree).rstrip(), exp)
3132         def func(x):
3133             return x.length &lt; 2.0
3134         tree = TreeNode.read(['(((a:1.04,b:2.32,c:1.44)d:3.20,'
3135                               '(e:3.91,f:2.47)g:1.21)h:1.75,'
3136                               '(i:4.14,(j:2.06,k:1.58)l:3.32)m:0.77);'])
3137         tree.unpack_by_func(func)
3138         exp = ('((a:1.04,b:2.32,c:1.44)d:4.95,e:6.87,f:5.43,i:4.91,'
3139                '(j:2.06,k:1.58)l:4.09);')
3140         self.assertEqual(str(tree).rstrip(), exp)
3141         def func(x):
3142             return x.support &lt; 75
3143         tree = TreeNode.read(['(((a,b)85,(c,d)78)75,(e,(f,g)64)80);'])
3144         tree.assign_supports()
3145         tree.unpack_by_func(func)
3146         exp = '(((a,b)85,(c,d)78)75,(e,f,g)80);'
3147         self.assertEqual(str(tree).rstrip(), exp)
3148         tree = TreeNode.read(['(((a,b)85,(c,d)78)75,(e,(f,g)64)80);'])
3149         tree.assign_supports()
3150         tree.unpack_by_func(lambda x: x.support &lt; 85)
3151         exp = '((a,b)85,c,d,e,f,g);'
3152         self.assertEqual(str(tree).rstrip(), exp)
3153         tree = TreeNode.read(['(((a,b)0.97,(c,d)0.98)1.0,(e,(f,g)0.88)0.96);'])
3154         tree.assign_supports()
3155         tree.unpack_by_func(lambda x: x.support &lt; 0.95)
3156         exp = '(((a,b)0.97,(c,d)0.98)1.0,(e,f,g)0.96);'
3157         self.assertEqual(str(tree).rstrip(), exp)
3158         tree = TreeNode.read(['(((a:1.02,b:0.33)85:0.12,(c:0.86,d:2.23)'
3159                               '70:3.02)75:0.95,(e:1.43,(f:1.69,g:1.92)64:0.20)'
3160                               'node:0.35)root;'])
3161         tree.assign_supports()
3162         tree.unpack_by_func(lambda x: x.support is not None and x.support &lt; 75)
3163         exp = ('(((a:1.02,b:0.33)85:0.12,c:3.88,d:5.25)75:0.95,'
3164                '(e:1.43,f:1.89,g:2.12)node:0.35)root;')
3165         self.assertEqual(str(tree).rstrip(), exp)
3166 sample = """
3167 (
3168 (
3169 xyz:0.28124,
3170 (
3171 def:0.24498,
3172 mno:0.03627)
3173 :0.17710)
3174 :0.04870,
3175 abc:0.05925,
3176 (
3177 ghi:0.06914,
3178 jkl:0.13776)
3179 :0.09853);
3180 """
3181 node_data_sample = """
3182 (
3183 (
3184 xyz:0.28124,
3185 (
3186 def:0.24498,
3187 mno:0.03627)
3188 'A':0.17710)
3189 B:0.04870,
3190 abc:0.05925,
3191 (
3192 ghi:0.06914,
3193 jkl:0.13776)
3194 C:0.09853);
3195 """
3196 minimal = "();"
3197 no_names = "((,),(,));"
3198 missing_tip_name = "((a,b),(c,));"
3199 empty = '();'
3200 single = '(abc:3);'
3201 double = '(abc:3, def:4);'
3202 onenest = '(abc:3, (def:4, ghi:5):6 );'
3203 nodedata = '(abc:3, (def:4, ghi:5)jkl:6 );'
3204 exp_ascii_art_three_children = r"""          /-a
3205          |
3206 ---------|          /-b
3207          |         |
3208           \--------|--c
3209                    |
3210                     \-d"""
3211 if __name__ == '__main__':
3212     main()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
