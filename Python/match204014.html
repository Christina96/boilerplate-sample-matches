<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_runner_returns.py & test_cmdmod.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_runner_returns.py & test_cmdmod.py
      </h3>
      <h1 align="center">
        1.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_runner_returns.py (5.5555553%)<TH>test_cmdmod.py (0.9448819%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match204014-0.html#0',2,'match204014-1.html#0',3)" NAME="0">(5-17)<TD><A HREF="javascript:ZweiFrames('match204014-0.html#0',2,'match204014-1.html#0',3)" NAME="0">(7-19)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_runner_returns.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
<A NAME="0"></A>Tests for runner_returns
&quot;&quot;&quot;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match204014-1.html#0',3,'match204014-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import errno
import os
import socket
import tempfile

import pytest
import salt.payload
import salt.utils.args
import salt.utils.files
import salt.utils.jid
import salt.utils.yaml
from tests.support.case import ShellCase
from</B></FONT> tests.support.runtests import RUNTIME_VARS


@pytest.mark.windows_whitelisted
class RunnerReturnsTest(ShellCase):
    &quot;&quot;&quot;
    Test the &quot;runner_returns&quot; feature
    &quot;&quot;&quot;

    def setUp(self):
        &quot;&quot;&quot;
        Create the temp file and master.d directory
        &quot;&quot;&quot;
        self.job_dir = os.path.join(self.master_opts[&quot;cachedir&quot;], &quot;jobs&quot;)
        self.hash_type = self.master_opts[&quot;hash_type&quot;]
        self.master_d_dir = os.path.join(self.config_dir, &quot;master.d&quot;)
        try:
            os.makedirs(self.master_d_dir)
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise

        self.conf = tempfile.NamedTemporaryFile(
            mode=&quot;w&quot;,
            suffix=&quot;.conf&quot;,
            dir=self.master_d_dir,
            delete=False,
        )

    def tearDown(self):
        &quot;&quot;&quot;
        Close the tempfile.NamedTemporaryFile object, cleaning it up
        &quot;&quot;&quot;
        try:
            self.conf.close()
        except OSError:
            pass
        salt.utils.files.rm_rf(self.master_d_dir)
        # Force a reload of the configuration now that our temp config file has
        # been removed.
        self.run_run_plus(&quot;test.arg&quot;)

    @staticmethod
    def clean_return(data):
        &quot;&quot;&quot;
        Remove kwargs and timestamp (things that are variable) so we have a
        stable value to assert
        &quot;&quot;&quot;
        # Remove pub_kwargs
        data[&quot;fun_args&quot;][1] = salt.utils.args.clean_kwargs(**data[&quot;fun_args&quot;][1])
        data[&quot;return&quot;][&quot;kwargs&quot;] = salt.utils.args.clean_kwargs(
            **data[&quot;return&quot;][&quot;kwargs&quot;]
        )

        # Pop off dynamic keys in the return schema that are impossible to test.
        # Do not supply the default arguments because we want to know if we are
        # missing some aspect of the schema.
        data.pop(&quot;_stamp&quot;)

    def write_conf(self, data):
        &quot;&quot;&quot;
        Dump the config dict to the conf file
        &quot;&quot;&quot;
        self.conf.write(salt.utils.yaml.safe_dump(data, default_flow_style=False))
        self.conf.flush()
        self.conf.close()

    @pytest.mark.slow_test
    def test_runner_returns_disabled(self):
        &quot;&quot;&quot;
        Test with runner_returns disabled
        &quot;&quot;&quot;
        self.write_conf({&quot;runner_returns&quot;: False})
        ret = self.run_run_plus(&quot;test.arg&quot;, &quot;foo&quot;, bar=&quot;hello world!&quot;)

        jid = ret.get(&quot;jid&quot;)
        if jid is None:
            raise Exception(&quot;jid missing from run_run_plus output&quot;)

        serialized_return = os.path.join(
            salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
            &quot;master&quot;,
            &quot;return.p&quot;,
        )
        self.assertFalse(os.path.isfile(serialized_return))

    @pytest.mark.slow_test
    def test_runner_returns_enabled(self):
        &quot;&quot;&quot;
        Test with runner_returns enabled
        &quot;&quot;&quot;
        self.write_conf({&quot;runner_returns&quot;: True})
        ret = self.run_run_plus(&quot;test.arg&quot;, &quot;foo&quot;, bar=&quot;hello world!&quot;)

        jid = ret.get(&quot;jid&quot;)
        if jid is None:
            raise Exception(&quot;jid missing from run_run_plus output&quot;)

        serialized_return = os.path.join(
            salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
            &quot;master&quot;,
            &quot;return.p&quot;,
        )
        with salt.utils.files.fopen(serialized_return, &quot;rb&quot;) as fp_:
            deserialized = salt.payload.loads(fp_.read(), encoding=&quot;utf-8&quot;)

        self.clean_return(deserialized[&quot;return&quot;])

        # Now we have something sane we can reliably compare in an assert.
        if &quot;SUDO_USER&quot; in os.environ:
            user = &quot;sudo_{}&quot;.format(os.environ[&quot;SUDO_USER&quot;])
        else:
            user = RUNTIME_VARS.RUNNING_TESTS_USER
        if salt.utils.platform.is_windows():
            user = &quot;sudo_{}\\{}&quot;.format(socket.gethostname(), user)
        self.assertEqual(
            deserialized,
            {
                &quot;return&quot;: {
                    &quot;fun&quot;: &quot;runner.test.arg&quot;,
                    &quot;fun_args&quot;: [&quot;foo&quot;, {&quot;bar&quot;: &quot;hello world!&quot;}],
                    &quot;jid&quot;: jid,
                    &quot;return&quot;: {&quot;args&quot;: [&quot;foo&quot;], &quot;kwargs&quot;: {&quot;bar&quot;: &quot;hello world!&quot;}},
                    &quot;success&quot;: True,
                    &quot;user&quot;: user,
                }
            },
        )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cmdmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Nicole Thomas &lt;nicole@saltstack.com&gt;

<A NAME="0"></A>    Unit tests for the salt.modules.cmdmod module
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match204014-0.html#0',2,'match204014-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import builtins
import getpass
import logging
import os
import re
import sys
import tempfile

import pytest
import salt.modules.cmdmod as cmdmod
import salt.utils.files
import salt.utils.platform
import</B></FONT> salt.utils.stringutils
from salt.exceptions import CommandExecutionError
from salt.log.setup import LOG_LEVELS
from tests.support.mock import MagicMock, Mock, MockTimedProc, mock_open, patch
from tests.support.runtests import RUNTIME_VARS

DEFAULT_SHELL = &quot;foo/bar&quot;
MOCK_SHELL_FILE = &quot;# List of acceptable shells\n\n/bin/bash\n&quot;


@pytest.fixture
def configure_loader_modules():
    opts = salt.config.DEFAULT_MINION_OPTS.copy()
    return {cmdmod: {&quot;__opts__&quot;: opts}}


@pytest.fixture(scope=&quot;module&quot;)
def mock_loglevels():
    return {
        &quot;info&quot;: &quot;foo&quot;,
        &quot;all&quot;: &quot;bar&quot;,
        &quot;critical&quot;: &quot;bar&quot;,
        &quot;trace&quot;: &quot;bar&quot;,
        &quot;garbage&quot;: &quot;bar&quot;,
        &quot;error&quot;: &quot;bar&quot;,
        &quot;debug&quot;: &quot;bar&quot;,
        &quot;warning&quot;: &quot;bar&quot;,
        &quot;quiet&quot;: &quot;bar&quot;,
    }


def test_render_cmd_no_template():
    &quot;&quot;&quot;
    Tests return when template=None
    &quot;&quot;&quot;
    assert cmdmod._render_cmd(&quot;foo&quot;, &quot;bar&quot;, None) == (&quot;foo&quot;, &quot;bar&quot;)


def test_render_cmd_saltenv_from_config():
    mock_template = MagicMock()
    with patch.dict(cmdmod.__opts__, {&quot;saltenv&quot;: &quot;base&quot;}):
        with patch.dict(
            &quot;salt.utils.templates.TEMPLATE_REGISTRY&quot;, {&quot;test&quot;: mock_template}
        ):
            cmdmod._render_cmd(&quot;test&quot;, &quot;test&quot;, &quot;test&quot;)
            assert mock_template.call_count == 2
            assert mock_template.call_args[1][&quot;saltenv&quot;] == &quot;base&quot;
            cmdmod._render_cmd(&quot;test&quot;, &quot;test&quot;, &quot;test&quot;, saltenv=&quot;fake&quot;)
            assert mock_template.call_count == 4
            assert mock_template.call_args[1][&quot;saltenv&quot;] == &quot;fake&quot;


def test_render_cmd_unavailable_engine():
    &quot;&quot;&quot;
    Tests CommandExecutionError raised when template isn't in the
    template registry
    &quot;&quot;&quot;
    with pytest.raises(CommandExecutionError):
        cmdmod._render_cmd(&quot;boo&quot;, &quot;bar&quot;, &quot;baz&quot;)


def test_check_loglevel_bad_level(mock_loglevels):
    &quot;&quot;&quot;
    Tests return of providing an invalid loglevel option
    &quot;&quot;&quot;
    with patch.dict(LOG_LEVELS, mock_loglevels):
        assert cmdmod._check_loglevel(level=&quot;bad_loglevel&quot;) == &quot;foo&quot;


def test_check_loglevel_bad_level_not_str(mock_loglevels):
    &quot;&quot;&quot;
    Tests the return of providing an invalid loglevel option that is not a string
    &quot;&quot;&quot;
    with patch.dict(LOG_LEVELS, mock_loglevels):
        assert cmdmod._check_loglevel(level=1000) == &quot;foo&quot;


def test_check_loglevel_quiet(mock_loglevels):
    &quot;&quot;&quot;
    Tests the return of providing a loglevel of 'quiet'
    &quot;&quot;&quot;
    with patch.dict(LOG_LEVELS, mock_loglevels):
        assert cmdmod._check_loglevel(level=&quot;quiet&quot;) is None


def test_parse_env_not_env():
    &quot;&quot;&quot;
    Tests the return of an env that is not an env
    &quot;&quot;&quot;
    assert cmdmod._parse_env(None) == {}


def test_parse_env_list():
    &quot;&quot;&quot;
    Tests the return of an env that is a list
    &quot;&quot;&quot;
    ret = {&quot;foo&quot;: None, &quot;bar&quot;: None}
    assert ret == cmdmod._parse_env([&quot;foo&quot;, &quot;bar&quot;])


def test_parse_env_dict():
    &quot;&quot;&quot;
    Test the return of an env that is not a dict
    &quot;&quot;&quot;
    assert cmdmod._parse_env(&quot;test&quot;) == {}


def test_run_shell_is_not_file():
    &quot;&quot;&quot;
    Tests error raised when shell is not available after _is_valid_shell error msg
    and os.path.isfile returns False
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, MagicMock(return_value=False)):
                with pytest.raises(CommandExecutionError):
                    cmdmod._run(&quot;foo&quot;, &quot;bar&quot;)


def test_run_shell_file_no_access():
    &quot;&quot;&quot;
    Tests error raised when shell is not available after _is_valid_shell error msg,
    os.path.isfile returns True, but os.access returns False
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, MagicMock(return_value=True)):
                with patch(&quot;os.access&quot;, MagicMock(return_value=False)):
                    with pytest.raises(CommandExecutionError):
                        cmdmod._run(&quot;foo&quot;, &quot;bar&quot;)


def test_run_runas_with_windows():
    &quot;&quot;&quot;
    Tests error raised when runas is passed on windows
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=True)):
            with patch(
                &quot;salt.utils.win_chcp.get_codepage_id&quot;, MagicMock(return_value=65001)
            ):
                with patch.dict(cmdmod.__grains__, {&quot;os&quot;: &quot;fake_os&quot;}):
                    with pytest.raises(CommandExecutionError):
                        cmdmod._run(&quot;foo&quot;, &quot;bar&quot;, runas=&quot;baz&quot;)


def test_run_with_tuple():
    &quot;&quot;&quot;
    Tests return when cmd is a tuple
    &quot;&quot;&quot;
    mock_true = MagicMock(return_value=True)
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, mock_true):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, mock_true):
                with patch(&quot;os.access&quot;, mock_true):
                    cmdmod._run((&quot;echo&quot;, &quot;foo&quot;), python_shell=True, cwd=&quot;/&quot;)


def test_run_user_not_available():
    &quot;&quot;&quot;
    Tests return when runas user is not available
    &quot;&quot;&quot;
    mock_true = MagicMock(return_value=True)
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, mock_true):
        with patch(&quot;os.path.isfile&quot;, mock_true):
            with patch(&quot;os.access&quot;, mock_true):
                with pytest.raises(CommandExecutionError):
                    cmdmod._run(&quot;foo&quot;, &quot;bar&quot;, runas=&quot;baz&quot;)


def test_run_zero_umask():
    &quot;&quot;&quot;
    Tests error raised when umask is set to zero
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, MagicMock(return_value=True)):
                with patch(&quot;os.access&quot;, MagicMock(return_value=True)):
                    with pytest.raises(CommandExecutionError):
                        cmdmod._run(&quot;foo&quot;, &quot;bar&quot;, umask=0)


def test_run_invalid_umask():
    &quot;&quot;&quot;
    Tests error raised when an invalid umask is given
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, MagicMock(return_value=True)):
                with patch(&quot;os.access&quot;, MagicMock(return_value=True)):
                    pytest.raises(
                        CommandExecutionError,
                        cmdmod._run,
                        &quot;foo&quot;,
                        &quot;bar&quot;,
                        umask=&quot;baz&quot;,
                    )


def test_run_invalid_cwd_not_abs_path():
    &quot;&quot;&quot;
    Tests error raised when cwd is not an absolute path
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, MagicMock(return_value=True)):
                with patch(&quot;os.access&quot;, MagicMock(return_value=True)):
                    with pytest.raises(CommandExecutionError):
                        cmdmod._run(&quot;foo&quot;, &quot;bar&quot;)


def test_run_invalid_cwd_not_dir():
    &quot;&quot;&quot;
    Tests error raised when cwd is not a dir
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, MagicMock(return_value=True)):
                with patch(&quot;os.access&quot;, MagicMock(return_value=True)):
                    with patch(&quot;os.path.isabs&quot;, MagicMock(return_value=True)):
                        with pytest.raises(CommandExecutionError):
                            cmdmod._run(&quot;foo&quot;, &quot;bar&quot;)


def test_run_no_vt_os_error():
    &quot;&quot;&quot;
    Tests error raised when not useing vt and OSError is provided
    &quot;&quot;&quot;
    expected_error = &quot;expect error&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, MagicMock(return_value=True)):
                with patch(&quot;os.access&quot;, MagicMock(return_value=True)):
                    with patch(
                        &quot;salt.utils.timed_subprocess.TimedProc&quot;,
                        MagicMock(side_effect=OSError(expected_error)),
                    ):
                        with pytest.raises(CommandExecutionError) as error:
                            cmdmod.run(&quot;foo&quot;, cwd=&quot;/&quot;)
                        assert error.value.args[0].endswith(expected_error)


def test_run_no_vt_io_error():
    &quot;&quot;&quot;
    Tests error raised when not useing vt and IOError is provided
    &quot;&quot;&quot;
    expected_error = &quot;expect error&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, MagicMock(return_value=True)):
                with patch(&quot;os.access&quot;, MagicMock(return_value=True)):
                    with patch(
                        &quot;salt.utils.timed_subprocess.TimedProc&quot;,
                        MagicMock(side_effect=IOError(expected_error)),
                    ):
                        with pytest.raises(CommandExecutionError) as error:
                            cmdmod.run(&quot;foo&quot;, cwd=&quot;/&quot;)
                        assert error.value.args[0].endswith(expected_error)


@pytest.mark.skip(reason=&quot;Test breaks unittests runs&quot;)
@pytest.mark.skip_on_windows
def test_run():
    &quot;&quot;&quot;
    Tests end result when a command is not found
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.cmdmod._is_valid_shell&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=False)):
            with patch(&quot;os.path.isfile&quot;, MagicMock(return_value=True)):
                with patch(&quot;os.access&quot;, MagicMock(return_value=True)):
                    ret = cmdmod._run(&quot;foo&quot;, cwd=os.getcwd(), use_vt=True).get(&quot;stderr&quot;)
                    assert &quot;foo&quot; in ret


@pytest.mark.skip_unless_on_windows
def test_powershell():
    &quot;&quot;&quot;
    Tests cmd.powershell with a string value output
    &quot;&quot;&quot;
    mock_run = {&quot;pid&quot;: 1234, &quot;retcode&quot;: 0, &quot;stderr&quot;: &quot;&quot;, &quot;stdout&quot;: '&quot;foo&quot;'}
    with patch(&quot;salt.modules.cmdmod._run&quot;, return_value=mock_run):
        ret = cmdmod.powershell(&quot;Set-ExecutionPolicy RemoteSigned&quot;)
        assert ret == &quot;foo&quot;


@pytest.mark.skip_unless_on_windows
def test_powershell_empty():
    &quot;&quot;&quot;
    Tests cmd.powershell when the output is an empty string
    &quot;&quot;&quot;
    mock_run = {&quot;pid&quot;: 1234, &quot;retcode&quot;: 0, &quot;stderr&quot;: &quot;&quot;, &quot;stdout&quot;: &quot;&quot;}
    with patch(&quot;salt.modules.cmdmod._run&quot;, return_value=mock_run):
        ret = cmdmod.powershell(&quot;Set-ExecutionPolicy RemoteSigned&quot;)
        assert ret == {}


def test_is_valid_shell_windows():
    &quot;&quot;&quot;
    Tests return if running on windows
    &quot;&quot;&quot;
    with patch(&quot;salt.utils.platform.is_windows&quot;, MagicMock(return_value=True)):
        assert cmdmod._is_valid_shell(&quot;foo&quot;)


@pytest.mark.skip_on_windows
def test_is_valid_shell_none():
    &quot;&quot;&quot;
    Tests return of when os.path.exists(/etc/shells) isn't available
    &quot;&quot;&quot;
    with patch(&quot;os.path.exists&quot;, MagicMock(return_value=False)):
        assert cmdmod._is_valid_shell(&quot;foo&quot;) is None


def test_is_valid_shell_available():
    &quot;&quot;&quot;
    Tests return when provided shell is available
    &quot;&quot;&quot;
    with patch(&quot;os.path.exists&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.files.fopen&quot;, mock_open(read_data=MOCK_SHELL_FILE)):
            assert cmdmod._is_valid_shell(&quot;/bin/bash&quot;)


@pytest.mark.skip_on_windows
def test_is_valid_shell_unavailable():
    &quot;&quot;&quot;
    Tests return when provided shell is not available
    &quot;&quot;&quot;
    with patch(&quot;os.path.exists&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.utils.files.fopen&quot;, mock_open(read_data=MOCK_SHELL_FILE)):
            assert not cmdmod._is_valid_shell(&quot;foo&quot;)


@pytest.mark.skip_on_windows
def test_os_environment_remains_intact():
    &quot;&quot;&quot;
    Make sure the OS environment is not tainted after running a command
    that specifies runas.
    &quot;&quot;&quot;
    with patch(&quot;pwd.getpwnam&quot;) as getpwnam_mock:
        with patch(&quot;subprocess.Popen&quot;) as popen_mock:
            environment = os.environ.copy()

            popen_mock.return_value = Mock(
                communicate=lambda *args, **kwags: [b&quot;&quot;, None],
                pid=lambda: 1,
                retcode=0,
            )

            with patch.dict(
                cmdmod.__grains__, {&quot;os&quot;: &quot;Darwin&quot;, &quot;os_family&quot;: &quot;Solaris&quot;}
            ):
                if sys.platform.startswith((&quot;freebsd&quot;, &quot;openbsd&quot;)):
                    shell = &quot;/bin/sh&quot;
                else:
                    shell = &quot;/bin/bash&quot;

                cmdmod._run(
                    &quot;ls&quot;, cwd=tempfile.gettempdir(), runas=&quot;foobar&quot;, shell=shell
                )

                environment2 = os.environ.copy()

                assert environment == environment2

                if not salt.utils.platform.is_darwin():
                    getpwnam_mock.assert_called_with(&quot;foobar&quot;)


@pytest.mark.skip_on_windows
def test_os_environment_do_not_pass_notify_socket():
    &quot;&quot;&quot;
    Make sure NOTIFY_SOCKET environment variable is not passed
    to the command if not explicitly set with env parameter.
    &quot;&quot;&quot;
    with patch(&quot;pwd.getpwnam&quot;) as getpwnam_mock:
        new_env = os.environ.copy()
        new_env.update({&quot;NOTIFY_SOCKET&quot;: &quot;/run/systemd/notify&quot;})
        with patch(&quot;subprocess.Popen&quot;) as popen_mock, patch(
            &quot;os.environ.copy&quot;, return_value=new_env
        ):
            popen_mock.return_value = Mock(
                communicate=lambda *args, **kwags: [b&quot;&quot;, None],
                pid=lambda: 1,
                retcode=0,
            )

            with patch.dict(cmdmod.__grains__, {&quot;os&quot;: &quot;SUSE&quot;, &quot;os_family&quot;: &quot;Suse&quot;}):
                if sys.platform.startswith((&quot;freebsd&quot;, &quot;openbsd&quot;)):
                    shell = &quot;/bin/sh&quot;
                else:
                    shell = &quot;/bin/bash&quot;

                cmdmod._run(&quot;ls&quot;, cwd=tempfile.gettempdir(), shell=shell)

                assert &quot;NOTIFY_SOCKET&quot; not in popen_mock.call_args_list[0][1][&quot;env&quot;]

                cmdmod._run(
                    &quot;ls&quot;,
                    cwd=tempfile.gettempdir(),
                    shell=shell,
                    env={&quot;NOTIFY_SOCKET&quot;: &quot;/run/systemd/notify.new&quot;},
                )

                assert (
                    popen_mock.call_args_list[1][1][&quot;env&quot;][&quot;NOTIFY_SOCKET&quot;]
                    == &quot;/run/systemd/notify.new&quot;
                )


@pytest.mark.skip_unless_on_darwin
def test_shell_properly_handled_on_macOS():
    &quot;&quot;&quot;
    cmd.run should invoke a new bash login only
    when bash is the default shell for the selected user
    &quot;&quot;&quot;

    class _CommandHandler:
        &quot;&quot;&quot;
        Class for capturing cmd
        &quot;&quot;&quot;

        def __init__(self):
            self.cmd = None

        def clear(self):
            self.cmd = None

    cmd_handler = _CommandHandler()

    def mock_proc(__cmd__, **kwargs):
        cmd_handler.cmd = &quot; &quot;.join(__cmd__)
        return MagicMock(return_value=MockTimedProc(stdout=None, stderr=None))

    with patch(&quot;pwd.getpwnam&quot;) as getpwnam_mock:
        with patch(&quot;salt.utils.timed_subprocess.TimedProc&quot;, mock_proc):

            # User default shell is '/usr/local/bin/bash'
            user_default_shell = &quot;/usr/local/bin/bash&quot;
            with patch.dict(
                cmdmod.__salt__,
                {&quot;user.info&quot;: MagicMock(return_value={&quot;shell&quot;: user_default_shell})},
            ):

                cmd_handler.clear()
                cmdmod._run(
                    &quot;ls&quot;, cwd=tempfile.gettempdir(), runas=&quot;foobar&quot;, use_vt=False
                )

                assert re.search(
                    &quot;{} -l -c&quot;.format(user_default_shell), cmd_handler.cmd
                ), &quot;cmd invokes right bash session on macOS&quot;

            # User default shell is '/bin/zsh'
            user_default_shell = &quot;/bin/zsh&quot;
            with patch.dict(
                cmdmod.__salt__,
                {&quot;user.info&quot;: MagicMock(return_value={&quot;shell&quot;: user_default_shell})},
            ):

                cmd_handler.clear()
                cmdmod._run(
                    &quot;ls&quot;, cwd=tempfile.gettempdir(), runas=&quot;foobar&quot;, use_vt=False
                )

                assert not re.search(
                    &quot;bash -l -c&quot;, cmd_handler.cmd
                ), &quot;cmd does not invoke user shell on macOS&quot;


def test_run_cwd_doesnt_exist_issue_7154():
    &quot;&quot;&quot;
    cmd.run should fail and raise
    salt.exceptions.CommandExecutionError if the cwd dir does not
    exist
    &quot;&quot;&quot;
    cmd = &quot;echo OHAI&quot;
    cwd = &quot;/path/to/nowhere&quot;
    with pytest.raises(CommandExecutionError):
        cmdmod.run_all(cmd, cwd=cwd)


@pytest.mark.skip_on_darwin
@pytest.mark.skip_on_windows
def test_run_cwd_in_combination_with_runas():
    &quot;&quot;&quot;
    cmd.run executes command in the cwd directory
    when the runas parameter is specified
    &quot;&quot;&quot;
    cmd = &quot;pwd&quot;
    cwd = &quot;/tmp&quot;
    runas = getpass.getuser()

    with patch.dict(cmdmod.__grains__, {&quot;os&quot;: &quot;Darwin&quot;, &quot;os_family&quot;: &quot;Solaris&quot;}):
        stdout = cmdmod._run(cmd, cwd=cwd, runas=runas).get(&quot;stdout&quot;)
    assert stdout == cwd


def test_run_all_binary_replace():
    &quot;&quot;&quot;
    Test for failed decoding of binary data, for instance when doing
    something silly like using dd to read from /dev/urandom and write to
    /dev/stdout.
    &quot;&quot;&quot;
    # Since we're using unicode_literals, read the random bytes from a file
    rand_bytes_file = os.path.join(RUNTIME_VARS.BASE_FILES, &quot;random_bytes&quot;)
    with salt.utils.files.fopen(rand_bytes_file, &quot;rb&quot;) as fp_:
        stdout_bytes = fp_.read()

    # kitchen-salt uses unix2dos on all the files before copying them over
    # to the vm that will be running the tests. It skips binary files though
    # The file specified in `rand_bytes_file` is detected as binary so the
    # Unix-style line ending remains. This should account for that.
    stdout_bytes = stdout_bytes.rstrip() + os.linesep.encode()

    # stdout with the non-decodable bits replaced with the unicode
    # replacement character U+FFFD.
    stdout_unicode = &quot;\ufffd\x1b\ufffd\ufffd&quot; + os.linesep
    stderr_bytes = (
        os.linesep.encode().join(
            [
                b&quot;1+0 records in&quot;,
                b&quot;1+0 records out&quot;,
                b&quot;4 bytes copied, 9.1522e-05 s, 43.7 kB/s&quot;,
            ]
        )
        + os.linesep.encode()
    )
    stderr_unicode = stderr_bytes.decode()

    proc = MagicMock(
        return_value=MockTimedProc(stdout=stdout_bytes, stderr=stderr_bytes)
    )
    with patch(&quot;salt.utils.timed_subprocess.TimedProc&quot;, proc):
        ret = cmdmod.run_all(
            &quot;dd if=/dev/urandom of=/dev/stdout bs=4 count=1&quot;, rstrip=False
        )

    assert ret[&quot;stdout&quot;] == stdout_unicode
    assert ret[&quot;stderr&quot;] == stderr_unicode


def test_run_all_none():
    &quot;&quot;&quot;
    Tests cases when proc.stdout or proc.stderr are None. These should be
    caught and replaced with empty strings.
    &quot;&quot;&quot;
    proc = MagicMock(return_value=MockTimedProc(stdout=None, stderr=None))
    with patch(&quot;salt.utils.timed_subprocess.TimedProc&quot;, proc):
        ret = cmdmod.run_all(&quot;some command&quot;, rstrip=False)

    assert ret[&quot;stdout&quot;] == &quot;&quot;
    assert ret[&quot;stderr&quot;] == &quot;&quot;


def test_run_all_unicode():
    &quot;&quot;&quot;
    Ensure that unicode stdout and stderr are decoded properly
    &quot;&quot;&quot;
    stdout_unicode = &quot;Here is some unicode: спам&quot;
    stderr_unicode = &quot;Here is some unicode: яйца&quot;
    stdout_bytes = stdout_unicode.encode(&quot;utf-8&quot;)
    stderr_bytes = stderr_unicode.encode(&quot;utf-8&quot;)

    proc = MagicMock(
        return_value=MockTimedProc(stdout=stdout_bytes, stderr=stderr_bytes)
    )

    with patch(&quot;salt.utils.timed_subprocess.TimedProc&quot;, proc), patch.object(
        builtins, &quot;__salt_system_encoding__&quot;, &quot;utf-8&quot;
    ):
        ret = cmdmod.run_all(&quot;some command&quot;, rstrip=False)

    assert ret[&quot;stdout&quot;] == stdout_unicode
    assert ret[&quot;stderr&quot;] == stderr_unicode


def test_run_all_output_encoding():
    &quot;&quot;&quot;
    Test that specifying the output encoding works as expected
    &quot;&quot;&quot;
    stdout = &quot;Æ&quot;
    stdout_latin1_enc = stdout.encode(&quot;latin1&quot;)

    proc = MagicMock(return_value=MockTimedProc(stdout=stdout_latin1_enc))

    with patch(&quot;salt.utils.timed_subprocess.TimedProc&quot;, proc), patch.object(
        builtins, &quot;__salt_system_encoding__&quot;, &quot;utf-8&quot;
    ):
        ret = cmdmod.run_all(&quot;some command&quot;, output_encoding=&quot;latin1&quot;)

    assert ret[&quot;stdout&quot;] == stdout


def test_run_all_output_loglevel_quiet(caplog):
    &quot;&quot;&quot;
    Test that specifying quiet for loglevel
    does not log the command.
    &quot;&quot;&quot;
    stdout = b&quot;test&quot;
    proc = MagicMock(return_value=MockTimedProc(stdout=stdout))

    msg = &quot;Executing command 'some command' in directory&quot;
    with patch(&quot;salt.utils.timed_subprocess.TimedProc&quot;, proc):
        with caplog.at_level(logging.DEBUG, logger=&quot;salt.modules.cmdmod&quot;):
            ret = cmdmod.run_all(&quot;some command&quot;, output_loglevel=&quot;quiet&quot;)
        assert msg not in caplog.text

    assert ret[&quot;stdout&quot;] == salt.utils.stringutils.to_unicode(stdout)


def test_run_all_output_loglevel_debug(caplog):
    &quot;&quot;&quot;
    Test that specifying debug for loglevel
    does log the command.
    &quot;&quot;&quot;
    stdout = b&quot;test&quot;
    proc = MagicMock(return_value=MockTimedProc(stdout=stdout))

    msg = &quot;Executing command 'some' in directory&quot;
    with patch(&quot;salt.utils.timed_subprocess.TimedProc&quot;, proc):
        with caplog.at_level(logging.DEBUG, logger=&quot;salt.modules.cmdmod&quot;):
            ret = cmdmod.run_all(&quot;some command&quot;, output_loglevel=&quot;debug&quot;)
        assert msg in caplog.text

    assert ret[&quot;stdout&quot;] == salt.utils.stringutils.to_unicode(stdout)


def test_run_chroot_mount():
    &quot;&quot;&quot;
    Test cmdmod.run_chroot mount / umount balance
    &quot;&quot;&quot;
    mock_mount = MagicMock()
    mock_umount = MagicMock()
    mock_run_all = MagicMock()
    with patch.dict(
        cmdmod.__salt__, {&quot;mount.mount&quot;: mock_mount, &quot;mount.umount&quot;: mock_umount}
    ):
        with patch(&quot;salt.modules.cmdmod.run_all&quot;, mock_run_all):
            cmdmod.run_chroot(&quot;/mnt&quot;, &quot;cmd&quot;)
            assert mock_mount.call_count == 3
            assert mock_umount.call_count == 3


def test_run_chroot_mount_bind():
    &quot;&quot;&quot;
    Test cmdmod.run_chroot mount / umount balance with bind mount
    &quot;&quot;&quot;
    mock_mount = MagicMock()
    mock_umount = MagicMock()
    mock_run_all = MagicMock()
    with patch.dict(
        cmdmod.__salt__, {&quot;mount.mount&quot;: mock_mount, &quot;mount.umount&quot;: mock_umount}
    ):
        with patch(&quot;salt.modules.cmdmod.run_all&quot;, mock_run_all):
            cmdmod.run_chroot(&quot;/mnt&quot;, &quot;cmd&quot;, binds=[&quot;/var&quot;])
            assert mock_mount.call_count == 4
            assert mock_umount.call_count == 4


@pytest.mark.skip_on_windows
def test_run_chroot_runas():
    &quot;&quot;&quot;
    Test run_chroot when a runas parameter is provided
    &quot;&quot;&quot;
    with patch.dict(
        cmdmod.__salt__, {&quot;mount.mount&quot;: MagicMock(), &quot;mount.umount&quot;: MagicMock()}
    ):
        with patch(&quot;salt.modules.cmdmod.run_all&quot;) as run_all_mock:
            cmdmod.run_chroot(&quot;/mnt&quot;, &quot;ls&quot;, runas=&quot;foobar&quot;, shell=&quot;/bin/sh&quot;)
    run_all_mock.assert_called_with(
        &quot;chroot --userspec foobar: /mnt /bin/sh -c ls&quot;,
        bg=False,
        clean_env=False,
        cwd=None,
        env=None,
        ignore_retcode=False,
        log_callback=None,
        output_encoding=None,
        output_loglevel=&quot;quiet&quot;,
        pillar=None,
        pillarenv=None,
        python_shell=True,
        reset_system_locale=True,
        rstrip=True,
        saltenv=None,
        shell=&quot;/bin/sh&quot;,
        stdin=None,
        success_retcodes=None,
        success_stdout=None,
        success_stderr=None,
        template=None,
        timeout=None,
        umask=None,
        use_vt=False,
    )


def test_cve_2021_25284(caplog):
    proc = MagicMock(
        return_value=MockTimedProc(stdout=b&quot;foo&quot;, stderr=b&quot;wtf&quot;, returncode=2)
    )
    with patch(&quot;salt.utils.timed_subprocess.TimedProc&quot;, proc):
        with caplog.at_level(logging.DEBUG, logger=&quot;salt.modules.cmdmod&quot;):
            cmdmod.run(&quot;testcmd -p ImAPassword&quot;, output_loglevel=&quot;error&quot;)
        assert &quot;ImAPassword&quot; not in caplog.text


def test__log_cmd_str():
    &quot;_log_cmd function handles strings&quot;
    assert cmdmod._log_cmd(&quot;foo bar&quot;) == &quot;foo&quot;


def test__log_cmd_list():
    &quot;_log_cmd function handles lists&quot;
    assert cmdmod._log_cmd([&quot;foo&quot;, &quot;bar&quot;]) == &quot;foo&quot;


def test_log_cmd_tuple():
    &quot;_log_cmd function handles tuples&quot;
    assert cmdmod._log_cmd((&quot;foo&quot;, &quot;bar&quot;)) == &quot;foo&quot;


def test_log_cmd_non_str_tuple_list():
    &quot;_log_cmd function casts objects to strings&quot;

    class cmd:
        def __init__(self, cmd):
            self.cmd = cmd

        def __str__(self):
            return self.cmd

    assert cmdmod._log_cmd(cmd(&quot;foo bar&quot;)) == &quot;foo&quot;


@pytest.mark.skip_on_windows
def test_cmd_script_saltenv_from_config():
    mock_cp_get_template = MagicMock()
    mock_cp_cache_file = MagicMock()
    mock_run = MagicMock()
    with patch.dict(cmdmod.__opts__, {&quot;saltenv&quot;: &quot;base&quot;}):
        with patch.dict(
            cmdmod.__salt__,
            {
                &quot;cp.cache_file&quot;: mock_cp_cache_file,
                &quot;cp.get_template&quot;: mock_cp_get_template,
                &quot;file.user_to_uid&quot;: MagicMock(),
                &quot;file.remove&quot;: MagicMock(),
            },
        ):
            with patch(&quot;salt.modules.cmdmod._run&quot;) as mock_run:
                with patch(&quot;shutil.copyfile&quot;, MagicMock()):
                    with patch(&quot;os.chmod&quot;, MagicMock()):
                        with patch(&quot;os.chown&quot;, MagicMock()):
                            cmdmod.script(&quot;test&quot;)
                            assert mock_cp_cache_file.call_count == 1
                            mock_cp_cache_file.assert_called_with(&quot;test&quot;, &quot;base&quot;)
                            assert mock_run.call_count == 1
                            assert mock_run.call_args[1][&quot;saltenv&quot;] == &quot;base&quot;
                            cmdmod.script(&quot;test&quot;, template=&quot;jinja&quot;)
                            assert mock_cp_get_template.call_count == 1
                            assert mock_cp_get_template.call_args[0][3] == &quot;base&quot;
                            assert mock_run.call_count == 2
                            assert mock_run.call_args[1][&quot;saltenv&quot;] == &quot;base&quot;


@pytest.mark.skip_unless_on_windows
def test_cmd_script_saltenv_from_config_windows():
    mock_cp_get_template = MagicMock()
    mock_cp_cache_file = MagicMock()
    mock_run = MagicMock()
    with patch.dict(cmdmod.__opts__, {&quot;saltenv&quot;: &quot;base&quot;}):
        with patch.dict(
            cmdmod.__salt__,
            {
                &quot;cp.cache_file&quot;: mock_cp_cache_file,
                &quot;cp.get_template&quot;: mock_cp_get_template,
                &quot;file.user_to_uid&quot;: MagicMock(),
                &quot;file.remove&quot;: MagicMock(),
            },
        ):
            with patch(&quot;salt.modules.cmdmod._run&quot;) as mock_run:
                with patch(&quot;shutil.copyfile&quot;, MagicMock()):
                    cmdmod.script(&quot;test&quot;)
                    assert mock_cp_cache_file.call_count == 1
                    mock_cp_cache_file.assert_called_with(&quot;test&quot;, &quot;base&quot;)
                    assert mock_run.call_count == 1
                    assert mock_run.call_args[1][&quot;saltenv&quot;] == &quot;base&quot;
                    cmdmod.script(&quot;test&quot;, template=&quot;jinja&quot;)
                    assert mock_cp_get_template.call_count == 1
                    assert mock_cp_get_template.call_args[0][3] == &quot;base&quot;
                    assert mock_run.call_count == 2
                    assert mock_run.call_args[1][&quot;saltenv&quot;] == &quot;base&quot;
</PRE>
</div>
  </div>
</body>
</html>
