<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_runner_returns.py &amp; test_cmdmod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_runner_returns.py &amp; test_cmdmod.py
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_runner_returns.py (5.5555553%)<th>test_cmdmod.py (0.9448819%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-17)<td><a href="#" name="0">(7-19)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_runner_returns.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
import os
import socket
import tempfile
import pytest
import salt.payload
import salt.utils.args
import salt.utils.files
import salt.utils.jid
import salt.utils.yaml
from tests.support.case import ShellCase
from</b></font> tests.support.runtests import RUNTIME_VARS
@pytest.mark.windows_whitelisted
class RunnerReturnsTest(ShellCase):
    def setUp(self):
        self.job_dir = os.path.join(self.master_opts["cachedir"], "jobs")
        self.hash_type = self.master_opts["hash_type"]
        self.master_d_dir = os.path.join(self.config_dir, "master.d")
        try:
            os.makedirs(self.master_d_dir)
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise
        self.conf = tempfile.NamedTemporaryFile(
            mode="w",
            suffix=".conf",
            dir=self.master_d_dir,
            delete=False,
        )
    def tearDown(self):
        try:
            self.conf.close()
        except OSError:
            pass
        salt.utils.files.rm_rf(self.master_d_dir)
        self.run_run_plus("test.arg")
    @staticmethod
    def clean_return(data):
        data["fun_args"][1] = salt.utils.args.clean_kwargs(**data["fun_args"][1])
        data["return"]["kwargs"] = salt.utils.args.clean_kwargs(
            **data["return"]["kwargs"]
        )
        data.pop("_stamp")
    def write_conf(self, data):
        self.conf.write(salt.utils.yaml.safe_dump(data, default_flow_style=False))
        self.conf.flush()
        self.conf.close()
    @pytest.mark.slow_test
    def test_runner_returns_disabled(self):
        self.write_conf({"runner_returns": False})
        ret = self.run_run_plus("test.arg", "foo", bar="hello world!")
        jid = ret.get("jid")
        if jid is None:
            raise Exception("jid missing from run_run_plus output")
        serialized_return = os.path.join(
            salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
            "master",
            "return.p",
        )
        self.assertFalse(os.path.isfile(serialized_return))
    @pytest.mark.slow_test
    def test_runner_returns_enabled(self):
        self.write_conf({"runner_returns": True})
        ret = self.run_run_plus("test.arg", "foo", bar="hello world!")
        jid = ret.get("jid")
        if jid is None:
            raise Exception("jid missing from run_run_plus output")
        serialized_return = os.path.join(
            salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
            "master",
            "return.p",
        )
        with salt.utils.files.fopen(serialized_return, "rb") as fp_:
            deserialized = salt.payload.loads(fp_.read(), encoding="utf-8")
        self.clean_return(deserialized["return"])
        if "SUDO_USER" in os.environ:
            user = "sudo_{}".format(os.environ["SUDO_USER"])
        else:
            user = RUNTIME_VARS.RUNNING_TESTS_USER
        if salt.utils.platform.is_windows():
            user = "sudo_{}\\{}".format(socket.gethostname(), user)
        self.assertEqual(
            deserialized,
            {
                "return": {
                    "fun": "runner.test.arg",
                    "fun_args": ["foo", {"bar": "hello world!"}],
                    "jid": jid,
                    "return": {"args": ["foo"], "kwargs": {"bar": "hello world!"}},
                    "success": True,
                    "user": user,
                }
            },
        )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cmdmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import builtins
import getpass
import logging
import os
import re
import sys
import tempfile
import pytest
import salt.modules.cmdmod as cmdmod
import salt.utils.files
import salt.utils.platform
import</b></font> salt.utils.stringutils
from salt.exceptions import CommandExecutionError
from salt.log.setup import LOG_LEVELS
from tests.support.mock import MagicMock, Mock, MockTimedProc, mock_open, patch
from tests.support.runtests import RUNTIME_VARS
DEFAULT_SHELL = "foo/bar"
MOCK_SHELL_FILE = "# List of acceptable shells\n\n/bin/bash\n"
@pytest.fixture
def configure_loader_modules():
    opts = salt.config.DEFAULT_MINION_OPTS.copy()
    return {cmdmod: {"__opts__": opts}}
@pytest.fixture(scope="module")
def mock_loglevels():
    return {
        "info": "foo",
        "all": "bar",
        "critical": "bar",
        "trace": "bar",
        "garbage": "bar",
        "error": "bar",
        "debug": "bar",
        "warning": "bar",
        "quiet": "bar",
    }
def test_render_cmd_no_template():
    assert cmdmod._render_cmd("foo", "bar", None) == ("foo", "bar")
def test_render_cmd_saltenv_from_config():
    mock_template = MagicMock()
    with patch.dict(cmdmod.__opts__, {"saltenv": "base"}):
        with patch.dict(
            "salt.utils.templates.TEMPLATE_REGISTRY", {"test": mock_template}
        ):
            cmdmod._render_cmd("test", "test", "test")
            assert mock_template.call_count == 2
            assert mock_template.call_args[1]["saltenv"] == "base"
            cmdmod._render_cmd("test", "test", "test", saltenv="fake")
            assert mock_template.call_count == 4
            assert mock_template.call_args[1]["saltenv"] == "fake"
def test_render_cmd_unavailable_engine():
    with pytest.raises(CommandExecutionError):
        cmdmod._render_cmd("boo", "bar", "baz")
def test_check_loglevel_bad_level(mock_loglevels):
    with patch.dict(LOG_LEVELS, mock_loglevels):
        assert cmdmod._check_loglevel(level="bad_loglevel") == "foo"
def test_check_loglevel_bad_level_not_str(mock_loglevels):
    with patch.dict(LOG_LEVELS, mock_loglevels):
        assert cmdmod._check_loglevel(level=1000) == "foo"
def test_check_loglevel_quiet(mock_loglevels):
    with patch.dict(LOG_LEVELS, mock_loglevels):
        assert cmdmod._check_loglevel(level="quiet") is None
def test_parse_env_not_env():
    assert cmdmod._parse_env(None) == {}
def test_parse_env_list():
    ret = {"foo": None, "bar": None}
    assert ret == cmdmod._parse_env(["foo", "bar"])
def test_parse_env_dict():
    assert cmdmod._parse_env("test") == {}
def test_run_shell_is_not_file():
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", MagicMock(return_value=False)):
                with pytest.raises(CommandExecutionError):
                    cmdmod._run("foo", "bar")
def test_run_shell_file_no_access():
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", MagicMock(return_value=True)):
                with patch("os.access", MagicMock(return_value=False)):
                    with pytest.raises(CommandExecutionError):
                        cmdmod._run("foo", "bar")
def test_run_runas_with_windows():
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=True)):
            with patch(
                "salt.utils.win_chcp.get_codepage_id", MagicMock(return_value=65001)
            ):
                with patch.dict(cmdmod.__grains__, {"os": "fake_os"}):
                    with pytest.raises(CommandExecutionError):
                        cmdmod._run("foo", "bar", runas="baz")
def test_run_with_tuple():
    mock_true = MagicMock(return_value=True)
    with patch("salt.modules.cmdmod._is_valid_shell", mock_true):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", mock_true):
                with patch("os.access", mock_true):
                    cmdmod._run(("echo", "foo"), python_shell=True, cwd="/")
def test_run_user_not_available():
    mock_true = MagicMock(return_value=True)
    with patch("salt.modules.cmdmod._is_valid_shell", mock_true):
        with patch("os.path.isfile", mock_true):
            with patch("os.access", mock_true):
                with pytest.raises(CommandExecutionError):
                    cmdmod._run("foo", "bar", runas="baz")
def test_run_zero_umask():
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", MagicMock(return_value=True)):
                with patch("os.access", MagicMock(return_value=True)):
                    with pytest.raises(CommandExecutionError):
                        cmdmod._run("foo", "bar", umask=0)
def test_run_invalid_umask():
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", MagicMock(return_value=True)):
                with patch("os.access", MagicMock(return_value=True)):
                    pytest.raises(
                        CommandExecutionError,
                        cmdmod._run,
                        "foo",
                        "bar",
                        umask="baz",
                    )
def test_run_invalid_cwd_not_abs_path():
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", MagicMock(return_value=True)):
                with patch("os.access", MagicMock(return_value=True)):
                    with pytest.raises(CommandExecutionError):
                        cmdmod._run("foo", "bar")
def test_run_invalid_cwd_not_dir():
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", MagicMock(return_value=True)):
                with patch("os.access", MagicMock(return_value=True)):
                    with patch("os.path.isabs", MagicMock(return_value=True)):
                        with pytest.raises(CommandExecutionError):
                            cmdmod._run("foo", "bar")
def test_run_no_vt_os_error():
    expected_error = "expect error"
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", MagicMock(return_value=True)):
                with patch("os.access", MagicMock(return_value=True)):
                    with patch(
                        "salt.utils.timed_subprocess.TimedProc",
                        MagicMock(side_effect=OSError(expected_error)),
                    ):
                        with pytest.raises(CommandExecutionError) as error:
                            cmdmod.run("foo", cwd="/")
                        assert error.value.args[0].endswith(expected_error)
def test_run_no_vt_io_error():
    expected_error = "expect error"
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", MagicMock(return_value=True)):
                with patch("os.access", MagicMock(return_value=True)):
                    with patch(
                        "salt.utils.timed_subprocess.TimedProc",
                        MagicMock(side_effect=IOError(expected_error)),
                    ):
                        with pytest.raises(CommandExecutionError) as error:
                            cmdmod.run("foo", cwd="/")
                        assert error.value.args[0].endswith(expected_error)
@pytest.mark.skip(reason="Test breaks unittests runs")
@pytest.mark.skip_on_windows
def test_run():
    with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
        with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
            with patch("os.path.isfile", MagicMock(return_value=True)):
                with patch("os.access", MagicMock(return_value=True)):
                    ret = cmdmod._run("foo", cwd=os.getcwd(), use_vt=True).get("stderr")
                    assert "foo" in ret
@pytest.mark.skip_unless_on_windows
def test_powershell():
    mock_run = {"pid": 1234, "retcode": 0, "stderr": "", "stdout": '"foo"'}
    with patch("salt.modules.cmdmod._run", return_value=mock_run):
        ret = cmdmod.powershell("Set-ExecutionPolicy RemoteSigned")
        assert ret == "foo"
@pytest.mark.skip_unless_on_windows
def test_powershell_empty():
    mock_run = {"pid": 1234, "retcode": 0, "stderr": "", "stdout": ""}
    with patch("salt.modules.cmdmod._run", return_value=mock_run):
        ret = cmdmod.powershell("Set-ExecutionPolicy RemoteSigned")
        assert ret == {}
def test_is_valid_shell_windows():
    with patch("salt.utils.platform.is_windows", MagicMock(return_value=True)):
        assert cmdmod._is_valid_shell("foo")
@pytest.mark.skip_on_windows
def test_is_valid_shell_none():
    with patch("os.path.exists", MagicMock(return_value=False)):
        assert cmdmod._is_valid_shell("foo") is None
def test_is_valid_shell_available():
    with patch("os.path.exists", MagicMock(return_value=True)):
        with patch("salt.utils.files.fopen", mock_open(read_data=MOCK_SHELL_FILE)):
            assert cmdmod._is_valid_shell("/bin/bash")
@pytest.mark.skip_on_windows
def test_is_valid_shell_unavailable():
    with patch("os.path.exists", MagicMock(return_value=True)):
        with patch("salt.utils.files.fopen", mock_open(read_data=MOCK_SHELL_FILE)):
            assert not cmdmod._is_valid_shell("foo")
@pytest.mark.skip_on_windows
def test_os_environment_remains_intact():
    with patch("pwd.getpwnam") as getpwnam_mock:
        with patch("subprocess.Popen") as popen_mock:
            environment = os.environ.copy()
            popen_mock.return_value = Mock(
                communicate=lambda *args, **kwags: [b"", None],
                pid=lambda: 1,
                retcode=0,
            )
            with patch.dict(
                cmdmod.__grains__, {"os": "Darwin", "os_family": "Solaris"}
            ):
                if sys.platform.startswith(("freebsd", "openbsd")):
                    shell = "/bin/sh"
                else:
                    shell = "/bin/bash"
                cmdmod._run(
                    "ls", cwd=tempfile.gettempdir(), runas="foobar", shell=shell
                )
                environment2 = os.environ.copy()
                assert environment == environment2
                if not salt.utils.platform.is_darwin():
                    getpwnam_mock.assert_called_with("foobar")
@pytest.mark.skip_on_windows
def test_os_environment_do_not_pass_notify_socket():
    with patch("pwd.getpwnam") as getpwnam_mock:
        new_env = os.environ.copy()
        new_env.update({"NOTIFY_SOCKET": "/run/systemd/notify"})
        with patch("subprocess.Popen") as popen_mock, patch(
            "os.environ.copy", return_value=new_env
        ):
            popen_mock.return_value = Mock(
                communicate=lambda *args, **kwags: [b"", None],
                pid=lambda: 1,
                retcode=0,
            )
            with patch.dict(cmdmod.__grains__, {"os": "SUSE", "os_family": "Suse"}):
                if sys.platform.startswith(("freebsd", "openbsd")):
                    shell = "/bin/sh"
                else:
                    shell = "/bin/bash"
                cmdmod._run("ls", cwd=tempfile.gettempdir(), shell=shell)
                assert "NOTIFY_SOCKET" not in popen_mock.call_args_list[0][1]["env"]
                cmdmod._run(
                    "ls",
                    cwd=tempfile.gettempdir(),
                    shell=shell,
                    env={"NOTIFY_SOCKET": "/run/systemd/notify.new"},
                )
                assert (
                    popen_mock.call_args_list[1][1]["env"]["NOTIFY_SOCKET"]
                    == "/run/systemd/notify.new"
                )
@pytest.mark.skip_unless_on_darwin
def test_shell_properly_handled_on_macOS():
    class _CommandHandler:
        def __init__(self):
            self.cmd = None
        def clear(self):
            self.cmd = None
    cmd_handler = _CommandHandler()
    def mock_proc(__cmd__, **kwargs):
        cmd_handler.cmd = " ".join(__cmd__)
        return MagicMock(return_value=MockTimedProc(stdout=None, stderr=None))
    with patch("pwd.getpwnam") as getpwnam_mock:
        with patch("salt.utils.timed_subprocess.TimedProc", mock_proc):
            user_default_shell = "/usr/local/bin/bash"
            with patch.dict(
                cmdmod.__salt__,
                {"user.info": MagicMock(return_value={"shell": user_default_shell})},
            ):
                cmd_handler.clear()
                cmdmod._run(
                    "ls", cwd=tempfile.gettempdir(), runas="foobar", use_vt=False
                )
                assert re.search(
                    "{} -l -c".format(user_default_shell), cmd_handler.cmd
                ), "cmd invokes right bash session on macOS"
            user_default_shell = "/bin/zsh"
            with patch.dict(
                cmdmod.__salt__,
                {"user.info": MagicMock(return_value={"shell": user_default_shell})},
            ):
                cmd_handler.clear()
                cmdmod._run(
                    "ls", cwd=tempfile.gettempdir(), runas="foobar", use_vt=False
                )
                assert not re.search(
                    "bash -l -c", cmd_handler.cmd
                ), "cmd does not invoke user shell on macOS"
def test_run_cwd_doesnt_exist_issue_7154():
    cmd = "echo OHAI"
    cwd = "/path/to/nowhere"
    with pytest.raises(CommandExecutionError):
        cmdmod.run_all(cmd, cwd=cwd)
@pytest.mark.skip_on_darwin
@pytest.mark.skip_on_windows
def test_run_cwd_in_combination_with_runas():
    cmd = "pwd"
    cwd = "/tmp"
    runas = getpass.getuser()
    with patch.dict(cmdmod.__grains__, {"os": "Darwin", "os_family": "Solaris"}):
        stdout = cmdmod._run(cmd, cwd=cwd, runas=runas).get("stdout")
    assert stdout == cwd
def test_run_all_binary_replace():
    rand_bytes_file = os.path.join(RUNTIME_VARS.BASE_FILES, "random_bytes")
    with salt.utils.files.fopen(rand_bytes_file, "rb") as fp_:
        stdout_bytes = fp_.read()
    stdout_bytes = stdout_bytes.rstrip() + os.linesep.encode()
    stdout_unicode = "\ufffd\x1b\ufffd\ufffd" + os.linesep
    stderr_bytes = (
        os.linesep.encode().join(
            [
                b"1+0 records in",
                b"1+0 records out",
                b"4 bytes copied, 9.1522e-05 s, 43.7 kB/s",
            ]
        )
        + os.linesep.encode()
    )
    stderr_unicode = stderr_bytes.decode()
    proc = MagicMock(
        return_value=MockTimedProc(stdout=stdout_bytes, stderr=stderr_bytes)
    )
    with patch("salt.utils.timed_subprocess.TimedProc", proc):
        ret = cmdmod.run_all(
            "dd if=/dev/urandom of=/dev/stdout bs=4 count=1", rstrip=False
        )
    assert ret["stdout"] == stdout_unicode
    assert ret["stderr"] == stderr_unicode
def test_run_all_none():
    proc = MagicMock(return_value=MockTimedProc(stdout=None, stderr=None))
    with patch("salt.utils.timed_subprocess.TimedProc", proc):
        ret = cmdmod.run_all("some command", rstrip=False)
    assert ret["stdout"] == ""
    assert ret["stderr"] == ""
def test_run_all_unicode():
    stdout_unicode = "Here is some unicode: спам"
    stderr_unicode = "Here is some unicode: яйца"
    stdout_bytes = stdout_unicode.encode("utf-8")
    stderr_bytes = stderr_unicode.encode("utf-8")
    proc = MagicMock(
        return_value=MockTimedProc(stdout=stdout_bytes, stderr=stderr_bytes)
    )
    with patch("salt.utils.timed_subprocess.TimedProc", proc), patch.object(
        builtins, "__salt_system_encoding__", "utf-8"
    ):
        ret = cmdmod.run_all("some command", rstrip=False)
    assert ret["stdout"] == stdout_unicode
    assert ret["stderr"] == stderr_unicode
def test_run_all_output_encoding():
    stdout = "Æ"
    stdout_latin1_enc = stdout.encode("latin1")
    proc = MagicMock(return_value=MockTimedProc(stdout=stdout_latin1_enc))
    with patch("salt.utils.timed_subprocess.TimedProc", proc), patch.object(
        builtins, "__salt_system_encoding__", "utf-8"
    ):
        ret = cmdmod.run_all("some command", output_encoding="latin1")
    assert ret["stdout"] == stdout
def test_run_all_output_loglevel_quiet(caplog):
    stdout = b"test"
    proc = MagicMock(return_value=MockTimedProc(stdout=stdout))
    msg = "Executing command 'some command' in directory"
    with patch("salt.utils.timed_subprocess.TimedProc", proc):
        with caplog.at_level(logging.DEBUG, logger="salt.modules.cmdmod"):
            ret = cmdmod.run_all("some command", output_loglevel="quiet")
        assert msg not in caplog.text
    assert ret["stdout"] == salt.utils.stringutils.to_unicode(stdout)
def test_run_all_output_loglevel_debug(caplog):
    stdout = b"test"
    proc = MagicMock(return_value=MockTimedProc(stdout=stdout))
    msg = "Executing command 'some' in directory"
    with patch("salt.utils.timed_subprocess.TimedProc", proc):
        with caplog.at_level(logging.DEBUG, logger="salt.modules.cmdmod"):
            ret = cmdmod.run_all("some command", output_loglevel="debug")
        assert msg in caplog.text
    assert ret["stdout"] == salt.utils.stringutils.to_unicode(stdout)
def test_run_chroot_mount():
    mock_mount = MagicMock()
    mock_umount = MagicMock()
    mock_run_all = MagicMock()
    with patch.dict(
        cmdmod.__salt__, {"mount.mount": mock_mount, "mount.umount": mock_umount}
    ):
        with patch("salt.modules.cmdmod.run_all", mock_run_all):
            cmdmod.run_chroot("/mnt", "cmd")
            assert mock_mount.call_count == 3
            assert mock_umount.call_count == 3
def test_run_chroot_mount_bind():
    mock_mount = MagicMock()
    mock_umount = MagicMock()
    mock_run_all = MagicMock()
    with patch.dict(
        cmdmod.__salt__, {"mount.mount": mock_mount, "mount.umount": mock_umount}
    ):
        with patch("salt.modules.cmdmod.run_all", mock_run_all):
            cmdmod.run_chroot("/mnt", "cmd", binds=["/var"])
            assert mock_mount.call_count == 4
            assert mock_umount.call_count == 4
@pytest.mark.skip_on_windows
def test_run_chroot_runas():
    with patch.dict(
        cmdmod.__salt__, {"mount.mount": MagicMock(), "mount.umount": MagicMock()}
    ):
        with patch("salt.modules.cmdmod.run_all") as run_all_mock:
            cmdmod.run_chroot("/mnt", "ls", runas="foobar", shell="/bin/sh")
    run_all_mock.assert_called_with(
        "chroot --userspec foobar: /mnt /bin/sh -c ls",
        bg=False,
        clean_env=False,
        cwd=None,
        env=None,
        ignore_retcode=False,
        log_callback=None,
        output_encoding=None,
        output_loglevel="quiet",
        pillar=None,
        pillarenv=None,
        python_shell=True,
        reset_system_locale=True,
        rstrip=True,
        saltenv=None,
        shell="/bin/sh",
        stdin=None,
        success_retcodes=None,
        success_stdout=None,
        success_stderr=None,
        template=None,
        timeout=None,
        umask=None,
        use_vt=False,
    )
def test_cve_2021_25284(caplog):
    proc = MagicMock(
        return_value=MockTimedProc(stdout=b"foo", stderr=b"wtf", returncode=2)
    )
    with patch("salt.utils.timed_subprocess.TimedProc", proc):
        with caplog.at_level(logging.DEBUG, logger="salt.modules.cmdmod"):
            cmdmod.run("testcmd -p ImAPassword", output_loglevel="error")
        assert "ImAPassword" not in caplog.text
def test__log_cmd_str():
    "_log_cmd function handles strings"
    assert cmdmod._log_cmd("foo bar") == "foo"
def test__log_cmd_list():
    "_log_cmd function handles lists"
    assert cmdmod._log_cmd(["foo", "bar"]) == "foo"
def test_log_cmd_tuple():
    "_log_cmd function handles tuples"
    assert cmdmod._log_cmd(("foo", "bar")) == "foo"
def test_log_cmd_non_str_tuple_list():
    "_log_cmd function casts objects to strings"
    class cmd:
        def __init__(self, cmd):
            self.cmd = cmd
        def __str__(self):
            return self.cmd
    assert cmdmod._log_cmd(cmd("foo bar")) == "foo"
@pytest.mark.skip_on_windows
def test_cmd_script_saltenv_from_config():
    mock_cp_get_template = MagicMock()
    mock_cp_cache_file = MagicMock()
    mock_run = MagicMock()
    with patch.dict(cmdmod.__opts__, {"saltenv": "base"}):
        with patch.dict(
            cmdmod.__salt__,
            {
                "cp.cache_file": mock_cp_cache_file,
                "cp.get_template": mock_cp_get_template,
                "file.user_to_uid": MagicMock(),
                "file.remove": MagicMock(),
            },
        ):
            with patch("salt.modules.cmdmod._run") as mock_run:
                with patch("shutil.copyfile", MagicMock()):
                    with patch("os.chmod", MagicMock()):
                        with patch("os.chown", MagicMock()):
                            cmdmod.script("test")
                            assert mock_cp_cache_file.call_count == 1
                            mock_cp_cache_file.assert_called_with("test", "base")
                            assert mock_run.call_count == 1
                            assert mock_run.call_args[1]["saltenv"] == "base"
                            cmdmod.script("test", template="jinja")
                            assert mock_cp_get_template.call_count == 1
                            assert mock_cp_get_template.call_args[0][3] == "base"
                            assert mock_run.call_count == 2
                            assert mock_run.call_args[1]["saltenv"] == "base"
@pytest.mark.skip_unless_on_windows
def test_cmd_script_saltenv_from_config_windows():
    mock_cp_get_template = MagicMock()
    mock_cp_cache_file = MagicMock()
    mock_run = MagicMock()
    with patch.dict(cmdmod.__opts__, {"saltenv": "base"}):
        with patch.dict(
            cmdmod.__salt__,
            {
                "cp.cache_file": mock_cp_cache_file,
                "cp.get_template": mock_cp_get_template,
                "file.user_to_uid": MagicMock(),
                "file.remove": MagicMock(),
            },
        ):
            with patch("salt.modules.cmdmod._run") as mock_run:
                with patch("shutil.copyfile", MagicMock()):
                    cmdmod.script("test")
                    assert mock_cp_cache_file.call_count == 1
                    mock_cp_cache_file.assert_called_with("test", "base")
                    assert mock_run.call_count == 1
                    assert mock_run.call_args[1]["saltenv"] == "base"
                    cmdmod.script("test", template="jinja")
                    assert mock_cp_get_template.call_count == 1
                    assert mock_cp_get_template.call_args[0][3] == "base"
                    assert mock_run.call_count == 2
                    assert mock_run.call_args[1]["saltenv"] == "base"
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
