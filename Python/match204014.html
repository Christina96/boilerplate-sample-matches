<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_runner_returns.py &amp; test_cmdmod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_runner_returns.py &amp; test_cmdmod.py
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_runner_returns.py (5.5555553%)<th>test_cmdmod.py (0.9448819%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-17)<td><a href="#" name="0">(7-19)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_runner_returns.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
2 import os
3 import socket
4 import tempfile
5 import pytest
6 import salt.payload
7 import salt.utils.args
8 import salt.utils.files
9 import salt.utils.jid
10 import salt.utils.yaml
11 from tests.support.case import ShellCase
12 from</b></font> tests.support.runtests import RUNTIME_VARS
13 @pytest.mark.windows_whitelisted
14 class RunnerReturnsTest(ShellCase):
15     def setUp(self):
16         self.job_dir = os.path.join(self.master_opts["cachedir"], "jobs")
17         self.hash_type = self.master_opts["hash_type"]
18         self.master_d_dir = os.path.join(self.config_dir, "master.d")
19         try:
20             os.makedirs(self.master_d_dir)
21         except OSError as exc:
22             if exc.errno != errno.EEXIST:
23                 raise
24         self.conf = tempfile.NamedTemporaryFile(
25             mode="w",
26             suffix=".conf",
27             dir=self.master_d_dir,
28             delete=False,
29         )
30     def tearDown(self):
31         try:
32             self.conf.close()
33         except OSError:
34             pass
35         salt.utils.files.rm_rf(self.master_d_dir)
36         self.run_run_plus("test.arg")
37     @staticmethod
38     def clean_return(data):
39         data["fun_args"][1] = salt.utils.args.clean_kwargs(**data["fun_args"][1])
40         data["return"]["kwargs"] = salt.utils.args.clean_kwargs(
41             **data["return"]["kwargs"]
42         )
43         data.pop("_stamp")
44     def write_conf(self, data):
45         self.conf.write(salt.utils.yaml.safe_dump(data, default_flow_style=False))
46         self.conf.flush()
47         self.conf.close()
48     @pytest.mark.slow_test
49     def test_runner_returns_disabled(self):
50         self.write_conf({"runner_returns": False})
51         ret = self.run_run_plus("test.arg", "foo", bar="hello world!")
52         jid = ret.get("jid")
53         if jid is None:
54             raise Exception("jid missing from run_run_plus output")
55         serialized_return = os.path.join(
56             salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
57             "master",
58             "return.p",
59         )
60         self.assertFalse(os.path.isfile(serialized_return))
61     @pytest.mark.slow_test
62     def test_runner_returns_enabled(self):
63         self.write_conf({"runner_returns": True})
64         ret = self.run_run_plus("test.arg", "foo", bar="hello world!")
65         jid = ret.get("jid")
66         if jid is None:
67             raise Exception("jid missing from run_run_plus output")
68         serialized_return = os.path.join(
69             salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
70             "master",
71             "return.p",
72         )
73         with salt.utils.files.fopen(serialized_return, "rb") as fp_:
74             deserialized = salt.payload.loads(fp_.read(), encoding="utf-8")
75         self.clean_return(deserialized["return"])
76         if "SUDO_USER" in os.environ:
77             user = "sudo_{}".format(os.environ["SUDO_USER"])
78         else:
79             user = RUNTIME_VARS.RUNNING_TESTS_USER
80         if salt.utils.platform.is_windows():
81             user = "sudo_{}\\{}".format(socket.gethostname(), user)
82         self.assertEqual(
83             deserialized,
84             {
85                 "return": {
86                     "fun": "runner.test.arg",
87                     "fun_args": ["foo", {"bar": "hello world!"}],
88                     "jid": jid,
89                     "return": {"args": ["foo"], "kwargs": {"bar": "hello world!"}},
90                     "success": True,
91                     "user": user,
92                 }
93             },
94         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cmdmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import builtins
2 import getpass
3 import logging
4 import os
5 import re
6 import sys
7 import tempfile
8 import pytest
9 import salt.modules.cmdmod as cmdmod
10 import salt.utils.files
11 import salt.utils.platform
12 import</b></font> salt.utils.stringutils
13 from salt.exceptions import CommandExecutionError
14 from salt.log.setup import LOG_LEVELS
15 from tests.support.mock import MagicMock, Mock, MockTimedProc, mock_open, patch
16 from tests.support.runtests import RUNTIME_VARS
17 DEFAULT_SHELL = "foo/bar"
18 MOCK_SHELL_FILE = "# List of acceptable shells\n\n/bin/bash\n"
19 @pytest.fixture
20 def configure_loader_modules():
21     opts = salt.config.DEFAULT_MINION_OPTS.copy()
22     return {cmdmod: {"__opts__": opts}}
23 @pytest.fixture(scope="module")
24 def mock_loglevels():
25     return {
26         "info": "foo",
27         "all": "bar",
28         "critical": "bar",
29         "trace": "bar",
30         "garbage": "bar",
31         "error": "bar",
32         "debug": "bar",
33         "warning": "bar",
34         "quiet": "bar",
35     }
36 def test_render_cmd_no_template():
37     assert cmdmod._render_cmd("foo", "bar", None) == ("foo", "bar")
38 def test_render_cmd_saltenv_from_config():
39     mock_template = MagicMock()
40     with patch.dict(cmdmod.__opts__, {"saltenv": "base"}):
41         with patch.dict(
42             "salt.utils.templates.TEMPLATE_REGISTRY", {"test": mock_template}
43         ):
44             cmdmod._render_cmd("test", "test", "test")
45             assert mock_template.call_count == 2
46             assert mock_template.call_args[1]["saltenv"] == "base"
47             cmdmod._render_cmd("test", "test", "test", saltenv="fake")
48             assert mock_template.call_count == 4
49             assert mock_template.call_args[1]["saltenv"] == "fake"
50 def test_render_cmd_unavailable_engine():
51     with pytest.raises(CommandExecutionError):
52         cmdmod._render_cmd("boo", "bar", "baz")
53 def test_check_loglevel_bad_level(mock_loglevels):
54     with patch.dict(LOG_LEVELS, mock_loglevels):
55         assert cmdmod._check_loglevel(level="bad_loglevel") == "foo"
56 def test_check_loglevel_bad_level_not_str(mock_loglevels):
57     with patch.dict(LOG_LEVELS, mock_loglevels):
58         assert cmdmod._check_loglevel(level=1000) == "foo"
59 def test_check_loglevel_quiet(mock_loglevels):
60     with patch.dict(LOG_LEVELS, mock_loglevels):
61         assert cmdmod._check_loglevel(level="quiet") is None
62 def test_parse_env_not_env():
63     assert cmdmod._parse_env(None) == {}
64 def test_parse_env_list():
65     ret = {"foo": None, "bar": None}
66     assert ret == cmdmod._parse_env(["foo", "bar"])
67 def test_parse_env_dict():
68     assert cmdmod._parse_env("test") == {}
69 def test_run_shell_is_not_file():
70     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
71         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
72             with patch("os.path.isfile", MagicMock(return_value=False)):
73                 with pytest.raises(CommandExecutionError):
74                     cmdmod._run("foo", "bar")
75 def test_run_shell_file_no_access():
76     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
77         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
78             with patch("os.path.isfile", MagicMock(return_value=True)):
79                 with patch("os.access", MagicMock(return_value=False)):
80                     with pytest.raises(CommandExecutionError):
81                         cmdmod._run("foo", "bar")
82 def test_run_runas_with_windows():
83     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
84         with patch("salt.utils.platform.is_windows", MagicMock(return_value=True)):
85             with patch(
86                 "salt.utils.win_chcp.get_codepage_id", MagicMock(return_value=65001)
87             ):
88                 with patch.dict(cmdmod.__grains__, {"os": "fake_os"}):
89                     with pytest.raises(CommandExecutionError):
90                         cmdmod._run("foo", "bar", runas="baz")
91 def test_run_with_tuple():
92     mock_true = MagicMock(return_value=True)
93     with patch("salt.modules.cmdmod._is_valid_shell", mock_true):
94         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
95             with patch("os.path.isfile", mock_true):
96                 with patch("os.access", mock_true):
97                     cmdmod._run(("echo", "foo"), python_shell=True, cwd="/")
98 def test_run_user_not_available():
99     mock_true = MagicMock(return_value=True)
100     with patch("salt.modules.cmdmod._is_valid_shell", mock_true):
101         with patch("os.path.isfile", mock_true):
102             with patch("os.access", mock_true):
103                 with pytest.raises(CommandExecutionError):
104                     cmdmod._run("foo", "bar", runas="baz")
105 def test_run_zero_umask():
106     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
107         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
108             with patch("os.path.isfile", MagicMock(return_value=True)):
109                 with patch("os.access", MagicMock(return_value=True)):
110                     with pytest.raises(CommandExecutionError):
111                         cmdmod._run("foo", "bar", umask=0)
112 def test_run_invalid_umask():
113     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
114         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
115             with patch("os.path.isfile", MagicMock(return_value=True)):
116                 with patch("os.access", MagicMock(return_value=True)):
117                     pytest.raises(
118                         CommandExecutionError,
119                         cmdmod._run,
120                         "foo",
121                         "bar",
122                         umask="baz",
123                     )
124 def test_run_invalid_cwd_not_abs_path():
125     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
126         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
127             with patch("os.path.isfile", MagicMock(return_value=True)):
128                 with patch("os.access", MagicMock(return_value=True)):
129                     with pytest.raises(CommandExecutionError):
130                         cmdmod._run("foo", "bar")
131 def test_run_invalid_cwd_not_dir():
132     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
133         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
134             with patch("os.path.isfile", MagicMock(return_value=True)):
135                 with patch("os.access", MagicMock(return_value=True)):
136                     with patch("os.path.isabs", MagicMock(return_value=True)):
137                         with pytest.raises(CommandExecutionError):
138                             cmdmod._run("foo", "bar")
139 def test_run_no_vt_os_error():
140     expected_error = "expect error"
141     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
142         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
143             with patch("os.path.isfile", MagicMock(return_value=True)):
144                 with patch("os.access", MagicMock(return_value=True)):
145                     with patch(
146                         "salt.utils.timed_subprocess.TimedProc",
147                         MagicMock(side_effect=OSError(expected_error)),
148                     ):
149                         with pytest.raises(CommandExecutionError) as error:
150                             cmdmod.run("foo", cwd="/")
151                         assert error.value.args[0].endswith(expected_error)
152 def test_run_no_vt_io_error():
153     expected_error = "expect error"
154     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
155         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
156             with patch("os.path.isfile", MagicMock(return_value=True)):
157                 with patch("os.access", MagicMock(return_value=True)):
158                     with patch(
159                         "salt.utils.timed_subprocess.TimedProc",
160                         MagicMock(side_effect=IOError(expected_error)),
161                     ):
162                         with pytest.raises(CommandExecutionError) as error:
163                             cmdmod.run("foo", cwd="/")
164                         assert error.value.args[0].endswith(expected_error)
165 @pytest.mark.skip(reason="Test breaks unittests runs")
166 @pytest.mark.skip_on_windows
167 def test_run():
168     with patch("salt.modules.cmdmod._is_valid_shell", MagicMock(return_value=True)):
169         with patch("salt.utils.platform.is_windows", MagicMock(return_value=False)):
170             with patch("os.path.isfile", MagicMock(return_value=True)):
171                 with patch("os.access", MagicMock(return_value=True)):
172                     ret = cmdmod._run("foo", cwd=os.getcwd(), use_vt=True).get("stderr")
173                     assert "foo" in ret
174 @pytest.mark.skip_unless_on_windows
175 def test_powershell():
176     mock_run = {"pid": 1234, "retcode": 0, "stderr": "", "stdout": '"foo"'}
177     with patch("salt.modules.cmdmod._run", return_value=mock_run):
178         ret = cmdmod.powershell("Set-ExecutionPolicy RemoteSigned")
179         assert ret == "foo"
180 @pytest.mark.skip_unless_on_windows
181 def test_powershell_empty():
182     mock_run = {"pid": 1234, "retcode": 0, "stderr": "", "stdout": ""}
183     with patch("salt.modules.cmdmod._run", return_value=mock_run):
184         ret = cmdmod.powershell("Set-ExecutionPolicy RemoteSigned")
185         assert ret == {}
186 def test_is_valid_shell_windows():
187     with patch("salt.utils.platform.is_windows", MagicMock(return_value=True)):
188         assert cmdmod._is_valid_shell("foo")
189 @pytest.mark.skip_on_windows
190 def test_is_valid_shell_none():
191     with patch("os.path.exists", MagicMock(return_value=False)):
192         assert cmdmod._is_valid_shell("foo") is None
193 def test_is_valid_shell_available():
194     with patch("os.path.exists", MagicMock(return_value=True)):
195         with patch("salt.utils.files.fopen", mock_open(read_data=MOCK_SHELL_FILE)):
196             assert cmdmod._is_valid_shell("/bin/bash")
197 @pytest.mark.skip_on_windows
198 def test_is_valid_shell_unavailable():
199     with patch("os.path.exists", MagicMock(return_value=True)):
200         with patch("salt.utils.files.fopen", mock_open(read_data=MOCK_SHELL_FILE)):
201             assert not cmdmod._is_valid_shell("foo")
202 @pytest.mark.skip_on_windows
203 def test_os_environment_remains_intact():
204     with patch("pwd.getpwnam") as getpwnam_mock:
205         with patch("subprocess.Popen") as popen_mock:
206             environment = os.environ.copy()
207             popen_mock.return_value = Mock(
208                 communicate=lambda *args, **kwags: [b"", None],
209                 pid=lambda: 1,
210                 retcode=0,
211             )
212             with patch.dict(
213                 cmdmod.__grains__, {"os": "Darwin", "os_family": "Solaris"}
214             ):
215                 if sys.platform.startswith(("freebsd", "openbsd")):
216                     shell = "/bin/sh"
217                 else:
218                     shell = "/bin/bash"
219                 cmdmod._run(
220                     "ls", cwd=tempfile.gettempdir(), runas="foobar", shell=shell
221                 )
222                 environment2 = os.environ.copy()
223                 assert environment == environment2
224                 if not salt.utils.platform.is_darwin():
225                     getpwnam_mock.assert_called_with("foobar")
226 @pytest.mark.skip_on_windows
227 def test_os_environment_do_not_pass_notify_socket():
228     with patch("pwd.getpwnam") as getpwnam_mock:
229         new_env = os.environ.copy()
230         new_env.update({"NOTIFY_SOCKET": "/run/systemd/notify"})
231         with patch("subprocess.Popen") as popen_mock, patch(
232             "os.environ.copy", return_value=new_env
233         ):
234             popen_mock.return_value = Mock(
235                 communicate=lambda *args, **kwags: [b"", None],
236                 pid=lambda: 1,
237                 retcode=0,
238             )
239             with patch.dict(cmdmod.__grains__, {"os": "SUSE", "os_family": "Suse"}):
240                 if sys.platform.startswith(("freebsd", "openbsd")):
241                     shell = "/bin/sh"
242                 else:
243                     shell = "/bin/bash"
244                 cmdmod._run("ls", cwd=tempfile.gettempdir(), shell=shell)
245                 assert "NOTIFY_SOCKET" not in popen_mock.call_args_list[0][1]["env"]
246                 cmdmod._run(
247                     "ls",
248                     cwd=tempfile.gettempdir(),
249                     shell=shell,
250                     env={"NOTIFY_SOCKET": "/run/systemd/notify.new"},
251                 )
252                 assert (
253                     popen_mock.call_args_list[1][1]["env"]["NOTIFY_SOCKET"]
254                     == "/run/systemd/notify.new"
255                 )
256 @pytest.mark.skip_unless_on_darwin
257 def test_shell_properly_handled_on_macOS():
258     class _CommandHandler:
259         def __init__(self):
260             self.cmd = None
261         def clear(self):
262             self.cmd = None
263     cmd_handler = _CommandHandler()
264     def mock_proc(__cmd__, **kwargs):
265         cmd_handler.cmd = " ".join(__cmd__)
266         return MagicMock(return_value=MockTimedProc(stdout=None, stderr=None))
267     with patch("pwd.getpwnam") as getpwnam_mock:
268         with patch("salt.utils.timed_subprocess.TimedProc", mock_proc):
269             user_default_shell = "/usr/local/bin/bash"
270             with patch.dict(
271                 cmdmod.__salt__,
272                 {"user.info": MagicMock(return_value={"shell": user_default_shell})},
273             ):
274                 cmd_handler.clear()
275                 cmdmod._run(
276                     "ls", cwd=tempfile.gettempdir(), runas="foobar", use_vt=False
277                 )
278                 assert re.search(
279                     "{} -l -c".format(user_default_shell), cmd_handler.cmd
280                 ), "cmd invokes right bash session on macOS"
281             user_default_shell = "/bin/zsh"
282             with patch.dict(
283                 cmdmod.__salt__,
284                 {"user.info": MagicMock(return_value={"shell": user_default_shell})},
285             ):
286                 cmd_handler.clear()
287                 cmdmod._run(
288                     "ls", cwd=tempfile.gettempdir(), runas="foobar", use_vt=False
289                 )
290                 assert not re.search(
291                     "bash -l -c", cmd_handler.cmd
292                 ), "cmd does not invoke user shell on macOS"
293 def test_run_cwd_doesnt_exist_issue_7154():
294     cmd = "echo OHAI"
295     cwd = "/path/to/nowhere"
296     with pytest.raises(CommandExecutionError):
297         cmdmod.run_all(cmd, cwd=cwd)
298 @pytest.mark.skip_on_darwin
299 @pytest.mark.skip_on_windows
300 def test_run_cwd_in_combination_with_runas():
301     cmd = "pwd"
302     cwd = "/tmp"
303     runas = getpass.getuser()
304     with patch.dict(cmdmod.__grains__, {"os": "Darwin", "os_family": "Solaris"}):
305         stdout = cmdmod._run(cmd, cwd=cwd, runas=runas).get("stdout")
306     assert stdout == cwd
307 def test_run_all_binary_replace():
308     rand_bytes_file = os.path.join(RUNTIME_VARS.BASE_FILES, "random_bytes")
309     with salt.utils.files.fopen(rand_bytes_file, "rb") as fp_:
310         stdout_bytes = fp_.read()
311     stdout_bytes = stdout_bytes.rstrip() + os.linesep.encode()
312     stdout_unicode = "\ufffd\x1b\ufffd\ufffd" + os.linesep
313     stderr_bytes = (
314         os.linesep.encode().join(
315             [
316                 b"1+0 records in",
317                 b"1+0 records out",
318                 b"4 bytes copied, 9.1522e-05 s, 43.7 kB/s",
319             ]
320         )
321         + os.linesep.encode()
322     )
323     stderr_unicode = stderr_bytes.decode()
324     proc = MagicMock(
325         return_value=MockTimedProc(stdout=stdout_bytes, stderr=stderr_bytes)
326     )
327     with patch("salt.utils.timed_subprocess.TimedProc", proc):
328         ret = cmdmod.run_all(
329             "dd if=/dev/urandom of=/dev/stdout bs=4 count=1", rstrip=False
330         )
331     assert ret["stdout"] == stdout_unicode
332     assert ret["stderr"] == stderr_unicode
333 def test_run_all_none():
334     proc = MagicMock(return_value=MockTimedProc(stdout=None, stderr=None))
335     with patch("salt.utils.timed_subprocess.TimedProc", proc):
336         ret = cmdmod.run_all("some command", rstrip=False)
337     assert ret["stdout"] == ""
338     assert ret["stderr"] == ""
339 def test_run_all_unicode():
340     stdout_unicode = "Here is some unicode: спам"
341     stderr_unicode = "Here is some unicode: яйца"
342     stdout_bytes = stdout_unicode.encode("utf-8")
343     stderr_bytes = stderr_unicode.encode("utf-8")
344     proc = MagicMock(
345         return_value=MockTimedProc(stdout=stdout_bytes, stderr=stderr_bytes)
346     )
347     with patch("salt.utils.timed_subprocess.TimedProc", proc), patch.object(
348         builtins, "__salt_system_encoding__", "utf-8"
349     ):
350         ret = cmdmod.run_all("some command", rstrip=False)
351     assert ret["stdout"] == stdout_unicode
352     assert ret["stderr"] == stderr_unicode
353 def test_run_all_output_encoding():
354     stdout = "Æ"
355     stdout_latin1_enc = stdout.encode("latin1")
356     proc = MagicMock(return_value=MockTimedProc(stdout=stdout_latin1_enc))
357     with patch("salt.utils.timed_subprocess.TimedProc", proc), patch.object(
358         builtins, "__salt_system_encoding__", "utf-8"
359     ):
360         ret = cmdmod.run_all("some command", output_encoding="latin1")
361     assert ret["stdout"] == stdout
362 def test_run_all_output_loglevel_quiet(caplog):
363     stdout = b"test"
364     proc = MagicMock(return_value=MockTimedProc(stdout=stdout))
365     msg = "Executing command 'some command' in directory"
366     with patch("salt.utils.timed_subprocess.TimedProc", proc):
367         with caplog.at_level(logging.DEBUG, logger="salt.modules.cmdmod"):
368             ret = cmdmod.run_all("some command", output_loglevel="quiet")
369         assert msg not in caplog.text
370     assert ret["stdout"] == salt.utils.stringutils.to_unicode(stdout)
371 def test_run_all_output_loglevel_debug(caplog):
372     stdout = b"test"
373     proc = MagicMock(return_value=MockTimedProc(stdout=stdout))
374     msg = "Executing command 'some' in directory"
375     with patch("salt.utils.timed_subprocess.TimedProc", proc):
376         with caplog.at_level(logging.DEBUG, logger="salt.modules.cmdmod"):
377             ret = cmdmod.run_all("some command", output_loglevel="debug")
378         assert msg in caplog.text
379     assert ret["stdout"] == salt.utils.stringutils.to_unicode(stdout)
380 def test_run_chroot_mount():
381     mock_mount = MagicMock()
382     mock_umount = MagicMock()
383     mock_run_all = MagicMock()
384     with patch.dict(
385         cmdmod.__salt__, {"mount.mount": mock_mount, "mount.umount": mock_umount}
386     ):
387         with patch("salt.modules.cmdmod.run_all", mock_run_all):
388             cmdmod.run_chroot("/mnt", "cmd")
389             assert mock_mount.call_count == 3
390             assert mock_umount.call_count == 3
391 def test_run_chroot_mount_bind():
392     mock_mount = MagicMock()
393     mock_umount = MagicMock()
394     mock_run_all = MagicMock()
395     with patch.dict(
396         cmdmod.__salt__, {"mount.mount": mock_mount, "mount.umount": mock_umount}
397     ):
398         with patch("salt.modules.cmdmod.run_all", mock_run_all):
399             cmdmod.run_chroot("/mnt", "cmd", binds=["/var"])
400             assert mock_mount.call_count == 4
401             assert mock_umount.call_count == 4
402 @pytest.mark.skip_on_windows
403 def test_run_chroot_runas():
404     with patch.dict(
405         cmdmod.__salt__, {"mount.mount": MagicMock(), "mount.umount": MagicMock()}
406     ):
407         with patch("salt.modules.cmdmod.run_all") as run_all_mock:
408             cmdmod.run_chroot("/mnt", "ls", runas="foobar", shell="/bin/sh")
409     run_all_mock.assert_called_with(
410         "chroot --userspec foobar: /mnt /bin/sh -c ls",
411         bg=False,
412         clean_env=False,
413         cwd=None,
414         env=None,
415         ignore_retcode=False,
416         log_callback=None,
417         output_encoding=None,
418         output_loglevel="quiet",
419         pillar=None,
420         pillarenv=None,
421         python_shell=True,
422         reset_system_locale=True,
423         rstrip=True,
424         saltenv=None,
425         shell="/bin/sh",
426         stdin=None,
427         success_retcodes=None,
428         success_stdout=None,
429         success_stderr=None,
430         template=None,
431         timeout=None,
432         umask=None,
433         use_vt=False,
434     )
435 def test_cve_2021_25284(caplog):
436     proc = MagicMock(
437         return_value=MockTimedProc(stdout=b"foo", stderr=b"wtf", returncode=2)
438     )
439     with patch("salt.utils.timed_subprocess.TimedProc", proc):
440         with caplog.at_level(logging.DEBUG, logger="salt.modules.cmdmod"):
441             cmdmod.run("testcmd -p ImAPassword", output_loglevel="error")
442         assert "ImAPassword" not in caplog.text
443 def test__log_cmd_str():
444     "_log_cmd function handles strings"
445     assert cmdmod._log_cmd("foo bar") == "foo"
446 def test__log_cmd_list():
447     "_log_cmd function handles lists"
448     assert cmdmod._log_cmd(["foo", "bar"]) == "foo"
449 def test_log_cmd_tuple():
450     "_log_cmd function handles tuples"
451     assert cmdmod._log_cmd(("foo", "bar")) == "foo"
452 def test_log_cmd_non_str_tuple_list():
453     "_log_cmd function casts objects to strings"
454     class cmd:
455         def __init__(self, cmd):
456             self.cmd = cmd
457         def __str__(self):
458             return self.cmd
459     assert cmdmod._log_cmd(cmd("foo bar")) == "foo"
460 @pytest.mark.skip_on_windows
461 def test_cmd_script_saltenv_from_config():
462     mock_cp_get_template = MagicMock()
463     mock_cp_cache_file = MagicMock()
464     mock_run = MagicMock()
465     with patch.dict(cmdmod.__opts__, {"saltenv": "base"}):
466         with patch.dict(
467             cmdmod.__salt__,
468             {
469                 "cp.cache_file": mock_cp_cache_file,
470                 "cp.get_template": mock_cp_get_template,
471                 "file.user_to_uid": MagicMock(),
472                 "file.remove": MagicMock(),
473             },
474         ):
475             with patch("salt.modules.cmdmod._run") as mock_run:
476                 with patch("shutil.copyfile", MagicMock()):
477                     with patch("os.chmod", MagicMock()):
478                         with patch("os.chown", MagicMock()):
479                             cmdmod.script("test")
480                             assert mock_cp_cache_file.call_count == 1
481                             mock_cp_cache_file.assert_called_with("test", "base")
482                             assert mock_run.call_count == 1
483                             assert mock_run.call_args[1]["saltenv"] == "base"
484                             cmdmod.script("test", template="jinja")
485                             assert mock_cp_get_template.call_count == 1
486                             assert mock_cp_get_template.call_args[0][3] == "base"
487                             assert mock_run.call_count == 2
488                             assert mock_run.call_args[1]["saltenv"] == "base"
489 @pytest.mark.skip_unless_on_windows
490 def test_cmd_script_saltenv_from_config_windows():
491     mock_cp_get_template = MagicMock()
492     mock_cp_cache_file = MagicMock()
493     mock_run = MagicMock()
494     with patch.dict(cmdmod.__opts__, {"saltenv": "base"}):
495         with patch.dict(
496             cmdmod.__salt__,
497             {
498                 "cp.cache_file": mock_cp_cache_file,
499                 "cp.get_template": mock_cp_get_template,
500                 "file.user_to_uid": MagicMock(),
501                 "file.remove": MagicMock(),
502             },
503         ):
504             with patch("salt.modules.cmdmod._run") as mock_run:
505                 with patch("shutil.copyfile", MagicMock()):
506                     cmdmod.script("test")
507                     assert mock_cp_cache_file.call_count == 1
508                     mock_cp_cache_file.assert_called_with("test", "base")
509                     assert mock_run.call_count == 1
510                     assert mock_run.call_args[1]["saltenv"] == "base"
511                     cmdmod.script("test", template="jinja")
512                     assert mock_cp_get_template.call_count == 1
513                     assert mock_cp_get_template.call_args[0][3] == "base"
514                     assert mock_run.call_count == 2
515                     assert mock_run.call_args[1]["saltenv"] == "base"
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
