<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for regioninfo_2.py &amp; image.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for regioninfo_2.py &amp; image.py
      </h3>
<h1 align="center">
        5.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>regioninfo_2.py (7.246377%)<th>image.py (3.916449%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(258-267)<td><a href="#" name="0">(70-79)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>regioninfo_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import boto
3 from boto.compat import json
4 from boto.exception import BotoClientError
5 from boto.endpoints import BotoEndpointResolver
6 from boto.endpoints import StaticEndpointBuilder
7 _endpoints_cache = {}
8 def load_endpoint_json(path):
9     return _load_json_file(path)
10 def _load_json_file(path):
11     with open(path, 'r') as endpoints_file:
12         return json.load(endpoints_file)
13 def merge_endpoints(defaults, additions):
14     for service, region_info in additions.items():
15         defaults.setdefault(service, {})
16         defaults[service].update(region_info)
17     return defaults
18 def load_regions():
19     endpoints = _load_builtin_endpoints()
20     additional_path = None
21     if os.environ.get('BOTO_ENDPOINTS'):
22         additional_path = os.environ['BOTO_ENDPOINTS']
23     elif boto.config.get('Boto', 'endpoints_path'):
24         additional_path = boto.config.get('Boto', 'endpoints_path')
25     if additional_path:
26         additional = load_endpoint_json(additional_path)
27         endpoints = merge_endpoints(endpoints, additional)
28     return endpoints
29 def _load_builtin_endpoints(_cache=_endpoints_cache):
30     if _cache:
31         return _cache
32     endpoints = _load_json_file(boto.ENDPOINTS_PATH)
33     resolver = BotoEndpointResolver(endpoints)
34     builder = StaticEndpointBuilder(resolver)
35     endpoints = builder.build_static_endpoints()
36     _cache.update(endpoints)
37     return _cache
38 def get_regions(service_name, region_cls=None, connection_cls=None):
39     endpoints = load_regions()
40     if service_name not in endpoints:
41         raise BotoClientError(
42             "Service '%s' not found in endpoints." % service_name
43         )
44     if region_cls is None:
45         region_cls = RegionInfo
46     region_objs = []
47     for region_name, endpoint in endpoints.get(service_name, {}).items():
48         region_objs.append(
49             region_cls(
50                 name=region_name,
51                 endpoint=endpoint,
52                 connection_cls=connection_cls
53             )
54         )
55     return region_objs
56 def connect(service_name, region_name, region_cls=None,
57             connection_cls=None, **kw_params):
58     if region_cls is None:
59         region_cls = RegionInfo
60     region = _get_region(service_name, region_name, region_cls, connection_cls)
61     if region is None and _use_endpoint_heuristics():
62         region = _get_region_with_heuristics(
63             service_name, region_name, region_cls, connection_cls
64         )
65     if region is None:
66         return None
67     return region.connect(**kw_params)
68 def _get_region(service_name, region_name, region_cls=None,
69                 connection_cls=None):
70     for region in get_regions(service_name, region_cls, connection_cls):
71         if region.name == region_name:
72             return region
73     return None
74 def _get_region_with_heuristics(service_name, region_name, region_cls=None,
75                                 connection_cls=None):
76     endpoints = load_endpoint_json(boto.ENDPOINTS_PATH)
77     resolver = BotoEndpointResolver(endpoints)
78     hostname = resolver.resolve_hostname(service_name, region_name)
79     return region_cls(
80         name=region_name,
81         endpoint=hostname,
82         connection_cls=connection_cls
83     )
84 def _use_endpoint_heuristics():
85     env_var = os.environ.get('BOTO_USE_ENDPOINT_HEURISTICS', 'false').lower()
86     config_var = boto.config.getbool('Boto', 'use_endpoint_heuristics', False)
87     return env_var == 'true' or config_var
88 class RegionInfo(object):
89     """
90                  connection_cls<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None):
91         self.connection = connection
92         self.name = name
93         self.endpoint = endpoint
94         self.connection_cls = connection_cls
95     def __repr__(self):
96         return 'RegionInfo:%s' % self.name
97     def</b></font> startElement(self, name, attrs, connection):
98         return None
99     def endElement(self, name, value, connection):
100         if name == 'regionName':
101             self.name = value
102         elif name == 'regionEndpoint':
103             self.endpoint = value
104         else:
105             setattr(self, name, value)
106     def connect(self, **kw_params):
107         """
108         Connect to this Region's endpoint. Returns an connection
109         object pointing to the endpoint associated with this region.
110         You may pass any of the arguments accepted by the connection
111         class's constructor as keyword arguments and they will be
112         passed along to the connection object.
113         :rtype: Connection object
114         :return: The connection to this regions endpoint
115         """
116         if self.connection_cls:
117             return self.connection_cls(region=self, **kw_params)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>image.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from boto.ec2.ec2object import EC2Object, TaggedEC2Object
2 from boto.ec2.blockdevicemapping import BlockDeviceMapping
3 class ProductCodes(list):
4     def startElement(self, name, attrs, connection):
5         pass
6     def endElement(self, name, value, connection):
7         if name == 'productCode':
8             self.append(value)
9 class BillingProducts(list):
10     def startElement(self, name, attrs, connection):
11         pass
12     def endElement(self, name, value, connection):
13         if name == 'billingProduct':
14             self.append(value)
15 class Image(TaggedEC2Object):
16     """
17     Represents an EC2 Image
18     """
19     def __init__(self, connection=None):
20         super(Image, self).__init__(connection)
21         self.id = None
22         self.location = None
23         self.state = None
24         self.ownerId = None  # for backwards compatibility
25         self.owner_id = None
26         self.owner_alias = None
27         self.is_public = False
28         self.architecture = None
29         self.platform = None
30         self.type = None
31         self.kernel_id = None
32         self.ramdisk_id = None
33         self.name = None
34         self.description = None
35         self.product_codes = ProductCodes()
36         self.block_device_mapping = None
37         self.root_device_type = None
38         self.root_device_name <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= None
39         self.virtualization_type = None
40         self.hypervisor = None
41         self.instance_lifecycle = None
42         self.sriov_net_support = None
43     def __repr__(self):
44         return 'Image:%s' % self.id
45     def</b></font> startElement(self, name, attrs, connection):
46         retval = super(Image, self).startElement(name, attrs, connection)
47         if retval is not None:
48             return retval
49         if name == 'blockDeviceMapping':
50             self.block_device_mapping = BlockDeviceMapping()
51             return self.block_device_mapping
52         elif name == 'productCodes':
53             return self.product_codes
54         elif name == 'billingProducts':
55             return self.billing_products
56         else:
57             return None
58     def endElement(self, name, value, connection):
59         if name == 'imageId':
60             self.id = value
61         elif name == 'imageLocation':
62             self.location = value
63         elif name == 'imageState':
64             self.state = value
65         elif name == 'imageOwnerId':
66             self.ownerId = value # for backwards compatibility
67             self.owner_id = value
68         elif name == 'isPublic':
69             if value == 'false':
70                 self.is_public = False
71             elif value == 'true':
72                 self.is_public = True
73             else:
74                 raise Exception(
75                     'Unexpected value of isPublic %s for image %s' % (
76                         value,
77                         self.id
78                     )
79                 )
80         elif name == 'architecture':
81             self.architecture = value
82         elif name == 'imageType':
83             self.type = value
84         elif name == 'kernelId':
85             self.kernel_id = value
86         elif name == 'ramdiskId':
87             self.ramdisk_id = value
88         elif name == 'imageOwnerAlias':
89             self.owner_alias = value
90         elif name == 'platform':
91             self.platform = value
92         elif name == 'name':
93             self.name = value
94         elif name == 'description':
95             self.description = value
96         elif name == 'rootDeviceType':
97             self.root_device_type = value
98         elif name == 'rootDeviceName':
99             self.root_device_name = value
100         elif name == 'virtualizationType':
101             self.virtualization_type = value
102         elif name == 'hypervisor':
103             self.hypervisor = value
104         elif name == 'instanceLifecycle':
105             self.instance_lifecycle = value
106         elif name == 'sriovNetSupport':
107             self.sriov_net_support = value
108         else:
109             setattr(self, name, value)
110     def _update(self, updated):
111         self.__dict__.update(updated.__dict__)
112     def update(self, validate=False, dry_run=False):
113         """
114         Update the image's state information by making a call to fetch
115         the current image attributes from the service.
116         :type validate: bool
117         :param validate: By default, if EC2 returns no data about the
118                          image the update method returns quietly.  If
119                          the validate param is True, however, it will
120                          raise a ValueError exception if no data is
121                          returned from EC2.
122         """
123         rs = self.connection.get_all_images([self.id], dry_run=dry_run)
124         if len(rs) &gt; 0:
125             img = rs[0]
126             if img.id == self.id:
127                 self._update(img)
128         elif validate:
129             raise ValueError('%s is not a valid Image ID' % self.id)
130         return self.state
131     def run(self, min_count=1, max_count=1, key_name=None,
132             security_groups=None, user_data=None,
133             addressing_type=None, instance_type='m1.small', placement=None,
134             kernel_id=None, ramdisk_id=None,
135             monitoring_enabled=False, subnet_id=None,
136             block_device_map=None,
137             disable_api_termination=False,
138             instance_initiated_shutdown_behavior=None,
139             private_ip_address=None,
140             placement_group=None, security_group_ids=None,
141             additional_info=None, instance_profile_name=None,
142             instance_profile_arn=None, tenancy=None, dry_run=False):
143         """
144         Runs this instance.
145         :type min_count: int
146         :param min_count: The minimum number of instances to start
147         :type max_count: int
148         :param max_count: The maximum number of instances to start
149         :type key_name: string
150         :param key_name: The name of the key pair with which to
151             launch instances.
152         :type security_groups: list of strings
153         :param security_groups: The names of the security groups with which to
154             associate instances.
155         :type user_data: string
156         :param user_data: The Base64-encoded MIME user data to be made
157             available to the instance(s) in this reservation.
158         :type instance_type: string
159         :param instance_type: The type of instance to run:
160             * t1.micro
161             * m1.small
162             * m1.medium
163             * m1.large
164             * m1.xlarge
165             * m3.medium
166             * m3.large
167             * m3.xlarge
168             * m3.2xlarge
169             * c1.medium
170             * c1.xlarge
171             * m2.xlarge
172             * m2.2xlarge
173             * m2.4xlarge
174             * cr1.8xlarge
175             * hi1.4xlarge
176             * hs1.8xlarge
177             * cc1.4xlarge
178             * cg1.4xlarge
179             * cc2.8xlarge
180             * g2.2xlarge
181             * c3.large
182             * c3.xlarge
183             * c3.2xlarge
184             * c3.4xlarge
185             * c3.8xlarge
186             * c4.large
187             * c4.xlarge
188             * c4.2xlarge
189             * c4.4xlarge
190             * c4.8xlarge
191             * i2.xlarge
192             * i2.2xlarge
193             * i2.4xlarge
194             * i2.8xlarge
195             * t2.micro
196             * t2.small
197             * t2.medium
198         :type placement: string
199         :param placement: The Availability Zone to launch the instance into.
200         :type kernel_id: string
201         :param kernel_id: The ID of the kernel with which to launch the
202             instances.
203         :type ramdisk_id: string
204         :param ramdisk_id: The ID of the RAM disk with which to launch the
205             instances.
206         :type monitoring_enabled: bool
207         :param monitoring_enabled: Enable CloudWatch monitoring on
208             the instance.
209          :type subnet_id: string
210         :param subnet_id: The subnet ID within which to launch the instances
211             for VPC.
212         :type private_ip_address: string
213         :param private_ip_address: If you're using VPC, you can
214             optionally use this parameter to assign the instance a
215             specific available IP address from the subnet (e.g.,
216             10.0.0.25).
217         :type block_device_map: :class:`boto.ec2.blockdevicemapping.BlockDeviceMapping`
218         :param block_device_map: A BlockDeviceMapping data structure
219             describing the EBS volumes associated with the Image.
220         :type disable_api_termination: bool
221         :param disable_api_termination: If True, the instances will be locked
222             and will not be able to be terminated via the API.
223         :type instance_initiated_shutdown_behavior: string
224         :param instance_initiated_shutdown_behavior: Specifies whether the
225             instance stops or terminates on instance-initiated shutdown.
226             Valid values are:
227             * stop
228             * terminate
229         :type placement_group: string
230         :param placement_group: If specified, this is the name of the placement
231             group in which the instance(s) will be launched.
232         :type additional_info: string
233         :param additional_info: Specifies additional information to make
234             available to the instance(s).
235         :type security_group_ids: list of strings
236         :param security_group_ids: The ID of the VPC security groups with
237             which to associate instances.
238         :type instance_profile_name: string
239         :param instance_profile_name: The name of
240             the IAM Instance Profile (IIP) to associate with the instances.
241         :type instance_profile_arn: string
242         :param instance_profile_arn: The Amazon resource name (ARN) of
243             the IAM Instance Profile (IIP) to associate with the instances.
244         :type tenancy: string
245         :param tenancy: The tenancy of the instance you want to
246             launch. An instance with a tenancy of 'dedicated' runs on
247             single-tenant hardware and can only be launched into a
248             VPC. Valid values are:"default" or "dedicated".
249             NOTE: To use dedicated tenancy you MUST specify a VPC
250             subnet-ID as well.
251         :rtype: Reservation
252         :return: The :class:`boto.ec2.instance.Reservation` associated with
253                  the request for machines
254         """
255         return self.connection.run_instances(self.id, min_count, max_count,
256                                              key_name, security_groups,
257                                              user_data, addressing_type,
258                                              instance_type, placement,
259                                              kernel_id, ramdisk_id,
260                                              monitoring_enabled, subnet_id,
261                                              block_device_map, disable_api_termination,
262                                              instance_initiated_shutdown_behavior,
263                                              private_ip_address, placement_group,
264                                              security_group_ids=security_group_ids,
265                                              additional_info=additional_info,
266                                              instance_profile_name=instance_profile_name,
267                                              instance_profile_arn=instance_profile_arn,
268                                              tenancy=tenancy, dry_run=dry_run)
269     def deregister(self, delete_snapshot=False, dry_run=False):
270         return self.connection.deregister_image(
271             self.id,
272             delete_snapshot,
273             dry_run=dry_run
274         )
275     def get_launch_permissions(self, dry_run=False):
276         img_attrs = self.connection.get_image_attribute(
277             self.id,
278             'launchPermission',
279             dry_run=dry_run
280         )
281         return img_attrs.attrs
282     def set_launch_permissions(self, user_ids=None, group_names=None,
283                                dry_run=False):
284         return self.connection.modify_image_attribute(self.id,
285                                                       'launchPermission',
286                                                       'add',
287                                                       user_ids,
288                                                       group_names,
289                                                       dry_run=dry_run)
290     def remove_launch_permissions(self, user_ids=None, group_names=None,
291                                   dry_run=False):
292         return self.connection.modify_image_attribute(self.id,
293                                                       'launchPermission',
294                                                       'remove',
295                                                       user_ids,
296                                                       group_names,
297                                                       dry_run=dry_run)
298     def reset_launch_attributes(self, dry_run=False):
299         return self.connection.reset_image_attribute(
300             self.id,
301             'launchPermission',
302             dry_run=dry_run
303         )
304     def get_kernel(self, dry_run=False):
305         img_attrs = self.connection.get_image_attribute(
306             self.id,
307             'kernel',
308             dry_run=dry_run
309         )
310         return img_attrs.kernel
311     def get_ramdisk(self, dry_run=False):
312         img_attrs = self.connection.get_image_attribute(
313             self.id,
314             'ramdisk',
315             dry_run=dry_run
316         )
317         return img_attrs.ramdisk
318 class ImageAttribute(object):
319     def __init__(self, parent=None):
320         self.name = None
321         self.kernel = None
322         self.ramdisk = None
323         self.attrs = {}
324     def startElement(self, name, attrs, connection):
325         if name == 'blockDeviceMapping':
326             self.attrs['block_device_mapping'] = BlockDeviceMapping()
327             return self.attrs['block_device_mapping']
328         else:
329             return None
330     def endElement(self, name, value, connection):
331         if name == 'launchPermission':
332             self.name = 'launch_permission'
333         elif name == 'group':
334             if 'groups' in self.attrs:
335                 self.attrs['groups'].append(value)
336             else:
337                 self.attrs['groups'] = [value]
338         elif name == 'userId':
339             if 'user_ids' in self.attrs:
340                 self.attrs['user_ids'].append(value)
341             else:
342                 self.attrs['user_ids'] = [value]
343         elif name == 'productCode':
344             if 'product_codes' in self.attrs:
345                 self.attrs['product_codes'].append(value)
346             else:
347                 self.attrs['product_codes'] = [value]
348         elif name == 'imageId':
349             self.image_id = value
350         elif name == 'kernel':
351             self.kernel = value
352         elif name == 'ramdisk':
353             self.ramdisk = value
354         else:
355             setattr(self, name, value)
356 class CopyImage(object):
357     def __init__(self, parent=None):
358         self._parent = parent
359         self.image_id = None
360     def startElement(self, name, attrs, connection):
361         pass
362     def endElement(self, name, value, connection):
363         if name == 'imageId':
364             self.image_id = value
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
