
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-ytdl.py</h3>
            <pre><code>1  import glob
2  import os
3  import re
4  import time
5  from telethon import Button
6  try:
7      from youtubesearchpython import Playlist, VideosSearch
8  except ImportError:
9      Playlist, VideosSearch = None, None
10  from yt_dlp import YoutubeDL
11  from .. import LOGS, udB
12  from .helper import download_file, humanbytes, run_async, time_formatter
13  from .tools import set_attributes
14  async def ytdl_progress(k, start_time, event):
15      if k["status"] == "error":
16          return await event.edit("error")
17      while k["status"] == "downloading":
<span onclick='openModal()' class='match'>18          text = (
19              f"`Downloading: {k['filename']}\n"
20              + f"Total Size: {humanbytes(k['total_bytes'])}\n"
21              + f"Downloaded: {humanbytes(k['downloaded_bytes'])}\n"
22              + f"Speed: {humanbytes(k['speed'])}/s\n"
23              + f"ETA: {time_formatter(k['eta']*1000)}`"
24          )
</span>25          if round((time.time() - start_time) % 10.0) == 0:
26              try:
27                  await event.edit(text)
28              except Exception as ex:
29                  LOGS.error(f"ytdl_progress: {ex}")
30  def get_yt_link(query):
31      search = VideosSearch(query, limit=1).result()
32      try:
33          return search["result"][0]["link"]
34      except IndexError:
35          return
36  async def download_yt(event, link, ytd):
37      reply_to = event.reply_to_msg_id or event
38      info = await dler(event, link, ytd, download=True)
39      if not info:
40          return
41      if info.get("_type", None) == "playlist":
42          total = info["playlist_count"]
43          for num, file in enumerate(info["entries"]):
44              num += 1
45              id_ = file["id"]
46              thumb = id_ + ".jpg"
47              title = file["title"]
48              await download_file(
49                  file.get("thumbnail", None) or file["thumbnails"][-1]["url"], thumb
50              )
51              ext = "." + ytd["outtmpl"]["default"].split(".")[-1]
52              if ext == ".m4a":
53                  ext = ".mp3"
54              id = None
55              for x in glob.glob(f"{id_}*"):
56                  if not x.endswith("jpg"):
57                      id = x
58              if not id:
59                  return
60              ext = "." + id.split(".")[-1]
61              file = title + ext
62              try:
63                  os.rename(id, file)
64              except FileNotFoundError:
65                  try:
66                      os.rename(id + ext, file)
67                  except FileNotFoundError as er:
68                      if os.path.exists(id):
69                          file = id
70                      else:
71                          raise er
72              if file.endswith(".part"):
73                  os.remove(file)
74                  os.remove(thumb)
75                  await event.client.send_message(
76                      event.chat_id,
77                      f"`[{num}/{total}]` `Invalid Video format.\nIgnoring that...`",
78                  )
79                  return
80              attributes = await set_attributes(file)
81              res, _ = await event.client.fast_uploader(
82                  file, show_progress=True, event=event, to_delete=True
83              )
84              from_ = info["extractor"].split(":")[0]
85              caption = f"`[{num}/{total}]` `{title}`\n\n`from {from_}`"
86              await event.client.send_file(
87                  event.chat_id,
88                  file=res,
89                  caption=caption,
90                  attributes=attributes,
91                  supports_streaming=True,
92                  thumb=thumb,
93                  reply_to=reply_to,
94              )
95              os.remove(thumb)
96          try:
97              await event.delete()
98          except BaseException:
99              pass
100          return
101      title = info["title"]
102      if len(title) > 20:
103          title = title[:17] + "..."
104      id_ = info["id"]
105      thumb = id_ + ".jpg"
106      await download_file(
107          info.get("thumbnail", None) or f"https://i.ytimg.com/vi/{id_}/hqdefault.jpg",
108          thumb,
109      )
110      ext = "." + ytd["outtmpl"]["default"].split(".")[-1]
111      for _ext in [".m4a", ".mp3", ".opus"]:
112          if ext == _ext:
113              ext = _ext
114              break
115      id = None
116      for x in glob.glob(f"{id_}*"):
117          if not x.endswith("jpg"):
118              id = x
119      if not id:
120          return
121      ext = "." + id.split(".")[-1]
122      file = title + ext
123      try:
124          os.rename(id, file)
125      except FileNotFoundError:
126          os.rename(id + ext, file)
127      attributes = await set_attributes(file)
128      res, _ = await event.client.fast_uploader(
129          file, show_progress=True, event=event, to_delete=True
130      )
131      caption = f"`{info['title']}`"
132      await event.client.send_file(
133          event.chat_id,
134          file=res,
135          caption=caption,
136          attributes=attributes,
137          supports_streaming=True,
138          thumb=thumb,
139          reply_to=reply_to,
140      )
141      os.remove(thumb)
142      try:
143          await event.delete()
144      except BaseException:
145          pass
146  def get_formats(type, id, data):
147      if type == "audio":
148          audio = []
149          for _quality in ["64", "128", "256", "320"]:
150              _audio = {}
151              _audio.update(
152                  {
153                      "ytid": id,
154                      "type": "audio",
155                      "id": _quality,
156                      "quality": _quality + "KBPS",
157                  }
158              )
159              audio.append(_audio)
160          return audio
161      if type == "video":
162          video = []
163          size = 0
164          for vid in data["formats"]:
165              if vid["format_id"] == "251":
166                  size += vid["filesize"] if vid.get("filesize") else 0
167              if vid["vcodec"] != "none":
168                  _id = int(vid["format_id"])
169                  _quality = str(vid["width"]) + "×" + str(vid["height"])
170                  _size = size + (vid["filesize"] if vid.get("filesize") else 0)
171                  _ext = "mkv" if vid["ext"] == "webm" else "mp4"
172                  if _size < 2147483648:  # Telegram's Limit of 2GB
173                      _video = {}
174                      _video.update(
175                          {
176                              "ytid": id,
177                              "type": "video",
178                              "id": str(_id) + "+251",
179                              "quality": _quality,
180                              "size": _size,
181                              "ext": _ext,
182                          }
183                      )
184                      video.append(_video)
185          return video
186      return []
187  def get_buttons(listt):
188      id = listt[0]["ytid"]
189      butts = [
190          Button.inline(
191              text=f"[{x['quality']}"
192              + (f" {humanbytes(x['size'])}]" if x.get("size") else "]"),
193              data=f"ytdownload:{x['type']}:{x['id']}:{x['ytid']}"
194              + (f":{x['ext']}" if x.get("ext") else ""),
195          )
196          for x in listt
197      ]
198      buttons = list(zip(butts[::2], butts[1::2]))
199      if len(butts) % 2 == 1:
200          buttons.append((butts[-1],))
201      buttons.append([Button.inline("« Back", f"ytdl_back:{id}")])
202      return buttons
203  async def dler(event, url, opts: dict = {}, download=False):
204      await event.edit("`Getting Data...`")
205      if "quiet" not in opts:
206          opts["quiet"] = True
207      opts["username"] = udB.get_key("YT_USERNAME")
208      opts["password"] = udB.get_key("YT_PASSWORD")
209      if download:
210          await ytdownload(url, opts)
211      try:
212          return await extract_info(url, opts)
213      except Exception as e:
214          await event.edit(f"{type(e)}: {e}")
215          return
216  @run_async
217  def ytdownload(url, opts):
218      try:
219          return YoutubeDL(opts).download([url])
220      except Exception as ex:
221          LOGS.error(ex)
222  @run_async
223  def extract_info(url, opts):
224      return YoutubeDL(opts).extract_info(url=url, download=False)
225  @run_async
226  def get_videos_link(url):
227      to_return = []
228      regex = re.search(r"\?list=([(\w+)\-]*)", url)
229      if not regex:
230          return to_return
231      playlist_id = regex.group(1)
232      videos = Playlist(playlist_id)
233      for vid in videos.videos:
234          link = re.search(r"\?v=([(\w+)\-]*)", vid["link"]).group(1)
235          to_return.append(f"https://youtube.com/watch?v={link}")
236      return to_return
</code></pre>
        </div>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-callbackstuffs.py</h3>
            <pre><code>1  import ast
2  import asyncio
3  import re
4  import sys
5  import time
6  from asyncio.exceptions import TimeoutError as AsyncTimeOut
7  from os import execl, remove
8  from random import choice
9  from bs4 import BeautifulSoup as bs
10  try:
11      from pyUltroid.fns.gDrive import GDriveManager
12  except ImportError:
13      GDriveManager = None
14  from telegraph import upload_file as upl
15  from telethon import Button, events
16  from telethon.tl.types import MessageMediaWebPage
17  from telethon.utils import get_peer_id
18  from pyUltroid.fns.helper import fast_download, progress
19  from pyUltroid.fns.tools import Carbon, async_searcher, get_paste, telegraph_client
20  from pyUltroid.startup.loader import Loader
21  from . import *
22  telegraph = telegraph_client()
23  GDrive = GDriveManager() if GDriveManager else None
24  def text_to_url(event):
25      if isinstance(event.media, MessageMediaWebPage):
26          webpage = event.media.webpage
27          if not isinstance(webpage, types.WebPageEmpty) and webpage.type in ["photo"]:
28              return webpage.display_url
29      return event.text
30  _buttons = {
31      "otvars": {
32          "text": "Other Variables to set for @TeamUltroid:",
33          "buttons": [
34              [
35                  Button.inline("Tᴀɢ Lᴏɢɢᴇʀ", data="taglog"),
36                  Button.inline("SᴜᴘᴇʀFʙᴀɴ", data="cbs_sfban"),
37              ],
38              [
39                  Button.inline("Sᴜᴅᴏ Mᴏᴅᴇ", data="sudo"),
40                  Button.inline("Hᴀɴᴅʟᴇʀ", data="hhndlr"),
41              ],
42              [
43                  Button.inline("Exᴛʀᴀ Pʟᴜɢɪɴs", data="plg"),
44                  Button.inline("Aᴅᴅᴏɴs", data="eaddon"),
45              ],
46              [
47                  Button.inline("Eᴍᴏᴊɪ ɪɴ Hᴇʟᴘ", data="emoj"),
48                  Button.inline("Sᴇᴛ ɢDʀɪᴠᴇ", data="gdrive"),
49              ],
50              [
51                  Button.inline("Iɴʟɪɴᴇ Pɪᴄ", data="inli_pic"),
52                  Button.inline("Sᴜᴅᴏ HNDLR", data="shndlr"),
53              ],
54              [Button.inline("Dᴜᴀʟ Mᴏᴅᴇ", "cbs_oofdm")],
55              [Button.inline("« Bᴀᴄᴋ", data="setter")],
56          ],
57      },
58      "sfban": {
59          "text": "SuperFban Settings:",
60          "buttons": [
61              [Button.inline("FBᴀɴ Gʀᴏᴜᴘ", data="sfgrp")],
62              [Button.inline("Exᴄʟᴜᴅᴇ Fᴇᴅs", data="abs_sfexf")],
63              [Button.inline("« Bᴀᴄᴋ", data="cbs_otvars")],
64          ],
65      },
66      "apauto": {
67          "text": "This'll auto approve on outgoing messages",
68          "buttons": [
69              [Button.inline("Aᴜᴛᴏ Aᴘᴘʀᴏᴠᴇ ON", data="apon")],
70              [Button.inline("Aᴜᴛᴏ Aᴘᴘʀᴏᴠᴇ OFF", data="apof")],
71              [Button.inline("« Bᴀᴄᴋ", data="cbs_pmcstm")],
72          ],
73      },
74      "alvcstm": {
75          "text": f"Customise your {HNDLR}alive. Choose from the below options -",
76          "buttons": [
77              [Button.inline("Aʟɪᴠᴇ Tᴇxᴛ", data="abs_alvtx")],
78              [Button.inline("Aʟɪᴠᴇ ᴍᴇᴅɪᴀ", data="alvmed")],
79              [Button.inline("Dᴇʟᴇᴛᴇ Aʟɪᴠᴇ Mᴇᴅɪᴀ", data="delmed")],
80              [Button.inline("« Bᴀᴄᴋ", data="setter")],
81          ],
82      },
83      "pmcstm": {
84          "text": "Customise your PMPERMIT Settings -",
85          "buttons": [
86              [
87                  Button.inline("Pᴍ Tᴇxᴛ", data="pmtxt"),
88                  Button.inline("Pᴍ Mᴇᴅɪᴀ", data="pmmed"),
89              ],
90              [
91                  Button.inline("Aᴜᴛᴏ Aᴘᴘʀᴏᴠᴇ", data="cbs_apauto"),
92                  Button.inline("PMLOGGER", data="pml"),
93              ],
94              [
95                  Button.inline("Sᴇᴛ Wᴀʀɴs", data="swarn"),
96                  Button.inline("Dᴇʟᴇᴛᴇ Pᴍ Mᴇᴅɪᴀ", data="delpmmed"),
97              ],
98              [Button.inline("PMPermit Type", data="cbs_pmtype")],
99              [Button.inline("« Bᴀᴄᴋ", data="cbs_ppmset")],
100          ],
101      },
102      "pmtype": {
103          "text": "Select the type of PMPermit needed.",
104          "buttons": [
105              [Button.inline("Inline", data="inpm_in")],
106              [Button.inline("Normal", data="inpm_no")],
107              [Button.inline("« Bᴀᴄᴋ", data="cbs_pmcstm")],
108          ],
109      },
110      "ppmset": {
111          "text": "PMPermit Settings:",
112          "buttons": [
113              [Button.inline("Tᴜʀɴ PMPᴇʀᴍɪᴛ Oɴ", data="pmon")],
114              [Button.inline("Tᴜʀɴ PMPᴇʀᴍɪᴛ Oғғ", data="pmoff")],
115              [Button.inline("Cᴜsᴛᴏᴍɪᴢᴇ PMPᴇʀᴍɪᴛ", data="cbs_pmcstm")],
116              [Button.inline("« Bᴀᴄᴋ", data="setter")],
117          ],
118      },
119      "chatbot": {
120          "text": "From This Feature U can chat with ppls Via ur Assistant Bot.\n[More info](https://t.me/UltroidUpdates/2)",
121          "buttons": [
122              [
123                  Button.inline("Cʜᴀᴛ Bᴏᴛ  Oɴ", data="onchbot"),
124                  Button.inline("Cʜᴀᴛ Bᴏᴛ  Oғғ", data="ofchbot"),
125              ],
126              [
127                  Button.inline("Bᴏᴛ Wᴇʟᴄᴏᴍᴇ", data="bwel"),
128                  Button.inline("Bᴏᴛ Wᴇʟᴄᴏᴍᴇ Mᴇᴅɪᴀ", data="botmew"),
129              ],
130              [Button.inline("Bᴏᴛ Iɴғᴏ Tᴇxᴛ", data="botinfe")],
131              [Button.inline("Fᴏʀᴄᴇ Sᴜʙsᴄʀɪʙᴇ", data="pmfs")],
132              [Button.inline("« Bᴀᴄᴋ", data="setter")],
133          ],
134      },
135      "vcb": {
136          "text": "From This Feature U can play songs in group voice chat\n\n[moreinfo](https://t.me/UltroidUpdates/4)",
137          "buttons": [
138              [Button.inline("VC Sᴇssɪᴏɴ", data="abs_vcs")],
139              [Button.inline("« Bᴀᴄᴋ", data="setter")],
140          ],
141      },
142      "oofdm": {
143          "text": "About [Dual Mode](https://t.me/UltroidUpdates/18)",
144          "buttons": [
145              [
146                  Button.inline("Dᴜᴀʟ Mᴏᴅᴇ Oɴ", "dmof"),
147                  Button.inline("Dᴜᴀʟ Mᴏᴅᴇ Oғғ", "dmof"),
148              ],
149              [Button.inline("Dᴜᴀʟ Mᴏᴅᴇ Hɴᴅʟʀ", "dmhn")],
150              [Button.inline("« Back", data="cbs_otvars")],
151          ],
152      },
153      "apiset": {
154          "text": get_string("ast_1"),
155          "buttons": [
156              [Button.inline("Remove.bg API", data="abs_rmbg")],
157              [Button.inline("DEEP API", data="abs_dapi")],
158              [Button.inline("OCR API", data="abs_oapi")],
159              [Button.inline("« Back", data="setter")],
160          ],
161      },
162  }
163  _convo = {
164      "rmbg": {
165          "var": "RMBG_API",
166          "name": "Remove.bg API Key",
167          "text": get_string("ast_2"),
168          "back": "cbs_apiset",
169      },
170      "dapi": {
171          "var": "DEEP_AI",
172          "name": "Deep AI Api Key",
173          "text": "Get Your Deep Api from deepai.org and send here.",
174          "back": "cbs_apiset",
175      },
176      "oapi": {
177          "var": "OCR_API",
178          "name": "Ocr Api Key",
179          "text": "Get Your OCR api from ocr.space and send that Here.",
180          "back": "cbs_apiset",
181      },
182      "pmlgg": {
183          "var": "PMLOGGROUP",
184          "name": "Pm Log Group",
185          "text": "Send chat id of chat which you want to save as Pm log Group.",
186          "back": "pml",
187      },
188      "vcs": {
189          "var": "VC_SESSION",
190          "name": "Vc Session",
191          "text": "**Vc session**\nEnter the New session u generated for vc bot.\n\nUse /cancel to terminate the operation.",
192          "back": "cbs_vcb",
193      },
194      "settag": {
195          "var": "TAG_LOG",
196          "name": "Tag Log Group",
197          "text": f"Make a group, add your assistant and make it admin.\nGet the `{HNDLR}id` of that group and send it here for tag logs.\n\nUse /cancel to cancel.",
198          "back": "taglog",
199      },
200      "alvtx": {
201          "var": "ALIVE_TEXT",
202          "name": "Alive Text",
203          "text": "**Alive Text**\nEnter the new alive text.\n\nUse /cancel to terminate the operation.",
204          "back": "cbs_alvcstm",
205      },
206      "sfexf": {
207          "var": "EXCLUDE_FED",
208          "name": "Excluded Fed",
209          "text": "Send the Fed IDs you want to exclude in the ban. Split by a space.\neg`id1 id2 id3`\nSet is as `None` if you dont want any.\nUse /cancel to go back.",
210          "back": "cbs_sfban",
211      },
212  }
213  TOKEN_FILE = "resources/auths/auth_token.txt"
214  @callback(
215      re.compile(
216          "sndplug_(.*)",
217      ),
218      owner=True,
219  )
220  async def send(eve):
221      key, name = (eve.data_match.group(1)).decode("UTF-8").split("_")
222      thumb = "resources/extras/inline.jpg"
223      await eve.answer("■ Sending ■")
224      data = f"uh_{key}_"
225      index = None
226      if "|" in name:
227          name, index = name.split("|")
228      key = "plugins" if key == "Official" else key.lower()
229      plugin = f"{key}/{name}.py"
230      _ = f"pasta-{plugin}"
231      if index is not None:
232          data += f"|{index}"
233          _ += f"|{index}"
234      buttons = [
235          [
236              Button.inline(
237                  "« Pᴀsᴛᴇ »",
238                  data=_,
239              )
240          ],
241          [
242              Button.inline("« Bᴀᴄᴋ", data=data),
243          ],
244      ]
245      try:
246          await eve.edit(file=plugin, thumb=thumb, buttons=buttons)
247      except Exception as er:
248          await eve.answer(str(er), alert=True)
249  heroku_api, app_name = Var.HEROKU_API, Var.HEROKU_APP_NAME
250  @callback("updatenow", owner=True)
251  async def update(eve):
252      repo = Repo()
253      ac_br = repo.active_branch
254      ups_rem = repo.remote("upstream")
255      if heroku_api:
256          import heroku3
257          try:
258              heroku = heroku3.from_key(heroku_api)
259              heroku_app = None
260              heroku_applications = heroku.apps()
261          except BaseException as er:
262              LOGS.exception(er)
263              return await eve.edit("`Wrong HEROKU_API.`")
264          for app in heroku_applications:
265              if app.name == app_name:
266                  heroku_app = app
267          if not heroku_app:
268              await eve.edit("`Wrong HEROKU_APP_NAME.`")
269              repo.__del__()
270              return
271          await eve.edit(get_string("clst_1"))
272          ups_rem.fetch(ac_br)
273          repo.git.reset("--hard", "FETCH_HEAD")
274          heroku_git_url = heroku_app.git_url.replace(
275              "https://", f"https://api:{heroku_api}@"
276          )
277          if "heroku" in repo.remotes:
278              remote = repo.remote("heroku")
279              remote.set_url(heroku_git_url)
280          else:
281              remote = repo.create_remote("heroku", heroku_git_url)
282          try:
283              remote.push(refspec=f"HEAD:refs/heads/{ac_br}", force=True)
284          except GitCommandError as error:
285              await eve.edit(f"`Here is the error log:\n{error}`")
286              repo.__del__()
287              return
288          await eve.edit("`Successfully Updated!\nRestarting, please wait...`")
289      else:
290          await eve.edit(get_string("clst_1"))
291          call_back()
292          await bash("git pull && pip3 install -r requirements.txt")
293          execl(sys.executable, sys.executable, "-m", "pyUltroid")
294  @callback(re.compile("changes(.*)"), owner=True)
295  async def changes(okk):
296      match = okk.data_match.group(1).decode("utf-8")
297      await okk.answer(get_string("clst_3"))
298      repo = Repo.init()
299      button = [[Button.inline("Update Now", data="updatenow")]]
300      changelog, tl_chnglog = await gen_chlog(
301          repo, f"HEAD..upstream/{repo.active_branch}"
302      )
303      cli = "\n\nClick the below button to update!"
304      if not match:
305          try:
306              if len(tl_chnglog) > 700:
307                  tl_chnglog = f"{tl_chnglog[:700]}..."
308                  button.append([Button.inline("View Complete", "changesall")])
309              await okk.edit("• Writing Changelogs 📝 •")
310              img = await Carbon(
311                  file_name="changelog",
312                  code=tl_chnglog,
313                  backgroundColor=choice(ATRA_COL),
314                  language="md",
315              )
316              return await okk.edit(
317                  f"**• Ultroid Userbot •**{cli}", file=img, buttons=button
318              )
319          except Exception as er:
320              LOGS.exception(er)
321      changelog_str = changelog + cli
322      if len(changelog_str) > 1024:
323          await okk.edit(get_string("upd_4"))
324          await asyncio.sleep(2)
325          with open("ultroid_updates.txt", "w+") as file:
326              file.write(tl_chnglog)
327          await okk.edit(
328              get_string("upd_5"),
329              file="ultroid_updates.txt",
330              buttons=button,
331          )
332          remove("ultroid_updates.txt")
333          return
334      await okk.edit(
335          changelog_str,
336          buttons=button,
337          parse_mode="html",
338      )
339  @callback(
340      re.compile(
341          "pasta-(.*)",
342      ),
343      owner=True,
344  )
345  async def _(e):
346      ok = (e.data_match.group(1)).decode("UTF-8")
347      index = None
348      if "|" in ok:
349          ok, index = ok.split("|")
350      with open(ok, "r") as hmm:
351          _, key = await get_paste(hmm.read())
352      link = f"https://spaceb.in/{key}"
353      raw = f"https://spaceb.in/api/v1/documents/{key}/raw"
354      if not _:
355          return await e.answer(key[:30], alert=True)
356      if ok.startswith("addons"):
357          key = "Addons"
358      elif ok.startswith("vcbot"):
359          key = "VCBot"
360      else:
361          key = "Official"
362      data = f"uh_{key}_"
363      if index is not None:
364          data += f"|{index}"
365      await e.edit(
366          "",
367          buttons=[
368              [Button.url("Lɪɴᴋ", link), Button.url("Rᴀᴡ", raw)],
369              [Button.inline("« Bᴀᴄᴋ", data=data)],
370          ],
371      )
372  @callback(re.compile("cbs_(.*)"), owner=True)
373  async def _edit_to(event):
374      match = event.data_match.group(1).decode("utf-8")
375      data = _buttons.get(match)
376      if not data:
377          return
378      await event.edit(data["text"], buttons=data["buttons"], link_preview=False)
379  @callback(re.compile("abs_(.*)"), owner=True)
380  async def convo_handler(event: events.CallbackQuery):
381      match = event.data_match.group(1).decode("utf-8")
382      if not _convo.get(match):
383          return
384      await event.delete()
385      get_ = _convo[match]
386      back = get_["back"]
387      async with event.client.conversation(event.sender_id) as conv:
388          await conv.send_message(get_["text"])
389          response = await conv.get_response()
390          themssg = response.message
391          try:
392              themssg = ast.literal_eval(themssg)
393          except Exception:
394              pass
395          if themssg == "/cancel":
396              return await conv.send_message(
397                  "Cancelled!!",
398                  buttons=get_back_button(back),
399              )
400          await setit(event, get_["var"], themssg)
401          await conv.send_message(
402              f"{get_['name']} changed to `{themssg}`",
403              buttons=get_back_button(back),
404          )
405  @callback("authorise", owner=True)
406  async def _(e):
407      if not e.is_private:
408          return
409      url = GDrive._create_token_file()
410      await e.edit("Go to the below link and send the code!")
411      async with asst.conversation(e.sender_id) as conv:
412          await conv.send_message(url)
413          code = await conv.get_response()
414          if GDrive._create_token_file(code=code.text):
415              await conv.send_message(
416                  "`Success!\nYou are all set to use Google Drive with Ultroid Userbot.`",
417                  buttons=Button.inline("Main Menu", data="setter"),
418              )
419          else:
420              await conv.send_message("Wrong code! Click authorise again.")
421  @callback("folderid", owner=True, func=lambda x: x.is_private)
422  async def _(e):
423      if not e.is_private:
424          return
<span onclick='openModal()' class='match'>425      msg = (
426          "Send your FOLDER ID\n\n"
427          + "For FOLDER ID:\n"
428          + "1. Open Google Drive App.\n"
429          + "2. Create Folder.\n"
430          + "3. Make that folder public.\n"
431          + "4. Send link of that folder."
</span>432      )
433      await e.delete()
434      async with asst.conversation(e.sender_id, timeout=150) as conv:
435          await conv.send_message(msg)
436          repl = await conv.get_response()
437          id = repl.text
438          if id.startswith("https"):
439              id = id.split("?id=")[-1]
440          udB.set_key("GDRIVE_FOLDER_ID", id)
441          await repl.reply(
442              "`Success.`",
443              buttons=get_back_button("gdrive"),
444          )
445  @callback("gdrive", owner=True)
446  async def _(e):
447      if not e.is_private:
448          return
449      await e.edit(
450          "Click Authorise and send the code.\n\nYou can use your own CLIENT ID and SECRET by [this](https://t.me/UltroidUpdates/37)",
451          buttons=[
452              [
453                  Button.inline("Folder ID", data="folderid"),
454                  Button.inline("Authorise", data="authorise"),
455              ],
456              [Button.inline("« Back", data="cbs_otvars")],
457          ],
458          link_preview=False,
459      )
460  @callback("dmof", owner=True)
461  async def rhwhe(e):
462      if udB.get_key("DUAL_MODE"):
463          udB.del_key("DUAL_MODE")
464          key = "Off"
465      else:
466          udB.set_key("DUAL_MODE", "True")
467          key = "On"
468      Msg = f"Dual Mode : {key}"
469      await e.edit(Msg, buttons=get_back_button("cbs_otvars"))
470  @callback("dmhn", owner=True)
471  async def hndlrr(event):
472      await event.delete()
473      pru = event.sender_id
474      var = "DUAL_HNDLR"
475      name = "Dual Handler"
476      CH = udB.get_key(var) or "/"
477      async with event.client.conversation(pru) as conv:
478          await conv.send_message(
479              f"Send The Symbol Which u want as Handler/Trigger to use your Assistant bot\nUr Current Handler is [ `{CH}` ]\n\n use /cancel to cancel.",
480          )
481          response = conv.wait_event(events.NewMessage(chats=pru))
482          response = await response
483          themssg = response.message.message
484          if themssg == "/cancel":
485              await conv.send_message(
486                  "Cancelled!!",
487                  buttons=get_back_button("cbs_otvars"),
488              )
489          elif len(themssg) > 1:
490              await conv.send_message(
491                  "Incorrect Handler",
492                  buttons=get_back_button("cbs_otvars"),
493              )
494          else:
495              await setit(event, var, themssg)
496              await conv.send_message(
497                  f"{name} changed to {themssg}",
498                  buttons=get_back_button("cbs_otvars"),
499              )
500  @callback("emoj", owner=True)
501  async def emoji(event):
502      await event.delete()
503      pru = event.sender_id
504      var = "EMOJI_IN_HELP"
505      name = f"Emoji in `{HNDLR}help` menu"
506      async with event.client.conversation(pru) as conv:
507          await conv.send_message("Send emoji u want to set 🙃.\n\nUse /cancel to cancel.")
508          response = conv.wait_event(events.NewMessage(chats=pru))
509          response = await response
510          themssg = response.message.message
511          if themssg == "/cancel":
512              await conv.send_message(
513                  "Cancelled!!",
514                  buttons=get_back_button("cbs_otvars"),
515              )
516          elif themssg.startswith(("/", HNDLR)):
517              await conv.send_message(
518                  "Incorrect Emoji",
519                  buttons=get_back_button("cbs_otvars"),
520              )
521          else:
522              await setit(event, var, themssg)
523              await conv.send_message(
524                  f"{name} changed to {themssg}\n",
525                  buttons=get_back_button("cbs_otvars"),
526              )
527  @callback("plg", owner=True)
528  async def pluginch(event):
529      await event.delete()
530      pru = event.sender_id
531      var = "PLUGIN_CHANNEL"
532      name = "Plugin Channel"
533      async with event.client.conversation(pru) as conv:
534          await conv.send_message(
535              "Send id or username of a channel from where u want to install all plugins\n\nOur Channel~ @ultroidplugins\n\nUse /cancel to cancel.",
536          )
537          response = conv.wait_event(events.NewMessage(chats=pru))
538          response = await response
539          themssg = response.message.message
540          if themssg == "/cancel":
541              await conv.send_message(
542                  "Cancelled!!",
543                  buttons=get_back_button("cbs_otvars"),
544              )
545          elif themssg.startswith(("/", HNDLR)):
546              await conv.send_message(
547                  "Incorrect channel",
548                  buttons=get_back_button("cbs_otvars"),
549              )
550          else:
551              await setit(event, var, themssg)
552              await conv.send_message(
553                  f"{name} changed to {themssg}\n After Setting All Things Do Restart",
554                  buttons=get_back_button("cbs_otvars"),
555              )
556  @callback("hhndlr", owner=True)
557  async def hndlrr(event):
558      await event.delete()
559      pru = event.sender_id
560      var = "HNDLR"
561      name = "Handler/ Trigger"
562      async with event.client.conversation(pru) as conv:
563          await conv.send_message(
564              f"Send The Symbol Which u want as Handler/Trigger to use bot\nUr Current Handler is [ `{HNDLR}` ]\n\n use /cancel to cancel.",
565          )
566          response = conv.wait_event(events.NewMessage(chats=pru))
567          response = await response
568          themssg = response.message.message
569          if themssg == "/cancel":
570              await conv.send_message(
571                  "Cancelled!!",
572                  buttons=get_back_button("cbs_otvars"),
573              )
574          elif len(themssg) > 1:
575              await conv.send_message(
576                  "Incorrect Handler",
577                  buttons=get_back_button("cbs_otvars"),
578              )
579          elif themssg.startswith(("/", "#", "@")):
580              await conv.send_message(
581                  "This cannot be used as handler",
582                  buttons=get_back_button("cbs_otvars"),
583              )
584          else:
585              await setit(event, var, themssg)
586              await conv.send_message(
587                  f"{name} changed to {themssg}",
588                  buttons=get_back_button("cbs_otvars"),
589              )
590  @callback("shndlr", owner=True)
591  async def hndlrr(event):
592      await event.delete()
593      pru = event.sender_id
594      var = "SUDO_HNDLR"
595      name = "Sudo Handler"
596      async with event.client.conversation(pru) as conv:
597          await conv.send_message(
598              "Send The Symbol Which u want as Sudo Handler/Trigger to use bot\n\n use /cancel to cancel."
599          )
600          response = conv.wait_event(events.NewMessage(chats=pru))
601          response = await response
602          themssg = response.message.message
603          if themssg == "/cancel":
604              await conv.send_message(
605                  "Cancelled!!",
606                  buttons=get_back_button("cbs_otvars"),
607              )
608          elif len(themssg) > 1:
609              await conv.send_message(
610                  "Incorrect Handler",
611                  buttons=get_back_button("cbs_otvars"),
612              )
613          elif themssg.startswith(("/", "#", "@")):
614              await conv.send_message(
615                  "This cannot be used as handler",
616                  buttons=get_back_button("cbs_otvars"),
617              )
618          else:
619              await setit(event, var, themssg)
620              await conv.send_message(
621                  f"{name} changed to {themssg}",
622                  buttons=get_back_button("cbs_otvars"),
623              )
624  @callback("taglog", owner=True)
625  async def tagloggrr(e):
626      BUTTON = [
627          [Button.inline("SET TAG LOG", data="abs_settag")],
628          [Button.inline("DELETE TAG LOG", data="deltag")],
629          get_back_button("cbs_otvars"),
630      ]
631      await e.edit(
632          "Choose Options",
633          buttons=BUTTON,
634      )
635  @callback("deltag", owner=True)
636  async def _(e):
637      udB.del_key("TAG_LOG")
638      await e.answer("Done!!! Tag Logger has been turned Off")
639  @callback("eaddon", owner=True)
640  async def pmset(event):
641      BT = (
642          [Button.inline("Aᴅᴅᴏɴs  Oғғ", data="edof")]
643          if udB.get_key("ADDONS")
644          else [Button.inline("Aᴅᴅᴏɴs  Oɴ", data="edon")]
645      )
646      await event.edit(
647          "ADDONS~ Extra Plugins:",
648          buttons=[
649              BT,
650              [Button.inline("« Bᴀᴄᴋ", data="cbs_otvars")],
651          ],
652      )
653  @callback("edon", owner=True)
654  async def eddon(event):
655      var = "ADDONS"
656      await setit(event, var, "True")
657      await event.edit(
658          "Done! ADDONS has been turned on!!\n\n After Setting All Things Do Restart",
659          buttons=get_back_button("eaddon"),
660      )
661  @callback("edof", owner=True)
662  async def eddof(event):
663      udB.set_key("ADDONS", "False")
664      await event.edit(
665          "Done! ADDONS has been turned off!! After Setting All Things Do Restart",
666          buttons=get_back_button("eaddon"),
667      )
668  @callback("sudo", owner=True)
669  async def pmset(event):
670      BT = (
671          [Button.inline("Sᴜᴅᴏ Mᴏᴅᴇ  Oғғ", data="ofsudo")]
672          if udB.get_key("SUDO")
673          else [Button.inline("Sᴜᴅᴏ Mᴏᴅᴇ  Oɴ", data="onsudo")]
674      )
675      await event.edit(
676          f"SUDO MODE ~ Some peoples can use ur Bot which u selected. To know More use `{HNDLR}help sudo`",
677          buttons=[
678              BT,
679              [Button.inline("« Bᴀᴄᴋ", data="cbs_otvars")],
680          ],
681      )
682  @callback("onsudo", owner=True)
683  async def eddon(event):
684      var = "SUDO"
685      await setit(event, var, "True")
686      await event.edit(
687          "Done! SUDO MODE has been turned on!!\n\n After Setting All Things Do Restart",
688          buttons=get_back_button("sudo"),
689      )
690  @callback("ofsudo", owner=True)
691  async def eddof(event):
692      var = "SUDO"
693      await setit(event, var, "False")
694      await event.edit(
695          "Done! SUDO MODE has been turned off!! After Setting All Things Do Restart",
696          buttons=get_back_button("sudo"),
697      )
698  @callback("sfgrp", owner=True)
699  async def sfgrp(event):
700      await event.delete()
701      name = "FBan Group ID"
702      var = "FBAN_GROUP_ID"
703      pru = event.sender_id
704      async with asst.conversation(pru) as conv:
705          await conv.send_message(
706              f"Make a group, add @MissRose_Bot, send `{HNDLR}id`, copy that and send it here.\nUse /cancel to go back.",
707          )
708          response = conv.wait_event(events.NewMessage(chats=pru))
709          response = await response
710          themssg = response.message.message
711          if themssg == "/cancel":
712              return await conv.send_message(
713                  "Cancelled!!",
714                  buttons=get_back_button("cbs_sfban"),
715              )
716          await setit(event, var, themssg)
717          await conv.send_message(
718              f"{name} changed to {themssg}",
719              buttons=get_back_button("cbs_sfban"),
720          )
721  @callback("alvmed", owner=True)
722  async def media(event):
723      await event.delete()
724      pru = event.sender_id
725      var = "ALIVE_PIC"
726      name = "Alive Media"
727      async with event.client.conversation(pru) as conv:
728          await conv.send_message(
729              "**Alive Media**\nSend me a pic/gif/media to set as alive media.\n\nUse /cancel to terminate the operation.",
730          )
731          response = await conv.get_response()
732          try:
733              themssg = response.message
734              if themssg == "/cancel":
735                  return await conv.send_message(
736                      "Operation cancelled!!",
737                      buttons=get_back_button("cbs_alvcstm"),
738                  )
739          except BaseException as er:
740              LOGS.exception(er)
741          if (
742              not (response.text).startswith("/")
743              and response.text != ""
744              and (not response.media or isinstance(response.media, MessageMediaWebPage))
745          ):
746              url = text_to_url(response)
747          elif response.sticker:
748              url = response.file.id
749          else:
750              media = await event.client.download_media(response, "alvpc")
751              try:
752                  x = upl(media)
753                  url = f"https://graph.org/{x[0]}"
754                  remove(media)
755              except BaseException as er:
756                  LOGS.exception(er)
757                  return await conv.send_message(
758                      "Terminated.",
759                      buttons=get_back_button("cbs_alvcstm"),
760                  )
761          await setit(event, var, url)
762          await conv.send_message(
763              f"{name} has been set.",
764              buttons=get_back_button("cbs_alvcstm"),
765          )
766  @callback("delmed", owner=True)
767  async def dell(event):
768      try:
769          udB.del_key("ALIVE_PIC")
770          return await event.edit(
771              get_string("clst_5"), buttons=get_back_button("cbs_alabs_vcstm")
772          )
773      except BaseException as er:
774          LOGS.exception(er)
775          return await event.edit(
776              get_string("clst_4"),
777              buttons=get_back_button("cbs_alabs_vcstm"),
778          )
779  @callback("inpm_in", owner=True)
780  async def inl_on(event):
781      var = "INLINE_PM"
782      await setit(event, var, "True")
783      await event.edit(
784          "Done!! PMPermit type has been set to inline!",
785          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_pmtype")]],
786      )
787  @callback("inpm_no", owner=True)
788  async def inl_on(event):
789      var = "INLINE_PM"
790      await setit(event, var, "False")
791      await event.edit(
792          "Done!! PMPermit type has been set to normal!",
793          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_pmtype")]],
794      )
795  @callback("pmtxt", owner=True)
796  async def name(event):
797      await event.delete()
798      pru = event.sender_id
799      var = "PM_TEXT"
800      name = "PM Text"
801      async with event.client.conversation(pru) as conv:
802          await conv.send_message(
803              "**PM Text**\nEnter the new Pmpermit text.\n\nu can use `{name}` `{fullname}` `{count}` `{mention}` `{username}` to get this from user Too\n\nUse /cancel to terminate the operation.",
804          )
805          response = conv.wait_event(events.NewMessage(chats=pru))
806          response = await response
807          themssg = response.message.message
808          if themssg == "/cancel":
809              return await conv.send_message(
810                  "Cancelled!!",
811                  buttons=get_back_button("cbs_pmcstm"),
812              )
813          if len(themssg) > 4090:
814              return await conv.send_message(
815                  "Message too long!\nGive a shorter message please!!",
816                  buttons=get_back_button("cbs_pmcstm"),
817              )
818          await setit(event, var, themssg)
819          await conv.send_message(
820              f"{name} changed to {themssg}\n\nAfter Setting All Things Do restart",
821              buttons=get_back_button("cbs_pmcstm"),
822          )
823  @callback("swarn", owner=True)
824  async def name(event):
825      m = range(1, 10)
826      tultd = [Button.inline(f"{x}", data=f"wrns_{x}") for x in m]
827      lst = list(zip(tultd[::3], tultd[1::3], tultd[2::3]))
828      lst.append([Button.inline("« Bᴀᴄᴋ", data="cbs_pmcstm")])
829      await event.edit(
830          "Select the number of warnings for a user before getting blocked in PMs.",
831          buttons=lst,
832      )
833  @callback(re.compile(b"wrns_(.*)"), owner=True)
834  async def set_wrns(event):
835      value = int(event.data_match.group(1).decode("UTF-8"))
836      if dn := udB.set_key("PMWARNS", value):
837          await event.edit(
838              f"PM Warns Set to {value}.\nNew users will have {value} chances in PMs before getting banned.",
839              buttons=get_back_button("cbs_pmcstm"),
840          )
841      else:
842          await event.edit(
843              f"Something went wrong, please check your {HNDLR}logs!",
844              buttons=get_back_button("cbs_pmcstm"),
845          )
846  @callback("pmmed", owner=True)
847  async def media(event):
848      await event.delete()
849      pru = event.sender_id
850      var = "PMPIC"
851      name = "PM Media"
852      async with event.client.conversation(pru) as conv:
853          await conv.send_message(
854              "**PM Media**\nSend me a pic/gif/sticker/link  to set as pmpermit media.\n\nUse /cancel to terminate the operation.",
855          )
856          response = await conv.get_response()
857          try:
858              themssg = response.message
859              if themssg == "/cancel":
860                  return await conv.send_message(
861                      "Operation cancelled!!",
862                      buttons=get_back_button("cbs_pmcstm"),
863                  )
864          except BaseException as er:
865              LOGS.exception(er)
866          media = await event.client.download_media(response, "pmpc")
867          if (
868              not (response.text).startswith("/")
869              and response.text != ""
870              and (not response.media or isinstance(response.media, MessageMediaWebPage))
871          ):
872              url = text_to_url(response)
873          elif response.sticker:
874              url = response.file.id
875          else:
876              try:
877                  x = upl(media)
878                  url = f"https://graph.org/{x[0]}"
879                  remove(media)
880              except BaseException as er:
881                  LOGS.exception(er)
882                  return await conv.send_message(
883                      "Terminated.",
884                      buttons=get_back_button("cbs_pmcstm"),
885                  )
886          await setit(event, var, url)
887          await conv.send_message(
888              f"{name} has been set.",
889              buttons=get_back_button("cbs_pmcstm"),
890          )
891  @callback("delpmmed", owner=True)
892  async def dell(event):
893      try:
894          udB.del_key("PMPIC")
895          return await event.edit(
896              get_string("clst_5"), buttons=get_back_button("cbs_pmcstm")
897          )
898      except BaseException as er:
899          LOGS.exception(er)
900          return await event.edit(
901              get_string("clst_4"),
902              buttons=[[Button.inline("« Sᴇᴛᴛɪɴɢs", data="setter")]],
903          )
904  @callback("apon", owner=True)
905  async def apon(event):
906      var = "AUTOAPPROVE"
907      await setit(event, var, "True")
908      await event.edit(
909          "Done!! AUTOAPPROVE  Started!!",
910          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_apauto")]],
911      )
912  @callback("apof", owner=True)
913  async def apof(event):
914      try:
915          udB.set_key("AUTOAPPROVE", "False")
916          return await event.edit(
917              "Done! AUTOAPPROVE Stopped!!",
918              buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_apauto")]],
919          )
920      except BaseException as er:
921          LOGS.exception(er)
922          return await event.edit(
923              get_string("clst_4"),
924              buttons=[[Button.inline("« Sᴇᴛᴛɪɴɢs", data="setter")]],
925          )
926  @callback("pml", owner=True)
927  async def l_vcs(event):
928      BT = (
929          [Button.inline("PMLOGGER OFF", data="pmlogof")]
930          if udB.get_key("PMLOG")
931          else [Button.inline("PMLOGGER ON", data="pmlog")]
932      )
933      await event.edit(
934          "PMLOGGER This Will Forward Ur Pm to Ur Private Group -",
935          buttons=[
936              BT,
937              [Button.inline("PᴍLᴏɢɢᴇʀ Gʀᴏᴜᴘ", "abs_pmlgg")],
938              [Button.inline("« Bᴀᴄᴋ", data="cbs_pmcstm")],
939          ],
940      )
941  @callback("pmlog", owner=True)
942  async def pmlog(event):
943      await setit(event, "PMLOG", "True")
944      await event.edit(
945          "Done!! PMLOGGER  Started!!",
946          buttons=[[Button.inline("« Bᴀᴄᴋ", data="pml")]],
947      )
948  @callback("pmlogof", owner=True)
949  async def pmlogof(event):
950      try:
951          udB.del_key("PMLOG")
952          return await event.edit(
953              "Done! PMLOGGER Stopped!!",
954              buttons=[[Button.inline("« Bᴀᴄᴋ", data="pml")]],
955          )
956      except BaseException as er:
957          LOGS.exception(er)
958          return await event.edit(
959              get_string("clst_4"),
960              buttons=[[Button.inline("« Sᴇᴛᴛɪɴɢs", data="setter")]],
961          )
962  @callback("pmon", owner=True)
963  async def pmonn(event):
964      var = "PMSETTING"
965      await setit(event, var, "True")
966      await event.edit(
967          "Done! PMPermit has been turned on!!",
968          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_ppmset")]],
969      )
970  @callback("pmoff", owner=True)
971  async def pmofff(event):
972      var = "PMSETTING"
973      await setit(event, var, "False")
974      await event.edit(
975          "Done! PMPermit has been turned off!!",
976          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_ppmset")]],
977      )
978  @callback("botmew", owner=True)
979  async def hhh(e):
980      async with e.client.conversation(e.chat_id) as conv:
981          await conv.send_message("Send Any Media to keep at your Bot's welcome ")
982          msg = await conv.get_response()
983          if not msg.media or msg.text.startswith("/"):
984              return await conv.send_message(
985                  "Terminated!", buttons=get_back_button("cbs_chatbot")
986              )
987          udB.set_key("STARTMEDIA", msg.file.id)
988          await conv.send_message("Done!", buttons=get_back_button("cbs_chatbot"))
989  @callback("botinfe", owner=True)
990  async def hhh(e):
991      async with e.client.conversation(e.chat_id) as conv:
992          await conv.send_message(
993              "Send message to set to Display, when user Press Info button in Bot Welcome!\n\nsend `False` to completely remove that button.."
994          )
995          msg = await conv.get_response()
996          if msg.media or msg.text.startswith("/"):
997              return await conv.send_message(
998                  "Terminated!", buttons=get_back_button("cbs_chatbot")
999              )
1000          udB.set_key("BOT_INFO_START", msg.text)
1001          await conv.send_message("Done!", buttons=get_back_button("cbs_chatbot"))
1002  @callback("pmfs", owner=True)
1003  async def heheh(event):
1004      Ll = []
1005      err = ""
1006      async with event.client.conversation(event.chat_id) as conv:
1007          await conv.send_message(
1008              "• Send The Chat Id(s), which you want user to Join Before using Chat/Pm Bot\n\n• Send /clear to disable PmBot Force sub..\n• • Send /cancel to stop this process.."
1009          )
1010          await conv.send_message(
1011              "Example : \n`-1001234567\n-100778888`\n\nFor Multiple Chat(s)."
1012          )
1013          try:
1014              msg = await conv.get_response()
1015          except AsyncTimeOut:
1016              return await conv.send_message("**• TimeUp!**\nStart from /start back.")
1017          if not msg.text or msg.text.startswith("/"):
1018              timyork = "Cancelled!"
1019              if msg.text == "/clear":
1020                  udB.del_key("PMBOT_FSUB")
1021                  timyork = "Done! Force Subscribe Stopped\nRestart your Bot!"
1022              return await conv.send_message(
1023                  "Cancelled!", buttons=get_back_button("cbs_chatbot")
1024              )
1025          for chat in msg.message.split("\n"):
1026              if chat.startswith("-") or chat.isdigit():
1027                  chat = int(chat)
1028              try:
1029                  CHSJSHS = await event.client.get_entity(chat)
1030                  Ll.append(get_peer_id(CHSJSHS))
1031              except Exception as er:
1032                  err += f"**{chat}** : {er}\n"
1033          if err:
1034              return await conv.send_message(err)
1035          udB.set_key("PMBOT_FSUB", str(Ll))
1036          await conv.send_message(
1037              "Done!\nRestart Your Bot.", buttons=get_back_button("cbs_chatbot")
1038          )
1039  @callback("bwel", owner=True)
1040  async def name(event):
1041      await event.delete()
1042      pru = event.sender_id
1043      var = "STARTMSG"
1044      name = "Bot Welcome Message:"
1045      async with event.client.conversation(pru) as conv:
1046          await conv.send_message(
1047              "**BOT WELCOME MSG**\nEnter the msg which u want to show when someone start your assistant Bot.\nYou Can use `{me}` , `{mention}` Parameters Too\nUse /cancel to terminate the operation.",
1048          )
1049          response = conv.wait_event(events.NewMessage(chats=pru))
1050          response = await response
1051          themssg = response.message.message
1052          if themssg == "/cancel":
1053              return await conv.send_message(
1054                  "Cancelled!!",
1055                  buttons=get_back_button("cbs_chatbot"),
1056              )
1057          await setit(event, var, themssg)
1058          await conv.send_message(
1059              f"{name} changed to {themssg}",
1060              buttons=get_back_button("cbs_chatbot"),
1061          )
1062  @callback("onchbot", owner=True)
1063  async def chon(event):
1064      var = "PMBOT"
1065      await setit(event, var, "True")
1066      Loader(path="assistant/pmbot.py", key="PM Bot").load()
1067      if AST_PLUGINS.get("pmbot"):
1068          for i, e in AST_PLUGINS["pmbot"]:
1069              event.client.remove_event_handler(i)
1070          for i, e in AST_PLUGINS["pmbot"]:
1071              event.client.add_event_handler(i, events.NewMessage(**e))
1072      await event.edit(
1073          "Done! Now u Can Chat With People Via This Bot",
1074          buttons=[Button.inline("« Bᴀᴄᴋ", data="cbs_chatbot")],
1075      )
1076  @callback("ofchbot", owner=True)
1077  async def chon(event):
1078      var = "PMBOT"
1079      await setit(event, var, "False")
1080      if AST_PLUGINS.get("pmbot"):
1081          for i, e in AST_PLUGINS["pmbot"]:
1082              event.client.remove_event_handler(i)
1083      await event.edit(
1084          "Done! Chat People Via This Bot Stopped.",
1085          buttons=[Button.inline("« Bᴀᴄᴋ", data="cbs_chatbot")],
1086      )
1087  @callback("inli_pic", owner=True)
1088  async def media(event):
1089      await event.delete()
1090      pru = event.sender_id
1091      var = "INLINE_PIC"
1092      name = "Inline Media"
1093      async with event.client.conversation(pru) as conv:
1094          await conv.send_message(
1095              "**Inline Media**\nSend me a pic/gif/ or link  to set as inline media.\n\nUse /cancel to terminate the operation.",
1096          )
1097          response = await conv.get_response()
1098          try:
1099              themssg = response.message
1100              if themssg == "/cancel":
1101                  return await conv.send_message(
1102                      "Operation cancelled!!",
1103                      buttons=get_back_button("setter"),
1104                  )
1105          except BaseException as er:
1106              LOGS.exception(er)
1107          media = await event.client.download_media(response, "inlpic")
1108          if (
1109              not (response.text).startswith("/")
1110              and response.text != ""
1111              and (not response.media or isinstance(response.media, MessageMediaWebPage))
1112          ):
1113              url = text_to_url(response)
1114          else:
1115              try:
1116                  x = upl(media)
1117                  url = f"https://graph.org/{x[0]}"
1118                  remove(media)
1119              except BaseException as er:
1120                  LOGS.exception(er)
1121                  return await conv.send_message(
1122                      "Terminated.",
1123                      buttons=get_back_button("setter"),
1124                  )
1125          await setit(event, var, url)
1126          await conv.send_message(
1127              f"{name} has been set.",
1128              buttons=get_back_button("setter"),
1129          )
1130  FD_MEDIA = {}
1131  @callback(re.compile("fd(.*)"), owner=True)
1132  async def fdroid_dler(event):
1133      uri = event.data_match.group(1).decode("utf-8")
1134      if FD_MEDIA.get(uri):
1135          return await event.edit(file=FD_MEDIA[uri])
1136      await event.answer("• Starting Download •", alert=True)
1137      await event.edit("• Downloading.. •")
1138      URL = f"https://f-droid.org/packages/{uri}"
1139      conte = await async_searcher(URL, re_content=True)
1140      BSC = bs(conte, "html.parser", from_encoding="utf-8")
1141      dl_ = BSC.find("p", "package-version-download").find("a")["href"]
1142      title = BSC.find("h3", "package-name").text.strip()
1143      thumb = BSC.find("img", "package-icon")["src"]
1144      if thumb.startswith("/"):
1145          thumb = f"https://f-droid.org{thumb}"
1146      thumb, _ = await fast_download(thumb, filename=f"{uri}.png")
1147      s_time = time.time()
1148      file, _ = await fast_download(
1149          dl_,
1150          filename=f"{title}.apk",
1151          progress_callback=lambda d, t: asyncio.get_event_loop().create_task(
1152              progress(
1153                  d,
1154                  t,
1155                  event,
1156                  s_time,
1157                  "Downloading...",
1158              )
1159          ),
1160      )
1161      time.time()
1162      n_file = await event.client.fast_uploader(
1163          file, show_progress=True, event=event, message="Uploading...", to_delete=True
1164      )
1165      buttons = Button.switch_inline("Search Back", query="fdroid", same_peer=True)
1166      try:
1167          msg = await event.edit(
1168              f"**• [{title}]({URL}) •**", file=n_file, thumb=thumb, buttons=buttons
1169          )
1170      except Exception as er:
1171          LOGS.exception(er)
1172          try:
1173              msg = await event.client.edit_message(
1174                  await event.get_input_chat(),
1175                  event.message_id,
1176                  f"**• [{title}]({URL}) •**",
1177                  buttons=buttons,
1178                  thumb=thumb,
1179                  file=n_file,
1180              )
1181          except Exception as er:
1182              os.remove(thumb)
1183              LOGS.exception(er)
1184              return await event.edit(f"**ERROR**: `{er}`", buttons=buttons)
1185      if msg and hasattr(msg, "media"):
1186          FD_MEDIA.update({uri: msg.media})
1187      os.remove(thumb)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-ytdl.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-callbackstuffs.py</div>
                </div>
                <div class="column column_space"><pre><code>18          text = (
19              f"`Downloading: {k['filename']}\n"
20              + f"Total Size: {humanbytes(k['total_bytes'])}\n"
21              + f"Downloaded: {humanbytes(k['downloaded_bytes'])}\n"
22              + f"Speed: {humanbytes(k['speed'])}/s\n"
23              + f"ETA: {time_formatter(k['eta']*1000)}`"
24          )
</pre></code></div>
                <div class="column column_space"><pre><code>425      msg = (
426          "Send your FOLDER ID\n\n"
427          + "For FOLDER ID:\n"
428          + "1. Open Google Drive App.\n"
429          + "2. Create Folder.\n"
430          + "3. Make that folder public.\n"
431          + "4. Send link of that folder."
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    