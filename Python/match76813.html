<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_bower_1.py &amp; joyent.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_bower_1.py &amp; joyent.py
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_bower_1.py (25.925926%)<th>joyent.py (2.3045268%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(66-72)<td><a href="#" name="0">(359-363)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(22-28)<td><a href="#" name="1">(1168-1172)</a><td align="center"><font color="#dd0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_bower_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import pytest
import salt.utils.json
import salt.utils.path
from tests.support.case import ModuleCase
from tests.support.mixins import SaltReturnAssertsMixin
from tests.support.unit import skipIf
@skipIf(salt.utils.path.which("bower") is None, "bower not installed")
class BowerStateTest(ModuleCase, SaltReturnAssertsMixin):
    @pytest.mark.destructive_test
    @pytest.mark.slow_test
    def test_bower_installed_removed(self):
        ret = self.run_state("file.directory", name="/salt_test_bower_1", makedirs<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=True)
        self.assertSaltTrueReturn(ret)
        ret = self.run_state(
            "bower.installed", name="underscore", dir="/salt_test_bower_1"
        )
        self.assertSaltTrueReturn(ret)
        ret = self.run_state(</b></font>
            "bower.removed", name="underscore", dir="/salt_test_bower_1"
        )
        self.assertSaltTrueReturn(ret)
        ret = self.run_state("file.absent", name="/salt_test_bower_1")
        self.assertSaltTrueReturn(ret)
    @pytest.mark.destructive_test
    @pytest.mark.slow_test
    def test_bower_installed_pkgs(self):
        ret = self.run_state("file.directory", name="/salt_test_bower_2", makedirs=True)
        self.assertSaltTrueReturn(ret)
        ret = self.run_state(
            "bower.installed",
            name="test",
            dir="/salt_test_bower_2",
            pkgs=["numeral", "underscore"],
        )
        self.assertSaltTrueReturn(ret)
        ret = self.run_state("file.absent", name="/salt_test_bower_2")
        self.assertSaltTrueReturn(ret)
    @pytest.mark.destructive_test
    @pytest.mark.slow_test
    def test_bower_installed_from_file(self):
        ret = self.run_state("file.directory", name="/salt_test_bower_3", makedirs=True)
        self.assertSaltTrueReturn(ret)
        bower_json = salt.utils.json.dumps(
            {
                "name": "salt_test_bower_3",
                "dependencies": {"numeral": "~1.5.3", "underscore": "~1.7.0"},
<a name="0"></a>            }
        )
        ret = self.run_state(
            "file.managed", name="/salt_test_bower_3/bower.json", contents<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=bower_json
        )
        self.assertSaltTrueReturn(ret)
        ret = self.run_state("bower.bootstrap", name="/salt_test_bower_3")
        self.assertSaltTrueReturn(ret)
        ret = self.run_state("file.absent", name="/salt_test_bower_3")
        self.assertSaltTrueReturn(</b></font>ret)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>joyent.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import base64
import datetime
import http.client
import inspect
import logging
import os
import pprint
import salt.config as config
import salt.utils.cloud
import salt.utils.files
import salt.utils.http
import salt.utils.json
import salt.utils.yaml
from salt.exceptions import (
    SaltCloudExecutionFailure,
    SaltCloudExecutionTimeout,
    SaltCloudNotFound,
    SaltCloudSystemExit,
)
try:
    from M2Crypto import EVP
    HAS_REQUIRED_CRYPTO = True
    HAS_M2 = True
except ImportError:
    HAS_M2 = False
    try:
        from Cryptodome.Hash import SHA256
        from Cryptodome.Signature import PKCS1_v1_5
        HAS_REQUIRED_CRYPTO = True
    except ImportError:
        try:
            from Crypto.Hash import SHA256  # nosec
            from Crypto.Signature import PKCS1_v1_5  # nosec
            HAS_REQUIRED_CRYPTO = True
        except ImportError:
            HAS_REQUIRED_CRYPTO = False
log = logging.getLogger(__name__)
__virtualname__ = "joyent"
JOYENT_API_HOST_SUFFIX = ".api.joyentcloud.com"
JOYENT_API_VERSION = "~7.2"
JOYENT_LOCATIONS = {
    "us-east-1": "North Virginia, USA",
    "us-west-1": "Bay Area, California, USA",
    "us-sw-1": "Las Vegas, Nevada, USA",
    "eu-ams-1": "Amsterdam, Netherlands",
}
DEFAULT_LOCATION = "us-east-1"
POLL_ALL_LOCATIONS = True
VALID_RESPONSE_CODES = [
    http.client.OK,
    http.client.ACCEPTED,
    http.client.CREATED,
    http.client.NO_CONTENT,
]
def __virtual__():
    if HAS_REQUIRED_CRYPTO is False:
        return False, "Either PyCrypto or Cryptodome needs to be installed."
    if get_configured_provider() is False:
        return False
    return __virtualname__
def _get_active_provider_name():
    try:
        return __active_provider_name__.value()
    except AttributeError:
        return __active_provider_name__
def get_configured_provider():
    return config.is_provider_configured(
        __opts__, _get_active_provider_name() or __virtualname__, ("user", "password")
    )
def get_image(vm_):
    images = avail_images()
    vm_image = config.get_cloud_config_value("image", vm_, __opts__)
    if vm_image and str(vm_image) in images:
        images[vm_image]["name"] = images[vm_image]["id"]
        return images[vm_image]
    raise SaltCloudNotFound(
        "The specified image, '{}', could not be found.".format(vm_image)
    )
def get_size(vm_):
    sizes = avail_sizes()
    vm_size = config.get_cloud_config_value("size", vm_, __opts__)
    if not vm_size:
        raise SaltCloudNotFound("No size specified for this VM.")
    if vm_size and str(vm_size) in sizes:
        return sizes[vm_size]
    raise SaltCloudNotFound(
        "The specified size, '{}', could not be found.".format(vm_size)
    )
def query_instance(vm_=None, call=None):
    if isinstance(vm_, str) and call == "action":
        vm_ = {"name": vm_, "provider": "joyent"}
    if call == "function":
        raise SaltCloudSystemExit(
            "The query_instance action must be called with -a or --action."
        )
    __utils__["cloud.fire_event"](
        "event",
        "querying instance",
        "salt/cloud/{}/querying".format(vm_["name"]),
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    def _query_ip_address():
        data = show_instance(vm_["name"], call="action")
        if not data:
            log.error("There was an error while querying Joyent. Empty response")
            return False
        if isinstance(data, dict) and "error" in data:
            log.warning("There was an error in the query %s", data.get("error"))
            return False
        log.debug("Returned query data: %s", data)
        if "primaryIp" in data[1]:
            if data[1]["state"] == "running":
                return data[1]["primaryIp"]
        return None
    try:
        data = salt.utils.cloud.wait_for_ip(
            _query_ip_address,
            timeout=config.get_cloud_config_value(
                "wait_for_ip_timeout", vm_, __opts__, default=10 * 60
            ),
            interval=config.get_cloud_config_value(
                "wait_for_ip_interval", vm_, __opts__, default=10
            ),
            interval_multiplier=config.get_cloud_config_value(
                "wait_for_ip_interval_multiplier", vm_, __opts__, default=1
            ),
        )
    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
        try:
            pass
        except SaltCloudSystemExit:
            pass
        finally:
            raise SaltCloudSystemExit(str(exc))
    return data
def create(vm_):
    try:
        if (
            vm_["profile"]
            and config.is_profile_configured(
                __opts__,
                _get_active_provider_name() or "joyent",
                vm_["profile"],
                vm_=vm_,
            )
            is False
        ):
            return False
    except AttributeError:
        pass
    key_filename = config.get_cloud_config_value(
        "private_key", vm_, __opts__, search_global=False, default=None
    )
    __utils__["cloud.fire_event"](
        "event",
        "starting create",
        "salt/cloud/{}/creating".format(vm_["name"]),
        args=__utils__["cloud.filter_event"](
            "creating", vm_, ["name", "profile", "provider", "driver"]
        ),
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    log.info(
        "Creating Cloud VM %s in %s", vm_["name"], vm_.get("location", DEFAULT_LOCATION)
    )
    salt.utils.cloud.check_name(vm_["name"], "a-zA-Z0-9-.")
    kwargs = {
        "name": vm_["name"],
        "image": get_image(vm_),
        "size": get_size(vm_),
        "location": vm_.get("location", DEFAULT_LOCATION),
    }
    if "networks" in vm_:
        kwargs["networks"] = vm_.get("networks")
    __utils__["cloud.fire_event"](
        "event",
        "requesting instance",
        "salt/cloud/{}/requesting".format(vm_["name"]),
        args={
            "kwargs": __utils__["cloud.filter_event"](
                "requesting", kwargs, list(kwargs)
            ),
        },
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    data = create_node(**kwargs)
    if data == {}:
        log.error("Error creating %s on JOYENT", vm_["name"])
        return False
    query_instance(vm_)
    data = show_instance(vm_["name"], call="action")
    vm_["key_filename"] = key_filename
    vm_["ssh_host"] = data[1]["primaryIp"]
    __utils__["cloud.bootstrap"](vm_, __opts__)
    __utils__["cloud.fire_event"](
        "event",
        "created instance",
        "salt/cloud/{}/created".format(vm_["name"]),
        args=__utils__["cloud.filter_event"](
            "created", vm_, ["name", "profile", "provider", "driver"]
        ),
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    return data[1]
def create_node(**kwargs):
    name = kwargs["name"]
<a name="0"></a>    size = kwargs["size"]
    image = kwargs["image"]
    location = kwargs["location"]
    networks <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= kwargs.get("networks")
    tag = kwargs.get("tag")
    locality = kwargs.get("locality")
    metadata = kwargs.get("metadata")
    firewall_enabled = kwargs.get(</b></font>"firewall_enabled")
    create_data = {
        "name": name,
        "package": size["name"],
        "image": image["name"],
    }
    if networks is not None:
        create_data["networks"] = networks
    if locality is not None:
        create_data["locality"] = locality
    if metadata is not None:
        for key, value in metadata.items():
            create_data["metadata.{}".format(key)] = value
    if tag is not None:
        for key, value in tag.items():
            create_data["tag.{}".format(key)] = value
    if firewall_enabled is not None:
        create_data["firewall_enabled"] = firewall_enabled
    data = salt.utils.json.dumps(create_data)
    ret = query(command="my/machines", data=data, method="POST", location=location)
    if ret[0] in VALID_RESPONSE_CODES:
        return ret[1]
    else:
        log.error("Failed to create node %s: %s", name, ret[1])
    return {}
def destroy(name, call=None):
    if call == "function":
        raise SaltCloudSystemExit(
            "The destroy action must be called with -d, --destroy, -a or --action."
        )
    __utils__["cloud.fire_event"](
        "event",
        "destroying instance",
        "salt/cloud/{}/destroying".format(name),
        args={"name": name},
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    node = get_node(name)
    ret = query(
        command="my/machines/{}".format(node["id"]),
        location=node["location"],
        method="DELETE",
    )
    __utils__["cloud.fire_event"](
        "event",
        "destroyed instance",
        "salt/cloud/{}/destroyed".format(name),
        args={"name": name},
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    if __opts__.get("update_cachedir", False) is True:
        __utils__["cloud.delete_minion_cachedir"](
            name, _get_active_provider_name().split(":")[0], __opts__
        )
    return ret[0] in VALID_RESPONSE_CODES
def reboot(name, call=None):
    node = get_node(name)
    ret = take_action(
        name=name,
        call=call,
        method="POST",
        command="my/machines/{}".format(node["id"]),
        location=node["location"],
        data={"action": "reboot"},
    )
    return ret[0] in VALID_RESPONSE_CODES
def stop(name, call=None):
    node = get_node(name)
    ret = take_action(
        name=name,
        call=call,
        method="POST",
        command="my/machines/{}".format(node["id"]),
        location=node["location"],
        data={"action": "stop"},
    )
    return ret[0] in VALID_RESPONSE_CODES
def start(name, call=None):
    node = get_node(name)
    ret = take_action(
        name=name,
        call=call,
        method="POST",
        command="my/machines/{}".format(node["id"]),
        location=node["location"],
        data={"action": "start"},
    )
    return ret[0] in VALID_RESPONSE_CODES
def take_action(
    name=None,
    call=None,
    command=None,
    data=None,
    method="GET",
    location=DEFAULT_LOCATION,
):
    caller = inspect.stack()[1][3]
    if call != "action":
        raise SaltCloudSystemExit("This action must be called with -a or --action.")
    if data:
        data = salt.utils.json.dumps(data)
    ret = []
    try:
        ret = query(command=command, data=data, method=method, location=location)
        log.info("Success %s for node %s", caller, name)
    except Exception as exc:  # pylint: disable=broad-except
        if "InvalidState" in str(exc):
            ret = [200, {}]
        else:
            log.error(
                "Failed to invoke %s node %s: %s",
                caller,
                name,
                exc,
                exc_info_on_loglevel=logging.DEBUG,
            )
            ret = [100, {}]
    return ret
def ssh_interface(vm_):
    return config.get_cloud_config_value(
        "ssh_interface", vm_, __opts__, default="public_ips", search_global=False
    )
def get_location(vm_=None):
    return __opts__.get(
        "location",
        config.get_cloud_config_value(
            "location",
            vm_ or get_configured_provider(),
            __opts__,
            default=DEFAULT_LOCATION,
            search_global=False,
        ),
    )
def avail_locations(call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The avail_locations function must be called with "
            "-f or --function, or with the --list-locations option"
        )
    ret = {}
    for key in JOYENT_LOCATIONS:
        ret[key] = {"name": key, "region": JOYENT_LOCATIONS[key]}
    return ret
def has_method(obj, method_name):
    if method_name in dir(obj):
        return True
    log.error("Method '%s' not yet supported!", method_name)
    return False
def key_list(items=None):
    if items is None:
        items = []
    ret = {}
    if items and isinstance(items, list):
        for item in items:
            if "name" in item:
                if "id" not in item:
                    item["id"] = item["name"]
                ret[item["name"]] = item
    return ret
def get_node(name):
    nodes = list_nodes()
    if name in nodes:
        return nodes[name]
    return None
def show_instance(name, call=None):
    node = get_node(name)
    ret = query(
        command="my/machines/{}".format(node["id"]),
        location=node["location"],
        method="GET",
    )
    return ret
def _old_libcloud_node_state(id_):
    states_int = {
        0: "RUNNING",
        1: "REBOOTING",
        2: "TERMINATED",
        3: "PENDING",
        4: "UNKNOWN",
        5: "STOPPED",
        6: "SUSPENDED",
        7: "ERROR",
        8: "PAUSED",
    }
    states_str = {
        "running": "RUNNING",
        "rebooting": "REBOOTING",
        "starting": "STARTING",
        "terminated": "TERMINATED",
        "pending": "PENDING",
        "unknown": "UNKNOWN",
        "stopping": "STOPPING",
        "stopped": "STOPPED",
        "suspended": "SUSPENDED",
        "error": "ERROR",
        "paused": "PAUSED",
        "reconfiguring": "RECONFIGURING",
    }
    return states_str[id_] if isinstance(id_, str) else states_int[id_]
def joyent_node_state(id_):
    states = {
        "running": 0,
        "stopped": 2,
        "stopping": 2,
        "provisioning": 3,
        "deleted": 2,
        "unknown": 4,
    }
    if id_ not in states:
        id_ = "unknown"
    return _old_libcloud_node_state(states[id_])
def reformat_node(item=None, full=False):
    desired_keys = [
        "id",
        "name",
        "state",
        "public_ips",
        "private_ips",
        "size",
        "image",
        "location",
    ]
    item["private_ips"] = []
    item["public_ips"] = []
    if "ips" in item:
        for ip in item["ips"]:
            if salt.utils.cloud.is_public_ip(ip):
                item["public_ips"].append(ip)
            else:
                item["private_ips"].append(ip)
    for key in desired_keys:
        if key not in item:
            item[key] = None
    to_del = []
    if not full:
        for key in item.keys():  # iterate over a copy of the keys
            if key not in desired_keys:
                to_del.append(key)
    for key in to_del:
        del item[key]
    if "state" in item:
        item["state"] = joyent_node_state(item["state"])
    return item
def list_nodes(full=False, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_nodes function must be called with -f or --function."
        )
    ret = {}
    if POLL_ALL_LOCATIONS:
        for location in JOYENT_LOCATIONS:
            result = query(command="my/machines", location=location, method="GET")
            if result[0] in VALID_RESPONSE_CODES:
                nodes = result[1]
                for node in nodes:
                    if "name" in node:
                        node["location"] = location
                        ret[node["name"]] = reformat_node(item=node, full=full)
            else:
                log.error("Invalid response when listing Joyent nodes: %s", result[1])
    else:
        location = get_location()
        result = query(command="my/machines", location=location, method="GET")
        nodes = result[1]
        for node in nodes:
            if "name" in node:
                node["location"] = location
                ret[node["name"]] = reformat_node(item=node, full=full)
    return ret
def list_nodes_full(call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_nodes_full function must be called with -f or --function."
        )
    return list_nodes(full=True)
def list_nodes_select(call=None):
    return salt.utils.cloud.list_nodes_select(
        list_nodes_full("function"),
        __opts__["query.selection"],
        call,
    )
def _get_proto():
    use_ssl = config.get_cloud_config_value(
        "use_ssl",
        get_configured_provider(),
        __opts__,
        search_global=False,
        default=True,
    )
    if use_ssl is True:
        return "https"
    return "http"
def avail_images(call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The avail_images function must be called with "
            "-f or --function, or with the --list-images option"
        )
    user = config.get_cloud_config_value(
        "user", get_configured_provider(), __opts__, search_global=False
    )
    img_url = config.get_cloud_config_value(
        "image_url",
        get_configured_provider(),
        __opts__,
        search_global=False,
        default="{}{}/{}/images".format(DEFAULT_LOCATION, JOYENT_API_HOST_SUFFIX, user),
    )
    if not img_url.startswith("http://") and not img_url.startswith("https://"):
        img_url = "{}://{}".format(_get_proto(), img_url)
    rcode, data = query(command="my/images", method="GET")
    log.debug(data)
    ret = {}
    for image in data:
        ret[image["name"]] = image
    return ret
def avail_sizes(call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The avail_sizes function must be called with "
            "-f or --function, or with the --list-sizes option"
        )
    rcode, items = query(command="my/packages")
    if rcode not in VALID_RESPONSE_CODES:
        return {}
    return key_list(items=items)
def list_keys(kwargs=None, call=None):
    if call != "function":
        log.error("The list_keys function must be called with -f or --function.")
        return False
    if not kwargs:
        kwargs = {}
    ret = {}
    rcode, data = query(command="my/keys", method="GET")
    for pair in data:
        ret[pair["name"]] = pair["key"]
    return {"keys": ret}
def show_key(kwargs=None, call=None):
    if call != "function":
        log.error("The list_keys function must be called with -f or --function.")
        return False
    if not kwargs:
        kwargs = {}
    if "keyname" not in kwargs:
        log.error("A keyname is required.")
        return False
    rcode, data = query(
        command="my/keys/{}".format(kwargs["keyname"]),
        method="GET",
    )
    return {"keys": {data["name"]: data["key"]}}
def import_key(kwargs=None, call=None):
    if call != "function":
        log.error("The import_key function must be called with -f or --function.")
        return False
    if not kwargs:
        kwargs = {}
    if "keyname" not in kwargs:
        log.error("A keyname is required.")
        return False
    if "keyfile" not in kwargs:
        log.error("The location of the SSH keyfile is required.")
        return False
    if not os.path.isfile(kwargs["keyfile"]):
        log.error("The specified keyfile (%s) does not exist.", kwargs["keyfile"])
        return False
    with salt.utils.files.fopen(kwargs["keyfile"], "r") as fp_:
        kwargs["key"] = salt.utils.stringutils.to_unicode(fp_.read())
    send_data = {"name": kwargs["keyname"], "key": kwargs["key"]}
    kwargs["data"] = salt.utils.json.dumps(send_data)
    rcode, data = query(
        command="my/keys",
        method="POST",
        data=kwargs["data"],
    )
    log.debug(pprint.pformat(data))
    return {"keys": {data["name"]: data["key"]}}
def delete_key(kwargs=None, call=None):
    if call != "function":
        log.error("The delete_keys function must be called with -f or --function.")
        return False
    if not kwargs:
        kwargs = {}
    if "keyname" not in kwargs:
        log.error("A keyname is required.")
        return False
    rcode, data = query(
        command="my/keys/{}".format(kwargs["keyname"]),
        method="DELETE",
    )
    return data
def get_location_path(
    location=DEFAULT_LOCATION, api_host_suffix=JOYENT_API_HOST_SUFFIX
):
    return "{}://{}{}".format(_get_proto(), location, api_host_suffix)
def query(action=None, command=None, args=None, method="GET", location=None, data=None):
    user = config.get_cloud_config_value(
        "user", get_configured_provider(), __opts__, search_global=False
    )
    if not user:
        log.error(
            "username is required for Joyent API requests. Please set one in your"
            " provider configuration"
        )
    password = config.get_cloud_config_value(
        "password", get_configured_provider(), __opts__, search_global=False
    )
    verify_ssl = config.get_cloud_config_value(
        "verify_ssl",
        get_configured_provider(),
        __opts__,
        search_global=False,
        default=True,
    )
    ssh_keyfile = config.get_cloud_config_value(
        "private_key",
        get_configured_provider(),
        __opts__,
        search_global=False,
        default=True,
    )
    if not ssh_keyfile:
        log.error(
            "ssh_keyfile is required for Joyent API requests.  Please set one in your"
            " provider configuration"
        )
    ssh_keyname = config.get_cloud_config_value(
        "keyname",
        get_configured_provider(),
        __opts__,
        search_global=False,
        default=True,
    )
    if not ssh_keyname:
        log.error(
            "ssh_keyname is required for Joyent API requests.  Please set one in your"
            " provider configuration"
        )
    if not location:
        location = get_location()
    api_host_suffix = config.get_cloud_config_value(
        "api_host_suffix",
        get_configured_provider(),
        __opts__,
        search_global=False,
        default=JOYENT_API_HOST_SUFFIX,
    )
    path = get_location_path(location=location, api_host_suffix=api_host_suffix)
    if action:
        path += action
    if command:
        path += "/{}".format(command)
    log.debug("User: '%s' on PATH: %s", user, path)
    if (not user) or (not ssh_keyfile) or (not ssh_keyname) or (not location):
        return None
    timenow = datetime.datetime.utcnow()
    timestamp = timenow.strftime("%a, %d %b %Y %H:%M:%S %Z").strip()
    rsa_key = salt.crypt.get_rsa_key(ssh_keyfile, None)
<a name="1"></a>    if HAS_M2:
        md = EVP.MessageDigest("sha256")
        md.update(timestamp.encode(__salt_system_encoding__))
        digest <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= md.final()
        signed = rsa_key.sign(digest, algo="sha256")
    else:
        rsa_ = PKCS1_v1_5.new(rsa_key)
        hash_ = SHA256.new(</b></font>)
        hash_.update(timestamp.encode(__salt_system_encoding__))
        signed = rsa_.sign(hash_)
    signed = base64.b64encode(signed)
    user_arr = user.split("/")
    if len(user_arr) == 1:
        keyid = "/{}/keys/{}".format(user_arr[0], ssh_keyname)
    elif len(user_arr) == 2:
        keyid = "/{}/users/{}/keys/{}".format(user_arr[0], user_arr[1], ssh_keyname)
    else:
        log.error("Malformed user string")
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "X-Api-Version": JOYENT_API_VERSION,
        "Date": timestamp,
        "Authorization": 'Signature keyId="{}",algorithm="rsa-sha256" {}'.format(
            keyid, signed.decode(__salt_system_encoding__)
        ),
    }
    if not isinstance(args, dict):
        args = {}
    if not data:
        data = salt.utils.json.dumps({})
    return_content = None
    result = salt.utils.http.query(
        path,
        method,
        params=args,
        header_dict=headers,
        data=data,
        decode=False,
        text=True,
        status=True,
        headers=True,
        verify_ssl=verify_ssl,
        opts=__opts__,
    )
    log.debug("Joyent Response Status Code: %s", result["status"])
    if "headers" not in result:
        return [result["status"], result["error"]]
    if "Content-Length" in result["headers"]:
        content = result["text"]
        return_content = salt.utils.yaml.safe_load(content)
    return [result["status"], return_content]
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
