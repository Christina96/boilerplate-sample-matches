<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto3_elasticsearch.py &amp; ioloop_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto3_elasticsearch.py &amp; ioloop_test.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto3_elasticsearch.py (2.108963%)<th>ioloop_test.py (1.8447348%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(197-204)<td><a href="#" name="0">(551-554)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(6-19)<td><a href="#" name="1">(11-24)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto3_elasticsearch.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import datetime
2 import random
3 import string
4 import textwrap
5 import salt.loader
6 import salt.modules.boto3_elasticsearch as boto3_elasticsearch
7 from salt.utils.versions import LooseVersion
8 from tests.support.mixins import LoaderModuleMockMixin
9 from tests.support.mock import MagicMock, patch
10 from tests.support.unit import TestCase, skipIf
11 try:
12     import</b></font> boto3
13     from botocore.exceptions import ClientError
14     HAS_BOTO3 = True
15 except ImportError:
16     HAS_BOTO3 = False
17 REQUIRED_BOTO3_VERSION = "1.2.1"
18 def __virtual__():
19     if not HAS_BOTO3:
20         return False
21     if LooseVersion(boto3.__version__) &lt; LooseVersion(REQUIRED_BOTO3_VERSION):
22         return (
23             False,
24             "The boto3 module must be greater or equal to version {}".format(
25                 REQUIRED_BOTO3_VERSION
26             ),
27         )
28     return True
29 REGION = "us-east-1"
30 ACCESS_KEY = "GKTADJGHEIQSXMKKRBJ08H"
31 SECRET_KEY = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
32 CONN_PARAMETERS = {
33     "region": REGION,
34     "key": ACCESS_KEY,
35     "keyid": SECRET_KEY,
36     "profile": {},
37 }
38 ERROR_MESSAGE = (
39     "An error occurred ({}) when calling the {} operation: Test-defined error"
40 )
41 ERROR_CONTENT = {"Error": {"Code": 101, "Message": "Test-defined error"}}
42 NOT_FOUND_ERROR = ClientError(
43     {"Error": {"Code": "ResourceNotFoundException", "Message": "Test-defined error"}},
44     "msg",
45 )
46 DOMAIN_RET = {
47     "DomainId": "accountno/testdomain",
48     "DomainName": "testdomain",
49     "ARN": "arn:aws:es:region:accountno:domain/testdomain",
50     "Created": True,
51     "Deleted": False,
52     "Endpoints": {"vpc": "vpc-testdomain-1234567890.region.es.amazonaws.com"},
53     "Processing": False,
54     "UpgradeProcessing": False,
55     "ElasticsearchVersion": "6.3",
56     "ElasticsearchClusterConfig": {
57         "InstanceType": "t2.medium.elasticsearch",
58         "InstanceCount": 1,
59         "DedicatedMasterEnabled": False,
60         "ZoneAwarenessEnabled": False,
61     },
62     "EBSOptions": {
63         "EBSEnabled": True,
64         "VolumeType": "gp2",
65         "VolumeSize": 123,
66         "Iops": 12,
67     },
68     "AccessPolicies": textwrap.dedent(
69     TestCase for salt.modules.boto3_elasticsearch module
70         Test that when describing a domain when the domain actually exists,
71         the .exists method returns a dict with 'result': True
72         and 'response' with the domain status information.
73         Test that when describing a domain when the domain does not exist,
74         the .exists method returns a dict with 'result': False
75         and 'error' with boto's ResourceNotFoundException.
76             result = boto3_elasticsearch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.describe_elasticsearch_domain(
77                 domain_name="testdomain", **CONN_PARAMETERS
78             )
79             self.assertEqual(
80                 result.get("error", ""),
81                 ERROR_MESSAGE.format("ResourceNotFoundException", "msg"),
82             )
83             self.assertFalse(result[</b></font>"result"])
84     def test_create_elasticsearch_domain_positive(self):
85         with patch.object(
86             self.conn,
87             "create_elasticsearch_domain",
88             return_value={"DomainStatus": DOMAIN_RET},
89         ):
90             kwargs = {
91                 "elasticsearch_version": DOMAIN_RET["ElasticsearchVersion"],
92                 "elasticsearch_cluster_config": DOMAIN_RET[
93                     "ElasticsearchClusterConfig"
94                 ],
95                 "ebs_options": DOMAIN_RET["EBSOptions"],
96                 "access_policies": DOMAIN_RET["AccessPolicies"],
97                 "snapshot_options": DOMAIN_RET["SnapshotOptions"],
98                 "vpc_options": DOMAIN_RET["VPCOptions"],
99                 "cognito_options": DOMAIN_RET["CognitoOptions"],
100                 "encryption_at_rest_options": DOMAIN_RET["EncryptionAtRestOptions"],
101                 "advanced_options": DOMAIN_RET["AdvancedOptions"],
102             }
103             kwargs.update(CONN_PARAMETERS)
104             self.assertEqual(
105                 boto3_elasticsearch.create_elasticsearch_domain(
106                     domain_name="testdomain", **kwargs
107                 ),
108                 {"result": True, "response": DOMAIN_RET},
109             )
110     def test_create_elasticsearch_domain_error(self):
111         with patch.object(
112             self.conn,
113             "create_elasticsearch_domain",
114             side_effect=ClientError(ERROR_CONTENT, "create_domain"),
115         ):
116             kwargs = {
117                 "elasticsearch_version": DOMAIN_RET["ElasticsearchVersion"],
118                 "elasticsearch_cluster_config": DOMAIN_RET[
119                     "ElasticsearchClusterConfig"
120                 ],
121                 "ebs_options": DOMAIN_RET["EBSOptions"],
122                 "access_policies": DOMAIN_RET["AccessPolicies"],
123                 "snapshot_options": DOMAIN_RET["SnapshotOptions"],
124                 "vpc_options": DOMAIN_RET["VPCOptions"],
125                 "cognito_options": DOMAIN_RET["CognitoOptions"],
126                 "encryption_at_rest_options": DOMAIN_RET["EncryptionAtRestOptions"],
127                 "advanced_options": DOMAIN_RET["AdvancedOptions"],
128             }
129             kwargs.update(CONN_PARAMETERS)
130             result = boto3_elasticsearch.create_elasticsearch_domain(
131                 "testdomain", **kwargs
132             )
133             self.assertEqual(
134                 result.get("error", ""), ERROR_MESSAGE.format(101, "create_domain")
135             )
136     def test_delete_domain_positive(self):
137         with patch.object(self.conn, "delete_elasticsearch_domain"):
138             self.assertEqual(
139                 boto3_elasticsearch.delete_elasticsearch_domain(
140                     "testdomain", **CONN_PARAMETERS
141                 ),
142                 {"result": True},
143             )
144     def test_delete_domain_error(self):
145         with patch.object(
146             self.conn,
147             "delete_elasticsearch_domain",
148             side_effect=ClientError(ERROR_CONTENT, "delete_domain"),
149         ):
150             result = boto3_elasticsearch.delete_elasticsearch_domain(
151                 "testdomain", **CONN_PARAMETERS
152             )
153             self.assertFalse(result["result"])
154             self.assertEqual(
155                 result.get("error", ""), ERROR_MESSAGE.format(101, "delete_domain")
156             )
157     def test_update_domain_positive(self):
158         with patch.object(
159             self.conn,
160             "update_elasticsearch_domain_config",
161             return_value={"DomainConfig": DOMAIN_RET},
162         ):
163             kwargs = {
164                 "elasticsearch_cluster_config": DOMAIN_RET[
165                     "ElasticsearchClusterConfig"
166                 ],
167                 "ebs_options": DOMAIN_RET["EBSOptions"],
168                 "snapshot_options": DOMAIN_RET["SnapshotOptions"],
169                 "vpc_options": DOMAIN_RET["VPCOptions"],
170                 "cognito_options": DOMAIN_RET["CognitoOptions"],
171                 "advanced_options": DOMAIN_RET["AdvancedOptions"],
172                 "access_policies": DOMAIN_RET["AccessPolicies"],
173                 "log_publishing_options": {},
174             }
175             kwargs.update(CONN_PARAMETERS)
176             self.assertEqual(
177                 boto3_elasticsearch.update_elasticsearch_domain_config(
178                     "testdomain", **kwargs
179                 ),
180                 {"result": True, "response": DOMAIN_RET},
181             )
182     def test_update_domain_error(self):
183         with patch.object(
184             self.conn,
185             "update_elasticsearch_domain_config",
186             side_effect=ClientError(ERROR_CONTENT, "update_domain"),
187         ):
188             kwargs = {
189                 "elasticsearch_cluster_config": DOMAIN_RET[
190                     "ElasticsearchClusterConfig"
191                 ],
192                 "ebs_options": DOMAIN_RET["EBSOptions"],
193                 "snapshot_options": DOMAIN_RET["SnapshotOptions"],
194                 "vpc_options": DOMAIN_RET["VPCOptions"],
195                 "cognito_options": DOMAIN_RET["CognitoOptions"],
196                 "advanced_options": DOMAIN_RET["AdvancedOptions"],
197                 "access_policies": DOMAIN_RET["AccessPolicies"],
198                 "log_publishing_options": {},
199             }
200             kwargs.update(CONN_PARAMETERS)
201             result = boto3_elasticsearch.update_elasticsearch_domain_config(
202                 "testdomain", **kwargs
203             )
204             self.assertEqual(
205                 result.get("error", ""), ERROR_MESSAGE.format(101, "update_domain")
206             )
207     def test_add_tags_positive(self):
208         with patch.object(
209             self.conn,
210             "describe_elasticsearch_domain",
211             return_value={"DomainStatus": DOMAIN_RET},
212         ):
213             self.assertEqual(
214                 boto3_elasticsearch.add_tags(
215                     "testdomain", tags={"foo": "bar", "baz": "qux"}, **CONN_PARAMETERS
216                 ),
217                 {"result": True},
218             )
219     def test_add_tags_default(self):
220         with patch.object(
221             self.conn,
222             "describe_elasticsearch_domain",
223             return_value={"DomainStatus": DOMAIN_RET},
224         ):
225             self.assertEqual(
226                 boto3_elasticsearch.add_tags("testdomain", **CONN_PARAMETERS),
227                 {"result": True},
228             )
229     def test_add_tags_error(self):
230         with patch.object(
231             self.conn, "add_tags", side_effect=ClientError(ERROR_CONTENT, "add_tags")
232         ), patch.object(
233             self.conn,
234             "describe_elasticsearch_domain",
235             return_value={"DomainStatus": DOMAIN_RET},
236         ):
237             result = boto3_elasticsearch.add_tags(
238                 "testdomain", tags={"foo": "bar", "baz": "qux"}, **CONN_PARAMETERS
239             )
240             self.assertFalse(result["result"])
241             self.assertEqual(
242                 result.get("error", ""), ERROR_MESSAGE.format(101, "add_tags")
243             )
244     def test_remove_tags_positive(self):
245         with patch.object(
246             self.conn,
247             "describe_elasticsearch_domain",
248             return_value={"DomainStatus": DOMAIN_RET},
249         ):
250             self.assertEqual(
251                 boto3_elasticsearch.remove_tags(
252                     tag_keys=["foo", "bar"], domain_name="testdomain", **CONN_PARAMETERS
253                 ),
254                 {"result": True},
255             )
256     def test_remove_tag_error(self):
257         with patch.object(
258             self.conn,
259             "remove_tags",
260             side_effect=ClientError(ERROR_CONTENT, "remove_tags"),
261         ), patch.object(
262             self.conn,
263             "describe_elasticsearch_domain",
264             return_value={"DomainStatus": DOMAIN_RET},
265         ):
266             result = boto3_elasticsearch.remove_tags(
267                 tag_keys=["foo", "bar"], domain_name="testdomain", **CONN_PARAMETERS
268             )
269             self.assertFalse(result["result"])
270             self.assertEqual(
271                 result.get("error", ""), ERROR_MESSAGE.format(101, "remove_tags")
272             )
273     def test_list_tags_positive(self):
274         with patch.object(
275             self.conn,
276             "describe_elasticsearch_domain",
277             return_value={"DomainStatus": DOMAIN_RET},
278         ), patch.object(
279             self.conn,
280             "list_tags",
281             return_value={"TagList": [{"Key": "foo", "Value": "bar"}]},
282         ):
283             result = boto3_elasticsearch.list_tags(
284                 domain_name="testdomain", **CONN_PARAMETERS
285             )
286             self.assertEqual(result, {"result": True, "response": {"foo": "bar"}})
287     def test_list_tags_error(self):
288         with patch.object(
289             self.conn, "list_tags", side_effect=ClientError(ERROR_CONTENT, "list_tags")
290         ), patch.object(
291             self.conn,
292             "describe_elasticsearch_domain",
293             return_value={"DomainStatus": DOMAIN_RET},
294         ):
295             result = boto3_elasticsearch.list_tags(
296                 domain_name="testdomain", **CONN_PARAMETERS
297             )
298             self.assertFalse(result["result"])
299             self.assertEqual(
300                 result.get("error", ""), ERROR_MESSAGE.format(101, "list_tags")
301             )
302     def test_cancel_elasticsearch_service_software_update_positive(self):
303         retval = {
304             "ServiceSoftwareOptions": {
305                 "CurrentVersion": "string",
306                 "NewVersion": "string",
307                 "UpdateAvailable": True,
308                 "Cancellable": True,
309                 "UpdateStatus": "ELIGIBLE",
310                 "Description": "string",
311                 "AutomatedUpdateDate": datetime.datetime(2015, 1, 1),
312             }
313         }
314         with patch.object(
315             self.conn,
316             "cancel_elasticsearch_service_software_update",
317             return_value=retval,
318         ):
319             result = boto3_elasticsearch.cancel_elasticsearch_service_software_update(
320                 domain_name="testdomain", **CONN_PARAMETERS
321             )
322             self.assertEqual(result, {"result": True})
323     def test_cancel_elasticsearch_service_software_update_error(self):
324         with patch.object(
325             self.conn,
326             "cancel_elasticsearch_service_software_update",
327             side_effect=ClientError(
328                 ERROR_CONTENT, "cancel_elasticsearch_service_software_update"
329             ),
330         ):
331             result = boto3_elasticsearch.cancel_elasticsearch_service_software_update(
332                 domain_name="testdomain", **CONN_PARAMETERS
333             )
334             self.assertFalse(result["result"])
335             self.assertEqual(
336                 result.get("error", ""),
337                 ERROR_MESSAGE.format(
338                     101, "cancel_elasticsearch_service_software_update"
339                 ),
340             )
341     def test_delete_elasticsearch_service_role_positive(self):
342         with patch.object(
343             self.conn, "delete_elasticsearch_service_role", return_value=None
344         ):
345             result = boto3_elasticsearch.delete_elasticsearch_service_role(
346                 **CONN_PARAMETERS
347             )
348             self.assertEqual(result, {"result": True})
349     def test_delete_elasticsearch_service_role_error(self):
350         with patch.object(
351             self.conn,
352             "delete_elasticsearch_service_role",
353             side_effect=ClientError(ERROR_CONTENT, "delete_elasticsearch_service_role"),
354         ):
355             result = boto3_elasticsearch.delete_elasticsearch_service_role(
356                 **CONN_PARAMETERS
357             )
358             self.assertFalse(result["result"])
359             self.assertEqual(
360                 result.get("error", ""),
361                 ERROR_MESSAGE.format(101, "delete_elasticsearch_service_role"),
362             )
363     def test_describe_elasticsearch_domain_config_positive(self):
364         with patch.object(
365             self.conn,
366             "describe_elasticsearch_domain_config",
367             return_value={"DomainConfig": DOMAIN_RET},
368         ):
369             self.assertEqual(
370                 boto3_elasticsearch.describe_elasticsearch_domain_config(
371                     "testdomain", **CONN_PARAMETERS
372                 ),
373                 {"result": True, "response": DOMAIN_RET},
374             )
375     def test_describe_elasticsearch_domain_config_error(self):
376         with patch.object(
377             self.conn,
378             "describe_elasticsearch_domain_config",
379             side_effect=ClientError(
380                 ERROR_CONTENT, "describe_elasticsearch_domain_config"
381             ),
382         ):
383             result = boto3_elasticsearch.describe_elasticsearch_domain_config(
384                 domain_name="testdomain", **CONN_PARAMETERS
385             )
386             self.assertFalse(result["result"])
387             self.assertEqual(
388                 result.get("error", ""),
389                 ERROR_MESSAGE.format(101, "describe_elasticsearch_domain_config"),
390             )
391     def test_describe_elasticsearch_domains_positive(self):
392         with patch.object(
393             self.conn,
394             "describe_elasticsearch_domains",
395             return_value={"DomainStatusList": [DOMAIN_RET]},
396         ):
397             self.assertEqual(
398                 boto3_elasticsearch.describe_elasticsearch_domains(
399                     domain_names=["test_domain"], **CONN_PARAMETERS
400                 ),
401                 {"result": True, "response": [DOMAIN_RET]},
402             )
403     def test_describe_elasticsearch_domains_error(self):
404         with patch.object(
405             self.conn,
406             "describe_elasticsearch_domains",
407             side_effect=ClientError(ERROR_CONTENT, "describe_elasticsearch_domains"),
408         ):
409             result = boto3_elasticsearch.describe_elasticsearch_domains(
410                 domain_names=["testdomain"], **CONN_PARAMETERS
411             )
412             self.assertFalse(result["result"])
413             self.assertEqual(
414                 result.get("error", ""),
415                 ERROR_MESSAGE.format(101, "describe_elasticsearch_domains"),
416             )
417     def test_describe_elasticsearch_instance_type_limits_positive(self):
418         ret_val = {
419             "LimitsByRole": {
420                 "string": {
421                     "StorageTypes": [
422                         {
423                             "StorageTypeName": "string",
424                             "StorageSubTypeName": "string",
425                             "StorageTypeLimits": [
426                                 {"LimitName": "string", "LimitValues": ["string"]}
427                             ],
428                         }
429                     ],
430                     "InstanceLimits": {
431                         "InstanceCountLimits": {
432                             "MinimumInstanceCount": 123,
433                             "MaximumInstanceCount": 123,
434                         }
435                     },
436                     "AdditionalLimits": [
437                         {"LimitName": "string", "LimitValues": ["string"]}
438                     ],
439                 }
440             }
441         }
442         with patch.object(
443             self.conn,
444             "describe_elasticsearch_instance_type_limits",
445             return_value=ret_val,
446         ):
447             self.assertEqual(
448                 boto3_elasticsearch.describe_elasticsearch_instance_type_limits(
449                     domain_name="testdomain",
450                     instance_type="foo",
451                     elasticsearch_version="1.0",
452                     **CONN_PARAMETERS
453                 ),
454                 {"result": True, "response": ret_val["LimitsByRole"]},
455             )
456     def test_describe_elasticsearch_instance_type_limits_error(self):
457         with patch.object(
458             self.conn,
459             "describe_elasticsearch_instance_type_limits",
460             side_effect=ClientError(
461                 ERROR_CONTENT, "describe_elasticsearch_instance_type_limits"
462             ),
463         ):
464             result = boto3_elasticsearch.describe_elasticsearch_instance_type_limits(
465                 domain_name="testdomain",
466                 instance_type="foo",
467                 elasticsearch_version="1.0",
468                 **CONN_PARAMETERS
469             )
470             self.assertFalse(result["result"])
471             self.assertEqual(
472                 result.get("error", ""),
473                 ERROR_MESSAGE.format(
474                     101, "describe_elasticsearch_instance_type_limits"
475                 ),
476             )
477     def test_describe_reserved_elasticsearch_instance_offerings_positive(self):
478         ret_val = {
479             "NextToken": "string",
480             "ReservedElasticsearchInstanceOfferings": [
481                 {
482                     "ReservedElasticsearchInstanceOfferingId": "string",
483                     "ElasticsearchInstanceType": "t2.medium.elasticsearch",
484                     "Duration": 123,
485                     "FixedPrice": 123.0,
486                     "UsagePrice": 123.0,
487                     "CurrencyCode": "string",
488                     "PaymentOption": "NO_UPFRONT",
489                     "RecurringCharges": [
490                         {
491                             "RecurringChargeAmount": 123.0,
492                             "RecurringChargeFrequency": "string",
493                         }
494                     ],
495                 }
496             ],
497         }
498         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
499             self.assertEqual(
500                 boto3_elasticsearch.describe_reserved_elasticsearch_instance_offerings(
501                     reserved_elasticsearch_instance_offering_id="foo", **CONN_PARAMETERS
502                 ),
503                 {
504                     "result": True,
505                     "response": ret_val["ReservedElasticsearchInstanceOfferings"],
506                 },
507             )
508     def test_describe_reserved_elasticsearch_instance_offerings_error(self):
509         with patch.object(
510             self.paginator,
511             "paginate",
512             side_effect=ClientError(
513                 ERROR_CONTENT, "describe_reserved_elasticsearch_instance_offerings"
514             ),
515         ):
516             result = (
517                 boto3_elasticsearch.describe_reserved_elasticsearch_instance_offerings(
518                     reserved_elasticsearch_instance_offering_id="foo", **CONN_PARAMETERS
519                 )
520             )
521             self.assertFalse(result["result"])
522             self.assertEqual(
523                 result.get("error", ""),
524                 ERROR_MESSAGE.format(
525                     101, "describe_reserved_elasticsearch_instance_offerings"
526                 ),
527             )
528     def test_describe_reserved_elasticsearch_instances_positive(self):
529         ret_val = {
530             "NextToken": "string",
531             "ReservedElasticsearchInstances": [
532                 {
533                     "ReservationName": "string",
534                     "ReservedElasticsearchInstanceId": "string",
535                     "ReservedElasticsearchInstanceOfferingId": "string",
536                     "ElasticsearchInstanceType": "t2.medium.elasticsearch",
537                     "StartTime": datetime.datetime(2015, 1, 1),
538                     "Duration": 123,
539                     "FixedPrice": 123.0,
540                     "UsagePrice": 123.0,
541                     "CurrencyCode": "string",
542                     "ElasticsearchInstanceCount": 123,
543                     "State": "string",
544                     "PaymentOption": "ALL_UPFRONT",
545                     "RecurringCharges": [
546                         {
547                             "RecurringChargeAmount": 123.0,
548                             "RecurringChargeFrequency": "string",
549                         },
550                     ],
551                 },
552             ],
553         }
554         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
555             self.assertEqual(
556                 boto3_elasticsearch.describe_reserved_elasticsearch_instances(
557                     reserved_elasticsearch_instance_id="foo", **CONN_PARAMETERS
558                 ),
559                 {"result": True, "response": ret_val["ReservedElasticsearchInstances"]},
560             )
561     def test_describe_reserved_elasticsearch_instances_error(self):
562         with patch.object(
563             self.paginator,
564             "paginate",
565             side_effect=ClientError(
566                 ERROR_CONTENT, "describe_reserved_elasticsearch_instances"
567             ),
568         ):
569             result = boto3_elasticsearch.describe_reserved_elasticsearch_instances(
570                 reserved_elasticsearch_instance_id="foo", **CONN_PARAMETERS
571             )
572             self.assertFalse(result["result"])
573             self.assertEqual(
574                 result.get("error", ""),
575                 ERROR_MESSAGE.format(101, "describe_reserved_elasticsearch_instances"),
576             )
577     def test_get_compatible_elasticsearch_versions_positive(self):
578         ret_val = {
579             "CompatibleElasticsearchVersions": [
580                 {"SourceVersion": "string", "TargetVersions": ["string"]}
581             ]
582         }
583         with patch.object(
584             self.conn, "get_compatible_elasticsearch_versions", return_value=ret_val
585         ):
586             self.assertEqual(
587                 boto3_elasticsearch.get_compatible_elasticsearch_versions(
588                     domain_name="testdomain", **CONN_PARAMETERS
589                 ),
590                 {
591                     "result": True,
592                     "response": ret_val["CompatibleElasticsearchVersions"],
593                 },
594             )
595     def test_get_compatible_elasticsearch_versions_error(self):
596         with patch.object(
597             self.conn,
598             "get_compatible_elasticsearch_versions",
599             side_effect=ClientError(
600                 ERROR_CONTENT, "get_compatible_elasticsearch_versions"
601             ),
602         ):
603             result = boto3_elasticsearch.get_compatible_elasticsearch_versions(
604                 domain_name="testdomain", **CONN_PARAMETERS
605             )
606             self.assertFalse(result["result"])
607             self.assertEqual(
608                 result.get("error", ""),
609                 ERROR_MESSAGE.format(101, "get_compatible_elasticsearch_versions"),
610             )
611     def test_get_upgrade_history_positive(self):
612         ret_val = {
613             "UpgradeHistories": [
614                 {
615                     "UpgradeName": "string",
616                     "StartTimestamp": datetime.datetime(2015, 1, 1),
617                     "UpgradeStatus": "IN_PROGRESS",
618                     "StepsList": [
619                         {
620                             "UpgradeStep": "PRE_UPGRADE_CHECK",
621                             "UpgradeStepStatus": "IN_PROGRESS",
622                             "Issues": ["string"],
623                             "ProgressPercent": 123.0,
624                         }
625                     ],
626                 }
627             ],
628             "NextToken": "string",
629         }
630         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
631             self.assertEqual(
632                 boto3_elasticsearch.get_upgrade_history(
633                     domain_name="testdomain", **CONN_PARAMETERS
634                 ),
635                 {"result": True, "response": ret_val["UpgradeHistories"]},
636             )
637     def test_get_upgrade_history_error(self):
638         with patch.object(
639             self.paginator,
640             "paginate",
641             side_effect=ClientError(ERROR_CONTENT, "get_upgrade_history"),
642         ):
643             result = boto3_elasticsearch.get_upgrade_history(
644                 domain_name="testdomain", **CONN_PARAMETERS
645             )
646             self.assertFalse(result["result"])
647             self.assertEqual(
648                 result.get("error", ""),
649                 ERROR_MESSAGE.format(101, "get_upgrade_history"),
650             )
651     def test_get_upgrade_status_positive(self):
652         ret_val = {
653             "UpgradeStep": "PRE_UPGRADE_CHECK",
654             "StepStatus": "IN_PROGRESS",
655             "UpgradeName": "string",
656             "ResponseMetadata": None,
657         }
658         with patch.object(self.conn, "get_upgrade_status", return_value=ret_val):
659             self.assertEqual(
660                 boto3_elasticsearch.get_upgrade_status(
661                     domain_name="testdomain", **CONN_PARAMETERS
662                 ),
663                 {"result": True, "response": ret_val},
664             )
665     def test_get_upgrade_status_error(self):
666         with patch.object(
667             self.conn,
668             "get_upgrade_status",
669             side_effect=ClientError(ERROR_CONTENT, "get_upgrade_status"),
670         ):
671             result = boto3_elasticsearch.get_upgrade_status(
672                 domain_name="testdomain", **CONN_PARAMETERS
673             )
674             self.assertFalse(result["result"])
675             self.assertEqual(
676                 result.get("error", ""), ERROR_MESSAGE.format(101, "get_upgrade_status")
677             )
678     def test_list_domain_names_positive(self):
679         ret_val = {"DomainNames": [{"DomainName": "string"}]}
680         with patch.object(self.conn, "list_domain_names", return_value=ret_val):
681             self.assertEqual(
682                 boto3_elasticsearch.list_domain_names(**CONN_PARAMETERS),
683                 {
684                     "result": True,
685                     "response": [item["DomainName"] for item in ret_val["DomainNames"]],
686                 },
687             )
688     def test_list_domain_names_error(self):
689         with patch.object(
690             self.conn,
691             "list_domain_names",
692             side_effect=ClientError(ERROR_CONTENT, "list_domain_names"),
693         ):
694             result = boto3_elasticsearch.list_domain_names(**CONN_PARAMETERS)
695             self.assertFalse(result["result"])
696             self.assertEqual(
697                 result.get("error", ""), ERROR_MESSAGE.format(101, "list_domain_names")
698             )
699     def test_list_elasticsearch_instance_types_positive(self):
700         ret_val = {
701             "ElasticsearchInstanceTypes": [
702                 "m3.medium.elasticsearch",
703                 "m3.large.elasticsearch",
704                 "m3.xlarge.elasticsearch",
705                 "m3.2xlarge.elasticsearch",
706                 "m4.large.elasticsearch",
707                 "m4.xlarge.elasticsearch",
708                 "m4.2xlarge.elasticsearch",
709                 "m4.4xlarge.elasticsearch",
710                 "m4.10xlarge.elasticsearch",
711                 "t2.micro.elasticsearch",
712                 "t2.small.elasticsearch",
713                 "t2.medium.elasticsearch",
714                 "r3.large.elasticsearch",
715                 "r3.xlarge.elasticsearch",
716                 "r3.2xlarge.elasticsearch",
717                 "r3.4xlarge.elasticsearch",
718                 "r3.8xlarge.elasticsearch",
719                 "i2.xlarge.elasticsearch",
720                 "i2.2xlarge.elasticsearch",
721                 "d2.xlarge.elasticsearch",
722                 "d2.2xlarge.elasticsearch",
723                 "d2.4xlarge.elasticsearch",
724                 "d2.8xlarge.elasticsearch",
725                 "c4.large.elasticsearch",
726                 "c4.xlarge.elasticsearch",
727                 "c4.2xlarge.elasticsearch",
728                 "c4.4xlarge.elasticsearch",
729                 "c4.8xlarge.elasticsearch",
730                 "r4.large.elasticsearch",
731                 "r4.xlarge.elasticsearch",
732                 "r4.2xlarge.elasticsearch",
733                 "r4.4xlarge.elasticsearch",
734                 "r4.8xlarge.elasticsearch",
735                 "r4.16xlarge.elasticsearch",
736                 "i3.large.elasticsearch",
737                 "i3.xlarge.elasticsearch",
738                 "i3.2xlarge.elasticsearch",
739                 "i3.4xlarge.elasticsearch",
740                 "i3.8xlarge.elasticsearch",
741                 "i3.16xlarge.elasticsearch",
742             ],
743             "NextToken": "string",
744         }
745         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
746             self.assertEqual(
747                 boto3_elasticsearch.list_elasticsearch_instance_types(
748                     elasticsearch_version="1.0", **CONN_PARAMETERS
749                 ),
750                 {"result": True, "response": ret_val["ElasticsearchInstanceTypes"]},
751             )
752     def test_list_elasticsearch_instance_types_error(self):
753         with patch.object(
754             self.paginator,
755             "paginate",
756             side_effect=ClientError(ERROR_CONTENT, "list_elasticsearch_instance_types"),
757         ):
758             result = boto3_elasticsearch.list_elasticsearch_instance_types(
759                 elasticsearch_version="1.0", **CONN_PARAMETERS
760             )
761             self.assertFalse(result["result"])
762             self.assertEqual(
763                 result.get("error", ""),
764                 ERROR_MESSAGE.format(101, "list_elasticsearch_instance_types"),
765             )
766     def test_list_elasticsearch_versions_positive(self):
767         ret_val = {"ElasticsearchVersions": ["string"], "NextToken": "string"}
768         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
769             self.assertEqual(
770                 boto3_elasticsearch.list_elasticsearch_versions(**CONN_PARAMETERS),
771                 {"result": True, "response": ret_val["ElasticsearchVersions"]},
772             )
773     def test_list_elasticsearch_versions_error(self):
774         with patch.object(
775             self.paginator,
776             "paginate",
777             side_effect=ClientError(ERROR_CONTENT, "list_elasticsearch_versions"),
778         ):
779             result = boto3_elasticsearch.list_elasticsearch_versions(**CONN_PARAMETERS)
780             self.assertFalse(result["result"])
781             self.assertEqual(
782                 result.get("error", ""),
783                 ERROR_MESSAGE.format(101, "list_elasticsearch_versions"),
784             )
785     def test_purchase_reserved_elasticsearch_instance_offering_positive(self):
786         ret_val = {
787             "ReservedElasticsearchInstanceId": "string",
788             "ReservationName": "string",
789         }
790         with patch.object(
791             self.conn,
792             "purchase_reserved_elasticsearch_instance_offering",
793             return_value=ret_val,
794         ):
795             self.assertEqual(
796                 boto3_elasticsearch.purchase_reserved_elasticsearch_instance_offering(
797                     reserved_elasticsearch_instance_offering_id="foo",
798                     reservation_name="bar",
799                     **CONN_PARAMETERS
800                 ),
801                 {"result": True, "response": ret_val},
802             )
803     def test_purchase_reserved_elasticsearch_instance_offering_error(self):
804         with patch.object(
805             self.conn,
806             "purchase_reserved_elasticsearch_instance_offering",
807             side_effect=ClientError(
808                 ERROR_CONTENT, "purchase_reserved_elasticsearch_instance_offering"
809             ),
810         ):
811             result = (
812                 boto3_elasticsearch.purchase_reserved_elasticsearch_instance_offering(
813                     reserved_elasticsearch_instance_offering_id="foo",
814                     reservation_name="bar",
815                     **CONN_PARAMETERS
816                 )
817             )
818             self.assertFalse(result["result"])
819             self.assertEqual(
820                 result.get("error", ""),
821                 ERROR_MESSAGE.format(
822                     101, "purchase_reserved_elasticsearch_instance_offering"
823                 ),
824             )
825     def test_start_elasticsearch_service_software_update_positive(self):
826         ret_val = {
827             "ServiceSoftwareOptions": {
828                 "CurrentVersion": "string",
829                 "NewVersion": "string",
830                 "UpdateAvailable": True,
831                 "Cancellable": True,
832                 "UpdateStatus": "PENDING_UPDATE",
833                 "Description": "string",
834                 "AutomatedUpdateDate": datetime.datetime(2015, 1, 1),
835             }
836         }
837         with patch.object(
838             self.conn,
839             "start_elasticsearch_service_software_update",
840             return_value=ret_val,
841         ):
842             self.assertEqual(
843                 boto3_elasticsearch.start_elasticsearch_service_software_update(
844                     domain_name="testdomain", **CONN_PARAMETERS
845                 ),
846                 {"result": True, "response": ret_val["ServiceSoftwareOptions"]},
847             )
848     def test_start_elasticsearch_service_software_update_error(self):
849         with patch.object(
850             self.conn,
851             "start_elasticsearch_service_software_update",
852             side_effect=ClientError(
853                 ERROR_CONTENT, "start_elasticsearch_service_software_update"
854             ),
855         ):
856             result = boto3_elasticsearch.start_elasticsearch_service_software_update(
857                 domain_name="testdomain", **CONN_PARAMETERS
858             )
859             self.assertFalse(result["result"])
860             self.assertEqual(
861                 result.get("error", ""),
862                 ERROR_MESSAGE.format(
863                     101, "start_elasticsearch_service_software_update"
864                 ),
865             )
866     def test_upgrade_elasticsearch_domain_positive(self):
867         ret_val = {
868             "DomainName": "string",
869             "TargetVersion": "string",
870             "PerformCheckOnly": True,
871         }
872         with patch.object(
873             self.conn, "upgrade_elasticsearch_domain", return_value=ret_val
874         ):
875             self.assertEqual(
876                 boto3_elasticsearch.upgrade_elasticsearch_domain(
877                     domain_name="testdomain", target_version="1.1", **CONN_PARAMETERS
878                 ),
879                 {"result": True, "response": ret_val},
880             )
881     def test_upgrade_elasticsearch_domain_error(self):
882         with patch.object(
883             self.conn,
884             "upgrade_elasticsearch_domain",
885             side_effect=ClientError(ERROR_CONTENT, "upgrade_elasticsearch_domain"),
886         ):
887             result = boto3_elasticsearch.upgrade_elasticsearch_domain(
888                 domain_name="testdomain", target_version="1.1", **CONN_PARAMETERS
889             )
890             self.assertFalse(result["result"])
891             self.assertEqual(
892                 result.get("error", ""),
893                 ERROR_MESSAGE.format(101, "upgrade_elasticsearch_domain"),
894             )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ioloop_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 import contextlib
3 import datetime
4 <a name="1"></a>import functools
5 import socket
6 import sys
7 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import threading
8 import time
9 import types
10 from salt.ext.tornado import gen
11 from salt.ext.tornado.ioloop import IOLoop, TimeoutError, PollIOLoop, PeriodicCallback
12 from salt.ext.tornado.log import app_log
13 from salt.ext.tornado.platform.select import _Select
14 from salt.ext.tornado.stack_context import ExceptionStackContext, StackContext, wrap, NullContext
15 from salt.ext.tornado.testing import AsyncTestCase, bind_unused_port, ExpectLog
16 from salt.ext.tornado.test.util import unittest, skipIfNonUnix, skipOnTravis, skipBefore35, exec_test
17 try:
18     from</b></font> concurrent import futures
19 except ImportError:
20     futures = None
21 class FakeTimeSelect(_Select):
22     def __init__(self):
23         self._time = 1000
24         super(FakeTimeSelect, self).__init__()
25     def time(self):
26         return self._time
27     def sleep(self, t):
28         self._time += t
29     def poll(self, timeout):
30         events = super(FakeTimeSelect, self).poll(0)
31         if events:
32             return events
33         self._time += timeout
34         return []
35 class FakeTimeIOLoop(PollIOLoop):
36     def initialize(self):
37         self.fts = FakeTimeSelect()
38         super(FakeTimeIOLoop, self).initialize(impl=self.fts,
39                                                time_func=self.fts.time)
40     def sleep(self, t):
41         self.fts.sleep(t)
42 class TestIOLoop(AsyncTestCase):
43     def test_add_callback_return_sequence(self):
44         self.calls = 0
45         loop = self.io_loop
46         test = self
47         old_add_callback = loop.add_callback
48         def add_callback(self, callback, *args, **kwargs):
49             test.calls += 1
50             old_add_callback(callback, *args, **kwargs)
51         loop.add_callback = types.MethodType(add_callback, loop)
52         loop.add_callback(lambda: {})
53         loop.add_callback(lambda: [])
54         loop.add_timeout(datetime.timedelta(milliseconds=50), loop.stop)
55         loop.start()
56         self.assertLess(self.calls, 10)
57     @skipOnTravis
58     def test_add_callback_wakeup(self):
59         def callback():
60             self.called = True
61             self.stop()
62         def schedule_callback():
63             self.called = False
64             self.io_loop.add_callback(callback)
65             self.start_time = time.time()
66         self.io_loop.add_timeout(self.io_loop.time(), schedule_callback)
67         self.wait()
68         self.assertAlmostEqual(time.time(), self.start_time, places=2)
69         self.assertTrue(self.called)
70     @skipOnTravis
71     def test_add_callback_wakeup_other_thread(self):
72         def target():
73             time.sleep(0.01)
74             self.stop_time = time.time()
75             self.io_loop.add_callback(self.stop)
76         thread = threading.Thread(target=target)
77         self.io_loop.add_callback(thread.start)
78         self.wait()
79         delta = time.time() - self.stop_time
80         self.assertLess(delta, 0.1)
81         thread.join()
82     def test_add_timeout_timedelta(self):
83         self.io_loop.add_timeout(datetime.timedelta(microseconds=1), self.stop)
84         self.wait()
85     def test_multiple_add(self):
86         sock, port = bind_unused_port()
87         try:
88             self.io_loop.add_handler(sock.fileno(), lambda fd, events: None,
89                                      IOLoop.READ)
90             self.assertRaises(Exception, self.io_loop.add_handler,
91                               sock.fileno(), lambda fd, events: None,
92                               IOLoop.READ)
93         finally:
94             self.io_loop.remove_handler(sock.fileno())
95             sock.close()
96     def test_remove_without_add(self):
97         sock, port = bind_unused_port()
98         try:
99             self.io_loop.remove_handler(sock.fileno())
100         finally:
101             sock.close()
102     def test_add_callback_from_signal(self):
103         self.io_loop.add_callback_from_signal(self.stop)
104         self.wait()
105     def test_add_callback_from_signal_other_thread(self):
106         other_ioloop = IOLoop()
107         thread = threading.Thread(target=other_ioloop.start)
108         thread.start()
109         other_ioloop.add_callback_from_signal(other_ioloop.stop)
110         thread.join()
111         other_ioloop.close()
112     def test_add_callback_while_closing(self):
113         if IOLoop.configured_class().__name__.endswith('AsyncIOLoop'):
114             raise unittest.SkipTest("AsyncIOMainLoop shutdown not thread safe")
115         closing = threading.Event()
116         def target():
117             other_ioloop.add_callback(other_ioloop.stop)
118             other_ioloop.start()
119             closing.set()
120             other_ioloop.close(all_fds=True)
121         other_ioloop = IOLoop()
122         thread = threading.Thread(target=target)
123         thread.start()
124         closing.wait()
125         for i in range(1000):
126             try:
127                 other_ioloop.add_callback(lambda: None)
128             except RuntimeError as e:
129                 self.assertEqual("IOLoop is closing", str(e))
130                 break
131     def test_handle_callback_exception(self):
132         def handle_callback_exception(callback):
133             self.assertIs(sys.exc_info()[0], ZeroDivisionError)
134             self.stop()
135         self.io_loop.handle_callback_exception = handle_callback_exception
136         with NullContext():
137             self.io_loop.add_callback(lambda: 1 / 0)
138         self.wait()
139     @skipIfNonUnix  # just because socketpair is so convenient
140     def test_read_while_writeable(self):
141         client, server = socket.socketpair()
142         try:
143             def handler(fd, events):
144                 self.assertEqual(events, IOLoop.READ)
145                 self.stop()
146             self.io_loop.add_handler(client.fileno(), handler, IOLoop.READ)
147             self.io_loop.add_timeout(self.io_loop.time() + 0.01,
148                                      functools.partial(server.send, b'asdf'))
149             self.wait()
150             self.io_loop.remove_handler(client.fileno())
151         finally:
152             client.close()
153             server.close()
154     def test_remove_timeout_after_fire(self):
155         handle = self.io_loop.add_timeout(self.io_loop.time(), self.stop)
156         self.wait()
157         self.io_loop.remove_timeout(handle)
158     def test_remove_timeout_cleanup(self):
159         for i in range(2000):
160             timeout = self.io_loop.add_timeout(self.io_loop.time() + 3600,
161                                                lambda: None)
162             self.io_loop.remove_timeout(timeout)
163         self.io_loop.add_callback(lambda: self.io_loop.add_callback(self.stop))
164         self.wait()
165     def test_remove_timeout_from_timeout(self):
166         calls = [False, False]
167         now = self.io_loop.time()
168         def t1():
169             calls[0] = True
170             self.io_loop.remove_timeout(t2_handle)
171         self.io_loop.add_timeout(now + 0.01, t1)
172         def t2():
173             calls[1] = True
174         t2_handle = self.io_loop.add_timeout(now + 0.02, t2)
175         self.io_loop.add_timeout(now + 0.03, self.stop)
176         time.sleep(0.03)
177         self.wait()
178         self.assertEqual(calls, [True, False])
179     def test_timeout_with_arguments(self):
180         results = []
181         self.io_loop.add_timeout(self.io_loop.time(), results.append, 1)
182         self.io_loop.add_timeout(datetime.timedelta(seconds=0),
183                                  results.append, 2)
184         self.io_loop.call_at(self.io_loop.time(), results.append, 3)
185         self.io_loop.call_later(0, results.append, 4)
186         self.io_loop.call_later(0, self.stop)
187         self.wait()
188         self.assertEqual(results, [1, 2, 3, 4])
189     def test_add_timeout_return(self):
190         handle = self.io_loop.add_timeout(self.io_loop.time(), lambda: None)
191         self.assertFalse(handle is None)
192         self.io_loop.remove_timeout(handle)
193     def test_call_at_return(self):
194         handle = self.io_loop.call_at(self.io_loop.time(), lambda: None)
195         self.assertFalse(handle is None)
196         self.io_loop.remove_timeout(handle)
197     def test_call_later_return(self):
198         handle = self.io_loop.call_later(0, lambda: None)
199         self.assertFalse(handle is None)
200         self.io_loop.remove_timeout(handle)
201     def test_close_file_object(self):
202         class SocketWrapper(object):
203             def __init__(self, sockobj):
204                 self.sockobj = sockobj
205                 self.closed = False
206             def fileno(self):
207                 return self.sockobj.fileno()
208             def close(self):
209                 self.closed = True
210                 self.sockobj.close()
211         sockobj, port = bind_unused_port()
212         socket_wrapper = SocketWrapper(sockobj)
213         io_loop = IOLoop()
214         io_loop.add_handler(socket_wrapper, lambda fd, events: None,
215                             IOLoop.READ)
216         io_loop.close(all_fds=True)
217         self.assertTrue(socket_wrapper.closed)
218     def test_handler_callback_file_object(self):
219         server_sock, port = bind_unused_port()
220         fds = []
221         def handle_connection(fd, events):
222             fds.append(fd)
223             conn, addr = server_sock.accept()
224             conn.close()
225             self.stop()
226         self.io_loop.add_handler(server_sock, handle_connection, IOLoop.READ)
227         with contextlib.closing(socket.socket()) as client_sock:
228             client_sock.connect(('127.0.0.1', port))
229             self.wait()
230         self.io_loop.remove_handler(server_sock)
231         self.io_loop.add_handler(server_sock.fileno(), handle_connection,
232                                  IOLoop.READ)
233         with contextlib.closing(socket.socket()) as client_sock:
234             client_sock.connect(('127.0.0.1', port))
235             self.wait()
236         self.assertIs(fds[0], server_sock)
237         self.assertEqual(fds[1], server_sock.fileno())
238         self.io_loop.remove_handler(server_sock.fileno())
239         server_sock.close()
240     def test_mixed_fd_fileobj(self):
241         server_sock, port = bind_unused_port()
242         def f(fd, events):
243             pass
244         self.io_loop.add_handler(server_sock, f, IOLoop.READ)
245         with self.assertRaises(Exception):
246             self.io_loop.add_handler(server_sock.fileno(), f, IOLoop.READ)
247         self.io_loop.remove_handler(server_sock.fileno())
248         server_sock.close()
249     def test_reentrant(self):
250         returned_from_start = [False]
251         got_exception = [False]
252         def callback():
253             try:
254                 self.io_loop.start()
255                 returned_from_start[0] = True
256             except Exception:
257                 got_exception[0] = True
258             self.stop()
259         self.io_loop.add_callback(callback)
260         self.wait()
261         self.assertTrue(got_exception[0])
262         self.assertFalse(returned_from_start[0])
263     def test_exception_logging(self):
264         with NullContext():
265             self.io_loop.add_callback(lambda: 1 / 0)
266             self.io_loop.add_callback(self.stop)
267             with ExpectLog(app_log, "Exception in callback"):
268                 self.wait()
269     def test_exception_logging_future(self):
270         with NullContext():
271             @gen.coroutine
272             def callback():
273                 self.io_loop.add_callback(self.stop)
274                 1 / 0
275             self.io_loop.add_callback(callback)
276             with ExpectLog(app_log, "Exception in callback"):
277                 self.wait()
278     @skipBefore35
279     def test_exception_logging_native_coro(self):
280         namespace = exec_test(globals(), locals(), """
281         async def callback():
282             self.io_loop.add_callback(self.stop)
283             1 / 0
284                                     lambda future: self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.stop(future))
285             future = self.wait()
286             self.assertTrue(future.done())
287             self.assertTrue(future.</b></font>result() is None)
288     def test_add_future_stack_context(self):
289         ready = threading.Event()
290         def task():
291             ready.wait(1)
292             assert ready.isSet(), "timed out"
293             raise Exception("worker")
294         def callback(future):
295             self.future = future
296             raise Exception("callback")
297         def handle_exception(typ, value, traceback):
298             self.exception = value
299             self.stop()
300             return True
301         with futures.ThreadPoolExecutor(1) as pool:
302             with ExceptionStackContext(handle_exception):
303                 self.io_loop.add_future(pool.submit(task), callback)
304             ready.set()
305         self.wait()
306         self.assertEqual(self.exception.args[0], "callback")
307         self.assertEqual(self.future.exception().args[0], "worker")
308 class TestIOLoopRunSync(unittest.TestCase):
309     def setUp(self):
310         self.io_loop = IOLoop()
311     def tearDown(self):
312         self.io_loop.close()
313     def test_sync_result(self):
314         with self.assertRaises(gen.BadYieldError):
315             self.io_loop.run_sync(lambda: 42)
316     def test_sync_exception(self):
317         with self.assertRaises(ZeroDivisionError):
318             self.io_loop.run_sync(lambda: 1 / 0)
319     def test_async_result(self):
320         @gen.coroutine
321         def f():
322             yield gen.Task(self.io_loop.add_callback)
323             raise gen.Return(42)
324         self.assertEqual(self.io_loop.run_sync(f), 42)
325     def test_async_exception(self):
326         @gen.coroutine
327         def f():
328             yield gen.Task(self.io_loop.add_callback)
329             1 / 0
330         with self.assertRaises(ZeroDivisionError):
331             self.io_loop.run_sync(f)
332     def test_current(self):
333         def f():
334             self.assertIs(IOLoop.current(), self.io_loop)
335         self.io_loop.run_sync(f)
336     def test_timeout(self):
337         @gen.coroutine
338         def f():
339             yield gen.Task(self.io_loop.add_timeout, self.io_loop.time() + 1)
340         self.assertRaises(TimeoutError, self.io_loop.run_sync, f, timeout=0.01)
341     @skipBefore35
342     def test_native_coroutine(self):
343         namespace = exec_test(globals(), locals(), """
344         async def f():
345             await gen.Task(self.io_loop.add_callback)
346         """)
347         self.io_loop.run_sync(namespace['f'])
348 class TestPeriodicCallback(unittest.TestCase):
349     def setUp(self):
350         self.io_loop = FakeTimeIOLoop()
351         self.io_loop.make_current()
352     def tearDown(self):
353         self.io_loop.close()
354     def test_basic(self):
355         calls = []
356         def cb():
357             calls.append(self.io_loop.time())
358         pc = PeriodicCallback(cb, 10000)
359         pc.start()
360         self.io_loop.call_later(50, self.io_loop.stop)
361         self.io_loop.start()
362         self.assertEqual(calls, [1010, 1020, 1030, 1040, 1050])
363     def test_overrun(self):
364         sleep_durations = [9, 9, 10, 11, 20, 20, 35, 35, 0, 0]
365         expected = [
366             1010, 1020, 1030,  # first 3 calls on schedule
367             1050, 1070,  # next 2 delayed one cycle
368             1100, 1130,  # next 2 delayed 2 cycles
369             1170, 1210,  # next 2 delayed 3 cycles
370             1220, 1230,  # then back on schedule.
371         ]
372         calls = []
373         def cb():
374             calls.append(self.io_loop.time())
375             if not sleep_durations:
376                 self.io_loop.stop()
377                 return
378             self.io_loop.sleep(sleep_durations.pop(0))
379         pc = PeriodicCallback(cb, 10000)
380         pc.start()
381         self.io_loop.start()
382         self.assertEqual(calls, expected)
383 if __name__ == "__main__":
384     unittest.main()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
