<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto3_elasticsearch.py &amp; ioloop_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto3_elasticsearch.py &amp; ioloop_test.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto3_elasticsearch.py (2.108963%)<th>ioloop_test.py (1.8447348%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(197-204)<td><a href="#" name="0">(551-554)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(6-19)<td><a href="#" name="1">(11-24)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto3_elasticsearch.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import datetime
3 import random
4 import string
5 import textwrap
6 import salt.loader
7 import salt.modules.boto3_elasticsearch as boto3_elasticsearch
8 from salt.utils.versions import LooseVersion
9 from tests.support.mixins import LoaderModuleMockMixin
10 from tests.support.mock import MagicMock, patch
11 from tests.support.unit import TestCase, skipIf
12 try:
13     import</b></font> boto3
14     from botocore.exceptions import ClientError
15     HAS_BOTO3 = True
16 except ImportError:
17     HAS_BOTO3 = False
18 REQUIRED_BOTO3_VERSION = "1.2.1"
19 def __virtual__():
20     """
21     Returns True/False boolean depending on if Boto3 is installed and correct
22     version.
23     """
24     if not HAS_BOTO3:
25         return False
26     if LooseVersion(boto3.__version__) &lt; LooseVersion(REQUIRED_BOTO3_VERSION):
27         return (
28             False,
29             "The boto3 module must be greater or equal to version {}".format(
30                 REQUIRED_BOTO3_VERSION
31             ),
32         )
33     return True
34 REGION = "us-east-1"
35 ACCESS_KEY = "GKTADJGHEIQSXMKKRBJ08H"
36 SECRET_KEY = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
37 CONN_PARAMETERS = {
38     "region": REGION,
39     "key": ACCESS_KEY,
40     "keyid": SECRET_KEY,
41     "profile": {},
42 }
43 ERROR_MESSAGE = (
44     "An error occurred ({}) when calling the {} operation: Test-defined error"
45 )
46 ERROR_CONTENT = {"Error": {"Code": 101, "Message": "Test-defined error"}}
47 NOT_FOUND_ERROR = ClientError(
48     {"Error": {"Code": "ResourceNotFoundException", "Message": "Test-defined error"}},
49     "msg",
50 )
51 DOMAIN_RET = {
52     "DomainId": "accountno/testdomain",
53     "DomainName": "testdomain",
54     "ARN": "arn:aws:es:region:accountno:domain/testdomain",
55     "Created": True,
56     "Deleted": False,
57     "Endpoints": {"vpc": "vpc-testdomain-1234567890.region.es.amazonaws.com"},
58     "Processing": False,
59     "UpgradeProcessing": False,
60     "ElasticsearchVersion": "6.3",
61     "ElasticsearchClusterConfig": {
62         "InstanceType": "t2.medium.elasticsearch",
63         "InstanceCount": 1,
64         "DedicatedMasterEnabled": False,
65         "ZoneAwarenessEnabled": False,
66     },
67     "EBSOptions": {
68         "EBSEnabled": True,
69         "VolumeType": "gp2",
70         "VolumeSize": 123,
71         "Iops": 12,
72     },
73     "AccessPolicies": textwrap.dedent(
74         """
75         {"Version":"2012-10-17","Statement":[{"Effect":"Allow",
76         "Principal":{"AWS":"*"},"Action":"es:*",
77         "Resource":"arn:aws:es:region:accountno:domain/testdomain/*"}]}"""
78     ),
79     "SnapshotOptions": {"AutomatedSnapshotStartHour": 1},
80     "VPCOptions": {
81         "VPCId": "vpc-12345678",
82         "SubnetIds": ["subnet-deadbeef"],
83         "AvailabilityZones": ["regiona"],
84         "SecurityGroupIds": ["sg-87654321"],
85     },
86     "CognitoOptions": {"Enabled": False},
87     "EncryptionAtRestOptions": {"Enabled": False},
88     "NodeToNodeEncryptionOptions": {"Enabled": False},
89     "AdvancedOptions": {"rest.action.multi.allow_explicit_index": "true"},
90     "ServiceSoftwareOptions": {
91         "CurrentVersion": "R20190221-P1",
92         "NewVersion": "R20190418",
93         "UpdateAvailable": True,
94         "Cancellable": False,
95         "UpdateStatus": "ELIGIBLE",
96         "Description": (
97             "A newer release R20190418 is available. This release "
98             "will be automatically deployed after somedate"
99         ),
100         "AutomatedUpdateDate": None,
101     },
102 }
103 @skipIf(HAS_BOTO3 is False, "The boto module must be installed.")
104 @skipIf(
105     LooseVersion(boto3.__version__) &lt; LooseVersion(REQUIRED_BOTO3_VERSION),
106     "The boto3 module must be greater or equal to version {}".format(
107         REQUIRED_BOTO3_VERSION
108     ),
109 )
110 class Boto3ElasticsearchTestCase(TestCase, LoaderModuleMockMixin):
111     """
112     TestCase for salt.modules.boto3_elasticsearch module
113     """
114     conn = None
115     def setup_loader_modules(self):
116         self.opts = salt.config.DEFAULT_MINION_OPTS.copy()
117         utils = salt.loader.utils(
118             self.opts,
119             whitelist=["boto3", "args", "systemd", "path", "platform"],
120             context={},
121         )
122         return {boto3_elasticsearch: {"__utils__": utils}}
123     def setUp(self):
124         super().setUp()
125         boto3_elasticsearch.__init__(self.opts)
126         del self.opts
127         CONN_PARAMETERS["key"] = "".join(
128             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
129         )
130         self.conn = MagicMock()
131         self.addCleanup(delattr, self, "conn")
132         self.patcher = patch("boto3.session.Session")
133         self.addCleanup(self.patcher.stop)
134         self.addCleanup(delattr, self, "patcher")
135         mock_session = self.patcher.start()
136         session_instance = mock_session.return_value
137         session_instance.configure_mock(client=MagicMock(return_value=self.conn))
138         self.paginator = MagicMock()
139         self.addCleanup(delattr, self, "paginator")
140         self.conn.configure_mock(get_paginator=MagicMock(return_value=self.paginator))
141     def test_describe_elasticsearch_domain_positive(self):
142         """
143         Test that when describing a domain when the domain actually exists,
144         the .exists method returns a dict with 'result': True
145         and 'response' with the domain status information.
146         """
147         with patch.object(
148             self.conn,
149             "describe_elasticsearch_domain",
150             return_value={"DomainStatus": DOMAIN_RET},
151         ):
152             self.assertEqual(
153                 boto3_elasticsearch.describe_elasticsearch_domain(
154                     domain_name="testdomain", **CONN_PARAMETERS
155                 ),
156                 {"result": True, "response": DOMAIN_RET},
157             )
158     def test_describe_elasticsearch_domain_error(self):
159         """
160         Test that when describing a domain when the domain does not exist,
161         the .exists method returns a dict with 'result': False
162         and 'error' with boto's ResourceNotFoundException.
163         """
164             self.conn, "describe_elasticsearch_domain", side_effect=NOT_FOUND_ERROR
165         ):
166             result = boto3_elasticsearch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.describe_elasticsearch_domain(
167                 domain_name="testdomain", **CONN_PARAMETERS
168             )
169             self.assertEqual(
170                 result.get("error", ""),
171                 ERROR_MESSAGE.format("ResourceNotFoundException", "msg"),
172             )
173             self.assertFalse(result[</b></font>"result"])
174     def test_create_elasticsearch_domain_positive(self):
175         """
176         Test that when creating a domain, and it succeeds,
177         the .create method returns a dict with 'result': True
178         and 'response' with the newly created domain's status information.
179         """
180         with patch.object(
181             self.conn,
182             "create_elasticsearch_domain",
183             return_value={"DomainStatus": DOMAIN_RET},
184         ):
185             kwargs = {
186                 "elasticsearch_version": DOMAIN_RET["ElasticsearchVersion"],
187                 "elasticsearch_cluster_config": DOMAIN_RET[
188                     "ElasticsearchClusterConfig"
189                 ],
190                 "ebs_options": DOMAIN_RET["EBSOptions"],
191                 "access_policies": DOMAIN_RET["AccessPolicies"],
192                 "snapshot_options": DOMAIN_RET["SnapshotOptions"],
193                 "vpc_options": DOMAIN_RET["VPCOptions"],
194                 "cognito_options": DOMAIN_RET["CognitoOptions"],
195                 "encryption_at_rest_options": DOMAIN_RET["EncryptionAtRestOptions"],
196                 "advanced_options": DOMAIN_RET["AdvancedOptions"],
197             }
198             kwargs.update(CONN_PARAMETERS)
199             self.assertEqual(
200                 boto3_elasticsearch.create_elasticsearch_domain(
201                     domain_name="testdomain", **kwargs
202                 ),
203                 {"result": True, "response": DOMAIN_RET},
204             )
205     def test_create_elasticsearch_domain_error(self):
206         """
207         Test that when creating a domain, and boto3 returns an error,
208         the .create method returns a dict with 'result': False
209         and 'error' with the error reported by boto3.
210         """
211         with patch.object(
212             self.conn,
213             "create_elasticsearch_domain",
214             side_effect=ClientError(ERROR_CONTENT, "create_domain"),
215         ):
216             kwargs = {
217                 "elasticsearch_version": DOMAIN_RET["ElasticsearchVersion"],
218                 "elasticsearch_cluster_config": DOMAIN_RET[
219                     "ElasticsearchClusterConfig"
220                 ],
221                 "ebs_options": DOMAIN_RET["EBSOptions"],
222                 "access_policies": DOMAIN_RET["AccessPolicies"],
223                 "snapshot_options": DOMAIN_RET["SnapshotOptions"],
224                 "vpc_options": DOMAIN_RET["VPCOptions"],
225                 "cognito_options": DOMAIN_RET["CognitoOptions"],
226                 "encryption_at_rest_options": DOMAIN_RET["EncryptionAtRestOptions"],
227                 "advanced_options": DOMAIN_RET["AdvancedOptions"],
228             }
229             kwargs.update(CONN_PARAMETERS)
230             result = boto3_elasticsearch.create_elasticsearch_domain(
231                 "testdomain", **kwargs
232             )
233             self.assertEqual(
234                 result.get("error", ""), ERROR_MESSAGE.format(101, "create_domain")
235             )
236     def test_delete_domain_positive(self):
237         """
238         Test that when deleting a domain, and it succeeds,
239         the .delete method returns {'result': True}.
240         """
241         with patch.object(self.conn, "delete_elasticsearch_domain"):
242             self.assertEqual(
243                 boto3_elasticsearch.delete_elasticsearch_domain(
244                     "testdomain", **CONN_PARAMETERS
245                 ),
246                 {"result": True},
247             )
248     def test_delete_domain_error(self):
249         """
250         Test that when deleting a domain, and boto3 returns an error,
251         the .delete method returns {'result': False, 'error' :'the error'}.
252         """
253         with patch.object(
254             self.conn,
255             "delete_elasticsearch_domain",
256             side_effect=ClientError(ERROR_CONTENT, "delete_domain"),
257         ):
258             result = boto3_elasticsearch.delete_elasticsearch_domain(
259                 "testdomain", **CONN_PARAMETERS
260             )
261             self.assertFalse(result["result"])
262             self.assertEqual(
263                 result.get("error", ""), ERROR_MESSAGE.format(101, "delete_domain")
264             )
265     def test_update_domain_positive(self):
266         """
267         Test that when updating a domain succeeds, the .update method returns {'result': True}.
268         """
269         with patch.object(
270             self.conn,
271             "update_elasticsearch_domain_config",
272             return_value={"DomainConfig": DOMAIN_RET},
273         ):
274             kwargs = {
275                 "elasticsearch_cluster_config": DOMAIN_RET[
276                     "ElasticsearchClusterConfig"
277                 ],
278                 "ebs_options": DOMAIN_RET["EBSOptions"],
279                 "snapshot_options": DOMAIN_RET["SnapshotOptions"],
280                 "vpc_options": DOMAIN_RET["VPCOptions"],
281                 "cognito_options": DOMAIN_RET["CognitoOptions"],
282                 "advanced_options": DOMAIN_RET["AdvancedOptions"],
283                 "access_policies": DOMAIN_RET["AccessPolicies"],
284                 "log_publishing_options": {},
285             }
286             kwargs.update(CONN_PARAMETERS)
287             self.assertEqual(
288                 boto3_elasticsearch.update_elasticsearch_domain_config(
289                     "testdomain", **kwargs
290                 ),
291                 {"result": True, "response": DOMAIN_RET},
292             )
293     def test_update_domain_error(self):
294         """
295         Test that when updating a domain fails, and boto3 returns an error,
296         the .update method returns the error.
297         """
298         with patch.object(
299             self.conn,
300             "update_elasticsearch_domain_config",
301             side_effect=ClientError(ERROR_CONTENT, "update_domain"),
302         ):
303             kwargs = {
304                 "elasticsearch_cluster_config": DOMAIN_RET[
305                     "ElasticsearchClusterConfig"
306                 ],
307                 "ebs_options": DOMAIN_RET["EBSOptions"],
308                 "snapshot_options": DOMAIN_RET["SnapshotOptions"],
309                 "vpc_options": DOMAIN_RET["VPCOptions"],
310                 "cognito_options": DOMAIN_RET["CognitoOptions"],
311                 "advanced_options": DOMAIN_RET["AdvancedOptions"],
312                 "access_policies": DOMAIN_RET["AccessPolicies"],
313                 "log_publishing_options": {},
314             }
315             kwargs.update(CONN_PARAMETERS)
316             result = boto3_elasticsearch.update_elasticsearch_domain_config(
317                 "testdomain", **kwargs
318             )
319             self.assertEqual(
320                 result.get("error", ""), ERROR_MESSAGE.format(101, "update_domain")
321             )
322     def test_add_tags_positive(self):
323         """
324         Test that when adding tags is successful, the .add_tags method returns {'result': True}.
325         """
326         with patch.object(
327             self.conn,
328             "describe_elasticsearch_domain",
329             return_value={"DomainStatus": DOMAIN_RET},
330         ):
331             self.assertEqual(
332                 boto3_elasticsearch.add_tags(
333                     "testdomain", tags={"foo": "bar", "baz": "qux"}, **CONN_PARAMETERS
334                 ),
335                 {"result": True},
336             )
337     def test_add_tags_default(self):
338         """
339         Test that when tags are not provided, no error is raised.
340         """
341         with patch.object(
342             self.conn,
343             "describe_elasticsearch_domain",
344             return_value={"DomainStatus": DOMAIN_RET},
345         ):
346             self.assertEqual(
347                 boto3_elasticsearch.add_tags("testdomain", **CONN_PARAMETERS),
348                 {"result": True},
349             )
350     def test_add_tags_error(self):
351         """
352         Test that when adding tags fails, and boto3 returns an error,
353         the .add_tags function returns {'tagged': False, 'error': 'the error'}.
354         """
355         with patch.object(
356             self.conn, "add_tags", side_effect=ClientError(ERROR_CONTENT, "add_tags")
357         ), patch.object(
358             self.conn,
359             "describe_elasticsearch_domain",
360             return_value={"DomainStatus": DOMAIN_RET},
361         ):
362             result = boto3_elasticsearch.add_tags(
363                 "testdomain", tags={"foo": "bar", "baz": "qux"}, **CONN_PARAMETERS
364             )
365             self.assertFalse(result["result"])
366             self.assertEqual(
367                 result.get("error", ""), ERROR_MESSAGE.format(101, "add_tags")
368             )
369     def test_remove_tags_positive(self):
370         """
371         Test that when removing tags is successful, the .remove_tags method returns {'tagged': True}.
372         """
373         with patch.object(
374             self.conn,
375             "describe_elasticsearch_domain",
376             return_value={"DomainStatus": DOMAIN_RET},
377         ):
378             self.assertEqual(
379                 boto3_elasticsearch.remove_tags(
380                     tag_keys=["foo", "bar"], domain_name="testdomain", **CONN_PARAMETERS
381                 ),
382                 {"result": True},
383             )
384     def test_remove_tag_error(self):
385         """
386         Test that when removing tags fails, and boto3 returns an error,
387         the .remove_tags method returns {'tagged': False, 'error': 'the error'}.
388         """
389         with patch.object(
390             self.conn,
391             "remove_tags",
392             side_effect=ClientError(ERROR_CONTENT, "remove_tags"),
393         ), patch.object(
394             self.conn,
395             "describe_elasticsearch_domain",
396             return_value={"DomainStatus": DOMAIN_RET},
397         ):
398             result = boto3_elasticsearch.remove_tags(
399                 tag_keys=["foo", "bar"], domain_name="testdomain", **CONN_PARAMETERS
400             )
401             self.assertFalse(result["result"])
402             self.assertEqual(
403                 result.get("error", ""), ERROR_MESSAGE.format(101, "remove_tags")
404             )
405     def test_list_tags_positive(self):
406         """
407         Test that when listing tags is successful,
408         the .list_tags method returns a dict with key 'tags'.
409         Also test that the tags returned are manipulated properly (i.e. transformed
410         into a dict with tags).
411         """
412         with patch.object(
413             self.conn,
414             "describe_elasticsearch_domain",
415             return_value={"DomainStatus": DOMAIN_RET},
416         ), patch.object(
417             self.conn,
418             "list_tags",
419             return_value={"TagList": [{"Key": "foo", "Value": "bar"}]},
420         ):
421             result = boto3_elasticsearch.list_tags(
422                 domain_name="testdomain", **CONN_PARAMETERS
423             )
424             self.assertEqual(result, {"result": True, "response": {"foo": "bar"}})
425     def test_list_tags_error(self):
426         """
427         Test that when listing tags causes boto3 to return an error,
428         the .list_tags method returns the error.
429         """
430         with patch.object(
431             self.conn, "list_tags", side_effect=ClientError(ERROR_CONTENT, "list_tags")
432         ), patch.object(
433             self.conn,
434             "describe_elasticsearch_domain",
435             return_value={"DomainStatus": DOMAIN_RET},
436         ):
437             result = boto3_elasticsearch.list_tags(
438                 domain_name="testdomain", **CONN_PARAMETERS
439             )
440             self.assertFalse(result["result"])
441             self.assertEqual(
442                 result.get("error", ""), ERROR_MESSAGE.format(101, "list_tags")
443             )
444     def test_cancel_elasticsearch_service_software_update_positive(self):
445         """
446         Test that when calling cancel_elasticsearch_service_software_update and
447         it is successful, it returns {'result': True}.
448         """
449         retval = {
450             "ServiceSoftwareOptions": {
451                 "CurrentVersion": "string",
452                 "NewVersion": "string",
453                 "UpdateAvailable": True,
454                 "Cancellable": True,
455                 "UpdateStatus": "ELIGIBLE",
456                 "Description": "string",
457                 "AutomatedUpdateDate": datetime.datetime(2015, 1, 1),
458             }
459         }
460         with patch.object(
461             self.conn,
462             "cancel_elasticsearch_service_software_update",
463             return_value=retval,
464         ):
465             result = boto3_elasticsearch.cancel_elasticsearch_service_software_update(
466                 domain_name="testdomain", **CONN_PARAMETERS
467             )
468             self.assertEqual(result, {"result": True})
469     def test_cancel_elasticsearch_service_software_update_error(self):
470         """
471         Test that when calling cancel_elasticsearch_service_software_update and
472         boto3 returns an error, it returns {'result': False, 'error': 'the error'}.
473         """
474         with patch.object(
475             self.conn,
476             "cancel_elasticsearch_service_software_update",
477             side_effect=ClientError(
478                 ERROR_CONTENT, "cancel_elasticsearch_service_software_update"
479             ),
480         ):
481             result = boto3_elasticsearch.cancel_elasticsearch_service_software_update(
482                 domain_name="testdomain", **CONN_PARAMETERS
483             )
484             self.assertFalse(result["result"])
485             self.assertEqual(
486                 result.get("error", ""),
487                 ERROR_MESSAGE.format(
488                     101, "cancel_elasticsearch_service_software_update"
489                 ),
490             )
491     def test_delete_elasticsearch_service_role_positive(self):
492         """
493         Test that when calling delete_elasticsearch_service_role and
494         it is successful, it returns {'result': True}.
495         """
496         with patch.object(
497             self.conn, "delete_elasticsearch_service_role", return_value=None
498         ):
499             result = boto3_elasticsearch.delete_elasticsearch_service_role(
500                 **CONN_PARAMETERS
501             )
502             self.assertEqual(result, {"result": True})
503     def test_delete_elasticsearch_service_role_error(self):
504         """
505         Test that when calling delete_elasticsearch_service_role and boto3 returns
506         an error, it returns {'result': False, 'error': 'the error'}.
507         """
508         with patch.object(
509             self.conn,
510             "delete_elasticsearch_service_role",
511             side_effect=ClientError(ERROR_CONTENT, "delete_elasticsearch_service_role"),
512         ):
513             result = boto3_elasticsearch.delete_elasticsearch_service_role(
514                 **CONN_PARAMETERS
515             )
516             self.assertFalse(result["result"])
517             self.assertEqual(
518                 result.get("error", ""),
519                 ERROR_MESSAGE.format(101, "delete_elasticsearch_service_role"),
520             )
521     def test_describe_elasticsearch_domain_config_positive(self):
522         """
523         Test that when calling describe_elasticsearch_domain_config and
524         it is successful, it returns {'result': True}.
525         """
526         with patch.object(
527             self.conn,
528             "describe_elasticsearch_domain_config",
529             return_value={"DomainConfig": DOMAIN_RET},
530         ):
531             self.assertEqual(
532                 boto3_elasticsearch.describe_elasticsearch_domain_config(
533                     "testdomain", **CONN_PARAMETERS
534                 ),
535                 {"result": True, "response": DOMAIN_RET},
536             )
537     def test_describe_elasticsearch_domain_config_error(self):
538         """
539         Test that when calling describe_elasticsearch_domain_config and boto3 returns
540         an error, it returns {'result': False, 'error': 'the error'}.
541         """
542         with patch.object(
543             self.conn,
544             "describe_elasticsearch_domain_config",
545             side_effect=ClientError(
546                 ERROR_CONTENT, "describe_elasticsearch_domain_config"
547             ),
548         ):
549             result = boto3_elasticsearch.describe_elasticsearch_domain_config(
550                 domain_name="testdomain", **CONN_PARAMETERS
551             )
552             self.assertFalse(result["result"])
553             self.assertEqual(
554                 result.get("error", ""),
555                 ERROR_MESSAGE.format(101, "describe_elasticsearch_domain_config"),
556             )
557     def test_describe_elasticsearch_domains_positive(self):
558         """
559         Test that when calling describe_elasticsearch_domains and it is successful,
560         it returns {'result': True, 'response': some_data}.
561         """
562         with patch.object(
563             self.conn,
564             "describe_elasticsearch_domains",
565             return_value={"DomainStatusList": [DOMAIN_RET]},
566         ):
567             self.assertEqual(
568                 boto3_elasticsearch.describe_elasticsearch_domains(
569                     domain_names=["test_domain"], **CONN_PARAMETERS
570                 ),
571                 {"result": True, "response": [DOMAIN_RET]},
572             )
573     def test_describe_elasticsearch_domains_error(self):
574         """
575         Test that when calling describe_elasticsearch_domains and boto3 returns
576         an error, it returns {'result': False, 'error': 'the error'}.
577         """
578         with patch.object(
579             self.conn,
580             "describe_elasticsearch_domains",
581             side_effect=ClientError(ERROR_CONTENT, "describe_elasticsearch_domains"),
582         ):
583             result = boto3_elasticsearch.describe_elasticsearch_domains(
584                 domain_names=["testdomain"], **CONN_PARAMETERS
585             )
586             self.assertFalse(result["result"])
587             self.assertEqual(
588                 result.get("error", ""),
589                 ERROR_MESSAGE.format(101, "describe_elasticsearch_domains"),
590             )
591     def test_describe_elasticsearch_instance_type_limits_positive(self):
592         """
593         Test that when calling describe_elasticsearch_instance_type_limits and
594         it succeeds, it returns {'result': True, 'response' some_value}.
595         """
596         ret_val = {
597             "LimitsByRole": {
598                 "string": {
599                     "StorageTypes": [
600                         {
601                             "StorageTypeName": "string",
602                             "StorageSubTypeName": "string",
603                             "StorageTypeLimits": [
604                                 {"LimitName": "string", "LimitValues": ["string"]}
605                             ],
606                         }
607                     ],
608                     "InstanceLimits": {
609                         "InstanceCountLimits": {
610                             "MinimumInstanceCount": 123,
611                             "MaximumInstanceCount": 123,
612                         }
613                     },
614                     "AdditionalLimits": [
615                         {"LimitName": "string", "LimitValues": ["string"]}
616                     ],
617                 }
618             }
619         }
620         with patch.object(
621             self.conn,
622             "describe_elasticsearch_instance_type_limits",
623             return_value=ret_val,
624         ):
625             self.assertEqual(
626                 boto3_elasticsearch.describe_elasticsearch_instance_type_limits(
627                     domain_name="testdomain",
628                     instance_type="foo",
629                     elasticsearch_version="1.0",
630                     **CONN_PARAMETERS
631                 ),
632                 {"result": True, "response": ret_val["LimitsByRole"]},
633             )
634     def test_describe_elasticsearch_instance_type_limits_error(self):
635         """
636         Test that when calling describe_elasticsearch_instance_type_limits and boto3 returns
637         an error, it returns {'result': False, 'error': 'the error'}.
638         """
639         with patch.object(
640             self.conn,
641             "describe_elasticsearch_instance_type_limits",
642             side_effect=ClientError(
643                 ERROR_CONTENT, "describe_elasticsearch_instance_type_limits"
644             ),
645         ):
646             result = boto3_elasticsearch.describe_elasticsearch_instance_type_limits(
647                 domain_name="testdomain",
648                 instance_type="foo",
649                 elasticsearch_version="1.0",
650                 **CONN_PARAMETERS
651             )
652             self.assertFalse(result["result"])
653             self.assertEqual(
654                 result.get("error", ""),
655                 ERROR_MESSAGE.format(
656                     101, "describe_elasticsearch_instance_type_limits"
657                 ),
658             )
659     def test_describe_reserved_elasticsearch_instance_offerings_positive(self):
660         """
661         Test that when calling describe_reserved_elasticsearch_instance_offerings
662         and it succeeds, it returns {'result': True, 'response': some_value}.
663         """
664         ret_val = {
665             "NextToken": "string",
666             "ReservedElasticsearchInstanceOfferings": [
667                 {
668                     "ReservedElasticsearchInstanceOfferingId": "string",
669                     "ElasticsearchInstanceType": "t2.medium.elasticsearch",
670                     "Duration": 123,
671                     "FixedPrice": 123.0,
672                     "UsagePrice": 123.0,
673                     "CurrencyCode": "string",
674                     "PaymentOption": "NO_UPFRONT",
675                     "RecurringCharges": [
676                         {
677                             "RecurringChargeAmount": 123.0,
678                             "RecurringChargeFrequency": "string",
679                         }
680                     ],
681                 }
682             ],
683         }
684         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
685             self.assertEqual(
686                 boto3_elasticsearch.describe_reserved_elasticsearch_instance_offerings(
687                     reserved_elasticsearch_instance_offering_id="foo", **CONN_PARAMETERS
688                 ),
689                 {
690                     "result": True,
691                     "response": ret_val["ReservedElasticsearchInstanceOfferings"],
692                 },
693             )
694     def test_describe_reserved_elasticsearch_instance_offerings_error(self):
695         """
696         Test that when calling describe_reserved_elasticsearch_instance_offerings
697         and boto3 returns an error, it returns {'result': False, 'error': 'the error'}.
698         """
699         with patch.object(
700             self.paginator,
701             "paginate",
702             side_effect=ClientError(
703                 ERROR_CONTENT, "describe_reserved_elasticsearch_instance_offerings"
704             ),
705         ):
706             result = (
707                 boto3_elasticsearch.describe_reserved_elasticsearch_instance_offerings(
708                     reserved_elasticsearch_instance_offering_id="foo", **CONN_PARAMETERS
709                 )
710             )
711             self.assertFalse(result["result"])
712             self.assertEqual(
713                 result.get("error", ""),
714                 ERROR_MESSAGE.format(
715                     101, "describe_reserved_elasticsearch_instance_offerings"
716                 ),
717             )
718     def test_describe_reserved_elasticsearch_instances_positive(self):
719         """
720         Test that when calling describe_reserved_elasticsearch_instances and it
721         succeeds, it returns {'result': True, 'response': some_value}.
722         """
723         ret_val = {
724             "NextToken": "string",
725             "ReservedElasticsearchInstances": [
726                 {
727                     "ReservationName": "string",
728                     "ReservedElasticsearchInstanceId": "string",
729                     "ReservedElasticsearchInstanceOfferingId": "string",
730                     "ElasticsearchInstanceType": "t2.medium.elasticsearch",
731                     "StartTime": datetime.datetime(2015, 1, 1),
732                     "Duration": 123,
733                     "FixedPrice": 123.0,
734                     "UsagePrice": 123.0,
735                     "CurrencyCode": "string",
736                     "ElasticsearchInstanceCount": 123,
737                     "State": "string",
738                     "PaymentOption": "ALL_UPFRONT",
739                     "RecurringCharges": [
740                         {
741                             "RecurringChargeAmount": 123.0,
742                             "RecurringChargeFrequency": "string",
743                         },
744                     ],
745                 },
746             ],
747         }
748         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
749             self.assertEqual(
750                 boto3_elasticsearch.describe_reserved_elasticsearch_instances(
751                     reserved_elasticsearch_instance_id="foo", **CONN_PARAMETERS
752                 ),
753                 {"result": True, "response": ret_val["ReservedElasticsearchInstances"]},
754             )
755     def test_describe_reserved_elasticsearch_instances_error(self):
756         """
757         Test that when calling describe_reserved_elasticsearch_instances and boto3
758         returns an error, it returns {'result': False, 'error': 'the error'}.
759         """
760         with patch.object(
761             self.paginator,
762             "paginate",
763             side_effect=ClientError(
764                 ERROR_CONTENT, "describe_reserved_elasticsearch_instances"
765             ),
766         ):
767             result = boto3_elasticsearch.describe_reserved_elasticsearch_instances(
768                 reserved_elasticsearch_instance_id="foo", **CONN_PARAMETERS
769             )
770             self.assertFalse(result["result"])
771             self.assertEqual(
772                 result.get("error", ""),
773                 ERROR_MESSAGE.format(101, "describe_reserved_elasticsearch_instances"),
774             )
775     def test_get_compatible_elasticsearch_versions_positive(self):
776         """
777         Test that when calling get_compatible_elasticsearch_versions and it
778         succeeds, it returns {'result': True, 'response': some_value}.
779         """
780         ret_val = {
781             "CompatibleElasticsearchVersions": [
782                 {"SourceVersion": "string", "TargetVersions": ["string"]}
783             ]
784         }
785         with patch.object(
786             self.conn, "get_compatible_elasticsearch_versions", return_value=ret_val
787         ):
788             self.assertEqual(
789                 boto3_elasticsearch.get_compatible_elasticsearch_versions(
790                     domain_name="testdomain", **CONN_PARAMETERS
791                 ),
792                 {
793                     "result": True,
794                     "response": ret_val["CompatibleElasticsearchVersions"],
795                 },
796             )
797     def test_get_compatible_elasticsearch_versions_error(self):
798         """
799         Test that when calling get_compatible_elasticsearch_versions and boto3
800         returns an error, it returns {'result': False, 'error': 'the error'}.
801         """
802         with patch.object(
803             self.conn,
804             "get_compatible_elasticsearch_versions",
805             side_effect=ClientError(
806                 ERROR_CONTENT, "get_compatible_elasticsearch_versions"
807             ),
808         ):
809             result = boto3_elasticsearch.get_compatible_elasticsearch_versions(
810                 domain_name="testdomain", **CONN_PARAMETERS
811             )
812             self.assertFalse(result["result"])
813             self.assertEqual(
814                 result.get("error", ""),
815                 ERROR_MESSAGE.format(101, "get_compatible_elasticsearch_versions"),
816             )
817     def test_get_upgrade_history_positive(self):
818         """
819         Test that when calling get_upgrade_history and it
820         succeeds, it returns {'result': True, 'response': some_value}.
821         """
822         ret_val = {
823             "UpgradeHistories": [
824                 {
825                     "UpgradeName": "string",
826                     "StartTimestamp": datetime.datetime(2015, 1, 1),
827                     "UpgradeStatus": "IN_PROGRESS",
828                     "StepsList": [
829                         {
830                             "UpgradeStep": "PRE_UPGRADE_CHECK",
831                             "UpgradeStepStatus": "IN_PROGRESS",
832                             "Issues": ["string"],
833                             "ProgressPercent": 123.0,
834                         }
835                     ],
836                 }
837             ],
838             "NextToken": "string",
839         }
840         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
841             self.assertEqual(
842                 boto3_elasticsearch.get_upgrade_history(
843                     domain_name="testdomain", **CONN_PARAMETERS
844                 ),
845                 {"result": True, "response": ret_val["UpgradeHistories"]},
846             )
847     def test_get_upgrade_history_error(self):
848         """
849         Test that when calling get_upgrade_history and boto3
850         returns an error, it returns {'result': False, 'error': 'the error'}.
851         """
852         with patch.object(
853             self.paginator,
854             "paginate",
855             side_effect=ClientError(ERROR_CONTENT, "get_upgrade_history"),
856         ):
857             result = boto3_elasticsearch.get_upgrade_history(
858                 domain_name="testdomain", **CONN_PARAMETERS
859             )
860             self.assertFalse(result["result"])
861             self.assertEqual(
862                 result.get("error", ""),
863                 ERROR_MESSAGE.format(101, "get_upgrade_history"),
864             )
865     def test_get_upgrade_status_positive(self):
866         """
867         Test that when calling get_upgrade_status and it
868         succeeds, it returns {'result': True, 'response': some_value}.
869         """
870         ret_val = {
871             "UpgradeStep": "PRE_UPGRADE_CHECK",
872             "StepStatus": "IN_PROGRESS",
873             "UpgradeName": "string",
874             "ResponseMetadata": None,
875         }
876         with patch.object(self.conn, "get_upgrade_status", return_value=ret_val):
877             self.assertEqual(
878                 boto3_elasticsearch.get_upgrade_status(
879                     domain_name="testdomain", **CONN_PARAMETERS
880                 ),
881                 {"result": True, "response": ret_val},
882             )
883     def test_get_upgrade_status_error(self):
884         """
885         Test that when calling get_upgrade_status and boto3
886         returns an error, it returns {'result': False, 'error': 'the error'}.
887         """
888         with patch.object(
889             self.conn,
890             "get_upgrade_status",
891             side_effect=ClientError(ERROR_CONTENT, "get_upgrade_status"),
892         ):
893             result = boto3_elasticsearch.get_upgrade_status(
894                 domain_name="testdomain", **CONN_PARAMETERS
895             )
896             self.assertFalse(result["result"])
897             self.assertEqual(
898                 result.get("error", ""), ERROR_MESSAGE.format(101, "get_upgrade_status")
899             )
900     def test_list_domain_names_positive(self):
901         """
902         Test that when calling list_domain_names and it
903         succeeds, it returns {'result': True, 'response': some_value}.
904         """
905         ret_val = {"DomainNames": [{"DomainName": "string"}]}
906         with patch.object(self.conn, "list_domain_names", return_value=ret_val):
907             self.assertEqual(
908                 boto3_elasticsearch.list_domain_names(**CONN_PARAMETERS),
909                 {
910                     "result": True,
911                     "response": [item["DomainName"] for item in ret_val["DomainNames"]],
912                 },
913             )
914     def test_list_domain_names_error(self):
915         """
916         Test that when calling list_domain_names and boto3
917         returns an error, it returns {'result': False, 'error': 'the error'}.
918         """
919         with patch.object(
920             self.conn,
921             "list_domain_names",
922             side_effect=ClientError(ERROR_CONTENT, "list_domain_names"),
923         ):
924             result = boto3_elasticsearch.list_domain_names(**CONN_PARAMETERS)
925             self.assertFalse(result["result"])
926             self.assertEqual(
927                 result.get("error", ""), ERROR_MESSAGE.format(101, "list_domain_names")
928             )
929     def test_list_elasticsearch_instance_types_positive(self):
930         """
931         Test that when calling list_elasticsearch_instance_types and it
932         succeeds, it returns {'result': True, 'response': some_value}.
933         """
934         ret_val = {
935             "ElasticsearchInstanceTypes": [
936                 "m3.medium.elasticsearch",
937                 "m3.large.elasticsearch",
938                 "m3.xlarge.elasticsearch",
939                 "m3.2xlarge.elasticsearch",
940                 "m4.large.elasticsearch",
941                 "m4.xlarge.elasticsearch",
942                 "m4.2xlarge.elasticsearch",
943                 "m4.4xlarge.elasticsearch",
944                 "m4.10xlarge.elasticsearch",
945                 "t2.micro.elasticsearch",
946                 "t2.small.elasticsearch",
947                 "t2.medium.elasticsearch",
948                 "r3.large.elasticsearch",
949                 "r3.xlarge.elasticsearch",
950                 "r3.2xlarge.elasticsearch",
951                 "r3.4xlarge.elasticsearch",
952                 "r3.8xlarge.elasticsearch",
953                 "i2.xlarge.elasticsearch",
954                 "i2.2xlarge.elasticsearch",
955                 "d2.xlarge.elasticsearch",
956                 "d2.2xlarge.elasticsearch",
957                 "d2.4xlarge.elasticsearch",
958                 "d2.8xlarge.elasticsearch",
959                 "c4.large.elasticsearch",
960                 "c4.xlarge.elasticsearch",
961                 "c4.2xlarge.elasticsearch",
962                 "c4.4xlarge.elasticsearch",
963                 "c4.8xlarge.elasticsearch",
964                 "r4.large.elasticsearch",
965                 "r4.xlarge.elasticsearch",
966                 "r4.2xlarge.elasticsearch",
967                 "r4.4xlarge.elasticsearch",
968                 "r4.8xlarge.elasticsearch",
969                 "r4.16xlarge.elasticsearch",
970                 "i3.large.elasticsearch",
971                 "i3.xlarge.elasticsearch",
972                 "i3.2xlarge.elasticsearch",
973                 "i3.4xlarge.elasticsearch",
974                 "i3.8xlarge.elasticsearch",
975                 "i3.16xlarge.elasticsearch",
976             ],
977             "NextToken": "string",
978         }
979         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
980             self.assertEqual(
981                 boto3_elasticsearch.list_elasticsearch_instance_types(
982                     elasticsearch_version="1.0", **CONN_PARAMETERS
983                 ),
984                 {"result": True, "response": ret_val["ElasticsearchInstanceTypes"]},
985             )
986     def test_list_elasticsearch_instance_types_error(self):
987         """
988         Test that when calling list_elasticsearch_instance_types and boto3
989         returns an error, it returns {'result': False, 'error': 'the error'}.
990         """
991         with patch.object(
992             self.paginator,
993             "paginate",
994             side_effect=ClientError(ERROR_CONTENT, "list_elasticsearch_instance_types"),
995         ):
996             result = boto3_elasticsearch.list_elasticsearch_instance_types(
997                 elasticsearch_version="1.0", **CONN_PARAMETERS
998             )
999             self.assertFalse(result["result"])
1000             self.assertEqual(
1001                 result.get("error", ""),
1002                 ERROR_MESSAGE.format(101, "list_elasticsearch_instance_types"),
1003             )
1004     def test_list_elasticsearch_versions_positive(self):
1005         """
1006         Test that when calling list_elasticsearch_versions and it
1007         succeeds, it returns {'result': True, 'response': some_value}.
1008         """
1009         ret_val = {"ElasticsearchVersions": ["string"], "NextToken": "string"}
1010         with patch.object(self.paginator, "paginate", return_value=[ret_val]):
1011             self.assertEqual(
1012                 boto3_elasticsearch.list_elasticsearch_versions(**CONN_PARAMETERS),
1013                 {"result": True, "response": ret_val["ElasticsearchVersions"]},
1014             )
1015     def test_list_elasticsearch_versions_error(self):
1016         """
1017         Test that when calling list_elasticsearch_versions and boto3
1018         returns an error, it returns {'result': False, 'error': 'the error'}.
1019         """
1020         with patch.object(
1021             self.paginator,
1022             "paginate",
1023             side_effect=ClientError(ERROR_CONTENT, "list_elasticsearch_versions"),
1024         ):
1025             result = boto3_elasticsearch.list_elasticsearch_versions(**CONN_PARAMETERS)
1026             self.assertFalse(result["result"])
1027             self.assertEqual(
1028                 result.get("error", ""),
1029                 ERROR_MESSAGE.format(101, "list_elasticsearch_versions"),
1030             )
1031     def test_purchase_reserved_elasticsearch_instance_offering_positive(self):
1032         """
1033         Test that when calling purchase_reserved_elasticsearch_instance_offering and it
1034         succeeds, it returns {'result': True, 'response': some_value}.
1035         """
1036         ret_val = {
1037             "ReservedElasticsearchInstanceId": "string",
1038             "ReservationName": "string",
1039         }
1040         with patch.object(
1041             self.conn,
1042             "purchase_reserved_elasticsearch_instance_offering",
1043             return_value=ret_val,
1044         ):
1045             self.assertEqual(
1046                 boto3_elasticsearch.purchase_reserved_elasticsearch_instance_offering(
1047                     reserved_elasticsearch_instance_offering_id="foo",
1048                     reservation_name="bar",
1049                     **CONN_PARAMETERS
1050                 ),
1051                 {"result": True, "response": ret_val},
1052             )
1053     def test_purchase_reserved_elasticsearch_instance_offering_error(self):
1054         """
1055         Test that when calling purchase_reserved_elasticsearch_instance_offering and boto3
1056         returns an error, it returns {'result': False, 'error': 'the error'}.
1057         """
1058         with patch.object(
1059             self.conn,
1060             "purchase_reserved_elasticsearch_instance_offering",
1061             side_effect=ClientError(
1062                 ERROR_CONTENT, "purchase_reserved_elasticsearch_instance_offering"
1063             ),
1064         ):
1065             result = (
1066                 boto3_elasticsearch.purchase_reserved_elasticsearch_instance_offering(
1067                     reserved_elasticsearch_instance_offering_id="foo",
1068                     reservation_name="bar",
1069                     **CONN_PARAMETERS
1070                 )
1071             )
1072             self.assertFalse(result["result"])
1073             self.assertEqual(
1074                 result.get("error", ""),
1075                 ERROR_MESSAGE.format(
1076                     101, "purchase_reserved_elasticsearch_instance_offering"
1077                 ),
1078             )
1079     def test_start_elasticsearch_service_software_update_positive(self):
1080         """
1081         Test that when calling start_elasticsearch_service_software_update and it
1082         succeeds, it returns {'result': True, 'response': some_value}.
1083         """
1084         ret_val = {
1085             "ServiceSoftwareOptions": {
1086                 "CurrentVersion": "string",
1087                 "NewVersion": "string",
1088                 "UpdateAvailable": True,
1089                 "Cancellable": True,
1090                 "UpdateStatus": "PENDING_UPDATE",
1091                 "Description": "string",
1092                 "AutomatedUpdateDate": datetime.datetime(2015, 1, 1),
1093             }
1094         }
1095         with patch.object(
1096             self.conn,
1097             "start_elasticsearch_service_software_update",
1098             return_value=ret_val,
1099         ):
1100             self.assertEqual(
1101                 boto3_elasticsearch.start_elasticsearch_service_software_update(
1102                     domain_name="testdomain", **CONN_PARAMETERS
1103                 ),
1104                 {"result": True, "response": ret_val["ServiceSoftwareOptions"]},
1105             )
1106     def test_start_elasticsearch_service_software_update_error(self):
1107         """
1108         Test that when calling start_elasticsearch_service_software_update and boto3
1109         returns an error, it returns {'result': False, 'error': 'the error'}.
1110         """
1111         with patch.object(
1112             self.conn,
1113             "start_elasticsearch_service_software_update",
1114             side_effect=ClientError(
1115                 ERROR_CONTENT, "start_elasticsearch_service_software_update"
1116             ),
1117         ):
1118             result = boto3_elasticsearch.start_elasticsearch_service_software_update(
1119                 domain_name="testdomain", **CONN_PARAMETERS
1120             )
1121             self.assertFalse(result["result"])
1122             self.assertEqual(
1123                 result.get("error", ""),
1124                 ERROR_MESSAGE.format(
1125                     101, "start_elasticsearch_service_software_update"
1126                 ),
1127             )
1128     def test_upgrade_elasticsearch_domain_positive(self):
1129         """
1130         Test that when calling upgrade_elasticsearch_domain and it
1131         succeeds, it returns {'result': True, 'response': some_value}.
1132         """
1133         ret_val = {
1134             "DomainName": "string",
1135             "TargetVersion": "string",
1136             "PerformCheckOnly": True,
1137         }
1138         with patch.object(
1139             self.conn, "upgrade_elasticsearch_domain", return_value=ret_val
1140         ):
1141             self.assertEqual(
1142                 boto3_elasticsearch.upgrade_elasticsearch_domain(
1143                     domain_name="testdomain", target_version="1.1", **CONN_PARAMETERS
1144                 ),
1145                 {"result": True, "response": ret_val},
1146             )
1147     def test_upgrade_elasticsearch_domain_error(self):
1148         """
1149         Test that when calling upgrade_elasticsearch_domain and boto3
1150         returns an error, it returns {'result': False, 'error': 'the error'}.
1151         """
1152         with patch.object(
1153             self.conn,
1154             "upgrade_elasticsearch_domain",
1155             side_effect=ClientError(ERROR_CONTENT, "upgrade_elasticsearch_domain"),
1156         ):
1157             result = boto3_elasticsearch.upgrade_elasticsearch_domain(
1158                 domain_name="testdomain", target_version="1.1", **CONN_PARAMETERS
1159             )
1160             self.assertFalse(result["result"])
1161             self.assertEqual(
1162                 result.get("error", ""),
1163                 ERROR_MESSAGE.format(101, "upgrade_elasticsearch_domain"),
1164             )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ioloop_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 import contextlib
3 import datetime
4 import socket
5 import sys
6 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import threading
7 import time
8 import types
9 from salt.ext.tornado import gen
10 from salt.ext.tornado.ioloop import IOLoop, TimeoutError, PollIOLoop, PeriodicCallback
11 from salt.ext.tornado.log import app_log
12 from salt.ext.tornado.platform.select import _Select
13 from salt.ext.tornado.stack_context import ExceptionStackContext, StackContext, wrap, NullContext
14 from salt.ext.tornado.testing import AsyncTestCase, bind_unused_port, ExpectLog
15 from salt.ext.tornado.test.util import unittest, skipIfNonUnix, skipOnTravis, skipBefore35, exec_test
16 try:
17     from</b></font> concurrent import futures
18 except ImportError:
19     futures = None
20 class FakeTimeSelect(_Select):
21     def __init__(self):
22         self._time = 1000
23         super(FakeTimeSelect, self).__init__()
24     def time(self):
25         return self._time
26     def sleep(self, t):
27         self._time += t
28     def poll(self, timeout):
29         events = super(FakeTimeSelect, self).poll(0)
30         if events:
31             return events
32         self._time += timeout
33         return []
34 class FakeTimeIOLoop(PollIOLoop):
35     """IOLoop implementation with a fake and deterministic clock.
36     The clock advances as needed to trigger timeouts immediately.
37     For use when testing code that involves the passage of time
38     and no external dependencies.
39     """
40     def initialize(self):
41         self.fts = FakeTimeSelect()
42         super(FakeTimeIOLoop, self).initialize(impl=self.fts,
43                                                time_func=self.fts.time)
44     def sleep(self, t):
45         self.fts.sleep(t)
46 class TestIOLoop(AsyncTestCase):
47     def test_add_callback_return_sequence(self):
48         self.calls = 0
49         loop = self.io_loop
50         test = self
51         old_add_callback = loop.add_callback
52         def add_callback(self, callback, *args, **kwargs):
53             test.calls += 1
54             old_add_callback(callback, *args, **kwargs)
55         loop.add_callback = types.MethodType(add_callback, loop)
56         loop.add_callback(lambda: {})
57         loop.add_callback(lambda: [])
58         loop.add_timeout(datetime.timedelta(milliseconds=50), loop.stop)
59         loop.start()
60         self.assertLess(self.calls, 10)
61     @skipOnTravis
62     def test_add_callback_wakeup(self):
63         def callback():
64             self.called = True
65             self.stop()
66         def schedule_callback():
67             self.called = False
68             self.io_loop.add_callback(callback)
69             self.start_time = time.time()
70         self.io_loop.add_timeout(self.io_loop.time(), schedule_callback)
71         self.wait()
72         self.assertAlmostEqual(time.time(), self.start_time, places=2)
73         self.assertTrue(self.called)
74     @skipOnTravis
75     def test_add_callback_wakeup_other_thread(self):
76         def target():
77             time.sleep(0.01)
78             self.stop_time = time.time()
79             self.io_loop.add_callback(self.stop)
80         thread = threading.Thread(target=target)
81         self.io_loop.add_callback(thread.start)
82         self.wait()
83         delta = time.time() - self.stop_time
84         self.assertLess(delta, 0.1)
85         thread.join()
86     def test_add_timeout_timedelta(self):
87         self.io_loop.add_timeout(datetime.timedelta(microseconds=1), self.stop)
88         self.wait()
89     def test_multiple_add(self):
90         sock, port = bind_unused_port()
91         try:
92             self.io_loop.add_handler(sock.fileno(), lambda fd, events: None,
93                                      IOLoop.READ)
94             self.assertRaises(Exception, self.io_loop.add_handler,
95                               sock.fileno(), lambda fd, events: None,
96                               IOLoop.READ)
97         finally:
98             self.io_loop.remove_handler(sock.fileno())
99             sock.close()
100     def test_remove_without_add(self):
101         sock, port = bind_unused_port()
102         try:
103             self.io_loop.remove_handler(sock.fileno())
104         finally:
105             sock.close()
106     def test_add_callback_from_signal(self):
107         self.io_loop.add_callback_from_signal(self.stop)
108         self.wait()
109     def test_add_callback_from_signal_other_thread(self):
110         other_ioloop = IOLoop()
111         thread = threading.Thread(target=other_ioloop.start)
112         thread.start()
113         other_ioloop.add_callback_from_signal(other_ioloop.stop)
114         thread.join()
115         other_ioloop.close()
116     def test_add_callback_while_closing(self):
117         if IOLoop.configured_class().__name__.endswith('AsyncIOLoop'):
118             raise unittest.SkipTest("AsyncIOMainLoop shutdown not thread safe")
119         closing = threading.Event()
120         def target():
121             other_ioloop.add_callback(other_ioloop.stop)
122             other_ioloop.start()
123             closing.set()
124             other_ioloop.close(all_fds=True)
125         other_ioloop = IOLoop()
126         thread = threading.Thread(target=target)
127         thread.start()
128         closing.wait()
129         for i in range(1000):
130             try:
131                 other_ioloop.add_callback(lambda: None)
132             except RuntimeError as e:
133                 self.assertEqual("IOLoop is closing", str(e))
134                 break
135     def test_handle_callback_exception(self):
136         def handle_callback_exception(callback):
137             self.assertIs(sys.exc_info()[0], ZeroDivisionError)
138             self.stop()
139         self.io_loop.handle_callback_exception = handle_callback_exception
140         with NullContext():
141             self.io_loop.add_callback(lambda: 1 / 0)
142         self.wait()
143     @skipIfNonUnix  # just because socketpair is so convenient
144     def test_read_while_writeable(self):
145         client, server = socket.socketpair()
146         try:
147             def handler(fd, events):
148                 self.assertEqual(events, IOLoop.READ)
149                 self.stop()
150             self.io_loop.add_handler(client.fileno(), handler, IOLoop.READ)
151             self.io_loop.add_timeout(self.io_loop.time() + 0.01,
152                                      functools.partial(server.send, b'asdf'))
153             self.wait()
154             self.io_loop.remove_handler(client.fileno())
155         finally:
156             client.close()
157             server.close()
158     def test_remove_timeout_after_fire(self):
159         handle = self.io_loop.add_timeout(self.io_loop.time(), self.stop)
160         self.wait()
161         self.io_loop.remove_timeout(handle)
162     def test_remove_timeout_cleanup(self):
163         for i in range(2000):
164             timeout = self.io_loop.add_timeout(self.io_loop.time() + 3600,
165                                                lambda: None)
166             self.io_loop.remove_timeout(timeout)
167         self.io_loop.add_callback(lambda: self.io_loop.add_callback(self.stop))
168         self.wait()
169     def test_remove_timeout_from_timeout(self):
170         calls = [False, False]
171         now = self.io_loop.time()
172         def t1():
173             calls[0] = True
174             self.io_loop.remove_timeout(t2_handle)
175         self.io_loop.add_timeout(now + 0.01, t1)
176         def t2():
177             calls[1] = True
178         t2_handle = self.io_loop.add_timeout(now + 0.02, t2)
179         self.io_loop.add_timeout(now + 0.03, self.stop)
180         time.sleep(0.03)
181         self.wait()
182         self.assertEqual(calls, [True, False])
183     def test_timeout_with_arguments(self):
184         results = []
185         self.io_loop.add_timeout(self.io_loop.time(), results.append, 1)
186         self.io_loop.add_timeout(datetime.timedelta(seconds=0),
187                                  results.append, 2)
188         self.io_loop.call_at(self.io_loop.time(), results.append, 3)
189         self.io_loop.call_later(0, results.append, 4)
190         self.io_loop.call_later(0, self.stop)
191         self.wait()
192         self.assertEqual(results, [1, 2, 3, 4])
193     def test_add_timeout_return(self):
194         handle = self.io_loop.add_timeout(self.io_loop.time(), lambda: None)
195         self.assertFalse(handle is None)
196         self.io_loop.remove_timeout(handle)
197     def test_call_at_return(self):
198         handle = self.io_loop.call_at(self.io_loop.time(), lambda: None)
199         self.assertFalse(handle is None)
200         self.io_loop.remove_timeout(handle)
201     def test_call_later_return(self):
202         handle = self.io_loop.call_later(0, lambda: None)
203         self.assertFalse(handle is None)
204         self.io_loop.remove_timeout(handle)
205     def test_close_file_object(self):
206         """When a file object is used instead of a numeric file descriptor,
207         the object should be closed (by IOLoop.close(all_fds=True),
208         not just the fd.
209         """
210         class SocketWrapper(object):
211             def __init__(self, sockobj):
212                 self.sockobj = sockobj
213                 self.closed = False
214             def fileno(self):
215                 return self.sockobj.fileno()
216             def close(self):
217                 self.closed = True
218                 self.sockobj.close()
219         sockobj, port = bind_unused_port()
220         socket_wrapper = SocketWrapper(sockobj)
221         io_loop = IOLoop()
222         io_loop.add_handler(socket_wrapper, lambda fd, events: None,
223                             IOLoop.READ)
224         io_loop.close(all_fds=True)
225         self.assertTrue(socket_wrapper.closed)
226     def test_handler_callback_file_object(self):
227         server_sock, port = bind_unused_port()
228         fds = []
229         def handle_connection(fd, events):
230             fds.append(fd)
231             conn, addr = server_sock.accept()
232             conn.close()
233             self.stop()
234         self.io_loop.add_handler(server_sock, handle_connection, IOLoop.READ)
235         with contextlib.closing(socket.socket()) as client_sock:
236             client_sock.connect(('127.0.0.1', port))
237             self.wait()
238         self.io_loop.remove_handler(server_sock)
239         self.io_loop.add_handler(server_sock.fileno(), handle_connection,
240                                  IOLoop.READ)
241         with contextlib.closing(socket.socket()) as client_sock:
242             client_sock.connect(('127.0.0.1', port))
243             self.wait()
244         self.assertIs(fds[0], server_sock)
245         self.assertEqual(fds[1], server_sock.fileno())
246         self.io_loop.remove_handler(server_sock.fileno())
247         server_sock.close()
248     def test_mixed_fd_fileobj(self):
249         server_sock, port = bind_unused_port()
250         def f(fd, events):
251             pass
252         self.io_loop.add_handler(server_sock, f, IOLoop.READ)
253         with self.assertRaises(Exception):
254             self.io_loop.add_handler(server_sock.fileno(), f, IOLoop.READ)
255         self.io_loop.remove_handler(server_sock.fileno())
256         server_sock.close()
257     def test_reentrant(self):
258         returned_from_start = [False]
259         got_exception = [False]
260         def callback():
261             try:
262                 self.io_loop.start()
263                 returned_from_start[0] = True
264             except Exception:
265                 got_exception[0] = True
266             self.stop()
267         self.io_loop.add_callback(callback)
268         self.wait()
269         self.assertTrue(got_exception[0])
270         self.assertFalse(returned_from_start[0])
271     def test_exception_logging(self):
272         with NullContext():
273             self.io_loop.add_callback(lambda: 1 / 0)
274             self.io_loop.add_callback(self.stop)
275             with ExpectLog(app_log, "Exception in callback"):
276                 self.wait()
277     def test_exception_logging_future(self):
278         with NullContext():
279             @gen.coroutine
280             def callback():
281                 self.io_loop.add_callback(self.stop)
282                 1 / 0
283             self.io_loop.add_callback(callback)
284             with ExpectLog(app_log, "Exception in callback"):
285                 self.wait()
286     @skipBefore35
287     def test_exception_logging_native_coro(self):
288         namespace = exec_test(globals(), locals(), """
289         async def callback():
290             self.io_loop.add_callback(self.stop)
291             1 / 0
292         """)
293         with NullContext():
294             self.io_loop.add_callback(namespace["callback"])
295             with ExpectLog(app_log, "Exception in callback"):
296                 self.wait()
297     def test_spawn_callback(self):
298         self.io_loop.add_callback(lambda: 1 / 0)
299         with self.assertRaises(ZeroDivisionError):
300             self.wait()
301         self.io_loop.spawn_callback(lambda: 1 / 0)
302         self.io_loop.add_callback(self.stop)
303         with ExpectLog(app_log, "Exception in callback"):
304             self.wait()
305     @skipIfNonUnix
306     def test_remove_handler_from_handler(self):
307         client, server = socket.socketpair()
308         try:
309             client.send(b'abc')
310             server.send(b'abc')
311             chunks = []
312             def handle_read(fd, events):
313                 chunks.append(fd.recv(1024))
314                 if fd is client:
315                     self.io_loop.remove_handler(server)
316                 else:
317                     self.io_loop.remove_handler(client)
318             self.io_loop.add_handler(client, handle_read, self.io_loop.READ)
319             self.io_loop.add_handler(server, handle_read, self.io_loop.READ)
320             self.io_loop.call_later(0.1, self.stop)
321             self.wait()
322             self.assertEqual(chunks, [b'abc'])
323         finally:
324             client.close()
325             server.close()
326 class TestIOLoopCurrent(unittest.TestCase):
327     def setUp(self):
328         self.io_loop = None
329         IOLoop.clear_current()
330     def tearDown(self):
331         if self.io_loop is not None:
332             self.io_loop.close()
333     def test_default_current(self):
334         self.io_loop = IOLoop()
335         self.assertIs(self.io_loop, IOLoop.current())
336         io_loop2 = IOLoop()
337         self.assertIs(self.io_loop, IOLoop.current())
338         io_loop2.close()
339     def test_non_current(self):
340         self.io_loop = IOLoop(make_current=False)
341         self.assertIsNone(IOLoop.current(instance=False))
342         for i in range(3):
343             def f():
344                 self.current_io_loop = IOLoop.current()
345                 self.io_loop.stop()
346             self.io_loop.add_callback(f)
347             self.io_loop.start()
348             self.assertIs(self.current_io_loop, self.io_loop)
349             self.assertIsNone(IOLoop.current(instance=False))
350     def test_force_current(self):
351         self.io_loop = IOLoop(make_current=True)
352         self.assertIs(self.io_loop, IOLoop.current())
353         with self.assertRaises(RuntimeError):
354             IOLoop(make_current=True)
355         self.assertIs(self.io_loop, IOLoop.current())
356 class TestIOLoopAddCallback(AsyncTestCase):
357     def setUp(self):
358         super(TestIOLoopAddCallback, self).setUp()
359         self.active_contexts = []
360     def add_callback(self, callback, *args, **kwargs):
361         self.io_loop.add_callback(callback, *args, **kwargs)
362     @contextlib.contextmanager
363     def context(self, name):
364         self.active_contexts.append(name)
365         yield
366         self.assertEqual(self.active_contexts.pop(), name)
367     def test_pre_wrap(self):
368         def f1():
369             self.assertIn('c1', self.active_contexts)
370             self.assertNotIn('c2', self.active_contexts)
371             self.stop()
372         with StackContext(functools.partial(self.context, 'c1')):
373             wrapped = wrap(f1)
374         with StackContext(functools.partial(self.context, 'c2')):
375             self.add_callback(wrapped)
376         self.wait()
377     def test_pre_wrap_with_args(self):
378         def f1(foo, bar):
379             self.assertIn('c1', self.active_contexts)
380             self.assertNotIn('c2', self.active_contexts)
381             self.stop((foo, bar))
382         with StackContext(functools.partial(self.context, 'c1')):
383             wrapped = wrap(f1)
384         with StackContext(functools.partial(self.context, 'c2')):
385             self.add_callback(wrapped, 1, bar=2)
386         result = self.wait()
387         self.assertEqual(result, (1, 2))
388 class TestIOLoopAddCallbackFromSignal(TestIOLoopAddCallback):
389     def add_callback(self, callback, *args, **kwargs):
390         self.io_loop.add_callback_from_signal(callback, *args, **kwargs)
391 @unittest.skipIf(futures is None, "futures module not present")
392 class TestIOLoopFutures(AsyncTestCase):
393         with futures.ThreadPoolExecutor(1) as pool:
394             self.io_loop.add_future(pool.submit(lambda: None),
395                                     lambda future: self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.stop(future))
396             future = self.wait()
397             self.assertTrue(future.done())
398             self.assertTrue(future.</b></font>result() is None)
399     def test_add_future_stack_context(self):
400         ready = threading.Event()
401         def task():
402             ready.wait(1)
403             assert ready.isSet(), "timed out"
404             raise Exception("worker")
405         def callback(future):
406             self.future = future
407             raise Exception("callback")
408         def handle_exception(typ, value, traceback):
409             self.exception = value
410             self.stop()
411             return True
412         with futures.ThreadPoolExecutor(1) as pool:
413             with ExceptionStackContext(handle_exception):
414                 self.io_loop.add_future(pool.submit(task), callback)
415             ready.set()
416         self.wait()
417         self.assertEqual(self.exception.args[0], "callback")
418         self.assertEqual(self.future.exception().args[0], "worker")
419 class TestIOLoopRunSync(unittest.TestCase):
420     def setUp(self):
421         self.io_loop = IOLoop()
422     def tearDown(self):
423         self.io_loop.close()
424     def test_sync_result(self):
425         with self.assertRaises(gen.BadYieldError):
426             self.io_loop.run_sync(lambda: 42)
427     def test_sync_exception(self):
428         with self.assertRaises(ZeroDivisionError):
429             self.io_loop.run_sync(lambda: 1 / 0)
430     def test_async_result(self):
431         @gen.coroutine
432         def f():
433             yield gen.Task(self.io_loop.add_callback)
434             raise gen.Return(42)
435         self.assertEqual(self.io_loop.run_sync(f), 42)
436     def test_async_exception(self):
437         @gen.coroutine
438         def f():
439             yield gen.Task(self.io_loop.add_callback)
440             1 / 0
441         with self.assertRaises(ZeroDivisionError):
442             self.io_loop.run_sync(f)
443     def test_current(self):
444         def f():
445             self.assertIs(IOLoop.current(), self.io_loop)
446         self.io_loop.run_sync(f)
447     def test_timeout(self):
448         @gen.coroutine
449         def f():
450             yield gen.Task(self.io_loop.add_timeout, self.io_loop.time() + 1)
451         self.assertRaises(TimeoutError, self.io_loop.run_sync, f, timeout=0.01)
452     @skipBefore35
453     def test_native_coroutine(self):
454         namespace = exec_test(globals(), locals(), """
455         async def f():
456             await gen.Task(self.io_loop.add_callback)
457         """)
458         self.io_loop.run_sync(namespace['f'])
459 class TestPeriodicCallback(unittest.TestCase):
460     def setUp(self):
461         self.io_loop = FakeTimeIOLoop()
462         self.io_loop.make_current()
463     def tearDown(self):
464         self.io_loop.close()
465     def test_basic(self):
466         calls = []
467         def cb():
468             calls.append(self.io_loop.time())
469         pc = PeriodicCallback(cb, 10000)
470         pc.start()
471         self.io_loop.call_later(50, self.io_loop.stop)
472         self.io_loop.start()
473         self.assertEqual(calls, [1010, 1020, 1030, 1040, 1050])
474     def test_overrun(self):
475         sleep_durations = [9, 9, 10, 11, 20, 20, 35, 35, 0, 0]
476         expected = [
477             1010, 1020, 1030,  # first 3 calls on schedule
478             1050, 1070,  # next 2 delayed one cycle
479             1100, 1130,  # next 2 delayed 2 cycles
480             1170, 1210,  # next 2 delayed 3 cycles
481             1220, 1230,  # then back on schedule.
482         ]
483         calls = []
484         def cb():
485             calls.append(self.io_loop.time())
486             if not sleep_durations:
487                 self.io_loop.stop()
488                 return
489             self.io_loop.sleep(sleep_durations.pop(0))
490         pc = PeriodicCallback(cb, 10000)
491         pc.start()
492         self.io_loop.start()
493         self.assertEqual(calls, expected)
494 if __name__ == "__main__":
495     unittest.main()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
