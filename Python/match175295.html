<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_boto3_elasticsearch.py & ioloop_test.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_boto3_elasticsearch.py & ioloop_test.py
      </h3>
      <h1 align="center">
        1.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_boto3_elasticsearch.py (2.108963%)<TH>ioloop_test.py (1.8447348%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match175295-0.html#0',2,'match175295-1.html#0',3)" NAME="0">(197-204)<TD><A HREF="javascript:ZweiFrames('match175295-0.html#0',2,'match175295-1.html#0',3)" NAME="0">(551-554)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match175295-0.html#1',2,'match175295-1.html#1',3)" NAME="1">(6-19)<TD><A HREF="javascript:ZweiFrames('match175295-0.html#1',2,'match175295-1.html#1',3)" NAME="1">(11-24)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto3_elasticsearch.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    Tests for salt.modules.boto3_elasticsearch
<A NAME="1"></A>&quot;&quot;&quot;


<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match175295-1.html#1',3,'match175295-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import datetime
import random
import string
import textwrap

import salt.loader
import salt.modules.boto3_elasticsearch as boto3_elasticsearch
from salt.utils.versions import LooseVersion
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf

try:
    import</B></FONT> boto3
    from botocore.exceptions import ClientError

    HAS_BOTO3 = True
except ImportError:
    HAS_BOTO3 = False

# the boto3_elasticsearch module relies on the connect_to_region() method
# which was added in boto 2.8.0
# https://github.com/boto/boto/commit/33ac26b416fbb48a60602542b4ce15dcc7029f12
REQUIRED_BOTO3_VERSION = &quot;1.2.1&quot;


def __virtual__():
    &quot;&quot;&quot;
    Returns True/False boolean depending on if Boto3 is installed and correct
    version.
    &quot;&quot;&quot;
    if not HAS_BOTO3:
        return False
    if LooseVersion(boto3.__version__) &lt; LooseVersion(REQUIRED_BOTO3_VERSION):
        return (
            False,
            &quot;The boto3 module must be greater or equal to version {}&quot;.format(
                REQUIRED_BOTO3_VERSION
            ),
        )
    return True


REGION = &quot;us-east-1&quot;
ACCESS_KEY = &quot;GKTADJGHEIQSXMKKRBJ08H&quot;
SECRET_KEY = &quot;askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs&quot;
CONN_PARAMETERS = {
    &quot;region&quot;: REGION,
    &quot;key&quot;: ACCESS_KEY,
    &quot;keyid&quot;: SECRET_KEY,
    &quot;profile&quot;: {},
}
ERROR_MESSAGE = (
    &quot;An error occurred ({}) when calling the {} operation: Test-defined error&quot;
)
ERROR_CONTENT = {&quot;Error&quot;: {&quot;Code&quot;: 101, &quot;Message&quot;: &quot;Test-defined error&quot;}}
NOT_FOUND_ERROR = ClientError(
    {&quot;Error&quot;: {&quot;Code&quot;: &quot;ResourceNotFoundException&quot;, &quot;Message&quot;: &quot;Test-defined error&quot;}},
    &quot;msg&quot;,
)
DOMAIN_RET = {
    &quot;DomainId&quot;: &quot;accountno/testdomain&quot;,
    &quot;DomainName&quot;: &quot;testdomain&quot;,
    &quot;ARN&quot;: &quot;arn:aws:es:region:accountno:domain/testdomain&quot;,
    &quot;Created&quot;: True,
    &quot;Deleted&quot;: False,
    &quot;Endpoints&quot;: {&quot;vpc&quot;: &quot;vpc-testdomain-1234567890.region.es.amazonaws.com&quot;},
    &quot;Processing&quot;: False,
    &quot;UpgradeProcessing&quot;: False,
    &quot;ElasticsearchVersion&quot;: &quot;6.3&quot;,
    &quot;ElasticsearchClusterConfig&quot;: {
        &quot;InstanceType&quot;: &quot;t2.medium.elasticsearch&quot;,
        &quot;InstanceCount&quot;: 1,
        &quot;DedicatedMasterEnabled&quot;: False,
        &quot;ZoneAwarenessEnabled&quot;: False,
    },
    &quot;EBSOptions&quot;: {
        &quot;EBSEnabled&quot;: True,
        &quot;VolumeType&quot;: &quot;gp2&quot;,
        &quot;VolumeSize&quot;: 123,
        &quot;Iops&quot;: 12,
    },
    &quot;AccessPolicies&quot;: textwrap.dedent(
        &quot;&quot;&quot;
        {&quot;Version&quot;:&quot;2012-10-17&quot;,&quot;Statement&quot;:[{&quot;Effect&quot;:&quot;Allow&quot;,
        &quot;Principal&quot;:{&quot;AWS&quot;:&quot;*&quot;},&quot;Action&quot;:&quot;es:*&quot;,
        &quot;Resource&quot;:&quot;arn:aws:es:region:accountno:domain/testdomain/*&quot;}]}&quot;&quot;&quot;
    ),
    &quot;SnapshotOptions&quot;: {&quot;AutomatedSnapshotStartHour&quot;: 1},
    &quot;VPCOptions&quot;: {
        &quot;VPCId&quot;: &quot;vpc-12345678&quot;,
        &quot;SubnetIds&quot;: [&quot;subnet-deadbeef&quot;],
        &quot;AvailabilityZones&quot;: [&quot;regiona&quot;],
        &quot;SecurityGroupIds&quot;: [&quot;sg-87654321&quot;],
    },
    &quot;CognitoOptions&quot;: {&quot;Enabled&quot;: False},
    &quot;EncryptionAtRestOptions&quot;: {&quot;Enabled&quot;: False},
    &quot;NodeToNodeEncryptionOptions&quot;: {&quot;Enabled&quot;: False},
    &quot;AdvancedOptions&quot;: {&quot;rest.action.multi.allow_explicit_index&quot;: &quot;true&quot;},
    &quot;ServiceSoftwareOptions&quot;: {
        &quot;CurrentVersion&quot;: &quot;R20190221-P1&quot;,
        &quot;NewVersion&quot;: &quot;R20190418&quot;,
        &quot;UpdateAvailable&quot;: True,
        &quot;Cancellable&quot;: False,
        &quot;UpdateStatus&quot;: &quot;ELIGIBLE&quot;,
        &quot;Description&quot;: (
            &quot;A newer release R20190418 is available. This release &quot;
            &quot;will be automatically deployed after somedate&quot;
        ),
        &quot;AutomatedUpdateDate&quot;: None,
    },
}


@skipIf(HAS_BOTO3 is False, &quot;The boto module must be installed.&quot;)
@skipIf(
    LooseVersion(boto3.__version__) &lt; LooseVersion(REQUIRED_BOTO3_VERSION),
    &quot;The boto3 module must be greater or equal to version {}&quot;.format(
        REQUIRED_BOTO3_VERSION
    ),
)
class Boto3ElasticsearchTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    TestCase for salt.modules.boto3_elasticsearch module
    &quot;&quot;&quot;

    conn = None

    def setup_loader_modules(self):
        self.opts = salt.config.DEFAULT_MINION_OPTS.copy()
        utils = salt.loader.utils(
            self.opts,
            whitelist=[&quot;boto3&quot;, &quot;args&quot;, &quot;systemd&quot;, &quot;path&quot;, &quot;platform&quot;],
            context={},
        )
        return {boto3_elasticsearch: {&quot;__utils__&quot;: utils}}

    def setUp(self):
        super().setUp()
        boto3_elasticsearch.__init__(self.opts)
        del self.opts

        # Set up MagicMock to replace the boto3 session
        # connections keep getting cached from prior tests, can't find the
        # correct context object to clear it. So randomize the cache key, to prevent any
        # cache hits
        CONN_PARAMETERS[&quot;key&quot;] = &quot;&quot;.join(
            random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
        )

        self.conn = MagicMock()
        self.addCleanup(delattr, self, &quot;conn&quot;)
        self.patcher = patch(&quot;boto3.session.Session&quot;)
        self.addCleanup(self.patcher.stop)
        self.addCleanup(delattr, self, &quot;patcher&quot;)
        mock_session = self.patcher.start()
        session_instance = mock_session.return_value
        session_instance.configure_mock(client=MagicMock(return_value=self.conn))
        self.paginator = MagicMock()
        self.addCleanup(delattr, self, &quot;paginator&quot;)
        self.conn.configure_mock(get_paginator=MagicMock(return_value=self.paginator))

    def test_describe_elasticsearch_domain_positive(self):
        &quot;&quot;&quot;
        Test that when describing a domain when the domain actually exists,
        the .exists method returns a dict with 'result': True
        and 'response' with the domain status information.
        &quot;&quot;&quot;
        # The patch below is not neccesary per se,
        # as .exists returns positive as long as no exception is raised.
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain&quot;,
            return_value={&quot;DomainStatus&quot;: DOMAIN_RET},
        ):
            self.assertEqual(
                boto3_elasticsearch.describe_elasticsearch_domain(
                    domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: DOMAIN_RET},
            )

    def test_describe_elasticsearch_domain_error(self):
        &quot;&quot;&quot;
        Test that when describing a domain when the domain does not exist,
        the .exists method returns a dict with 'result': False
        and 'error' with boto's ResourceNotFoundException.
        &quot;&quot;&quot;
<A NAME="0"></A>        with patch.object(
            self.conn, &quot;describe_elasticsearch_domain&quot;, side_effect=NOT_FOUND_ERROR
        ):
            result = boto3_elasticsearch<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match175295-1.html#0',3,'match175295-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.describe_elasticsearch_domain(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(&quot;ResourceNotFoundException&quot;, &quot;msg&quot;),
            )
            self.assertFalse(result[</B></FONT>&quot;result&quot;])

    def test_create_elasticsearch_domain_positive(self):
        &quot;&quot;&quot;
        Test that when creating a domain, and it succeeds,
        the .create method returns a dict with 'result': True
        and 'response' with the newly created domain's status information.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;create_elasticsearch_domain&quot;,
            return_value={&quot;DomainStatus&quot;: DOMAIN_RET},
        ):
            kwargs = {
                &quot;elasticsearch_version&quot;: DOMAIN_RET[&quot;ElasticsearchVersion&quot;],
                &quot;elasticsearch_cluster_config&quot;: DOMAIN_RET[
                    &quot;ElasticsearchClusterConfig&quot;
                ],
                &quot;ebs_options&quot;: DOMAIN_RET[&quot;EBSOptions&quot;],
                &quot;access_policies&quot;: DOMAIN_RET[&quot;AccessPolicies&quot;],
                &quot;snapshot_options&quot;: DOMAIN_RET[&quot;SnapshotOptions&quot;],
                &quot;vpc_options&quot;: DOMAIN_RET[&quot;VPCOptions&quot;],
                &quot;cognito_options&quot;: DOMAIN_RET[&quot;CognitoOptions&quot;],
                &quot;encryption_at_rest_options&quot;: DOMAIN_RET[&quot;EncryptionAtRestOptions&quot;],
                &quot;advanced_options&quot;: DOMAIN_RET[&quot;AdvancedOptions&quot;],
            }
            kwargs.update(CONN_PARAMETERS)
            self.assertEqual(
                boto3_elasticsearch.create_elasticsearch_domain(
                    domain_name=&quot;testdomain&quot;, **kwargs
                ),
                {&quot;result&quot;: True, &quot;response&quot;: DOMAIN_RET},
            )

    def test_create_elasticsearch_domain_error(self):
        &quot;&quot;&quot;
        Test that when creating a domain, and boto3 returns an error,
        the .create method returns a dict with 'result': False
        and 'error' with the error reported by boto3.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;create_elasticsearch_domain&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;create_domain&quot;),
        ):
            kwargs = {
                &quot;elasticsearch_version&quot;: DOMAIN_RET[&quot;ElasticsearchVersion&quot;],
                &quot;elasticsearch_cluster_config&quot;: DOMAIN_RET[
                    &quot;ElasticsearchClusterConfig&quot;
                ],
                &quot;ebs_options&quot;: DOMAIN_RET[&quot;EBSOptions&quot;],
                &quot;access_policies&quot;: DOMAIN_RET[&quot;AccessPolicies&quot;],
                &quot;snapshot_options&quot;: DOMAIN_RET[&quot;SnapshotOptions&quot;],
                &quot;vpc_options&quot;: DOMAIN_RET[&quot;VPCOptions&quot;],
                &quot;cognito_options&quot;: DOMAIN_RET[&quot;CognitoOptions&quot;],
                &quot;encryption_at_rest_options&quot;: DOMAIN_RET[&quot;EncryptionAtRestOptions&quot;],
                &quot;advanced_options&quot;: DOMAIN_RET[&quot;AdvancedOptions&quot;],
            }
            kwargs.update(CONN_PARAMETERS)
            result = boto3_elasticsearch.create_elasticsearch_domain(
                &quot;testdomain&quot;, **kwargs
            )
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;), ERROR_MESSAGE.format(101, &quot;create_domain&quot;)
            )

    def test_delete_domain_positive(self):
        &quot;&quot;&quot;
        Test that when deleting a domain, and it succeeds,
        the .delete method returns {'result': True}.
        &quot;&quot;&quot;
        with patch.object(self.conn, &quot;delete_elasticsearch_domain&quot;):
            self.assertEqual(
                boto3_elasticsearch.delete_elasticsearch_domain(
                    &quot;testdomain&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True},
            )

    def test_delete_domain_error(self):
        &quot;&quot;&quot;
        Test that when deleting a domain, and boto3 returns an error,
        the .delete method returns {'result': False, 'error' :'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;delete_elasticsearch_domain&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;delete_domain&quot;),
        ):
            result = boto3_elasticsearch.delete_elasticsearch_domain(
                &quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;), ERROR_MESSAGE.format(101, &quot;delete_domain&quot;)
            )

    def test_update_domain_positive(self):
        &quot;&quot;&quot;
        Test that when updating a domain succeeds, the .update method returns {'result': True}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;update_elasticsearch_domain_config&quot;,
            return_value={&quot;DomainConfig&quot;: DOMAIN_RET},
        ):
            kwargs = {
                &quot;elasticsearch_cluster_config&quot;: DOMAIN_RET[
                    &quot;ElasticsearchClusterConfig&quot;
                ],
                &quot;ebs_options&quot;: DOMAIN_RET[&quot;EBSOptions&quot;],
                &quot;snapshot_options&quot;: DOMAIN_RET[&quot;SnapshotOptions&quot;],
                &quot;vpc_options&quot;: DOMAIN_RET[&quot;VPCOptions&quot;],
                &quot;cognito_options&quot;: DOMAIN_RET[&quot;CognitoOptions&quot;],
                &quot;advanced_options&quot;: DOMAIN_RET[&quot;AdvancedOptions&quot;],
                &quot;access_policies&quot;: DOMAIN_RET[&quot;AccessPolicies&quot;],
                &quot;log_publishing_options&quot;: {},
            }

            kwargs.update(CONN_PARAMETERS)
            self.assertEqual(
                boto3_elasticsearch.update_elasticsearch_domain_config(
                    &quot;testdomain&quot;, **kwargs
                ),
                {&quot;result&quot;: True, &quot;response&quot;: DOMAIN_RET},
            )

    def test_update_domain_error(self):
        &quot;&quot;&quot;
        Test that when updating a domain fails, and boto3 returns an error,
        the .update method returns the error.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;update_elasticsearch_domain_config&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;update_domain&quot;),
        ):
            kwargs = {
                &quot;elasticsearch_cluster_config&quot;: DOMAIN_RET[
                    &quot;ElasticsearchClusterConfig&quot;
                ],
                &quot;ebs_options&quot;: DOMAIN_RET[&quot;EBSOptions&quot;],
                &quot;snapshot_options&quot;: DOMAIN_RET[&quot;SnapshotOptions&quot;],
                &quot;vpc_options&quot;: DOMAIN_RET[&quot;VPCOptions&quot;],
                &quot;cognito_options&quot;: DOMAIN_RET[&quot;CognitoOptions&quot;],
                &quot;advanced_options&quot;: DOMAIN_RET[&quot;AdvancedOptions&quot;],
                &quot;access_policies&quot;: DOMAIN_RET[&quot;AccessPolicies&quot;],
                &quot;log_publishing_options&quot;: {},
            }
            kwargs.update(CONN_PARAMETERS)
            result = boto3_elasticsearch.update_elasticsearch_domain_config(
                &quot;testdomain&quot;, **kwargs
            )
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;), ERROR_MESSAGE.format(101, &quot;update_domain&quot;)
            )

    def test_add_tags_positive(self):
        &quot;&quot;&quot;
        Test that when adding tags is successful, the .add_tags method returns {'result': True}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain&quot;,
            return_value={&quot;DomainStatus&quot;: DOMAIN_RET},
        ):
            self.assertEqual(
                boto3_elasticsearch.add_tags(
                    &quot;testdomain&quot;, tags={&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True},
            )

    def test_add_tags_default(self):
        &quot;&quot;&quot;
        Test that when tags are not provided, no error is raised.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain&quot;,
            return_value={&quot;DomainStatus&quot;: DOMAIN_RET},
        ):
            self.assertEqual(
                boto3_elasticsearch.add_tags(&quot;testdomain&quot;, **CONN_PARAMETERS),
                {&quot;result&quot;: True},
            )

    def test_add_tags_error(self):
        &quot;&quot;&quot;
        Test that when adding tags fails, and boto3 returns an error,
        the .add_tags function returns {'tagged': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn, &quot;add_tags&quot;, side_effect=ClientError(ERROR_CONTENT, &quot;add_tags&quot;)
        ), patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain&quot;,
            return_value={&quot;DomainStatus&quot;: DOMAIN_RET},
        ):
            result = boto3_elasticsearch.add_tags(
                &quot;testdomain&quot;, tags={&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;), ERROR_MESSAGE.format(101, &quot;add_tags&quot;)
            )

    def test_remove_tags_positive(self):
        &quot;&quot;&quot;
        Test that when removing tags is successful, the .remove_tags method returns {'tagged': True}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain&quot;,
            return_value={&quot;DomainStatus&quot;: DOMAIN_RET},
        ):
            self.assertEqual(
                boto3_elasticsearch.remove_tags(
                    tag_keys=[&quot;foo&quot;, &quot;bar&quot;], domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True},
            )

    def test_remove_tag_error(self):
        &quot;&quot;&quot;
        Test that when removing tags fails, and boto3 returns an error,
        the .remove_tags method returns {'tagged': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;remove_tags&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;remove_tags&quot;),
        ), patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain&quot;,
            return_value={&quot;DomainStatus&quot;: DOMAIN_RET},
        ):
            result = boto3_elasticsearch.remove_tags(
                tag_keys=[&quot;foo&quot;, &quot;bar&quot;], domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;), ERROR_MESSAGE.format(101, &quot;remove_tags&quot;)
            )

    def test_list_tags_positive(self):
        &quot;&quot;&quot;
        Test that when listing tags is successful,
        the .list_tags method returns a dict with key 'tags'.
        Also test that the tags returned are manipulated properly (i.e. transformed
        into a dict with tags).
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain&quot;,
            return_value={&quot;DomainStatus&quot;: DOMAIN_RET},
        ), patch.object(
            self.conn,
            &quot;list_tags&quot;,
            return_value={&quot;TagList&quot;: [{&quot;Key&quot;: &quot;foo&quot;, &quot;Value&quot;: &quot;bar&quot;}]},
        ):
            result = boto3_elasticsearch.list_tags(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertEqual(result, {&quot;result&quot;: True, &quot;response&quot;: {&quot;foo&quot;: &quot;bar&quot;}})

    def test_list_tags_error(self):
        &quot;&quot;&quot;
        Test that when listing tags causes boto3 to return an error,
        the .list_tags method returns the error.
        &quot;&quot;&quot;
        with patch.object(
            self.conn, &quot;list_tags&quot;, side_effect=ClientError(ERROR_CONTENT, &quot;list_tags&quot;)
        ), patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain&quot;,
            return_value={&quot;DomainStatus&quot;: DOMAIN_RET},
        ):
            result = boto3_elasticsearch.list_tags(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;), ERROR_MESSAGE.format(101, &quot;list_tags&quot;)
            )

    def test_cancel_elasticsearch_service_software_update_positive(self):
        &quot;&quot;&quot;
        Test that when calling cancel_elasticsearch_service_software_update and
        it is successful, it returns {'result': True}.
        &quot;&quot;&quot;
        retval = {
            &quot;ServiceSoftwareOptions&quot;: {
                &quot;CurrentVersion&quot;: &quot;string&quot;,
                &quot;NewVersion&quot;: &quot;string&quot;,
                &quot;UpdateAvailable&quot;: True,
                &quot;Cancellable&quot;: True,
                &quot;UpdateStatus&quot;: &quot;ELIGIBLE&quot;,
                &quot;Description&quot;: &quot;string&quot;,
                &quot;AutomatedUpdateDate&quot;: datetime.datetime(2015, 1, 1),
            }
        }
        with patch.object(
            self.conn,
            &quot;cancel_elasticsearch_service_software_update&quot;,
            return_value=retval,
        ):
            result = boto3_elasticsearch.cancel_elasticsearch_service_software_update(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertEqual(result, {&quot;result&quot;: True})

    def test_cancel_elasticsearch_service_software_update_error(self):
        &quot;&quot;&quot;
        Test that when calling cancel_elasticsearch_service_software_update and
        boto3 returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;cancel_elasticsearch_service_software_update&quot;,
            side_effect=ClientError(
                ERROR_CONTENT, &quot;cancel_elasticsearch_service_software_update&quot;
            ),
        ):
            result = boto3_elasticsearch.cancel_elasticsearch_service_software_update(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(
                    101, &quot;cancel_elasticsearch_service_software_update&quot;
                ),
            )

    def test_delete_elasticsearch_service_role_positive(self):
        &quot;&quot;&quot;
        Test that when calling delete_elasticsearch_service_role and
        it is successful, it returns {'result': True}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn, &quot;delete_elasticsearch_service_role&quot;, return_value=None
        ):
            result = boto3_elasticsearch.delete_elasticsearch_service_role(
                **CONN_PARAMETERS
            )
            self.assertEqual(result, {&quot;result&quot;: True})

    def test_delete_elasticsearch_service_role_error(self):
        &quot;&quot;&quot;
        Test that when calling delete_elasticsearch_service_role and boto3 returns
        an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;delete_elasticsearch_service_role&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;delete_elasticsearch_service_role&quot;),
        ):
            result = boto3_elasticsearch.delete_elasticsearch_service_role(
                **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(101, &quot;delete_elasticsearch_service_role&quot;),
            )

    def test_describe_elasticsearch_domain_config_positive(self):
        &quot;&quot;&quot;
        Test that when calling describe_elasticsearch_domain_config and
        it is successful, it returns {'result': True}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain_config&quot;,
            return_value={&quot;DomainConfig&quot;: DOMAIN_RET},
        ):
            self.assertEqual(
                boto3_elasticsearch.describe_elasticsearch_domain_config(
                    &quot;testdomain&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: DOMAIN_RET},
            )

    def test_describe_elasticsearch_domain_config_error(self):
        &quot;&quot;&quot;
        Test that when calling describe_elasticsearch_domain_config and boto3 returns
        an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_domain_config&quot;,
            side_effect=ClientError(
                ERROR_CONTENT, &quot;describe_elasticsearch_domain_config&quot;
            ),
        ):
            result = boto3_elasticsearch.describe_elasticsearch_domain_config(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(101, &quot;describe_elasticsearch_domain_config&quot;),
            )

    def test_describe_elasticsearch_domains_positive(self):
        &quot;&quot;&quot;
        Test that when calling describe_elasticsearch_domains and it is successful,
        it returns {'result': True, 'response': some_data}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_domains&quot;,
            return_value={&quot;DomainStatusList&quot;: [DOMAIN_RET]},
        ):
            self.assertEqual(
                boto3_elasticsearch.describe_elasticsearch_domains(
                    domain_names=[&quot;test_domain&quot;], **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: [DOMAIN_RET]},
            )

    def test_describe_elasticsearch_domains_error(self):
        &quot;&quot;&quot;
        Test that when calling describe_elasticsearch_domains and boto3 returns
        an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_domains&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;describe_elasticsearch_domains&quot;),
        ):
            result = boto3_elasticsearch.describe_elasticsearch_domains(
                domain_names=[&quot;testdomain&quot;], **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(101, &quot;describe_elasticsearch_domains&quot;),
            )

    def test_describe_elasticsearch_instance_type_limits_positive(self):
        &quot;&quot;&quot;
        Test that when calling describe_elasticsearch_instance_type_limits and
        it succeeds, it returns {'result': True, 'response' some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;LimitsByRole&quot;: {
                &quot;string&quot;: {
                    &quot;StorageTypes&quot;: [
                        {
                            &quot;StorageTypeName&quot;: &quot;string&quot;,
                            &quot;StorageSubTypeName&quot;: &quot;string&quot;,
                            &quot;StorageTypeLimits&quot;: [
                                {&quot;LimitName&quot;: &quot;string&quot;, &quot;LimitValues&quot;: [&quot;string&quot;]}
                            ],
                        }
                    ],
                    &quot;InstanceLimits&quot;: {
                        &quot;InstanceCountLimits&quot;: {
                            &quot;MinimumInstanceCount&quot;: 123,
                            &quot;MaximumInstanceCount&quot;: 123,
                        }
                    },
                    &quot;AdditionalLimits&quot;: [
                        {&quot;LimitName&quot;: &quot;string&quot;, &quot;LimitValues&quot;: [&quot;string&quot;]}
                    ],
                }
            }
        }
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_instance_type_limits&quot;,
            return_value=ret_val,
        ):
            self.assertEqual(
                boto3_elasticsearch.describe_elasticsearch_instance_type_limits(
                    domain_name=&quot;testdomain&quot;,
                    instance_type=&quot;foo&quot;,
                    elasticsearch_version=&quot;1.0&quot;,
                    **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: ret_val[&quot;LimitsByRole&quot;]},
            )

    def test_describe_elasticsearch_instance_type_limits_error(self):
        &quot;&quot;&quot;
        Test that when calling describe_elasticsearch_instance_type_limits and boto3 returns
        an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;describe_elasticsearch_instance_type_limits&quot;,
            side_effect=ClientError(
                ERROR_CONTENT, &quot;describe_elasticsearch_instance_type_limits&quot;
            ),
        ):
            result = boto3_elasticsearch.describe_elasticsearch_instance_type_limits(
                domain_name=&quot;testdomain&quot;,
                instance_type=&quot;foo&quot;,
                elasticsearch_version=&quot;1.0&quot;,
                **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(
                    101, &quot;describe_elasticsearch_instance_type_limits&quot;
                ),
            )

    def test_describe_reserved_elasticsearch_instance_offerings_positive(self):
        &quot;&quot;&quot;
        Test that when calling describe_reserved_elasticsearch_instance_offerings
        and it succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;NextToken&quot;: &quot;string&quot;,
            &quot;ReservedElasticsearchInstanceOfferings&quot;: [
                {
                    &quot;ReservedElasticsearchInstanceOfferingId&quot;: &quot;string&quot;,
                    &quot;ElasticsearchInstanceType&quot;: &quot;t2.medium.elasticsearch&quot;,
                    &quot;Duration&quot;: 123,
                    &quot;FixedPrice&quot;: 123.0,
                    &quot;UsagePrice&quot;: 123.0,
                    &quot;CurrencyCode&quot;: &quot;string&quot;,
                    &quot;PaymentOption&quot;: &quot;NO_UPFRONT&quot;,
                    &quot;RecurringCharges&quot;: [
                        {
                            &quot;RecurringChargeAmount&quot;: 123.0,
                            &quot;RecurringChargeFrequency&quot;: &quot;string&quot;,
                        }
                    ],
                }
            ],
        }
        with patch.object(self.paginator, &quot;paginate&quot;, return_value=[ret_val]):
            self.assertEqual(
                boto3_elasticsearch.describe_reserved_elasticsearch_instance_offerings(
                    reserved_elasticsearch_instance_offering_id=&quot;foo&quot;, **CONN_PARAMETERS
                ),
                {
                    &quot;result&quot;: True,
                    &quot;response&quot;: ret_val[&quot;ReservedElasticsearchInstanceOfferings&quot;],
                },
            )

    def test_describe_reserved_elasticsearch_instance_offerings_error(self):
        &quot;&quot;&quot;
        Test that when calling describe_reserved_elasticsearch_instance_offerings
        and boto3 returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.paginator,
            &quot;paginate&quot;,
            side_effect=ClientError(
                ERROR_CONTENT, &quot;describe_reserved_elasticsearch_instance_offerings&quot;
            ),
        ):
            result = (
                boto3_elasticsearch.describe_reserved_elasticsearch_instance_offerings(
                    reserved_elasticsearch_instance_offering_id=&quot;foo&quot;, **CONN_PARAMETERS
                )
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(
                    101, &quot;describe_reserved_elasticsearch_instance_offerings&quot;
                ),
            )

    def test_describe_reserved_elasticsearch_instances_positive(self):
        &quot;&quot;&quot;
        Test that when calling describe_reserved_elasticsearch_instances and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;NextToken&quot;: &quot;string&quot;,
            &quot;ReservedElasticsearchInstances&quot;: [
                {
                    &quot;ReservationName&quot;: &quot;string&quot;,
                    &quot;ReservedElasticsearchInstanceId&quot;: &quot;string&quot;,
                    &quot;ReservedElasticsearchInstanceOfferingId&quot;: &quot;string&quot;,
                    &quot;ElasticsearchInstanceType&quot;: &quot;t2.medium.elasticsearch&quot;,
                    &quot;StartTime&quot;: datetime.datetime(2015, 1, 1),
                    &quot;Duration&quot;: 123,
                    &quot;FixedPrice&quot;: 123.0,
                    &quot;UsagePrice&quot;: 123.0,
                    &quot;CurrencyCode&quot;: &quot;string&quot;,
                    &quot;ElasticsearchInstanceCount&quot;: 123,
                    &quot;State&quot;: &quot;string&quot;,
                    &quot;PaymentOption&quot;: &quot;ALL_UPFRONT&quot;,
                    &quot;RecurringCharges&quot;: [
                        {
                            &quot;RecurringChargeAmount&quot;: 123.0,
                            &quot;RecurringChargeFrequency&quot;: &quot;string&quot;,
                        },
                    ],
                },
            ],
        }
        with patch.object(self.paginator, &quot;paginate&quot;, return_value=[ret_val]):
            self.assertEqual(
                boto3_elasticsearch.describe_reserved_elasticsearch_instances(
                    reserved_elasticsearch_instance_id=&quot;foo&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: ret_val[&quot;ReservedElasticsearchInstances&quot;]},
            )

    def test_describe_reserved_elasticsearch_instances_error(self):
        &quot;&quot;&quot;
        Test that when calling describe_reserved_elasticsearch_instances and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.paginator,
            &quot;paginate&quot;,
            side_effect=ClientError(
                ERROR_CONTENT, &quot;describe_reserved_elasticsearch_instances&quot;
            ),
        ):
            result = boto3_elasticsearch.describe_reserved_elasticsearch_instances(
                reserved_elasticsearch_instance_id=&quot;foo&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(101, &quot;describe_reserved_elasticsearch_instances&quot;),
            )

    def test_get_compatible_elasticsearch_versions_positive(self):
        &quot;&quot;&quot;
        Test that when calling get_compatible_elasticsearch_versions and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;CompatibleElasticsearchVersions&quot;: [
                {&quot;SourceVersion&quot;: &quot;string&quot;, &quot;TargetVersions&quot;: [&quot;string&quot;]}
            ]
        }
        with patch.object(
            self.conn, &quot;get_compatible_elasticsearch_versions&quot;, return_value=ret_val
        ):
            self.assertEqual(
                boto3_elasticsearch.get_compatible_elasticsearch_versions(
                    domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
                ),
                {
                    &quot;result&quot;: True,
                    &quot;response&quot;: ret_val[&quot;CompatibleElasticsearchVersions&quot;],
                },
            )

    def test_get_compatible_elasticsearch_versions_error(self):
        &quot;&quot;&quot;
        Test that when calling get_compatible_elasticsearch_versions and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;get_compatible_elasticsearch_versions&quot;,
            side_effect=ClientError(
                ERROR_CONTENT, &quot;get_compatible_elasticsearch_versions&quot;
            ),
        ):
            result = boto3_elasticsearch.get_compatible_elasticsearch_versions(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(101, &quot;get_compatible_elasticsearch_versions&quot;),
            )

    def test_get_upgrade_history_positive(self):
        &quot;&quot;&quot;
        Test that when calling get_upgrade_history and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;UpgradeHistories&quot;: [
                {
                    &quot;UpgradeName&quot;: &quot;string&quot;,
                    &quot;StartTimestamp&quot;: datetime.datetime(2015, 1, 1),
                    &quot;UpgradeStatus&quot;: &quot;IN_PROGRESS&quot;,
                    &quot;StepsList&quot;: [
                        {
                            &quot;UpgradeStep&quot;: &quot;PRE_UPGRADE_CHECK&quot;,
                            &quot;UpgradeStepStatus&quot;: &quot;IN_PROGRESS&quot;,
                            &quot;Issues&quot;: [&quot;string&quot;],
                            &quot;ProgressPercent&quot;: 123.0,
                        }
                    ],
                }
            ],
            &quot;NextToken&quot;: &quot;string&quot;,
        }
        with patch.object(self.paginator, &quot;paginate&quot;, return_value=[ret_val]):
            self.assertEqual(
                boto3_elasticsearch.get_upgrade_history(
                    domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: ret_val[&quot;UpgradeHistories&quot;]},
            )

    def test_get_upgrade_history_error(self):
        &quot;&quot;&quot;
        Test that when calling get_upgrade_history and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.paginator,
            &quot;paginate&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;get_upgrade_history&quot;),
        ):
            result = boto3_elasticsearch.get_upgrade_history(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(101, &quot;get_upgrade_history&quot;),
            )

    def test_get_upgrade_status_positive(self):
        &quot;&quot;&quot;
        Test that when calling get_upgrade_status and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;UpgradeStep&quot;: &quot;PRE_UPGRADE_CHECK&quot;,
            &quot;StepStatus&quot;: &quot;IN_PROGRESS&quot;,
            &quot;UpgradeName&quot;: &quot;string&quot;,
            &quot;ResponseMetadata&quot;: None,
        }
        with patch.object(self.conn, &quot;get_upgrade_status&quot;, return_value=ret_val):
            self.assertEqual(
                boto3_elasticsearch.get_upgrade_status(
                    domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: ret_val},
            )

    def test_get_upgrade_status_error(self):
        &quot;&quot;&quot;
        Test that when calling get_upgrade_status and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;get_upgrade_status&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;get_upgrade_status&quot;),
        ):
            result = boto3_elasticsearch.get_upgrade_status(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;), ERROR_MESSAGE.format(101, &quot;get_upgrade_status&quot;)
            )

    def test_list_domain_names_positive(self):
        &quot;&quot;&quot;
        Test that when calling list_domain_names and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {&quot;DomainNames&quot;: [{&quot;DomainName&quot;: &quot;string&quot;}]}
        with patch.object(self.conn, &quot;list_domain_names&quot;, return_value=ret_val):
            self.assertEqual(
                boto3_elasticsearch.list_domain_names(**CONN_PARAMETERS),
                {
                    &quot;result&quot;: True,
                    &quot;response&quot;: [item[&quot;DomainName&quot;] for item in ret_val[&quot;DomainNames&quot;]],
                },
            )

    def test_list_domain_names_error(self):
        &quot;&quot;&quot;
        Test that when calling list_domain_names and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;list_domain_names&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;list_domain_names&quot;),
        ):
            result = boto3_elasticsearch.list_domain_names(**CONN_PARAMETERS)
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;), ERROR_MESSAGE.format(101, &quot;list_domain_names&quot;)
            )

    def test_list_elasticsearch_instance_types_positive(self):
        &quot;&quot;&quot;
        Test that when calling list_elasticsearch_instance_types and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;ElasticsearchInstanceTypes&quot;: [
                &quot;m3.medium.elasticsearch&quot;,
                &quot;m3.large.elasticsearch&quot;,
                &quot;m3.xlarge.elasticsearch&quot;,
                &quot;m3.2xlarge.elasticsearch&quot;,
                &quot;m4.large.elasticsearch&quot;,
                &quot;m4.xlarge.elasticsearch&quot;,
                &quot;m4.2xlarge.elasticsearch&quot;,
                &quot;m4.4xlarge.elasticsearch&quot;,
                &quot;m4.10xlarge.elasticsearch&quot;,
                &quot;t2.micro.elasticsearch&quot;,
                &quot;t2.small.elasticsearch&quot;,
                &quot;t2.medium.elasticsearch&quot;,
                &quot;r3.large.elasticsearch&quot;,
                &quot;r3.xlarge.elasticsearch&quot;,
                &quot;r3.2xlarge.elasticsearch&quot;,
                &quot;r3.4xlarge.elasticsearch&quot;,
                &quot;r3.8xlarge.elasticsearch&quot;,
                &quot;i2.xlarge.elasticsearch&quot;,
                &quot;i2.2xlarge.elasticsearch&quot;,
                &quot;d2.xlarge.elasticsearch&quot;,
                &quot;d2.2xlarge.elasticsearch&quot;,
                &quot;d2.4xlarge.elasticsearch&quot;,
                &quot;d2.8xlarge.elasticsearch&quot;,
                &quot;c4.large.elasticsearch&quot;,
                &quot;c4.xlarge.elasticsearch&quot;,
                &quot;c4.2xlarge.elasticsearch&quot;,
                &quot;c4.4xlarge.elasticsearch&quot;,
                &quot;c4.8xlarge.elasticsearch&quot;,
                &quot;r4.large.elasticsearch&quot;,
                &quot;r4.xlarge.elasticsearch&quot;,
                &quot;r4.2xlarge.elasticsearch&quot;,
                &quot;r4.4xlarge.elasticsearch&quot;,
                &quot;r4.8xlarge.elasticsearch&quot;,
                &quot;r4.16xlarge.elasticsearch&quot;,
                &quot;i3.large.elasticsearch&quot;,
                &quot;i3.xlarge.elasticsearch&quot;,
                &quot;i3.2xlarge.elasticsearch&quot;,
                &quot;i3.4xlarge.elasticsearch&quot;,
                &quot;i3.8xlarge.elasticsearch&quot;,
                &quot;i3.16xlarge.elasticsearch&quot;,
            ],
            &quot;NextToken&quot;: &quot;string&quot;,
        }
        with patch.object(self.paginator, &quot;paginate&quot;, return_value=[ret_val]):
            self.assertEqual(
                boto3_elasticsearch.list_elasticsearch_instance_types(
                    elasticsearch_version=&quot;1.0&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: ret_val[&quot;ElasticsearchInstanceTypes&quot;]},
            )

    def test_list_elasticsearch_instance_types_error(self):
        &quot;&quot;&quot;
        Test that when calling list_elasticsearch_instance_types and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.paginator,
            &quot;paginate&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;list_elasticsearch_instance_types&quot;),
        ):
            result = boto3_elasticsearch.list_elasticsearch_instance_types(
                elasticsearch_version=&quot;1.0&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(101, &quot;list_elasticsearch_instance_types&quot;),
            )

    def test_list_elasticsearch_versions_positive(self):
        &quot;&quot;&quot;
        Test that when calling list_elasticsearch_versions and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {&quot;ElasticsearchVersions&quot;: [&quot;string&quot;], &quot;NextToken&quot;: &quot;string&quot;}
        with patch.object(self.paginator, &quot;paginate&quot;, return_value=[ret_val]):
            self.assertEqual(
                boto3_elasticsearch.list_elasticsearch_versions(**CONN_PARAMETERS),
                {&quot;result&quot;: True, &quot;response&quot;: ret_val[&quot;ElasticsearchVersions&quot;]},
            )

    def test_list_elasticsearch_versions_error(self):
        &quot;&quot;&quot;
        Test that when calling list_elasticsearch_versions and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.paginator,
            &quot;paginate&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;list_elasticsearch_versions&quot;),
        ):
            result = boto3_elasticsearch.list_elasticsearch_versions(**CONN_PARAMETERS)
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(101, &quot;list_elasticsearch_versions&quot;),
            )

    def test_purchase_reserved_elasticsearch_instance_offering_positive(self):
        &quot;&quot;&quot;
        Test that when calling purchase_reserved_elasticsearch_instance_offering and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;ReservedElasticsearchInstanceId&quot;: &quot;string&quot;,
            &quot;ReservationName&quot;: &quot;string&quot;,
        }
        with patch.object(
            self.conn,
            &quot;purchase_reserved_elasticsearch_instance_offering&quot;,
            return_value=ret_val,
        ):
            self.assertEqual(
                boto3_elasticsearch.purchase_reserved_elasticsearch_instance_offering(
                    reserved_elasticsearch_instance_offering_id=&quot;foo&quot;,
                    reservation_name=&quot;bar&quot;,
                    **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: ret_val},
            )

    def test_purchase_reserved_elasticsearch_instance_offering_error(self):
        &quot;&quot;&quot;
        Test that when calling purchase_reserved_elasticsearch_instance_offering and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;purchase_reserved_elasticsearch_instance_offering&quot;,
            side_effect=ClientError(
                ERROR_CONTENT, &quot;purchase_reserved_elasticsearch_instance_offering&quot;
            ),
        ):
            result = (
                boto3_elasticsearch.purchase_reserved_elasticsearch_instance_offering(
                    reserved_elasticsearch_instance_offering_id=&quot;foo&quot;,
                    reservation_name=&quot;bar&quot;,
                    **CONN_PARAMETERS
                )
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(
                    101, &quot;purchase_reserved_elasticsearch_instance_offering&quot;
                ),
            )

    def test_start_elasticsearch_service_software_update_positive(self):
        &quot;&quot;&quot;
        Test that when calling start_elasticsearch_service_software_update and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;ServiceSoftwareOptions&quot;: {
                &quot;CurrentVersion&quot;: &quot;string&quot;,
                &quot;NewVersion&quot;: &quot;string&quot;,
                &quot;UpdateAvailable&quot;: True,
                &quot;Cancellable&quot;: True,
                &quot;UpdateStatus&quot;: &quot;PENDING_UPDATE&quot;,
                &quot;Description&quot;: &quot;string&quot;,
                &quot;AutomatedUpdateDate&quot;: datetime.datetime(2015, 1, 1),
            }
        }
        with patch.object(
            self.conn,
            &quot;start_elasticsearch_service_software_update&quot;,
            return_value=ret_val,
        ):
            self.assertEqual(
                boto3_elasticsearch.start_elasticsearch_service_software_update(
                    domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: ret_val[&quot;ServiceSoftwareOptions&quot;]},
            )

    def test_start_elasticsearch_service_software_update_error(self):
        &quot;&quot;&quot;
        Test that when calling start_elasticsearch_service_software_update and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;start_elasticsearch_service_software_update&quot;,
            side_effect=ClientError(
                ERROR_CONTENT, &quot;start_elasticsearch_service_software_update&quot;
            ),
        ):
            result = boto3_elasticsearch.start_elasticsearch_service_software_update(
                domain_name=&quot;testdomain&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(
                    101, &quot;start_elasticsearch_service_software_update&quot;
                ),
            )

    def test_upgrade_elasticsearch_domain_positive(self):
        &quot;&quot;&quot;
        Test that when calling upgrade_elasticsearch_domain and it
        succeeds, it returns {'result': True, 'response': some_value}.
        &quot;&quot;&quot;
        ret_val = {
            &quot;DomainName&quot;: &quot;string&quot;,
            &quot;TargetVersion&quot;: &quot;string&quot;,
            &quot;PerformCheckOnly&quot;: True,
        }
        with patch.object(
            self.conn, &quot;upgrade_elasticsearch_domain&quot;, return_value=ret_val
        ):
            self.assertEqual(
                boto3_elasticsearch.upgrade_elasticsearch_domain(
                    domain_name=&quot;testdomain&quot;, target_version=&quot;1.1&quot;, **CONN_PARAMETERS
                ),
                {&quot;result&quot;: True, &quot;response&quot;: ret_val},
            )

    def test_upgrade_elasticsearch_domain_error(self):
        &quot;&quot;&quot;
        Test that when calling upgrade_elasticsearch_domain and boto3
        returns an error, it returns {'result': False, 'error': 'the error'}.
        &quot;&quot;&quot;
        with patch.object(
            self.conn,
            &quot;upgrade_elasticsearch_domain&quot;,
            side_effect=ClientError(ERROR_CONTENT, &quot;upgrade_elasticsearch_domain&quot;),
        ):
            result = boto3_elasticsearch.upgrade_elasticsearch_domain(
                domain_name=&quot;testdomain&quot;, target_version=&quot;1.1&quot;, **CONN_PARAMETERS
            )
            self.assertFalse(result[&quot;result&quot;])
            self.assertEqual(
                result.get(&quot;error&quot;, &quot;&quot;),
                ERROR_MESSAGE.format(101, &quot;upgrade_elasticsearch_domain&quot;),
            )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ioloop_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#!/usr/bin/env python
# pylint: skip-file


from __future__ import absolute_import, division, print_function
import contextlib
import datetime
<A NAME="1"></A>import functools
import socket
import sys
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match175295-0.html#1',2,'match175295-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import threading
import time
import types

from salt.ext.tornado import gen
from salt.ext.tornado.ioloop import IOLoop, TimeoutError, PollIOLoop, PeriodicCallback
from salt.ext.tornado.log import app_log
from salt.ext.tornado.platform.select import _Select
from salt.ext.tornado.stack_context import ExceptionStackContext, StackContext, wrap, NullContext
from salt.ext.tornado.testing import AsyncTestCase, bind_unused_port, ExpectLog
from salt.ext.tornado.test.util import unittest, skipIfNonUnix, skipOnTravis, skipBefore35, exec_test

try:
    from</B></FONT> concurrent import futures
except ImportError:
    futures = None


class FakeTimeSelect(_Select):
    def __init__(self):
        self._time = 1000
        super(FakeTimeSelect, self).__init__()

    def time(self):
        return self._time

    def sleep(self, t):
        self._time += t

    def poll(self, timeout):
        events = super(FakeTimeSelect, self).poll(0)
        if events:
            return events
        self._time += timeout
        return []


class FakeTimeIOLoop(PollIOLoop):
    &quot;&quot;&quot;IOLoop implementation with a fake and deterministic clock.

    The clock advances as needed to trigger timeouts immediately.
    For use when testing code that involves the passage of time
    and no external dependencies.
    &quot;&quot;&quot;
    def initialize(self):
        self.fts = FakeTimeSelect()
        super(FakeTimeIOLoop, self).initialize(impl=self.fts,
                                               time_func=self.fts.time)

    def sleep(self, t):
        &quot;&quot;&quot;Simulate a blocking sleep by advancing the clock.&quot;&quot;&quot;
        self.fts.sleep(t)


class TestIOLoop(AsyncTestCase):
    def test_add_callback_return_sequence(self):
        # A callback returning {} or [] shouldn't spin the CPU, see Issue #1803.
        self.calls = 0

        loop = self.io_loop
        test = self
        old_add_callback = loop.add_callback

        def add_callback(self, callback, *args, **kwargs):
            test.calls += 1
            old_add_callback(callback, *args, **kwargs)

        loop.add_callback = types.MethodType(add_callback, loop)
        loop.add_callback(lambda: {})
        loop.add_callback(lambda: [])
        loop.add_timeout(datetime.timedelta(milliseconds=50), loop.stop)
        loop.start()
        self.assertLess(self.calls, 10)

    @skipOnTravis
    def test_add_callback_wakeup(self):
        # Make sure that add_callback from inside a running IOLoop
        # wakes up the IOLoop immediately instead of waiting for a timeout.
        def callback():
            self.called = True
            self.stop()

        def schedule_callback():
            self.called = False
            self.io_loop.add_callback(callback)
            # Store away the time so we can check if we woke up immediately
            self.start_time = time.time()
        self.io_loop.add_timeout(self.io_loop.time(), schedule_callback)
        self.wait()
        self.assertAlmostEqual(time.time(), self.start_time, places=2)
        self.assertTrue(self.called)

    @skipOnTravis
    def test_add_callback_wakeup_other_thread(self):
        def target():
            # sleep a bit to let the ioloop go into its poll loop
            time.sleep(0.01)
            self.stop_time = time.time()
            self.io_loop.add_callback(self.stop)
        thread = threading.Thread(target=target)
        self.io_loop.add_callback(thread.start)
        self.wait()
        delta = time.time() - self.stop_time
        self.assertLess(delta, 0.1)
        thread.join()

    def test_add_timeout_timedelta(self):
        self.io_loop.add_timeout(datetime.timedelta(microseconds=1), self.stop)
        self.wait()

    def test_multiple_add(self):
        sock, port = bind_unused_port()
        try:
            self.io_loop.add_handler(sock.fileno(), lambda fd, events: None,
                                     IOLoop.READ)
            # Attempting to add the same handler twice fails
            # (with a platform-dependent exception)
            self.assertRaises(Exception, self.io_loop.add_handler,
                              sock.fileno(), lambda fd, events: None,
                              IOLoop.READ)
        finally:
            self.io_loop.remove_handler(sock.fileno())
            sock.close()

    def test_remove_without_add(self):
        # remove_handler should not throw an exception if called on an fd
        # was never added.
        sock, port = bind_unused_port()
        try:
            self.io_loop.remove_handler(sock.fileno())
        finally:
            sock.close()

    def test_add_callback_from_signal(self):
        # cheat a little bit and just run this normally, since we can't
        # easily simulate the races that happen with real signal handlers
        self.io_loop.add_callback_from_signal(self.stop)
        self.wait()

    def test_add_callback_from_signal_other_thread(self):
        # Very crude test, just to make sure that we cover this case.
        # This also happens to be the first test where we run an IOLoop in
        # a non-main thread.
        other_ioloop = IOLoop()
        thread = threading.Thread(target=other_ioloop.start)
        thread.start()
        other_ioloop.add_callback_from_signal(other_ioloop.stop)
        thread.join()
        other_ioloop.close()

    def test_add_callback_while_closing(self):
        # Issue #635: add_callback() should raise a clean exception
        # if called while another thread is closing the IOLoop.
        if IOLoop.configured_class().__name__.endswith('AsyncIOLoop'):
            raise unittest.SkipTest(&quot;AsyncIOMainLoop shutdown not thread safe&quot;)
        closing = threading.Event()

        def target():
            other_ioloop.add_callback(other_ioloop.stop)
            other_ioloop.start()
            closing.set()
            other_ioloop.close(all_fds=True)
        other_ioloop = IOLoop()
        thread = threading.Thread(target=target)
        thread.start()
        closing.wait()
        for i in range(1000):
            try:
                other_ioloop.add_callback(lambda: None)
            except RuntimeError as e:
                self.assertEqual(&quot;IOLoop is closing&quot;, str(e))
                break

    def test_handle_callback_exception(self):
        # IOLoop.handle_callback_exception can be overridden to catch
        # exceptions in callbacks.
        def handle_callback_exception(callback):
            self.assertIs(sys.exc_info()[0], ZeroDivisionError)
            self.stop()
        self.io_loop.handle_callback_exception = handle_callback_exception
        with NullContext():
            # remove the test StackContext that would see this uncaught
            # exception as a test failure.
            self.io_loop.add_callback(lambda: 1 / 0)
        self.wait()

    @skipIfNonUnix  # just because socketpair is so convenient
    def test_read_while_writeable(self):
        # Ensure that write events don't come in while we're waiting for
        # a read and haven't asked for writeability. (the reverse is
        # difficult to test for)
        client, server = socket.socketpair()
        try:
            def handler(fd, events):
                self.assertEqual(events, IOLoop.READ)
                self.stop()
            self.io_loop.add_handler(client.fileno(), handler, IOLoop.READ)
            self.io_loop.add_timeout(self.io_loop.time() + 0.01,
                                     functools.partial(server.send, b'asdf'))
            self.wait()
            self.io_loop.remove_handler(client.fileno())
        finally:
            client.close()
            server.close()

    def test_remove_timeout_after_fire(self):
        # It is not an error to call remove_timeout after it has run.
        handle = self.io_loop.add_timeout(self.io_loop.time(), self.stop)
        self.wait()
        self.io_loop.remove_timeout(handle)

    def test_remove_timeout_cleanup(self):
        # Add and remove enough callbacks to trigger cleanup.
        # Not a very thorough test, but it ensures that the cleanup code
        # gets executed and doesn't blow up.  This test is only really useful
        # on PollIOLoop subclasses, but it should run silently on any
        # implementation.
        for i in range(2000):
            timeout = self.io_loop.add_timeout(self.io_loop.time() + 3600,
                                               lambda: None)
            self.io_loop.remove_timeout(timeout)
        # HACK: wait two IOLoop iterations for the GC to happen.
        self.io_loop.add_callback(lambda: self.io_loop.add_callback(self.stop))
        self.wait()

    def test_remove_timeout_from_timeout(self):
        calls = [False, False]

        # Schedule several callbacks and wait for them all to come due at once.
        # t2 should be cancelled by t1, even though it is already scheduled to
        # be run before the ioloop even looks at it.
        now = self.io_loop.time()

        def t1():
            calls[0] = True
            self.io_loop.remove_timeout(t2_handle)
        self.io_loop.add_timeout(now + 0.01, t1)

        def t2():
            calls[1] = True
        t2_handle = self.io_loop.add_timeout(now + 0.02, t2)
        self.io_loop.add_timeout(now + 0.03, self.stop)
        time.sleep(0.03)
        self.wait()
        self.assertEqual(calls, [True, False])

    def test_timeout_with_arguments(self):
        # This tests that all the timeout methods pass through *args correctly.
        results = []
        self.io_loop.add_timeout(self.io_loop.time(), results.append, 1)
        self.io_loop.add_timeout(datetime.timedelta(seconds=0),
                                 results.append, 2)
        self.io_loop.call_at(self.io_loop.time(), results.append, 3)
        self.io_loop.call_later(0, results.append, 4)
        self.io_loop.call_later(0, self.stop)
        self.wait()
        self.assertEqual(results, [1, 2, 3, 4])

    def test_add_timeout_return(self):
        # All the timeout methods return non-None handles that can be
        # passed to remove_timeout.
        handle = self.io_loop.add_timeout(self.io_loop.time(), lambda: None)
        self.assertFalse(handle is None)
        self.io_loop.remove_timeout(handle)

    def test_call_at_return(self):
        handle = self.io_loop.call_at(self.io_loop.time(), lambda: None)
        self.assertFalse(handle is None)
        self.io_loop.remove_timeout(handle)

    def test_call_later_return(self):
        handle = self.io_loop.call_later(0, lambda: None)
        self.assertFalse(handle is None)
        self.io_loop.remove_timeout(handle)

    def test_close_file_object(self):
        &quot;&quot;&quot;When a file object is used instead of a numeric file descriptor,
        the object should be closed (by IOLoop.close(all_fds=True),
        not just the fd.
        &quot;&quot;&quot;
        # Use a socket since they are supported by IOLoop on all platforms.
        # Unfortunately, sockets don't support the .closed attribute for
        # inspecting their close status, so we must use a wrapper.
        class SocketWrapper(object):
            def __init__(self, sockobj):
                self.sockobj = sockobj
                self.closed = False

            def fileno(self):
                return self.sockobj.fileno()

            def close(self):
                self.closed = True
                self.sockobj.close()
        sockobj, port = bind_unused_port()
        socket_wrapper = SocketWrapper(sockobj)
        io_loop = IOLoop()
        io_loop.add_handler(socket_wrapper, lambda fd, events: None,
                            IOLoop.READ)
        io_loop.close(all_fds=True)
        self.assertTrue(socket_wrapper.closed)

    def test_handler_callback_file_object(self):
        &quot;&quot;&quot;The handler callback receives the same fd object it passed in.&quot;&quot;&quot;
        server_sock, port = bind_unused_port()
        fds = []

        def handle_connection(fd, events):
            fds.append(fd)
            conn, addr = server_sock.accept()
            conn.close()
            self.stop()
        self.io_loop.add_handler(server_sock, handle_connection, IOLoop.READ)
        with contextlib.closing(socket.socket()) as client_sock:
            client_sock.connect(('127.0.0.1', port))
            self.wait()
        self.io_loop.remove_handler(server_sock)
        self.io_loop.add_handler(server_sock.fileno(), handle_connection,
                                 IOLoop.READ)
        with contextlib.closing(socket.socket()) as client_sock:
            client_sock.connect(('127.0.0.1', port))
            self.wait()
        self.assertIs(fds[0], server_sock)
        self.assertEqual(fds[1], server_sock.fileno())
        self.io_loop.remove_handler(server_sock.fileno())
        server_sock.close()

    def test_mixed_fd_fileobj(self):
        server_sock, port = bind_unused_port()

        def f(fd, events):
            pass
        self.io_loop.add_handler(server_sock, f, IOLoop.READ)
        with self.assertRaises(Exception):
            # The exact error is unspecified - some implementations use
            # IOError, others use ValueError.
            self.io_loop.add_handler(server_sock.fileno(), f, IOLoop.READ)
        self.io_loop.remove_handler(server_sock.fileno())
        server_sock.close()

    def test_reentrant(self):
        &quot;&quot;&quot;Calling start() twice should raise an error, not deadlock.&quot;&quot;&quot;
        returned_from_start = [False]
        got_exception = [False]

        def callback():
            try:
                self.io_loop.start()
                returned_from_start[0] = True
            except Exception:
                got_exception[0] = True
            self.stop()
        self.io_loop.add_callback(callback)
        self.wait()
        self.assertTrue(got_exception[0])
        self.assertFalse(returned_from_start[0])

    def test_exception_logging(self):
        &quot;&quot;&quot;Uncaught exceptions get logged by the IOLoop.&quot;&quot;&quot;
        # Use a NullContext to keep the exception from being caught by
        # AsyncTestCase.
        with NullContext():
            self.io_loop.add_callback(lambda: 1 / 0)
            self.io_loop.add_callback(self.stop)
            with ExpectLog(app_log, &quot;Exception in callback&quot;):
                self.wait()

    def test_exception_logging_future(self):
        &quot;&quot;&quot;The IOLoop examines exceptions from Futures and logs them.&quot;&quot;&quot;
        with NullContext():
            @gen.coroutine
            def callback():
                self.io_loop.add_callback(self.stop)
                1 / 0
            self.io_loop.add_callback(callback)
            with ExpectLog(app_log, &quot;Exception in callback&quot;):
                self.wait()

    @skipBefore35
    def test_exception_logging_native_coro(self):
        &quot;&quot;&quot;The IOLoop examines exceptions from awaitables and logs them.&quot;&quot;&quot;
        namespace = exec_test(globals(), locals(), &quot;&quot;&quot;
        async def callback():
            self.io_loop.add_callback(self.stop)
            1 / 0
        &quot;&quot;&quot;)
        with NullContext():
            self.io_loop.add_callback(namespace[&quot;callback&quot;])
            with ExpectLog(app_log, &quot;Exception in callback&quot;):
                self.wait()

    def test_spawn_callback(self):
        # An added callback runs in the test's stack_context, so will be
        # re-arised in wait().
        self.io_loop.add_callback(lambda: 1 / 0)
        with self.assertRaises(ZeroDivisionError):
            self.wait()
        # A spawned callback is run directly on the IOLoop, so it will be
        # logged without stopping the test.
        self.io_loop.spawn_callback(lambda: 1 / 0)
        self.io_loop.add_callback(self.stop)
        with ExpectLog(app_log, &quot;Exception in callback&quot;):
            self.wait()

    @skipIfNonUnix
    def test_remove_handler_from_handler(self):
        # Create two sockets with simultaneous read events.
        client, server = socket.socketpair()
        try:
            client.send(b'abc')
            server.send(b'abc')

            # After reading from one fd, remove the other from the IOLoop.
            chunks = []

            def handle_read(fd, events):
                chunks.append(fd.recv(1024))
                if fd is client:
                    self.io_loop.remove_handler(server)
                else:
                    self.io_loop.remove_handler(client)
            self.io_loop.add_handler(client, handle_read, self.io_loop.READ)
            self.io_loop.add_handler(server, handle_read, self.io_loop.READ)
            self.io_loop.call_later(0.1, self.stop)
            self.wait()

            # Only one fd was read; the other was cleanly removed.
            self.assertEqual(chunks, [b'abc'])
        finally:
            client.close()
            server.close()


# Deliberately not a subclass of AsyncTestCase so the IOLoop isn't
# automatically set as current.
class TestIOLoopCurrent(unittest.TestCase):
    def setUp(self):
        self.io_loop = None
        IOLoop.clear_current()

    def tearDown(self):
        if self.io_loop is not None:
            self.io_loop.close()

    def test_default_current(self):
        self.io_loop = IOLoop()
        # The first IOLoop with default arguments is made current.
        self.assertIs(self.io_loop, IOLoop.current())
        # A second IOLoop can be created but is not made current.
        io_loop2 = IOLoop()
        self.assertIs(self.io_loop, IOLoop.current())
        io_loop2.close()

    def test_non_current(self):
        self.io_loop = IOLoop(make_current=False)
        # The new IOLoop is not initially made current.
        self.assertIsNone(IOLoop.current(instance=False))
        # Starting the IOLoop makes it current, and stopping the loop
        # makes it non-current. This process is repeatable.
        for i in range(3):
            def f():
                self.current_io_loop = IOLoop.current()
                self.io_loop.stop()
            self.io_loop.add_callback(f)
            self.io_loop.start()
            self.assertIs(self.current_io_loop, self.io_loop)
            # Now that the loop is stopped, it is no longer current.
            self.assertIsNone(IOLoop.current(instance=False))

    def test_force_current(self):
        self.io_loop = IOLoop(make_current=True)
        self.assertIs(self.io_loop, IOLoop.current())
        with self.assertRaises(RuntimeError):
            # A second make_current=True construction cannot succeed.
            IOLoop(make_current=True)
        # current() was not affected by the failed construction.
        self.assertIs(self.io_loop, IOLoop.current())


class TestIOLoopAddCallback(AsyncTestCase):
    def setUp(self):
        super(TestIOLoopAddCallback, self).setUp()
        self.active_contexts = []

    def add_callback(self, callback, *args, **kwargs):
        self.io_loop.add_callback(callback, *args, **kwargs)

    @contextlib.contextmanager
    def context(self, name):
        self.active_contexts.append(name)
        yield
        self.assertEqual(self.active_contexts.pop(), name)

    def test_pre_wrap(self):
        # A pre-wrapped callback is run in the context in which it was
        # wrapped, not when it was added to the IOLoop.
        def f1():
            self.assertIn('c1', self.active_contexts)
            self.assertNotIn('c2', self.active_contexts)
            self.stop()

        with StackContext(functools.partial(self.context, 'c1')):
            wrapped = wrap(f1)

        with StackContext(functools.partial(self.context, 'c2')):
            self.add_callback(wrapped)

        self.wait()

    def test_pre_wrap_with_args(self):
        # Same as test_pre_wrap, but the function takes arguments.
        # Implementation note: The function must not be wrapped in a
        # functools.partial until after it has been passed through
        # stack_context.wrap
        def f1(foo, bar):
            self.assertIn('c1', self.active_contexts)
            self.assertNotIn('c2', self.active_contexts)
            self.stop((foo, bar))

        with StackContext(functools.partial(self.context, 'c1')):
            wrapped = wrap(f1)

        with StackContext(functools.partial(self.context, 'c2')):
            self.add_callback(wrapped, 1, bar=2)

        result = self.wait()
        self.assertEqual(result, (1, 2))


class TestIOLoopAddCallbackFromSignal(TestIOLoopAddCallback):
    # Repeat the add_callback tests using add_callback_from_signal
    def add_callback(self, callback, *args, **kwargs):
        self.io_loop.add_callback_from_signal(callback, *args, **kwargs)


@unittest.skipIf(futures is None, &quot;futures module not present&quot;)
class TestIOLoopFutures(AsyncTestCase):
<A NAME="0"></A>    def test_add_future_threads(self):
        with futures.ThreadPoolExecutor(1) as pool:
            self.io_loop.add_future(pool.submit(lambda: None),
                                    lambda future: self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match175295-0.html#0',2,'match175295-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.stop(future))
            future = self.wait()
            self.assertTrue(future.done())
            self.assertTrue(future.</B></FONT>result() is None)

    def test_add_future_stack_context(self):
        ready = threading.Event()

        def task():
            # we must wait for the ioloop callback to be scheduled before
            # the task completes to ensure that add_future adds the callback
            # asynchronously (which is the scenario in which capturing
            # the stack_context matters)
            ready.wait(1)
            assert ready.isSet(), &quot;timed out&quot;
            raise Exception(&quot;worker&quot;)

        def callback(future):
            self.future = future
            raise Exception(&quot;callback&quot;)

        def handle_exception(typ, value, traceback):
            self.exception = value
            self.stop()
            return True

        # stack_context propagates to the ioloop callback, but the worker
        # task just has its exceptions caught and saved in the Future.
        with futures.ThreadPoolExecutor(1) as pool:
            with ExceptionStackContext(handle_exception):
                self.io_loop.add_future(pool.submit(task), callback)
            ready.set()
        self.wait()

        self.assertEqual(self.exception.args[0], &quot;callback&quot;)
        self.assertEqual(self.future.exception().args[0], &quot;worker&quot;)


class TestIOLoopRunSync(unittest.TestCase):
    def setUp(self):
        self.io_loop = IOLoop()

    def tearDown(self):
        self.io_loop.close()

    def test_sync_result(self):
        with self.assertRaises(gen.BadYieldError):
            self.io_loop.run_sync(lambda: 42)

    def test_sync_exception(self):
        with self.assertRaises(ZeroDivisionError):
            self.io_loop.run_sync(lambda: 1 / 0)

    def test_async_result(self):
        @gen.coroutine
        def f():
            yield gen.Task(self.io_loop.add_callback)
            raise gen.Return(42)
        self.assertEqual(self.io_loop.run_sync(f), 42)

    def test_async_exception(self):
        @gen.coroutine
        def f():
            yield gen.Task(self.io_loop.add_callback)
            1 / 0
        with self.assertRaises(ZeroDivisionError):
            self.io_loop.run_sync(f)

    def test_current(self):
        def f():
            self.assertIs(IOLoop.current(), self.io_loop)
        self.io_loop.run_sync(f)

    def test_timeout(self):
        @gen.coroutine
        def f():
            yield gen.Task(self.io_loop.add_timeout, self.io_loop.time() + 1)
        self.assertRaises(TimeoutError, self.io_loop.run_sync, f, timeout=0.01)

    @skipBefore35
    def test_native_coroutine(self):
        namespace = exec_test(globals(), locals(), &quot;&quot;&quot;
        async def f():
            await gen.Task(self.io_loop.add_callback)
        &quot;&quot;&quot;)
        self.io_loop.run_sync(namespace['f'])


class TestPeriodicCallback(unittest.TestCase):
    def setUp(self):
        self.io_loop = FakeTimeIOLoop()
        self.io_loop.make_current()

    def tearDown(self):
        self.io_loop.close()

    def test_basic(self):
        calls = []

        def cb():
            calls.append(self.io_loop.time())
        pc = PeriodicCallback(cb, 10000)
        pc.start()
        self.io_loop.call_later(50, self.io_loop.stop)
        self.io_loop.start()
        self.assertEqual(calls, [1010, 1020, 1030, 1040, 1050])

    def test_overrun(self):
        sleep_durations = [9, 9, 10, 11, 20, 20, 35, 35, 0, 0]
        expected = [
            1010, 1020, 1030,  # first 3 calls on schedule
            1050, 1070,  # next 2 delayed one cycle
            1100, 1130,  # next 2 delayed 2 cycles
            1170, 1210,  # next 2 delayed 3 cycles
            1220, 1230,  # then back on schedule.
        ]
        calls = []

        def cb():
            calls.append(self.io_loop.time())
            if not sleep_durations:
                self.io_loop.stop()
                return
            self.io_loop.sleep(sleep_durations.pop(0))
        pc = PeriodicCallback(cb, 10000)
        pc.start()
        self.io_loop.start()
        self.assertEqual(calls, expected)


if __name__ == &quot;__main__&quot;:
    unittest.main()
</PRE>
</div>
  </div>
</body>
</html>
