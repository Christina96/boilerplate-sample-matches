<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for xbpspkg.py &amp; key_5.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for xbpspkg.py &amp; key_5.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>xbpspkg.py (2.6119404%)<th>key_5.py (0.7667032%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(9-22)<td><a href="#" name="0">(19-31)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>xbpspkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Package support for XBPS package manager (used by VoidLinux)

.. versionadded:: 2016.11.0
"""
<a name="0"></a>
# TODO: what about the initial acceptance of repo's fingerprint when adding a new repo?

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import glob
import logging
import os
import re

import salt.utils.data
import salt.utils.decorators as decorators
import salt.utils.files
import salt.utils.path
import salt.utils.pkg
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError, MinionError

log = logging.getLogger(</b></font>__name__)

# Define the module's virtual name
__virtualname__ = "pkg"


def __virtual__():
    """
    Set the virtual pkg module if the os is Void and xbps-install found
    """
    if __grains__["os"] in ("Void") and _check_xbps():
        return __virtualname__
    return (False, "Missing dependency: xbps-install")


@decorators.memoize
def _check_xbps():
    """
    Looks to see if xbps-install is present on the system, return full path
    """
    return salt.utils.path.which("xbps-install")


@decorators.memoize
def _get_version():
    """
    Get the xbps version
    """
    version_string = __salt__["cmd.run"](
        [_check_xbps(), "--version"], output_loglevel="trace"
    )
    if version_string is None:
        # Dunno why it would, but...
        return False

    VERSION_MATCH = re.compile(r"(?:XBPS:[\s]+)([\d.]+)(?:[\s]+.*)")
    version_match = VERSION_MATCH.search(version_string)
    if not version_match:
        return False

    return version_match.group(1).split(".")


def _rehash():
    """
    Recomputes internal hash table for the PATH variable.
    Used whenever a new command is created during the current
    session.
    """
    shell = __salt__["environ.get"]("SHELL")
    if shell.split("/")[-1] in ("csh", "tcsh"):
        __salt__["cmd.run"]("rehash", output_loglevel="trace")


def list_pkgs(versions_as_list=False, **kwargs):
    """
    List the packages currently installed as a dict::

        {'&lt;package_name&gt;': '&lt;version&gt;'}

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.list_pkgs
    """
    versions_as_list = salt.utils.data.is_true(versions_as_list)
    # not yet implemented or not applicable
    if any(
        [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
    ):
        return {}

    cmd = "xbps-query -l"
    ret = {}
    out = __salt__["cmd.run"](cmd, output_loglevel="trace")
    for line in out.splitlines():
        if not line:
            continue
        try:
            # xbps-query -l output sample:
            # ii desktop-file-utils-0.22_4  Utilities to ...
            #
            # XXX handle package status (like 'ii') ?
            pkg, ver = line.split(None)[1].rsplit("-", 1)
        except ValueError:
            log.error('xbps-query: Unexpected formatting in line: "%s"', line)

        __salt__["pkg_resource.add_pkg"](ret, pkg, ver)

    __salt__["pkg_resource.sort_pkglist"](ret)
    if not versions_as_list:
        __salt__["pkg_resource.stringify"](ret)
    return ret


def list_upgrades(refresh=True, **kwargs):
    """
    Check whether or not an upgrade is available for all packages

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.list_upgrades
    """

    # sample output of 'xbps-install -un':
    #     fuse-2.9.4_4 update i686 http://repo.voidlinux.eu/current 298133 91688
    #     xtools-0.34_1 update noarch http://repo.voidlinux.eu/current 21424 10752

    refresh = salt.utils.data.is_true(refresh)

    # Refresh repo index before checking for latest version available
    if refresh:
        refresh_db()

    ret = {}

    # retrieve list of updatable packages
    cmd = "xbps-install -un"
    out = __salt__["cmd.run"](cmd, output_loglevel="trace")
    for line in out.splitlines():
        if not line:
            continue
        pkg = "base-system"
        ver = "NonNumericValueIsError"
        try:
            pkg, ver = line.split()[0].rsplit("-", 1)
        except (ValueError, IndexError):
            log.error('xbps-query: Unexpected formatting in line: "%s"', line)
            continue

        log.trace("pkg=%s version=%s", pkg, ver)
        ret[pkg] = ver

    return ret


def latest_version(*names, **kwargs):
    """
    Return the latest version of the named package available for upgrade or
    installation. If more than one package name is specified, a dict of
    name/version pairs is returned.

    If the latest version of a given package is already installed, an empty
    string will be returned for that package.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.latest_version &lt;package name&gt;
        salt '*' pkg.latest_version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt; ...
    """

    # Why using 'xbps-install -un' and not 'xbps-query -R':
    # if several repos, xbps-query will produces this kind of output,
    # that is difficult to handle correctly:
    #     [*] salt-2015.8.3_2 Remote execution system ...
    #     [-] salt-2015.8.3_1 Remote execution system ...
    #
    # XXX 'xbps-install -un pkg1 pkg2' won't produce any info on updatable pkg1
    #     if pkg2 is up-to-date. Bug of xbps 0.51, probably get fixed in 0.52.
    #     See related issue https://github.com/voidlinux/xbps/issues/145
    #
    # sample outputs of 'xbps-install -un':
    #     fuse-2.9.4_4 update i686 http://repo.voidlinux.eu/current 298133 91688
    #     xtools-0.34_1 update noarch http://repo.voidlinux.eu/current 21424 10752
    #     Package 'vim' is up to date.

    refresh = salt.utils.data.is_true(kwargs.pop("refresh", True))

    if len(names) == 0:
        return ""

    # Refresh repo index before checking for latest version available
    if refresh:
        refresh_db()

    # Initialize the dict with empty strings
    ret = {}
    for name in names:
        ret[name] = ""

    # retrieve list of updatable packages
    # ignore return code since 'is up to date' case produces retcode==17 (xbps 0.51)
    cmd = ["xbps-install", "-un"]
    cmd.extend(names)
    out = __salt__["cmd.run"](cmd, ignore_retcode=True, output_loglevel="trace")
    for line in out.splitlines():
        if not line:
            continue
        if line.find(" is up to date.") != -1:
            continue
        # retrieve tuple pkgname version
        try:
            pkg, ver = line.split()[0].rsplit("-", 1)
        except (ValueError, IndexError):
            log.error('xbps-query: Unexpected formatting in line: "%s"', line)
            continue

        log.trace("pkg=%s version=%s", pkg, ver)
        if pkg in names:
            ret[pkg] = ver

    # Return a string if only one package name passed
    if len(names) == 1:
        return ret[names[0]]
    return ret


# available_version is being deprecated
available_version = latest_version


def upgrade_available(name, **kwargs):
    """
    Check whether or not an upgrade is available for a given package

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.upgrade_available &lt;package name&gt;
    """
    return latest_version(name) != ""


def refresh_db(**kwargs):
    """
    Update list of available packages from installed repos

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.refresh_db
    """
    # Remove rtag file to keep multiple refreshes from happening in pkg states
    salt.utils.pkg.clear_rtag(__opts__)
    cmd = "xbps-install -Sy"
    call = __salt__["cmd.run_all"](cmd, output_loglevel="trace")
    if call["retcode"] != 0:
        comment = ""
        if "stderr" in call:
            comment += call["stderr"]

        raise CommandExecutionError(comment)

    return True


def version(*names, **kwargs):
    """
    Returns a string representing the package version or an empty string if not
    installed. If more than one package name is specified, a dict of
    name/version pairs is returned.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.version &lt;package name&gt;
        salt '*' pkg.version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt; ...
    """
    return __salt__["pkg_resource.version"](*names, **kwargs)


def upgrade(refresh=True, **kwargs):
    """
    Run a full system upgrade

    refresh
        Whether or not to refresh the package database before installing.
        Default is `True`.

    Returns a dictionary containing the changes:

    .. code-block:: python

        {'&lt;package&gt;':  {'old': '&lt;old-version&gt;',
                        'new': '&lt;new-version&gt;'}}

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.upgrade
    """

    # XXX if xbps has to be upgraded, 2 times is required to fully upgrade
    # system: one for xbps, a subsequent one for all other packages. Not
    # handled in this code.

    old = list_pkgs()

    cmd = ["xbps-install", "-{}yu".format("S" if refresh else "")]
    result = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)

    if result["retcode"] != 0:
        raise CommandExecutionError(
            "Problem encountered upgrading packages",
            info={"changes": ret, "result": result},
        )

    return ret


def install(name=None, refresh=False, fromrepo=None, pkgs=None, sources=None, **kwargs):
    """
    Install the passed package

    name
        The name of the package to be installed.

    refresh
        Whether or not to refresh the package database before installing.

    fromrepo
        Specify a package repository (url) to install from.


    Multiple Package Installation Options:

    pkgs
        A list of packages to install from a software repository. Must be
        passed as a python list.

        CLI Example:

        .. code-block:: bash

            salt '*' pkg.install pkgs='["foo","bar"]'

    sources
        A list of packages to install. Must be passed as a list of dicts,
        with the keys being package names, and the values being the source URI
        or local path to the package.

        CLI Example:

        .. code-block:: bash

            salt '*' pkg.install sources='[{"foo": "salt://foo.deb"},{"bar": "salt://bar.deb"}]'

    Return a dict containing the new package names and versions::

        {'&lt;package&gt;': {'old': '&lt;old-version&gt;',
                       'new': '&lt;new-version&gt;'}}

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.install &lt;package name&gt;
    """

    # XXX sources is not yet used in this code

    try:
        pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
            name, pkgs, sources, **kwargs
        )
    except MinionError as exc:
        raise CommandExecutionError(exc)

    if pkg_params is None or len(pkg_params) == 0:
        return {}

    if pkg_type != "repository":
        log.error('xbps: pkg_type "%s" not supported.', pkg_type)
        return {}

    cmd = ["xbps-install"]

    if refresh:
        cmd.append("-S")  # update repo db
    if fromrepo:
        cmd.append("--repository={}".format(fromrepo))
    cmd.append("-y")  # assume yes when asked
    cmd.extend(pkg_params)

    old = list_pkgs()
    __salt__["cmd.run"](cmd, output_loglevel="trace")
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()

    _rehash()
    return salt.utils.data.compare_dicts(old, new)


def remove(name=None, pkgs=None, recursive=True, **kwargs):
    """
    name
        The name of the package to be deleted.

    recursive
        Also remove dependent packages (not required elsewhere).
        Default mode: enabled.

    Multiple Package Options:

    pkgs
        A list of packages to delete. Must be passed as a python list. The
        ``name`` parameter will be ignored if this option is passed.

    Returns a list containing the removed packages.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.remove &lt;package name&gt; [recursive=False]
        salt '*' pkg.remove &lt;package1&gt;,&lt;package2&gt;,&lt;package3&gt; [recursive=False]
        salt '*' pkg.remove pkgs='["foo", "bar"]' [recursive=False]
    """

    try:
        pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](name, pkgs)
    except MinionError as exc:
        raise CommandExecutionError(exc)

    if not pkg_params:
        return {}

    old = list_pkgs()

    # keep only installed packages
    targets = [x for x in pkg_params if x in old]
    if not targets:
        return {}

    cmd = ["xbps-remove", "-y"]
    if recursive:
        cmd.append("-R")
    cmd.extend(targets)
    __salt__["cmd.run"](cmd, output_loglevel="trace")
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()

    return salt.utils.data.compare_dicts(old, new)


def list_repos(**kwargs):
    """
    List all repos known by XBPS

    CLI Example:

    .. code-block:: bash

       salt '*' pkg.list_repos
    """
    repos = {}
    out = __salt__["cmd.run"]("xbps-query -L", output_loglevel="trace")
    for line in out.splitlines():
        repo = {}
        if not line:
            continue
        try:
            nb, url, rsa = line.strip().split(" ", 2)
        except ValueError:
            log.error(
                'Problem parsing xbps-query: Unexpected formatting in line: "%s"',
                line,
            )
        repo["nbpkg"] = int(nb) if nb.isdigit() else 0
        repo["url"] = url
        repo["rsasigned"] = True if rsa == "(RSA signed)" else False
        repos[repo["url"]] = repo
    return repos


def get_repo(repo, **kwargs):
    """
    Display information about the repo.

    CLI Examples:

    .. code-block:: bash

        salt '*' pkg.get_repo 'repo-url'
    """
    repos = list_repos()
    if repo in repos:
        return repos[repo]
    return {}


def _locate_repo_files(repo, rewrite=False):
    """
    Find what file a repo is called in.

    Helper function for add_repo() and del_repo()

    repo
        url of the repo to locate (persistent).

    rewrite
        Whether to remove matching repository settings during this process.

    Returns a list of absolute paths.
    """

    ret_val = []
    files = []
    conf_dirs = ["/etc/xbps.d/", "/usr/share/xbps.d/"]
    name_glob = "*.conf"
    # Matches a line where first printing is "repository" and there is an equals
    # sign before the repo, an optional forwardslash at the end of the repo name,
    # and it's possible for there to be a comment after repository=repo
    regex = re.compile(r"\s*repository\s*=\s*" + repo + r"/?\s*(#.*)?$")

    for cur_dir in conf_dirs:
        files.extend(glob.glob(cur_dir + name_glob))

    for filename in files:
        write_buff = []
        with salt.utils.files.fopen(filename, "r") as cur_file:
            for line in cur_file:
                if regex.match(salt.utils.stringutils.to_unicode(line)):
                    ret_val.append(filename)
                else:
                    write_buff.append(line)
        if rewrite and filename in ret_val:
            if len(write_buff) &gt; 0:
                with salt.utils.files.fopen(filename, "w") as rewrite_file:
                    rewrite_file.writelines(write_buff)
            else:  # Prune empty files
                os.remove(filename)

    return ret_val


def add_repo(repo, conffile="/usr/share/xbps.d/15-saltstack.conf"):
    """
    Add an XBPS repository to the system.

    repo
        url of repo to add (persistent).

    conffile
        path to xbps conf file to add this repo
        default: /usr/share/xbps.d/15-saltstack.conf

    CLI Examples:

    .. code-block:: bash

        salt '*' pkg.add_repo &lt;repo url&gt; [conffile=/path/to/xbps/repo.conf]
    """

    if len(_locate_repo_files(repo)) == 0:
        try:
            with salt.utils.files.fopen(conffile, "a+") as conf_file:
                conf_file.write(
                    salt.utils.stringutils.to_str("repository={}\n".format(repo))
                )
        except OSError:
            return False

    return True


def del_repo(repo, **kwargs):
    """
    Remove an XBPS repository from the system.

    repo
        url of repo to remove (persistent).

    CLI Examples:

    .. code-block:: bash

        salt '*' pkg.del_repo &lt;repo url&gt;
    """

    try:
        _locate_repo_files(repo, rewrite=True)
    except OSError:
        return False
    else:
        return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>key_5.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
The Salt Key backend API and interface used by the CLI. The Key class can be
used to manage salt keys directly without interfacing with the CLI.
"""

import fnmatch
import itertools
import logging
import os
import shutil
import sys

import salt.cache
import salt.client
import salt.crypt
<a name="0"></a>import salt.daemons.masterapi
import salt.exceptions
import salt.minion
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.args
import salt.utils.crypt
import salt.utils.data
import salt.utils.event
import salt.utils.files
import salt.utils.json
import salt.utils.kinds
import salt.utils.master
import salt.utils.sdb
import salt.utils.stringutils
import salt.utils.user

log = logging.getLogger(</b></font>__name__)


def get_key(opts):
    return Key(opts)


class KeyCLI:
    """
    Manage key CLI operations
    """

    CLI_KEY_MAP = {
        "list": "list_status",
        "delete": "delete_key",
        "gen_signature": "gen_keys_signature",
        "print": "key_str",
    }

    def __init__(self, opts):
        self.opts = opts
        self.client = salt.wheel.WheelClient(opts)
        self.key = Key
        # instantiate the key object for masterless mode
        if not opts.get("eauth"):
            self.key = self.key(opts)
        self.auth = None

    def _update_opts(self):
        # get the key command
        for cmd in (
            "gen_keys",
            "gen_signature",
            "list",
            "list_all",
            "print",
            "print_all",
            "accept",
            "accept_all",
            "reject",
            "reject_all",
            "delete",
            "delete_all",
            "finger",
            "finger_all",
            "list_all",
        ):  # last is default
            if self.opts[cmd]:
                break
        # set match if needed
        if not cmd.startswith("gen_"):
            if cmd == "list_all":
                self.opts["match"] = "all"
            elif cmd.endswith("_all"):
                self.opts["match"] = "*"
            else:
                self.opts["match"] = self.opts[cmd]
            if cmd.startswith("accept"):
                self.opts["include_rejected"] = (
                    self.opts["include_all"] or self.opts["include_rejected"]
                )
                self.opts["include_accepted"] = False
            elif cmd.startswith("reject"):
                self.opts["include_accepted"] = (
                    self.opts["include_all"] or self.opts["include_accepted"]
                )
                self.opts["include_rejected"] = False
        elif cmd == "gen_keys":
            self.opts["keydir"] = self.opts["gen_keys_dir"]
            self.opts["keyname"] = self.opts["gen_keys"]
        # match is set to opts, now we can forget about *_all commands
        self.opts["fun"] = cmd.replace("_all", "")

    def _init_auth(self):
        if self.auth:
            return

        low = {}
        skip_perm_errors = self.opts["eauth"] != ""

        if self.opts["eauth"]:
            if "token" in self.opts:
                try:
                    with salt.utils.files.fopen(
                        os.path.join(self.opts["cachedir"], ".root_key"), "r"
                    ) as fp_:
                        low["key"] = salt.utils.stringutils.to_unicode(fp_.readline())
                except OSError:
                    low["token"] = self.opts["token"]
            #
            # If using eauth and a token hasn't already been loaded into
            # low, prompt the user to enter auth credentials
            if "token" not in low and "key" not in low and self.opts["eauth"]:
                # This is expensive. Don't do it unless we need to.
                resolver = salt.auth.Resolver(self.opts)
                res = resolver.cli(self.opts["eauth"])
                if self.opts["mktoken"] and res:
                    tok = resolver.token_cli(self.opts["eauth"], res)
                    if tok:
                        low["token"] = tok.get("token", "")
                if not res:
                    log.error("Authentication failed")
                    return {}
                low.update(res)
                low["eauth"] = self.opts["eauth"]
        else:
            low["user"] = salt.utils.user.get_specific_user()
            low["key"] = salt.utils.master.get_master_key(
                low["user"], self.opts, skip_perm_errors
            )

        self.auth = low

    def _get_args_kwargs(self, fun, args=None):
        argspec = salt.utils.args.get_function_argspec(fun)
        if args is None:
            args = []
            if argspec.args:
                # Iterate in reverse order to ensure we get the correct default
                # value for the positional argument.
                for arg, default in itertools.zip_longest(
                    reversed(argspec.args), reversed(argspec.defaults or ())
                ):
                    args.append(self.opts.get(arg, default))
            # Reverse the args so that they are in the correct order
            args = args[::-1]

        if argspec.keywords is None:
            kwargs = {}
        else:
            args, kwargs = salt.minion.load_args_and_kwargs(fun, args)
        return args, kwargs

    def _run_cmd(self, cmd, args=None):
        if not self.opts.get("eauth"):
            cmd = self.CLI_KEY_MAP.get(cmd, cmd)
            fun = getattr(self.key, cmd)
            args, kwargs = self._get_args_kwargs(fun, args)
            ret = fun(*args, **kwargs)
            if (
                isinstance(ret, dict)
                and "local" in ret
                and cmd not in ("finger", "finger_all")
            ):
                ret.pop("local", None)
            return ret

        if cmd in ("accept", "reject", "delete") and args is None:
            args = self.opts.get("match_dict", {}).get("minions")
        fstr = "key.{}".format(cmd)
        fun = self.client.functions[fstr]
        args, kwargs = self._get_args_kwargs(fun, args)

        low = {
            "fun": fstr,
            "arg": args,
            "kwarg": kwargs,
        }

        self._init_auth()
        low.update(self.auth)

        # Execute the key request!
        ret = self.client.cmd_sync(low)

        ret = ret["data"]["return"]
        if (
            isinstance(ret, dict)
            and "local" in ret
            and cmd not in ("finger", "finger_all")
        ):
            ret.pop("local", None)

        return ret

    def _filter_ret(self, cmd, ret):
        if cmd.startswith("delete"):
            return ret

        keys = {}
        if self.key.PEND in ret:
            keys[self.key.PEND] = ret[self.key.PEND]
        if self.opts["include_accepted"] and bool(ret.get(self.key.ACC)):
            keys[self.key.ACC] = ret[self.key.ACC]
        if self.opts["include_rejected"] and bool(ret.get(self.key.REJ)):
            keys[self.key.REJ] = ret[self.key.REJ]
        if self.opts["include_denied"] and bool(ret.get(self.key.DEN)):
            keys[self.key.DEN] = ret[self.key.DEN]
        return keys

    def _print_no_match(self, cmd, match):
        statuses = ["unaccepted"]
        if self.opts["include_accepted"]:
            statuses.append("accepted")
        if self.opts["include_rejected"]:
            statuses.append("rejected")
        if self.opts["include_denied"]:
            statuses.append("denied")
        if len(statuses) == 1:
            stat_str = statuses[0]
        else:
            stat_str = "{} or {}".format(", ".join(statuses[:-1]), statuses[-1])
        msg = "The key glob '{}' does not match any {} keys.".format(match, stat_str)
        print(msg)

    def run(self):
        """
        Run the logic for saltkey
        """
        self._update_opts()
        cmd = self.opts["fun"]

        veri = None
        ret = None
        try:
            if cmd in ("accept", "reject", "delete"):
                ret = self._run_cmd("name_match")
                if not isinstance(ret, dict):
                    salt.output.display_output(ret, "key", opts=self.opts)
                    return ret
                ret = self._filter_ret(cmd, ret)
                if not ret:
                    self._print_no_match(cmd, self.opts["match"])
                    return
                print(
                    "The following keys are going to be {}ed:".format(cmd.rstrip("e"))
                )
                salt.output.display_output(ret, "key", opts=self.opts)

                if not self.opts.get("yes", False):
                    try:
                        if cmd.startswith("delete"):
                            veri = input("Proceed? [N/y] ")
                            if not veri:
                                veri = "n"
                        else:
                            veri = input("Proceed? [n/Y] ")
                            if not veri:
                                veri = "y"
                    except KeyboardInterrupt:
                        raise SystemExit("\nExiting on CTRL-c")
                # accept/reject/delete the same keys we're printed to the user
                self.opts["match_dict"] = ret
                self.opts.pop("match", None)
                list_ret = ret

            if veri is None or veri.lower().startswith("y"):
                ret = self._run_cmd(cmd)
                if cmd in ("accept", "reject", "delete"):
                    if cmd == "delete":
                        ret = list_ret
                    for minions in ret.values():
                        for minion in minions:
                            print(
                                "Key for minion {} {}ed.".format(
                                    minion, cmd.rstrip("e")
                                )
                            )
                elif isinstance(ret, dict):
                    salt.output.display_output(ret, "key", opts=self.opts)
                else:
                    salt.output.display_output({"return": ret}, "key", opts=self.opts)
        except salt.exceptions.SaltException as exc:
            ret = "{}".format(exc)
            if not self.opts.get("quiet", False):
                salt.output.display_output(ret, "nested", self.opts)
        return ret


class Key:
    """
    The object that encapsulates saltkey actions
    """

    ACC = "minions"
    PEND = "minions_pre"
    REJ = "minions_rejected"
    DEN = "minions_denied"

    def __init__(self, opts, io_loop=None):
        self.opts = opts
        kind = self.opts.get("__role", "")  # application kind
        if kind not in salt.utils.kinds.APPL_KINDS:
            emsg = "Invalid application kind = '{}'.".format(kind)
            log.error(emsg)
            raise ValueError(emsg)
        self.event = salt.utils.event.get_event(
            kind,
            opts["sock_dir"],
            opts=opts,
            listen=False,
            io_loop=io_loop,
        )

        self.passphrase = salt.utils.sdb.sdb_get(
            self.opts.get("signing_key_pass"), self.opts
        )

    def _check_minions_directories(self):
        """
        Return the minion keys directory paths
        """
        minions_accepted = os.path.join(self.opts["pki_dir"], self.ACC)
        minions_pre = os.path.join(self.opts["pki_dir"], self.PEND)
        minions_rejected = os.path.join(self.opts["pki_dir"], self.REJ)

        minions_denied = os.path.join(self.opts["pki_dir"], self.DEN)
        return minions_accepted, minions_pre, minions_rejected, minions_denied

    def _get_key_attrs(self, keydir, keyname, keysize, user):
        if not keydir:
            if "gen_keys_dir" in self.opts:
                keydir = self.opts["gen_keys_dir"]
            else:
                keydir = self.opts["pki_dir"]
        if not keyname:
            if "gen_keys" in self.opts:
                keyname = self.opts["gen_keys"]
            else:
                keyname = "minion"
        if not keysize:
            keysize = self.opts["keysize"]
        return keydir, keyname, keysize, user

    def gen_keys(self, keydir=None, keyname=None, keysize=None, user=None):
        """
        Generate minion RSA public keypair
        """
        keydir, keyname, keysize, user = self._get_key_attrs(
            keydir, keyname, keysize, user
        )
        salt.crypt.gen_keys(keydir, keyname, keysize, user, self.passphrase)
        return salt.utils.crypt.pem_finger(os.path.join(keydir, keyname + ".pub"))

    def gen_signature(self, privkey, pubkey, sig_path):
        """
        Generate master public-key-signature
        """
        return salt.crypt.gen_signature(privkey, pubkey, sig_path, self.passphrase)

    def gen_keys_signature(
        self, priv, pub, signature_path, auto_create=False, keysize=None
    ):
        """
        Generate master public-key-signature
        """
        # check given pub-key
        if pub:
            if not os.path.isfile(pub):
                return "Public-key {} does not exist".format(pub)
        # default to master.pub
        else:
            mpub = self.opts["pki_dir"] + "/" + "master.pub"
            if os.path.isfile(mpub):
                pub = mpub

        # check given priv-key
        if priv:
            if not os.path.isfile(priv):
                return "Private-key {} does not exist".format(priv)
        # default to master_sign.pem
        else:
            mpriv = self.opts["pki_dir"] + "/" + "master_sign.pem"
            if os.path.isfile(mpriv):
                priv = mpriv

        if not priv:
            if auto_create:
                log.debug(
                    "Generating new signing key-pair .%s.* in %s",
                    self.opts["master_sign_key_name"],
                    self.opts["pki_dir"],
                )
                salt.crypt.gen_keys(
                    self.opts["pki_dir"],
                    self.opts["master_sign_key_name"],
                    keysize or self.opts["keysize"],
                    self.opts.get("user"),
                    self.passphrase,
                )

                priv = (
                    self.opts["pki_dir"]
                    + "/"
                    + self.opts["master_sign_key_name"]
                    + ".pem"
                )
            else:
                return "No usable private-key found"

        if not pub:
            return "No usable public-key found"

        log.debug("Using public-key %s", pub)
        log.debug("Using private-key %s", priv)

        if signature_path:
            if not os.path.isdir(signature_path):
                log.debug("target directory %s does not exist", signature_path)
        else:
            signature_path = self.opts["pki_dir"]

        sign_path = signature_path + "/" + self.opts["master_pubkey_signature"]

        skey = get_key(self.opts)
        return skey.gen_signature(priv, pub, sign_path)

    def check_minion_cache(self, preserve_minions=None):
        """
        Check the minion cache to make sure that old minion data is cleared

        Optionally, pass in a list of minions which should have their caches
        preserved. To preserve all caches, set __opts__['preserve_minion_cache']
        """
        if preserve_minions is None:
            preserve_minions = []
        keys = self.list_keys()
        minions = []
        for key, val in keys.items():
            minions.extend(val)
        if not self.opts.get("preserve_minion_cache", False):
            m_cache = os.path.join(self.opts["cachedir"], self.ACC)
            if os.path.isdir(m_cache):
                for minion in os.listdir(m_cache):
                    if minion not in minions and minion not in preserve_minions:
                        try:
                            shutil.rmtree(os.path.join(m_cache, minion))
                        except OSError as ex:
                            log.warning(
                                "Key: Delete cache for %s got OSError/IOError: %s \n",
                                minion,
                                ex,
                            )
                            continue
            cache = salt.cache.factory(self.opts)
            clist = cache.list(self.ACC)
            if clist:
                for minion in clist:
                    if minion not in minions and minion not in preserve_minions:
                        cache.flush("{}/{}".format(self.ACC, minion))

    def check_master(self):
        """
        Log if the master is not running

        :rtype: bool
        :return: Whether or not the master is running
        """
        if not os.path.exists(os.path.join(self.opts["sock_dir"], "publish_pull.ipc")):
            return False
        return True

    def name_match(self, match, full=False):
        """
        Accept a glob which to match the of a key and return the key's location
        """
        if full:
            matches = self.all_keys()
        else:
            matches = self.list_keys()
        ret = {}
        if "," in match and isinstance(match, str):
            match = match.split(",")
        for status, keys in matches.items():
            for key in salt.utils.data.sorted_ignorecase(keys):
                if isinstance(match, list):
                    for match_item in match:
                        if fnmatch.fnmatch(key, match_item):
                            if status not in ret:
                                ret[status] = []
                            ret[status].append(key)
                else:
                    if fnmatch.fnmatch(key, match):
                        if status not in ret:
                            ret[status] = []
                        ret[status].append(key)
        return ret

    def dict_match(self, match_dict):
        """
        Accept a dictionary of keys and return the current state of the
        specified keys
        """
        ret = {}
        cur_keys = self.list_keys()
        for status, keys in match_dict.items():
            for key in salt.utils.data.sorted_ignorecase(keys):
                for keydir in (self.ACC, self.PEND, self.REJ, self.DEN):
                    if keydir and fnmatch.filter(cur_keys.get(keydir, []), key):
                        ret.setdefault(keydir, []).append(key)
        return ret

    def local_keys(self):
        """
        Return a dict of local keys
        """
        ret = {"local": []}
        for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(self.opts["pki_dir"])):
            if fn_.endswith(".pub") or fn_.endswith(".pem"):
                path = os.path.join(self.opts["pki_dir"], fn_)
                if os.path.isfile(path):
                    ret["local"].append(fn_)
        return ret

    def list_keys(self):
        """
        Return a dict of managed keys and what the key status are
        """
        key_dirs = self._check_minions_directories()

        ret = {}

        for dir_ in key_dirs:
            if dir_ is None:
                continue
            ret[os.path.basename(dir_)] = []
            try:
                for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(dir_)):
                    if not fn_.startswith("."):
                        if os.path.isfile(os.path.join(dir_, fn_)):
                            ret[os.path.basename(dir_)].append(
                                salt.utils.stringutils.to_unicode(fn_)
                            )
            except OSError:
                # key dir kind is not created yet, just skip
                continue
        return ret

    def all_keys(self):
        """
        Merge managed keys with local keys
        """
        keys = self.list_keys()
        keys.update(self.local_keys())
        return keys

    def list_status(self, match):
        """
        Return a dict of managed keys under a named status
        """
        acc, pre, rej, den = self._check_minions_directories()
        ret = {}
        if match.startswith("acc"):
            ret[os.path.basename(acc)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(acc)):
                if not fn_.startswith("."):
                    if os.path.isfile(os.path.join(acc, fn_)):
                        ret[os.path.basename(acc)].append(fn_)
        elif match.startswith("pre") or match.startswith("un"):
            ret[os.path.basename(pre)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(pre)):
                if not fn_.startswith("."):
                    if os.path.isfile(os.path.join(pre, fn_)):
                        ret[os.path.basename(pre)].append(fn_)
        elif match.startswith("rej"):
            ret[os.path.basename(rej)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(rej)):
                if not fn_.startswith("."):
                    if os.path.isfile(os.path.join(rej, fn_)):
                        ret[os.path.basename(rej)].append(fn_)
        elif match.startswith("den") and den is not None:
            ret[os.path.basename(den)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(den)):
                if not fn_.startswith("."):
                    if os.path.isfile(os.path.join(den, fn_)):
                        ret[os.path.basename(den)].append(fn_)
        elif match.startswith("all"):
            return self.all_keys()
        return ret

    def key_str(self, match):
        """
        Return the specified public key or keys based on a glob
        """
        ret = {}
        for status, keys in self.name_match(match).items():
            ret[status] = {}
            for key in salt.utils.data.sorted_ignorecase(keys):
                path = os.path.join(self.opts["pki_dir"], status, key)
                with salt.utils.files.fopen(path, "r") as fp_:
                    ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
        return ret

    def key_str_all(self):
        """
        Return all managed key strings
        """
        ret = {}
        for status, keys in self.list_keys().items():
            ret[status] = {}
            for key in salt.utils.data.sorted_ignorecase(keys):
                path = os.path.join(self.opts["pki_dir"], status, key)
                with salt.utils.files.fopen(path, "r") as fp_:
                    ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
        return ret

    def accept(
        self, match=None, match_dict=None, include_rejected=False, include_denied=False
    ):
        """
        Accept public keys. If "match" is passed, it is evaluated as a glob.
        Pre-gathered matches can also be passed via "match_dict".
        """
        if match is not None:
            matches = self.name_match(match)
        elif match_dict is not None and isinstance(match_dict, dict):
            matches = match_dict
        else:
            matches = {}
        keydirs = [self.PEND]
        if include_rejected:
            keydirs.append(self.REJ)
        if include_denied:
            keydirs.append(self.DEN)
        invalid_keys = []
        for keydir in keydirs:
            for key in matches.get(keydir, []):
                key_path = os.path.join(self.opts["pki_dir"], keydir, key)
                try:
                    salt.crypt.get_rsa_pub_key(key_path)
                except salt.exceptions.InvalidKeyError:
                    log.error("Invalid RSA public key: %s", key)
                    invalid_keys.append((keydir, key))
                    continue
                try:
                    shutil.move(
                        key_path,
                        os.path.join(self.opts["pki_dir"], self.ACC, key),
                    )
                    eload = {"result": True, "act": "accept", "id": key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
                except OSError:
                    pass
        for keydir, key in invalid_keys:
            matches[keydir].remove(key)
            sys.stderr.write("Unable to accept invalid key for {}.\n".format(key))
        return self.name_match(match) if match is not None else self.dict_match(matches)

    def accept_all(self):
        """
        Accept all keys in pre
        """
        keys = self.list_keys()
        for key in keys[self.PEND]:
            try:
                shutil.move(
                    os.path.join(self.opts["pki_dir"], self.PEND, key),
                    os.path.join(self.opts["pki_dir"], self.ACC, key),
                )
                eload = {"result": True, "act": "accept", "id": key}
                self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
            except OSError:
                pass
        return self.list_keys()

    def delete_key(
        self, match=None, match_dict=None, preserve_minions=None, revoke_auth=False
    ):
        """
        Delete public keys. If "match" is passed, it is evaluated as a glob.
        Pre-gathered matches can also be passed via "match_dict".

        To preserve the master caches of minions who are matched, set preserve_minions
        """
        if match is not None:
            matches = self.name_match(match)
        elif match_dict is not None and isinstance(match_dict, dict):
            matches = match_dict
        else:
            matches = {}
        with salt.client.get_local_client(mopts=self.opts) as client:
            for status, keys in matches.items():
                for key in keys:
                    try:
                        if revoke_auth:
                            if self.opts.get("rotate_aes_key") is False:
                                print(
                                    "Immediate auth revocation specified but AES key"
                                    " rotation not allowed. Minion will not be"
                                    " disconnected until the master AES key is rotated."
                                )
                            else:
                                try:
                                    client.cmd_async(key, "saltutil.revoke_auth")
                                except salt.exceptions.SaltClientError:
                                    print(
                                        "Cannot contact Salt master. "
                                        "Connection for {} will remain up until "
                                        "master AES key is rotated or auth is revoked "
                                        "with 'saltutil.revoke_auth'.".format(key)
                                    )
                        os.remove(os.path.join(self.opts["pki_dir"], status, key))
                        eload = {"result": True, "act": "delete", "id": key}
                        self.event.fire_event(
                            eload, salt.utils.event.tagify(prefix="key")
                        )
                    except OSError:
                        pass
        if self.opts.get("preserve_minions") is True:
            self.check_minion_cache(preserve_minions=matches.get("minions", []))
        else:
            self.check_minion_cache()
        if self.opts.get("rotate_aes_key"):
            salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
        return self.name_match(match) if match is not None else self.dict_match(matches)

    def delete_den(self):
        """
        Delete all denied keys
        """
        keys = self.list_keys()
        for status, keys in self.list_keys().items():
            for key in keys[self.DEN]:
                try:
                    os.remove(os.path.join(self.opts["pki_dir"], status, key))
                    eload = {"result": True, "act": "delete", "id": key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
                except OSError:
                    pass
        self.check_minion_cache()
        return self.list_keys()

    def delete_all(self):
        """
        Delete all keys
        """
        for status, keys in self.list_keys().items():
            for key in keys:
                try:
                    os.remove(os.path.join(self.opts["pki_dir"], status, key))
                    eload = {"result": True, "act": "delete", "id": key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
                except OSError:
                    pass
        self.check_minion_cache()
        if self.opts.get("rotate_aes_key"):
            salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
        return self.list_keys()

    def reject(
        self, match=None, match_dict=None, include_accepted=False, include_denied=False
    ):
        """
        Reject public keys. If "match" is passed, it is evaluated as a glob.
        Pre-gathered matches can also be passed via "match_dict".
        """
        if match is not None:
            matches = self.name_match(match)
        elif match_dict is not None and isinstance(match_dict, dict):
            matches = match_dict
        else:
            matches = {}
        keydirs = [self.PEND]
        if include_accepted:
            keydirs.append(self.ACC)
        if include_denied:
            keydirs.append(self.DEN)
        for keydir in keydirs:
            for key in matches.get(keydir, []):
                try:
                    shutil.move(
                        os.path.join(self.opts["pki_dir"], keydir, key),
                        os.path.join(self.opts["pki_dir"], self.REJ, key),
                    )
                    eload = {"result": True, "act": "reject", "id": key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
                except OSError:
                    pass
        self.check_minion_cache()
        if self.opts.get("rotate_aes_key"):
            salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
        return self.name_match(match) if match is not None else self.dict_match(matches)

    def reject_all(self):
        """
        Reject all keys in pre
        """
        keys = self.list_keys()
        for key in keys[self.PEND]:
            try:
                shutil.move(
                    os.path.join(self.opts["pki_dir"], self.PEND, key),
                    os.path.join(self.opts["pki_dir"], self.REJ, key),
                )
                eload = {"result": True, "act": "reject", "id": key}
                self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
            except OSError:
                pass
        self.check_minion_cache()
        if self.opts.get("rotate_aes_key"):
            salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
        return self.list_keys()

    def finger(self, match, hash_type=None):
        """
        Return the fingerprint for a specified key
        """
        if hash_type is None:
            hash_type = __opts__["hash_type"]

        matches = self.name_match(match, True)
        ret = {}
        for status, keys in matches.items():
            ret[status] = {}
            for key in keys:
                if status == "local":
                    path = os.path.join(self.opts["pki_dir"], key)
                else:
                    path = os.path.join(self.opts["pki_dir"], status, key)
                ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
        return ret

    def finger_all(self, hash_type=None):
        """
        Return fingerprints for all keys
        """
        if hash_type is None:
            hash_type = __opts__["hash_type"]

        ret = {}
        for status, keys in self.all_keys().items():
            ret[status] = {}
            for key in keys:
                if status == "local":
                    path = os.path.join(self.opts["pki_dir"], key)
                else:
                    path = os.path.join(self.opts["pki_dir"], status, key)
                ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
        return ret

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.event.destroy()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
