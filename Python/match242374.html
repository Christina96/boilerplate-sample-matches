<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for xbpspkg.py & key_5.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for xbpspkg.py & key_5.py
      </h3>
      <h1 align="center">
        1.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>xbpspkg.py (2.6119404%)<TH>key_5.py (0.7667032%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match242374-0.html#0',2,'match242374-1.html#0',3)" NAME="0">(9-22)<TD><A HREF="javascript:ZweiFrames('match242374-0.html#0',2,'match242374-1.html#0',3)" NAME="0">(19-31)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>xbpspkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Package support for XBPS package manager (used by VoidLinux)

.. versionadded:: 2016.11.0
&quot;&quot;&quot;
<A NAME="0"></A>
# TODO: what about the initial acceptance of repo's fingerprint when adding a new repo?

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match242374-1.html#0',3,'match242374-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import glob
import logging
import os
import re

import salt.utils.data
import salt.utils.decorators as decorators
import salt.utils.files
import salt.utils.path
import salt.utils.pkg
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError, MinionError

log = logging.getLogger(</B></FONT>__name__)

# Define the module's virtual name
__virtualname__ = &quot;pkg&quot;


def __virtual__():
    &quot;&quot;&quot;
    Set the virtual pkg module if the os is Void and xbps-install found
    &quot;&quot;&quot;
    if __grains__[&quot;os&quot;] in (&quot;Void&quot;) and _check_xbps():
        return __virtualname__
    return (False, &quot;Missing dependency: xbps-install&quot;)


@decorators.memoize
def _check_xbps():
    &quot;&quot;&quot;
    Looks to see if xbps-install is present on the system, return full path
    &quot;&quot;&quot;
    return salt.utils.path.which(&quot;xbps-install&quot;)


@decorators.memoize
def _get_version():
    &quot;&quot;&quot;
    Get the xbps version
    &quot;&quot;&quot;
    version_string = __salt__[&quot;cmd.run&quot;](
        [_check_xbps(), &quot;--version&quot;], output_loglevel=&quot;trace&quot;
    )
    if version_string is None:
        # Dunno why it would, but...
        return False

    VERSION_MATCH = re.compile(r&quot;(?:XBPS:[\s]+)([\d.]+)(?:[\s]+.*)&quot;)
    version_match = VERSION_MATCH.search(version_string)
    if not version_match:
        return False

    return version_match.group(1).split(&quot;.&quot;)


def _rehash():
    &quot;&quot;&quot;
    Recomputes internal hash table for the PATH variable.
    Used whenever a new command is created during the current
    session.
    &quot;&quot;&quot;
    shell = __salt__[&quot;environ.get&quot;](&quot;SHELL&quot;)
    if shell.split(&quot;/&quot;)[-1] in (&quot;csh&quot;, &quot;tcsh&quot;):
        __salt__[&quot;cmd.run&quot;](&quot;rehash&quot;, output_loglevel=&quot;trace&quot;)


def list_pkgs(versions_as_list=False, **kwargs):
    &quot;&quot;&quot;
    List the packages currently installed as a dict::

        {'&lt;package_name&gt;': '&lt;version&gt;'}

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.list_pkgs
    &quot;&quot;&quot;
    versions_as_list = salt.utils.data.is_true(versions_as_list)
    # not yet implemented or not applicable
    if any(
        [salt.utils.data.is_true(kwargs.get(x)) for x in (&quot;removed&quot;, &quot;purge_desired&quot;)]
    ):
        return {}

    cmd = &quot;xbps-query -l&quot;
    ret = {}
    out = __salt__[&quot;cmd.run&quot;](cmd, output_loglevel=&quot;trace&quot;)
    for line in out.splitlines():
        if not line:
            continue
        try:
            # xbps-query -l output sample:
            # ii desktop-file-utils-0.22_4  Utilities to ...
            #
            # XXX handle package status (like 'ii') ?
            pkg, ver = line.split(None)[1].rsplit(&quot;-&quot;, 1)
        except ValueError:
            log.error('xbps-query: Unexpected formatting in line: &quot;%s&quot;', line)

        __salt__[&quot;pkg_resource.add_pkg&quot;](ret, pkg, ver)

    __salt__[&quot;pkg_resource.sort_pkglist&quot;](ret)
    if not versions_as_list:
        __salt__[&quot;pkg_resource.stringify&quot;](ret)
    return ret


def list_upgrades(refresh=True, **kwargs):
    &quot;&quot;&quot;
    Check whether or not an upgrade is available for all packages

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.list_upgrades
    &quot;&quot;&quot;

    # sample output of 'xbps-install -un':
    #     fuse-2.9.4_4 update i686 http://repo.voidlinux.eu/current 298133 91688
    #     xtools-0.34_1 update noarch http://repo.voidlinux.eu/current 21424 10752

    refresh = salt.utils.data.is_true(refresh)

    # Refresh repo index before checking for latest version available
    if refresh:
        refresh_db()

    ret = {}

    # retrieve list of updatable packages
    cmd = &quot;xbps-install -un&quot;
    out = __salt__[&quot;cmd.run&quot;](cmd, output_loglevel=&quot;trace&quot;)
    for line in out.splitlines():
        if not line:
            continue
        pkg = &quot;base-system&quot;
        ver = &quot;NonNumericValueIsError&quot;
        try:
            pkg, ver = line.split()[0].rsplit(&quot;-&quot;, 1)
        except (ValueError, IndexError):
            log.error('xbps-query: Unexpected formatting in line: &quot;%s&quot;', line)
            continue

        log.trace(&quot;pkg=%s version=%s&quot;, pkg, ver)
        ret[pkg] = ver

    return ret


def latest_version(*names, **kwargs):
    &quot;&quot;&quot;
    Return the latest version of the named package available for upgrade or
    installation. If more than one package name is specified, a dict of
    name/version pairs is returned.

    If the latest version of a given package is already installed, an empty
    string will be returned for that package.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.latest_version &lt;package name&gt;
        salt '*' pkg.latest_version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt; ...
    &quot;&quot;&quot;

    # Why using 'xbps-install -un' and not 'xbps-query -R':
    # if several repos, xbps-query will produces this kind of output,
    # that is difficult to handle correctly:
    #     [*] salt-2015.8.3_2 Remote execution system ...
    #     [-] salt-2015.8.3_1 Remote execution system ...
    #
    # XXX 'xbps-install -un pkg1 pkg2' won't produce any info on updatable pkg1
    #     if pkg2 is up-to-date. Bug of xbps 0.51, probably get fixed in 0.52.
    #     See related issue https://github.com/voidlinux/xbps/issues/145
    #
    # sample outputs of 'xbps-install -un':
    #     fuse-2.9.4_4 update i686 http://repo.voidlinux.eu/current 298133 91688
    #     xtools-0.34_1 update noarch http://repo.voidlinux.eu/current 21424 10752
    #     Package 'vim' is up to date.

    refresh = salt.utils.data.is_true(kwargs.pop(&quot;refresh&quot;, True))

    if len(names) == 0:
        return &quot;&quot;

    # Refresh repo index before checking for latest version available
    if refresh:
        refresh_db()

    # Initialize the dict with empty strings
    ret = {}
    for name in names:
        ret[name] = &quot;&quot;

    # retrieve list of updatable packages
    # ignore return code since 'is up to date' case produces retcode==17 (xbps 0.51)
    cmd = [&quot;xbps-install&quot;, &quot;-un&quot;]
    cmd.extend(names)
    out = __salt__[&quot;cmd.run&quot;](cmd, ignore_retcode=True, output_loglevel=&quot;trace&quot;)
    for line in out.splitlines():
        if not line:
            continue
        if line.find(&quot; is up to date.&quot;) != -1:
            continue
        # retrieve tuple pkgname version
        try:
            pkg, ver = line.split()[0].rsplit(&quot;-&quot;, 1)
        except (ValueError, IndexError):
            log.error('xbps-query: Unexpected formatting in line: &quot;%s&quot;', line)
            continue

        log.trace(&quot;pkg=%s version=%s&quot;, pkg, ver)
        if pkg in names:
            ret[pkg] = ver

    # Return a string if only one package name passed
    if len(names) == 1:
        return ret[names[0]]
    return ret


# available_version is being deprecated
available_version = latest_version


def upgrade_available(name, **kwargs):
    &quot;&quot;&quot;
    Check whether or not an upgrade is available for a given package

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.upgrade_available &lt;package name&gt;
    &quot;&quot;&quot;
    return latest_version(name) != &quot;&quot;


def refresh_db(**kwargs):
    &quot;&quot;&quot;
    Update list of available packages from installed repos

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.refresh_db
    &quot;&quot;&quot;
    # Remove rtag file to keep multiple refreshes from happening in pkg states
    salt.utils.pkg.clear_rtag(__opts__)
    cmd = &quot;xbps-install -Sy&quot;
    call = __salt__[&quot;cmd.run_all&quot;](cmd, output_loglevel=&quot;trace&quot;)
    if call[&quot;retcode&quot;] != 0:
        comment = &quot;&quot;
        if &quot;stderr&quot; in call:
            comment += call[&quot;stderr&quot;]

        raise CommandExecutionError(comment)

    return True


def version(*names, **kwargs):
    &quot;&quot;&quot;
    Returns a string representing the package version or an empty string if not
    installed. If more than one package name is specified, a dict of
    name/version pairs is returned.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.version &lt;package name&gt;
        salt '*' pkg.version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt; ...
    &quot;&quot;&quot;
    return __salt__[&quot;pkg_resource.version&quot;](*names, **kwargs)


def upgrade(refresh=True, **kwargs):
    &quot;&quot;&quot;
    Run a full system upgrade

    refresh
        Whether or not to refresh the package database before installing.
        Default is `True`.

    Returns a dictionary containing the changes:

    .. code-block:: python

        {'&lt;package&gt;':  {'old': '&lt;old-version&gt;',
                        'new': '&lt;new-version&gt;'}}

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.upgrade
    &quot;&quot;&quot;

    # XXX if xbps has to be upgraded, 2 times is required to fully upgrade
    # system: one for xbps, a subsequent one for all other packages. Not
    # handled in this code.

    old = list_pkgs()

    cmd = [&quot;xbps-install&quot;, &quot;-{}yu&quot;.format(&quot;S&quot; if refresh else &quot;&quot;)]
    result = __salt__[&quot;cmd.run_all&quot;](cmd, output_loglevel=&quot;trace&quot;, python_shell=False)
    __context__.pop(&quot;pkg.list_pkgs&quot;, None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)

    if result[&quot;retcode&quot;] != 0:
        raise CommandExecutionError(
            &quot;Problem encountered upgrading packages&quot;,
            info={&quot;changes&quot;: ret, &quot;result&quot;: result},
        )

    return ret


def install(name=None, refresh=False, fromrepo=None, pkgs=None, sources=None, **kwargs):
    &quot;&quot;&quot;
    Install the passed package

    name
        The name of the package to be installed.

    refresh
        Whether or not to refresh the package database before installing.

    fromrepo
        Specify a package repository (url) to install from.


    Multiple Package Installation Options:

    pkgs
        A list of packages to install from a software repository. Must be
        passed as a python list.

        CLI Example:

        .. code-block:: bash

            salt '*' pkg.install pkgs='[&quot;foo&quot;,&quot;bar&quot;]'

    sources
        A list of packages to install. Must be passed as a list of dicts,
        with the keys being package names, and the values being the source URI
        or local path to the package.

        CLI Example:

        .. code-block:: bash

            salt '*' pkg.install sources='[{&quot;foo&quot;: &quot;salt://foo.deb&quot;},{&quot;bar&quot;: &quot;salt://bar.deb&quot;}]'

    Return a dict containing the new package names and versions::

        {'&lt;package&gt;': {'old': '&lt;old-version&gt;',
                       'new': '&lt;new-version&gt;'}}

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.install &lt;package name&gt;
    &quot;&quot;&quot;

    # XXX sources is not yet used in this code

    try:
        pkg_params, pkg_type = __salt__[&quot;pkg_resource.parse_targets&quot;](
            name, pkgs, sources, **kwargs
        )
    except MinionError as exc:
        raise CommandExecutionError(exc)

    if pkg_params is None or len(pkg_params) == 0:
        return {}

    if pkg_type != &quot;repository&quot;:
        log.error('xbps: pkg_type &quot;%s&quot; not supported.', pkg_type)
        return {}

    cmd = [&quot;xbps-install&quot;]

    if refresh:
        cmd.append(&quot;-S&quot;)  # update repo db
    if fromrepo:
        cmd.append(&quot;--repository={}&quot;.format(fromrepo))
    cmd.append(&quot;-y&quot;)  # assume yes when asked
    cmd.extend(pkg_params)

    old = list_pkgs()
    __salt__[&quot;cmd.run&quot;](cmd, output_loglevel=&quot;trace&quot;)
    __context__.pop(&quot;pkg.list_pkgs&quot;, None)
    new = list_pkgs()

    _rehash()
    return salt.utils.data.compare_dicts(old, new)


def remove(name=None, pkgs=None, recursive=True, **kwargs):
    &quot;&quot;&quot;
    name
        The name of the package to be deleted.

    recursive
        Also remove dependent packages (not required elsewhere).
        Default mode: enabled.

    Multiple Package Options:

    pkgs
        A list of packages to delete. Must be passed as a python list. The
        ``name`` parameter will be ignored if this option is passed.

    Returns a list containing the removed packages.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.remove &lt;package name&gt; [recursive=False]
        salt '*' pkg.remove &lt;package1&gt;,&lt;package2&gt;,&lt;package3&gt; [recursive=False]
        salt '*' pkg.remove pkgs='[&quot;foo&quot;, &quot;bar&quot;]' [recursive=False]
    &quot;&quot;&quot;

    try:
        pkg_params, pkg_type = __salt__[&quot;pkg_resource.parse_targets&quot;](name, pkgs)
    except MinionError as exc:
        raise CommandExecutionError(exc)

    if not pkg_params:
        return {}

    old = list_pkgs()

    # keep only installed packages
    targets = [x for x in pkg_params if x in old]
    if not targets:
        return {}

    cmd = [&quot;xbps-remove&quot;, &quot;-y&quot;]
    if recursive:
        cmd.append(&quot;-R&quot;)
    cmd.extend(targets)
    __salt__[&quot;cmd.run&quot;](cmd, output_loglevel=&quot;trace&quot;)
    __context__.pop(&quot;pkg.list_pkgs&quot;, None)
    new = list_pkgs()

    return salt.utils.data.compare_dicts(old, new)


def list_repos(**kwargs):
    &quot;&quot;&quot;
    List all repos known by XBPS

    CLI Example:

    .. code-block:: bash

       salt '*' pkg.list_repos
    &quot;&quot;&quot;
    repos = {}
    out = __salt__[&quot;cmd.run&quot;](&quot;xbps-query -L&quot;, output_loglevel=&quot;trace&quot;)
    for line in out.splitlines():
        repo = {}
        if not line:
            continue
        try:
            nb, url, rsa = line.strip().split(&quot; &quot;, 2)
        except ValueError:
            log.error(
                'Problem parsing xbps-query: Unexpected formatting in line: &quot;%s&quot;',
                line,
            )
        repo[&quot;nbpkg&quot;] = int(nb) if nb.isdigit() else 0
        repo[&quot;url&quot;] = url
        repo[&quot;rsasigned&quot;] = True if rsa == &quot;(RSA signed)&quot; else False
        repos[repo[&quot;url&quot;]] = repo
    return repos


def get_repo(repo, **kwargs):
    &quot;&quot;&quot;
    Display information about the repo.

    CLI Examples:

    .. code-block:: bash

        salt '*' pkg.get_repo 'repo-url'
    &quot;&quot;&quot;
    repos = list_repos()
    if repo in repos:
        return repos[repo]
    return {}


def _locate_repo_files(repo, rewrite=False):
    &quot;&quot;&quot;
    Find what file a repo is called in.

    Helper function for add_repo() and del_repo()

    repo
        url of the repo to locate (persistent).

    rewrite
        Whether to remove matching repository settings during this process.

    Returns a list of absolute paths.
    &quot;&quot;&quot;

    ret_val = []
    files = []
    conf_dirs = [&quot;/etc/xbps.d/&quot;, &quot;/usr/share/xbps.d/&quot;]
    name_glob = &quot;*.conf&quot;
    # Matches a line where first printing is &quot;repository&quot; and there is an equals
    # sign before the repo, an optional forwardslash at the end of the repo name,
    # and it's possible for there to be a comment after repository=repo
    regex = re.compile(r&quot;\s*repository\s*=\s*&quot; + repo + r&quot;/?\s*(#.*)?$&quot;)

    for cur_dir in conf_dirs:
        files.extend(glob.glob(cur_dir + name_glob))

    for filename in files:
        write_buff = []
        with salt.utils.files.fopen(filename, &quot;r&quot;) as cur_file:
            for line in cur_file:
                if regex.match(salt.utils.stringutils.to_unicode(line)):
                    ret_val.append(filename)
                else:
                    write_buff.append(line)
        if rewrite and filename in ret_val:
            if len(write_buff) &gt; 0:
                with salt.utils.files.fopen(filename, &quot;w&quot;) as rewrite_file:
                    rewrite_file.writelines(write_buff)
            else:  # Prune empty files
                os.remove(filename)

    return ret_val


def add_repo(repo, conffile=&quot;/usr/share/xbps.d/15-saltstack.conf&quot;):
    &quot;&quot;&quot;
    Add an XBPS repository to the system.

    repo
        url of repo to add (persistent).

    conffile
        path to xbps conf file to add this repo
        default: /usr/share/xbps.d/15-saltstack.conf

    CLI Examples:

    .. code-block:: bash

        salt '*' pkg.add_repo &lt;repo url&gt; [conffile=/path/to/xbps/repo.conf]
    &quot;&quot;&quot;

    if len(_locate_repo_files(repo)) == 0:
        try:
            with salt.utils.files.fopen(conffile, &quot;a+&quot;) as conf_file:
                conf_file.write(
                    salt.utils.stringutils.to_str(&quot;repository={}\n&quot;.format(repo))
                )
        except OSError:
            return False

    return True


def del_repo(repo, **kwargs):
    &quot;&quot;&quot;
    Remove an XBPS repository from the system.

    repo
        url of repo to remove (persistent).

    CLI Examples:

    .. code-block:: bash

        salt '*' pkg.del_repo &lt;repo url&gt;
    &quot;&quot;&quot;

    try:
        _locate_repo_files(repo, rewrite=True)
    except OSError:
        return False
    else:
        return True
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>key_5.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
The Salt Key backend API and interface used by the CLI. The Key class can be
used to manage salt keys directly without interfacing with the CLI.
&quot;&quot;&quot;

import fnmatch
import itertools
import logging
import os
import shutil
import sys

import salt.cache
import salt.client
import salt.crypt
<A NAME="0"></A>import salt.daemons.masterapi
import salt.exceptions
import salt.minion
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match242374-0.html#0',2,'match242374-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import salt.utils.args
import salt.utils.crypt
import salt.utils.data
import salt.utils.event
import salt.utils.files
import salt.utils.json
import salt.utils.kinds
import salt.utils.master
import salt.utils.sdb
import salt.utils.stringutils
import salt.utils.user

log = logging.getLogger(</B></FONT>__name__)


def get_key(opts):
    return Key(opts)


class KeyCLI:
    &quot;&quot;&quot;
    Manage key CLI operations
    &quot;&quot;&quot;

    CLI_KEY_MAP = {
        &quot;list&quot;: &quot;list_status&quot;,
        &quot;delete&quot;: &quot;delete_key&quot;,
        &quot;gen_signature&quot;: &quot;gen_keys_signature&quot;,
        &quot;print&quot;: &quot;key_str&quot;,
    }

    def __init__(self, opts):
        self.opts = opts
        self.client = salt.wheel.WheelClient(opts)
        self.key = Key
        # instantiate the key object for masterless mode
        if not opts.get(&quot;eauth&quot;):
            self.key = self.key(opts)
        self.auth = None

    def _update_opts(self):
        # get the key command
        for cmd in (
            &quot;gen_keys&quot;,
            &quot;gen_signature&quot;,
            &quot;list&quot;,
            &quot;list_all&quot;,
            &quot;print&quot;,
            &quot;print_all&quot;,
            &quot;accept&quot;,
            &quot;accept_all&quot;,
            &quot;reject&quot;,
            &quot;reject_all&quot;,
            &quot;delete&quot;,
            &quot;delete_all&quot;,
            &quot;finger&quot;,
            &quot;finger_all&quot;,
            &quot;list_all&quot;,
        ):  # last is default
            if self.opts[cmd]:
                break
        # set match if needed
        if not cmd.startswith(&quot;gen_&quot;):
            if cmd == &quot;list_all&quot;:
                self.opts[&quot;match&quot;] = &quot;all&quot;
            elif cmd.endswith(&quot;_all&quot;):
                self.opts[&quot;match&quot;] = &quot;*&quot;
            else:
                self.opts[&quot;match&quot;] = self.opts[cmd]
            if cmd.startswith(&quot;accept&quot;):
                self.opts[&quot;include_rejected&quot;] = (
                    self.opts[&quot;include_all&quot;] or self.opts[&quot;include_rejected&quot;]
                )
                self.opts[&quot;include_accepted&quot;] = False
            elif cmd.startswith(&quot;reject&quot;):
                self.opts[&quot;include_accepted&quot;] = (
                    self.opts[&quot;include_all&quot;] or self.opts[&quot;include_accepted&quot;]
                )
                self.opts[&quot;include_rejected&quot;] = False
        elif cmd == &quot;gen_keys&quot;:
            self.opts[&quot;keydir&quot;] = self.opts[&quot;gen_keys_dir&quot;]
            self.opts[&quot;keyname&quot;] = self.opts[&quot;gen_keys&quot;]
        # match is set to opts, now we can forget about *_all commands
        self.opts[&quot;fun&quot;] = cmd.replace(&quot;_all&quot;, &quot;&quot;)

    def _init_auth(self):
        if self.auth:
            return

        low = {}
        skip_perm_errors = self.opts[&quot;eauth&quot;] != &quot;&quot;

        if self.opts[&quot;eauth&quot;]:
            if &quot;token&quot; in self.opts:
                try:
                    with salt.utils.files.fopen(
                        os.path.join(self.opts[&quot;cachedir&quot;], &quot;.root_key&quot;), &quot;r&quot;
                    ) as fp_:
                        low[&quot;key&quot;] = salt.utils.stringutils.to_unicode(fp_.readline())
                except OSError:
                    low[&quot;token&quot;] = self.opts[&quot;token&quot;]
            #
            # If using eauth and a token hasn't already been loaded into
            # low, prompt the user to enter auth credentials
            if &quot;token&quot; not in low and &quot;key&quot; not in low and self.opts[&quot;eauth&quot;]:
                # This is expensive. Don't do it unless we need to.
                resolver = salt.auth.Resolver(self.opts)
                res = resolver.cli(self.opts[&quot;eauth&quot;])
                if self.opts[&quot;mktoken&quot;] and res:
                    tok = resolver.token_cli(self.opts[&quot;eauth&quot;], res)
                    if tok:
                        low[&quot;token&quot;] = tok.get(&quot;token&quot;, &quot;&quot;)
                if not res:
                    log.error(&quot;Authentication failed&quot;)
                    return {}
                low.update(res)
                low[&quot;eauth&quot;] = self.opts[&quot;eauth&quot;]
        else:
            low[&quot;user&quot;] = salt.utils.user.get_specific_user()
            low[&quot;key&quot;] = salt.utils.master.get_master_key(
                low[&quot;user&quot;], self.opts, skip_perm_errors
            )

        self.auth = low

    def _get_args_kwargs(self, fun, args=None):
        argspec = salt.utils.args.get_function_argspec(fun)
        if args is None:
            args = []
            if argspec.args:
                # Iterate in reverse order to ensure we get the correct default
                # value for the positional argument.
                for arg, default in itertools.zip_longest(
                    reversed(argspec.args), reversed(argspec.defaults or ())
                ):
                    args.append(self.opts.get(arg, default))
            # Reverse the args so that they are in the correct order
            args = args[::-1]

        if argspec.keywords is None:
            kwargs = {}
        else:
            args, kwargs = salt.minion.load_args_and_kwargs(fun, args)
        return args, kwargs

    def _run_cmd(self, cmd, args=None):
        if not self.opts.get(&quot;eauth&quot;):
            cmd = self.CLI_KEY_MAP.get(cmd, cmd)
            fun = getattr(self.key, cmd)
            args, kwargs = self._get_args_kwargs(fun, args)
            ret = fun(*args, **kwargs)
            if (
                isinstance(ret, dict)
                and &quot;local&quot; in ret
                and cmd not in (&quot;finger&quot;, &quot;finger_all&quot;)
            ):
                ret.pop(&quot;local&quot;, None)
            return ret

        if cmd in (&quot;accept&quot;, &quot;reject&quot;, &quot;delete&quot;) and args is None:
            args = self.opts.get(&quot;match_dict&quot;, {}).get(&quot;minions&quot;)
        fstr = &quot;key.{}&quot;.format(cmd)
        fun = self.client.functions[fstr]
        args, kwargs = self._get_args_kwargs(fun, args)

        low = {
            &quot;fun&quot;: fstr,
            &quot;arg&quot;: args,
            &quot;kwarg&quot;: kwargs,
        }

        self._init_auth()
        low.update(self.auth)

        # Execute the key request!
        ret = self.client.cmd_sync(low)

        ret = ret[&quot;data&quot;][&quot;return&quot;]
        if (
            isinstance(ret, dict)
            and &quot;local&quot; in ret
            and cmd not in (&quot;finger&quot;, &quot;finger_all&quot;)
        ):
            ret.pop(&quot;local&quot;, None)

        return ret

    def _filter_ret(self, cmd, ret):
        if cmd.startswith(&quot;delete&quot;):
            return ret

        keys = {}
        if self.key.PEND in ret:
            keys[self.key.PEND] = ret[self.key.PEND]
        if self.opts[&quot;include_accepted&quot;] and bool(ret.get(self.key.ACC)):
            keys[self.key.ACC] = ret[self.key.ACC]
        if self.opts[&quot;include_rejected&quot;] and bool(ret.get(self.key.REJ)):
            keys[self.key.REJ] = ret[self.key.REJ]
        if self.opts[&quot;include_denied&quot;] and bool(ret.get(self.key.DEN)):
            keys[self.key.DEN] = ret[self.key.DEN]
        return keys

    def _print_no_match(self, cmd, match):
        statuses = [&quot;unaccepted&quot;]
        if self.opts[&quot;include_accepted&quot;]:
            statuses.append(&quot;accepted&quot;)
        if self.opts[&quot;include_rejected&quot;]:
            statuses.append(&quot;rejected&quot;)
        if self.opts[&quot;include_denied&quot;]:
            statuses.append(&quot;denied&quot;)
        if len(statuses) == 1:
            stat_str = statuses[0]
        else:
            stat_str = &quot;{} or {}&quot;.format(&quot;, &quot;.join(statuses[:-1]), statuses[-1])
        msg = &quot;The key glob '{}' does not match any {} keys.&quot;.format(match, stat_str)
        print(msg)

    def run(self):
        &quot;&quot;&quot;
        Run the logic for saltkey
        &quot;&quot;&quot;
        self._update_opts()
        cmd = self.opts[&quot;fun&quot;]

        veri = None
        ret = None
        try:
            if cmd in (&quot;accept&quot;, &quot;reject&quot;, &quot;delete&quot;):
                ret = self._run_cmd(&quot;name_match&quot;)
                if not isinstance(ret, dict):
                    salt.output.display_output(ret, &quot;key&quot;, opts=self.opts)
                    return ret
                ret = self._filter_ret(cmd, ret)
                if not ret:
                    self._print_no_match(cmd, self.opts[&quot;match&quot;])
                    return
                print(
                    &quot;The following keys are going to be {}ed:&quot;.format(cmd.rstrip(&quot;e&quot;))
                )
                salt.output.display_output(ret, &quot;key&quot;, opts=self.opts)

                if not self.opts.get(&quot;yes&quot;, False):
                    try:
                        if cmd.startswith(&quot;delete&quot;):
                            veri = input(&quot;Proceed? [N/y] &quot;)
                            if not veri:
                                veri = &quot;n&quot;
                        else:
                            veri = input(&quot;Proceed? [n/Y] &quot;)
                            if not veri:
                                veri = &quot;y&quot;
                    except KeyboardInterrupt:
                        raise SystemExit(&quot;\nExiting on CTRL-c&quot;)
                # accept/reject/delete the same keys we're printed to the user
                self.opts[&quot;match_dict&quot;] = ret
                self.opts.pop(&quot;match&quot;, None)
                list_ret = ret

            if veri is None or veri.lower().startswith(&quot;y&quot;):
                ret = self._run_cmd(cmd)
                if cmd in (&quot;accept&quot;, &quot;reject&quot;, &quot;delete&quot;):
                    if cmd == &quot;delete&quot;:
                        ret = list_ret
                    for minions in ret.values():
                        for minion in minions:
                            print(
                                &quot;Key for minion {} {}ed.&quot;.format(
                                    minion, cmd.rstrip(&quot;e&quot;)
                                )
                            )
                elif isinstance(ret, dict):
                    salt.output.display_output(ret, &quot;key&quot;, opts=self.opts)
                else:
                    salt.output.display_output({&quot;return&quot;: ret}, &quot;key&quot;, opts=self.opts)
        except salt.exceptions.SaltException as exc:
            ret = &quot;{}&quot;.format(exc)
            if not self.opts.get(&quot;quiet&quot;, False):
                salt.output.display_output(ret, &quot;nested&quot;, self.opts)
        return ret


class Key:
    &quot;&quot;&quot;
    The object that encapsulates saltkey actions
    &quot;&quot;&quot;

    ACC = &quot;minions&quot;
    PEND = &quot;minions_pre&quot;
    REJ = &quot;minions_rejected&quot;
    DEN = &quot;minions_denied&quot;

    def __init__(self, opts, io_loop=None):
        self.opts = opts
        kind = self.opts.get(&quot;__role&quot;, &quot;&quot;)  # application kind
        if kind not in salt.utils.kinds.APPL_KINDS:
            emsg = &quot;Invalid application kind = '{}'.&quot;.format(kind)
            log.error(emsg)
            raise ValueError(emsg)
        self.event = salt.utils.event.get_event(
            kind,
            opts[&quot;sock_dir&quot;],
            opts=opts,
            listen=False,
            io_loop=io_loop,
        )

        self.passphrase = salt.utils.sdb.sdb_get(
            self.opts.get(&quot;signing_key_pass&quot;), self.opts
        )

    def _check_minions_directories(self):
        &quot;&quot;&quot;
        Return the minion keys directory paths
        &quot;&quot;&quot;
        minions_accepted = os.path.join(self.opts[&quot;pki_dir&quot;], self.ACC)
        minions_pre = os.path.join(self.opts[&quot;pki_dir&quot;], self.PEND)
        minions_rejected = os.path.join(self.opts[&quot;pki_dir&quot;], self.REJ)

        minions_denied = os.path.join(self.opts[&quot;pki_dir&quot;], self.DEN)
        return minions_accepted, minions_pre, minions_rejected, minions_denied

    def _get_key_attrs(self, keydir, keyname, keysize, user):
        if not keydir:
            if &quot;gen_keys_dir&quot; in self.opts:
                keydir = self.opts[&quot;gen_keys_dir&quot;]
            else:
                keydir = self.opts[&quot;pki_dir&quot;]
        if not keyname:
            if &quot;gen_keys&quot; in self.opts:
                keyname = self.opts[&quot;gen_keys&quot;]
            else:
                keyname = &quot;minion&quot;
        if not keysize:
            keysize = self.opts[&quot;keysize&quot;]
        return keydir, keyname, keysize, user

    def gen_keys(self, keydir=None, keyname=None, keysize=None, user=None):
        &quot;&quot;&quot;
        Generate minion RSA public keypair
        &quot;&quot;&quot;
        keydir, keyname, keysize, user = self._get_key_attrs(
            keydir, keyname, keysize, user
        )
        salt.crypt.gen_keys(keydir, keyname, keysize, user, self.passphrase)
        return salt.utils.crypt.pem_finger(os.path.join(keydir, keyname + &quot;.pub&quot;))

    def gen_signature(self, privkey, pubkey, sig_path):
        &quot;&quot;&quot;
        Generate master public-key-signature
        &quot;&quot;&quot;
        return salt.crypt.gen_signature(privkey, pubkey, sig_path, self.passphrase)

    def gen_keys_signature(
        self, priv, pub, signature_path, auto_create=False, keysize=None
    ):
        &quot;&quot;&quot;
        Generate master public-key-signature
        &quot;&quot;&quot;
        # check given pub-key
        if pub:
            if not os.path.isfile(pub):
                return &quot;Public-key {} does not exist&quot;.format(pub)
        # default to master.pub
        else:
            mpub = self.opts[&quot;pki_dir&quot;] + &quot;/&quot; + &quot;master.pub&quot;
            if os.path.isfile(mpub):
                pub = mpub

        # check given priv-key
        if priv:
            if not os.path.isfile(priv):
                return &quot;Private-key {} does not exist&quot;.format(priv)
        # default to master_sign.pem
        else:
            mpriv = self.opts[&quot;pki_dir&quot;] + &quot;/&quot; + &quot;master_sign.pem&quot;
            if os.path.isfile(mpriv):
                priv = mpriv

        if not priv:
            if auto_create:
                log.debug(
                    &quot;Generating new signing key-pair .%s.* in %s&quot;,
                    self.opts[&quot;master_sign_key_name&quot;],
                    self.opts[&quot;pki_dir&quot;],
                )
                salt.crypt.gen_keys(
                    self.opts[&quot;pki_dir&quot;],
                    self.opts[&quot;master_sign_key_name&quot;],
                    keysize or self.opts[&quot;keysize&quot;],
                    self.opts.get(&quot;user&quot;),
                    self.passphrase,
                )

                priv = (
                    self.opts[&quot;pki_dir&quot;]
                    + &quot;/&quot;
                    + self.opts[&quot;master_sign_key_name&quot;]
                    + &quot;.pem&quot;
                )
            else:
                return &quot;No usable private-key found&quot;

        if not pub:
            return &quot;No usable public-key found&quot;

        log.debug(&quot;Using public-key %s&quot;, pub)
        log.debug(&quot;Using private-key %s&quot;, priv)

        if signature_path:
            if not os.path.isdir(signature_path):
                log.debug(&quot;target directory %s does not exist&quot;, signature_path)
        else:
            signature_path = self.opts[&quot;pki_dir&quot;]

        sign_path = signature_path + &quot;/&quot; + self.opts[&quot;master_pubkey_signature&quot;]

        skey = get_key(self.opts)
        return skey.gen_signature(priv, pub, sign_path)

    def check_minion_cache(self, preserve_minions=None):
        &quot;&quot;&quot;
        Check the minion cache to make sure that old minion data is cleared

        Optionally, pass in a list of minions which should have their caches
        preserved. To preserve all caches, set __opts__['preserve_minion_cache']
        &quot;&quot;&quot;
        if preserve_minions is None:
            preserve_minions = []
        keys = self.list_keys()
        minions = []
        for key, val in keys.items():
            minions.extend(val)
        if not self.opts.get(&quot;preserve_minion_cache&quot;, False):
            m_cache = os.path.join(self.opts[&quot;cachedir&quot;], self.ACC)
            if os.path.isdir(m_cache):
                for minion in os.listdir(m_cache):
                    if minion not in minions and minion not in preserve_minions:
                        try:
                            shutil.rmtree(os.path.join(m_cache, minion))
                        except OSError as ex:
                            log.warning(
                                &quot;Key: Delete cache for %s got OSError/IOError: %s \n&quot;,
                                minion,
                                ex,
                            )
                            continue
            cache = salt.cache.factory(self.opts)
            clist = cache.list(self.ACC)
            if clist:
                for minion in clist:
                    if minion not in minions and minion not in preserve_minions:
                        cache.flush(&quot;{}/{}&quot;.format(self.ACC, minion))

    def check_master(self):
        &quot;&quot;&quot;
        Log if the master is not running

        :rtype: bool
        :return: Whether or not the master is running
        &quot;&quot;&quot;
        if not os.path.exists(os.path.join(self.opts[&quot;sock_dir&quot;], &quot;publish_pull.ipc&quot;)):
            return False
        return True

    def name_match(self, match, full=False):
        &quot;&quot;&quot;
        Accept a glob which to match the of a key and return the key's location
        &quot;&quot;&quot;
        if full:
            matches = self.all_keys()
        else:
            matches = self.list_keys()
        ret = {}
        if &quot;,&quot; in match and isinstance(match, str):
            match = match.split(&quot;,&quot;)
        for status, keys in matches.items():
            for key in salt.utils.data.sorted_ignorecase(keys):
                if isinstance(match, list):
                    for match_item in match:
                        if fnmatch.fnmatch(key, match_item):
                            if status not in ret:
                                ret[status] = []
                            ret[status].append(key)
                else:
                    if fnmatch.fnmatch(key, match):
                        if status not in ret:
                            ret[status] = []
                        ret[status].append(key)
        return ret

    def dict_match(self, match_dict):
        &quot;&quot;&quot;
        Accept a dictionary of keys and return the current state of the
        specified keys
        &quot;&quot;&quot;
        ret = {}
        cur_keys = self.list_keys()
        for status, keys in match_dict.items():
            for key in salt.utils.data.sorted_ignorecase(keys):
                for keydir in (self.ACC, self.PEND, self.REJ, self.DEN):
                    if keydir and fnmatch.filter(cur_keys.get(keydir, []), key):
                        ret.setdefault(keydir, []).append(key)
        return ret

    def local_keys(self):
        &quot;&quot;&quot;
        Return a dict of local keys
        &quot;&quot;&quot;
        ret = {&quot;local&quot;: []}
        for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(self.opts[&quot;pki_dir&quot;])):
            if fn_.endswith(&quot;.pub&quot;) or fn_.endswith(&quot;.pem&quot;):
                path = os.path.join(self.opts[&quot;pki_dir&quot;], fn_)
                if os.path.isfile(path):
                    ret[&quot;local&quot;].append(fn_)
        return ret

    def list_keys(self):
        &quot;&quot;&quot;
        Return a dict of managed keys and what the key status are
        &quot;&quot;&quot;
        key_dirs = self._check_minions_directories()

        ret = {}

        for dir_ in key_dirs:
            if dir_ is None:
                continue
            ret[os.path.basename(dir_)] = []
            try:
                for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(dir_)):
                    if not fn_.startswith(&quot;.&quot;):
                        if os.path.isfile(os.path.join(dir_, fn_)):
                            ret[os.path.basename(dir_)].append(
                                salt.utils.stringutils.to_unicode(fn_)
                            )
            except OSError:
                # key dir kind is not created yet, just skip
                continue
        return ret

    def all_keys(self):
        &quot;&quot;&quot;
        Merge managed keys with local keys
        &quot;&quot;&quot;
        keys = self.list_keys()
        keys.update(self.local_keys())
        return keys

    def list_status(self, match):
        &quot;&quot;&quot;
        Return a dict of managed keys under a named status
        &quot;&quot;&quot;
        acc, pre, rej, den = self._check_minions_directories()
        ret = {}
        if match.startswith(&quot;acc&quot;):
            ret[os.path.basename(acc)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(acc)):
                if not fn_.startswith(&quot;.&quot;):
                    if os.path.isfile(os.path.join(acc, fn_)):
                        ret[os.path.basename(acc)].append(fn_)
        elif match.startswith(&quot;pre&quot;) or match.startswith(&quot;un&quot;):
            ret[os.path.basename(pre)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(pre)):
                if not fn_.startswith(&quot;.&quot;):
                    if os.path.isfile(os.path.join(pre, fn_)):
                        ret[os.path.basename(pre)].append(fn_)
        elif match.startswith(&quot;rej&quot;):
            ret[os.path.basename(rej)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(rej)):
                if not fn_.startswith(&quot;.&quot;):
                    if os.path.isfile(os.path.join(rej, fn_)):
                        ret[os.path.basename(rej)].append(fn_)
        elif match.startswith(&quot;den&quot;) and den is not None:
            ret[os.path.basename(den)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(den)):
                if not fn_.startswith(&quot;.&quot;):
                    if os.path.isfile(os.path.join(den, fn_)):
                        ret[os.path.basename(den)].append(fn_)
        elif match.startswith(&quot;all&quot;):
            return self.all_keys()
        return ret

    def key_str(self, match):
        &quot;&quot;&quot;
        Return the specified public key or keys based on a glob
        &quot;&quot;&quot;
        ret = {}
        for status, keys in self.name_match(match).items():
            ret[status] = {}
            for key in salt.utils.data.sorted_ignorecase(keys):
                path = os.path.join(self.opts[&quot;pki_dir&quot;], status, key)
                with salt.utils.files.fopen(path, &quot;r&quot;) as fp_:
                    ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
        return ret

    def key_str_all(self):
        &quot;&quot;&quot;
        Return all managed key strings
        &quot;&quot;&quot;
        ret = {}
        for status, keys in self.list_keys().items():
            ret[status] = {}
            for key in salt.utils.data.sorted_ignorecase(keys):
                path = os.path.join(self.opts[&quot;pki_dir&quot;], status, key)
                with salt.utils.files.fopen(path, &quot;r&quot;) as fp_:
                    ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
        return ret

    def accept(
        self, match=None, match_dict=None, include_rejected=False, include_denied=False
    ):
        &quot;&quot;&quot;
        Accept public keys. If &quot;match&quot; is passed, it is evaluated as a glob.
        Pre-gathered matches can also be passed via &quot;match_dict&quot;.
        &quot;&quot;&quot;
        if match is not None:
            matches = self.name_match(match)
        elif match_dict is not None and isinstance(match_dict, dict):
            matches = match_dict
        else:
            matches = {}
        keydirs = [self.PEND]
        if include_rejected:
            keydirs.append(self.REJ)
        if include_denied:
            keydirs.append(self.DEN)
        invalid_keys = []
        for keydir in keydirs:
            for key in matches.get(keydir, []):
                key_path = os.path.join(self.opts[&quot;pki_dir&quot;], keydir, key)
                try:
                    salt.crypt.get_rsa_pub_key(key_path)
                except salt.exceptions.InvalidKeyError:
                    log.error(&quot;Invalid RSA public key: %s&quot;, key)
                    invalid_keys.append((keydir, key))
                    continue
                try:
                    shutil.move(
                        key_path,
                        os.path.join(self.opts[&quot;pki_dir&quot;], self.ACC, key),
                    )
                    eload = {&quot;result&quot;: True, &quot;act&quot;: &quot;accept&quot;, &quot;id&quot;: key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix=&quot;key&quot;))
                except OSError:
                    pass
        for keydir, key in invalid_keys:
            matches[keydir].remove(key)
            sys.stderr.write(&quot;Unable to accept invalid key for {}.\n&quot;.format(key))
        return self.name_match(match) if match is not None else self.dict_match(matches)

    def accept_all(self):
        &quot;&quot;&quot;
        Accept all keys in pre
        &quot;&quot;&quot;
        keys = self.list_keys()
        for key in keys[self.PEND]:
            try:
                shutil.move(
                    os.path.join(self.opts[&quot;pki_dir&quot;], self.PEND, key),
                    os.path.join(self.opts[&quot;pki_dir&quot;], self.ACC, key),
                )
                eload = {&quot;result&quot;: True, &quot;act&quot;: &quot;accept&quot;, &quot;id&quot;: key}
                self.event.fire_event(eload, salt.utils.event.tagify(prefix=&quot;key&quot;))
            except OSError:
                pass
        return self.list_keys()

    def delete_key(
        self, match=None, match_dict=None, preserve_minions=None, revoke_auth=False
    ):
        &quot;&quot;&quot;
        Delete public keys. If &quot;match&quot; is passed, it is evaluated as a glob.
        Pre-gathered matches can also be passed via &quot;match_dict&quot;.

        To preserve the master caches of minions who are matched, set preserve_minions
        &quot;&quot;&quot;
        if match is not None:
            matches = self.name_match(match)
        elif match_dict is not None and isinstance(match_dict, dict):
            matches = match_dict
        else:
            matches = {}
        with salt.client.get_local_client(mopts=self.opts) as client:
            for status, keys in matches.items():
                for key in keys:
                    try:
                        if revoke_auth:
                            if self.opts.get(&quot;rotate_aes_key&quot;) is False:
                                print(
                                    &quot;Immediate auth revocation specified but AES key&quot;
                                    &quot; rotation not allowed. Minion will not be&quot;
                                    &quot; disconnected until the master AES key is rotated.&quot;
                                )
                            else:
                                try:
                                    client.cmd_async(key, &quot;saltutil.revoke_auth&quot;)
                                except salt.exceptions.SaltClientError:
                                    print(
                                        &quot;Cannot contact Salt master. &quot;
                                        &quot;Connection for {} will remain up until &quot;
                                        &quot;master AES key is rotated or auth is revoked &quot;
                                        &quot;with 'saltutil.revoke_auth'.&quot;.format(key)
                                    )
                        os.remove(os.path.join(self.opts[&quot;pki_dir&quot;], status, key))
                        eload = {&quot;result&quot;: True, &quot;act&quot;: &quot;delete&quot;, &quot;id&quot;: key}
                        self.event.fire_event(
                            eload, salt.utils.event.tagify(prefix=&quot;key&quot;)
                        )
                    except OSError:
                        pass
        if self.opts.get(&quot;preserve_minions&quot;) is True:
            self.check_minion_cache(preserve_minions=matches.get(&quot;minions&quot;, []))
        else:
            self.check_minion_cache()
        if self.opts.get(&quot;rotate_aes_key&quot;):
            salt.crypt.dropfile(self.opts[&quot;cachedir&quot;], self.opts[&quot;user&quot;])
        return self.name_match(match) if match is not None else self.dict_match(matches)

    def delete_den(self):
        &quot;&quot;&quot;
        Delete all denied keys
        &quot;&quot;&quot;
        keys = self.list_keys()
        for status, keys in self.list_keys().items():
            for key in keys[self.DEN]:
                try:
                    os.remove(os.path.join(self.opts[&quot;pki_dir&quot;], status, key))
                    eload = {&quot;result&quot;: True, &quot;act&quot;: &quot;delete&quot;, &quot;id&quot;: key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix=&quot;key&quot;))
                except OSError:
                    pass
        self.check_minion_cache()
        return self.list_keys()

    def delete_all(self):
        &quot;&quot;&quot;
        Delete all keys
        &quot;&quot;&quot;
        for status, keys in self.list_keys().items():
            for key in keys:
                try:
                    os.remove(os.path.join(self.opts[&quot;pki_dir&quot;], status, key))
                    eload = {&quot;result&quot;: True, &quot;act&quot;: &quot;delete&quot;, &quot;id&quot;: key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix=&quot;key&quot;))
                except OSError:
                    pass
        self.check_minion_cache()
        if self.opts.get(&quot;rotate_aes_key&quot;):
            salt.crypt.dropfile(self.opts[&quot;cachedir&quot;], self.opts[&quot;user&quot;])
        return self.list_keys()

    def reject(
        self, match=None, match_dict=None, include_accepted=False, include_denied=False
    ):
        &quot;&quot;&quot;
        Reject public keys. If &quot;match&quot; is passed, it is evaluated as a glob.
        Pre-gathered matches can also be passed via &quot;match_dict&quot;.
        &quot;&quot;&quot;
        if match is not None:
            matches = self.name_match(match)
        elif match_dict is not None and isinstance(match_dict, dict):
            matches = match_dict
        else:
            matches = {}
        keydirs = [self.PEND]
        if include_accepted:
            keydirs.append(self.ACC)
        if include_denied:
            keydirs.append(self.DEN)
        for keydir in keydirs:
            for key in matches.get(keydir, []):
                try:
                    shutil.move(
                        os.path.join(self.opts[&quot;pki_dir&quot;], keydir, key),
                        os.path.join(self.opts[&quot;pki_dir&quot;], self.REJ, key),
                    )
                    eload = {&quot;result&quot;: True, &quot;act&quot;: &quot;reject&quot;, &quot;id&quot;: key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix=&quot;key&quot;))
                except OSError:
                    pass
        self.check_minion_cache()
        if self.opts.get(&quot;rotate_aes_key&quot;):
            salt.crypt.dropfile(self.opts[&quot;cachedir&quot;], self.opts[&quot;user&quot;])
        return self.name_match(match) if match is not None else self.dict_match(matches)

    def reject_all(self):
        &quot;&quot;&quot;
        Reject all keys in pre
        &quot;&quot;&quot;
        keys = self.list_keys()
        for key in keys[self.PEND]:
            try:
                shutil.move(
                    os.path.join(self.opts[&quot;pki_dir&quot;], self.PEND, key),
                    os.path.join(self.opts[&quot;pki_dir&quot;], self.REJ, key),
                )
                eload = {&quot;result&quot;: True, &quot;act&quot;: &quot;reject&quot;, &quot;id&quot;: key}
                self.event.fire_event(eload, salt.utils.event.tagify(prefix=&quot;key&quot;))
            except OSError:
                pass
        self.check_minion_cache()
        if self.opts.get(&quot;rotate_aes_key&quot;):
            salt.crypt.dropfile(self.opts[&quot;cachedir&quot;], self.opts[&quot;user&quot;])
        return self.list_keys()

    def finger(self, match, hash_type=None):
        &quot;&quot;&quot;
        Return the fingerprint for a specified key
        &quot;&quot;&quot;
        if hash_type is None:
            hash_type = __opts__[&quot;hash_type&quot;]

        matches = self.name_match(match, True)
        ret = {}
        for status, keys in matches.items():
            ret[status] = {}
            for key in keys:
                if status == &quot;local&quot;:
                    path = os.path.join(self.opts[&quot;pki_dir&quot;], key)
                else:
                    path = os.path.join(self.opts[&quot;pki_dir&quot;], status, key)
                ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
        return ret

    def finger_all(self, hash_type=None):
        &quot;&quot;&quot;
        Return fingerprints for all keys
        &quot;&quot;&quot;
        if hash_type is None:
            hash_type = __opts__[&quot;hash_type&quot;]

        ret = {}
        for status, keys in self.all_keys().items():
            ret[status] = {}
            for key in keys:
                if status == &quot;local&quot;:
                    path = os.path.join(self.opts[&quot;pki_dir&quot;], key)
                else:
                    path = os.path.join(self.opts[&quot;pki_dir&quot;], status, key)
                ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
        return ret

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.event.destroy()
</PRE>
</div>
  </div>
</body>
</html>
