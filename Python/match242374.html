<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for xbpspkg.py &amp; key_5.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for xbpspkg.py &amp; key_5.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>xbpspkg.py (2.6119404%)<th>key_5.py (0.7667032%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(9-22)<td><a href="#" name="0">(19-31)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>xbpspkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import glob
3 import logging
4 import os
5 import re
6 import salt.utils.data
7 import salt.utils.decorators as decorators
8 import salt.utils.files
9 import salt.utils.path
10 import salt.utils.pkg
11 import salt.utils.stringutils
12 from salt.exceptions import CommandExecutionError, MinionError
13 log = logging.getLogger(</b></font>__name__)
14 __virtualname__ = "pkg"
15 def __virtual__():
16     if __grains__["os"] in ("Void") and _check_xbps():
17         return __virtualname__
18     return (False, "Missing dependency: xbps-install")
19 @decorators.memoize
20 def _check_xbps():
21     return salt.utils.path.which("xbps-install")
22 @decorators.memoize
23 def _get_version():
24     version_string = __salt__["cmd.run"](
25         [_check_xbps(), "--version"], output_loglevel="trace"
26     )
27     if version_string is None:
28         return False
29     VERSION_MATCH = re.compile(r"(?:XBPS:[\s]+)([\d.]+)(?:[\s]+.*)")
30     version_match = VERSION_MATCH.search(version_string)
31     if not version_match:
32         return False
33     return version_match.group(1).split(".")
34 def _rehash():
35     shell = __salt__["environ.get"]("SHELL")
36     if shell.split("/")[-1] in ("csh", "tcsh"):
37         __salt__["cmd.run"]("rehash", output_loglevel="trace")
38 def list_pkgs(versions_as_list=False, **kwargs):
39     versions_as_list = salt.utils.data.is_true(versions_as_list)
40     if any(
41         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
42     ):
43         return {}
44     cmd = "xbps-query -l"
45     ret = {}
46     out = __salt__["cmd.run"](cmd, output_loglevel="trace")
47     for line in out.splitlines():
48         if not line:
49             continue
50         try:
51             pkg, ver = line.split(None)[1].rsplit("-", 1)
52         except ValueError:
53             log.error('xbps-query: Unexpected formatting in line: "%s"', line)
54         __salt__["pkg_resource.add_pkg"](ret, pkg, ver)
55     __salt__["pkg_resource.sort_pkglist"](ret)
56     if not versions_as_list:
57         __salt__["pkg_resource.stringify"](ret)
58     return ret
59 def list_upgrades(refresh=True, **kwargs):
60     refresh = salt.utils.data.is_true(refresh)
61     if refresh:
62         refresh_db()
63     ret = {}
64     cmd = "xbps-install -un"
65     out = __salt__["cmd.run"](cmd, output_loglevel="trace")
66     for line in out.splitlines():
67         if not line:
68             continue
69         pkg = "base-system"
70         ver = "NonNumericValueIsError"
71         try:
72             pkg, ver = line.split()[0].rsplit("-", 1)
73         except (ValueError, IndexError):
74             log.error('xbps-query: Unexpected formatting in line: "%s"', line)
75             continue
76         log.trace("pkg=%s version=%s", pkg, ver)
77         ret[pkg] = ver
78     return ret
79 def latest_version(*names, **kwargs):
80     refresh = salt.utils.data.is_true(kwargs.pop("refresh", True))
81     if len(names) == 0:
82         return ""
83     if refresh:
84         refresh_db()
85     ret = {}
86     for name in names:
87         ret[name] = ""
88     cmd = ["xbps-install", "-un"]
89     cmd.extend(names)
90     out = __salt__["cmd.run"](cmd, ignore_retcode=True, output_loglevel="trace")
91     for line in out.splitlines():
92         if not line:
93             continue
94         if line.find(" is up to date.") != -1:
95             continue
96         try:
97             pkg, ver = line.split()[0].rsplit("-", 1)
98         except (ValueError, IndexError):
99             log.error('xbps-query: Unexpected formatting in line: "%s"', line)
100             continue
101         log.trace("pkg=%s version=%s", pkg, ver)
102         if pkg in names:
103             ret[pkg] = ver
104     if len(names) == 1:
105         return ret[names[0]]
106     return ret
107 available_version = latest_version
108 def upgrade_available(name, **kwargs):
109     return latest_version(name) != ""
110 def refresh_db(**kwargs):
111     salt.utils.pkg.clear_rtag(__opts__)
112     cmd = "xbps-install -Sy"
113     call = __salt__["cmd.run_all"](cmd, output_loglevel="trace")
114     if call["retcode"] != 0:
115         comment = ""
116         if "stderr" in call:
117             comment += call["stderr"]
118         raise CommandExecutionError(comment)
119     return True
120 def version(*names, **kwargs):
121     return __salt__["pkg_resource.version"](*names, **kwargs)
122 def upgrade(refresh=True, **kwargs):
123     old = list_pkgs()
124     cmd = ["xbps-install", "-{}yu".format("S" if refresh else "")]
125     result = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
126     __context__.pop("pkg.list_pkgs", None)
127     new = list_pkgs()
128     ret = salt.utils.data.compare_dicts(old, new)
129     if result["retcode"] != 0:
130         raise CommandExecutionError(
131             "Problem encountered upgrading packages",
132             info={"changes": ret, "result": result},
133         )
134     return ret
135 def install(name=None, refresh=False, fromrepo=None, pkgs=None, sources=None, **kwargs):
136     try:
137         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
138             name, pkgs, sources, **kwargs
139         )
140     except MinionError as exc:
141         raise CommandExecutionError(exc)
142     if pkg_params is None or len(pkg_params) == 0:
143         return {}
144     if pkg_type != "repository":
145         log.error('xbps: pkg_type "%s" not supported.', pkg_type)
146         return {}
147     cmd = ["xbps-install"]
148     if refresh:
149         cmd.append("-S")  # update repo db
150     if fromrepo:
151         cmd.append("--repository={}".format(fromrepo))
152     cmd.append("-y")  # assume yes when asked
153     cmd.extend(pkg_params)
154     old = list_pkgs()
155     __salt__["cmd.run"](cmd, output_loglevel="trace")
156     __context__.pop("pkg.list_pkgs", None)
157     new = list_pkgs()
158     _rehash()
159     return salt.utils.data.compare_dicts(old, new)
160 def remove(name=None, pkgs=None, recursive=True, **kwargs):
161     try:
162         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](name, pkgs)
163     except MinionError as exc:
164         raise CommandExecutionError(exc)
165     if not pkg_params:
166         return {}
167     old = list_pkgs()
168     targets = [x for x in pkg_params if x in old]
169     if not targets:
170         return {}
171     cmd = ["xbps-remove", "-y"]
172     if recursive:
173         cmd.append("-R")
174     cmd.extend(targets)
175     __salt__["cmd.run"](cmd, output_loglevel="trace")
176     __context__.pop("pkg.list_pkgs", None)
177     new = list_pkgs()
178     return salt.utils.data.compare_dicts(old, new)
179 def list_repos(**kwargs):
180     repos = {}
181     out = __salt__["cmd.run"]("xbps-query -L", output_loglevel="trace")
182     for line in out.splitlines():
183         repo = {}
184         if not line:
185             continue
186         try:
187             nb, url, rsa = line.strip().split(" ", 2)
188         except ValueError:
189             log.error(
190                 'Problem parsing xbps-query: Unexpected formatting in line: "%s"',
191                 line,
192             )
193         repo["nbpkg"] = int(nb) if nb.isdigit() else 0
194         repo["url"] = url
195         repo["rsasigned"] = True if rsa == "(RSA signed)" else False
196         repos[repo["url"]] = repo
197     return repos
198 def get_repo(repo, **kwargs):
199     repos = list_repos()
200     if repo in repos:
201         return repos[repo]
202     return {}
203 def _locate_repo_files(repo, rewrite=False):
204     ret_val = []
205     files = []
206     conf_dirs = ["/etc/xbps.d/", "/usr/share/xbps.d/"]
207     name_glob = "*.conf"
208     regex = re.compile(r"\s*repository\s*=\s*" + repo + r"/?\s*(#.*)?$")
209     for cur_dir in conf_dirs:
210         files.extend(glob.glob(cur_dir + name_glob))
211     for filename in files:
212         write_buff = []
213         with salt.utils.files.fopen(filename, "r") as cur_file:
214             for line in cur_file:
215                 if regex.match(salt.utils.stringutils.to_unicode(line)):
216                     ret_val.append(filename)
217                 else:
218                     write_buff.append(line)
219         if rewrite and filename in ret_val:
220             if len(write_buff) &gt; 0:
221                 with salt.utils.files.fopen(filename, "w") as rewrite_file:
222                     rewrite_file.writelines(write_buff)
223             else:  # Prune empty files
224                 os.remove(filename)
225     return ret_val
226 def add_repo(repo, conffile="/usr/share/xbps.d/15-saltstack.conf"):
227     if len(_locate_repo_files(repo)) == 0:
228         try:
229             with salt.utils.files.fopen(conffile, "a+") as conf_file:
230                 conf_file.write(
231                     salt.utils.stringutils.to_str("repository={}\n".format(repo))
232                 )
233         except OSError:
234             return False
235     return True
236 def del_repo(repo, **kwargs):
237     try:
238         _locate_repo_files(repo, rewrite=True)
239     except OSError:
240         return False
241     else:
242         return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>key_5.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import fnmatch
2 import itertools
3 import logging
4 import os
5 import shutil
6 import sys
7 import salt.cache
8 import salt.client
9 import salt.crypt
10 <a name="0"></a>import salt.daemons.masterapi
11 import salt.exceptions
12 import salt.minion
13 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.args
14 import salt.utils.crypt
15 import salt.utils.data
16 import salt.utils.event
17 import salt.utils.files
18 import salt.utils.json
19 import salt.utils.kinds
20 import salt.utils.master
21 import salt.utils.sdb
22 import salt.utils.stringutils
23 import salt.utils.user
24 log = logging.getLogger(</b></font>__name__)
25 def get_key(opts):
26     return Key(opts)
27 class KeyCLI:
28     CLI_KEY_MAP = {
29         "list": "list_status",
30         "delete": "delete_key",
31         "gen_signature": "gen_keys_signature",
32         "print": "key_str",
33     }
34     def __init__(self, opts):
35         self.opts = opts
36         self.client = salt.wheel.WheelClient(opts)
37         self.key = Key
38         if not opts.get("eauth"):
39             self.key = self.key(opts)
40         self.auth = None
41     def _update_opts(self):
42         for cmd in (
43             "gen_keys",
44             "gen_signature",
45             "list",
46             "list_all",
47             "print",
48             "print_all",
49             "accept",
50             "accept_all",
51             "reject",
52             "reject_all",
53             "delete",
54             "delete_all",
55             "finger",
56             "finger_all",
57             "list_all",
58         ):  # last is default
59             if self.opts[cmd]:
60                 break
61         if not cmd.startswith("gen_"):
62             if cmd == "list_all":
63                 self.opts["match"] = "all"
64             elif cmd.endswith("_all"):
65                 self.opts["match"] = "*"
66             else:
67                 self.opts["match"] = self.opts[cmd]
68             if cmd.startswith("accept"):
69                 self.opts["include_rejected"] = (
70                     self.opts["include_all"] or self.opts["include_rejected"]
71                 )
72                 self.opts["include_accepted"] = False
73             elif cmd.startswith("reject"):
74                 self.opts["include_accepted"] = (
75                     self.opts["include_all"] or self.opts["include_accepted"]
76                 )
77                 self.opts["include_rejected"] = False
78         elif cmd == "gen_keys":
79             self.opts["keydir"] = self.opts["gen_keys_dir"]
80             self.opts["keyname"] = self.opts["gen_keys"]
81         self.opts["fun"] = cmd.replace("_all", "")
82     def _init_auth(self):
83         if self.auth:
84             return
85         low = {}
86         skip_perm_errors = self.opts["eauth"] != ""
87         if self.opts["eauth"]:
88             if "token" in self.opts:
89                 try:
90                     with salt.utils.files.fopen(
91                         os.path.join(self.opts["cachedir"], ".root_key"), "r"
92                     ) as fp_:
93                         low["key"] = salt.utils.stringutils.to_unicode(fp_.readline())
94                 except OSError:
95                     low["token"] = self.opts["token"]
96             if "token" not in low and "key" not in low and self.opts["eauth"]:
97                 resolver = salt.auth.Resolver(self.opts)
98                 res = resolver.cli(self.opts["eauth"])
99                 if self.opts["mktoken"] and res:
100                     tok = resolver.token_cli(self.opts["eauth"], res)
101                     if tok:
102                         low["token"] = tok.get("token", "")
103                 if not res:
104                     log.error("Authentication failed")
105                     return {}
106                 low.update(res)
107                 low["eauth"] = self.opts["eauth"]
108         else:
109             low["user"] = salt.utils.user.get_specific_user()
110             low["key"] = salt.utils.master.get_master_key(
111                 low["user"], self.opts, skip_perm_errors
112             )
113         self.auth = low
114     def _get_args_kwargs(self, fun, args=None):
115         argspec = salt.utils.args.get_function_argspec(fun)
116         if args is None:
117             args = []
118             if argspec.args:
119                 for arg, default in itertools.zip_longest(
120                     reversed(argspec.args), reversed(argspec.defaults or ())
121                 ):
122                     args.append(self.opts.get(arg, default))
123             args = args[::-1]
124         if argspec.keywords is None:
125             kwargs = {}
126         else:
127             args, kwargs = salt.minion.load_args_and_kwargs(fun, args)
128         return args, kwargs
129     def _run_cmd(self, cmd, args=None):
130         if not self.opts.get("eauth"):
131             cmd = self.CLI_KEY_MAP.get(cmd, cmd)
132             fun = getattr(self.key, cmd)
133             args, kwargs = self._get_args_kwargs(fun, args)
134             ret = fun(*args, **kwargs)
135             if (
136                 isinstance(ret, dict)
137                 and "local" in ret
138                 and cmd not in ("finger", "finger_all")
139             ):
140                 ret.pop("local", None)
141             return ret
142         if cmd in ("accept", "reject", "delete") and args is None:
143             args = self.opts.get("match_dict", {}).get("minions")
144         fstr = "key.{}".format(cmd)
145         fun = self.client.functions[fstr]
146         args, kwargs = self._get_args_kwargs(fun, args)
147         low = {
148             "fun": fstr,
149             "arg": args,
150             "kwarg": kwargs,
151         }
152         self._init_auth()
153         low.update(self.auth)
154         ret = self.client.cmd_sync(low)
155         ret = ret["data"]["return"]
156         if (
157             isinstance(ret, dict)
158             and "local" in ret
159             and cmd not in ("finger", "finger_all")
160         ):
161             ret.pop("local", None)
162         return ret
163     def _filter_ret(self, cmd, ret):
164         if cmd.startswith("delete"):
165             return ret
166         keys = {}
167         if self.key.PEND in ret:
168             keys[self.key.PEND] = ret[self.key.PEND]
169         if self.opts["include_accepted"] and bool(ret.get(self.key.ACC)):
170             keys[self.key.ACC] = ret[self.key.ACC]
171         if self.opts["include_rejected"] and bool(ret.get(self.key.REJ)):
172             keys[self.key.REJ] = ret[self.key.REJ]
173         if self.opts["include_denied"] and bool(ret.get(self.key.DEN)):
174             keys[self.key.DEN] = ret[self.key.DEN]
175         return keys
176     def _print_no_match(self, cmd, match):
177         statuses = ["unaccepted"]
178         if self.opts["include_accepted"]:
179             statuses.append("accepted")
180         if self.opts["include_rejected"]:
181             statuses.append("rejected")
182         if self.opts["include_denied"]:
183             statuses.append("denied")
184         if len(statuses) == 1:
185             stat_str = statuses[0]
186         else:
187             stat_str = "{} or {}".format(", ".join(statuses[:-1]), statuses[-1])
188         msg = "The key glob '{}' does not match any {} keys.".format(match, stat_str)
189         print(msg)
190     def run(self):
191         self._update_opts()
192         cmd = self.opts["fun"]
193         veri = None
194         ret = None
195         try:
196             if cmd in ("accept", "reject", "delete"):
197                 ret = self._run_cmd("name_match")
198                 if not isinstance(ret, dict):
199                     salt.output.display_output(ret, "key", opts=self.opts)
200                     return ret
201                 ret = self._filter_ret(cmd, ret)
202                 if not ret:
203                     self._print_no_match(cmd, self.opts["match"])
204                     return
205                 print(
206                     "The following keys are going to be {}ed:".format(cmd.rstrip("e"))
207                 )
208                 salt.output.display_output(ret, "key", opts=self.opts)
209                 if not self.opts.get("yes", False):
210                     try:
211                         if cmd.startswith("delete"):
212                             veri = input("Proceed? [N/y] ")
213                             if not veri:
214                                 veri = "n"
215                         else:
216                             veri = input("Proceed? [n/Y] ")
217                             if not veri:
218                                 veri = "y"
219                     except KeyboardInterrupt:
220                         raise SystemExit("\nExiting on CTRL-c")
221                 self.opts["match_dict"] = ret
222                 self.opts.pop("match", None)
223                 list_ret = ret
224             if veri is None or veri.lower().startswith("y"):
225                 ret = self._run_cmd(cmd)
226                 if cmd in ("accept", "reject", "delete"):
227                     if cmd == "delete":
228                         ret = list_ret
229                     for minions in ret.values():
230                         for minion in minions:
231                             print(
232                                 "Key for minion {} {}ed.".format(
233                                     minion, cmd.rstrip("e")
234                                 )
235                             )
236                 elif isinstance(ret, dict):
237                     salt.output.display_output(ret, "key", opts=self.opts)
238                 else:
239                     salt.output.display_output({"return": ret}, "key", opts=self.opts)
240         except salt.exceptions.SaltException as exc:
241             ret = "{}".format(exc)
242             if not self.opts.get("quiet", False):
243                 salt.output.display_output(ret, "nested", self.opts)
244         return ret
245 class Key:
246     ACC = "minions"
247     PEND = "minions_pre"
248     REJ = "minions_rejected"
249     DEN = "minions_denied"
250     def __init__(self, opts, io_loop=None):
251         self.opts = opts
252         kind = self.opts.get("__role", "")  # application kind
253         if kind not in salt.utils.kinds.APPL_KINDS:
254             emsg = "Invalid application kind = '{}'.".format(kind)
255             log.error(emsg)
256             raise ValueError(emsg)
257         self.event = salt.utils.event.get_event(
258             kind,
259             opts["sock_dir"],
260             opts=opts,
261             listen=False,
262             io_loop=io_loop,
263         )
264         self.passphrase = salt.utils.sdb.sdb_get(
265             self.opts.get("signing_key_pass"), self.opts
266         )
267     def _check_minions_directories(self):
268         minions_accepted = os.path.join(self.opts["pki_dir"], self.ACC)
269         minions_pre = os.path.join(self.opts["pki_dir"], self.PEND)
270         minions_rejected = os.path.join(self.opts["pki_dir"], self.REJ)
271         minions_denied = os.path.join(self.opts["pki_dir"], self.DEN)
272         return minions_accepted, minions_pre, minions_rejected, minions_denied
273     def _get_key_attrs(self, keydir, keyname, keysize, user):
274         if not keydir:
275             if "gen_keys_dir" in self.opts:
276                 keydir = self.opts["gen_keys_dir"]
277             else:
278                 keydir = self.opts["pki_dir"]
279         if not keyname:
280             if "gen_keys" in self.opts:
281                 keyname = self.opts["gen_keys"]
282             else:
283                 keyname = "minion"
284         if not keysize:
285             keysize = self.opts["keysize"]
286         return keydir, keyname, keysize, user
287     def gen_keys(self, keydir=None, keyname=None, keysize=None, user=None):
288         keydir, keyname, keysize, user = self._get_key_attrs(
289             keydir, keyname, keysize, user
290         )
291         salt.crypt.gen_keys(keydir, keyname, keysize, user, self.passphrase)
292         return salt.utils.crypt.pem_finger(os.path.join(keydir, keyname + ".pub"))
293     def gen_signature(self, privkey, pubkey, sig_path):
294         return salt.crypt.gen_signature(privkey, pubkey, sig_path, self.passphrase)
295     def gen_keys_signature(
296         self, priv, pub, signature_path, auto_create=False, keysize=None
297     ):
298         if pub:
299             if not os.path.isfile(pub):
300                 return "Public-key {} does not exist".format(pub)
301         else:
302             mpub = self.opts["pki_dir"] + "/" + "master.pub"
303             if os.path.isfile(mpub):
304                 pub = mpub
305         if priv:
306             if not os.path.isfile(priv):
307                 return "Private-key {} does not exist".format(priv)
308         else:
309             mpriv = self.opts["pki_dir"] + "/" + "master_sign.pem"
310             if os.path.isfile(mpriv):
311                 priv = mpriv
312         if not priv:
313             if auto_create:
314                 log.debug(
315                     "Generating new signing key-pair .%s.* in %s",
316                     self.opts["master_sign_key_name"],
317                     self.opts["pki_dir"],
318                 )
319                 salt.crypt.gen_keys(
320                     self.opts["pki_dir"],
321                     self.opts["master_sign_key_name"],
322                     keysize or self.opts["keysize"],
323                     self.opts.get("user"),
324                     self.passphrase,
325                 )
326                 priv = (
327                     self.opts["pki_dir"]
328                     + "/"
329                     + self.opts["master_sign_key_name"]
330                     + ".pem"
331                 )
332             else:
333                 return "No usable private-key found"
334         if not pub:
335             return "No usable public-key found"
336         log.debug("Using public-key %s", pub)
337         log.debug("Using private-key %s", priv)
338         if signature_path:
339             if not os.path.isdir(signature_path):
340                 log.debug("target directory %s does not exist", signature_path)
341         else:
342             signature_path = self.opts["pki_dir"]
343         sign_path = signature_path + "/" + self.opts["master_pubkey_signature"]
344         skey = get_key(self.opts)
345         return skey.gen_signature(priv, pub, sign_path)
346     def check_minion_cache(self, preserve_minions=None):
347         if preserve_minions is None:
348             preserve_minions = []
349         keys = self.list_keys()
350         minions = []
351         for key, val in keys.items():
352             minions.extend(val)
353         if not self.opts.get("preserve_minion_cache", False):
354             m_cache = os.path.join(self.opts["cachedir"], self.ACC)
355             if os.path.isdir(m_cache):
356                 for minion in os.listdir(m_cache):
357                     if minion not in minions and minion not in preserve_minions:
358                         try:
359                             shutil.rmtree(os.path.join(m_cache, minion))
360                         except OSError as ex:
361                             log.warning(
362                                 "Key: Delete cache for %s got OSError/IOError: %s \n",
363                                 minion,
364                                 ex,
365                             )
366                             continue
367             cache = salt.cache.factory(self.opts)
368             clist = cache.list(self.ACC)
369             if clist:
370                 for minion in clist:
371                     if minion not in minions and minion not in preserve_minions:
372                         cache.flush("{}/{}".format(self.ACC, minion))
373     def check_master(self):
374         if not os.path.exists(os.path.join(self.opts["sock_dir"], "publish_pull.ipc")):
375             return False
376         return True
377     def name_match(self, match, full=False):
378         if full:
379             matches = self.all_keys()
380         else:
381             matches = self.list_keys()
382         ret = {}
383         if "," in match and isinstance(match, str):
384             match = match.split(",")
385         for status, keys in matches.items():
386             for key in salt.utils.data.sorted_ignorecase(keys):
387                 if isinstance(match, list):
388                     for match_item in match:
389                         if fnmatch.fnmatch(key, match_item):
390                             if status not in ret:
391                                 ret[status] = []
392                             ret[status].append(key)
393                 else:
394                     if fnmatch.fnmatch(key, match):
395                         if status not in ret:
396                             ret[status] = []
397                         ret[status].append(key)
398         return ret
399     def dict_match(self, match_dict):
400         ret = {}
401         cur_keys = self.list_keys()
402         for status, keys in match_dict.items():
403             for key in salt.utils.data.sorted_ignorecase(keys):
404                 for keydir in (self.ACC, self.PEND, self.REJ, self.DEN):
405                     if keydir and fnmatch.filter(cur_keys.get(keydir, []), key):
406                         ret.setdefault(keydir, []).append(key)
407         return ret
408     def local_keys(self):
409         ret = {"local": []}
410         for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(self.opts["pki_dir"])):
411             if fn_.endswith(".pub") or fn_.endswith(".pem"):
412                 path = os.path.join(self.opts["pki_dir"], fn_)
413                 if os.path.isfile(path):
414                     ret["local"].append(fn_)
415         return ret
416     def list_keys(self):
417         key_dirs = self._check_minions_directories()
418         ret = {}
419         for dir_ in key_dirs:
420             if dir_ is None:
421                 continue
422             ret[os.path.basename(dir_)] = []
423             try:
424                 for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(dir_)):
425                     if not fn_.startswith("."):
426                         if os.path.isfile(os.path.join(dir_, fn_)):
427                             ret[os.path.basename(dir_)].append(
428                                 salt.utils.stringutils.to_unicode(fn_)
429                             )
430             except OSError:
431                 continue
432         return ret
433     def all_keys(self):
434         keys = self.list_keys()
435         keys.update(self.local_keys())
436         return keys
437     def list_status(self, match):
438         acc, pre, rej, den = self._check_minions_directories()
439         ret = {}
440         if match.startswith("acc"):
441             ret[os.path.basename(acc)] = []
442             for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(acc)):
443                 if not fn_.startswith("."):
444                     if os.path.isfile(os.path.join(acc, fn_)):
445                         ret[os.path.basename(acc)].append(fn_)
446         elif match.startswith("pre") or match.startswith("un"):
447             ret[os.path.basename(pre)] = []
448             for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(pre)):
449                 if not fn_.startswith("."):
450                     if os.path.isfile(os.path.join(pre, fn_)):
451                         ret[os.path.basename(pre)].append(fn_)
452         elif match.startswith("rej"):
453             ret[os.path.basename(rej)] = []
454             for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(rej)):
455                 if not fn_.startswith("."):
456                     if os.path.isfile(os.path.join(rej, fn_)):
457                         ret[os.path.basename(rej)].append(fn_)
458         elif match.startswith("den") and den is not None:
459             ret[os.path.basename(den)] = []
460             for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(den)):
461                 if not fn_.startswith("."):
462                     if os.path.isfile(os.path.join(den, fn_)):
463                         ret[os.path.basename(den)].append(fn_)
464         elif match.startswith("all"):
465             return self.all_keys()
466         return ret
467     def key_str(self, match):
468         ret = {}
469         for status, keys in self.name_match(match).items():
470             ret[status] = {}
471             for key in salt.utils.data.sorted_ignorecase(keys):
472                 path = os.path.join(self.opts["pki_dir"], status, key)
473                 with salt.utils.files.fopen(path, "r") as fp_:
474                     ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
475         return ret
476     def key_str_all(self):
477         ret = {}
478         for status, keys in self.list_keys().items():
479             ret[status] = {}
480             for key in salt.utils.data.sorted_ignorecase(keys):
481                 path = os.path.join(self.opts["pki_dir"], status, key)
482                 with salt.utils.files.fopen(path, "r") as fp_:
483                     ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
484         return ret
485     def accept(
486         self, match=None, match_dict=None, include_rejected=False, include_denied=False
487     ):
488         if match is not None:
489             matches = self.name_match(match)
490         elif match_dict is not None and isinstance(match_dict, dict):
491             matches = match_dict
492         else:
493             matches = {}
494         keydirs = [self.PEND]
495         if include_rejected:
496             keydirs.append(self.REJ)
497         if include_denied:
498             keydirs.append(self.DEN)
499         invalid_keys = []
500         for keydir in keydirs:
501             for key in matches.get(keydir, []):
502                 key_path = os.path.join(self.opts["pki_dir"], keydir, key)
503                 try:
504                     salt.crypt.get_rsa_pub_key(key_path)
505                 except salt.exceptions.InvalidKeyError:
506                     log.error("Invalid RSA public key: %s", key)
507                     invalid_keys.append((keydir, key))
508                     continue
509                 try:
510                     shutil.move(
511                         key_path,
512                         os.path.join(self.opts["pki_dir"], self.ACC, key),
513                     )
514                     eload = {"result": True, "act": "accept", "id": key}
515                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
516                 except OSError:
517                     pass
518         for keydir, key in invalid_keys:
519             matches[keydir].remove(key)
520             sys.stderr.write("Unable to accept invalid key for {}.\n".format(key))
521         return self.name_match(match) if match is not None else self.dict_match(matches)
522     def accept_all(self):
523         keys = self.list_keys()
524         for key in keys[self.PEND]:
525             try:
526                 shutil.move(
527                     os.path.join(self.opts["pki_dir"], self.PEND, key),
528                     os.path.join(self.opts["pki_dir"], self.ACC, key),
529                 )
530                 eload = {"result": True, "act": "accept", "id": key}
531                 self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
532             except OSError:
533                 pass
534         return self.list_keys()
535     def delete_key(
536         self, match=None, match_dict=None, preserve_minions=None, revoke_auth=False
537     ):
538         if match is not None:
539             matches = self.name_match(match)
540         elif match_dict is not None and isinstance(match_dict, dict):
541             matches = match_dict
542         else:
543             matches = {}
544         with salt.client.get_local_client(mopts=self.opts) as client:
545             for status, keys in matches.items():
546                 for key in keys:
547                     try:
548                         if revoke_auth:
549                             if self.opts.get("rotate_aes_key") is False:
550                                 print(
551                                     "Immediate auth revocation specified but AES key"
552                                     " rotation not allowed. Minion will not be"
553                                     " disconnected until the master AES key is rotated."
554                                 )
555                             else:
556                                 try:
557                                     client.cmd_async(key, "saltutil.revoke_auth")
558                                 except salt.exceptions.SaltClientError:
559                                     print(
560                                         "Cannot contact Salt master. "
561                                         "Connection for {} will remain up until "
562                                         "master AES key is rotated or auth is revoked "
563                                         "with 'saltutil.revoke_auth'.".format(key)
564                                     )
565                         os.remove(os.path.join(self.opts["pki_dir"], status, key))
566                         eload = {"result": True, "act": "delete", "id": key}
567                         self.event.fire_event(
568                             eload, salt.utils.event.tagify(prefix="key")
569                         )
570                     except OSError:
571                         pass
572         if self.opts.get("preserve_minions") is True:
573             self.check_minion_cache(preserve_minions=matches.get("minions", []))
574         else:
575             self.check_minion_cache()
576         if self.opts.get("rotate_aes_key"):
577             salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
578         return self.name_match(match) if match is not None else self.dict_match(matches)
579     def delete_den(self):
580         keys = self.list_keys()
581         for status, keys in self.list_keys().items():
582             for key in keys[self.DEN]:
583                 try:
584                     os.remove(os.path.join(self.opts["pki_dir"], status, key))
585                     eload = {"result": True, "act": "delete", "id": key}
586                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
587                 except OSError:
588                     pass
589         self.check_minion_cache()
590         return self.list_keys()
591     def delete_all(self):
592         for status, keys in self.list_keys().items():
593             for key in keys:
594                 try:
595                     os.remove(os.path.join(self.opts["pki_dir"], status, key))
596                     eload = {"result": True, "act": "delete", "id": key}
597                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
598                 except OSError:
599                     pass
600         self.check_minion_cache()
601         if self.opts.get("rotate_aes_key"):
602             salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
603         return self.list_keys()
604     def reject(
605         self, match=None, match_dict=None, include_accepted=False, include_denied=False
606     ):
607         if match is not None:
608             matches = self.name_match(match)
609         elif match_dict is not None and isinstance(match_dict, dict):
610             matches = match_dict
611         else:
612             matches = {}
613         keydirs = [self.PEND]
614         if include_accepted:
615             keydirs.append(self.ACC)
616         if include_denied:
617             keydirs.append(self.DEN)
618         for keydir in keydirs:
619             for key in matches.get(keydir, []):
620                 try:
621                     shutil.move(
622                         os.path.join(self.opts["pki_dir"], keydir, key),
623                         os.path.join(self.opts["pki_dir"], self.REJ, key),
624                     )
625                     eload = {"result": True, "act": "reject", "id": key}
626                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
627                 except OSError:
628                     pass
629         self.check_minion_cache()
630         if self.opts.get("rotate_aes_key"):
631             salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
632         return self.name_match(match) if match is not None else self.dict_match(matches)
633     def reject_all(self):
634         keys = self.list_keys()
635         for key in keys[self.PEND]:
636             try:
637                 shutil.move(
638                     os.path.join(self.opts["pki_dir"], self.PEND, key),
639                     os.path.join(self.opts["pki_dir"], self.REJ, key),
640                 )
641                 eload = {"result": True, "act": "reject", "id": key}
642                 self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
643             except OSError:
644                 pass
645         self.check_minion_cache()
646         if self.opts.get("rotate_aes_key"):
647             salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
648         return self.list_keys()
649     def finger(self, match, hash_type=None):
650         if hash_type is None:
651             hash_type = __opts__["hash_type"]
652         matches = self.name_match(match, True)
653         ret = {}
654         for status, keys in matches.items():
655             ret[status] = {}
656             for key in keys:
657                 if status == "local":
658                     path = os.path.join(self.opts["pki_dir"], key)
659                 else:
660                     path = os.path.join(self.opts["pki_dir"], status, key)
661                 ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
662         return ret
663     def finger_all(self, hash_type=None):
664         if hash_type is None:
665             hash_type = __opts__["hash_type"]
666         ret = {}
667         for status, keys in self.all_keys().items():
668             ret[status] = {}
669             for key in keys:
670                 if status == "local":
671                     path = os.path.join(self.opts["pki_dir"], key)
672                 else:
673                     path = os.path.join(self.opts["pki_dir"], status, key)
674                 ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
675         return ret
676     def __enter__(self):
677         return self
678     def __exit__(self, *args):
679         self.event.destroy()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
