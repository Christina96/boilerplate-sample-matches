<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for xbpspkg.py &amp; key_5.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for xbpspkg.py &amp; key_5.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>xbpspkg.py (2.6119404%)<th>key_5.py (0.7667032%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(9-22)<td><a href="#" name="0">(19-31)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>xbpspkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import glob
import logging
import os
import re
import salt.utils.data
import salt.utils.decorators as decorators
import salt.utils.files
import salt.utils.path
import salt.utils.pkg
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError, MinionError
log = logging.getLogger(</b></font>__name__)
__virtualname__ = "pkg"
def __virtual__():
    if __grains__["os"] in ("Void") and _check_xbps():
        return __virtualname__
    return (False, "Missing dependency: xbps-install")
@decorators.memoize
def _check_xbps():
    return salt.utils.path.which("xbps-install")
@decorators.memoize
def _get_version():
    version_string = __salt__["cmd.run"](
        [_check_xbps(), "--version"], output_loglevel="trace"
    )
    if version_string is None:
        return False
    VERSION_MATCH = re.compile(r"(?:XBPS:[\s]+)([\d.]+)(?:[\s]+.*)")
    version_match = VERSION_MATCH.search(version_string)
    if not version_match:
        return False
    return version_match.group(1).split(".")
def _rehash():
    shell = __salt__["environ.get"]("SHELL")
    if shell.split("/")[-1] in ("csh", "tcsh"):
        __salt__["cmd.run"]("rehash", output_loglevel="trace")
def list_pkgs(versions_as_list=False, **kwargs):
    versions_as_list = salt.utils.data.is_true(versions_as_list)
    if any(
        [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
    ):
        return {}
    cmd = "xbps-query -l"
    ret = {}
    out = __salt__["cmd.run"](cmd, output_loglevel="trace")
    for line in out.splitlines():
        if not line:
            continue
        try:
            pkg, ver = line.split(None)[1].rsplit("-", 1)
        except ValueError:
            log.error('xbps-query: Unexpected formatting in line: "%s"', line)
        __salt__["pkg_resource.add_pkg"](ret, pkg, ver)
    __salt__["pkg_resource.sort_pkglist"](ret)
    if not versions_as_list:
        __salt__["pkg_resource.stringify"](ret)
    return ret
def list_upgrades(refresh=True, **kwargs):
    refresh = salt.utils.data.is_true(refresh)
    if refresh:
        refresh_db()
    ret = {}
    cmd = "xbps-install -un"
    out = __salt__["cmd.run"](cmd, output_loglevel="trace")
    for line in out.splitlines():
        if not line:
            continue
        pkg = "base-system"
        ver = "NonNumericValueIsError"
        try:
            pkg, ver = line.split()[0].rsplit("-", 1)
        except (ValueError, IndexError):
            log.error('xbps-query: Unexpected formatting in line: "%s"', line)
            continue
        log.trace("pkg=%s version=%s", pkg, ver)
        ret[pkg] = ver
    return ret
def latest_version(*names, **kwargs):
    refresh = salt.utils.data.is_true(kwargs.pop("refresh", True))
    if len(names) == 0:
        return ""
    if refresh:
        refresh_db()
    ret = {}
    for name in names:
        ret[name] = ""
    cmd = ["xbps-install", "-un"]
    cmd.extend(names)
    out = __salt__["cmd.run"](cmd, ignore_retcode=True, output_loglevel="trace")
    for line in out.splitlines():
        if not line:
            continue
        if line.find(" is up to date.") != -1:
            continue
        try:
            pkg, ver = line.split()[0].rsplit("-", 1)
        except (ValueError, IndexError):
            log.error('xbps-query: Unexpected formatting in line: "%s"', line)
            continue
        log.trace("pkg=%s version=%s", pkg, ver)
        if pkg in names:
            ret[pkg] = ver
    if len(names) == 1:
        return ret[names[0]]
    return ret
available_version = latest_version
def upgrade_available(name, **kwargs):
    return latest_version(name) != ""
def refresh_db(**kwargs):
    salt.utils.pkg.clear_rtag(__opts__)
    cmd = "xbps-install -Sy"
    call = __salt__["cmd.run_all"](cmd, output_loglevel="trace")
    if call["retcode"] != 0:
        comment = ""
        if "stderr" in call:
            comment += call["stderr"]
        raise CommandExecutionError(comment)
    return True
def version(*names, **kwargs):
    return __salt__["pkg_resource.version"](*names, **kwargs)
def upgrade(refresh=True, **kwargs):
    old = list_pkgs()
    cmd = ["xbps-install", "-{}yu".format("S" if refresh else "")]
    result = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)
    if result["retcode"] != 0:
        raise CommandExecutionError(
            "Problem encountered upgrading packages",
            info={"changes": ret, "result": result},
        )
    return ret
def install(name=None, refresh=False, fromrepo=None, pkgs=None, sources=None, **kwargs):
    try:
        pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
            name, pkgs, sources, **kwargs
        )
    except MinionError as exc:
        raise CommandExecutionError(exc)
    if pkg_params is None or len(pkg_params) == 0:
        return {}
    if pkg_type != "repository":
        log.error('xbps: pkg_type "%s" not supported.', pkg_type)
        return {}
    cmd = ["xbps-install"]
    if refresh:
        cmd.append("-S")  # update repo db
    if fromrepo:
        cmd.append("--repository={}".format(fromrepo))
    cmd.append("-y")  # assume yes when asked
    cmd.extend(pkg_params)
    old = list_pkgs()
    __salt__["cmd.run"](cmd, output_loglevel="trace")
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()
    _rehash()
    return salt.utils.data.compare_dicts(old, new)
def remove(name=None, pkgs=None, recursive=True, **kwargs):
    try:
        pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](name, pkgs)
    except MinionError as exc:
        raise CommandExecutionError(exc)
    if not pkg_params:
        return {}
    old = list_pkgs()
    targets = [x for x in pkg_params if x in old]
    if not targets:
        return {}
    cmd = ["xbps-remove", "-y"]
    if recursive:
        cmd.append("-R")
    cmd.extend(targets)
    __salt__["cmd.run"](cmd, output_loglevel="trace")
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()
    return salt.utils.data.compare_dicts(old, new)
def list_repos(**kwargs):
    repos = {}
    out = __salt__["cmd.run"]("xbps-query -L", output_loglevel="trace")
    for line in out.splitlines():
        repo = {}
        if not line:
            continue
        try:
            nb, url, rsa = line.strip().split(" ", 2)
        except ValueError:
            log.error(
                'Problem parsing xbps-query: Unexpected formatting in line: "%s"',
                line,
            )
        repo["nbpkg"] = int(nb) if nb.isdigit() else 0
        repo["url"] = url
        repo["rsasigned"] = True if rsa == "(RSA signed)" else False
        repos[repo["url"]] = repo
    return repos
def get_repo(repo, **kwargs):
    repos = list_repos()
    if repo in repos:
        return repos[repo]
    return {}
def _locate_repo_files(repo, rewrite=False):
    ret_val = []
    files = []
    conf_dirs = ["/etc/xbps.d/", "/usr/share/xbps.d/"]
    name_glob = "*.conf"
    regex = re.compile(r"\s*repository\s*=\s*" + repo + r"/?\s*(#.*)?$")
    for cur_dir in conf_dirs:
        files.extend(glob.glob(cur_dir + name_glob))
    for filename in files:
        write_buff = []
        with salt.utils.files.fopen(filename, "r") as cur_file:
            for line in cur_file:
                if regex.match(salt.utils.stringutils.to_unicode(line)):
                    ret_val.append(filename)
                else:
                    write_buff.append(line)
        if rewrite and filename in ret_val:
            if len(write_buff) &gt; 0:
                with salt.utils.files.fopen(filename, "w") as rewrite_file:
                    rewrite_file.writelines(write_buff)
            else:  # Prune empty files
                os.remove(filename)
    return ret_val
def add_repo(repo, conffile="/usr/share/xbps.d/15-saltstack.conf"):
    if len(_locate_repo_files(repo)) == 0:
        try:
            with salt.utils.files.fopen(conffile, "a+") as conf_file:
                conf_file.write(
                    salt.utils.stringutils.to_str("repository={}\n".format(repo))
                )
        except OSError:
            return False
    return True
def del_repo(repo, **kwargs):
    try:
        _locate_repo_files(repo, rewrite=True)
    except OSError:
        return False
    else:
        return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>key_5.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import fnmatch
import itertools
import logging
import os
import shutil
import sys
import salt.cache
import salt.client
import salt.crypt
<a name="0"></a>import salt.daemons.masterapi
import salt.exceptions
import salt.minion
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.args
import salt.utils.crypt
import salt.utils.data
import salt.utils.event
import salt.utils.files
import salt.utils.json
import salt.utils.kinds
import salt.utils.master
import salt.utils.sdb
import salt.utils.stringutils
import salt.utils.user
log = logging.getLogger(</b></font>__name__)
def get_key(opts):
    return Key(opts)
class KeyCLI:
    CLI_KEY_MAP = {
        "list": "list_status",
        "delete": "delete_key",
        "gen_signature": "gen_keys_signature",
        "print": "key_str",
    }
    def __init__(self, opts):
        self.opts = opts
        self.client = salt.wheel.WheelClient(opts)
        self.key = Key
        if not opts.get("eauth"):
            self.key = self.key(opts)
        self.auth = None
    def _update_opts(self):
        for cmd in (
            "gen_keys",
            "gen_signature",
            "list",
            "list_all",
            "print",
            "print_all",
            "accept",
            "accept_all",
            "reject",
            "reject_all",
            "delete",
            "delete_all",
            "finger",
            "finger_all",
            "list_all",
        ):  # last is default
            if self.opts[cmd]:
                break
        if not cmd.startswith("gen_"):
            if cmd == "list_all":
                self.opts["match"] = "all"
            elif cmd.endswith("_all"):
                self.opts["match"] = "*"
            else:
                self.opts["match"] = self.opts[cmd]
            if cmd.startswith("accept"):
                self.opts["include_rejected"] = (
                    self.opts["include_all"] or self.opts["include_rejected"]
                )
                self.opts["include_accepted"] = False
            elif cmd.startswith("reject"):
                self.opts["include_accepted"] = (
                    self.opts["include_all"] or self.opts["include_accepted"]
                )
                self.opts["include_rejected"] = False
        elif cmd == "gen_keys":
            self.opts["keydir"] = self.opts["gen_keys_dir"]
            self.opts["keyname"] = self.opts["gen_keys"]
        self.opts["fun"] = cmd.replace("_all", "")
    def _init_auth(self):
        if self.auth:
            return
        low = {}
        skip_perm_errors = self.opts["eauth"] != ""
        if self.opts["eauth"]:
            if "token" in self.opts:
                try:
                    with salt.utils.files.fopen(
                        os.path.join(self.opts["cachedir"], ".root_key"), "r"
                    ) as fp_:
                        low["key"] = salt.utils.stringutils.to_unicode(fp_.readline())
                except OSError:
                    low["token"] = self.opts["token"]
            if "token" not in low and "key" not in low and self.opts["eauth"]:
                resolver = salt.auth.Resolver(self.opts)
                res = resolver.cli(self.opts["eauth"])
                if self.opts["mktoken"] and res:
                    tok = resolver.token_cli(self.opts["eauth"], res)
                    if tok:
                        low["token"] = tok.get("token", "")
                if not res:
                    log.error("Authentication failed")
                    return {}
                low.update(res)
                low["eauth"] = self.opts["eauth"]
        else:
            low["user"] = salt.utils.user.get_specific_user()
            low["key"] = salt.utils.master.get_master_key(
                low["user"], self.opts, skip_perm_errors
            )
        self.auth = low
    def _get_args_kwargs(self, fun, args=None):
        argspec = salt.utils.args.get_function_argspec(fun)
        if args is None:
            args = []
            if argspec.args:
                for arg, default in itertools.zip_longest(
                    reversed(argspec.args), reversed(argspec.defaults or ())
                ):
                    args.append(self.opts.get(arg, default))
            args = args[::-1]
        if argspec.keywords is None:
            kwargs = {}
        else:
            args, kwargs = salt.minion.load_args_and_kwargs(fun, args)
        return args, kwargs
    def _run_cmd(self, cmd, args=None):
        if not self.opts.get("eauth"):
            cmd = self.CLI_KEY_MAP.get(cmd, cmd)
            fun = getattr(self.key, cmd)
            args, kwargs = self._get_args_kwargs(fun, args)
            ret = fun(*args, **kwargs)
            if (
                isinstance(ret, dict)
                and "local" in ret
                and cmd not in ("finger", "finger_all")
            ):
                ret.pop("local", None)
            return ret
        if cmd in ("accept", "reject", "delete") and args is None:
            args = self.opts.get("match_dict", {}).get("minions")
        fstr = "key.{}".format(cmd)
        fun = self.client.functions[fstr]
        args, kwargs = self._get_args_kwargs(fun, args)
        low = {
            "fun": fstr,
            "arg": args,
            "kwarg": kwargs,
        }
        self._init_auth()
        low.update(self.auth)
        ret = self.client.cmd_sync(low)
        ret = ret["data"]["return"]
        if (
            isinstance(ret, dict)
            and "local" in ret
            and cmd not in ("finger", "finger_all")
        ):
            ret.pop("local", None)
        return ret
    def _filter_ret(self, cmd, ret):
        if cmd.startswith("delete"):
            return ret
        keys = {}
        if self.key.PEND in ret:
            keys[self.key.PEND] = ret[self.key.PEND]
        if self.opts["include_accepted"] and bool(ret.get(self.key.ACC)):
            keys[self.key.ACC] = ret[self.key.ACC]
        if self.opts["include_rejected"] and bool(ret.get(self.key.REJ)):
            keys[self.key.REJ] = ret[self.key.REJ]
        if self.opts["include_denied"] and bool(ret.get(self.key.DEN)):
            keys[self.key.DEN] = ret[self.key.DEN]
        return keys
    def _print_no_match(self, cmd, match):
        statuses = ["unaccepted"]
        if self.opts["include_accepted"]:
            statuses.append("accepted")
        if self.opts["include_rejected"]:
            statuses.append("rejected")
        if self.opts["include_denied"]:
            statuses.append("denied")
        if len(statuses) == 1:
            stat_str = statuses[0]
        else:
            stat_str = "{} or {}".format(", ".join(statuses[:-1]), statuses[-1])
        msg = "The key glob '{}' does not match any {} keys.".format(match, stat_str)
        print(msg)
    def run(self):
        self._update_opts()
        cmd = self.opts["fun"]
        veri = None
        ret = None
        try:
            if cmd in ("accept", "reject", "delete"):
                ret = self._run_cmd("name_match")
                if not isinstance(ret, dict):
                    salt.output.display_output(ret, "key", opts=self.opts)
                    return ret
                ret = self._filter_ret(cmd, ret)
                if not ret:
                    self._print_no_match(cmd, self.opts["match"])
                    return
                print(
                    "The following keys are going to be {}ed:".format(cmd.rstrip("e"))
                )
                salt.output.display_output(ret, "key", opts=self.opts)
                if not self.opts.get("yes", False):
                    try:
                        if cmd.startswith("delete"):
                            veri = input("Proceed? [N/y] ")
                            if not veri:
                                veri = "n"
                        else:
                            veri = input("Proceed? [n/Y] ")
                            if not veri:
                                veri = "y"
                    except KeyboardInterrupt:
                        raise SystemExit("\nExiting on CTRL-c")
                self.opts["match_dict"] = ret
                self.opts.pop("match", None)
                list_ret = ret
            if veri is None or veri.lower().startswith("y"):
                ret = self._run_cmd(cmd)
                if cmd in ("accept", "reject", "delete"):
                    if cmd == "delete":
                        ret = list_ret
                    for minions in ret.values():
                        for minion in minions:
                            print(
                                "Key for minion {} {}ed.".format(
                                    minion, cmd.rstrip("e")
                                )
                            )
                elif isinstance(ret, dict):
                    salt.output.display_output(ret, "key", opts=self.opts)
                else:
                    salt.output.display_output({"return": ret}, "key", opts=self.opts)
        except salt.exceptions.SaltException as exc:
            ret = "{}".format(exc)
            if not self.opts.get("quiet", False):
                salt.output.display_output(ret, "nested", self.opts)
        return ret
class Key:
    ACC = "minions"
    PEND = "minions_pre"
    REJ = "minions_rejected"
    DEN = "minions_denied"
    def __init__(self, opts, io_loop=None):
        self.opts = opts
        kind = self.opts.get("__role", "")  # application kind
        if kind not in salt.utils.kinds.APPL_KINDS:
            emsg = "Invalid application kind = '{}'.".format(kind)
            log.error(emsg)
            raise ValueError(emsg)
        self.event = salt.utils.event.get_event(
            kind,
            opts["sock_dir"],
            opts=opts,
            listen=False,
            io_loop=io_loop,
        )
        self.passphrase = salt.utils.sdb.sdb_get(
            self.opts.get("signing_key_pass"), self.opts
        )
    def _check_minions_directories(self):
        minions_accepted = os.path.join(self.opts["pki_dir"], self.ACC)
        minions_pre = os.path.join(self.opts["pki_dir"], self.PEND)
        minions_rejected = os.path.join(self.opts["pki_dir"], self.REJ)
        minions_denied = os.path.join(self.opts["pki_dir"], self.DEN)
        return minions_accepted, minions_pre, minions_rejected, minions_denied
    def _get_key_attrs(self, keydir, keyname, keysize, user):
        if not keydir:
            if "gen_keys_dir" in self.opts:
                keydir = self.opts["gen_keys_dir"]
            else:
                keydir = self.opts["pki_dir"]
        if not keyname:
            if "gen_keys" in self.opts:
                keyname = self.opts["gen_keys"]
            else:
                keyname = "minion"
        if not keysize:
            keysize = self.opts["keysize"]
        return keydir, keyname, keysize, user
    def gen_keys(self, keydir=None, keyname=None, keysize=None, user=None):
        keydir, keyname, keysize, user = self._get_key_attrs(
            keydir, keyname, keysize, user
        )
        salt.crypt.gen_keys(keydir, keyname, keysize, user, self.passphrase)
        return salt.utils.crypt.pem_finger(os.path.join(keydir, keyname + ".pub"))
    def gen_signature(self, privkey, pubkey, sig_path):
        return salt.crypt.gen_signature(privkey, pubkey, sig_path, self.passphrase)
    def gen_keys_signature(
        self, priv, pub, signature_path, auto_create=False, keysize=None
    ):
        if pub:
            if not os.path.isfile(pub):
                return "Public-key {} does not exist".format(pub)
        else:
            mpub = self.opts["pki_dir"] + "/" + "master.pub"
            if os.path.isfile(mpub):
                pub = mpub
        if priv:
            if not os.path.isfile(priv):
                return "Private-key {} does not exist".format(priv)
        else:
            mpriv = self.opts["pki_dir"] + "/" + "master_sign.pem"
            if os.path.isfile(mpriv):
                priv = mpriv
        if not priv:
            if auto_create:
                log.debug(
                    "Generating new signing key-pair .%s.* in %s",
                    self.opts["master_sign_key_name"],
                    self.opts["pki_dir"],
                )
                salt.crypt.gen_keys(
                    self.opts["pki_dir"],
                    self.opts["master_sign_key_name"],
                    keysize or self.opts["keysize"],
                    self.opts.get("user"),
                    self.passphrase,
                )
                priv = (
                    self.opts["pki_dir"]
                    + "/"
                    + self.opts["master_sign_key_name"]
                    + ".pem"
                )
            else:
                return "No usable private-key found"
        if not pub:
            return "No usable public-key found"
        log.debug("Using public-key %s", pub)
        log.debug("Using private-key %s", priv)
        if signature_path:
            if not os.path.isdir(signature_path):
                log.debug("target directory %s does not exist", signature_path)
        else:
            signature_path = self.opts["pki_dir"]
        sign_path = signature_path + "/" + self.opts["master_pubkey_signature"]
        skey = get_key(self.opts)
        return skey.gen_signature(priv, pub, sign_path)
    def check_minion_cache(self, preserve_minions=None):
        if preserve_minions is None:
            preserve_minions = []
        keys = self.list_keys()
        minions = []
        for key, val in keys.items():
            minions.extend(val)
        if not self.opts.get("preserve_minion_cache", False):
            m_cache = os.path.join(self.opts["cachedir"], self.ACC)
            if os.path.isdir(m_cache):
                for minion in os.listdir(m_cache):
                    if minion not in minions and minion not in preserve_minions:
                        try:
                            shutil.rmtree(os.path.join(m_cache, minion))
                        except OSError as ex:
                            log.warning(
                                "Key: Delete cache for %s got OSError/IOError: %s \n",
                                minion,
                                ex,
                            )
                            continue
            cache = salt.cache.factory(self.opts)
            clist = cache.list(self.ACC)
            if clist:
                for minion in clist:
                    if minion not in minions and minion not in preserve_minions:
                        cache.flush("{}/{}".format(self.ACC, minion))
    def check_master(self):
        if not os.path.exists(os.path.join(self.opts["sock_dir"], "publish_pull.ipc")):
            return False
        return True
    def name_match(self, match, full=False):
        if full:
            matches = self.all_keys()
        else:
            matches = self.list_keys()
        ret = {}
        if "," in match and isinstance(match, str):
            match = match.split(",")
        for status, keys in matches.items():
            for key in salt.utils.data.sorted_ignorecase(keys):
                if isinstance(match, list):
                    for match_item in match:
                        if fnmatch.fnmatch(key, match_item):
                            if status not in ret:
                                ret[status] = []
                            ret[status].append(key)
                else:
                    if fnmatch.fnmatch(key, match):
                        if status not in ret:
                            ret[status] = []
                        ret[status].append(key)
        return ret
    def dict_match(self, match_dict):
        ret = {}
        cur_keys = self.list_keys()
        for status, keys in match_dict.items():
            for key in salt.utils.data.sorted_ignorecase(keys):
                for keydir in (self.ACC, self.PEND, self.REJ, self.DEN):
                    if keydir and fnmatch.filter(cur_keys.get(keydir, []), key):
                        ret.setdefault(keydir, []).append(key)
        return ret
    def local_keys(self):
        ret = {"local": []}
        for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(self.opts["pki_dir"])):
            if fn_.endswith(".pub") or fn_.endswith(".pem"):
                path = os.path.join(self.opts["pki_dir"], fn_)
                if os.path.isfile(path):
                    ret["local"].append(fn_)
        return ret
    def list_keys(self):
        key_dirs = self._check_minions_directories()
        ret = {}
        for dir_ in key_dirs:
            if dir_ is None:
                continue
            ret[os.path.basename(dir_)] = []
            try:
                for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(dir_)):
                    if not fn_.startswith("."):
                        if os.path.isfile(os.path.join(dir_, fn_)):
                            ret[os.path.basename(dir_)].append(
                                salt.utils.stringutils.to_unicode(fn_)
                            )
            except OSError:
                continue
        return ret
    def all_keys(self):
        keys = self.list_keys()
        keys.update(self.local_keys())
        return keys
    def list_status(self, match):
        acc, pre, rej, den = self._check_minions_directories()
        ret = {}
        if match.startswith("acc"):
            ret[os.path.basename(acc)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(acc)):
                if not fn_.startswith("."):
                    if os.path.isfile(os.path.join(acc, fn_)):
                        ret[os.path.basename(acc)].append(fn_)
        elif match.startswith("pre") or match.startswith("un"):
            ret[os.path.basename(pre)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(pre)):
                if not fn_.startswith("."):
                    if os.path.isfile(os.path.join(pre, fn_)):
                        ret[os.path.basename(pre)].append(fn_)
        elif match.startswith("rej"):
            ret[os.path.basename(rej)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(rej)):
                if not fn_.startswith("."):
                    if os.path.isfile(os.path.join(rej, fn_)):
                        ret[os.path.basename(rej)].append(fn_)
        elif match.startswith("den") and den is not None:
            ret[os.path.basename(den)] = []
            for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(den)):
                if not fn_.startswith("."):
                    if os.path.isfile(os.path.join(den, fn_)):
                        ret[os.path.basename(den)].append(fn_)
        elif match.startswith("all"):
            return self.all_keys()
        return ret
    def key_str(self, match):
        ret = {}
        for status, keys in self.name_match(match).items():
            ret[status] = {}
            for key in salt.utils.data.sorted_ignorecase(keys):
                path = os.path.join(self.opts["pki_dir"], status, key)
                with salt.utils.files.fopen(path, "r") as fp_:
                    ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
        return ret
    def key_str_all(self):
        ret = {}
        for status, keys in self.list_keys().items():
            ret[status] = {}
            for key in salt.utils.data.sorted_ignorecase(keys):
                path = os.path.join(self.opts["pki_dir"], status, key)
                with salt.utils.files.fopen(path, "r") as fp_:
                    ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
        return ret
    def accept(
        self, match=None, match_dict=None, include_rejected=False, include_denied=False
    ):
        if match is not None:
            matches = self.name_match(match)
        elif match_dict is not None and isinstance(match_dict, dict):
            matches = match_dict
        else:
            matches = {}
        keydirs = [self.PEND]
        if include_rejected:
            keydirs.append(self.REJ)
        if include_denied:
            keydirs.append(self.DEN)
        invalid_keys = []
        for keydir in keydirs:
            for key in matches.get(keydir, []):
                key_path = os.path.join(self.opts["pki_dir"], keydir, key)
                try:
                    salt.crypt.get_rsa_pub_key(key_path)
                except salt.exceptions.InvalidKeyError:
                    log.error("Invalid RSA public key: %s", key)
                    invalid_keys.append((keydir, key))
                    continue
                try:
                    shutil.move(
                        key_path,
                        os.path.join(self.opts["pki_dir"], self.ACC, key),
                    )
                    eload = {"result": True, "act": "accept", "id": key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
                except OSError:
                    pass
        for keydir, key in invalid_keys:
            matches[keydir].remove(key)
            sys.stderr.write("Unable to accept invalid key for {}.\n".format(key))
        return self.name_match(match) if match is not None else self.dict_match(matches)
    def accept_all(self):
        keys = self.list_keys()
        for key in keys[self.PEND]:
            try:
                shutil.move(
                    os.path.join(self.opts["pki_dir"], self.PEND, key),
                    os.path.join(self.opts["pki_dir"], self.ACC, key),
                )
                eload = {"result": True, "act": "accept", "id": key}
                self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
            except OSError:
                pass
        return self.list_keys()
    def delete_key(
        self, match=None, match_dict=None, preserve_minions=None, revoke_auth=False
    ):
        if match is not None:
            matches = self.name_match(match)
        elif match_dict is not None and isinstance(match_dict, dict):
            matches = match_dict
        else:
            matches = {}
        with salt.client.get_local_client(mopts=self.opts) as client:
            for status, keys in matches.items():
                for key in keys:
                    try:
                        if revoke_auth:
                            if self.opts.get("rotate_aes_key") is False:
                                print(
                                    "Immediate auth revocation specified but AES key"
                                    " rotation not allowed. Minion will not be"
                                    " disconnected until the master AES key is rotated."
                                )
                            else:
                                try:
                                    client.cmd_async(key, "saltutil.revoke_auth")
                                except salt.exceptions.SaltClientError:
                                    print(
                                        "Cannot contact Salt master. "
                                        "Connection for {} will remain up until "
                                        "master AES key is rotated or auth is revoked "
                                        "with 'saltutil.revoke_auth'.".format(key)
                                    )
                        os.remove(os.path.join(self.opts["pki_dir"], status, key))
                        eload = {"result": True, "act": "delete", "id": key}
                        self.event.fire_event(
                            eload, salt.utils.event.tagify(prefix="key")
                        )
                    except OSError:
                        pass
        if self.opts.get("preserve_minions") is True:
            self.check_minion_cache(preserve_minions=matches.get("minions", []))
        else:
            self.check_minion_cache()
        if self.opts.get("rotate_aes_key"):
            salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
        return self.name_match(match) if match is not None else self.dict_match(matches)
    def delete_den(self):
        keys = self.list_keys()
        for status, keys in self.list_keys().items():
            for key in keys[self.DEN]:
                try:
                    os.remove(os.path.join(self.opts["pki_dir"], status, key))
                    eload = {"result": True, "act": "delete", "id": key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
                except OSError:
                    pass
        self.check_minion_cache()
        return self.list_keys()
    def delete_all(self):
        for status, keys in self.list_keys().items():
            for key in keys:
                try:
                    os.remove(os.path.join(self.opts["pki_dir"], status, key))
                    eload = {"result": True, "act": "delete", "id": key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
                except OSError:
                    pass
        self.check_minion_cache()
        if self.opts.get("rotate_aes_key"):
            salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
        return self.list_keys()
    def reject(
        self, match=None, match_dict=None, include_accepted=False, include_denied=False
    ):
        if match is not None:
            matches = self.name_match(match)
        elif match_dict is not None and isinstance(match_dict, dict):
            matches = match_dict
        else:
            matches = {}
        keydirs = [self.PEND]
        if include_accepted:
            keydirs.append(self.ACC)
        if include_denied:
            keydirs.append(self.DEN)
        for keydir in keydirs:
            for key in matches.get(keydir, []):
                try:
                    shutil.move(
                        os.path.join(self.opts["pki_dir"], keydir, key),
                        os.path.join(self.opts["pki_dir"], self.REJ, key),
                    )
                    eload = {"result": True, "act": "reject", "id": key}
                    self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
                except OSError:
                    pass
        self.check_minion_cache()
        if self.opts.get("rotate_aes_key"):
            salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
        return self.name_match(match) if match is not None else self.dict_match(matches)
    def reject_all(self):
        keys = self.list_keys()
        for key in keys[self.PEND]:
            try:
                shutil.move(
                    os.path.join(self.opts["pki_dir"], self.PEND, key),
                    os.path.join(self.opts["pki_dir"], self.REJ, key),
                )
                eload = {"result": True, "act": "reject", "id": key}
                self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
            except OSError:
                pass
        self.check_minion_cache()
        if self.opts.get("rotate_aes_key"):
            salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
        return self.list_keys()
    def finger(self, match, hash_type=None):
        if hash_type is None:
            hash_type = __opts__["hash_type"]
        matches = self.name_match(match, True)
        ret = {}
        for status, keys in matches.items():
            ret[status] = {}
            for key in keys:
                if status == "local":
                    path = os.path.join(self.opts["pki_dir"], key)
                else:
                    path = os.path.join(self.opts["pki_dir"], status, key)
                ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
        return ret
    def finger_all(self, hash_type=None):
        if hash_type is None:
            hash_type = __opts__["hash_type"]
        ret = {}
        for status, keys in self.all_keys().items():
            ret[status] = {}
            for key in keys:
                if status == "local":
                    path = os.path.join(self.opts["pki_dir"], key)
                else:
                    path = os.path.join(self.opts["pki_dir"], status, key)
                ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
        return ret
    def __enter__(self):
        return self
    def __exit__(self, *args):
        self.event.destroy()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
