<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for xbpspkg.py &amp; key_5.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for xbpspkg.py &amp; key_5.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>xbpspkg.py (2.6119404%)<th>key_5.py (0.7667032%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(9-22)<td><a href="#" name="0">(19-31)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>xbpspkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import glob
2 import logging
3 import os
4 import re
5 import salt.utils.data
6 import salt.utils.decorators as decorators
7 import salt.utils.files
8 import salt.utils.path
9 import salt.utils.pkg
10 import salt.utils.stringutils
11 from salt.exceptions import CommandExecutionError, MinionError
12 log = logging.getLogger(</b></font>__name__)
13 __virtualname__ = "pkg"
14 def __virtual__():
15     if __grains__["os"] in ("Void") and _check_xbps():
16         return __virtualname__
17     return (False, "Missing dependency: xbps-install")
18 @decorators.memoize
19 def _check_xbps():
20     return salt.utils.path.which("xbps-install")
21 @decorators.memoize
22 def _get_version():
23     version_string = __salt__["cmd.run"](
24         [_check_xbps(), "--version"], output_loglevel="trace"
25     )
26     if version_string is None:
27         return False
28     VERSION_MATCH = re.compile(r"(?:XBPS:[\s]+)([\d.]+)(?:[\s]+.*)")
29     version_match = VERSION_MATCH.search(version_string)
30     if not version_match:
31         return False
32     return version_match.group(1).split(".")
33 def _rehash():
34     shell = __salt__["environ.get"]("SHELL")
35     if shell.split("/")[-1] in ("csh", "tcsh"):
36         __salt__["cmd.run"]("rehash", output_loglevel="trace")
37 def list_pkgs(versions_as_list=False, **kwargs):
38     versions_as_list = salt.utils.data.is_true(versions_as_list)
39     if any(
40         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
41     ):
42         return {}
43     cmd = "xbps-query -l"
44     ret = {}
45     out = __salt__["cmd.run"](cmd, output_loglevel="trace")
46     for line in out.splitlines():
47         if not line:
48             continue
49         try:
50             pkg, ver = line.split(None)[1].rsplit("-", 1)
51         except ValueError:
52             log.error('xbps-query: Unexpected formatting in line: "%s"', line)
53         __salt__["pkg_resource.add_pkg"](ret, pkg, ver)
54     __salt__["pkg_resource.sort_pkglist"](ret)
55     if not versions_as_list:
56         __salt__["pkg_resource.stringify"](ret)
57     return ret
58 def list_upgrades(refresh=True, **kwargs):
59     refresh = salt.utils.data.is_true(refresh)
60     if refresh:
61         refresh_db()
62     ret = {}
63     cmd = "xbps-install -un"
64     out = __salt__["cmd.run"](cmd, output_loglevel="trace")
65     for line in out.splitlines():
66         if not line:
67             continue
68         pkg = "base-system"
69         ver = "NonNumericValueIsError"
70         try:
71             pkg, ver = line.split()[0].rsplit("-", 1)
72         except (ValueError, IndexError):
73             log.error('xbps-query: Unexpected formatting in line: "%s"', line)
74             continue
75         log.trace("pkg=%s version=%s", pkg, ver)
76         ret[pkg] = ver
77     return ret
78 def latest_version(*names, **kwargs):
79     refresh = salt.utils.data.is_true(kwargs.pop("refresh", True))
80     if len(names) == 0:
81         return ""
82     if refresh:
83         refresh_db()
84     ret = {}
85     for name in names:
86         ret[name] = ""
87     cmd = ["xbps-install", "-un"]
88     cmd.extend(names)
89     out = __salt__["cmd.run"](cmd, ignore_retcode=True, output_loglevel="trace")
90     for line in out.splitlines():
91         if not line:
92             continue
93         if line.find(" is up to date.") != -1:
94             continue
95         try:
96             pkg, ver = line.split()[0].rsplit("-", 1)
97         except (ValueError, IndexError):
98             log.error('xbps-query: Unexpected formatting in line: "%s"', line)
99             continue
100         log.trace("pkg=%s version=%s", pkg, ver)
101         if pkg in names:
102             ret[pkg] = ver
103     if len(names) == 1:
104         return ret[names[0]]
105     return ret
106 available_version = latest_version
107 def upgrade_available(name, **kwargs):
108     return latest_version(name) != ""
109 def refresh_db(**kwargs):
110     salt.utils.pkg.clear_rtag(__opts__)
111     cmd = "xbps-install -Sy"
112     call = __salt__["cmd.run_all"](cmd, output_loglevel="trace")
113     if call["retcode"] != 0:
114         comment = ""
115         if "stderr" in call:
116             comment += call["stderr"]
117         raise CommandExecutionError(comment)
118     return True
119 def version(*names, **kwargs):
120     return __salt__["pkg_resource.version"](*names, **kwargs)
121 def upgrade(refresh=True, **kwargs):
122     old = list_pkgs()
123     cmd = ["xbps-install", "-{}yu".format("S" if refresh else "")]
124     result = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
125     __context__.pop("pkg.list_pkgs", None)
126     new = list_pkgs()
127     ret = salt.utils.data.compare_dicts(old, new)
128     if result["retcode"] != 0:
129         raise CommandExecutionError(
130             "Problem encountered upgrading packages",
131             info={"changes": ret, "result": result},
132         )
133     return ret
134 def install(name=None, refresh=False, fromrepo=None, pkgs=None, sources=None, **kwargs):
135     try:
136         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
137             name, pkgs, sources, **kwargs
138         )
139     except MinionError as exc:
140         raise CommandExecutionError(exc)
141     if pkg_params is None or len(pkg_params) == 0:
142         return {}
143     if pkg_type != "repository":
144         log.error('xbps: pkg_type "%s" not supported.', pkg_type)
145         return {}
146     cmd = ["xbps-install"]
147     if refresh:
148         cmd.append("-S")  # update repo db
149     if fromrepo:
150         cmd.append("--repository={}".format(fromrepo))
151     cmd.append("-y")  # assume yes when asked
152     cmd.extend(pkg_params)
153     old = list_pkgs()
154     __salt__["cmd.run"](cmd, output_loglevel="trace")
155     __context__.pop("pkg.list_pkgs", None)
156     new = list_pkgs()
157     _rehash()
158     return salt.utils.data.compare_dicts(old, new)
159 def remove(name=None, pkgs=None, recursive=True, **kwargs):
160     try:
161         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](name, pkgs)
162     except MinionError as exc:
163         raise CommandExecutionError(exc)
164     if not pkg_params:
165         return {}
166     old = list_pkgs()
167     targets = [x for x in pkg_params if x in old]
168     if not targets:
169         return {}
170     cmd = ["xbps-remove", "-y"]
171     if recursive:
172         cmd.append("-R")
173     cmd.extend(targets)
174     __salt__["cmd.run"](cmd, output_loglevel="trace")
175     __context__.pop("pkg.list_pkgs", None)
176     new = list_pkgs()
177     return salt.utils.data.compare_dicts(old, new)
178 def list_repos(**kwargs):
179     repos = {}
180     out = __salt__["cmd.run"]("xbps-query -L", output_loglevel="trace")
181     for line in out.splitlines():
182         repo = {}
183         if not line:
184             continue
185         try:
186             nb, url, rsa = line.strip().split(" ", 2)
187         except ValueError:
188             log.error(
189                 'Problem parsing xbps-query: Unexpected formatting in line: "%s"',
190                 line,
191             )
192         repo["nbpkg"] = int(nb) if nb.isdigit() else 0
193         repo["url"] = url
194         repo["rsasigned"] = True if rsa == "(RSA signed)" else False
195         repos[repo["url"]] = repo
196     return repos
197 def get_repo(repo, **kwargs):
198     repos = list_repos()
199     if repo in repos:
200         return repos[repo]
201     return {}
202 def _locate_repo_files(repo, rewrite=False):
203     ret_val = []
204     files = []
205     conf_dirs = ["/etc/xbps.d/", "/usr/share/xbps.d/"]
206     name_glob = "*.conf"
207     regex = re.compile(r"\s*repository\s*=\s*" + repo + r"/?\s*(#.*)?$")
208     for cur_dir in conf_dirs:
209         files.extend(glob.glob(cur_dir + name_glob))
210     for filename in files:
211         write_buff = []
212         with salt.utils.files.fopen(filename, "r") as cur_file:
213             for line in cur_file:
214                 if regex.match(salt.utils.stringutils.to_unicode(line)):
215                     ret_val.append(filename)
216                 else:
217                     write_buff.append(line)
218         if rewrite and filename in ret_val:
219             if len(write_buff) &gt; 0:
220                 with salt.utils.files.fopen(filename, "w") as rewrite_file:
221                     rewrite_file.writelines(write_buff)
222             else:  # Prune empty files
223                 os.remove(filename)
224     return ret_val
225 def add_repo(repo, conffile="/usr/share/xbps.d/15-saltstack.conf"):
226     if len(_locate_repo_files(repo)) == 0:
227         try:
228             with salt.utils.files.fopen(conffile, "a+") as conf_file:
229                 conf_file.write(
230                     salt.utils.stringutils.to_str("repository={}\n".format(repo))
231                 )
232         except OSError:
233             return False
234     return True
235 def del_repo(repo, **kwargs):
236     try:
237         _locate_repo_files(repo, rewrite=True)
238     except OSError:
239         return False
240     else:
241         return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>key_5.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import fnmatch
2 import itertools
3 import logging
4 import os
5 import shutil
6 import sys
7 import salt.cache
8 import salt.client
9 import salt.crypt
10 import salt.exceptions
11 import salt.minion
12 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.args
13 import salt.utils.crypt
14 import salt.utils.data
15 import salt.utils.event
16 import salt.utils.files
17 import salt.utils.json
18 import salt.utils.kinds
19 import salt.utils.master
20 import salt.utils.sdb
21 import salt.utils.stringutils
22 import salt.utils.user
23 log = logging.getLogger(</b></font>__name__)
24 def get_key(opts):
25     return Key(opts)
26 class KeyCLI:
27     CLI_KEY_MAP = {
28         "list": "list_status",
29         "delete": "delete_key",
30         "gen_signature": "gen_keys_signature",
31         "print": "key_str",
32     }
33     def __init__(self, opts):
34         self.opts = opts
35         self.client = salt.wheel.WheelClient(opts)
36         self.key = Key
37         if not opts.get("eauth"):
38             self.key = self.key(opts)
39         self.auth = None
40     def _update_opts(self):
41         for cmd in (
42             "gen_keys",
43             "gen_signature",
44             "list",
45             "list_all",
46             "print",
47             "print_all",
48             "accept",
49             "accept_all",
50             "reject",
51             "reject_all",
52             "delete",
53             "delete_all",
54             "finger",
55             "finger_all",
56             "list_all",
57         ):  # last is default
58             if self.opts[cmd]:
59                 break
60         if not cmd.startswith("gen_"):
61             if cmd == "list_all":
62                 self.opts["match"] = "all"
63             elif cmd.endswith("_all"):
64                 self.opts["match"] = "*"
65             else:
66                 self.opts["match"] = self.opts[cmd]
67             if cmd.startswith("accept"):
68                 self.opts["include_rejected"] = (
69                     self.opts["include_all"] or self.opts["include_rejected"]
70                 )
71                 self.opts["include_accepted"] = False
72             elif cmd.startswith("reject"):
73                 self.opts["include_accepted"] = (
74                     self.opts["include_all"] or self.opts["include_accepted"]
75                 )
76                 self.opts["include_rejected"] = False
77         elif cmd == "gen_keys":
78             self.opts["keydir"] = self.opts["gen_keys_dir"]
79             self.opts["keyname"] = self.opts["gen_keys"]
80         self.opts["fun"] = cmd.replace("_all", "")
81     def _init_auth(self):
82         if self.auth:
83             return
84         low = {}
85         skip_perm_errors = self.opts["eauth"] != ""
86         if self.opts["eauth"]:
87             if "token" in self.opts:
88                 try:
89                     with salt.utils.files.fopen(
90                         os.path.join(self.opts["cachedir"], ".root_key"), "r"
91                     ) as fp_:
92                         low["key"] = salt.utils.stringutils.to_unicode(fp_.readline())
93                 except OSError:
94                     low["token"] = self.opts["token"]
95             if "token" not in low and "key" not in low and self.opts["eauth"]:
96                 resolver = salt.auth.Resolver(self.opts)
97                 res = resolver.cli(self.opts["eauth"])
98                 if self.opts["mktoken"] and res:
99                     tok = resolver.token_cli(self.opts["eauth"], res)
100                     if tok:
101                         low["token"] = tok.get("token", "")
102                 if not res:
103                     log.error("Authentication failed")
104                     return {}
105                 low.update(res)
106                 low["eauth"] = self.opts["eauth"]
107         else:
108             low["user"] = salt.utils.user.get_specific_user()
109             low["key"] = salt.utils.master.get_master_key(
110                 low["user"], self.opts, skip_perm_errors
111             )
112         self.auth = low
113     def _get_args_kwargs(self, fun, args=None):
114         argspec = salt.utils.args.get_function_argspec(fun)
115         if args is None:
116             args = []
117             if argspec.args:
118                 for arg, default in itertools.zip_longest(
119                     reversed(argspec.args), reversed(argspec.defaults or ())
120                 ):
121                     args.append(self.opts.get(arg, default))
122             args = args[::-1]
123         if argspec.keywords is None:
124             kwargs = {}
125         else:
126             args, kwargs = salt.minion.load_args_and_kwargs(fun, args)
127         return args, kwargs
128     def _run_cmd(self, cmd, args=None):
129         if not self.opts.get("eauth"):
130             cmd = self.CLI_KEY_MAP.get(cmd, cmd)
131             fun = getattr(self.key, cmd)
132             args, kwargs = self._get_args_kwargs(fun, args)
133             ret = fun(*args, **kwargs)
134             if (
135                 isinstance(ret, dict)
136                 and "local" in ret
137                 and cmd not in ("finger", "finger_all")
138             ):
139                 ret.pop("local", None)
140             return ret
141         if cmd in ("accept", "reject", "delete") and args is None:
142             args = self.opts.get("match_dict", {}).get("minions")
143         fstr = "key.{}".format(cmd)
144         fun = self.client.functions[fstr]
145         args, kwargs = self._get_args_kwargs(fun, args)
146         low = {
147             "fun": fstr,
148             "arg": args,
149             "kwarg": kwargs,
150         }
151         self._init_auth()
152         low.update(self.auth)
153         ret = self.client.cmd_sync(low)
154         ret = ret["data"]["return"]
155         if (
156             isinstance(ret, dict)
157             and "local" in ret
158             and cmd not in ("finger", "finger_all")
159         ):
160             ret.pop("local", None)
161         return ret
162     def _filter_ret(self, cmd, ret):
163         if cmd.startswith("delete"):
164             return ret
165         keys = {}
166         if self.key.PEND in ret:
167             keys[self.key.PEND] = ret[self.key.PEND]
168         if self.opts["include_accepted"] and bool(ret.get(self.key.ACC)):
169             keys[self.key.ACC] = ret[self.key.ACC]
170         if self.opts["include_rejected"] and bool(ret.get(self.key.REJ)):
171             keys[self.key.REJ] = ret[self.key.REJ]
172         if self.opts["include_denied"] and bool(ret.get(self.key.DEN)):
173             keys[self.key.DEN] = ret[self.key.DEN]
174         return keys
175     def _print_no_match(self, cmd, match):
176         statuses = ["unaccepted"]
177         if self.opts["include_accepted"]:
178             statuses.append("accepted")
179         if self.opts["include_rejected"]:
180             statuses.append("rejected")
181         if self.opts["include_denied"]:
182             statuses.append("denied")
183         if len(statuses) == 1:
184             stat_str = statuses[0]
185         else:
186             stat_str = "{} or {}".format(", ".join(statuses[:-1]), statuses[-1])
187         msg = "The key glob '{}' does not match any {} keys.".format(match, stat_str)
188         print(msg)
189     def run(self):
190         self._update_opts()
191         cmd = self.opts["fun"]
192         veri = None
193         ret = None
194         try:
195             if cmd in ("accept", "reject", "delete"):
196                 ret = self._run_cmd("name_match")
197                 if not isinstance(ret, dict):
198                     salt.output.display_output(ret, "key", opts=self.opts)
199                     return ret
200                 ret = self._filter_ret(cmd, ret)
201                 if not ret:
202                     self._print_no_match(cmd, self.opts["match"])
203                     return
204                 print(
205                     "The following keys are going to be {}ed:".format(cmd.rstrip("e"))
206                 )
207                 salt.output.display_output(ret, "key", opts=self.opts)
208                 if not self.opts.get("yes", False):
209                     try:
210                         if cmd.startswith("delete"):
211                             veri = input("Proceed? [N/y] ")
212                             if not veri:
213                                 veri = "n"
214                         else:
215                             veri = input("Proceed? [n/Y] ")
216                             if not veri:
217                                 veri = "y"
218                     except KeyboardInterrupt:
219                         raise SystemExit("\nExiting on CTRL-c")
220                 self.opts["match_dict"] = ret
221                 self.opts.pop("match", None)
222                 list_ret = ret
223             if veri is None or veri.lower().startswith("y"):
224                 ret = self._run_cmd(cmd)
225                 if cmd in ("accept", "reject", "delete"):
226                     if cmd == "delete":
227                         ret = list_ret
228                     for minions in ret.values():
229                         for minion in minions:
230                             print(
231                                 "Key for minion {} {}ed.".format(
232                                     minion, cmd.rstrip("e")
233                                 )
234                             )
235                 elif isinstance(ret, dict):
236                     salt.output.display_output(ret, "key", opts=self.opts)
237                 else:
238                     salt.output.display_output({"return": ret}, "key", opts=self.opts)
239         except salt.exceptions.SaltException as exc:
240             ret = "{}".format(exc)
241             if not self.opts.get("quiet", False):
242                 salt.output.display_output(ret, "nested", self.opts)
243         return ret
244 class Key:
245     ACC = "minions"
246     PEND = "minions_pre"
247     REJ = "minions_rejected"
248     DEN = "minions_denied"
249     def __init__(self, opts, io_loop=None):
250         self.opts = opts
251         kind = self.opts.get("__role", "")  # application kind
252         if kind not in salt.utils.kinds.APPL_KINDS:
253             emsg = "Invalid application kind = '{}'.".format(kind)
254             log.error(emsg)
255             raise ValueError(emsg)
256         self.event = salt.utils.event.get_event(
257             kind,
258             opts["sock_dir"],
259             opts=opts,
260             listen=False,
261             io_loop=io_loop,
262         )
263         self.passphrase = salt.utils.sdb.sdb_get(
264             self.opts.get("signing_key_pass"), self.opts
265         )
266     def _check_minions_directories(self):
267         minions_accepted = os.path.join(self.opts["pki_dir"], self.ACC)
268         minions_pre = os.path.join(self.opts["pki_dir"], self.PEND)
269         minions_rejected = os.path.join(self.opts["pki_dir"], self.REJ)
270         minions_denied = os.path.join(self.opts["pki_dir"], self.DEN)
271         return minions_accepted, minions_pre, minions_rejected, minions_denied
272     def _get_key_attrs(self, keydir, keyname, keysize, user):
273         if not keydir:
274             if "gen_keys_dir" in self.opts:
275                 keydir = self.opts["gen_keys_dir"]
276             else:
277                 keydir = self.opts["pki_dir"]
278         if not keyname:
279             if "gen_keys" in self.opts:
280                 keyname = self.opts["gen_keys"]
281             else:
282                 keyname = "minion"
283         if not keysize:
284             keysize = self.opts["keysize"]
285         return keydir, keyname, keysize, user
286     def gen_keys(self, keydir=None, keyname=None, keysize=None, user=None):
287         keydir, keyname, keysize, user = self._get_key_attrs(
288             keydir, keyname, keysize, user
289         )
290         salt.crypt.gen_keys(keydir, keyname, keysize, user, self.passphrase)
291         return salt.utils.crypt.pem_finger(os.path.join(keydir, keyname + ".pub"))
292     def gen_signature(self, privkey, pubkey, sig_path):
293         return salt.crypt.gen_signature(privkey, pubkey, sig_path, self.passphrase)
294     def gen_keys_signature(
295         self, priv, pub, signature_path, auto_create=False, keysize=None
296     ):
297         if pub:
298             if not os.path.isfile(pub):
299                 return "Public-key {} does not exist".format(pub)
300         else:
301             mpub = self.opts["pki_dir"] + "/" + "master.pub"
302             if os.path.isfile(mpub):
303                 pub = mpub
304         if priv:
305             if not os.path.isfile(priv):
306                 return "Private-key {} does not exist".format(priv)
307         else:
308             mpriv = self.opts["pki_dir"] + "/" + "master_sign.pem"
309             if os.path.isfile(mpriv):
310                 priv = mpriv
311         if not priv:
312             if auto_create:
313                 log.debug(
314                     "Generating new signing key-pair .%s.* in %s",
315                     self.opts["master_sign_key_name"],
316                     self.opts["pki_dir"],
317                 )
318                 salt.crypt.gen_keys(
319                     self.opts["pki_dir"],
320                     self.opts["master_sign_key_name"],
321                     keysize or self.opts["keysize"],
322                     self.opts.get("user"),
323                     self.passphrase,
324                 )
325                 priv = (
326                     self.opts["pki_dir"]
327                     + "/"
328                     + self.opts["master_sign_key_name"]
329                     + ".pem"
330                 )
331             else:
332                 return "No usable private-key found"
333         if not pub:
334             return "No usable public-key found"
335         log.debug("Using public-key %s", pub)
336         log.debug("Using private-key %s", priv)
337         if signature_path:
338             if not os.path.isdir(signature_path):
339                 log.debug("target directory %s does not exist", signature_path)
340         else:
341             signature_path = self.opts["pki_dir"]
342         sign_path = signature_path + "/" + self.opts["master_pubkey_signature"]
343         skey = get_key(self.opts)
344         return skey.gen_signature(priv, pub, sign_path)
345     def check_minion_cache(self, preserve_minions=None):
346         if preserve_minions is None:
347             preserve_minions = []
348         keys = self.list_keys()
349         minions = []
350         for key, val in keys.items():
351             minions.extend(val)
352         if not self.opts.get("preserve_minion_cache", False):
353             m_cache = os.path.join(self.opts["cachedir"], self.ACC)
354             if os.path.isdir(m_cache):
355                 for minion in os.listdir(m_cache):
356                     if minion not in minions and minion not in preserve_minions:
357                         try:
358                             shutil.rmtree(os.path.join(m_cache, minion))
359                         except OSError as ex:
360                             log.warning(
361                                 "Key: Delete cache for %s got OSError/IOError: %s \n",
362                                 minion,
363                                 ex,
364                             )
365                             continue
366             cache = salt.cache.factory(self.opts)
367             clist = cache.list(self.ACC)
368             if clist:
369                 for minion in clist:
370                     if minion not in minions and minion not in preserve_minions:
371                         cache.flush("{}/{}".format(self.ACC, minion))
372     def check_master(self):
373         if not os.path.exists(os.path.join(self.opts["sock_dir"], "publish_pull.ipc")):
374             return False
375         return True
376     def name_match(self, match, full=False):
377         if full:
378             matches = self.all_keys()
379         else:
380             matches = self.list_keys()
381         ret = {}
382         if "," in match and isinstance(match, str):
383             match = match.split(",")
384         for status, keys in matches.items():
385             for key in salt.utils.data.sorted_ignorecase(keys):
386                 if isinstance(match, list):
387                     for match_item in match:
388                         if fnmatch.fnmatch(key, match_item):
389                             if status not in ret:
390                                 ret[status] = []
391                             ret[status].append(key)
392                 else:
393                     if fnmatch.fnmatch(key, match):
394                         if status not in ret:
395                             ret[status] = []
396                         ret[status].append(key)
397         return ret
398     def dict_match(self, match_dict):
399         ret = {}
400         cur_keys = self.list_keys()
401         for status, keys in match_dict.items():
402             for key in salt.utils.data.sorted_ignorecase(keys):
403                 for keydir in (self.ACC, self.PEND, self.REJ, self.DEN):
404                     if keydir and fnmatch.filter(cur_keys.get(keydir, []), key):
405                         ret.setdefault(keydir, []).append(key)
406         return ret
407     def local_keys(self):
408         ret = {"local": []}
409         for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(self.opts["pki_dir"])):
410             if fn_.endswith(".pub") or fn_.endswith(".pem"):
411                 path = os.path.join(self.opts["pki_dir"], fn_)
412                 if os.path.isfile(path):
413                     ret["local"].append(fn_)
414         return ret
415     def list_keys(self):
416         key_dirs = self._check_minions_directories()
417         ret = {}
418         for dir_ in key_dirs:
419             if dir_ is None:
420                 continue
421             ret[os.path.basename(dir_)] = []
422             try:
423                 for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(dir_)):
424                     if not fn_.startswith("."):
425                         if os.path.isfile(os.path.join(dir_, fn_)):
426                             ret[os.path.basename(dir_)].append(
427                                 salt.utils.stringutils.to_unicode(fn_)
428                             )
429             except OSError:
430                 continue
431         return ret
432     def all_keys(self):
433         keys = self.list_keys()
434         keys.update(self.local_keys())
435         return keys
436     def list_status(self, match):
437         acc, pre, rej, den = self._check_minions_directories()
438         ret = {}
439         if match.startswith("acc"):
440             ret[os.path.basename(acc)] = []
441             for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(acc)):
442                 if not fn_.startswith("."):
443                     if os.path.isfile(os.path.join(acc, fn_)):
444                         ret[os.path.basename(acc)].append(fn_)
445         elif match.startswith("pre") or match.startswith("un"):
446             ret[os.path.basename(pre)] = []
447             for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(pre)):
448                 if not fn_.startswith("."):
449                     if os.path.isfile(os.path.join(pre, fn_)):
450                         ret[os.path.basename(pre)].append(fn_)
451         elif match.startswith("rej"):
452             ret[os.path.basename(rej)] = []
453             for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(rej)):
454                 if not fn_.startswith("."):
455                     if os.path.isfile(os.path.join(rej, fn_)):
456                         ret[os.path.basename(rej)].append(fn_)
457         elif match.startswith("den") and den is not None:
458             ret[os.path.basename(den)] = []
459             for fn_ in salt.utils.data.sorted_ignorecase(os.listdir(den)):
460                 if not fn_.startswith("."):
461                     if os.path.isfile(os.path.join(den, fn_)):
462                         ret[os.path.basename(den)].append(fn_)
463         elif match.startswith("all"):
464             return self.all_keys()
465         return ret
466     def key_str(self, match):
467         ret = {}
468         for status, keys in self.name_match(match).items():
469             ret[status] = {}
470             for key in salt.utils.data.sorted_ignorecase(keys):
471                 path = os.path.join(self.opts["pki_dir"], status, key)
472                 with salt.utils.files.fopen(path, "r") as fp_:
473                     ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
474         return ret
475     def key_str_all(self):
476         ret = {}
477         for status, keys in self.list_keys().items():
478             ret[status] = {}
479             for key in salt.utils.data.sorted_ignorecase(keys):
480                 path = os.path.join(self.opts["pki_dir"], status, key)
481                 with salt.utils.files.fopen(path, "r") as fp_:
482                     ret[status][key] = salt.utils.stringutils.to_unicode(fp_.read())
483         return ret
484     def accept(
485         self, match=None, match_dict=None, include_rejected=False, include_denied=False
486     ):
487         if match is not None:
488             matches = self.name_match(match)
489         elif match_dict is not None and isinstance(match_dict, dict):
490             matches = match_dict
491         else:
492             matches = {}
493         keydirs = [self.PEND]
494         if include_rejected:
495             keydirs.append(self.REJ)
496         if include_denied:
497             keydirs.append(self.DEN)
498         invalid_keys = []
499         for keydir in keydirs:
500             for key in matches.get(keydir, []):
501                 key_path = os.path.join(self.opts["pki_dir"], keydir, key)
502                 try:
503                     salt.crypt.get_rsa_pub_key(key_path)
504                 except salt.exceptions.InvalidKeyError:
505                     log.error("Invalid RSA public key: %s", key)
506                     invalid_keys.append((keydir, key))
507                     continue
508                 try:
509                     shutil.move(
510                         key_path,
511                         os.path.join(self.opts["pki_dir"], self.ACC, key),
512                     )
513                     eload = {"result": True, "act": "accept", "id": key}
514                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
515                 except OSError:
516                     pass
517         for keydir, key in invalid_keys:
518             matches[keydir].remove(key)
519             sys.stderr.write("Unable to accept invalid key for {}.\n".format(key))
520         return self.name_match(match) if match is not None else self.dict_match(matches)
521     def accept_all(self):
522         keys = self.list_keys()
523         for key in keys[self.PEND]:
524             try:
525                 shutil.move(
526                     os.path.join(self.opts["pki_dir"], self.PEND, key),
527                     os.path.join(self.opts["pki_dir"], self.ACC, key),
528                 )
529                 eload = {"result": True, "act": "accept", "id": key}
530                 self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
531             except OSError:
532                 pass
533         return self.list_keys()
534     def delete_key(
535         self, match=None, match_dict=None, preserve_minions=None, revoke_auth=False
536     ):
537         if match is not None:
538             matches = self.name_match(match)
539         elif match_dict is not None and isinstance(match_dict, dict):
540             matches = match_dict
541         else:
542             matches = {}
543         with salt.client.get_local_client(mopts=self.opts) as client:
544             for status, keys in matches.items():
545                 for key in keys:
546                     try:
547                         if revoke_auth:
548                             if self.opts.get("rotate_aes_key") is False:
549                                 print(
550                                     "Immediate auth revocation specified but AES key"
551                                     " rotation not allowed. Minion will not be"
552                                     " disconnected until the master AES key is rotated."
553                                 )
554                             else:
555                                 try:
556                                     client.cmd_async(key, "saltutil.revoke_auth")
557                                 except salt.exceptions.SaltClientError:
558                                     print(
559                                         "Cannot contact Salt master. "
560                                         "Connection for {} will remain up until "
561                                         "master AES key is rotated or auth is revoked "
562                                         "with 'saltutil.revoke_auth'.".format(key)
563                                     )
564                         os.remove(os.path.join(self.opts["pki_dir"], status, key))
565                         eload = {"result": True, "act": "delete", "id": key}
566                         self.event.fire_event(
567                             eload, salt.utils.event.tagify(prefix="key")
568                         )
569                     except OSError:
570                         pass
571         if self.opts.get("preserve_minions") is True:
572             self.check_minion_cache(preserve_minions=matches.get("minions", []))
573         else:
574             self.check_minion_cache()
575         if self.opts.get("rotate_aes_key"):
576             salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
577         return self.name_match(match) if match is not None else self.dict_match(matches)
578     def delete_den(self):
579         keys = self.list_keys()
580         for status, keys in self.list_keys().items():
581             for key in keys[self.DEN]:
582                 try:
583                     os.remove(os.path.join(self.opts["pki_dir"], status, key))
584                     eload = {"result": True, "act": "delete", "id": key}
585                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
586                 except OSError:
587                     pass
588         self.check_minion_cache()
589         return self.list_keys()
590     def delete_all(self):
591         for status, keys in self.list_keys().items():
592             for key in keys:
593                 try:
594                     os.remove(os.path.join(self.opts["pki_dir"], status, key))
595                     eload = {"result": True, "act": "delete", "id": key}
596                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
597                 except OSError:
598                     pass
599         self.check_minion_cache()
600         if self.opts.get("rotate_aes_key"):
601             salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
602         return self.list_keys()
603     def reject(
604         self, match=None, match_dict=None, include_accepted=False, include_denied=False
605     ):
606         if match is not None:
607             matches = self.name_match(match)
608         elif match_dict is not None and isinstance(match_dict, dict):
609             matches = match_dict
610         else:
611             matches = {}
612         keydirs = [self.PEND]
613         if include_accepted:
614             keydirs.append(self.ACC)
615         if include_denied:
616             keydirs.append(self.DEN)
617         for keydir in keydirs:
618             for key in matches.get(keydir, []):
619                 try:
620                     shutil.move(
621                         os.path.join(self.opts["pki_dir"], keydir, key),
622                         os.path.join(self.opts["pki_dir"], self.REJ, key),
623                     )
624                     eload = {"result": True, "act": "reject", "id": key}
625                     self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
626                 except OSError:
627                     pass
628         self.check_minion_cache()
629         if self.opts.get("rotate_aes_key"):
630             salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
631         return self.name_match(match) if match is not None else self.dict_match(matches)
632     def reject_all(self):
633         keys = self.list_keys()
634         for key in keys[self.PEND]:
635             try:
636                 shutil.move(
637                     os.path.join(self.opts["pki_dir"], self.PEND, key),
638                     os.path.join(self.opts["pki_dir"], self.REJ, key),
639                 )
640                 eload = {"result": True, "act": "reject", "id": key}
641                 self.event.fire_event(eload, salt.utils.event.tagify(prefix="key"))
642             except OSError:
643                 pass
644         self.check_minion_cache()
645         if self.opts.get("rotate_aes_key"):
646             salt.crypt.dropfile(self.opts["cachedir"], self.opts["user"])
647         return self.list_keys()
648     def finger(self, match, hash_type=None):
649         if hash_type is None:
650             hash_type = __opts__["hash_type"]
651         matches = self.name_match(match, True)
652         ret = {}
653         for status, keys in matches.items():
654             ret[status] = {}
655             for key in keys:
656                 if status == "local":
657                     path = os.path.join(self.opts["pki_dir"], key)
658                 else:
659                     path = os.path.join(self.opts["pki_dir"], status, key)
660                 ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
661         return ret
662     def finger_all(self, hash_type=None):
663         if hash_type is None:
664             hash_type = __opts__["hash_type"]
665         ret = {}
666         for status, keys in self.all_keys().items():
667             ret[status] = {}
668             for key in keys:
669                 if status == "local":
670                     path = os.path.join(self.opts["pki_dir"], key)
671                 else:
672                     path = os.path.join(self.opts["pki_dir"], status, key)
673                 ret[status][key] = salt.utils.crypt.pem_finger(path, sum_type=hash_type)
674         return ret
675     def __enter__(self):
676         return self
677     def __exit__(self, *args):
678         self.event.destroy()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
