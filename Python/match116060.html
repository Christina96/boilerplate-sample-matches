<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tls_1.py &amp; boto_lc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tls_1.py &amp; boto_lc.py
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tls_1.py (1.5964524%)<th>boto_lc.py (24.827587%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(645-727)<td><a href="#" name="0">(110-132)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(953-969)<td><a href="#" name="1">(267-283)</a><td align="center"><font color="#e40000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tls_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 r"""
2 A salt module for SSL/TLS.  Can create a Certificate Authority (CA)
3 or use Self-Signed certificates.
4 :depends: PyOpenSSL Python module (0.10 or later, 0.14 or later for X509
5     extension support)
6 :configuration: Add the following values in /etc/salt/minion for the CA module
7     to function properly:
8     .. code-block:: yaml
9         ca.cert_base_path: '/etc/pki'
10 CLI Example #1:
11 Creating a CA, a server request and its signed certificate:
12 .. code-block:: bash
13     days=5 \
14     CN='My Little CA' \
15     C=US \
16     ST=Utah \
17     L=Salt Lake City \
18     O=Saltstack \
19     emailAddress=pleasedontemail@example.com
20     Created Private Key: "/etc/pki/my_little/my_little_ca_cert.key"
21     Created CA "my_little_ca": "/etc/pki/my_little_ca/my_little_ca_cert.crt"
22     Created Private Key: "/etc/pki/my_little/certs/www.example.com.key
23     Created CSR for "www.example.com": "/etc/pki/my_little/certs/www.example.com.csr"
24     Created Certificate for "www.example.com": /etc/pki/my_little/certs/www.example.com.crt"
25 CLI Example #2:
26 Creating a client request and its signed certificate
27 .. code-block:: bash
28     Created Private Key: "/etc/pki/my_little/certs//DBReplica_No.1.key."
29     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.csr."
30     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
31 CLI Example #3:
32 Creating both a server and client req + cert for the same CN
33 .. code-block:: bash
34         cert_type=client
35     Created Private Key: "/etc/pki/my_little/certs/MasterDBReplica_No.2.key."
36     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/MasterDBReplica_No.2.csr."
37     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
38         cert_type=server
39     Certificate "MasterDBReplica_No.2" already exists
40     (doh!)
41         cert_type=server type_ext=True
42     Created Private Key: "/etc/pki/my_little/certs/DBReplica_No.1_client.key."
43     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1_client.csr."
44     Certificate "MasterDBReplica_No.2" already exists
45     (DOH!)
46         cert_type=server type_ext=True
47     Created Certificate for "MasterDBReplica_No.2": "/etc/pki/my_little/certs/MasterDBReplica_No.2_server.crt"
48 CLI Example #4:
49 Create a server req + cert with non-CN filename for the cert
50 .. code-block:: bash
51         cert_type=server type_ext=True
52     Created Private Key: "/etc/pki/my_little/certs/www.anothersometh.ing_server.key."
53     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/www.anothersometh.ing_server.csr."
54         cert_type=server cert_filename="something_completely_different"
55     Created Certificate for "www.anothersometh.ing": /etc/pki/my_little/certs/something_completely_different.crt
56     Only load this module if the ca config options are set
57     Return a Unix timestamp as a string of digits
58     :return:
59     Return the base path for certs from CLI or from options
60     cacert_path
61         absolute path to ca certificates root directory
62     CLI Example:
63     .. code-block:: bash
64         salt '*' tls.cert_base_path
65     Retrocompatible wrapper
66     If wanted, store the aforementioned cacert_path in context
67     to be used as the basepath for further operations
68     CLI Example:
69     .. code-block:: bash
70         salt '*' tls.set_ca_path /etc/certs
71     Return a serial number in hex using os.urandom() and a Unix timestamp
72     in microseconds.
73     ca_name
74         name of the CA
75     CN
76         common name in the request
77     Get basic info to write out to the index.txt
78     write out the index.txt database file in the appropriate directory to
79     track certificates
80     ca_name
81         name of the CA
82     cert
83         certificate to be recorded
84     Check that the X509 version is correct
85     (was incorrectly set in previous salt versions).
86     This will fix the version if needed.
87     ca_name
88         ca authority name
89     cacert_path
90         absolute path to ca certificates root directory
91     ca_filename
92         alternative filename for the CA
93         .. versionadded:: 2015.5.3
94     CLI Example:
95     .. code-block:: bash
96         salt '*' tls.maybe_fix_ssl_version test_ca /etc/certs
97     Verify whether a Certificate Authority (CA) already exists
98     ca_name
99         name of the CA
100     cacert_path
101         absolute path to ca certificates root directory
102     ca_filename
103         alternative filename for the CA
104         .. versionadded:: 2015.5.3
105     CLI Example:
106     .. code-block:: bash
107         salt '*' tls.ca_exists test_ca /etc/certs
108     Get the certificate path or content
109     ca_name
110         name of the CA
111     as_text
112         if true, return the certificate content instead of the path
113     cacert_path
114         absolute path to ca certificates root directory
115     CLI Example:
116     .. code-block:: bash
117         salt '*' tls.get_ca test_ca as_text=False cacert_path=/etc/certs
118     Get the certificate path or content
119     ca_name
120         name of the CA
121     CN
122         common name of the certificate
123     as_text
124         if true, return the certificate content instead of the path
125     cacert_path
126         absolute path to certificates root directory
127     cert_filename
128         alternative filename for the certificate, useful when using special characters in the CN
129         .. versionadded:: 2015.5.3
130     CLI Example:
131     .. code-block:: bash
132         salt '*' tls.get_ca_signed_cert test_ca CN=localhost as_text=False cacert_path=/etc/certs
133     Get the certificate path or content
134     ca_name
135         name of the CA
136     CN
137         common name of the certificate
138     as_text
139         if true, return the certificate content instead of the path
140     cacert_path
141         absolute path to certificates root directory
142     key_filename
143         alternative filename for the key, useful when using special characters
144         .. versionadded:: 2015.5.3
145         in the CN
146     CLI Example:
147     .. code-block:: bash
148         salt '*' tls.get_ca_signed_key \
149                 test_ca CN=localhost \
150                 as_text=False \
151                 cacert_path=/etc/certs
152     .. versionadded:: 3000
153     Validate a certificate against a given CA/CRL.
154     cert
155         path to the certifiate PEM file or string
156     ca_name
157         name of the CA
158     crl_file
159         full path to the CRL file
160     Returns a datetime.datetime object
161     .. versionadded:: 2019.2.0
162     Get a certificate's expiration date
163     cert
164         Full path to the certificate
165     date_format
166         By default this will return the expiration date in YYYY-MM-DD format,
167         use this to specify a different strftime format string. Note that the
168         expiration time will be in UTC.
169     CLI Examples:
170     .. code-block:: bash
171         salt '*' tls.get_expiration_date /path/to/foo.crt
172         salt '*' tls.get_expiration_date /path/to/foo.crt date_format='%d/%m/%Y'
173     """
174     r<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn ret
175 def create_ca(
176     ca_name,
177     bits=2048,
178     days=365,
179     CN="localhost",
180     C="US",
181     ST="Utah",
182     L="Salt Lake City",
183     O="SaltStack",
184     OU=None,
185     emailAddress=None,
186     fixmode=False,
187     cacert_path=None,
188     ca_filename=None,
189     digest="sha256",
190     onlyif=None,
191     unless=None,
192     replace=False,
193 ):
194     """
195     Create a Certificate Authority (CA)
196     ca_name
197         name of the CA
198     bits
199         number of RSA key bits, default is 2048
200     days
201         number of days the CA will be valid, default is 365
202     CN
203         common name in the request, default is "localhost"
204     C
205         country, default is "US"
206     ST
207         state, default is "Utah"
208     L
209         locality, default is "Centerville", the city where SaltStack originated
210     O
211         organization, default is "SaltStack"
212     OU
213         organizational unit, default is None
214     emailAddress
215         email address for the CA owner, default is None
216     cacert_path
217         absolute path to ca certificates root directory
218     ca_filename
219         alternative filename for the CA
220         .. versionadded:: 2015.5.3
221     digest
222         The message digest algorithm. Must be a string describing a digest
223         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
224         For example, "md5" or "sha1". Default: 'sha256'
225     replace
226         Replace this certificate even if it exists
227         .. versionadded:: 2015.5.1
228     Writes out a CA certificate based upon defined config values. If the file
229     already exists, the function just returns assuming the CA certificate
230     already exists.
231     If the following values were set::
232         ca.cert_base_path='/etc/pki'
233         ca_name='koji'
234     the resulting CA, and corresponding key, would be written in the following
235     location with appropriate permissions::
236         /etc/pki/koji/koji_ca_cert.crt
237         /etc/pki/koji/koji_ca_cert.key
238     CLI Example:
239     .. code-block:: bash
240         salt '*' tls.create_ca test_ca
241     """
242     status =</b></font> _check_onlyif_unless(onlyif, unless)
243     if status is not None:
244         return None
245     set_ca_path(cacert_path)
246     if not ca_filename:
247         ca_filename = "{}_ca_cert".format(ca_name)
248     certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
249     ca_keyp = "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
250     if not replace and not fixmode and ca_exists(ca_name, ca_filename=ca_filename):
251         return 'Certificate for CA named "{}" already exists'.format(ca_name)
252     if fixmode and not os.path.exists(certp):
253         raise ValueError("{} does not exists, can't fix".format(certp))
254     if not os.path.exists("{}/{}".format(cert_base_path(), ca_name)):
255         os.makedirs("{}/{}".format(cert_base_path(), ca_name))
256     key = None
257     if os.path.exists(ca_keyp):
258         with salt.utils.files.fopen(ca_keyp) as fic2:
259             try:
260                 key = OpenSSL.crypto.load_privatekey(
261                     OpenSSL.crypto.FILETYPE_PEM, fic2.read()
262                 )
263             except OpenSSL.crypto.Error as err:
264                 log.warning(
265                     "Error loading existing private key %s, generating a new key: %s",
266                     ca_keyp,
267                     err,
268                 )
269                 bck = "{}.unloadable.{}".format(
270                     ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S")
271                 )
272                 log.info("Saving unloadable CA ssl key in %s", bck)
273                 os.rename(ca_keyp, bck)
274     if not key:
275         key = OpenSSL.crypto.PKey()
276         key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
277     ca = OpenSSL.crypto.X509()
278     ca.set_version(2)
279     ca.set_serial_number(_new_serial(ca_name))
280     ca.get_subject().C = C
281     ca.get_subject().ST = ST
282     ca.get_subject().L = L
283     ca.get_subject().O = O
284     if OU:
285         ca.get_subject().OU = OU
286     ca.get_subject().CN = CN
287     if emailAddress:
288         ca.get_subject().emailAddress = emailAddress
289     ca.gmtime_adj_notBefore(0)
290     ca.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
291     ca.set_issuer(ca.get_subject())
292     ca.set_pubkey(key)
293     if X509_EXT_ENABLED:
294         ca.add_extensions(
295             [
296                 OpenSSL.crypto.X509Extension(
297                     b"basicConstraints", True, b"CA:TRUE, pathlen:0"
298                 ),
299                 OpenSSL.crypto.X509Extension(
300                     b"keyUsage", True, b"keyCertSign, cRLSign"
301                 ),
302                 OpenSSL.crypto.X509Extension(
303                     b"subjectKeyIdentifier", False, b"hash", subject=ca
304                 ),
305             ]
306         )
307         ca.add_extensions(
308             [
309                 OpenSSL.crypto.X509Extension(
310                     b"authorityKeyIdentifier",
311                     False,
312                     b"issuer:always,keyid:always",
313                     issuer=ca,
314                 )
315             ]
316         )
317     ca.sign(key, salt.utils.stringutils.to_str(digest))
318     keycontent = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
319     write_key = True
320     if os.path.exists(ca_keyp):
321         bck = "{}.{}".format(ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S"))
322         with salt.utils.files.fopen(ca_keyp) as fic:
323             old_key = salt.utils.stringutils.to_unicode(fic.read()).strip()
324             if old_key.strip() == keycontent.strip():
325                 write_key = False
326             else:
327                 log.info("Saving old CA ssl key in %s", bck)
328                 fp = os.open(bck, os.O_CREAT | os.O_RDWR, 0o600)
329                 with salt.utils.files.fopen(fp, "w") as bckf:
330                     bckf.write(old_key)
331     if write_key:
332         fp = os.open(ca_keyp, os.O_CREAT | os.O_RDWR, 0o600)
333         with salt.utils.files.fopen(fp, "wb") as ca_key:
334             ca_key.write(salt.utils.stringutils.to_bytes(keycontent))
335     with salt.utils.files.fopen(certp, "wb") as ca_crt:
336         ca_crt.write(
337             salt.utils.stringutils.to_bytes(
338                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, ca)
339             )
340         )
341     _write_cert_to_database(ca_name, ca)
342     ret = 'Created Private Key: "{}/{}/{}.key." '.format(
343         cert_base_path(), ca_name, ca_filename
344     )
345     ret += 'Created CA "{0}": "{1}/{0}/{2}.crt."'.format(
346         ca_name, cert_base_path(), ca_filename
347     )
348     return ret
349 def get_extensions(cert_type):
350     """
351     Fetch X509 and CSR extension definitions from tls:extensions:
352     (common|server|client) or set them to standard defaults.
353     .. versionadded:: 2015.8.0
354     cert_type:
355         The type of certificate such as ``server`` or ``client``.
356     CLI Example:
357     .. code-block:: bash
358         salt '*' tls.get_extensions client
359     """
360     assert X509_EXT_ENABLED, (
361         "X509 extensions are not supported in "
362         "pyOpenSSL prior to version 0.15.1. Your "
363         "version: {}".format(OpenSSL_version)
364     )
365     ext = {}
366     if cert_type == "":
367         log.error(
368             "cert_type set to empty in tls_ca.get_extensions(); "
369             "defaulting to ``server``"
370         )
371         cert_type = "server"
372     try:
373         ext["common"] = __salt__["pillar.get"]("tls.extensions:common", False)
374     except NameError as err:
375         log.debug(err)
376     if not ext["common"] or ext["common"] == "":
377         ext["common"] = {
378             "csr": {"basicConstraints": "CA:FALSE"},
379             "cert": {
380                 "authorityKeyIdentifier": "keyid,issuer:always",
381                 "subjectKeyIdentifier": "hash",
382             },
383         }
384     try:
385         ext["server"] = __salt__["pillar.get"]("tls.extensions:server", False)
386     except NameError as err:
387         log.debug(err)
388     if not ext["server"] or ext["server"] == "":
389         ext["server"] = {
390             "csr": {
391                 "extendedKeyUsage": "serverAuth",
392                 "keyUsage": "digitalSignature, keyEncipherment",
393             },
394             "cert": {},
395         }
396     try:
397         ext["client"] = __salt__["pillar.get"]("tls.extensions:client", False)
398     except NameError as err:
399         log.debug(err)
400     if not ext["client"] or ext["client"] == "":
401         ext["client"] = {
402             "csr": {
403                 "extendedKeyUsage": "clientAuth",
404                 "keyUsage": "nonRepudiation, digitalSignature, keyEncipherment",
405             },
406             "cert": {},
407         }
408     if cert_type not in ext:
409         try:
410             ext[cert_type] = __salt__["pillar.get"](
411                 "tls.extensions:{}".format(cert_type)
412             )
413         except NameError as e:
414             log.debug(
415                 "pillar, tls:extensions:%s not available or "
416                 "not operating in a salt context\n%s",
417                 cert_type,
418                 e,
419             )
420     retval = ext["common"]
421     for Use in retval:
422         retval[Use].update(ext[cert_type][Use])
423     return retval
424 def create_csr(
425     ca_name,
426     bits<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=2048,
427     CN="localhost",
428     C="US",
429     ST="Utah",
430     L="Salt Lake City",
431     O="SaltStack",
432     OU=None,
433     emailAddress=None,
434     subjectAltName=None,
435     cacert_path=None,
436     ca_filename=None,
437     csr_path=None,
438     csr_filename=None,
439     digest="sha256",
440     type_ext=False,
441     cert_type="server",
442     replace=</b></font>False,
443 ):
444     """
445     Create a Certificate Signing Request (CSR) for a
446     particular Certificate Authority (CA)
447     ca_name
448         name of the CA
449     bits
450         number of RSA key bits, default is 2048
451     CN
452         common name in the request, default is "localhost"
453     C
454         country, default is "US"
455     ST
456         state, default is "Utah"
457     L
458         locality, default is "Centerville", the city where SaltStack originated
459     O
460         organization, default is "SaltStack"
461         NOTE: Must the same as CA certificate or an error will be raised
462     OU
463         organizational unit, default is None
464     emailAddress
465         email address for the request, default is None
466     subjectAltName
467         valid subjectAltNames in full form, e.g. to add DNS entry you would call
468         this function with this value:
469         examples: ['DNS:somednsname.com',
470                 'DNS:1.2.3.4',
471                 'IP:1.2.3.4',
472                 'IP:2001:4801:7821:77:be76:4eff:fe11:e51',
473                 'email:me@i.like.pie.com']
474     .. note::
475         some libraries do not properly query IP: prefixes, instead looking
476         for the given req. source with a DNS: prefix. To be thorough, you
477         may want to include both DNS: and IP: entries if you are using
478         subjectAltNames for destinations for your TLS connections.
479         e.g.:
480         requests to https://1.2.3.4 will fail from python's
481         requests library w/out the second entry in the above list
482     .. versionadded:: 2015.8.0
483     cert_type
484         Specify the general certificate type. Can be either `server` or
485         `client`. Indicates the set of common extensions added to the CSR.
486         .. code-block:: cfg
487             server: {
488                'basicConstraints': 'CA:FALSE',
489                'extendedKeyUsage': 'serverAuth',
490                'keyUsage': 'digitalSignature, keyEncipherment'
491             }
492             client: {
493                'basicConstraints': 'CA:FALSE',
494                'extendedKeyUsage': 'clientAuth',
495                'keyUsage': 'nonRepudiation, digitalSignature, keyEncipherment'
496             }
497     type_ext
498         boolean.  Whether or not to extend the filename with CN_[cert_type]
499         This can be useful if a server and client certificate are needed for
500         the same CN. Defaults to False to avoid introducing an unexpected file
501         naming pattern
502         The files normally named some_subject_CN.csr and some_subject_CN.key
503         will then be saved
504     replace
505         Replace this signing request even if it exists
506         .. versionadded:: 2015.5.1
507     Writes out a Certificate Signing Request (CSR) If the file already
508     exists, the function just returns assuming the CSR already exists.
509     If the following values were set::
510         ca.cert_base_path='/etc/pki'
511         ca_name='koji'
512         CN='test.egavas.org'
513     the resulting CSR, and corresponding key, would be written in the
514     following location with appropriate permissions::
515         /etc/pki/koji/certs/test.egavas.org.csr
516         /etc/pki/koji/certs/test.egavas.org.key
517     CLI Example:
518     .. code-block:: bash
519         salt '*' tls.create_csr test
520     """
521     set_ca_path(cacert_path)
522     if not ca_filename:
523         ca_filename = "{}_ca_cert".format(ca_name)
524     if not ca_exists(ca_name, ca_filename=ca_filename):
525         return 'Certificate for CA named "{}" does not exist, please create it first.'.format(
526             ca_name
527         )
528     if not csr_path:
529         csr_path = "{}/{}/certs/".format(cert_base_path(), ca_name)
530     if not os.path.exists(csr_path):
531         os.makedirs(csr_path)
532     CN_ext = "_{}".format(cert_type) if type_ext else ""
533     if not csr_filename:
534         csr_filename = "{}{}".format(CN, CN_ext)
535     csr_f = "{}/{}.csr".format(csr_path, csr_filename)
536     if not replace and os.path.exists(csr_f):
537         return 'Certificate Request "{}" already exists'.format(csr_f)
538     key = OpenSSL.crypto.PKey()
539     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
540     req = OpenSSL.crypto.X509Req()
541     req.get_subject().C = C
542     req.get_subject().ST = ST
543     req.get_subject().L = L
544     req.get_subject().O = O
545     if OU:
546         req.get_subject().OU = OU
547     req.get_subject().CN = CN
548     if emailAddress:
549         req.get_subject().emailAddress = emailAddress
550     try:
551         extensions = get_extensions(cert_type)["csr"]
552         extension_adds = []
553         for ext, value in extensions.items():
554             if isinstance(value, str):
555                 value = salt.utils.stringutils.to_bytes(value)
556             extension_adds.append(
557                 OpenSSL.crypto.X509Extension(
558                     salt.utils.stringutils.to_bytes(ext), False, value
559                 )
560             )
561     except AssertionError as err:
562         log.error(err)
563         extensions = []
564     if subjectAltName:
565         if X509_EXT_ENABLED:
566             if isinstance(subjectAltName, str):
567                 subjectAltName = [subjectAltName]
568             extension_adds.append(
569                 OpenSSL.crypto.X509Extension(
570                     b"subjectAltName",
571                     False,
572                     b", ".join(salt.utils.data.encode(subjectAltName)),
573                 )
574             )
575         else:
576             raise ValueError(
577                 "subjectAltName cannot be set as X509 "
578                 "extensions are not supported in pyOpenSSL "
579                 "prior to version 0.15.1. Your "
580                 "version: {}.".format(OpenSSL_version)
581             )
582     if X509_EXT_ENABLED:
583         req.add_extensions(extension_adds)
584     req.set_pubkey(key)
585     req.sign(key, salt.utils.stringutils.to_str(digest))
586     priv_keyp = "{}/{}.key".format(csr_path, csr_filename)
587     fp = os.open(priv_keyp, os.O_CREAT | os.O_RDWR, 0o600)
588     with salt.utils.files.fopen(fp, "wb+") as priv_key:
589         priv_key.write(
590             salt.utils.stringutils.to_bytes(
591                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
592             )
593         )
594     with salt.utils.files.fopen(csr_f, "wb+") as csr:
595         csr.write(
596             salt.utils.stringutils.to_bytes(
597                 OpenSSL.crypto.dump_certificate_request(
598                     OpenSSL.crypto.FILETYPE_PEM, req
599                 )
600             )
601         )
602     ret = 'Created Private Key: "{}{}.key." '.format(csr_path, csr_filename)
603     ret += 'Created CSR for "{}": "{}{}.csr."'.format(CN, csr_path, csr_filename)
604     return ret
605 def create_self_signed_cert(
606     tls_dir="tls",
607     bits=2048,
608     days=365,
609     CN="localhost",
610     C="US",
611     ST="Utah",
612     L="Salt Lake City",
613     O="SaltStack",
614     OU=None,
615     emailAddress=None,
616     cacert_path=None,
617     cert_filename=None,
618     digest="sha256",
619     replace=False,
620 ):
621     """
622     Create a Self-Signed Certificate (CERT)
623     tls_dir
624         location appended to the ca.cert_base_path, default is 'tls'
625     bits
626         number of RSA key bits, default is 2048
627     CN
628         common name in the request, default is "localhost"
629     C
630         country, default is "US"
631     ST
632         state, default is "Utah"
633     L
634         locality, default is "Centerville", the city where SaltStack originated
635     O
636         organization, default is "SaltStack"
637         NOTE: Must the same as CA certificate or an error will be raised
638     OU
639         organizational unit, default is None
640     emailAddress
641         email address for the request, default is None
642     cacert_path
643         absolute path to ca certificates root directory
644     digest
645         The message digest algorithm. Must be a string describing a digest
646         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
647         For example, "md5" or "sha1". Default: 'sha256'
648     replace
649         Replace this certificate even if it exists
650         .. versionadded:: 2015.5.1
651     Writes out a Self-Signed Certificate (CERT). If the file already
652     exists, the function just returns.
653     If the following values were set::
654         ca.cert_base_path='/etc/pki'
655         tls_dir='koji'
656         CN='test.egavas.org'
657     the resulting CERT, and corresponding key, would be written in the
658     following location with appropriate permissions::
659         /etc/pki/koji/certs/test.egavas.org.crt
660         /etc/pki/koji/certs/test.egavas.org.key
661     CLI Example:
662     .. code-block:: bash
663         salt '*' tls.create_self_signed_cert
664     Passing options from the command line:
665     .. code-block:: bash
666         salt 'minion' tls.create_self_signed_cert CN='test.mysite.org'
667     """
668     set_ca_path(cacert_path)
669     if not os.path.exists("{}/{}/certs/".format(cert_base_path(), tls_dir)):
670         os.makedirs("{}/{}/certs/".format(cert_base_path(), tls_dir))
671     if not cert_filename:
672         cert_filename = CN
673     if not replace and os.path.exists(
674         "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
675     ):
676         return 'Certificate "{}" already exists'.format(cert_filename)
677     key = OpenSSL.crypto.PKey()
678     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
679     cert = OpenSSL.crypto.X509()
680     cert.set_version(2)
681     cert.gmtime_adj_notBefore(0)
682     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
683     cert.get_subject().C = C
684     cert.get_subject().ST = ST
685     cert.get_subject().L = L
686     cert.get_subject().O = O
687     if OU:
688         cert.get_subject().OU = OU
689     cert.get_subject().CN = CN
690     if emailAddress:
691         cert.get_subject().emailAddress = emailAddress
692     cert.set_serial_number(_new_serial(tls_dir))
693     cert.set_issuer(cert.get_subject())
694     cert.set_pubkey(key)
695     cert.sign(key, salt.utils.stringutils.to_str(digest))
696     priv_key_path = "{}/{}/certs/{}.key".format(
697         cert_base_path(), tls_dir, cert_filename
698     )
699     fp = os.open(priv_key_path, os.O_CREAT | os.O_RDWR, 0o600)
700     with salt.utils.files.fopen(fp, "wb+") as priv_key:
701         priv_key.write(
702             salt.utils.stringutils.to_bytes(
703                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
704             )
705         )
706     crt_path = "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
707     with salt.utils.files.fopen(crt_path, "wb+") as crt:
708         crt.write(
709             salt.utils.stringutils.to_bytes(
710                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
711             )
712         )
713     _write_cert_to_database(tls_dir, cert)
714     ret = 'Created Private Key: "{}/{}/certs/{}.key." '.format(
715         cert_base_path(), tls_dir, cert_filename
716     )
717     ret += 'Created Certificate: "{}/{}/certs/{}.crt."'.format(
718         cert_base_path(), tls_dir, cert_filename
719     )
720     return ret
721 def create_ca_signed_cert(
722     ca_name,
723     CN,
724     days=365,
725     cacert_path=None,
726     ca_filename=None,
727     cert_path=None,
728     cert_filename=None,
729     digest="sha256",
730     cert_type=None,
731     type_ext=False,
732     replace=False,
733 ):
734     """
735     Create a Certificate (CERT) signed by a named Certificate Authority (CA)
736     If the certificate file already exists, the function just returns assuming
737     the CERT already exists.
738     The CN *must* match an existing CSR generated by create_csr. If it
739     does not, this method does nothing.
740     ca_name
741         name of the CA
742     CN
743         common name matching the certificate signing request
744     days
745         number of days certificate is valid, default is 365 (1 year)
746     cacert_path
747         absolute path to ca certificates root directory
748     ca_filename
749         alternative filename for the CA
750         .. versionadded:: 2015.5.3
751     cert_path
752         full path to the certificates directory
753     cert_filename
754         alternative filename for the certificate, useful when using special
755         characters in the CN. If this option is set it will override
756         the certificate filename output effects of ``cert_type``.
757         ``type_ext`` will be completely overridden.
758         .. versionadded:: 2015.5.3
759     digest
760         The message digest algorithm. Must be a string describing a digest
761         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
762         For example, "md5" or "sha1". Default: 'sha256'
763     replace
764         Replace this certificate even if it exists
765         .. versionadded:: 2015.5.1
766     cert_type
767         string. Either 'server' or 'client' (see create_csr() for details).
768         If create_csr(type_ext=True) this function **must** be called with the
769         same cert_type so it can find the CSR file.
770     .. note::
771         create_csr() defaults to cert_type='server'; therefore, if it was also
772         called with type_ext, cert_type becomes a required argument for
773         create_ca_signed_cert()
774     type_ext
775         bool. If set True, use ``cert_type`` as an extension to the CN when
776         formatting the filename.
777         e.g.: some_subject_CN_server.crt or some_subject_CN_client.crt
778         This facilitates the context where both types are required for the same
779         subject
780         If ``cert_filename`` is `not None`, setting ``type_ext`` has no
781         effect
782     If the following values were set:
783     .. code-block:: text
784         ca.cert_base_path='/etc/pki'
785         ca_name='koji'
786         CN='test.egavas.org'
787     the resulting signed certificate would be written in the following
788     location:
789     .. code-block:: text
790         /etc/pki/koji/certs/test.egavas.org.crt
791     CLI Example:
792     .. code-block:: bash
793         salt '*' tls.create_ca_signed_cert test localhost
794     """
795     ret = {}
796     set_ca_path(cacert_path)
797     if not ca_filename:
798         ca_filename = "{}_ca_cert".format(ca_name)
799     if not cert_path:
800         cert_path = "{}/{}/certs".format(cert_base_path(), ca_name)
801     if type_ext:
802         if not cert_type:
803             log.error(
804                 "type_ext = True but cert_type is unset. Certificate not written."
805             )
806             return ret
807         elif cert_type:
808             CN_ext = "_{}".format(cert_type)
809     else:
810         CN_ext = ""
811     csr_filename = "{}{}".format(CN, CN_ext)
812     if not cert_filename:
813         cert_filename = "{}{}".format(CN, CN_ext)
814     if not replace and os.path.exists(
815         os.path.join(
816             os.path.sep.join(
817                 "{}/{}/certs/{}.crt".format(
818                     cert_base_path(), ca_name, cert_filename
819                 ).split("/")
820             )
821         )
822     ):
823         return 'Certificate "{}" already exists'.format(cert_filename)
824     try:
825         maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
826         with salt.utils.files.fopen(
827             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
828         ) as fhr:
829             ca_cert = OpenSSL.crypto.load_certificate(
830                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
831             )
832         with salt.utils.files.fopen(
833             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
834         ) as fhr:
835             ca_key = OpenSSL.crypto.load_privatekey(
836                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
837             )
838     except OSError:
839         ret["retcode"] = 1
840         ret["comment"] = 'There is no CA named "{}"'.format(ca_name)
841         return ret
842     try:
843         csr_path = "{}/{}.csr".format(cert_path, csr_filename)
844         with salt.utils.files.fopen(csr_path) as fhr:
845             req = OpenSSL.crypto.load_certificate_request(
846                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
847             )
848     except OSError:
849         ret["retcode"] = 1
850         ret["comment"] = 'There is no CSR that matches the CN "{}"'.format(
851             cert_filename
852         )
853         return ret
854     exts = []
855     try:
856         exts.extend(req.get_extensions())
857     except AttributeError:
858         try:
859             log.info(
860                 "req.get_extensions() not supported in pyOpenSSL versions "
861                 "prior to 0.15. Processing extensions internally. "
862                 "Your version: %s",
863                 OpenSSL_version,
864             )
865             native_exts_obj = OpenSSL._util.lib.X509_REQ_get_extensions(req._req)
866             for i in range(OpenSSL._util.lib.sk_X509_EXTENSION_num(native_exts_obj)):
867                 ext = OpenSSL.crypto.X509Extension.__new__(OpenSSL.crypto.X509Extension)
868                 ext._extension = OpenSSL._util.lib.sk_X509_EXTENSION_value(
869                     native_exts_obj, i
870                 )
871                 exts.append(ext)
872         except Exception:  # pylint: disable=broad-except
873             log.error(
874                 "X509 extensions are unsupported in pyOpenSSL "
875                 "versions prior to 0.14. Upgrade required to "
876                 "use extensions. Current version: %s",
877                 OpenSSL_version,
878             )
879     cert = OpenSSL.crypto.X509()
880     cert.set_version(2)
881     cert.set_subject(req.get_subject())
882     cert.gmtime_adj_notBefore(0)
883     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
884     cert.set_serial_number(_new_serial(ca_name))
885     cert.set_issuer(ca_cert.get_subject())
886     cert.set_pubkey(req.get_pubkey())
887     cert.add_extensions(exts)
888     cert.sign(ca_key, salt.utils.stringutils.to_str(digest))
889     cert_full_path = "{}/{}.crt".format(cert_path, cert_filename)
890     with salt.utils.files.fopen(cert_full_path, "wb+") as crt:
891         crt.write(
892             salt.utils.stringutils.to_bytes(
893                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
894             )
895         )
896     _write_cert_to_database(ca_name, cert)
897     return 'Created Certificate for "{}": "{}/{}.crt"'.format(
898         CN, cert_path, cert_filename
899     )
900 def create_pkcs12(ca_name, CN, passphrase="", cacert_path=None, replace=False):
901     """
902     Create a PKCS#12 browser certificate for a particular Certificate (CN)
903     ca_name
904         name of the CA
905     CN
906         common name matching the certificate signing request
907     passphrase
908         used to unlock the PKCS#12 certificate when loaded into the browser
909     cacert_path
910         absolute path to ca certificates root directory
911     replace
912         Replace this certificate even if it exists
913         .. versionadded:: 2015.5.1
914     If the following values were set::
915         ca.cert_base_path='/etc/pki'
916         ca_name='koji'
917         CN='test.egavas.org'
918     the resulting signed certificate would be written in the
919     following location::
920         /etc/pki/koji/certs/test.egavas.org.p12
921     CLI Example:
922     .. code-block:: bash
923         salt '*' tls.create_pkcs12 test localhost
924     """
925     set_ca_path(cacert_path)
926     if not replace and os.path.exists(
927         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN)
928     ):
929         return 'Certificate "{}" already exists'.format(CN)
930     try:
931         with salt.utils.files.fopen(
932             "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
933         ) as fhr:
934             ca_cert = OpenSSL.crypto.load_certificate(
935                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
936             )
937     except OSError:
938         return 'There is no CA named "{}"'.format(ca_name)
939     try:
940         with salt.utils.files.fopen(
941             "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, CN)
942         ) as fhr:
943             cert = OpenSSL.crypto.load_certificate(
944                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
945             )
946         with salt.utils.files.fopen(
947             "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, CN)
948         ) as fhr:
949             key = OpenSSL.crypto.load_privatekey(
950                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
951             )
952     except OSError:
953         return 'There is no certificate that matches the CN "{}"'.format(CN)
954     pkcs12 = OpenSSL.crypto.PKCS12()
955     pkcs12.set_certificate(cert)
956     pkcs12.set_ca_certificates([ca_cert])
957     pkcs12.set_privatekey(key)
958     with salt.utils.files.fopen(
959         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN), "wb"
960     ) as ofile:
961         ofile.write(
962             pkcs12.export(passphrase=salt.utils.stringutils.to_bytes(passphrase))
963         )
964     return 'Created PKCS#12 Certificate for "{0}": "{1}/{2}/certs/{0}.p12"'.format(
965         CN,
966         cert_base_path(),
967         ca_name,
968     )
969 def cert_info(cert, digest="sha256"):
970     """
971     Return information for a particular certificate
972     cert
973         path to the certifiate PEM file or string
974         .. versionchanged:: 2018.3.4
975     digest
976         what digest to use for fingerprinting
977     CLI Example:
978     .. code-block:: bash
979         salt '*' tls.cert_info /dir/for/certs/cert.pem
980     """
981     date_fmt = "%Y%m%d%H%M%SZ"
982     if "-----BEGIN" not in cert:
983         with salt.utils.files.fopen(cert) as cert_file:
984             cert = cert_file.read()
985     cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
986     issuer = {}
987     for key, value in cert.get_issuer().get_components():
988         if isinstance(key, bytes):
989             key = salt.utils.stringutils.to_unicode(key)
990         if isinstance(value, bytes):
991             value = salt.utils.stringutils.to_unicode(value)
992         issuer[key] = value
993     subject = {}
994     for key, value in cert.get_subject().get_components():
995         if isinstance(key, bytes):
996             key = salt.utils.stringutils.to_unicode(key)
997         if isinstance(value, bytes):
998             value = salt.utils.stringutils.to_unicode(value)
999         subject[key] = value
1000     ret = {
1001         "fingerprint": salt.utils.stringutils.to_unicode(
1002             cert.digest(salt.utils.stringutils.to_str(digest))
1003         ),
1004         "subject": subject,
1005         "issuer": issuer,
1006         "serial_number": cert.get_serial_number(),
1007         "not_before": calendar.timegm(
1008             time.strptime(
1009                 str(cert.get_notBefore().decode(__salt_system_encoding__)), date_fmt
1010             )
1011         ),
1012         "not_after": calendar.timegm(
1013             time.strptime(
1014                 cert.get_notAfter().decode(__salt_system_encoding__), date_fmt
1015             )
1016         ),
1017     }
1018     if hasattr(cert, "get_extension_count"):
1019         ret["extensions"] = {}
1020         for i in range(cert.get_extension_count()):
1021             try:
1022                 ext = cert.get_extension(i)
1023                 key = salt.utils.stringutils.to_unicode(ext.get_short_name())
1024                 ret["extensions"][key] = str(ext).strip()
1025             except AttributeError:
1026                 continue
1027     if "subjectAltName" in ret.get("extensions", {}):
1028         valid_entries = ("DNS", "IP Address")
1029         valid_names = set()
1030         for name in str(ret["extensions"]["subjectAltName"]).split(", "):
1031             entry, name = name.split(":", 1)
1032             if entry not in valid_entries:
1033                 log.error(
1034                     "Cert %s has an entry (%s) which does not start with %s",
1035                     ret["subject"],
1036                     name,
1037                     "/".join(valid_entries),
1038                 )
1039             else:
1040                 valid_names.add(name)
1041         ret["subject_alt_names"] = list(valid_names)
1042     if hasattr(cert, "get_signature_algorithm"):
1043         try:
1044             value = cert.get_signature_algorithm()
1045             if isinstance(value, bytes):
1046                 value = salt.utils.stringutils.to_unicode(value)
1047             ret["signature_algorithm"] = value
1048         except AttributeError:
1049             pass
1050     return ret
1051 def create_empty_crl(
1052     ca_name, cacert_path=None, ca_filename=None, crl_file=None, digest="sha256"
1053 ):
1054     """
1055     Create an empty Certificate Revocation List.
1056     .. versionadded:: 2015.8.0
1057     ca_name
1058         name of the CA
1059     cacert_path
1060         absolute path to ca certificates root directory
1061     ca_filename
1062         alternative filename for the CA
1063         .. versionadded:: 2015.5.3
1064     crl_file
1065         full path to the CRL file
1066     digest
1067         The message digest algorithm. Must be a string describing a digest
1068         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
1069         For example, "md5" or "sha1". Default: 'sha256'
1070     CLI Example:
1071     .. code-block:: bash
1072         salt '*' tls.create_empty_crl ca_name='koji' \
1073                 ca_filename='ca' \
1074                 crl_file='/etc/openvpn/team1/crl.pem'
1075     """
1076     set_ca_path(cacert_path)
1077     if not ca_filename:
1078         ca_filename = "{}_ca_cert".format(ca_name)
1079     if not crl_file:
1080         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
1081     if os.path.exists("{}".format(crl_file)):
1082         return 'CRL "{}" already exists'.format(crl_file)
1083     try:
1084         with salt.utils.files.fopen(
1085             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
1086         ) as fp_:
1087             ca_cert = OpenSSL.crypto.load_certificate(
1088                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1089             )
1090         with salt.utils.files.fopen(
1091             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
1092         ) as fp_:
1093             ca_key = OpenSSL.crypto.load_privatekey(
1094                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1095             )
1096     except OSError:
1097         return 'There is no CA named "{}"'.format(ca_name)
1098     crl = OpenSSL.crypto.CRL()
1099     crl_text = crl.export(
1100         ca_cert,
1101         ca_key,
1102         digest=salt.utils.stringutils.to_bytes(digest),
1103     )
1104     with salt.utils.files.fopen(crl_file, "w") as f:
1105         f.write(salt.utils.stringutils.to_str(crl_text))
1106     return 'Created an empty CRL: "{}"'.format(crl_file)
1107 def revoke_cert(
1108     ca_name,
1109     CN,
1110     cacert_path=None,
1111     ca_filename=None,
1112     cert_path=None,
1113     cert_filename=None,
1114     crl_file=None,
1115     digest="sha256",
1116 ):
1117     """
1118     Revoke a certificate.
1119     .. versionadded:: 2015.8.0
1120     ca_name
1121         Name of the CA.
1122     CN
1123         Common name matching the certificate signing request.
1124     cacert_path
1125         Absolute path to ca certificates root directory.
1126     ca_filename
1127         Alternative filename for the CA.
1128     cert_path
1129         Path to the cert file.
1130     cert_filename
1131         Alternative filename for the certificate, useful when using special
1132         characters in the CN.
1133     crl_file
1134         Full path to the CRL file.
1135     digest
1136         The message digest algorithm. Must be a string describing a digest
1137         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
1138         For example, "md5" or "sha1". Default: 'sha256'
1139     CLI Example:
1140     .. code-block:: bash
1141         salt '*' tls.revoke_cert ca_name='koji' \
1142                 ca_filename='ca' \
1143                 crl_file='/etc/openvpn/team1/crl.pem'
1144     """
1145     set_ca_path(cacert_path)
1146     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
1147     if ca_filename is None:
1148         ca_filename = "{}_ca_cert".format(ca_name)
1149     if cert_path is None:
1150         cert_path = "{}/{}/certs".format(_cert_base_path(), ca_name)
1151     if cert_filename is None:
1152         cert_filename = "{}".format(CN)
1153     try:
1154         with salt.utils.files.fopen(
1155             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
1156         ) as fp_:
1157             ca_cert = OpenSSL.crypto.load_certificate(
1158                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1159             )
1160         with salt.utils.files.fopen(
1161             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
1162         ) as fp_:
1163             ca_key = OpenSSL.crypto.load_privatekey(
1164                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1165             )
1166     except OSError:
1167         return 'There is no CA named "{}"'.format(ca_name)
1168     client_cert = _read_cert("{}/{}.crt".format(cert_path, cert_filename))
1169     if client_cert is None:
1170         return 'There is no client certificate named "{}"'.format(CN)
1171     index_file, expire_date, serial_number, subject = _get_basic_info(
1172         ca_name, client_cert, ca_dir
1173     )
1174     index_serial_subject = "{}\tunknown\t{}".format(serial_number, subject)
1175     index_v_data = "V\t{}\t\t{}".format(expire_date, index_serial_subject)
1176     index_r_data_pattern = re.compile(
1177         r"R\t" + expire_date + r"\t\d{12}Z\t" + re.escape(index_serial_subject)
1178     )
1179     index_r_data = "R\t{}\t{}\t{}".format(
1180         expire_date,
1181         _four_digit_year_to_two_digit(datetime.utcnow()),
1182         index_serial_subject,
1183     )
1184     ret = {}
1185     with salt.utils.files.fopen(index_file) as fp_:
1186         for line in fp_:
1187             line = salt.utils.stringutils.to_unicode(line)
1188             if index_r_data_pattern.match(line):
1189                 revoke_date = line.split("\t")[2]
1190                 try:
1191                     datetime.strptime(revoke_date, two_digit_year_fmt)
1192                     return '"{}/{}.crt" was already revoked, serial number: {}'.format(
1193                         cert_path, cert_filename, serial_number
1194                     )
1195                 except ValueError:
1196                     ret["retcode"] = 1
1197                     ret[
1198                         "comment"
1199                     ] = "Revocation date '{}' does not matchformat '{}'".format(
1200                         revoke_date, two_digit_year_fmt
1201                     )
1202                     return ret
1203             elif index_serial_subject in line:
1204                 __salt__["file.replace"](
1205                     index_file, index_v_data, index_r_data, backup=False
1206                 )
1207                 break
1208     crl = OpenSSL.crypto.CRL()
1209     with salt.utils.files.fopen(index_file) as fp_:
1210         for line in fp_:
1211             line = salt.utils.stringutils.to_unicode(line)
1212             if line.startswith("R"):
1213                 fields = line.split("\t")
1214                 revoked = OpenSSL.crypto.Revoked()
1215                 revoked.set_serial(salt.utils.stringutils.to_bytes(fields[3]))
1216                 revoke_date_2_digit = datetime.strptime(fields[2], two_digit_year_fmt)
1217                 revoked.set_rev_date(
1218                     salt.utils.stringutils.to_bytes(
1219                         revoke_date_2_digit.strftime(four_digit_year_fmt)
1220                     )
1221                 )
1222                 crl.add_revoked(revoked)
1223     crl_text = crl.export(
1224         ca_cert, ca_key, digest=salt.utils.stringutils.to_bytes(digest)
1225     )
1226     if crl_file is None:
1227         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
1228     if os.path.isdir(crl_file):
1229         ret["retcode"] = 1
1230         ret["comment"] = 'crl_file "{}" is an existing directory'.format(crl_file)
1231         return ret
1232     with salt.utils.files.fopen(crl_file, "w") as fp_:
1233         fp_.write(salt.utils.stringutils.to_str(crl_text))
1234     return 'Revoked Certificate: "{}/{}.crt", serial number: {}'.format(
1235         cert_path, cert_filename, serial_number
1236     )
1237 if __name__ == "__main__":
1238     create_csr(
1239         "koji",
1240         CN="test_system",
1241         C="US",
1242         ST="Utah",
1243         L="Centerville",
1244         O="SaltStack",
1245         OU=None,
1246         emailAddress="test_system@saltstack.org",
1247     )
1248     create_ca_signed_cert("koji", "test_system")
1249     create_pkcs12("koji", "test_system", passphrase="test")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_lc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Manage Launch Configurations
3 .. versionadded:: 2014.7.0
4 Create and destroy Launch Configurations. Be aware that this interacts with
5 Amazon's services, and so may incur charges.
6 A limitation of this module is that you can not modify launch configurations
7 once they have been created. If a launch configuration with the specified name
8 exists, this module will always report success, even if the specified
9 configuration doesn't match. This is due to a limitation in Amazon's launch
10 configuration API, as it only allows launch configurations to be created and
11 deleted.
12 Also note that a launch configuration that's in use by an autoscale group can
13 not be deleted until the autoscale group is no longer using it. This may affect
14 the way in which you want to order your states.
15 This module uses ``boto``, which can be installed via package, or pip.
16 This module accepts explicit autoscale credentials but can also utilize
17 IAM roles assigned to the instance through Instance Profiles. Dynamic
18 credentials are then automatically obtained from AWS API and no further
19 configuration is necessary. More information available `here
20 &lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.
21 If IAM roles are not used you need to specify them either in a pillar file or
22 in the minion's config file:
23 .. code-block:: yaml
24     asg.keyid: GKTADJGHEIQSXMKKRBJ08H
25     asg.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
26 It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
27 passed in as a dict, or as a string to pull from pillars or minion config:
28 .. code-block:: yaml
29     myprofile:
30         keyid: GKTADJGHEIQSXMKKRBJ08H
31         key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
32         region: us-east-1
33 Credential information is shared with autoscale groups as launch configurations
34 and autoscale groups are completely dependent on each other.
35 .. code-block:: yaml
36     Ensure mylc exists:
37       boto_lc.present:
38         - name: mylc
39         - image_id: ami-0b9c9f62
40         - key_name: mykey
41         - security_groups:
42             - mygroup
43         - instance_type: m1.small
44         - instance_monitoring: true
45         - block_device_mappings:
46             - '/dev/sda1':
47                 size: 20
48                 volume_type: 'io1'
49                 iops: 220
50                 delete_on_termination: true
51         - cloud_init:
52             boothooks:
53               'disable-master.sh': |
54                 echo "manual" &gt; /etc/init/salt-master.override
55             scripts:
56               'run_salt.sh': |
57                 add-apt-repository -y ppa:saltstack/salt
58                 apt-get update
59                 apt-get install -y salt-minion
60                 salt-call state.highstate
61         - region: us-east-1
62         - keyid: GKTADJGHEIQSXMKKRBJ08H
63         - key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
64     Ensure mylc exists:
65       boto_lc.present:
66         - name: mylc
67         - image_id: ami-0b9c9f62
68         - profile: myprofile
69     Ensure mylc exists:
70       boto_lc.present:
71         - name: mylc
72         - image_id: ami-0b9c9f62
73         - profile:
74             keyid: GKTADJGHEIQSXMKKRBJ08H
75             key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
76             region: us-east-1
77 """
78 from salt.exceptions import SaltInvocationError
79 def __virtual__():
80     """
81     Only load if boto is available.
82     if "boto_asg.exists" in __salt__:
83         return "boto_lc"
84     return (F<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>alse, "boto_asg module could not be loaded")
85 def present(
86     name,
87     image_id,
88     key_name=None,
89     vpc_id=None,
90     vpc_name=None,
91     security_groups=None,
92     user_data=None,
93     cloud_init=None,
94     instance_type="m1.small",
95     kernel_id=None,
96     ramdisk_id=None,
97     block_device_mappings=None,
98     delete_on_termination=None,
99     instance_monitoring=False,
100     spot_price=None,
101     instance_profile_name=None,
102     ebs_optimized=False,
103     associate_public_ip_address=None,
104     region=</b></font>None,
105     key=None,
106     keyid=None,
107     profile=None,
108 ):
109     """
110     Ensure the launch configuration exists.
111     name
112         Name of the launch configuration.
113     image_id
114         AMI to use for instances. AMI must exist or creation of the launch
115         configuration will fail.
116     key_name
117         Name of the EC2 key pair to use for instances. Key must exist or
118         creation of the launch configuration will fail.
119     vpc_id
120         The VPC id where the security groups are defined. Only necessary when
121         using named security groups that exist outside of the default VPC.
122         Mutually exclusive with vpc_name.
123     vpc_name
124         Name of the VPC where the security groups are defined. Only Necessary
125         when using named security groups that exist outside of the default VPC.
126         Mutually exclusive with vpc_id.
127     security_groups
128         List of Names or security group ids of the security groups with which
129         to associate the EC2 instances or VPC instances, respectively. Security
130         groups must exist, or creation of the launch configuration will fail.
131     user_data
132         The user data available to launched EC2 instances.
133     cloud_init
134         A dict of cloud_init configuration. Currently supported keys:
135         boothooks, scripts and cloud-config.
136         Mutually exclusive with user_data.
137     instance_type
138         The instance type. ex: m1.small.
139     kernel_id
140         The kernel id for the instance.
141     ramdisk_id
142         The RAM disk ID for the instance.
143     block_device_mappings
144         A dict of block device mappings that contains a dict
145         with volume_type, delete_on_termination, iops, size, encrypted,
146         snapshot_id.
147         volume_type
148             Indicates what volume type to use. Valid values are standard, io1, gp2.
149             Default is standard.
150         delete_on_termination
151             Whether the volume should be explicitly marked for deletion when its instance is
152             terminated (True), or left around (False).  If not provided, or None is explicitly passed,
153             the default AWS behaviour is used, which is True for ROOT volumes of instances, and
154             False for all others.
155         iops
156             For Provisioned IOPS (SSD) volumes only. The number of I/O operations per
157             second (IOPS) to provision for the volume.
158         size
159             Desired volume size (in GiB).
160         encrypted
161             Indicates whether the volume should be encrypted. Encrypted EBS volumes must
162             be attached to instances that support Amazon EBS encryption. Volumes that are
163             created from encrypted snapshots are automatically encrypted. There is no way
164             to create an encrypted volume from an unencrypted snapshot or an unencrypted
165             volume from an encrypted snapshot.
166     instance_monitoring
167         Whether instances in group are launched with detailed monitoring.
168     spot_price
169         The spot price you are bidding. Only applies if you are building an
170         autoscaling group with spot instances.
171     instance_profile_name
172         The name or the Amazon Resource Name (ARN) of the instance profile
173         associated with the IAM role for the instance. Instance profile must
174         exist or the creation of the launch configuration will fail.
175     ebs_optimized
176         Specifies whether the instance is optimized for EBS I/O (true) or not
177         (false).
178     associate_public_ip_address
179         Used for Auto Scaling groups that launch instances into an Amazon
180         Virtual Private Cloud. Specifies whether to assign a public IP address
181         to each instance launched in a Amazon VPC.
182     region
183         The region to connect to.
184     key
185         Secret key to be used.
186     keyid
187         Access key to be used.
188     profile
189         A dict with region, key and keyid, or a pillar key (string)
190         that contains a dict with region, key and keyid.
191     """
192     if user_data and cloud_init:
193         raise SaltInvocationError(
194             "user_data and cloud_init are mutually exclusive options."
195         )
196     ret = {"name": name, "result": True, "comment": "", "changes": {}}
197     exists = __salt__["boto_asg.launch_configuration_exists"](
198         name, region=region, key=key, keyid=keyid, profile=profile
199     )
200     if not exists:
201         if __opts__["test"]:
202             msg = "Launch configuration set to be created."
203             ret["comment"] = msg
204             ret["result"] = None
205             return ret
206         if cloud_init:
207             user_data = __salt__["boto_asg.get_cloud_init_mime"](cloud_init)
208             name,
209             image_id,
210             key_name<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=key_name,
211             vpc_id=vpc_id,
212             vpc_name=vpc_name,
213             security_groups=security_groups,
214             user_data=user_data,
215             instance_type=instance_type,
216             kernel_id=kernel_id,
217             ramdisk_id=ramdisk_id,
218             block_device_mappings=block_device_mappings,
219             delete_on_termination=delete_on_termination,
220             instance_monitoring=instance_monitoring,
221             spot_price=spot_price,
222             instance_profile_name=instance_profile_name,
223             ebs_optimized=ebs_optimized,
224             associate_public_ip_address=associate_public_ip_address,
225             region=region,
226             key=</b></font>key,
227             keyid=keyid,
228             profile=profile,
229         )
230         if created:
231             ret["changes"]["old"] = None
232             ret["changes"]["new"] = name
233         else:
234             ret["result"] = False
235             ret["comment"] = "Failed to create launch configuration."
236     else:
237         ret["comment"] = "Launch configuration present."
238     return ret
239 def absent(name, region=None, key=None, keyid=None, profile=None):
240     """
241     Ensure the named launch configuration is deleted.
242     name
243         Name of the launch configuration.
244     region
245         The region to connect to.
246     key
247         Secret key to be used.
248     keyid
249         Access key to be used.
250     profile
251         A dict with region, key and keyid, or a pillar key (string)
252         that contains a dict with region, key and keyid.
253     """
254     ret = {"name": name, "result": True, "comment": "", "changes": {}}
255     exists = __salt__["boto_asg.launch_configuration_exists"](
256         name, region=region, key=key, keyid=keyid, profile=profile
257     )
258     if exists:
259         if __opts__["test"]:
260             ret["comment"] = "Launch configuration set to be deleted."
261             ret["result"] = None
262             return ret
263         deleted = __salt__["boto_asg.delete_launch_configuration"](
264             name, region=region, key=key, keyid=keyid, profile=profile
265         )
266         if deleted:
267             ret["changes"]["old"] = name
268             ret["changes"]["new"] = None
269             ret["comment"] = "Deleted launch configuration."
270         else:
271             ret["result"] = False
272             ret["comment"] = "Failed to delete launch configuration."
273     else:
274         ret["comment"] = "Launch configuration does not exist."
275     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
