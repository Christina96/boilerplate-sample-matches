<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tls_1.py &amp; boto_lc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tls_1.py &amp; boto_lc.py
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tls_1.py (1.5964524%)<th>boto_lc.py (24.827587%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(645-727)<td><a href="#" name="0">(110-132)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(953-969)<td><a href="#" name="1">(267-283)</a><td align="center"><font color="#e40000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tls_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
r"""
A salt module for SSL/TLS.  Can create a Certificate Authority (CA)
or use Self-Signed certificates.
:depends: PyOpenSSL Python module (0.10 or later, 0.14 or later for X509
    extension support)
:configuration: Add the following values in /etc/salt/minion for the CA module
    to function properly:
    .. code-block:: yaml
        ca.cert_base_path: '/etc/pki'
CLI Example #1:
Creating a CA, a server request and its signed certificate:
.. code-block:: bash
    days=5 \
    CN='My Little CA' \
    C=US \
    ST=Utah \
    L=Salt Lake City \
    O=Saltstack \
    emailAddress=pleasedontemail@example.com
    Created Private Key: "/etc/pki/my_little/my_little_ca_cert.key"
    Created CA "my_little_ca": "/etc/pki/my_little_ca/my_little_ca_cert.crt"
    Created Private Key: "/etc/pki/my_little/certs/www.example.com.key
    Created CSR for "www.example.com": "/etc/pki/my_little/certs/www.example.com.csr"
    Created Certificate for "www.example.com": /etc/pki/my_little/certs/www.example.com.crt"
CLI Example #2:
Creating a client request and its signed certificate
.. code-block:: bash
    Created Private Key: "/etc/pki/my_little/certs//DBReplica_No.1.key."
    Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.csr."
    Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
CLI Example #3:
Creating both a server and client req + cert for the same CN
.. code-block:: bash
        cert_type=client
    Created Private Key: "/etc/pki/my_little/certs/MasterDBReplica_No.2.key."
    Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/MasterDBReplica_No.2.csr."
    Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
        cert_type=server
    Certificate "MasterDBReplica_No.2" already exists
    (doh!)
        cert_type=server type_ext=True
    Created Private Key: "/etc/pki/my_little/certs/DBReplica_No.1_client.key."
    Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1_client.csr."
    Certificate "MasterDBReplica_No.2" already exists
    (DOH!)
        cert_type=server type_ext=True
    Created Certificate for "MasterDBReplica_No.2": "/etc/pki/my_little/certs/MasterDBReplica_No.2_server.crt"
CLI Example #4:
Create a server req + cert with non-CN filename for the cert
.. code-block:: bash
        cert_type=server type_ext=True
    Created Private Key: "/etc/pki/my_little/certs/www.anothersometh.ing_server.key."
    Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/www.anothersometh.ing_server.csr."
        cert_type=server cert_filename="something_completely_different"
    Created Certificate for "www.anothersometh.ing": /etc/pki/my_little/certs/something_completely_different.crt
    Only load this module if the ca config options are set
    Return a Unix timestamp as a string of digits
    :return:
    Return the base path for certs from CLI or from options
    cacert_path
        absolute path to ca certificates root directory
    CLI Example:
    .. code-block:: bash
        salt '*' tls.cert_base_path
    Retrocompatible wrapper
    If wanted, store the aforementioned cacert_path in context
    to be used as the basepath for further operations
    CLI Example:
    .. code-block:: bash
        salt '*' tls.set_ca_path /etc/certs
    Return a serial number in hex using os.urandom() and a Unix timestamp
    in microseconds.
    ca_name
        name of the CA
    CN
        common name in the request
    Get basic info to write out to the index.txt
    write out the index.txt database file in the appropriate directory to
    track certificates
    ca_name
        name of the CA
    cert
        certificate to be recorded
    Check that the X509 version is correct
    (was incorrectly set in previous salt versions).
    This will fix the version if needed.
    ca_name
        ca authority name
    cacert_path
        absolute path to ca certificates root directory
    ca_filename
        alternative filename for the CA
        .. versionadded:: 2015.5.3
    CLI Example:
    .. code-block:: bash
        salt '*' tls.maybe_fix_ssl_version test_ca /etc/certs
    Verify whether a Certificate Authority (CA) already exists
    ca_name
        name of the CA
    cacert_path
        absolute path to ca certificates root directory
    ca_filename
        alternative filename for the CA
        .. versionadded:: 2015.5.3
    CLI Example:
    .. code-block:: bash
        salt '*' tls.ca_exists test_ca /etc/certs
    Get the certificate path or content
    ca_name
        name of the CA
    as_text
        if true, return the certificate content instead of the path
    cacert_path
        absolute path to ca certificates root directory
    CLI Example:
    .. code-block:: bash
        salt '*' tls.get_ca test_ca as_text=False cacert_path=/etc/certs
    Get the certificate path or content
    ca_name
        name of the CA
    CN
        common name of the certificate
    as_text
        if true, return the certificate content instead of the path
    cacert_path
        absolute path to certificates root directory
    cert_filename
        alternative filename for the certificate, useful when using special characters in the CN
        .. versionadded:: 2015.5.3
    CLI Example:
    .. code-block:: bash
        salt '*' tls.get_ca_signed_cert test_ca CN=localhost as_text=False cacert_path=/etc/certs
    Get the certificate path or content
    ca_name
        name of the CA
    CN
        common name of the certificate
    as_text
        if true, return the certificate content instead of the path
    cacert_path
        absolute path to certificates root directory
    key_filename
        alternative filename for the key, useful when using special characters
        .. versionadded:: 2015.5.3
        in the CN
    CLI Example:
    .. code-block:: bash
        salt '*' tls.get_ca_signed_key \
                test_ca CN=localhost \
                as_text=False \
                cacert_path=/etc/certs
    .. versionadded:: 3000
    Validate a certificate against a given CA/CRL.
    cert
        path to the certifiate PEM file or string
    ca_name
        name of the CA
    crl_file
        full path to the CRL file
    Returns a datetime.datetime object
    .. versionadded:: 2019.2.0
    Get a certificate's expiration date
    cert
        Full path to the certificate
    date_format
        By default this will return the expiration date in YYYY-MM-DD format,
        use this to specify a different strftime format string. Note that the
        expiration time will be in UTC.
    CLI Examples:
    .. code-block:: bash
        salt '*' tls.get_expiration_date /path/to/foo.crt
        salt '*' tls.get_expiration_date /path/to/foo.crt date_format='%d/%m/%Y'
    r<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn ret
def create_ca(
    ca_name,
    bits=2048,
    days=365,
    CN="localhost",
    C="US",
    ST="Utah",
    L="Salt Lake City",
    O="SaltStack",
    OU=None,
    emailAddress=None,
    fixmode=False,
    cacert_path=None,
    ca_filename=None,
    digest="sha256",
    onlyif=None,
    unless=None,
    replace=False,
):
    status =</b></font> _check_onlyif_unless(onlyif, unless)
    if status is not None:
        return None
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
    ca_keyp = "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
    if not replace and not fixmode and ca_exists(ca_name, ca_filename=ca_filename):
        return 'Certificate for CA named "{}" already exists'.format(ca_name)
    if fixmode and not os.path.exists(certp):
        raise ValueError("{} does not exists, can't fix".format(certp))
    if not os.path.exists("{}/{}".format(cert_base_path(), ca_name)):
        os.makedirs("{}/{}".format(cert_base_path(), ca_name))
    key = None
    if os.path.exists(ca_keyp):
        with salt.utils.files.fopen(ca_keyp) as fic2:
            try:
                key = OpenSSL.crypto.load_privatekey(
                    OpenSSL.crypto.FILETYPE_PEM, fic2.read()
                )
            except OpenSSL.crypto.Error as err:
                log.warning(
                    "Error loading existing private key %s, generating a new key: %s",
                    ca_keyp,
                    err,
                )
                bck = "{}.unloadable.{}".format(
                    ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S")
                )
                log.info("Saving unloadable CA ssl key in %s", bck)
                os.rename(ca_keyp, bck)
    if not key:
        key = OpenSSL.crypto.PKey()
        key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
    ca = OpenSSL.crypto.X509()
    ca.set_version(2)
    ca.set_serial_number(_new_serial(ca_name))
    ca.get_subject().C = C
    ca.get_subject().ST = ST
    ca.get_subject().L = L
    ca.get_subject().O = O
    if OU:
        ca.get_subject().OU = OU
    ca.get_subject().CN = CN
    if emailAddress:
        ca.get_subject().emailAddress = emailAddress
    ca.gmtime_adj_notBefore(0)
    ca.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
    ca.set_issuer(ca.get_subject())
    ca.set_pubkey(key)
    if X509_EXT_ENABLED:
        ca.add_extensions(
            [
                OpenSSL.crypto.X509Extension(
                    b"basicConstraints", True, b"CA:TRUE, pathlen:0"
                ),
                OpenSSL.crypto.X509Extension(
                    b"keyUsage", True, b"keyCertSign, cRLSign"
                ),
                OpenSSL.crypto.X509Extension(
                    b"subjectKeyIdentifier", False, b"hash", subject=ca
                ),
            ]
        )
        ca.add_extensions(
            [
                OpenSSL.crypto.X509Extension(
                    b"authorityKeyIdentifier",
                    False,
                    b"issuer:always,keyid:always",
                    issuer=ca,
                )
            ]
        )
    ca.sign(key, salt.utils.stringutils.to_str(digest))
    keycontent = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
    write_key = True
    if os.path.exists(ca_keyp):
        bck = "{}.{}".format(ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S"))
        with salt.utils.files.fopen(ca_keyp) as fic:
            old_key = salt.utils.stringutils.to_unicode(fic.read()).strip()
            if old_key.strip() == keycontent.strip():
                write_key = False
            else:
                log.info("Saving old CA ssl key in %s", bck)
                fp = os.open(bck, os.O_CREAT | os.O_RDWR, 0o600)
                with salt.utils.files.fopen(fp, "w") as bckf:
                    bckf.write(old_key)
    if write_key:
        fp = os.open(ca_keyp, os.O_CREAT | os.O_RDWR, 0o600)
        with salt.utils.files.fopen(fp, "wb") as ca_key:
            ca_key.write(salt.utils.stringutils.to_bytes(keycontent))
    with salt.utils.files.fopen(certp, "wb") as ca_crt:
        ca_crt.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, ca)
            )
        )
    _write_cert_to_database(ca_name, ca)
    ret = 'Created Private Key: "{}/{}/{}.key." '.format(
        cert_base_path(), ca_name, ca_filename
    )
    ret += 'Created CA "{0}": "{1}/{0}/{2}.crt."'.format(
        ca_name, cert_base_path(), ca_filename
    )
    return ret
def get_extensions(cert_type):
    assert X509_EXT_ENABLED, (
        "X509 extensions are not supported in "
        "pyOpenSSL prior to version 0.15.1. Your "
        "version: {}".format(OpenSSL_version)
    )
    ext = {}
    if cert_type == "":
        log.error(
            "cert_type set to empty in tls_ca.get_extensions(); "
            "defaulting to ``server``"
        )
        cert_type = "server"
    try:
        ext["common"] = __salt__["pillar.get"]("tls.extensions:common", False)
    except NameError as err:
        log.debug(err)
    if not ext["common"] or ext["common"] == "":
        ext["common"] = {
            "csr": {"basicConstraints": "CA:FALSE"},
            "cert": {
                "authorityKeyIdentifier": "keyid,issuer:always",
                "subjectKeyIdentifier": "hash",
            },
        }
    try:
        ext["server"] = __salt__["pillar.get"]("tls.extensions:server", False)
    except NameError as err:
        log.debug(err)
    if not ext["server"] or ext["server"] == "":
        ext["server"] = {
            "csr": {
                "extendedKeyUsage": "serverAuth",
                "keyUsage": "digitalSignature, keyEncipherment",
            },
            "cert": {},
        }
    try:
        ext["client"] = __salt__["pillar.get"]("tls.extensions:client", False)
    except NameError as err:
        log.debug(err)
    if not ext["client"] or ext["client"] == "":
        ext["client"] = {
            "csr": {
                "extendedKeyUsage": "clientAuth",
                "keyUsage": "nonRepudiation, digitalSignature, keyEncipherment",
            },
            "cert": {},
        }
    if cert_type not in ext:
        try:
            ext[cert_type] = __salt__["pillar.get"](
                "tls.extensions:{}".format(cert_type)
            )
        except NameError as e:
            log.debug(
                "pillar, tls:extensions:%s not available or "
                "not operating in a salt context\n%s",
                cert_type,
                e,
            )
    retval = ext["common"]
    for Use in retval:
        retval[Use].update(ext[cert_type][Use])
    return retval
<a name="1"></a>
def create_csr(
    ca_name,
    bits<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=2048,
    CN="localhost",
    C="US",
    ST="Utah",
    L="Salt Lake City",
    O="SaltStack",
    OU=None,
    emailAddress=None,
    subjectAltName=None,
    cacert_path=None,
    ca_filename=None,
    csr_path=None,
    csr_filename=None,
    digest="sha256",
    type_ext=False,
    cert_type="server",
    replace=</b></font>False,
):
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    if not ca_exists(ca_name, ca_filename=ca_filename):
        return 'Certificate for CA named "{}" does not exist, please create it first.'.format(
            ca_name
        )
    if not csr_path:
        csr_path = "{}/{}/certs/".format(cert_base_path(), ca_name)
    if not os.path.exists(csr_path):
        os.makedirs(csr_path)
    CN_ext = "_{}".format(cert_type) if type_ext else ""
    if not csr_filename:
        csr_filename = "{}{}".format(CN, CN_ext)
    csr_f = "{}/{}.csr".format(csr_path, csr_filename)
    if not replace and os.path.exists(csr_f):
        return 'Certificate Request "{}" already exists'.format(csr_f)
    key = OpenSSL.crypto.PKey()
    key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
    req = OpenSSL.crypto.X509Req()
    req.get_subject().C = C
    req.get_subject().ST = ST
    req.get_subject().L = L
    req.get_subject().O = O
    if OU:
        req.get_subject().OU = OU
    req.get_subject().CN = CN
    if emailAddress:
        req.get_subject().emailAddress = emailAddress
    try:
        extensions = get_extensions(cert_type)["csr"]
        extension_adds = []
        for ext, value in extensions.items():
            if isinstance(value, str):
                value = salt.utils.stringutils.to_bytes(value)
            extension_adds.append(
                OpenSSL.crypto.X509Extension(
                    salt.utils.stringutils.to_bytes(ext), False, value
                )
            )
    except AssertionError as err:
        log.error(err)
        extensions = []
    if subjectAltName:
        if X509_EXT_ENABLED:
            if isinstance(subjectAltName, str):
                subjectAltName = [subjectAltName]
            extension_adds.append(
                OpenSSL.crypto.X509Extension(
                    b"subjectAltName",
                    False,
                    b", ".join(salt.utils.data.encode(subjectAltName)),
                )
            )
        else:
            raise ValueError(
                "subjectAltName cannot be set as X509 "
                "extensions are not supported in pyOpenSSL "
                "prior to version 0.15.1. Your "
                "version: {}.".format(OpenSSL_version)
            )
    if X509_EXT_ENABLED:
        req.add_extensions(extension_adds)
    req.set_pubkey(key)
    req.sign(key, salt.utils.stringutils.to_str(digest))
    priv_keyp = "{}/{}.key".format(csr_path, csr_filename)
    fp = os.open(priv_keyp, os.O_CREAT | os.O_RDWR, 0o600)
    with salt.utils.files.fopen(fp, "wb+") as priv_key:
        priv_key.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
            )
        )
    with salt.utils.files.fopen(csr_f, "wb+") as csr:
        csr.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate_request(
                    OpenSSL.crypto.FILETYPE_PEM, req
                )
            )
        )
    ret = 'Created Private Key: "{}{}.key." '.format(csr_path, csr_filename)
    ret += 'Created CSR for "{}": "{}{}.csr."'.format(CN, csr_path, csr_filename)
    return ret
def create_self_signed_cert(
    tls_dir="tls",
    bits=2048,
    days=365,
    CN="localhost",
    C="US",
    ST="Utah",
    L="Salt Lake City",
    O="SaltStack",
    OU=None,
    emailAddress=None,
    cacert_path=None,
    cert_filename=None,
    digest="sha256",
    replace=False,
):
    set_ca_path(cacert_path)
    if not os.path.exists("{}/{}/certs/".format(cert_base_path(), tls_dir)):
        os.makedirs("{}/{}/certs/".format(cert_base_path(), tls_dir))
    if not cert_filename:
        cert_filename = CN
    if not replace and os.path.exists(
        "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
    ):
        return 'Certificate "{}" already exists'.format(cert_filename)
    key = OpenSSL.crypto.PKey()
    key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
    cert = OpenSSL.crypto.X509()
    cert.set_version(2)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
    cert.get_subject().C = C
    cert.get_subject().ST = ST
    cert.get_subject().L = L
    cert.get_subject().O = O
    if OU:
        cert.get_subject().OU = OU
    cert.get_subject().CN = CN
    if emailAddress:
        cert.get_subject().emailAddress = emailAddress
    cert.set_serial_number(_new_serial(tls_dir))
    cert.set_issuer(cert.get_subject())
    cert.set_pubkey(key)
    cert.sign(key, salt.utils.stringutils.to_str(digest))
    priv_key_path = "{}/{}/certs/{}.key".format(
        cert_base_path(), tls_dir, cert_filename
    )
    fp = os.open(priv_key_path, os.O_CREAT | os.O_RDWR, 0o600)
    with salt.utils.files.fopen(fp, "wb+") as priv_key:
        priv_key.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
            )
        )
    crt_path = "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
    with salt.utils.files.fopen(crt_path, "wb+") as crt:
        crt.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            )
        )
    _write_cert_to_database(tls_dir, cert)
    ret = 'Created Private Key: "{}/{}/certs/{}.key." '.format(
        cert_base_path(), tls_dir, cert_filename
    )
    ret += 'Created Certificate: "{}/{}/certs/{}.crt."'.format(
        cert_base_path(), tls_dir, cert_filename
    )
    return ret
def create_ca_signed_cert(
    ca_name,
    CN,
    days=365,
    cacert_path=None,
    ca_filename=None,
    cert_path=None,
    cert_filename=None,
    digest="sha256",
    cert_type=None,
    type_ext=False,
    replace=False,
):
    ret = {}
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    if not cert_path:
        cert_path = "{}/{}/certs".format(cert_base_path(), ca_name)
    if type_ext:
        if not cert_type:
            log.error(
                "type_ext = True but cert_type is unset. Certificate not written."
            )
            return ret
        elif cert_type:
            CN_ext = "_{}".format(cert_type)
    else:
        CN_ext = ""
    csr_filename = "{}{}".format(CN, CN_ext)
    if not cert_filename:
        cert_filename = "{}{}".format(CN, CN_ext)
    if not replace and os.path.exists(
        os.path.join(
            os.path.sep.join(
                "{}/{}/certs/{}.crt".format(
                    cert_base_path(), ca_name, cert_filename
                ).split("/")
            )
        )
    ):
        return 'Certificate "{}" already exists'.format(cert_filename)
    try:
        maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
        with salt.utils.files.fopen(
            "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
        ) as fhr:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
        with salt.utils.files.fopen(
            "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
        ) as fhr:
            ca_key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        ret["retcode"] = 1
        ret["comment"] = 'There is no CA named "{}"'.format(ca_name)
        return ret
    try:
        csr_path = "{}/{}.csr".format(cert_path, csr_filename)
        with salt.utils.files.fopen(csr_path) as fhr:
            req = OpenSSL.crypto.load_certificate_request(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        ret["retcode"] = 1
        ret["comment"] = 'There is no CSR that matches the CN "{}"'.format(
            cert_filename
        )
        return ret
    exts = []
    try:
        exts.extend(req.get_extensions())
    except AttributeError:
        try:
            log.info(
                "req.get_extensions() not supported in pyOpenSSL versions "
                "prior to 0.15. Processing extensions internally. "
                "Your version: %s",
                OpenSSL_version,
            )
            native_exts_obj = OpenSSL._util.lib.X509_REQ_get_extensions(req._req)
            for i in range(OpenSSL._util.lib.sk_X509_EXTENSION_num(native_exts_obj)):
                ext = OpenSSL.crypto.X509Extension.__new__(OpenSSL.crypto.X509Extension)
                ext._extension = OpenSSL._util.lib.sk_X509_EXTENSION_value(
                    native_exts_obj, i
                )
                exts.append(ext)
        except Exception:  # pylint: disable=broad-except
            log.error(
                "X509 extensions are unsupported in pyOpenSSL "
                "versions prior to 0.14. Upgrade required to "
                "use extensions. Current version: %s",
                OpenSSL_version,
            )
    cert = OpenSSL.crypto.X509()
    cert.set_version(2)
    cert.set_subject(req.get_subject())
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
    cert.set_serial_number(_new_serial(ca_name))
    cert.set_issuer(ca_cert.get_subject())
    cert.set_pubkey(req.get_pubkey())
    cert.add_extensions(exts)
    cert.sign(ca_key, salt.utils.stringutils.to_str(digest))
    cert_full_path = "{}/{}.crt".format(cert_path, cert_filename)
    with salt.utils.files.fopen(cert_full_path, "wb+") as crt:
        crt.write(
            salt.utils.stringutils.to_bytes(
                OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
            )
        )
    _write_cert_to_database(ca_name, cert)
    return 'Created Certificate for "{}": "{}/{}.crt"'.format(
        CN, cert_path, cert_filename
    )
def create_pkcs12(ca_name, CN, passphrase="", cacert_path=None, replace=False):
    set_ca_path(cacert_path)
    if not replace and os.path.exists(
        "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN)
    ):
        return 'Certificate "{}" already exists'.format(CN)
    try:
        with salt.utils.files.fopen(
            "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
        ) as fhr:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        return 'There is no CA named "{}"'.format(ca_name)
    try:
        with salt.utils.files.fopen(
            "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, CN)
        ) as fhr:
            cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
        with salt.utils.files.fopen(
            "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, CN)
        ) as fhr:
            key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fhr.read()
            )
    except OSError:
        return 'There is no certificate that matches the CN "{}"'.format(CN)
    pkcs12 = OpenSSL.crypto.PKCS12()
    pkcs12.set_certificate(cert)
    pkcs12.set_ca_certificates([ca_cert])
    pkcs12.set_privatekey(key)
    with salt.utils.files.fopen(
        "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN), "wb"
    ) as ofile:
        ofile.write(
            pkcs12.export(passphrase=salt.utils.stringutils.to_bytes(passphrase))
        )
    return 'Created PKCS#12 Certificate for "{0}": "{1}/{2}/certs/{0}.p12"'.format(
        CN,
        cert_base_path(),
        ca_name,
    )
def cert_info(cert, digest="sha256"):
    date_fmt = "%Y%m%d%H%M%SZ"
    if "-----BEGIN" not in cert:
        with salt.utils.files.fopen(cert) as cert_file:
            cert = cert_file.read()
    cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
    issuer = {}
    for key, value in cert.get_issuer().get_components():
        if isinstance(key, bytes):
            key = salt.utils.stringutils.to_unicode(key)
        if isinstance(value, bytes):
            value = salt.utils.stringutils.to_unicode(value)
        issuer[key] = value
    subject = {}
    for key, value in cert.get_subject().get_components():
        if isinstance(key, bytes):
            key = salt.utils.stringutils.to_unicode(key)
        if isinstance(value, bytes):
            value = salt.utils.stringutils.to_unicode(value)
        subject[key] = value
    ret = {
        "fingerprint": salt.utils.stringutils.to_unicode(
            cert.digest(salt.utils.stringutils.to_str(digest))
        ),
        "subject": subject,
        "issuer": issuer,
        "serial_number": cert.get_serial_number(),
        "not_before": calendar.timegm(
            time.strptime(
                str(cert.get_notBefore().decode(__salt_system_encoding__)), date_fmt
            )
        ),
        "not_after": calendar.timegm(
            time.strptime(
                cert.get_notAfter().decode(__salt_system_encoding__), date_fmt
            )
        ),
    }
    if hasattr(cert, "get_extension_count"):
        ret["extensions"] = {}
        for i in range(cert.get_extension_count()):
            try:
                ext = cert.get_extension(i)
                key = salt.utils.stringutils.to_unicode(ext.get_short_name())
                ret["extensions"][key] = str(ext).strip()
            except AttributeError:
                continue
    if "subjectAltName" in ret.get("extensions", {}):
        valid_entries = ("DNS", "IP Address")
        valid_names = set()
        for name in str(ret["extensions"]["subjectAltName"]).split(", "):
            entry, name = name.split(":", 1)
            if entry not in valid_entries:
                log.error(
                    "Cert %s has an entry (%s) which does not start with %s",
                    ret["subject"],
                    name,
                    "/".join(valid_entries),
                )
            else:
                valid_names.add(name)
        ret["subject_alt_names"] = list(valid_names)
    if hasattr(cert, "get_signature_algorithm"):
        try:
            value = cert.get_signature_algorithm()
            if isinstance(value, bytes):
                value = salt.utils.stringutils.to_unicode(value)
            ret["signature_algorithm"] = value
        except AttributeError:
            pass
    return ret
def create_empty_crl(
    ca_name, cacert_path=None, ca_filename=None, crl_file=None, digest="sha256"
):
    set_ca_path(cacert_path)
    if not ca_filename:
        ca_filename = "{}_ca_cert".format(ca_name)
    if not crl_file:
        crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
    if os.path.exists("{}".format(crl_file)):
        return 'CRL "{}" already exists'.format(crl_file)
    try:
        with salt.utils.files.fopen(
            "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
        with salt.utils.files.fopen(
            "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
    except OSError:
        return 'There is no CA named "{}"'.format(ca_name)
    crl = OpenSSL.crypto.CRL()
    crl_text = crl.export(
        ca_cert,
        ca_key,
        digest=salt.utils.stringutils.to_bytes(digest),
    )
    with salt.utils.files.fopen(crl_file, "w") as f:
        f.write(salt.utils.stringutils.to_str(crl_text))
    return 'Created an empty CRL: "{}"'.format(crl_file)
def revoke_cert(
    ca_name,
    CN,
    cacert_path=None,
    ca_filename=None,
    cert_path=None,
    cert_filename=None,
    crl_file=None,
    digest="sha256",
):
    set_ca_path(cacert_path)
    ca_dir = "{}/{}".format(cert_base_path(), ca_name)
    if ca_filename is None:
        ca_filename = "{}_ca_cert".format(ca_name)
    if cert_path is None:
        cert_path = "{}/{}/certs".format(_cert_base_path(), ca_name)
    if cert_filename is None:
        cert_filename = "{}".format(CN)
    try:
        with salt.utils.files.fopen(
            "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_cert = OpenSSL.crypto.load_certificate(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
        with salt.utils.files.fopen(
            "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
        ) as fp_:
            ca_key = OpenSSL.crypto.load_privatekey(
                OpenSSL.crypto.FILETYPE_PEM, fp_.read()
            )
    except OSError:
        return 'There is no CA named "{}"'.format(ca_name)
    client_cert = _read_cert("{}/{}.crt".format(cert_path, cert_filename))
    if client_cert is None:
        return 'There is no client certificate named "{}"'.format(CN)
    index_file, expire_date, serial_number, subject = _get_basic_info(
        ca_name, client_cert, ca_dir
    )
    index_serial_subject = "{}\tunknown\t{}".format(serial_number, subject)
    index_v_data = "V\t{}\t\t{}".format(expire_date, index_serial_subject)
    index_r_data_pattern = re.compile(
        r"R\t" + expire_date + r"\t\d{12}Z\t" + re.escape(index_serial_subject)
    )
    index_r_data = "R\t{}\t{}\t{}".format(
        expire_date,
        _four_digit_year_to_two_digit(datetime.utcnow()),
        index_serial_subject,
    )
    ret = {}
    with salt.utils.files.fopen(index_file) as fp_:
        for line in fp_:
            line = salt.utils.stringutils.to_unicode(line)
            if index_r_data_pattern.match(line):
                revoke_date = line.split("\t")[2]
                try:
                    datetime.strptime(revoke_date, two_digit_year_fmt)
                    return '"{}/{}.crt" was already revoked, serial number: {}'.format(
                        cert_path, cert_filename, serial_number
                    )
                except ValueError:
                    ret["retcode"] = 1
                    ret[
                        "comment"
                    ] = "Revocation date '{}' does not matchformat '{}'".format(
                        revoke_date, two_digit_year_fmt
                    )
                    return ret
            elif index_serial_subject in line:
                __salt__["file.replace"](
                    index_file, index_v_data, index_r_data, backup=False
                )
                break
    crl = OpenSSL.crypto.CRL()
    with salt.utils.files.fopen(index_file) as fp_:
        for line in fp_:
            line = salt.utils.stringutils.to_unicode(line)
            if line.startswith("R"):
                fields = line.split("\t")
                revoked = OpenSSL.crypto.Revoked()
                revoked.set_serial(salt.utils.stringutils.to_bytes(fields[3]))
                revoke_date_2_digit = datetime.strptime(fields[2], two_digit_year_fmt)
                revoked.set_rev_date(
                    salt.utils.stringutils.to_bytes(
                        revoke_date_2_digit.strftime(four_digit_year_fmt)
                    )
                )
                crl.add_revoked(revoked)
    crl_text = crl.export(
        ca_cert, ca_key, digest=salt.utils.stringutils.to_bytes(digest)
    )
    if crl_file is None:
        crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
    if os.path.isdir(crl_file):
        ret["retcode"] = 1
        ret["comment"] = 'crl_file "{}" is an existing directory'.format(crl_file)
        return ret
    with salt.utils.files.fopen(crl_file, "w") as fp_:
        fp_.write(salt.utils.stringutils.to_str(crl_text))
    return 'Revoked Certificate: "{}/{}.crt", serial number: {}'.format(
        cert_path, cert_filename, serial_number
    )
if __name__ == "__main__":
    create_csr(
        "koji",
        CN="test_system",
        C="US",
        ST="Utah",
        L="Centerville",
        O="SaltStack",
        OU=None,
        emailAddress="test_system@saltstack.org",
    )
    create_ca_signed_cert("koji", "test_system")
    create_pkcs12("koji", "test_system", passphrase="test")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_lc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
from salt.exceptions import SaltInvocationError
def __virtual__():
    return (F<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>alse, "boto_asg module could not be loaded")
def present(
    name,
    image_id,
    key_name=None,
    vpc_id=None,
    vpc_name=None,
    security_groups=None,
    user_data=None,
    cloud_init=None,
    instance_type="m1.small",
    kernel_id=None,
    ramdisk_id=None,
    block_device_mappings=None,
    delete_on_termination=None,
    instance_monitoring=False,
    spot_price=None,
    instance_profile_name=None,
    ebs_optimized=False,
    associate_public_ip_address=None,
    region=</b></font>None,
    key=None,
    keyid=None,
    profile=None,
):
    if user_data and cloud_init:
        raise SaltInvocationError(
            "user_data and cloud_init are mutually exclusive options."
        )
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    exists = __salt__["boto_asg.launch_configuration_exists"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not exists:
        if __opts__["test"]:
            msg = "Launch configuration set to be created."
            ret["comment"] = msg
            ret["result"] = None
            return ret
        if cloud_init:
            user_data = __salt__["boto_asg.get_cloud_init_mime"](cloud_init)
<a name="1"></a>        created = __salt__["boto_asg.create_launch_configuration"](
            name,
            image_id,
            key_name<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=key_name,
            vpc_id=vpc_id,
            vpc_name=vpc_name,
            security_groups=security_groups,
            user_data=user_data,
            instance_type=instance_type,
            kernel_id=kernel_id,
            ramdisk_id=ramdisk_id,
            block_device_mappings=block_device_mappings,
            delete_on_termination=delete_on_termination,
            instance_monitoring=instance_monitoring,
            spot_price=spot_price,
            instance_profile_name=instance_profile_name,
            ebs_optimized=ebs_optimized,
            associate_public_ip_address=associate_public_ip_address,
            region=region,
            key=</b></font>key,
            keyid=keyid,
            profile=profile,
        )
        if created:
            ret["changes"]["old"] = None
            ret["changes"]["new"] = name
        else:
            ret["result"] = False
            ret["comment"] = "Failed to create launch configuration."
    else:
        ret["comment"] = "Launch configuration present."
    return ret
def absent(name, region=None, key=None, keyid=None, profile=None):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    exists = __salt__["boto_asg.launch_configuration_exists"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if exists:
        if __opts__["test"]:
            ret["comment"] = "Launch configuration set to be deleted."
            ret["result"] = None
            return ret
        deleted = __salt__["boto_asg.delete_launch_configuration"](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        if deleted:
            ret["changes"]["old"] = name
            ret["changes"]["new"] = None
            ret["comment"] = "Deleted launch configuration."
        else:
            ret["result"] = False
            ret["comment"] = "Failed to delete launch configuration."
    else:
        ret["comment"] = "Launch configuration does not exist."
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
