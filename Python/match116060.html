<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tls_1.py &amp; boto_lc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tls_1.py &amp; boto_lc.py
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tls_1.py (1.5964524%)<th>boto_lc.py (24.827587%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(645-727)<td><a href="#" name="0">(110-132)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(953-969)<td><a href="#" name="1">(267-283)</a><td align="center"><font color="#e40000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tls_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 r"""
2 A salt module for SSL/TLS.  Can create a Certificate Authority (CA)
3 or use Self-Signed certificates.
4 :depends: PyOpenSSL Python module (0.10 or later, 0.14 or later for X509
5     extension support)
6 :configuration: Add the following values in /etc/salt/minion for the CA module
7     to function properly:
8     .. code-block:: yaml
9         ca.cert_base_path: '/etc/pki'
10 CLI Example #1:
11 Creating a CA, a server request and its signed certificate:
12 .. code-block:: bash
13     days=5 \
14     CN='My Little CA' \
15     C=US \
16     ST=Utah \
17     L=Salt Lake City \
18     O=Saltstack \
19     emailAddress=pleasedontemail@example.com
20     Created Private Key: "/etc/pki/my_little/my_little_ca_cert.key"
21     Created CA "my_little_ca": "/etc/pki/my_little_ca/my_little_ca_cert.crt"
22     Created Private Key: "/etc/pki/my_little/certs/www.example.com.key
23     Created CSR for "www.example.com": "/etc/pki/my_little/certs/www.example.com.csr"
24     Created Certificate for "www.example.com": /etc/pki/my_little/certs/www.example.com.crt"
25 CLI Example #2:
26 Creating a client request and its signed certificate
27 .. code-block:: bash
28     Created Private Key: "/etc/pki/my_little/certs//DBReplica_No.1.key."
29     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.csr."
30     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
31 CLI Example #3:
32 Creating both a server and client req + cert for the same CN
33 .. code-block:: bash
34         cert_type=client
35     Created Private Key: "/etc/pki/my_little/certs/MasterDBReplica_No.2.key."
36     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/MasterDBReplica_No.2.csr."
37     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
38         cert_type=server
39     Certificate "MasterDBReplica_No.2" already exists
40     (doh!)
41         cert_type=server type_ext=True
42     Created Private Key: "/etc/pki/my_little/certs/DBReplica_No.1_client.key."
43     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1_client.csr."
44     Certificate "MasterDBReplica_No.2" already exists
45     (DOH!)
46         cert_type=server type_ext=True
47     Created Certificate for "MasterDBReplica_No.2": "/etc/pki/my_little/certs/MasterDBReplica_No.2_server.crt"
48 CLI Example #4:
49 Create a server req + cert with non-CN filename for the cert
50 .. code-block:: bash
51         cert_type=server type_ext=True
52     Created Private Key: "/etc/pki/my_little/certs/www.anothersometh.ing_server.key."
53     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/www.anothersometh.ing_server.csr."
54         cert_type=server cert_filename="something_completely_different"
55     Created Certificate for "www.anothersometh.ing": /etc/pki/my_little/certs/something_completely_different.crt
56     Only load this module if the ca config options are set
57     Return a Unix timestamp as a string of digits
58     :return:
59     Return the base path for certs from CLI or from options
60     cacert_path
61         absolute path to ca certificates root directory
62     CLI Example:
63     .. code-block:: bash
64         salt '*' tls.cert_base_path
65     Retrocompatible wrapper
66     If wanted, store the aforementioned cacert_path in context
67     to be used as the basepath for further operations
68     CLI Example:
69     .. code-block:: bash
70         salt '*' tls.set_ca_path /etc/certs
71     Return a serial number in hex using os.urandom() and a Unix timestamp
72     in microseconds.
73     ca_name
74         name of the CA
75     CN
76         common name in the request
77     Get basic info to write out to the index.txt
78     write out the index.txt database file in the appropriate directory to
79     track certificates
80     ca_name
81         name of the CA
82     cert
83         certificate to be recorded
84     Check that the X509 version is correct
85     (was incorrectly set in previous salt versions).
86     This will fix the version if needed.
87     ca_name
88         ca authority name
89     cacert_path
90         absolute path to ca certificates root directory
91     ca_filename
92         alternative filename for the CA
93         .. versionadded:: 2015.5.3
94     CLI Example:
95     .. code-block:: bash
96         salt '*' tls.maybe_fix_ssl_version test_ca /etc/certs
97     Verify whether a Certificate Authority (CA) already exists
98     ca_name
99         name of the CA
100     cacert_path
101         absolute path to ca certificates root directory
102     ca_filename
103         alternative filename for the CA
104         .. versionadded:: 2015.5.3
105     CLI Example:
106     .. code-block:: bash
107         salt '*' tls.ca_exists test_ca /etc/certs
108     Get the certificate path or content
109     ca_name
110         name of the CA
111     as_text
112         if true, return the certificate content instead of the path
113     cacert_path
114         absolute path to ca certificates root directory
115     CLI Example:
116     .. code-block:: bash
117         salt '*' tls.get_ca test_ca as_text=False cacert_path=/etc/certs
118     Get the certificate path or content
119     ca_name
120         name of the CA
121     CN
122         common name of the certificate
123     as_text
124         if true, return the certificate content instead of the path
125     cacert_path
126         absolute path to certificates root directory
127     cert_filename
128         alternative filename for the certificate, useful when using special characters in the CN
129         .. versionadded:: 2015.5.3
130     CLI Example:
131     .. code-block:: bash
132         salt '*' tls.get_ca_signed_cert test_ca CN=localhost as_text=False cacert_path=/etc/certs
133     Get the certificate path or content
134     ca_name
135         name of the CA
136     CN
137         common name of the certificate
138     as_text
139         if true, return the certificate content instead of the path
140     cacert_path
141         absolute path to certificates root directory
142     key_filename
143         alternative filename for the key, useful when using special characters
144         .. versionadded:: 2015.5.3
145         in the CN
146     CLI Example:
147     .. code-block:: bash
148         salt '*' tls.get_ca_signed_key \
149                 test_ca CN=localhost \
150                 as_text=False \
151                 cacert_path=/etc/certs
152     .. versionadded:: 3000
153     Validate a certificate against a given CA/CRL.
154     cert
155         path to the certifiate PEM file or string
156     ca_name
157         name of the CA
158     crl_file
159         full path to the CRL file
160     Returns a datetime.datetime object
161     .. versionadded:: 2019.2.0
162     Get a certificate's expiration date
163     cert
164         Full path to the certificate
165     date_format
166         By default this will return the expiration date in YYYY-MM-DD format,
167         use this to specify a different strftime format string. Note that the
168         expiration time will be in UTC.
169     CLI Examples:
170     .. code-block:: bash
171         salt '*' tls.get_expiration_date /path/to/foo.crt
172         salt '*' tls.get_expiration_date /path/to/foo.crt date_format='%d/%m/%Y'
173     r<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn ret
174 def create_ca(
175     ca_name,
176     bits=2048,
177     days=365,
178     CN="localhost",
179     C="US",
180     ST="Utah",
181     L="Salt Lake City",
182     O="SaltStack",
183     OU=None,
184     emailAddress=None,
185     fixmode=False,
186     cacert_path=None,
187     ca_filename=None,
188     digest="sha256",
189     onlyif=None,
190     unless=None,
191     replace=False,
192 ):
193     status =</b></font> _check_onlyif_unless(onlyif, unless)
194     if status is not None:
195         return None
196     set_ca_path(cacert_path)
197     if not ca_filename:
198         ca_filename = "{}_ca_cert".format(ca_name)
199     certp = "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
200     ca_keyp = "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
201     if not replace and not fixmode and ca_exists(ca_name, ca_filename=ca_filename):
202         return 'Certificate for CA named "{}" already exists'.format(ca_name)
203     if fixmode and not os.path.exists(certp):
204         raise ValueError("{} does not exists, can't fix".format(certp))
205     if not os.path.exists("{}/{}".format(cert_base_path(), ca_name)):
206         os.makedirs("{}/{}".format(cert_base_path(), ca_name))
207     key = None
208     if os.path.exists(ca_keyp):
209         with salt.utils.files.fopen(ca_keyp) as fic2:
210             try:
211                 key = OpenSSL.crypto.load_privatekey(
212                     OpenSSL.crypto.FILETYPE_PEM, fic2.read()
213                 )
214             except OpenSSL.crypto.Error as err:
215                 log.warning(
216                     "Error loading existing private key %s, generating a new key: %s",
217                     ca_keyp,
218                     err,
219                 )
220                 bck = "{}.unloadable.{}".format(
221                     ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S")
222                 )
223                 log.info("Saving unloadable CA ssl key in %s", bck)
224                 os.rename(ca_keyp, bck)
225     if not key:
226         key = OpenSSL.crypto.PKey()
227         key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
228     ca = OpenSSL.crypto.X509()
229     ca.set_version(2)
230     ca.set_serial_number(_new_serial(ca_name))
231     ca.get_subject().C = C
232     ca.get_subject().ST = ST
233     ca.get_subject().L = L
234     ca.get_subject().O = O
235     if OU:
236         ca.get_subject().OU = OU
237     ca.get_subject().CN = CN
238     if emailAddress:
239         ca.get_subject().emailAddress = emailAddress
240     ca.gmtime_adj_notBefore(0)
241     ca.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
242     ca.set_issuer(ca.get_subject())
243     ca.set_pubkey(key)
244     if X509_EXT_ENABLED:
245         ca.add_extensions(
246             [
247                 OpenSSL.crypto.X509Extension(
248                     b"basicConstraints", True, b"CA:TRUE, pathlen:0"
249                 ),
250                 OpenSSL.crypto.X509Extension(
251                     b"keyUsage", True, b"keyCertSign, cRLSign"
252                 ),
253                 OpenSSL.crypto.X509Extension(
254                     b"subjectKeyIdentifier", False, b"hash", subject=ca
255                 ),
256             ]
257         )
258         ca.add_extensions(
259             [
260                 OpenSSL.crypto.X509Extension(
261                     b"authorityKeyIdentifier",
262                     False,
263                     b"issuer:always,keyid:always",
264                     issuer=ca,
265                 )
266             ]
267         )
268     ca.sign(key, salt.utils.stringutils.to_str(digest))
269     keycontent = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
270     write_key = True
271     if os.path.exists(ca_keyp):
272         bck = "{}.{}".format(ca_keyp, datetime.utcnow().strftime("%Y%m%d%H%M%S"))
273         with salt.utils.files.fopen(ca_keyp) as fic:
274             old_key = salt.utils.stringutils.to_unicode(fic.read()).strip()
275             if old_key.strip() == keycontent.strip():
276                 write_key = False
277             else:
278                 log.info("Saving old CA ssl key in %s", bck)
279                 fp = os.open(bck, os.O_CREAT | os.O_RDWR, 0o600)
280                 with salt.utils.files.fopen(fp, "w") as bckf:
281                     bckf.write(old_key)
282     if write_key:
283         fp = os.open(ca_keyp, os.O_CREAT | os.O_RDWR, 0o600)
284         with salt.utils.files.fopen(fp, "wb") as ca_key:
285             ca_key.write(salt.utils.stringutils.to_bytes(keycontent))
286     with salt.utils.files.fopen(certp, "wb") as ca_crt:
287         ca_crt.write(
288             salt.utils.stringutils.to_bytes(
289                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, ca)
290             )
291         )
292     _write_cert_to_database(ca_name, ca)
293     ret = 'Created Private Key: "{}/{}/{}.key." '.format(
294         cert_base_path(), ca_name, ca_filename
295     )
296     ret += 'Created CA "{0}": "{1}/{0}/{2}.crt."'.format(
297         ca_name, cert_base_path(), ca_filename
298     )
299     return ret
300 def get_extensions(cert_type):
301     assert X509_EXT_ENABLED, (
302         "X509 extensions are not supported in "
303         "pyOpenSSL prior to version 0.15.1. Your "
304         "version: {}".format(OpenSSL_version)
305     )
306     ext = {}
307     if cert_type == "":
308         log.error(
309             "cert_type set to empty in tls_ca.get_extensions(); "
310             "defaulting to ``server``"
311         )
312         cert_type = "server"
313     try:
314         ext["common"] = __salt__["pillar.get"]("tls.extensions:common", False)
315     except NameError as err:
316         log.debug(err)
317     if not ext["common"] or ext["common"] == "":
318         ext["common"] = {
319             "csr": {"basicConstraints": "CA:FALSE"},
320             "cert": {
321                 "authorityKeyIdentifier": "keyid,issuer:always",
322                 "subjectKeyIdentifier": "hash",
323             },
324         }
325     try:
326         ext["server"] = __salt__["pillar.get"]("tls.extensions:server", False)
327     except NameError as err:
328         log.debug(err)
329     if not ext["server"] or ext["server"] == "":
330         ext["server"] = {
331             "csr": {
332                 "extendedKeyUsage": "serverAuth",
333                 "keyUsage": "digitalSignature, keyEncipherment",
334             },
335             "cert": {},
336         }
337     try:
338         ext["client"] = __salt__["pillar.get"]("tls.extensions:client", False)
339     except NameError as err:
340         log.debug(err)
341     if not ext["client"] or ext["client"] == "":
342         ext["client"] = {
343             "csr": {
344                 "extendedKeyUsage": "clientAuth",
345                 "keyUsage": "nonRepudiation, digitalSignature, keyEncipherment",
346             },
347             "cert": {},
348         }
349     if cert_type not in ext:
350         try:
351             ext[cert_type] = __salt__["pillar.get"](
352                 "tls.extensions:{}".format(cert_type)
353             )
354         except NameError as e:
355             log.debug(
356                 "pillar, tls:extensions:%s not available or "
357                 "not operating in a salt context\n%s",
358                 cert_type,
359                 e,
360             )
361     retval = ext["common"]
362     for Use in retval:
363         retval[Use].update(ext[cert_type][Use])
364     return retval
365 <a name="1"></a>
366 def create_csr(
367     ca_name,
368     bits<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=2048,
369     CN="localhost",
370     C="US",
371     ST="Utah",
372     L="Salt Lake City",
373     O="SaltStack",
374     OU=None,
375     emailAddress=None,
376     subjectAltName=None,
377     cacert_path=None,
378     ca_filename=None,
379     csr_path=None,
380     csr_filename=None,
381     digest="sha256",
382     type_ext=False,
383     cert_type="server",
384     replace=</b></font>False,
385 ):
386     set_ca_path(cacert_path)
387     if not ca_filename:
388         ca_filename = "{}_ca_cert".format(ca_name)
389     if not ca_exists(ca_name, ca_filename=ca_filename):
390         return 'Certificate for CA named "{}" does not exist, please create it first.'.format(
391             ca_name
392         )
393     if not csr_path:
394         csr_path = "{}/{}/certs/".format(cert_base_path(), ca_name)
395     if not os.path.exists(csr_path):
396         os.makedirs(csr_path)
397     CN_ext = "_{}".format(cert_type) if type_ext else ""
398     if not csr_filename:
399         csr_filename = "{}{}".format(CN, CN_ext)
400     csr_f = "{}/{}.csr".format(csr_path, csr_filename)
401     if not replace and os.path.exists(csr_f):
402         return 'Certificate Request "{}" already exists'.format(csr_f)
403     key = OpenSSL.crypto.PKey()
404     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
405     req = OpenSSL.crypto.X509Req()
406     req.get_subject().C = C
407     req.get_subject().ST = ST
408     req.get_subject().L = L
409     req.get_subject().O = O
410     if OU:
411         req.get_subject().OU = OU
412     req.get_subject().CN = CN
413     if emailAddress:
414         req.get_subject().emailAddress = emailAddress
415     try:
416         extensions = get_extensions(cert_type)["csr"]
417         extension_adds = []
418         for ext, value in extensions.items():
419             if isinstance(value, str):
420                 value = salt.utils.stringutils.to_bytes(value)
421             extension_adds.append(
422                 OpenSSL.crypto.X509Extension(
423                     salt.utils.stringutils.to_bytes(ext), False, value
424                 )
425             )
426     except AssertionError as err:
427         log.error(err)
428         extensions = []
429     if subjectAltName:
430         if X509_EXT_ENABLED:
431             if isinstance(subjectAltName, str):
432                 subjectAltName = [subjectAltName]
433             extension_adds.append(
434                 OpenSSL.crypto.X509Extension(
435                     b"subjectAltName",
436                     False,
437                     b", ".join(salt.utils.data.encode(subjectAltName)),
438                 )
439             )
440         else:
441             raise ValueError(
442                 "subjectAltName cannot be set as X509 "
443                 "extensions are not supported in pyOpenSSL "
444                 "prior to version 0.15.1. Your "
445                 "version: {}.".format(OpenSSL_version)
446             )
447     if X509_EXT_ENABLED:
448         req.add_extensions(extension_adds)
449     req.set_pubkey(key)
450     req.sign(key, salt.utils.stringutils.to_str(digest))
451     priv_keyp = "{}/{}.key".format(csr_path, csr_filename)
452     fp = os.open(priv_keyp, os.O_CREAT | os.O_RDWR, 0o600)
453     with salt.utils.files.fopen(fp, "wb+") as priv_key:
454         priv_key.write(
455             salt.utils.stringutils.to_bytes(
456                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
457             )
458         )
459     with salt.utils.files.fopen(csr_f, "wb+") as csr:
460         csr.write(
461             salt.utils.stringutils.to_bytes(
462                 OpenSSL.crypto.dump_certificate_request(
463                     OpenSSL.crypto.FILETYPE_PEM, req
464                 )
465             )
466         )
467     ret = 'Created Private Key: "{}{}.key." '.format(csr_path, csr_filename)
468     ret += 'Created CSR for "{}": "{}{}.csr."'.format(CN, csr_path, csr_filename)
469     return ret
470 def create_self_signed_cert(
471     tls_dir="tls",
472     bits=2048,
473     days=365,
474     CN="localhost",
475     C="US",
476     ST="Utah",
477     L="Salt Lake City",
478     O="SaltStack",
479     OU=None,
480     emailAddress=None,
481     cacert_path=None,
482     cert_filename=None,
483     digest="sha256",
484     replace=False,
485 ):
486     set_ca_path(cacert_path)
487     if not os.path.exists("{}/{}/certs/".format(cert_base_path(), tls_dir)):
488         os.makedirs("{}/{}/certs/".format(cert_base_path(), tls_dir))
489     if not cert_filename:
490         cert_filename = CN
491     if not replace and os.path.exists(
492         "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
493     ):
494         return 'Certificate "{}" already exists'.format(cert_filename)
495     key = OpenSSL.crypto.PKey()
496     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
497     cert = OpenSSL.crypto.X509()
498     cert.set_version(2)
499     cert.gmtime_adj_notBefore(0)
500     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
501     cert.get_subject().C = C
502     cert.get_subject().ST = ST
503     cert.get_subject().L = L
504     cert.get_subject().O = O
505     if OU:
506         cert.get_subject().OU = OU
507     cert.get_subject().CN = CN
508     if emailAddress:
509         cert.get_subject().emailAddress = emailAddress
510     cert.set_serial_number(_new_serial(tls_dir))
511     cert.set_issuer(cert.get_subject())
512     cert.set_pubkey(key)
513     cert.sign(key, salt.utils.stringutils.to_str(digest))
514     priv_key_path = "{}/{}/certs/{}.key".format(
515         cert_base_path(), tls_dir, cert_filename
516     )
517     fp = os.open(priv_key_path, os.O_CREAT | os.O_RDWR, 0o600)
518     with salt.utils.files.fopen(fp, "wb+") as priv_key:
519         priv_key.write(
520             salt.utils.stringutils.to_bytes(
521                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
522             )
523         )
524     crt_path = "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
525     with salt.utils.files.fopen(crt_path, "wb+") as crt:
526         crt.write(
527             salt.utils.stringutils.to_bytes(
528                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
529             )
530         )
531     _write_cert_to_database(tls_dir, cert)
532     ret = 'Created Private Key: "{}/{}/certs/{}.key." '.format(
533         cert_base_path(), tls_dir, cert_filename
534     )
535     ret += 'Created Certificate: "{}/{}/certs/{}.crt."'.format(
536         cert_base_path(), tls_dir, cert_filename
537     )
538     return ret
539 def create_ca_signed_cert(
540     ca_name,
541     CN,
542     days=365,
543     cacert_path=None,
544     ca_filename=None,
545     cert_path=None,
546     cert_filename=None,
547     digest="sha256",
548     cert_type=None,
549     type_ext=False,
550     replace=False,
551 ):
552     ret = {}
553     set_ca_path(cacert_path)
554     if not ca_filename:
555         ca_filename = "{}_ca_cert".format(ca_name)
556     if not cert_path:
557         cert_path = "{}/{}/certs".format(cert_base_path(), ca_name)
558     if type_ext:
559         if not cert_type:
560             log.error(
561                 "type_ext = True but cert_type is unset. Certificate not written."
562             )
563             return ret
564         elif cert_type:
565             CN_ext = "_{}".format(cert_type)
566     else:
567         CN_ext = ""
568     csr_filename = "{}{}".format(CN, CN_ext)
569     if not cert_filename:
570         cert_filename = "{}{}".format(CN, CN_ext)
571     if not replace and os.path.exists(
572         os.path.join(
573             os.path.sep.join(
574                 "{}/{}/certs/{}.crt".format(
575                     cert_base_path(), ca_name, cert_filename
576                 ).split("/")
577             )
578         )
579     ):
580         return 'Certificate "{}" already exists'.format(cert_filename)
581     try:
582         maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
583         with salt.utils.files.fopen(
584             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
585         ) as fhr:
586             ca_cert = OpenSSL.crypto.load_certificate(
587                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
588             )
589         with salt.utils.files.fopen(
590             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
591         ) as fhr:
592             ca_key = OpenSSL.crypto.load_privatekey(
593                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
594             )
595     except OSError:
596         ret["retcode"] = 1
597         ret["comment"] = 'There is no CA named "{}"'.format(ca_name)
598         return ret
599     try:
600         csr_path = "{}/{}.csr".format(cert_path, csr_filename)
601         with salt.utils.files.fopen(csr_path) as fhr:
602             req = OpenSSL.crypto.load_certificate_request(
603                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
604             )
605     except OSError:
606         ret["retcode"] = 1
607         ret["comment"] = 'There is no CSR that matches the CN "{}"'.format(
608             cert_filename
609         )
610         return ret
611     exts = []
612     try:
613         exts.extend(req.get_extensions())
614     except AttributeError:
615         try:
616             log.info(
617                 "req.get_extensions() not supported in pyOpenSSL versions "
618                 "prior to 0.15. Processing extensions internally. "
619                 "Your version: %s",
620                 OpenSSL_version,
621             )
622             native_exts_obj = OpenSSL._util.lib.X509_REQ_get_extensions(req._req)
623             for i in range(OpenSSL._util.lib.sk_X509_EXTENSION_num(native_exts_obj)):
624                 ext = OpenSSL.crypto.X509Extension.__new__(OpenSSL.crypto.X509Extension)
625                 ext._extension = OpenSSL._util.lib.sk_X509_EXTENSION_value(
626                     native_exts_obj, i
627                 )
628                 exts.append(ext)
629         except Exception:  # pylint: disable=broad-except
630             log.error(
631                 "X509 extensions are unsupported in pyOpenSSL "
632                 "versions prior to 0.14. Upgrade required to "
633                 "use extensions. Current version: %s",
634                 OpenSSL_version,
635             )
636     cert = OpenSSL.crypto.X509()
637     cert.set_version(2)
638     cert.set_subject(req.get_subject())
639     cert.gmtime_adj_notBefore(0)
640     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
641     cert.set_serial_number(_new_serial(ca_name))
642     cert.set_issuer(ca_cert.get_subject())
643     cert.set_pubkey(req.get_pubkey())
644     cert.add_extensions(exts)
645     cert.sign(ca_key, salt.utils.stringutils.to_str(digest))
646     cert_full_path = "{}/{}.crt".format(cert_path, cert_filename)
647     with salt.utils.files.fopen(cert_full_path, "wb+") as crt:
648         crt.write(
649             salt.utils.stringutils.to_bytes(
650                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
651             )
652         )
653     _write_cert_to_database(ca_name, cert)
654     return 'Created Certificate for "{}": "{}/{}.crt"'.format(
655         CN, cert_path, cert_filename
656     )
657 def create_pkcs12(ca_name, CN, passphrase="", cacert_path=None, replace=False):
658     set_ca_path(cacert_path)
659     if not replace and os.path.exists(
660         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN)
661     ):
662         return 'Certificate "{}" already exists'.format(CN)
663     try:
664         with salt.utils.files.fopen(
665             "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
666         ) as fhr:
667             ca_cert = OpenSSL.crypto.load_certificate(
668                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
669             )
670     except OSError:
671         return 'There is no CA named "{}"'.format(ca_name)
672     try:
673         with salt.utils.files.fopen(
674             "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, CN)
675         ) as fhr:
676             cert = OpenSSL.crypto.load_certificate(
677                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
678             )
679         with salt.utils.files.fopen(
680             "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, CN)
681         ) as fhr:
682             key = OpenSSL.crypto.load_privatekey(
683                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
684             )
685     except OSError:
686         return 'There is no certificate that matches the CN "{}"'.format(CN)
687     pkcs12 = OpenSSL.crypto.PKCS12()
688     pkcs12.set_certificate(cert)
689     pkcs12.set_ca_certificates([ca_cert])
690     pkcs12.set_privatekey(key)
691     with salt.utils.files.fopen(
692         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN), "wb"
693     ) as ofile:
694         ofile.write(
695             pkcs12.export(passphrase=salt.utils.stringutils.to_bytes(passphrase))
696         )
697     return 'Created PKCS#12 Certificate for "{0}": "{1}/{2}/certs/{0}.p12"'.format(
698         CN,
699         cert_base_path(),
700         ca_name,
701     )
702 def cert_info(cert, digest="sha256"):
703     date_fmt = "%Y%m%d%H%M%SZ"
704     if "-----BEGIN" not in cert:
705         with salt.utils.files.fopen(cert) as cert_file:
706             cert = cert_file.read()
707     cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
708     issuer = {}
709     for key, value in cert.get_issuer().get_components():
710         if isinstance(key, bytes):
711             key = salt.utils.stringutils.to_unicode(key)
712         if isinstance(value, bytes):
713             value = salt.utils.stringutils.to_unicode(value)
714         issuer[key] = value
715     subject = {}
716     for key, value in cert.get_subject().get_components():
717         if isinstance(key, bytes):
718             key = salt.utils.stringutils.to_unicode(key)
719         if isinstance(value, bytes):
720             value = salt.utils.stringutils.to_unicode(value)
721         subject[key] = value
722     ret = {
723         "fingerprint": salt.utils.stringutils.to_unicode(
724             cert.digest(salt.utils.stringutils.to_str(digest))
725         ),
726         "subject": subject,
727         "issuer": issuer,
728         "serial_number": cert.get_serial_number(),
729         "not_before": calendar.timegm(
730             time.strptime(
731                 str(cert.get_notBefore().decode(__salt_system_encoding__)), date_fmt
732             )
733         ),
734         "not_after": calendar.timegm(
735             time.strptime(
736                 cert.get_notAfter().decode(__salt_system_encoding__), date_fmt
737             )
738         ),
739     }
740     if hasattr(cert, "get_extension_count"):
741         ret["extensions"] = {}
742         for i in range(cert.get_extension_count()):
743             try:
744                 ext = cert.get_extension(i)
745                 key = salt.utils.stringutils.to_unicode(ext.get_short_name())
746                 ret["extensions"][key] = str(ext).strip()
747             except AttributeError:
748                 continue
749     if "subjectAltName" in ret.get("extensions", {}):
750         valid_entries = ("DNS", "IP Address")
751         valid_names = set()
752         for name in str(ret["extensions"]["subjectAltName"]).split(", "):
753             entry, name = name.split(":", 1)
754             if entry not in valid_entries:
755                 log.error(
756                     "Cert %s has an entry (%s) which does not start with %s",
757                     ret["subject"],
758                     name,
759                     "/".join(valid_entries),
760                 )
761             else:
762                 valid_names.add(name)
763         ret["subject_alt_names"] = list(valid_names)
764     if hasattr(cert, "get_signature_algorithm"):
765         try:
766             value = cert.get_signature_algorithm()
767             if isinstance(value, bytes):
768                 value = salt.utils.stringutils.to_unicode(value)
769             ret["signature_algorithm"] = value
770         except AttributeError:
771             pass
772     return ret
773 def create_empty_crl(
774     ca_name, cacert_path=None, ca_filename=None, crl_file=None, digest="sha256"
775 ):
776     set_ca_path(cacert_path)
777     if not ca_filename:
778         ca_filename = "{}_ca_cert".format(ca_name)
779     if not crl_file:
780         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
781     if os.path.exists("{}".format(crl_file)):
782         return 'CRL "{}" already exists'.format(crl_file)
783     try:
784         with salt.utils.files.fopen(
785             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
786         ) as fp_:
787             ca_cert = OpenSSL.crypto.load_certificate(
788                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
789             )
790         with salt.utils.files.fopen(
791             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
792         ) as fp_:
793             ca_key = OpenSSL.crypto.load_privatekey(
794                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
795             )
796     except OSError:
797         return 'There is no CA named "{}"'.format(ca_name)
798     crl = OpenSSL.crypto.CRL()
799     crl_text = crl.export(
800         ca_cert,
801         ca_key,
802         digest=salt.utils.stringutils.to_bytes(digest),
803     )
804     with salt.utils.files.fopen(crl_file, "w") as f:
805         f.write(salt.utils.stringutils.to_str(crl_text))
806     return 'Created an empty CRL: "{}"'.format(crl_file)
807 def revoke_cert(
808     ca_name,
809     CN,
810     cacert_path=None,
811     ca_filename=None,
812     cert_path=None,
813     cert_filename=None,
814     crl_file=None,
815     digest="sha256",
816 ):
817     set_ca_path(cacert_path)
818     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
819     if ca_filename is None:
820         ca_filename = "{}_ca_cert".format(ca_name)
821     if cert_path is None:
822         cert_path = "{}/{}/certs".format(_cert_base_path(), ca_name)
823     if cert_filename is None:
824         cert_filename = "{}".format(CN)
825     try:
826         with salt.utils.files.fopen(
827             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
828         ) as fp_:
829             ca_cert = OpenSSL.crypto.load_certificate(
830                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
831             )
832         with salt.utils.files.fopen(
833             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
834         ) as fp_:
835             ca_key = OpenSSL.crypto.load_privatekey(
836                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
837             )
838     except OSError:
839         return 'There is no CA named "{}"'.format(ca_name)
840     client_cert = _read_cert("{}/{}.crt".format(cert_path, cert_filename))
841     if client_cert is None:
842         return 'There is no client certificate named "{}"'.format(CN)
843     index_file, expire_date, serial_number, subject = _get_basic_info(
844         ca_name, client_cert, ca_dir
845     )
846     index_serial_subject = "{}\tunknown\t{}".format(serial_number, subject)
847     index_v_data = "V\t{}\t\t{}".format(expire_date, index_serial_subject)
848     index_r_data_pattern = re.compile(
849         r"R\t" + expire_date + r"\t\d{12}Z\t" + re.escape(index_serial_subject)
850     )
851     index_r_data = "R\t{}\t{}\t{}".format(
852         expire_date,
853         _four_digit_year_to_two_digit(datetime.utcnow()),
854         index_serial_subject,
855     )
856     ret = {}
857     with salt.utils.files.fopen(index_file) as fp_:
858         for line in fp_:
859             line = salt.utils.stringutils.to_unicode(line)
860             if index_r_data_pattern.match(line):
861                 revoke_date = line.split("\t")[2]
862                 try:
863                     datetime.strptime(revoke_date, two_digit_year_fmt)
864                     return '"{}/{}.crt" was already revoked, serial number: {}'.format(
865                         cert_path, cert_filename, serial_number
866                     )
867                 except ValueError:
868                     ret["retcode"] = 1
869                     ret[
870                         "comment"
871                     ] = "Revocation date '{}' does not matchformat '{}'".format(
872                         revoke_date, two_digit_year_fmt
873                     )
874                     return ret
875             elif index_serial_subject in line:
876                 __salt__["file.replace"](
877                     index_file, index_v_data, index_r_data, backup=False
878                 )
879                 break
880     crl = OpenSSL.crypto.CRL()
881     with salt.utils.files.fopen(index_file) as fp_:
882         for line in fp_:
883             line = salt.utils.stringutils.to_unicode(line)
884             if line.startswith("R"):
885                 fields = line.split("\t")
886                 revoked = OpenSSL.crypto.Revoked()
887                 revoked.set_serial(salt.utils.stringutils.to_bytes(fields[3]))
888                 revoke_date_2_digit = datetime.strptime(fields[2], two_digit_year_fmt)
889                 revoked.set_rev_date(
890                     salt.utils.stringutils.to_bytes(
891                         revoke_date_2_digit.strftime(four_digit_year_fmt)
892                     )
893                 )
894                 crl.add_revoked(revoked)
895     crl_text = crl.export(
896         ca_cert, ca_key, digest=salt.utils.stringutils.to_bytes(digest)
897     )
898     if crl_file is None:
899         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
900     if os.path.isdir(crl_file):
901         ret["retcode"] = 1
902         ret["comment"] = 'crl_file "{}" is an existing directory'.format(crl_file)
903         return ret
904     with salt.utils.files.fopen(crl_file, "w") as fp_:
905         fp_.write(salt.utils.stringutils.to_str(crl_text))
906     return 'Revoked Certificate: "{}/{}.crt", serial number: {}'.format(
907         cert_path, cert_filename, serial_number
908     )
909 if __name__ == "__main__":
910     create_csr(
911         "koji",
912         CN="test_system",
913         C="US",
914         ST="Utah",
915         L="Centerville",
916         O="SaltStack",
917         OU=None,
918         emailAddress="test_system@saltstack.org",
919     )
920     create_ca_signed_cert("koji", "test_system")
921     create_pkcs12("koji", "test_system", passphrase="test")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_lc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from salt.exceptions import SaltInvocationError
2 def __virtual__():
3     return (F<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>alse, "boto_asg module could not be loaded")
4 def present(
5     name,
6     image_id,
7     key_name=None,
8     vpc_id=None,
9     vpc_name=None,
10     security_groups=None,
11     user_data=None,
12     cloud_init=None,
13     instance_type="m1.small",
14     kernel_id=None,
15     ramdisk_id=None,
16     block_device_mappings=None,
17     delete_on_termination=None,
18     instance_monitoring=False,
19     spot_price=None,
20     instance_profile_name=None,
21     ebs_optimized=False,
22     associate_public_ip_address=None,
23     region=</b></font>None,
24     key=None,
25     keyid=None,
26     profile=None,
27 ):
28     if user_data and cloud_init:
29         raise SaltInvocationError(
30             "user_data and cloud_init are mutually exclusive options."
31         )
32     ret = {"name": name, "result": True, "comment": "", "changes": {}}
33     exists = __salt__["boto_asg.launch_configuration_exists"](
34         name, region=region, key=key, keyid=keyid, profile=profile
35     )
36     if not exists:
37         if __opts__["test"]:
38             msg = "Launch configuration set to be created."
39             ret["comment"] = msg
40             ret["result"] = None
41             return ret
42         if cloud_init:
43             user_data = __salt__["boto_asg.get_cloud_init_mime"](cloud_init)
44 <a name="1"></a>        created = __salt__["boto_asg.create_launch_configuration"](
45             name,
46             image_id,
47             key_name<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=key_name,
48             vpc_id=vpc_id,
49             vpc_name=vpc_name,
50             security_groups=security_groups,
51             user_data=user_data,
52             instance_type=instance_type,
53             kernel_id=kernel_id,
54             ramdisk_id=ramdisk_id,
55             block_device_mappings=block_device_mappings,
56             delete_on_termination=delete_on_termination,
57             instance_monitoring=instance_monitoring,
58             spot_price=spot_price,
59             instance_profile_name=instance_profile_name,
60             ebs_optimized=ebs_optimized,
61             associate_public_ip_address=associate_public_ip_address,
62             region=region,
63             key=</b></font>key,
64             keyid=keyid,
65             profile=profile,
66         )
67         if created:
68             ret["changes"]["old"] = None
69             ret["changes"]["new"] = name
70         else:
71             ret["result"] = False
72             ret["comment"] = "Failed to create launch configuration."
73     else:
74         ret["comment"] = "Launch configuration present."
75     return ret
76 def absent(name, region=None, key=None, keyid=None, profile=None):
77     ret = {"name": name, "result": True, "comment": "", "changes": {}}
78     exists = __salt__["boto_asg.launch_configuration_exists"](
79         name, region=region, key=key, keyid=keyid, profile=profile
80     )
81     if exists:
82         if __opts__["test"]:
83             ret["comment"] = "Launch configuration set to be deleted."
84             ret["result"] = None
85             return ret
86         deleted = __salt__["boto_asg.delete_launch_configuration"](
87             name, region=region, key=key, keyid=keyid, profile=profile
88         )
89         if deleted:
90             ret["changes"]["old"] = name
91             ret["changes"]["new"] = None
92             ret["comment"] = "Deleted launch configuration."
93         else:
94             ret["result"] = False
95             ret["comment"] = "Failed to delete launch configuration."
96     else:
97         ret["comment"] = "Launch configuration does not exist."
98     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
