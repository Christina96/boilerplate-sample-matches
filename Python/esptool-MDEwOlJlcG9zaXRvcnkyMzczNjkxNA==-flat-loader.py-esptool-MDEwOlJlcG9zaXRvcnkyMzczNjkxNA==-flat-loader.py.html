
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</h3>
            <pre><code>1  import base64
2  import hashlib
3  import itertools
4  import json
5  import os
6  import re
7  import string
8  import struct
9  import sys
10  import time
11  from .config import load_config_file
12  from .reset import (
13      ClassicReset,
14      CustomReset,
15      DEFAULT_RESET_DELAY,
16      HardReset,
17      USBJTAGSerialReset,
18      UnixTightReset,
19  )
20  from .util import FatalError, NotImplementedInROMError, UnsupportedCommandError
21  from .util import byte, hexify, mask_to_shift, pad_to, strip_chip_name
22  try:
23      import serial
24  except ImportError:
25      print(
26          "Pyserial is not installed for %s. "
27          "Check the README for installation instructions." % (sys.executable)
28      )
29      raise
30  try:
31      if "serialization" in serial.__doc__ and "deserialization" in serial.__doc__:
32          raise ImportError(
33              "esptool.py depends on pyserial, but there is a conflict with a currently "
34              "installed package named 'serial'.\n"
35              "You may work around this by 'pip uninstall serial; pip install pyserial' "
36              "but this may break other installed Python software "
37              "that depends on 'serial'.\n"
38              "There is no good fix for this right now, "
39              "apart from configuring virtualenvs. "
40              "See https://github.com/espressif/esptool/issues/269#issuecomment-385298196"
41              " for discussion of the underlying issue(s)."
42          )
43  except TypeError:
44      pass  # __doc__ returns None for pyserial
45  try:
46      import serial.tools.list_ports as list_ports
47  except ImportError:
48      print(
49          "The installed version (%s) of pyserial appears to be too old for esptool.py "
50          "(Python interpreter %s). Check the README for installation instructions."
51          % (sys.VERSION, sys.executable)
52      )
53      raise
54  except Exception:
55      if sys.platform == "darwin":
56          list_ports = None
57      else:
58          raise
59  cfg, _ = load_config_file()
60  cfg = cfg["esptool"]
61  DEFAULT_TIMEOUT = cfg.getfloat("timeout", 3)
62  CHIP_ERASE_TIMEOUT = cfg.getfloat("chip_erase_timeout", 120)
63  MAX_TIMEOUT = cfg.getfloat("max_timeout", CHIP_ERASE_TIMEOUT * 2)
64  SYNC_TIMEOUT = cfg.getfloat("sync_timeout", 0.1)
65  MD5_TIMEOUT_PER_MB = cfg.getfloat("md5_timeout_per_mb", 8)
66  ERASE_REGION_TIMEOUT_PER_MB = cfg.getfloat("erase_region_timeout_per_mb", 30)
67  ERASE_WRITE_TIMEOUT_PER_MB = cfg.getfloat("erase_write_timeout_per_mb", 40)
68  MEM_END_ROM_TIMEOUT = cfg.getfloat("mem_end_rom_timeout", 0.2)
69  DEFAULT_SERIAL_WRITE_TIMEOUT = cfg.getfloat("serial_write_timeout", 10)
70  DEFAULT_CONNECT_ATTEMPTS = cfg.getint("connect_attempts", 7)
71  WRITE_BLOCK_ATTEMPTS = cfg.getint("write_block_attempts", 3)
72  STUBS_DIR = os.path.join(os.path.dirname(__file__), "targets", "stub_flasher")
73  def get_stub_json_path(chip_name):
74      chip_name = strip_chip_name(chip_name)
75      chip_name = chip_name.replace("esp", "")
76      return os.path.join(STUBS_DIR, f"stub_flasher_{chip_name}.json")
77  def timeout_per_mb(seconds_per_mb, size_bytes):
78      result = seconds_per_mb * (size_bytes / 1e6)
79      if result < DEFAULT_TIMEOUT:
80          return DEFAULT_TIMEOUT
81      return result
82  def check_supported_function(func, check_func):
83      def inner(*args, **kwargs):
84          obj = args[0]
85          if check_func(obj):
86              return func(*args, **kwargs)
87          else:
88              raise NotImplementedInROMError(obj, func)
89      return inner
90  def stub_function_only(func):
91      return check_supported_function(func, lambda o: o.IS_STUB)
92  def stub_and_esp32_function_only(func):
93      return check_supported_function(
94          func, lambda o: o.IS_STUB or o.CHIP_NAME not in ["ESP8266"]
95      )
96  def esp32s3_or_newer_function_only(func):
97      return check_supported_function(
98          func, lambda o: o.CHIP_NAME not in ["ESP8266", "ESP32", "ESP32-S2"]
99      )
100  class StubFlasher:
101      def __init__(self, json_path):
102          with open(json_path) as json_file:
103              stub = json.load(json_file)
104          self.text = base64.b64decode(stub["text"])
105          self.text_start = stub["text_start"]
106          self.entry = stub["entry"]
107          try:
108              self.data = base64.b64decode(stub["data"])
109              self.data_start = stub["data_start"]
110          except KeyError:
111              self.data = None
112              self.data_start = None
113  class ESPLoader(object):
114      CHIP_NAME = "Espressif device"
115      IS_STUB = False
116      FPGA_SLOW_BOOT = False
117      DEFAULT_PORT = "/dev/ttyUSB0"
118      USES_RFC2217 = False
119      ESP_FLASH_BEGIN = 0x02
120      ESP_FLASH_DATA = 0x03
121      ESP_FLASH_END = 0x04
122      ESP_MEM_BEGIN = 0x05
123      ESP_MEM_END = 0x06
124      ESP_MEM_DATA = 0x07
125      ESP_SYNC = 0x08
126      ESP_WRITE_REG = 0x09
127      ESP_READ_REG = 0x0A
128      ESP_SPI_SET_PARAMS = 0x0B
129      ESP_SPI_ATTACH = 0x0D
130      ESP_READ_FLASH_SLOW = 0x0E  # ROM only, much slower than the stub flash read
131      ESP_CHANGE_BAUDRATE = 0x0F
132      ESP_FLASH_DEFL_BEGIN = 0x10
133      ESP_FLASH_DEFL_DATA = 0x11
134      ESP_FLASH_DEFL_END = 0x12
135      ESP_SPI_FLASH_MD5 = 0x13
136      ESP_GET_SECURITY_INFO = 0x14
137      ESP_ERASE_FLASH = 0xD0
138      ESP_ERASE_REGION = 0xD1
139      ESP_READ_FLASH = 0xD2
140      ESP_RUN_USER_CODE = 0xD3
141      ESP_FLASH_ENCRYPT_DATA = 0xD4
142      ROM_INVALID_RECV_MSG = 0x05  # response if an invalid message is received
143      ESP_RAM_BLOCK = 0x1800
144      FLASH_WRITE_SIZE = 0x400
145      ESP_ROM_BAUD = 115200
146      ESP_IMAGE_MAGIC = 0xE9
147      ESP_CHECKSUM_MAGIC = 0xEF
148      FLASH_SECTOR_SIZE = 0x1000
149      UART_DATE_REG_ADDR = 0x60000078
150      CHIP_DETECT_MAGIC_REG_ADDR = 0x40001000
151      UART_CLKDIV_MASK = 0xFFFFF
152      IROM_MAP_START = 0x40200000
153      IROM_MAP_END = 0x40300000
154      STATUS_BYTES_LENGTH = 2
155      BOOTLOADER_FLASH_OFFSET = 0x0
156      SUPPORTS_ENCRYPTED_FLASH = False
157      sync_stub_detected = False
158      USB_JTAG_SERIAL_PID = 0x1001
159      UNSUPPORTED_CHIPS = {6: "ESP32-S3(beta 3)"}
160      def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):
161          self.secure_download_mode = False
162          self.stub_is_disabled = False
163          self.cache = {
164              "flash_id": None,
165              "chip_id": None,
166              "uart_no": None,
167              "usb_pid": None,
168          }
169          if isinstance(port, str):
170              try:
171                  self._port = serial.serial_for_url(port)
172              except serial.serialutil.SerialException:
173                  raise FatalError(f"Could not open {port}, the port doesn't exist")
174          else:
175              self._port = port
176          self._slip_reader = slip_reader(self._port, self.trace)
177          self._set_port_baudrate(baud)
178          self._trace_enabled = trace_enabled
179          try:
180              self._port.write_timeout = DEFAULT_SERIAL_WRITE_TIMEOUT
181          except NotImplementedError:
182              self._port.write_timeout = None
183      @property
184      def serial_port(self):
185          return self._port.port
186      def _set_port_baudrate(self, baud):
187          try:
188              self._port.baudrate = baud
189          except IOError:
190              raise FatalError(
191                  "Failed to set baud rate %d. The driver may not support this rate."
192                  % baud
193              )
194      def read(self):
195          return next(self._slip_reader)
196      def write(self, packet):
197          buf = (
198              b"\xc0"
199              + (packet.replace(b"\xdb", b"\xdb\xdd").replace(b"\xc0", b"\xdb\xdc"))
200              + b"\xc0"
201          )
202          self.trace("Write %d bytes: %s", len(buf), HexFormatter(buf))
203          self._port.write(buf)
204      def trace(self, message, *format_args):
205          if self._trace_enabled:
206              now = time.time()
207              try:
208                  delta = now - self._last_trace
209              except AttributeError:
210                  delta = 0.0
211              self._last_trace = now
212              prefix = "TRACE +%.3f " % delta
213              print(prefix + (message % format_args))
214      @staticmethod
215      def checksum(data, state=ESP_CHECKSUM_MAGIC):
216          for b in data:
217              state ^= b
218          return state
219      def command(
220          self,
221          op=None,
222          data=b"",
223          chk=0,
224          wait_response=True,
225          timeout=DEFAULT_TIMEOUT,
226      ):
227          saved_timeout = self._port.timeout
228          new_timeout = min(timeout, MAX_TIMEOUT)
229          if new_timeout != saved_timeout:
230              self._port.timeout = new_timeout
231          try:
232              if op is not None:
233                  self.trace(
234                      "command op=0x%02x data len=%s wait_response=%d "
235                      "timeout=%.3f data=%s",
236                      op,
237                      len(data),
238                      1 if wait_response else 0,
239                      timeout,
240                      HexFormatter(data),
241                  )
242                  pkt = struct.pack(b"<BBHI", 0x00, op, len(data), chk) + data
243                  self.write(pkt)
244              if not wait_response:
245                  return
246              for retry in range(100):
247                  p = self.read()
248                  if len(p) < 8:
249                      continue
250                  (resp, op_ret, len_ret, val) = struct.unpack("<BBHI", p[:8])
251                  if resp != 1:
252                      continue
253                  data = p[8:]
254                  if op is None or op_ret == op:
255                      return val, data
256                  if byte(data, 0) != 0 and byte(data, 1) == self.ROM_INVALID_RECV_MSG:
257                      self.flush_input()
258                      raise UnsupportedCommandError(self, op)
259          finally:
260              if new_timeout != saved_timeout:
261                  self._port.timeout = saved_timeout
262          raise FatalError("Response doesn't match request")
263      def check_command(
264          self, op_description, op=None, data=b"", chk=0, timeout=DEFAULT_TIMEOUT
265      ):
266          val, data = self.command(op, data, chk, timeout=timeout)
267          if len(data) < self.STATUS_BYTES_LENGTH:
268              raise FatalError(
269                  "Failed to %s. Only got %d byte status response."
270                  % (op_description, len(data))
271              )
272          status_bytes = data[-self.STATUS_BYTES_LENGTH :]
273          if byte(status_bytes, 0) != 0:
274              raise FatalError.WithResult("Failed to %s" % op_description, status_bytes)
275          if len(data) > self.STATUS_BYTES_LENGTH:
276              return data[: -self.STATUS_BYTES_LENGTH]
277          else:
278              return val
279      def flush_input(self):
280          self._port.flushInput()
281          self._slip_reader = slip_reader(self._port, self.trace)
282      def sync(self):
283          val, _ = self.command(
284              self.ESP_SYNC, b"\x07\x07\x12\x20" + 32 * b"\x55", timeout=SYNC_TIMEOUT
285          )
286          self.sync_stub_detected = val == 0
287          for _ in range(7):
288              val, _ = self.command()
289              self.sync_stub_detected &= val == 0
290      def _get_pid(self):
291          if self.cache["usb_pid"] is not None:
292              return self.cache["usb_pid"]
293          if list_ports is None:
294              print(
295                  "\nListing all serial ports is currently not available. "
296                  "Can't get device PID."
297              )
298              return
299          active_port = self._port.port
300          if not active_port.lower().startswith(("com", "/dev/")):
301              print(
302                  "\nDevice PID identification is only supported on "
303                  "COM and /dev/ serial ports."
304              )
305              return
306          if active_port.startswith("/dev/") and os.path.islink(active_port):
307              active_port = os.path.realpath(active_port)
308          active_ports = [active_port]
309          if sys.platform == "darwin" and "tty" in active_port:
310              active_ports.append(active_port.replace("tty", "cu"))
311          ports = list_ports.comports()
312          for p in ports:
313              if p.device in active_ports:
314                  self.cache["usb_pid"] = p.pid
315                  return p.pid
316          print(
317              f"\nFailed to get PID of a device on {active_port}, "
318              "using standard reset sequence."
319          )
320      def _connect_attempt(self, reset_strategy, mode="default_reset"):
321          last_error = None
322          boot_log_detected = False
323          download_mode = False
324          if mode == "no_reset_no_sync":
325              return last_error
326          if mode != "no_reset":
327              if not self.USES_RFC2217:  # Might block on rfc2217 ports
328                  self._port.reset_input_buffer()
329              reset_strategy()  # Reset the chip to bootloader (download mode)
330              waiting = self._port.inWaiting()
331              read_bytes = self._port.read(waiting)
332              data = re.search(
333                  b"boot:(0x[0-9a-fA-F]+)(.*waiting for download)?", read_bytes, re.DOTALL
334              )
335              if data is not None:
336                  boot_log_detected = True
337                  boot_mode = data.group(1)
338                  download_mode = data.group(2) is not None
339          for _ in range(5):
340              try:
341                  self.flush_input()
342                  self._port.flushOutput()
343                  self.sync()
344                  return None
345              except FatalError as e:
346                  print(".", end="")
347                  sys.stdout.flush()
348                  time.sleep(0.05)
349                  last_error = e
350          if boot_log_detected:
351              last_error = FatalError(
352                  "Wrong boot mode detected ({})! "
353                  "The chip needs to be in download mode.".format(
354                      boot_mode.decode("utf-8")
355                  )
356              )
357              if download_mode:
358                  last_error = FatalError(
359                      "Download mode successfully detected, but getting no sync reply: "
360                      "The serial TX path seems to be down."
361                  )
362          return last_error
363      def get_memory_region(self, name):
364          try:
365              return [(start, end) for (start, end, n) in self.MEMORY_MAP if n == name][0]
366          except IndexError:
367              return None
368      def _construct_reset_strategy_sequence(self, mode):
369          cfg_custom_reset_sequence = cfg.get("custom_reset_sequence")
370          if cfg_custom_reset_sequence is not None:
371              return (CustomReset(self._port, cfg_custom_reset_sequence),)
372          cfg_reset_delay = cfg.getfloat("reset_delay")
373          if cfg_reset_delay is not None:
374              delay = extra_delay = cfg_reset_delay
375          else:
376              delay = DEFAULT_RESET_DELAY
377              extra_delay = DEFAULT_RESET_DELAY + 0.5
378          if (
379              self.FPGA_SLOW_BOOT
380              and os.environ.get("ESPTOOL_ENV_FPGA", "").strip() == "1"
381          ):
382              delay = extra_delay = 7
383          if mode == "usb_reset" or self._get_pid() == self.USB_JTAG_SERIAL_PID:
384              return (USBJTAGSerialReset(self._port),)
385          if os.name != "nt" and not self._port.name.startswith("rfc2217:"):
386              return (
387                  UnixTightReset(self._port, delay),
388                  UnixTightReset(self._port, extra_delay),
389                  ClassicReset(self._port, delay),
390                  ClassicReset(self._port, extra_delay),
391              )
392          return (
393              ClassicReset(self._port, delay),
394              ClassicReset(self._port, extra_delay),
395          )
396      def connect(
397          self,
398          mode="default_reset",
399          attempts=DEFAULT_CONNECT_ATTEMPTS,
400          detecting=False,
401          warnings=True,
402      ):
403          if warnings and mode in ["no_reset", "no_reset_no_sync"]:
404              print(
405                  'WARNING: Pre-connection option "{}" was selected.'.format(mode),
406                  "Connection may fail if the chip is not in bootloader "
407                  "or flasher stub mode.",
408              )
409          print("Connecting...", end="")
410          sys.stdout.flush()
411          last_error = None
412          reset_sequence = self._construct_reset_strategy_sequence(mode)
413          try:
414              for _, reset_strategy in zip(
415                  range(attempts) if attempts > 0 else itertools.count(),
416                  itertools.cycle(reset_sequence),
417              ):
418                  last_error = self._connect_attempt(reset_strategy, mode)
419                  if last_error is None:
420                      break
421          finally:
422              print("")  # end 'Connecting...' line
423          if last_error is not None:
424              raise FatalError(
425                  "Failed to connect to {}: {}"
426                  "\nFor troubleshooting steps visit: "
427                  "https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html".format(  # noqa E501
428                      self.CHIP_NAME, last_error
429                  )
430              )
431          if not detecting:
432              try:
433                  from .targets import ROM_LIST
434                  chip_magic_value = self.read_reg(ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR)
435                  if chip_magic_value not in self.CHIP_DETECT_MAGIC_VALUE:
436                      actually = None
437                      for cls in ROM_LIST:
438                          if chip_magic_value in cls.CHIP_DETECT_MAGIC_VALUE:
439                              actually = cls
440                              break
441                      if warnings and actually is None:
442                          print(
443                              "WARNING: This chip doesn't appear to be a %s "
444                              "(chip magic value 0x%08x). "
445                              "Probably it is unsupported by this version of esptool."
446                              % (self.CHIP_NAME, chip_magic_value)
447                          )
448                      else:
449                          raise FatalError(
450                              "This chip is %s not %s. Wrong --chip argument?"
451                              % (actually.CHIP_NAME, self.CHIP_NAME)
452                          )
453              except UnsupportedCommandError:
454                  self.secure_download_mode = True
455              try:
456                  self.check_chip_id()
457              except UnsupportedCommandError:
458                  if self.secure_download_mode:
459                      self._connect_attempt(mode, reset_sequence[0])
460                      self.check_chip_id()
461                  else:
462                      raise
463              self._post_connect()
464      def _post_connect(self):
465          pass
466      def read_reg(self, addr, timeout=DEFAULT_TIMEOUT):
467          val, data = self.command(
468              self.ESP_READ_REG, struct.pack("<I", addr), timeout=timeout
469          )
470          if byte(data, 0) != 0:
471              raise FatalError.WithResult(
472                  "Failed to read register address %08x" % addr, data
473              )
474          return val
475      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
476          command = struct.pack("<IIII", addr, value, mask, delay_us)
477          if delay_after_us > 0:
478              command += struct.pack(
479                  "<IIII", self.UART_DATE_REG_ADDR, 0, 0, delay_after_us
480              )
481          return self.check_command("write target memory", self.ESP_WRITE_REG, command)
482      def update_reg(self, addr, mask, new_val):
483          shift = mask_to_shift(mask)
484          val = self.read_reg(addr)
485          val &= ~mask
486          val |= (new_val << shift) & mask
487          self.write_reg(addr, val)
488          return val
489      def mem_begin(self, size, blocks, blocksize, offset):
490          if self.IS_STUB:
491              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
492              load_start = offset
493              load_end = offset + size
494              for start, end in [
495                  (stub.data_start, stub.data_start + len(stub.data)),
496                  (stub.text_start, stub.text_start + len(stub.text)),
497              ]:
498                  if load_start < end and load_end > start:
499                      raise FatalError(
500                          "Software loader is resident at 0x%08x-0x%08x. "
501                          "Can't load binary at overlapping address range 0x%08x-0x%08x. "
502                          "Either change binary loading address, or use the --no-stub "
503                          "option to disable the software loader."
504                          % (start, end, load_start, load_end)
505                      )
506          return self.check_command(
507              "enter RAM download mode",
508              self.ESP_MEM_BEGIN,
509              struct.pack("<IIII", size, blocks, blocksize, offset),
510          )
511      def mem_block(self, data, seq):
512          return self.check_command(
513              "write to target RAM",
514              self.ESP_MEM_DATA,
515              struct.pack("<IIII", len(data), seq, 0, 0) + data,
516              self.checksum(data),
517          )
518      def mem_finish(self, entrypoint=0):
519          timeout = DEFAULT_TIMEOUT if self.IS_STUB else MEM_END_ROM_TIMEOUT
520          data = struct.pack("<II", int(entrypoint == 0), entrypoint)
521          try:
522              return self.check_command(
523                  "leave RAM download mode", self.ESP_MEM_END, data=data, timeout=timeout
524              )
525          except FatalError:
526              if self.IS_STUB:
527                  raise
528              pass
529      def flash_begin(self, size, offset, begin_rom_encrypted=False):
530          num_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
531          erase_size = self.get_erase_size(offset, size)
532          t = time.time()
533          if self.IS_STUB:
534              timeout = DEFAULT_TIMEOUT
535          else:
536              timeout = timeout_per_mb(
537                  ERASE_REGION_TIMEOUT_PER_MB, size
538              )  # ROM performs the erase up front
539          params = struct.pack(
540              "<IIII", erase_size, num_blocks, self.FLASH_WRITE_SIZE, offset
541          )
542          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
543              params += struct.pack("<I", 1 if begin_rom_encrypted else 0)
544          self.check_command(
545              "enter Flash download mode", self.ESP_FLASH_BEGIN, params, timeout=timeout
546          )
547          if size != 0 and not self.IS_STUB:
548              print("Took %.2fs to erase flash block" % (time.time() - t))
549          return num_blocks
550      def flash_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
551          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
552              try:
553                  self.check_command(
554                      "write to target Flash after seq %d" % seq,
555                      self.ESP_FLASH_DATA,
556                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
557                      self.checksum(data),
558                      timeout=timeout,
559                  )
560                  break
561              except FatalError:
562                  if attempts_left:
563                      self.trace(
564                          "Block write failed, "
565                          f"retrying with {attempts_left} attempts left"
566                      )
567                  else:
568                      raise
569      def flash_encrypt_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
570          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
571              return self.flash_block(data, seq, timeout)
572          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
573              try:
574                  self.check_command(
575                      "Write encrypted to target Flash after seq %d" % seq,
576                      self.ESP_FLASH_ENCRYPT_DATA,
577                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
578                      self.checksum(data),
579                      timeout=timeout,
580                  )
581                  break
582              except FatalError:
583                  if attempts_left:
584                      self.trace(
585                          "Encrypted block write failed, "
586                          f"retrying with {attempts_left} attempts left"
587                      )
588                  else:
589                      raise
590      def flash_finish(self, reboot=False):
<span onclick='openModal()' class='match'>591          pkt = struct.pack("<I", int(not reboot))
592          self.check_command("leave Flash mode", self.ESP_FLASH_END, pkt)
593      def run(self, reboot=False):
</span>594          self.flash_begin(0, 0)
595          self.flash_finish(reboot)
596      def flash_id(self):
597          if self.cache["flash_id"] is None:
598              SPIFLASH_RDID = 0x9F
599              self.cache["flash_id"] = self.run_spiflash_command(SPIFLASH_RDID, b"", 24)
600          return self.cache["flash_id"]
601      def flash_type(self):
602          return None  # not implemented for all chip targets
603      def get_security_info(self):
604          res = self.check_command("get security info", self.ESP_GET_SECURITY_INFO, b"")
605          esp32s2 = True if len(res) == 12 else False
606          res = struct.unpack("<IBBBBBBBB" if esp32s2 else "<IBBBBBBBBII", res)
607          return {
608              "flags": res[0],
609              "flash_crypt_cnt": res[1],
610              "key_purposes": res[2:9],
611              "chip_id": None if esp32s2 else res[9],
612              "api_version": None if esp32s2 else res[10],
613          }
614      @esp32s3_or_newer_function_only
615      def get_chip_id(self):
616          if self.cache["chip_id"] is None:
617              res = self.check_command(
618                  "get security info", self.ESP_GET_SECURITY_INFO, b""
619              )
620              res = struct.unpack(
621                  "<IBBBBBBBBI", res[:16]
622              )  # 4b flags, 1b flash_crypt_cnt, 7*1b key_purposes, 4b chip_id
623              self.cache["chip_id"] = res[9]  # 2/4 status bytes invariant
624          return self.cache["chip_id"]
625      def get_uart_no(self):
626          if self.cache["uart_no"] is None:
627              self.cache["uart_no"] = self.read_reg(self.UARTDEV_BUF_NO) & 0xFF
628          return self.cache["uart_no"]
629      @classmethod
630      def parse_flash_size_arg(cls, arg):
631          try:
632              return cls.FLASH_SIZES[arg]
633          except KeyError:
634              raise FatalError(
635                  "Flash size '%s' is not supported by this chip type. "
636                  "Supported sizes: %s" % (arg, ", ".join(cls.FLASH_SIZES.keys()))
637              )
638      @classmethod
639      def parse_flash_freq_arg(cls, arg):
640          if arg is None:
641              return 0
642          try:
643              return cls.FLASH_FREQUENCY[arg]
644          except KeyError:
645              raise FatalError(
646                  "Flash frequency '%s' is not supported by this chip type. "
647                  "Supported frequencies: %s"
648                  % (arg, ", ".join(cls.FLASH_FREQUENCY.keys()))
649              )
650      def run_stub(self, stub=None):
651          if stub is None:
652              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
653          if self.sync_stub_detected:
654              print("Stub is already running. No upload is necessary.")
655              return self.STUB_CLASS(self)
656          print("Uploading stub...")
657          for field in [stub.text, stub.data]:
658              if field is not None:
659                  offs = stub.text_start if field == stub.text else stub.data_start
660                  length = len(field)
661                  blocks = (length + self.ESP_RAM_BLOCK - 1) // self.ESP_RAM_BLOCK
662                  self.mem_begin(length, blocks, self.ESP_RAM_BLOCK, offs)
663                  for seq in range(blocks):
664                      from_offs = seq * self.ESP_RAM_BLOCK
665                      to_offs = from_offs + self.ESP_RAM_BLOCK
666                      self.mem_block(field[from_offs:to_offs], seq)
667          print("Running stub...")
668          self.mem_finish(stub.entry)
669          try:
670              p = self.read()
671          except StopIteration:
672              raise FatalError(
673                  "Failed to start stub. There was no response."
674                  "\nTry increasing timeouts, for more information see: "
675                  "https://docs.espressif.com/projects/esptool/en/latest/esptool/configuration-file.html"  # noqa E501
676              )
677          if p != b"OHAI":
678              raise FatalError(f"Failed to start stub. Unexpected response: {p}")
679          print("Stub running...")
680          return self.STUB_CLASS(self)
681      @stub_and_esp32_function_only
682      def flash_defl_begin(self, size, compsize, offset):
683          num_blocks = (compsize + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
684          erase_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
685          t = time.time()
686          if self.IS_STUB:
687              write_size = (
688                  size  # stub expects number of bytes here, manages erasing internally
689              )
690              timeout = DEFAULT_TIMEOUT
691          else:
692              write_size = (
693                  erase_blocks * self.FLASH_WRITE_SIZE
694              )  # ROM expects rounded up to erase block size
695              timeout = timeout_per_mb(
696                  ERASE_REGION_TIMEOUT_PER_MB, write_size
697              )  # ROM performs the erase up front
698          print("Compressed %d bytes to %d..." % (size, compsize))
699          params = struct.pack(
700              "<IIII", write_size, num_blocks, self.FLASH_WRITE_SIZE, offset
701          )
702          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
703              params += struct.pack("<I", 0)
704          self.check_command(
705              "enter compressed flash mode",
706              self.ESP_FLASH_DEFL_BEGIN,
707              params,
708              timeout=timeout,
709          )
710          if size != 0 and not self.IS_STUB:
711              print("Took %.2fs to erase flash block" % (time.time() - t))
712          return num_blocks
713      @stub_and_esp32_function_only
714      def flash_defl_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
715          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
716              try:
717                  self.check_command(
718                      "write compressed data to flash after seq %d" % seq,
719                      self.ESP_FLASH_DEFL_DATA,
720                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
721                      self.checksum(data),
722                      timeout=timeout,
723                  )
724                  break
725              except FatalError:
726                  if attempts_left:
727                      self.trace(
728                          "Compressed block write failed, "
729                          f"retrying with {attempts_left} attempts left"
730                      )
731                  else:
732                      raise
733      @stub_and_esp32_function_only
734      def flash_defl_finish(self, reboot=False):
735          if not reboot and not self.IS_STUB:
736              return
737          pkt = struct.pack("<I", int(not reboot))
738          self.check_command("leave compressed flash mode", self.ESP_FLASH_DEFL_END, pkt)
739          self.in_bootloader = False
740      @stub_and_esp32_function_only
741      def flash_md5sum(self, addr, size):
742          timeout = timeout_per_mb(MD5_TIMEOUT_PER_MB, size)
743          res = self.check_command(
744              "calculate md5sum",
745              self.ESP_SPI_FLASH_MD5,
746              struct.pack("<IIII", addr, size, 0, 0),
747              timeout=timeout,
748          )
749          if len(res) == 32:
750              return res.decode("utf-8")  # already hex formatted
751          elif len(res) == 16:
752              return hexify(res).lower()
753          else:
754              raise FatalError("MD5Sum command returned unexpected result: %r" % res)
755      @stub_and_esp32_function_only
756      def change_baud(self, baud):
757          print("Changing baud rate to %d" % baud)
758          second_arg = self._port.baudrate if self.IS_STUB else 0
759          self.command(self.ESP_CHANGE_BAUDRATE, struct.pack("<II", baud, second_arg))
760          print("Changed.")
761          self._set_port_baudrate(baud)
762          time.sleep(0.05)  # get rid of crap sent during baud rate change
763          self.flush_input()
764      @stub_function_only
765      def erase_flash(self):
766          self.check_command(
767              "erase flash", self.ESP_ERASE_FLASH, timeout=CHIP_ERASE_TIMEOUT
768          )
769      @stub_function_only
770      def erase_region(self, offset, size):
771          if offset % self.FLASH_SECTOR_SIZE != 0:
772              raise FatalError("Offset to erase from must be a multiple of 4096")
773          if size % self.FLASH_SECTOR_SIZE != 0:
774              raise FatalError("Size of data to erase must be a multiple of 4096")
775          timeout = timeout_per_mb(ERASE_REGION_TIMEOUT_PER_MB, size)
776          self.check_command(
777              "erase region",
778              self.ESP_ERASE_REGION,
779              struct.pack("<II", offset, size),
780              timeout=timeout,
781          )
782      def read_flash_slow(self, offset, length, progress_fn):
783          raise NotImplementedInROMError(self, self.read_flash_slow)
784      def read_flash(self, offset, length, progress_fn=None):
785          if not self.IS_STUB:
786              return self.read_flash_slow(offset, length, progress_fn)  # ROM-only routine
787          self.check_command(
788              "read flash",
789              self.ESP_READ_FLASH,
790              struct.pack("<IIII", offset, length, self.FLASH_SECTOR_SIZE, 64),
791          )
792          data = b""
793          while len(data) < length:
794              p = self.read()
795              data += p
796              if len(data) < length and len(p) < self.FLASH_SECTOR_SIZE:
797                  raise FatalError(
798                      "Corrupt data, expected 0x%x bytes but received 0x%x bytes"
799                      % (self.FLASH_SECTOR_SIZE, len(p))
800                  )
801              self.write(struct.pack("<I", len(data)))
802              if progress_fn and (len(data) % 1024 == 0 or len(data) == length):
803                  progress_fn(len(data), length)
804          if progress_fn:
805              progress_fn(len(data), length)
806          if len(data) > length:
807              raise FatalError("Read more than expected")
808          digest_frame = self.read()
809          if len(digest_frame) != 16:
810              raise FatalError("Expected digest, got: %s" % hexify(digest_frame))
811          expected_digest = hexify(digest_frame).upper()
812          digest = hashlib.md5(data).hexdigest().upper()
813          if digest != expected_digest:
814              raise FatalError(
815                  "Digest mismatch: expected %s, got %s" % (expected_digest, digest)
816              )
817          return data
818      def flash_spi_attach(self, hspi_arg):
819          arg = struct.pack("<I", hspi_arg)
820          if not self.IS_STUB:
821              is_legacy = 0
822              arg += struct.pack("BBBB", is_legacy, 0, 0, 0)
823          self.check_command("configure SPI flash pins", self.ESP_SPI_ATTACH, arg)
824      def flash_set_parameters(self, size):
825          fl_id = 0
826          total_size = size
827          block_size = 64 * 1024
828          sector_size = 4 * 1024
829          page_size = 256
830          status_mask = 0xFFFF
831          self.check_command(
832              "set SPI params",
833              self.ESP_SPI_SET_PARAMS,
834              struct.pack(
835                  "<IIIIII",
836                  fl_id,
837                  total_size,
838                  block_size,
839                  sector_size,
840                  page_size,
841                  status_mask,
842              ),
843          )
844      def run_spiflash_command(
845          self,
846          spiflash_command,
847          data=b"",
848          read_bits=0,
849          addr=None,
850          addr_len=0,
851          dummy_len=0,
852      ):
853          SPI_USR_COMMAND = 1 << 31
854          SPI_USR_ADDR = 1 << 30
855          SPI_USR_DUMMY = 1 << 29
856          SPI_USR_MISO = 1 << 28
857          SPI_USR_MOSI = 1 << 27
858          base = self.SPI_REG_BASE
859          SPI_CMD_REG = base + 0x00
860          SPI_ADDR_REG = base + 0x04
861          SPI_USR_REG = base + self.SPI_USR_OFFS
862          SPI_USR1_REG = base + self.SPI_USR1_OFFS
863          SPI_USR2_REG = base + self.SPI_USR2_OFFS
864          SPI_W0_REG = base + self.SPI_W0_OFFS
865          if self.SPI_MOSI_DLEN_OFFS is not None:
866              def set_data_lengths(mosi_bits, miso_bits):
867                  SPI_MOSI_DLEN_REG = base + self.SPI_MOSI_DLEN_OFFS
868                  SPI_MISO_DLEN_REG = base + self.SPI_MISO_DLEN_OFFS
869                  if mosi_bits > 0:
870                      self.write_reg(SPI_MOSI_DLEN_REG, mosi_bits - 1)
871                  if miso_bits > 0:
872                      self.write_reg(SPI_MISO_DLEN_REG, miso_bits - 1)
873                  flags = 0
874                  if dummy_len > 0:
875                      flags |= dummy_len - 1
876                  if addr_len > 0:
877                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
878                  if flags:
879                      self.write_reg(SPI_USR1_REG, flags)
880          else:
881              def set_data_lengths(mosi_bits, miso_bits):
882                  SPI_DATA_LEN_REG = SPI_USR1_REG
883                  SPI_MOSI_BITLEN_S = 17
884                  SPI_MISO_BITLEN_S = 8
885                  mosi_mask = 0 if (mosi_bits == 0) else (mosi_bits - 1)
886                  miso_mask = 0 if (miso_bits == 0) else (miso_bits - 1)
887                  flags = (miso_mask << SPI_MISO_BITLEN_S) | (
888                      mosi_mask << SPI_MOSI_BITLEN_S
889                  )
890                  if dummy_len > 0:
891                      flags |= dummy_len - 1
892                  if addr_len > 0:
893                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
894                  self.write_reg(SPI_DATA_LEN_REG, flags)
895          SPI_CMD_USR = 1 << 18
896          SPI_USR2_COMMAND_LEN_SHIFT = 28
897          SPI_USR_ADDR_LEN_SHIFT = 26
898          if read_bits > 32:
899              raise FatalError(
900                  "Reading more than 32 bits back from a SPI flash "
901                  "operation is unsupported"
902              )
903          if len(data) > 64:
904              raise FatalError(
905                  "Writing more than 64 bytes of data with one SPI "
906                  "command is unsupported"
907              )
908          data_bits = len(data) * 8
909          old_spi_usr = self.read_reg(SPI_USR_REG)
910          old_spi_usr2 = self.read_reg(SPI_USR2_REG)
911          flags = SPI_USR_COMMAND
912          if read_bits > 0:
913              flags |= SPI_USR_MISO
914          if data_bits > 0:
915              flags |= SPI_USR_MOSI
916          if addr_len > 0:
917              flags |= SPI_USR_ADDR
918          if dummy_len > 0:
919              flags |= SPI_USR_DUMMY
920          set_data_lengths(data_bits, read_bits)
921          self.write_reg(SPI_USR_REG, flags)
922          self.write_reg(
923              SPI_USR2_REG, (7 << SPI_USR2_COMMAND_LEN_SHIFT) | spiflash_command
924          )
925          if addr and addr_len > 0:
926              self.write_reg(SPI_ADDR_REG, addr)
927          if data_bits == 0:
928              self.write_reg(SPI_W0_REG, 0)  # clear data register before we read it
929          else:
930              data = pad_to(data, 4, b"\00")  # pad to 32-bit multiple
931              words = struct.unpack("I" * (len(data) // 4), data)
932              next_reg = SPI_W0_REG
933              for word in words:
934                  self.write_reg(next_reg, word)
935                  next_reg += 4
936          self.write_reg(SPI_CMD_REG, SPI_CMD_USR)
937          def wait_done():
938              for _ in range(10):
939                  if (self.read_reg(SPI_CMD_REG) & SPI_CMD_USR) == 0:
940                      return
941              raise FatalError("SPI command did not complete in time")
942          wait_done()
943          status = self.read_reg(SPI_W0_REG)
944          self.write_reg(SPI_USR_REG, old_spi_usr)
945          self.write_reg(SPI_USR2_REG, old_spi_usr2)
946          return status
947      def read_spiflash_sfdp(self, addr, read_bits):
948          CMD_RDSFDP = 0x5A
949          return self.run_spiflash_command(
950              CMD_RDSFDP, read_bits=read_bits, addr=addr, addr_len=24, dummy_len=8
951          )
952      def read_status(self, num_bytes=2):
953          SPIFLASH_RDSR = 0x05
954          SPIFLASH_RDSR2 = 0x35
955          SPIFLASH_RDSR3 = 0x15
956          status = 0
957          shift = 0
958          for cmd in [SPIFLASH_RDSR, SPIFLASH_RDSR2, SPIFLASH_RDSR3][0:num_bytes]:
959              status += self.run_spiflash_command(cmd, read_bits=8) << shift
960              shift += 8
961          return status
962      def write_status(self, new_status, num_bytes=2, set_non_volatile=False):
963          SPIFLASH_WRSR = 0x01
964          SPIFLASH_WRSR2 = 0x31
965          SPIFLASH_WRSR3 = 0x11
966          SPIFLASH_WEVSR = 0x50
967          SPIFLASH_WREN = 0x06
968          SPIFLASH_WRDI = 0x04
969          enable_cmd = SPIFLASH_WREN if set_non_volatile else SPIFLASH_WEVSR
970          if num_bytes == 2:
971              self.run_spiflash_command(enable_cmd)
972              self.run_spiflash_command(SPIFLASH_WRSR, struct.pack("<H", new_status))
973          for cmd in [SPIFLASH_WRSR, SPIFLASH_WRSR2, SPIFLASH_WRSR3][0:num_bytes]:
974              self.run_spiflash_command(enable_cmd)
975              self.run_spiflash_command(cmd, struct.pack("B", new_status & 0xFF))
976              new_status >>= 8
977          self.run_spiflash_command(SPIFLASH_WRDI)
978      def get_crystal_freq(self):
979          uart_div = self.read_reg(self.UART_CLKDIV_REG) & self.UART_CLKDIV_MASK
980          est_xtal = (self._port.baudrate * uart_div) / 1e6 / self.XTAL_CLK_DIVIDER
981          norm_xtal = 40 if est_xtal > 33 else 26
982          if abs(norm_xtal - est_xtal) > 1:
983              print(
984                  "WARNING: Detected crystal freq %.2fMHz is quite different to "
985                  "normalized freq %dMHz. Unsupported crystal in use?"
986                  % (est_xtal, norm_xtal)
987              )
988          return norm_xtal
989      def hard_reset(self):
990          print("Hard resetting via RTS pin...")
991          HardReset(self._port)()
992      def soft_reset(self, stay_in_bootloader):
993          if not self.IS_STUB:
994              if stay_in_bootloader:
995                  return  # ROM bootloader is already in bootloader!
996              else:
997                  self.flash_begin(0, 0)
998                  self.flash_finish(False)
999          else:
1000              if stay_in_bootloader:
1001                  self.flash_begin(0, 0)
1002                  self.flash_finish(True)
1003              elif self.CHIP_NAME != "ESP8266":
1004                  raise FatalError(
1005                      "Soft resetting is currently only supported on ESP8266"
1006                  )
1007              else:
1008                  self.command(self.ESP_RUN_USER_CODE, wait_response=False)
1009      def check_chip_id(self):
1010          try:
1011              chip_id = self.get_chip_id()
1012              if chip_id != self.IMAGE_CHIP_ID:
1013                  print(
1014                      "WARNING: Chip ID {} ({}) doesn't match expected Chip ID {}. "
1015                      "esptool may not work correctly.".format(
1016                          chip_id,
1017                          self.UNSUPPORTED_CHIPS.get(chip_id, "Unknown"),
1018                          self.IMAGE_CHIP_ID,
1019                      )
1020                  )
1021                  self.stub_is_disabled = True
1022          except NotImplementedInROMError:
1023              pass
1024  def slip_reader(port, trace_function):
1025      def detect_panic_handler(input):
1026          guru_meditation = (
1027              rb"G?uru Meditation Error: (?:Core \d panic'ed \(([a-zA-Z ]*)\))?"
1028          )
1029          fatal_exception = rb"F?atal exception \(\d+\): (?:([a-zA-Z ]*)?.*epc)?"
1030          data = re.search(
1031              rb"".join([rb"(?:", guru_meditation, rb"|", fatal_exception, rb")"]),
1032              input,
1033              re.DOTALL,
1034          )
1035          if data is not None:
1036              cause = [
1037                  "({})".format(i.decode("utf-8"))
1038                  for i in [data.group(1), data.group(2)]
1039                  if i is not None
1040              ]
1041              cause = f" {cause[0]}" if len(cause) else ""
1042              msg = f"Guru Meditation Error detected{cause}"
1043              raise FatalError(msg)
1044      partial_packet = None
1045      in_escape = False
1046      successful_slip = False
1047      while True:
1048          waiting = port.inWaiting()
1049          read_bytes = port.read(1 if waiting == 0 else waiting)
1050          if read_bytes == b"":
1051              if partial_packet is None:  # fail due to no data
1052                  msg = (
1053                      "Serial data stream stopped: Possible serial noise or corruption."
1054                      if successful_slip
1055                      else "No serial data received."
1056                  )
1057              else:  # fail during packet transfer
1058                  msg = "Packet content transfer stopped (received {} bytes)".format(
1059                      len(partial_packet)
1060                  )
1061              trace_function(msg)
1062              raise FatalError(msg)
1063          trace_function("Read %d bytes: %s", len(read_bytes), HexFormatter(read_bytes))
1064          for b in read_bytes:
1065              b = bytes([b])
1066              if partial_packet is None:  # waiting for packet header
1067                  if b == b"\xc0":
1068                      partial_packet = b""
1069                  else:
1070                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1071                      remaining_data = port.read(port.inWaiting())
1072                      trace_function(
1073                          "Remaining data in serial buffer: %s",
1074                          HexFormatter(remaining_data),
1075                      )
1076                      detect_panic_handler(read_bytes + remaining_data)
1077                      raise FatalError(
1078                          "Invalid head of packet (0x%s): "
1079                          "Possible serial noise or corruption." % hexify(b)
1080                      )
1081              elif in_escape:  # part-way through escape sequence
1082                  in_escape = False
1083                  if b == b"\xdc":
1084                      partial_packet += b"\xc0"
1085                  elif b == b"\xdd":
1086                      partial_packet += b"\xdb"
1087                  else:
1088                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1089                      remaining_data = port.read(port.inWaiting())
1090                      trace_function(
1091                          "Remaining data in serial buffer: %s",
1092                          HexFormatter(remaining_data),
1093                      )
1094                      detect_panic_handler(read_bytes + remaining_data)
1095                      raise FatalError("Invalid SLIP escape (0xdb, 0x%s)" % (hexify(b)))
1096              elif b == b"\xdb":  # start of escape sequence
1097                  in_escape = True
1098              elif b == b"\xc0":  # end of packet
1099                  trace_function("Received full packet: %s", HexFormatter(partial_packet))
1100                  yield partial_packet
1101                  partial_packet = None
1102                  successful_slip = True
1103              else:  # normal byte in packet
1104                  partial_packet += b
1105  class HexFormatter(object):
1106      def __init__(self, binary_string, auto_split=True):
1107          self._s = binary_string
1108          self._auto_split = auto_split
1109      def __str__(self):
1110          if self._auto_split and len(self._s) > 16:
1111              result = ""
1112              s = self._s
1113              while len(s) > 0:
1114                  line = s[:16]
1115                  ascii_line = "".join(
1116                      c
1117                      if (
1118                          c == " "
1119                          or (c in string.printable and c not in string.whitespace)
1120                      )
1121                      else "."
1122                      for c in line.decode("ascii", "replace")
1123                  )
1124                  s = s[16:]
1125                  result += "\n    %-16s %-16s | %s" % (
1126                      hexify(line[:8], False),
1127                      hexify(line[8:], False),
1128                      ascii_line,
1129                  )
1130              return result
1131          else:
1132              return hexify(self._s, False)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</h3>
            <pre><code>1  import base64
2  import hashlib
3  import itertools
4  import json
5  import os
6  import re
7  import string
8  import struct
9  import sys
10  import time
11  from .config import load_config_file
12  from .reset import (
13      ClassicReset,
14      CustomReset,
15      DEFAULT_RESET_DELAY,
16      HardReset,
17      USBJTAGSerialReset,
18      UnixTightReset,
19  )
20  from .util import FatalError, NotImplementedInROMError, UnsupportedCommandError
21  from .util import byte, hexify, mask_to_shift, pad_to, strip_chip_name
22  try:
23      import serial
24  except ImportError:
25      print(
26          "Pyserial is not installed for %s. "
27          "Check the README for installation instructions." % (sys.executable)
28      )
29      raise
30  try:
31      if "serialization" in serial.__doc__ and "deserialization" in serial.__doc__:
32          raise ImportError(
33              "esptool.py depends on pyserial, but there is a conflict with a currently "
34              "installed package named 'serial'.\n"
35              "You may work around this by 'pip uninstall serial; pip install pyserial' "
36              "but this may break other installed Python software "
37              "that depends on 'serial'.\n"
38              "There is no good fix for this right now, "
39              "apart from configuring virtualenvs. "
40              "See https://github.com/espressif/esptool/issues/269#issuecomment-385298196"
41              " for discussion of the underlying issue(s)."
42          )
43  except TypeError:
44      pass  # __doc__ returns None for pyserial
45  try:
46      import serial.tools.list_ports as list_ports
47  except ImportError:
48      print(
49          "The installed version (%s) of pyserial appears to be too old for esptool.py "
50          "(Python interpreter %s). Check the README for installation instructions."
51          % (sys.VERSION, sys.executable)
52      )
53      raise
54  except Exception:
55      if sys.platform == "darwin":
56          list_ports = None
57      else:
58          raise
59  cfg, _ = load_config_file()
60  cfg = cfg["esptool"]
61  DEFAULT_TIMEOUT = cfg.getfloat("timeout", 3)
62  CHIP_ERASE_TIMEOUT = cfg.getfloat("chip_erase_timeout", 120)
63  MAX_TIMEOUT = cfg.getfloat("max_timeout", CHIP_ERASE_TIMEOUT * 2)
64  SYNC_TIMEOUT = cfg.getfloat("sync_timeout", 0.1)
65  MD5_TIMEOUT_PER_MB = cfg.getfloat("md5_timeout_per_mb", 8)
66  ERASE_REGION_TIMEOUT_PER_MB = cfg.getfloat("erase_region_timeout_per_mb", 30)
67  ERASE_WRITE_TIMEOUT_PER_MB = cfg.getfloat("erase_write_timeout_per_mb", 40)
68  MEM_END_ROM_TIMEOUT = cfg.getfloat("mem_end_rom_timeout", 0.2)
69  DEFAULT_SERIAL_WRITE_TIMEOUT = cfg.getfloat("serial_write_timeout", 10)
70  DEFAULT_CONNECT_ATTEMPTS = cfg.getint("connect_attempts", 7)
71  WRITE_BLOCK_ATTEMPTS = cfg.getint("write_block_attempts", 3)
72  STUBS_DIR = os.path.join(os.path.dirname(__file__), "targets", "stub_flasher")
73  def get_stub_json_path(chip_name):
74      chip_name = strip_chip_name(chip_name)
75      chip_name = chip_name.replace("esp", "")
76      return os.path.join(STUBS_DIR, f"stub_flasher_{chip_name}.json")
77  def timeout_per_mb(seconds_per_mb, size_bytes):
78      result = seconds_per_mb * (size_bytes / 1e6)
79      if result < DEFAULT_TIMEOUT:
80          return DEFAULT_TIMEOUT
81      return result
82  def check_supported_function(func, check_func):
83      def inner(*args, **kwargs):
84          obj = args[0]
85          if check_func(obj):
86              return func(*args, **kwargs)
87          else:
88              raise NotImplementedInROMError(obj, func)
89      return inner
90  def stub_function_only(func):
91      return check_supported_function(func, lambda o: o.IS_STUB)
92  def stub_and_esp32_function_only(func):
93      return check_supported_function(
94          func, lambda o: o.IS_STUB or o.CHIP_NAME not in ["ESP8266"]
95      )
96  def esp32s3_or_newer_function_only(func):
97      return check_supported_function(
98          func, lambda o: o.CHIP_NAME not in ["ESP8266", "ESP32", "ESP32-S2"]
99      )
100  class StubFlasher:
101      def __init__(self, json_path):
102          with open(json_path) as json_file:
103              stub = json.load(json_file)
104          self.text = base64.b64decode(stub["text"])
105          self.text_start = stub["text_start"]
106          self.entry = stub["entry"]
107          try:
108              self.data = base64.b64decode(stub["data"])
109              self.data_start = stub["data_start"]
110          except KeyError:
111              self.data = None
112              self.data_start = None
113  class ESPLoader(object):
114      CHIP_NAME = "Espressif device"
115      IS_STUB = False
116      FPGA_SLOW_BOOT = False
117      DEFAULT_PORT = "/dev/ttyUSB0"
118      USES_RFC2217 = False
119      ESP_FLASH_BEGIN = 0x02
120      ESP_FLASH_DATA = 0x03
121      ESP_FLASH_END = 0x04
122      ESP_MEM_BEGIN = 0x05
123      ESP_MEM_END = 0x06
124      ESP_MEM_DATA = 0x07
125      ESP_SYNC = 0x08
126      ESP_WRITE_REG = 0x09
127      ESP_READ_REG = 0x0A
128      ESP_SPI_SET_PARAMS = 0x0B
129      ESP_SPI_ATTACH = 0x0D
130      ESP_READ_FLASH_SLOW = 0x0E  # ROM only, much slower than the stub flash read
131      ESP_CHANGE_BAUDRATE = 0x0F
132      ESP_FLASH_DEFL_BEGIN = 0x10
133      ESP_FLASH_DEFL_DATA = 0x11
134      ESP_FLASH_DEFL_END = 0x12
135      ESP_SPI_FLASH_MD5 = 0x13
136      ESP_GET_SECURITY_INFO = 0x14
137      ESP_ERASE_FLASH = 0xD0
138      ESP_ERASE_REGION = 0xD1
139      ESP_READ_FLASH = 0xD2
140      ESP_RUN_USER_CODE = 0xD3
141      ESP_FLASH_ENCRYPT_DATA = 0xD4
142      ROM_INVALID_RECV_MSG = 0x05  # response if an invalid message is received
143      ESP_RAM_BLOCK = 0x1800
144      FLASH_WRITE_SIZE = 0x400
145      ESP_ROM_BAUD = 115200
146      ESP_IMAGE_MAGIC = 0xE9
147      ESP_CHECKSUM_MAGIC = 0xEF
148      FLASH_SECTOR_SIZE = 0x1000
149      UART_DATE_REG_ADDR = 0x60000078
150      CHIP_DETECT_MAGIC_REG_ADDR = 0x40001000
151      UART_CLKDIV_MASK = 0xFFFFF
152      IROM_MAP_START = 0x40200000
153      IROM_MAP_END = 0x40300000
154      STATUS_BYTES_LENGTH = 2
155      BOOTLOADER_FLASH_OFFSET = 0x0
156      SUPPORTS_ENCRYPTED_FLASH = False
157      sync_stub_detected = False
158      USB_JTAG_SERIAL_PID = 0x1001
159      UNSUPPORTED_CHIPS = {6: "ESP32-S3(beta 3)"}
160      def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):
161          self.secure_download_mode = False
162          self.stub_is_disabled = False
163          self.cache = {
164              "flash_id": None,
165              "chip_id": None,
166              "uart_no": None,
167              "usb_pid": None,
168          }
169          if isinstance(port, str):
170              try:
171                  self._port = serial.serial_for_url(port)
172              except serial.serialutil.SerialException:
173                  raise FatalError(f"Could not open {port}, the port doesn't exist")
174          else:
175              self._port = port
176          self._slip_reader = slip_reader(self._port, self.trace)
177          self._set_port_baudrate(baud)
178          self._trace_enabled = trace_enabled
179          try:
180              self._port.write_timeout = DEFAULT_SERIAL_WRITE_TIMEOUT
181          except NotImplementedError:
182              self._port.write_timeout = None
183      @property
184      def serial_port(self):
185          return self._port.port
186      def _set_port_baudrate(self, baud):
187          try:
188              self._port.baudrate = baud
189          except IOError:
190              raise FatalError(
191                  "Failed to set baud rate %d. The driver may not support this rate."
192                  % baud
193              )
194      def read(self):
195          return next(self._slip_reader)
196      def write(self, packet):
197          buf = (
198              b"\xc0"
199              + (packet.replace(b"\xdb", b"\xdb\xdd").replace(b"\xc0", b"\xdb\xdc"))
200              + b"\xc0"
201          )
202          self.trace("Write %d bytes: %s", len(buf), HexFormatter(buf))
203          self._port.write(buf)
204      def trace(self, message, *format_args):
205          if self._trace_enabled:
206              now = time.time()
207              try:
208                  delta = now - self._last_trace
209              except AttributeError:
210                  delta = 0.0
211              self._last_trace = now
212              prefix = "TRACE +%.3f " % delta
213              print(prefix + (message % format_args))
214      @staticmethod
215      def checksum(data, state=ESP_CHECKSUM_MAGIC):
216          for b in data:
217              state ^= b
218          return state
219      def command(
220          self,
221          op=None,
222          data=b"",
223          chk=0,
224          wait_response=True,
225          timeout=DEFAULT_TIMEOUT,
226      ):
227          saved_timeout = self._port.timeout
228          new_timeout = min(timeout, MAX_TIMEOUT)
229          if new_timeout != saved_timeout:
230              self._port.timeout = new_timeout
231          try:
232              if op is not None:
233                  self.trace(
234                      "command op=0x%02x data len=%s wait_response=%d "
235                      "timeout=%.3f data=%s",
236                      op,
237                      len(data),
238                      1 if wait_response else 0,
239                      timeout,
240                      HexFormatter(data),
241                  )
242                  pkt = struct.pack(b"<BBHI", 0x00, op, len(data), chk) + data
243                  self.write(pkt)
244              if not wait_response:
245                  return
246              for retry in range(100):
247                  p = self.read()
248                  if len(p) < 8:
249                      continue
250                  (resp, op_ret, len_ret, val) = struct.unpack("<BBHI", p[:8])
251                  if resp != 1:
252                      continue
253                  data = p[8:]
254                  if op is None or op_ret == op:
255                      return val, data
256                  if byte(data, 0) != 0 and byte(data, 1) == self.ROM_INVALID_RECV_MSG:
257                      self.flush_input()
258                      raise UnsupportedCommandError(self, op)
259          finally:
260              if new_timeout != saved_timeout:
261                  self._port.timeout = saved_timeout
262          raise FatalError("Response doesn't match request")
263      def check_command(
264          self, op_description, op=None, data=b"", chk=0, timeout=DEFAULT_TIMEOUT
265      ):
266          val, data = self.command(op, data, chk, timeout=timeout)
267          if len(data) < self.STATUS_BYTES_LENGTH:
268              raise FatalError(
269                  "Failed to %s. Only got %d byte status response."
270                  % (op_description, len(data))
271              )
272          status_bytes = data[-self.STATUS_BYTES_LENGTH :]
273          if byte(status_bytes, 0) != 0:
274              raise FatalError.WithResult("Failed to %s" % op_description, status_bytes)
275          if len(data) > self.STATUS_BYTES_LENGTH:
276              return data[: -self.STATUS_BYTES_LENGTH]
277          else:
278              return val
279      def flush_input(self):
280          self._port.flushInput()
281          self._slip_reader = slip_reader(self._port, self.trace)
282      def sync(self):
283          val, _ = self.command(
284              self.ESP_SYNC, b"\x07\x07\x12\x20" + 32 * b"\x55", timeout=SYNC_TIMEOUT
285          )
286          self.sync_stub_detected = val == 0
287          for _ in range(7):
288              val, _ = self.command()
289              self.sync_stub_detected &= val == 0
290      def _get_pid(self):
291          if self.cache["usb_pid"] is not None:
292              return self.cache["usb_pid"]
293          if list_ports is None:
294              print(
295                  "\nListing all serial ports is currently not available. "
296                  "Can't get device PID."
297              )
298              return
299          active_port = self._port.port
300          if not active_port.lower().startswith(("com", "/dev/")):
301              print(
302                  "\nDevice PID identification is only supported on "
303                  "COM and /dev/ serial ports."
304              )
305              return
306          if active_port.startswith("/dev/") and os.path.islink(active_port):
307              active_port = os.path.realpath(active_port)
308          active_ports = [active_port]
309          if sys.platform == "darwin" and "tty" in active_port:
310              active_ports.append(active_port.replace("tty", "cu"))
311          ports = list_ports.comports()
312          for p in ports:
313              if p.device in active_ports:
314                  self.cache["usb_pid"] = p.pid
315                  return p.pid
316          print(
317              f"\nFailed to get PID of a device on {active_port}, "
318              "using standard reset sequence."
319          )
320      def _connect_attempt(self, reset_strategy, mode="default_reset"):
321          last_error = None
322          boot_log_detected = False
323          download_mode = False
324          if mode == "no_reset_no_sync":
325              return last_error
326          if mode != "no_reset":
327              if not self.USES_RFC2217:  # Might block on rfc2217 ports
328                  self._port.reset_input_buffer()
329              reset_strategy()  # Reset the chip to bootloader (download mode)
330              waiting = self._port.inWaiting()
331              read_bytes = self._port.read(waiting)
332              data = re.search(
333                  b"boot:(0x[0-9a-fA-F]+)(.*waiting for download)?", read_bytes, re.DOTALL
334              )
335              if data is not None:
336                  boot_log_detected = True
337                  boot_mode = data.group(1)
338                  download_mode = data.group(2) is not None
339          for _ in range(5):
340              try:
341                  self.flush_input()
342                  self._port.flushOutput()
343                  self.sync()
344                  return None
345              except FatalError as e:
346                  print(".", end="")
347                  sys.stdout.flush()
348                  time.sleep(0.05)
349                  last_error = e
350          if boot_log_detected:
351              last_error = FatalError(
352                  "Wrong boot mode detected ({})! "
353                  "The chip needs to be in download mode.".format(
354                      boot_mode.decode("utf-8")
355                  )
356              )
357              if download_mode:
358                  last_error = FatalError(
359                      "Download mode successfully detected, but getting no sync reply: "
360                      "The serial TX path seems to be down."
361                  )
362          return last_error
363      def get_memory_region(self, name):
364          try:
365              return [(start, end) for (start, end, n) in self.MEMORY_MAP if n == name][0]
366          except IndexError:
367              return None
368      def _construct_reset_strategy_sequence(self, mode):
369          cfg_custom_reset_sequence = cfg.get("custom_reset_sequence")
370          if cfg_custom_reset_sequence is not None:
371              return (CustomReset(self._port, cfg_custom_reset_sequence),)
372          cfg_reset_delay = cfg.getfloat("reset_delay")
373          if cfg_reset_delay is not None:
374              delay = extra_delay = cfg_reset_delay
375          else:
376              delay = DEFAULT_RESET_DELAY
377              extra_delay = DEFAULT_RESET_DELAY + 0.5
378          if (
379              self.FPGA_SLOW_BOOT
380              and os.environ.get("ESPTOOL_ENV_FPGA", "").strip() == "1"
381          ):
382              delay = extra_delay = 7
383          if mode == "usb_reset" or self._get_pid() == self.USB_JTAG_SERIAL_PID:
384              return (USBJTAGSerialReset(self._port),)
385          if os.name != "nt" and not self._port.name.startswith("rfc2217:"):
386              return (
387                  UnixTightReset(self._port, delay),
388                  UnixTightReset(self._port, extra_delay),
389                  ClassicReset(self._port, delay),
390                  ClassicReset(self._port, extra_delay),
391              )
392          return (
393              ClassicReset(self._port, delay),
394              ClassicReset(self._port, extra_delay),
395          )
396      def connect(
397          self,
398          mode="default_reset",
399          attempts=DEFAULT_CONNECT_ATTEMPTS,
400          detecting=False,
401          warnings=True,
402      ):
403          if warnings and mode in ["no_reset", "no_reset_no_sync"]:
404              print(
405                  'WARNING: Pre-connection option "{}" was selected.'.format(mode),
406                  "Connection may fail if the chip is not in bootloader "
407                  "or flasher stub mode.",
408              )
409          print("Connecting...", end="")
410          sys.stdout.flush()
411          last_error = None
412          reset_sequence = self._construct_reset_strategy_sequence(mode)
413          try:
414              for _, reset_strategy in zip(
415                  range(attempts) if attempts > 0 else itertools.count(),
416                  itertools.cycle(reset_sequence),
417              ):
418                  last_error = self._connect_attempt(reset_strategy, mode)
419                  if last_error is None:
420                      break
421          finally:
422              print("")  # end 'Connecting...' line
423          if last_error is not None:
424              raise FatalError(
425                  "Failed to connect to {}: {}"
426                  "\nFor troubleshooting steps visit: "
427                  "https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html".format(  # noqa E501
428                      self.CHIP_NAME, last_error
429                  )
430              )
431          if not detecting:
432              try:
433                  from .targets import ROM_LIST
434                  chip_magic_value = self.read_reg(ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR)
435                  if chip_magic_value not in self.CHIP_DETECT_MAGIC_VALUE:
436                      actually = None
437                      for cls in ROM_LIST:
438                          if chip_magic_value in cls.CHIP_DETECT_MAGIC_VALUE:
439                              actually = cls
440                              break
441                      if warnings and actually is None:
442                          print(
443                              "WARNING: This chip doesn't appear to be a %s "
444                              "(chip magic value 0x%08x). "
445                              "Probably it is unsupported by this version of esptool."
446                              % (self.CHIP_NAME, chip_magic_value)
447                          )
448                      else:
449                          raise FatalError(
450                              "This chip is %s not %s. Wrong --chip argument?"
451                              % (actually.CHIP_NAME, self.CHIP_NAME)
452                          )
453              except UnsupportedCommandError:
454                  self.secure_download_mode = True
455              try:
456                  self.check_chip_id()
457              except UnsupportedCommandError:
458                  if self.secure_download_mode:
459                      self._connect_attempt(mode, reset_sequence[0])
460                      self.check_chip_id()
461                  else:
462                      raise
463              self._post_connect()
464      def _post_connect(self):
465          pass
466      def read_reg(self, addr, timeout=DEFAULT_TIMEOUT):
467          val, data = self.command(
468              self.ESP_READ_REG, struct.pack("<I", addr), timeout=timeout
469          )
470          if byte(data, 0) != 0:
471              raise FatalError.WithResult(
472                  "Failed to read register address %08x" % addr, data
473              )
474          return val
475      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
476          command = struct.pack("<IIII", addr, value, mask, delay_us)
477          if delay_after_us > 0:
478              command += struct.pack(
479                  "<IIII", self.UART_DATE_REG_ADDR, 0, 0, delay_after_us
480              )
481          return self.check_command("write target memory", self.ESP_WRITE_REG, command)
482      def update_reg(self, addr, mask, new_val):
483          shift = mask_to_shift(mask)
484          val = self.read_reg(addr)
485          val &= ~mask
486          val |= (new_val << shift) & mask
487          self.write_reg(addr, val)
488          return val
489      def mem_begin(self, size, blocks, blocksize, offset):
490          if self.IS_STUB:
491              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
492              load_start = offset
493              load_end = offset + size
494              for start, end in [
495                  (stub.data_start, stub.data_start + len(stub.data)),
496                  (stub.text_start, stub.text_start + len(stub.text)),
497              ]:
498                  if load_start < end and load_end > start:
499                      raise FatalError(
500                          "Software loader is resident at 0x%08x-0x%08x. "
501                          "Can't load binary at overlapping address range 0x%08x-0x%08x. "
502                          "Either change binary loading address, or use the --no-stub "
503                          "option to disable the software loader."
504                          % (start, end, load_start, load_end)
505                      )
506          return self.check_command(
507              "enter RAM download mode",
508              self.ESP_MEM_BEGIN,
509              struct.pack("<IIII", size, blocks, blocksize, offset),
510          )
511      def mem_block(self, data, seq):
512          return self.check_command(
513              "write to target RAM",
514              self.ESP_MEM_DATA,
515              struct.pack("<IIII", len(data), seq, 0, 0) + data,
516              self.checksum(data),
517          )
518      def mem_finish(self, entrypoint=0):
519          timeout = DEFAULT_TIMEOUT if self.IS_STUB else MEM_END_ROM_TIMEOUT
520          data = struct.pack("<II", int(entrypoint == 0), entrypoint)
521          try:
522              return self.check_command(
523                  "leave RAM download mode", self.ESP_MEM_END, data=data, timeout=timeout
524              )
525          except FatalError:
526              if self.IS_STUB:
527                  raise
528              pass
529      def flash_begin(self, size, offset, begin_rom_encrypted=False):
530          num_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
531          erase_size = self.get_erase_size(offset, size)
532          t = time.time()
533          if self.IS_STUB:
534              timeout = DEFAULT_TIMEOUT
535          else:
536              timeout = timeout_per_mb(
537                  ERASE_REGION_TIMEOUT_PER_MB, size
538              )  # ROM performs the erase up front
539          params = struct.pack(
540              "<IIII", erase_size, num_blocks, self.FLASH_WRITE_SIZE, offset
541          )
542          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
543              params += struct.pack("<I", 1 if begin_rom_encrypted else 0)
544          self.check_command(
545              "enter Flash download mode", self.ESP_FLASH_BEGIN, params, timeout=timeout
546          )
547          if size != 0 and not self.IS_STUB:
548              print("Took %.2fs to erase flash block" % (time.time() - t))
549          return num_blocks
550      def flash_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
551          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
552              try:
553                  self.check_command(
554                      "write to target Flash after seq %d" % seq,
555                      self.ESP_FLASH_DATA,
556                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
557                      self.checksum(data),
558                      timeout=timeout,
559                  )
560                  break
561              except FatalError:
562                  if attempts_left:
563                      self.trace(
564                          "Block write failed, "
565                          f"retrying with {attempts_left} attempts left"
566                      )
567                  else:
568                      raise
569      def flash_encrypt_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
570          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
571              return self.flash_block(data, seq, timeout)
572          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
573              try:
574                  self.check_command(
575                      "Write encrypted to target Flash after seq %d" % seq,
576                      self.ESP_FLASH_ENCRYPT_DATA,
577                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
578                      self.checksum(data),
579                      timeout=timeout,
580                  )
581                  break
582              except FatalError:
583                  if attempts_left:
584                      self.trace(
585                          "Encrypted block write failed, "
586                          f"retrying with {attempts_left} attempts left"
587                      )
588                  else:
589                      raise
590      def flash_finish(self, reboot=False):
591          pkt = struct.pack("<I", int(not reboot))
592          self.check_command("leave Flash mode", self.ESP_FLASH_END, pkt)
593      def run(self, reboot=False):
594          self.flash_begin(0, 0)
595          self.flash_finish(reboot)
596      def flash_id(self):
597          if self.cache["flash_id"] is None:
598              SPIFLASH_RDID = 0x9F
599              self.cache["flash_id"] = self.run_spiflash_command(SPIFLASH_RDID, b"", 24)
600          return self.cache["flash_id"]
601      def flash_type(self):
602          return None  # not implemented for all chip targets
603      def get_security_info(self):
604          res = self.check_command("get security info", self.ESP_GET_SECURITY_INFO, b"")
605          esp32s2 = True if len(res) == 12 else False
606          res = struct.unpack("<IBBBBBBBB" if esp32s2 else "<IBBBBBBBBII", res)
607          return {
608              "flags": res[0],
609              "flash_crypt_cnt": res[1],
610              "key_purposes": res[2:9],
611              "chip_id": None if esp32s2 else res[9],
612              "api_version": None if esp32s2 else res[10],
613          }
614      @esp32s3_or_newer_function_only
615      def get_chip_id(self):
616          if self.cache["chip_id"] is None:
617              res = self.check_command(
618                  "get security info", self.ESP_GET_SECURITY_INFO, b""
619              )
620              res = struct.unpack(
621                  "<IBBBBBBBBI", res[:16]
622              )  # 4b flags, 1b flash_crypt_cnt, 7*1b key_purposes, 4b chip_id
623              self.cache["chip_id"] = res[9]  # 2/4 status bytes invariant
624          return self.cache["chip_id"]
625      def get_uart_no(self):
626          if self.cache["uart_no"] is None:
627              self.cache["uart_no"] = self.read_reg(self.UARTDEV_BUF_NO) & 0xFF
628          return self.cache["uart_no"]
629      @classmethod
630      def parse_flash_size_arg(cls, arg):
631          try:
632              return cls.FLASH_SIZES[arg]
633          except KeyError:
634              raise FatalError(
635                  "Flash size '%s' is not supported by this chip type. "
636                  "Supported sizes: %s" % (arg, ", ".join(cls.FLASH_SIZES.keys()))
637              )
638      @classmethod
639      def parse_flash_freq_arg(cls, arg):
640          if arg is None:
641              return 0
642          try:
643              return cls.FLASH_FREQUENCY[arg]
644          except KeyError:
645              raise FatalError(
646                  "Flash frequency '%s' is not supported by this chip type. "
647                  "Supported frequencies: %s"
648                  % (arg, ", ".join(cls.FLASH_FREQUENCY.keys()))
649              )
650      def run_stub(self, stub=None):
651          if stub is None:
652              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
653          if self.sync_stub_detected:
654              print("Stub is already running. No upload is necessary.")
655              return self.STUB_CLASS(self)
656          print("Uploading stub...")
657          for field in [stub.text, stub.data]:
658              if field is not None:
659                  offs = stub.text_start if field == stub.text else stub.data_start
660                  length = len(field)
661                  blocks = (length + self.ESP_RAM_BLOCK - 1) // self.ESP_RAM_BLOCK
662                  self.mem_begin(length, blocks, self.ESP_RAM_BLOCK, offs)
663                  for seq in range(blocks):
664                      from_offs = seq * self.ESP_RAM_BLOCK
665                      to_offs = from_offs + self.ESP_RAM_BLOCK
666                      self.mem_block(field[from_offs:to_offs], seq)
667          print("Running stub...")
668          self.mem_finish(stub.entry)
669          try:
670              p = self.read()
671          except StopIteration:
672              raise FatalError(
673                  "Failed to start stub. There was no response."
674                  "\nTry increasing timeouts, for more information see: "
675                  "https://docs.espressif.com/projects/esptool/en/latest/esptool/configuration-file.html"  # noqa E501
676              )
677          if p != b"OHAI":
678              raise FatalError(f"Failed to start stub. Unexpected response: {p}")
679          print("Stub running...")
680          return self.STUB_CLASS(self)
681      @stub_and_esp32_function_only
682      def flash_defl_begin(self, size, compsize, offset):
683          num_blocks = (compsize + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
684          erase_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
685          t = time.time()
686          if self.IS_STUB:
687              write_size = (
688                  size  # stub expects number of bytes here, manages erasing internally
689              )
690              timeout = DEFAULT_TIMEOUT
691          else:
692              write_size = (
693                  erase_blocks * self.FLASH_WRITE_SIZE
694              )  # ROM expects rounded up to erase block size
695              timeout = timeout_per_mb(
696                  ERASE_REGION_TIMEOUT_PER_MB, write_size
697              )  # ROM performs the erase up front
698          print("Compressed %d bytes to %d..." % (size, compsize))
699          params = struct.pack(
700              "<IIII", write_size, num_blocks, self.FLASH_WRITE_SIZE, offset
701          )
702          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
703              params += struct.pack("<I", 0)
704          self.check_command(
705              "enter compressed flash mode",
706              self.ESP_FLASH_DEFL_BEGIN,
707              params,
708              timeout=timeout,
709          )
710          if size != 0 and not self.IS_STUB:
711              print("Took %.2fs to erase flash block" % (time.time() - t))
712          return num_blocks
713      @stub_and_esp32_function_only
714      def flash_defl_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
715          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
716              try:
717                  self.check_command(
718                      "write compressed data to flash after seq %d" % seq,
719                      self.ESP_FLASH_DEFL_DATA,
720                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
721                      self.checksum(data),
722                      timeout=timeout,
723                  )
724                  break
725              except FatalError:
726                  if attempts_left:
727                      self.trace(
728                          "Compressed block write failed, "
729                          f"retrying with {attempts_left} attempts left"
730                      )
731                  else:
732                      raise
733      @stub_and_esp32_function_only
734      def flash_defl_finish(self, reboot=False):
735          if not reboot and not self.IS_STUB:
736              return
<span onclick='openModal()' class='match'>737          pkt = struct.pack("<I", int(not reboot))
738          self.check_command("leave compressed flash mode", self.ESP_FLASH_DEFL_END, pkt)
739          self.in_bootloader = False
</span>740      @stub_and_esp32_function_only
741      def flash_md5sum(self, addr, size):
742          timeout = timeout_per_mb(MD5_TIMEOUT_PER_MB, size)
743          res = self.check_command(
744              "calculate md5sum",
745              self.ESP_SPI_FLASH_MD5,
746              struct.pack("<IIII", addr, size, 0, 0),
747              timeout=timeout,
748          )
749          if len(res) == 32:
750              return res.decode("utf-8")  # already hex formatted
751          elif len(res) == 16:
752              return hexify(res).lower()
753          else:
754              raise FatalError("MD5Sum command returned unexpected result: %r" % res)
755      @stub_and_esp32_function_only
756      def change_baud(self, baud):
757          print("Changing baud rate to %d" % baud)
758          second_arg = self._port.baudrate if self.IS_STUB else 0
759          self.command(self.ESP_CHANGE_BAUDRATE, struct.pack("<II", baud, second_arg))
760          print("Changed.")
761          self._set_port_baudrate(baud)
762          time.sleep(0.05)  # get rid of crap sent during baud rate change
763          self.flush_input()
764      @stub_function_only
765      def erase_flash(self):
766          self.check_command(
767              "erase flash", self.ESP_ERASE_FLASH, timeout=CHIP_ERASE_TIMEOUT
768          )
769      @stub_function_only
770      def erase_region(self, offset, size):
771          if offset % self.FLASH_SECTOR_SIZE != 0:
772              raise FatalError("Offset to erase from must be a multiple of 4096")
773          if size % self.FLASH_SECTOR_SIZE != 0:
774              raise FatalError("Size of data to erase must be a multiple of 4096")
775          timeout = timeout_per_mb(ERASE_REGION_TIMEOUT_PER_MB, size)
776          self.check_command(
777              "erase region",
778              self.ESP_ERASE_REGION,
779              struct.pack("<II", offset, size),
780              timeout=timeout,
781          )
782      def read_flash_slow(self, offset, length, progress_fn):
783          raise NotImplementedInROMError(self, self.read_flash_slow)
784      def read_flash(self, offset, length, progress_fn=None):
785          if not self.IS_STUB:
786              return self.read_flash_slow(offset, length, progress_fn)  # ROM-only routine
787          self.check_command(
788              "read flash",
789              self.ESP_READ_FLASH,
790              struct.pack("<IIII", offset, length, self.FLASH_SECTOR_SIZE, 64),
791          )
792          data = b""
793          while len(data) < length:
794              p = self.read()
795              data += p
796              if len(data) < length and len(p) < self.FLASH_SECTOR_SIZE:
797                  raise FatalError(
798                      "Corrupt data, expected 0x%x bytes but received 0x%x bytes"
799                      % (self.FLASH_SECTOR_SIZE, len(p))
800                  )
801              self.write(struct.pack("<I", len(data)))
802              if progress_fn and (len(data) % 1024 == 0 or len(data) == length):
803                  progress_fn(len(data), length)
804          if progress_fn:
805              progress_fn(len(data), length)
806          if len(data) > length:
807              raise FatalError("Read more than expected")
808          digest_frame = self.read()
809          if len(digest_frame) != 16:
810              raise FatalError("Expected digest, got: %s" % hexify(digest_frame))
811          expected_digest = hexify(digest_frame).upper()
812          digest = hashlib.md5(data).hexdigest().upper()
813          if digest != expected_digest:
814              raise FatalError(
815                  "Digest mismatch: expected %s, got %s" % (expected_digest, digest)
816              )
817          return data
818      def flash_spi_attach(self, hspi_arg):
819          arg = struct.pack("<I", hspi_arg)
820          if not self.IS_STUB:
821              is_legacy = 0
822              arg += struct.pack("BBBB", is_legacy, 0, 0, 0)
823          self.check_command("configure SPI flash pins", self.ESP_SPI_ATTACH, arg)
824      def flash_set_parameters(self, size):
825          fl_id = 0
826          total_size = size
827          block_size = 64 * 1024
828          sector_size = 4 * 1024
829          page_size = 256
830          status_mask = 0xFFFF
831          self.check_command(
832              "set SPI params",
833              self.ESP_SPI_SET_PARAMS,
834              struct.pack(
835                  "<IIIIII",
836                  fl_id,
837                  total_size,
838                  block_size,
839                  sector_size,
840                  page_size,
841                  status_mask,
842              ),
843          )
844      def run_spiflash_command(
845          self,
846          spiflash_command,
847          data=b"",
848          read_bits=0,
849          addr=None,
850          addr_len=0,
851          dummy_len=0,
852      ):
853          SPI_USR_COMMAND = 1 << 31
854          SPI_USR_ADDR = 1 << 30
855          SPI_USR_DUMMY = 1 << 29
856          SPI_USR_MISO = 1 << 28
857          SPI_USR_MOSI = 1 << 27
858          base = self.SPI_REG_BASE
859          SPI_CMD_REG = base + 0x00
860          SPI_ADDR_REG = base + 0x04
861          SPI_USR_REG = base + self.SPI_USR_OFFS
862          SPI_USR1_REG = base + self.SPI_USR1_OFFS
863          SPI_USR2_REG = base + self.SPI_USR2_OFFS
864          SPI_W0_REG = base + self.SPI_W0_OFFS
865          if self.SPI_MOSI_DLEN_OFFS is not None:
866              def set_data_lengths(mosi_bits, miso_bits):
867                  SPI_MOSI_DLEN_REG = base + self.SPI_MOSI_DLEN_OFFS
868                  SPI_MISO_DLEN_REG = base + self.SPI_MISO_DLEN_OFFS
869                  if mosi_bits > 0:
870                      self.write_reg(SPI_MOSI_DLEN_REG, mosi_bits - 1)
871                  if miso_bits > 0:
872                      self.write_reg(SPI_MISO_DLEN_REG, miso_bits - 1)
873                  flags = 0
874                  if dummy_len > 0:
875                      flags |= dummy_len - 1
876                  if addr_len > 0:
877                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
878                  if flags:
879                      self.write_reg(SPI_USR1_REG, flags)
880          else:
881              def set_data_lengths(mosi_bits, miso_bits):
882                  SPI_DATA_LEN_REG = SPI_USR1_REG
883                  SPI_MOSI_BITLEN_S = 17
884                  SPI_MISO_BITLEN_S = 8
885                  mosi_mask = 0 if (mosi_bits == 0) else (mosi_bits - 1)
886                  miso_mask = 0 if (miso_bits == 0) else (miso_bits - 1)
887                  flags = (miso_mask << SPI_MISO_BITLEN_S) | (
888                      mosi_mask << SPI_MOSI_BITLEN_S
889                  )
890                  if dummy_len > 0:
891                      flags |= dummy_len - 1
892                  if addr_len > 0:
893                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
894                  self.write_reg(SPI_DATA_LEN_REG, flags)
895          SPI_CMD_USR = 1 << 18
896          SPI_USR2_COMMAND_LEN_SHIFT = 28
897          SPI_USR_ADDR_LEN_SHIFT = 26
898          if read_bits > 32:
899              raise FatalError(
900                  "Reading more than 32 bits back from a SPI flash "
901                  "operation is unsupported"
902              )
903          if len(data) > 64:
904              raise FatalError(
905                  "Writing more than 64 bytes of data with one SPI "
906                  "command is unsupported"
907              )
908          data_bits = len(data) * 8
909          old_spi_usr = self.read_reg(SPI_USR_REG)
910          old_spi_usr2 = self.read_reg(SPI_USR2_REG)
911          flags = SPI_USR_COMMAND
912          if read_bits > 0:
913              flags |= SPI_USR_MISO
914          if data_bits > 0:
915              flags |= SPI_USR_MOSI
916          if addr_len > 0:
917              flags |= SPI_USR_ADDR
918          if dummy_len > 0:
919              flags |= SPI_USR_DUMMY
920          set_data_lengths(data_bits, read_bits)
921          self.write_reg(SPI_USR_REG, flags)
922          self.write_reg(
923              SPI_USR2_REG, (7 << SPI_USR2_COMMAND_LEN_SHIFT) | spiflash_command
924          )
925          if addr and addr_len > 0:
926              self.write_reg(SPI_ADDR_REG, addr)
927          if data_bits == 0:
928              self.write_reg(SPI_W0_REG, 0)  # clear data register before we read it
929          else:
930              data = pad_to(data, 4, b"\00")  # pad to 32-bit multiple
931              words = struct.unpack("I" * (len(data) // 4), data)
932              next_reg = SPI_W0_REG
933              for word in words:
934                  self.write_reg(next_reg, word)
935                  next_reg += 4
936          self.write_reg(SPI_CMD_REG, SPI_CMD_USR)
937          def wait_done():
938              for _ in range(10):
939                  if (self.read_reg(SPI_CMD_REG) & SPI_CMD_USR) == 0:
940                      return
941              raise FatalError("SPI command did not complete in time")
942          wait_done()
943          status = self.read_reg(SPI_W0_REG)
944          self.write_reg(SPI_USR_REG, old_spi_usr)
945          self.write_reg(SPI_USR2_REG, old_spi_usr2)
946          return status
947      def read_spiflash_sfdp(self, addr, read_bits):
948          CMD_RDSFDP = 0x5A
949          return self.run_spiflash_command(
950              CMD_RDSFDP, read_bits=read_bits, addr=addr, addr_len=24, dummy_len=8
951          )
952      def read_status(self, num_bytes=2):
953          SPIFLASH_RDSR = 0x05
954          SPIFLASH_RDSR2 = 0x35
955          SPIFLASH_RDSR3 = 0x15
956          status = 0
957          shift = 0
958          for cmd in [SPIFLASH_RDSR, SPIFLASH_RDSR2, SPIFLASH_RDSR3][0:num_bytes]:
959              status += self.run_spiflash_command(cmd, read_bits=8) << shift
960              shift += 8
961          return status
962      def write_status(self, new_status, num_bytes=2, set_non_volatile=False):
963          SPIFLASH_WRSR = 0x01
964          SPIFLASH_WRSR2 = 0x31
965          SPIFLASH_WRSR3 = 0x11
966          SPIFLASH_WEVSR = 0x50
967          SPIFLASH_WREN = 0x06
968          SPIFLASH_WRDI = 0x04
969          enable_cmd = SPIFLASH_WREN if set_non_volatile else SPIFLASH_WEVSR
970          if num_bytes == 2:
971              self.run_spiflash_command(enable_cmd)
972              self.run_spiflash_command(SPIFLASH_WRSR, struct.pack("<H", new_status))
973          for cmd in [SPIFLASH_WRSR, SPIFLASH_WRSR2, SPIFLASH_WRSR3][0:num_bytes]:
974              self.run_spiflash_command(enable_cmd)
975              self.run_spiflash_command(cmd, struct.pack("B", new_status & 0xFF))
976              new_status >>= 8
977          self.run_spiflash_command(SPIFLASH_WRDI)
978      def get_crystal_freq(self):
979          uart_div = self.read_reg(self.UART_CLKDIV_REG) & self.UART_CLKDIV_MASK
980          est_xtal = (self._port.baudrate * uart_div) / 1e6 / self.XTAL_CLK_DIVIDER
981          norm_xtal = 40 if est_xtal > 33 else 26
982          if abs(norm_xtal - est_xtal) > 1:
983              print(
984                  "WARNING: Detected crystal freq %.2fMHz is quite different to "
985                  "normalized freq %dMHz. Unsupported crystal in use?"
986                  % (est_xtal, norm_xtal)
987              )
988          return norm_xtal
989      def hard_reset(self):
990          print("Hard resetting via RTS pin...")
991          HardReset(self._port)()
992      def soft_reset(self, stay_in_bootloader):
993          if not self.IS_STUB:
994              if stay_in_bootloader:
995                  return  # ROM bootloader is already in bootloader!
996              else:
997                  self.flash_begin(0, 0)
998                  self.flash_finish(False)
999          else:
1000              if stay_in_bootloader:
1001                  self.flash_begin(0, 0)
1002                  self.flash_finish(True)
1003              elif self.CHIP_NAME != "ESP8266":
1004                  raise FatalError(
1005                      "Soft resetting is currently only supported on ESP8266"
1006                  )
1007              else:
1008                  self.command(self.ESP_RUN_USER_CODE, wait_response=False)
1009      def check_chip_id(self):
1010          try:
1011              chip_id = self.get_chip_id()
1012              if chip_id != self.IMAGE_CHIP_ID:
1013                  print(
1014                      "WARNING: Chip ID {} ({}) doesn't match expected Chip ID {}. "
1015                      "esptool may not work correctly.".format(
1016                          chip_id,
1017                          self.UNSUPPORTED_CHIPS.get(chip_id, "Unknown"),
1018                          self.IMAGE_CHIP_ID,
1019                      )
1020                  )
1021                  self.stub_is_disabled = True
1022          except NotImplementedInROMError:
1023              pass
1024  def slip_reader(port, trace_function):
1025      def detect_panic_handler(input):
1026          guru_meditation = (
1027              rb"G?uru Meditation Error: (?:Core \d panic'ed \(([a-zA-Z ]*)\))?"
1028          )
1029          fatal_exception = rb"F?atal exception \(\d+\): (?:([a-zA-Z ]*)?.*epc)?"
1030          data = re.search(
1031              rb"".join([rb"(?:", guru_meditation, rb"|", fatal_exception, rb")"]),
1032              input,
1033              re.DOTALL,
1034          )
1035          if data is not None:
1036              cause = [
1037                  "({})".format(i.decode("utf-8"))
1038                  for i in [data.group(1), data.group(2)]
1039                  if i is not None
1040              ]
1041              cause = f" {cause[0]}" if len(cause) else ""
1042              msg = f"Guru Meditation Error detected{cause}"
1043              raise FatalError(msg)
1044      partial_packet = None
1045      in_escape = False
1046      successful_slip = False
1047      while True:
1048          waiting = port.inWaiting()
1049          read_bytes = port.read(1 if waiting == 0 else waiting)
1050          if read_bytes == b"":
1051              if partial_packet is None:  # fail due to no data
1052                  msg = (
1053                      "Serial data stream stopped: Possible serial noise or corruption."
1054                      if successful_slip
1055                      else "No serial data received."
1056                  )
1057              else:  # fail during packet transfer
1058                  msg = "Packet content transfer stopped (received {} bytes)".format(
1059                      len(partial_packet)
1060                  )
1061              trace_function(msg)
1062              raise FatalError(msg)
1063          trace_function("Read %d bytes: %s", len(read_bytes), HexFormatter(read_bytes))
1064          for b in read_bytes:
1065              b = bytes([b])
1066              if partial_packet is None:  # waiting for packet header
1067                  if b == b"\xc0":
1068                      partial_packet = b""
1069                  else:
1070                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1071                      remaining_data = port.read(port.inWaiting())
1072                      trace_function(
1073                          "Remaining data in serial buffer: %s",
1074                          HexFormatter(remaining_data),
1075                      )
1076                      detect_panic_handler(read_bytes + remaining_data)
1077                      raise FatalError(
1078                          "Invalid head of packet (0x%s): "
1079                          "Possible serial noise or corruption." % hexify(b)
1080                      )
1081              elif in_escape:  # part-way through escape sequence
1082                  in_escape = False
1083                  if b == b"\xdc":
1084                      partial_packet += b"\xc0"
1085                  elif b == b"\xdd":
1086                      partial_packet += b"\xdb"
1087                  else:
1088                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1089                      remaining_data = port.read(port.inWaiting())
1090                      trace_function(
1091                          "Remaining data in serial buffer: %s",
1092                          HexFormatter(remaining_data),
1093                      )
1094                      detect_panic_handler(read_bytes + remaining_data)
1095                      raise FatalError("Invalid SLIP escape (0xdb, 0x%s)" % (hexify(b)))
1096              elif b == b"\xdb":  # start of escape sequence
1097                  in_escape = True
1098              elif b == b"\xc0":  # end of packet
1099                  trace_function("Received full packet: %s", HexFormatter(partial_packet))
1100                  yield partial_packet
1101                  partial_packet = None
1102                  successful_slip = True
1103              else:  # normal byte in packet
1104                  partial_packet += b
1105  class HexFormatter(object):
1106      def __init__(self, binary_string, auto_split=True):
1107          self._s = binary_string
1108          self._auto_split = auto_split
1109      def __str__(self):
1110          if self._auto_split and len(self._s) > 16:
1111              result = ""
1112              s = self._s
1113              while len(s) > 0:
1114                  line = s[:16]
1115                  ascii_line = "".join(
1116                      c
1117                      if (
1118                          c == " "
1119                          or (c in string.printable and c not in string.whitespace)
1120                      )
1121                      else "."
1122                      for c in line.decode("ascii", "replace")
1123                  )
1124                  s = s[16:]
1125                  result += "\n    %-16s %-16s | %s" % (
1126                      hexify(line[:8], False),
1127                      hexify(line[8:], False),
1128                      ascii_line,
1129                  )
1130              return result
1131          else:
1132              return hexify(self._s, False)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</div>
                </div>
                <div class="column column_space"><pre><code>591          pkt = struct.pack("<I", int(not reboot))
592          self.check_command("leave Flash mode", self.ESP_FLASH_END, pkt)
593      def run(self, reboot=False):
</pre></code></div>
                <div class="column column_space"><pre><code>737          pkt = struct.pack("<I", int(not reboot))
738          self.check_command("leave compressed flash mode", self.ESP_FLASH_DEFL_END, pkt)
739          self.in_bootloader = False
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    