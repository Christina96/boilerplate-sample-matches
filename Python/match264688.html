<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lxc_1.py &amp; ciscoconfparse_mod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lxc_1.py &amp; ciscoconfparse_mod.py
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lxc_1.py (0.48115477%)<th>ciscoconfparse_mod.py (13.483146%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(3676-3689)<td><a href="#" name="0">(155-212)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(2281-2295)<td><a href="#" name="1">(214-261)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import difflib
4 import logging
5 import os
6 import pipes
7 import random
8 import re
9 import shutil
10 import string
11 import tempfile
12 import textwrap
13 import time
14 import urllib.parse
15 import salt.config
16 import salt.utils.args
17 import salt.utils.cloud
18 import salt.utils.data
19 import salt.utils.dictupdate
20 import salt.utils.files
21 import salt.utils.functools
22 import salt.utils.hashutils
23 import salt.utils.network
24 import salt.utils.odict
25 import salt.utils.path
26 import salt.utils.stringutils
27 from salt.exceptions import CommandExecutionError, SaltInvocationError
28 from salt.utils.versions import LooseVersion as _LooseVersion
29 log = logging.getLogger(__name__)
30 __func_alias__ = {"list_": "list", "ls_": "ls"}
31 __virtualname__ = "lxc"
32 DEFAULT_NIC = "eth0"
33 DEFAULT_BR = "br0"
34 SEED_MARKER = "/lxc.initial_seed"
35 EXEC_DRIVER = "lxc-attach"
36 DEFAULT_PATH = "/var/lib/lxc"
37 _marker = object()
38 def __virtual__():
39     if salt.utils.path.which("lxc-start"):
40         return __virtualname__
41     return (
42         False,
43         "The lxc execution module cannot be loaded: the lxc-start binary is not in the"
44         " path.",
45     )
46 def get_root_path(path):
47     if not path:
48         path = __opts__.get("lxc.root_path", DEFAULT_PATH)
49     return path
50 def version():
51     k = "lxc.version"
52     if not __context__.get(k, None):
53         cversion = __salt__["cmd.run_all"]("lxc-info --version")
54         if not cversion["retcode"]:
55             ver = _LooseVersion(cversion["stdout"])
56             if ver &lt; _LooseVersion("1.0"):
57                 raise CommandExecutionError("LXC should be at least 1.0")
58             __context__[k] = "{}".format(ver)
59     return __context__.get(k, None)
60 def _clear_context():
61     for var in [x for x in __context__ if x.startswith("lxc.")]:
62         log.trace("Clearing __context__['%s']", var)
63         __context__.pop(var, None)
64 def _ip_sort(ip):
65     idx = "001"
66     if ip == "127.0.0.1":
67         idx = "200"
68     if ip == "::1":
69         idx = "201"
70     elif "::" in ip:
71         idx = "100"
72     return "{}___{}".format(idx, ip)
73 def search_lxc_bridges():
74     bridges = __context__.get("lxc.bridges", None)
75     if not bridges:
76         bridges = set()
77         running_bridges = set()
78         bridges.add(DEFAULT_BR)
79         try:
80             output = __salt__["cmd.run_all"]("brctl show")
81             for line in output["stdout"].splitlines()[1:]:
82                 if not line.startswith(" "):
83                     running_bridges.add(line.split()[0].strip())
84         except (SaltInvocationError, CommandExecutionError):
85             pass
86         for ifc, ip in __grains__.get("ip_interfaces", {}).items():
87             if ifc in running_bridges:
88                 bridges.add(ifc)
89             elif os.path.exists("/sys/devices/virtual/net/{}/bridge".format(ifc)):
90                 bridges.add(ifc)
91         bridges = list(bridges)
92         def sort_bridges(a):
93             pref = "z"
94             if "lxc" in a:
95                 pref = "a"
96             elif "br0" == a:
97                 pref = "c"
98             return "{}_{}".format(pref, a)
99         bridges.sort(key=sort_bridges)
100         __context__["lxc.bridges"] = bridges
101     return bridges
102 def search_lxc_bridge():
103     return search_lxc_bridges()[0]
104 def _get_salt_config(config, **kwargs):
105     if not config:
106         config = kwargs.get("minion", {})
107     if not config:
108         config = {}
109     config.setdefault(
110         "master", kwargs.get("master", __opts__.get("master", __opts__["id"]))
111     )
112     config.setdefault(
113         "master_port",
114         kwargs.get(
115             "master_port",
116             __opts__.get("master_port", __opts__.get("ret_port", __opts__.get("4506"))),
117         ),
118     )
119     if not config["master"]:
120         config = {}
121     return config
122 def cloud_init_interface(name, vm_=None, **kwargs):
123     if vm_ is None:
124         vm_ = {}
125     vm_ = copy.deepcopy(vm_)
126     vm_ = salt.utils.dictupdate.update(vm_, kwargs)
127     profile_data = copy.deepcopy(vm_.get("lxc_profile", vm_.get("profile", {})))
128     if not isinstance(profile_data, (dict, (str,))):
129         profile_data = {}
130     profile = get_container_profile(profile_data)
131     def _cloud_get(k, default=None):
132         return vm_.get(k, profile.get(k, default))
133     if name is None:
134         name = vm_["name"]
135     default_template = ""
136     if __grains__.get("os", "") in ["Ubuntu"]:
137         default_template = "ubuntu"
138     image = _cloud_get("image")
139     if not image:
140         _cloud_get("template", default_template)
141     backing = _cloud_get("backing", "dir")
142     if image:
143         profile["template"] = image
144     vgname = _cloud_get("vgname", None)
145     if vgname:
146         profile["vgname"] = vgname
147     if backing:
148         profile["backing"] = backing
149     snapshot = _cloud_get("snapshot", False)
150     autostart = bool(_cloud_get("autostart", True))
151     dnsservers = _cloud_get("dnsservers", [])
152     dns_via_dhcp = _cloud_get("dns_via_dhcp", True)
153     password = _cloud_get("password", "s3cr3t")
154     password_encrypted = _cloud_get("password_encrypted", False)
155     fstype = _cloud_get("fstype", None)
156     lvname = _cloud_get("lvname", None)
157     thinpool = _cloud_get("thinpool", None)
158     pub_key = _cloud_get("pub_key", None)
159     priv_key = _cloud_get("priv_key", None)
160     size = _cloud_get("size", "20G")
161     script = _cloud_get("script", None)
162     script_args = _cloud_get("script_args", None)
163     users = _cloud_get("users", None)
164     if users is None:
165         users = []
166     ssh_username = _cloud_get("ssh_username", None)
167     if ssh_username and (ssh_username not in users):
168         users.append(ssh_username)
169     network_profile = _cloud_get("network_profile", None)
170     nic_opts = kwargs.get("nic_opts", None)
171     netmask = _cloud_get("netmask", "24")
172     path = _cloud_get("path", None)
173     bridge = _cloud_get("bridge", None)
174     gateway = _cloud_get("gateway", None)
175     unconditional_install = _cloud_get("unconditional_install", False)
176     force_install = _cloud_get("force_install", True)
177     config = _get_salt_config(_cloud_get("config", {}), **vm_)
178     default_nic = _cloud_get("default_nic", DEFAULT_NIC)
179     if not isinstance(nic_opts, dict):
180         nic_opts = salt.utils.odict.OrderedDict()
181     eth0 = nic_opts.setdefault(default_nic, salt.utils.odict.OrderedDict())
182     if not isinstance(nic_opts, salt.utils.odict.OrderedDict):
183         bnic_opts = salt.utils.odict.OrderedDict()
184         bnic_opts.update(nic_opts)
185         nic_opts = bnic_opts
186     gw = None
187     bridge = _cloud_get("bridge", None)
188     ip = _cloud_get("ip", None)
189     mac = _cloud_get("mac", None)
190     if ip:
191         fullip = ip
192         if netmask:
193             fullip += "/{}".format(netmask)
194         eth0["ipv4"] = fullip
195         if mac is not None:
196             eth0["mac"] = mac
197     for ix, iopts in enumerate(_cloud_get("additional_ips", [])):
198         ifh = "eth{}".format(ix + 1)
199         ethx = nic_opts.setdefault(ifh, {})
200         if gw is None:
201             gw = iopts.get("gateway", ethx.get("gateway", None))
202             if gw:
203                 eth0.pop("gateway", None)
204                 gateway = None
205                 ethx["gateway"] = gw
206         elink = iopts.get("link", ethx.get("link", None))
207         if elink:
208             ethx["link"] = elink
209         aip = iopts.get("ipv4", iopts.get("ip", None))
210         if aip:
211             ethx["ipv4"] = aip
212         nm = iopts.get("netmask", "")
213         if nm:
214             ethx["ipv4"] += "/{}".format(nm)
215         for i in ("mac", "hwaddr"):
216             if i in iopts:
217                 ethx["mac"] = iopts[i]
218                 break
219         if "mac" not in ethx:
220             ethx["mac"] = salt.utils.network.gen_mac()
221     gw = None
222     for ethx in [a for a in nic_opts]:
223         ndata = nic_opts[ethx]
224         if gw:
225             ndata.pop("gateway", None)
226         if "gateway" in ndata:
227             gw = ndata["gateway"]
228             gateway = None
229     if bridge:
230         eth0["link"] = bridge
231     if gateway:
232         eth0["gateway"] = gateway
233     lxc_init_interface = {}
234     lxc_init_interface["name"] = name
235     lxc_init_interface["config"] = config
236     lxc_init_interface["memory"] = _cloud_get("memory", 0)  # nolimit
237     lxc_init_interface["pub_key"] = pub_key
238     lxc_init_interface["priv_key"] = priv_key
239     lxc_init_interface["nic_opts"] = nic_opts
240     for clone_from in ["clone_from", "clone", "from_container"]:
241         lxc_init_interface["clone_from"] = _cloud_get(clone_from, None)
242         if lxc_init_interface["clone_from"] is not None:
243             break
244     lxc_init_interface["profile"] = profile
245     lxc_init_interface["snapshot"] = snapshot
246     lxc_init_interface["dnsservers"] = dnsservers
247     lxc_init_interface["fstype"] = fstype
248     lxc_init_interface["path"] = path
249     lxc_init_interface["vgname"] = vgname
250     lxc_init_interface["size"] = size
251     lxc_init_interface["lvname"] = lvname
252     lxc_init_interface["thinpool"] = thinpool
253     lxc_init_interface["force_install"] = force_install
254     lxc_init_interface["unconditional_install"] = unconditional_install
255     lxc_init_interface["bootstrap_url"] = script
256     lxc_init_interface["bootstrap_args"] = script_args
257     lxc_init_interface["bootstrap_shell"] = _cloud_get("bootstrap_shell", "sh")
258     lxc_init_interface["bootstrap_delay"] = _cloud_get("bootstrap_delay", None)
259     lxc_init_interface["autostart"] = autostart
260     lxc_init_interface["users"] = users
261     lxc_init_interface["password"] = password
262     lxc_init_interface["password_encrypted"] = password_encrypted
263     lxc_init_interface["network_profile"] = network_profile
264     for i in ["cpu", "cpuset", "cpushare"]:
265         if _cloud_get(i, None):
266             try:
267                 lxc_init_interface[i] = vm_[i]
268             except KeyError:
269                 lxc_init_interface[i] = profile[i]
270     return lxc_init_interface
271 def _get_profile(key, name, **kwargs):
272     if isinstance(name, dict):
273         profilename = name.pop("name", None)
274         return _get_profile(key, profilename, **name)
275     if name is None:
276         profile_match = {}
277     else:
278         profile_match = __salt__["config.get"](
279             "lxc.{1}:{0}".format(name, key), default=None, merge="recurse"
280         )
281         if profile_match is None:
282             profile_match = {}
283     if not isinstance(profile_match, dict):
284         raise CommandExecutionError("lxc.{} must be a dictionary".format(key))
285     overrides = salt.utils.args.clean_kwargs(**copy.deepcopy(kwargs))
286     profile_match = salt.utils.dictupdate.update(
287         copy.deepcopy(profile_match), overrides
288     )
289     return profile_match
290 def get_container_profile(name=None, **kwargs):
291     profile = _get_profile("container_profile", name, **kwargs)
292     return profile
293 def get_network_profile(name=None, **kwargs):
294     profile = _get_profile("network_profile", name, **kwargs)
295     return profile
296 def _rand_cpu_str(cpu):
297     cpu = int(cpu)
298     avail = __salt__["status.nproc"]()
299     if cpu &lt; avail:
300         return "0-{}".format(avail)
301     to_set = set()
302     while len(to_set) &lt; cpu:
303         choice = random.randint(0, avail - 1)
304         if choice not in to_set:
305             to_set.add(str(choice))
306     return ",".join(sorted(to_set))
307 def _network_conf(conf_tuples=None, **kwargs):
308     nic = kwargs.get("network_profile", None)
309     ret = []
310     nic_opts = kwargs.get("nic_opts", {})
311     if nic_opts is None:
312         nic_opts = {}
313     if not conf_tuples:
314         conf_tuples = []
315     old = _get_veths(conf_tuples)
316     if not old:
317         old = {}
318     if nic and isinstance(nic, ((str,), dict)):
319         nicp = get_network_profile(nic)
320     else:
321         nicp = {}
322     if DEFAULT_NIC not in nicp:
323         nicp[DEFAULT_NIC] = {}
324     kwargs = copy.deepcopy(kwargs)
325     gateway = kwargs.pop("gateway", None)
326     bridge = kwargs.get("bridge", None)
327     if nic_opts:
328         for dev, args in nic_opts.items():
329             ethx = nicp.setdefault(dev, {})
330             try:
331                 ethx = salt.utils.dictupdate.update(ethx, args)
332             except AttributeError:
333                 raise SaltInvocationError("Invalid nic_opts configuration")
334     ifs = [a for a in nicp]
335     ifs += [a for a in old if a not in nicp]
336     ifs.sort()
337     gateway_set = False
338     for dev in ifs:
339         args = nicp.get(dev, {})
340         opts = nic_opts.get(dev, {}) if nic_opts else {}
341         old_if = old.get(dev, {})
342         disable = opts.get("disable", args.get("disable", False))
343         if disable:
344             continue
345         mac = opts.get(
346             "mac", opts.get("hwaddr", args.get("mac", args.get("hwaddr", "")))
347         )
348         type_ = opts.get("type", args.get("type", ""))
349         flags = opts.get("flags", args.get("flags", ""))
350         link = opts.get("link", args.get("link", ""))
351         ipv4 = opts.get("ipv4", args.get("ipv4", ""))
352         ipv6 = opts.get("ipv6", args.get("ipv6", ""))
353         infos = salt.utils.odict.OrderedDict(
354             [
355                 (
356                     "lxc.network.type",
357                     {
358                         "test": not type_,
359                         "value": type_,
360                         "old": old_if.get("lxc.network.type"),
361                         "default": "veth",
362                     },
363                 ),
364                 (
365                     "lxc.network.name",
366                     {"test": False, "value": dev, "old": dev, "default": dev},
367                 ),
368                 (
369                     "lxc.network.flags",
370                     {
371                         "test": not flags,
372                         "value": flags,
373                         "old": old_if.get("lxc.network.flags"),
374                         "default": "up",
375                     },
376                 ),
377                 (
378                     "lxc.network.link",
379                     {
380                         "test": not link,
381                         "value": link,
382                         "old": old_if.get("lxc.network.link"),
383                         "default": search_lxc_bridge(),
384                     },
385                 ),
386                 (
387                     "lxc.network.hwaddr",
388                     {
389                         "test": not mac,
390                         "value": mac,
391                         "old": old_if.get("lxc.network.hwaddr"),
392                         "default": salt.utils.network.gen_mac(),
393                     },
394                 ),
395                 (
396                     "lxc.network.ipv4",
397                     {
398                         "test": not ipv4,
399                         "value": ipv4,
400                         "old": old_if.get("lxc.network.ipv4", ""),
401                         "default": None,
402                     },
403                 ),
404                 (
405                     "lxc.network.ipv6",
406                     {
407                         "test": not ipv6,
408                         "value": ipv6,
409                         "old": old_if.get("lxc.network.ipv6", ""),
410                         "default": None,
411                     },
412                 ),
413             ]
414         )
415         for info in list(infos.keys()):
416             bundle = infos[info]
417             if bundle["test"]:
418                 if bundle["old"]:
419                     bundle["value"] = bundle["old"]
420                 elif bundle["default"]:
421                     bundle["value"] = bundle["default"]
422         for info, data in infos.items():
423             if data["value"]:
424                 ret.append({info: data["value"]})
425         for key, val in args.items():
426             if key == "link" and bridge:
427                 val = bridge
428             val = opts.get(key, val)
429             if key in [
430                 "type",
431                 "flags",
432                 "name",
433                 "gateway",
434                 "mac",
435                 "link",
436                 "ipv4",
437                 "ipv6",
438             ]:
439                 continue
440             ret.append({"lxc.network.{}".format(key): val})
441         if not gateway:
442             gateway = args.get("gateway", None)
443         if gateway is not None and not gateway_set:
444             ret.append({"lxc.network.ipv4.gateway": gateway})
445             gateway_set = True
446     if gateway is not None and not gateway_set:
447         ret.append({"lxc.network.ipv4.gateway": gateway})
448         gateway_set = True
449     new = _get_veths(ret)
450     for iface in [a for a in new]:
451         ndata = new[iface]
452         nmac = ndata.get("lxc.network.hwaddr", "")
453         ntype = ndata.get("lxc.network.type", "")
454         omac, otype = "", ""
455         if iface in old:
456             odata = old[iface]
457             omac = odata.get("lxc.network.hwaddr", "")
458             otype = odata.get("lxc.network.type", "")
459         if otype and not ntype:
460             ntype = otype
461         if not ntype:
462             ntype = "veth"
463         new[iface]["lxc.network.type"] = ntype
464         if omac and not nmac:
465             new[iface]["lxc.network.hwaddr"] = omac
466     ret = []
467     for val in new.values():
468         for row in val:
469             ret.append(salt.utils.odict.OrderedDict([(row, val[row])]))
470     if (
471         _LooseVersion(version()) &lt;= _LooseVersion("1.0.7")
472         and True not in ["lxc.network.ipv4.gateway" in a for a in ret]
473         and True in ["lxc.network.ipv4" in a for a in ret]
474     ):
475         ret.append({"lxc.network.ipv4.gateway": "auto"})
476     return ret
477 def _get_lxc_default_data(**kwargs):
478     kwargs = copy.deepcopy(kwargs)
479     ret = {}
480     for k in ["utsname", "rootfs"]:
481         val = kwargs.get(k, None)
482         if val is not None:
483             ret["lxc.{}".format(k)] = val
484     autostart = kwargs.get("autostart")
485     if autostart is None:
486         autostart = True
487     if autostart != "keep":
488         if autostart:
489             ret["lxc.start.auto"] = "1"
490         else:
491             ret["lxc.start.auto"] = "0"
492     memory = kwargs.get("memory")
493     if memory is not None:
494         ret["lxc.cgroup.memory.limit_in_bytes"] = memory * 1024 * 1024
495     cpuset = kwargs.get("cpuset")
496     if cpuset:
497         ret["lxc.cgroup.cpuset.cpus"] = cpuset
498     cpushare = kwargs.get("cpushare")
499     cpu = kwargs.get("cpu")
500     if cpushare:
501         ret["lxc.cgroup.cpu.shares"] = cpushare
502     if cpu and not cpuset:
503         ret["lxc.cgroup.cpuset.cpus"] = _rand_cpu_str(cpu)
504     return ret
505 def _config_list(conf_tuples=None, only_net=False, **kwargs):
506     only_net = bool(only_net)
507     if not conf_tuples:
508         conf_tuples = []
509     kwargs = copy.deepcopy(kwargs)
510     ret = []
511     if not only_net:
512         default_data = _get_lxc_default_data(**kwargs)
513         for k, val in default_data.items():
514             ret.append({k: val})
515     net_datas = _network_conf(conf_tuples=conf_tuples, **kwargs)
516     ret.extend(net_datas)
517     return ret
518 def _get_veths(net_data):
519     if isinstance(net_data, dict):
520         net_data = list(net_data.items())
521     nics = salt.utils.odict.OrderedDict()
522     current_nic = salt.utils.odict.OrderedDict()
523     no_names = True
524     for item in net_data:
525         if item and isinstance(item, dict):
526             item = list(item.items())[0]
527         elif isinstance(item, str):
528             sitem = item.strip()
529             if sitem.startswith("#") or not sitem:
530                 continue
531             elif "=" in item:
532                 item = tuple(a.strip() for a in item.split("=", 1))
533         if item[0] == "lxc.network.type":
534             current_nic = salt.utils.odict.OrderedDict()
535         if item[0] == "lxc.network.name":
536             no_names = False
537             nics[item[1].strip()] = current_nic
538         current_nic[item[0].strip()] = item[1].strip()
539     if no_names and current_nic:
540         nics[DEFAULT_NIC] = current_nic
541     return nics
542 class _LXCConfig:
543     pattern = re.compile(r"^(\S+)(\s*)(=)(\s*)(.*)")
544     non_interpretable_pattern = re.compile(r"^((#.*)|(\s*))$")
545     def __init__(self, **kwargs):
546         kwargs = copy.deepcopy(kwargs)
547         self.name = kwargs.pop("name", None)
548         path = get_root_path(kwargs.get("path", None))
549         self.data = []
550         if self.name:
551             self.path = os.path.join(path, self.name, "config")
552             if os.path.isfile(self.path):
553                 with salt.utils.files.fopen(self.path) as fhr:
554                     for line in salt.utils.data.decode(fhr.readlines()):
555                         match = self.pattern.findall(line.strip())
556                         if match:
557                             self.data.append((match[0][0], match[0][-1]))
558                         match = self.non_interpretable_pattern.findall(line.strip())
559                         if match:
560                             self.data.append(("", match[0][0]))
561         else:
562             self.path = None
563         def _replace(key, val):
564             if val:
565                 self._filter_data(key)
566                 self.data.append((key, val))
567         default_data = _get_lxc_default_data(**kwargs)
568         for key, val in default_data.items():
569             _replace(key, val)
570         old_net = self._filter_data("lxc.network")
571         net_datas = _network_conf(conf_tuples=old_net, **kwargs)
572         if net_datas:
573             for row in net_datas:
574                 self.data.extend(list(row.items()))
575         for idx in ["lxc.cgroup.memory.limit_in_bytes"]:
576             if not default_data.get(idx):
577                 self._filter_data(idx)
578     def as_string(self):
579         chunks = (
580             "{0[0]}{1}{0[1]}".format(item, (" = " if item[0] else ""))
581             for item in self.data
582         )
583         return "\n".join(chunks) + "\n"
584     def write(self):
585         if self.path:
586             content = self.as_string()
587             with salt.utils.files.fopen(self.path, "w") as fic:
588                 fic.write(salt.utils.stringutils.to_str(content))
589                 fic.flush()
590     def tempfile(self):
591         ntf = tempfile.NamedTemporaryFile()
592         ntf.write(self.as_string())
593         ntf.flush()
594         return ntf
595     def _filter_data(self, pattern):
596         removed = []
597         filtered = []
598         for param in self.data:
599             if not param[0].startswith(pattern):
600                 filtered.append(param)
601             else:
602                 removed.append(param)
603         self.data = filtered
604         return removed
605 def _get_base(**kwargs):
606     profile = get_container_profile(copy.deepcopy(kwargs.get("profile")))
607     kw_overrides = copy.deepcopy(kwargs)
608     def select(key, default=None):
609         kw_overrides_match = kw_overrides.pop(key, _marker)
610         profile_match = profile.pop(key, default)
611         if kw_overrides_match is _marker:
612             return profile_match
613         return kw_overrides_match
614     template = select("template")
615     image = select("image")
616     vgname = select("vgname")
617     path = kwargs.get("path", None)
618     for param in ("path", "image", "vgname", "template"):
619         kwargs.pop(param, None)
620     if image:
621         proto = urllib.parse.urlparse(image).scheme
622         img_tar = __salt__["cp.cache_file"](image)
623         img_name = os.path.basename(img_tar)
624         hash_ = salt.utils.hashutils.get_hash(
625             img_tar, __salt__["config.get"]("hash_type")
626         )
627         name = "__base_{}_{}_{}".format(proto, img_name, hash_)
628         if not exists(name, path=path):
629             create(
630                 name, template=template, image=image, path=path, vgname=vgname, **kwargs
631             )
632             if vgname:
633                 rootfs = os.path.join("/dev", vgname, name)
634                 edit_conf(
635                     info(name, path=path)["config"],
636                     out_format="commented",
637                     **{"lxc.rootfs": rootfs}
638                 )
639         return name
640     elif template:
641         name = "__base_{}".format(template)
642         if not exists(name, path=path):
643             create(
644                 name, template=template, image=image, path=path, vgname=vgname, **kwargs
645             )
646             if vgname:
647                 rootfs = os.path.join("/dev", vgname, name)
648                 edit_conf(
649                     info(name, path=path)["config"],
650                     out_format="commented",
651                     **{"lxc.rootfs": rootfs}
652                 )
653         return name
654     return ""
655 def init(
656     name,
657     config=None,
658     cpuset=None,
659     cpushare=None,
660     memory=None,
661     profile=None,
662     network_profile=None,
663     nic_opts=None,
664     cpu=None,
665     autostart=True,
666     password=None,
667     password_encrypted=None,
668     users=None,
669     dnsservers=None,
670     searchdomains=None,
671     bridge=None,
672     gateway=None,
673     pub_key=None,
674     priv_key=None,
675     force_install=False,
676     unconditional_install=False,
677     bootstrap_delay=None,
678     bootstrap_args=None,
679     bootstrap_shell=None,
680     bootstrap_url=None,
681     **kwargs
682 ):
683     ret = {"name": name, "changes": {}}
684     profile = get_container_profile(copy.deepcopy(profile))
685     if not network_profile:
686         network_profile = profile.get("network_profile")
687     if not network_profile:
688         network_profile = DEFAULT_NIC
689     changes_dict = {"init": []}
690     changes = changes_dict.get("init")
691     if users is None:
692         users = []
693     dusers = ["root"]
694     for user in dusers:
695         if user not in users:
696             users.append(user)
697     kw_overrides = copy.deepcopy(kwargs)
698     def select(key, default=None):
699         kw_overrides_match = kw_overrides.pop(key, _marker)
700         profile_match = profile.pop(key, default)
701         if kw_overrides_match is _marker:
702             return profile_match
703         return kw_overrides_match
704     path = select("path")
705     bpath = get_root_path(path)
706     state_pre = state(name, path=path)
707     tvg = select("vgname")
708     vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
709     start_ = select("start", True)
710     autostart = select("autostart", autostart)
711     seed = select("seed", True)
712     install = select("install", True)
713     seed_cmd = select("seed_cmd")
714     salt_config = _get_salt_config(config, **kwargs)
715     approve_key = select("approve_key", True)
716     clone_from = select("clone_from")
717     if vgname and not clone_from:
718         try:
719             kwargs["vgname"] = vgname
720             clone_from = _get_base(profile=profile, **kwargs)
721         except (SaltInvocationError, CommandExecutionError) as exc:
722             ret["comment"] = exc.strerror
723             if changes:
724                 ret["changes"] = changes_dict
725             return ret
726         if not kwargs.get("snapshot") is False:
727             kwargs["snapshot"] = True
728     does_exist = exists(name, path=path)
729     to_reboot = False
730     remove_seed_marker = False
731     if does_exist:
732         pass
733     elif clone_from:
734         remove_seed_marker = True
735         try:
736             clone(name, clone_from, profile=profile, **kwargs)
737             changes.append({"create": "Container cloned"})
738         except (SaltInvocationError, CommandExecutionError) as exc:
739             if "already exists" in exc.strerror:
740                 changes.append({"create": "Container already exists"})
741             else:
742                 ret["result"] = False
743                 ret["comment"] = exc.strerror
744                 if changes:
745                     ret["changes"] = changes_dict
746                 return ret
747         cfg = _LXCConfig(
748             name=name,
749             network_profile=network_profile,
750             nic_opts=nic_opts,
751             bridge=bridge,
752             path=path,
753             gateway=gateway,
754             autostart=autostart,
755             cpuset=cpuset,
756             cpushare=cpushare,
757             memory=memory,
758         )
759         old_chunks = read_conf(cfg.path, out_format="commented")
760         cfg.write()
761         chunks = read_conf(cfg.path, out_format="commented")
762         if old_chunks != chunks:
763             to_reboot = True
764     else:
765         remove_seed_marker = True
766         cfg = _LXCConfig(
767             network_profile=network_profile,
768             nic_opts=nic_opts,
769             cpuset=cpuset,
770             path=path,
771             bridge=bridge,
772             gateway=gateway,
773             autostart=autostart,
774             cpushare=cpushare,
775             memory=memory,
776         )
777         with cfg.tempfile() as cfile:
778             try:
779                 create(name, config=cfile.name, profile=profile, **kwargs)
780                 changes.append({"create": "Container created"})
781             except (SaltInvocationError, CommandExecutionError) as exc:
782                 if "already exists" in exc.strerror:
783                     changes.append({"create": "Container already exists"})
784                 else:
785                     ret["comment"] = exc.strerror
786                     if changes:
787                         ret["changes"] = changes_dict
788                     return ret
789         cpath = os.path.join(bpath, name, "config")
790         old_chunks = []
791         if os.path.exists(cpath):
792             old_chunks = read_conf(cpath, out_format="commented")
793         new_cfg = _config_list(
794             conf_tuples=old_chunks,
795             cpu=cpu,
796             network_profile=network_profile,
797             nic_opts=nic_opts,
798             bridge=bridge,
799             cpuset=cpuset,
800             cpushare=cpushare,
801             memory=memory,
802         )
803         if new_cfg:
804             edit_conf(cpath, out_format="commented", lxc_config=new_cfg)
805         chunks = read_conf(cpath, out_format="commented")
806         if old_chunks != chunks:
807             to_reboot = True
808     cfg = _LXCConfig(
809         name=name,
810         network_profile=network_profile,
811         nic_opts=nic_opts,
812         bridge=bridge,
813         path=path,
814         gateway=gateway,
815         autostart=autostart,
816         cpuset=cpuset,
817         cpushare=cpushare,
818         memory=memory,
819     )
820     old_chunks = []
821     if os.path.exists(cfg.path):
822         old_chunks = read_conf(cfg.path, out_format="commented")
823     cfg.write()
824     chunks = read_conf(cfg.path, out_format="commented")
825     if old_chunks != chunks:
826         changes.append({"config": "Container configuration updated"})
827         to_reboot = True
828     if to_reboot:
829         try:
830             stop(name, path=path)
831         except (SaltInvocationError, CommandExecutionError) as exc:
832             ret["comment"] = "Unable to stop container: {}".format(exc)
833             if changes:
834                 ret["changes"] = changes_dict
835             return ret
836     if not does_exist or (does_exist and state(name, path=path) != "running"):
837         try:
838             start(name, path=path)
839         except (SaltInvocationError, CommandExecutionError) as exc:
840             ret["comment"] = "Unable to stop container: {}".format(exc)
841             if changes:
842                 ret["changes"] = changes_dict
843             return ret
844     if remove_seed_marker:
845         run(
846             name,
847             "rm -f '{}'".format(SEED_MARKER),
848             path=path,
849             chroot_fallback=False,
850             python_shell=False,
851         )
852     if ret.get("result", True) and password:
853         gid = "/.lxc.initial_pass"
854         gids = [gid, "/lxc.initial_pass", "/.lxc.{}.initial_pass".format(name)]
855         if not any(
856             retcode(
857                 name,
858                 'test -e "{}"'.format(x),
859                 chroot_fallback=True,
860                 path=path,
861                 ignore_retcode=True,
862             )
863             == 0
864             for x in gids
865         ):
866             for default_user in ["ubuntu"]:
867                 if (
868                     default_user not in users
869                     and retcode(
870                         name,
871                         "id {}".format(default_user),
872                         python_shell=False,
873                         path=path,
874                         chroot_fallback=True,
875                         ignore_retcode=True,
876                     )
877                     == 0
878                 ):
879                     users.append(default_user)
880             for user in users:
881                 try:
882                     cret = set_password(
883                         name,
884                         users=[user],
885                         path=path,
886                         password=password,
887                         encrypted=password_encrypted,
888                     )
889                 except (SaltInvocationError, CommandExecutionError) as exc:
890                     msg = "{}: Failed to set password".format(user) + exc.strerror
891                     if user == "root":
892                         ret["comment"] = msg
893                         ret["result"] = False
894                     else:
895                         log.debug(msg)
896             if ret.get("result", True):
897                 changes.append({"password": "Password(s) updated"})
898                 if (
899                     retcode(
900                         name,
901                         'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
902                         path=path,
903                         chroot_fallback=True,
904                         ignore_retcode=True,
905                     )
906                     != 0
907                 ):
908                     ret["comment"] = "Failed to set password marker"
909                     changes[-1]["password"] += ". " + ret["comment"] + "."
910                     ret["result"] = False
911     if ret.get("result", True) and dnsservers:
912         gid = "/.lxc.initial_dns"
913         gids = [gid, "/lxc.initial_dns", "/lxc.{}.initial_dns".format(name)]
914         if not any(
915             retcode(
916                 name,
917                 'test -e "{}"'.format(x),
918                 chroot_fallback=True,
919                 path=path,
920                 ignore_retcode=True,
921             )
922             == 0
923             for x in gids
924         ):
925             try:
926                 set_dns(
927                     name, path=path, dnsservers=dnsservers, searchdomains=searchdomains
928                 )
929             except (SaltInvocationError, CommandExecutionError) as exc:
930                 ret["comment"] = "Failed to set DNS: " + exc.strerror
931                 ret["result"] = False
932             else:
933                 changes.append({"dns": "DNS updated"})
934                 if (
935                     retcode(
936                         name,
937                         'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
938                         chroot_fallback=True,
939                         path=path,
940                         ignore_retcode=True,
941                     )
942                     != 0
943                 ):
944                     ret["comment"] = "Failed to set DNS marker"
945                     changes[-1]["dns"] += ". " + ret["comment"] + "."
946                     ret["result"] = False
947     if remove_seed_marker:
948         run(name, "rm -f '{}'".format(SEED_MARKER), path=path, python_shell=False)
949     gid = "/.lxc.initial_seed"
950     gids = [gid, "/lxc.initial_seed"]
951     if (
952         any(
953             retcode(
954                 name,
955                 "test -e {}".format(x),
956                 path=path,
957                 chroot_fallback=True,
958                 ignore_retcode=True,
959             )
960             == 0
961             for x in gids
962         )
963         or not ret.get("result", True)
964     ):
965         pass
966     elif seed or seed_cmd:
967         if seed:
968             try:
969                 result = bootstrap(
970                     name,
971                     config=salt_config,
972                     path=path,
973                     approve_key=approve_key,
974                     pub_key=pub_key,
975                     priv_key=priv_key,
976                     install=install,
977                     force_install=force_install,
978                     unconditional_install=unconditional_install,
979                     bootstrap_delay=bootstrap_delay,
980                     bootstrap_url=bootstrap_url,
981                     bootstrap_shell=bootstrap_shell,
982                     bootstrap_args=bootstrap_args,
983                 )
984             except (SaltInvocationError, CommandExecutionError) as exc:
985                 ret["comment"] = "Bootstrap failed: " + exc.strerror
986                 ret["result"] = False
987             else:
988                 if not result:
989                     ret[
990                         "comment"
991                     ] = "Bootstrap failed, see minion log for more information"
992                     ret["result"] = False
993                 else:
994                     changes.append({"bootstrap": "Container successfully bootstrapped"})
995         elif seed_cmd:
996             try:
997                 result = __salt__[seed_cmd](
998                     info(name, path=path)["rootfs"], name, salt_config
999                 )
1000             except (SaltInvocationError, CommandExecutionError) as exc:
1001                 ret["comment"] = "Bootstrap via seed_cmd '{}' failed: {}".format(
1002                     seed_cmd, exc.strerror
1003                 )
1004                 ret["result"] = False
1005             else:
1006                 if not result:
1007                     ret["comment"] = (
1008                         "Bootstrap via seed_cmd '{}' failed, "
1009                         "see minion log for more information ".format(seed_cmd)
1010                     )
1011                     ret["result"] = False
1012                 else:
1013                     changes.append(
1014                         {
1015                             "bootstrap": (
1016                                 "Container successfully bootstrapped "
1017                                 "using seed_cmd '{}'".format(seed_cmd)
1018                             )
1019                         }
1020                     )
1021     if ret.get("result", True) and not start_:
1022         try:
1023             stop(name, path=path)
1024         except (SaltInvocationError, CommandExecutionError) as exc:
1025             ret["comment"] = "Unable to stop container: {}".format(exc)
1026             ret["result"] = False
1027     state_post = state(name, path=path)
1028     if state_pre != state_post:
1029         changes.append({"state": {"old": state_pre, "new": state_post}})
1030     if ret.get("result", True):
1031         ret["comment"] = "Container '{}' successfully initialized".format(name)
1032         ret["result"] = True
1033     if changes:
1034         ret["changes"] = changes_dict
1035     return ret
1036 def cloud_init(name, vm_=None, **kwargs):
1037     init_interface = cloud_init_interface(name, vm_, **kwargs)
1038     name = init_interface.pop("name", name)
1039     return init(name, **init_interface)
1040 def images(dist=None):
1041     out = __salt__["cmd.run_stdout"](
1042         "lxc-create -n __imgcheck -t download -- --list", ignore_retcode=True
1043     )
1044     if "DIST" not in out:
1045         raise CommandExecutionError(
1046             "Unable to run the 'download' template script. Is it installed?"
1047         )
1048     ret = {}
1049     passed_header = False
1050     for line in out.splitlines():
1051         try:
1052             distro, release, arch, variant, build_time = line.split()
1053         except ValueError:
1054             continue
1055         if not passed_header:
1056             if distro == "DIST":
1057                 passed_header = True
1058             continue
1059         dist_list = ret.setdefault(distro, [])
1060         dist_list.append(
1061             {
1062                 "release": release,
1063                 "arch": arch,
1064                 "variant": variant,
1065                 "build_time": build_time,
1066             }
1067         )
1068     if dist is not None:
1069         return dict([(dist, ret.get(dist, []))])
1070     return ret
1071 def templates():
1072     try:
1073         template_scripts = os.listdir("/usr/share/lxc/templates")
1074     except OSError:
1075         return []
1076     else:
1077         return [x[4:] for x in template_scripts if x.startswith("lxc-")]
1078 def _after_ignition_network_profile(cmd, ret, name, network_profile, path, nic_opts):
1079     _clear_context()
1080     if ret["retcode"] == 0 and exists(name, path=path):
1081         if network_profile:
1082             network_changes = apply_network_profile(
1083                 name, network_profile, path=path, nic_opts=nic_opts
1084             )
1085             if network_changes:
1086                 log.info(
1087                     "Network changes from applying network profile '%s' "
1088                     "to newly-created container '%s':\n%s",
1089                     network_profile,
1090                     name,
1091                     network_changes,
1092                 )
1093         c_state = state(name, path=path)
1094         return {"result": True, "state": {"old": None, "new": c_state}}
1095     else:
1096         if exists(name, path=path):
1097             cmd = "lxc-destroy"
1098             if path:
1099                 cmd += " -P {}".format(pipes.quote(path))
1100             cmd += " -n {}".format(name)
1101             __salt__["cmd.retcode"](cmd, python_shell=False)
1102         raise CommandExecutionError(
1103             "Container could not be created with cmd '{}': {}".format(
1104                 cmd, ret["stderr"]
1105             )
1106         )
1107 def create(
1108     name, config=None, profile=None, network_profile=None, nic_opts=None, **kwargs
1109 ):
1110     download_template_deps = ("dist", "release", "arch")
1111     cmd = "lxc-create -n {}".format(name)
1112     profile = get_container_profile(copy.deepcopy(profile))
1113     kw_overrides = copy.deepcopy(kwargs)
1114     def select(key, default=None):
1115         kw_overrides_match = kw_overrides.pop(key, None)
1116         profile_match = profile.pop(key, default)
1117         if kw_overrides_match is None:
1118             return profile_match
1119         return kw_overrides_match
1120     path = select("path")
1121     if exists(name, path=path):
1122         raise CommandExecutionError("Container '{}' already exists".format(name))
1123     tvg = select("vgname")
1124     vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
1125     template = select("template")
1126     image = select("image")
1127     if template and image:
1128         raise SaltInvocationError("Only one of 'template' and 'image' is permitted")
1129     elif not any((template, image, profile)):
1130         raise SaltInvocationError(
1131             "At least one of 'template', 'image', and 'profile' is required"
1132         )
1133     options = select("options") or {}
1134     backing = select("backing")
1135     if vgname and not backing:
1136         backing = "lvm"
1137     lvname = select("lvname")
1138     thinpool = select("thinpool")
1139     fstype = select("fstype")
1140     size = select("size", "1G")
1141     zfsroot = select("zfsroot")
1142     if backing in ("dir", "overlayfs", "btrfs", "zfs"):
1143         fstype = None
1144         size = None
1145     if backing in ("aufs", "dir", "overlayfs", "btrfs"):
1146         lvname = vgname = thinpool = None
1147     if image:
1148         img_tar = __salt__["cp.cache_file"](image)
1149         template = os.path.join(
1150             os.path.dirname(salt.__file__), "templates", "lxc", "salt_tarball"
1151         )
1152         options["imgtar"] = img_tar
1153     if path:
1154         cmd += " -P {}".format(pipes.quote(path))
1155         if not os.path.exists(path):
1156             os.makedirs(path)
1157     if config:
1158         cmd += " -f {}".format(config)
1159     if template:
1160         cmd += " -t {}".format(template)
1161     if backing:
1162         backing = backing.lower()
1163         cmd += " -B {}".format(backing)
1164         if backing in ("zfs",):
1165             if zfsroot:
1166                 cmd += " --zfsroot {}".format(zfsroot)
1167         if backing in ("lvm",):
1168             if lvname:
1169                 cmd += " --lvname {}".format(lvname)
1170             if vgname:
1171                 cmd += " --vgname {}".format(vgname)
1172             if thinpool:
1173                 cmd += " --thinpool {}".format(thinpool)
1174         if backing not in ("dir", "overlayfs"):
1175             if fstype:
1176                 cmd += " --fstype {}".format(fstype)
1177             if size:
1178                 cmd += " --fssize {}".format(size)
1179     if options:
1180         if template == "download":
1181             missing_deps = [x for x in download_template_deps if x not in options]
1182             if missing_deps:
1183                 raise SaltInvocationError(
1184                     "Missing params in 'options' dict: {}".format(
1185                         ", ".join(missing_deps)
1186                     )
1187                 )
1188         cmd += " --"
1189         for key, val in options.items():
1190             cmd += " --{} {}".format(key, val)
1191     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1192     return _after_ignition_network_profile(
1193         cmd, ret, name, network_profile, path, nic_opts
1194     )
1195 def clone(name, orig, profile=None, network_profile=None, nic_opts=None, **kwargs):
1196     profile = get_container_profile(copy.deepcopy(profile))
1197     kw_overrides = copy.deepcopy(kwargs)
1198     def select(key, default=None):
1199         kw_overrides_match = kw_overrides.pop(key, None)
1200         profile_match = profile.pop(key, default)
1201         if kw_overrides_match is None:
1202             return profile_match
1203         return kw_overrides_match
1204     path = select("path")
1205     if exists(name, path=path):
1206         raise CommandExecutionError("Container '{}' already exists".format(name))
1207     _ensure_exists(orig, path=path)
1208     if state(orig, path=path) != "stopped":
1209         raise CommandExecutionError(
1210             "Container '{}' must be stopped to be cloned".format(orig)
1211         )
1212     backing = select("backing")
1213     snapshot = select("snapshot")
1214     if backing in ("dir",):
1215         snapshot = False
1216     if not snapshot:
1217         snapshot = ""
1218     else:
1219         snapshot = "-s"
1220     size = select("size", "1G")
1221     if backing in ("dir", "overlayfs", "btrfs"):
1222         size = None
1223     if _LooseVersion(version()) &gt;= _LooseVersion("2.0"):
1224         cmd = "lxc-copy"
1225         cmd += " {} -n {} -N {}".format(snapshot, orig, name)
1226     else:
1227         cmd = "lxc-clone"
1228         cmd += " {} -o {} -n {}".format(snapshot, orig, name)
1229     if path:
1230         cmd += " -P {}".format(pipes.quote(path))
1231         if not os.path.exists(path):
1232             os.makedirs(path)
1233     if backing:
1234         backing = backing.lower()
1235         cmd += " -B {}".format(backing)
1236         if backing not in ("dir", "overlayfs"):
1237             if size:
1238                 cmd += " -L {}".format(size)
1239     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1240     return _after_ignition_network_profile(
1241         cmd, ret, name, network_profile, path, nic_opts
1242     )
1243 def ls_(active=None, cache=True, path=None):
1244     contextvar = "lxc.ls{}".format(path)
1245     if active:
1246         contextvar += ".active"
1247     if cache and (contextvar in __context__):
1248         return __context__[contextvar]
1249     else:
1250         ret = []
1251         cmd = "lxc-ls"
1252         if path:
1253             cmd += " -P {}".format(pipes.quote(path))
1254         if active:
1255             cmd += " --active"
1256         output = __salt__["cmd.run_stdout"](cmd, python_shell=False)
1257         for line in output.splitlines():
1258             ret.extend(line.split())
1259         __context__[contextvar] = ret
1260         return ret
1261 def list_(extra=False, limit=None, path=None):
1262     ctnrs = ls_(path=path)
1263     if extra:
1264         stopped = {}
1265         frozen = {}
1266         running = {}
1267     else:
1268         stopped = []
1269         frozen = []
1270         running = []
1271     ret = {"running": running, "stopped": stopped, "frozen": frozen}
1272     for container in ctnrs:
1273         cmd = "lxc-info"
1274         if path:
1275             cmd += " -P {}".format(pipes.quote(path))
1276         cmd += " -n {}".format(container)
1277         c_info = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="debug")
1278         c_state = None
1279         for line in c_info.splitlines():
1280             stat = line.split(":")
1281             if stat[0] in ("State", "state"):
1282                 c_state = stat[1].strip()
1283                 break
1284         if not c_state or (limit is not None and c_state.lower() != limit):
1285             continue
1286         if extra:
1287             infos = info(container, path=path)
1288             method = "update"
1289             value = {container: infos}
1290         else:
1291             method = "append"
1292             value = container
1293         if c_state == "STOPPED":
1294             getattr(stopped, method)(value)
1295             continue
1296         if c_state == "FROZEN":
1297             getattr(frozen, method)(value)
1298             continue
1299         if c_state == "RUNNING":
1300             getattr(running, method)(value)
1301             continue
1302 <a name="1"></a>
1303     if limit is not None:
1304         return ret.get(limit, {} if extra else [])
1305     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
1306 def _change_state(
1307     cmd,
1308     name,
1309     expected,
1310     stdin=_marker,
1311     stdout=_marker,
1312     stderr=_marker,
1313     with_communicate=_marker,
1314     use_vt=_marker,
1315     path=None,
1316 ):
1317     pre = state(name, path=</b></font>path)
1318     if pre == expected:
1319         return {
1320             "result": True,
1321             "state": {"old": expected, "new": expected},
1322             "comment": "Container '{}' already {}".format(name, expected),
1323         }
1324     if cmd == "lxc-destroy":
1325         scmd = "lxc-stop"
1326         if path:
1327             scmd += " -P {}".format(pipes.quote(path))
1328         scmd += " -k -n {}".format(name)
1329         __salt__["cmd.run"](scmd, python_shell=False)
1330     if path and " -P " not in cmd:
1331         cmd += " -P {}".format(pipes.quote(path))
1332     cmd += " -n {}".format(name)
1333     pkwargs = {
1334         "python_shell": False,
1335         "redirect_stderr": True,
1336         "with_communicate": with_communicate,
1337         "use_vt": use_vt,
1338         "stdin": stdin,
1339         "stdout": stdout,
1340     }
1341     for i in [a for a in pkwargs]:
1342         val = pkwargs[i]
1343         if val is _marker:
1344             pkwargs.pop(i, None)
1345     _cmdout = __salt__["cmd.run_all"](cmd, **pkwargs)
1346     if _cmdout["retcode"] != 0:
1347         raise CommandExecutionError(
1348             "Error changing state for container '{}' using command '{}': {}".format(
1349                 name, cmd, _cmdout["stdout"]
1350             )
1351         )
1352     if expected is not None:
1353         rcmd = "lxc-wait"
1354         if path:
1355             rcmd += " -P {}".format(pipes.quote(path))
1356         rcmd += " -n {} -s {}".format(name, expected.upper())
1357         __salt__["cmd.run"](rcmd, python_shell=False, timeout=30)
1358     _clear_context()
1359     post = state(name, path=path)
1360     ret = {"result": post == expected, "state": {"old": pre, "new": post}}
1361     return ret
1362 def _ensure_exists(name, path=None):
1363     if not exists(name, path=path):
1364         raise CommandExecutionError("Container '{}' does not exist".format(name))
1365 def _ensure_running(name, no_start=False, path=None):
1366     _ensure_exists(name, path=path)
1367     pre = state(name, path=path)
1368     if pre == "running":
1369         return start(name, path=path)
1370     elif pre == "stopped":
1371         if no_start:
1372             raise CommandExecutionError("Container '{}' is not running".format(name))
1373         return start(name, path=path)
1374     elif pre == "frozen":
1375         if no_start:
1376             raise CommandExecutionError("Container '{}' is not running".format(name))
1377         return unfreeze(name, path=path)
1378 def restart(name, path=None, lxc_config=None, force=False):
1379     _ensure_exists(name, path=path)
1380     orig_state = state(name, path=path)
1381     if orig_state != "stopped":
1382         stop(name, kill=force, path=path)
1383     ret = start(name, path=path, lxc_config=lxc_config)
1384     ret["state"]["old"] = orig_state
1385     if orig_state != "stopped":
1386         ret["restarted"] = True
1387     return ret
1388 def start(name, **kwargs):
1389     path = kwargs.get("path", None)
1390     cpath = get_root_path(path)
1391     lxc_config = kwargs.get("lxc_config", None)
1392     cmd = "lxc-start"
1393     if not lxc_config:
1394         lxc_config = os.path.join(cpath, name, "config")
1395     if os.path.exists(lxc_config):
1396         cmd += " -f {}".format(pipes.quote(lxc_config))
1397     cmd += " -d"
1398     _ensure_exists(name, path=path)
1399     if state(name, path=path) == "frozen":
1400         raise CommandExecutionError(
1401             "Container '{}' is frozen, use lxc.unfreeze".format(name)
1402         )
1403     use_vt = kwargs.get("use_vt", None)
1404     with_communicate = kwargs.get("with_communicate", False)
1405     return _change_state(
1406         cmd,
1407         name,
1408         "running",
1409         stdout=None,
1410         stderr=None,
1411         stdin=None,
1412         with_communicate=with_communicate,
1413         path=path,
1414         use_vt=use_vt,
1415     )
1416 def stop(name, kill=False, path=None, use_vt=None):
1417     _ensure_exists(name, path=path)
1418     orig_state = state(name, path=path)
1419     if orig_state == "frozen" and not kill:
1420         unfreeze(name, path=path)
1421     cmd = "lxc-stop"
1422     if kill:
1423         cmd += " -k"
1424     ret = _change_state(cmd, name, "stopped", use_vt=use_vt, path=path)
1425     ret["state"]["old"] = orig_state
1426     return ret
1427 def freeze(name, **kwargs):
1428     use_vt = kwargs.get("use_vt", None)
1429     path = kwargs.get("path", None)
1430     _ensure_exists(name, path=path)
1431     orig_state = state(name, path=path)
1432     start_ = kwargs.get("start", False)
1433     if orig_state == "stopped":
1434         if not start_:
1435             raise CommandExecutionError("Container '{}' is stopped".format(name))
1436         start(name, path=path)
1437     cmd = "lxc-freeze"
1438     if path:
1439         cmd += " -P {}".format(pipes.quote(path))
1440     ret = _change_state(cmd, name, "frozen", use_vt=use_vt, path=path)
1441     if orig_state == "stopped" and start_:
1442         ret["state"]["old"] = orig_state
1443         ret["started"] = True
1444     ret["state"]["new"] = state(name, path=path)
1445     return ret
1446 def unfreeze(name, path=None, use_vt=None):
1447     _ensure_exists(name, path=path)
1448     if state(name, path=path) == "stopped":
1449         raise CommandExecutionError("Container '{}' is stopped".format(name))
1450     cmd = "lxc-unfreeze"
1451     if path:
1452         cmd += " -P {}".format(pipes.quote(path))
1453     return _change_state(cmd, name, "running", path=path, use_vt=use_vt)
1454 def destroy(name, stop=False, path=None):
1455     _ensure_exists(name, path=path)
1456     if not stop and state(name, path=path) != "stopped":
1457         raise CommandExecutionError("Container '{}' is not stopped".format(name))
1458     return _change_state("lxc-destroy", name, None, path=path)
1459 remove = salt.utils.functools.alias_function(destroy, "remove")
1460 def exists(name, path=None):
1461     _exists = name in ls_(path=path)
1462     if not _exists:
1463         _exists = name in ls_(cache=False, path=path)
1464     return _exists
1465 def state(name, path=None):
1466     cachekey = "lxc.state.{}{}".format(name, path)
1467     try:
1468         return __context__[cachekey]
1469     except KeyError:
1470         if not exists(name, path=path):
1471             __context__[cachekey] = None
1472         else:
1473             cmd = "lxc-info"
1474             if path:
1475                 cmd += " -P {}".format(pipes.quote(path))
1476             cmd += " -n {}".format(name)
1477             ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1478             if ret["retcode"] != 0:
1479                 _clear_context()
1480                 raise CommandExecutionError(
1481                     "Unable to get state of container '{}'".format(name)
1482                 )
1483             c_infos = ret["stdout"].splitlines()
1484             c_state = None
1485             for c_info in c_infos:
1486                 stat = c_info.split(":")
1487                 if stat[0].lower() == "state":
1488                     c_state = stat[1].strip().lower()
1489                     break
1490             __context__[cachekey] = c_state
1491     return __context__[cachekey]
1492 def get_parameter(name, parameter, path=None):
1493     _ensure_exists(name, path=path)
1494     cmd = "lxc-cgroup"
1495     if path:
1496         cmd += " -P {}".format(pipes.quote(path))
1497     cmd += " -n {} {}".format(name, parameter)
1498     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1499     if ret["retcode"] != 0:
1500         raise CommandExecutionError(
1501             "Unable to retrieve value for '{}'".format(parameter)
1502         )
1503     return ret["stdout"].strip()
1504 def set_parameter(name, parameter, value, path=None):
1505     if not exists(name, path=path):
1506         return None
1507     cmd = "lxc-cgroup"
1508     if path:
1509         cmd += " -P {}".format(pipes.quote(path))
1510     cmd += " -n {} {} {}".format(name, parameter, value)
1511     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1512     if ret["retcode"] != 0:
1513         return False
1514     else:
1515         return True
1516 def info(name, path=None):
1517     cachekey = "lxc.info.{}{}".format(name, path)
1518     try:
1519         return __context__[cachekey]
1520     except KeyError:
1521         _ensure_exists(name, path=path)
1522         cpath = get_root_path(path)
1523         try:
1524             conf_file = os.path.join(cpath, name, "config")
1525         except AttributeError:
1526             conf_file = os.path.join(cpath, str(name), "config")
1527         if not os.path.isfile(conf_file):
1528             raise CommandExecutionError(
1529                 "LXC config file {} does not exist".format(conf_file)
1530             )
1531         ret = {}
1532         config = []
1533         with salt.utils.files.fopen(conf_file) as fp_:
1534             for line in fp_:
1535                 line = salt.utils.stringutils.to_unicode(line)
1536                 comps = [x.strip() for x in line.split("#", 1)[0].strip().split("=", 1)]
1537                 if len(comps) == 2:
1538                     config.append(tuple(comps))
1539         ifaces = []
1540         current = {}
1541         for key, val in config:
1542             if key == "lxc.network.type":
1543                 current = {"type": val}
1544                 ifaces.append(current)
1545             elif not current:
1546                 continue
1547             elif key.startswith("lxc.network."):
1548                 current[key.replace("lxc.network.", "", 1)] = val
1549         if ifaces:
1550             ret["nics"] = ifaces
1551         ret["rootfs"] = next((x[1] for x in config if x[0] == "lxc.rootfs"), None)
1552         ret["state"] = state(name, path=path)
1553         ret["ips"] = []
1554         ret["public_ips"] = []
1555         ret["private_ips"] = []
1556         ret["public_ipv4_ips"] = []
1557         ret["public_ipv6_ips"] = []
1558         ret["private_ipv4_ips"] = []
1559         ret["private_ipv6_ips"] = []
1560         ret["ipv4_ips"] = []
1561         ret["ipv6_ips"] = []
1562         ret["size"] = None
1563         ret["config"] = conf_file
1564         if ret["state"] == "running":
1565             try:
1566                 limit = int(get_parameter(name, "memory.limit_in_bytes"))
1567             except (CommandExecutionError, TypeError, ValueError):
1568                 limit = 0
1569             try:
1570                 usage = int(get_parameter(name, "memory.usage_in_bytes"))
1571             except (CommandExecutionError, TypeError, ValueError):
1572                 usage = 0
1573             free = limit - usage
1574             ret["memory_limit"] = limit
1575             ret["memory_free"] = free
1576             size = run_stdout(name, "df /", path=path, python_shell=False)
1577             ret["size"] = size.splitlines()[-1].split()[1]
1578             ip_cmd = run_all(name, "ip link show", path=path, python_shell=False)
1579             if ip_cmd["retcode"] == 0:
1580                 ip_data = ip_cmd["stdout"]
1581                 ip_cmd = run_all(name, "ip addr show", path=path, python_shell=False)
1582                 ip_data += "\n" + ip_cmd["stdout"]
1583                 ip_data = salt.utils.network._interfaces_ip(ip_data)
1584             else:
1585                 ip_cmd = run_all(name, "ifconfig", path=path, python_shell=False)
1586                 if ip_cmd["retcode"] == 0:
1587                     ip_data = salt.utils.network._interfaces_ifconfig(ip_cmd["stdout"])
1588                 else:
1589                     log.warning("Unable to run ip or ifconfig in container '%s'", name)
1590                     ip_data = {}
1591             ret["ipv4_ips"] = salt.utils.network.ip_addrs(
1592                 include_loopback=True, interface_data=ip_data
1593             )
1594             ret["ipv6_ips"] = salt.utils.network.ip_addrs6(
1595                 include_loopback=True, interface_data=ip_data
1596             )
1597             ret["ips"] = ret["ipv4_ips"] + ret["ipv6_ips"]
1598             for address in ret["ipv4_ips"]:
1599                 if address == "127.0.0.1":
1600                     ret["private_ips"].append(address)
1601                     ret["private_ipv4_ips"].append(address)
1602                 elif salt.utils.cloud.is_public_ip(address):
1603                     ret["public_ips"].append(address)
1604                     ret["public_ipv4_ips"].append(address)
1605                 else:
1606                     ret["private_ips"].append(address)
1607                     ret["private_ipv4_ips"].append(address)
1608             for address in ret["ipv6_ips"]:
1609                 if address == "::1" or address.startswith("fe80"):
1610                     ret["private_ips"].append(address)
1611                     ret["private_ipv6_ips"].append(address)
1612                 else:
1613                     ret["public_ips"].append(address)
1614                     ret["public_ipv6_ips"].append(address)
1615         for key in [x for x in ret if x == "ips" or x.endswith("ips")]:
1616             ret[key].sort(key=_ip_sort)
1617         __context__[cachekey] = ret
1618     return __context__[cachekey]
1619 def set_password(name, users, password, encrypted=True, path=None):
1620     def _bad_user_input():
1621         raise SaltInvocationError("Invalid input for 'users' parameter")
1622     if not isinstance(users, list):
1623         try:
1624             users = users.split(",")
1625         except AttributeError:
1626             _bad_user_input()
1627     if not users:
1628         _bad_user_input()
1629     failed_users = []
1630     for user in users:
1631         result = retcode(
1632             name,
1633             "chpasswd{}".format(" -e" if encrypted else ""),
1634             stdin=":".join((user, password)),
1635             python_shell=False,
1636             path=path,
1637             chroot_fallback=True,
1638             output_loglevel="quiet",
1639         )
1640         if result != 0:
1641             failed_users.append(user)
1642     if failed_users:
1643         raise CommandExecutionError(
1644             "Password change failed for the following user(s): {}".format(
1645                 ", ".join(failed_users)
1646             )
1647         )
1648     return True
1649 set_pass = salt.utils.functools.alias_function(set_password, "set_pass")
1650 def update_lxc_conf(name, lxc_conf, lxc_conf_unset, path=None):
1651     _ensure_exists(name, path=path)
1652     cpath = get_root_path(path)
1653     lxc_conf_p = os.path.join(cpath, name, "config")
1654     if not os.path.exists(lxc_conf_p):
1655         raise SaltInvocationError(
1656             "Configuration file {} does not exist".format(lxc_conf_p)
1657         )
1658     changes = {"edited": [], "added": [], "removed": []}
1659     ret = {"changes": changes, "result": True, "comment": ""}
1660     with salt.utils.files.fopen(lxc_conf_p, "r") as fic:
1661         filtered_lxc_conf = []
1662         for row in lxc_conf:
1663             if not row:
1664                 continue
1665             for conf in row:
1666                 filtered_lxc_conf.append((conf.strip(), row[conf].strip()))
1667         ret["comment"] = "lxc.conf is up to date"
1668         lines = []
1669         orig_config = salt.utils.stringutils.to_unicode(fic.read())
1670         for line in orig_config.splitlines():
1671             if line.startswith("#") or not line.strip():
1672                 lines.append([line, ""])
1673             else:
1674                 line = line.split("=")
1675                 index = line.pop(0)
1676                 val = (index.strip(), "=".join(line).strip())
1677                 if val not in lines:
1678                     lines.append(val)
1679         for key, item in filtered_lxc_conf:
1680             matched = False
1681             for idx, line in enumerate(lines[:]):
1682                 if line[0] == key:
1683                     matched = True
1684                     lines[idx] = (key, item)
1685                     if "=".join(line[1:]).strip() != item.strip():
1686                         changes["edited"].append(({line[0]: line[1:]}, {key: item}))
1687                         break
1688             if not matched:
1689                 if (key, item) not in lines:
1690                     lines.append((key, item))
1691                 changes["added"].append({key: item})
1692         dest_lxc_conf = []
1693         if lxc_conf_unset:
1694             for line in lines:
1695                 for opt in lxc_conf_unset:
1696                     if not line[0].startswith(opt) and line not in dest_lxc_conf:
1697                         dest_lxc_conf.append(line)
1698                     else:
1699                         changes["removed"].append(opt)
1700         else:
1701             dest_lxc_conf = lines
1702         conf = ""
1703         for key, val in dest_lxc_conf:
1704             if not val:
1705                 conf += "{}\n".format(key)
1706             else:
1707                 conf += "{} = {}\n".format(key.strip(), val.strip())
1708         conf_changed = conf != orig_config
1709         chrono = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
1710         if conf_changed:
1711             with salt.utils.files.fopen(
1712                 "{}.{}".format(lxc_conf_p, chrono), "w"
1713             ) as wfic:
1714                 wfic.write(salt.utils.stringutils.to_str(conf))
1715             with salt.utils.files.fopen(lxc_conf_p, "w") as wfic:
1716                 wfic.write(salt.utils.stringutils.to_str(conf))
1717             ret["comment"] = "Updated"
1718             ret["result"] = True
1719     if not any(changes[x] for x in changes):
1720         ret["changes"] = {}
1721     return ret
1722 def set_dns(name, dnsservers=None, searchdomains=None, path=None):
1723     if dnsservers is None:
1724         dnsservers = ["8.8.8.8", "4.4.4.4"]
1725     elif not isinstance(dnsservers, list):
1726         try:
1727             dnsservers = dnsservers.split(",")
1728         except AttributeError:
1729             raise SaltInvocationError("Invalid input for 'dnsservers' parameter")
1730     if searchdomains is None:
1731         searchdomains = []
1732     elif not isinstance(searchdomains, list):
1733         try:
1734             searchdomains = searchdomains.split(",")
1735         except AttributeError:
1736             raise SaltInvocationError("Invalid input for 'searchdomains' parameter")
1737     dns = ["nameserver {}".format(x) for x in dnsservers]
1738     dns.extend(["search {}".format(x) for x in searchdomains])
1739     dns = "\n".join(dns) + "\n"
1740     rstr = __salt__["test.random_hash"]()
1741     script = "/sbin/{}_dns.sh".format(rstr)
1742     DNS_SCRIPT = "\n".join(
1743         [
1744             "#!/usr/bin/env bash",
1745             "if [ -h /etc/resolv.conf ];then",
1746             ' if [ "x$(readlink /etc/resolv.conf)"'
1747             ' = "x../run/resolvconf/resolv.conf" ];then',
1748             "  if [ ! -d /run/resolvconf/ ];then",
1749             "   mkdir -p /run/resolvconf",
1750             "  fi",
1751             "  cat &gt; /etc/resolvconf/resolv.conf.d/head &lt;&lt;EOF",
1752             dns,
1753             "EOF",
1754             "",
1755             " fi",
1756             "fi",
1757             "cat &gt; /etc/resolv.conf &lt;&lt;EOF",
1758             dns,
1759             "EOF",
1760             "",
1761         ]
1762     )
1763     result = run_all(
1764         name, "tee {}".format(script), path=path, stdin=DNS_SCRIPT, python_shell=True
1765     )
1766     if result["retcode"] == 0:
1767         result = run_all(
1768             name,
1769             'sh -c "chmod +x {0};{0}"'.format(script),
1770             path=path,
1771             python_shell=True,
1772         )
1773     run_all(
1774         name,
1775         'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1776         path=path,
1777         python_shell=True,
1778     )
1779     if result["retcode"] != 0:
1780         error = "Unable to write to /etc/resolv.conf in container '{}'".format(name)
1781         if result["stderr"]:
1782             error += ": {}".format(result["stderr"])
1783         raise CommandExecutionError(error)
1784     return True
1785 def running_systemd(name, cache=True, path=None):
1786     k = "lxc.systemd.test.{}{}".format(name, path)
1787     ret = __context__.get(k, None)
1788     if ret is None or not cache:
1789         rstr = __salt__["test.random_hash"]()
1790         script = "/sbin/{}_testsystemd.sh".format(rstr)
1791         _script = textwrap.dedent(
1792         )
1793         result = run_all(
1794             name, "tee {}".format(script), path=path, stdin=_script, python_shell=True
1795         )
1796         if result["retcode"] == 0:
1797             result = run_all(
1798                 name,
1799                 'sh -c "chmod +x {0};{0}"'.format(script),
1800                 path=path,
1801                 python_shell=True,
1802             )
1803         else:
1804             raise CommandExecutionError(
1805                 "lxc {} failed to copy initd tester".format(name)
1806             )
1807         run_all(
1808             name,
1809             'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1810             path=path,
1811             ignore_retcode=True,
1812             python_shell=True,
1813         )
1814         if result["retcode"] != 0:
1815             error = (
1816                 "Unable to determine if the container '{}'"
1817                 " was running systemd, assmuming it is not."
1818                 "".format(name)
1819             )
1820             if result["stderr"]:
1821                 error += ": {}".format(result["stderr"])
1822         if result["retcode"] in (0, 2):
1823             __context__[k] = ret = not result["retcode"]
1824     return ret
1825 def systemd_running_state(name, path=None):
1826     try:
1827         ret = run_all(
1828             name, "systemctl is-system-running", path=path, ignore_retcode=True
1829         )["stdout"]
1830     except CommandExecutionError:
1831         ret = ""
1832     return ret
1833 def test_sd_started_state(name, path=None):
1834     qstate = systemd_running_state(name, path=path)
1835     if qstate in ("initializing", "starting"):
1836         return False
1837     elif qstate == "":
1838         return None
1839     else:
1840         return True
1841 def test_bare_started_state(name, path=None):
1842     try:
1843         ret = run_all(name, "ls", path=path, ignore_retcode=True)["retcode"] == 0
1844     except (CommandExecutionError,):
1845         ret = None
1846     return ret
1847 def wait_started(name, path=None, timeout=300):
1848     if not exists(name, path=path):
1849         raise CommandExecutionError("Container {} does does exists".format(name))
1850     if not state(name, path=path) == "running":
1851         raise CommandExecutionError("Container {} is not running".format(name))
1852     ret = False
1853     if running_systemd(name, path=path):
1854         test_started = test_sd_started_state
1855         logger = log.error
1856     else:
1857         test_started = test_bare_started_state
1858         logger = log.debug
1859     now = time.time()
1860     expire = now + timeout
1861     now = time.time()
1862     started = test_started(name, path=path)
1863     while time.time() &lt; expire and not started:
1864         time.sleep(0.3)
1865         started = test_started(name, path=path)
1866     if started is None:
1867         logger(
1868             "Assuming %s is started, although we failed to detect that"
1869             " is fully started correctly",
1870             name,
1871         )
1872         ret = True
1873     else:
1874         ret = started
1875     return ret
1876 def _needs_install(name, path=None):
1877     ret = 0
1878     has_minion = retcode(name, "which salt-minion", path=path, ignore_retcode=True)
1879     if has_minion:
1880         processes = run_stdout(name, "ps aux", path=path)
1881         if "salt-minion" not in processes:
1882             ret = 1
1883         else:
1884             retcode(name, "salt-call --local service.stop salt-minion")
1885     else:
1886         ret = 1
1887     return ret
1888 def bootstrap(
1889     name,
1890     config=None,
1891     approve_key=True,
1892     install=True,
1893     pub_key=None,
1894     priv_key=None,
1895     bootstrap_url=None,
1896     force_install=False,
1897     unconditional_install=False,
1898     path=None,
1899     bootstrap_delay=None,
1900     bootstrap_args=None,
1901     bootstrap_shell=None,
1902 ):
1903     wait_started(name, path=path)
1904     if bootstrap_delay is not None:
1905         try:
1906             log.info("LXC %s: bootstrap_delay: %s", name, bootstrap_delay)
1907             time.sleep(bootstrap_delay)
1908         except TypeError:
1909             time.sleep(5)
1910     c_info = info(name, path=path)
1911     if not c_info:
1912         return None
1913     if bootstrap_args:
1914         if "{0}" not in bootstrap_args:
1915             bootstrap_args += " -c {0}"
1916     else:
1917         bootstrap_args = "-c {0}"
1918     if not bootstrap_shell:
1919         bootstrap_shell = "sh"
1920     orig_state = _ensure_running(name, path=path)
1921     if not orig_state:
1922         return orig_state
1923     if not force_install:
1924         needs_install = _needs_install(name, path=path)
1925     else:
1926         needs_install = True
1927     seeded = (
1928         retcode(
1929             name,
1930             "test -e '{}'".format(SEED_MARKER),
1931             path=path,
1932             chroot_fallback=True,
1933             ignore_retcode=True,
1934         )
1935         == 0
1936     )
1937     tmp = tempfile.mkdtemp()
1938     if seeded and not unconditional_install:
1939         ret = True
1940     else:
1941         ret = False
1942         cfg_files = __salt__["seed.mkconfig"](
1943             config,
1944             tmp=tmp,
1945             id_=name,
1946             approve_key=approve_key,
1947             pub_key=pub_key,
1948             priv_key=priv_key,
1949         )
1950         if needs_install or force_install or unconditional_install:
1951             if install:
1952                 rstr = __salt__["test.random_hash"]()
1953                 configdir = "/var/tmp/.c_{}".format(rstr)
1954                 cmd = "install -m 0700 -d {}".format(configdir)
1955                 if run_all(name, cmd, path=path, python_shell=False)["retcode"] != 0:
1956                     log.error("tmpdir %s creation failed %s", configdir, cmd)
1957                     return False
1958                 bs_ = __salt__["config.gather_bootstrap_script"](
1959                     bootstrap=bootstrap_url
1960                 )
1961                 script = "/sbin/{}_bootstrap.sh".format(rstr)
1962                 copy_to(name, bs_, script, path=path)
1963                 result = run_all(
1964                     name,
1965                     'sh -c "chmod +x {}"'.format(script),
1966                     path=path,
1967                     python_shell=True,
1968                 )
1969                 copy_to(
1970                     name,
1971                     cfg_files["config"],
1972                     os.path.join(configdir, "minion"),
1973                     path=path,
1974                 )
1975                 copy_to(
1976                     name,
1977                     cfg_files["privkey"],
1978                     os.path.join(configdir, "minion.pem"),
1979                     path=path,
1980                 )
1981                 copy_to(
1982                     name,
1983                     cfg_files["pubkey"],
1984                     os.path.join(configdir, "minion.pub"),
1985                     path=path,
1986                 )
1987                 bootstrap_args = bootstrap_args.format(configdir)
1988                 cmd = "{0} {2} {1}".format(
1989                     bootstrap_shell, bootstrap_args.replace("'", "''"), script
1990                 )
1991                 log.info("Running %s in LXC container '%s'", cmd, name)
1992                 ret = (
1993                     retcode(name, cmd, output_loglevel="info", path=path, use_vt=True)
1994                     == 0
1995                 )
1996                 run_all(
1997                     name,
1998                     'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1999                     path=path,
2000                     ignore_retcode=True,
2001                     python_shell=True,
2002                 )
2003             else:
2004                 ret = False
2005         else:
2006             minion_config = salt.config.minion_config(cfg_files["config"])
2007             pki_dir = minion_config["pki_dir"]
2008             copy_to(name, cfg_files["config"], "/etc/salt/minion", path=path)
2009             copy_to(
2010                 name,
2011                 cfg_files["privkey"],
2012                 os.path.join(pki_dir, "minion.pem"),
2013                 path=path,
2014             )
2015             copy_to(
2016                 name,
2017                 cfg_files["pubkey"],
2018                 os.path.join(pki_dir, "minion.pub"),
2019                 path=path,
2020             )
2021             run(
2022                 name,
2023                 "salt-call --local service.enable salt-minion",
2024                 path=path,
2025                 python_shell=False,
2026             )
2027             ret = True
2028         shutil.rmtree(tmp)
2029         if orig_state == "stopped":
2030             stop(name, path=path)
2031         elif orig_state == "frozen":
2032             freeze(name, path=path)
2033         if ret:
2034             run(name, "touch '{}'".format(SEED_MARKER), path=path, python_shell=False)
2035     return ret
2036 def attachable(name, path=None):
2037     cachekey = "lxc.attachable{}{}".format(name, path)
2038     try:
2039         return __context__[cachekey]
2040     except KeyError:
2041         _ensure_exists(name, path=path)
2042         log.debug("Checking if LXC container %s is attachable", name)
2043         cmd = "lxc-attach"
2044         if path:
2045             cmd += " -P {}".format(pipes.quote(path))
2046         cmd += " --clear-env -n {} -- /usr/bin/env".format(name)
2047         result = (
2048             __salt__["cmd.retcode"](
2049                 cmd, python_shell=False, output_loglevel="quiet", ignore_retcode=True
2050 <a name="0"></a>            )
2051             == 0
2052         )
2053         __context__[cachekey] <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= result
2054     return __context__[cachekey]
2055 def _run(
2056     name,
2057     cmd,
2058     output=None,
2059     no_start=False,
2060     preserve_state=True,
2061     stdin=None,
2062     python_shell=True,
2063     output_loglevel="debug",
2064     use_vt=</b></font>False,
2065     path=None,
2066     ignore_retcode=False,
2067     chroot_fallback=None,
2068     keep_env="http_proxy,https_proxy,no_proxy",
2069 ):
2070     orig_state = state(name, path=path)
2071     try:
2072         if attachable(name, path=path):
2073             ret = __salt__["container_resource.run"](
2074                 name,
2075                 cmd,
2076                 path=path,
2077                 container_type=__virtualname__,
2078                 exec_driver=EXEC_DRIVER,
2079                 output=output,
2080                 no_start=no_start,
2081                 stdin=stdin,
2082                 python_shell=python_shell,
2083                 output_loglevel=output_loglevel,
2084                 ignore_retcode=ignore_retcode,
2085                 use_vt=use_vt,
2086                 keep_env=keep_env,
2087             )
2088         else:
2089             if not chroot_fallback:
2090                 raise CommandExecutionError("{} is not attachable.".format(name))
2091             rootfs = info(name, path=path).get("rootfs")
2092             __context__["cmd.run_chroot.func"] = __salt__["cmd.run"]
2093             ret = __salt__["cmd.run_chroot"](
2094                 rootfs,
2095                 cmd,
2096                 stdin=stdin,
2097                 python_shell=python_shell,
2098                 output_loglevel=output_loglevel,
2099                 ignore_retcode=ignore_retcode,
2100             )
2101     finally:
2102         new_state = state(name, path=path)
2103         if preserve_state:
2104             if orig_state == "stopped" and new_state != "stopped":
2105                 stop(name, path=path)
2106             elif orig_state == "frozen" and new_state != "frozen":
2107                 freeze(name, start=True, path=path)
2108     if output in (None, "all"):
2109         return ret
2110     else:
2111         return ret[output]
2112 def run(
2113     name,
2114     cmd,
2115     no_start=False,
2116     preserve_state=True,
2117     stdin=None,
2118     python_shell=True,
2119     output_loglevel="debug",
2120     use_vt=False,
2121     path=None,
2122     ignore_retcode=False,
2123     chroot_fallback=False,
2124     keep_env="http_proxy,https_proxy,no_proxy",
2125 ):
2126     return _run(
2127         name,
2128         cmd,
2129         path=path,
2130         output=None,
2131         no_start=no_start,
2132         preserve_state=preserve_state,
2133         stdin=stdin,
2134         python_shell=python_shell,
2135         output_loglevel=output_loglevel,
2136         use_vt=use_vt,
2137         ignore_retcode=ignore_retcode,
2138         chroot_fallback=chroot_fallback,
2139         keep_env=keep_env,
2140     )
2141 def run_stdout(
2142     name,
2143     cmd,
2144     no_start=False,
2145     preserve_state=True,
2146     stdin=None,
2147     python_shell=True,
2148     output_loglevel="debug",
2149     use_vt=False,
2150     path=None,
2151     ignore_retcode=False,
2152     chroot_fallback=False,
2153     keep_env="http_proxy,https_proxy,no_proxy",
2154 ):
2155     return _run(
2156         name,
2157         cmd,
2158         path=path,
2159         output="stdout",
2160         no_start=no_start,
2161         preserve_state=preserve_state,
2162         stdin=stdin,
2163         python_shell=python_shell,
2164         output_loglevel=output_loglevel,
2165         use_vt=use_vt,
2166         ignore_retcode=ignore_retcode,
2167         chroot_fallback=chroot_fallback,
2168         keep_env=keep_env,
2169     )
2170 def run_stderr(
2171     name,
2172     cmd,
2173     no_start=False,
2174     preserve_state=True,
2175     stdin=None,
2176     python_shell=True,
2177     output_loglevel="debug",
2178     use_vt=False,
2179     path=None,
2180     ignore_retcode=False,
2181     chroot_fallback=False,
2182     keep_env="http_proxy,https_proxy,no_proxy",
2183 ):
2184     return _run(
2185         name,
2186         cmd,
2187         path=path,
2188         output="stderr",
2189         no_start=no_start,
2190         preserve_state=preserve_state,
2191         stdin=stdin,
2192         python_shell=python_shell,
2193         output_loglevel=output_loglevel,
2194         use_vt=use_vt,
2195         ignore_retcode=ignore_retcode,
2196         chroot_fallback=chroot_fallback,
2197         keep_env=keep_env,
2198     )
2199 def retcode(
2200     name,
2201     cmd,
2202     no_start=False,
2203     preserve_state=True,
2204     stdin=None,
2205     python_shell=True,
2206     output_loglevel="debug",
2207     use_vt=False,
2208     path=None,
2209     ignore_retcode=False,
2210     chroot_fallback=False,
2211     keep_env="http_proxy,https_proxy,no_proxy",
2212 ):
2213     return _run(
2214         name,
2215         cmd,
2216         output="retcode",
2217         path=path,
2218         no_start=no_start,
2219         preserve_state=preserve_state,
2220         stdin=stdin,
2221         python_shell=python_shell,
2222         output_loglevel=output_loglevel,
2223         use_vt=use_vt,
2224         ignore_retcode=ignore_retcode,
2225         chroot_fallback=chroot_fallback,
2226         keep_env=keep_env,
2227     )
2228 def run_all(
2229     name,
2230     cmd,
2231     no_start=False,
2232     preserve_state=True,
2233     stdin=None,
2234     python_shell=True,
2235     output_loglevel="debug",
2236     use_vt=False,
2237     path=None,
2238     ignore_retcode=False,
2239     chroot_fallback=False,
2240     keep_env="http_proxy,https_proxy,no_proxy",
2241 ):
2242     return _run(
2243         name,
2244         cmd,
2245         output="all",
2246         no_start=no_start,
2247         preserve_state=preserve_state,
2248         stdin=stdin,
2249         python_shell=python_shell,
2250         output_loglevel=output_loglevel,
2251         use_vt=use_vt,
2252         path=path,
2253         ignore_retcode=ignore_retcode,
2254         chroot_fallback=chroot_fallback,
2255         keep_env=keep_env,
2256     )
2257 def _get_md5(name, path):
2258     output = run_stdout(
2259         name, 'md5sum "{}"'.format(path), chroot_fallback=True, ignore_retcode=True
2260     )
2261     try:
2262         return output.split()[0]
2263     except IndexError:
2264         return None
2265 def copy_to(name, source, dest, overwrite=False, makedirs=False, path=None):
2266     _ensure_running(name, no_start=True, path=path)
2267     return __salt__["container_resource.copy_to"](
2268         name,
2269         source,
2270         dest,
2271         container_type=__virtualname__,
2272         path=path,
2273         exec_driver=EXEC_DRIVER,
2274         overwrite=overwrite,
2275         makedirs=makedirs,
2276     )
2277 cp = salt.utils.functools.alias_function(copy_to, "cp")
2278 def read_conf(conf_file, out_format="simple"):
2279     ret_commented = []
2280     ret_simple = {}
2281     with salt.utils.files.fopen(conf_file, "r") as fp_:
2282         for line in salt.utils.data.decode(fp_.readlines()):
2283             if "=" not in line:
2284                 ret_commented.append(line)
2285                 continue
2286             comps = line.split("=")
2287             value = "=".join(comps[1:]).strip()
2288             comment = None
2289             if value.strip().startswith("#"):
2290                 vcomps = value.strip().split("#")
2291                 value = vcomps[1].strip()
2292                 comment = "#".join(vcomps[1:]).strip()
2293                 ret_commented.append(
2294                     {comps[0].strip(): {"value": value, "comment": comment}}
2295                 )
2296             else:
2297                 ret_commented.append({comps[0].strip(): value})
2298                 ret_simple[comps[0].strip()] = value
2299     if out_format == "simple":
2300         return ret_simple
2301     return ret_commented
2302 def write_conf(conf_file, conf):
2303     if not isinstance(conf, list):
2304         raise SaltInvocationError("Configuration must be passed as a list")
2305     content = ""
2306     for line in conf:
2307         if isinstance(line, (str, (str,))):
2308             content += line
2309         elif isinstance(line, dict):
2310             for key in list(line.keys()):
2311                 out_line = None
2312                 if isinstance(
2313                     line[key],
2314                     (str, (str,), (int,), float),
2315                 ):
2316                     out_line = " = ".join((key, "{}".format(line[key])))
2317                 elif isinstance(line[key], dict):
2318                     out_line = " = ".join((key, line[key]["value"]))
2319                     if "comment" in line[key]:
2320                         out_line = " # ".join((out_line, line[key]["comment"]))
2321                 if out_line:
2322                     content += out_line
2323                     content += "\n"
2324     with salt.utils.files.fopen(conf_file, "w") as fp_:
2325         fp_.write(salt.utils.stringutils.to_str(content))
2326     return {}
2327 def edit_conf(
2328     conf_file, out_format="simple", read_only=False, lxc_config=None, **kwargs
2329 ):
2330     data = []
2331     try:
2332         conf = read_conf(conf_file, out_format=out_format)
2333     except Exception:  # pylint: disable=broad-except
2334         conf = []
2335     if not lxc_config:
2336         lxc_config = []
2337     lxc_config = copy.deepcopy(lxc_config)
2338     net_config = []
2339     for lxc_kws in lxc_config + [kwargs]:
2340         net_params = {}
2341         for kwarg in [a for a in lxc_kws]:
2342             if kwarg.startswith("__"):
2343                 continue
2344             if kwarg.startswith("lxc.network."):
2345                 net_params[kwarg] = lxc_kws[kwarg]
2346                 lxc_kws.pop(kwarg, None)
2347         if net_params:
2348             net_config.append(net_params)
2349     nic_opts = salt.utils.odict.OrderedDict()
2350     for params in net_config:
2351         dev = params.get("lxc.network.name", DEFAULT_NIC)
2352         dev_opts = nic_opts.setdefault(dev, salt.utils.odict.OrderedDict())
2353         for param in params:
2354             opt = param.replace("lxc.network.", "")
2355             opt = {"hwaddr": "mac"}.get(opt, opt)
2356             dev_opts[opt] = params[param]
2357     net_changes = []
2358     if nic_opts:
2359         net_changes = _config_list(
2360             conf,
2361             only_net=True,
2362             **{"network_profile": DEFAULT_NIC, "nic_opts": nic_opts}
2363         )
2364         if net_changes:
2365             lxc_config.extend(net_changes)
2366     for line in conf:
2367         if not isinstance(line, dict):
2368             data.append(line)
2369             continue
2370         else:
2371             for key in list(line.keys()):
2372                 val = line[key]
2373                 if net_changes and key.startswith("lxc.network."):
2374                     continue
2375                 found = False
2376                 for kw in lxc_config:
2377                     if key in kw:
2378                         found = True
2379                         data.append({key: kw[key]})
2380                         del kw[key]
2381                 if not found:
2382                     data.append({key: val})
2383     for lxc_kws in lxc_config:
2384         for kwarg in lxc_kws:
2385             data.append({kwarg: lxc_kws[kwarg]})
2386     if read_only:
2387         return data
2388     write_conf(conf_file, data)
2389     return read_conf(conf_file, out_format)
2390 def reboot(name, path=None):
2391     ret = {"result": True, "changes": {}, "comment": "{} rebooted".format(name)}
2392     does_exist = exists(name, path=path)
2393     if does_exist and (state(name, path=path) == "running"):
2394         try:
2395             stop(name, path=path)
2396         except (SaltInvocationError, CommandExecutionError) as exc:
2397             ret["comment"] = "Unable to stop container: {}".format(exc)
2398             ret["result"] = False
2399             return ret
2400     if does_exist and (state(name, path=path) != "running"):
2401         try:
2402             start(name, path=path)
2403         except (SaltInvocationError, CommandExecutionError) as exc:
2404             ret["comment"] = "Unable to stop container: {}".format(exc)
2405             ret["result"] = False
2406             return ret
2407     ret["changes"][name] = "rebooted"
2408     return ret
2409 def reconfigure(
2410     name,
2411     cpu=None,
2412     cpuset=None,
2413     cpushare=None,
2414     memory=None,
2415     profile=None,
2416     network_profile=None,
2417     nic_opts=None,
2418     bridge=None,
2419     gateway=None,
2420     autostart=None,
2421     utsname=None,
2422     rootfs=None,
2423     path=None,
2424     **kwargs
2425 ):
2426     changes = {}
2427     cpath = get_root_path(path)
2428     path = os.path.join(cpath, name, "config")
2429     ret = {
2430         "name": name,
2431         "comment": "config for {} up to date".format(name),
2432         "result": True,
2433         "changes": changes,
2434     }
2435     profile = get_container_profile(copy.deepcopy(profile))
2436     kw_overrides = copy.deepcopy(kwargs)
2437     def select(key, default=None):
2438         kw_overrides_match = kw_overrides.pop(key, _marker)
2439         profile_match = profile.pop(key, default)
2440         if kw_overrides_match is _marker:
2441             return profile_match
2442         return kw_overrides_match
2443     if nic_opts is not None and not network_profile:
2444         network_profile = DEFAULT_NIC
2445     if autostart is not None:
2446         autostart = select("autostart", autostart)
2447     else:
2448         autostart = "keep"
2449     if not utsname:
2450         utsname = select("utsname", utsname)
2451     if os.path.exists(path):
2452         old_chunks = read_conf(path, out_format="commented")
2453         make_kw = salt.utils.odict.OrderedDict(
2454             [
2455                 ("utsname", utsname),
2456                 ("rootfs", rootfs),
2457                 ("autostart", autostart),
2458                 ("cpu", cpu),
2459                 ("gateway", gateway),
2460                 ("cpuset", cpuset),
2461                 ("cpushare", cpushare),
2462                 ("network_profile", network_profile),
2463                 ("nic_opts", nic_opts),
2464                 ("bridge", bridge),
2465             ]
2466         )
2467         if memory:
2468             make_kw["memory"] = memory
2469         kw = salt.utils.odict.OrderedDict()
2470         for key, val in make_kw.items():
2471             if val is not None:
2472                 kw[key] = val
2473         new_cfg = _config_list(conf_tuples=old_chunks, **kw)
2474         if new_cfg:
2475             edit_conf(path, out_format="commented", lxc_config=new_cfg)
2476         chunks = read_conf(path, out_format="commented")
2477         if old_chunks != chunks:
2478             ret["comment"] = "{} lxc config updated".format(name)
2479             if state(name, path=path) == "running":
2480                 cret = reboot(name, path=path)
2481                 ret["result"] = cret["result"]
2482     return ret
2483 def apply_network_profile(name, network_profile, nic_opts=None, path=None):
2484     cpath = get_root_path(path)
2485     cfgpath = os.path.join(cpath, name, "config")
2486     before = []
2487     with salt.utils.files.fopen(cfgpath, "r") as fp_:
2488         for line in fp_:
2489             before.append(line)
2490     lxcconfig = _LXCConfig(name=name, path=path)
2491     old_net = lxcconfig._filter_data("lxc.network")
2492     network_params = {}
2493     for param in _network_conf(
2494         conf_tuples=old_net, network_profile=network_profile, nic_opts=nic_opts
2495     ):
2496         network_params.update(param)
2497     if network_params:
2498         edit_conf(cfgpath, out_format="commented", **network_params)
2499     after = []
2500     with salt.utils.files.fopen(cfgpath, "r") as fp_:
2501         for line in fp_:
2502             after.append(line)
2503     diff = ""
2504     for line in difflib.unified_diff(before, after, fromfile="before", tofile="after"):
2505         diff += line
2506     return diff
2507 def get_pid(name, path=None):
2508     if name not in list_(limit="running", path=path):
2509         raise CommandExecutionError(
2510             "Container {} is not running, can't determine PID".format(name)
2511         )
2512     info = __salt__["cmd.run"]("lxc-info -n {}".format(name)).split("\n")
2513     pid = [
2514         line.split(":")[1].strip()
2515         for line in info
2516         if re.match(r"\s*PID", line) is not None
2517     ][0]
2518     return pid
2519 def add_veth(name, interface_name, bridge=None, path=None):
2520     pid = get_pid(name, path=path)
2521     while True:
2522         random_veth = "veth" + "".join(
2523             random.choice(string.ascii_uppercase + string.digits) for _ in range(6)
2524         )
2525         if random_veth not in __salt__["network.interfaces"]().keys():
2526             break
2527     if not __salt__["file.directory_exists"]("/var/run/"):
2528         raise CommandExecutionError(
2529             "Directory /var/run required for lxc.add_veth doesn't exists"
2530         )
2531     if not __salt__["file.file_exists"]("/proc/{}/ns/net".format(pid)):
2532         raise CommandExecutionError(
2533             "Proc file for container {} network namespace doesn't exists".format(name)
2534         )
2535     if not __salt__["file.directory_exists"]("/var/run/netns"):
2536         __salt__["file.mkdir"]("/var/run/netns")
2537     if __salt__["file.is_link"]("/var/run/netns/{}".format(name)):
2538         __salt__["file.remove"]("/var/run/netns/{}".format(name))
2539     __salt__["file.symlink"](
2540         "/proc/{}/ns/net".format(pid), "/var/run/netns/{}".format(name)
2541     )
2542     interface_exists = 0 == __salt__["cmd.retcode"](
2543         "ip netns exec {netns} ip address list {interface}".format(
2544             netns=name, interface=interface_name
2545         )
2546     )
2547     if interface_exists:
2548         raise CommandExecutionError(
2549             "Interface {interface} already exists in {container}".format(
2550                 interface=interface_name, container=name
2551             )
2552         )
2553     if (
2554         __salt__["cmd.retcode"](
2555             "ip link add name {veth} type veth peer name {veth}_c".format(
2556                 veth=random_veth
2557             )
2558         )
2559         != 0
2560     ):
2561         raise CommandExecutionError(
2562             "Error while creating the veth pair {}".format(random_veth)
2563         )
2564     if __salt__["cmd.retcode"]("ip link set dev {} up".format(random_veth)) != 0:
2565         raise CommandExecutionError(
2566             "Error while bringing up host-side veth {}".format(random_veth)
2567         )
2568     attached = 0 == __salt__["cmd.retcode"](
2569         "ip link set dev {veth}_c netns {container} name {interface_name}".format(
2570             veth=random_veth, container=name, interface_name=interface_name
2571         )
2572     )
2573     if not attached:
2574         raise CommandExecutionError(
2575             "Error while attaching the veth {veth} to container {container}".format(
2576                 veth=random_veth, container=name
2577             )
2578         )
2579     __salt__["file.remove"]("/var/run/netns/{}".format(name))
2580     if bridge is not None:
2581         __salt__["bridge.addif"](bridge, random_veth)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ciscoconfparse_mod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from salt.exceptions import SaltException
2 try:
3     import ciscoconfparse
4     HAS_CISCOCONFPARSE = True
5 except ImportError:
6     HAS_CISCOCONFPARSE = False
7 __virtualname__ = "ciscoconfparse"
8 def __virtual__():
9     if HAS_CISCOCONFPARSE:
10         return HAS_CISCOCONFPARSE
11     else:
12         return (False, "Missing dependency ciscoconfparse")
13 def _get_ccp(config=None, config_path=None, saltenv="base"):
14     if config_path:
15         config = __salt__["cp.get_file_str"](config_path, saltenv=saltenv)
16         if config is False:
17             raise SaltException("{} is not available".format(config_path))
18     if isinstance(config, str):
19         config = config.splitlines()
20     ccp = ciscoconfparse.CiscoConfParse(config)
21     return ccp
22 def find_objects(config=None, config_path=None, regex=None, saltenv="base"):
23     ccp = _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
24     lines = ccp.find_objects(regex)
25     return lines
26 def find_lines(config=None, config_path=None, regex=None, saltenv="base"):
27     lines = find_objects(
28         config=config, config_path=config_path, regex=regex, saltenv<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=saltenv
29     )
30     return [line.text for line in lines]
31 def find_objects_w_child(
32     config=None,
33     config_path=None,
34     parent_regex=None,
35     child_regex=None,
36     ignore_ws=False,
37     saltenv="base",
38 ):
39     ccp =</b></font> _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
40     lines = ccp.find_objects_w_child(parent_regex, child_regex, ignore_ws=ignore_ws)
41     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return lines
42 def find_lines_w_child(
43     config=None,
44     config_path=None,
45     parent_regex=None,
46     child_regex=None,
47     ignore_ws=False,
48     saltenv="base",
49 ):
50     r"""
51     Return a list of parent lines (as text)  matching the regular expression
52     ``parent_regex`` that have children lines matching ``child_regex``.
53     config
54         The configuration sent as text.
55         .. note::
56             This argument is ignored when ``config_path`` is specified.
57     config_path
58         The absolute or remote path to the file with the configuration to be
59         parsed. This argument supports the usual Salt filesystem URIs, e.g.,
60         ``salt://``, ``https://``, ``ftp://``, ``s3://``, etc.
61     parent_regex
62         The regular expression to match the parent lines against.
63     child_regex
64         The regular expression to match the child lines against.
65     ignore_ws: ``False``
66         Whether to ignore the white spaces.
67     saltenv: ``base``
68         Salt fileserver environment from which to retrieve the file. This
69         argument is ignored when ``config_path`` is not a ``salt://`` URL.
70     CLI Example:
71     .. code-block:: bash
72         salt '*' ciscoconfparse.find_lines_w_child config_path=https://bit.ly/2mAdq7z parent_line='line con' child_line='stopbits'
73         salt '*' ciscoconfparse.find_lines_w_child config_path=https://bit.ly/2uIRxau parent_regex='ge-(.*)' child_regex='unit \d+'
74         config=</b></font>config,
75         config_path=config_path,
76         parent_regex=parent_regex,
77         child_regex=child_regex,
78         ignore_ws=ignore_ws,
79         saltenv=saltenv,
80     )
81     return [line.text for line in lines]
82 def find_objects_wo_child(
83     config=None,
84     config_path=None,
85     parent_regex=None,
86     child_regex=None,
87     ignore_ws=False,
88     saltenv="base",
89 ):
90     ccp = _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
91     lines = ccp.find_objects_wo_child(parent_regex, child_regex, ignore_ws=ignore_ws)
92     return lines
93 def find_lines_wo_child(
94     config=None,
95     config_path=None,
96     parent_regex=None,
97     child_regex=None,
98     ignore_ws=False,
99     saltenv="base",
100 ):
101     lines = find_objects_wo_child(
102         config=config,
103         config_path=config_path,
104         parent_regex=parent_regex,
105         child_regex=child_regex,
106         ignore_ws=ignore_ws,
107         saltenv=saltenv,
108     )
109     return [line.text for line in lines]
110 def filter_lines(
111     config=None, config_path=None, parent_regex=None, child_regex=None, saltenv="base"
112 ):
113     ret = []
114     ccp = _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
115     parent_lines = ccp.find_objects(parent_regex)
116     for parent_line in parent_lines:
117         child_lines = parent_line.re_search_children(child_regex)
118         if child_lines:
119             for child_line in child_lines:
120                 ret.append(
121                     {
122                         "match": True,
123                         "parent": parent_line.text,
124                         "child": child_line.text,
125                     }
126                 )
127         else:
128             ret.append({"match": False, "parent": parent_line.text, "child": None})
129     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
