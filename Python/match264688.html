<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lxc_1.py &amp; ciscoconfparse_mod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lxc_1.py &amp; ciscoconfparse_mod.py
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lxc_1.py (0.48115477%)<th>ciscoconfparse_mod.py (13.483146%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(3676-3689)<td><a href="#" name="0">(155-212)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(2281-2295)<td><a href="#" name="1">(214-261)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import difflib
4 import logging
5 import os
6 import pipes
7 import random
8 import re
9 import shutil
10 import string
11 import tempfile
12 import textwrap
13 import time
14 import urllib.parse
15 import salt.config
16 import salt.utils.args
17 import salt.utils.cloud
18 import salt.utils.data
19 import salt.utils.dictupdate
20 import salt.utils.files
21 import salt.utils.functools
22 import salt.utils.hashutils
23 import salt.utils.network
24 import salt.utils.odict
25 import salt.utils.path
26 import salt.utils.stringutils
27 from salt.exceptions import CommandExecutionError, SaltInvocationError
28 from salt.utils.versions import LooseVersion as _LooseVersion
29 log = logging.getLogger(__name__)
30 __func_alias__ = {"list_": "list", "ls_": "ls"}
31 __virtualname__ = "lxc"
32 DEFAULT_NIC = "eth0"
33 DEFAULT_BR = "br0"
34 SEED_MARKER = "/lxc.initial_seed"
35 EXEC_DRIVER = "lxc-attach"
36 DEFAULT_PATH = "/var/lib/lxc"
37 _marker = object()
38 def __virtual__():
39     if salt.utils.path.which("lxc-start"):
40         return __virtualname__
41     return (
42         False,
43         "The lxc execution module cannot be loaded: the lxc-start binary is not in the"
44         " path.",
45     )
46 def get_root_path(path):
47     if not path:
48         path = __opts__.get("lxc.root_path", DEFAULT_PATH)
49     return path
50 def version():
51     k = "lxc.version"
52     if not __context__.get(k, None):
53         cversion = __salt__["cmd.run_all"]("lxc-info --version")
54         if not cversion["retcode"]:
55             ver = _LooseVersion(cversion["stdout"])
56             if ver &lt; _LooseVersion("1.0"):
57                 raise CommandExecutionError("LXC should be at least 1.0")
58             __context__[k] = "{}".format(ver)
59     return __context__.get(k, None)
60 def _clear_context():
61     for var in [x for x in __context__ if x.startswith("lxc.")]:
62         log.trace("Clearing __context__['%s']", var)
63         __context__.pop(var, None)
64 def _ip_sort(ip):
65     idx = "001"
66     if ip == "127.0.0.1":
67         idx = "200"
68     if ip == "::1":
69         idx = "201"
70     elif "::" in ip:
71         idx = "100"
72     return "{}___{}".format(idx, ip)
73 def search_lxc_bridges():
74     bridges = __context__.get("lxc.bridges", None)
75     if not bridges:
76         bridges = set()
77         running_bridges = set()
78         bridges.add(DEFAULT_BR)
79         try:
80             output = __salt__["cmd.run_all"]("brctl show")
81             for line in output["stdout"].splitlines()[1:]:
82                 if not line.startswith(" "):
83                     running_bridges.add(line.split()[0].strip())
84         except (SaltInvocationError, CommandExecutionError):
85             pass
86         for ifc, ip in __grains__.get("ip_interfaces", {}).items():
87             if ifc in running_bridges:
88                 bridges.add(ifc)
89             elif os.path.exists("/sys/devices/virtual/net/{}/bridge".format(ifc)):
90                 bridges.add(ifc)
91         bridges = list(bridges)
92         def sort_bridges(a):
93             pref = "z"
94             if "lxc" in a:
95                 pref = "a"
96             elif "br0" == a:
97                 pref = "c"
98             return "{}_{}".format(pref, a)
99         bridges.sort(key=sort_bridges)
100         __context__["lxc.bridges"] = bridges
101     return bridges
102 def search_lxc_bridge():
103     return search_lxc_bridges()[0]
104 def _get_salt_config(config, **kwargs):
105     if not config:
106         config = kwargs.get("minion", {})
107     if not config:
108         config = {}
109     config.setdefault(
110         "master", kwargs.get("master", __opts__.get("master", __opts__["id"]))
111     )
112     config.setdefault(
113         "master_port",
114         kwargs.get(
115             "master_port",
116             __opts__.get("master_port", __opts__.get("ret_port", __opts__.get("4506"))),
117         ),
118     )
119     if not config["master"]:
120         config = {}
121     return config
122 def cloud_init_interface(name, vm_=None, **kwargs):
123     if vm_ is None:
124         vm_ = {}
125     vm_ = copy.deepcopy(vm_)
126     vm_ = salt.utils.dictupdate.update(vm_, kwargs)
127     profile_data = copy.deepcopy(vm_.get("lxc_profile", vm_.get("profile", {})))
128     if not isinstance(profile_data, (dict, (str,))):
129         profile_data = {}
130     profile = get_container_profile(profile_data)
131     def _cloud_get(k, default=None):
132         return vm_.get(k, profile.get(k, default))
133     if name is None:
134         name = vm_["name"]
135     default_template = ""
136     if __grains__.get("os", "") in ["Ubuntu"]:
137         default_template = "ubuntu"
138     image = _cloud_get("image")
139     if not image:
140         _cloud_get("template", default_template)
141     backing = _cloud_get("backing", "dir")
142     if image:
143         profile["template"] = image
144     vgname = _cloud_get("vgname", None)
145     if vgname:
146         profile["vgname"] = vgname
147     if backing:
148         profile["backing"] = backing
149     snapshot = _cloud_get("snapshot", False)
150     autostart = bool(_cloud_get("autostart", True))
151     dnsservers = _cloud_get("dnsservers", [])
152     dns_via_dhcp = _cloud_get("dns_via_dhcp", True)
153     password = _cloud_get("password", "s3cr3t")
154     password_encrypted = _cloud_get("password_encrypted", False)
155     fstype = _cloud_get("fstype", None)
156     lvname = _cloud_get("lvname", None)
157     thinpool = _cloud_get("thinpool", None)
158     pub_key = _cloud_get("pub_key", None)
159     priv_key = _cloud_get("priv_key", None)
160     size = _cloud_get("size", "20G")
161     script = _cloud_get("script", None)
162     script_args = _cloud_get("script_args", None)
163     users = _cloud_get("users", None)
164     if users is None:
165         users = []
166     ssh_username = _cloud_get("ssh_username", None)
167     if ssh_username and (ssh_username not in users):
168         users.append(ssh_username)
169     network_profile = _cloud_get("network_profile", None)
170     nic_opts = kwargs.get("nic_opts", None)
171     netmask = _cloud_get("netmask", "24")
172     path = _cloud_get("path", None)
173     bridge = _cloud_get("bridge", None)
174     gateway = _cloud_get("gateway", None)
175     unconditional_install = _cloud_get("unconditional_install", False)
176     force_install = _cloud_get("force_install", True)
177     config = _get_salt_config(_cloud_get("config", {}), **vm_)
178     default_nic = _cloud_get("default_nic", DEFAULT_NIC)
179     if not isinstance(nic_opts, dict):
180         nic_opts = salt.utils.odict.OrderedDict()
181     eth0 = nic_opts.setdefault(default_nic, salt.utils.odict.OrderedDict())
182     if not isinstance(nic_opts, salt.utils.odict.OrderedDict):
183         bnic_opts = salt.utils.odict.OrderedDict()
184         bnic_opts.update(nic_opts)
185         nic_opts = bnic_opts
186     gw = None
187     bridge = _cloud_get("bridge", None)
188     ip = _cloud_get("ip", None)
189     mac = _cloud_get("mac", None)
190     if ip:
191         fullip = ip
192         if netmask:
193             fullip += "/{}".format(netmask)
194         eth0["ipv4"] = fullip
195         if mac is not None:
196             eth0["mac"] = mac
197     for ix, iopts in enumerate(_cloud_get("additional_ips", [])):
198         ifh = "eth{}".format(ix + 1)
199         ethx = nic_opts.setdefault(ifh, {})
200         if gw is None:
201             gw = iopts.get("gateway", ethx.get("gateway", None))
202             if gw:
203                 eth0.pop("gateway", None)
204                 gateway = None
205                 ethx["gateway"] = gw
206         elink = iopts.get("link", ethx.get("link", None))
207         if elink:
208             ethx["link"] = elink
209         aip = iopts.get("ipv4", iopts.get("ip", None))
210         if aip:
211             ethx["ipv4"] = aip
212         nm = iopts.get("netmask", "")
213         if nm:
214             ethx["ipv4"] += "/{}".format(nm)
215         for i in ("mac", "hwaddr"):
216             if i in iopts:
217                 ethx["mac"] = iopts[i]
218                 break
219         if "mac" not in ethx:
220             ethx["mac"] = salt.utils.network.gen_mac()
221     gw = None
222     for ethx in [a for a in nic_opts]:
223         ndata = nic_opts[ethx]
224         if gw:
225             ndata.pop("gateway", None)
226         if "gateway" in ndata:
227             gw = ndata["gateway"]
228             gateway = None
229     if bridge:
230         eth0["link"] = bridge
231     if gateway:
232         eth0["gateway"] = gateway
233     lxc_init_interface = {}
234     lxc_init_interface["name"] = name
235     lxc_init_interface["config"] = config
236     lxc_init_interface["memory"] = _cloud_get("memory", 0)  # nolimit
237     lxc_init_interface["pub_key"] = pub_key
238     lxc_init_interface["priv_key"] = priv_key
239     lxc_init_interface["nic_opts"] = nic_opts
240     for clone_from in ["clone_from", "clone", "from_container"]:
241         lxc_init_interface["clone_from"] = _cloud_get(clone_from, None)
242         if lxc_init_interface["clone_from"] is not None:
243             break
244     lxc_init_interface["profile"] = profile
245     lxc_init_interface["snapshot"] = snapshot
246     lxc_init_interface["dnsservers"] = dnsservers
247     lxc_init_interface["fstype"] = fstype
248     lxc_init_interface["path"] = path
249     lxc_init_interface["vgname"] = vgname
250     lxc_init_interface["size"] = size
251     lxc_init_interface["lvname"] = lvname
252     lxc_init_interface["thinpool"] = thinpool
253     lxc_init_interface["force_install"] = force_install
254     lxc_init_interface["unconditional_install"] = unconditional_install
255     lxc_init_interface["bootstrap_url"] = script
256     lxc_init_interface["bootstrap_args"] = script_args
257     lxc_init_interface["bootstrap_shell"] = _cloud_get("bootstrap_shell", "sh")
258     lxc_init_interface["bootstrap_delay"] = _cloud_get("bootstrap_delay", None)
259     lxc_init_interface["autostart"] = autostart
260     lxc_init_interface["users"] = users
261     lxc_init_interface["password"] = password
262     lxc_init_interface["password_encrypted"] = password_encrypted
263     lxc_init_interface["network_profile"] = network_profile
264     for i in ["cpu", "cpuset", "cpushare"]:
265         if _cloud_get(i, None):
266             try:
267                 lxc_init_interface[i] = vm_[i]
268             except KeyError:
269                 lxc_init_interface[i] = profile[i]
270     return lxc_init_interface
271 def _get_profile(key, name, **kwargs):
272     if isinstance(name, dict):
273         profilename = name.pop("name", None)
274         return _get_profile(key, profilename, **name)
275     if name is None:
276         profile_match = {}
277     else:
278         profile_match = __salt__["config.get"](
279             "lxc.{1}:{0}".format(name, key), default=None, merge="recurse"
280         )
281         if profile_match is None:
282             profile_match = {}
283     if not isinstance(profile_match, dict):
284         raise CommandExecutionError("lxc.{} must be a dictionary".format(key))
285     overrides = salt.utils.args.clean_kwargs(**copy.deepcopy(kwargs))
286     profile_match = salt.utils.dictupdate.update(
287         copy.deepcopy(profile_match), overrides
288     )
289     return profile_match
290 def get_container_profile(name=None, **kwargs):
291     profile = _get_profile("container_profile", name, **kwargs)
292     return profile
293 def get_network_profile(name=None, **kwargs):
294     profile = _get_profile("network_profile", name, **kwargs)
295     return profile
296 def _rand_cpu_str(cpu):
297     cpu = int(cpu)
298     avail = __salt__["status.nproc"]()
299     if cpu &lt; avail:
300         return "0-{}".format(avail)
301     to_set = set()
302     while len(to_set) &lt; cpu:
303         choice = random.randint(0, avail - 1)
304         if choice not in to_set:
305             to_set.add(str(choice))
306     return ",".join(sorted(to_set))
307 def _network_conf(conf_tuples=None, **kwargs):
308     nic = kwargs.get("network_profile", None)
309     ret = []
310     nic_opts = kwargs.get("nic_opts", {})
311     if nic_opts is None:
312         nic_opts = {}
313     if not conf_tuples:
314         conf_tuples = []
315     old = _get_veths(conf_tuples)
316     if not old:
317         old = {}
318     if nic and isinstance(nic, ((str,), dict)):
319         nicp = get_network_profile(nic)
320     else:
321         nicp = {}
322     if DEFAULT_NIC not in nicp:
323         nicp[DEFAULT_NIC] = {}
324     kwargs = copy.deepcopy(kwargs)
325     gateway = kwargs.pop("gateway", None)
326     bridge = kwargs.get("bridge", None)
327     if nic_opts:
328         for dev, args in nic_opts.items():
329             ethx = nicp.setdefault(dev, {})
330             try:
331                 ethx = salt.utils.dictupdate.update(ethx, args)
332             except AttributeError:
333                 raise SaltInvocationError("Invalid nic_opts configuration")
334     ifs = [a for a in nicp]
335     ifs += [a for a in old if a not in nicp]
336     ifs.sort()
337     gateway_set = False
338     for dev in ifs:
339         args = nicp.get(dev, {})
340         opts = nic_opts.get(dev, {}) if nic_opts else {}
341         old_if = old.get(dev, {})
342         disable = opts.get("disable", args.get("disable", False))
343         if disable:
344             continue
345         mac = opts.get(
346             "mac", opts.get("hwaddr", args.get("mac", args.get("hwaddr", "")))
347         )
348         type_ = opts.get("type", args.get("type", ""))
349         flags = opts.get("flags", args.get("flags", ""))
350         link = opts.get("link", args.get("link", ""))
351         ipv4 = opts.get("ipv4", args.get("ipv4", ""))
352         ipv6 = opts.get("ipv6", args.get("ipv6", ""))
353         infos = salt.utils.odict.OrderedDict(
354             [
355                 (
356                     "lxc.network.type",
357                     {
358                         "test": not type_,
359                         "value": type_,
360                         "old": old_if.get("lxc.network.type"),
361                         "default": "veth",
362                     },
363                 ),
364                 (
365                     "lxc.network.name",
366                     {"test": False, "value": dev, "old": dev, "default": dev},
367                 ),
368                 (
369                     "lxc.network.flags",
370                     {
371                         "test": not flags,
372                         "value": flags,
373                         "old": old_if.get("lxc.network.flags"),
374                         "default": "up",
375                     },
376                 ),
377                 (
378                     "lxc.network.link",
379                     {
380                         "test": not link,
381                         "value": link,
382                         "old": old_if.get("lxc.network.link"),
383                         "default": search_lxc_bridge(),
384                     },
385                 ),
386                 (
387                     "lxc.network.hwaddr",
388                     {
389                         "test": not mac,
390                         "value": mac,
391                         "old": old_if.get("lxc.network.hwaddr"),
392                         "default": salt.utils.network.gen_mac(),
393                     },
394                 ),
395                 (
396                     "lxc.network.ipv4",
397                     {
398                         "test": not ipv4,
399                         "value": ipv4,
400                         "old": old_if.get("lxc.network.ipv4", ""),
401                         "default": None,
402                     },
403                 ),
404                 (
405                     "lxc.network.ipv6",
406                     {
407                         "test": not ipv6,
408                         "value": ipv6,
409                         "old": old_if.get("lxc.network.ipv6", ""),
410                         "default": None,
411                     },
412                 ),
413             ]
414         )
415         for info in list(infos.keys()):
416             bundle = infos[info]
417             if bundle["test"]:
418                 if bundle["old"]:
419                     bundle["value"] = bundle["old"]
420                 elif bundle["default"]:
421                     bundle["value"] = bundle["default"]
422         for info, data in infos.items():
423             if data["value"]:
424                 ret.append({info: data["value"]})
425         for key, val in args.items():
426             if key == "link" and bridge:
427                 val = bridge
428             val = opts.get(key, val)
429             if key in [
430                 "type",
431                 "flags",
432                 "name",
433                 "gateway",
434                 "mac",
435                 "link",
436                 "ipv4",
437                 "ipv6",
438             ]:
439                 continue
440             ret.append({"lxc.network.{}".format(key): val})
441         if not gateway:
442             gateway = args.get("gateway", None)
443         if gateway is not None and not gateway_set:
444             ret.append({"lxc.network.ipv4.gateway": gateway})
445             gateway_set = True
446     if gateway is not None and not gateway_set:
447         ret.append({"lxc.network.ipv4.gateway": gateway})
448         gateway_set = True
449     new = _get_veths(ret)
450     for iface in [a for a in new]:
451         ndata = new[iface]
452         nmac = ndata.get("lxc.network.hwaddr", "")
453         ntype = ndata.get("lxc.network.type", "")
454         omac, otype = "", ""
455         if iface in old:
456             odata = old[iface]
457             omac = odata.get("lxc.network.hwaddr", "")
458             otype = odata.get("lxc.network.type", "")
459         if otype and not ntype:
460             ntype = otype
461         if not ntype:
462             ntype = "veth"
463         new[iface]["lxc.network.type"] = ntype
464         if omac and not nmac:
465             new[iface]["lxc.network.hwaddr"] = omac
466     ret = []
467     for val in new.values():
468         for row in val:
469             ret.append(salt.utils.odict.OrderedDict([(row, val[row])]))
470     if (
471         _LooseVersion(version()) &lt;= _LooseVersion("1.0.7")
472         and True not in ["lxc.network.ipv4.gateway" in a for a in ret]
473         and True in ["lxc.network.ipv4" in a for a in ret]
474     ):
475         ret.append({"lxc.network.ipv4.gateway": "auto"})
476     return ret
477 def _get_lxc_default_data(**kwargs):
478     kwargs = copy.deepcopy(kwargs)
479     ret = {}
480     for k in ["utsname", "rootfs"]:
481         val = kwargs.get(k, None)
482         if val is not None:
483             ret["lxc.{}".format(k)] = val
484     autostart = kwargs.get("autostart")
485     if autostart is None:
486         autostart = True
487     if autostart != "keep":
488         if autostart:
489             ret["lxc.start.auto"] = "1"
490         else:
491             ret["lxc.start.auto"] = "0"
492     memory = kwargs.get("memory")
493     if memory is not None:
494         ret["lxc.cgroup.memory.limit_in_bytes"] = memory * 1024 * 1024
495     cpuset = kwargs.get("cpuset")
496     if cpuset:
497         ret["lxc.cgroup.cpuset.cpus"] = cpuset
498     cpushare = kwargs.get("cpushare")
499     cpu = kwargs.get("cpu")
500     if cpushare:
501         ret["lxc.cgroup.cpu.shares"] = cpushare
502     if cpu and not cpuset:
503         ret["lxc.cgroup.cpuset.cpus"] = _rand_cpu_str(cpu)
504     return ret
505 def _config_list(conf_tuples=None, only_net=False, **kwargs):
506     only_net = bool(only_net)
507     if not conf_tuples:
508         conf_tuples = []
509     kwargs = copy.deepcopy(kwargs)
510     ret = []
511     if not only_net:
512         default_data = _get_lxc_default_data(**kwargs)
513         for k, val in default_data.items():
514             ret.append({k: val})
515     net_datas = _network_conf(conf_tuples=conf_tuples, **kwargs)
516     ret.extend(net_datas)
517     return ret
518 def _get_veths(net_data):
519     if isinstance(net_data, dict):
520         net_data = list(net_data.items())
521     nics = salt.utils.odict.OrderedDict()
522     current_nic = salt.utils.odict.OrderedDict()
523     no_names = True
524     for item in net_data:
525         if item and isinstance(item, dict):
526             item = list(item.items())[0]
527         elif isinstance(item, str):
528             sitem = item.strip()
529             if sitem.startswith("#") or not sitem:
530                 continue
531             elif "=" in item:
532                 item = tuple(a.strip() for a in item.split("=", 1))
533         if item[0] == "lxc.network.type":
534             current_nic = salt.utils.odict.OrderedDict()
535         if item[0] == "lxc.network.name":
536             no_names = False
537             nics[item[1].strip()] = current_nic
538         current_nic[item[0].strip()] = item[1].strip()
539     if no_names and current_nic:
540         nics[DEFAULT_NIC] = current_nic
541     return nics
542 class _LXCConfig:
543     pattern = re.compile(r"^(\S+)(\s*)(=)(\s*)(.*)")
544     non_interpretable_pattern = re.compile(r"^((#.*)|(\s*))$")
545     def __init__(self, **kwargs):
546         kwargs = copy.deepcopy(kwargs)
547         self.name = kwargs.pop("name", None)
548         path = get_root_path(kwargs.get("path", None))
549         self.data = []
550         if self.name:
551             self.path = os.path.join(path, self.name, "config")
552             if os.path.isfile(self.path):
553                 with salt.utils.files.fopen(self.path) as fhr:
554                     for line in salt.utils.data.decode(fhr.readlines()):
555                         match = self.pattern.findall(line.strip())
556                         if match:
557                             self.data.append((match[0][0], match[0][-1]))
558                         match = self.non_interpretable_pattern.findall(line.strip())
559                         if match:
560                             self.data.append(("", match[0][0]))
561         else:
562             self.path = None
563         def _replace(key, val):
564             if val:
565                 self._filter_data(key)
566                 self.data.append((key, val))
567         default_data = _get_lxc_default_data(**kwargs)
568         for key, val in default_data.items():
569             _replace(key, val)
570         old_net = self._filter_data("lxc.network")
571         net_datas = _network_conf(conf_tuples=old_net, **kwargs)
572         if net_datas:
573             for row in net_datas:
574                 self.data.extend(list(row.items()))
575         for idx in ["lxc.cgroup.memory.limit_in_bytes"]:
576             if not default_data.get(idx):
577                 self._filter_data(idx)
578     def as_string(self):
579         chunks = (
580             "{0[0]}{1}{0[1]}".format(item, (" = " if item[0] else ""))
581             for item in self.data
582         )
583         return "\n".join(chunks) + "\n"
584     def write(self):
585         if self.path:
586             content = self.as_string()
587             with salt.utils.files.fopen(self.path, "w") as fic:
588                 fic.write(salt.utils.stringutils.to_str(content))
589                 fic.flush()
590     def tempfile(self):
591         ntf = tempfile.NamedTemporaryFile()
592         ntf.write(self.as_string())
593         ntf.flush()
594         return ntf
595     def _filter_data(self, pattern):
596         removed = []
597         filtered = []
598         for param in self.data:
599             if not param[0].startswith(pattern):
600                 filtered.append(param)
601             else:
602                 removed.append(param)
603         self.data = filtered
604         return removed
605 def _get_base(**kwargs):
606     profile = get_container_profile(copy.deepcopy(kwargs.get("profile")))
607     kw_overrides = copy.deepcopy(kwargs)
608     def select(key, default=None):
609         kw_overrides_match = kw_overrides.pop(key, _marker)
610         profile_match = profile.pop(key, default)
611         if kw_overrides_match is _marker:
612             return profile_match
613         return kw_overrides_match
614     template = select("template")
615     image = select("image")
616     vgname = select("vgname")
617     path = kwargs.get("path", None)
618     for param in ("path", "image", "vgname", "template"):
619         kwargs.pop(param, None)
620     if image:
621         proto = urllib.parse.urlparse(image).scheme
622         img_tar = __salt__["cp.cache_file"](image)
623         img_name = os.path.basename(img_tar)
624         hash_ = salt.utils.hashutils.get_hash(
625             img_tar, __salt__["config.get"]("hash_type")
626         )
627         name = "__base_{}_{}_{}".format(proto, img_name, hash_)
628         if not exists(name, path=path):
629             create(
630                 name, template=template, image=image, path=path, vgname=vgname, **kwargs
631             )
632             if vgname:
633                 rootfs = os.path.join("/dev", vgname, name)
634                 edit_conf(
635                     info(name, path=path)["config"],
636                     out_format="commented",
637                     **{"lxc.rootfs": rootfs}
638                 )
639         return name
640     elif template:
641         name = "__base_{}".format(template)
642         if not exists(name, path=path):
643             create(
644                 name, template=template, image=image, path=path, vgname=vgname, **kwargs
645             )
646             if vgname:
647                 rootfs = os.path.join("/dev", vgname, name)
648                 edit_conf(
649                     info(name, path=path)["config"],
650                     out_format="commented",
651                     **{"lxc.rootfs": rootfs}
652                 )
653         return name
654     return ""
655 def init(
656     name,
657     config=None,
658     cpuset=None,
659     cpushare=None,
660     memory=None,
661     profile=None,
662     network_profile=None,
663     nic_opts=None,
664     cpu=None,
665     autostart=True,
666     password=None,
667     password_encrypted=None,
668     users=None,
669     dnsservers=None,
670     searchdomains=None,
671     bridge=None,
672     gateway=None,
673     pub_key=None,
674     priv_key=None,
675     force_install=False,
676     unconditional_install=False,
677     bootstrap_delay=None,
678     bootstrap_args=None,
679     bootstrap_shell=None,
680     bootstrap_url=None,
681     **kwargs
682 ):
683     ret = {"name": name, "changes": {}}
684     profile = get_container_profile(copy.deepcopy(profile))
685     if not network_profile:
686         network_profile = profile.get("network_profile")
687     if not network_profile:
688         network_profile = DEFAULT_NIC
689     changes_dict = {"init": []}
690     changes = changes_dict.get("init")
691     if users is None:
692         users = []
693     dusers = ["root"]
694     for user in dusers:
695         if user not in users:
696             users.append(user)
697     kw_overrides = copy.deepcopy(kwargs)
698     def select(key, default=None):
699         kw_overrides_match = kw_overrides.pop(key, _marker)
700         profile_match = profile.pop(key, default)
701         if kw_overrides_match is _marker:
702             return profile_match
703         return kw_overrides_match
704     path = select("path")
705     bpath = get_root_path(path)
706     state_pre = state(name, path=path)
707     tvg = select("vgname")
708     vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
709     start_ = select("start", True)
710     autostart = select("autostart", autostart)
711     seed = select("seed", True)
712     install = select("install", True)
713     seed_cmd = select("seed_cmd")
714     salt_config = _get_salt_config(config, **kwargs)
715     approve_key = select("approve_key", True)
716     clone_from = select("clone_from")
717     if vgname and not clone_from:
718         try:
719             kwargs["vgname"] = vgname
720             clone_from = _get_base(profile=profile, **kwargs)
721         except (SaltInvocationError, CommandExecutionError) as exc:
722             ret["comment"] = exc.strerror
723             if changes:
724                 ret["changes"] = changes_dict
725             return ret
726         if not kwargs.get("snapshot") is False:
727             kwargs["snapshot"] = True
728     does_exist = exists(name, path=path)
729     to_reboot = False
730     remove_seed_marker = False
731     if does_exist:
732         pass
733     elif clone_from:
734         remove_seed_marker = True
735         try:
736             clone(name, clone_from, profile=profile, **kwargs)
737             changes.append({"create": "Container cloned"})
738         except (SaltInvocationError, CommandExecutionError) as exc:
739             if "already exists" in exc.strerror:
740                 changes.append({"create": "Container already exists"})
741             else:
742                 ret["result"] = False
743                 ret["comment"] = exc.strerror
744                 if changes:
745                     ret["changes"] = changes_dict
746                 return ret
747         cfg = _LXCConfig(
748             name=name,
749             network_profile=network_profile,
750             nic_opts=nic_opts,
751             bridge=bridge,
752             path=path,
753             gateway=gateway,
754             autostart=autostart,
755             cpuset=cpuset,
756             cpushare=cpushare,
757             memory=memory,
758         )
759         old_chunks = read_conf(cfg.path, out_format="commented")
760         cfg.write()
761         chunks = read_conf(cfg.path, out_format="commented")
762         if old_chunks != chunks:
763             to_reboot = True
764     else:
765         remove_seed_marker = True
766         cfg = _LXCConfig(
767             network_profile=network_profile,
768             nic_opts=nic_opts,
769             cpuset=cpuset,
770             path=path,
771             bridge=bridge,
772             gateway=gateway,
773             autostart=autostart,
774             cpushare=cpushare,
775             memory=memory,
776         )
777         with cfg.tempfile() as cfile:
778             try:
779                 create(name, config=cfile.name, profile=profile, **kwargs)
780                 changes.append({"create": "Container created"})
781             except (SaltInvocationError, CommandExecutionError) as exc:
782                 if "already exists" in exc.strerror:
783                     changes.append({"create": "Container already exists"})
784                 else:
785                     ret["comment"] = exc.strerror
786                     if changes:
787                         ret["changes"] = changes_dict
788                     return ret
789         cpath = os.path.join(bpath, name, "config")
790         old_chunks = []
791         if os.path.exists(cpath):
792             old_chunks = read_conf(cpath, out_format="commented")
793         new_cfg = _config_list(
794             conf_tuples=old_chunks,
795             cpu=cpu,
796             network_profile=network_profile,
797             nic_opts=nic_opts,
798             bridge=bridge,
799             cpuset=cpuset,
800             cpushare=cpushare,
801             memory=memory,
802         )
803         if new_cfg:
804             edit_conf(cpath, out_format="commented", lxc_config=new_cfg)
805         chunks = read_conf(cpath, out_format="commented")
806         if old_chunks != chunks:
807             to_reboot = True
808     cfg = _LXCConfig(
809         name=name,
810         network_profile=network_profile,
811         nic_opts=nic_opts,
812         bridge=bridge,
813         path=path,
814         gateway=gateway,
815         autostart=autostart,
816         cpuset=cpuset,
817         cpushare=cpushare,
818         memory=memory,
819     )
820     old_chunks = []
821     if os.path.exists(cfg.path):
822         old_chunks = read_conf(cfg.path, out_format="commented")
823     cfg.write()
824     chunks = read_conf(cfg.path, out_format="commented")
825     if old_chunks != chunks:
826         changes.append({"config": "Container configuration updated"})
827         to_reboot = True
828     if to_reboot:
829         try:
830             stop(name, path=path)
831         except (SaltInvocationError, CommandExecutionError) as exc:
832             ret["comment"] = "Unable to stop container: {}".format(exc)
833             if changes:
834                 ret["changes"] = changes_dict
835             return ret
836     if not does_exist or (does_exist and state(name, path=path) != "running"):
837         try:
838             start(name, path=path)
839         except (SaltInvocationError, CommandExecutionError) as exc:
840             ret["comment"] = "Unable to stop container: {}".format(exc)
841             if changes:
842                 ret["changes"] = changes_dict
843             return ret
844     if remove_seed_marker:
845         run(
846             name,
847             "rm -f '{}'".format(SEED_MARKER),
848             path=path,
849             chroot_fallback=False,
850             python_shell=False,
851         )
852     if ret.get("result", True) and password:
853         gid = "/.lxc.initial_pass"
854         gids = [gid, "/lxc.initial_pass", "/.lxc.{}.initial_pass".format(name)]
855         if not any(
856             retcode(
857                 name,
858                 'test -e "{}"'.format(x),
859                 chroot_fallback=True,
860                 path=path,
861                 ignore_retcode=True,
862             )
863             == 0
864             for x in gids
865         ):
866             for default_user in ["ubuntu"]:
867                 if (
868                     default_user not in users
869                     and retcode(
870                         name,
871                         "id {}".format(default_user),
872                         python_shell=False,
873                         path=path,
874                         chroot_fallback=True,
875                         ignore_retcode=True,
876                     )
877                     == 0
878                 ):
879                     users.append(default_user)
880             for user in users:
881                 try:
882                     cret = set_password(
883                         name,
884                         users=[user],
885                         path=path,
886                         password=password,
887                         encrypted=password_encrypted,
888                     )
889                 except (SaltInvocationError, CommandExecutionError) as exc:
890                     msg = "{}: Failed to set password".format(user) + exc.strerror
891                     if user == "root":
892                         ret["comment"] = msg
893                         ret["result"] = False
894                     else:
895                         log.debug(msg)
896             if ret.get("result", True):
897                 changes.append({"password": "Password(s) updated"})
898                 if (
899                     retcode(
900                         name,
901                         'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
902                         path=path,
903                         chroot_fallback=True,
904                         ignore_retcode=True,
905                     )
906                     != 0
907                 ):
908                     ret["comment"] = "Failed to set password marker"
909                     changes[-1]["password"] += ". " + ret["comment"] + "."
910                     ret["result"] = False
911     if ret.get("result", True) and dnsservers:
912         gid = "/.lxc.initial_dns"
913         gids = [gid, "/lxc.initial_dns", "/lxc.{}.initial_dns".format(name)]
914         if not any(
915             retcode(
916                 name,
917                 'test -e "{}"'.format(x),
918                 chroot_fallback=True,
919                 path=path,
920                 ignore_retcode=True,
921             )
922             == 0
923             for x in gids
924         ):
925             try:
926                 set_dns(
927                     name, path=path, dnsservers=dnsservers, searchdomains=searchdomains
928                 )
929             except (SaltInvocationError, CommandExecutionError) as exc:
930                 ret["comment"] = "Failed to set DNS: " + exc.strerror
931                 ret["result"] = False
932             else:
933                 changes.append({"dns": "DNS updated"})
934                 if (
935                     retcode(
936                         name,
937                         'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
938                         chroot_fallback=True,
939                         path=path,
940                         ignore_retcode=True,
941                     )
942                     != 0
943                 ):
944                     ret["comment"] = "Failed to set DNS marker"
945                     changes[-1]["dns"] += ". " + ret["comment"] + "."
946                     ret["result"] = False
947     if remove_seed_marker:
948         run(name, "rm -f '{}'".format(SEED_MARKER), path=path, python_shell=False)
949     gid = "/.lxc.initial_seed"
950     gids = [gid, "/lxc.initial_seed"]
951     if (
952         any(
953             retcode(
954                 name,
955                 "test -e {}".format(x),
956                 path=path,
957                 chroot_fallback=True,
958                 ignore_retcode=True,
959             )
960             == 0
961             for x in gids
962         )
963         or not ret.get("result", True)
964     ):
965         pass
966     elif seed or seed_cmd:
967         if seed:
968             try:
969                 result = bootstrap(
970                     name,
971                     config=salt_config,
972                     path=path,
973                     approve_key=approve_key,
974                     pub_key=pub_key,
975                     priv_key=priv_key,
976                     install=install,
977                     force_install=force_install,
978                     unconditional_install=unconditional_install,
979                     bootstrap_delay=bootstrap_delay,
980                     bootstrap_url=bootstrap_url,
981                     bootstrap_shell=bootstrap_shell,
982                     bootstrap_args=bootstrap_args,
983                 )
984             except (SaltInvocationError, CommandExecutionError) as exc:
985                 ret["comment"] = "Bootstrap failed: " + exc.strerror
986                 ret["result"] = False
987             else:
988                 if not result:
989                     ret[
990                         "comment"
991                     ] = "Bootstrap failed, see minion log for more information"
992                     ret["result"] = False
993                 else:
994                     changes.append({"bootstrap": "Container successfully bootstrapped"})
995         elif seed_cmd:
996             try:
997                 result = __salt__[seed_cmd](
998                     info(name, path=path)["rootfs"], name, salt_config
999                 )
1000             except (SaltInvocationError, CommandExecutionError) as exc:
1001                 ret["comment"] = "Bootstrap via seed_cmd '{}' failed: {}".format(
1002                     seed_cmd, exc.strerror
1003                 )
1004                 ret["result"] = False
1005             else:
1006                 if not result:
1007                     ret["comment"] = (
1008                         "Bootstrap via seed_cmd '{}' failed, "
1009                         "see minion log for more information ".format(seed_cmd)
1010                     )
1011                     ret["result"] = False
1012                 else:
1013                     changes.append(
1014                         {
1015                             "bootstrap": (
1016                                 "Container successfully bootstrapped "
1017                                 "using seed_cmd '{}'".format(seed_cmd)
1018                             )
1019                         }
1020                     )
1021     if ret.get("result", True) and not start_:
1022         try:
1023             stop(name, path=path)
1024         except (SaltInvocationError, CommandExecutionError) as exc:
1025             ret["comment"] = "Unable to stop container: {}".format(exc)
1026             ret["result"] = False
1027     state_post = state(name, path=path)
1028     if state_pre != state_post:
1029         changes.append({"state": {"old": state_pre, "new": state_post}})
1030     if ret.get("result", True):
1031         ret["comment"] = "Container '{}' successfully initialized".format(name)
1032         ret["result"] = True
1033     if changes:
1034         ret["changes"] = changes_dict
1035     return ret
1036 def cloud_init(name, vm_=None, **kwargs):
1037     init_interface = cloud_init_interface(name, vm_, **kwargs)
1038     name = init_interface.pop("name", name)
1039     return init(name, **init_interface)
1040 def images(dist=None):
1041     out = __salt__["cmd.run_stdout"](
1042         "lxc-create -n __imgcheck -t download -- --list", ignore_retcode=True
1043     )
1044     if "DIST" not in out:
1045         raise CommandExecutionError(
1046             "Unable to run the 'download' template script. Is it installed?"
1047         )
1048     ret = {}
1049     passed_header = False
1050     for line in out.splitlines():
1051         try:
1052             distro, release, arch, variant, build_time = line.split()
1053         except ValueError:
1054             continue
1055         if not passed_header:
1056             if distro == "DIST":
1057                 passed_header = True
1058             continue
1059         dist_list = ret.setdefault(distro, [])
1060         dist_list.append(
1061             {
1062                 "release": release,
1063                 "arch": arch,
1064                 "variant": variant,
1065                 "build_time": build_time,
1066             }
1067         )
1068     if dist is not None:
1069         return dict([(dist, ret.get(dist, []))])
1070     return ret
1071 def templates():
1072     try:
1073         template_scripts = os.listdir("/usr/share/lxc/templates")
1074     except OSError:
1075         return []
1076     else:
1077         return [x[4:] for x in template_scripts if x.startswith("lxc-")]
1078 def _after_ignition_network_profile(cmd, ret, name, network_profile, path, nic_opts):
1079     _clear_context()
1080     if ret["retcode"] == 0 and exists(name, path=path):
1081         if network_profile:
1082             network_changes = apply_network_profile(
1083                 name, network_profile, path=path, nic_opts=nic_opts
1084             )
1085             if network_changes:
1086                 log.info(
1087                     "Network changes from applying network profile '%s' "
1088                     "to newly-created container '%s':\n%s",
1089                     network_profile,
1090                     name,
1091                     network_changes,
1092                 )
1093         c_state = state(name, path=path)
1094         return {"result": True, "state": {"old": None, "new": c_state}}
1095     else:
1096         if exists(name, path=path):
1097             cmd = "lxc-destroy"
1098             if path:
1099                 cmd += " -P {}".format(pipes.quote(path))
1100             cmd += " -n {}".format(name)
1101             __salt__["cmd.retcode"](cmd, python_shell=False)
1102         raise CommandExecutionError(
1103             "Container could not be created with cmd '{}': {}".format(
1104                 cmd, ret["stderr"]
1105             )
1106         )
1107 def create(
1108     name, config=None, profile=None, network_profile=None, nic_opts=None, **kwargs
1109 ):
1110     download_template_deps = ("dist", "release", "arch")
1111     cmd = "lxc-create -n {}".format(name)
1112     profile = get_container_profile(copy.deepcopy(profile))
1113     kw_overrides = copy.deepcopy(kwargs)
1114     def select(key, default=None):
1115         kw_overrides_match = kw_overrides.pop(key, None)
1116         profile_match = profile.pop(key, default)
1117         if kw_overrides_match is None:
1118             return profile_match
1119         return kw_overrides_match
1120     path = select("path")
1121     if exists(name, path=path):
1122         raise CommandExecutionError("Container '{}' already exists".format(name))
1123     tvg = select("vgname")
1124     vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
1125     template = select("template")
1126     image = select("image")
1127     if template and image:
1128         raise SaltInvocationError("Only one of 'template' and 'image' is permitted")
1129     elif not any((template, image, profile)):
1130         raise SaltInvocationError(
1131             "At least one of 'template', 'image', and 'profile' is required"
1132         )
1133     options = select("options") or {}
1134     backing = select("backing")
1135     if vgname and not backing:
1136         backing = "lvm"
1137     lvname = select("lvname")
1138     thinpool = select("thinpool")
1139     fstype = select("fstype")
1140     size = select("size", "1G")
1141     zfsroot = select("zfsroot")
1142     if backing in ("dir", "overlayfs", "btrfs", "zfs"):
1143         fstype = None
1144         size = None
1145     if backing in ("aufs", "dir", "overlayfs", "btrfs"):
1146         lvname = vgname = thinpool = None
1147     if image:
1148         img_tar = __salt__["cp.cache_file"](image)
1149         template = os.path.join(
1150             os.path.dirname(salt.__file__), "templates", "lxc", "salt_tarball"
1151         )
1152         options["imgtar"] = img_tar
1153     if path:
1154         cmd += " -P {}".format(pipes.quote(path))
1155         if not os.path.exists(path):
1156             os.makedirs(path)
1157     if config:
1158         cmd += " -f {}".format(config)
1159     if template:
1160         cmd += " -t {}".format(template)
1161     if backing:
1162         backing = backing.lower()
1163         cmd += " -B {}".format(backing)
1164         if backing in ("zfs",):
1165             if zfsroot:
1166                 cmd += " --zfsroot {}".format(zfsroot)
1167         if backing in ("lvm",):
1168             if lvname:
1169                 cmd += " --lvname {}".format(lvname)
1170             if vgname:
1171                 cmd += " --vgname {}".format(vgname)
1172             if thinpool:
1173                 cmd += " --thinpool {}".format(thinpool)
1174         if backing not in ("dir", "overlayfs"):
1175             if fstype:
1176                 cmd += " --fstype {}".format(fstype)
1177             if size:
1178                 cmd += " --fssize {}".format(size)
1179     if options:
1180         if template == "download":
1181             missing_deps = [x for x in download_template_deps if x not in options]
1182             if missing_deps:
1183                 raise SaltInvocationError(
1184                     "Missing params in 'options' dict: {}".format(
1185                         ", ".join(missing_deps)
1186                     )
1187                 )
1188         cmd += " --"
1189         for key, val in options.items():
1190             cmd += " --{} {}".format(key, val)
1191     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1192     return _after_ignition_network_profile(
1193         cmd, ret, name, network_profile, path, nic_opts
1194     )
1195 def clone(name, orig, profile=None, network_profile=None, nic_opts=None, **kwargs):
1196     profile = get_container_profile(copy.deepcopy(profile))
1197     kw_overrides = copy.deepcopy(kwargs)
1198     def select(key, default=None):
1199         kw_overrides_match = kw_overrides.pop(key, None)
1200         profile_match = profile.pop(key, default)
1201         if kw_overrides_match is None:
1202             return profile_match
1203         return kw_overrides_match
1204     path = select("path")
1205     if exists(name, path=path):
1206         raise CommandExecutionError("Container '{}' already exists".format(name))
1207     _ensure_exists(orig, path=path)
1208     if state(orig, path=path) != "stopped":
1209         raise CommandExecutionError(
1210             "Container '{}' must be stopped to be cloned".format(orig)
1211         )
1212     backing = select("backing")
1213     snapshot = select("snapshot")
1214     if backing in ("dir",):
1215         snapshot = False
1216     if not snapshot:
1217         snapshot = ""
1218     else:
1219         snapshot = "-s"
1220     size = select("size", "1G")
1221     if backing in ("dir", "overlayfs", "btrfs"):
1222         size = None
1223     if _LooseVersion(version()) &gt;= _LooseVersion("2.0"):
1224         cmd = "lxc-copy"
1225         cmd += " {} -n {} -N {}".format(snapshot, orig, name)
1226     else:
1227         cmd = "lxc-clone"
1228         cmd += " {} -o {} -n {}".format(snapshot, orig, name)
1229     if path:
1230         cmd += " -P {}".format(pipes.quote(path))
1231         if not os.path.exists(path):
1232             os.makedirs(path)
1233     if backing:
1234         backing = backing.lower()
1235         cmd += " -B {}".format(backing)
1236         if backing not in ("dir", "overlayfs"):
1237             if size:
1238                 cmd += " -L {}".format(size)
1239     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1240     return _after_ignition_network_profile(
1241         cmd, ret, name, network_profile, path, nic_opts
1242     )
1243 def ls_(active=None, cache=True, path=None):
1244     contextvar = "lxc.ls{}".format(path)
1245     if active:
1246         contextvar += ".active"
1247     if cache and (contextvar in __context__):
1248         return __context__[contextvar]
1249     else:
1250         ret = []
1251         cmd = "lxc-ls"
1252         if path:
1253             cmd += " -P {}".format(pipes.quote(path))
1254         if active:
1255             cmd += " --active"
1256         output = __salt__["cmd.run_stdout"](cmd, python_shell=False)
1257         for line in output.splitlines():
1258             ret.extend(line.split())
1259         __context__[contextvar] = ret
1260         return ret
1261 def list_(extra=False, limit=None, path=None):
1262     ctnrs = ls_(path=path)
1263     if extra:
1264         stopped = {}
1265         frozen = {}
1266         running = {}
1267     else:
1268         stopped = []
1269         frozen = []
1270         running = []
1271     ret = {"running": running, "stopped": stopped, "frozen": frozen}
1272     for container in ctnrs:
1273         cmd = "lxc-info"
1274         if path:
1275             cmd += " -P {}".format(pipes.quote(path))
1276         cmd += " -n {}".format(container)
1277         c_info = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="debug")
1278         c_state = None
1279         for line in c_info.splitlines():
1280             stat = line.split(":")
1281             if stat[0] in ("State", "state"):
1282                 c_state = stat[1].strip()
1283                 break
1284         if not c_state or (limit is not None and c_state.lower() != limit):
1285             continue
1286         if extra:
1287             infos = info(container, path=path)
1288             method = "update"
1289             value = {container: infos}
1290         else:
1291             method = "append"
1292             value = container
1293         if c_state == "STOPPED":
1294             getattr(stopped, method)(value)
1295             continue
1296         if c_state == "FROZEN":
1297             getattr(frozen, method)(value)
1298             continue
1299         if c_state == "RUNNING":
1300             getattr(running, method)(value)
1301             continue
1302     if limit is not None:
1303         return ret.get(limit, {} if extra else [])
1304     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
1305 def _change_state(
1306     cmd,
1307     name,
1308     expected,
1309     stdin=_marker,
1310     stdout=_marker,
1311     stderr=_marker,
1312     with_communicate=_marker,
1313     use_vt=_marker,
1314     path=None,
1315 ):
1316     pre = state(name, path=</b></font>path)
1317     if pre == expected:
1318         return {
1319             "result": True,
1320             "state": {"old": expected, "new": expected},
1321             "comment": "Container '{}' already {}".format(name, expected),
1322         }
1323     if cmd == "lxc-destroy":
1324         scmd = "lxc-stop"
1325         if path:
1326             scmd += " -P {}".format(pipes.quote(path))
1327         scmd += " -k -n {}".format(name)
1328         __salt__["cmd.run"](scmd, python_shell=False)
1329     if path and " -P " not in cmd:
1330         cmd += " -P {}".format(pipes.quote(path))
1331     cmd += " -n {}".format(name)
1332     pkwargs = {
1333         "python_shell": False,
1334         "redirect_stderr": True,
1335         "with_communicate": with_communicate,
1336         "use_vt": use_vt,
1337         "stdin": stdin,
1338         "stdout": stdout,
1339     }
1340     for i in [a for a in pkwargs]:
1341         val = pkwargs[i]
1342         if val is _marker:
1343             pkwargs.pop(i, None)
1344     _cmdout = __salt__["cmd.run_all"](cmd, **pkwargs)
1345     if _cmdout["retcode"] != 0:
1346         raise CommandExecutionError(
1347             "Error changing state for container '{}' using command '{}': {}".format(
1348                 name, cmd, _cmdout["stdout"]
1349             )
1350         )
1351     if expected is not None:
1352         rcmd = "lxc-wait"
1353         if path:
1354             rcmd += " -P {}".format(pipes.quote(path))
1355         rcmd += " -n {} -s {}".format(name, expected.upper())
1356         __salt__["cmd.run"](rcmd, python_shell=False, timeout=30)
1357     _clear_context()
1358     post = state(name, path=path)
1359     ret = {"result": post == expected, "state": {"old": pre, "new": post}}
1360     return ret
1361 def _ensure_exists(name, path=None):
1362     if not exists(name, path=path):
1363         raise CommandExecutionError("Container '{}' does not exist".format(name))
1364 def _ensure_running(name, no_start=False, path=None):
1365     _ensure_exists(name, path=path)
1366     pre = state(name, path=path)
1367     if pre == "running":
1368         return start(name, path=path)
1369     elif pre == "stopped":
1370         if no_start:
1371             raise CommandExecutionError("Container '{}' is not running".format(name))
1372         return start(name, path=path)
1373     elif pre == "frozen":
1374         if no_start:
1375             raise CommandExecutionError("Container '{}' is not running".format(name))
1376         return unfreeze(name, path=path)
1377 def restart(name, path=None, lxc_config=None, force=False):
1378     _ensure_exists(name, path=path)
1379     orig_state = state(name, path=path)
1380     if orig_state != "stopped":
1381         stop(name, kill=force, path=path)
1382     ret = start(name, path=path, lxc_config=lxc_config)
1383     ret["state"]["old"] = orig_state
1384     if orig_state != "stopped":
1385         ret["restarted"] = True
1386     return ret
1387 def start(name, **kwargs):
1388     path = kwargs.get("path", None)
1389     cpath = get_root_path(path)
1390     lxc_config = kwargs.get("lxc_config", None)
1391     cmd = "lxc-start"
1392     if not lxc_config:
1393         lxc_config = os.path.join(cpath, name, "config")
1394     if os.path.exists(lxc_config):
1395         cmd += " -f {}".format(pipes.quote(lxc_config))
1396     cmd += " -d"
1397     _ensure_exists(name, path=path)
1398     if state(name, path=path) == "frozen":
1399         raise CommandExecutionError(
1400             "Container '{}' is frozen, use lxc.unfreeze".format(name)
1401         )
1402     use_vt = kwargs.get("use_vt", None)
1403     with_communicate = kwargs.get("with_communicate", False)
1404     return _change_state(
1405         cmd,
1406         name,
1407         "running",
1408         stdout=None,
1409         stderr=None,
1410         stdin=None,
1411         with_communicate=with_communicate,
1412         path=path,
1413         use_vt=use_vt,
1414     )
1415 def stop(name, kill=False, path=None, use_vt=None):
1416     _ensure_exists(name, path=path)
1417     orig_state = state(name, path=path)
1418     if orig_state == "frozen" and not kill:
1419         unfreeze(name, path=path)
1420     cmd = "lxc-stop"
1421     if kill:
1422         cmd += " -k"
1423     ret = _change_state(cmd, name, "stopped", use_vt=use_vt, path=path)
1424     ret["state"]["old"] = orig_state
1425     return ret
1426 def freeze(name, **kwargs):
1427     use_vt = kwargs.get("use_vt", None)
1428     path = kwargs.get("path", None)
1429     _ensure_exists(name, path=path)
1430     orig_state = state(name, path=path)
1431     start_ = kwargs.get("start", False)
1432     if orig_state == "stopped":
1433         if not start_:
1434             raise CommandExecutionError("Container '{}' is stopped".format(name))
1435         start(name, path=path)
1436     cmd = "lxc-freeze"
1437     if path:
1438         cmd += " -P {}".format(pipes.quote(path))
1439     ret = _change_state(cmd, name, "frozen", use_vt=use_vt, path=path)
1440     if orig_state == "stopped" and start_:
1441         ret["state"]["old"] = orig_state
1442         ret["started"] = True
1443     ret["state"]["new"] = state(name, path=path)
1444     return ret
1445 def unfreeze(name, path=None, use_vt=None):
1446     _ensure_exists(name, path=path)
1447     if state(name, path=path) == "stopped":
1448         raise CommandExecutionError("Container '{}' is stopped".format(name))
1449     cmd = "lxc-unfreeze"
1450     if path:
1451         cmd += " -P {}".format(pipes.quote(path))
1452     return _change_state(cmd, name, "running", path=path, use_vt=use_vt)
1453 def destroy(name, stop=False, path=None):
1454     _ensure_exists(name, path=path)
1455     if not stop and state(name, path=path) != "stopped":
1456         raise CommandExecutionError("Container '{}' is not stopped".format(name))
1457     return _change_state("lxc-destroy", name, None, path=path)
1458 remove = salt.utils.functools.alias_function(destroy, "remove")
1459 def exists(name, path=None):
1460     _exists = name in ls_(path=path)
1461     if not _exists:
1462         _exists = name in ls_(cache=False, path=path)
1463     return _exists
1464 def state(name, path=None):
1465     cachekey = "lxc.state.{}{}".format(name, path)
1466     try:
1467         return __context__[cachekey]
1468     except KeyError:
1469         if not exists(name, path=path):
1470             __context__[cachekey] = None
1471         else:
1472             cmd = "lxc-info"
1473             if path:
1474                 cmd += " -P {}".format(pipes.quote(path))
1475             cmd += " -n {}".format(name)
1476             ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1477             if ret["retcode"] != 0:
1478                 _clear_context()
1479                 raise CommandExecutionError(
1480                     "Unable to get state of container '{}'".format(name)
1481                 )
1482             c_infos = ret["stdout"].splitlines()
1483             c_state = None
1484             for c_info in c_infos:
1485                 stat = c_info.split(":")
1486                 if stat[0].lower() == "state":
1487                     c_state = stat[1].strip().lower()
1488                     break
1489             __context__[cachekey] = c_state
1490     return __context__[cachekey]
1491 def get_parameter(name, parameter, path=None):
1492     _ensure_exists(name, path=path)
1493     cmd = "lxc-cgroup"
1494     if path:
1495         cmd += " -P {}".format(pipes.quote(path))
1496     cmd += " -n {} {}".format(name, parameter)
1497     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1498     if ret["retcode"] != 0:
1499         raise CommandExecutionError(
1500             "Unable to retrieve value for '{}'".format(parameter)
1501         )
1502     return ret["stdout"].strip()
1503 def set_parameter(name, parameter, value, path=None):
1504     if not exists(name, path=path):
1505         return None
1506     cmd = "lxc-cgroup"
1507     if path:
1508         cmd += " -P {}".format(pipes.quote(path))
1509     cmd += " -n {} {} {}".format(name, parameter, value)
1510     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1511     if ret["retcode"] != 0:
1512         return False
1513     else:
1514         return True
1515 def info(name, path=None):
1516     cachekey = "lxc.info.{}{}".format(name, path)
1517     try:
1518         return __context__[cachekey]
1519     except KeyError:
1520         _ensure_exists(name, path=path)
1521         cpath = get_root_path(path)
1522         try:
1523             conf_file = os.path.join(cpath, name, "config")
1524         except AttributeError:
1525             conf_file = os.path.join(cpath, str(name), "config")
1526         if not os.path.isfile(conf_file):
1527             raise CommandExecutionError(
1528                 "LXC config file {} does not exist".format(conf_file)
1529             )
1530         ret = {}
1531         config = []
1532         with salt.utils.files.fopen(conf_file) as fp_:
1533             for line in fp_:
1534                 line = salt.utils.stringutils.to_unicode(line)
1535                 comps = [x.strip() for x in line.split("#", 1)[0].strip().split("=", 1)]
1536                 if len(comps) == 2:
1537                     config.append(tuple(comps))
1538         ifaces = []
1539         current = {}
1540         for key, val in config:
1541             if key == "lxc.network.type":
1542                 current = {"type": val}
1543                 ifaces.append(current)
1544             elif not current:
1545                 continue
1546             elif key.startswith("lxc.network."):
1547                 current[key.replace("lxc.network.", "", 1)] = val
1548         if ifaces:
1549             ret["nics"] = ifaces
1550         ret["rootfs"] = next((x[1] for x in config if x[0] == "lxc.rootfs"), None)
1551         ret["state"] = state(name, path=path)
1552         ret["ips"] = []
1553         ret["public_ips"] = []
1554         ret["private_ips"] = []
1555         ret["public_ipv4_ips"] = []
1556         ret["public_ipv6_ips"] = []
1557         ret["private_ipv4_ips"] = []
1558         ret["private_ipv6_ips"] = []
1559         ret["ipv4_ips"] = []
1560         ret["ipv6_ips"] = []
1561         ret["size"] = None
1562         ret["config"] = conf_file
1563         if ret["state"] == "running":
1564             try:
1565                 limit = int(get_parameter(name, "memory.limit_in_bytes"))
1566             except (CommandExecutionError, TypeError, ValueError):
1567                 limit = 0
1568             try:
1569                 usage = int(get_parameter(name, "memory.usage_in_bytes"))
1570             except (CommandExecutionError, TypeError, ValueError):
1571                 usage = 0
1572             free = limit - usage
1573             ret["memory_limit"] = limit
1574             ret["memory_free"] = free
1575             size = run_stdout(name, "df /", path=path, python_shell=False)
1576             ret["size"] = size.splitlines()[-1].split()[1]
1577             ip_cmd = run_all(name, "ip link show", path=path, python_shell=False)
1578             if ip_cmd["retcode"] == 0:
1579                 ip_data = ip_cmd["stdout"]
1580                 ip_cmd = run_all(name, "ip addr show", path=path, python_shell=False)
1581                 ip_data += "\n" + ip_cmd["stdout"]
1582                 ip_data = salt.utils.network._interfaces_ip(ip_data)
1583             else:
1584                 ip_cmd = run_all(name, "ifconfig", path=path, python_shell=False)
1585                 if ip_cmd["retcode"] == 0:
1586                     ip_data = salt.utils.network._interfaces_ifconfig(ip_cmd["stdout"])
1587                 else:
1588                     log.warning("Unable to run ip or ifconfig in container '%s'", name)
1589                     ip_data = {}
1590             ret["ipv4_ips"] = salt.utils.network.ip_addrs(
1591                 include_loopback=True, interface_data=ip_data
1592             )
1593             ret["ipv6_ips"] = salt.utils.network.ip_addrs6(
1594                 include_loopback=True, interface_data=ip_data
1595             )
1596             ret["ips"] = ret["ipv4_ips"] + ret["ipv6_ips"]
1597             for address in ret["ipv4_ips"]:
1598                 if address == "127.0.0.1":
1599                     ret["private_ips"].append(address)
1600                     ret["private_ipv4_ips"].append(address)
1601                 elif salt.utils.cloud.is_public_ip(address):
1602                     ret["public_ips"].append(address)
1603                     ret["public_ipv4_ips"].append(address)
1604                 else:
1605                     ret["private_ips"].append(address)
1606                     ret["private_ipv4_ips"].append(address)
1607             for address in ret["ipv6_ips"]:
1608                 if address == "::1" or address.startswith("fe80"):
1609                     ret["private_ips"].append(address)
1610                     ret["private_ipv6_ips"].append(address)
1611                 else:
1612                     ret["public_ips"].append(address)
1613                     ret["public_ipv6_ips"].append(address)
1614         for key in [x for x in ret if x == "ips" or x.endswith("ips")]:
1615             ret[key].sort(key=_ip_sort)
1616         __context__[cachekey] = ret
1617     return __context__[cachekey]
1618 def set_password(name, users, password, encrypted=True, path=None):
1619     def _bad_user_input():
1620         raise SaltInvocationError("Invalid input for 'users' parameter")
1621     if not isinstance(users, list):
1622         try:
1623             users = users.split(",")
1624         except AttributeError:
1625             _bad_user_input()
1626     if not users:
1627         _bad_user_input()
1628     failed_users = []
1629     for user in users:
1630         result = retcode(
1631             name,
1632             "chpasswd{}".format(" -e" if encrypted else ""),
1633             stdin=":".join((user, password)),
1634             python_shell=False,
1635             path=path,
1636             chroot_fallback=True,
1637             output_loglevel="quiet",
1638         )
1639         if result != 0:
1640             failed_users.append(user)
1641     if failed_users:
1642         raise CommandExecutionError(
1643             "Password change failed for the following user(s): {}".format(
1644                 ", ".join(failed_users)
1645             )
1646         )
1647     return True
1648 set_pass = salt.utils.functools.alias_function(set_password, "set_pass")
1649 def update_lxc_conf(name, lxc_conf, lxc_conf_unset, path=None):
1650     _ensure_exists(name, path=path)
1651     cpath = get_root_path(path)
1652     lxc_conf_p = os.path.join(cpath, name, "config")
1653     if not os.path.exists(lxc_conf_p):
1654         raise SaltInvocationError(
1655             "Configuration file {} does not exist".format(lxc_conf_p)
1656         )
1657     changes = {"edited": [], "added": [], "removed": []}
1658     ret = {"changes": changes, "result": True, "comment": ""}
1659     with salt.utils.files.fopen(lxc_conf_p, "r") as fic:
1660         filtered_lxc_conf = []
1661         for row in lxc_conf:
1662             if not row:
1663                 continue
1664             for conf in row:
1665                 filtered_lxc_conf.append((conf.strip(), row[conf].strip()))
1666         ret["comment"] = "lxc.conf is up to date"
1667         lines = []
1668         orig_config = salt.utils.stringutils.to_unicode(fic.read())
1669         for line in orig_config.splitlines():
1670             if line.startswith("#") or not line.strip():
1671                 lines.append([line, ""])
1672             else:
1673                 line = line.split("=")
1674                 index = line.pop(0)
1675                 val = (index.strip(), "=".join(line).strip())
1676                 if val not in lines:
1677                     lines.append(val)
1678         for key, item in filtered_lxc_conf:
1679             matched = False
1680             for idx, line in enumerate(lines[:]):
1681                 if line[0] == key:
1682                     matched = True
1683                     lines[idx] = (key, item)
1684                     if "=".join(line[1:]).strip() != item.strip():
1685                         changes["edited"].append(({line[0]: line[1:]}, {key: item}))
1686                         break
1687             if not matched:
1688                 if (key, item) not in lines:
1689                     lines.append((key, item))
1690                 changes["added"].append({key: item})
1691         dest_lxc_conf = []
1692         if lxc_conf_unset:
1693             for line in lines:
1694                 for opt in lxc_conf_unset:
1695                     if not line[0].startswith(opt) and line not in dest_lxc_conf:
1696                         dest_lxc_conf.append(line)
1697                     else:
1698                         changes["removed"].append(opt)
1699         else:
1700             dest_lxc_conf = lines
1701         conf = ""
1702         for key, val in dest_lxc_conf:
1703             if not val:
1704                 conf += "{}\n".format(key)
1705             else:
1706                 conf += "{} = {}\n".format(key.strip(), val.strip())
1707         conf_changed = conf != orig_config
1708         chrono = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
1709         if conf_changed:
1710             with salt.utils.files.fopen(
1711                 "{}.{}".format(lxc_conf_p, chrono), "w"
1712             ) as wfic:
1713                 wfic.write(salt.utils.stringutils.to_str(conf))
1714             with salt.utils.files.fopen(lxc_conf_p, "w") as wfic:
1715                 wfic.write(salt.utils.stringutils.to_str(conf))
1716             ret["comment"] = "Updated"
1717             ret["result"] = True
1718     if not any(changes[x] for x in changes):
1719         ret["changes"] = {}
1720     return ret
1721 def set_dns(name, dnsservers=None, searchdomains=None, path=None):
1722     if dnsservers is None:
1723         dnsservers = ["8.8.8.8", "4.4.4.4"]
1724     elif not isinstance(dnsservers, list):
1725         try:
1726             dnsservers = dnsservers.split(",")
1727         except AttributeError:
1728             raise SaltInvocationError("Invalid input for 'dnsservers' parameter")
1729     if searchdomains is None:
1730         searchdomains = []
1731     elif not isinstance(searchdomains, list):
1732         try:
1733             searchdomains = searchdomains.split(",")
1734         except AttributeError:
1735             raise SaltInvocationError("Invalid input for 'searchdomains' parameter")
1736     dns = ["nameserver {}".format(x) for x in dnsservers]
1737     dns.extend(["search {}".format(x) for x in searchdomains])
1738     dns = "\n".join(dns) + "\n"
1739     rstr = __salt__["test.random_hash"]()
1740     script = "/sbin/{}_dns.sh".format(rstr)
1741     DNS_SCRIPT = "\n".join(
1742         [
1743             "#!/usr/bin/env bash",
1744             "if [ -h /etc/resolv.conf ];then",
1745             ' if [ "x$(readlink /etc/resolv.conf)"'
1746             ' = "x../run/resolvconf/resolv.conf" ];then',
1747             "  if [ ! -d /run/resolvconf/ ];then",
1748             "   mkdir -p /run/resolvconf",
1749             "  fi",
1750             "  cat &gt; /etc/resolvconf/resolv.conf.d/head &lt;&lt;EOF",
1751             dns,
1752             "EOF",
1753             "",
1754             " fi",
1755             "fi",
1756             "cat &gt; /etc/resolv.conf &lt;&lt;EOF",
1757             dns,
1758             "EOF",
1759             "",
1760         ]
1761     )
1762     result = run_all(
1763         name, "tee {}".format(script), path=path, stdin=DNS_SCRIPT, python_shell=True
1764     )
1765     if result["retcode"] == 0:
1766         result = run_all(
1767             name,
1768             'sh -c "chmod +x {0};{0}"'.format(script),
1769             path=path,
1770             python_shell=True,
1771         )
1772     run_all(
1773         name,
1774         'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1775         path=path,
1776         python_shell=True,
1777     )
1778     if result["retcode"] != 0:
1779         error = "Unable to write to /etc/resolv.conf in container '{}'".format(name)
1780         if result["stderr"]:
1781             error += ": {}".format(result["stderr"])
1782         raise CommandExecutionError(error)
1783     return True
1784 def running_systemd(name, cache=True, path=None):
1785     k = "lxc.systemd.test.{}{}".format(name, path)
1786     ret = __context__.get(k, None)
1787     if ret is None or not cache:
1788         rstr = __salt__["test.random_hash"]()
1789         script = "/sbin/{}_testsystemd.sh".format(rstr)
1790         _script = textwrap.dedent(
1791         )
1792         result = run_all(
1793             name, "tee {}".format(script), path=path, stdin=_script, python_shell=True
1794         )
1795         if result["retcode"] == 0:
1796             result = run_all(
1797                 name,
1798                 'sh -c "chmod +x {0};{0}"'.format(script),
1799                 path=path,
1800                 python_shell=True,
1801             )
1802         else:
1803             raise CommandExecutionError(
1804                 "lxc {} failed to copy initd tester".format(name)
1805             )
1806         run_all(
1807             name,
1808             'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1809             path=path,
1810             ignore_retcode=True,
1811             python_shell=True,
1812         )
1813         if result["retcode"] != 0:
1814             error = (
1815                 "Unable to determine if the container '{}'"
1816                 " was running systemd, assmuming it is not."
1817                 "".format(name)
1818             )
1819             if result["stderr"]:
1820                 error += ": {}".format(result["stderr"])
1821         if result["retcode"] in (0, 2):
1822             __context__[k] = ret = not result["retcode"]
1823     return ret
1824 def systemd_running_state(name, path=None):
1825     try:
1826         ret = run_all(
1827             name, "systemctl is-system-running", path=path, ignore_retcode=True
1828         )["stdout"]
1829     except CommandExecutionError:
1830         ret = ""
1831     return ret
1832 def test_sd_started_state(name, path=None):
1833     qstate = systemd_running_state(name, path=path)
1834     if qstate in ("initializing", "starting"):
1835         return False
1836     elif qstate == "":
1837         return None
1838     else:
1839         return True
1840 def test_bare_started_state(name, path=None):
1841     try:
1842         ret = run_all(name, "ls", path=path, ignore_retcode=True)["retcode"] == 0
1843     except (CommandExecutionError,):
1844         ret = None
1845     return ret
1846 def wait_started(name, path=None, timeout=300):
1847     if not exists(name, path=path):
1848         raise CommandExecutionError("Container {} does does exists".format(name))
1849     if not state(name, path=path) == "running":
1850         raise CommandExecutionError("Container {} is not running".format(name))
1851     ret = False
1852     if running_systemd(name, path=path):
1853         test_started = test_sd_started_state
1854         logger = log.error
1855     else:
1856         test_started = test_bare_started_state
1857         logger = log.debug
1858     now = time.time()
1859     expire = now + timeout
1860     now = time.time()
1861     started = test_started(name, path=path)
1862     while time.time() &lt; expire and not started:
1863         time.sleep(0.3)
1864         started = test_started(name, path=path)
1865     if started is None:
1866         logger(
1867             "Assuming %s is started, although we failed to detect that"
1868             " is fully started correctly",
1869             name,
1870         )
1871         ret = True
1872     else:
1873         ret = started
1874     return ret
1875 def _needs_install(name, path=None):
1876     ret = 0
1877     has_minion = retcode(name, "which salt-minion", path=path, ignore_retcode=True)
1878     if has_minion:
1879         processes = run_stdout(name, "ps aux", path=path)
1880         if "salt-minion" not in processes:
1881             ret = 1
1882         else:
1883             retcode(name, "salt-call --local service.stop salt-minion")
1884     else:
1885         ret = 1
1886     return ret
1887 def bootstrap(
1888     name,
1889     config=None,
1890     approve_key=True,
1891     install=True,
1892     pub_key=None,
1893     priv_key=None,
1894     bootstrap_url=None,
1895     force_install=False,
1896     unconditional_install=False,
1897     path=None,
1898     bootstrap_delay=None,
1899     bootstrap_args=None,
1900     bootstrap_shell=None,
1901 ):
1902     wait_started(name, path=path)
1903     if bootstrap_delay is not None:
1904         try:
1905             log.info("LXC %s: bootstrap_delay: %s", name, bootstrap_delay)
1906             time.sleep(bootstrap_delay)
1907         except TypeError:
1908             time.sleep(5)
1909     c_info = info(name, path=path)
1910     if not c_info:
1911         return None
1912     if bootstrap_args:
1913         if "{0}" not in bootstrap_args:
1914             bootstrap_args += " -c {0}"
1915     else:
1916         bootstrap_args = "-c {0}"
1917     if not bootstrap_shell:
1918         bootstrap_shell = "sh"
1919     orig_state = _ensure_running(name, path=path)
1920     if not orig_state:
1921         return orig_state
1922     if not force_install:
1923         needs_install = _needs_install(name, path=path)
1924     else:
1925         needs_install = True
1926     seeded = (
1927         retcode(
1928             name,
1929             "test -e '{}'".format(SEED_MARKER),
1930             path=path,
1931             chroot_fallback=True,
1932             ignore_retcode=True,
1933         )
1934         == 0
1935     )
1936     tmp = tempfile.mkdtemp()
1937     if seeded and not unconditional_install:
1938         ret = True
1939     else:
1940         ret = False
1941         cfg_files = __salt__["seed.mkconfig"](
1942             config,
1943             tmp=tmp,
1944             id_=name,
1945             approve_key=approve_key,
1946             pub_key=pub_key,
1947             priv_key=priv_key,
1948         )
1949         if needs_install or force_install or unconditional_install:
1950             if install:
1951                 rstr = __salt__["test.random_hash"]()
1952                 configdir = "/var/tmp/.c_{}".format(rstr)
1953                 cmd = "install -m 0700 -d {}".format(configdir)
1954                 if run_all(name, cmd, path=path, python_shell=False)["retcode"] != 0:
1955                     log.error("tmpdir %s creation failed %s", configdir, cmd)
1956                     return False
1957                 bs_ = __salt__["config.gather_bootstrap_script"](
1958                     bootstrap=bootstrap_url
1959                 )
1960                 script = "/sbin/{}_bootstrap.sh".format(rstr)
1961                 copy_to(name, bs_, script, path=path)
1962                 result = run_all(
1963                     name,
1964                     'sh -c "chmod +x {}"'.format(script),
1965                     path=path,
1966                     python_shell=True,
1967                 )
1968                 copy_to(
1969                     name,
1970                     cfg_files["config"],
1971                     os.path.join(configdir, "minion"),
1972                     path=path,
1973                 )
1974                 copy_to(
1975                     name,
1976                     cfg_files["privkey"],
1977                     os.path.join(configdir, "minion.pem"),
1978                     path=path,
1979                 )
1980                 copy_to(
1981                     name,
1982                     cfg_files["pubkey"],
1983                     os.path.join(configdir, "minion.pub"),
1984                     path=path,
1985                 )
1986                 bootstrap_args = bootstrap_args.format(configdir)
1987                 cmd = "{0} {2} {1}".format(
1988                     bootstrap_shell, bootstrap_args.replace("'", "''"), script
1989                 )
1990                 log.info("Running %s in LXC container '%s'", cmd, name)
1991                 ret = (
1992                     retcode(name, cmd, output_loglevel="info", path=path, use_vt=True)
1993                     == 0
1994                 )
1995                 run_all(
1996                     name,
1997                     'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1998                     path=path,
1999                     ignore_retcode=True,
2000                     python_shell=True,
2001                 )
2002             else:
2003                 ret = False
2004         else:
2005             minion_config = salt.config.minion_config(cfg_files["config"])
2006             pki_dir = minion_config["pki_dir"]
2007             copy_to(name, cfg_files["config"], "/etc/salt/minion", path=path)
2008             copy_to(
2009                 name,
2010                 cfg_files["privkey"],
2011                 os.path.join(pki_dir, "minion.pem"),
2012                 path=path,
2013             )
2014             copy_to(
2015                 name,
2016                 cfg_files["pubkey"],
2017                 os.path.join(pki_dir, "minion.pub"),
2018                 path=path,
2019             )
2020             run(
2021                 name,
2022                 "salt-call --local service.enable salt-minion",
2023                 path=path,
2024                 python_shell=False,
2025             )
2026             ret = True
2027         shutil.rmtree(tmp)
2028         if orig_state == "stopped":
2029             stop(name, path=path)
2030         elif orig_state == "frozen":
2031             freeze(name, path=path)
2032         if ret:
2033             run(name, "touch '{}'".format(SEED_MARKER), path=path, python_shell=False)
2034     return ret
2035 def attachable(name, path=None):
2036     cachekey = "lxc.attachable{}{}".format(name, path)
2037     try:
2038         return __context__[cachekey]
2039     except KeyError:
2040         _ensure_exists(name, path=path)
2041         log.debug("Checking if LXC container %s is attachable", name)
2042         cmd = "lxc-attach"
2043         if path:
2044             cmd += " -P {}".format(pipes.quote(path))
2045         cmd += " --clear-env -n {} -- /usr/bin/env".format(name)
2046         result = (
2047             __salt__["cmd.retcode"](
2048                 cmd, python_shell=False, output_loglevel="quiet", ignore_retcode=True
2049             == 0
2050         )
2051         __context__[cachekey] <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= result
2052     return __context__[cachekey]
2053 def _run(
2054     name,
2055     cmd,
2056     output=None,
2057     no_start=False,
2058     preserve_state=True,
2059     stdin=None,
2060     python_shell=True,
2061     output_loglevel="debug",
2062     use_vt=</b></font>False,
2063     path=None,
2064     ignore_retcode=False,
2065     chroot_fallback=None,
2066     keep_env="http_proxy,https_proxy,no_proxy",
2067 ):
2068     orig_state = state(name, path=path)
2069     try:
2070         if attachable(name, path=path):
2071             ret = __salt__["container_resource.run"](
2072                 name,
2073                 cmd,
2074                 path=path,
2075                 container_type=__virtualname__,
2076                 exec_driver=EXEC_DRIVER,
2077                 output=output,
2078                 no_start=no_start,
2079                 stdin=stdin,
2080                 python_shell=python_shell,
2081                 output_loglevel=output_loglevel,
2082                 ignore_retcode=ignore_retcode,
2083                 use_vt=use_vt,
2084                 keep_env=keep_env,
2085             )
2086         else:
2087             if not chroot_fallback:
2088                 raise CommandExecutionError("{} is not attachable.".format(name))
2089             rootfs = info(name, path=path).get("rootfs")
2090             __context__["cmd.run_chroot.func"] = __salt__["cmd.run"]
2091             ret = __salt__["cmd.run_chroot"](
2092                 rootfs,
2093                 cmd,
2094                 stdin=stdin,
2095                 python_shell=python_shell,
2096                 output_loglevel=output_loglevel,
2097                 ignore_retcode=ignore_retcode,
2098             )
2099     finally:
2100         new_state = state(name, path=path)
2101         if preserve_state:
2102             if orig_state == "stopped" and new_state != "stopped":
2103                 stop(name, path=path)
2104             elif orig_state == "frozen" and new_state != "frozen":
2105                 freeze(name, start=True, path=path)
2106     if output in (None, "all"):
2107         return ret
2108     else:
2109         return ret[output]
2110 def run(
2111     name,
2112     cmd,
2113     no_start=False,
2114     preserve_state=True,
2115     stdin=None,
2116     python_shell=True,
2117     output_loglevel="debug",
2118     use_vt=False,
2119     path=None,
2120     ignore_retcode=False,
2121     chroot_fallback=False,
2122     keep_env="http_proxy,https_proxy,no_proxy",
2123 ):
2124     return _run(
2125         name,
2126         cmd,
2127         path=path,
2128         output=None,
2129         no_start=no_start,
2130         preserve_state=preserve_state,
2131         stdin=stdin,
2132         python_shell=python_shell,
2133         output_loglevel=output_loglevel,
2134         use_vt=use_vt,
2135         ignore_retcode=ignore_retcode,
2136         chroot_fallback=chroot_fallback,
2137         keep_env=keep_env,
2138     )
2139 def run_stdout(
2140     name,
2141     cmd,
2142     no_start=False,
2143     preserve_state=True,
2144     stdin=None,
2145     python_shell=True,
2146     output_loglevel="debug",
2147     use_vt=False,
2148     path=None,
2149     ignore_retcode=False,
2150     chroot_fallback=False,
2151     keep_env="http_proxy,https_proxy,no_proxy",
2152 ):
2153     return _run(
2154         name,
2155         cmd,
2156         path=path,
2157         output="stdout",
2158         no_start=no_start,
2159         preserve_state=preserve_state,
2160         stdin=stdin,
2161         python_shell=python_shell,
2162         output_loglevel=output_loglevel,
2163         use_vt=use_vt,
2164         ignore_retcode=ignore_retcode,
2165         chroot_fallback=chroot_fallback,
2166         keep_env=keep_env,
2167     )
2168 def run_stderr(
2169     name,
2170     cmd,
2171     no_start=False,
2172     preserve_state=True,
2173     stdin=None,
2174     python_shell=True,
2175     output_loglevel="debug",
2176     use_vt=False,
2177     path=None,
2178     ignore_retcode=False,
2179     chroot_fallback=False,
2180     keep_env="http_proxy,https_proxy,no_proxy",
2181 ):
2182     return _run(
2183         name,
2184         cmd,
2185         path=path,
2186         output="stderr",
2187         no_start=no_start,
2188         preserve_state=preserve_state,
2189         stdin=stdin,
2190         python_shell=python_shell,
2191         output_loglevel=output_loglevel,
2192         use_vt=use_vt,
2193         ignore_retcode=ignore_retcode,
2194         chroot_fallback=chroot_fallback,
2195         keep_env=keep_env,
2196     )
2197 def retcode(
2198     name,
2199     cmd,
2200     no_start=False,
2201     preserve_state=True,
2202     stdin=None,
2203     python_shell=True,
2204     output_loglevel="debug",
2205     use_vt=False,
2206     path=None,
2207     ignore_retcode=False,
2208     chroot_fallback=False,
2209     keep_env="http_proxy,https_proxy,no_proxy",
2210 ):
2211     return _run(
2212         name,
2213         cmd,
2214         output="retcode",
2215         path=path,
2216         no_start=no_start,
2217         preserve_state=preserve_state,
2218         stdin=stdin,
2219         python_shell=python_shell,
2220         output_loglevel=output_loglevel,
2221         use_vt=use_vt,
2222         ignore_retcode=ignore_retcode,
2223         chroot_fallback=chroot_fallback,
2224         keep_env=keep_env,
2225     )
2226 def run_all(
2227     name,
2228     cmd,
2229     no_start=False,
2230     preserve_state=True,
2231     stdin=None,
2232     python_shell=True,
2233     output_loglevel="debug",
2234     use_vt=False,
2235     path=None,
2236     ignore_retcode=False,
2237     chroot_fallback=False,
2238     keep_env="http_proxy,https_proxy,no_proxy",
2239 ):
2240     return _run(
2241         name,
2242         cmd,
2243         output="all",
2244         no_start=no_start,
2245         preserve_state=preserve_state,
2246         stdin=stdin,
2247         python_shell=python_shell,
2248         output_loglevel=output_loglevel,
2249         use_vt=use_vt,
2250         path=path,
2251         ignore_retcode=ignore_retcode,
2252         chroot_fallback=chroot_fallback,
2253         keep_env=keep_env,
2254     )
2255 def _get_md5(name, path):
2256     output = run_stdout(
2257         name, 'md5sum "{}"'.format(path), chroot_fallback=True, ignore_retcode=True
2258     )
2259     try:
2260         return output.split()[0]
2261     except IndexError:
2262         return None
2263 def copy_to(name, source, dest, overwrite=False, makedirs=False, path=None):
2264     _ensure_running(name, no_start=True, path=path)
2265     return __salt__["container_resource.copy_to"](
2266         name,
2267         source,
2268         dest,
2269         container_type=__virtualname__,
2270         path=path,
2271         exec_driver=EXEC_DRIVER,
2272         overwrite=overwrite,
2273         makedirs=makedirs,
2274     )
2275 cp = salt.utils.functools.alias_function(copy_to, "cp")
2276 def read_conf(conf_file, out_format="simple"):
2277     ret_commented = []
2278     ret_simple = {}
2279     with salt.utils.files.fopen(conf_file, "r") as fp_:
2280         for line in salt.utils.data.decode(fp_.readlines()):
2281             if "=" not in line:
2282                 ret_commented.append(line)
2283                 continue
2284             comps = line.split("=")
2285             value = "=".join(comps[1:]).strip()
2286             comment = None
2287             if value.strip().startswith("#"):
2288                 vcomps = value.strip().split("#")
2289                 value = vcomps[1].strip()
2290                 comment = "#".join(vcomps[1:]).strip()
2291                 ret_commented.append(
2292                     {comps[0].strip(): {"value": value, "comment": comment}}
2293                 )
2294             else:
2295                 ret_commented.append({comps[0].strip(): value})
2296                 ret_simple[comps[0].strip()] = value
2297     if out_format == "simple":
2298         return ret_simple
2299     return ret_commented
2300 def write_conf(conf_file, conf):
2301     if not isinstance(conf, list):
2302         raise SaltInvocationError("Configuration must be passed as a list")
2303     content = ""
2304     for line in conf:
2305         if isinstance(line, (str, (str,))):
2306             content += line
2307         elif isinstance(line, dict):
2308             for key in list(line.keys()):
2309                 out_line = None
2310                 if isinstance(
2311                     line[key],
2312                     (str, (str,), (int,), float),
2313                 ):
2314                     out_line = " = ".join((key, "{}".format(line[key])))
2315                 elif isinstance(line[key], dict):
2316                     out_line = " = ".join((key, line[key]["value"]))
2317                     if "comment" in line[key]:
2318                         out_line = " # ".join((out_line, line[key]["comment"]))
2319                 if out_line:
2320                     content += out_line
2321                     content += "\n"
2322     with salt.utils.files.fopen(conf_file, "w") as fp_:
2323         fp_.write(salt.utils.stringutils.to_str(content))
2324     return {}
2325 def edit_conf(
2326     conf_file, out_format="simple", read_only=False, lxc_config=None, **kwargs
2327 ):
2328     data = []
2329     try:
2330         conf = read_conf(conf_file, out_format=out_format)
2331     except Exception:  # pylint: disable=broad-except
2332         conf = []
2333     if not lxc_config:
2334         lxc_config = []
2335     lxc_config = copy.deepcopy(lxc_config)
2336     net_config = []
2337     for lxc_kws in lxc_config + [kwargs]:
2338         net_params = {}
2339         for kwarg in [a for a in lxc_kws]:
2340             if kwarg.startswith("__"):
2341                 continue
2342             if kwarg.startswith("lxc.network."):
2343                 net_params[kwarg] = lxc_kws[kwarg]
2344                 lxc_kws.pop(kwarg, None)
2345         if net_params:
2346             net_config.append(net_params)
2347     nic_opts = salt.utils.odict.OrderedDict()
2348     for params in net_config:
2349         dev = params.get("lxc.network.name", DEFAULT_NIC)
2350         dev_opts = nic_opts.setdefault(dev, salt.utils.odict.OrderedDict())
2351         for param in params:
2352             opt = param.replace("lxc.network.", "")
2353             opt = {"hwaddr": "mac"}.get(opt, opt)
2354             dev_opts[opt] = params[param]
2355     net_changes = []
2356     if nic_opts:
2357         net_changes = _config_list(
2358             conf,
2359             only_net=True,
2360             **{"network_profile": DEFAULT_NIC, "nic_opts": nic_opts}
2361         )
2362         if net_changes:
2363             lxc_config.extend(net_changes)
2364     for line in conf:
2365         if not isinstance(line, dict):
2366             data.append(line)
2367             continue
2368         else:
2369             for key in list(line.keys()):
2370                 val = line[key]
2371                 if net_changes and key.startswith("lxc.network."):
2372                     continue
2373                 found = False
2374                 for kw in lxc_config:
2375                     if key in kw:
2376                         found = True
2377                         data.append({key: kw[key]})
2378                         del kw[key]
2379                 if not found:
2380                     data.append({key: val})
2381     for lxc_kws in lxc_config:
2382         for kwarg in lxc_kws:
2383             data.append({kwarg: lxc_kws[kwarg]})
2384     if read_only:
2385         return data
2386     write_conf(conf_file, data)
2387     return read_conf(conf_file, out_format)
2388 def reboot(name, path=None):
2389     ret = {"result": True, "changes": {}, "comment": "{} rebooted".format(name)}
2390     does_exist = exists(name, path=path)
2391     if does_exist and (state(name, path=path) == "running"):
2392         try:
2393             stop(name, path=path)
2394         except (SaltInvocationError, CommandExecutionError) as exc:
2395             ret["comment"] = "Unable to stop container: {}".format(exc)
2396             ret["result"] = False
2397             return ret
2398     if does_exist and (state(name, path=path) != "running"):
2399         try:
2400             start(name, path=path)
2401         except (SaltInvocationError, CommandExecutionError) as exc:
2402             ret["comment"] = "Unable to stop container: {}".format(exc)
2403             ret["result"] = False
2404             return ret
2405     ret["changes"][name] = "rebooted"
2406     return ret
2407 def reconfigure(
2408     name,
2409     cpu=None,
2410     cpuset=None,
2411     cpushare=None,
2412     memory=None,
2413     profile=None,
2414     network_profile=None,
2415     nic_opts=None,
2416     bridge=None,
2417     gateway=None,
2418     autostart=None,
2419     utsname=None,
2420     rootfs=None,
2421     path=None,
2422     **kwargs
2423 ):
2424     changes = {}
2425     cpath = get_root_path(path)
2426     path = os.path.join(cpath, name, "config")
2427     ret = {
2428         "name": name,
2429         "comment": "config for {} up to date".format(name),
2430         "result": True,
2431         "changes": changes,
2432     }
2433     profile = get_container_profile(copy.deepcopy(profile))
2434     kw_overrides = copy.deepcopy(kwargs)
2435     def select(key, default=None):
2436         kw_overrides_match = kw_overrides.pop(key, _marker)
2437         profile_match = profile.pop(key, default)
2438         if kw_overrides_match is _marker:
2439             return profile_match
2440         return kw_overrides_match
2441     if nic_opts is not None and not network_profile:
2442         network_profile = DEFAULT_NIC
2443     if autostart is not None:
2444         autostart = select("autostart", autostart)
2445     else:
2446         autostart = "keep"
2447     if not utsname:
2448         utsname = select("utsname", utsname)
2449     if os.path.exists(path):
2450         old_chunks = read_conf(path, out_format="commented")
2451         make_kw = salt.utils.odict.OrderedDict(
2452             [
2453                 ("utsname", utsname),
2454                 ("rootfs", rootfs),
2455                 ("autostart", autostart),
2456                 ("cpu", cpu),
2457                 ("gateway", gateway),
2458                 ("cpuset", cpuset),
2459                 ("cpushare", cpushare),
2460                 ("network_profile", network_profile),
2461                 ("nic_opts", nic_opts),
2462                 ("bridge", bridge),
2463             ]
2464         )
2465         if memory:
2466             make_kw["memory"] = memory
2467         kw = salt.utils.odict.OrderedDict()
2468         for key, val in make_kw.items():
2469             if val is not None:
2470                 kw[key] = val
2471         new_cfg = _config_list(conf_tuples=old_chunks, **kw)
2472         if new_cfg:
2473             edit_conf(path, out_format="commented", lxc_config=new_cfg)
2474         chunks = read_conf(path, out_format="commented")
2475         if old_chunks != chunks:
2476             ret["comment"] = "{} lxc config updated".format(name)
2477             if state(name, path=path) == "running":
2478                 cret = reboot(name, path=path)
2479                 ret["result"] = cret["result"]
2480     return ret
2481 def apply_network_profile(name, network_profile, nic_opts=None, path=None):
2482     cpath = get_root_path(path)
2483     cfgpath = os.path.join(cpath, name, "config")
2484     before = []
2485     with salt.utils.files.fopen(cfgpath, "r") as fp_:
2486         for line in fp_:
2487             before.append(line)
2488     lxcconfig = _LXCConfig(name=name, path=path)
2489     old_net = lxcconfig._filter_data("lxc.network")
2490     network_params = {}
2491     for param in _network_conf(
2492         conf_tuples=old_net, network_profile=network_profile, nic_opts=nic_opts
2493     ):
2494         network_params.update(param)
2495     if network_params:
2496         edit_conf(cfgpath, out_format="commented", **network_params)
2497     after = []
2498     with salt.utils.files.fopen(cfgpath, "r") as fp_:
2499         for line in fp_:
2500             after.append(line)
2501     diff = ""
2502     for line in difflib.unified_diff(before, after, fromfile="before", tofile="after"):
2503         diff += line
2504     return diff
2505 def get_pid(name, path=None):
2506     if name not in list_(limit="running", path=path):
2507         raise CommandExecutionError(
2508             "Container {} is not running, can't determine PID".format(name)
2509         )
2510     info = __salt__["cmd.run"]("lxc-info -n {}".format(name)).split("\n")
2511     pid = [
2512         line.split(":")[1].strip()
2513         for line in info
2514         if re.match(r"\s*PID", line) is not None
2515     ][0]
2516     return pid
2517 def add_veth(name, interface_name, bridge=None, path=None):
2518     pid = get_pid(name, path=path)
2519     while True:
2520         random_veth = "veth" + "".join(
2521             random.choice(string.ascii_uppercase + string.digits) for _ in range(6)
2522         )
2523         if random_veth not in __salt__["network.interfaces"]().keys():
2524             break
2525     if not __salt__["file.directory_exists"]("/var/run/"):
2526         raise CommandExecutionError(
2527             "Directory /var/run required for lxc.add_veth doesn't exists"
2528         )
2529     if not __salt__["file.file_exists"]("/proc/{}/ns/net".format(pid)):
2530         raise CommandExecutionError(
2531             "Proc file for container {} network namespace doesn't exists".format(name)
2532         )
2533     if not __salt__["file.directory_exists"]("/var/run/netns"):
2534         __salt__["file.mkdir"]("/var/run/netns")
2535     if __salt__["file.is_link"]("/var/run/netns/{}".format(name)):
2536         __salt__["file.remove"]("/var/run/netns/{}".format(name))
2537     __salt__["file.symlink"](
2538         "/proc/{}/ns/net".format(pid), "/var/run/netns/{}".format(name)
2539     )
2540     interface_exists = 0 == __salt__["cmd.retcode"](
2541         "ip netns exec {netns} ip address list {interface}".format(
2542             netns=name, interface=interface_name
2543         )
2544     )
2545     if interface_exists:
2546         raise CommandExecutionError(
2547             "Interface {interface} already exists in {container}".format(
2548                 interface=interface_name, container=name
2549             )
2550         )
2551     if (
2552         __salt__["cmd.retcode"](
2553             "ip link add name {veth} type veth peer name {veth}_c".format(
2554                 veth=random_veth
2555             )
2556         )
2557         != 0
2558     ):
2559         raise CommandExecutionError(
2560             "Error while creating the veth pair {}".format(random_veth)
2561         )
2562     if __salt__["cmd.retcode"]("ip link set dev {} up".format(random_veth)) != 0:
2563         raise CommandExecutionError(
2564             "Error while bringing up host-side veth {}".format(random_veth)
2565         )
2566     attached = 0 == __salt__["cmd.retcode"](
2567         "ip link set dev {veth}_c netns {container} name {interface_name}".format(
2568             veth=random_veth, container=name, interface_name=interface_name
2569         )
2570     )
2571     if not attached:
2572         raise CommandExecutionError(
2573             "Error while attaching the veth {veth} to container {container}".format(
2574                 veth=random_veth, container=name
2575             )
2576         )
2577     __salt__["file.remove"]("/var/run/netns/{}".format(name))
2578     if bridge is not None:
2579         __salt__["bridge.addif"](bridge, random_veth)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ciscoconfparse_mod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from salt.exceptions import SaltException
2 try:
3     import ciscoconfparse
4     HAS_CISCOCONFPARSE = True
5 except ImportError:
6     HAS_CISCOCONFPARSE = False
7 __virtualname__ = "ciscoconfparse"
8 def __virtual__():
9     if HAS_CISCOCONFPARSE:
10         return HAS_CISCOCONFPARSE
11     else:
12         return (False, "Missing dependency ciscoconfparse")
13 def _get_ccp(config=None, config_path=None, saltenv="base"):
14     if config_path:
15         config = __salt__["cp.get_file_str"](config_path, saltenv=saltenv)
16         if config is False:
17             raise SaltException("{} is not available".format(config_path))
18     if isinstance(config, str):
19         config = config.splitlines()
20     ccp = ciscoconfparse.CiscoConfParse(config)
21     return ccp
22 def find_objects(config=None, config_path=None, regex=None, saltenv="base"):
23     ccp = _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
24     lines = ccp.find_objects(regex)
25     return lines
26 def find_lines(config=None, config_path=None, regex=None, saltenv="base"):
27     lines = find_objects(
28         config=config, config_path=config_path, regex=regex, saltenv<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=saltenv
29     )
30     return [line.text for line in lines]
31 def find_objects_w_child(
32     config=None,
33     config_path=None,
34     parent_regex=None,
35     child_regex=None,
36     ignore_ws=False,
37     saltenv="base",
38 ):
39     """
40     ccp =</b></font> _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
41     lines = ccp.find_objects_w_child(parent_regex, child_regex, ignore_ws=ignore_ws)
42     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return lines
43 def find_lines_w_child(
44     config=None,
45     config_path=None,
46     parent_regex=None,
47     child_regex=None,
48     ignore_ws=False,
49     saltenv="base",
50 ):
51     r"""
52     Return a list of parent lines (as text)  matching the regular expression
53     ``parent_regex`` that have children lines matching ``child_regex``.
54     config
55         The configuration sent as text.
56         .. note::
57             This argument is ignored when ``config_path`` is specified.
58     config_path
59         The absolute or remote path to the file with the configuration to be
60         parsed. This argument supports the usual Salt filesystem URIs, e.g.,
61         ``salt://``, ``https://``, ``ftp://``, ``s3://``, etc.
62     parent_regex
63         The regular expression to match the parent lines against.
64     child_regex
65         The regular expression to match the child lines against.
66     ignore_ws: ``False``
67         Whether to ignore the white spaces.
68     saltenv: ``base``
69         Salt fileserver environment from which to retrieve the file. This
70         argument is ignored when ``config_path`` is not a ``salt://`` URL.
71     CLI Example:
72     .. code-block:: bash
73         salt '*' ciscoconfparse.find_lines_w_child config_path=https://bit.ly/2mAdq7z parent_line='line con' child_line='stopbits'
74         salt '*' ciscoconfparse.find_lines_w_child config_path=https://bit.ly/2uIRxau parent_regex='ge-(.*)' child_regex='unit \d+'
75     """
76     lines = find_objects_w_child(
77         config=</b></font>config,
78         config_path=config_path,
79         parent_regex=parent_regex,
80         child_regex=child_regex,
81         ignore_ws=ignore_ws,
82         saltenv=saltenv,
83     )
84     return [line.text for line in lines]
85 def find_objects_wo_child(
86     config=None,
87     config_path=None,
88     parent_regex=None,
89     child_regex=None,
90     ignore_ws=False,
91     saltenv="base",
92 ):
93     """
94     Return a list of parent ``ciscoconfparse.IOSCfgLine`` objects, which matched
95     the ``parent_regex`` and whose children did *not* match ``child_regex``.
96     Only the parent ``ciscoconfparse.IOSCfgLine`` objects will be returned. For
97     simplicity, this method only finds oldest ancestors without immediate
98     children that match.
99     .. warning::
100         This function is mostly valuable when invoked from other Salt
101         components (i.e., execution modules, states, templates etc.). For CLI
102         usage, please consider using
103         :py:func:`ciscoconfparse.find_lines_wo_child &lt;salt.ciscoconfparse_mod.find_lines_wo_child&gt;`
104     config
105         The configuration sent as text.
106         .. note::
107             This argument is ignored when ``config_path`` is specified.
108     config_path
109         The absolute or remote path to the file with the configuration to be
110         parsed. This argument supports the usual Salt filesystem URIs, e.g.,
111         ``salt://``, ``https://``, ``ftp://``, ``s3://``, etc.
112     parent_regex
113         The regular expression to match the parent lines against.
114     child_regex
115         The regular expression to match the child lines against.
116     ignore_ws: ``False``
117         Whether to ignore the white spaces.
118     saltenv: ``base``
119         Salt fileserver environment from which to retrieve the file. This
120         argument is ignored when ``config_path`` is not a ``salt://`` URL.
121     Usage example:
122     .. code-block:: python
123         objects = __salt__['ciscoconfparse.find_objects_wo_child'](config_path='https://bit.ly/2mAdq7z',
124                                                                    parent_regex='line con',
125                                                                    child_regex='stopbits')
126         for obj in objects:
127             print(obj.text)
128     """
129     ccp = _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
130     lines = ccp.find_objects_wo_child(parent_regex, child_regex, ignore_ws=ignore_ws)
131     return lines
132 def find_lines_wo_child(
133     config=None,
134     config_path=None,
135     parent_regex=None,
136     child_regex=None,
137     ignore_ws=False,
138     saltenv="base",
139 ):
140     """
141     Return a list of parent ``ciscoconfparse.IOSCfgLine`` lines as text, which
142     matched the ``parent_regex`` and whose children did *not* match ``child_regex``.
143     Only the parent ``ciscoconfparse.IOSCfgLine`` text lines  will be returned.
144     For simplicity, this method only finds oldest ancestors without immediate
145     children that match.
146     config
147         The configuration sent as text.
148         .. note::
149             This argument is ignored when ``config_path`` is specified.
150     config_path
151         The absolute or remote path to the file with the configuration to be
152         parsed. This argument supports the usual Salt filesystem URIs, e.g.,
153         ``salt://``, ``https://``, ``ftp://``, ``s3://``, etc.
154     parent_regex
155         The regular expression to match the parent lines against.
156     child_regex
157         The regular expression to match the child lines against.
158     ignore_ws: ``False``
159         Whether to ignore the white spaces.
160     saltenv: ``base``
161         Salt fileserver environment from which to retrieve the file. This
162         argument is ignored when ``config_path`` is not a ``salt://`` URL.
163     CLI Example:
164     .. code-block:: bash
165         salt '*' ciscoconfparse.find_lines_wo_child config_path=https://bit.ly/2mAdq7z parent_line='line con' child_line='stopbits'
166     """
167     lines = find_objects_wo_child(
168         config=config,
169         config_path=config_path,
170         parent_regex=parent_regex,
171         child_regex=child_regex,
172         ignore_ws=ignore_ws,
173         saltenv=saltenv,
174     )
175     return [line.text for line in lines]
176 def filter_lines(
177     config=None, config_path=None, parent_regex=None, child_regex=None, saltenv="base"
178 ):
179     """
180     Return a list of detailed matches, for the configuration blocks (parent-child
181     relationship) whose parent respects the regular expressions configured via
182     the ``parent_regex`` argument, and the child matches the ``child_regex``
183     regular expression. The result is a list of dictionaries with the following
184     keys:
185     - ``match``: a boolean value that tells whether ``child_regex`` matched any
186       children lines.
187     - ``parent``: the parent line (as text).
188     - ``child``: the child line (as text). If no child line matched, this field
189       will be ``None``.
190     Note that the return list contains the elements that matched the parent
191     condition, the ``parent_regex`` regular expression. Therefore, the ``parent``
192     field will always have a valid value, while ``match`` and ``child`` may
193     default to ``False`` and ``None`` respectively when there is not child match.
194     CLI Example:
195     .. code-block:: bash
196         salt '*' ciscoconfparse.filter_lines config_path=https://bit.ly/2mAdq7z parent_regex='Gigabit' child_regex='shutdown'
197     Example output (for the example above):
198     .. code-block:: python
199         [
200             {
201                 'parent': 'interface GigabitEthernet1',
202                 'match': False,
203                 'child': None
204             },
205             {
206                 'parent': 'interface GigabitEthernet2',
207                 'match': True,
208                 'child': ' shutdown'
209             },
210             {
211                 'parent': 'interface GigabitEthernet3',
212                 'match': True,
213                 'child': ' shutdown'
214             }
215         ]
216     """
217     ret = []
218     ccp = _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
219     parent_lines = ccp.find_objects(parent_regex)
220     for parent_line in parent_lines:
221         child_lines = parent_line.re_search_children(child_regex)
222         if child_lines:
223             for child_line in child_lines:
224                 ret.append(
225                     {
226                         "match": True,
227                         "parent": parent_line.text,
228                         "child": child_line.text,
229                     }
230                 )
231         else:
232             ret.append({"match": False, "parent": parent_line.text, "child": None})
233     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
