<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lxc_1.py &amp; ciscoconfparse_mod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lxc_1.py &amp; ciscoconfparse_mod.py
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lxc_1.py (0.48115477%)<th>ciscoconfparse_mod.py (13.483146%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(3676-3689)<td><a href="#" name="0">(155-212)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(2281-2295)<td><a href="#" name="1">(214-261)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import datetime
import difflib
import logging
import os
import pipes
import random
import re
import shutil
import string
import tempfile
import textwrap
import time
import urllib.parse
import salt.config
import salt.utils.args
import salt.utils.cloud
import salt.utils.data
import salt.utils.dictupdate
import salt.utils.files
import salt.utils.functools
import salt.utils.hashutils
import salt.utils.network
import salt.utils.odict
import salt.utils.path
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError, SaltInvocationError
from salt.utils.versions import LooseVersion as _LooseVersion
log = logging.getLogger(__name__)
__func_alias__ = {"list_": "list", "ls_": "ls"}
__virtualname__ = "lxc"
DEFAULT_NIC = "eth0"
DEFAULT_BR = "br0"
SEED_MARKER = "/lxc.initial_seed"
EXEC_DRIVER = "lxc-attach"
DEFAULT_PATH = "/var/lib/lxc"
_marker = object()
def __virtual__():
    if salt.utils.path.which("lxc-start"):
        return __virtualname__
    return (
        False,
        "The lxc execution module cannot be loaded: the lxc-start binary is not in the"
        " path.",
    )
def get_root_path(path):
    if not path:
        path = __opts__.get("lxc.root_path", DEFAULT_PATH)
    return path
def version():
    k = "lxc.version"
    if not __context__.get(k, None):
        cversion = __salt__["cmd.run_all"]("lxc-info --version")
        if not cversion["retcode"]:
            ver = _LooseVersion(cversion["stdout"])
            if ver &lt; _LooseVersion("1.0"):
                raise CommandExecutionError("LXC should be at least 1.0")
            __context__[k] = "{}".format(ver)
    return __context__.get(k, None)
def _clear_context():
    for var in [x for x in __context__ if x.startswith("lxc.")]:
        log.trace("Clearing __context__['%s']", var)
        __context__.pop(var, None)
def _ip_sort(ip):
    idx = "001"
    if ip == "127.0.0.1":
        idx = "200"
    if ip == "::1":
        idx = "201"
    elif "::" in ip:
        idx = "100"
    return "{}___{}".format(idx, ip)
def search_lxc_bridges():
    bridges = __context__.get("lxc.bridges", None)
    if not bridges:
        bridges = set()
        running_bridges = set()
        bridges.add(DEFAULT_BR)
        try:
            output = __salt__["cmd.run_all"]("brctl show")
            for line in output["stdout"].splitlines()[1:]:
                if not line.startswith(" "):
                    running_bridges.add(line.split()[0].strip())
        except (SaltInvocationError, CommandExecutionError):
            pass
        for ifc, ip in __grains__.get("ip_interfaces", {}).items():
            if ifc in running_bridges:
                bridges.add(ifc)
            elif os.path.exists("/sys/devices/virtual/net/{}/bridge".format(ifc)):
                bridges.add(ifc)
        bridges = list(bridges)
        def sort_bridges(a):
            pref = "z"
            if "lxc" in a:
                pref = "a"
            elif "br0" == a:
                pref = "c"
            return "{}_{}".format(pref, a)
        bridges.sort(key=sort_bridges)
        __context__["lxc.bridges"] = bridges
    return bridges
def search_lxc_bridge():
    return search_lxc_bridges()[0]
def _get_salt_config(config, **kwargs):
    if not config:
        config = kwargs.get("minion", {})
    if not config:
        config = {}
    config.setdefault(
        "master", kwargs.get("master", __opts__.get("master", __opts__["id"]))
    )
    config.setdefault(
        "master_port",
        kwargs.get(
            "master_port",
            __opts__.get("master_port", __opts__.get("ret_port", __opts__.get("4506"))),
        ),
    )
    if not config["master"]:
        config = {}
    return config
def cloud_init_interface(name, vm_=None, **kwargs):
    if vm_ is None:
        vm_ = {}
    vm_ = copy.deepcopy(vm_)
    vm_ = salt.utils.dictupdate.update(vm_, kwargs)
    profile_data = copy.deepcopy(vm_.get("lxc_profile", vm_.get("profile", {})))
    if not isinstance(profile_data, (dict, (str,))):
        profile_data = {}
    profile = get_container_profile(profile_data)
    def _cloud_get(k, default=None):
        return vm_.get(k, profile.get(k, default))
    if name is None:
        name = vm_["name"]
    default_template = ""
    if __grains__.get("os", "") in ["Ubuntu"]:
        default_template = "ubuntu"
    image = _cloud_get("image")
    if not image:
        _cloud_get("template", default_template)
    backing = _cloud_get("backing", "dir")
    if image:
        profile["template"] = image
    vgname = _cloud_get("vgname", None)
    if vgname:
        profile["vgname"] = vgname
    if backing:
        profile["backing"] = backing
    snapshot = _cloud_get("snapshot", False)
    autostart = bool(_cloud_get("autostart", True))
    dnsservers = _cloud_get("dnsservers", [])
    dns_via_dhcp = _cloud_get("dns_via_dhcp", True)
    password = _cloud_get("password", "s3cr3t")
    password_encrypted = _cloud_get("password_encrypted", False)
    fstype = _cloud_get("fstype", None)
    lvname = _cloud_get("lvname", None)
    thinpool = _cloud_get("thinpool", None)
    pub_key = _cloud_get("pub_key", None)
    priv_key = _cloud_get("priv_key", None)
    size = _cloud_get("size", "20G")
    script = _cloud_get("script", None)
    script_args = _cloud_get("script_args", None)
    users = _cloud_get("users", None)
    if users is None:
        users = []
    ssh_username = _cloud_get("ssh_username", None)
    if ssh_username and (ssh_username not in users):
        users.append(ssh_username)
    network_profile = _cloud_get("network_profile", None)
    nic_opts = kwargs.get("nic_opts", None)
    netmask = _cloud_get("netmask", "24")
    path = _cloud_get("path", None)
    bridge = _cloud_get("bridge", None)
    gateway = _cloud_get("gateway", None)
    unconditional_install = _cloud_get("unconditional_install", False)
    force_install = _cloud_get("force_install", True)
    config = _get_salt_config(_cloud_get("config", {}), **vm_)
    default_nic = _cloud_get("default_nic", DEFAULT_NIC)
    if not isinstance(nic_opts, dict):
        nic_opts = salt.utils.odict.OrderedDict()
    eth0 = nic_opts.setdefault(default_nic, salt.utils.odict.OrderedDict())
    if not isinstance(nic_opts, salt.utils.odict.OrderedDict):
        bnic_opts = salt.utils.odict.OrderedDict()
        bnic_opts.update(nic_opts)
        nic_opts = bnic_opts
    gw = None
    bridge = _cloud_get("bridge", None)
    ip = _cloud_get("ip", None)
    mac = _cloud_get("mac", None)
    if ip:
        fullip = ip
        if netmask:
            fullip += "/{}".format(netmask)
        eth0["ipv4"] = fullip
        if mac is not None:
            eth0["mac"] = mac
    for ix, iopts in enumerate(_cloud_get("additional_ips", [])):
        ifh = "eth{}".format(ix + 1)
        ethx = nic_opts.setdefault(ifh, {})
        if gw is None:
            gw = iopts.get("gateway", ethx.get("gateway", None))
            if gw:
                eth0.pop("gateway", None)
                gateway = None
                ethx["gateway"] = gw
        elink = iopts.get("link", ethx.get("link", None))
        if elink:
            ethx["link"] = elink
        aip = iopts.get("ipv4", iopts.get("ip", None))
        if aip:
            ethx["ipv4"] = aip
        nm = iopts.get("netmask", "")
        if nm:
            ethx["ipv4"] += "/{}".format(nm)
        for i in ("mac", "hwaddr"):
            if i in iopts:
                ethx["mac"] = iopts[i]
                break
        if "mac" not in ethx:
            ethx["mac"] = salt.utils.network.gen_mac()
    gw = None
    for ethx in [a for a in nic_opts]:
        ndata = nic_opts[ethx]
        if gw:
            ndata.pop("gateway", None)
        if "gateway" in ndata:
            gw = ndata["gateway"]
            gateway = None
    if bridge:
        eth0["link"] = bridge
    if gateway:
        eth0["gateway"] = gateway
    lxc_init_interface = {}
    lxc_init_interface["name"] = name
    lxc_init_interface["config"] = config
    lxc_init_interface["memory"] = _cloud_get("memory", 0)  # nolimit
    lxc_init_interface["pub_key"] = pub_key
    lxc_init_interface["priv_key"] = priv_key
    lxc_init_interface["nic_opts"] = nic_opts
    for clone_from in ["clone_from", "clone", "from_container"]:
        lxc_init_interface["clone_from"] = _cloud_get(clone_from, None)
        if lxc_init_interface["clone_from"] is not None:
            break
    lxc_init_interface["profile"] = profile
    lxc_init_interface["snapshot"] = snapshot
    lxc_init_interface["dnsservers"] = dnsservers
    lxc_init_interface["fstype"] = fstype
    lxc_init_interface["path"] = path
    lxc_init_interface["vgname"] = vgname
    lxc_init_interface["size"] = size
    lxc_init_interface["lvname"] = lvname
    lxc_init_interface["thinpool"] = thinpool
    lxc_init_interface["force_install"] = force_install
    lxc_init_interface["unconditional_install"] = unconditional_install
    lxc_init_interface["bootstrap_url"] = script
    lxc_init_interface["bootstrap_args"] = script_args
    lxc_init_interface["bootstrap_shell"] = _cloud_get("bootstrap_shell", "sh")
    lxc_init_interface["bootstrap_delay"] = _cloud_get("bootstrap_delay", None)
    lxc_init_interface["autostart"] = autostart
    lxc_init_interface["users"] = users
    lxc_init_interface["password"] = password
    lxc_init_interface["password_encrypted"] = password_encrypted
    lxc_init_interface["network_profile"] = network_profile
    for i in ["cpu", "cpuset", "cpushare"]:
        if _cloud_get(i, None):
            try:
                lxc_init_interface[i] = vm_[i]
            except KeyError:
                lxc_init_interface[i] = profile[i]
    return lxc_init_interface
def _get_profile(key, name, **kwargs):
    if isinstance(name, dict):
        profilename = name.pop("name", None)
        return _get_profile(key, profilename, **name)
    if name is None:
        profile_match = {}
    else:
        profile_match = __salt__["config.get"](
            "lxc.{1}:{0}".format(name, key), default=None, merge="recurse"
        )
        if profile_match is None:
            profile_match = {}
    if not isinstance(profile_match, dict):
        raise CommandExecutionError("lxc.{} must be a dictionary".format(key))
    overrides = salt.utils.args.clean_kwargs(**copy.deepcopy(kwargs))
    profile_match = salt.utils.dictupdate.update(
        copy.deepcopy(profile_match), overrides
    )
    return profile_match
def get_container_profile(name=None, **kwargs):
    profile = _get_profile("container_profile", name, **kwargs)
    return profile
def get_network_profile(name=None, **kwargs):
    profile = _get_profile("network_profile", name, **kwargs)
    return profile
def _rand_cpu_str(cpu):
    cpu = int(cpu)
    avail = __salt__["status.nproc"]()
    if cpu &lt; avail:
        return "0-{}".format(avail)
    to_set = set()
    while len(to_set) &lt; cpu:
        choice = random.randint(0, avail - 1)
        if choice not in to_set:
            to_set.add(str(choice))
    return ",".join(sorted(to_set))
def _network_conf(conf_tuples=None, **kwargs):
    nic = kwargs.get("network_profile", None)
    ret = []
    nic_opts = kwargs.get("nic_opts", {})
    if nic_opts is None:
        nic_opts = {}
    if not conf_tuples:
        conf_tuples = []
    old = _get_veths(conf_tuples)
    if not old:
        old = {}
    if nic and isinstance(nic, ((str,), dict)):
        nicp = get_network_profile(nic)
    else:
        nicp = {}
    if DEFAULT_NIC not in nicp:
        nicp[DEFAULT_NIC] = {}
    kwargs = copy.deepcopy(kwargs)
    gateway = kwargs.pop("gateway", None)
    bridge = kwargs.get("bridge", None)
    if nic_opts:
        for dev, args in nic_opts.items():
            ethx = nicp.setdefault(dev, {})
            try:
                ethx = salt.utils.dictupdate.update(ethx, args)
            except AttributeError:
                raise SaltInvocationError("Invalid nic_opts configuration")
    ifs = [a for a in nicp]
    ifs += [a for a in old if a not in nicp]
    ifs.sort()
    gateway_set = False
    for dev in ifs:
        args = nicp.get(dev, {})
        opts = nic_opts.get(dev, {}) if nic_opts else {}
        old_if = old.get(dev, {})
        disable = opts.get("disable", args.get("disable", False))
        if disable:
            continue
        mac = opts.get(
            "mac", opts.get("hwaddr", args.get("mac", args.get("hwaddr", "")))
        )
        type_ = opts.get("type", args.get("type", ""))
        flags = opts.get("flags", args.get("flags", ""))
        link = opts.get("link", args.get("link", ""))
        ipv4 = opts.get("ipv4", args.get("ipv4", ""))
        ipv6 = opts.get("ipv6", args.get("ipv6", ""))
        infos = salt.utils.odict.OrderedDict(
            [
                (
                    "lxc.network.type",
                    {
                        "test": not type_,
                        "value": type_,
                        "old": old_if.get("lxc.network.type"),
                        "default": "veth",
                    },
                ),
                (
                    "lxc.network.name",
                    {"test": False, "value": dev, "old": dev, "default": dev},
                ),
                (
                    "lxc.network.flags",
                    {
                        "test": not flags,
                        "value": flags,
                        "old": old_if.get("lxc.network.flags"),
                        "default": "up",
                    },
                ),
                (
                    "lxc.network.link",
                    {
                        "test": not link,
                        "value": link,
                        "old": old_if.get("lxc.network.link"),
                        "default": search_lxc_bridge(),
                    },
                ),
                (
                    "lxc.network.hwaddr",
                    {
                        "test": not mac,
                        "value": mac,
                        "old": old_if.get("lxc.network.hwaddr"),
                        "default": salt.utils.network.gen_mac(),
                    },
                ),
                (
                    "lxc.network.ipv4",
                    {
                        "test": not ipv4,
                        "value": ipv4,
                        "old": old_if.get("lxc.network.ipv4", ""),
                        "default": None,
                    },
                ),
                (
                    "lxc.network.ipv6",
                    {
                        "test": not ipv6,
                        "value": ipv6,
                        "old": old_if.get("lxc.network.ipv6", ""),
                        "default": None,
                    },
                ),
            ]
        )
        for info in list(infos.keys()):
            bundle = infos[info]
            if bundle["test"]:
                if bundle["old"]:
                    bundle["value"] = bundle["old"]
                elif bundle["default"]:
                    bundle["value"] = bundle["default"]
        for info, data in infos.items():
            if data["value"]:
                ret.append({info: data["value"]})
        for key, val in args.items():
            if key == "link" and bridge:
                val = bridge
            val = opts.get(key, val)
            if key in [
                "type",
                "flags",
                "name",
                "gateway",
                "mac",
                "link",
                "ipv4",
                "ipv6",
            ]:
                continue
            ret.append({"lxc.network.{}".format(key): val})
        if not gateway:
            gateway = args.get("gateway", None)
        if gateway is not None and not gateway_set:
            ret.append({"lxc.network.ipv4.gateway": gateway})
            gateway_set = True
    if gateway is not None and not gateway_set:
        ret.append({"lxc.network.ipv4.gateway": gateway})
        gateway_set = True
    new = _get_veths(ret)
    for iface in [a for a in new]:
        ndata = new[iface]
        nmac = ndata.get("lxc.network.hwaddr", "")
        ntype = ndata.get("lxc.network.type", "")
        omac, otype = "", ""
        if iface in old:
            odata = old[iface]
            omac = odata.get("lxc.network.hwaddr", "")
            otype = odata.get("lxc.network.type", "")
        if otype and not ntype:
            ntype = otype
        if not ntype:
            ntype = "veth"
        new[iface]["lxc.network.type"] = ntype
        if omac and not nmac:
            new[iface]["lxc.network.hwaddr"] = omac
    ret = []
    for val in new.values():
        for row in val:
            ret.append(salt.utils.odict.OrderedDict([(row, val[row])]))
    if (
        _LooseVersion(version()) &lt;= _LooseVersion("1.0.7")
        and True not in ["lxc.network.ipv4.gateway" in a for a in ret]
        and True in ["lxc.network.ipv4" in a for a in ret]
    ):
        ret.append({"lxc.network.ipv4.gateway": "auto"})
    return ret
def _get_lxc_default_data(**kwargs):
    kwargs = copy.deepcopy(kwargs)
    ret = {}
    for k in ["utsname", "rootfs"]:
        val = kwargs.get(k, None)
        if val is not None:
            ret["lxc.{}".format(k)] = val
    autostart = kwargs.get("autostart")
    if autostart is None:
        autostart = True
    if autostart != "keep":
        if autostart:
            ret["lxc.start.auto"] = "1"
        else:
            ret["lxc.start.auto"] = "0"
    memory = kwargs.get("memory")
    if memory is not None:
        ret["lxc.cgroup.memory.limit_in_bytes"] = memory * 1024 * 1024
    cpuset = kwargs.get("cpuset")
    if cpuset:
        ret["lxc.cgroup.cpuset.cpus"] = cpuset
    cpushare = kwargs.get("cpushare")
    cpu = kwargs.get("cpu")
    if cpushare:
        ret["lxc.cgroup.cpu.shares"] = cpushare
    if cpu and not cpuset:
        ret["lxc.cgroup.cpuset.cpus"] = _rand_cpu_str(cpu)
    return ret
def _config_list(conf_tuples=None, only_net=False, **kwargs):
    only_net = bool(only_net)
    if not conf_tuples:
        conf_tuples = []
    kwargs = copy.deepcopy(kwargs)
    ret = []
    if not only_net:
        default_data = _get_lxc_default_data(**kwargs)
        for k, val in default_data.items():
            ret.append({k: val})
    net_datas = _network_conf(conf_tuples=conf_tuples, **kwargs)
    ret.extend(net_datas)
    return ret
def _get_veths(net_data):
    if isinstance(net_data, dict):
        net_data = list(net_data.items())
    nics = salt.utils.odict.OrderedDict()
    current_nic = salt.utils.odict.OrderedDict()
    no_names = True
    for item in net_data:
        if item and isinstance(item, dict):
            item = list(item.items())[0]
        elif isinstance(item, str):
            sitem = item.strip()
            if sitem.startswith("#") or not sitem:
                continue
            elif "=" in item:
                item = tuple(a.strip() for a in item.split("=", 1))
        if item[0] == "lxc.network.type":
            current_nic = salt.utils.odict.OrderedDict()
        if item[0] == "lxc.network.name":
            no_names = False
            nics[item[1].strip()] = current_nic
        current_nic[item[0].strip()] = item[1].strip()
    if no_names and current_nic:
        nics[DEFAULT_NIC] = current_nic
    return nics
class _LXCConfig:
    pattern = re.compile(r"^(\S+)(\s*)(=)(\s*)(.*)")
    non_interpretable_pattern = re.compile(r"^((#.*)|(\s*))$")
    def __init__(self, **kwargs):
        kwargs = copy.deepcopy(kwargs)
        self.name = kwargs.pop("name", None)
        path = get_root_path(kwargs.get("path", None))
        self.data = []
        if self.name:
            self.path = os.path.join(path, self.name, "config")
            if os.path.isfile(self.path):
                with salt.utils.files.fopen(self.path) as fhr:
                    for line in salt.utils.data.decode(fhr.readlines()):
                        match = self.pattern.findall(line.strip())
                        if match:
                            self.data.append((match[0][0], match[0][-1]))
                        match = self.non_interpretable_pattern.findall(line.strip())
                        if match:
                            self.data.append(("", match[0][0]))
        else:
            self.path = None
        def _replace(key, val):
            if val:
                self._filter_data(key)
                self.data.append((key, val))
        default_data = _get_lxc_default_data(**kwargs)
        for key, val in default_data.items():
            _replace(key, val)
        old_net = self._filter_data("lxc.network")
        net_datas = _network_conf(conf_tuples=old_net, **kwargs)
        if net_datas:
            for row in net_datas:
                self.data.extend(list(row.items()))
        for idx in ["lxc.cgroup.memory.limit_in_bytes"]:
            if not default_data.get(idx):
                self._filter_data(idx)
    def as_string(self):
        chunks = (
            "{0[0]}{1}{0[1]}".format(item, (" = " if item[0] else ""))
            for item in self.data
        )
        return "\n".join(chunks) + "\n"
    def write(self):
        if self.path:
            content = self.as_string()
            with salt.utils.files.fopen(self.path, "w") as fic:
                fic.write(salt.utils.stringutils.to_str(content))
                fic.flush()
    def tempfile(self):
        ntf = tempfile.NamedTemporaryFile()
        ntf.write(self.as_string())
        ntf.flush()
        return ntf
    def _filter_data(self, pattern):
        removed = []
        filtered = []
        for param in self.data:
            if not param[0].startswith(pattern):
                filtered.append(param)
            else:
                removed.append(param)
        self.data = filtered
        return removed
def _get_base(**kwargs):
    profile = get_container_profile(copy.deepcopy(kwargs.get("profile")))
    kw_overrides = copy.deepcopy(kwargs)
    def select(key, default=None):
        kw_overrides_match = kw_overrides.pop(key, _marker)
        profile_match = profile.pop(key, default)
        if kw_overrides_match is _marker:
            return profile_match
        return kw_overrides_match
    template = select("template")
    image = select("image")
    vgname = select("vgname")
    path = kwargs.get("path", None)
    for param in ("path", "image", "vgname", "template"):
        kwargs.pop(param, None)
    if image:
        proto = urllib.parse.urlparse(image).scheme
        img_tar = __salt__["cp.cache_file"](image)
        img_name = os.path.basename(img_tar)
        hash_ = salt.utils.hashutils.get_hash(
            img_tar, __salt__["config.get"]("hash_type")
        )
        name = "__base_{}_{}_{}".format(proto, img_name, hash_)
        if not exists(name, path=path):
            create(
                name, template=template, image=image, path=path, vgname=vgname, **kwargs
            )
            if vgname:
                rootfs = os.path.join("/dev", vgname, name)
                edit_conf(
                    info(name, path=path)["config"],
                    out_format="commented",
                    **{"lxc.rootfs": rootfs}
                )
        return name
    elif template:
        name = "__base_{}".format(template)
        if not exists(name, path=path):
            create(
                name, template=template, image=image, path=path, vgname=vgname, **kwargs
            )
            if vgname:
                rootfs = os.path.join("/dev", vgname, name)
                edit_conf(
                    info(name, path=path)["config"],
                    out_format="commented",
                    **{"lxc.rootfs": rootfs}
                )
        return name
    return ""
def init(
    name,
    config=None,
    cpuset=None,
    cpushare=None,
    memory=None,
    profile=None,
    network_profile=None,
    nic_opts=None,
    cpu=None,
    autostart=True,
    password=None,
    password_encrypted=None,
    users=None,
    dnsservers=None,
    searchdomains=None,
    bridge=None,
    gateway=None,
    pub_key=None,
    priv_key=None,
    force_install=False,
    unconditional_install=False,
    bootstrap_delay=None,
    bootstrap_args=None,
    bootstrap_shell=None,
    bootstrap_url=None,
    **kwargs
):
    ret = {"name": name, "changes": {}}
    profile = get_container_profile(copy.deepcopy(profile))
    if not network_profile:
        network_profile = profile.get("network_profile")
    if not network_profile:
        network_profile = DEFAULT_NIC
    changes_dict = {"init": []}
    changes = changes_dict.get("init")
    if users is None:
        users = []
    dusers = ["root"]
    for user in dusers:
        if user not in users:
            users.append(user)
    kw_overrides = copy.deepcopy(kwargs)
    def select(key, default=None):
        kw_overrides_match = kw_overrides.pop(key, _marker)
        profile_match = profile.pop(key, default)
        if kw_overrides_match is _marker:
            return profile_match
        return kw_overrides_match
    path = select("path")
    bpath = get_root_path(path)
    state_pre = state(name, path=path)
    tvg = select("vgname")
    vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
    start_ = select("start", True)
    autostart = select("autostart", autostart)
    seed = select("seed", True)
    install = select("install", True)
    seed_cmd = select("seed_cmd")
    salt_config = _get_salt_config(config, **kwargs)
    approve_key = select("approve_key", True)
    clone_from = select("clone_from")
    if vgname and not clone_from:
        try:
            kwargs["vgname"] = vgname
            clone_from = _get_base(profile=profile, **kwargs)
        except (SaltInvocationError, CommandExecutionError) as exc:
            ret["comment"] = exc.strerror
            if changes:
                ret["changes"] = changes_dict
            return ret
        if not kwargs.get("snapshot") is False:
            kwargs["snapshot"] = True
    does_exist = exists(name, path=path)
    to_reboot = False
    remove_seed_marker = False
    if does_exist:
        pass
    elif clone_from:
        remove_seed_marker = True
        try:
            clone(name, clone_from, profile=profile, **kwargs)
            changes.append({"create": "Container cloned"})
        except (SaltInvocationError, CommandExecutionError) as exc:
            if "already exists" in exc.strerror:
                changes.append({"create": "Container already exists"})
            else:
                ret["result"] = False
                ret["comment"] = exc.strerror
                if changes:
                    ret["changes"] = changes_dict
                return ret
        cfg = _LXCConfig(
            name=name,
            network_profile=network_profile,
            nic_opts=nic_opts,
            bridge=bridge,
            path=path,
            gateway=gateway,
            autostart=autostart,
            cpuset=cpuset,
            cpushare=cpushare,
            memory=memory,
        )
        old_chunks = read_conf(cfg.path, out_format="commented")
        cfg.write()
        chunks = read_conf(cfg.path, out_format="commented")
        if old_chunks != chunks:
            to_reboot = True
    else:
        remove_seed_marker = True
        cfg = _LXCConfig(
            network_profile=network_profile,
            nic_opts=nic_opts,
            cpuset=cpuset,
            path=path,
            bridge=bridge,
            gateway=gateway,
            autostart=autostart,
            cpushare=cpushare,
            memory=memory,
        )
        with cfg.tempfile() as cfile:
            try:
                create(name, config=cfile.name, profile=profile, **kwargs)
                changes.append({"create": "Container created"})
            except (SaltInvocationError, CommandExecutionError) as exc:
                if "already exists" in exc.strerror:
                    changes.append({"create": "Container already exists"})
                else:
                    ret["comment"] = exc.strerror
                    if changes:
                        ret["changes"] = changes_dict
                    return ret
        cpath = os.path.join(bpath, name, "config")
        old_chunks = []
        if os.path.exists(cpath):
            old_chunks = read_conf(cpath, out_format="commented")
        new_cfg = _config_list(
            conf_tuples=old_chunks,
            cpu=cpu,
            network_profile=network_profile,
            nic_opts=nic_opts,
            bridge=bridge,
            cpuset=cpuset,
            cpushare=cpushare,
            memory=memory,
        )
        if new_cfg:
            edit_conf(cpath, out_format="commented", lxc_config=new_cfg)
        chunks = read_conf(cpath, out_format="commented")
        if old_chunks != chunks:
            to_reboot = True
    cfg = _LXCConfig(
        name=name,
        network_profile=network_profile,
        nic_opts=nic_opts,
        bridge=bridge,
        path=path,
        gateway=gateway,
        autostart=autostart,
        cpuset=cpuset,
        cpushare=cpushare,
        memory=memory,
    )
    old_chunks = []
    if os.path.exists(cfg.path):
        old_chunks = read_conf(cfg.path, out_format="commented")
    cfg.write()
    chunks = read_conf(cfg.path, out_format="commented")
    if old_chunks != chunks:
        changes.append({"config": "Container configuration updated"})
        to_reboot = True
    if to_reboot:
        try:
            stop(name, path=path)
        except (SaltInvocationError, CommandExecutionError) as exc:
            ret["comment"] = "Unable to stop container: {}".format(exc)
            if changes:
                ret["changes"] = changes_dict
            return ret
    if not does_exist or (does_exist and state(name, path=path) != "running"):
        try:
            start(name, path=path)
        except (SaltInvocationError, CommandExecutionError) as exc:
            ret["comment"] = "Unable to stop container: {}".format(exc)
            if changes:
                ret["changes"] = changes_dict
            return ret
    if remove_seed_marker:
        run(
            name,
            "rm -f '{}'".format(SEED_MARKER),
            path=path,
            chroot_fallback=False,
            python_shell=False,
        )
    if ret.get("result", True) and password:
        gid = "/.lxc.initial_pass"
        gids = [gid, "/lxc.initial_pass", "/.lxc.{}.initial_pass".format(name)]
        if not any(
            retcode(
                name,
                'test -e "{}"'.format(x),
                chroot_fallback=True,
                path=path,
                ignore_retcode=True,
            )
            == 0
            for x in gids
        ):
            for default_user in ["ubuntu"]:
                if (
                    default_user not in users
                    and retcode(
                        name,
                        "id {}".format(default_user),
                        python_shell=False,
                        path=path,
                        chroot_fallback=True,
                        ignore_retcode=True,
                    )
                    == 0
                ):
                    users.append(default_user)
            for user in users:
                try:
                    cret = set_password(
                        name,
                        users=[user],
                        path=path,
                        password=password,
                        encrypted=password_encrypted,
                    )
                except (SaltInvocationError, CommandExecutionError) as exc:
                    msg = "{}: Failed to set password".format(user) + exc.strerror
                    if user == "root":
                        ret["comment"] = msg
                        ret["result"] = False
                    else:
                        log.debug(msg)
            if ret.get("result", True):
                changes.append({"password": "Password(s) updated"})
                if (
                    retcode(
                        name,
                        'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
                        path=path,
                        chroot_fallback=True,
                        ignore_retcode=True,
                    )
                    != 0
                ):
                    ret["comment"] = "Failed to set password marker"
                    changes[-1]["password"] += ". " + ret["comment"] + "."
                    ret["result"] = False
    if ret.get("result", True) and dnsservers:
        gid = "/.lxc.initial_dns"
        gids = [gid, "/lxc.initial_dns", "/lxc.{}.initial_dns".format(name)]
        if not any(
            retcode(
                name,
                'test -e "{}"'.format(x),
                chroot_fallback=True,
                path=path,
                ignore_retcode=True,
            )
            == 0
            for x in gids
        ):
            try:
                set_dns(
                    name, path=path, dnsservers=dnsservers, searchdomains=searchdomains
                )
            except (SaltInvocationError, CommandExecutionError) as exc:
                ret["comment"] = "Failed to set DNS: " + exc.strerror
                ret["result"] = False
            else:
                changes.append({"dns": "DNS updated"})
                if (
                    retcode(
                        name,
                        'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
                        chroot_fallback=True,
                        path=path,
                        ignore_retcode=True,
                    )
                    != 0
                ):
                    ret["comment"] = "Failed to set DNS marker"
                    changes[-1]["dns"] += ". " + ret["comment"] + "."
                    ret["result"] = False
    if remove_seed_marker:
        run(name, "rm -f '{}'".format(SEED_MARKER), path=path, python_shell=False)
    gid = "/.lxc.initial_seed"
    gids = [gid, "/lxc.initial_seed"]
    if (
        any(
            retcode(
                name,
                "test -e {}".format(x),
                path=path,
                chroot_fallback=True,
                ignore_retcode=True,
            )
            == 0
            for x in gids
        )
        or not ret.get("result", True)
    ):
        pass
    elif seed or seed_cmd:
        if seed:
            try:
                result = bootstrap(
                    name,
                    config=salt_config,
                    path=path,
                    approve_key=approve_key,
                    pub_key=pub_key,
                    priv_key=priv_key,
                    install=install,
                    force_install=force_install,
                    unconditional_install=unconditional_install,
                    bootstrap_delay=bootstrap_delay,
                    bootstrap_url=bootstrap_url,
                    bootstrap_shell=bootstrap_shell,
                    bootstrap_args=bootstrap_args,
                )
            except (SaltInvocationError, CommandExecutionError) as exc:
                ret["comment"] = "Bootstrap failed: " + exc.strerror
                ret["result"] = False
            else:
                if not result:
                    ret[
                        "comment"
                    ] = "Bootstrap failed, see minion log for more information"
                    ret["result"] = False
                else:
                    changes.append({"bootstrap": "Container successfully bootstrapped"})
        elif seed_cmd:
            try:
                result = __salt__[seed_cmd](
                    info(name, path=path)["rootfs"], name, salt_config
                )
            except (SaltInvocationError, CommandExecutionError) as exc:
                ret["comment"] = "Bootstrap via seed_cmd '{}' failed: {}".format(
                    seed_cmd, exc.strerror
                )
                ret["result"] = False
            else:
                if not result:
                    ret["comment"] = (
                        "Bootstrap via seed_cmd '{}' failed, "
                        "see minion log for more information ".format(seed_cmd)
                    )
                    ret["result"] = False
                else:
                    changes.append(
                        {
                            "bootstrap": (
                                "Container successfully bootstrapped "
                                "using seed_cmd '{}'".format(seed_cmd)
                            )
                        }
                    )
    if ret.get("result", True) and not start_:
        try:
            stop(name, path=path)
        except (SaltInvocationError, CommandExecutionError) as exc:
            ret["comment"] = "Unable to stop container: {}".format(exc)
            ret["result"] = False
    state_post = state(name, path=path)
    if state_pre != state_post:
        changes.append({"state": {"old": state_pre, "new": state_post}})
    if ret.get("result", True):
        ret["comment"] = "Container '{}' successfully initialized".format(name)
        ret["result"] = True
    if changes:
        ret["changes"] = changes_dict
    return ret
def cloud_init(name, vm_=None, **kwargs):
    init_interface = cloud_init_interface(name, vm_, **kwargs)
    name = init_interface.pop("name", name)
    return init(name, **init_interface)
def images(dist=None):
    out = __salt__["cmd.run_stdout"](
        "lxc-create -n __imgcheck -t download -- --list", ignore_retcode=True
    )
    if "DIST" not in out:
        raise CommandExecutionError(
            "Unable to run the 'download' template script. Is it installed?"
        )
    ret = {}
    passed_header = False
    for line in out.splitlines():
        try:
            distro, release, arch, variant, build_time = line.split()
        except ValueError:
            continue
        if not passed_header:
            if distro == "DIST":
                passed_header = True
            continue
        dist_list = ret.setdefault(distro, [])
        dist_list.append(
            {
                "release": release,
                "arch": arch,
                "variant": variant,
                "build_time": build_time,
            }
        )
    if dist is not None:
        return dict([(dist, ret.get(dist, []))])
    return ret
def templates():
    try:
        template_scripts = os.listdir("/usr/share/lxc/templates")
    except OSError:
        return []
    else:
        return [x[4:] for x in template_scripts if x.startswith("lxc-")]
def _after_ignition_network_profile(cmd, ret, name, network_profile, path, nic_opts):
    _clear_context()
    if ret["retcode"] == 0 and exists(name, path=path):
        if network_profile:
            network_changes = apply_network_profile(
                name, network_profile, path=path, nic_opts=nic_opts
            )
            if network_changes:
                log.info(
                    "Network changes from applying network profile '%s' "
                    "to newly-created container '%s':\n%s",
                    network_profile,
                    name,
                    network_changes,
                )
        c_state = state(name, path=path)
        return {"result": True, "state": {"old": None, "new": c_state}}
    else:
        if exists(name, path=path):
            cmd = "lxc-destroy"
            if path:
                cmd += " -P {}".format(pipes.quote(path))
            cmd += " -n {}".format(name)
            __salt__["cmd.retcode"](cmd, python_shell=False)
        raise CommandExecutionError(
            "Container could not be created with cmd '{}': {}".format(
                cmd, ret["stderr"]
            )
        )
def create(
    name, config=None, profile=None, network_profile=None, nic_opts=None, **kwargs
):
    download_template_deps = ("dist", "release", "arch")
    cmd = "lxc-create -n {}".format(name)
    profile = get_container_profile(copy.deepcopy(profile))
    kw_overrides = copy.deepcopy(kwargs)
    def select(key, default=None):
        kw_overrides_match = kw_overrides.pop(key, None)
        profile_match = profile.pop(key, default)
        if kw_overrides_match is None:
            return profile_match
        return kw_overrides_match
    path = select("path")
    if exists(name, path=path):
        raise CommandExecutionError("Container '{}' already exists".format(name))
    tvg = select("vgname")
    vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
    template = select("template")
    image = select("image")
    if template and image:
        raise SaltInvocationError("Only one of 'template' and 'image' is permitted")
    elif not any((template, image, profile)):
        raise SaltInvocationError(
            "At least one of 'template', 'image', and 'profile' is required"
        )
    options = select("options") or {}
    backing = select("backing")
    if vgname and not backing:
        backing = "lvm"
    lvname = select("lvname")
    thinpool = select("thinpool")
    fstype = select("fstype")
    size = select("size", "1G")
    zfsroot = select("zfsroot")
    if backing in ("dir", "overlayfs", "btrfs", "zfs"):
        fstype = None
        size = None
    if backing in ("aufs", "dir", "overlayfs", "btrfs"):
        lvname = vgname = thinpool = None
    if image:
        img_tar = __salt__["cp.cache_file"](image)
        template = os.path.join(
            os.path.dirname(salt.__file__), "templates", "lxc", "salt_tarball"
        )
        options["imgtar"] = img_tar
    if path:
        cmd += " -P {}".format(pipes.quote(path))
        if not os.path.exists(path):
            os.makedirs(path)
    if config:
        cmd += " -f {}".format(config)
    if template:
        cmd += " -t {}".format(template)
    if backing:
        backing = backing.lower()
        cmd += " -B {}".format(backing)
        if backing in ("zfs",):
            if zfsroot:
                cmd += " --zfsroot {}".format(zfsroot)
        if backing in ("lvm",):
            if lvname:
                cmd += " --lvname {}".format(lvname)
            if vgname:
                cmd += " --vgname {}".format(vgname)
            if thinpool:
                cmd += " --thinpool {}".format(thinpool)
        if backing not in ("dir", "overlayfs"):
            if fstype:
                cmd += " --fstype {}".format(fstype)
            if size:
                cmd += " --fssize {}".format(size)
    if options:
        if template == "download":
            missing_deps = [x for x in download_template_deps if x not in options]
            if missing_deps:
                raise SaltInvocationError(
                    "Missing params in 'options' dict: {}".format(
                        ", ".join(missing_deps)
                    )
                )
        cmd += " --"
        for key, val in options.items():
            cmd += " --{} {}".format(key, val)
    ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    return _after_ignition_network_profile(
        cmd, ret, name, network_profile, path, nic_opts
    )
def clone(name, orig, profile=None, network_profile=None, nic_opts=None, **kwargs):
    profile = get_container_profile(copy.deepcopy(profile))
    kw_overrides = copy.deepcopy(kwargs)
    def select(key, default=None):
        kw_overrides_match = kw_overrides.pop(key, None)
        profile_match = profile.pop(key, default)
        if kw_overrides_match is None:
            return profile_match
        return kw_overrides_match
    path = select("path")
    if exists(name, path=path):
        raise CommandExecutionError("Container '{}' already exists".format(name))
    _ensure_exists(orig, path=path)
    if state(orig, path=path) != "stopped":
        raise CommandExecutionError(
            "Container '{}' must be stopped to be cloned".format(orig)
        )
    backing = select("backing")
    snapshot = select("snapshot")
    if backing in ("dir",):
        snapshot = False
    if not snapshot:
        snapshot = ""
    else:
        snapshot = "-s"
    size = select("size", "1G")
    if backing in ("dir", "overlayfs", "btrfs"):
        size = None
    if _LooseVersion(version()) &gt;= _LooseVersion("2.0"):
        cmd = "lxc-copy"
        cmd += " {} -n {} -N {}".format(snapshot, orig, name)
    else:
        cmd = "lxc-clone"
        cmd += " {} -o {} -n {}".format(snapshot, orig, name)
    if path:
        cmd += " -P {}".format(pipes.quote(path))
        if not os.path.exists(path):
            os.makedirs(path)
    if backing:
        backing = backing.lower()
        cmd += " -B {}".format(backing)
        if backing not in ("dir", "overlayfs"):
            if size:
                cmd += " -L {}".format(size)
    ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    return _after_ignition_network_profile(
        cmd, ret, name, network_profile, path, nic_opts
    )
def ls_(active=None, cache=True, path=None):
    contextvar = "lxc.ls{}".format(path)
    if active:
        contextvar += ".active"
    if cache and (contextvar in __context__):
        return __context__[contextvar]
    else:
        ret = []
        cmd = "lxc-ls"
        if path:
            cmd += " -P {}".format(pipes.quote(path))
        if active:
            cmd += " --active"
        output = __salt__["cmd.run_stdout"](cmd, python_shell=False)
        for line in output.splitlines():
            ret.extend(line.split())
        __context__[contextvar] = ret
        return ret
def list_(extra=False, limit=None, path=None):
    ctnrs = ls_(path=path)
    if extra:
        stopped = {}
        frozen = {}
        running = {}
    else:
        stopped = []
        frozen = []
        running = []
    ret = {"running": running, "stopped": stopped, "frozen": frozen}
    for container in ctnrs:
        cmd = "lxc-info"
        if path:
            cmd += " -P {}".format(pipes.quote(path))
        cmd += " -n {}".format(container)
        c_info = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="debug")
        c_state = None
        for line in c_info.splitlines():
            stat = line.split(":")
            if stat[0] in ("State", "state"):
                c_state = stat[1].strip()
                break
        if not c_state or (limit is not None and c_state.lower() != limit):
            continue
        if extra:
            infos = info(container, path=path)
            method = "update"
            value = {container: infos}
        else:
            method = "append"
            value = container
        if c_state == "STOPPED":
            getattr(stopped, method)(value)
            continue
        if c_state == "FROZEN":
            getattr(frozen, method)(value)
            continue
        if c_state == "RUNNING":
            getattr(running, method)(value)
            continue
<a name="1"></a>
    if limit is not None:
        return ret.get(limit, {} if extra else [])
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
def _change_state(
    cmd,
    name,
    expected,
    stdin=_marker,
    stdout=_marker,
    stderr=_marker,
    with_communicate=_marker,
    use_vt=_marker,
    path=None,
):
    pre = state(name, path=</b></font>path)
    if pre == expected:
        return {
            "result": True,
            "state": {"old": expected, "new": expected},
            "comment": "Container '{}' already {}".format(name, expected),
        }
    if cmd == "lxc-destroy":
        scmd = "lxc-stop"
        if path:
            scmd += " -P {}".format(pipes.quote(path))
        scmd += " -k -n {}".format(name)
        __salt__["cmd.run"](scmd, python_shell=False)
    if path and " -P " not in cmd:
        cmd += " -P {}".format(pipes.quote(path))
    cmd += " -n {}".format(name)
    pkwargs = {
        "python_shell": False,
        "redirect_stderr": True,
        "with_communicate": with_communicate,
        "use_vt": use_vt,
        "stdin": stdin,
        "stdout": stdout,
    }
    for i in [a for a in pkwargs]:
        val = pkwargs[i]
        if val is _marker:
            pkwargs.pop(i, None)
    _cmdout = __salt__["cmd.run_all"](cmd, **pkwargs)
    if _cmdout["retcode"] != 0:
        raise CommandExecutionError(
            "Error changing state for container '{}' using command '{}': {}".format(
                name, cmd, _cmdout["stdout"]
            )
        )
    if expected is not None:
        rcmd = "lxc-wait"
        if path:
            rcmd += " -P {}".format(pipes.quote(path))
        rcmd += " -n {} -s {}".format(name, expected.upper())
        __salt__["cmd.run"](rcmd, python_shell=False, timeout=30)
    _clear_context()
    post = state(name, path=path)
    ret = {"result": post == expected, "state": {"old": pre, "new": post}}
    return ret
def _ensure_exists(name, path=None):
    if not exists(name, path=path):
        raise CommandExecutionError("Container '{}' does not exist".format(name))
def _ensure_running(name, no_start=False, path=None):
    _ensure_exists(name, path=path)
    pre = state(name, path=path)
    if pre == "running":
        return start(name, path=path)
    elif pre == "stopped":
        if no_start:
            raise CommandExecutionError("Container '{}' is not running".format(name))
        return start(name, path=path)
    elif pre == "frozen":
        if no_start:
            raise CommandExecutionError("Container '{}' is not running".format(name))
        return unfreeze(name, path=path)
def restart(name, path=None, lxc_config=None, force=False):
    _ensure_exists(name, path=path)
    orig_state = state(name, path=path)
    if orig_state != "stopped":
        stop(name, kill=force, path=path)
    ret = start(name, path=path, lxc_config=lxc_config)
    ret["state"]["old"] = orig_state
    if orig_state != "stopped":
        ret["restarted"] = True
    return ret
def start(name, **kwargs):
    path = kwargs.get("path", None)
    cpath = get_root_path(path)
    lxc_config = kwargs.get("lxc_config", None)
    cmd = "lxc-start"
    if not lxc_config:
        lxc_config = os.path.join(cpath, name, "config")
    if os.path.exists(lxc_config):
        cmd += " -f {}".format(pipes.quote(lxc_config))
    cmd += " -d"
    _ensure_exists(name, path=path)
    if state(name, path=path) == "frozen":
        raise CommandExecutionError(
            "Container '{}' is frozen, use lxc.unfreeze".format(name)
        )
    use_vt = kwargs.get("use_vt", None)
    with_communicate = kwargs.get("with_communicate", False)
    return _change_state(
        cmd,
        name,
        "running",
        stdout=None,
        stderr=None,
        stdin=None,
        with_communicate=with_communicate,
        path=path,
        use_vt=use_vt,
    )
def stop(name, kill=False, path=None, use_vt=None):
    _ensure_exists(name, path=path)
    orig_state = state(name, path=path)
    if orig_state == "frozen" and not kill:
        unfreeze(name, path=path)
    cmd = "lxc-stop"
    if kill:
        cmd += " -k"
    ret = _change_state(cmd, name, "stopped", use_vt=use_vt, path=path)
    ret["state"]["old"] = orig_state
    return ret
def freeze(name, **kwargs):
    use_vt = kwargs.get("use_vt", None)
    path = kwargs.get("path", None)
    _ensure_exists(name, path=path)
    orig_state = state(name, path=path)
    start_ = kwargs.get("start", False)
    if orig_state == "stopped":
        if not start_:
            raise CommandExecutionError("Container '{}' is stopped".format(name))
        start(name, path=path)
    cmd = "lxc-freeze"
    if path:
        cmd += " -P {}".format(pipes.quote(path))
    ret = _change_state(cmd, name, "frozen", use_vt=use_vt, path=path)
    if orig_state == "stopped" and start_:
        ret["state"]["old"] = orig_state
        ret["started"] = True
    ret["state"]["new"] = state(name, path=path)
    return ret
def unfreeze(name, path=None, use_vt=None):
    _ensure_exists(name, path=path)
    if state(name, path=path) == "stopped":
        raise CommandExecutionError("Container '{}' is stopped".format(name))
    cmd = "lxc-unfreeze"
    if path:
        cmd += " -P {}".format(pipes.quote(path))
    return _change_state(cmd, name, "running", path=path, use_vt=use_vt)
def destroy(name, stop=False, path=None):
    _ensure_exists(name, path=path)
    if not stop and state(name, path=path) != "stopped":
        raise CommandExecutionError("Container '{}' is not stopped".format(name))
    return _change_state("lxc-destroy", name, None, path=path)
remove = salt.utils.functools.alias_function(destroy, "remove")
def exists(name, path=None):
    _exists = name in ls_(path=path)
    if not _exists:
        _exists = name in ls_(cache=False, path=path)
    return _exists
def state(name, path=None):
    cachekey = "lxc.state.{}{}".format(name, path)
    try:
        return __context__[cachekey]
    except KeyError:
        if not exists(name, path=path):
            __context__[cachekey] = None
        else:
            cmd = "lxc-info"
            if path:
                cmd += " -P {}".format(pipes.quote(path))
            cmd += " -n {}".format(name)
            ret = __salt__["cmd.run_all"](cmd, python_shell=False)
            if ret["retcode"] != 0:
                _clear_context()
                raise CommandExecutionError(
                    "Unable to get state of container '{}'".format(name)
                )
            c_infos = ret["stdout"].splitlines()
            c_state = None
            for c_info in c_infos:
                stat = c_info.split(":")
                if stat[0].lower() == "state":
                    c_state = stat[1].strip().lower()
                    break
            __context__[cachekey] = c_state
    return __context__[cachekey]
def get_parameter(name, parameter, path=None):
    _ensure_exists(name, path=path)
    cmd = "lxc-cgroup"
    if path:
        cmd += " -P {}".format(pipes.quote(path))
    cmd += " -n {} {}".format(name, parameter)
    ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    if ret["retcode"] != 0:
        raise CommandExecutionError(
            "Unable to retrieve value for '{}'".format(parameter)
        )
    return ret["stdout"].strip()
def set_parameter(name, parameter, value, path=None):
    if not exists(name, path=path):
        return None
    cmd = "lxc-cgroup"
    if path:
        cmd += " -P {}".format(pipes.quote(path))
    cmd += " -n {} {} {}".format(name, parameter, value)
    ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    if ret["retcode"] != 0:
        return False
    else:
        return True
def info(name, path=None):
    cachekey = "lxc.info.{}{}".format(name, path)
    try:
        return __context__[cachekey]
    except KeyError:
        _ensure_exists(name, path=path)
        cpath = get_root_path(path)
        try:
            conf_file = os.path.join(cpath, name, "config")
        except AttributeError:
            conf_file = os.path.join(cpath, str(name), "config")
        if not os.path.isfile(conf_file):
            raise CommandExecutionError(
                "LXC config file {} does not exist".format(conf_file)
            )
        ret = {}
        config = []
        with salt.utils.files.fopen(conf_file) as fp_:
            for line in fp_:
                line = salt.utils.stringutils.to_unicode(line)
                comps = [x.strip() for x in line.split("#", 1)[0].strip().split("=", 1)]
                if len(comps) == 2:
                    config.append(tuple(comps))
        ifaces = []
        current = {}
        for key, val in config:
            if key == "lxc.network.type":
                current = {"type": val}
                ifaces.append(current)
            elif not current:
                continue
            elif key.startswith("lxc.network."):
                current[key.replace("lxc.network.", "", 1)] = val
        if ifaces:
            ret["nics"] = ifaces
        ret["rootfs"] = next((x[1] for x in config if x[0] == "lxc.rootfs"), None)
        ret["state"] = state(name, path=path)
        ret["ips"] = []
        ret["public_ips"] = []
        ret["private_ips"] = []
        ret["public_ipv4_ips"] = []
        ret["public_ipv6_ips"] = []
        ret["private_ipv4_ips"] = []
        ret["private_ipv6_ips"] = []
        ret["ipv4_ips"] = []
        ret["ipv6_ips"] = []
        ret["size"] = None
        ret["config"] = conf_file
        if ret["state"] == "running":
            try:
                limit = int(get_parameter(name, "memory.limit_in_bytes"))
            except (CommandExecutionError, TypeError, ValueError):
                limit = 0
            try:
                usage = int(get_parameter(name, "memory.usage_in_bytes"))
            except (CommandExecutionError, TypeError, ValueError):
                usage = 0
            free = limit - usage
            ret["memory_limit"] = limit
            ret["memory_free"] = free
            size = run_stdout(name, "df /", path=path, python_shell=False)
            ret["size"] = size.splitlines()[-1].split()[1]
            ip_cmd = run_all(name, "ip link show", path=path, python_shell=False)
            if ip_cmd["retcode"] == 0:
                ip_data = ip_cmd["stdout"]
                ip_cmd = run_all(name, "ip addr show", path=path, python_shell=False)
                ip_data += "\n" + ip_cmd["stdout"]
                ip_data = salt.utils.network._interfaces_ip(ip_data)
            else:
                ip_cmd = run_all(name, "ifconfig", path=path, python_shell=False)
                if ip_cmd["retcode"] == 0:
                    ip_data = salt.utils.network._interfaces_ifconfig(ip_cmd["stdout"])
                else:
                    log.warning("Unable to run ip or ifconfig in container '%s'", name)
                    ip_data = {}
            ret["ipv4_ips"] = salt.utils.network.ip_addrs(
                include_loopback=True, interface_data=ip_data
            )
            ret["ipv6_ips"] = salt.utils.network.ip_addrs6(
                include_loopback=True, interface_data=ip_data
            )
            ret["ips"] = ret["ipv4_ips"] + ret["ipv6_ips"]
            for address in ret["ipv4_ips"]:
                if address == "127.0.0.1":
                    ret["private_ips"].append(address)
                    ret["private_ipv4_ips"].append(address)
                elif salt.utils.cloud.is_public_ip(address):
                    ret["public_ips"].append(address)
                    ret["public_ipv4_ips"].append(address)
                else:
                    ret["private_ips"].append(address)
                    ret["private_ipv4_ips"].append(address)
            for address in ret["ipv6_ips"]:
                if address == "::1" or address.startswith("fe80"):
                    ret["private_ips"].append(address)
                    ret["private_ipv6_ips"].append(address)
                else:
                    ret["public_ips"].append(address)
                    ret["public_ipv6_ips"].append(address)
        for key in [x for x in ret if x == "ips" or x.endswith("ips")]:
            ret[key].sort(key=_ip_sort)
        __context__[cachekey] = ret
    return __context__[cachekey]
def set_password(name, users, password, encrypted=True, path=None):
    def _bad_user_input():
        raise SaltInvocationError("Invalid input for 'users' parameter")
    if not isinstance(users, list):
        try:
            users = users.split(",")
        except AttributeError:
            _bad_user_input()
    if not users:
        _bad_user_input()
    failed_users = []
    for user in users:
        result = retcode(
            name,
            "chpasswd{}".format(" -e" if encrypted else ""),
            stdin=":".join((user, password)),
            python_shell=False,
            path=path,
            chroot_fallback=True,
            output_loglevel="quiet",
        )
        if result != 0:
            failed_users.append(user)
    if failed_users:
        raise CommandExecutionError(
            "Password change failed for the following user(s): {}".format(
                ", ".join(failed_users)
            )
        )
    return True
set_pass = salt.utils.functools.alias_function(set_password, "set_pass")
def update_lxc_conf(name, lxc_conf, lxc_conf_unset, path=None):
    _ensure_exists(name, path=path)
    cpath = get_root_path(path)
    lxc_conf_p = os.path.join(cpath, name, "config")
    if not os.path.exists(lxc_conf_p):
        raise SaltInvocationError(
            "Configuration file {} does not exist".format(lxc_conf_p)
        )
    changes = {"edited": [], "added": [], "removed": []}
    ret = {"changes": changes, "result": True, "comment": ""}
    with salt.utils.files.fopen(lxc_conf_p, "r") as fic:
        filtered_lxc_conf = []
        for row in lxc_conf:
            if not row:
                continue
            for conf in row:
                filtered_lxc_conf.append((conf.strip(), row[conf].strip()))
        ret["comment"] = "lxc.conf is up to date"
        lines = []
        orig_config = salt.utils.stringutils.to_unicode(fic.read())
        for line in orig_config.splitlines():
            if line.startswith("#") or not line.strip():
                lines.append([line, ""])
            else:
                line = line.split("=")
                index = line.pop(0)
                val = (index.strip(), "=".join(line).strip())
                if val not in lines:
                    lines.append(val)
        for key, item in filtered_lxc_conf:
            matched = False
            for idx, line in enumerate(lines[:]):
                if line[0] == key:
                    matched = True
                    lines[idx] = (key, item)
                    if "=".join(line[1:]).strip() != item.strip():
                        changes["edited"].append(({line[0]: line[1:]}, {key: item}))
                        break
            if not matched:
                if (key, item) not in lines:
                    lines.append((key, item))
                changes["added"].append({key: item})
        dest_lxc_conf = []
        if lxc_conf_unset:
            for line in lines:
                for opt in lxc_conf_unset:
                    if not line[0].startswith(opt) and line not in dest_lxc_conf:
                        dest_lxc_conf.append(line)
                    else:
                        changes["removed"].append(opt)
        else:
            dest_lxc_conf = lines
        conf = ""
        for key, val in dest_lxc_conf:
            if not val:
                conf += "{}\n".format(key)
            else:
                conf += "{} = {}\n".format(key.strip(), val.strip())
        conf_changed = conf != orig_config
        chrono = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        if conf_changed:
            with salt.utils.files.fopen(
                "{}.{}".format(lxc_conf_p, chrono), "w"
            ) as wfic:
                wfic.write(salt.utils.stringutils.to_str(conf))
            with salt.utils.files.fopen(lxc_conf_p, "w") as wfic:
                wfic.write(salt.utils.stringutils.to_str(conf))
            ret["comment"] = "Updated"
            ret["result"] = True
    if not any(changes[x] for x in changes):
        ret["changes"] = {}
    return ret
def set_dns(name, dnsservers=None, searchdomains=None, path=None):
    if dnsservers is None:
        dnsservers = ["8.8.8.8", "4.4.4.4"]
    elif not isinstance(dnsservers, list):
        try:
            dnsservers = dnsservers.split(",")
        except AttributeError:
            raise SaltInvocationError("Invalid input for 'dnsservers' parameter")
    if searchdomains is None:
        searchdomains = []
    elif not isinstance(searchdomains, list):
        try:
            searchdomains = searchdomains.split(",")
        except AttributeError:
            raise SaltInvocationError("Invalid input for 'searchdomains' parameter")
    dns = ["nameserver {}".format(x) for x in dnsservers]
    dns.extend(["search {}".format(x) for x in searchdomains])
    dns = "\n".join(dns) + "\n"
    rstr = __salt__["test.random_hash"]()
    script = "/sbin/{}_dns.sh".format(rstr)
    DNS_SCRIPT = "\n".join(
        [
            "#!/usr/bin/env bash",
            "if [ -h /etc/resolv.conf ];then",
            ' if [ "x$(readlink /etc/resolv.conf)"'
            ' = "x../run/resolvconf/resolv.conf" ];then',
            "  if [ ! -d /run/resolvconf/ ];then",
            "   mkdir -p /run/resolvconf",
            "  fi",
            "  cat &gt; /etc/resolvconf/resolv.conf.d/head &lt;&lt;EOF",
            dns,
            "EOF",
            "",
            " fi",
            "fi",
            "cat &gt; /etc/resolv.conf &lt;&lt;EOF",
            dns,
            "EOF",
            "",
        ]
    )
    result = run_all(
        name, "tee {}".format(script), path=path, stdin=DNS_SCRIPT, python_shell=True
    )
    if result["retcode"] == 0:
        result = run_all(
            name,
            'sh -c "chmod +x {0};{0}"'.format(script),
            path=path,
            python_shell=True,
        )
    run_all(
        name,
        'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
        path=path,
        python_shell=True,
    )
    if result["retcode"] != 0:
        error = "Unable to write to /etc/resolv.conf in container '{}'".format(name)
        if result["stderr"]:
            error += ": {}".format(result["stderr"])
        raise CommandExecutionError(error)
    return True
def running_systemd(name, cache=True, path=None):
    k = "lxc.systemd.test.{}{}".format(name, path)
    ret = __context__.get(k, None)
    if ret is None or not cache:
        rstr = __salt__["test.random_hash"]()
        script = "/sbin/{}_testsystemd.sh".format(rstr)
        _script = textwrap.dedent(
        )
        result = run_all(
            name, "tee {}".format(script), path=path, stdin=_script, python_shell=True
        )
        if result["retcode"] == 0:
            result = run_all(
                name,
                'sh -c "chmod +x {0};{0}"'.format(script),
                path=path,
                python_shell=True,
            )
        else:
            raise CommandExecutionError(
                "lxc {} failed to copy initd tester".format(name)
            )
        run_all(
            name,
            'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
            path=path,
            ignore_retcode=True,
            python_shell=True,
        )
        if result["retcode"] != 0:
            error = (
                "Unable to determine if the container '{}'"
                " was running systemd, assmuming it is not."
                "".format(name)
            )
            if result["stderr"]:
                error += ": {}".format(result["stderr"])
        if result["retcode"] in (0, 2):
            __context__[k] = ret = not result["retcode"]
    return ret
def systemd_running_state(name, path=None):
    try:
        ret = run_all(
            name, "systemctl is-system-running", path=path, ignore_retcode=True
        )["stdout"]
    except CommandExecutionError:
        ret = ""
    return ret
def test_sd_started_state(name, path=None):
    qstate = systemd_running_state(name, path=path)
    if qstate in ("initializing", "starting"):
        return False
    elif qstate == "":
        return None
    else:
        return True
def test_bare_started_state(name, path=None):
    try:
        ret = run_all(name, "ls", path=path, ignore_retcode=True)["retcode"] == 0
    except (CommandExecutionError,):
        ret = None
    return ret
def wait_started(name, path=None, timeout=300):
    if not exists(name, path=path):
        raise CommandExecutionError("Container {} does does exists".format(name))
    if not state(name, path=path) == "running":
        raise CommandExecutionError("Container {} is not running".format(name))
    ret = False
    if running_systemd(name, path=path):
        test_started = test_sd_started_state
        logger = log.error
    else:
        test_started = test_bare_started_state
        logger = log.debug
    now = time.time()
    expire = now + timeout
    now = time.time()
    started = test_started(name, path=path)
    while time.time() &lt; expire and not started:
        time.sleep(0.3)
        started = test_started(name, path=path)
    if started is None:
        logger(
            "Assuming %s is started, although we failed to detect that"
            " is fully started correctly",
            name,
        )
        ret = True
    else:
        ret = started
    return ret
def _needs_install(name, path=None):
    ret = 0
    has_minion = retcode(name, "which salt-minion", path=path, ignore_retcode=True)
    if has_minion:
        processes = run_stdout(name, "ps aux", path=path)
        if "salt-minion" not in processes:
            ret = 1
        else:
            retcode(name, "salt-call --local service.stop salt-minion")
    else:
        ret = 1
    return ret
def bootstrap(
    name,
    config=None,
    approve_key=True,
    install=True,
    pub_key=None,
    priv_key=None,
    bootstrap_url=None,
    force_install=False,
    unconditional_install=False,
    path=None,
    bootstrap_delay=None,
    bootstrap_args=None,
    bootstrap_shell=None,
):
    wait_started(name, path=path)
    if bootstrap_delay is not None:
        try:
            log.info("LXC %s: bootstrap_delay: %s", name, bootstrap_delay)
            time.sleep(bootstrap_delay)
        except TypeError:
            time.sleep(5)
    c_info = info(name, path=path)
    if not c_info:
        return None
    if bootstrap_args:
        if "{0}" not in bootstrap_args:
            bootstrap_args += " -c {0}"
    else:
        bootstrap_args = "-c {0}"
    if not bootstrap_shell:
        bootstrap_shell = "sh"
    orig_state = _ensure_running(name, path=path)
    if not orig_state:
        return orig_state
    if not force_install:
        needs_install = _needs_install(name, path=path)
    else:
        needs_install = True
    seeded = (
        retcode(
            name,
            "test -e '{}'".format(SEED_MARKER),
            path=path,
            chroot_fallback=True,
            ignore_retcode=True,
        )
        == 0
    )
    tmp = tempfile.mkdtemp()
    if seeded and not unconditional_install:
        ret = True
    else:
        ret = False
        cfg_files = __salt__["seed.mkconfig"](
            config,
            tmp=tmp,
            id_=name,
            approve_key=approve_key,
            pub_key=pub_key,
            priv_key=priv_key,
        )
        if needs_install or force_install or unconditional_install:
            if install:
                rstr = __salt__["test.random_hash"]()
                configdir = "/var/tmp/.c_{}".format(rstr)
                cmd = "install -m 0700 -d {}".format(configdir)
                if run_all(name, cmd, path=path, python_shell=False)["retcode"] != 0:
                    log.error("tmpdir %s creation failed %s", configdir, cmd)
                    return False
                bs_ = __salt__["config.gather_bootstrap_script"](
                    bootstrap=bootstrap_url
                )
                script = "/sbin/{}_bootstrap.sh".format(rstr)
                copy_to(name, bs_, script, path=path)
                result = run_all(
                    name,
                    'sh -c "chmod +x {}"'.format(script),
                    path=path,
                    python_shell=True,
                )
                copy_to(
                    name,
                    cfg_files["config"],
                    os.path.join(configdir, "minion"),
                    path=path,
                )
                copy_to(
                    name,
                    cfg_files["privkey"],
                    os.path.join(configdir, "minion.pem"),
                    path=path,
                )
                copy_to(
                    name,
                    cfg_files["pubkey"],
                    os.path.join(configdir, "minion.pub"),
                    path=path,
                )
                bootstrap_args = bootstrap_args.format(configdir)
                cmd = "{0} {2} {1}".format(
                    bootstrap_shell, bootstrap_args.replace("'", "''"), script
                )
                log.info("Running %s in LXC container '%s'", cmd, name)
                ret = (
                    retcode(name, cmd, output_loglevel="info", path=path, use_vt=True)
                    == 0
                )
                run_all(
                    name,
                    'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
                    path=path,
                    ignore_retcode=True,
                    python_shell=True,
                )
            else:
                ret = False
        else:
            minion_config = salt.config.minion_config(cfg_files["config"])
            pki_dir = minion_config["pki_dir"]
            copy_to(name, cfg_files["config"], "/etc/salt/minion", path=path)
            copy_to(
                name,
                cfg_files["privkey"],
                os.path.join(pki_dir, "minion.pem"),
                path=path,
            )
            copy_to(
                name,
                cfg_files["pubkey"],
                os.path.join(pki_dir, "minion.pub"),
                path=path,
            )
            run(
                name,
                "salt-call --local service.enable salt-minion",
                path=path,
                python_shell=False,
            )
            ret = True
        shutil.rmtree(tmp)
        if orig_state == "stopped":
            stop(name, path=path)
        elif orig_state == "frozen":
            freeze(name, path=path)
        if ret:
            run(name, "touch '{}'".format(SEED_MARKER), path=path, python_shell=False)
    return ret
def attachable(name, path=None):
    cachekey = "lxc.attachable{}{}".format(name, path)
    try:
        return __context__[cachekey]
    except KeyError:
        _ensure_exists(name, path=path)
        log.debug("Checking if LXC container %s is attachable", name)
        cmd = "lxc-attach"
        if path:
            cmd += " -P {}".format(pipes.quote(path))
        cmd += " --clear-env -n {} -- /usr/bin/env".format(name)
        result = (
            __salt__["cmd.retcode"](
                cmd, python_shell=False, output_loglevel="quiet", ignore_retcode=True
<a name="0"></a>            )
            == 0
        )
        __context__[cachekey] <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= result
    return __context__[cachekey]
def _run(
    name,
    cmd,
    output=None,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=</b></font>False,
    path=None,
    ignore_retcode=False,
    chroot_fallback=None,
    keep_env="http_proxy,https_proxy,no_proxy",
):
    orig_state = state(name, path=path)
    try:
        if attachable(name, path=path):
            ret = __salt__["container_resource.run"](
                name,
                cmd,
                path=path,
                container_type=__virtualname__,
                exec_driver=EXEC_DRIVER,
                output=output,
                no_start=no_start,
                stdin=stdin,
                python_shell=python_shell,
                output_loglevel=output_loglevel,
                ignore_retcode=ignore_retcode,
                use_vt=use_vt,
                keep_env=keep_env,
            )
        else:
            if not chroot_fallback:
                raise CommandExecutionError("{} is not attachable.".format(name))
            rootfs = info(name, path=path).get("rootfs")
            __context__["cmd.run_chroot.func"] = __salt__["cmd.run"]
            ret = __salt__["cmd.run_chroot"](
                rootfs,
                cmd,
                stdin=stdin,
                python_shell=python_shell,
                output_loglevel=output_loglevel,
                ignore_retcode=ignore_retcode,
            )
    finally:
        new_state = state(name, path=path)
        if preserve_state:
            if orig_state == "stopped" and new_state != "stopped":
                stop(name, path=path)
            elif orig_state == "frozen" and new_state != "frozen":
                freeze(name, start=True, path=path)
    if output in (None, "all"):
        return ret
    else:
        return ret[output]
def run(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    path=None,
    ignore_retcode=False,
    chroot_fallback=False,
    keep_env="http_proxy,https_proxy,no_proxy",
):
    return _run(
        name,
        cmd,
        path=path,
        output=None,
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        chroot_fallback=chroot_fallback,
        keep_env=keep_env,
    )
def run_stdout(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    path=None,
    ignore_retcode=False,
    chroot_fallback=False,
    keep_env="http_proxy,https_proxy,no_proxy",
):
    return _run(
        name,
        cmd,
        path=path,
        output="stdout",
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        chroot_fallback=chroot_fallback,
        keep_env=keep_env,
    )
def run_stderr(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    path=None,
    ignore_retcode=False,
    chroot_fallback=False,
    keep_env="http_proxy,https_proxy,no_proxy",
):
    return _run(
        name,
        cmd,
        path=path,
        output="stderr",
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        chroot_fallback=chroot_fallback,
        keep_env=keep_env,
    )
def retcode(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    path=None,
    ignore_retcode=False,
    chroot_fallback=False,
    keep_env="http_proxy,https_proxy,no_proxy",
):
    return _run(
        name,
        cmd,
        output="retcode",
        path=path,
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        chroot_fallback=chroot_fallback,
        keep_env=keep_env,
    )
def run_all(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    path=None,
    ignore_retcode=False,
    chroot_fallback=False,
    keep_env="http_proxy,https_proxy,no_proxy",
):
    return _run(
        name,
        cmd,
        output="all",
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        path=path,
        ignore_retcode=ignore_retcode,
        chroot_fallback=chroot_fallback,
        keep_env=keep_env,
    )
def _get_md5(name, path):
    output = run_stdout(
        name, 'md5sum "{}"'.format(path), chroot_fallback=True, ignore_retcode=True
    )
    try:
        return output.split()[0]
    except IndexError:
        return None
def copy_to(name, source, dest, overwrite=False, makedirs=False, path=None):
    _ensure_running(name, no_start=True, path=path)
    return __salt__["container_resource.copy_to"](
        name,
        source,
        dest,
        container_type=__virtualname__,
        path=path,
        exec_driver=EXEC_DRIVER,
        overwrite=overwrite,
        makedirs=makedirs,
    )
cp = salt.utils.functools.alias_function(copy_to, "cp")
def read_conf(conf_file, out_format="simple"):
    ret_commented = []
    ret_simple = {}
    with salt.utils.files.fopen(conf_file, "r") as fp_:
        for line in salt.utils.data.decode(fp_.readlines()):
            if "=" not in line:
                ret_commented.append(line)
                continue
            comps = line.split("=")
            value = "=".join(comps[1:]).strip()
            comment = None
            if value.strip().startswith("#"):
                vcomps = value.strip().split("#")
                value = vcomps[1].strip()
                comment = "#".join(vcomps[1:]).strip()
                ret_commented.append(
                    {comps[0].strip(): {"value": value, "comment": comment}}
                )
            else:
                ret_commented.append({comps[0].strip(): value})
                ret_simple[comps[0].strip()] = value
    if out_format == "simple":
        return ret_simple
    return ret_commented
def write_conf(conf_file, conf):
    if not isinstance(conf, list):
        raise SaltInvocationError("Configuration must be passed as a list")
    content = ""
    for line in conf:
        if isinstance(line, (str, (str,))):
            content += line
        elif isinstance(line, dict):
            for key in list(line.keys()):
                out_line = None
                if isinstance(
                    line[key],
                    (str, (str,), (int,), float),
                ):
                    out_line = " = ".join((key, "{}".format(line[key])))
                elif isinstance(line[key], dict):
                    out_line = " = ".join((key, line[key]["value"]))
                    if "comment" in line[key]:
                        out_line = " # ".join((out_line, line[key]["comment"]))
                if out_line:
                    content += out_line
                    content += "\n"
    with salt.utils.files.fopen(conf_file, "w") as fp_:
        fp_.write(salt.utils.stringutils.to_str(content))
    return {}
def edit_conf(
    conf_file, out_format="simple", read_only=False, lxc_config=None, **kwargs
):
    data = []
    try:
        conf = read_conf(conf_file, out_format=out_format)
    except Exception:  # pylint: disable=broad-except
        conf = []
    if not lxc_config:
        lxc_config = []
    lxc_config = copy.deepcopy(lxc_config)
    net_config = []
    for lxc_kws in lxc_config + [kwargs]:
        net_params = {}
        for kwarg in [a for a in lxc_kws]:
            if kwarg.startswith("__"):
                continue
            if kwarg.startswith("lxc.network."):
                net_params[kwarg] = lxc_kws[kwarg]
                lxc_kws.pop(kwarg, None)
        if net_params:
            net_config.append(net_params)
    nic_opts = salt.utils.odict.OrderedDict()
    for params in net_config:
        dev = params.get("lxc.network.name", DEFAULT_NIC)
        dev_opts = nic_opts.setdefault(dev, salt.utils.odict.OrderedDict())
        for param in params:
            opt = param.replace("lxc.network.", "")
            opt = {"hwaddr": "mac"}.get(opt, opt)
            dev_opts[opt] = params[param]
    net_changes = []
    if nic_opts:
        net_changes = _config_list(
            conf,
            only_net=True,
            **{"network_profile": DEFAULT_NIC, "nic_opts": nic_opts}
        )
        if net_changes:
            lxc_config.extend(net_changes)
    for line in conf:
        if not isinstance(line, dict):
            data.append(line)
            continue
        else:
            for key in list(line.keys()):
                val = line[key]
                if net_changes and key.startswith("lxc.network."):
                    continue
                found = False
                for kw in lxc_config:
                    if key in kw:
                        found = True
                        data.append({key: kw[key]})
                        del kw[key]
                if not found:
                    data.append({key: val})
    for lxc_kws in lxc_config:
        for kwarg in lxc_kws:
            data.append({kwarg: lxc_kws[kwarg]})
    if read_only:
        return data
    write_conf(conf_file, data)
    return read_conf(conf_file, out_format)
def reboot(name, path=None):
    ret = {"result": True, "changes": {}, "comment": "{} rebooted".format(name)}
    does_exist = exists(name, path=path)
    if does_exist and (state(name, path=path) == "running"):
        try:
            stop(name, path=path)
        except (SaltInvocationError, CommandExecutionError) as exc:
            ret["comment"] = "Unable to stop container: {}".format(exc)
            ret["result"] = False
            return ret
    if does_exist and (state(name, path=path) != "running"):
        try:
            start(name, path=path)
        except (SaltInvocationError, CommandExecutionError) as exc:
            ret["comment"] = "Unable to stop container: {}".format(exc)
            ret["result"] = False
            return ret
    ret["changes"][name] = "rebooted"
    return ret
def reconfigure(
    name,
    cpu=None,
    cpuset=None,
    cpushare=None,
    memory=None,
    profile=None,
    network_profile=None,
    nic_opts=None,
    bridge=None,
    gateway=None,
    autostart=None,
    utsname=None,
    rootfs=None,
    path=None,
    **kwargs
):
    changes = {}
    cpath = get_root_path(path)
    path = os.path.join(cpath, name, "config")
    ret = {
        "name": name,
        "comment": "config for {} up to date".format(name),
        "result": True,
        "changes": changes,
    }
    profile = get_container_profile(copy.deepcopy(profile))
    kw_overrides = copy.deepcopy(kwargs)
    def select(key, default=None):
        kw_overrides_match = kw_overrides.pop(key, _marker)
        profile_match = profile.pop(key, default)
        if kw_overrides_match is _marker:
            return profile_match
        return kw_overrides_match
    if nic_opts is not None and not network_profile:
        network_profile = DEFAULT_NIC
    if autostart is not None:
        autostart = select("autostart", autostart)
    else:
        autostart = "keep"
    if not utsname:
        utsname = select("utsname", utsname)
    if os.path.exists(path):
        old_chunks = read_conf(path, out_format="commented")
        make_kw = salt.utils.odict.OrderedDict(
            [
                ("utsname", utsname),
                ("rootfs", rootfs),
                ("autostart", autostart),
                ("cpu", cpu),
                ("gateway", gateway),
                ("cpuset", cpuset),
                ("cpushare", cpushare),
                ("network_profile", network_profile),
                ("nic_opts", nic_opts),
                ("bridge", bridge),
            ]
        )
        if memory:
            make_kw["memory"] = memory
        kw = salt.utils.odict.OrderedDict()
        for key, val in make_kw.items():
            if val is not None:
                kw[key] = val
        new_cfg = _config_list(conf_tuples=old_chunks, **kw)
        if new_cfg:
            edit_conf(path, out_format="commented", lxc_config=new_cfg)
        chunks = read_conf(path, out_format="commented")
        if old_chunks != chunks:
            ret["comment"] = "{} lxc config updated".format(name)
            if state(name, path=path) == "running":
                cret = reboot(name, path=path)
                ret["result"] = cret["result"]
    return ret
def apply_network_profile(name, network_profile, nic_opts=None, path=None):
    cpath = get_root_path(path)
    cfgpath = os.path.join(cpath, name, "config")
    before = []
    with salt.utils.files.fopen(cfgpath, "r") as fp_:
        for line in fp_:
            before.append(line)
    lxcconfig = _LXCConfig(name=name, path=path)
    old_net = lxcconfig._filter_data("lxc.network")
    network_params = {}
    for param in _network_conf(
        conf_tuples=old_net, network_profile=network_profile, nic_opts=nic_opts
    ):
        network_params.update(param)
    if network_params:
        edit_conf(cfgpath, out_format="commented", **network_params)
    after = []
    with salt.utils.files.fopen(cfgpath, "r") as fp_:
        for line in fp_:
            after.append(line)
    diff = ""
    for line in difflib.unified_diff(before, after, fromfile="before", tofile="after"):
        diff += line
    return diff
def get_pid(name, path=None):
    if name not in list_(limit="running", path=path):
        raise CommandExecutionError(
            "Container {} is not running, can't determine PID".format(name)
        )
    info = __salt__["cmd.run"]("lxc-info -n {}".format(name)).split("\n")
    pid = [
        line.split(":")[1].strip()
        for line in info
        if re.match(r"\s*PID", line) is not None
    ][0]
    return pid
def add_veth(name, interface_name, bridge=None, path=None):
    pid = get_pid(name, path=path)
    while True:
        random_veth = "veth" + "".join(
            random.choice(string.ascii_uppercase + string.digits) for _ in range(6)
        )
        if random_veth not in __salt__["network.interfaces"]().keys():
            break
    if not __salt__["file.directory_exists"]("/var/run/"):
        raise CommandExecutionError(
            "Directory /var/run required for lxc.add_veth doesn't exists"
        )
    if not __salt__["file.file_exists"]("/proc/{}/ns/net".format(pid)):
        raise CommandExecutionError(
            "Proc file for container {} network namespace doesn't exists".format(name)
        )
    if not __salt__["file.directory_exists"]("/var/run/netns"):
        __salt__["file.mkdir"]("/var/run/netns")
    if __salt__["file.is_link"]("/var/run/netns/{}".format(name)):
        __salt__["file.remove"]("/var/run/netns/{}".format(name))
    __salt__["file.symlink"](
        "/proc/{}/ns/net".format(pid), "/var/run/netns/{}".format(name)
    )
    interface_exists = 0 == __salt__["cmd.retcode"](
        "ip netns exec {netns} ip address list {interface}".format(
            netns=name, interface=interface_name
        )
    )
    if interface_exists:
        raise CommandExecutionError(
            "Interface {interface} already exists in {container}".format(
                interface=interface_name, container=name
            )
        )
    if (
        __salt__["cmd.retcode"](
            "ip link add name {veth} type veth peer name {veth}_c".format(
                veth=random_veth
            )
        )
        != 0
    ):
        raise CommandExecutionError(
            "Error while creating the veth pair {}".format(random_veth)
        )
    if __salt__["cmd.retcode"]("ip link set dev {} up".format(random_veth)) != 0:
        raise CommandExecutionError(
            "Error while bringing up host-side veth {}".format(random_veth)
        )
    attached = 0 == __salt__["cmd.retcode"](
        "ip link set dev {veth}_c netns {container} name {interface_name}".format(
            veth=random_veth, container=name, interface_name=interface_name
        )
    )
    if not attached:
        raise CommandExecutionError(
            "Error while attaching the veth {veth} to container {container}".format(
                veth=random_veth, container=name
            )
        )
    __salt__["file.remove"]("/var/run/netns/{}".format(name))
    if bridge is not None:
        __salt__["bridge.addif"](bridge, random_veth)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ciscoconfparse_mod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
from salt.exceptions import SaltException
try:
    import ciscoconfparse
    HAS_CISCOCONFPARSE = True
except ImportError:
    HAS_CISCOCONFPARSE = False
__virtualname__ = "ciscoconfparse"
def __virtual__():
    if HAS_CISCOCONFPARSE:
        return HAS_CISCOCONFPARSE
    else:
        return (False, "Missing dependency ciscoconfparse")
def _get_ccp(config=None, config_path=None, saltenv="base"):
    if config_path:
        config = __salt__["cp.get_file_str"](config_path, saltenv=saltenv)
        if config is False:
            raise SaltException("{} is not available".format(config_path))
    if isinstance(config, str):
        config = config.splitlines()
    ccp = ciscoconfparse.CiscoConfParse(config)
    return ccp
def find_objects(config=None, config_path=None, regex=None, saltenv="base"):
    ccp = _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
    lines = ccp.find_objects(regex)
    return lines
def find_lines(config=None, config_path=None, regex=None, saltenv="base"):
    lines = find_objects(
        config=config, config_path=config_path, regex=regex, saltenv<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=saltenv
    )
    return [line.text for line in lines]
def find_objects_w_child(
    config=None,
    config_path=None,
    parent_regex=None,
    child_regex=None,
    ignore_ws=False,
    saltenv="base",
):
    ccp =</b></font> _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
    lines = ccp.find_objects_w_child(parent_regex, child_regex, ignore_ws=ignore_ws)
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return lines
def find_lines_w_child(
    config=None,
    config_path=None,
    parent_regex=None,
    child_regex=None,
    ignore_ws=False,
    saltenv="base",
):
    r"""
    Return a list of parent lines (as text)  matching the regular expression
    ``parent_regex`` that have children lines matching ``child_regex``.
    config
        The configuration sent as text.
        .. note::
            This argument is ignored when ``config_path`` is specified.
    config_path
        The absolute or remote path to the file with the configuration to be
        parsed. This argument supports the usual Salt filesystem URIs, e.g.,
        ``salt://``, ``https://``, ``ftp://``, ``s3://``, etc.
    parent_regex
        The regular expression to match the parent lines against.
    child_regex
        The regular expression to match the child lines against.
    ignore_ws: ``False``
        Whether to ignore the white spaces.
    saltenv: ``base``
        Salt fileserver environment from which to retrieve the file. This
        argument is ignored when ``config_path`` is not a ``salt://`` URL.
    CLI Example:
    .. code-block:: bash
        salt '*' ciscoconfparse.find_lines_w_child config_path=https://bit.ly/2mAdq7z parent_line='line con' child_line='stopbits'
        salt '*' ciscoconfparse.find_lines_w_child config_path=https://bit.ly/2uIRxau parent_regex='ge-(.*)' child_regex='unit \d+'
        config=</b></font>config,
        config_path=config_path,
        parent_regex=parent_regex,
        child_regex=child_regex,
        ignore_ws=ignore_ws,
        saltenv=saltenv,
    )
    return [line.text for line in lines]
def find_objects_wo_child(
    config=None,
    config_path=None,
    parent_regex=None,
    child_regex=None,
    ignore_ws=False,
    saltenv="base",
):
    ccp = _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
    lines = ccp.find_objects_wo_child(parent_regex, child_regex, ignore_ws=ignore_ws)
    return lines
def find_lines_wo_child(
    config=None,
    config_path=None,
    parent_regex=None,
    child_regex=None,
    ignore_ws=False,
    saltenv="base",
):
    lines = find_objects_wo_child(
        config=config,
        config_path=config_path,
        parent_regex=parent_regex,
        child_regex=child_regex,
        ignore_ws=ignore_ws,
        saltenv=saltenv,
    )
    return [line.text for line in lines]
def filter_lines(
    config=None, config_path=None, parent_regex=None, child_regex=None, saltenv="base"
):
    ret = []
    ccp = _get_ccp(config=config, config_path=config_path, saltenv=saltenv)
    parent_lines = ccp.find_objects(parent_regex)
    for parent_line in parent_lines:
        child_lines = parent_line.re_search_children(child_regex)
        if child_lines:
            for child_line in child_lines:
                ret.append(
                    {
                        "match": True,
                        "parent": parent_line.text,
                        "child": child_line.text,
                    }
                )
        else:
            ret.append({"match": False, "parent": parent_line.text, "child": None})
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
