<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for alphaporno.py &amp; zattoo.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for alphaporno.py &amp; zattoo.py
      </h3>
<h1 align="center">
        3.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>alphaporno.py (19.047619%)<th>zattoo.py (2.201835%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(36-43)<td><a href="#" name="0">(56-64)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>alphaporno.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 from .common import InfoExtractor
3 from ..utils import (
4     parse_iso8601,
5     parse_duration,
6     parse_filesize,
7     int_or_none,
8 )
9 class AlphaPornoIE(InfoExtractor):
10     _VALID_URL = r'https?://(?:www\.)?alphaporno\.com/videos/(?P&lt;id&gt;[^/]+)'
11     _TEST = {
12         'url': 'http://www.alphaporno.com/videos/sensual-striptease-porn-with-samantha-alexandra/',
13         'md5': 'feb6d3bba8848cd54467a87ad34bd38e',
14         'info_dict': {
15             'id': '258807',
16             'display_id': 'sensual-striptease-porn-with-samantha-alexandra',
17             'ext': 'mp4',
18             'title': 'Sensual striptease porn with Samantha Alexandra',
19             'thumbnail': r're:https?://.*\.jpg$',
20             'timestamp': 1418694611,
21             'upload_date': '20141216',
22             'duration': 387,
23             'filesize_approx': 54120000,
24             'tbr': 1145,
25             'categories': list,
26             'age_limit': 18,
27         }
28     }
29 <a name="0"></a>    def _real_extract(self, url):
30         display_id = self._match_id(url)
31         webpage = self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._download_webpage(url, display_id)
32         video_id = self._search_regex(
33             r"video_id\s*:\s*'([^']+)'", webpage, 'video id', default=None)
34         video_url = self._search_regex(
35             r"video_url\s*:\s*'([^']+)'", webpage, 'video url')
36         ext = self._html_search_meta(</b></font>
37             'encodingFormat', webpage, 'ext', default='.mp4')[1:]
38         title = self._search_regex(
39             [r'&lt;meta content="([^"]+)" itemprop="description"&gt;',
40              r'class="title" itemprop="name"&gt;([^&lt;]+)&lt;'],
41             webpage, 'title')
42         thumbnail = self._html_search_meta('thumbnail', webpage, 'thumbnail')
43         timestamp = parse_iso8601(self._html_search_meta(
44             'uploadDate', webpage, 'upload date'))
45         duration = parse_duration(self._html_search_meta(
46             'duration', webpage, 'duration'))
47         filesize_approx = parse_filesize(self._html_search_meta(
48             'contentSize', webpage, 'file size'))
49         bitrate = int_or_none(self._html_search_meta(
50             'bitrate', webpage, 'bitrate'))
51         categories = self._html_search_meta(
52             'keywords', webpage, 'categories', default='').split(',')
53         age_limit = self._rta_search(webpage)
54         return {
55             'id': video_id,
56             'display_id': display_id,
57             'url': video_url,
58             'ext': ext,
59             'title': title,
60             'thumbnail': thumbnail,
61             'timestamp': timestamp,
62             'duration': duration,
63             'filesize_approx': filesize_approx,
64             'tbr': bitrate,
65             'categories': categories,
66             'age_limit': age_limit,
67         }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>zattoo.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import re
3 from uuid import uuid4
4 from .common import InfoExtractor
5 from ..compat import (
6     compat_HTTPError,
7     compat_str,
8 )
9 from ..utils import (
10     ExtractorError,
11     int_or_none,
12     try_get,
13     url_or_none,
14     urlencode_postdata,
15 )
16 class ZattooPlatformBaseIE(InfoExtractor):
17     _power_guide_hash = None
18     def _host_url(self):
19         return 'https://%s' % (self._API_HOST if hasattr(self, '_API_HOST') else self._HOST)
20     def _login(self):
21         username, password = self._get_login_info()
22         if not username or not password:
23             self.raise_login_required(
24                 'A valid %s account is needed to access this media.'
25                 % self._NETRC_MACHINE)
26         try:
27             data = self._download_json(
28                 '%s/zapi/v2/account/login' % self._host_url(), None, 'Logging in',
29                 data=urlencode_postdata({
30                     'login': username,
31                     'password': password,
32                     'remember': 'true',
33                 }), headers={
34                     'Referer': '%s/login' % self._host_url(),
35                     'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
36                 })
37         except ExtractorError as e:
38             if isinstance(e.cause, compat_HTTPError) and e.cause.code == 400:
39                 raise ExtractorError(
40                     'Unable to login: incorrect username and/or password',
41                     expected=True)
42             raise
43         self._power_guide_hash = data['session']['power_guide_hash']
44 <a name="0"></a>
45     def _real_initialize(self):
46         webpage = self._download_webpage(
47             self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._host_url(), None, 'Downloading app token')
48         app_token = self._html_search_regex(
49             r'appToken\s*=\s*(["\'])(?P&lt;token&gt;(?:(?!\1).)+?)\1',
50             webpage, 'app token', group='token')
51         app_version = self._html_search_regex(
52             r'&lt;!--\w+-(.+?)-', webpage, 'app version', default='2.8.2')
53         self._request_webpage(</b></font>
54             '%s/zapi/v2/session/hello' % self._host_url(), None,
55             'Opening session', data=urlencode_postdata({
56                 'client_app_token': app_token,
57                 'uuid': compat_str(uuid4()),
58                 'lang': 'en',
59                 'app_version': app_version,
60                 'format': 'json',
61             }))
62         self._login()
63     def _extract_cid(self, video_id, channel_name):
64         channel_groups = self._download_json(
65             '%s/zapi/v2/cached/channels/%s' % (self._host_url(),
66                                                self._power_guide_hash),
67             video_id, 'Downloading channel list',
68             query={'details': False})['channel_groups']
69         channel_list = []
70         for chgrp in channel_groups:
71             channel_list.extend(chgrp['channels'])
72         try:
73             return next(
74                 chan['cid'] for chan in channel_list
75                 if chan.get('cid') and (
76                     chan.get('display_alias') == channel_name
77                     or chan.get('cid') == channel_name))
78         except StopIteration:
79             raise ExtractorError('Could not extract channel id')
80     def _extract_cid_and_video_info(self, video_id):
81         data = self._download_json(
82             '%s/zapi/v2/cached/program/power_details/%s' % (
83                 self._host_url(), self._power_guide_hash),
84             video_id,
85             'Downloading video information',
86             query={
87                 'program_ids': video_id,
88                 'complete': True,
89             })
90         p = data['programs'][0]
91         cid = p['cid']
92         info_dict = {
93             'id': video_id,
94             'title': p.get('t') or p['et'],
95             'description': p.get('d'),
96             'thumbnail': p.get('i_url'),
97             'creator': p.get('channel_name'),
98             'episode': p.get('et'),
99             'episode_number': int_or_none(p.get('e_no')),
100             'season_number': int_or_none(p.get('s_no')),
101             'release_year': int_or_none(p.get('year')),
102             'categories': try_get(p, lambda x: x['c'], list),
103             'tags': try_get(p, lambda x: x['g'], list)
104         }
105         return cid, info_dict
106     def _extract_formats(self, cid, video_id, record_id=None, is_live=False):
107         postdata_common = {
108             'https_watch_urls': True,
109         }
110         if is_live:
111             postdata_common.update({'timeshift': 10800})
112             url = '%s/zapi/watch/live/%s' % (self._host_url(), cid)
113         elif record_id:
114             url = '%s/zapi/watch/recording/%s' % (self._host_url(), record_id)
115         else:
116             url = '%s/zapi/watch/recall/%s/%s' % (self._host_url(), cid, video_id)
117         formats = []
118         for stream_type in ('dash', 'hls', 'hls5', 'hds'):
119             postdata = postdata_common.copy()
120             postdata['stream_type'] = stream_type
121             data = self._download_json(
122                 url, video_id, 'Downloading %s formats' % stream_type.upper(),
123                 data=urlencode_postdata(postdata), fatal=False)
124             if not data:
125                 continue
126             watch_urls = try_get(
127                 data, lambda x: x['stream']['watch_urls'], list)
128             if not watch_urls:
129                 continue
130             for watch in watch_urls:
131                 if not isinstance(watch, dict):
132                     continue
133                 watch_url = url_or_none(watch.get('url'))
134                 if not watch_url:
135                     continue
136                 format_id_list = [stream_type]
137                 maxrate = watch.get('maxrate')
138                 if maxrate:
139                     format_id_list.append(compat_str(maxrate))
140                 audio_channel = watch.get('audio_channel')
141                 if audio_channel:
142                     format_id_list.append(compat_str(audio_channel))
143                 preference = 1 if audio_channel == 'A' else None
144                 format_id = '-'.join(format_id_list)
145                 if stream_type in ('dash', 'dash_widevine', 'dash_playready'):
146                     this_formats = self._extract_mpd_formats(
147                         watch_url, video_id, mpd_id=format_id, fatal=False)
148                 elif stream_type in ('hls', 'hls5', 'hls5_fairplay'):
149                     this_formats = self._extract_m3u8_formats(
150                         watch_url, video_id, 'mp4',
151                         entry_protocol='m3u8_native', m3u8_id=format_id,
152                         fatal=False)
153                 elif stream_type == 'hds':
154                     this_formats = self._extract_f4m_formats(
155                         watch_url, video_id, f4m_id=format_id, fatal=False)
156                 elif stream_type == 'smooth_playready':
157                     this_formats = self._extract_ism_formats(
158                         watch_url, video_id, ism_id=format_id, fatal=False)
159                 else:
160                     assert False
161                 for this_format in this_formats:
162                     this_format['preference'] = preference
163                 formats.extend(this_formats)
164         self._sort_formats(formats)
165         return formats
166     def _extract_video(self, channel_name, video_id, record_id=None, is_live=False):
167         if is_live:
168             cid = self._extract_cid(video_id, channel_name)
169             info_dict = {
170                 'id': channel_name,
171                 'title': self._live_title(channel_name),
172                 'is_live': True,
173             }
174         else:
175             cid, info_dict = self._extract_cid_and_video_info(video_id)
176         formats = self._extract_formats(
177             cid, video_id, record_id=record_id, is_live=is_live)
178         info_dict['formats'] = formats
179         return info_dict
180 class QuicklineBaseIE(ZattooPlatformBaseIE):
181     _NETRC_MACHINE = 'quickline'
182     _HOST = 'mobiltv.quickline.com'
183 class QuicklineIE(QuicklineBaseIE):
184     _VALID_URL = r'https?://(?:www\.)?%s/watch/(?P&lt;channel&gt;[^/]+)/(?P&lt;id&gt;[0-9]+)' % re.escape(QuicklineBaseIE._HOST)
185     _TEST = {
186         'url': 'https://mobiltv.quickline.com/watch/prosieben/130671867-maze-runner-die-auserwaehlten-in-der-brandwueste',
187         'only_matching': True,
188     }
189     def _real_extract(self, url):
190         channel_name, video_id = re.match(self._VALID_URL, url).groups()
191         return self._extract_video(channel_name, video_id)
192 class QuicklineLiveIE(QuicklineBaseIE):
193     _VALID_URL = r'https?://(?:www\.)?%s/watch/(?P&lt;id&gt;[^/]+)' % re.escape(QuicklineBaseIE._HOST)
194     _TEST = {
195         'url': 'https://mobiltv.quickline.com/watch/srf1',
196         'only_matching': True,
197     }
198     @classmethod
199     def suitable(cls, url):
200         return False if QuicklineIE.suitable(url) else super(QuicklineLiveIE, cls).suitable(url)
201     def _real_extract(self, url):
202         channel_name = video_id = self._match_id(url)
203         return self._extract_video(channel_name, video_id, is_live=True)
204 class ZattooBaseIE(ZattooPlatformBaseIE):
205     _NETRC_MACHINE = 'zattoo'
206     _HOST = 'zattoo.com'
207 def _make_valid_url(tmpl, host):
208     return tmpl % re.escape(host)
209 class ZattooIE(ZattooBaseIE):
210     _VALID_URL_TEMPLATE = r'https?://(?:www\.)?%s/watch/(?P&lt;channel&gt;[^/]+?)/(?P&lt;id&gt;[0-9]+)[^/]+(?:/(?P&lt;recid&gt;[0-9]+))?'
211     _VALID_URL = _make_valid_url(_VALID_URL_TEMPLATE, ZattooBaseIE._HOST)
212     _TESTS = [{
213         'url': 'https://zattoo.com/watch/prosieben/130671867-maze-runner-die-auserwaehlten-in-der-brandwueste',
214         'only_matching': True,
215     }, {
216         'url': 'https://zattoo.com/watch/srf_zwei/132905652-eishockey-spengler-cup/102791477/1512211800000/1514433500000/92000',
217         'only_matching': True,
218     }]
219     def _real_extract(self, url):
220         channel_name, video_id, record_id = re.match(self._VALID_URL, url).groups()
221         return self._extract_video(channel_name, video_id, record_id)
222 class ZattooLiveIE(ZattooBaseIE):
223     _VALID_URL = r'https?://(?:www\.)?zattoo\.com/watch/(?P&lt;id&gt;[^/]+)'
224     _TEST = {
225         'url': 'https://zattoo.com/watch/srf1',
226         'only_matching': True,
227     }
228     @classmethod
229     def suitable(cls, url):
230         return False if ZattooIE.suitable(url) else super(ZattooLiveIE, cls).suitable(url)
231     def _real_extract(self, url):
232         channel_name = video_id = self._match_id(url)
233         return self._extract_video(channel_name, video_id, is_live=True)
234 class NetPlusIE(ZattooIE):
235     _NETRC_MACHINE = 'netplus'
236     _HOST = 'netplus.tv'
237     _API_HOST = 'www.%s' % _HOST
238     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
239     _TESTS = [{
240         'url': 'https://www.netplus.tv/watch/abc/123-abc',
241         'only_matching': True,
242     }]
243 class MNetTVIE(ZattooIE):
244     _NETRC_MACHINE = 'mnettv'
245     _HOST = 'tvplus.m-net.de'
246     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
247     _TESTS = [{
248         'url': 'https://tvplus.m-net.de/watch/abc/123-abc',
249         'only_matching': True,
250     }]
251 class WalyTVIE(ZattooIE):
252     _NETRC_MACHINE = 'walytv'
253     _HOST = 'player.waly.tv'
254     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
255     _TESTS = [{
256         'url': 'https://player.waly.tv/watch/abc/123-abc',
257         'only_matching': True,
258     }]
259 class BBVTVIE(ZattooIE):
260     _NETRC_MACHINE = 'bbvtv'
261     _HOST = 'bbv-tv.net'
262     _API_HOST = 'www.%s' % _HOST
263     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
264     _TESTS = [{
265         'url': 'https://www.bbv-tv.net/watch/abc/123-abc',
266         'only_matching': True,
267     }]
268 class VTXTVIE(ZattooIE):
269     _NETRC_MACHINE = 'vtxtv'
270     _HOST = 'vtxtv.ch'
271     _API_HOST = 'www.%s' % _HOST
272     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
273     _TESTS = [{
274         'url': 'https://www.vtxtv.ch/watch/abc/123-abc',
275         'only_matching': True,
276     }]
277 class MyVisionTVIE(ZattooIE):
278     _NETRC_MACHINE = 'myvisiontv'
279     _HOST = 'myvisiontv.ch'
280     _API_HOST = 'www.%s' % _HOST
281     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
282     _TESTS = [{
283         'url': 'https://www.myvisiontv.ch/watch/abc/123-abc',
284         'only_matching': True,
285     }]
286 class GlattvisionTVIE(ZattooIE):
287     _NETRC_MACHINE = 'glattvisiontv'
288     _HOST = 'iptv.glattvision.ch'
289     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
290     _TESTS = [{
291         'url': 'https://iptv.glattvision.ch/watch/abc/123-abc',
292         'only_matching': True,
293     }]
294 class SAKTVIE(ZattooIE):
295     _NETRC_MACHINE = 'saktv'
296     _HOST = 'saktv.ch'
297     _API_HOST = 'www.%s' % _HOST
298     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
299     _TESTS = [{
300         'url': 'https://www.saktv.ch/watch/abc/123-abc',
301         'only_matching': True,
302     }]
303 class EWETVIE(ZattooIE):
304     _NETRC_MACHINE = 'ewetv'
305     _HOST = 'tvonline.ewe.de'
306     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
307     _TESTS = [{
308         'url': 'https://tvonline.ewe.de/watch/abc/123-abc',
309         'only_matching': True,
310     }]
311 class QuantumTVIE(ZattooIE):
312     _NETRC_MACHINE = 'quantumtv'
313     _HOST = 'quantum-tv.com'
314     _API_HOST = 'www.%s' % _HOST
315     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
316     _TESTS = [{
317         'url': 'https://www.quantum-tv.com/watch/abc/123-abc',
318         'only_matching': True,
319     }]
320 class OsnatelTVIE(ZattooIE):
321     _NETRC_MACHINE = 'osnateltv'
322     _HOST = 'tvonline.osnatel.de'
323     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
324     _TESTS = [{
325         'url': 'https://tvonline.osnatel.de/watch/abc/123-abc',
326         'only_matching': True,
327     }]
328 class EinsUndEinsTVIE(ZattooIE):
329     _NETRC_MACHINE = '1und1tv'
330     _HOST = '1und1.tv'
331     _API_HOST = 'www.%s' % _HOST
332     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
333     _TESTS = [{
334         'url': 'https://www.1und1.tv/watch/abc/123-abc',
335         'only_matching': True,
336     }]
337 class SaltTVIE(ZattooIE):
338     _NETRC_MACHINE = 'salttv'
339     _HOST = 'tv.salt.ch'
340     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
341     _TESTS = [{
342         'url': 'https://tv.salt.ch/watch/abc/123-abc',
343         'only_matching': True,
344     }]
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
