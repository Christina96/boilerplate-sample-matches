<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for alphaporno.py &amp; zattoo.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for alphaporno.py &amp; zattoo.py
      </h3>
<h1 align="center">
        3.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>alphaporno.py (19.047619%)<th>zattoo.py (2.201835%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(36-43)<td><a href="#" name="0">(56-64)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>alphaporno.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 from .common import InfoExtractor
3 from ..utils import (
4     parse_iso8601,
5     parse_duration,
6     parse_filesize,
7     int_or_none,
8 )
9 class AlphaPornoIE(InfoExtractor):
10     _VALID_URL = r'https?://(?:www\.)?alphaporno\.com/videos/(?P&lt;id&gt;[^/]+)'
11     _TEST = {
12         'url': 'http://www.alphaporno.com/videos/sensual-striptease-porn-with-samantha-alexandra/',
13         'md5': 'feb6d3bba8848cd54467a87ad34bd38e',
14         'info_dict': {
15             'id': '258807',
16             'display_id': 'sensual-striptease-porn-with-samantha-alexandra',
17             'ext': 'mp4',
18             'title': 'Sensual striptease porn with Samantha Alexandra',
19             'thumbnail': r're:https?://.*\.jpg$',
20             'timestamp': 1418694611,
21             'upload_date': '20141216',
22             'duration': 387,
23             'filesize_approx': 54120000,
24             'tbr': 1145,
25             'categories': list,
26             'age_limit': 18,
27         }
28     }
29         display_id = self._match_id(url)
30         webpage = self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._download_webpage(url, display_id)
31         video_id = self._search_regex(
32             r"video_id\s*:\s*'([^']+)'", webpage, 'video id', default=None)
33         video_url = self._search_regex(
34             r"video_url\s*:\s*'([^']+)'", webpage, 'video url')
35         ext = self._html_search_meta(</b></font>
36             'encodingFormat', webpage, 'ext', default='.mp4')[1:]
37         title = self._search_regex(
38             [r'&lt;meta content="([^"]+)" itemprop="description"&gt;',
39              r'class="title" itemprop="name"&gt;([^&lt;]+)&lt;'],
40             webpage, 'title')
41         thumbnail = self._html_search_meta('thumbnail', webpage, 'thumbnail')
42         timestamp = parse_iso8601(self._html_search_meta(
43             'uploadDate', webpage, 'upload date'))
44         duration = parse_duration(self._html_search_meta(
45             'duration', webpage, 'duration'))
46         filesize_approx = parse_filesize(self._html_search_meta(
47             'contentSize', webpage, 'file size'))
48         bitrate = int_or_none(self._html_search_meta(
49             'bitrate', webpage, 'bitrate'))
50         categories = self._html_search_meta(
51             'keywords', webpage, 'categories', default='').split(',')
52         age_limit = self._rta_search(webpage)
53         return {
54             'id': video_id,
55             'display_id': display_id,
56             'url': video_url,
57             'ext': ext,
58             'title': title,
59             'thumbnail': thumbnail,
60             'timestamp': timestamp,
61             'duration': duration,
62             'filesize_approx': filesize_approx,
63             'tbr': bitrate,
64             'categories': categories,
65             'age_limit': age_limit,
66         }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>zattoo.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import re
3 from uuid import uuid4
4 from .common import InfoExtractor
5 from ..compat import (
6     compat_HTTPError,
7     compat_str,
8 )
9 from ..utils import (
10     ExtractorError,
11     int_or_none,
12     try_get,
13     url_or_none,
14     urlencode_postdata,
15 )
16 class ZattooPlatformBaseIE(InfoExtractor):
17     _power_guide_hash = None
18     def _host_url(self):
19         return 'https://%s' % (self._API_HOST if hasattr(self, '_API_HOST') else self._HOST)
20     def _login(self):
21         username, password = self._get_login_info()
22         if not username or not password:
23             self.raise_login_required(
24                 'A valid %s account is needed to access this media.'
25                 % self._NETRC_MACHINE)
26         try:
27             data = self._download_json(
28                 '%s/zapi/v2/account/login' % self._host_url(), None, 'Logging in',
29                 data=urlencode_postdata({
30                     'login': username,
31                     'password': password,
32                     'remember': 'true',
33                 }), headers={
34                     'Referer': '%s/login' % self._host_url(),
35                     'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
36                 })
37         except ExtractorError as e:
38             if isinstance(e.cause, compat_HTTPError) and e.cause.code == 400:
39                 raise ExtractorError(
40                     'Unable to login: incorrect username and/or password',
41                     expected=True)
42             raise
43         self._power_guide_hash = data['session']['power_guide_hash']
44     def _real_initialize(self):
45         webpage = self._download_webpage(
46             self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._host_url(), None, 'Downloading app token')
47         app_token = self._html_search_regex(
48             r'appToken\s*=\s*(["\'])(?P&lt;token&gt;(?:(?!\1).)+?)\1',
49             webpage, 'app token', group='token')
50         app_version = self._html_search_regex(
51             r'&lt;!--\w+-(.+?)-', webpage, 'app version', default='2.8.2')
52         self._request_webpage(</b></font>
53             '%s/zapi/v2/session/hello' % self._host_url(), None,
54             'Opening session', data=urlencode_postdata({
55                 'client_app_token': app_token,
56                 'uuid': compat_str(uuid4()),
57                 'lang': 'en',
58                 'app_version': app_version,
59                 'format': 'json',
60             }))
61         self._login()
62     def _extract_cid(self, video_id, channel_name):
63         channel_groups = self._download_json(
64             '%s/zapi/v2/cached/channels/%s' % (self._host_url(),
65                                                self._power_guide_hash),
66             video_id, 'Downloading channel list',
67             query={'details': False})['channel_groups']
68         channel_list = []
69         for chgrp in channel_groups:
70             channel_list.extend(chgrp['channels'])
71         try:
72             return next(
73                 chan['cid'] for chan in channel_list
74                 if chan.get('cid') and (
75                     chan.get('display_alias') == channel_name
76                     or chan.get('cid') == channel_name))
77         except StopIteration:
78             raise ExtractorError('Could not extract channel id')
79     def _extract_cid_and_video_info(self, video_id):
80         data = self._download_json(
81             '%s/zapi/v2/cached/program/power_details/%s' % (
82                 self._host_url(), self._power_guide_hash),
83             video_id,
84             'Downloading video information',
85             query={
86                 'program_ids': video_id,
87                 'complete': True,
88             })
89         p = data['programs'][0]
90         cid = p['cid']
91         info_dict = {
92             'id': video_id,
93             'title': p.get('t') or p['et'],
94             'description': p.get('d'),
95             'thumbnail': p.get('i_url'),
96             'creator': p.get('channel_name'),
97             'episode': p.get('et'),
98             'episode_number': int_or_none(p.get('e_no')),
99             'season_number': int_or_none(p.get('s_no')),
100             'release_year': int_or_none(p.get('year')),
101             'categories': try_get(p, lambda x: x['c'], list),
102             'tags': try_get(p, lambda x: x['g'], list)
103         }
104         return cid, info_dict
105     def _extract_formats(self, cid, video_id, record_id=None, is_live=False):
106         postdata_common = {
107             'https_watch_urls': True,
108         }
109         if is_live:
110             postdata_common.update({'timeshift': 10800})
111             url = '%s/zapi/watch/live/%s' % (self._host_url(), cid)
112         elif record_id:
113             url = '%s/zapi/watch/recording/%s' % (self._host_url(), record_id)
114         else:
115             url = '%s/zapi/watch/recall/%s/%s' % (self._host_url(), cid, video_id)
116         formats = []
117         for stream_type in ('dash', 'hls', 'hls5', 'hds'):
118             postdata = postdata_common.copy()
119             postdata['stream_type'] = stream_type
120             data = self._download_json(
121                 url, video_id, 'Downloading %s formats' % stream_type.upper(),
122                 data=urlencode_postdata(postdata), fatal=False)
123             if not data:
124                 continue
125             watch_urls = try_get(
126                 data, lambda x: x['stream']['watch_urls'], list)
127             if not watch_urls:
128                 continue
129             for watch in watch_urls:
130                 if not isinstance(watch, dict):
131                     continue
132                 watch_url = url_or_none(watch.get('url'))
133                 if not watch_url:
134                     continue
135                 format_id_list = [stream_type]
136                 maxrate = watch.get('maxrate')
137                 if maxrate:
138                     format_id_list.append(compat_str(maxrate))
139                 audio_channel = watch.get('audio_channel')
140                 if audio_channel:
141                     format_id_list.append(compat_str(audio_channel))
142                 preference = 1 if audio_channel == 'A' else None
143                 format_id = '-'.join(format_id_list)
144                 if stream_type in ('dash', 'dash_widevine', 'dash_playready'):
145                     this_formats = self._extract_mpd_formats(
146                         watch_url, video_id, mpd_id=format_id, fatal=False)
147                 elif stream_type in ('hls', 'hls5', 'hls5_fairplay'):
148                     this_formats = self._extract_m3u8_formats(
149                         watch_url, video_id, 'mp4',
150                         entry_protocol='m3u8_native', m3u8_id=format_id,
151                         fatal=False)
152                 elif stream_type == 'hds':
153                     this_formats = self._extract_f4m_formats(
154                         watch_url, video_id, f4m_id=format_id, fatal=False)
155                 elif stream_type == 'smooth_playready':
156                     this_formats = self._extract_ism_formats(
157                         watch_url, video_id, ism_id=format_id, fatal=False)
158                 else:
159                     assert False
160                 for this_format in this_formats:
161                     this_format['preference'] = preference
162                 formats.extend(this_formats)
163         self._sort_formats(formats)
164         return formats
165     def _extract_video(self, channel_name, video_id, record_id=None, is_live=False):
166         if is_live:
167             cid = self._extract_cid(video_id, channel_name)
168             info_dict = {
169                 'id': channel_name,
170                 'title': self._live_title(channel_name),
171                 'is_live': True,
172             }
173         else:
174             cid, info_dict = self._extract_cid_and_video_info(video_id)
175         formats = self._extract_formats(
176             cid, video_id, record_id=record_id, is_live=is_live)
177         info_dict['formats'] = formats
178         return info_dict
179 class QuicklineBaseIE(ZattooPlatformBaseIE):
180     _NETRC_MACHINE = 'quickline'
181     _HOST = 'mobiltv.quickline.com'
182 class QuicklineIE(QuicklineBaseIE):
183     _VALID_URL = r'https?://(?:www\.)?%s/watch/(?P&lt;channel&gt;[^/]+)/(?P&lt;id&gt;[0-9]+)' % re.escape(QuicklineBaseIE._HOST)
184     _TEST = {
185         'url': 'https://mobiltv.quickline.com/watch/prosieben/130671867-maze-runner-die-auserwaehlten-in-der-brandwueste',
186         'only_matching': True,
187     }
188     def _real_extract(self, url):
189         channel_name, video_id = re.match(self._VALID_URL, url).groups()
190         return self._extract_video(channel_name, video_id)
191 class QuicklineLiveIE(QuicklineBaseIE):
192     _VALID_URL = r'https?://(?:www\.)?%s/watch/(?P&lt;id&gt;[^/]+)' % re.escape(QuicklineBaseIE._HOST)
193     _TEST = {
194         'url': 'https://mobiltv.quickline.com/watch/srf1',
195         'only_matching': True,
196     }
197     @classmethod
198     def suitable(cls, url):
199         return False if QuicklineIE.suitable(url) else super(QuicklineLiveIE, cls).suitable(url)
200     def _real_extract(self, url):
201         channel_name = video_id = self._match_id(url)
202         return self._extract_video(channel_name, video_id, is_live=True)
203 class ZattooBaseIE(ZattooPlatformBaseIE):
204     _NETRC_MACHINE = 'zattoo'
205     _HOST = 'zattoo.com'
206 def _make_valid_url(tmpl, host):
207     return tmpl % re.escape(host)
208 class ZattooIE(ZattooBaseIE):
209     _VALID_URL_TEMPLATE = r'https?://(?:www\.)?%s/watch/(?P&lt;channel&gt;[^/]+?)/(?P&lt;id&gt;[0-9]+)[^/]+(?:/(?P&lt;recid&gt;[0-9]+))?'
210     _VALID_URL = _make_valid_url(_VALID_URL_TEMPLATE, ZattooBaseIE._HOST)
211     _TESTS = [{
212         'url': 'https://zattoo.com/watch/prosieben/130671867-maze-runner-die-auserwaehlten-in-der-brandwueste',
213         'only_matching': True,
214     }, {
215         'url': 'https://zattoo.com/watch/srf_zwei/132905652-eishockey-spengler-cup/102791477/1512211800000/1514433500000/92000',
216         'only_matching': True,
217     }]
218     def _real_extract(self, url):
219         channel_name, video_id, record_id = re.match(self._VALID_URL, url).groups()
220         return self._extract_video(channel_name, video_id, record_id)
221 class ZattooLiveIE(ZattooBaseIE):
222     _VALID_URL = r'https?://(?:www\.)?zattoo\.com/watch/(?P&lt;id&gt;[^/]+)'
223     _TEST = {
224         'url': 'https://zattoo.com/watch/srf1',
225         'only_matching': True,
226     }
227     @classmethod
228     def suitable(cls, url):
229         return False if ZattooIE.suitable(url) else super(ZattooLiveIE, cls).suitable(url)
230     def _real_extract(self, url):
231         channel_name = video_id = self._match_id(url)
232         return self._extract_video(channel_name, video_id, is_live=True)
233 class NetPlusIE(ZattooIE):
234     _NETRC_MACHINE = 'netplus'
235     _HOST = 'netplus.tv'
236     _API_HOST = 'www.%s' % _HOST
237     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
238     _TESTS = [{
239         'url': 'https://www.netplus.tv/watch/abc/123-abc',
240         'only_matching': True,
241     }]
242 class MNetTVIE(ZattooIE):
243     _NETRC_MACHINE = 'mnettv'
244     _HOST = 'tvplus.m-net.de'
245     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
246     _TESTS = [{
247         'url': 'https://tvplus.m-net.de/watch/abc/123-abc',
248         'only_matching': True,
249     }]
250 class WalyTVIE(ZattooIE):
251     _NETRC_MACHINE = 'walytv'
252     _HOST = 'player.waly.tv'
253     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
254     _TESTS = [{
255         'url': 'https://player.waly.tv/watch/abc/123-abc',
256         'only_matching': True,
257     }]
258 class BBVTVIE(ZattooIE):
259     _NETRC_MACHINE = 'bbvtv'
260     _HOST = 'bbv-tv.net'
261     _API_HOST = 'www.%s' % _HOST
262     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
263     _TESTS = [{
264         'url': 'https://www.bbv-tv.net/watch/abc/123-abc',
265         'only_matching': True,
266     }]
267 class VTXTVIE(ZattooIE):
268     _NETRC_MACHINE = 'vtxtv'
269     _HOST = 'vtxtv.ch'
270     _API_HOST = 'www.%s' % _HOST
271     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
272     _TESTS = [{
273         'url': 'https://www.vtxtv.ch/watch/abc/123-abc',
274         'only_matching': True,
275     }]
276 class MyVisionTVIE(ZattooIE):
277     _NETRC_MACHINE = 'myvisiontv'
278     _HOST = 'myvisiontv.ch'
279     _API_HOST = 'www.%s' % _HOST
280     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
281     _TESTS = [{
282         'url': 'https://www.myvisiontv.ch/watch/abc/123-abc',
283         'only_matching': True,
284     }]
285 class GlattvisionTVIE(ZattooIE):
286     _NETRC_MACHINE = 'glattvisiontv'
287     _HOST = 'iptv.glattvision.ch'
288     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
289     _TESTS = [{
290         'url': 'https://iptv.glattvision.ch/watch/abc/123-abc',
291         'only_matching': True,
292     }]
293 class SAKTVIE(ZattooIE):
294     _NETRC_MACHINE = 'saktv'
295     _HOST = 'saktv.ch'
296     _API_HOST = 'www.%s' % _HOST
297     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
298     _TESTS = [{
299         'url': 'https://www.saktv.ch/watch/abc/123-abc',
300         'only_matching': True,
301     }]
302 class EWETVIE(ZattooIE):
303     _NETRC_MACHINE = 'ewetv'
304     _HOST = 'tvonline.ewe.de'
305     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
306     _TESTS = [{
307         'url': 'https://tvonline.ewe.de/watch/abc/123-abc',
308         'only_matching': True,
309     }]
310 class QuantumTVIE(ZattooIE):
311     _NETRC_MACHINE = 'quantumtv'
312     _HOST = 'quantum-tv.com'
313     _API_HOST = 'www.%s' % _HOST
314     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
315     _TESTS = [{
316         'url': 'https://www.quantum-tv.com/watch/abc/123-abc',
317         'only_matching': True,
318     }]
319 class OsnatelTVIE(ZattooIE):
320     _NETRC_MACHINE = 'osnateltv'
321     _HOST = 'tvonline.osnatel.de'
322     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
323     _TESTS = [{
324         'url': 'https://tvonline.osnatel.de/watch/abc/123-abc',
325         'only_matching': True,
326     }]
327 class EinsUndEinsTVIE(ZattooIE):
328     _NETRC_MACHINE = '1und1tv'
329     _HOST = '1und1.tv'
330     _API_HOST = 'www.%s' % _HOST
331     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
332     _TESTS = [{
333         'url': 'https://www.1und1.tv/watch/abc/123-abc',
334         'only_matching': True,
335     }]
336 class SaltTVIE(ZattooIE):
337     _NETRC_MACHINE = 'salttv'
338     _HOST = 'tv.salt.ch'
339     _VALID_URL = _make_valid_url(ZattooIE._VALID_URL_TEMPLATE, _HOST)
340     _TESTS = [{
341         'url': 'https://tv.salt.ch/watch/abc/123-abc',
342         'only_matching': True,
343     }]
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
