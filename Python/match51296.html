<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_reactor_2.py &amp; test_dockermod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_reactor_2.py &amp; test_dockermod.py
      </h3>
<h1 align="center">
        5.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_reactor_2.py (19.426048%)<th>test_dockermod.py (3.319502%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(270-330)<td><a href="#" name="0">(1226-1249)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(145-216)<td><a href="#" name="1">(1266-1288)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(49-135)<td><a href="#" name="2">(2013-2025)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(216-256)<td><a href="#" name="3">(1381-1411)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(2-16)<td><a href="#" name="4">(8-22)</a><td align="center"><font color="#9d0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_reactor_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import glob
import logging
import os
import textwrap
import salt.loader
import salt.utils.data
import salt.utils.files
import salt.utils.reactor as reactor
import salt.utils.yaml
from tests.support.mixins import AdaptedConfigurationTestCaseMixin
from tests.support.mock import MagicMock, Mock, mock_open, patch
from tests.support.unit import TestCase
REACTOR_CONFIG =</b></font> """\
reactor:
  - old_runner:
    - /srv/reactor/old_runner.sls
  - old_wheel:
    - /srv/reactor/old_wheel.sls
  - old_local:
    - /srv/reactor/old_local.sls
  - old_cmd:
    - /srv/reactor/old_cmd.sls
  - old_caller:
    - /srv/reactor/old_caller.sls
  - new_runner:
    - /srv/reactor/new_runner.sls
  - new_wheel:
    - /srv/reactor/new_wheel.sls
  - new_local:
    - /srv/reactor/new_local.sls
  - new_cmd:
    - /srv/reactor/new_cmd.sls
  - new_caller:
    - /srv/reactor/new_caller.sls
"""
REACTOR_DATA = {
    "runner": {"data": {"message": "This is an error"}},
    "wheel": {"data": {"id": "foo"}},
    "local": {"data": {"pkg": "zsh", "repo": "updates"}},
    "cmd": {"data": {"pkg": "zsh", "repo": "updates"}},
    "caller": {"data": {"path": "/tmp/foo"}},
SLS = {
    "/srv/reactor/old_runner.sls": textwrap<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dedent(
        """\
        raise_error:
          runner.error.error:
            - name: Exception
            - message: {{ data['data']['message'] }}
        """
    ),
    "/srv/reactor/old_wheel.sls": textwrap.dedent(
        """\
        remove_key:
          wheel.key.delete:
            - match: {{ data['data']['id'] }}
        """
    ),
    "/srv/reactor/old_local.sls": textwrap.dedent(
        """\
        install_zsh:
          local.state.single:
            - tgt: test
            - arg:
              - pkg.installed
              - {{ data['data']['pkg'] }}
            - kwarg:
                fromrepo: {{ data['data']['repo'] }}
        """
    ),
    "/srv/reactor/old_cmd.sls": textwrap.dedent(
        """\
        install_zsh:
          cmd.state.single:
            - tgt: test
            - arg:
              - pkg.installed
              - {{ data['data']['pkg'] }}
            - kwarg:
                fromrepo: {{ data['data']['repo'] }}
        """
    ),
    "/srv/reactor/old_caller.sls": textwrap.dedent(
        """\
        touch_file:
          caller.file.touch:
            - args:
              - {{ data['data']['path'] }}
        """
    ),
    "/srv/reactor/new_runner.sls": textwrap.dedent(
        """\
        raise_error:
          runner.error.error:
            - args:
              - name: Exception
              - message: {{ data['data']['message'] }}
        """
    ),
    "/srv/reactor/new_wheel.sls": textwrap.dedent(
        """\
        remove_key:
          wheel.key.delete:
            - args:
              - match: {{ data['data']['id'] }}
        """
    ),
    "/srv/reactor/new_local.sls": textwrap.dedent(
        """\
        install_zsh:
          local.state.single:
            - tgt: test
            - args:
              - fun: pkg.installed
              - name: {{ data['data']['pkg'] }}
              - fromrepo: {{ data['data']['repo'] }}
        """
    ),
    "/srv/reactor/new_cmd.sls": textwrap.dedent(
        """\
        install_zsh:
          cmd.state.single:
            - tgt: test
            - args:
              - fun: pkg.installed
              - name: {{ data['data']['pkg'] }}
              - fromrepo: {{ data['data']['repo'] }}
        """
    ),
    "/srv/reactor/new_caller.sls": textwrap.dedent(</b></font>
        """\
        touch_file:
          caller.file.touch:
            - args:
              - name: {{ data['data']['path'] }}
        """
}
LOW_CHUNKS <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
    "old_runner": [
        {
            "state": "runner",
            "__id__": "raise_error",
            "__sls__": "/srv/reactor/old_runner.sls",
            "order": 1,
            "fun": "error.error",
            "name": "Exception",
            "message": "This is an error",
        }
    ],
    "old_wheel": [
        {
            "state": "wheel",
            "__id__": "remove_key",
            "name": "remove_key",
            "__sls__": "/srv/reactor/old_wheel.sls",
            "order": 1,
            "fun": "key.delete",
            "match": "foo",
        }
    ],
    "old_local": [
        {
            "state": "local",
            "__id__": "install_zsh",
            "name": "install_zsh",
            "__sls__": "/srv/reactor/old_local.sls",
            "order": 1,
            "tgt": "test",
            "fun": "state.single",
            "arg": ["pkg.installed", "zsh"],
            "kwarg": {"fromrepo": "updates"},
        }
    ],
    "old_cmd": [
        {
            "state": "local",  # 'cmd' should be aliased to 'local'
            "__id__": "install_zsh",
            "name": "install_zsh",
            "__sls__": "/srv/reactor/old_cmd.sls",
            "order": 1,
            "tgt": "test",
            "fun": "state.single",
            "arg": ["pkg.installed", "zsh"],
            "kwarg": {"fromrepo": "updates"},
        }
    ],
    "old_caller": [
        {
            "state": "caller",
            "__id__": "touch_file",
            "name": "touch_file",
            "__sls__": "/srv/reactor/old_caller.sls",
            "order": 1,
            "fun": "file.touch",
            "args": ["/tmp/foo"],
        }
    ],
    "new_runner": [
        {
            "state": "runner",
            "__id__": "raise_error",
            "name": "raise_error",
            "order": 1,
            "fun": "error.error",
            "args": [{"name"</b></font>: "Exception"}, {<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"message": "This is an error"}],
        }
    ],
    "new_wheel": [
        {
            "state": "wheel",
            "__id__": "remove_key",
            "name": "remove_key",
            "__sls__": "/srv/reactor/new_wheel.sls",
            "order": 1,
            "fun": "key.delete",
            "args": [{"match": "foo"}],
        }
    ],
    "new_local": [
        {
            "state": "local",
            "__id__": "install_zsh",
            "name": "install_zsh",
            "__sls__": "/srv/reactor/new_local.sls",
            "order": 1,
            "tgt": "test",
            "fun": "state.single",
            "args": [
                {"fun": "pkg.installed"},
                {"name": "zsh"},
                {"fromrepo": "updates"},
            ],
        }
    ],
    "new_cmd": [
        {
            "state": "local",
            "__id__": "install_zsh",
            "name": "install_zsh",
            "__sls__": "/srv/reactor/new_cmd.sls",
            "order": 1,
            "tgt": "test",
            "fun": "state.single",
            "args": [
                {"fun"</b></font>: "pkg.installed"},
                {"name": "zsh"},
                {"fromrepo": "updates"},
            ],
        }
    ],
    "new_caller": [
        {
            "state": "caller",
            "__id__": "touch_file",
            "name": "touch_file",
            "order": 1,
            "fun": "file.touch",
            "args": [{<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"name": "/tmp/foo"}],
        }
    ],
}
WRAPPER_CALLS = {
    "old_runner": (
        "error.error",
        {
            "__state__": "runner",
            "__id__": "raise_error",
            "__sls__": "/srv/reactor/old_runner.sls",
            "__user__": "Reactor",
            "order": 1,
            "arg": [],
            "kwarg": {"name": "Exception", "message": "This is an error"},
            "name": "Exception",
            "message": "This is an error",
        },
    ),
    "old_wheel": (
        "key.delete",
        {
            "__state__": "wheel",
            "__id__": "remove_key",
            "name": "remove_key",
            "__sls__": "/srv/reactor/old_wheel.sls",
            "order": 1,
            "__user__": "Reactor",
            "arg": ["foo"],
            "kwarg": {},
            "match": "foo",
        },
    ),
    "old_local": {
        "args": ("test", "state.single"),
        "kwargs": {
            "state": "local",
            "__id__": "install_zsh",
            "name": "install_zsh",
            "__sls__": "/srv/reactor/old_local.sls",
            "order": 1,
            "arg": ["pkg.installed", "zsh"],
            "kwarg": {"fromrepo": "updates"},
        },
    },
    "old_cmd": {
        "args": ("test", "state.single"),
        "kwargs": {
            "state": "local",
            "__id__": "install_zsh",
            "name": "install_zsh",
            "__sls__": "/srv/reactor/old_cmd.sls",
            "order": 1,
            "arg": ["pkg.installed", "zsh"],
            "kwarg": {"fromrepo": "updates"},
        },
    },
    "old_caller": {"args": ("file.touch", "/tmp/foo"), "kwargs": {}},
    "new_runner": (
        "error.error"</b></font>,
        {
            "__state__": "runner",
            "__id__": "raise_error",
            "name": "raise_error",
            "__sls__": "/srv/reactor/new_runner.sls",
            "__user__": "Reactor",
            "order": 1,
            "arg": (),
            "kwarg": {"name": "Exception", "message": "This is an error"},
        },
    ),
    "new_wheel": (
        "key.delete",
        {
            "__state__": "wheel",
            "__id__": "remove_key",
            "name": "remove_key",
            "__sls__": "/srv/reactor/new_wheel.sls",
            "order": 1,
            "__user__": "Reactor",
            "arg": (),
            "kwarg": {"match": "foo"},
        },
    ),
    "new_local": {
        "args": ("test", "state.single"),
        "kwargs": {
            "state": "local",
            "__id__": "install_zsh",
            "name": "install_zsh",
            "__sls__": "/srv/reactor/new_local.sls",
            "order": 1,
            "arg": (),
            "kwarg": {"fun": "pkg.installed", "name": "zsh", "fromrepo": "updates"},
        },
    },
    "new_cmd": {
        "args": ("test", "state.single"),
        "kwargs": {
            "state": "local",
            "__id__": "install_zsh",
            "name": "install_zsh",
            "__sls__": "/srv/reactor/new_cmd.sls",
            "order": 1,
            "arg": (),
            "kwarg": {"fun": "pkg.installed", "name": "zsh", "fromrepo": "updates"},
        },
    },
    "new_caller": {"args": ("file.touch",), "kwargs": {"name": "/tmp/foo"}},
}
log = logging.getLogger(__name__)
class TestReactor(TestCase, AdaptedConfigurationTestCaseMixin):
    """
    Tests for constructing the low chunks to be executed via the Reactor
    """
    @classmethod
    def setUpClass(cls):
        """
        Load the reactor config for mocking
        """
        cls.opts = cls.get_temp_config("master")
        reactor_config = salt.utils.yaml.safe_load(REACTOR_CONFIG)
        cls.opts.update(reactor_config)
        cls.reactor = reactor.Reactor(cls.opts)
        cls.reaction_map = salt.utils.data.repack_dictlist(reactor_config["reactor"])
        renderers = salt.loader.render(cls.opts, {})
        cls.render_pipe = [(renderers[x], "") for x in ("jinja", "yaml")]
    @classmethod
    def tearDownClass(cls):
        del cls.opts
        del cls.reactor
        del cls.render_pipe
    def test_list_reactors(self):
        """
        Ensure that list_reactors() returns the correct list of reactor SLS
        files for each tag.
        """
        for schema in ("old", "new"):
            for rtype in REACTOR_DATA:
                tag = "_".join((schema, rtype))
                self.assertEqual(
                    self.reactor.list_reactors(tag), self.reaction_map[tag]
                )
    def test_reactions(self):
        """
        Ensure that the correct reactions are built from the configured SLS
        files and tag data.
        """
        for schema in ("old", "new"):
            for rtype in REACTOR_DATA:
                tag = "_".join((schema, rtype))
                log.debug("test_reactions: processing %s", tag)
                reactors = self.reactor.list_reactors(tag)
                log.debug("test_reactions: %s reactors: %s", tag, reactors)
                with patch.object(glob, "glob", MagicMock(side_effect=lambda x: [x])):
                    with patch.object(os.path, "isfile", MagicMock(return_value=True)):
                        with patch.object(
                            salt.utils.files, "is_empty", MagicMock(return_value=False)
                        ):
                            with patch.object(
                                codecs, "open", mock_open(read_data=SLS[reactors[0]])
                            ):
                                with patch.object(
                                    salt.template,
                                    "template_shebang",
                                    MagicMock(return_value=self.render_pipe),
                                ):
                                    reactions = self.reactor.reactions(
                                        tag,
                                        REACTOR_DATA[rtype],
                                        reactors,
                                    )
                                    log.debug(
                                        "test_reactions: %s reactions: %s",
                                        tag,
                                        reactions,
                                    )
                                    self.assertEqual(reactions, LOW_CHUNKS[tag])
class TestReactWrap(TestCase, AdaptedConfigurationTestCaseMixin):
    """
    Tests that we are formulating the wrapper calls properly
    """
    @classmethod
    def setUpClass(cls):
        cls.wrap = reactor.ReactWrap(cls.get_temp_config("master"))
    @classmethod
    def tearDownClass(cls):
        del cls.wrap
    def test_runner(self):
        """
        Test runner reactions using both the old and new config schema
        """
        for schema in ("old", "new"):
            tag = "_".join((schema, "runner"))
            chunk = LOW_CHUNKS[tag][0]
            thread_pool = Mock()
            thread_pool.fire_async = Mock()
            with patch.object(self.wrap, "pool", thread_pool):
                self.wrap.run(chunk)
            thread_pool.fire_async.assert_called_with(
                self.wrap.client_cache["runner"].low, args=WRAPPER_CALLS[tag]
            )
    def test_wheel(self):
        """
        Test wheel reactions using both the old and new config schema
        """
        for schema in ("old", "new"):
            tag = "_".join((schema, "wheel"))
            chunk = LOW_CHUNKS[tag][0]
            thread_pool = Mock()
            thread_pool.fire_async = Mock()
            with patch.object(self.wrap, "pool", thread_pool):
                self.wrap.run(chunk)
            thread_pool.fire_async.assert_called_with(
                self.wrap.client_cache["wheel"].low, args=WRAPPER_CALLS[tag]
            )
    def test_local(self):
        """
        Test local reactions using both the old and new config schema
        """
        for schema in ("old", "new"):
            tag = "_".join((schema, "local"))
            chunk = LOW_CHUNKS[tag][0]
            client_cache = {"local": Mock()}
            client_cache["local"].cmd_async = Mock()
            with patch.object(self.wrap, "client_cache", client_cache):
                self.wrap.run(chunk)
            client_cache["local"].cmd_async.assert_called_with(
                *WRAPPER_CALLS[tag]["args"], **WRAPPER_CALLS[tag]["kwargs"]
            )
    def test_cmd(self):
        """
        Test cmd reactions (alias for 'local') using both the old and new
        config schema
        """
        for schema in ("old", "new"):
            tag = "_".join((schema, "cmd"))
            chunk = LOW_CHUNKS[tag][0]
            client_cache = {"local": Mock()}
            client_cache["local"].cmd_async = Mock()
            with patch.object(self.wrap, "client_cache", client_cache):
                self.wrap.run(chunk)
            client_cache["local"].cmd_async.assert_called_with(
                *WRAPPER_CALLS[tag]["args"], **WRAPPER_CALLS[tag]["kwargs"]
            )
    def test_caller(self):
        """
        Test caller reactions using both the old and new config schema
        """
        for schema in ("old", "new"):
            tag = "_".join((schema, "caller"))
            chunk = LOW_CHUNKS[tag][0]
            client_cache = {"caller": Mock()}
            client_cache["caller"].cmd = Mock()
            with patch.object(self.wrap, "client_cache", client_cache):
                self.wrap.run(chunk)
            client_cache["caller"].cmd.assert_called_with(
                *WRAPPER_CALLS[tag]["args"], **WRAPPER_CALLS[tag]["kwargs"]
            )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_dockermod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
tests.unit.utils.test_dockermod
===============================
"""
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
import functools
import logging
import os
import salt.config
import salt.loader
import salt.utils.dockermod.translate.container
import salt.utils.dockermod.translate.network
import salt.utils.platform
from salt.exceptions import CommandExecutionError
from salt.utils.dockermod.translate import helpers as translate_helpers
from tests.support.unit import TestCase
log =</b></font> logging.getLogger(__name__)
class Assert:
    def __init__(self, translator):
        self.translator = translator
    def __call__(self, func):
        self.func = func
        return functools.wraps(func)(
            lambda testcase, *args, **kwargs: self.wrap(testcase, *args, **kwargs)
        )
    def wrap(self, *args, **kwargs):
        raise NotImplementedError
    def test_stringlist(self, testcase, name):
        alias = self.translator.ALIASES_REVMAP.get(name)
        if salt.utils.platform.is_windows():
            data = [r"c:\foo", r"c:\bar", r"c:\baz"]
        else:
            data = ["/foo", "/bar", "/baz"]
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: ",".join(data)}
                ),
                testcase.apply_defaults({name: data}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: data}),
                testcase.apply_defaults({name: data}),
            )
            if name != "volumes":
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, **{item: ["one", 2]}
                    ),
                    testcase.apply_defaults({name: ["one", "2"]}),
                )
        if alias is not None:
            test_kwargs = {name: data, alias: sorted(data)}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "is an alias for.+cannot both be used"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
    def test_key_value(self, testcase, name, delimiter):
        """
        Common logic for key/value pair testing. IP address validation is
        turned off here, and must be done separately in the wrapped function.
        """
        alias = self.translator.ALIASES_REVMAP.get(name)
        expected = {"foo": "bar", "baz": "qux"}
        vals = "foo{0}bar,baz{0}qux".format(delimiter)
        for item in (name, alias):
            if item is None:
                continue
            for val in (vals, vals.split(",")):
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=False, **{item: val}
                    ),
                    testcase.apply_defaults({name: expected}),
                )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, validate_ip_addrs=False, **{item: expected}
                ),
                testcase.apply_defaults({name: expected}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=False,
                    **{item: [{"foo": "bar"}, {"baz": "qux"}]}
                ),
                testcase.apply_defaults({name: expected}),
            )
        if alias is not None:
            test_kwargs = {name: vals, alias: "hello{}world".format(delimiter)}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=False,
                    ignore_collisions=True,
                    **test_kwargs
                ),
                testcase.apply_defaults({name: expected}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "is an alias for.+cannot both be used"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=False,
                    ignore_collisions=False,
                    **test_kwargs
                )
class assert_bool(Assert):
    """
    Test a boolean value
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: True}),
                testcase.apply_defaults({name: True}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: "foo"}),
                testcase.apply_defaults({name: True}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: 0}),
                testcase.apply_defaults({name: False}),
            )
        if alias is not None:
            test_kwargs = {name: True, alias: False}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "is an alias for.+cannot both be used"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)
class assert_int(Assert):
    """
    Test an integer value
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            for val in (100, "100"):
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, **{item: val}
                    ),
                    testcase.apply_defaults({name: 100}),
                )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "'foo' is not an integer"
            ):
                salt.utils.dockermod.translate_input(self.translator, **{item: "foo"})
        if alias is not None:
            test_kwargs = {name: 100, alias: 200}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "is an alias for.+cannot both be used"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)
class assert_string(Assert):
    """
    Test that item is a string or is converted to one
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        if salt.utils.platform.is_windows():
            data = r"c:\foo"
        else:
            data = "/foo"
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: data}),
                testcase.apply_defaults({name: data}),
            )
            if name != "working_dir":
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, **{item: 123}
                    ),
                    testcase.apply_defaults({name: "123"}),
                )
        if alias is not None:
            test_kwargs = {name: data, alias: data}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "is an alias for.+cannot both be used"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)
class assert_int_or_string(Assert):
    """
    Test an integer or string value
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: 100}),
                testcase.apply_defaults({name: 100}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: "100M"}),
                testcase.apply_defaults({name: "100M"}),
            )
        if alias is not None:
            test_kwargs = {name: 100, alias: "100M"}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "is an alias for.+cannot both be used"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)
class assert_stringlist(Assert):
    """
    Test a comma-separated or Python list of strings
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        self.test_stringlist(testcase, name)
        return self.func(testcase, *args, **kwargs)
class assert_dict(Assert):
    """
    Dictionaries should be untouched, dictlists should be repacked and end up
    as a single dictionary.
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        expected = {"foo": "bar", "baz": "qux"}
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: expected}
                ),
                testcase.apply_defaults({name: expected}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: [{x: y} for x, y in expected.items()]}
                ),
                testcase.apply_defaults({name: expected}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "'foo' is not a dictionary"
            ):
                salt.utils.dockermod.translate_input(self.translator, **{item: "foo"})
        if alias is not None:
            test_kwargs = {name: "foo", alias: "bar"}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "is an alias for.+cannot both be used"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)
class assert_cmd(Assert):
    """
    Test for a string, or a comma-separated or Python list of strings. This is
    different from a stringlist in that we do not do any splitting. This
    decorator is used both by the "command" and "entrypoint" arguments.
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: "foo bar"}
                ),
                testcase.apply_defaults({name: "foo bar"}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: ["foo", "bar"]}
                ),
                testcase.apply_defaults({name: ["foo", "bar"]}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: 123}),
                testcase.apply_defaults({name: "123"}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: ["one", 2]}
                ),
                testcase.apply_defaults({name: ["one", "2"]}),
            )
        if alias is not None:
            test_kwargs = {name: "foo", alias: "bar"}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "is an alias for.+cannot both be used"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)
class assert_key_colon_value(Assert):
    """
    Test a key/value pair with parameters passed as key:value pairs
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        self.test_key_value(testcase, name, ":")
        return self.func(testcase, *args, **kwargs)
class assert_key_equals_value(Assert):
    """
    Test a key/value pair with parameters passed as key=value pairs
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        self.test_key_value(testcase, name, "=")
        if name == "labels":
            self.test_stringlist(testcase, name)
        return self.func(testcase, *args, **kwargs)
class assert_labels(Assert):
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        labels = ["foo", "bar=baz", {"hello": "world"}]
        expected = {"foo": "", "bar": "baz", "hello": "world"}
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: labels}),
                testcase.apply_defaults({name: expected}),
            )
            bad_labels = copy.deepcopy(labels)
            bad_labels[-1]["bad"] = "input"
            with testcase.assertRaisesRegex(
                CommandExecutionError, r"Invalid label\(s\)"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: bad_labels}
                )
        return self.func(testcase, *args, **kwargs)
class assert_device_rates(Assert):
    """
    Tests for device_{read,write}_{bps,iops}. The bps values have a "Rate"
    value expressed in bytes/kb/mb/gb, while the iops values have a "Rate"
    expressed as a simple integer.
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            path = os.path.join("foo", "bar", "baz")
            with testcase.assertRaisesRegex(
                CommandExecutionError,
                "Path '{}' is not absolute".format(path.replace("\\", "\\\\")),
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: "{}:1048576".format(path)}
                )
            if name.endswith("_bps"):
                expected = ({}, [])
                vals = "/dev/sda:1048576,/dev/sdb:1048576"
                for val in (vals, vals.split(",")):
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, **{item: val}
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {"Path": "/dev/sda", "Rate": 1048576},
                                    {"Path": "/dev/sdb", "Rate": 1048576},
                                ]
                            }
                        ),
                    )
                vals = "/dev/sda:1mb,/dev/sdb:5mb"
                for val in (vals, vals.split(",")):
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, **{item: val}
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {"Path": "/dev/sda", "Rate": "1mb"},
                                    {"Path": "/dev/sdb", "Rate": "5mb"},
                                ]
                            }
                        ),
                    )
                if alias is not None:
                    test_kwargs = {
                        name: "/dev/sda:1048576,/dev/sdb:1048576",
                        alias: "/dev/sda:1mb,/dev/sdb:5mb",
                    }
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, ignore_collisions=True, **test_kwargs
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {"Path": "/dev/sda", "Rate": 1048576},
                                    {"Path": "/dev/sdb", "Rate": 1048576},
                                ]
                            }
                        ),
                    )
                    with testcase.assertRaisesRegex(
                        CommandExecutionError, "is an alias for.+cannot both be used"
                    ):
                        salt.utils.dockermod.translate_input(
                            self.translator, ignore_collisions=False, **test_kwargs
                        )
            else:
                vals = "/dev/sda:1000,/dev/sdb:500"
                for val in (vals, vals.split(",")):
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, **{item: val}
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {"Path": "/dev/sda", "Rate": 1000},
                                    {"Path": "/dev/sdb", "Rate": 500},
                                ]
                            }
                        ),
                    )
                expected = (
                    {},
                    {item: "Rate '5mb' for path '/dev/sdb' is non-numeric"},
                    [],
                )
                vals = "/dev/sda:1000,/dev/sdb:5mb"
                for val in (vals, vals.split(",")):
                    with testcase.assertRaisesRegex(
                        CommandExecutionError,
                        "Rate '5mb' for path '/dev/sdb' is non-numeric",
                    ):
                        salt.utils.dockermod.translate_input(
                            self.translator, **{item: val}
                        )
                if alias is not None:
                    test_kwargs = {
                        name: "/dev/sda:1000,/dev/sdb:500",
                        alias: "/dev/sda:888,/dev/sdb:999",
                    }
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, ignore_collisions=True, **test_kwargs
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {"Path": "/dev/sda", "Rate": 1000},
                                    {"Path": "/dev/sdb", "Rate": 500},
                                ]
                            }
                        ),
                    )
                    with testcase.assertRaisesRegex(
                        CommandExecutionError, "is an alias for.+cannot both be used"
                    ):
                        salt.utils.dockermod.translate_input(
                            self.translator, ignore_collisions=False, **test_kwargs
                        )
        return self.func(testcase, *args, **kwargs)
class assert_subnet(Assert):
    """
    Test an IPv4 or IPv6 subnet
    """
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            for val in ("127.0.0.1/32", "::1/128"):
                log.debug("Verifying '%s' is a valid subnet", val)
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=True, **{item: val}
                    ),
                    testcase.apply_defaults({name: val}),
                )
            for val in (
                "127.0.0.1",
                "999.999.999.999/24",
                "10.0.0.0/33",
                "::1",
                "feaz::1/128",
                "::1/129",
            ):
                log.debug("Verifying '%s' is not a valid subnet", val)
                with testcase.assertRaisesRegex(
                    CommandExecutionError, "'{}' is not a valid subnet".format(val)
                ):
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=True, **{item: val}
                    )
            val = "foo"
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, validate_ip_addrs=False, **{item: val}
                ),
                testcase.apply_defaults({name: val}),
            )
        if alias is not None:
            test_kwargs = {name: "10.0.0.0/24", alias: "192.168.50.128/25"}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, "is an alias for.+cannot both be used"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)
class TranslateBase(TestCase):
    maxDiff = None
    translator = None  # Must be overridden in the subclass
    def apply_defaults(self, ret, skip_translate=None):
        if skip_translate is not True:
            defaults = getattr(self.translator, "DEFAULTS", {})
            for key, val in defaults.items():
                if key not in ret:
                    ret[key] = val
        return ret
    @staticmethod
    def normalize_ports(ret):
        """
        When we translate exposed ports, we can end up with a mixture of ints
        (representing TCP ports) and tuples (representing UDP ports). Python 2
        will sort an iterable containing these mixed types, but Python 3 will
        not. This helper is used to munge the ports in the return data so that
        the resulting list is sorted in a way that can reliably be compared to
        the expected results in the test.
        This helper should only be needed for port_bindings and ports.
        """
        if "ports" in ret[0]:
            tcp_ports = []
            udp_ports = []
            for item in ret[0]["ports"]:
                if isinstance(item, int):
                    tcp_ports.append(item)
                else:
                    udp_ports.append(item)
            ret[0]["ports"] = sorted(tcp_ports) + sorted(udp_ports)
        return ret
    def tearDown(self):
        """
        Test skip_translate kwarg
        """
        name = self.id().split(".")[-1][5:]
        for val in (True, name, [name]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, skip_translate=val, **{name: "foo"}
                ),
                self.apply_defaults({name: "foo"}, skip_translate=val),
            )
class TranslateContainerInputTestCase(TranslateBase):
    """
    Tests for salt.utils.dockermod.translate_input(), invoked using
    salt.utils.dockermod.translate.container as the translator module.
    """
    translator = salt.utils.dockermod.translate.container
    @staticmethod
    def normalize_ports(ret):
        """
        When we translate exposed ports, we can end up with a mixture of ints
        (representing TCP ports) and tuples (representing UDP ports). Python 2
        will sort an iterable containing these mixed types, but Python 3 will
        not. This helper is used to munge the ports in the return data so that
        the resulting list is sorted in a way that can reliably be compared to
        the expected results in the test.
        This helper should only be needed for port_bindings and ports.
        """
        if "ports" in ret:
            tcp_ports = []
            udp_ports = []
            for item in ret["ports"]:
                if isinstance(item, int):
                    tcp_ports.append(item)
                else:
                    udp_ports.append(item)
            ret["ports"] = sorted(tcp_ports) + sorted(udp_ports)
        return ret
    @assert_bool(salt.utils.dockermod.translate.container)
    def test_auto_remove(self):
        """
        Should be a bool or converted to one
        """
    def test_binds(self):
        """
        Test the "binds" kwarg. Any volumes not defined in the "volumes" kwarg
        should be added to the results.
        """
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator, binds="/srv/www:/var/www:ro", volumes="/testing"
            ),
            {"binds": ["/srv/www:/var/www:ro"], "volumes": ["/testing", "/var/www"]},
        )
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator, binds=["/srv/www:/var/www:ro"], volumes="/testing"
            ),
            {"binds": ["/srv/www:/var/www:ro"], "volumes": ["/testing", "/var/www"]},
        )
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator,
                binds={"/srv/www": {"bind": "/var/www", "mode": "ro"}},
                volumes="/testing",
            ),
            {
                "binds": {"/srv/www": {"bind": "/var/www", "mode": "ro"}},
                "volumes": ["/testing", "/var/www"],
            },
        )
    @assert_int(salt.utils.dockermod.translate.container)
    def test_blkio_weight(self):
        """
        Should be an int or converted to one
        """
    def test_blkio_weight_device(self):
        """
        Should translate a list of PATH:WEIGHT pairs to a list of dictionaries
        with the following format: {'Path': PATH, 'Weight': WEIGHT}
        """
        for val in ("/dev/sda:100,/dev/sdb:200", ["/dev/sda:100", "/dev/sdb:200"]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, blkio_weight_device="/dev/sda:100,/dev/sdb:200"
                ),
                {
                    "blkio_weight_device": [
                        {"Path": "/dev/sda", "Weight": 100},
                        {"Path": "/dev/sdb", "Weight": 200},
                    ]
                },
            )
        with self.assertRaisesRegex(
            CommandExecutionError, r"'foo' contains 1 value\(s\) \(expected 2\)"
        ):
            salt.utils.dockermod.translate_input(
                self.translator, blkio_weight_device="foo"
            )
        with self.assertRaisesRegex(
            CommandExecutionError, r"'foo:bar:baz' contains 3 value\(s\) \(expected 2\)"
        ):
            salt.utils.dockermod.translate_input(
                self.translator, blkio_weight_device="foo:bar:baz"
            )
        with self.assertRaisesRegex(
            CommandExecutionError, r"Weight 'foo' for path '/dev/sdb' is not an integer"
        ):
            salt.utils.dockermod.translate_input(
                self.translator, blkio_weight_device=["/dev/sda:100", "/dev/sdb:foo"]
            )
    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_cap_add(self):
        """
        Should be a list of strings or converted to one
        """
    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_cap_drop(self):
        """
        Should be a list of strings or converted to one
        """
    @assert_cmd(salt.utils.dockermod.translate.container)
    def test_command(self):
        """
        Can either be a string or a comma-separated or Python list of strings.
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_cpuset_cpus(self):
        """
        Should be a string or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_cpuset_mems(self):
        """
        Should be a string or converted to one
        """
    @assert_int(salt.utils.dockermod.translate.container)
    def test_cpu_group(self):
        """
        Should be an int or converted to one
        """
    @assert_int(salt.utils.dockermod.translate.container)
    def test_cpu_period(self):
        """
        Should be an int or converted to one
        """
    @assert_int(salt.utils.dockermod.translate.container)
    def test_cpu_shares(self):
        """
        Should be an int or converted to one
        """
    @assert_bool(salt.utils.dockermod.translate.container)
    def test_detach(self):
        """
        Should be a bool or converted to one
        """
    @assert_device_rates(salt.utils.dockermod.translate.container)
    def test_device_read_bps(self):
        """
        CLI input is a list of PATH:RATE pairs, but the API expects a list of
        dictionaries in the format [{'Path': path, 'Rate': rate}]
        """
    @assert_device_rates(salt.utils.dockermod.translate.container)
    def test_device_read_iops(self):
        """
        CLI input is a list of PATH:RATE pairs, but the API expects a list of
        dictionaries in the format [{'Path': path, 'Rate': rate}]
        """
    @assert_device_rates(salt.utils.dockermod.translate.container)
    def test_device_write_bps(self):
        """
        CLI input is a list of PATH:RATE pairs, but the API expects a list of
        dictionaries in the format [{'Path': path, 'Rate': rate}]
        """
    @assert_device_rates(salt.utils.dockermod.translate.container)
    def test_device_write_iops(self):
        """
        CLI input is a list of PATH:RATE pairs, but the API expects a list of
        dictionaries in the format [{'Path': path, 'Rate': rate}]
        """
    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_devices(self):
        """
        Should be a list of strings or converted to one
        """
    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_dns_opt(self):
        """
        Should be a list of strings or converted to one
        """
    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_dns_search(self):
        """
        Should be a list of strings or converted to one
        """
    def test_dns(self):
        """
        While this is a stringlist, it also supports IP address validation, so
        it can't use the test_stringlist decorator because we need to test both
        with and without validation, and it isn't necessary to make all other
        stringlist tests also do that same kind of testing.
        """
        for val in ("8.8.8.8,8.8.4.4", ["8.8.8.8", "8.8.4.4"]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    dns=val,
                    validate_ip_addrs=True,
                ),
                {"dns": ["8.8.8.8", "8.8.4.4"]},
            )
        for val in ("8.8.8.888,8.8.4.4", ["8.8.8.888", "8.8.4.4"]):
            with self.assertRaisesRegex(
                CommandExecutionError, r"'8.8.8.888' is not a valid IP address"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    dns=val,
                    validate_ip_addrs=True,
                )
        for val in ("foo,bar", ["foo", "bar"]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    dns=val,
                    validate_ip_addrs=False,
                ),
                {"dns": ["foo", "bar"]},
            )
    @assert_string(salt.utils.dockermod.translate.container)
    def test_domainname(self):
        """
        Should be a list of strings or converted to one
        """
    @assert_cmd(salt.utils.dockermod.translate.container)
    def test_entrypoint(self):
        """
        Can either be a string or a comma-separated or Python list of strings.
        """
    @assert_key_equals_value(salt.utils.dockermod.translate.container)
    def test_environment(self):
        """
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        """
    def test_extra_hosts(self):
        """
        Can be passed as a list of key:value pairs but can't be simply tested
        using @assert_key_colon_value since we need to test both with and without
        IP address validation.
        """
        for val in ("web1:10.9.8.7,web2:10.9.8.8", ["web1:10.9.8.7", "web2:10.9.8.8"]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    extra_hosts=val,
                    validate_ip_addrs=True,
                ),
                {"extra_hosts": {"web1": "10.9.8.7", "web2": "10.9.8.8"}},
            )
        for val in (
            "web1:10.9.8.299,web2:10.9.8.8",
            ["web1:10.9.8.299", "web2:10.9.8.8"],
        ):
            with self.assertRaisesRegex(
                CommandExecutionError, r"'10.9.8.299' is not a valid IP address"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    extra_hosts=val,
                    validate_ip_addrs=True,
                )
        for val in ("foo:bar,baz:qux", ["foo:bar", "baz:qux"]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    extra_hosts=val,
                    validate_ip_addrs=False,
                ),
                {"extra_hosts": {"foo": "bar", "baz": "qux"}},
            )
    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_group_add(self):
        """
        Should be a list of strings or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_hostname(self):
        """
        Should be a string or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_ipc_mode(self):
        """
        Should be a string or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_isolation(self):
        """
        Should be a string or converted to one
        """
    @assert_labels(salt.utils.dockermod.translate.container)
    def test_labels(self):
        """
        Can be passed as a list of key=value pairs or a dictionary, and must
        ultimately end up as a dictionary.
        """
    @assert_key_colon_value(salt.utils.dockermod.translate.container)
    def test_links(self):
        """
        Can be passed as a list of key:value pairs or a dictionary, and must
        ultimately end up as a dictionary.
        """
    def test_log_config(self):
        """
        This is a mixture of log_driver and log_opt, which get combined into a
        dictionary.
        log_driver is a simple string, but log_opt can be passed in several
        ways, so we need to test them all.
        """
        expected = (
            {"log_config": {"Type": "foo", "Config": {"foo": "bar", "baz": "qux"}}},
            {},
            [],
        )
        for val in (
            "foo=bar,baz=qux",
            ["foo=bar", "baz=qux"],
            [{"foo": "bar"}, {"baz": "qux"}],
            {"foo": "bar", "baz": "qux"},
        ):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, log_driver="foo", log_opt="foo=bar,baz=qux"
                ),
                {"log_config": {"Type": "foo", "Config": {"foo": "bar", "baz": "qux"}}},
            )
        self.assertEqual(
            salt.utils.dockermod.translate_input(self.translator, log_driver="foo"),
            {"log_config": {"Type": "foo", "Config": {}}},
        )
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator, log_opt={"foo": "bar", "baz": "qux"}
            ),
            {"log_config": {"Type": "none", "Config": {"foo": "bar", "baz": "qux"}}},
        )
    @assert_key_equals_value(salt.utils.dockermod.translate.container)
    def test_lxc_conf(self):
        """
        Can be passed as a list of key=value pairs or a dictionary, and must
        ultimately end up as a dictionary.
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_mac_address(self):
        """
        Should be a string or converted to one
        """
    @assert_int_or_string(salt.utils.dockermod.translate.container)
    def test_mem_limit(self):
        """
        Should be a string or converted to one
        """
    @assert_int(salt.utils.dockermod.translate.container)
    def test_mem_swappiness(self):
        """
        Should be an int or converted to one
        """
    @assert_int_or_string(salt.utils.dockermod.translate.container)
    def test_memswap_limit(self):
        """
        Should be a string or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_name(self):
        """
        Should be a string or converted to one
        """
    @assert_bool(salt.utils.dockermod.translate.container)
    def test_network_disabled(self):
        """
        Should be a bool or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_network_mode(self):
        """
        Should be a string or converted to one
        """
    @assert_bool(salt.utils.dockermod.translate.container)
    def test_oom_kill_disable(self):
        """
        Should be a bool or converted to one
        """
    @assert_int(salt.utils.dockermod.translate.container)
    def test_oom_score_adj(self):
        """
        Should be an int or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_pid_mode(self):
        """
        Should be a string or converted to one
        """
    @assert_int(salt.utils.dockermod.translate.container)
    def test_pids_limit(self):
        """
        Should be an int or converted to one
        """
    def test_port_bindings(self):
        """
        This has several potential formats and can include port ranges. It
        needs its own test.
        """
        bindings = (
            "10.1.2.3:8080:80,10.1.2.3:8888:80,10.4.5.6:3333:3333,"
            "10.7.8.9:14505-14506:4505-4506,10.1.2.3:8080:81/udp,"
            "10.1.2.3:8888:81/udp,10.4.5.6:3334:3334/udp,"
            "10.7.8.9:15505-15506:5505-5506/udp"
        )
        for val in (bindings, bindings.split(",")):
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.translator,
                        port_bindings=val,
                    )
                ),
                {
                    "port_bindings": {
                        80: [("10.1.2.3", 8080), ("10.1.2.3", 8888)],
                        3333: ("10.4.5.6", 3333),
                        4505: ("10.7.8.9", 14505),
                        4506: ("10.7.8.9", 14506),
                        "81/udp": [("10.1.2.3", 8080), ("10.1.2.3", 8888)],
                        "3334/udp": ("10.4.5.6", 3334),
                        "5505/udp": ("10.7.8.9", 15505),
                        "5506/udp": ("10.7.8.9", 15506),
                    },
                    "ports": [
                        80,
                        3333,
                        4505,
                        4506,
                        (81, "udp"),
                        (3334, "udp"),
                        (5505, "udp"),
                        (5506</b></font>, "udp"),
                    ],
                },
            )
        bindings = (
            "10.1.2.3::80,10.1.2.3::80,10.4.5.6::3333,10.7.8.9::4505-4506,"
            "10.1.2.3::81/udp,10.1.2.3::81/udp,10.4.5.6::3334/udp,"
            "10.7.8.9::5505-5506/udp"
        )
        for val in (bindings, bindings.split(",")):
            self.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        port_bindings<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=val,
                    )
                ),
                {
                    "port_bindings": {
                        80: [("10.1.2.3",), ("10.1.2.3",)],
                        3333: ("10.4.5.6",),
                        4505: ("10.7.8.9",),
                        4506: ("10.7.8.9",),
                        "81/udp": [("10.1.2.3",), ("10.1.2.3",)],
                        "3334/udp": ("10.4.5.6",),
                        "5505/udp": ("10.7.8.9",),
                        "5506/udp": ("10.7.8.9",),
                    },
                    "ports": [
                        80,
                        3333,
                        4505,
                        4506,
                        (81, "udp"),
                        (3334, "udp"),
                        (5505, "udp"),
                        (5506</b></font>, "udp"),
                    ],
                },
            )
        bindings = (
            "8080:80,8888:80,3333:3333,14505-14506:4505-4506,8080:81/udp,"
            "8888:81/udp,3334:3334/udp,15505-15506:5505-5506/udp"
        )
        for val in (bindings, bindings.split(",")):
            self.assertEqual(
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        port_bindings=val,
                    )
                ),
                {
                    "port_bindings": {
                        80: [8080, 8888],
                        3333: 3333,
                        4505: 14505,
                        4506: 14506,
                        "81/udp": [8080, 8888],
                        "3334/udp": 3334,
                        "5505/udp": 15505,
                        "5506/udp": 15506,
                    },
                    "ports": [
                        80,
                        3333,
                        4505,
                        4506,
                        (81, "udp"),
                        (3334, "udp"),
                        (5505, "udp"),
                        (5506, "udp"),
                    ],
                },
            )
        bindings = "80,3333,4505-4506,81/udp,3334/udp,5505-5506/udp"
        for val in (bindings, bindings.split(",")):
            self.assertEqual(
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        port_bindings=val,
                    )
                ),
                {
                    "port_bindings": {
                        80: None,
                        3333: None,
                        4505: None,
                        4506: None,
                        "81/udp": None,
                        "3334/udp": None,
                        "5505/udp": None,
                        "5506/udp": None,
                    },
                    "ports": [
                        80,
                        3333,
                        4505,
                        4506,
                        (81, "udp"),
                        (3334, "udp"),
                        (5505, "udp"),
                        (5506, "udp"),
                    ],
                },
            )
        bindings = (
            "10.1.2.3:8080:80,10.4.5.6::3333,14505-14506:4505-4506,"
            "9999-10001,10.1.2.3:8080:81/udp,10.4.5.6::3334/udp,"
            "15505-15506:5505-5506/udp,19999-20001/udp"
        )
        for val in (bindings, bindings.split(",")):
            self.assertEqual(
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        port_bindings=val,
                ),
                {
                    <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"port_bindings": {
                        80: ("10.1.2.3", 8080),
                        3333: ("10.4.5.6",),
                        4505: 14505,
                        4506: 14506,
                        9999: None,
                        10000: None,
                        10001: None,
                        "81/udp": ("10.1.2.3", 8080),
                        "3334/udp": ("10.4.5.6",),
                        "5505/udp": 15505,
                        "5506/udp": 15506,
                        "19999/udp": None,
                        "20000/udp": None,
                        "20001/udp": None,
                    },
                    "ports": [
                        80,
                        3333,
                        4505,
                        4506,
                        9999,
                        10000,
                        10001,
                        (81, "udp"),
                        (3334, "udp"),
                        (5505, "udp"),
                        (5506, "udp"),
                        (19999, "udp"),
                        (20000, "udp"),
                        (20001</b></font>, "udp"),
                    ],
                },
            )
        with self.assertRaisesRegex(
            CommandExecutionError,
            r"'10.1.2.3:8080:80:123' is an invalid port binding "
            r"definition \(at most 3 components are allowed, found 4\)",
        ):
            salt.utils.dockermod.translate_input(
                self.translator, port_bindings="10.1.2.3:8080:80:123"
            )
        for val in (
            "10.1.2.3:5555-5554:1111-1112",
            "10.1.2.3:1111-1112:5555-5554",
            "10.1.2.3::5555-5554",
            "5555-5554:1111-1112",
            "1111-1112:5555-5554",
            "5555-5554",
        ):
            with self.assertRaisesRegex(
                CommandExecutionError,
                r"Start of port range \(5555\) cannot be greater than end "
                r"of port range \(5554\)",
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    port_bindings=val,
                )
        for val in (
            "10.1.2.3:foo:1111-1112",
            "10.1.2.3:1111-1112:foo",
            "10.1.2.3::foo",
            "foo:1111-1112",
            "1111-1112:foo",
            "foo",
        ):
            with self.assertRaisesRegex(
                CommandExecutionError, "'foo' is non-numeric or an invalid port range"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    port_bindings=val,
                )
        for val in ("10.1.2.3:1111-1113:1111-1112", "1111-1113:1111-1112"):
            with self.assertRaisesRegex(
                CommandExecutionError,
                r"Host port range \(1111-1113\) does not have the same "
                r"number of ports as the container port range \(1111-1112\)",
            ):
                salt.utils.dockermod.translate_input(self.translator, port_bindings=val)
        for val in ("10.1.2.3:1111-1112:1111-1113", "1111-1112:1111-1113"):
            with self.assertRaisesRegex(
                CommandExecutionError,
                r"Host port range \(1111-1112\) does not have the same "
                r"number of ports as the container port range \(1111-1113\)",
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    port_bindings=val,
                )
        with self.assertRaisesRegex(
            CommandExecutionError, "Empty host port in port binding definition ':1111'"
        ):
            salt.utils.dockermod.translate_input(self.translator, port_bindings=":1111")
        with self.assertRaisesRegex(
            CommandExecutionError,
            "Empty container port in port binding definition '1111:'",
        ):
            salt.utils.dockermod.translate_input(self.translator, port_bindings="1111:")
        with self.assertRaisesRegex(
            CommandExecutionError, "Empty port binding definition found"
        ):
            salt.utils.dockermod.translate_input(self.translator, port_bindings="")
    def test_ports(self):
        """
        Ports can be passed as a comma-separated or Python list of port
        numbers, with '/tcp' being optional for TCP ports. They must ultimately
        be a list of port definitions, in which an integer denotes a TCP port,
        and a tuple in the format (port_num, 'udp') denotes a UDP port. Also,
        the port numbers must end up as integers. None of the decorators will
        suffice so this one must be tested specially.
        """
        for val in (
            "1111,2222/tcp,3333/udp,4505-4506",
            [1111, "2222/tcp", "3333/udp", "4505-4506"],
            ["1111", "2222/tcp", "3333/udp", "4505-4506"],
        ):
            self.assertEqual(
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        ports=val,
                    )
                ),
                {"ports": [1111, 2222, 4505, 4506, (3333, "udp")]},
            )
        for val in (1.0, [1.0]):
            with self.assertRaisesRegex(
                CommandExecutionError, "'1.0' is not a valid port definition"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    ports=val,
                )
        with self.assertRaisesRegex(
            CommandExecutionError,
            r"Start of port range \(5555\) cannot be greater than end of "
            r"port range \(5554\)",
        ):
            salt.utils.dockermod.translate_input(
                self.translator,
                ports="5555-5554",
            )
    @assert_bool(salt.utils.dockermod.translate.container)
    def test_privileged(self):
        """
        Should be a bool or converted to one
        """
    @assert_bool(salt.utils.dockermod.translate.container)
    def test_publish_all_ports(self):
        """
        Should be a bool or converted to one
        """
    @assert_bool(salt.utils.dockermod.translate.container)
    def test_read_only(self):
        """
        Should be a bool or converted to one
        """
    def test_restart_policy(self):
        """
        Input is in the format "name[:retry_count]", but the API wants it
        in the format {'Name': name, 'MaximumRetryCount': retry_count}
        """
        name = "restart_policy"
        alias = "restart"
        for item in (name, alias):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: "on-failure:5"}
                ),
                {name: {"Name": "on-failure", "MaximumRetryCount": 5}},
            )
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: "on-failure"}
                ),
                {name: {"Name": "on-failure", "MaximumRetryCount": 0}},
            )
            with self.assertRaisesRegex(
                CommandExecutionError, "Only one policy is permitted"
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: "on-failure,always"}
                )
        test_kwargs = {name: "on-failure:5", alias: "always"}
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator, ignore_collisions=True, **test_kwargs
            ),
            {name: {"Name": "on-failure", "MaximumRetryCount": 5}},
        )
        with self.assertRaisesRegex(
            CommandExecutionError, "'restart' is an alias for 'restart_policy'"
        ):
            salt.utils.dockermod.translate_input(
                self.translator, ignore_collisions=False, **test_kwargs
            )
    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_security_opt(self):
        """
        Should be a list of strings or converted to one
        """
    @assert_int_or_string(salt.utils.dockermod.translate.container)
    def test_shm_size(self):
        """
        Should be a string or converted to one
        """
    @assert_bool(salt.utils.dockermod.translate.container)
    def test_stdin_open(self):
        """
        Should be a bool or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_stop_signal(self):
        """
        Should be a string or converted to one
        """
    @assert_int(salt.utils.dockermod.translate.container)
    def test_stop_timeout(self):
        """
        Should be an int or converted to one
        """
    @assert_key_equals_value(salt.utils.dockermod.translate.container)
    def test_storage_opt(self):
        """
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        """
    @assert_key_equals_value(salt.utils.dockermod.translate.container)
    def test_sysctls(self):
        """
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        """
    @assert_dict(salt.utils.dockermod.translate.container)
    def test_tmpfs(self):
        """
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        """
    @assert_bool(salt.utils.dockermod.translate.container)
    def test_tty(self):
        """
        Should be a bool or converted to one
        """
    def test_ulimits(self):
        """
        Input is in the format "name=soft_limit[:hard_limit]", but the API
        wants it in the format
        {'Name': name, 'Soft': soft_limit, 'Hard': hard_limit}
        """
        ulimits = "nofile=1024:2048,nproc=50"
        for val in (ulimits, ulimits.split(",")):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    ulimits=val,
                ),
                {
                    "ulimits": [
                        {"Name": "nofile", "Soft": 1024, "Hard": 2048},
                        {"Name": "nproc", "Soft": 50, "Hard": 50},
                    ]
                },
            )
        with self.assertRaisesRegex(
            CommandExecutionError,
            r"Ulimit definition 'nofile:1024:2048' is not in the format "
            r"type=soft_limit\[:hard_limit\]",
        ):
            salt.utils.dockermod.translate_input(
                self.translator, ulimits="nofile:1024:2048"
            )
        with self.assertRaisesRegex(
            CommandExecutionError,
            r"Limit 'nofile=foo:2048' contains non-numeric value\(s\)",
        ):
            salt.utils.dockermod.translate_input(
                self.translator, ulimits="nofile=foo:2048"
            )
    def test_user(self):
        """
        Must be either username (string) or uid (int). An int passed as a
        string (e.g. '0') should be converted to an int.
        """
        self.assertEqual(
            salt.utils.dockermod.translate_input(self.translator, user="foo"),
            {"user": "foo"},
        )
        for val in (0, "0"):
            self.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, user=val),
                {"user": 0},
            )
        with self.assertRaisesRegex(
            CommandExecutionError, "Value must be a username or uid"
        ):
            salt.utils.dockermod.translate_input(self.translator, user=["foo"])
        with self.assertRaisesRegex(CommandExecutionError, "'-1' is an invalid uid"):
            salt.utils.dockermod.translate_input(self.translator, user=-1)
    @assert_string(salt.utils.dockermod.translate.container)
    def test_userns_mode(self):
        """
        Should be a bool or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_volume_driver(self):
        """
        Should be a bool or converted to one
        """
    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_volumes(self):
        """
        Should be a list of absolute paths
        """
        path = os.path.join("foo", "bar", "baz")
        with self.assertRaisesRegex(
            CommandExecutionError,
            "'{}' is not an absolute path".format(path.replace("\\", "\\\\")),
        ):
            salt.utils.dockermod.translate_input(self.translator, volumes=path)
    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_volumes_from(self):
        """
        Should be a list of strings or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.container)
    def test_working_dir(self):
        """
        Should be a single absolute path
        """
        path = os.path.join("foo", "bar", "baz")
        with self.assertRaisesRegex(
            CommandExecutionError,
            "'{}' is not an absolute path".format(path.replace("\\", "\\\\")),
        ):
            salt.utils.dockermod.translate_input(self.translator, working_dir=path)
class TranslateNetworkInputTestCase(TranslateBase):
    """
    Tests for salt.utils.dockermod.translate_input(), invoked using
    salt.utils.dockermod.translate.network as the translator module.
    """
    translator = salt.utils.dockermod.translate.network
    ip_addrs = {
        True: ("10.1.2.3", "::1"),
        False: ("FOO", "0.9.800.1000", "feaz::1", "aj01::feac"),
    }
    @assert_string(salt.utils.dockermod.translate.network)
    def test_driver(self):
        """
        Should be a string or converted to one
        """
    @assert_key_equals_value(salt.utils.dockermod.translate.network)
    def test_options(self):
        """
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        """
    @assert_dict(salt.utils.dockermod.translate.network)
    def test_ipam(self):
        """
        Must be a dict
        """
    @assert_bool(salt.utils.dockermod.translate.network)
    def test_check_duplicate(self):
        """
        Should be a bool or converted to one
        """
    @assert_bool(salt.utils.dockermod.translate.network)
    def test_internal(self):
        """
        Should be a bool or converted to one
        """
    @assert_labels(salt.utils.dockermod.translate.network)
    def test_labels(self):
        """
        Can be passed as a list of key=value pairs or a dictionary, and must
        ultimately end up as a dictionary.
        """
    @assert_bool(salt.utils.dockermod.translate.network)
    def test_enable_ipv6(self):
        """
        Should be a bool or converted to one
        """
    @assert_bool(salt.utils.dockermod.translate.network)
    def test_attachable(self):
        """
        Should be a bool or converted to one
        """
    @assert_bool(salt.utils.dockermod.translate.network)
    def test_ingress(self):
        """
        Should be a bool or converted to one
        """
    @assert_string(salt.utils.dockermod.translate.network)
    def test_ipam_driver(self):
        """
        Should be a bool or converted to one
        """
    @assert_key_equals_value(salt.utils.dockermod.translate.network)
    def test_ipam_opts(self):
        """
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        """
    def ipam_pools(self):
        """
        Must be a list of dictionaries (not a dictlist)
        """
        good_pool = {
            "subnet": "10.0.0.0/24",
            "iprange": "10.0.0.128/25",
            "gateway": "10.0.0.254",
            "aux_addresses": {
                "foo.bar.tld": "10.0.0.20",
                "hello.world.tld": "10.0.0.21",
            },
        }
        bad_pools = [
            {
                "subnet": "10.0.0.0/33",
                "iprange": "10.0.0.128/25",
                "gateway": "10.0.0.254",
                "aux_addresses": {
                    "foo.bar.tld": "10.0.0.20",
                    "hello.world.tld": "10.0.0.21",
                },
            },
            {
                "subnet": "10.0.0.0/24",
                "iprange": "foo/25",
                "gateway": "10.0.0.254",
                "aux_addresses": {
                    "foo.bar.tld": "10.0.0.20",
                    "hello.world.tld": "10.0.0.21",
                },
            },
            {
                "subnet": "10.0.0.0/24",
                "iprange": "10.0.0.128/25",
                "gateway": "10.0.0.256",
                "aux_addresses": {
                    "foo.bar.tld": "10.0.0.20",
                    "hello.world.tld": "10.0.0.21",
                },
            },
            {
                "subnet": "10.0.0.0/24",
                "iprange": "10.0.0.128/25",
                "gateway": "10.0.0.254",
                "aux_addresses": {
                    "foo.bar.tld": "10.0.0.20",
                    "hello.world.tld": "999.0.0.21",
                },
            },
        ]
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator,
                ipam_pools=[good_pool],
            ),
            {"ipam_pools": [good_pool]},
        )
        for bad_pool in bad_pools:
            with self.assertRaisesRegex(CommandExecutionError, "not a valid"):
                salt.utils.dockermod.translate_input(
                    self.translator, ipam_pools=[good_pool, bad_pool]
                )
    @assert_subnet(salt.utils.dockermod.translate.network)
    def test_subnet(self):
        """
        Must be an IPv4 or IPv6 subnet
        """
    @assert_subnet(salt.utils.dockermod.translate.network)
    def test_iprange(self):
        """
        Must be an IPv4 or IPv6 subnet
        """
    def test_gateway(self):
        """
        Must be an IPv4 or IPv6 address
        """
        for val in self.ip_addrs[True]:
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=True,
                    gateway=val,
                ),
                self.apply_defaults({"gateway": val}),
            )
        for val in self.ip_addrs[False]:
            with self.assertRaisesRegex(
                CommandExecutionError, "'{}' is not a valid IP address".format(val)
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=True,
                    gateway=val,
                )
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=False,
                    gateway=val,
                ),
                self.apply_defaults(
                    {"gateway": val if isinstance(val, str) else str(val)}
                ),
            )
    @assert_key_equals_value(salt.utils.dockermod.translate.network)
    def test_aux_addresses(self):
        """
        Must be a mapping of hostnames to IP addresses
        """
        name = "aux_addresses"
        alias = "aux_address"
        for item in (name, alias):
            for val in self.ip_addrs[True]:
                addresses = {"foo.bar.tld": val}
                self.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=True, **{item: addresses}
                    ),
                    self.apply_defaults({name: addresses}),
                )
            for val in self.ip_addrs[False]:
                addresses = {"foo.bar.tld": val}
                with self.assertRaisesRegex(
                    CommandExecutionError, "'{}' is not a valid IP address".format(val)
                ):
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=True, **{item: addresses}
                    )
                self.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        validate_ip_addrs=False,
                        aux_addresses=addresses,
                    ),
                    self.apply_defaults({name: addresses}),
                )
class DockerTranslateHelperTestCase(TestCase):
    """
    Tests for a couple helper functions in salt.utils.dockermod.translate
    """
    def test_get_port_def(self):
        """
        Test translation of port definition (1234, '1234/tcp', '1234/udp',
        etc.) into the format which docker-py uses (integer for TCP ports,
        """
        self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(translate_helpers.get_port_def(2222), 2222)
        self.assertEqual(translate_helpers.get_port_def("2222"), 2222)
        self.assertEqual(translate_helpers.get_port_def("2222", "tcp"), 2222)
        self.assertEqual(translate_helpers.get_port_def("2222/tcp", "udp"), 2222)
        self.assertEqual(translate_helpers.get_port_def(</b></font>2222, "udp"), (2222, "udp"))
        self.assertEqual(translate_helpers.get_port_def("2222", "udp"), (2222, "udp"))
        self.assertEqual(translate_helpers.get_port_def("2222/udp"), (2222, "udp"))
    def test_get_port_range(self):
        """
        Test extracting the start and end of a port range from a port range
        expression (e.g. 4505-4506)
        """
        self.assertEqual(translate_helpers.get_port_range(2222), (2222, 2222))
        self.assertEqual(translate_helpers.get_port_range("2222"), (2222, 2222))
        self.assertEqual(translate_helpers.get_port_range("2222-2223"), (2222, 2223))
        with self.assertRaisesRegex(
            ValueError,
            r"Start of port range \(2222\) cannot be greater than end of "
            r"port range \(2221\)",
        ):
            translate_helpers.get_port_range("2222-2221")
        with self.assertRaisesRegex(
            ValueError, "'2222-bar' is non-numeric or an invalid port range"
        ):
            translate_helpers.get_port_range("2222-bar")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
