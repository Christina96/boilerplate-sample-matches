<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_reactor_2.py &amp; test_dockermod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_reactor_2.py &amp; test_dockermod.py
      </h3>
<h1 align="center">
        5.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_reactor_2.py (19.426048%)<th>test_dockermod.py (3.319502%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(270-330)<td><a href="#" name="0">(1226-1249)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(145-216)<td><a href="#" name="1">(1266-1288)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(49-135)<td><a href="#" name="2">(2013-2025)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(216-256)<td><a href="#" name="3">(1381-1411)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(2-16)<td><a href="#" name="4">(8-22)</a><td align="center"><font color="#9d0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_reactor_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="4"></a>import codecs
2 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import glob
3 import logging
4 import os
5 import textwrap
6 import salt.loader
7 import salt.utils.data
8 import salt.utils.files
9 import salt.utils.reactor as reactor
10 import salt.utils.yaml
11 from tests.support.mixins import AdaptedConfigurationTestCaseMixin
12 from tests.support.mock import MagicMock, Mock, mock_open, patch
13 from tests.support.unit import TestCase
14 REACTOR_CONFIG =</b></font> """\
15 reactor:
16   - old_runner:
17     - /srv/reactor/old_runner.sls
18   - old_wheel:
19     - /srv/reactor/old_wheel.sls
20   - old_local:
21     - /srv/reactor/old_local.sls
22   - old_cmd:
23     - /srv/reactor/old_cmd.sls
24   - old_caller:
25     - /srv/reactor/old_caller.sls
26   - new_runner:
27     - /srv/reactor/new_runner.sls
28   - new_wheel:
29     - /srv/reactor/new_wheel.sls
30   - new_local:
31     - /srv/reactor/new_local.sls
32   - new_cmd:
33     - /srv/reactor/new_cmd.sls
34   - new_caller:
35     - /srv/reactor/new_caller.sls
36     "/srv/reactor/old_runner.sls": textwrap<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dedent(
37     ),
38     "/srv/reactor/old_wheel.sls": textwrap.dedent(
39     ),
40     "/srv/reactor/old_local.sls": textwrap.dedent(
41     ),
42     "/srv/reactor/old_cmd.sls": textwrap.dedent(
43     ),
44     "/srv/reactor/old_caller.sls": textwrap.dedent(
45     ),
46     "/srv/reactor/new_runner.sls": textwrap.dedent(
47     ),
48     "/srv/reactor/new_wheel.sls": textwrap.dedent(
49     ),
50     "/srv/reactor/new_local.sls": textwrap.dedent(
51     ),
52     "/srv/reactor/new_cmd.sls": textwrap.dedent(
53     ),
54     "/srv/reactor/new_caller.sls": textwrap.dedent(</b></font>
55 <a name="1"></a>    ),
56 }
57 LOW_CHUNKS <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
58     "old_runner": [
59         {
60             "state": "runner",
61             "__id__": "raise_error",
62             "__sls__": "/srv/reactor/old_runner.sls",
63             "order": 1,
64             "fun": "error.error",
65             "name": "Exception",
66             "message": "This is an error",
67         }
68     ],
69     "old_wheel": [
70         {
71             "state": "wheel",
72             "__id__": "remove_key",
73             "name": "remove_key",
74             "__sls__": "/srv/reactor/old_wheel.sls",
75             "order": 1,
76             "fun": "key.delete",
77             "match": "foo",
78         }
79     ],
80     "old_local": [
81         {
82             "state": "local",
83             "__id__": "install_zsh",
84             "name": "install_zsh",
85             "__sls__": "/srv/reactor/old_local.sls",
86             "order": 1,
87             "tgt": "test",
88             "fun": "state.single",
89             "arg": ["pkg.installed", "zsh"],
90             "kwarg": {"fromrepo": "updates"},
91         }
92     ],
93     "old_cmd": [
94         {
95             "state": "local",  # 'cmd' should be aliased to 'local'
96             "__id__": "install_zsh",
97             "name": "install_zsh",
98             "__sls__": "/srv/reactor/old_cmd.sls",
99             "order": 1,
100             "tgt": "test",
101             "fun": "state.single",
102             "arg": ["pkg.installed", "zsh"],
103             "kwarg": {"fromrepo": "updates"},
104         }
105     ],
106     "old_caller": [
107         {
108             "state": "caller",
109             "__id__": "touch_file",
110             "name": "touch_file",
111             "__sls__": "/srv/reactor/old_caller.sls",
112             "order": 1,
113             "fun": "file.touch",
114             "args": ["/tmp/foo"],
115         }
116     ],
117     "new_runner": [
118         {
119             "state": "runner",
120             "__id__": "raise_error",
121             "name": "raise_error",
122 <a name="3"></a>            "__sls__": "/srv/reactor/new_runner.sls",
123             "order": 1,
124             "fun": "error.error",
125             "args": [{"name"</b></font>: "Exception"}, {<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"message": "This is an error"}],
126         }
127     ],
128     "new_wheel": [
129         {
130             "state": "wheel",
131             "__id__": "remove_key",
132             "name": "remove_key",
133             "__sls__": "/srv/reactor/new_wheel.sls",
134             "order": 1,
135             "fun": "key.delete",
136             "args": [{"match": "foo"}],
137         }
138     ],
139     "new_local": [
140         {
141             "state": "local",
142             "__id__": "install_zsh",
143             "name": "install_zsh",
144             "__sls__": "/srv/reactor/new_local.sls",
145             "order": 1,
146             "tgt": "test",
147             "fun": "state.single",
148             "args": [
149                 {"fun": "pkg.installed"},
150                 {"name": "zsh"},
151                 {"fromrepo": "updates"},
152             ],
153         }
154     ],
155     "new_cmd": [
156         {
157             "state": "local",
158             "__id__": "install_zsh",
159             "name": "install_zsh",
160             "__sls__": "/srv/reactor/new_cmd.sls",
161             "order": 1,
162             "tgt": "test",
163             "fun": "state.single",
164             "args": [
165                 {"fun"</b></font>: "pkg.installed"},
166                 {"name": "zsh"},
167                 {"fromrepo": "updates"},
168             ],
169         }
170     ],
171     "new_caller": [
172         {
173             "state": "caller",
174             "__id__": "touch_file",
175             "name": "touch_file",
176 <a name="0"></a>            "__sls__": "/srv/reactor/new_caller.sls",
177             "order": 1,
178             "fun": "file.touch",
179             "args": [{<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"name": "/tmp/foo"}],
180         }
181     ],
182 }
183 WRAPPER_CALLS = {
184     "old_runner": (
185         "error.error",
186         {
187             "__state__": "runner",
188             "__id__": "raise_error",
189             "__sls__": "/srv/reactor/old_runner.sls",
190             "__user__": "Reactor",
191             "order": 1,
192             "arg": [],
193             "kwarg": {"name": "Exception", "message": "This is an error"},
194             "name": "Exception",
195             "message": "This is an error",
196         },
197     ),
198     "old_wheel": (
199         "key.delete",
200         {
201             "__state__": "wheel",
202             "__id__": "remove_key",
203             "name": "remove_key",
204             "__sls__": "/srv/reactor/old_wheel.sls",
205             "order": 1,
206             "__user__": "Reactor",
207             "arg": ["foo"],
208             "kwarg": {},
209             "match": "foo",
210         },
211     ),
212     "old_local": {
213         "args": ("test", "state.single"),
214         "kwargs": {
215             "state": "local",
216             "__id__": "install_zsh",
217             "name": "install_zsh",
218             "__sls__": "/srv/reactor/old_local.sls",
219             "order": 1,
220             "arg": ["pkg.installed", "zsh"],
221             "kwarg": {"fromrepo": "updates"},
222         },
223     },
224     "old_cmd": {
225         "args": ("test", "state.single"),
226         "kwargs": {
227             "state": "local",
228             "__id__": "install_zsh",
229             "name": "install_zsh",
230             "__sls__": "/srv/reactor/old_cmd.sls",
231             "order": 1,
232             "arg": ["pkg.installed", "zsh"],
233             "kwarg": {"fromrepo": "updates"},
234         },
235     },
236     "old_caller": {"args": ("file.touch", "/tmp/foo"), "kwargs": {}},
237     "new_runner": (
238         "error.error"</b></font>,
239         {
240             "__state__": "runner",
241             "__id__": "raise_error",
242             "name": "raise_error",
243             "__sls__": "/srv/reactor/new_runner.sls",
244             "__user__": "Reactor",
245             "order": 1,
246             "arg": (),
247             "kwarg": {"name": "Exception", "message": "This is an error"},
248         },
249     ),
250     "new_wheel": (
251         "key.delete",
252         {
253             "__state__": "wheel",
254             "__id__": "remove_key",
255             "name": "remove_key",
256             "__sls__": "/srv/reactor/new_wheel.sls",
257             "order": 1,
258             "__user__": "Reactor",
259             "arg": (),
260             "kwarg": {"match": "foo"},
261         },
262     ),
263     "new_local": {
264         "args": ("test", "state.single"),
265         "kwargs": {
266             "state": "local",
267             "__id__": "install_zsh",
268             "name": "install_zsh",
269             "__sls__": "/srv/reactor/new_local.sls",
270             "order": 1,
271             "arg": (),
272             "kwarg": {"fun": "pkg.installed", "name": "zsh", "fromrepo": "updates"},
273         },
274     },
275     "new_cmd": {
276         "args": ("test", "state.single"),
277         "kwargs": {
278             "state": "local",
279             "__id__": "install_zsh",
280             "name": "install_zsh",
281             "__sls__": "/srv/reactor/new_cmd.sls",
282             "order": 1,
283             "arg": (),
284             "kwarg": {"fun": "pkg.installed", "name": "zsh", "fromrepo": "updates"},
285         },
286     },
287     "new_caller": {"args": ("file.touch",), "kwargs": {"name": "/tmp/foo"}},
288 }
289 log = logging.getLogger(__name__)
290 class TestReactor(TestCase, AdaptedConfigurationTestCaseMixin):
291     @classmethod
292     def setUpClass(cls):
293         cls.opts = cls.get_temp_config("master")
294         reactor_config = salt.utils.yaml.safe_load(REACTOR_CONFIG)
295         cls.opts.update(reactor_config)
296         cls.reactor = reactor.Reactor(cls.opts)
297         cls.reaction_map = salt.utils.data.repack_dictlist(reactor_config["reactor"])
298         renderers = salt.loader.render(cls.opts, {})
299         cls.render_pipe = [(renderers[x], "") for x in ("jinja", "yaml")]
300     @classmethod
301     def tearDownClass(cls):
302         del cls.opts
303         del cls.reactor
304         del cls.render_pipe
305     def test_list_reactors(self):
306         for schema in ("old", "new"):
307             for rtype in REACTOR_DATA:
308                 tag = "_".join((schema, rtype))
309                 self.assertEqual(
310                     self.reactor.list_reactors(tag), self.reaction_map[tag]
311                 )
312     def test_reactions(self):
313         for schema in ("old", "new"):
314             for rtype in REACTOR_DATA:
315                 tag = "_".join((schema, rtype))
316                 log.debug("test_reactions: processing %s", tag)
317                 reactors = self.reactor.list_reactors(tag)
318                 log.debug("test_reactions: %s reactors: %s", tag, reactors)
319                 with patch.object(glob, "glob", MagicMock(side_effect=lambda x: [x])):
320                     with patch.object(os.path, "isfile", MagicMock(return_value=True)):
321                         with patch.object(
322                             salt.utils.files, "is_empty", MagicMock(return_value=False)
323                         ):
324                             with patch.object(
325                                 codecs, "open", mock_open(read_data=SLS[reactors[0]])
326                             ):
327                                 with patch.object(
328                                     salt.template,
329                                     "template_shebang",
330                                     MagicMock(return_value=self.render_pipe),
331                                 ):
332                                     reactions = self.reactor.reactions(
333                                         tag,
334                                         REACTOR_DATA[rtype],
335                                         reactors,
336                                     )
337                                     log.debug(
338                                         "test_reactions: %s reactions: %s",
339                                         tag,
340                                         reactions,
341                                     )
342                                     self.assertEqual(reactions, LOW_CHUNKS[tag])
343 class TestReactWrap(TestCase, AdaptedConfigurationTestCaseMixin):
344     @classmethod
345     def setUpClass(cls):
346         cls.wrap = reactor.ReactWrap(cls.get_temp_config("master"))
347     @classmethod
348     def tearDownClass(cls):
349         del cls.wrap
350     def test_runner(self):
351         for schema in ("old", "new"):
352             tag = "_".join((schema, "runner"))
353             chunk = LOW_CHUNKS[tag][0]
354             thread_pool = Mock()
355             thread_pool.fire_async = Mock()
356             with patch.object(self.wrap, "pool", thread_pool):
357                 self.wrap.run(chunk)
358             thread_pool.fire_async.assert_called_with(
359                 self.wrap.client_cache["runner"].low, args=WRAPPER_CALLS[tag]
360             )
361     def test_wheel(self):
362         for schema in ("old", "new"):
363             tag = "_".join((schema, "wheel"))
364             chunk = LOW_CHUNKS[tag][0]
365             thread_pool = Mock()
366             thread_pool.fire_async = Mock()
367             with patch.object(self.wrap, "pool", thread_pool):
368                 self.wrap.run(chunk)
369             thread_pool.fire_async.assert_called_with(
370                 self.wrap.client_cache["wheel"].low, args=WRAPPER_CALLS[tag]
371             )
372     def test_local(self):
373         for schema in ("old", "new"):
374             tag = "_".join((schema, "local"))
375             chunk = LOW_CHUNKS[tag][0]
376             client_cache = {"local": Mock()}
377             client_cache["local"].cmd_async = Mock()
378             with patch.object(self.wrap, "client_cache", client_cache):
379                 self.wrap.run(chunk)
380             client_cache["local"].cmd_async.assert_called_with(
381                 *WRAPPER_CALLS[tag]["args"], **WRAPPER_CALLS[tag]["kwargs"]
382             )
383     def test_cmd(self):
384         for schema in ("old", "new"):
385             tag = "_".join((schema, "cmd"))
386             chunk = LOW_CHUNKS[tag][0]
387             client_cache = {"local": Mock()}
388             client_cache["local"].cmd_async = Mock()
389             with patch.object(self.wrap, "client_cache", client_cache):
390                 self.wrap.run(chunk)
391             client_cache["local"].cmd_async.assert_called_with(
392                 *WRAPPER_CALLS[tag]["args"], **WRAPPER_CALLS[tag]["kwargs"]
393             )
394     def test_caller(self):
395         for schema in ("old", "new"):
396             tag = "_".join((schema, "caller"))
397             chunk = LOW_CHUNKS[tag][0]
398             client_cache = {"caller": Mock()}
399             client_cache["caller"].cmd = Mock()
400             with patch.object(self.wrap, "client_cache", client_cache):
401                 self.wrap.run(chunk)
402             client_cache["caller"].cmd.assert_called_with(
403                 *WRAPPER_CALLS[tag]["args"], **WRAPPER_CALLS[tag]["kwargs"]
404             )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_dockermod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
2 import functools
3 import logging
4 import os
5 import salt.config
6 import salt.loader
7 import salt.utils.dockermod.translate.container
8 import salt.utils.dockermod.translate.network
9 import salt.utils.platform
10 from salt.exceptions import CommandExecutionError
11 from salt.utils.dockermod.translate import helpers as translate_helpers
12 from tests.support.unit import TestCase
13 log =</b></font> logging.getLogger(__name__)
14 class Assert:
15     def __init__(self, translator):
16         self.translator = translator
17     def __call__(self, func):
18         self.func = func
19         return functools.wraps(func)(
20             lambda testcase, *args, **kwargs: self.wrap(testcase, *args, **kwargs)
21         )
22     def wrap(self, *args, **kwargs):
23         raise NotImplementedError
24     def test_stringlist(self, testcase, name):
25         alias = self.translator.ALIASES_REVMAP.get(name)
26         if salt.utils.platform.is_windows():
27             data = [r"c:\foo", r"c:\bar", r"c:\baz"]
28         else:
29             data = ["/foo", "/bar", "/baz"]
30         for item in (name, alias):
31             if item is None:
32                 continue
33             testcase.assertEqual(
34                 salt.utils.dockermod.translate_input(
35                     self.translator, **{item: ",".join(data)}
36                 ),
37                 testcase.apply_defaults({name: data}),
38             )
39             testcase.assertEqual(
40                 salt.utils.dockermod.translate_input(self.translator, **{item: data}),
41                 testcase.apply_defaults({name: data}),
42             )
43             if name != "volumes":
44                 testcase.assertEqual(
45                     salt.utils.dockermod.translate_input(
46                         self.translator, **{item: ["one", 2]}
47                     ),
48                     testcase.apply_defaults({name: ["one", "2"]}),
49                 )
50         if alias is not None:
51             test_kwargs = {name: data, alias: sorted(data)}
52             testcase.assertEqual(
53                 salt.utils.dockermod.translate_input(
54                     self.translator, ignore_collisions=True, **test_kwargs
55                 ),
56                 testcase.apply_defaults({name: test_kwargs[name]}),
57             )
58             with testcase.assertRaisesRegex(
59                 CommandExecutionError, "is an alias for.+cannot both be used"
60             ):
61                 salt.utils.dockermod.translate_input(
62                     self.translator, ignore_collisions=False, **test_kwargs
63                 )
64     def test_key_value(self, testcase, name, delimiter):
65         alias = self.translator.ALIASES_REVMAP.get(name)
66         expected = {"foo": "bar", "baz": "qux"}
67         vals = "foo{0}bar,baz{0}qux".format(delimiter)
68         for item in (name, alias):
69             if item is None:
70                 continue
71             for val in (vals, vals.split(",")):
72                 testcase.assertEqual(
73                     salt.utils.dockermod.translate_input(
74                         self.translator, validate_ip_addrs=False, **{item: val}
75                     ),
76                     testcase.apply_defaults({name: expected}),
77                 )
78             testcase.assertEqual(
79                 salt.utils.dockermod.translate_input(
80                     self.translator, validate_ip_addrs=False, **{item: expected}
81                 ),
82                 testcase.apply_defaults({name: expected}),
83             )
84             testcase.assertEqual(
85                 salt.utils.dockermod.translate_input(
86                     self.translator,
87                     validate_ip_addrs=False,
88                     **{item: [{"foo": "bar"}, {"baz": "qux"}]}
89                 ),
90                 testcase.apply_defaults({name: expected}),
91             )
92         if alias is not None:
93             test_kwargs = {name: vals, alias: "hello{}world".format(delimiter)}
94             testcase.assertEqual(
95                 salt.utils.dockermod.translate_input(
96                     self.translator,
97                     validate_ip_addrs=False,
98                     ignore_collisions=True,
99                     **test_kwargs
100                 ),
101                 testcase.apply_defaults({name: expected}),
102             )
103             with testcase.assertRaisesRegex(
104                 CommandExecutionError, "is an alias for.+cannot both be used"
105             ):
106                 salt.utils.dockermod.translate_input(
107                     self.translator,
108                     validate_ip_addrs=False,
109                     ignore_collisions=False,
110                     **test_kwargs
111                 )
112 class assert_bool(Assert):
113     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
114         name = self.func.__name__[5:]
115         alias = self.translator.ALIASES_REVMAP.get(name)
116         for item in (name, alias):
117             if item is None:
118                 continue
119             testcase.assertEqual(
120                 salt.utils.dockermod.translate_input(self.translator, **{item: True}),
121                 testcase.apply_defaults({name: True}),
122             )
123             testcase.assertEqual(
124                 salt.utils.dockermod.translate_input(self.translator, **{item: "foo"}),
125                 testcase.apply_defaults({name: True}),
126             )
127             testcase.assertEqual(
128                 salt.utils.dockermod.translate_input(self.translator, **{item: 0}),
129                 testcase.apply_defaults({name: False}),
130             )
131         if alias is not None:
132             test_kwargs = {name: True, alias: False}
133             testcase.assertEqual(
134                 salt.utils.dockermod.translate_input(
135                     self.translator, ignore_collisions=True, **test_kwargs
136                 ),
137                 testcase.apply_defaults({name: test_kwargs[name]}),
138             )
139             with testcase.assertRaisesRegex(
140                 CommandExecutionError, "is an alias for.+cannot both be used"
141             ):
142                 salt.utils.dockermod.translate_input(
143                     self.translator, ignore_collisions=False, **test_kwargs
144                 )
145         return self.func(testcase, *args, **kwargs)
146 class assert_int(Assert):
147     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
148         name = self.func.__name__[5:]
149         alias = self.translator.ALIASES_REVMAP.get(name)
150         for item in (name, alias):
151             if item is None:
152                 continue
153             for val in (100, "100"):
154                 testcase.assertEqual(
155                     salt.utils.dockermod.translate_input(
156                         self.translator, **{item: val}
157                     ),
158                     testcase.apply_defaults({name: 100}),
159                 )
160             with testcase.assertRaisesRegex(
161                 CommandExecutionError, "'foo' is not an integer"
162             ):
163                 salt.utils.dockermod.translate_input(self.translator, **{item: "foo"})
164         if alias is not None:
165             test_kwargs = {name: 100, alias: 200}
166             testcase.assertEqual(
167                 salt.utils.dockermod.translate_input(
168                     self.translator, ignore_collisions=True, **test_kwargs
169                 ),
170                 testcase.apply_defaults({name: test_kwargs[name]}),
171             )
172             with testcase.assertRaisesRegex(
173                 CommandExecutionError, "is an alias for.+cannot both be used"
174             ):
175                 salt.utils.dockermod.translate_input(
176                     self.translator, ignore_collisions=False, **test_kwargs
177                 )
178         return self.func(testcase, *args, **kwargs)
179 class assert_string(Assert):
180     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
181         name = self.func.__name__[5:]
182         alias = self.translator.ALIASES_REVMAP.get(name)
183         if salt.utils.platform.is_windows():
184             data = r"c:\foo"
185         else:
186             data = "/foo"
187         for item in (name, alias):
188             if item is None:
189                 continue
190             testcase.assertEqual(
191                 salt.utils.dockermod.translate_input(self.translator, **{item: data}),
192                 testcase.apply_defaults({name: data}),
193             )
194             if name != "working_dir":
195                 testcase.assertEqual(
196                     salt.utils.dockermod.translate_input(
197                         self.translator, **{item: 123}
198                     ),
199                     testcase.apply_defaults({name: "123"}),
200                 )
201         if alias is not None:
202             test_kwargs = {name: data, alias: data}
203             testcase.assertEqual(
204                 salt.utils.dockermod.translate_input(
205                     self.translator, ignore_collisions=True, **test_kwargs
206                 ),
207                 testcase.apply_defaults({name: test_kwargs[name]}),
208             )
209             with testcase.assertRaisesRegex(
210                 CommandExecutionError, "is an alias for.+cannot both be used"
211             ):
212                 salt.utils.dockermod.translate_input(
213                     self.translator, ignore_collisions=False, **test_kwargs
214                 )
215         return self.func(testcase, *args, **kwargs)
216 class assert_int_or_string(Assert):
217     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
218         name = self.func.__name__[5:]
219         alias = self.translator.ALIASES_REVMAP.get(name)
220         for item in (name, alias):
221             if item is None:
222                 continue
223             testcase.assertEqual(
224                 salt.utils.dockermod.translate_input(self.translator, **{item: 100}),
225                 testcase.apply_defaults({name: 100}),
226             )
227             testcase.assertEqual(
228                 salt.utils.dockermod.translate_input(self.translator, **{item: "100M"}),
229                 testcase.apply_defaults({name: "100M"}),
230             )
231         if alias is not None:
232             test_kwargs = {name: 100, alias: "100M"}
233             testcase.assertEqual(
234                 salt.utils.dockermod.translate_input(
235                     self.translator, ignore_collisions=True, **test_kwargs
236                 ),
237                 testcase.apply_defaults({name: test_kwargs[name]}),
238             )
239             with testcase.assertRaisesRegex(
240                 CommandExecutionError, "is an alias for.+cannot both be used"
241             ):
242                 salt.utils.dockermod.translate_input(
243                     self.translator, ignore_collisions=False, **test_kwargs
244                 )
245         return self.func(testcase, *args, **kwargs)
246 class assert_stringlist(Assert):
247     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
248         name = self.func.__name__[5:]
249         self.test_stringlist(testcase, name)
250         return self.func(testcase, *args, **kwargs)
251 class assert_dict(Assert):
252     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
253         name = self.func.__name__[5:]
254         alias = self.translator.ALIASES_REVMAP.get(name)
255         expected = {"foo": "bar", "baz": "qux"}
256         for item in (name, alias):
257             if item is None:
258                 continue
259             testcase.assertEqual(
260                 salt.utils.dockermod.translate_input(
261                     self.translator, **{item: expected}
262                 ),
263                 testcase.apply_defaults({name: expected}),
264             )
265             testcase.assertEqual(
266                 salt.utils.dockermod.translate_input(
267                     self.translator, **{item: [{x: y} for x, y in expected.items()]}
268                 ),
269                 testcase.apply_defaults({name: expected}),
270             )
271             with testcase.assertRaisesRegex(
272                 CommandExecutionError, "'foo' is not a dictionary"
273             ):
274                 salt.utils.dockermod.translate_input(self.translator, **{item: "foo"})
275         if alias is not None:
276             test_kwargs = {name: "foo", alias: "bar"}
277             testcase.assertEqual(
278                 salt.utils.dockermod.translate_input(
279                     self.translator, ignore_collisions=True, **test_kwargs
280                 ),
281                 testcase.apply_defaults({name: test_kwargs[name]}),
282             )
283             with testcase.assertRaisesRegex(
284                 CommandExecutionError, "is an alias for.+cannot both be used"
285             ):
286                 salt.utils.dockermod.translate_input(
287                     self.translator, ignore_collisions=False, **test_kwargs
288                 )
289         return self.func(testcase, *args, **kwargs)
290 class assert_cmd(Assert):
291     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
292         name = self.func.__name__[5:]
293         alias = self.translator.ALIASES_REVMAP.get(name)
294         for item in (name, alias):
295             if item is None:
296                 continue
297             testcase.assertEqual(
298                 salt.utils.dockermod.translate_input(
299                     self.translator, **{item: "foo bar"}
300                 ),
301                 testcase.apply_defaults({name: "foo bar"}),
302             )
303             testcase.assertEqual(
304                 salt.utils.dockermod.translate_input(
305                     self.translator, **{item: ["foo", "bar"]}
306                 ),
307                 testcase.apply_defaults({name: ["foo", "bar"]}),
308             )
309             testcase.assertEqual(
310                 salt.utils.dockermod.translate_input(self.translator, **{item: 123}),
311                 testcase.apply_defaults({name: "123"}),
312             )
313             testcase.assertEqual(
314                 salt.utils.dockermod.translate_input(
315                     self.translator, **{item: ["one", 2]}
316                 ),
317                 testcase.apply_defaults({name: ["one", "2"]}),
318             )
319         if alias is not None:
320             test_kwargs = {name: "foo", alias: "bar"}
321             testcase.assertEqual(
322                 salt.utils.dockermod.translate_input(
323                     self.translator, ignore_collisions=True, **test_kwargs
324                 ),
325                 testcase.apply_defaults({name: test_kwargs[name]}),
326             )
327             with testcase.assertRaisesRegex(
328                 CommandExecutionError, "is an alias for.+cannot both be used"
329             ):
330                 salt.utils.dockermod.translate_input(
331                     self.translator, ignore_collisions=False, **test_kwargs
332                 )
333         return self.func(testcase, *args, **kwargs)
334 class assert_key_colon_value(Assert):
335     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
336         name = self.func.__name__[5:]
337         self.test_key_value(testcase, name, ":")
338         return self.func(testcase, *args, **kwargs)
339 class assert_key_equals_value(Assert):
340     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
341         name = self.func.__name__[5:]
342         self.test_key_value(testcase, name, "=")
343         if name == "labels":
344             self.test_stringlist(testcase, name)
345         return self.func(testcase, *args, **kwargs)
346 class assert_labels(Assert):
347     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
348         name = self.func.__name__[5:]
349         alias = self.translator.ALIASES_REVMAP.get(name)
350         labels = ["foo", "bar=baz", {"hello": "world"}]
351         expected = {"foo": "", "bar": "baz", "hello": "world"}
352         for item in (name, alias):
353             if item is None:
354                 continue
355             testcase.assertEqual(
356                 salt.utils.dockermod.translate_input(self.translator, **{item: labels}),
357                 testcase.apply_defaults({name: expected}),
358             )
359             bad_labels = copy.deepcopy(labels)
360             bad_labels[-1]["bad"] = "input"
361             with testcase.assertRaisesRegex(
362                 CommandExecutionError, r"Invalid label\(s\)"
363             ):
364                 salt.utils.dockermod.translate_input(
365                     self.translator, **{item: bad_labels}
366                 )
367         return self.func(testcase, *args, **kwargs)
368 class assert_device_rates(Assert):
369     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
370         name = self.func.__name__[5:]
371         alias = self.translator.ALIASES_REVMAP.get(name)
372         for item in (name, alias):
373             if item is None:
374                 continue
375             path = os.path.join("foo", "bar", "baz")
376             with testcase.assertRaisesRegex(
377                 CommandExecutionError,
378                 "Path '{}' is not absolute".format(path.replace("\\", "\\\\")),
379             ):
380                 salt.utils.dockermod.translate_input(
381                     self.translator, **{item: "{}:1048576".format(path)}
382                 )
383             if name.endswith("_bps"):
384                 expected = ({}, [])
385                 vals = "/dev/sda:1048576,/dev/sdb:1048576"
386                 for val in (vals, vals.split(",")):
387                     testcase.assertEqual(
388                         salt.utils.dockermod.translate_input(
389                             self.translator, **{item: val}
390                         ),
391                         testcase.apply_defaults(
392                             {
393                                 name: [
394                                     {"Path": "/dev/sda", "Rate": 1048576},
395                                     {"Path": "/dev/sdb", "Rate": 1048576},
396                                 ]
397                             }
398                         ),
399                     )
400                 vals = "/dev/sda:1mb,/dev/sdb:5mb"
401                 for val in (vals, vals.split(",")):
402                     testcase.assertEqual(
403                         salt.utils.dockermod.translate_input(
404                             self.translator, **{item: val}
405                         ),
406                         testcase.apply_defaults(
407                             {
408                                 name: [
409                                     {"Path": "/dev/sda", "Rate": "1mb"},
410                                     {"Path": "/dev/sdb", "Rate": "5mb"},
411                                 ]
412                             }
413                         ),
414                     )
415                 if alias is not None:
416                     test_kwargs = {
417                         name: "/dev/sda:1048576,/dev/sdb:1048576",
418                         alias: "/dev/sda:1mb,/dev/sdb:5mb",
419                     }
420                     testcase.assertEqual(
421                         salt.utils.dockermod.translate_input(
422                             self.translator, ignore_collisions=True, **test_kwargs
423                         ),
424                         testcase.apply_defaults(
425                             {
426                                 name: [
427                                     {"Path": "/dev/sda", "Rate": 1048576},
428                                     {"Path": "/dev/sdb", "Rate": 1048576},
429                                 ]
430                             }
431                         ),
432                     )
433                     with testcase.assertRaisesRegex(
434                         CommandExecutionError, "is an alias for.+cannot both be used"
435                     ):
436                         salt.utils.dockermod.translate_input(
437                             self.translator, ignore_collisions=False, **test_kwargs
438                         )
439             else:
440                 vals = "/dev/sda:1000,/dev/sdb:500"
441                 for val in (vals, vals.split(",")):
442                     testcase.assertEqual(
443                         salt.utils.dockermod.translate_input(
444                             self.translator, **{item: val}
445                         ),
446                         testcase.apply_defaults(
447                             {
448                                 name: [
449                                     {"Path": "/dev/sda", "Rate": 1000},
450                                     {"Path": "/dev/sdb", "Rate": 500},
451                                 ]
452                             }
453                         ),
454                     )
455                 expected = (
456                     {},
457                     {item: "Rate '5mb' for path '/dev/sdb' is non-numeric"},
458                     [],
459                 )
460                 vals = "/dev/sda:1000,/dev/sdb:5mb"
461                 for val in (vals, vals.split(",")):
462                     with testcase.assertRaisesRegex(
463                         CommandExecutionError,
464                         "Rate '5mb' for path '/dev/sdb' is non-numeric",
465                     ):
466                         salt.utils.dockermod.translate_input(
467                             self.translator, **{item: val}
468                         )
469                 if alias is not None:
470                     test_kwargs = {
471                         name: "/dev/sda:1000,/dev/sdb:500",
472                         alias: "/dev/sda:888,/dev/sdb:999",
473                     }
474                     testcase.assertEqual(
475                         salt.utils.dockermod.translate_input(
476                             self.translator, ignore_collisions=True, **test_kwargs
477                         ),
478                         testcase.apply_defaults(
479                             {
480                                 name: [
481                                     {"Path": "/dev/sda", "Rate": 1000},
482                                     {"Path": "/dev/sdb", "Rate": 500},
483                                 ]
484                             }
485                         ),
486                     )
487                     with testcase.assertRaisesRegex(
488                         CommandExecutionError, "is an alias for.+cannot both be used"
489                     ):
490                         salt.utils.dockermod.translate_input(
491                             self.translator, ignore_collisions=False, **test_kwargs
492                         )
493         return self.func(testcase, *args, **kwargs)
494 class assert_subnet(Assert):
495     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
496         name = self.func.__name__[5:]
497         alias = self.translator.ALIASES_REVMAP.get(name)
498         for item in (name, alias):
499             if item is None:
500                 continue
501             for val in ("127.0.0.1/32", "::1/128"):
502                 log.debug("Verifying '%s' is a valid subnet", val)
503                 testcase.assertEqual(
504                     salt.utils.dockermod.translate_input(
505                         self.translator, validate_ip_addrs=True, **{item: val}
506                     ),
507                     testcase.apply_defaults({name: val}),
508                 )
509             for val in (
510                 "127.0.0.1",
511                 "999.999.999.999/24",
512                 "10.0.0.0/33",
513                 "::1",
514                 "feaz::1/128",
515                 "::1/129",
516             ):
517                 log.debug("Verifying '%s' is not a valid subnet", val)
518                 with testcase.assertRaisesRegex(
519                     CommandExecutionError, "'{}' is not a valid subnet".format(val)
520                 ):
521                     salt.utils.dockermod.translate_input(
522                         self.translator, validate_ip_addrs=True, **{item: val}
523                     )
524             val = "foo"
525             testcase.assertEqual(
526                 salt.utils.dockermod.translate_input(
527                     self.translator, validate_ip_addrs=False, **{item: val}
528                 ),
529                 testcase.apply_defaults({name: val}),
530             )
531         if alias is not None:
532             test_kwargs = {name: "10.0.0.0/24", alias: "192.168.50.128/25"}
533             testcase.assertEqual(
534                 salt.utils.dockermod.translate_input(
535                     self.translator, ignore_collisions=True, **test_kwargs
536                 ),
537                 testcase.apply_defaults({name: test_kwargs[name]}),
538             )
539             with testcase.assertRaisesRegex(
540                 CommandExecutionError, "is an alias for.+cannot both be used"
541             ):
542                 salt.utils.dockermod.translate_input(
543                     self.translator, ignore_collisions=False, **test_kwargs
544                 )
545         return self.func(testcase, *args, **kwargs)
546 class TranslateBase(TestCase):
547     maxDiff = None
548     translator = None  # Must be overridden in the subclass
549     def apply_defaults(self, ret, skip_translate=None):
550         if skip_translate is not True:
551             defaults = getattr(self.translator, "DEFAULTS", {})
552             for key, val in defaults.items():
553                 if key not in ret:
554                     ret[key] = val
555         return ret
556     @staticmethod
557     def normalize_ports(ret):
558         if "ports" in ret[0]:
559             tcp_ports = []
560             udp_ports = []
561             for item in ret[0]["ports"]:
562                 if isinstance(item, int):
563                     tcp_ports.append(item)
564                 else:
565                     udp_ports.append(item)
566             ret[0]["ports"] = sorted(tcp_ports) + sorted(udp_ports)
567         return ret
568     def tearDown(self):
569         name = self.id().split(".")[-1][5:]
570         for val in (True, name, [name]):
571             self.assertEqual(
572                 salt.utils.dockermod.translate_input(
573                     self.translator, skip_translate=val, **{name: "foo"}
574                 ),
575                 self.apply_defaults({name: "foo"}, skip_translate=val),
576             )
577 class TranslateContainerInputTestCase(TranslateBase):
578     translator = salt.utils.dockermod.translate.container
579     @staticmethod
580     def normalize_ports(ret):
581         if "ports" in ret:
582             tcp_ports = []
583             udp_ports = []
584             for item in ret["ports"]:
585                 if isinstance(item, int):
586                     tcp_ports.append(item)
587                 else:
588                     udp_ports.append(item)
589             ret["ports"] = sorted(tcp_ports) + sorted(udp_ports)
590         return ret
591     @assert_bool(salt.utils.dockermod.translate.container)
592     def test_auto_remove(self):
593     def test_binds(self):
594         self.assertEqual(
595             salt.utils.dockermod.translate_input(
596                 self.translator, binds="/srv/www:/var/www:ro", volumes="/testing"
597             ),
598             {"binds": ["/srv/www:/var/www:ro"], "volumes": ["/testing", "/var/www"]},
599         )
600         self.assertEqual(
601             salt.utils.dockermod.translate_input(
602                 self.translator, binds=["/srv/www:/var/www:ro"], volumes="/testing"
603             ),
604             {"binds": ["/srv/www:/var/www:ro"], "volumes": ["/testing", "/var/www"]},
605         )
606         self.assertEqual(
607             salt.utils.dockermod.translate_input(
608                 self.translator,
609                 binds={"/srv/www": {"bind": "/var/www", "mode": "ro"}},
610                 volumes="/testing",
611             ),
612             {
613                 "binds": {"/srv/www": {"bind": "/var/www", "mode": "ro"}},
614                 "volumes": ["/testing", "/var/www"],
615             },
616         )
617     @assert_int(salt.utils.dockermod.translate.container)
618     def test_blkio_weight(self):
619     def test_blkio_weight_device(self):
620         for val in ("/dev/sda:100,/dev/sdb:200", ["/dev/sda:100", "/dev/sdb:200"]):
621             self.assertEqual(
622                 salt.utils.dockermod.translate_input(
623                     self.translator, blkio_weight_device="/dev/sda:100,/dev/sdb:200"
624                 ),
625                 {
626                     "blkio_weight_device": [
627                         {"Path": "/dev/sda", "Weight": 100},
628                         {"Path": "/dev/sdb", "Weight": 200},
629                     ]
630                 },
631             )
632         with self.assertRaisesRegex(
633             CommandExecutionError, r"'foo' contains 1 value\(s\) \(expected 2\)"
634         ):
635             salt.utils.dockermod.translate_input(
636                 self.translator, blkio_weight_device="foo"
637             )
638         with self.assertRaisesRegex(
639             CommandExecutionError, r"'foo:bar:baz' contains 3 value\(s\) \(expected 2\)"
640         ):
641             salt.utils.dockermod.translate_input(
642                 self.translator, blkio_weight_device="foo:bar:baz"
643             )
644         with self.assertRaisesRegex(
645             CommandExecutionError, r"Weight 'foo' for path '/dev/sdb' is not an integer"
646         ):
647             salt.utils.dockermod.translate_input(
648                 self.translator, blkio_weight_device=["/dev/sda:100", "/dev/sdb:foo"]
649             )
650     @assert_stringlist(salt.utils.dockermod.translate.container)
651     def test_cap_add(self):
652     @assert_stringlist(salt.utils.dockermod.translate.container)
653     def test_cap_drop(self):
654     @assert_cmd(salt.utils.dockermod.translate.container)
655     def test_command(self):
656     @assert_string(salt.utils.dockermod.translate.container)
657     def test_cpuset_cpus(self):
658     @assert_string(salt.utils.dockermod.translate.container)
659     def test_cpuset_mems(self):
660     @assert_int(salt.utils.dockermod.translate.container)
661     def test_cpu_group(self):
662     @assert_int(salt.utils.dockermod.translate.container)
663     def test_cpu_period(self):
664     @assert_int(salt.utils.dockermod.translate.container)
665     def test_cpu_shares(self):
666     @assert_bool(salt.utils.dockermod.translate.container)
667     def test_detach(self):
668     @assert_device_rates(salt.utils.dockermod.translate.container)
669     def test_device_read_bps(self):
670     @assert_device_rates(salt.utils.dockermod.translate.container)
671     def test_device_read_iops(self):
672     @assert_device_rates(salt.utils.dockermod.translate.container)
673     def test_device_write_bps(self):
674     @assert_device_rates(salt.utils.dockermod.translate.container)
675     def test_device_write_iops(self):
676     @assert_stringlist(salt.utils.dockermod.translate.container)
677     def test_devices(self):
678     @assert_stringlist(salt.utils.dockermod.translate.container)
679     def test_dns_opt(self):
680     @assert_stringlist(salt.utils.dockermod.translate.container)
681     def test_dns_search(self):
682     def test_dns(self):
683         for val in ("8.8.8.8,8.8.4.4", ["8.8.8.8", "8.8.4.4"]):
684             self.assertEqual(
685                 salt.utils.dockermod.translate_input(
686                     self.translator,
687                     dns=val,
688                     validate_ip_addrs=True,
689                 ),
690                 {"dns": ["8.8.8.8", "8.8.4.4"]},
691             )
692         for val in ("8.8.8.888,8.8.4.4", ["8.8.8.888", "8.8.4.4"]):
693             with self.assertRaisesRegex(
694                 CommandExecutionError, r"'8.8.8.888' is not a valid IP address"
695             ):
696                 salt.utils.dockermod.translate_input(
697                     self.translator,
698                     dns=val,
699                     validate_ip_addrs=True,
700                 )
701         for val in ("foo,bar", ["foo", "bar"]):
702             self.assertEqual(
703                 salt.utils.dockermod.translate_input(
704                     self.translator,
705                     dns=val,
706                     validate_ip_addrs=False,
707                 ),
708                 {"dns": ["foo", "bar"]},
709             )
710     @assert_string(salt.utils.dockermod.translate.container)
711     def test_domainname(self):
712     @assert_cmd(salt.utils.dockermod.translate.container)
713     def test_entrypoint(self):
714     @assert_key_equals_value(salt.utils.dockermod.translate.container)
715     def test_environment(self):
716     def test_extra_hosts(self):
717         for val in ("web1:10.9.8.7,web2:10.9.8.8", ["web1:10.9.8.7", "web2:10.9.8.8"]):
718             self.assertEqual(
719                 salt.utils.dockermod.translate_input(
720                     self.translator,
721                     extra_hosts=val,
722                     validate_ip_addrs=True,
723                 ),
724                 {"extra_hosts": {"web1": "10.9.8.7", "web2": "10.9.8.8"}},
725             )
726         for val in (
727             "web1:10.9.8.299,web2:10.9.8.8",
728             ["web1:10.9.8.299", "web2:10.9.8.8"],
729         ):
730             with self.assertRaisesRegex(
731                 CommandExecutionError, r"'10.9.8.299' is not a valid IP address"
732             ):
733                 salt.utils.dockermod.translate_input(
734                     self.translator,
735                     extra_hosts=val,
736                     validate_ip_addrs=True,
737                 )
738         for val in ("foo:bar,baz:qux", ["foo:bar", "baz:qux"]):
739             self.assertEqual(
740                 salt.utils.dockermod.translate_input(
741                     self.translator,
742                     extra_hosts=val,
743                     validate_ip_addrs=False,
744                 ),
745                 {"extra_hosts": {"foo": "bar", "baz": "qux"}},
746             )
747     @assert_stringlist(salt.utils.dockermod.translate.container)
748     def test_group_add(self):
749     @assert_string(salt.utils.dockermod.translate.container)
750     def test_hostname(self):
751     @assert_string(salt.utils.dockermod.translate.container)
752     def test_ipc_mode(self):
753     @assert_string(salt.utils.dockermod.translate.container)
754     def test_isolation(self):
755     @assert_labels(salt.utils.dockermod.translate.container)
756     def test_labels(self):
757     @assert_key_colon_value(salt.utils.dockermod.translate.container)
758     def test_links(self):
759     def test_log_config(self):
760         expected = (
761             {"log_config": {"Type": "foo", "Config": {"foo": "bar", "baz": "qux"}}},
762             {},
763             [],
764         )
765         for val in (
766             "foo=bar,baz=qux",
767             ["foo=bar", "baz=qux"],
768             [{"foo": "bar"}, {"baz": "qux"}],
769             {"foo": "bar", "baz": "qux"},
770         ):
771             self.assertEqual(
772                 salt.utils.dockermod.translate_input(
773                     self.translator, log_driver="foo", log_opt="foo=bar,baz=qux"
774                 ),
775                 {"log_config": {"Type": "foo", "Config": {"foo": "bar", "baz": "qux"}}},
776             )
777         self.assertEqual(
778             salt.utils.dockermod.translate_input(self.translator, log_driver="foo"),
779             {"log_config": {"Type": "foo", "Config": {}}},
780         )
781         self.assertEqual(
782             salt.utils.dockermod.translate_input(
783                 self.translator, log_opt={"foo": "bar", "baz": "qux"}
784             ),
785             {"log_config": {"Type": "none", "Config": {"foo": "bar", "baz": "qux"}}},
786         )
787     @assert_key_equals_value(salt.utils.dockermod.translate.container)
788     def test_lxc_conf(self):
789     @assert_string(salt.utils.dockermod.translate.container)
790     def test_mac_address(self):
791     @assert_int_or_string(salt.utils.dockermod.translate.container)
792     def test_mem_limit(self):
793     @assert_int(salt.utils.dockermod.translate.container)
794     def test_mem_swappiness(self):
795     @assert_int_or_string(salt.utils.dockermod.translate.container)
796     def test_memswap_limit(self):
797     @assert_string(salt.utils.dockermod.translate.container)
798     def test_name(self):
799     @assert_bool(salt.utils.dockermod.translate.container)
800     def test_network_disabled(self):
801     @assert_string(salt.utils.dockermod.translate.container)
802     def test_network_mode(self):
803     @assert_bool(salt.utils.dockermod.translate.container)
804     def test_oom_kill_disable(self):
805     @assert_int(salt.utils.dockermod.translate.container)
806     def test_oom_score_adj(self):
807     @assert_string(salt.utils.dockermod.translate.container)
808     def test_pid_mode(self):
809     @assert_int(salt.utils.dockermod.translate.container)
810     def test_pids_limit(self):
811     def test_port_bindings(self):
812         bindings = (
813             "10.1.2.3:8080:80,10.1.2.3:8888:80,10.4.5.6:3333:3333,"
814             "10.7.8.9:14505-14506:4505-4506,10.1.2.3:8080:81/udp,"
815             "10.1.2.3:8888:81/udp,10.4.5.6:3334:3334/udp,"
816             "10.7.8.9:15505-15506:5505-5506/udp"
817         )
818         for val in (bindings, bindings.split(",")):
819 <a name="0"></a>            self.assertEqual(
820                 self.normalize_ports(
821                     salt.utils.dockermod.translate_input(
822                         self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.translator,
823                         port_bindings=val,
824                     )
825                 ),
826                 {
827                     "port_bindings": {
828                         80: [("10.1.2.3", 8080), ("10.1.2.3", 8888)],
829                         3333: ("10.4.5.6", 3333),
830                         4505: ("10.7.8.9", 14505),
831                         4506: ("10.7.8.9", 14506),
832                         "81/udp": [("10.1.2.3", 8080), ("10.1.2.3", 8888)],
833                         "3334/udp": ("10.4.5.6", 3334),
834                         "5505/udp": ("10.7.8.9", 15505),
835                         "5506/udp": ("10.7.8.9", 15506),
836                     },
837                     "ports": [
838                         80,
839                         3333,
840                         4505,
841                         4506,
842                         (81, "udp"),
843                         (3334, "udp"),
844                         (5505, "udp"),
845                         (5506</b></font>, "udp"),
846                     ],
847                 },
848             )
849         bindings = (
850             "10.1.2.3::80,10.1.2.3::80,10.4.5.6::3333,10.7.8.9::4505-4506,"
851             "10.1.2.3::81/udp,10.1.2.3::81/udp,10.4.5.6::3334/udp,"
852             "10.7.8.9::5505-5506/udp"
853         )
854         for val in (bindings, bindings.split(",")):
855             self.assertEqual(
856 <a name="1"></a>                self.normalize_ports(
857                     salt.utils.dockermod.translate_input(
858                         self.translator,
859                         port_bindings<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=val,
860                     )
861                 ),
862                 {
863                     "port_bindings": {
864                         80: [("10.1.2.3",), ("10.1.2.3",)],
865                         3333: ("10.4.5.6",),
866                         4505: ("10.7.8.9",),
867                         4506: ("10.7.8.9",),
868                         "81/udp": [("10.1.2.3",), ("10.1.2.3",)],
869                         "3334/udp": ("10.4.5.6",),
870                         "5505/udp": ("10.7.8.9",),
871                         "5506/udp": ("10.7.8.9",),
872                     },
873                     "ports": [
874                         80,
875                         3333,
876                         4505,
877                         4506,
878                         (81, "udp"),
879                         (3334, "udp"),
880                         (5505, "udp"),
881                         (5506</b></font>, "udp"),
882                     ],
883                 },
884             )
885         bindings = (
886             "8080:80,8888:80,3333:3333,14505-14506:4505-4506,8080:81/udp,"
887             "8888:81/udp,3334:3334/udp,15505-15506:5505-5506/udp"
888         )
889         for val in (bindings, bindings.split(",")):
890             self.assertEqual(
891                 self.normalize_ports(
892                     salt.utils.dockermod.translate_input(
893                         self.translator,
894                         port_bindings=val,
895                     )
896                 ),
897                 {
898                     "port_bindings": {
899                         80: [8080, 8888],
900                         3333: 3333,
901                         4505: 14505,
902                         4506: 14506,
903                         "81/udp": [8080, 8888],
904                         "3334/udp": 3334,
905                         "5505/udp": 15505,
906                         "5506/udp": 15506,
907                     },
908                     "ports": [
909                         80,
910                         3333,
911                         4505,
912                         4506,
913                         (81, "udp"),
914                         (3334, "udp"),
915                         (5505, "udp"),
916                         (5506, "udp"),
917                     ],
918                 },
919             )
920         bindings = "80,3333,4505-4506,81/udp,3334/udp,5505-5506/udp"
921         for val in (bindings, bindings.split(",")):
922             self.assertEqual(
923                 self.normalize_ports(
924                     salt.utils.dockermod.translate_input(
925                         self.translator,
926                         port_bindings=val,
927                     )
928                 ),
929                 {
930                     "port_bindings": {
931                         80: None,
932                         3333: None,
933                         4505: None,
934                         4506: None,
935                         "81/udp": None,
936                         "3334/udp": None,
937                         "5505/udp": None,
938                         "5506/udp": None,
939                     },
940                     "ports": [
941                         80,
942                         3333,
943                         4505,
944                         4506,
945                         (81, "udp"),
946                         (3334, "udp"),
947                         (5505, "udp"),
948                         (5506, "udp"),
949                     ],
950                 },
951             )
952         bindings = (
953             "10.1.2.3:8080:80,10.4.5.6::3333,14505-14506:4505-4506,"
954             "9999-10001,10.1.2.3:8080:81/udp,10.4.5.6::3334/udp,"
955             "15505-15506:5505-5506/udp,19999-20001/udp"
956         )
957         for val in (bindings, bindings.split(",")):
958             self.assertEqual(
959                 self.normalize_ports(
960                     salt.utils.dockermod.translate_input(
961                         self.translator,
962                         port_bindings=val,
963 <a name="3"></a>                    )
964                 ),
965                 {
966                     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"port_bindings": {
967                         80: ("10.1.2.3", 8080),
968                         3333: ("10.4.5.6",),
969                         4505: 14505,
970                         4506: 14506,
971                         9999: None,
972                         10000: None,
973                         10001: None,
974                         "81/udp": ("10.1.2.3", 8080),
975                         "3334/udp": ("10.4.5.6",),
976                         "5505/udp": 15505,
977                         "5506/udp": 15506,
978                         "19999/udp": None,
979                         "20000/udp": None,
980                         "20001/udp": None,
981                     },
982                     "ports": [
983                         80,
984                         3333,
985                         4505,
986                         4506,
987                         9999,
988                         10000,
989                         10001,
990                         (81, "udp"),
991                         (3334, "udp"),
992                         (5505, "udp"),
993                         (5506, "udp"),
994                         (19999, "udp"),
995                         (20000, "udp"),
996                         (20001</b></font>, "udp"),
997                     ],
998                 },
999             )
1000         with self.assertRaisesRegex(
1001             CommandExecutionError,
1002             r"'10.1.2.3:8080:80:123' is an invalid port binding "
1003             r"definition \(at most 3 components are allowed, found 4\)",
1004         ):
1005             salt.utils.dockermod.translate_input(
1006                 self.translator, port_bindings="10.1.2.3:8080:80:123"
1007             )
1008         for val in (
1009             "10.1.2.3:5555-5554:1111-1112",
1010             "10.1.2.3:1111-1112:5555-5554",
1011             "10.1.2.3::5555-5554",
1012             "5555-5554:1111-1112",
1013             "1111-1112:5555-5554",
1014             "5555-5554",
1015         ):
1016             with self.assertRaisesRegex(
1017                 CommandExecutionError,
1018                 r"Start of port range \(5555\) cannot be greater than end "
1019                 r"of port range \(5554\)",
1020             ):
1021                 salt.utils.dockermod.translate_input(
1022                     self.translator,
1023                     port_bindings=val,
1024                 )
1025         for val in (
1026             "10.1.2.3:foo:1111-1112",
1027             "10.1.2.3:1111-1112:foo",
1028             "10.1.2.3::foo",
1029             "foo:1111-1112",
1030             "1111-1112:foo",
1031             "foo",
1032         ):
1033             with self.assertRaisesRegex(
1034                 CommandExecutionError, "'foo' is non-numeric or an invalid port range"
1035             ):
1036                 salt.utils.dockermod.translate_input(
1037                     self.translator,
1038                     port_bindings=val,
1039                 )
1040         for val in ("10.1.2.3:1111-1113:1111-1112", "1111-1113:1111-1112"):
1041             with self.assertRaisesRegex(
1042                 CommandExecutionError,
1043                 r"Host port range \(1111-1113\) does not have the same "
1044                 r"number of ports as the container port range \(1111-1112\)",
1045             ):
1046                 salt.utils.dockermod.translate_input(self.translator, port_bindings=val)
1047         for val in ("10.1.2.3:1111-1112:1111-1113", "1111-1112:1111-1113"):
1048             with self.assertRaisesRegex(
1049                 CommandExecutionError,
1050                 r"Host port range \(1111-1112\) does not have the same "
1051                 r"number of ports as the container port range \(1111-1113\)",
1052             ):
1053                 salt.utils.dockermod.translate_input(
1054                     self.translator,
1055                     port_bindings=val,
1056                 )
1057         with self.assertRaisesRegex(
1058             CommandExecutionError, "Empty host port in port binding definition ':1111'"
1059         ):
1060             salt.utils.dockermod.translate_input(self.translator, port_bindings=":1111")
1061         with self.assertRaisesRegex(
1062             CommandExecutionError,
1063             "Empty container port in port binding definition '1111:'",
1064         ):
1065             salt.utils.dockermod.translate_input(self.translator, port_bindings="1111:")
1066         with self.assertRaisesRegex(
1067             CommandExecutionError, "Empty port binding definition found"
1068         ):
1069             salt.utils.dockermod.translate_input(self.translator, port_bindings="")
1070     def test_ports(self):
1071         for val in (
1072             "1111,2222/tcp,3333/udp,4505-4506",
1073             [1111, "2222/tcp", "3333/udp", "4505-4506"],
1074             ["1111", "2222/tcp", "3333/udp", "4505-4506"],
1075         ):
1076             self.assertEqual(
1077                 self.normalize_ports(
1078                     salt.utils.dockermod.translate_input(
1079                         self.translator,
1080                         ports=val,
1081                     )
1082                 ),
1083                 {"ports": [1111, 2222, 4505, 4506, (3333, "udp")]},
1084             )
1085         for val in (1.0, [1.0]):
1086             with self.assertRaisesRegex(
1087                 CommandExecutionError, "'1.0' is not a valid port definition"
1088             ):
1089                 salt.utils.dockermod.translate_input(
1090                     self.translator,
1091                     ports=val,
1092                 )
1093         with self.assertRaisesRegex(
1094             CommandExecutionError,
1095             r"Start of port range \(5555\) cannot be greater than end of "
1096             r"port range \(5554\)",
1097         ):
1098             salt.utils.dockermod.translate_input(
1099                 self.translator,
1100                 ports="5555-5554",
1101             )
1102     @assert_bool(salt.utils.dockermod.translate.container)
1103     def test_privileged(self):
1104     @assert_bool(salt.utils.dockermod.translate.container)
1105     def test_publish_all_ports(self):
1106     @assert_bool(salt.utils.dockermod.translate.container)
1107     def test_read_only(self):
1108     def test_restart_policy(self):
1109         name = "restart_policy"
1110         alias = "restart"
1111         for item in (name, alias):
1112             self.assertEqual(
1113                 salt.utils.dockermod.translate_input(
1114                     self.translator, **{item: "on-failure:5"}
1115                 ),
1116                 {name: {"Name": "on-failure", "MaximumRetryCount": 5}},
1117             )
1118             self.assertEqual(
1119                 salt.utils.dockermod.translate_input(
1120                     self.translator, **{item: "on-failure"}
1121                 ),
1122                 {name: {"Name": "on-failure", "MaximumRetryCount": 0}},
1123             )
1124             with self.assertRaisesRegex(
1125                 CommandExecutionError, "Only one policy is permitted"
1126             ):
1127                 salt.utils.dockermod.translate_input(
1128                     self.translator, **{item: "on-failure,always"}
1129                 )
1130         test_kwargs = {name: "on-failure:5", alias: "always"}
1131         self.assertEqual(
1132             salt.utils.dockermod.translate_input(
1133                 self.translator, ignore_collisions=True, **test_kwargs
1134             ),
1135             {name: {"Name": "on-failure", "MaximumRetryCount": 5}},
1136         )
1137         with self.assertRaisesRegex(
1138             CommandExecutionError, "'restart' is an alias for 'restart_policy'"
1139         ):
1140             salt.utils.dockermod.translate_input(
1141                 self.translator, ignore_collisions=False, **test_kwargs
1142             )
1143     @assert_stringlist(salt.utils.dockermod.translate.container)
1144     def test_security_opt(self):
1145     @assert_int_or_string(salt.utils.dockermod.translate.container)
1146     def test_shm_size(self):
1147     @assert_bool(salt.utils.dockermod.translate.container)
1148     def test_stdin_open(self):
1149     @assert_string(salt.utils.dockermod.translate.container)
1150     def test_stop_signal(self):
1151     @assert_int(salt.utils.dockermod.translate.container)
1152     def test_stop_timeout(self):
1153     @assert_key_equals_value(salt.utils.dockermod.translate.container)
1154     def test_storage_opt(self):
1155     @assert_key_equals_value(salt.utils.dockermod.translate.container)
1156     def test_sysctls(self):
1157     @assert_dict(salt.utils.dockermod.translate.container)
1158     def test_tmpfs(self):
1159     @assert_bool(salt.utils.dockermod.translate.container)
1160     def test_tty(self):
1161     def test_ulimits(self):
1162         ulimits = "nofile=1024:2048,nproc=50"
1163         for val in (ulimits, ulimits.split(",")):
1164             self.assertEqual(
1165                 salt.utils.dockermod.translate_input(
1166                     self.translator,
1167                     ulimits=val,
1168                 ),
1169                 {
1170                     "ulimits": [
1171                         {"Name": "nofile", "Soft": 1024, "Hard": 2048},
1172                         {"Name": "nproc", "Soft": 50, "Hard": 50},
1173                     ]
1174                 },
1175             )
1176         with self.assertRaisesRegex(
1177             CommandExecutionError,
1178             r"Ulimit definition 'nofile:1024:2048' is not in the format "
1179             r"type=soft_limit\[:hard_limit\]",
1180         ):
1181             salt.utils.dockermod.translate_input(
1182                 self.translator, ulimits="nofile:1024:2048"
1183             )
1184         with self.assertRaisesRegex(
1185             CommandExecutionError,
1186             r"Limit 'nofile=foo:2048' contains non-numeric value\(s\)",
1187         ):
1188             salt.utils.dockermod.translate_input(
1189                 self.translator, ulimits="nofile=foo:2048"
1190             )
1191     def test_user(self):
1192         self.assertEqual(
1193             salt.utils.dockermod.translate_input(self.translator, user="foo"),
1194             {"user": "foo"},
1195         )
1196         for val in (0, "0"):
1197             self.assertEqual(
1198                 salt.utils.dockermod.translate_input(self.translator, user=val),
1199                 {"user": 0},
1200             )
1201         with self.assertRaisesRegex(
1202             CommandExecutionError, "Value must be a username or uid"
1203         ):
1204             salt.utils.dockermod.translate_input(self.translator, user=["foo"])
1205         with self.assertRaisesRegex(CommandExecutionError, "'-1' is an invalid uid"):
1206             salt.utils.dockermod.translate_input(self.translator, user=-1)
1207     @assert_string(salt.utils.dockermod.translate.container)
1208     def test_userns_mode(self):
1209     @assert_string(salt.utils.dockermod.translate.container)
1210     def test_volume_driver(self):
1211     @assert_stringlist(salt.utils.dockermod.translate.container)
1212     def test_volumes(self):
1213         path = os.path.join("foo", "bar", "baz")
1214         with self.assertRaisesRegex(
1215             CommandExecutionError,
1216             "'{}' is not an absolute path".format(path.replace("\\", "\\\\")),
1217         ):
1218             salt.utils.dockermod.translate_input(self.translator, volumes=path)
1219     @assert_stringlist(salt.utils.dockermod.translate.container)
1220     def test_volumes_from(self):
1221     @assert_string(salt.utils.dockermod.translate.container)
1222     def test_working_dir(self):
1223         path = os.path.join("foo", "bar", "baz")
1224         with self.assertRaisesRegex(
1225             CommandExecutionError,
1226             "'{}' is not an absolute path".format(path.replace("\\", "\\\\")),
1227         ):
1228             salt.utils.dockermod.translate_input(self.translator, working_dir=path)
1229 class TranslateNetworkInputTestCase(TranslateBase):
1230     translator = salt.utils.dockermod.translate.network
1231     ip_addrs = {
1232         True: ("10.1.2.3", "::1"),
1233         False: ("FOO", "0.9.800.1000", "feaz::1", "aj01::feac"),
1234     }
1235     @assert_string(salt.utils.dockermod.translate.network)
1236     def test_driver(self):
1237     @assert_key_equals_value(salt.utils.dockermod.translate.network)
1238     def test_options(self):
1239     @assert_dict(salt.utils.dockermod.translate.network)
1240     def test_ipam(self):
1241     @assert_bool(salt.utils.dockermod.translate.network)
1242     def test_check_duplicate(self):
1243     @assert_bool(salt.utils.dockermod.translate.network)
1244     def test_internal(self):
1245     @assert_labels(salt.utils.dockermod.translate.network)
1246     def test_labels(self):
1247     @assert_bool(salt.utils.dockermod.translate.network)
1248     def test_enable_ipv6(self):
1249     @assert_bool(salt.utils.dockermod.translate.network)
1250     def test_attachable(self):
1251     @assert_bool(salt.utils.dockermod.translate.network)
1252     def test_ingress(self):
1253     @assert_string(salt.utils.dockermod.translate.network)
1254     def test_ipam_driver(self):
1255     @assert_key_equals_value(salt.utils.dockermod.translate.network)
1256     def test_ipam_opts(self):
1257     def ipam_pools(self):
1258         good_pool = {
1259             "subnet": "10.0.0.0/24",
1260             "iprange": "10.0.0.128/25",
1261             "gateway": "10.0.0.254",
1262             "aux_addresses": {
1263                 "foo.bar.tld": "10.0.0.20",
1264                 "hello.world.tld": "10.0.0.21",
1265             },
1266         }
1267         bad_pools = [
1268             {
1269                 "subnet": "10.0.0.0/33",
1270                 "iprange": "10.0.0.128/25",
1271                 "gateway": "10.0.0.254",
1272                 "aux_addresses": {
1273                     "foo.bar.tld": "10.0.0.20",
1274                     "hello.world.tld": "10.0.0.21",
1275                 },
1276             },
1277             {
1278                 "subnet": "10.0.0.0/24",
1279                 "iprange": "foo/25",
1280                 "gateway": "10.0.0.254",
1281                 "aux_addresses": {
1282                     "foo.bar.tld": "10.0.0.20",
1283                     "hello.world.tld": "10.0.0.21",
1284                 },
1285             },
1286             {
1287                 "subnet": "10.0.0.0/24",
1288                 "iprange": "10.0.0.128/25",
1289                 "gateway": "10.0.0.256",
1290                 "aux_addresses": {
1291                     "foo.bar.tld": "10.0.0.20",
1292                     "hello.world.tld": "10.0.0.21",
1293                 },
1294             },
1295             {
1296                 "subnet": "10.0.0.0/24",
1297                 "iprange": "10.0.0.128/25",
1298                 "gateway": "10.0.0.254",
1299                 "aux_addresses": {
1300                     "foo.bar.tld": "10.0.0.20",
1301                     "hello.world.tld": "999.0.0.21",
1302                 },
1303             },
1304         ]
1305         self.assertEqual(
1306             salt.utils.dockermod.translate_input(
1307                 self.translator,
1308                 ipam_pools=[good_pool],
1309             ),
1310             {"ipam_pools": [good_pool]},
1311         )
1312         for bad_pool in bad_pools:
1313             with self.assertRaisesRegex(CommandExecutionError, "not a valid"):
1314                 salt.utils.dockermod.translate_input(
1315                     self.translator, ipam_pools=[good_pool, bad_pool]
1316                 )
1317     @assert_subnet(salt.utils.dockermod.translate.network)
1318     def test_subnet(self):
1319     @assert_subnet(salt.utils.dockermod.translate.network)
1320     def test_iprange(self):
1321     def test_gateway(self):
1322         for val in self.ip_addrs[True]:
1323             self.assertEqual(
1324                 salt.utils.dockermod.translate_input(
1325                     self.translator,
1326                     validate_ip_addrs=True,
1327                     gateway=val,
1328                 ),
1329                 self.apply_defaults({"gateway": val}),
1330             )
1331         for val in self.ip_addrs[False]:
1332             with self.assertRaisesRegex(
1333                 CommandExecutionError, "'{}' is not a valid IP address".format(val)
1334             ):
1335                 salt.utils.dockermod.translate_input(
1336                     self.translator,
1337                     validate_ip_addrs=True,
1338                     gateway=val,
1339                 )
1340             self.assertEqual(
1341                 salt.utils.dockermod.translate_input(
1342                     self.translator,
1343                     validate_ip_addrs=False,
1344                     gateway=val,
1345                 ),
1346                 self.apply_defaults(
1347                     {"gateway": val if isinstance(val, str) else str(val)}
1348                 ),
1349             )
1350     @assert_key_equals_value(salt.utils.dockermod.translate.network)
1351     def test_aux_addresses(self):
1352         name = "aux_addresses"
1353         alias = "aux_address"
1354         for item in (name, alias):
1355             for val in self.ip_addrs[True]:
1356                 addresses = {"foo.bar.tld": val}
1357                 self.assertEqual(
1358                     salt.utils.dockermod.translate_input(
1359                         self.translator, validate_ip_addrs=True, **{item: addresses}
1360                     ),
1361                     self.apply_defaults({name: addresses}),
1362                 )
1363             for val in self.ip_addrs[False]:
1364                 addresses = {"foo.bar.tld": val}
1365                 with self.assertRaisesRegex(
1366                     CommandExecutionError, "'{}' is not a valid IP address".format(val)
1367                 ):
1368                     salt.utils.dockermod.translate_input(
1369                         self.translator, validate_ip_addrs=True, **{item: addresses}
1370                     )
1371                 self.assertEqual(
1372                     salt.utils.dockermod.translate_input(
1373                         self.translator,
1374                         validate_ip_addrs=False,
1375                         aux_addresses=addresses,
1376                     ),
1377                     self.apply_defaults({name: addresses}),
1378                 )
1379 class DockerTranslateHelperTestCase(TestCase):
1380     def test_get_port_def(self):
1381         self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(translate_helpers.get_port_def(2222), 2222)
1382         self.assertEqual(translate_helpers.get_port_def("2222"), 2222)
1383         self.assertEqual(translate_helpers.get_port_def("2222", "tcp"), 2222)
1384         self.assertEqual(translate_helpers.get_port_def("2222/tcp", "udp"), 2222)
1385         self.assertEqual(translate_helpers.get_port_def(</b></font>2222, "udp"), (2222, "udp"))
1386         self.assertEqual(translate_helpers.get_port_def("2222", "udp"), (2222, "udp"))
1387         self.assertEqual(translate_helpers.get_port_def("2222/udp"), (2222, "udp"))
1388     def test_get_port_range(self):
1389         self.assertEqual(translate_helpers.get_port_range(2222), (2222, 2222))
1390         self.assertEqual(translate_helpers.get_port_range("2222"), (2222, 2222))
1391         self.assertEqual(translate_helpers.get_port_range("2222-2223"), (2222, 2223))
1392         with self.assertRaisesRegex(
1393             ValueError,
1394             r"Start of port range \(2222\) cannot be greater than end of "
1395             r"port range \(2221\)",
1396         ):
1397             translate_helpers.get_port_range("2222-2221")
1398         with self.assertRaisesRegex(
1399             ValueError, "'2222-bar' is non-numeric or an invalid port range"
1400         ):
1401             translate_helpers.get_port_range("2222-bar")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
