<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_reactor_2.py &amp; test_dockermod.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_reactor_2.py &amp; test_dockermod.py
      </h3>
<h1 align="center">
        5.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_reactor_2.py (19.426048%)<th>test_dockermod.py (3.319502%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(270-330)<td><a href="#" name="0">(1226-1249)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(145-216)<td><a href="#" name="1">(1266-1288)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(49-135)<td><a href="#" name="2">(2013-2025)</a><td align="center"><font color="#f20000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(216-256)<td><a href="#" name="3">(1381-1411)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(2-16)<td><a href="#" name="4">(8-22)</a><td align="center"><font color="#9d0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_reactor_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import glob
2 import logging
3 import os
4 import textwrap
5 import salt.loader
6 import salt.utils.data
7 import salt.utils.files
8 import salt.utils.reactor as reactor
9 import salt.utils.yaml
10 from tests.support.mixins import AdaptedConfigurationTestCaseMixin
11 from tests.support.mock import MagicMock, Mock, mock_open, patch
12 from tests.support.unit import TestCase
13 REACTOR_CONFIG =</b></font> """\
14 reactor:
15   - old_runner:
16     - /srv/reactor/old_runner.sls
17   - old_wheel:
18     - /srv/reactor/old_wheel.sls
19   - old_local:
20     - /srv/reactor/old_local.sls
21   - old_cmd:
22     - /srv/reactor/old_cmd.sls
23   - old_caller:
24     - /srv/reactor/old_caller.sls
25   - new_runner:
26     - /srv/reactor/new_runner.sls
27   - new_wheel:
28     - /srv/reactor/new_wheel.sls
29   - new_local:
30     - /srv/reactor/new_local.sls
31   - new_cmd:
32     - /srv/reactor/new_cmd.sls
33   - new_caller:
34     - /srv/reactor/new_caller.sls
35 """
36     "/srv/reactor/old_runner.sls": textwrap<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dedent(
37         """\
38         raise_error:
39           runner.error.error:
40             - name: Exception
41             - message: {{ data['data']['message'] }}
42         """
43     ),
44     "/srv/reactor/old_wheel.sls": textwrap.dedent(
45         """\
46         remove_key:
47           wheel.key.delete:
48             - match: {{ data['data']['id'] }}
49         """
50     ),
51     "/srv/reactor/old_local.sls": textwrap.dedent(
52         """\
53         install_zsh:
54           local.state.single:
55             - tgt: test
56             - arg:
57               - pkg.installed
58               - {{ data['data']['pkg'] }}
59             - kwarg:
60                 fromrepo: {{ data['data']['repo'] }}
61         """
62     ),
63     "/srv/reactor/old_cmd.sls": textwrap.dedent(
64         """\
65         install_zsh:
66           cmd.state.single:
67             - tgt: test
68             - arg:
69               - pkg.installed
70               - {{ data['data']['pkg'] }}
71             - kwarg:
72                 fromrepo: {{ data['data']['repo'] }}
73         """
74     ),
75     "/srv/reactor/old_caller.sls": textwrap.dedent(
76         """\
77         touch_file:
78           caller.file.touch:
79             - args:
80               - {{ data['data']['path'] }}
81         """
82     ),
83     "/srv/reactor/new_runner.sls": textwrap.dedent(
84         """\
85         raise_error:
86           runner.error.error:
87             - args:
88               - name: Exception
89               - message: {{ data['data']['message'] }}
90         """
91     ),
92     "/srv/reactor/new_wheel.sls": textwrap.dedent(
93         """\
94         remove_key:
95           wheel.key.delete:
96             - args:
97               - match: {{ data['data']['id'] }}
98         """
99     ),
100     "/srv/reactor/new_local.sls": textwrap.dedent(
101         """\
102         install_zsh:
103           local.state.single:
104             - tgt: test
105             - args:
106               - fun: pkg.installed
107               - name: {{ data['data']['pkg'] }}
108               - fromrepo: {{ data['data']['repo'] }}
109         """
110     ),
111     "/srv/reactor/new_cmd.sls": textwrap.dedent(
112         """\
113         install_zsh:
114           cmd.state.single:
115             - tgt: test
116             - args:
117               - fun: pkg.installed
118               - name: {{ data['data']['pkg'] }}
119               - fromrepo: {{ data['data']['repo'] }}
120         """
121     ),
122     "/srv/reactor/new_caller.sls": textwrap.dedent(</b></font>
123         """\
124         touch_file:
125           caller.file.touch:
126             - args:
127               - name: {{ data['data']['path'] }}
128         """
129 }
130 LOW_CHUNKS <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
131     "old_runner": [
132         {
133             "state": "runner",
134             "__id__": "raise_error",
135             "__sls__": "/srv/reactor/old_runner.sls",
136             "order": 1,
137             "fun": "error.error",
138             "name": "Exception",
139             "message": "This is an error",
140         }
141     ],
142     "old_wheel": [
143         {
144             "state": "wheel",
145             "__id__": "remove_key",
146             "name": "remove_key",
147             "__sls__": "/srv/reactor/old_wheel.sls",
148             "order": 1,
149             "fun": "key.delete",
150             "match": "foo",
151         }
152     ],
153     "old_local": [
154         {
155             "state": "local",
156             "__id__": "install_zsh",
157             "name": "install_zsh",
158             "__sls__": "/srv/reactor/old_local.sls",
159             "order": 1,
160             "tgt": "test",
161             "fun": "state.single",
162             "arg": ["pkg.installed", "zsh"],
163             "kwarg": {"fromrepo": "updates"},
164         }
165     ],
166     "old_cmd": [
167         {
168             "state": "local",  # 'cmd' should be aliased to 'local'
169             "__id__": "install_zsh",
170             "name": "install_zsh",
171             "__sls__": "/srv/reactor/old_cmd.sls",
172             "order": 1,
173             "tgt": "test",
174             "fun": "state.single",
175             "arg": ["pkg.installed", "zsh"],
176             "kwarg": {"fromrepo": "updates"},
177         }
178     ],
179     "old_caller": [
180         {
181             "state": "caller",
182             "__id__": "touch_file",
183             "name": "touch_file",
184             "__sls__": "/srv/reactor/old_caller.sls",
185             "order": 1,
186             "fun": "file.touch",
187             "args": ["/tmp/foo"],
188         }
189     ],
190     "new_runner": [
191         {
192             "state": "runner",
193             "__id__": "raise_error",
194             "name": "raise_error",
195             "order": 1,
196             "fun": "error.error",
197             "args": [{"name"</b></font>: "Exception"}, {<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"message": "This is an error"}],
198         }
199     ],
200     "new_wheel": [
201         {
202             "state": "wheel",
203             "__id__": "remove_key",
204             "name": "remove_key",
205             "__sls__": "/srv/reactor/new_wheel.sls",
206             "order": 1,
207             "fun": "key.delete",
208             "args": [{"match": "foo"}],
209         }
210     ],
211     "new_local": [
212         {
213             "state": "local",
214             "__id__": "install_zsh",
215             "name": "install_zsh",
216             "__sls__": "/srv/reactor/new_local.sls",
217             "order": 1,
218             "tgt": "test",
219             "fun": "state.single",
220             "args": [
221                 {"fun": "pkg.installed"},
222                 {"name": "zsh"},
223                 {"fromrepo": "updates"},
224             ],
225         }
226     ],
227     "new_cmd": [
228         {
229             "state": "local",
230             "__id__": "install_zsh",
231             "name": "install_zsh",
232             "__sls__": "/srv/reactor/new_cmd.sls",
233             "order": 1,
234             "tgt": "test",
235             "fun": "state.single",
236             "args": [
237                 {"fun"</b></font>: "pkg.installed"},
238                 {"name": "zsh"},
239                 {"fromrepo": "updates"},
240             ],
241         }
242     ],
243     "new_caller": [
244         {
245             "state": "caller",
246             "__id__": "touch_file",
247             "name": "touch_file",
248             "order": 1,
249             "fun": "file.touch",
250             "args": [{<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"name": "/tmp/foo"}],
251         }
252     ],
253 }
254 WRAPPER_CALLS = {
255     "old_runner": (
256         "error.error",
257         {
258             "__state__": "runner",
259             "__id__": "raise_error",
260             "__sls__": "/srv/reactor/old_runner.sls",
261             "__user__": "Reactor",
262             "order": 1,
263             "arg": [],
264             "kwarg": {"name": "Exception", "message": "This is an error"},
265             "name": "Exception",
266             "message": "This is an error",
267         },
268     ),
269     "old_wheel": (
270         "key.delete",
271         {
272             "__state__": "wheel",
273             "__id__": "remove_key",
274             "name": "remove_key",
275             "__sls__": "/srv/reactor/old_wheel.sls",
276             "order": 1,
277             "__user__": "Reactor",
278             "arg": ["foo"],
279             "kwarg": {},
280             "match": "foo",
281         },
282     ),
283     "old_local": {
284         "args": ("test", "state.single"),
285         "kwargs": {
286             "state": "local",
287             "__id__": "install_zsh",
288             "name": "install_zsh",
289             "__sls__": "/srv/reactor/old_local.sls",
290             "order": 1,
291             "arg": ["pkg.installed", "zsh"],
292             "kwarg": {"fromrepo": "updates"},
293         },
294     },
295     "old_cmd": {
296         "args": ("test", "state.single"),
297         "kwargs": {
298             "state": "local",
299             "__id__": "install_zsh",
300             "name": "install_zsh",
301             "__sls__": "/srv/reactor/old_cmd.sls",
302             "order": 1,
303             "arg": ["pkg.installed", "zsh"],
304             "kwarg": {"fromrepo": "updates"},
305         },
306     },
307     "old_caller": {"args": ("file.touch", "/tmp/foo"), "kwargs": {}},
308     "new_runner": (
309         "error.error"</b></font>,
310         {
311             "__state__": "runner",
312             "__id__": "raise_error",
313             "name": "raise_error",
314             "__sls__": "/srv/reactor/new_runner.sls",
315             "__user__": "Reactor",
316             "order": 1,
317             "arg": (),
318             "kwarg": {"name": "Exception", "message": "This is an error"},
319         },
320     ),
321     "new_wheel": (
322         "key.delete",
323         {
324             "__state__": "wheel",
325             "__id__": "remove_key",
326             "name": "remove_key",
327             "__sls__": "/srv/reactor/new_wheel.sls",
328             "order": 1,
329             "__user__": "Reactor",
330             "arg": (),
331             "kwarg": {"match": "foo"},
332         },
333     ),
334     "new_local": {
335         "args": ("test", "state.single"),
336         "kwargs": {
337             "state": "local",
338             "__id__": "install_zsh",
339             "name": "install_zsh",
340             "__sls__": "/srv/reactor/new_local.sls",
341             "order": 1,
342             "arg": (),
343             "kwarg": {"fun": "pkg.installed", "name": "zsh", "fromrepo": "updates"},
344         },
345     },
346     "new_cmd": {
347         "args": ("test", "state.single"),
348         "kwargs": {
349             "state": "local",
350             "__id__": "install_zsh",
351             "name": "install_zsh",
352             "__sls__": "/srv/reactor/new_cmd.sls",
353             "order": 1,
354             "arg": (),
355             "kwarg": {"fun": "pkg.installed", "name": "zsh", "fromrepo": "updates"},
356         },
357     },
358     "new_caller": {"args": ("file.touch",), "kwargs": {"name": "/tmp/foo"}},
359 }
360 log = logging.getLogger(__name__)
361 class TestReactor(TestCase, AdaptedConfigurationTestCaseMixin):
362     """
363     Tests for constructing the low chunks to be executed via the Reactor
364     """
365     @classmethod
366     def setUpClass(cls):
367         """
368         Load the reactor config for mocking
369         """
370         cls.opts = cls.get_temp_config("master")
371         reactor_config = salt.utils.yaml.safe_load(REACTOR_CONFIG)
372         cls.opts.update(reactor_config)
373         cls.reactor = reactor.Reactor(cls.opts)
374         cls.reaction_map = salt.utils.data.repack_dictlist(reactor_config["reactor"])
375         renderers = salt.loader.render(cls.opts, {})
376         cls.render_pipe = [(renderers[x], "") for x in ("jinja", "yaml")]
377     @classmethod
378     def tearDownClass(cls):
379         del cls.opts
380         del cls.reactor
381         del cls.render_pipe
382     def test_list_reactors(self):
383         """
384         Ensure that list_reactors() returns the correct list of reactor SLS
385         files for each tag.
386         """
387         for schema in ("old", "new"):
388             for rtype in REACTOR_DATA:
389                 tag = "_".join((schema, rtype))
390                 self.assertEqual(
391                     self.reactor.list_reactors(tag), self.reaction_map[tag]
392                 )
393     def test_reactions(self):
394         """
395         Ensure that the correct reactions are built from the configured SLS
396         files and tag data.
397         """
398         for schema in ("old", "new"):
399             for rtype in REACTOR_DATA:
400                 tag = "_".join((schema, rtype))
401                 log.debug("test_reactions: processing %s", tag)
402                 reactors = self.reactor.list_reactors(tag)
403                 log.debug("test_reactions: %s reactors: %s", tag, reactors)
404                 with patch.object(glob, "glob", MagicMock(side_effect=lambda x: [x])):
405                     with patch.object(os.path, "isfile", MagicMock(return_value=True)):
406                         with patch.object(
407                             salt.utils.files, "is_empty", MagicMock(return_value=False)
408                         ):
409                             with patch.object(
410                                 codecs, "open", mock_open(read_data=SLS[reactors[0]])
411                             ):
412                                 with patch.object(
413                                     salt.template,
414                                     "template_shebang",
415                                     MagicMock(return_value=self.render_pipe),
416                                 ):
417                                     reactions = self.reactor.reactions(
418                                         tag,
419                                         REACTOR_DATA[rtype],
420                                         reactors,
421                                     )
422                                     log.debug(
423                                         "test_reactions: %s reactions: %s",
424                                         tag,
425                                         reactions,
426                                     )
427                                     self.assertEqual(reactions, LOW_CHUNKS[tag])
428 class TestReactWrap(TestCase, AdaptedConfigurationTestCaseMixin):
429     """
430     Tests that we are formulating the wrapper calls properly
431     """
432     @classmethod
433     def setUpClass(cls):
434         cls.wrap = reactor.ReactWrap(cls.get_temp_config("master"))
435     @classmethod
436     def tearDownClass(cls):
437         del cls.wrap
438     def test_runner(self):
439         """
440         Test runner reactions using both the old and new config schema
441         """
442         for schema in ("old", "new"):
443             tag = "_".join((schema, "runner"))
444             chunk = LOW_CHUNKS[tag][0]
445             thread_pool = Mock()
446             thread_pool.fire_async = Mock()
447             with patch.object(self.wrap, "pool", thread_pool):
448                 self.wrap.run(chunk)
449             thread_pool.fire_async.assert_called_with(
450                 self.wrap.client_cache["runner"].low, args=WRAPPER_CALLS[tag]
451             )
452     def test_wheel(self):
453         """
454         Test wheel reactions using both the old and new config schema
455         """
456         for schema in ("old", "new"):
457             tag = "_".join((schema, "wheel"))
458             chunk = LOW_CHUNKS[tag][0]
459             thread_pool = Mock()
460             thread_pool.fire_async = Mock()
461             with patch.object(self.wrap, "pool", thread_pool):
462                 self.wrap.run(chunk)
463             thread_pool.fire_async.assert_called_with(
464                 self.wrap.client_cache["wheel"].low, args=WRAPPER_CALLS[tag]
465             )
466     def test_local(self):
467         """
468         Test local reactions using both the old and new config schema
469         """
470         for schema in ("old", "new"):
471             tag = "_".join((schema, "local"))
472             chunk = LOW_CHUNKS[tag][0]
473             client_cache = {"local": Mock()}
474             client_cache["local"].cmd_async = Mock()
475             with patch.object(self.wrap, "client_cache", client_cache):
476                 self.wrap.run(chunk)
477             client_cache["local"].cmd_async.assert_called_with(
478                 *WRAPPER_CALLS[tag]["args"], **WRAPPER_CALLS[tag]["kwargs"]
479             )
480     def test_cmd(self):
481         """
482         Test cmd reactions (alias for 'local') using both the old and new
483         config schema
484         """
485         for schema in ("old", "new"):
486             tag = "_".join((schema, "cmd"))
487             chunk = LOW_CHUNKS[tag][0]
488             client_cache = {"local": Mock()}
489             client_cache["local"].cmd_async = Mock()
490             with patch.object(self.wrap, "client_cache", client_cache):
491                 self.wrap.run(chunk)
492             client_cache["local"].cmd_async.assert_called_with(
493                 *WRAPPER_CALLS[tag]["args"], **WRAPPER_CALLS[tag]["kwargs"]
494             )
495     def test_caller(self):
496         """
497         Test caller reactions using both the old and new config schema
498         """
499         for schema in ("old", "new"):
500             tag = "_".join((schema, "caller"))
501             chunk = LOW_CHUNKS[tag][0]
502             client_cache = {"caller": Mock()}
503             client_cache["caller"].cmd = Mock()
504             with patch.object(self.wrap, "client_cache", client_cache):
505                 self.wrap.run(chunk)
506             client_cache["caller"].cmd.assert_called_with(
507                 *WRAPPER_CALLS[tag]["args"], **WRAPPER_CALLS[tag]["kwargs"]
508             )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_dockermod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 tests.unit.utils.test_dockermod
3 ===============================
4 """
5 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
6 import functools
7 import logging
8 import os
9 import salt.config
10 import salt.loader
11 import salt.utils.dockermod.translate.container
12 import salt.utils.dockermod.translate.network
13 import salt.utils.platform
14 from salt.exceptions import CommandExecutionError
15 from salt.utils.dockermod.translate import helpers as translate_helpers
16 from tests.support.unit import TestCase
17 log =</b></font> logging.getLogger(__name__)
18 class Assert:
19     def __init__(self, translator):
20         self.translator = translator
21     def __call__(self, func):
22         self.func = func
23         return functools.wraps(func)(
24             lambda testcase, *args, **kwargs: self.wrap(testcase, *args, **kwargs)
25         )
26     def wrap(self, *args, **kwargs):
27         raise NotImplementedError
28     def test_stringlist(self, testcase, name):
29         alias = self.translator.ALIASES_REVMAP.get(name)
30         if salt.utils.platform.is_windows():
31             data = [r"c:\foo", r"c:\bar", r"c:\baz"]
32         else:
33             data = ["/foo", "/bar", "/baz"]
34         for item in (name, alias):
35             if item is None:
36                 continue
37             testcase.assertEqual(
38                 salt.utils.dockermod.translate_input(
39                     self.translator, **{item: ",".join(data)}
40                 ),
41                 testcase.apply_defaults({name: data}),
42             )
43             testcase.assertEqual(
44                 salt.utils.dockermod.translate_input(self.translator, **{item: data}),
45                 testcase.apply_defaults({name: data}),
46             )
47             if name != "volumes":
48                 testcase.assertEqual(
49                     salt.utils.dockermod.translate_input(
50                         self.translator, **{item: ["one", 2]}
51                     ),
52                     testcase.apply_defaults({name: ["one", "2"]}),
53                 )
54         if alias is not None:
55             test_kwargs = {name: data, alias: sorted(data)}
56             testcase.assertEqual(
57                 salt.utils.dockermod.translate_input(
58                     self.translator, ignore_collisions=True, **test_kwargs
59                 ),
60                 testcase.apply_defaults({name: test_kwargs[name]}),
61             )
62             with testcase.assertRaisesRegex(
63                 CommandExecutionError, "is an alias for.+cannot both be used"
64             ):
65                 salt.utils.dockermod.translate_input(
66                     self.translator, ignore_collisions=False, **test_kwargs
67                 )
68     def test_key_value(self, testcase, name, delimiter):
69         """
70         Common logic for key/value pair testing. IP address validation is
71         turned off here, and must be done separately in the wrapped function.
72         """
73         alias = self.translator.ALIASES_REVMAP.get(name)
74         expected = {"foo": "bar", "baz": "qux"}
75         vals = "foo{0}bar,baz{0}qux".format(delimiter)
76         for item in (name, alias):
77             if item is None:
78                 continue
79             for val in (vals, vals.split(",")):
80                 testcase.assertEqual(
81                     salt.utils.dockermod.translate_input(
82                         self.translator, validate_ip_addrs=False, **{item: val}
83                     ),
84                     testcase.apply_defaults({name: expected}),
85                 )
86             testcase.assertEqual(
87                 salt.utils.dockermod.translate_input(
88                     self.translator, validate_ip_addrs=False, **{item: expected}
89                 ),
90                 testcase.apply_defaults({name: expected}),
91             )
92             testcase.assertEqual(
93                 salt.utils.dockermod.translate_input(
94                     self.translator,
95                     validate_ip_addrs=False,
96                     **{item: [{"foo": "bar"}, {"baz": "qux"}]}
97                 ),
98                 testcase.apply_defaults({name: expected}),
99             )
100         if alias is not None:
101             test_kwargs = {name: vals, alias: "hello{}world".format(delimiter)}
102             testcase.assertEqual(
103                 salt.utils.dockermod.translate_input(
104                     self.translator,
105                     validate_ip_addrs=False,
106                     ignore_collisions=True,
107                     **test_kwargs
108                 ),
109                 testcase.apply_defaults({name: expected}),
110             )
111             with testcase.assertRaisesRegex(
112                 CommandExecutionError, "is an alias for.+cannot both be used"
113             ):
114                 salt.utils.dockermod.translate_input(
115                     self.translator,
116                     validate_ip_addrs=False,
117                     ignore_collisions=False,
118                     **test_kwargs
119                 )
120 class assert_bool(Assert):
121     """
122     Test a boolean value
123     """
124     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
125         name = self.func.__name__[5:]
126         alias = self.translator.ALIASES_REVMAP.get(name)
127         for item in (name, alias):
128             if item is None:
129                 continue
130             testcase.assertEqual(
131                 salt.utils.dockermod.translate_input(self.translator, **{item: True}),
132                 testcase.apply_defaults({name: True}),
133             )
134             testcase.assertEqual(
135                 salt.utils.dockermod.translate_input(self.translator, **{item: "foo"}),
136                 testcase.apply_defaults({name: True}),
137             )
138             testcase.assertEqual(
139                 salt.utils.dockermod.translate_input(self.translator, **{item: 0}),
140                 testcase.apply_defaults({name: False}),
141             )
142         if alias is not None:
143             test_kwargs = {name: True, alias: False}
144             testcase.assertEqual(
145                 salt.utils.dockermod.translate_input(
146                     self.translator, ignore_collisions=True, **test_kwargs
147                 ),
148                 testcase.apply_defaults({name: test_kwargs[name]}),
149             )
150             with testcase.assertRaisesRegex(
151                 CommandExecutionError, "is an alias for.+cannot both be used"
152             ):
153                 salt.utils.dockermod.translate_input(
154                     self.translator, ignore_collisions=False, **test_kwargs
155                 )
156         return self.func(testcase, *args, **kwargs)
157 class assert_int(Assert):
158     """
159     Test an integer value
160     """
161     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
162         name = self.func.__name__[5:]
163         alias = self.translator.ALIASES_REVMAP.get(name)
164         for item in (name, alias):
165             if item is None:
166                 continue
167             for val in (100, "100"):
168                 testcase.assertEqual(
169                     salt.utils.dockermod.translate_input(
170                         self.translator, **{item: val}
171                     ),
172                     testcase.apply_defaults({name: 100}),
173                 )
174             with testcase.assertRaisesRegex(
175                 CommandExecutionError, "'foo' is not an integer"
176             ):
177                 salt.utils.dockermod.translate_input(self.translator, **{item: "foo"})
178         if alias is not None:
179             test_kwargs = {name: 100, alias: 200}
180             testcase.assertEqual(
181                 salt.utils.dockermod.translate_input(
182                     self.translator, ignore_collisions=True, **test_kwargs
183                 ),
184                 testcase.apply_defaults({name: test_kwargs[name]}),
185             )
186             with testcase.assertRaisesRegex(
187                 CommandExecutionError, "is an alias for.+cannot both be used"
188             ):
189                 salt.utils.dockermod.translate_input(
190                     self.translator, ignore_collisions=False, **test_kwargs
191                 )
192         return self.func(testcase, *args, **kwargs)
193 class assert_string(Assert):
194     """
195     Test that item is a string or is converted to one
196     """
197     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
198         name = self.func.__name__[5:]
199         alias = self.translator.ALIASES_REVMAP.get(name)
200         if salt.utils.platform.is_windows():
201             data = r"c:\foo"
202         else:
203             data = "/foo"
204         for item in (name, alias):
205             if item is None:
206                 continue
207             testcase.assertEqual(
208                 salt.utils.dockermod.translate_input(self.translator, **{item: data}),
209                 testcase.apply_defaults({name: data}),
210             )
211             if name != "working_dir":
212                 testcase.assertEqual(
213                     salt.utils.dockermod.translate_input(
214                         self.translator, **{item: 123}
215                     ),
216                     testcase.apply_defaults({name: "123"}),
217                 )
218         if alias is not None:
219             test_kwargs = {name: data, alias: data}
220             testcase.assertEqual(
221                 salt.utils.dockermod.translate_input(
222                     self.translator, ignore_collisions=True, **test_kwargs
223                 ),
224                 testcase.apply_defaults({name: test_kwargs[name]}),
225             )
226             with testcase.assertRaisesRegex(
227                 CommandExecutionError, "is an alias for.+cannot both be used"
228             ):
229                 salt.utils.dockermod.translate_input(
230                     self.translator, ignore_collisions=False, **test_kwargs
231                 )
232         return self.func(testcase, *args, **kwargs)
233 class assert_int_or_string(Assert):
234     """
235     Test an integer or string value
236     """
237     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
238         name = self.func.__name__[5:]
239         alias = self.translator.ALIASES_REVMAP.get(name)
240         for item in (name, alias):
241             if item is None:
242                 continue
243             testcase.assertEqual(
244                 salt.utils.dockermod.translate_input(self.translator, **{item: 100}),
245                 testcase.apply_defaults({name: 100}),
246             )
247             testcase.assertEqual(
248                 salt.utils.dockermod.translate_input(self.translator, **{item: "100M"}),
249                 testcase.apply_defaults({name: "100M"}),
250             )
251         if alias is not None:
252             test_kwargs = {name: 100, alias: "100M"}
253             testcase.assertEqual(
254                 salt.utils.dockermod.translate_input(
255                     self.translator, ignore_collisions=True, **test_kwargs
256                 ),
257                 testcase.apply_defaults({name: test_kwargs[name]}),
258             )
259             with testcase.assertRaisesRegex(
260                 CommandExecutionError, "is an alias for.+cannot both be used"
261             ):
262                 salt.utils.dockermod.translate_input(
263                     self.translator, ignore_collisions=False, **test_kwargs
264                 )
265         return self.func(testcase, *args, **kwargs)
266 class assert_stringlist(Assert):
267     """
268     Test a comma-separated or Python list of strings
269     """
270     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
271         name = self.func.__name__[5:]
272         self.test_stringlist(testcase, name)
273         return self.func(testcase, *args, **kwargs)
274 class assert_dict(Assert):
275     """
276     Dictionaries should be untouched, dictlists should be repacked and end up
277     as a single dictionary.
278     """
279     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
280         name = self.func.__name__[5:]
281         alias = self.translator.ALIASES_REVMAP.get(name)
282         expected = {"foo": "bar", "baz": "qux"}
283         for item in (name, alias):
284             if item is None:
285                 continue
286             testcase.assertEqual(
287                 salt.utils.dockermod.translate_input(
288                     self.translator, **{item: expected}
289                 ),
290                 testcase.apply_defaults({name: expected}),
291             )
292             testcase.assertEqual(
293                 salt.utils.dockermod.translate_input(
294                     self.translator, **{item: [{x: y} for x, y in expected.items()]}
295                 ),
296                 testcase.apply_defaults({name: expected}),
297             )
298             with testcase.assertRaisesRegex(
299                 CommandExecutionError, "'foo' is not a dictionary"
300             ):
301                 salt.utils.dockermod.translate_input(self.translator, **{item: "foo"})
302         if alias is not None:
303             test_kwargs = {name: "foo", alias: "bar"}
304             testcase.assertEqual(
305                 salt.utils.dockermod.translate_input(
306                     self.translator, ignore_collisions=True, **test_kwargs
307                 ),
308                 testcase.apply_defaults({name: test_kwargs[name]}),
309             )
310             with testcase.assertRaisesRegex(
311                 CommandExecutionError, "is an alias for.+cannot both be used"
312             ):
313                 salt.utils.dockermod.translate_input(
314                     self.translator, ignore_collisions=False, **test_kwargs
315                 )
316         return self.func(testcase, *args, **kwargs)
317 class assert_cmd(Assert):
318     """
319     Test for a string, or a comma-separated or Python list of strings. This is
320     different from a stringlist in that we do not do any splitting. This
321     decorator is used both by the "command" and "entrypoint" arguments.
322     """
323     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
324         name = self.func.__name__[5:]
325         alias = self.translator.ALIASES_REVMAP.get(name)
326         for item in (name, alias):
327             if item is None:
328                 continue
329             testcase.assertEqual(
330                 salt.utils.dockermod.translate_input(
331                     self.translator, **{item: "foo bar"}
332                 ),
333                 testcase.apply_defaults({name: "foo bar"}),
334             )
335             testcase.assertEqual(
336                 salt.utils.dockermod.translate_input(
337                     self.translator, **{item: ["foo", "bar"]}
338                 ),
339                 testcase.apply_defaults({name: ["foo", "bar"]}),
340             )
341             testcase.assertEqual(
342                 salt.utils.dockermod.translate_input(self.translator, **{item: 123}),
343                 testcase.apply_defaults({name: "123"}),
344             )
345             testcase.assertEqual(
346                 salt.utils.dockermod.translate_input(
347                     self.translator, **{item: ["one", 2]}
348                 ),
349                 testcase.apply_defaults({name: ["one", "2"]}),
350             )
351         if alias is not None:
352             test_kwargs = {name: "foo", alias: "bar"}
353             testcase.assertEqual(
354                 salt.utils.dockermod.translate_input(
355                     self.translator, ignore_collisions=True, **test_kwargs
356                 ),
357                 testcase.apply_defaults({name: test_kwargs[name]}),
358             )
359             with testcase.assertRaisesRegex(
360                 CommandExecutionError, "is an alias for.+cannot both be used"
361             ):
362                 salt.utils.dockermod.translate_input(
363                     self.translator, ignore_collisions=False, **test_kwargs
364                 )
365         return self.func(testcase, *args, **kwargs)
366 class assert_key_colon_value(Assert):
367     """
368     Test a key/value pair with parameters passed as key:value pairs
369     """
370     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
371         name = self.func.__name__[5:]
372         self.test_key_value(testcase, name, ":")
373         return self.func(testcase, *args, **kwargs)
374 class assert_key_equals_value(Assert):
375     """
376     Test a key/value pair with parameters passed as key=value pairs
377     """
378     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
379         name = self.func.__name__[5:]
380         self.test_key_value(testcase, name, "=")
381         if name == "labels":
382             self.test_stringlist(testcase, name)
383         return self.func(testcase, *args, **kwargs)
384 class assert_labels(Assert):
385     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
386         name = self.func.__name__[5:]
387         alias = self.translator.ALIASES_REVMAP.get(name)
388         labels = ["foo", "bar=baz", {"hello": "world"}]
389         expected = {"foo": "", "bar": "baz", "hello": "world"}
390         for item in (name, alias):
391             if item is None:
392                 continue
393             testcase.assertEqual(
394                 salt.utils.dockermod.translate_input(self.translator, **{item: labels}),
395                 testcase.apply_defaults({name: expected}),
396             )
397             bad_labels = copy.deepcopy(labels)
398             bad_labels[-1]["bad"] = "input"
399             with testcase.assertRaisesRegex(
400                 CommandExecutionError, r"Invalid label\(s\)"
401             ):
402                 salt.utils.dockermod.translate_input(
403                     self.translator, **{item: bad_labels}
404                 )
405         return self.func(testcase, *args, **kwargs)
406 class assert_device_rates(Assert):
407     """
408     Tests for device_{read,write}_{bps,iops}. The bps values have a "Rate"
409     value expressed in bytes/kb/mb/gb, while the iops values have a "Rate"
410     expressed as a simple integer.
411     """
412     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
413         name = self.func.__name__[5:]
414         alias = self.translator.ALIASES_REVMAP.get(name)
415         for item in (name, alias):
416             if item is None:
417                 continue
418             path = os.path.join("foo", "bar", "baz")
419             with testcase.assertRaisesRegex(
420                 CommandExecutionError,
421                 "Path '{}' is not absolute".format(path.replace("\\", "\\\\")),
422             ):
423                 salt.utils.dockermod.translate_input(
424                     self.translator, **{item: "{}:1048576".format(path)}
425                 )
426             if name.endswith("_bps"):
427                 expected = ({}, [])
428                 vals = "/dev/sda:1048576,/dev/sdb:1048576"
429                 for val in (vals, vals.split(",")):
430                     testcase.assertEqual(
431                         salt.utils.dockermod.translate_input(
432                             self.translator, **{item: val}
433                         ),
434                         testcase.apply_defaults(
435                             {
436                                 name: [
437                                     {"Path": "/dev/sda", "Rate": 1048576},
438                                     {"Path": "/dev/sdb", "Rate": 1048576},
439                                 ]
440                             }
441                         ),
442                     )
443                 vals = "/dev/sda:1mb,/dev/sdb:5mb"
444                 for val in (vals, vals.split(",")):
445                     testcase.assertEqual(
446                         salt.utils.dockermod.translate_input(
447                             self.translator, **{item: val}
448                         ),
449                         testcase.apply_defaults(
450                             {
451                                 name: [
452                                     {"Path": "/dev/sda", "Rate": "1mb"},
453                                     {"Path": "/dev/sdb", "Rate": "5mb"},
454                                 ]
455                             }
456                         ),
457                     )
458                 if alias is not None:
459                     test_kwargs = {
460                         name: "/dev/sda:1048576,/dev/sdb:1048576",
461                         alias: "/dev/sda:1mb,/dev/sdb:5mb",
462                     }
463                     testcase.assertEqual(
464                         salt.utils.dockermod.translate_input(
465                             self.translator, ignore_collisions=True, **test_kwargs
466                         ),
467                         testcase.apply_defaults(
468                             {
469                                 name: [
470                                     {"Path": "/dev/sda", "Rate": 1048576},
471                                     {"Path": "/dev/sdb", "Rate": 1048576},
472                                 ]
473                             }
474                         ),
475                     )
476                     with testcase.assertRaisesRegex(
477                         CommandExecutionError, "is an alias for.+cannot both be used"
478                     ):
479                         salt.utils.dockermod.translate_input(
480                             self.translator, ignore_collisions=False, **test_kwargs
481                         )
482             else:
483                 vals = "/dev/sda:1000,/dev/sdb:500"
484                 for val in (vals, vals.split(",")):
485                     testcase.assertEqual(
486                         salt.utils.dockermod.translate_input(
487                             self.translator, **{item: val}
488                         ),
489                         testcase.apply_defaults(
490                             {
491                                 name: [
492                                     {"Path": "/dev/sda", "Rate": 1000},
493                                     {"Path": "/dev/sdb", "Rate": 500},
494                                 ]
495                             }
496                         ),
497                     )
498                 expected = (
499                     {},
500                     {item: "Rate '5mb' for path '/dev/sdb' is non-numeric"},
501                     [],
502                 )
503                 vals = "/dev/sda:1000,/dev/sdb:5mb"
504                 for val in (vals, vals.split(",")):
505                     with testcase.assertRaisesRegex(
506                         CommandExecutionError,
507                         "Rate '5mb' for path '/dev/sdb' is non-numeric",
508                     ):
509                         salt.utils.dockermod.translate_input(
510                             self.translator, **{item: val}
511                         )
512                 if alias is not None:
513                     test_kwargs = {
514                         name: "/dev/sda:1000,/dev/sdb:500",
515                         alias: "/dev/sda:888,/dev/sdb:999",
516                     }
517                     testcase.assertEqual(
518                         salt.utils.dockermod.translate_input(
519                             self.translator, ignore_collisions=True, **test_kwargs
520                         ),
521                         testcase.apply_defaults(
522                             {
523                                 name: [
524                                     {"Path": "/dev/sda", "Rate": 1000},
525                                     {"Path": "/dev/sdb", "Rate": 500},
526                                 ]
527                             }
528                         ),
529                     )
530                     with testcase.assertRaisesRegex(
531                         CommandExecutionError, "is an alias for.+cannot both be used"
532                     ):
533                         salt.utils.dockermod.translate_input(
534                             self.translator, ignore_collisions=False, **test_kwargs
535                         )
536         return self.func(testcase, *args, **kwargs)
537 class assert_subnet(Assert):
538     """
539     Test an IPv4 or IPv6 subnet
540     """
541     def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
542         name = self.func.__name__[5:]
543         alias = self.translator.ALIASES_REVMAP.get(name)
544         for item in (name, alias):
545             if item is None:
546                 continue
547             for val in ("127.0.0.1/32", "::1/128"):
548                 log.debug("Verifying '%s' is a valid subnet", val)
549                 testcase.assertEqual(
550                     salt.utils.dockermod.translate_input(
551                         self.translator, validate_ip_addrs=True, **{item: val}
552                     ),
553                     testcase.apply_defaults({name: val}),
554                 )
555             for val in (
556                 "127.0.0.1",
557                 "999.999.999.999/24",
558                 "10.0.0.0/33",
559                 "::1",
560                 "feaz::1/128",
561                 "::1/129",
562             ):
563                 log.debug("Verifying '%s' is not a valid subnet", val)
564                 with testcase.assertRaisesRegex(
565                     CommandExecutionError, "'{}' is not a valid subnet".format(val)
566                 ):
567                     salt.utils.dockermod.translate_input(
568                         self.translator, validate_ip_addrs=True, **{item: val}
569                     )
570             val = "foo"
571             testcase.assertEqual(
572                 salt.utils.dockermod.translate_input(
573                     self.translator, validate_ip_addrs=False, **{item: val}
574                 ),
575                 testcase.apply_defaults({name: val}),
576             )
577         if alias is not None:
578             test_kwargs = {name: "10.0.0.0/24", alias: "192.168.50.128/25"}
579             testcase.assertEqual(
580                 salt.utils.dockermod.translate_input(
581                     self.translator, ignore_collisions=True, **test_kwargs
582                 ),
583                 testcase.apply_defaults({name: test_kwargs[name]}),
584             )
585             with testcase.assertRaisesRegex(
586                 CommandExecutionError, "is an alias for.+cannot both be used"
587             ):
588                 salt.utils.dockermod.translate_input(
589                     self.translator, ignore_collisions=False, **test_kwargs
590                 )
591         return self.func(testcase, *args, **kwargs)
592 class TranslateBase(TestCase):
593     maxDiff = None
594     translator = None  # Must be overridden in the subclass
595     def apply_defaults(self, ret, skip_translate=None):
596         if skip_translate is not True:
597             defaults = getattr(self.translator, "DEFAULTS", {})
598             for key, val in defaults.items():
599                 if key not in ret:
600                     ret[key] = val
601         return ret
602     @staticmethod
603     def normalize_ports(ret):
604         """
605         When we translate exposed ports, we can end up with a mixture of ints
606         (representing TCP ports) and tuples (representing UDP ports). Python 2
607         will sort an iterable containing these mixed types, but Python 3 will
608         not. This helper is used to munge the ports in the return data so that
609         the resulting list is sorted in a way that can reliably be compared to
610         the expected results in the test.
611         This helper should only be needed for port_bindings and ports.
612         """
613         if "ports" in ret[0]:
614             tcp_ports = []
615             udp_ports = []
616             for item in ret[0]["ports"]:
617                 if isinstance(item, int):
618                     tcp_ports.append(item)
619                 else:
620                     udp_ports.append(item)
621             ret[0]["ports"] = sorted(tcp_ports) + sorted(udp_ports)
622         return ret
623     def tearDown(self):
624         """
625         Test skip_translate kwarg
626         """
627         name = self.id().split(".")[-1][5:]
628         for val in (True, name, [name]):
629             self.assertEqual(
630                 salt.utils.dockermod.translate_input(
631                     self.translator, skip_translate=val, **{name: "foo"}
632                 ),
633                 self.apply_defaults({name: "foo"}, skip_translate=val),
634             )
635 class TranslateContainerInputTestCase(TranslateBase):
636     """
637     Tests for salt.utils.dockermod.translate_input(), invoked using
638     salt.utils.dockermod.translate.container as the translator module.
639     """
640     translator = salt.utils.dockermod.translate.container
641     @staticmethod
642     def normalize_ports(ret):
643         """
644         When we translate exposed ports, we can end up with a mixture of ints
645         (representing TCP ports) and tuples (representing UDP ports). Python 2
646         will sort an iterable containing these mixed types, but Python 3 will
647         not. This helper is used to munge the ports in the return data so that
648         the resulting list is sorted in a way that can reliably be compared to
649         the expected results in the test.
650         This helper should only be needed for port_bindings and ports.
651         """
652         if "ports" in ret:
653             tcp_ports = []
654             udp_ports = []
655             for item in ret["ports"]:
656                 if isinstance(item, int):
657                     tcp_ports.append(item)
658                 else:
659                     udp_ports.append(item)
660             ret["ports"] = sorted(tcp_ports) + sorted(udp_ports)
661         return ret
662     @assert_bool(salt.utils.dockermod.translate.container)
663     def test_auto_remove(self):
664         """
665         Should be a bool or converted to one
666         """
667     def test_binds(self):
668         """
669         Test the "binds" kwarg. Any volumes not defined in the "volumes" kwarg
670         should be added to the results.
671         """
672         self.assertEqual(
673             salt.utils.dockermod.translate_input(
674                 self.translator, binds="/srv/www:/var/www:ro", volumes="/testing"
675             ),
676             {"binds": ["/srv/www:/var/www:ro"], "volumes": ["/testing", "/var/www"]},
677         )
678         self.assertEqual(
679             salt.utils.dockermod.translate_input(
680                 self.translator, binds=["/srv/www:/var/www:ro"], volumes="/testing"
681             ),
682             {"binds": ["/srv/www:/var/www:ro"], "volumes": ["/testing", "/var/www"]},
683         )
684         self.assertEqual(
685             salt.utils.dockermod.translate_input(
686                 self.translator,
687                 binds={"/srv/www": {"bind": "/var/www", "mode": "ro"}},
688                 volumes="/testing",
689             ),
690             {
691                 "binds": {"/srv/www": {"bind": "/var/www", "mode": "ro"}},
692                 "volumes": ["/testing", "/var/www"],
693             },
694         )
695     @assert_int(salt.utils.dockermod.translate.container)
696     def test_blkio_weight(self):
697         """
698         Should be an int or converted to one
699         """
700     def test_blkio_weight_device(self):
701         """
702         Should translate a list of PATH:WEIGHT pairs to a list of dictionaries
703         with the following format: {'Path': PATH, 'Weight': WEIGHT}
704         """
705         for val in ("/dev/sda:100,/dev/sdb:200", ["/dev/sda:100", "/dev/sdb:200"]):
706             self.assertEqual(
707                 salt.utils.dockermod.translate_input(
708                     self.translator, blkio_weight_device="/dev/sda:100,/dev/sdb:200"
709                 ),
710                 {
711                     "blkio_weight_device": [
712                         {"Path": "/dev/sda", "Weight": 100},
713                         {"Path": "/dev/sdb", "Weight": 200},
714                     ]
715                 },
716             )
717         with self.assertRaisesRegex(
718             CommandExecutionError, r"'foo' contains 1 value\(s\) \(expected 2\)"
719         ):
720             salt.utils.dockermod.translate_input(
721                 self.translator, blkio_weight_device="foo"
722             )
723         with self.assertRaisesRegex(
724             CommandExecutionError, r"'foo:bar:baz' contains 3 value\(s\) \(expected 2\)"
725         ):
726             salt.utils.dockermod.translate_input(
727                 self.translator, blkio_weight_device="foo:bar:baz"
728             )
729         with self.assertRaisesRegex(
730             CommandExecutionError, r"Weight 'foo' for path '/dev/sdb' is not an integer"
731         ):
732             salt.utils.dockermod.translate_input(
733                 self.translator, blkio_weight_device=["/dev/sda:100", "/dev/sdb:foo"]
734             )
735     @assert_stringlist(salt.utils.dockermod.translate.container)
736     def test_cap_add(self):
737         """
738         Should be a list of strings or converted to one
739         """
740     @assert_stringlist(salt.utils.dockermod.translate.container)
741     def test_cap_drop(self):
742         """
743         Should be a list of strings or converted to one
744         """
745     @assert_cmd(salt.utils.dockermod.translate.container)
746     def test_command(self):
747         """
748         Can either be a string or a comma-separated or Python list of strings.
749         """
750     @assert_string(salt.utils.dockermod.translate.container)
751     def test_cpuset_cpus(self):
752         """
753         Should be a string or converted to one
754         """
755     @assert_string(salt.utils.dockermod.translate.container)
756     def test_cpuset_mems(self):
757         """
758         Should be a string or converted to one
759         """
760     @assert_int(salt.utils.dockermod.translate.container)
761     def test_cpu_group(self):
762         """
763         Should be an int or converted to one
764         """
765     @assert_int(salt.utils.dockermod.translate.container)
766     def test_cpu_period(self):
767         """
768         Should be an int or converted to one
769         """
770     @assert_int(salt.utils.dockermod.translate.container)
771     def test_cpu_shares(self):
772         """
773         Should be an int or converted to one
774         """
775     @assert_bool(salt.utils.dockermod.translate.container)
776     def test_detach(self):
777         """
778         Should be a bool or converted to one
779         """
780     @assert_device_rates(salt.utils.dockermod.translate.container)
781     def test_device_read_bps(self):
782         """
783         CLI input is a list of PATH:RATE pairs, but the API expects a list of
784         dictionaries in the format [{'Path': path, 'Rate': rate}]
785         """
786     @assert_device_rates(salt.utils.dockermod.translate.container)
787     def test_device_read_iops(self):
788         """
789         CLI input is a list of PATH:RATE pairs, but the API expects a list of
790         dictionaries in the format [{'Path': path, 'Rate': rate}]
791         """
792     @assert_device_rates(salt.utils.dockermod.translate.container)
793     def test_device_write_bps(self):
794         """
795         CLI input is a list of PATH:RATE pairs, but the API expects a list of
796         dictionaries in the format [{'Path': path, 'Rate': rate}]
797         """
798     @assert_device_rates(salt.utils.dockermod.translate.container)
799     def test_device_write_iops(self):
800         """
801         CLI input is a list of PATH:RATE pairs, but the API expects a list of
802         dictionaries in the format [{'Path': path, 'Rate': rate}]
803         """
804     @assert_stringlist(salt.utils.dockermod.translate.container)
805     def test_devices(self):
806         """
807         Should be a list of strings or converted to one
808         """
809     @assert_stringlist(salt.utils.dockermod.translate.container)
810     def test_dns_opt(self):
811         """
812         Should be a list of strings or converted to one
813         """
814     @assert_stringlist(salt.utils.dockermod.translate.container)
815     def test_dns_search(self):
816         """
817         Should be a list of strings or converted to one
818         """
819     def test_dns(self):
820         """
821         While this is a stringlist, it also supports IP address validation, so
822         it can't use the test_stringlist decorator because we need to test both
823         with and without validation, and it isn't necessary to make all other
824         stringlist tests also do that same kind of testing.
825         """
826         for val in ("8.8.8.8,8.8.4.4", ["8.8.8.8", "8.8.4.4"]):
827             self.assertEqual(
828                 salt.utils.dockermod.translate_input(
829                     self.translator,
830                     dns=val,
831                     validate_ip_addrs=True,
832                 ),
833                 {"dns": ["8.8.8.8", "8.8.4.4"]},
834             )
835         for val in ("8.8.8.888,8.8.4.4", ["8.8.8.888", "8.8.4.4"]):
836             with self.assertRaisesRegex(
837                 CommandExecutionError, r"'8.8.8.888' is not a valid IP address"
838             ):
839                 salt.utils.dockermod.translate_input(
840                     self.translator,
841                     dns=val,
842                     validate_ip_addrs=True,
843                 )
844         for val in ("foo,bar", ["foo", "bar"]):
845             self.assertEqual(
846                 salt.utils.dockermod.translate_input(
847                     self.translator,
848                     dns=val,
849                     validate_ip_addrs=False,
850                 ),
851                 {"dns": ["foo", "bar"]},
852             )
853     @assert_string(salt.utils.dockermod.translate.container)
854     def test_domainname(self):
855         """
856         Should be a list of strings or converted to one
857         """
858     @assert_cmd(salt.utils.dockermod.translate.container)
859     def test_entrypoint(self):
860         """
861         Can either be a string or a comma-separated or Python list of strings.
862         """
863     @assert_key_equals_value(salt.utils.dockermod.translate.container)
864     def test_environment(self):
865         """
866         Can be passed in several formats but must end up as a dictionary
867         mapping keys to values
868         """
869     def test_extra_hosts(self):
870         """
871         Can be passed as a list of key:value pairs but can't be simply tested
872         using @assert_key_colon_value since we need to test both with and without
873         IP address validation.
874         """
875         for val in ("web1:10.9.8.7,web2:10.9.8.8", ["web1:10.9.8.7", "web2:10.9.8.8"]):
876             self.assertEqual(
877                 salt.utils.dockermod.translate_input(
878                     self.translator,
879                     extra_hosts=val,
880                     validate_ip_addrs=True,
881                 ),
882                 {"extra_hosts": {"web1": "10.9.8.7", "web2": "10.9.8.8"}},
883             )
884         for val in (
885             "web1:10.9.8.299,web2:10.9.8.8",
886             ["web1:10.9.8.299", "web2:10.9.8.8"],
887         ):
888             with self.assertRaisesRegex(
889                 CommandExecutionError, r"'10.9.8.299' is not a valid IP address"
890             ):
891                 salt.utils.dockermod.translate_input(
892                     self.translator,
893                     extra_hosts=val,
894                     validate_ip_addrs=True,
895                 )
896         for val in ("foo:bar,baz:qux", ["foo:bar", "baz:qux"]):
897             self.assertEqual(
898                 salt.utils.dockermod.translate_input(
899                     self.translator,
900                     extra_hosts=val,
901                     validate_ip_addrs=False,
902                 ),
903                 {"extra_hosts": {"foo": "bar", "baz": "qux"}},
904             )
905     @assert_stringlist(salt.utils.dockermod.translate.container)
906     def test_group_add(self):
907         """
908         Should be a list of strings or converted to one
909         """
910     @assert_string(salt.utils.dockermod.translate.container)
911     def test_hostname(self):
912         """
913         Should be a string or converted to one
914         """
915     @assert_string(salt.utils.dockermod.translate.container)
916     def test_ipc_mode(self):
917         """
918         Should be a string or converted to one
919         """
920     @assert_string(salt.utils.dockermod.translate.container)
921     def test_isolation(self):
922         """
923         Should be a string or converted to one
924         """
925     @assert_labels(salt.utils.dockermod.translate.container)
926     def test_labels(self):
927         """
928         Can be passed as a list of key=value pairs or a dictionary, and must
929         ultimately end up as a dictionary.
930         """
931     @assert_key_colon_value(salt.utils.dockermod.translate.container)
932     def test_links(self):
933         """
934         Can be passed as a list of key:value pairs or a dictionary, and must
935         ultimately end up as a dictionary.
936         """
937     def test_log_config(self):
938         """
939         This is a mixture of log_driver and log_opt, which get combined into a
940         dictionary.
941         log_driver is a simple string, but log_opt can be passed in several
942         ways, so we need to test them all.
943         """
944         expected = (
945             {"log_config": {"Type": "foo", "Config": {"foo": "bar", "baz": "qux"}}},
946             {},
947             [],
948         )
949         for val in (
950             "foo=bar,baz=qux",
951             ["foo=bar", "baz=qux"],
952             [{"foo": "bar"}, {"baz": "qux"}],
953             {"foo": "bar", "baz": "qux"},
954         ):
955             self.assertEqual(
956                 salt.utils.dockermod.translate_input(
957                     self.translator, log_driver="foo", log_opt="foo=bar,baz=qux"
958                 ),
959                 {"log_config": {"Type": "foo", "Config": {"foo": "bar", "baz": "qux"}}},
960             )
961         self.assertEqual(
962             salt.utils.dockermod.translate_input(self.translator, log_driver="foo"),
963             {"log_config": {"Type": "foo", "Config": {}}},
964         )
965         self.assertEqual(
966             salt.utils.dockermod.translate_input(
967                 self.translator, log_opt={"foo": "bar", "baz": "qux"}
968             ),
969             {"log_config": {"Type": "none", "Config": {"foo": "bar", "baz": "qux"}}},
970         )
971     @assert_key_equals_value(salt.utils.dockermod.translate.container)
972     def test_lxc_conf(self):
973         """
974         Can be passed as a list of key=value pairs or a dictionary, and must
975         ultimately end up as a dictionary.
976         """
977     @assert_string(salt.utils.dockermod.translate.container)
978     def test_mac_address(self):
979         """
980         Should be a string or converted to one
981         """
982     @assert_int_or_string(salt.utils.dockermod.translate.container)
983     def test_mem_limit(self):
984         """
985         Should be a string or converted to one
986         """
987     @assert_int(salt.utils.dockermod.translate.container)
988     def test_mem_swappiness(self):
989         """
990         Should be an int or converted to one
991         """
992     @assert_int_or_string(salt.utils.dockermod.translate.container)
993     def test_memswap_limit(self):
994         """
995         Should be a string or converted to one
996         """
997     @assert_string(salt.utils.dockermod.translate.container)
998     def test_name(self):
999         """
1000         Should be a string or converted to one
1001         """
1002     @assert_bool(salt.utils.dockermod.translate.container)
1003     def test_network_disabled(self):
1004         """
1005         Should be a bool or converted to one
1006         """
1007     @assert_string(salt.utils.dockermod.translate.container)
1008     def test_network_mode(self):
1009         """
1010         Should be a string or converted to one
1011         """
1012     @assert_bool(salt.utils.dockermod.translate.container)
1013     def test_oom_kill_disable(self):
1014         """
1015         Should be a bool or converted to one
1016         """
1017     @assert_int(salt.utils.dockermod.translate.container)
1018     def test_oom_score_adj(self):
1019         """
1020         Should be an int or converted to one
1021         """
1022     @assert_string(salt.utils.dockermod.translate.container)
1023     def test_pid_mode(self):
1024         """
1025         Should be a string or converted to one
1026         """
1027     @assert_int(salt.utils.dockermod.translate.container)
1028     def test_pids_limit(self):
1029         """
1030         Should be an int or converted to one
1031         """
1032     def test_port_bindings(self):
1033         """
1034         This has several potential formats and can include port ranges. It
1035         needs its own test.
1036         """
1037         bindings = (
1038             "10.1.2.3:8080:80,10.1.2.3:8888:80,10.4.5.6:3333:3333,"
1039             "10.7.8.9:14505-14506:4505-4506,10.1.2.3:8080:81/udp,"
1040             "10.1.2.3:8888:81/udp,10.4.5.6:3334:3334/udp,"
1041             "10.7.8.9:15505-15506:5505-5506/udp"
1042         )
1043         for val in (bindings, bindings.split(",")):
1044                 self.normalize_ports(
1045                     salt.utils.dockermod.translate_input(
1046                         self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.translator,
1047                         port_bindings=val,
1048                     )
1049                 ),
1050                 {
1051                     "port_bindings": {
1052                         80: [("10.1.2.3", 8080), ("10.1.2.3", 8888)],
1053                         3333: ("10.4.5.6", 3333),
1054                         4505: ("10.7.8.9", 14505),
1055                         4506: ("10.7.8.9", 14506),
1056                         "81/udp": [("10.1.2.3", 8080), ("10.1.2.3", 8888)],
1057                         "3334/udp": ("10.4.5.6", 3334),
1058                         "5505/udp": ("10.7.8.9", 15505),
1059                         "5506/udp": ("10.7.8.9", 15506),
1060                     },
1061                     "ports": [
1062                         80,
1063                         3333,
1064                         4505,
1065                         4506,
1066                         (81, "udp"),
1067                         (3334, "udp"),
1068                         (5505, "udp"),
1069                         (5506</b></font>, "udp"),
1070                     ],
1071                 },
1072             )
1073         bindings = (
1074             "10.1.2.3::80,10.1.2.3::80,10.4.5.6::3333,10.7.8.9::4505-4506,"
1075             "10.1.2.3::81/udp,10.1.2.3::81/udp,10.4.5.6::3334/udp,"
1076             "10.7.8.9::5505-5506/udp"
1077         )
1078         for val in (bindings, bindings.split(",")):
1079             self.assertEqual(
1080                     salt.utils.dockermod.translate_input(
1081                         self.translator,
1082                         port_bindings<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=val,
1083                     )
1084                 ),
1085                 {
1086                     "port_bindings": {
1087                         80: [("10.1.2.3",), ("10.1.2.3",)],
1088                         3333: ("10.4.5.6",),
1089                         4505: ("10.7.8.9",),
1090                         4506: ("10.7.8.9",),
1091                         "81/udp": [("10.1.2.3",), ("10.1.2.3",)],
1092                         "3334/udp": ("10.4.5.6",),
1093                         "5505/udp": ("10.7.8.9",),
1094                         "5506/udp": ("10.7.8.9",),
1095                     },
1096                     "ports": [
1097                         80,
1098                         3333,
1099                         4505,
1100                         4506,
1101                         (81, "udp"),
1102                         (3334, "udp"),
1103                         (5505, "udp"),
1104                         (5506</b></font>, "udp"),
1105                     ],
1106                 },
1107             )
1108         bindings = (
1109             "8080:80,8888:80,3333:3333,14505-14506:4505-4506,8080:81/udp,"
1110             "8888:81/udp,3334:3334/udp,15505-15506:5505-5506/udp"
1111         )
1112         for val in (bindings, bindings.split(",")):
1113             self.assertEqual(
1114                 self.normalize_ports(
1115                     salt.utils.dockermod.translate_input(
1116                         self.translator,
1117                         port_bindings=val,
1118                     )
1119                 ),
1120                 {
1121                     "port_bindings": {
1122                         80: [8080, 8888],
1123                         3333: 3333,
1124                         4505: 14505,
1125                         4506: 14506,
1126                         "81/udp": [8080, 8888],
1127                         "3334/udp": 3334,
1128                         "5505/udp": 15505,
1129                         "5506/udp": 15506,
1130                     },
1131                     "ports": [
1132                         80,
1133                         3333,
1134                         4505,
1135                         4506,
1136                         (81, "udp"),
1137                         (3334, "udp"),
1138                         (5505, "udp"),
1139                         (5506, "udp"),
1140                     ],
1141                 },
1142             )
1143         bindings = "80,3333,4505-4506,81/udp,3334/udp,5505-5506/udp"
1144         for val in (bindings, bindings.split(",")):
1145             self.assertEqual(
1146                 self.normalize_ports(
1147                     salt.utils.dockermod.translate_input(
1148                         self.translator,
1149                         port_bindings=val,
1150                     )
1151                 ),
1152                 {
1153                     "port_bindings": {
1154                         80: None,
1155                         3333: None,
1156                         4505: None,
1157                         4506: None,
1158                         "81/udp": None,
1159                         "3334/udp": None,
1160                         "5505/udp": None,
1161                         "5506/udp": None,
1162                     },
1163                     "ports": [
1164                         80,
1165                         3333,
1166                         4505,
1167                         4506,
1168                         (81, "udp"),
1169                         (3334, "udp"),
1170                         (5505, "udp"),
1171                         (5506, "udp"),
1172                     ],
1173                 },
1174             )
1175         bindings = (
1176             "10.1.2.3:8080:80,10.4.5.6::3333,14505-14506:4505-4506,"
1177             "9999-10001,10.1.2.3:8080:81/udp,10.4.5.6::3334/udp,"
1178             "15505-15506:5505-5506/udp,19999-20001/udp"
1179         )
1180         for val in (bindings, bindings.split(",")):
1181             self.assertEqual(
1182                 self.normalize_ports(
1183                     salt.utils.dockermod.translate_input(
1184                         self.translator,
1185                         port_bindings=val,
1186                 ),
1187                 {
1188                     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"port_bindings": {
1189                         80: ("10.1.2.3", 8080),
1190                         3333: ("10.4.5.6",),
1191                         4505: 14505,
1192                         4506: 14506,
1193                         9999: None,
1194                         10000: None,
1195                         10001: None,
1196                         "81/udp": ("10.1.2.3", 8080),
1197                         "3334/udp": ("10.4.5.6",),
1198                         "5505/udp": 15505,
1199                         "5506/udp": 15506,
1200                         "19999/udp": None,
1201                         "20000/udp": None,
1202                         "20001/udp": None,
1203                     },
1204                     "ports": [
1205                         80,
1206                         3333,
1207                         4505,
1208                         4506,
1209                         9999,
1210                         10000,
1211                         10001,
1212                         (81, "udp"),
1213                         (3334, "udp"),
1214                         (5505, "udp"),
1215                         (5506, "udp"),
1216                         (19999, "udp"),
1217                         (20000, "udp"),
1218                         (20001</b></font>, "udp"),
1219                     ],
1220                 },
1221             )
1222         with self.assertRaisesRegex(
1223             CommandExecutionError,
1224             r"'10.1.2.3:8080:80:123' is an invalid port binding "
1225             r"definition \(at most 3 components are allowed, found 4\)",
1226         ):
1227             salt.utils.dockermod.translate_input(
1228                 self.translator, port_bindings="10.1.2.3:8080:80:123"
1229             )
1230         for val in (
1231             "10.1.2.3:5555-5554:1111-1112",
1232             "10.1.2.3:1111-1112:5555-5554",
1233             "10.1.2.3::5555-5554",
1234             "5555-5554:1111-1112",
1235             "1111-1112:5555-5554",
1236             "5555-5554",
1237         ):
1238             with self.assertRaisesRegex(
1239                 CommandExecutionError,
1240                 r"Start of port range \(5555\) cannot be greater than end "
1241                 r"of port range \(5554\)",
1242             ):
1243                 salt.utils.dockermod.translate_input(
1244                     self.translator,
1245                     port_bindings=val,
1246                 )
1247         for val in (
1248             "10.1.2.3:foo:1111-1112",
1249             "10.1.2.3:1111-1112:foo",
1250             "10.1.2.3::foo",
1251             "foo:1111-1112",
1252             "1111-1112:foo",
1253             "foo",
1254         ):
1255             with self.assertRaisesRegex(
1256                 CommandExecutionError, "'foo' is non-numeric or an invalid port range"
1257             ):
1258                 salt.utils.dockermod.translate_input(
1259                     self.translator,
1260                     port_bindings=val,
1261                 )
1262         for val in ("10.1.2.3:1111-1113:1111-1112", "1111-1113:1111-1112"):
1263             with self.assertRaisesRegex(
1264                 CommandExecutionError,
1265                 r"Host port range \(1111-1113\) does not have the same "
1266                 r"number of ports as the container port range \(1111-1112\)",
1267             ):
1268                 salt.utils.dockermod.translate_input(self.translator, port_bindings=val)
1269         for val in ("10.1.2.3:1111-1112:1111-1113", "1111-1112:1111-1113"):
1270             with self.assertRaisesRegex(
1271                 CommandExecutionError,
1272                 r"Host port range \(1111-1112\) does not have the same "
1273                 r"number of ports as the container port range \(1111-1113\)",
1274             ):
1275                 salt.utils.dockermod.translate_input(
1276                     self.translator,
1277                     port_bindings=val,
1278                 )
1279         with self.assertRaisesRegex(
1280             CommandExecutionError, "Empty host port in port binding definition ':1111'"
1281         ):
1282             salt.utils.dockermod.translate_input(self.translator, port_bindings=":1111")
1283         with self.assertRaisesRegex(
1284             CommandExecutionError,
1285             "Empty container port in port binding definition '1111:'",
1286         ):
1287             salt.utils.dockermod.translate_input(self.translator, port_bindings="1111:")
1288         with self.assertRaisesRegex(
1289             CommandExecutionError, "Empty port binding definition found"
1290         ):
1291             salt.utils.dockermod.translate_input(self.translator, port_bindings="")
1292     def test_ports(self):
1293         """
1294         Ports can be passed as a comma-separated or Python list of port
1295         numbers, with '/tcp' being optional for TCP ports. They must ultimately
1296         be a list of port definitions, in which an integer denotes a TCP port,
1297         and a tuple in the format (port_num, 'udp') denotes a UDP port. Also,
1298         the port numbers must end up as integers. None of the decorators will
1299         suffice so this one must be tested specially.
1300         """
1301         for val in (
1302             "1111,2222/tcp,3333/udp,4505-4506",
1303             [1111, "2222/tcp", "3333/udp", "4505-4506"],
1304             ["1111", "2222/tcp", "3333/udp", "4505-4506"],
1305         ):
1306             self.assertEqual(
1307                 self.normalize_ports(
1308                     salt.utils.dockermod.translate_input(
1309                         self.translator,
1310                         ports=val,
1311                     )
1312                 ),
1313                 {"ports": [1111, 2222, 4505, 4506, (3333, "udp")]},
1314             )
1315         for val in (1.0, [1.0]):
1316             with self.assertRaisesRegex(
1317                 CommandExecutionError, "'1.0' is not a valid port definition"
1318             ):
1319                 salt.utils.dockermod.translate_input(
1320                     self.translator,
1321                     ports=val,
1322                 )
1323         with self.assertRaisesRegex(
1324             CommandExecutionError,
1325             r"Start of port range \(5555\) cannot be greater than end of "
1326             r"port range \(5554\)",
1327         ):
1328             salt.utils.dockermod.translate_input(
1329                 self.translator,
1330                 ports="5555-5554",
1331             )
1332     @assert_bool(salt.utils.dockermod.translate.container)
1333     def test_privileged(self):
1334         """
1335         Should be a bool or converted to one
1336         """
1337     @assert_bool(salt.utils.dockermod.translate.container)
1338     def test_publish_all_ports(self):
1339         """
1340         Should be a bool or converted to one
1341         """
1342     @assert_bool(salt.utils.dockermod.translate.container)
1343     def test_read_only(self):
1344         """
1345         Should be a bool or converted to one
1346         """
1347     def test_restart_policy(self):
1348         """
1349         Input is in the format "name[:retry_count]", but the API wants it
1350         in the format {'Name': name, 'MaximumRetryCount': retry_count}
1351         """
1352         name = "restart_policy"
1353         alias = "restart"
1354         for item in (name, alias):
1355             self.assertEqual(
1356                 salt.utils.dockermod.translate_input(
1357                     self.translator, **{item: "on-failure:5"}
1358                 ),
1359                 {name: {"Name": "on-failure", "MaximumRetryCount": 5}},
1360             )
1361             self.assertEqual(
1362                 salt.utils.dockermod.translate_input(
1363                     self.translator, **{item: "on-failure"}
1364                 ),
1365                 {name: {"Name": "on-failure", "MaximumRetryCount": 0}},
1366             )
1367             with self.assertRaisesRegex(
1368                 CommandExecutionError, "Only one policy is permitted"
1369             ):
1370                 salt.utils.dockermod.translate_input(
1371                     self.translator, **{item: "on-failure,always"}
1372                 )
1373         test_kwargs = {name: "on-failure:5", alias: "always"}
1374         self.assertEqual(
1375             salt.utils.dockermod.translate_input(
1376                 self.translator, ignore_collisions=True, **test_kwargs
1377             ),
1378             {name: {"Name": "on-failure", "MaximumRetryCount": 5}},
1379         )
1380         with self.assertRaisesRegex(
1381             CommandExecutionError, "'restart' is an alias for 'restart_policy'"
1382         ):
1383             salt.utils.dockermod.translate_input(
1384                 self.translator, ignore_collisions=False, **test_kwargs
1385             )
1386     @assert_stringlist(salt.utils.dockermod.translate.container)
1387     def test_security_opt(self):
1388         """
1389         Should be a list of strings or converted to one
1390         """
1391     @assert_int_or_string(salt.utils.dockermod.translate.container)
1392     def test_shm_size(self):
1393         """
1394         Should be a string or converted to one
1395         """
1396     @assert_bool(salt.utils.dockermod.translate.container)
1397     def test_stdin_open(self):
1398         """
1399         Should be a bool or converted to one
1400         """
1401     @assert_string(salt.utils.dockermod.translate.container)
1402     def test_stop_signal(self):
1403         """
1404         Should be a string or converted to one
1405         """
1406     @assert_int(salt.utils.dockermod.translate.container)
1407     def test_stop_timeout(self):
1408         """
1409         Should be an int or converted to one
1410         """
1411     @assert_key_equals_value(salt.utils.dockermod.translate.container)
1412     def test_storage_opt(self):
1413         """
1414         Can be passed in several formats but must end up as a dictionary
1415         mapping keys to values
1416         """
1417     @assert_key_equals_value(salt.utils.dockermod.translate.container)
1418     def test_sysctls(self):
1419         """
1420         Can be passed in several formats but must end up as a dictionary
1421         mapping keys to values
1422         """
1423     @assert_dict(salt.utils.dockermod.translate.container)
1424     def test_tmpfs(self):
1425         """
1426         Can be passed in several formats but must end up as a dictionary
1427         mapping keys to values
1428         """
1429     @assert_bool(salt.utils.dockermod.translate.container)
1430     def test_tty(self):
1431         """
1432         Should be a bool or converted to one
1433         """
1434     def test_ulimits(self):
1435         """
1436         Input is in the format "name=soft_limit[:hard_limit]", but the API
1437         wants it in the format
1438         {'Name': name, 'Soft': soft_limit, 'Hard': hard_limit}
1439         """
1440         ulimits = "nofile=1024:2048,nproc=50"
1441         for val in (ulimits, ulimits.split(",")):
1442             self.assertEqual(
1443                 salt.utils.dockermod.translate_input(
1444                     self.translator,
1445                     ulimits=val,
1446                 ),
1447                 {
1448                     "ulimits": [
1449                         {"Name": "nofile", "Soft": 1024, "Hard": 2048},
1450                         {"Name": "nproc", "Soft": 50, "Hard": 50},
1451                     ]
1452                 },
1453             )
1454         with self.assertRaisesRegex(
1455             CommandExecutionError,
1456             r"Ulimit definition 'nofile:1024:2048' is not in the format "
1457             r"type=soft_limit\[:hard_limit\]",
1458         ):
1459             salt.utils.dockermod.translate_input(
1460                 self.translator, ulimits="nofile:1024:2048"
1461             )
1462         with self.assertRaisesRegex(
1463             CommandExecutionError,
1464             r"Limit 'nofile=foo:2048' contains non-numeric value\(s\)",
1465         ):
1466             salt.utils.dockermod.translate_input(
1467                 self.translator, ulimits="nofile=foo:2048"
1468             )
1469     def test_user(self):
1470         """
1471         Must be either username (string) or uid (int). An int passed as a
1472         string (e.g. '0') should be converted to an int.
1473         """
1474         self.assertEqual(
1475             salt.utils.dockermod.translate_input(self.translator, user="foo"),
1476             {"user": "foo"},
1477         )
1478         for val in (0, "0"):
1479             self.assertEqual(
1480                 salt.utils.dockermod.translate_input(self.translator, user=val),
1481                 {"user": 0},
1482             )
1483         with self.assertRaisesRegex(
1484             CommandExecutionError, "Value must be a username or uid"
1485         ):
1486             salt.utils.dockermod.translate_input(self.translator, user=["foo"])
1487         with self.assertRaisesRegex(CommandExecutionError, "'-1' is an invalid uid"):
1488             salt.utils.dockermod.translate_input(self.translator, user=-1)
1489     @assert_string(salt.utils.dockermod.translate.container)
1490     def test_userns_mode(self):
1491         """
1492         Should be a bool or converted to one
1493         """
1494     @assert_string(salt.utils.dockermod.translate.container)
1495     def test_volume_driver(self):
1496         """
1497         Should be a bool or converted to one
1498         """
1499     @assert_stringlist(salt.utils.dockermod.translate.container)
1500     def test_volumes(self):
1501         """
1502         Should be a list of absolute paths
1503         """
1504         path = os.path.join("foo", "bar", "baz")
1505         with self.assertRaisesRegex(
1506             CommandExecutionError,
1507             "'{}' is not an absolute path".format(path.replace("\\", "\\\\")),
1508         ):
1509             salt.utils.dockermod.translate_input(self.translator, volumes=path)
1510     @assert_stringlist(salt.utils.dockermod.translate.container)
1511     def test_volumes_from(self):
1512         """
1513         Should be a list of strings or converted to one
1514         """
1515     @assert_string(salt.utils.dockermod.translate.container)
1516     def test_working_dir(self):
1517         """
1518         Should be a single absolute path
1519         """
1520         path = os.path.join("foo", "bar", "baz")
1521         with self.assertRaisesRegex(
1522             CommandExecutionError,
1523             "'{}' is not an absolute path".format(path.replace("\\", "\\\\")),
1524         ):
1525             salt.utils.dockermod.translate_input(self.translator, working_dir=path)
1526 class TranslateNetworkInputTestCase(TranslateBase):
1527     """
1528     Tests for salt.utils.dockermod.translate_input(), invoked using
1529     salt.utils.dockermod.translate.network as the translator module.
1530     """
1531     translator = salt.utils.dockermod.translate.network
1532     ip_addrs = {
1533         True: ("10.1.2.3", "::1"),
1534         False: ("FOO", "0.9.800.1000", "feaz::1", "aj01::feac"),
1535     }
1536     @assert_string(salt.utils.dockermod.translate.network)
1537     def test_driver(self):
1538         """
1539         Should be a string or converted to one
1540         """
1541     @assert_key_equals_value(salt.utils.dockermod.translate.network)
1542     def test_options(self):
1543         """
1544         Can be passed in several formats but must end up as a dictionary
1545         mapping keys to values
1546         """
1547     @assert_dict(salt.utils.dockermod.translate.network)
1548     def test_ipam(self):
1549         """
1550         Must be a dict
1551         """
1552     @assert_bool(salt.utils.dockermod.translate.network)
1553     def test_check_duplicate(self):
1554         """
1555         Should be a bool or converted to one
1556         """
1557     @assert_bool(salt.utils.dockermod.translate.network)
1558     def test_internal(self):
1559         """
1560         Should be a bool or converted to one
1561         """
1562     @assert_labels(salt.utils.dockermod.translate.network)
1563     def test_labels(self):
1564         """
1565         Can be passed as a list of key=value pairs or a dictionary, and must
1566         ultimately end up as a dictionary.
1567         """
1568     @assert_bool(salt.utils.dockermod.translate.network)
1569     def test_enable_ipv6(self):
1570         """
1571         Should be a bool or converted to one
1572         """
1573     @assert_bool(salt.utils.dockermod.translate.network)
1574     def test_attachable(self):
1575         """
1576         Should be a bool or converted to one
1577         """
1578     @assert_bool(salt.utils.dockermod.translate.network)
1579     def test_ingress(self):
1580         """
1581         Should be a bool or converted to one
1582         """
1583     @assert_string(salt.utils.dockermod.translate.network)
1584     def test_ipam_driver(self):
1585         """
1586         Should be a bool or converted to one
1587         """
1588     @assert_key_equals_value(salt.utils.dockermod.translate.network)
1589     def test_ipam_opts(self):
1590         """
1591         Can be passed in several formats but must end up as a dictionary
1592         mapping keys to values
1593         """
1594     def ipam_pools(self):
1595         """
1596         Must be a list of dictionaries (not a dictlist)
1597         """
1598         good_pool = {
1599             "subnet": "10.0.0.0/24",
1600             "iprange": "10.0.0.128/25",
1601             "gateway": "10.0.0.254",
1602             "aux_addresses": {
1603                 "foo.bar.tld": "10.0.0.20",
1604                 "hello.world.tld": "10.0.0.21",
1605             },
1606         }
1607         bad_pools = [
1608             {
1609                 "subnet": "10.0.0.0/33",
1610                 "iprange": "10.0.0.128/25",
1611                 "gateway": "10.0.0.254",
1612                 "aux_addresses": {
1613                     "foo.bar.tld": "10.0.0.20",
1614                     "hello.world.tld": "10.0.0.21",
1615                 },
1616             },
1617             {
1618                 "subnet": "10.0.0.0/24",
1619                 "iprange": "foo/25",
1620                 "gateway": "10.0.0.254",
1621                 "aux_addresses": {
1622                     "foo.bar.tld": "10.0.0.20",
1623                     "hello.world.tld": "10.0.0.21",
1624                 },
1625             },
1626             {
1627                 "subnet": "10.0.0.0/24",
1628                 "iprange": "10.0.0.128/25",
1629                 "gateway": "10.0.0.256",
1630                 "aux_addresses": {
1631                     "foo.bar.tld": "10.0.0.20",
1632                     "hello.world.tld": "10.0.0.21",
1633                 },
1634             },
1635             {
1636                 "subnet": "10.0.0.0/24",
1637                 "iprange": "10.0.0.128/25",
1638                 "gateway": "10.0.0.254",
1639                 "aux_addresses": {
1640                     "foo.bar.tld": "10.0.0.20",
1641                     "hello.world.tld": "999.0.0.21",
1642                 },
1643             },
1644         ]
1645         self.assertEqual(
1646             salt.utils.dockermod.translate_input(
1647                 self.translator,
1648                 ipam_pools=[good_pool],
1649             ),
1650             {"ipam_pools": [good_pool]},
1651         )
1652         for bad_pool in bad_pools:
1653             with self.assertRaisesRegex(CommandExecutionError, "not a valid"):
1654                 salt.utils.dockermod.translate_input(
1655                     self.translator, ipam_pools=[good_pool, bad_pool]
1656                 )
1657     @assert_subnet(salt.utils.dockermod.translate.network)
1658     def test_subnet(self):
1659         """
1660         Must be an IPv4 or IPv6 subnet
1661         """
1662     @assert_subnet(salt.utils.dockermod.translate.network)
1663     def test_iprange(self):
1664         """
1665         Must be an IPv4 or IPv6 subnet
1666         """
1667     def test_gateway(self):
1668         """
1669         Must be an IPv4 or IPv6 address
1670         """
1671         for val in self.ip_addrs[True]:
1672             self.assertEqual(
1673                 salt.utils.dockermod.translate_input(
1674                     self.translator,
1675                     validate_ip_addrs=True,
1676                     gateway=val,
1677                 ),
1678                 self.apply_defaults({"gateway": val}),
1679             )
1680         for val in self.ip_addrs[False]:
1681             with self.assertRaisesRegex(
1682                 CommandExecutionError, "'{}' is not a valid IP address".format(val)
1683             ):
1684                 salt.utils.dockermod.translate_input(
1685                     self.translator,
1686                     validate_ip_addrs=True,
1687                     gateway=val,
1688                 )
1689             self.assertEqual(
1690                 salt.utils.dockermod.translate_input(
1691                     self.translator,
1692                     validate_ip_addrs=False,
1693                     gateway=val,
1694                 ),
1695                 self.apply_defaults(
1696                     {"gateway": val if isinstance(val, str) else str(val)}
1697                 ),
1698             )
1699     @assert_key_equals_value(salt.utils.dockermod.translate.network)
1700     def test_aux_addresses(self):
1701         """
1702         Must be a mapping of hostnames to IP addresses
1703         """
1704         name = "aux_addresses"
1705         alias = "aux_address"
1706         for item in (name, alias):
1707             for val in self.ip_addrs[True]:
1708                 addresses = {"foo.bar.tld": val}
1709                 self.assertEqual(
1710                     salt.utils.dockermod.translate_input(
1711                         self.translator, validate_ip_addrs=True, **{item: addresses}
1712                     ),
1713                     self.apply_defaults({name: addresses}),
1714                 )
1715             for val in self.ip_addrs[False]:
1716                 addresses = {"foo.bar.tld": val}
1717                 with self.assertRaisesRegex(
1718                     CommandExecutionError, "'{}' is not a valid IP address".format(val)
1719                 ):
1720                     salt.utils.dockermod.translate_input(
1721                         self.translator, validate_ip_addrs=True, **{item: addresses}
1722                     )
1723                 self.assertEqual(
1724                     salt.utils.dockermod.translate_input(
1725                         self.translator,
1726                         validate_ip_addrs=False,
1727                         aux_addresses=addresses,
1728                     ),
1729                     self.apply_defaults({name: addresses}),
1730                 )
1731 class DockerTranslateHelperTestCase(TestCase):
1732     """
1733     Tests for a couple helper functions in salt.utils.dockermod.translate
1734     """
1735     def test_get_port_def(self):
1736         """
1737         Test translation of port definition (1234, '1234/tcp', '1234/udp',
1738         etc.) into the format which docker-py uses (integer for TCP ports,
1739         """
1740         self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(translate_helpers.get_port_def(2222), 2222)
1741         self.assertEqual(translate_helpers.get_port_def("2222"), 2222)
1742         self.assertEqual(translate_helpers.get_port_def("2222", "tcp"), 2222)
1743         self.assertEqual(translate_helpers.get_port_def("2222/tcp", "udp"), 2222)
1744         self.assertEqual(translate_helpers.get_port_def(</b></font>2222, "udp"), (2222, "udp"))
1745         self.assertEqual(translate_helpers.get_port_def("2222", "udp"), (2222, "udp"))
1746         self.assertEqual(translate_helpers.get_port_def("2222/udp"), (2222, "udp"))
1747     def test_get_port_range(self):
1748         """
1749         Test extracting the start and end of a port range from a port range
1750         expression (e.g. 4505-4506)
1751         """
1752         self.assertEqual(translate_helpers.get_port_range(2222), (2222, 2222))
1753         self.assertEqual(translate_helpers.get_port_range("2222"), (2222, 2222))
1754         self.assertEqual(translate_helpers.get_port_range("2222-2223"), (2222, 2223))
1755         with self.assertRaisesRegex(
1756             ValueError,
1757             r"Start of port range \(2222\) cannot be greater than end of "
1758             r"port range \(2221\)",
1759         ):
1760             translate_helpers.get_port_range("2222-2221")
1761         with self.assertRaisesRegex(
1762             ValueError, "'2222-bar' is non-numeric or an invalid port range"
1763         ):
1764             translate_helpers.get_port_range("2222-bar")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
