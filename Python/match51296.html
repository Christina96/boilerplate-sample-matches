<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_reactor_2.py & test_dockermod.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_reactor_2.py & test_dockermod.py
      </h3>
      <h1 align="center">
        5.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_reactor_2.py (19.426048%)<TH>test_dockermod.py (3.319502%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match51296-0.html#0',2,'match51296-1.html#0',3)" NAME="0">(270-330)<TD><A HREF="javascript:ZweiFrames('match51296-0.html#0',2,'match51296-1.html#0',3)" NAME="0">(1226-1249)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match51296-0.html#1',2,'match51296-1.html#1',3)" NAME="1">(145-216)<TD><A HREF="javascript:ZweiFrames('match51296-0.html#1',2,'match51296-1.html#1',3)" NAME="1">(1266-1288)</A><TD ALIGN=center><FONT COLOR="#f20000">20</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match51296-0.html#2',2,'match51296-1.html#2',3)" NAME="2">(49-135)<TD><A HREF="javascript:ZweiFrames('match51296-0.html#2',2,'match51296-1.html#2',3)" NAME="2">(2013-2025)</A><TD ALIGN=center><FONT COLOR="#f20000">20</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match51296-0.html#3',2,'match51296-1.html#3',3)" NAME="3">(216-256)<TD><A HREF="javascript:ZweiFrames('match51296-0.html#3',2,'match51296-1.html#3',3)" NAME="3">(1381-1411)</A><TD ALIGN=center><FONT COLOR="#aa0000">14</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match51296-0.html#4',2,'match51296-1.html#4',3)" NAME="4">(2-16)<TD><A HREF="javascript:ZweiFrames('match51296-0.html#4',2,'match51296-1.html#4',3)" NAME="4">(8-22)</A><TD ALIGN=center><FONT COLOR="#9d0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_reactor_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="4"></A>import codecs
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match51296-1.html#4',3,'match51296-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import glob
import logging
import os
import textwrap

import salt.loader
import salt.utils.data
import salt.utils.files
import salt.utils.reactor as reactor
import salt.utils.yaml
from tests.support.mixins import AdaptedConfigurationTestCaseMixin
from tests.support.mock import MagicMock, Mock, mock_open, patch
from tests.support.unit import TestCase

REACTOR_CONFIG =</B></FONT> &quot;&quot;&quot;\
reactor:
  - old_runner:
    - /srv/reactor/old_runner.sls
  - old_wheel:
    - /srv/reactor/old_wheel.sls
  - old_local:
    - /srv/reactor/old_local.sls
  - old_cmd:
    - /srv/reactor/old_cmd.sls
  - old_caller:
    - /srv/reactor/old_caller.sls
  - new_runner:
    - /srv/reactor/new_runner.sls
  - new_wheel:
    - /srv/reactor/new_wheel.sls
  - new_local:
    - /srv/reactor/new_local.sls
  - new_cmd:
    - /srv/reactor/new_cmd.sls
  - new_caller:
    - /srv/reactor/new_caller.sls
&quot;&quot;&quot;

REACTOR_DATA = {
    &quot;runner&quot;: {&quot;data&quot;: {&quot;message&quot;: &quot;This is an error&quot;}},
    &quot;wheel&quot;: {&quot;data&quot;: {&quot;id&quot;: &quot;foo&quot;}},
    &quot;local&quot;: {&quot;data&quot;: {&quot;pkg&quot;: &quot;zsh&quot;, &quot;repo&quot;: &quot;updates&quot;}},
    &quot;cmd&quot;: {&quot;data&quot;: {&quot;pkg&quot;: &quot;zsh&quot;, &quot;repo&quot;: &quot;updates&quot;}},
    &quot;caller&quot;: {&quot;data&quot;: {&quot;path&quot;: &quot;/tmp/foo&quot;}},
<A NAME="2"></A>}

SLS = {
    &quot;/srv/reactor/old_runner.sls&quot;: textwrap<FONT color="#980517"><A HREF="javascript:ZweiFrames('match51296-1.html#2',3,'match51296-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.dedent(
        &quot;&quot;&quot;\
        raise_error:
          runner.error.error:
            - name: Exception
            - message: {{ data['data']['message'] }}
        &quot;&quot;&quot;
    ),
    &quot;/srv/reactor/old_wheel.sls&quot;: textwrap.dedent(
        &quot;&quot;&quot;\
        remove_key:
          wheel.key.delete:
            - match: {{ data['data']['id'] }}
        &quot;&quot;&quot;
    ),
    &quot;/srv/reactor/old_local.sls&quot;: textwrap.dedent(
        &quot;&quot;&quot;\
        install_zsh:
          local.state.single:
            - tgt: test
            - arg:
              - pkg.installed
              - {{ data['data']['pkg'] }}
            - kwarg:
                fromrepo: {{ data['data']['repo'] }}
        &quot;&quot;&quot;
    ),
    &quot;/srv/reactor/old_cmd.sls&quot;: textwrap.dedent(
        &quot;&quot;&quot;\
        install_zsh:
          cmd.state.single:
            - tgt: test
            - arg:
              - pkg.installed
              - {{ data['data']['pkg'] }}
            - kwarg:
                fromrepo: {{ data['data']['repo'] }}
        &quot;&quot;&quot;
    ),
    &quot;/srv/reactor/old_caller.sls&quot;: textwrap.dedent(
        &quot;&quot;&quot;\
        touch_file:
          caller.file.touch:
            - args:
              - {{ data['data']['path'] }}
        &quot;&quot;&quot;
    ),
    &quot;/srv/reactor/new_runner.sls&quot;: textwrap.dedent(
        &quot;&quot;&quot;\
        raise_error:
          runner.error.error:
            - args:
              - name: Exception
              - message: {{ data['data']['message'] }}
        &quot;&quot;&quot;
    ),
    &quot;/srv/reactor/new_wheel.sls&quot;: textwrap.dedent(
        &quot;&quot;&quot;\
        remove_key:
          wheel.key.delete:
            - args:
              - match: {{ data['data']['id'] }}
        &quot;&quot;&quot;
    ),
    &quot;/srv/reactor/new_local.sls&quot;: textwrap.dedent(
        &quot;&quot;&quot;\
        install_zsh:
          local.state.single:
            - tgt: test
            - args:
              - fun: pkg.installed
              - name: {{ data['data']['pkg'] }}
              - fromrepo: {{ data['data']['repo'] }}
        &quot;&quot;&quot;
    ),
    &quot;/srv/reactor/new_cmd.sls&quot;: textwrap.dedent(
        &quot;&quot;&quot;\
        install_zsh:
          cmd.state.single:
            - tgt: test
            - args:
              - fun: pkg.installed
              - name: {{ data['data']['pkg'] }}
              - fromrepo: {{ data['data']['repo'] }}
        &quot;&quot;&quot;
    ),
    &quot;/srv/reactor/new_caller.sls&quot;: textwrap.dedent(</B></FONT>
        &quot;&quot;&quot;\
        touch_file:
          caller.file.touch:
            - args:
              - name: {{ data['data']['path'] }}
        &quot;&quot;&quot;
<A NAME="1"></A>    ),
}

LOW_CHUNKS <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match51296-1.html#1',3,'match51296-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= {
    # Note that the &quot;name&quot; value in the chunk has been overwritten by the
    # &quot;name&quot; argument in the SLS. This is one reason why the new schema was
    # needed.
    &quot;old_runner&quot;: [
        {
            &quot;state&quot;: &quot;runner&quot;,
            &quot;__id__&quot;: &quot;raise_error&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/old_runner.sls&quot;,
            &quot;order&quot;: 1,
            &quot;fun&quot;: &quot;error.error&quot;,
            &quot;name&quot;: &quot;Exception&quot;,
            &quot;message&quot;: &quot;This is an error&quot;,
        }
    ],
    &quot;old_wheel&quot;: [
        {
            &quot;state&quot;: &quot;wheel&quot;,
            &quot;__id__&quot;: &quot;remove_key&quot;,
            &quot;name&quot;: &quot;remove_key&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/old_wheel.sls&quot;,
            &quot;order&quot;: 1,
            &quot;fun&quot;: &quot;key.delete&quot;,
            &quot;match&quot;: &quot;foo&quot;,
        }
    ],
    &quot;old_local&quot;: [
        {
            &quot;state&quot;: &quot;local&quot;,
            &quot;__id__&quot;: &quot;install_zsh&quot;,
            &quot;name&quot;: &quot;install_zsh&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/old_local.sls&quot;,
            &quot;order&quot;: 1,
            &quot;tgt&quot;: &quot;test&quot;,
            &quot;fun&quot;: &quot;state.single&quot;,
            &quot;arg&quot;: [&quot;pkg.installed&quot;, &quot;zsh&quot;],
            &quot;kwarg&quot;: {&quot;fromrepo&quot;: &quot;updates&quot;},
        }
    ],
    &quot;old_cmd&quot;: [
        {
            &quot;state&quot;: &quot;local&quot;,  # 'cmd' should be aliased to 'local'
            &quot;__id__&quot;: &quot;install_zsh&quot;,
            &quot;name&quot;: &quot;install_zsh&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/old_cmd.sls&quot;,
            &quot;order&quot;: 1,
            &quot;tgt&quot;: &quot;test&quot;,
            &quot;fun&quot;: &quot;state.single&quot;,
            &quot;arg&quot;: [&quot;pkg.installed&quot;, &quot;zsh&quot;],
            &quot;kwarg&quot;: {&quot;fromrepo&quot;: &quot;updates&quot;},
        }
    ],
    &quot;old_caller&quot;: [
        {
            &quot;state&quot;: &quot;caller&quot;,
            &quot;__id__&quot;: &quot;touch_file&quot;,
            &quot;name&quot;: &quot;touch_file&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/old_caller.sls&quot;,
            &quot;order&quot;: 1,
            &quot;fun&quot;: &quot;file.touch&quot;,
            &quot;args&quot;: [&quot;/tmp/foo&quot;],
        }
    ],
    &quot;new_runner&quot;: [
        {
            &quot;state&quot;: &quot;runner&quot;,
            &quot;__id__&quot;: &quot;raise_error&quot;,
            &quot;name&quot;: &quot;raise_error&quot;,
<A NAME="3"></A>            &quot;__sls__&quot;: &quot;/srv/reactor/new_runner.sls&quot;,
            &quot;order&quot;: 1,
            &quot;fun&quot;: &quot;error.error&quot;,
            &quot;args&quot;: [{&quot;name&quot;</B></FONT>: &quot;Exception&quot;}, {<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match51296-1.html#3',3,'match51296-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>&quot;message&quot;: &quot;This is an error&quot;}],
        }
    ],
    &quot;new_wheel&quot;: [
        {
            &quot;state&quot;: &quot;wheel&quot;,
            &quot;__id__&quot;: &quot;remove_key&quot;,
            &quot;name&quot;: &quot;remove_key&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/new_wheel.sls&quot;,
            &quot;order&quot;: 1,
            &quot;fun&quot;: &quot;key.delete&quot;,
            &quot;args&quot;: [{&quot;match&quot;: &quot;foo&quot;}],
        }
    ],
    &quot;new_local&quot;: [
        {
            &quot;state&quot;: &quot;local&quot;,
            &quot;__id__&quot;: &quot;install_zsh&quot;,
            &quot;name&quot;: &quot;install_zsh&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/new_local.sls&quot;,
            &quot;order&quot;: 1,
            &quot;tgt&quot;: &quot;test&quot;,
            &quot;fun&quot;: &quot;state.single&quot;,
            &quot;args&quot;: [
                {&quot;fun&quot;: &quot;pkg.installed&quot;},
                {&quot;name&quot;: &quot;zsh&quot;},
                {&quot;fromrepo&quot;: &quot;updates&quot;},
            ],
        }
    ],
    &quot;new_cmd&quot;: [
        {
            &quot;state&quot;: &quot;local&quot;,
            &quot;__id__&quot;: &quot;install_zsh&quot;,
            &quot;name&quot;: &quot;install_zsh&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/new_cmd.sls&quot;,
            &quot;order&quot;: 1,
            &quot;tgt&quot;: &quot;test&quot;,
            &quot;fun&quot;: &quot;state.single&quot;,
            &quot;args&quot;: [
                {&quot;fun&quot;</B></FONT>: &quot;pkg.installed&quot;},
                {&quot;name&quot;: &quot;zsh&quot;},
                {&quot;fromrepo&quot;: &quot;updates&quot;},
            ],
        }
    ],
    &quot;new_caller&quot;: [
        {
            &quot;state&quot;: &quot;caller&quot;,
            &quot;__id__&quot;: &quot;touch_file&quot;,
            &quot;name&quot;: &quot;touch_file&quot;,
<A NAME="0"></A>            &quot;__sls__&quot;: &quot;/srv/reactor/new_caller.sls&quot;,
            &quot;order&quot;: 1,
            &quot;fun&quot;: &quot;file.touch&quot;,
            &quot;args&quot;: [{<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match51296-1.html#0',3,'match51296-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>&quot;name&quot;: &quot;/tmp/foo&quot;}],
        }
    ],
}

WRAPPER_CALLS = {
    &quot;old_runner&quot;: (
        &quot;error.error&quot;,
        {
            &quot;__state__&quot;: &quot;runner&quot;,
            &quot;__id__&quot;: &quot;raise_error&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/old_runner.sls&quot;,
            &quot;__user__&quot;: &quot;Reactor&quot;,
            &quot;order&quot;: 1,
            &quot;arg&quot;: [],
            &quot;kwarg&quot;: {&quot;name&quot;: &quot;Exception&quot;, &quot;message&quot;: &quot;This is an error&quot;},
            &quot;name&quot;: &quot;Exception&quot;,
            &quot;message&quot;: &quot;This is an error&quot;,
        },
    ),
    &quot;old_wheel&quot;: (
        &quot;key.delete&quot;,
        {
            &quot;__state__&quot;: &quot;wheel&quot;,
            &quot;__id__&quot;: &quot;remove_key&quot;,
            &quot;name&quot;: &quot;remove_key&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/old_wheel.sls&quot;,
            &quot;order&quot;: 1,
            &quot;__user__&quot;: &quot;Reactor&quot;,
            &quot;arg&quot;: [&quot;foo&quot;],
            &quot;kwarg&quot;: {},
            &quot;match&quot;: &quot;foo&quot;,
        },
    ),
    &quot;old_local&quot;: {
        &quot;args&quot;: (&quot;test&quot;, &quot;state.single&quot;),
        &quot;kwargs&quot;: {
            &quot;state&quot;: &quot;local&quot;,
            &quot;__id__&quot;: &quot;install_zsh&quot;,
            &quot;name&quot;: &quot;install_zsh&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/old_local.sls&quot;,
            &quot;order&quot;: 1,
            &quot;arg&quot;: [&quot;pkg.installed&quot;, &quot;zsh&quot;],
            &quot;kwarg&quot;: {&quot;fromrepo&quot;: &quot;updates&quot;},
        },
    },
    &quot;old_cmd&quot;: {
        &quot;args&quot;: (&quot;test&quot;, &quot;state.single&quot;),
        &quot;kwargs&quot;: {
            &quot;state&quot;: &quot;local&quot;,
            &quot;__id__&quot;: &quot;install_zsh&quot;,
            &quot;name&quot;: &quot;install_zsh&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/old_cmd.sls&quot;,
            &quot;order&quot;: 1,
            &quot;arg&quot;: [&quot;pkg.installed&quot;, &quot;zsh&quot;],
            &quot;kwarg&quot;: {&quot;fromrepo&quot;: &quot;updates&quot;},
        },
    },
    &quot;old_caller&quot;: {&quot;args&quot;: (&quot;file.touch&quot;, &quot;/tmp/foo&quot;), &quot;kwargs&quot;: {}},
    &quot;new_runner&quot;: (
        &quot;error.error&quot;</B></FONT>,
        {
            &quot;__state__&quot;: &quot;runner&quot;,
            &quot;__id__&quot;: &quot;raise_error&quot;,
            &quot;name&quot;: &quot;raise_error&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/new_runner.sls&quot;,
            &quot;__user__&quot;: &quot;Reactor&quot;,
            &quot;order&quot;: 1,
            &quot;arg&quot;: (),
            &quot;kwarg&quot;: {&quot;name&quot;: &quot;Exception&quot;, &quot;message&quot;: &quot;This is an error&quot;},
        },
    ),
    &quot;new_wheel&quot;: (
        &quot;key.delete&quot;,
        {
            &quot;__state__&quot;: &quot;wheel&quot;,
            &quot;__id__&quot;: &quot;remove_key&quot;,
            &quot;name&quot;: &quot;remove_key&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/new_wheel.sls&quot;,
            &quot;order&quot;: 1,
            &quot;__user__&quot;: &quot;Reactor&quot;,
            &quot;arg&quot;: (),
            &quot;kwarg&quot;: {&quot;match&quot;: &quot;foo&quot;},
        },
    ),
    &quot;new_local&quot;: {
        &quot;args&quot;: (&quot;test&quot;, &quot;state.single&quot;),
        &quot;kwargs&quot;: {
            &quot;state&quot;: &quot;local&quot;,
            &quot;__id__&quot;: &quot;install_zsh&quot;,
            &quot;name&quot;: &quot;install_zsh&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/new_local.sls&quot;,
            &quot;order&quot;: 1,
            &quot;arg&quot;: (),
            &quot;kwarg&quot;: {&quot;fun&quot;: &quot;pkg.installed&quot;, &quot;name&quot;: &quot;zsh&quot;, &quot;fromrepo&quot;: &quot;updates&quot;},
        },
    },
    &quot;new_cmd&quot;: {
        &quot;args&quot;: (&quot;test&quot;, &quot;state.single&quot;),
        &quot;kwargs&quot;: {
            &quot;state&quot;: &quot;local&quot;,
            &quot;__id__&quot;: &quot;install_zsh&quot;,
            &quot;name&quot;: &quot;install_zsh&quot;,
            &quot;__sls__&quot;: &quot;/srv/reactor/new_cmd.sls&quot;,
            &quot;order&quot;: 1,
            &quot;arg&quot;: (),
            &quot;kwarg&quot;: {&quot;fun&quot;: &quot;pkg.installed&quot;, &quot;name&quot;: &quot;zsh&quot;, &quot;fromrepo&quot;: &quot;updates&quot;},
        },
    },
    &quot;new_caller&quot;: {&quot;args&quot;: (&quot;file.touch&quot;,), &quot;kwargs&quot;: {&quot;name&quot;: &quot;/tmp/foo&quot;}},
}

log = logging.getLogger(__name__)


class TestReactor(TestCase, AdaptedConfigurationTestCaseMixin):
    &quot;&quot;&quot;
    Tests for constructing the low chunks to be executed via the Reactor
    &quot;&quot;&quot;

    @classmethod
    def setUpClass(cls):
        &quot;&quot;&quot;
        Load the reactor config for mocking
        &quot;&quot;&quot;
        cls.opts = cls.get_temp_config(&quot;master&quot;)
        reactor_config = salt.utils.yaml.safe_load(REACTOR_CONFIG)
        cls.opts.update(reactor_config)
        cls.reactor = reactor.Reactor(cls.opts)
        cls.reaction_map = salt.utils.data.repack_dictlist(reactor_config[&quot;reactor&quot;])
        renderers = salt.loader.render(cls.opts, {})
        cls.render_pipe = [(renderers[x], &quot;&quot;) for x in (&quot;jinja&quot;, &quot;yaml&quot;)]

    @classmethod
    def tearDownClass(cls):
        del cls.opts
        del cls.reactor
        del cls.render_pipe

    def test_list_reactors(self):
        &quot;&quot;&quot;
        Ensure that list_reactors() returns the correct list of reactor SLS
        files for each tag.
        &quot;&quot;&quot;
        for schema in (&quot;old&quot;, &quot;new&quot;):
            for rtype in REACTOR_DATA:
                tag = &quot;_&quot;.join((schema, rtype))
                self.assertEqual(
                    self.reactor.list_reactors(tag), self.reaction_map[tag]
                )

    def test_reactions(self):
        &quot;&quot;&quot;
        Ensure that the correct reactions are built from the configured SLS
        files and tag data.
        &quot;&quot;&quot;
        for schema in (&quot;old&quot;, &quot;new&quot;):
            for rtype in REACTOR_DATA:
                tag = &quot;_&quot;.join((schema, rtype))
                log.debug(&quot;test_reactions: processing %s&quot;, tag)
                reactors = self.reactor.list_reactors(tag)
                log.debug(&quot;test_reactions: %s reactors: %s&quot;, tag, reactors)
                # No globbing in our example SLS, and the files don't actually
                # exist, so mock glob.glob to just return back the path passed
                # to it.
                with patch.object(glob, &quot;glob&quot;, MagicMock(side_effect=lambda x: [x])):
                    # The below four mocks are all so that
                    # salt.template.compile_template() will read the templates
                    # we've mocked up in the SLS global variable above.
                    with patch.object(os.path, &quot;isfile&quot;, MagicMock(return_value=True)):
                        with patch.object(
                            salt.utils.files, &quot;is_empty&quot;, MagicMock(return_value=False)
                        ):
                            with patch.object(
                                codecs, &quot;open&quot;, mock_open(read_data=SLS[reactors[0]])
                            ):
                                with patch.object(
                                    salt.template,
                                    &quot;template_shebang&quot;,
                                    MagicMock(return_value=self.render_pipe),
                                ):
                                    reactions = self.reactor.reactions(
                                        tag,
                                        REACTOR_DATA[rtype],
                                        reactors,
                                    )
                                    log.debug(
                                        &quot;test_reactions: %s reactions: %s&quot;,
                                        tag,
                                        reactions,
                                    )
                                    self.assertEqual(reactions, LOW_CHUNKS[tag])


class TestReactWrap(TestCase, AdaptedConfigurationTestCaseMixin):
    &quot;&quot;&quot;
    Tests that we are formulating the wrapper calls properly
    &quot;&quot;&quot;

    @classmethod
    def setUpClass(cls):
        cls.wrap = reactor.ReactWrap(cls.get_temp_config(&quot;master&quot;))

    @classmethod
    def tearDownClass(cls):
        del cls.wrap

    def test_runner(self):
        &quot;&quot;&quot;
        Test runner reactions using both the old and new config schema
        &quot;&quot;&quot;
        for schema in (&quot;old&quot;, &quot;new&quot;):
            tag = &quot;_&quot;.join((schema, &quot;runner&quot;))
            chunk = LOW_CHUNKS[tag][0]
            thread_pool = Mock()
            thread_pool.fire_async = Mock()
            with patch.object(self.wrap, &quot;pool&quot;, thread_pool):
                self.wrap.run(chunk)
            thread_pool.fire_async.assert_called_with(
                self.wrap.client_cache[&quot;runner&quot;].low, args=WRAPPER_CALLS[tag]
            )

    def test_wheel(self):
        &quot;&quot;&quot;
        Test wheel reactions using both the old and new config schema
        &quot;&quot;&quot;
        for schema in (&quot;old&quot;, &quot;new&quot;):
            tag = &quot;_&quot;.join((schema, &quot;wheel&quot;))
            chunk = LOW_CHUNKS[tag][0]
            thread_pool = Mock()
            thread_pool.fire_async = Mock()
            with patch.object(self.wrap, &quot;pool&quot;, thread_pool):
                self.wrap.run(chunk)
            thread_pool.fire_async.assert_called_with(
                self.wrap.client_cache[&quot;wheel&quot;].low, args=WRAPPER_CALLS[tag]
            )

    def test_local(self):
        &quot;&quot;&quot;
        Test local reactions using both the old and new config schema
        &quot;&quot;&quot;
        for schema in (&quot;old&quot;, &quot;new&quot;):
            tag = &quot;_&quot;.join((schema, &quot;local&quot;))
            chunk = LOW_CHUNKS[tag][0]
            client_cache = {&quot;local&quot;: Mock()}
            client_cache[&quot;local&quot;].cmd_async = Mock()
            with patch.object(self.wrap, &quot;client_cache&quot;, client_cache):
                self.wrap.run(chunk)
            client_cache[&quot;local&quot;].cmd_async.assert_called_with(
                *WRAPPER_CALLS[tag][&quot;args&quot;], **WRAPPER_CALLS[tag][&quot;kwargs&quot;]
            )

    def test_cmd(self):
        &quot;&quot;&quot;
        Test cmd reactions (alias for 'local') using both the old and new
        config schema
        &quot;&quot;&quot;
        for schema in (&quot;old&quot;, &quot;new&quot;):
            tag = &quot;_&quot;.join((schema, &quot;cmd&quot;))
            chunk = LOW_CHUNKS[tag][0]
            client_cache = {&quot;local&quot;: Mock()}
            client_cache[&quot;local&quot;].cmd_async = Mock()
            with patch.object(self.wrap, &quot;client_cache&quot;, client_cache):
                self.wrap.run(chunk)
            client_cache[&quot;local&quot;].cmd_async.assert_called_with(
                *WRAPPER_CALLS[tag][&quot;args&quot;], **WRAPPER_CALLS[tag][&quot;kwargs&quot;]
            )

    def test_caller(self):
        &quot;&quot;&quot;
        Test caller reactions using both the old and new config schema
        &quot;&quot;&quot;
        for schema in (&quot;old&quot;, &quot;new&quot;):
            tag = &quot;_&quot;.join((schema, &quot;caller&quot;))
            chunk = LOW_CHUNKS[tag][0]
            client_cache = {&quot;caller&quot;: Mock()}
            client_cache[&quot;caller&quot;].cmd = Mock()
            with patch.object(self.wrap, &quot;client_cache&quot;, client_cache):
                self.wrap.run(chunk)
            client_cache[&quot;caller&quot;].cmd.assert_called_with(
                *WRAPPER_CALLS[tag][&quot;args&quot;], **WRAPPER_CALLS[tag][&quot;kwargs&quot;]
            )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_dockermod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
tests.unit.utils.test_dockermod
===============================

<A NAME="4"></A>Test the funcs in salt.utils.dockermod and salt.utils.dockermod.translate
&quot;&quot;&quot;

<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51296-0.html#4',2,'match51296-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import copy
import functools
import logging
import os

import salt.config
import salt.loader
import salt.utils.dockermod.translate.container
import salt.utils.dockermod.translate.network
import salt.utils.platform
from salt.exceptions import CommandExecutionError
from salt.utils.dockermod.translate import helpers as translate_helpers
from tests.support.unit import TestCase

log =</B></FONT> logging.getLogger(__name__)


class Assert:
    def __init__(self, translator):
        self.translator = translator

    def __call__(self, func):
        self.func = func
        return functools.wraps(func)(
            # pylint: disable=unnecessary-lambda
            lambda testcase, *args, **kwargs: self.wrap(testcase, *args, **kwargs)
            # pylint: enable=unnecessary-lambda
        )

    def wrap(self, *args, **kwargs):
        raise NotImplementedError

    def test_stringlist(self, testcase, name):
        alias = self.translator.ALIASES_REVMAP.get(name)
        # Using file paths here because &quot;volumes&quot; must be passed through this
        # set of assertions and it requires absolute paths.
        if salt.utils.platform.is_windows():
            data = [r&quot;c:\foo&quot;, r&quot;c:\bar&quot;, r&quot;c:\baz&quot;]
        else:
            data = [&quot;/foo&quot;, &quot;/bar&quot;, &quot;/baz&quot;]
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: &quot;,&quot;.join(data)}
                ),
                testcase.apply_defaults({name: data}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: data}),
                testcase.apply_defaults({name: data}),
            )
            if name != &quot;volumes&quot;:
                # Test coercing to string
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, **{item: [&quot;one&quot;, 2]}
                    ),
                    testcase.apply_defaults({name: [&quot;one&quot;, &quot;2&quot;]}),
                )
        if alias is not None:
            # Test collision
            # sorted() used here because we want to confirm that we discard the
            # alias' value and go with the unsorted version.
            test_kwargs = {name: data, alias: sorted(data)}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )

    def test_key_value(self, testcase, name, delimiter):
        &quot;&quot;&quot;
        Common logic for key/value pair testing. IP address validation is
        turned off here, and must be done separately in the wrapped function.
        &quot;&quot;&quot;
        alias = self.translator.ALIASES_REVMAP.get(name)
        expected = {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}
        vals = &quot;foo{0}bar,baz{0}qux&quot;.format(delimiter)
        for item in (name, alias):
            if item is None:
                continue
            for val in (vals, vals.split(&quot;,&quot;)):
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=False, **{item: val}
                    ),
                    testcase.apply_defaults({name: expected}),
                )
            # Dictionary input
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, validate_ip_addrs=False, **{item: expected}
                ),
                testcase.apply_defaults({name: expected}),
            )
            # &quot;Dictlist&quot; input from states
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=False,
                    **{item: [{&quot;foo&quot;: &quot;bar&quot;}, {&quot;baz&quot;: &quot;qux&quot;}]}
                ),
                testcase.apply_defaults({name: expected}),
            )
        if alias is not None:
            # Test collision
            test_kwargs = {name: vals, alias: &quot;hello{}world&quot;.format(delimiter)}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=False,
                    ignore_collisions=True,
                    **test_kwargs
                ),
                testcase.apply_defaults({name: expected}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=False,
                    ignore_collisions=False,
                    **test_kwargs
                )


class assert_bool(Assert):
    &quot;&quot;&quot;
    Test a boolean value
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: True}),
                testcase.apply_defaults({name: True}),
            )
            # These two are contrived examples, but they will test bool-ifying
            # a non-bool value to ensure proper input format.
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: &quot;foo&quot;}),
                testcase.apply_defaults({name: True}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: 0}),
                testcase.apply_defaults({name: False}),
            )
        if alias is not None:
            # Test collision
            test_kwargs = {name: True, alias: False}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)


class assert_int(Assert):
    &quot;&quot;&quot;
    Test an integer value
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            for val in (100, &quot;100&quot;):
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, **{item: val}
                    ),
                    testcase.apply_defaults({name: 100}),
                )
            # Error case: non-numeric value passed
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;'foo' is not an integer&quot;
            ):
                salt.utils.dockermod.translate_input(self.translator, **{item: &quot;foo&quot;})
        if alias is not None:
            # Test collision
            test_kwargs = {name: 100, alias: 200}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)


class assert_string(Assert):
    &quot;&quot;&quot;
    Test that item is a string or is converted to one
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        # Using file paths here because &quot;working_dir&quot; must be passed through
        # this set of assertions and it requires absolute paths.
        if salt.utils.platform.is_windows():
            data = r&quot;c:\foo&quot;
        else:
            data = &quot;/foo&quot;
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: data}),
                testcase.apply_defaults({name: data}),
            )
            if name != &quot;working_dir&quot;:
                # Test coercing to string
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, **{item: 123}
                    ),
                    testcase.apply_defaults({name: &quot;123&quot;}),
                )
        if alias is not None:
            # Test collision
            test_kwargs = {name: data, alias: data}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)


class assert_int_or_string(Assert):
    &quot;&quot;&quot;
    Test an integer or string value
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: 100}),
                testcase.apply_defaults({name: 100}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: &quot;100M&quot;}),
                testcase.apply_defaults({name: &quot;100M&quot;}),
            )
        if alias is not None:
            # Test collision
            test_kwargs = {name: 100, alias: &quot;100M&quot;}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)


class assert_stringlist(Assert):
    &quot;&quot;&quot;
    Test a comma-separated or Python list of strings
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        self.test_stringlist(testcase, name)
        return self.func(testcase, *args, **kwargs)


class assert_dict(Assert):
    &quot;&quot;&quot;
    Dictionaries should be untouched, dictlists should be repacked and end up
    as a single dictionary.
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        expected = {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: expected}
                ),
                testcase.apply_defaults({name: expected}),
            )
            # &quot;Dictlist&quot; input from states
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: [{x: y} for x, y in expected.items()]}
                ),
                testcase.apply_defaults({name: expected}),
            )
            # Error case: non-dictionary input
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;'foo' is not a dictionary&quot;
            ):
                salt.utils.dockermod.translate_input(self.translator, **{item: &quot;foo&quot;})
        if alias is not None:
            # Test collision
            test_kwargs = {name: &quot;foo&quot;, alias: &quot;bar&quot;}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)


class assert_cmd(Assert):
    &quot;&quot;&quot;
    Test for a string, or a comma-separated or Python list of strings. This is
    different from a stringlist in that we do not do any splitting. This
    decorator is used both by the &quot;command&quot; and &quot;entrypoint&quot; arguments.
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: &quot;foo bar&quot;}
                ),
                testcase.apply_defaults({name: &quot;foo bar&quot;}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: [&quot;foo&quot;, &quot;bar&quot;]}
                ),
                testcase.apply_defaults({name: [&quot;foo&quot;, &quot;bar&quot;]}),
            )
            # Test coercing to string
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: 123}),
                testcase.apply_defaults({name: &quot;123&quot;}),
            )
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: [&quot;one&quot;, 2]}
                ),
                testcase.apply_defaults({name: [&quot;one&quot;, &quot;2&quot;]}),
            )
        if alias is not None:
            # Test collision
            test_kwargs = {name: &quot;foo&quot;, alias: &quot;bar&quot;}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)


class assert_key_colon_value(Assert):
    &quot;&quot;&quot;
    Test a key/value pair with parameters passed as key:value pairs
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        self.test_key_value(testcase, name, &quot;:&quot;)
        return self.func(testcase, *args, **kwargs)


class assert_key_equals_value(Assert):
    &quot;&quot;&quot;
    Test a key/value pair with parameters passed as key=value pairs
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        self.test_key_value(testcase, name, &quot;=&quot;)
        if name == &quot;labels&quot;:
            self.test_stringlist(testcase, name)
        return self.func(testcase, *args, **kwargs)


class assert_labels(Assert):
    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        labels = [&quot;foo&quot;, &quot;bar=baz&quot;, {&quot;hello&quot;: &quot;world&quot;}]
        expected = {&quot;foo&quot;: &quot;&quot;, &quot;bar&quot;: &quot;baz&quot;, &quot;hello&quot;: &quot;world&quot;}
        for item in (name, alias):
            if item is None:
                continue

            testcase.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, **{item: labels}),
                testcase.apply_defaults({name: expected}),
            )
            # Error case: Passed a mutli-element dict in dictlist
            bad_labels = copy.deepcopy(labels)
            bad_labels[-1][&quot;bad&quot;] = &quot;input&quot;
            with testcase.assertRaisesRegex(
                CommandExecutionError, r&quot;Invalid label\(s\)&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: bad_labels}
                )
        return self.func(testcase, *args, **kwargs)


class assert_device_rates(Assert):
    &quot;&quot;&quot;
    Tests for device_{read,write}_{bps,iops}. The bps values have a &quot;Rate&quot;
    value expressed in bytes/kb/mb/gb, while the iops values have a &quot;Rate&quot;
    expressed as a simple integer.
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue

            # Error case: Not an absolute path
            path = os.path.join(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
            with testcase.assertRaisesRegex(
                CommandExecutionError,
                &quot;Path '{}' is not absolute&quot;.format(path.replace(&quot;\\&quot;, &quot;\\\\&quot;)),
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: &quot;{}:1048576&quot;.format(path)}
                )

            if name.endswith(&quot;_bps&quot;):
                # Both integer bytes and a string providing a shorthand for kb,
                # mb, or gb can be used, so we need to test for both.
                expected = ({}, [])
                vals = &quot;/dev/sda:1048576,/dev/sdb:1048576&quot;
                for val in (vals, vals.split(&quot;,&quot;)):
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, **{item: val}
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {&quot;Path&quot;: &quot;/dev/sda&quot;, &quot;Rate&quot;: 1048576},
                                    {&quot;Path&quot;: &quot;/dev/sdb&quot;, &quot;Rate&quot;: 1048576},
                                ]
                            }
                        ),
                    )

                vals = &quot;/dev/sda:1mb,/dev/sdb:5mb&quot;
                for val in (vals, vals.split(&quot;,&quot;)):
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, **{item: val}
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {&quot;Path&quot;: &quot;/dev/sda&quot;, &quot;Rate&quot;: &quot;1mb&quot;},
                                    {&quot;Path&quot;: &quot;/dev/sdb&quot;, &quot;Rate&quot;: &quot;5mb&quot;},
                                ]
                            }
                        ),
                    )

                if alias is not None:
                    # Test collision
                    test_kwargs = {
                        name: &quot;/dev/sda:1048576,/dev/sdb:1048576&quot;,
                        alias: &quot;/dev/sda:1mb,/dev/sdb:5mb&quot;,
                    }
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, ignore_collisions=True, **test_kwargs
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {&quot;Path&quot;: &quot;/dev/sda&quot;, &quot;Rate&quot;: 1048576},
                                    {&quot;Path&quot;: &quot;/dev/sdb&quot;, &quot;Rate&quot;: 1048576},
                                ]
                            }
                        ),
                    )
                    with testcase.assertRaisesRegex(
                        CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
                    ):
                        salt.utils.dockermod.translate_input(
                            self.translator, ignore_collisions=False, **test_kwargs
                        )
            else:
                # The &quot;Rate&quot; value must be an integer
                vals = &quot;/dev/sda:1000,/dev/sdb:500&quot;
                for val in (vals, vals.split(&quot;,&quot;)):
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, **{item: val}
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {&quot;Path&quot;: &quot;/dev/sda&quot;, &quot;Rate&quot;: 1000},
                                    {&quot;Path&quot;: &quot;/dev/sdb&quot;, &quot;Rate&quot;: 500},
                                ]
                            }
                        ),
                    )
                # Test non-integer input
                expected = (
                    {},
                    {item: &quot;Rate '5mb' for path '/dev/sdb' is non-numeric&quot;},
                    [],
                )
                vals = &quot;/dev/sda:1000,/dev/sdb:5mb&quot;
                for val in (vals, vals.split(&quot;,&quot;)):
                    with testcase.assertRaisesRegex(
                        CommandExecutionError,
                        &quot;Rate '5mb' for path '/dev/sdb' is non-numeric&quot;,
                    ):
                        salt.utils.dockermod.translate_input(
                            self.translator, **{item: val}
                        )

                if alias is not None:
                    # Test collision
                    test_kwargs = {
                        name: &quot;/dev/sda:1000,/dev/sdb:500&quot;,
                        alias: &quot;/dev/sda:888,/dev/sdb:999&quot;,
                    }
                    testcase.assertEqual(
                        salt.utils.dockermod.translate_input(
                            self.translator, ignore_collisions=True, **test_kwargs
                        ),
                        testcase.apply_defaults(
                            {
                                name: [
                                    {&quot;Path&quot;: &quot;/dev/sda&quot;, &quot;Rate&quot;: 1000},
                                    {&quot;Path&quot;: &quot;/dev/sdb&quot;, &quot;Rate&quot;: 500},
                                ]
                            }
                        ),
                    )
                    with testcase.assertRaisesRegex(
                        CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
                    ):
                        salt.utils.dockermod.translate_input(
                            self.translator, ignore_collisions=False, **test_kwargs
                        )
        return self.func(testcase, *args, **kwargs)


class assert_subnet(Assert):
    &quot;&quot;&quot;
    Test an IPv4 or IPv6 subnet
    &quot;&quot;&quot;

    def wrap(self, testcase, *args, **kwargs):  # pylint: disable=arguments-differ
        # Strip off the &quot;test_&quot; from the function name
        name = self.func.__name__[5:]
        alias = self.translator.ALIASES_REVMAP.get(name)
        for item in (name, alias):
            if item is None:
                continue
            for val in (&quot;127.0.0.1/32&quot;, &quot;::1/128&quot;):
                log.debug(&quot;Verifying '%s' is a valid subnet&quot;, val)
                testcase.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=True, **{item: val}
                    ),
                    testcase.apply_defaults({name: val}),
                )
            # Error case: invalid subnet caught by validation
            for val in (
                &quot;127.0.0.1&quot;,
                &quot;999.999.999.999/24&quot;,
                &quot;10.0.0.0/33&quot;,
                &quot;::1&quot;,
                &quot;feaz::1/128&quot;,
                &quot;::1/129&quot;,
            ):
                log.debug(&quot;Verifying '%s' is not a valid subnet&quot;, val)
                with testcase.assertRaisesRegex(
                    CommandExecutionError, &quot;'{}' is not a valid subnet&quot;.format(val)
                ):
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=True, **{item: val}
                    )

            # This is not valid input but it will test whether or not subnet
            # validation happened
            val = &quot;foo&quot;
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, validate_ip_addrs=False, **{item: val}
                ),
                testcase.apply_defaults({name: val}),
            )

        if alias is not None:
            # Test collision
            test_kwargs = {name: &quot;10.0.0.0/24&quot;, alias: &quot;192.168.50.128/25&quot;}
            testcase.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=True, **test_kwargs
                ),
                testcase.apply_defaults({name: test_kwargs[name]}),
            )
            with testcase.assertRaisesRegex(
                CommandExecutionError, &quot;is an alias for.+cannot both be used&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, ignore_collisions=False, **test_kwargs
                )
        return self.func(testcase, *args, **kwargs)


class TranslateBase(TestCase):
    maxDiff = None
    translator = None  # Must be overridden in the subclass

    def apply_defaults(self, ret, skip_translate=None):
        if skip_translate is not True:
            defaults = getattr(self.translator, &quot;DEFAULTS&quot;, {})
            for key, val in defaults.items():
                if key not in ret:
                    ret[key] = val
        return ret

    @staticmethod
    def normalize_ports(ret):
        &quot;&quot;&quot;
        When we translate exposed ports, we can end up with a mixture of ints
        (representing TCP ports) and tuples (representing UDP ports). Python 2
        will sort an iterable containing these mixed types, but Python 3 will
        not. This helper is used to munge the ports in the return data so that
        the resulting list is sorted in a way that can reliably be compared to
        the expected results in the test.

        This helper should only be needed for port_bindings and ports.
        &quot;&quot;&quot;
        if &quot;ports&quot; in ret[0]:
            tcp_ports = []
            udp_ports = []
            for item in ret[0][&quot;ports&quot;]:
                if isinstance(item, int):
                    tcp_ports.append(item)
                else:
                    udp_ports.append(item)
            ret[0][&quot;ports&quot;] = sorted(tcp_ports) + sorted(udp_ports)
        return ret

    def tearDown(self):
        &quot;&quot;&quot;
        Test skip_translate kwarg
        &quot;&quot;&quot;
        name = self.id().split(&quot;.&quot;)[-1][5:]
        # The below is not valid input for the Docker API, but these
        # assertions confirm that we successfully skipped translation.
        for val in (True, name, [name]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, skip_translate=val, **{name: &quot;foo&quot;}
                ),
                self.apply_defaults({name: &quot;foo&quot;}, skip_translate=val),
            )


class TranslateContainerInputTestCase(TranslateBase):
    &quot;&quot;&quot;
    Tests for salt.utils.dockermod.translate_input(), invoked using
    salt.utils.dockermod.translate.container as the translator module.
    &quot;&quot;&quot;

    translator = salt.utils.dockermod.translate.container

    @staticmethod
    def normalize_ports(ret):
        &quot;&quot;&quot;
        When we translate exposed ports, we can end up with a mixture of ints
        (representing TCP ports) and tuples (representing UDP ports). Python 2
        will sort an iterable containing these mixed types, but Python 3 will
        not. This helper is used to munge the ports in the return data so that
        the resulting list is sorted in a way that can reliably be compared to
        the expected results in the test.

        This helper should only be needed for port_bindings and ports.
        &quot;&quot;&quot;
        if &quot;ports&quot; in ret:
            tcp_ports = []
            udp_ports = []
            for item in ret[&quot;ports&quot;]:
                if isinstance(item, int):
                    tcp_ports.append(item)
                else:
                    udp_ports.append(item)
            ret[&quot;ports&quot;] = sorted(tcp_ports) + sorted(udp_ports)
        return ret

    @assert_bool(salt.utils.dockermod.translate.container)
    def test_auto_remove(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    def test_binds(self):
        &quot;&quot;&quot;
        Test the &quot;binds&quot; kwarg. Any volumes not defined in the &quot;volumes&quot; kwarg
        should be added to the results.
        &quot;&quot;&quot;
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator, binds=&quot;/srv/www:/var/www:ro&quot;, volumes=&quot;/testing&quot;
            ),
            {&quot;binds&quot;: [&quot;/srv/www:/var/www:ro&quot;], &quot;volumes&quot;: [&quot;/testing&quot;, &quot;/var/www&quot;]},
        )
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator, binds=[&quot;/srv/www:/var/www:ro&quot;], volumes=&quot;/testing&quot;
            ),
            {&quot;binds&quot;: [&quot;/srv/www:/var/www:ro&quot;], &quot;volumes&quot;: [&quot;/testing&quot;, &quot;/var/www&quot;]},
        )
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator,
                binds={&quot;/srv/www&quot;: {&quot;bind&quot;: &quot;/var/www&quot;, &quot;mode&quot;: &quot;ro&quot;}},
                volumes=&quot;/testing&quot;,
            ),
            {
                &quot;binds&quot;: {&quot;/srv/www&quot;: {&quot;bind&quot;: &quot;/var/www&quot;, &quot;mode&quot;: &quot;ro&quot;}},
                &quot;volumes&quot;: [&quot;/testing&quot;, &quot;/var/www&quot;],
            },
        )

    @assert_int(salt.utils.dockermod.translate.container)
    def test_blkio_weight(self):
        &quot;&quot;&quot;
        Should be an int or converted to one
        &quot;&quot;&quot;

    def test_blkio_weight_device(self):
        &quot;&quot;&quot;
        Should translate a list of PATH:WEIGHT pairs to a list of dictionaries
        with the following format: {'Path': PATH, 'Weight': WEIGHT}
        &quot;&quot;&quot;
        for val in (&quot;/dev/sda:100,/dev/sdb:200&quot;, [&quot;/dev/sda:100&quot;, &quot;/dev/sdb:200&quot;]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, blkio_weight_device=&quot;/dev/sda:100,/dev/sdb:200&quot;
                ),
                {
                    &quot;blkio_weight_device&quot;: [
                        {&quot;Path&quot;: &quot;/dev/sda&quot;, &quot;Weight&quot;: 100},
                        {&quot;Path&quot;: &quot;/dev/sdb&quot;, &quot;Weight&quot;: 200},
                    ]
                },
            )

        # Error cases
        with self.assertRaisesRegex(
            CommandExecutionError, r&quot;'foo' contains 1 value\(s\) \(expected 2\)&quot;
        ):
            salt.utils.dockermod.translate_input(
                self.translator, blkio_weight_device=&quot;foo&quot;
            )
        with self.assertRaisesRegex(
            CommandExecutionError, r&quot;'foo:bar:baz' contains 3 value\(s\) \(expected 2\)&quot;
        ):
            salt.utils.dockermod.translate_input(
                self.translator, blkio_weight_device=&quot;foo:bar:baz&quot;
            )
        with self.assertRaisesRegex(
            CommandExecutionError, r&quot;Weight 'foo' for path '/dev/sdb' is not an integer&quot;
        ):
            salt.utils.dockermod.translate_input(
                self.translator, blkio_weight_device=[&quot;/dev/sda:100&quot;, &quot;/dev/sdb:foo&quot;]
            )

    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_cap_add(self):
        &quot;&quot;&quot;
        Should be a list of strings or converted to one
        &quot;&quot;&quot;

    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_cap_drop(self):
        &quot;&quot;&quot;
        Should be a list of strings or converted to one
        &quot;&quot;&quot;

    @assert_cmd(salt.utils.dockermod.translate.container)
    def test_command(self):
        &quot;&quot;&quot;
        Can either be a string or a comma-separated or Python list of strings.
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_cpuset_cpus(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_cpuset_mems(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_int(salt.utils.dockermod.translate.container)
    def test_cpu_group(self):
        &quot;&quot;&quot;
        Should be an int or converted to one
        &quot;&quot;&quot;

    @assert_int(salt.utils.dockermod.translate.container)
    def test_cpu_period(self):
        &quot;&quot;&quot;
        Should be an int or converted to one
        &quot;&quot;&quot;

    @assert_int(salt.utils.dockermod.translate.container)
    def test_cpu_shares(self):
        &quot;&quot;&quot;
        Should be an int or converted to one
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.container)
    def test_detach(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_device_rates(salt.utils.dockermod.translate.container)
    def test_device_read_bps(self):
        &quot;&quot;&quot;
        CLI input is a list of PATH:RATE pairs, but the API expects a list of
        dictionaries in the format [{'Path': path, 'Rate': rate}]
        &quot;&quot;&quot;

    @assert_device_rates(salt.utils.dockermod.translate.container)
    def test_device_read_iops(self):
        &quot;&quot;&quot;
        CLI input is a list of PATH:RATE pairs, but the API expects a list of
        dictionaries in the format [{'Path': path, 'Rate': rate}]
        &quot;&quot;&quot;

    @assert_device_rates(salt.utils.dockermod.translate.container)
    def test_device_write_bps(self):
        &quot;&quot;&quot;
        CLI input is a list of PATH:RATE pairs, but the API expects a list of
        dictionaries in the format [{'Path': path, 'Rate': rate}]
        &quot;&quot;&quot;

    @assert_device_rates(salt.utils.dockermod.translate.container)
    def test_device_write_iops(self):
        &quot;&quot;&quot;
        CLI input is a list of PATH:RATE pairs, but the API expects a list of
        dictionaries in the format [{'Path': path, 'Rate': rate}]
        &quot;&quot;&quot;

    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_devices(self):
        &quot;&quot;&quot;
        Should be a list of strings or converted to one
        &quot;&quot;&quot;

    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_dns_opt(self):
        &quot;&quot;&quot;
        Should be a list of strings or converted to one
        &quot;&quot;&quot;

    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_dns_search(self):
        &quot;&quot;&quot;
        Should be a list of strings or converted to one
        &quot;&quot;&quot;

    def test_dns(self):
        &quot;&quot;&quot;
        While this is a stringlist, it also supports IP address validation, so
        it can't use the test_stringlist decorator because we need to test both
        with and without validation, and it isn't necessary to make all other
        stringlist tests also do that same kind of testing.
        &quot;&quot;&quot;
        for val in (&quot;8.8.8.8,8.8.4.4&quot;, [&quot;8.8.8.8&quot;, &quot;8.8.4.4&quot;]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    dns=val,
                    validate_ip_addrs=True,
                ),
                {&quot;dns&quot;: [&quot;8.8.8.8&quot;, &quot;8.8.4.4&quot;]},
            )

        # Error case: invalid IP address caught by validation
        for val in (&quot;8.8.8.888,8.8.4.4&quot;, [&quot;8.8.8.888&quot;, &quot;8.8.4.4&quot;]):
            with self.assertRaisesRegex(
                CommandExecutionError, r&quot;'8.8.8.888' is not a valid IP address&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    dns=val,
                    validate_ip_addrs=True,
                )

        # This is not valid input but it will test whether or not IP address
        # validation happened.
        for val in (&quot;foo,bar&quot;, [&quot;foo&quot;, &quot;bar&quot;]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    dns=val,
                    validate_ip_addrs=False,
                ),
                {&quot;dns&quot;: [&quot;foo&quot;, &quot;bar&quot;]},
            )

    @assert_string(salt.utils.dockermod.translate.container)
    def test_domainname(self):
        &quot;&quot;&quot;
        Should be a list of strings or converted to one
        &quot;&quot;&quot;

    @assert_cmd(salt.utils.dockermod.translate.container)
    def test_entrypoint(self):
        &quot;&quot;&quot;
        Can either be a string or a comma-separated or Python list of strings.
        &quot;&quot;&quot;

    @assert_key_equals_value(salt.utils.dockermod.translate.container)
    def test_environment(self):
        &quot;&quot;&quot;
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        &quot;&quot;&quot;

    def test_extra_hosts(self):
        &quot;&quot;&quot;
        Can be passed as a list of key:value pairs but can't be simply tested
        using @assert_key_colon_value since we need to test both with and without
        IP address validation.
        &quot;&quot;&quot;
        for val in (&quot;web1:10.9.8.7,web2:10.9.8.8&quot;, [&quot;web1:10.9.8.7&quot;, &quot;web2:10.9.8.8&quot;]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    extra_hosts=val,
                    validate_ip_addrs=True,
                ),
                {&quot;extra_hosts&quot;: {&quot;web1&quot;: &quot;10.9.8.7&quot;, &quot;web2&quot;: &quot;10.9.8.8&quot;}},
            )

        # Error case: invalid IP address caught by validation
        for val in (
            &quot;web1:10.9.8.299,web2:10.9.8.8&quot;,
            [&quot;web1:10.9.8.299&quot;, &quot;web2:10.9.8.8&quot;],
        ):
            with self.assertRaisesRegex(
                CommandExecutionError, r&quot;'10.9.8.299' is not a valid IP address&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    extra_hosts=val,
                    validate_ip_addrs=True,
                )

        # This is not valid input but it will test whether or not IP address
        # validation happened.
        for val in (&quot;foo:bar,baz:qux&quot;, [&quot;foo:bar&quot;, &quot;baz:qux&quot;]):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    extra_hosts=val,
                    validate_ip_addrs=False,
                ),
                {&quot;extra_hosts&quot;: {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}},
            )

    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_group_add(self):
        &quot;&quot;&quot;
        Should be a list of strings or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_hostname(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_ipc_mode(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_isolation(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_labels(salt.utils.dockermod.translate.container)
    def test_labels(self):
        &quot;&quot;&quot;
        Can be passed as a list of key=value pairs or a dictionary, and must
        ultimately end up as a dictionary.
        &quot;&quot;&quot;

    @assert_key_colon_value(salt.utils.dockermod.translate.container)
    def test_links(self):
        &quot;&quot;&quot;
        Can be passed as a list of key:value pairs or a dictionary, and must
        ultimately end up as a dictionary.
        &quot;&quot;&quot;

    def test_log_config(self):
        &quot;&quot;&quot;
        This is a mixture of log_driver and log_opt, which get combined into a
        dictionary.

        log_driver is a simple string, but log_opt can be passed in several
        ways, so we need to test them all.
        &quot;&quot;&quot;
        expected = (
            {&quot;log_config&quot;: {&quot;Type&quot;: &quot;foo&quot;, &quot;Config&quot;: {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}}},
            {},
            [],
        )
        for val in (
            &quot;foo=bar,baz=qux&quot;,
            [&quot;foo=bar&quot;, &quot;baz=qux&quot;],
            [{&quot;foo&quot;: &quot;bar&quot;}, {&quot;baz&quot;: &quot;qux&quot;}],
            {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;},
        ):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, log_driver=&quot;foo&quot;, log_opt=&quot;foo=bar,baz=qux&quot;
                ),
                {&quot;log_config&quot;: {&quot;Type&quot;: &quot;foo&quot;, &quot;Config&quot;: {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}}},
            )

        # Ensure passing either `log_driver` or `log_opt` alone works
        self.assertEqual(
            salt.utils.dockermod.translate_input(self.translator, log_driver=&quot;foo&quot;),
            {&quot;log_config&quot;: {&quot;Type&quot;: &quot;foo&quot;, &quot;Config&quot;: {}}},
        )
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator, log_opt={&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}
            ),
            {&quot;log_config&quot;: {&quot;Type&quot;: &quot;none&quot;, &quot;Config&quot;: {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;qux&quot;}}},
        )

    @assert_key_equals_value(salt.utils.dockermod.translate.container)
    def test_lxc_conf(self):
        &quot;&quot;&quot;
        Can be passed as a list of key=value pairs or a dictionary, and must
        ultimately end up as a dictionary.
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_mac_address(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_int_or_string(salt.utils.dockermod.translate.container)
    def test_mem_limit(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_int(salt.utils.dockermod.translate.container)
    def test_mem_swappiness(self):
        &quot;&quot;&quot;
        Should be an int or converted to one
        &quot;&quot;&quot;

    @assert_int_or_string(salt.utils.dockermod.translate.container)
    def test_memswap_limit(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_name(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.container)
    def test_network_disabled(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_network_mode(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.container)
    def test_oom_kill_disable(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_int(salt.utils.dockermod.translate.container)
    def test_oom_score_adj(self):
        &quot;&quot;&quot;
        Should be an int or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_pid_mode(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_int(salt.utils.dockermod.translate.container)
    def test_pids_limit(self):
        &quot;&quot;&quot;
        Should be an int or converted to one
        &quot;&quot;&quot;

    def test_port_bindings(self):
        &quot;&quot;&quot;
        This has several potential formats and can include port ranges. It
        needs its own test.
        &quot;&quot;&quot;
        # ip:hostPort:containerPort - Bind a specific IP and port on the host
        # to a specific port within the container.
        bindings = (
            &quot;10.1.2.3:8080:80,10.1.2.3:8888:80,10.4.5.6:3333:3333,&quot;
            &quot;10.7.8.9:14505-14506:4505-4506,10.1.2.3:8080:81/udp,&quot;
            &quot;10.1.2.3:8888:81/udp,10.4.5.6:3334:3334/udp,&quot;
            &quot;10.7.8.9:15505-15506:5505-5506/udp&quot;
        )
        for val in (bindings, bindings.split(&quot;,&quot;)):
<A NAME="0"></A>            self.assertEqual(
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51296-0.html#0',2,'match51296-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.translator,
                        port_bindings=val,
                    )
                ),
                {
                    &quot;port_bindings&quot;: {
                        80: [(&quot;10.1.2.3&quot;, 8080), (&quot;10.1.2.3&quot;, 8888)],
                        3333: (&quot;10.4.5.6&quot;, 3333),
                        4505: (&quot;10.7.8.9&quot;, 14505),
                        4506: (&quot;10.7.8.9&quot;, 14506),
                        &quot;81/udp&quot;: [(&quot;10.1.2.3&quot;, 8080), (&quot;10.1.2.3&quot;, 8888)],
                        &quot;3334/udp&quot;: (&quot;10.4.5.6&quot;, 3334),
                        &quot;5505/udp&quot;: (&quot;10.7.8.9&quot;, 15505),
                        &quot;5506/udp&quot;: (&quot;10.7.8.9&quot;, 15506),
                    },
                    &quot;ports&quot;: [
                        80,
                        3333,
                        4505,
                        4506,
                        (81, &quot;udp&quot;),
                        (3334, &quot;udp&quot;),
                        (5505, &quot;udp&quot;),
                        (5506</B></FONT>, &quot;udp&quot;),
                    ],
                },
            )

        # ip::containerPort - Bind a specific IP and an ephemeral port to a
        # specific port within the container.
        bindings = (
            &quot;10.1.2.3::80,10.1.2.3::80,10.4.5.6::3333,10.7.8.9::4505-4506,&quot;
            &quot;10.1.2.3::81/udp,10.1.2.3::81/udp,10.4.5.6::3334/udp,&quot;
            &quot;10.7.8.9::5505-5506/udp&quot;
        )
        for val in (bindings, bindings.split(&quot;,&quot;)):
            self.assertEqual(
<A NAME="1"></A>                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        port_bindings<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51296-0.html#1',2,'match51296-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>=val,
                    )
                ),
                {
                    &quot;port_bindings&quot;: {
                        80: [(&quot;10.1.2.3&quot;,), (&quot;10.1.2.3&quot;,)],
                        3333: (&quot;10.4.5.6&quot;,),
                        4505: (&quot;10.7.8.9&quot;,),
                        4506: (&quot;10.7.8.9&quot;,),
                        &quot;81/udp&quot;: [(&quot;10.1.2.3&quot;,), (&quot;10.1.2.3&quot;,)],
                        &quot;3334/udp&quot;: (&quot;10.4.5.6&quot;,),
                        &quot;5505/udp&quot;: (&quot;10.7.8.9&quot;,),
                        &quot;5506/udp&quot;: (&quot;10.7.8.9&quot;,),
                    },
                    &quot;ports&quot;: [
                        80,
                        3333,
                        4505,
                        4506,
                        (81, &quot;udp&quot;),
                        (3334, &quot;udp&quot;),
                        (5505, &quot;udp&quot;),
                        (5506</B></FONT>, &quot;udp&quot;),
                    ],
                },
            )

        # hostPort:containerPort - Bind a specific port on all of the host's
        # interfaces to a specific port within the container.
        bindings = (
            &quot;8080:80,8888:80,3333:3333,14505-14506:4505-4506,8080:81/udp,&quot;
            &quot;8888:81/udp,3334:3334/udp,15505-15506:5505-5506/udp&quot;
        )
        for val in (bindings, bindings.split(&quot;,&quot;)):
            self.assertEqual(
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        port_bindings=val,
                    )
                ),
                {
                    &quot;port_bindings&quot;: {
                        80: [8080, 8888],
                        3333: 3333,
                        4505: 14505,
                        4506: 14506,
                        &quot;81/udp&quot;: [8080, 8888],
                        &quot;3334/udp&quot;: 3334,
                        &quot;5505/udp&quot;: 15505,
                        &quot;5506/udp&quot;: 15506,
                    },
                    &quot;ports&quot;: [
                        80,
                        3333,
                        4505,
                        4506,
                        (81, &quot;udp&quot;),
                        (3334, &quot;udp&quot;),
                        (5505, &quot;udp&quot;),
                        (5506, &quot;udp&quot;),
                    ],
                },
            )

        # containerPort - Bind an ephemeral port on all of the host's
        # interfaces to a specific port within the container.
        bindings = &quot;80,3333,4505-4506,81/udp,3334/udp,5505-5506/udp&quot;
        for val in (bindings, bindings.split(&quot;,&quot;)):
            self.assertEqual(
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        port_bindings=val,
                    )
                ),
                {
                    &quot;port_bindings&quot;: {
                        80: None,
                        3333: None,
                        4505: None,
                        4506: None,
                        &quot;81/udp&quot;: None,
                        &quot;3334/udp&quot;: None,
                        &quot;5505/udp&quot;: None,
                        &quot;5506/udp&quot;: None,
                    },
                    &quot;ports&quot;: [
                        80,
                        3333,
                        4505,
                        4506,
                        (81, &quot;udp&quot;),
                        (3334, &quot;udp&quot;),
                        (5505, &quot;udp&quot;),
                        (5506, &quot;udp&quot;),
                    ],
                },
            )

        # Test a mixture of different types of input
        bindings = (
            &quot;10.1.2.3:8080:80,10.4.5.6::3333,14505-14506:4505-4506,&quot;
            &quot;9999-10001,10.1.2.3:8080:81/udp,10.4.5.6::3334/udp,&quot;
            &quot;15505-15506:5505-5506/udp,19999-20001/udp&quot;
        )
        for val in (bindings, bindings.split(&quot;,&quot;)):
            self.assertEqual(
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        port_bindings=val,
<A NAME="3"></A>                    )
                ),
                {
                    <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51296-0.html#3',2,'match51296-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;port_bindings&quot;: {
                        80: (&quot;10.1.2.3&quot;, 8080),
                        3333: (&quot;10.4.5.6&quot;,),
                        4505: 14505,
                        4506: 14506,
                        9999: None,
                        10000: None,
                        10001: None,
                        &quot;81/udp&quot;: (&quot;10.1.2.3&quot;, 8080),
                        &quot;3334/udp&quot;: (&quot;10.4.5.6&quot;,),
                        &quot;5505/udp&quot;: 15505,
                        &quot;5506/udp&quot;: 15506,
                        &quot;19999/udp&quot;: None,
                        &quot;20000/udp&quot;: None,
                        &quot;20001/udp&quot;: None,
                    },
                    &quot;ports&quot;: [
                        80,
                        3333,
                        4505,
                        4506,
                        9999,
                        10000,
                        10001,
                        (81, &quot;udp&quot;),
                        (3334, &quot;udp&quot;),
                        (5505, &quot;udp&quot;),
                        (5506, &quot;udp&quot;),
                        (19999, &quot;udp&quot;),
                        (20000, &quot;udp&quot;),
                        (20001</B></FONT>, &quot;udp&quot;),
                    ],
                },
            )

        # Error case: too many items (max 3)
        with self.assertRaisesRegex(
            CommandExecutionError,
            r&quot;'10.1.2.3:8080:80:123' is an invalid port binding &quot;
            r&quot;definition \(at most 3 components are allowed, found 4\)&quot;,
        ):
            salt.utils.dockermod.translate_input(
                self.translator, port_bindings=&quot;10.1.2.3:8080:80:123&quot;
            )

        # Error case: port range start is greater than end
        for val in (
            &quot;10.1.2.3:5555-5554:1111-1112&quot;,
            &quot;10.1.2.3:1111-1112:5555-5554&quot;,
            &quot;10.1.2.3::5555-5554&quot;,
            &quot;5555-5554:1111-1112&quot;,
            &quot;1111-1112:5555-5554&quot;,
            &quot;5555-5554&quot;,
        ):
            with self.assertRaisesRegex(
                CommandExecutionError,
                r&quot;Start of port range \(5555\) cannot be greater than end &quot;
                r&quot;of port range \(5554\)&quot;,
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    port_bindings=val,
                )

        # Error case: non-numeric port range
        for val in (
            &quot;10.1.2.3:foo:1111-1112&quot;,
            &quot;10.1.2.3:1111-1112:foo&quot;,
            &quot;10.1.2.3::foo&quot;,
            &quot;foo:1111-1112&quot;,
            &quot;1111-1112:foo&quot;,
            &quot;foo&quot;,
        ):
            with self.assertRaisesRegex(
                CommandExecutionError, &quot;'foo' is non-numeric or an invalid port range&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    port_bindings=val,
                )

        # Error case: misatched port range
        for val in (&quot;10.1.2.3:1111-1113:1111-1112&quot;, &quot;1111-1113:1111-1112&quot;):
            with self.assertRaisesRegex(
                CommandExecutionError,
                r&quot;Host port range \(1111-1113\) does not have the same &quot;
                r&quot;number of ports as the container port range \(1111-1112\)&quot;,
            ):
                salt.utils.dockermod.translate_input(self.translator, port_bindings=val)

        for val in (&quot;10.1.2.3:1111-1112:1111-1113&quot;, &quot;1111-1112:1111-1113&quot;):
            with self.assertRaisesRegex(
                CommandExecutionError,
                r&quot;Host port range \(1111-1112\) does not have the same &quot;
                r&quot;number of ports as the container port range \(1111-1113\)&quot;,
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    port_bindings=val,
                )

        # Error case: empty host port or container port
        with self.assertRaisesRegex(
            CommandExecutionError, &quot;Empty host port in port binding definition ':1111'&quot;
        ):
            salt.utils.dockermod.translate_input(self.translator, port_bindings=&quot;:1111&quot;)
        with self.assertRaisesRegex(
            CommandExecutionError,
            &quot;Empty container port in port binding definition '1111:'&quot;,
        ):
            salt.utils.dockermod.translate_input(self.translator, port_bindings=&quot;1111:&quot;)
        with self.assertRaisesRegex(
            CommandExecutionError, &quot;Empty port binding definition found&quot;
        ):
            salt.utils.dockermod.translate_input(self.translator, port_bindings=&quot;&quot;)

    def test_ports(self):
        &quot;&quot;&quot;
        Ports can be passed as a comma-separated or Python list of port
        numbers, with '/tcp' being optional for TCP ports. They must ultimately
        be a list of port definitions, in which an integer denotes a TCP port,
        and a tuple in the format (port_num, 'udp') denotes a UDP port. Also,
        the port numbers must end up as integers. None of the decorators will
        suffice so this one must be tested specially.
        &quot;&quot;&quot;
        for val in (
            &quot;1111,2222/tcp,3333/udp,4505-4506&quot;,
            [1111, &quot;2222/tcp&quot;, &quot;3333/udp&quot;, &quot;4505-4506&quot;],
            [&quot;1111&quot;, &quot;2222/tcp&quot;, &quot;3333/udp&quot;, &quot;4505-4506&quot;],
        ):
            self.assertEqual(
                self.normalize_ports(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        ports=val,
                    )
                ),
                {&quot;ports&quot;: [1111, 2222, 4505, 4506, (3333, &quot;udp&quot;)]},
            )

        # Error case: non-integer and non/string value
        for val in (1.0, [1.0]):
            with self.assertRaisesRegex(
                CommandExecutionError, &quot;'1.0' is not a valid port definition&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    ports=val,
                )

        # Error case: port range start is greater than end
        with self.assertRaisesRegex(
            CommandExecutionError,
            r&quot;Start of port range \(5555\) cannot be greater than end of &quot;
            r&quot;port range \(5554\)&quot;,
        ):
            salt.utils.dockermod.translate_input(
                self.translator,
                ports=&quot;5555-5554&quot;,
            )

    @assert_bool(salt.utils.dockermod.translate.container)
    def test_privileged(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.container)
    def test_publish_all_ports(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.container)
    def test_read_only(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    def test_restart_policy(self):
        &quot;&quot;&quot;
        Input is in the format &quot;name[:retry_count]&quot;, but the API wants it
        in the format {'Name': name, 'MaximumRetryCount': retry_count}
        &quot;&quot;&quot;
        name = &quot;restart_policy&quot;
        alias = &quot;restart&quot;
        for item in (name, alias):
            # Test with retry count
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: &quot;on-failure:5&quot;}
                ),
                {name: {&quot;Name&quot;: &quot;on-failure&quot;, &quot;MaximumRetryCount&quot;: 5}},
            )
            # Test without retry count
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: &quot;on-failure&quot;}
                ),
                {name: {&quot;Name&quot;: &quot;on-failure&quot;, &quot;MaximumRetryCount&quot;: 0}},
            )
            # Error case: more than one policy passed
            with self.assertRaisesRegex(
                CommandExecutionError, &quot;Only one policy is permitted&quot;
            ):
                salt.utils.dockermod.translate_input(
                    self.translator, **{item: &quot;on-failure,always&quot;}
                )

        # Test collision
        test_kwargs = {name: &quot;on-failure:5&quot;, alias: &quot;always&quot;}
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator, ignore_collisions=True, **test_kwargs
            ),
            {name: {&quot;Name&quot;: &quot;on-failure&quot;, &quot;MaximumRetryCount&quot;: 5}},
        )
        with self.assertRaisesRegex(
            CommandExecutionError, &quot;'restart' is an alias for 'restart_policy'&quot;
        ):
            salt.utils.dockermod.translate_input(
                self.translator, ignore_collisions=False, **test_kwargs
            )

    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_security_opt(self):
        &quot;&quot;&quot;
        Should be a list of strings or converted to one
        &quot;&quot;&quot;

    @assert_int_or_string(salt.utils.dockermod.translate.container)
    def test_shm_size(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.container)
    def test_stdin_open(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_stop_signal(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_int(salt.utils.dockermod.translate.container)
    def test_stop_timeout(self):
        &quot;&quot;&quot;
        Should be an int or converted to one
        &quot;&quot;&quot;

    @assert_key_equals_value(salt.utils.dockermod.translate.container)
    def test_storage_opt(self):
        &quot;&quot;&quot;
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        &quot;&quot;&quot;

    @assert_key_equals_value(salt.utils.dockermod.translate.container)
    def test_sysctls(self):
        &quot;&quot;&quot;
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        &quot;&quot;&quot;

    @assert_dict(salt.utils.dockermod.translate.container)
    def test_tmpfs(self):
        &quot;&quot;&quot;
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.container)
    def test_tty(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    def test_ulimits(self):
        &quot;&quot;&quot;
        Input is in the format &quot;name=soft_limit[:hard_limit]&quot;, but the API
        wants it in the format
        {'Name': name, 'Soft': soft_limit, 'Hard': hard_limit}
        &quot;&quot;&quot;
        # Test with and without hard limit
        ulimits = &quot;nofile=1024:2048,nproc=50&quot;
        for val in (ulimits, ulimits.split(&quot;,&quot;)):
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    ulimits=val,
                ),
                {
                    &quot;ulimits&quot;: [
                        {&quot;Name&quot;: &quot;nofile&quot;, &quot;Soft&quot;: 1024, &quot;Hard&quot;: 2048},
                        {&quot;Name&quot;: &quot;nproc&quot;, &quot;Soft&quot;: 50, &quot;Hard&quot;: 50},
                    ]
                },
            )

        # Error case: Invalid format
        with self.assertRaisesRegex(
            CommandExecutionError,
            r&quot;Ulimit definition 'nofile:1024:2048' is not in the format &quot;
            r&quot;type=soft_limit\[:hard_limit\]&quot;,
        ):
            salt.utils.dockermod.translate_input(
                self.translator, ulimits=&quot;nofile:1024:2048&quot;
            )

        # Error case: Invalid format
        with self.assertRaisesRegex(
            CommandExecutionError,
            r&quot;Limit 'nofile=foo:2048' contains non-numeric value\(s\)&quot;,
        ):
            salt.utils.dockermod.translate_input(
                self.translator, ulimits=&quot;nofile=foo:2048&quot;
            )

    def test_user(self):
        &quot;&quot;&quot;
        Must be either username (string) or uid (int). An int passed as a
        string (e.g. '0') should be converted to an int.
        &quot;&quot;&quot;
        # Username passed as string
        self.assertEqual(
            salt.utils.dockermod.translate_input(self.translator, user=&quot;foo&quot;),
            {&quot;user&quot;: &quot;foo&quot;},
        )
        for val in (0, &quot;0&quot;):
            self.assertEqual(
                salt.utils.dockermod.translate_input(self.translator, user=val),
                {&quot;user&quot;: 0},
            )

        # Error case: non string/int passed
        with self.assertRaisesRegex(
            CommandExecutionError, &quot;Value must be a username or uid&quot;
        ):
            salt.utils.dockermod.translate_input(self.translator, user=[&quot;foo&quot;])

        # Error case: negative int passed
        with self.assertRaisesRegex(CommandExecutionError, &quot;'-1' is an invalid uid&quot;):
            salt.utils.dockermod.translate_input(self.translator, user=-1)

    @assert_string(salt.utils.dockermod.translate.container)
    def test_userns_mode(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_volume_driver(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_volumes(self):
        &quot;&quot;&quot;
        Should be a list of absolute paths
        &quot;&quot;&quot;
        # Error case: Not an absolute path
        path = os.path.join(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
        with self.assertRaisesRegex(
            CommandExecutionError,
            &quot;'{}' is not an absolute path&quot;.format(path.replace(&quot;\\&quot;, &quot;\\\\&quot;)),
        ):
            salt.utils.dockermod.translate_input(self.translator, volumes=path)

    @assert_stringlist(salt.utils.dockermod.translate.container)
    def test_volumes_from(self):
        &quot;&quot;&quot;
        Should be a list of strings or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.container)
    def test_working_dir(self):
        &quot;&quot;&quot;
        Should be a single absolute path
        &quot;&quot;&quot;
        # Error case: Not an absolute path
        path = os.path.join(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
        with self.assertRaisesRegex(
            CommandExecutionError,
            &quot;'{}' is not an absolute path&quot;.format(path.replace(&quot;\\&quot;, &quot;\\\\&quot;)),
        ):
            salt.utils.dockermod.translate_input(self.translator, working_dir=path)


class TranslateNetworkInputTestCase(TranslateBase):
    &quot;&quot;&quot;
    Tests for salt.utils.dockermod.translate_input(), invoked using
    salt.utils.dockermod.translate.network as the translator module.
    &quot;&quot;&quot;

    translator = salt.utils.dockermod.translate.network

    ip_addrs = {
        True: (&quot;10.1.2.3&quot;, &quot;::1&quot;),
        False: (&quot;FOO&quot;, &quot;0.9.800.1000&quot;, &quot;feaz::1&quot;, &quot;aj01::feac&quot;),
    }

    @assert_string(salt.utils.dockermod.translate.network)
    def test_driver(self):
        &quot;&quot;&quot;
        Should be a string or converted to one
        &quot;&quot;&quot;

    @assert_key_equals_value(salt.utils.dockermod.translate.network)
    def test_options(self):
        &quot;&quot;&quot;
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        &quot;&quot;&quot;

    @assert_dict(salt.utils.dockermod.translate.network)
    def test_ipam(self):
        &quot;&quot;&quot;
        Must be a dict
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.network)
    def test_check_duplicate(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.network)
    def test_internal(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_labels(salt.utils.dockermod.translate.network)
    def test_labels(self):
        &quot;&quot;&quot;
        Can be passed as a list of key=value pairs or a dictionary, and must
        ultimately end up as a dictionary.
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.network)
    def test_enable_ipv6(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.network)
    def test_attachable(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_bool(salt.utils.dockermod.translate.network)
    def test_ingress(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_string(salt.utils.dockermod.translate.network)
    def test_ipam_driver(self):
        &quot;&quot;&quot;
        Should be a bool or converted to one
        &quot;&quot;&quot;

    @assert_key_equals_value(salt.utils.dockermod.translate.network)
    def test_ipam_opts(self):
        &quot;&quot;&quot;
        Can be passed in several formats but must end up as a dictionary
        mapping keys to values
        &quot;&quot;&quot;

    def ipam_pools(self):
        &quot;&quot;&quot;
        Must be a list of dictionaries (not a dictlist)
        &quot;&quot;&quot;
        good_pool = {
            &quot;subnet&quot;: &quot;10.0.0.0/24&quot;,
            &quot;iprange&quot;: &quot;10.0.0.128/25&quot;,
            &quot;gateway&quot;: &quot;10.0.0.254&quot;,
            &quot;aux_addresses&quot;: {
                &quot;foo.bar.tld&quot;: &quot;10.0.0.20&quot;,
                &quot;hello.world.tld&quot;: &quot;10.0.0.21&quot;,
            },
        }
        bad_pools = [
            {
                &quot;subnet&quot;: &quot;10.0.0.0/33&quot;,
                &quot;iprange&quot;: &quot;10.0.0.128/25&quot;,
                &quot;gateway&quot;: &quot;10.0.0.254&quot;,
                &quot;aux_addresses&quot;: {
                    &quot;foo.bar.tld&quot;: &quot;10.0.0.20&quot;,
                    &quot;hello.world.tld&quot;: &quot;10.0.0.21&quot;,
                },
            },
            {
                &quot;subnet&quot;: &quot;10.0.0.0/24&quot;,
                &quot;iprange&quot;: &quot;foo/25&quot;,
                &quot;gateway&quot;: &quot;10.0.0.254&quot;,
                &quot;aux_addresses&quot;: {
                    &quot;foo.bar.tld&quot;: &quot;10.0.0.20&quot;,
                    &quot;hello.world.tld&quot;: &quot;10.0.0.21&quot;,
                },
            },
            {
                &quot;subnet&quot;: &quot;10.0.0.0/24&quot;,
                &quot;iprange&quot;: &quot;10.0.0.128/25&quot;,
                &quot;gateway&quot;: &quot;10.0.0.256&quot;,
                &quot;aux_addresses&quot;: {
                    &quot;foo.bar.tld&quot;: &quot;10.0.0.20&quot;,
                    &quot;hello.world.tld&quot;: &quot;10.0.0.21&quot;,
                },
            },
            {
                &quot;subnet&quot;: &quot;10.0.0.0/24&quot;,
                &quot;iprange&quot;: &quot;10.0.0.128/25&quot;,
                &quot;gateway&quot;: &quot;10.0.0.254&quot;,
                &quot;aux_addresses&quot;: {
                    &quot;foo.bar.tld&quot;: &quot;10.0.0.20&quot;,
                    &quot;hello.world.tld&quot;: &quot;999.0.0.21&quot;,
                },
            },
        ]
        self.assertEqual(
            salt.utils.dockermod.translate_input(
                self.translator,
                ipam_pools=[good_pool],
            ),
            {&quot;ipam_pools&quot;: [good_pool]},
        )
        for bad_pool in bad_pools:
            with self.assertRaisesRegex(CommandExecutionError, &quot;not a valid&quot;):
                salt.utils.dockermod.translate_input(
                    self.translator, ipam_pools=[good_pool, bad_pool]
                )

    @assert_subnet(salt.utils.dockermod.translate.network)
    def test_subnet(self):
        &quot;&quot;&quot;
        Must be an IPv4 or IPv6 subnet
        &quot;&quot;&quot;

    @assert_subnet(salt.utils.dockermod.translate.network)
    def test_iprange(self):
        &quot;&quot;&quot;
        Must be an IPv4 or IPv6 subnet
        &quot;&quot;&quot;

    def test_gateway(self):
        &quot;&quot;&quot;
        Must be an IPv4 or IPv6 address
        &quot;&quot;&quot;
        for val in self.ip_addrs[True]:
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=True,
                    gateway=val,
                ),
                self.apply_defaults({&quot;gateway&quot;: val}),
            )

        for val in self.ip_addrs[False]:
            with self.assertRaisesRegex(
                CommandExecutionError, &quot;'{}' is not a valid IP address&quot;.format(val)
            ):
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=True,
                    gateway=val,
                )
            self.assertEqual(
                salt.utils.dockermod.translate_input(
                    self.translator,
                    validate_ip_addrs=False,
                    gateway=val,
                ),
                self.apply_defaults(
                    {&quot;gateway&quot;: val if isinstance(val, str) else str(val)}
                ),
            )

    @assert_key_equals_value(salt.utils.dockermod.translate.network)
    def test_aux_addresses(self):
        &quot;&quot;&quot;
        Must be a mapping of hostnames to IP addresses
        &quot;&quot;&quot;
        name = &quot;aux_addresses&quot;
        alias = &quot;aux_address&quot;
        for item in (name, alias):
            for val in self.ip_addrs[True]:
                addresses = {&quot;foo.bar.tld&quot;: val}
                self.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=True, **{item: addresses}
                    ),
                    self.apply_defaults({name: addresses}),
                )

            for val in self.ip_addrs[False]:
                addresses = {&quot;foo.bar.tld&quot;: val}
                with self.assertRaisesRegex(
                    CommandExecutionError, &quot;'{}' is not a valid IP address&quot;.format(val)
                ):
                    salt.utils.dockermod.translate_input(
                        self.translator, validate_ip_addrs=True, **{item: addresses}
                    )
                self.assertEqual(
                    salt.utils.dockermod.translate_input(
                        self.translator,
                        validate_ip_addrs=False,
                        aux_addresses=addresses,
                    ),
                    self.apply_defaults({name: addresses}),
                )


class DockerTranslateHelperTestCase(TestCase):
    &quot;&quot;&quot;
    Tests for a couple helper functions in salt.utils.dockermod.translate
    &quot;&quot;&quot;

    def test_get_port_def(self):
        &quot;&quot;&quot;
        Test translation of port definition (1234, '1234/tcp', '1234/udp',
        etc.) into the format which docker-py uses (integer for TCP ports,
<A NAME="2"></A>        'port_num/udp' for UDP ports).
        &quot;&quot;&quot;
        # Test TCP port (passed as int, no protocol passed)
        self<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51296-0.html#2',2,'match51296-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertEqual(translate_helpers.get_port_def(2222), 2222)
        # Test TCP port (passed as str, no protocol passed)
        self.assertEqual(translate_helpers.get_port_def(&quot;2222&quot;), 2222)
        # Test TCP port (passed as str, with protocol passed)
        self.assertEqual(translate_helpers.get_port_def(&quot;2222&quot;, &quot;tcp&quot;), 2222)
        # Test TCP port (proto passed in port_num, with passed proto ignored).
        # This is a contrived example as we would never invoke the function in
        # this way, but it tests that we are taking the port number from the
        # port_num argument and ignoring the passed protocol.
        self.assertEqual(translate_helpers.get_port_def(&quot;2222/tcp&quot;, &quot;udp&quot;), 2222)

        # Test UDP port (passed as int)
        self.assertEqual(translate_helpers.get_port_def(</B></FONT>2222, &quot;udp&quot;), (2222, &quot;udp&quot;))
        # Test UDP port (passed as string)
        self.assertEqual(translate_helpers.get_port_def(&quot;2222&quot;, &quot;udp&quot;), (2222, &quot;udp&quot;))
        # Test UDP port (proto passed in port_num
        self.assertEqual(translate_helpers.get_port_def(&quot;2222/udp&quot;), (2222, &quot;udp&quot;))

    def test_get_port_range(self):
        &quot;&quot;&quot;
        Test extracting the start and end of a port range from a port range
        expression (e.g. 4505-4506)
        &quot;&quot;&quot;
        # Passing a single int should return the start and end as the same value
        self.assertEqual(translate_helpers.get_port_range(2222), (2222, 2222))
        # Same as above but with port number passed as a string
        self.assertEqual(translate_helpers.get_port_range(&quot;2222&quot;), (2222, 2222))
        # Passing a port range
        self.assertEqual(translate_helpers.get_port_range(&quot;2222-2223&quot;), (2222, 2223))
        # Error case: port range start is greater than end
        with self.assertRaisesRegex(
            ValueError,
            r&quot;Start of port range \(2222\) cannot be greater than end of &quot;
            r&quot;port range \(2221\)&quot;,
        ):
            translate_helpers.get_port_range(&quot;2222-2221&quot;)
        # Error case: non-numeric input
        with self.assertRaisesRegex(
            ValueError, &quot;'2222-bar' is non-numeric or an invalid port range&quot;
        ):
            translate_helpers.get_port_range(&quot;2222-bar&quot;)
</PRE>
</div>
  </div>
</body>
</html>
