<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for pkg_resource.py &amp; win_iis_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pkg_resource.py &amp; win_iis_1.py
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pkg_resource.py (3.1662269%)<th>win_iis_1.py (0.5479452%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(7-18)<td><a href="#" name="0">(11-23)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pkg_resource.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>
import copy
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import fnmatch
import logging
import os
import pprint
import salt.utils.data
import salt.utils.versions
import salt.utils.yaml
from salt.exceptions import SaltInvocationError
log = logging.getLogger(__name__)
__SUFFIX_NOT_NEEDED =</b></font> ("x86_64", "noarch")
def _repack_pkgs(pkgs, normalize=True):
    if normalize and "pkg.normalize_name" in __salt__:
        _normalize_name = __salt__["pkg.normalize_name"]
    else:
        _normalize_name = lambda pkgname: pkgname
    return {
        _normalize_name(str(x)): str(y) if y is not None else y
        for x, y in salt.utils.data.repack_dictlist(pkgs).items()
    }
def pack_sources(sources, normalize=True):
    if normalize and "pkg.normalize_name" in __salt__:
        _normalize_name = __salt__["pkg.normalize_name"]
    else:
        _normalize_name = lambda pkgname: pkgname
    if isinstance(sources, str):
        try:
            sources = salt.utils.yaml.safe_load(sources)
        except salt.utils.yaml.parser.ParserError as err:
            log.error(err)
            return {}
    ret = {}
    for source in sources:
        if (not isinstance(source, dict)) or len(source) != 1:
            log.error("Invalid input: %s", pprint.pformat(sources))
            log.error("Input must be a list of 1-element dicts")
            return {}
        else:
            key = next(iter(source))
            ret[_normalize_name(key)] = source[key]
    return ret
def parse_targets(
    name=None, pkgs=None, sources=None, saltenv="base", normalize=True, **kwargs
):
    if "__env__" in kwargs:
        kwargs.pop("__env__")
    if __grains__["os"] == "MacOS" and sources:
        log.warning('Parameter "sources" ignored on MacOS hosts.')
    version = kwargs.get("version")
    if pkgs and sources:
        log.error('Only one of "pkgs" and "sources" can be used.')
        return None, None
    elif "advisory_ids" in kwargs:
        if pkgs:
            log.error('Cannot use "advisory_ids" and "pkgs" at the same time')
            return None, None
        elif kwargs["advisory_ids"]:
            return kwargs["advisory_ids"], "advisory"
        else:
            return [name], "advisory"
    elif pkgs:
        if version is not None:
            log.warning(
                "'version' argument will be ignored for multiple package targets"
            )
        pkgs = _repack_pkgs(pkgs, normalize=normalize)
        if not pkgs:
            return None, None
        else:
            return pkgs, "repository"
    elif sources and __grains__["os"] != "MacOS":
        if version is not None:
            log.warning(
                "'version' argument will be ignored for multiple package targets"
            )
        sources = pack_sources(sources, normalize=normalize)
        if not sources:
            return None, None
        srcinfo = []
        for pkg_name, pkg_src in sources.items():
            if __salt__["config.valid_fileproto"](pkg_src):
                srcinfo.append(__salt__["cp.cache_file"](pkg_src, saltenv))
            else:
                if not os.path.isabs(pkg_src):
                    raise SaltInvocationError(
                        "Path {} for package {} is either not absolute or "
                        "an invalid protocol".format(pkg_src, pkg_name)
                    )
                srcinfo.append(pkg_src)
        return srcinfo, "file"
    elif name:
        if normalize:
            _normalize_name = __salt__.get(
                "pkg.normalize_name", lambda pkgname: pkgname
            )
            packed = {_normalize_name(x): version for x in name.split(",")}
        else:
            packed = {x: version for x in name.split(",")}
        return packed, "repository"
    else:
        log.error("No package sources provided")
        return None, None
def version(*names, **kwargs):
    ret = {}
    versions_as_list = salt.utils.data.is_true(kwargs.pop("versions_as_list", False))
    pkg_glob = False
    if len(names) != 0:
        pkgs = __salt__["pkg.list_pkgs"](versions_as_list=True, **kwargs)
        for name in names:
            if "*" in name:
                pkg_glob = True
                for match in fnmatch.filter(pkgs, name):
                    ret[match] = pkgs.get(match, [])
            else:
                ret[name] = pkgs.get(name, [])
    if not versions_as_list:
        __salt__["pkg_resource.stringify"](ret)
    if len(ret) == 1 and not pkg_glob:
        try:
            return next(iter(ret.values()))
        except StopIteration:
            return ""
    return ret
def add_pkg(pkgs, name, pkgver):
    try:
        pkgs.setdefault(name, []).append(pkgver)
    except AttributeError as exc:
        log.exception(exc)
def sort_pkglist(pkgs):
    try:
        for key in pkgs:
            pkgs[key] = sorted(set(pkgs[key]))
    except AttributeError as exc:
        log.exception(exc)
def stringify(pkgs):
    try:
        for key in pkgs:
            pkgs[key] = ",".join(pkgs[key])
    except AttributeError as exc:
        log.exception(exc)
def version_clean(verstr):
    if verstr and "pkg.version_clean" in __salt__:
        return __salt__["pkg.version_clean"](verstr)
    return verstr
def version_compare(ver1, oper, ver2, ignore_epoch=False):
    return salt.utils.versions.compare(
        ver1,
        oper,
        ver2,
        ignore_epoch=ignore_epoch,
        cmp_func=__salt__.get("version_cmp"),
    )
def check_extra_requirements(pkgname, pkgver):
    if pkgver and "pkg.check_extra_requirements" in __salt__:
        return __salt__["pkg.check_extra_requirements"](pkgname, pkgver)
    return True
def format_pkg_list(packages, versions_as_list, attr):
    ret = copy.deepcopy(packages)
    if attr:
        ret_attr = {}
        requested_attr = {
            "epoch",
            "version",
            "release",
            "arch",
            "install_date",
            "install_date_time_t",
        }
        if attr != "all":
            requested_attr &amp;= set(attr + ["version"] + ["arch"])
        for name in ret:
            if "pkg.parse_arch" in __salt__:
                _parse_arch = __salt__["pkg.parse_arch"](name)
            else:
                _parse_arch = {"name": name, "arch": None}
            _name = _parse_arch["name"]
            _arch = _parse_arch["arch"]
            versions = []
            pkgname = None
            for all_attr in ret[name]:
                filtered_attr = {}
                for key in requested_attr:
                    if key in all_attr:
                        filtered_attr[key] = all_attr[key]
                versions.append(filtered_attr)
                if _name and filtered_attr.get("arch", None) == _arch:
                    pkgname = _name
            ret_attr.setdefault(pkgname or name, []).extend(versions)
        return ret_attr
    for name in ret:
        ret[name] = [
            format_version(d["epoch"], d["version"], d["release"]) for d in ret[name]
        ]
    if not versions_as_list:
        stringify(ret)
    return ret
def format_version(epoch, version, release):
    full_version = "{}:{}".format(epoch, version) if epoch else version
    if release:
        full_version += "-{}".format(release)
    return full_version
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_iis_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import decimal
import logging
import os
import re
import salt.utils.json
import salt.utils.platform
import yaml
from salt.exceptions import CommandExecutionError, SaltInvocationError
log = logging.getLogger(__name__)
_DEFAULT_APP =</b></font> "/"
_VALID_PROTOCOLS = ("ftp", "http", "https")
_VALID_SSL_FLAGS = tuple(range(0, 4))
__virtualname__ = "win_iis"
def __virtual__():
    if not salt.utils.platform.is_windows():
        return False, "Only available on Windows systems"
    powershell_info = __salt__["cmd.shell_info"]("powershell", True)
    if not powershell_info["installed"]:
        return False, "PowerShell not available"
    if "WebAdministration" not in powershell_info["modules"]:
        return False, "IIS is not installed"
    return __virtualname__
def _get_binding_info(host_header="", ip_address="*", port=80):
    return ":".join([ip_address, str(port), host_header.replace(" ", "")])
def _list_certs(certificate_store="My"):
    ret = dict()
    blacklist_keys = ["DnsNameList", "Thumbprint"]
    ps_cmd = [
        "Get-ChildItem",
        "-Path",
        r"'Cert:\LocalMachine\{}'".format(certificate_store),
        "|",
        "Select-Object DnsNameList, SerialNumber, Subject, Thumbprint, Version",
    ]
    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)
    try:
        items = salt.utils.json.loads(cmd_ret["stdout"], strict=False)
    except ValueError:
        raise CommandExecutionError("Unable to parse return data as Json.")
    for item in items:
        cert_info = dict()
        for key in item:
            if key not in blacklist_keys:
                cert_info[key.lower()] = item[key]
        cert_info["dnsnames"] = []
        if item["DnsNameList"]:
            cert_info["dnsnames"] = [name["Unicode"] for name in item["DnsNameList"]]
        ret[item["Thumbprint"]] = cert_info
    return ret
def _iisVersion():
    pscmd = []
    pscmd.append(r"Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\InetStp\\")
    pscmd.append(" | Select-Object MajorVersion, MinorVersion")
    cmd_ret = _srvmgr(pscmd, return_json=True)
    try:
        items = salt.utils.json.loads(cmd_ret["stdout"], strict=False)
    except ValueError:
        log.error("Unable to parse return data as Json.")
        return -1
    return decimal.Decimal(
        "{}.{}".format(items[0]["MajorVersion"], items[0]["MinorVersion"])
    )
def _srvmgr(cmd, return_json=False):
    if isinstance(cmd, list):
        cmd = " ".join(cmd)
    if return_json:
        cmd = "ConvertTo-Json -Compress -Depth 4 -InputObject @({})".format(cmd)
    cmd = "Import-Module WebAdministration; {}".format(cmd)
    ret = __salt__["cmd.run_all"](cmd, shell="powershell", python_shell=True)
    if ret["retcode"] != 0:
        log.error("Unable to execute command: %s\nError: %s", cmd, ret["stderr"])
    return ret
def _collection_match_to_index(pspath, colfilter, name, match):
    collection = get_webconfiguration_settings(
        pspath, [{"name": name, "filter": colfilter}]
    )[0]["value"]
    for idx, collect_dict in enumerate(collection):
        if all(item in collect_dict.items() for item in match.items()):
            return idx
    return -1
def _prepare_settings(pspath, settings):
    prepared_settings = []
    for setting in settings:
        if setting.get("name", None) is None:
            log.warning("win_iis: Setting has no name: %s", setting)
            continue
        if setting.get("filter", None) is None:
            log.warning("win_iis: Setting has no filter: %s", setting)
            continue
        match = re.search(r"Collection\[(\{.*\})\]", setting["name"])
        if match:
            name = setting["name"][: match.start(1) - 1]
            match_dict = yaml.load(match.group(1))
            index = _collection_match_to_index(
                pspath, setting["filter"], name, match_dict
            )
            if index == -1:
                log.warning("win_iis: No match found for setting: %s", setting)
            else:
                setting["name"] = setting["name"].replace(match.group(1), str(index))
                prepared_settings.append(setting)
        else:
            prepared_settings.append(setting)
    return prepared_settings
def list_sites():
    ret = dict()
    ps_cmd = [
        "Get-ChildItem",
        "-Path",
        r"'IIS:\Sites'",
        "|",
        "Select-Object applicationPool, Bindings, ID, Name, PhysicalPath, State",
    ]
    keep_keys = ("certificateHash", "certificateStoreName", "protocol", "sslFlags")
    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)
    try:
        items = salt.utils.json.loads(cmd_ret["stdout"], strict=False)
    except ValueError:
        raise CommandExecutionError("Unable to parse return data as Json.")
    for item in items:
        bindings = dict()
        for binding in item["bindings"]["Collection"]:
            if binding["protocol"] not in ["http", "https"]:
                continue
            filtered_binding = dict()
            for key in binding:
                if key in keep_keys:
                    filtered_binding.update({key.lower(): binding[key]})
            binding_info = binding["bindingInformation"].split(":", 2)
            ipaddress, port, hostheader = (element.strip() for element in binding_info)
            filtered_binding.update(
                {"hostheader": hostheader, "ipaddress": ipaddress, "port": port}
            )
            bindings[binding["bindingInformation"]] = filtered_binding
        ret[item["name"]] = {
            "apppool": item["applicationPool"],
            "bindings": bindings,
            "id": item["id"],
            "state": item["state"],
            "sourcepath": item["physicalPath"],
        }
    if not ret:
        log.warning("No sites found in output: %s", cmd_ret["stdout"])
    return ret
def create_site(
    name, sourcepath, apppool="", hostheader="", ipaddress="*", port=80, protocol="http"
):
    protocol = str(protocol).lower()
    site_path = r"IIS:\Sites\{}".format(name)
    binding_info = _get_binding_info(hostheader, ipaddress, port)
    current_sites = list_sites()
    if name in current_sites:
        log.debug("Site '%s' already present.", name)
        return True
    if protocol not in _VALID_PROTOCOLS:
        message = "Invalid protocol '{}' specified. Valid formats: {}".format(
            protocol, _VALID_PROTOCOLS
        )
        raise SaltInvocationError(message)
    ps_cmd = [
        "New-Item",
        "-Path",
        r"'{}'".format(site_path),
        "-PhysicalPath",
        r"'{}'".format(sourcepath),
        "-Bindings",
        "@{{ protocol='{0}'; bindingInformation='{1}' }};".format(
            protocol, binding_info
        ),
    ]
    if apppool:
        if apppool in list_apppools():
            log.debug("Utilizing pre-existing application pool: %s", apppool)
        else:
            log.debug("Application pool will be created: %s", apppool)
            create_apppool(apppool)
        ps_cmd.extend(
            [
                "Set-ItemProperty",
                "-Path",
                "'{}'".format(site_path),
                "-Name",
                "ApplicationPool",
                "-Value",
                "'{}'".format(apppool),
            ]
        )
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to create site: {}\nError: {}".format(name, cmd_ret["stderr"])
        raise CommandExecutionError(msg)
    log.debug("Site created successfully: %s", name)
    return True
def modify_site(name, sourcepath=None, apppool=None):
    site_path = r"IIS:\Sites\{}".format(name)
    current_sites = list_sites()
    if name not in current_sites:
        log.debug("Site '%s' not defined.", name)
        return False
    ps_cmd = list()
    if sourcepath:
        ps_cmd.extend(
            [
                "Set-ItemProperty",
                "-Path",
                r"'{}'".format(site_path),
                "-Name",
                "PhysicalPath",
                "-Value",
                r"'{}'".format(sourcepath),
            ]
        )
    if apppool:
        if apppool in list_apppools():
            log.debug("Utilizing pre-existing application pool: %s", apppool)
        else:
            log.debug("Application pool will be created: %s", apppool)
            create_apppool(apppool)
        if ps_cmd:
            ps_cmd.append(";")
        ps_cmd.extend(
            [
                "Set-ItemProperty",
                "-Path",
                r"'{}'".format(site_path),
                "-Name",
                "ApplicationPool",
                "-Value",
                r"'{}'".format(apppool),
            ]
        )
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to modify site: {}\nError: {}".format(name, cmd_ret["stderr"])
        raise CommandExecutionError(msg)
    log.debug("Site modified successfully: %s", name)
    return True
def remove_site(name):
    current_sites = list_sites()
    if name not in current_sites:
        log.debug("Site already absent: %s", name)
        return True
    ps_cmd = ["Remove-WebSite", "-Name", r"'{}'".format(name)]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to remove site: {}\nError: {}".format(name, cmd_ret["stderr"])
        raise CommandExecutionError(msg)
    log.debug("Site removed successfully: %s", name)
    return True
def stop_site(name):
    ps_cmd = ["Stop-WebSite", r"'{}'".format(name)]
    cmd_ret = _srvmgr(ps_cmd)
    return cmd_ret["retcode"] == 0
def start_site(name):
    ps_cmd = ["Start-WebSite", r"'{}'".format(name)]
    cmd_ret = _srvmgr(ps_cmd)
    return cmd_ret["retcode"] == 0
def restart_site(name):
    return stop_site(name) and start_site(name)
def list_bindings(site):
    ret = dict()
    sites = list_sites()
    if site not in sites:
        log.warning("Site not found: %s", site)
        return ret
    ret = sites[site]["bindings"]
    if not ret:
        log.warning("No bindings found for site: %s", site)
    return ret
def create_binding(
    site, hostheader="", ipaddress="*", port=80, protocol="http", sslflags=None
):
    protocol = str(protocol).lower()
    name = _get_binding_info(hostheader, ipaddress, port)
    if protocol not in _VALID_PROTOCOLS:
        message = "Invalid protocol '{}' specified. Valid formats: {}".format(
            protocol, _VALID_PROTOCOLS
        )
        raise SaltInvocationError(message)
    if sslflags:
        sslflags = int(sslflags)
        if sslflags not in _VALID_SSL_FLAGS:
            raise SaltInvocationError(
                "Invalid sslflags '{}' specified. Valid sslflags range: {}..{}".format(
                    sslflags, _VALID_SSL_FLAGS[0], _VALID_SSL_FLAGS[-1]
                )
            )
    current_bindings = list_bindings(site)
    if name in current_bindings:
        log.debug("Binding already present: %s", name)
        return True
    if sslflags:
        ps_cmd = [
            "New-WebBinding",
            "-Name",
            "'{}'".format(site),
            "-HostHeader",
            "'{}'".format(hostheader),
            "-IpAddress",
            "'{}'".format(ipaddress),
            "-Port",
            "'{}'".format(port),
            "-Protocol",
            "'{}'".format(protocol),
            "-SslFlags",
            "{}".format(sslflags),
        ]
    else:
        ps_cmd = [
            "New-WebBinding",
            "-Name",
            "'{}'".format(site),
            "-HostHeader",
            "'{}'".format(hostheader),
            "-IpAddress",
            "'{}'".format(ipaddress),
            "-Port",
            "'{}'".format(port),
            "-Protocol",
            "'{}'".format(protocol),
        ]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to create binding: {}\nError: {}".format(site, cmd_ret["stderr"])
        raise CommandExecutionError(msg)
    if name in list_bindings(site):
        log.debug("Binding created successfully: %s", site)
        return True
    log.error("Unable to create binding: %s", site)
    return False
def modify_binding(
    site, binding, hostheader=None, ipaddress=None, port=None, sslflags=None
):
    if sslflags is not None and sslflags not in _VALID_SSL_FLAGS:
        raise SaltInvocationError(
            "Invalid sslflags '{}' specified. Valid sslflags range: {}..{}".format(
                sslflags, _VALID_SSL_FLAGS[0], _VALID_SSL_FLAGS[-1]
            )
        )
    current_sites = list_sites()
    if site not in current_sites:
        log.debug("Site '%s' not defined.", site)
        return False
    current_bindings = list_bindings(site)
    if binding not in current_bindings:
        log.debug("Binding '%s' not defined.", binding)
        return False
    i, p, h = binding.split(":")
    new_binding = ":".join(
        [
            ipaddress if ipaddress is not None else i,
            str(port) if port is not None else str(p),
            hostheader if hostheader is not None else h,
        ]
    )
    if new_binding != binding:
        ps_cmd = [
            "Set-WebBinding",
            "-Name",
            "'{}'".format(site),
            "-BindingInformation",
            "'{}'".format(binding),
            "-PropertyName",
            "BindingInformation",
            "-Value",
            "'{}'".format(new_binding),
        ]
        cmd_ret = _srvmgr(ps_cmd)
        if cmd_ret["retcode"] != 0:
            msg = "Unable to modify binding: {}\nError: {}".format(
                binding, cmd_ret["stderr"]
            )
            raise CommandExecutionError(msg)
    if (
        sslflags is not None
        and sslflags != current_sites[site]["bindings"][binding]["sslflags"]
    ):
        ps_cmd = [
            "Set-WebBinding",
            "-Name",
            "'{}'".format(site),
            "-BindingInformation",
            "'{}'".format(new_binding),
            "-PropertyName",
            "sslflags",
            "-Value",
            "'{}'".format(sslflags),
        ]
        cmd_ret = _srvmgr(ps_cmd)
        if cmd_ret["retcode"] != 0:
            msg = "Unable to modify binding SSL Flags: {}\nError: {}".format(
                sslflags, cmd_ret["stderr"]
            )
            raise CommandExecutionError(msg)
    log.debug("Binding modified successfully: %s", binding)
    return True
def remove_binding(site, hostheader="", ipaddress="*", port=80):
    name = _get_binding_info(hostheader, ipaddress, port)
    current_bindings = list_bindings(site)
    if name not in current_bindings:
        log.debug("Binding already absent: %s", name)
        return True
    ps_cmd = [
        "Remove-WebBinding",
        "-HostHeader",
        "'{}'".format(hostheader),
        "-IpAddress",
        "'{}'".format(ipaddress),
        "-Port",
        "'{}'".format(port),
    ]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to remove binding: {}\nError: {}".format(site, cmd_ret["stderr"])
        raise CommandExecutionError(msg)
    if name not in list_bindings(site):
        log.debug("Binding removed successfully: %s", site)
        return True
    log.error("Unable to remove binding: %s", site)
    return False
def list_cert_bindings(site):
    ret = dict()
    sites = list_sites()
    if site not in sites:
        log.warning("Site not found: %s", site)
        return ret
    for binding in sites[site]["bindings"]:
        if sites[site]["bindings"][binding]["certificatehash"]:
            ret[binding] = sites[site]["bindings"][binding]
    if not ret:
        log.warning("No certificate bindings found for site: %s", site)
    return ret
def create_cert_binding(name, site, hostheader="", ipaddress="*", port=443, sslflags=0):
    name = str(name).upper()
    binding_info = _get_binding_info(hostheader, ipaddress, port)
    if _iisVersion() &lt; 8:
        binding_info = binding_info.rpartition(":")[0] + ":"
    binding_path = r"IIS:\SslBindings\{}".format(binding_info.replace(":", "!"))
    if sslflags not in _VALID_SSL_FLAGS:
        raise SaltInvocationError(
            "Invalid sslflags '{}' specified. Valid sslflags range: {}..{}".format(
                sslflags, _VALID_SSL_FLAGS[0], _VALID_SSL_FLAGS[-1]
            )
        )
    current_bindings = list_bindings(site)
    if binding_info not in current_bindings:
        log.error("Binding not present: %s", binding_info)
        return False
    current_name = None
    for current_binding in current_bindings:
        if binding_info == current_binding:
            current_name = current_bindings[current_binding]["certificatehash"]
    log.debug("Current certificate thumbprint: %s", current_name)
    log.debug("New certificate thumbprint: %s", name)
    if name == current_name:
        log.debug("Certificate already present for binding: %s", name)
        return True
    certs = _list_certs()
    if name not in certs:
        log.error("Certificate not present: %s", name)
        return False
    if _iisVersion() &lt; 8:
        iis7path = binding_path.replace(r"\*!", "\\0.0.0.0!")
        if iis7path.endswith("!"):
            iis7path = iis7path[:-1]
        ps_cmd = [
            "New-Item",
            "-Path",
            "'{}'".format(iis7path),
            "-Thumbprint",
            "'{}'".format(name),
        ]
    else:
        ps_cmd = [
            "New-Item",
            "-Path",
            "'{}'".format(binding_path),
            "-Thumbprint",
            "'{}'".format(name),
            "-SSLFlags",
            "{}".format(sslflags),
        ]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to create certificate binding: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    new_cert_bindings = list_cert_bindings(site)
    if binding_info not in new_cert_bindings:
        log.error("Binding not present: %s", binding_info)
        return False
    if name == new_cert_bindings[binding_info]["certificatehash"]:
        log.debug("Certificate binding created successfully: %s", name)
        return True
    log.error("Unable to create certificate binding: %s", name)
    return False
def remove_cert_binding(name, site, hostheader="", ipaddress="*", port=443):
    name = str(name).upper()
    binding_info = _get_binding_info(hostheader, ipaddress, port)
    ps_cmd = [
        "$Site = Get-ChildItem",
        "-Path",
        r"'IIS:\Sites'",
        "|",
        "Where-Object",
        r" {{ $_.Name -Eq '{0}' }};".format(site),
        "$Binding = $Site.Bindings.Collection",
        r"| Where-Object { $_.bindingInformation",
        r"-Eq '{0}' }};".format(binding_info),
        "$Binding.RemoveSslCertificate()",
    ]
    current_cert_bindings = list_cert_bindings(site)
    if binding_info not in current_cert_bindings:
        log.warning("Binding not found: %s", binding_info)
        return True
    if name != current_cert_bindings[binding_info]["certificatehash"]:
        log.debug("Certificate binding already absent: %s", name)
        return True
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to remove certificate binding: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    new_cert_bindings = list_cert_bindings(site)
    if binding_info not in new_cert_bindings:
        log.warning("Binding not found: %s", binding_info)
        return True
    if name != new_cert_bindings[binding_info]["certificatehash"]:
        log.debug("Certificate binding removed successfully: %s", name)
        return True
    log.error("Unable to remove certificate binding: %s", name)
    return False
def list_apppools():
    ret = dict()
    ps_cmd = []
    ps_cmd.append(r"Get-ChildItem -Path 'IIS:\AppPools' | Select-Object Name, State")
    ps_cmd.append(r", @{ Name = 'Applications'; Expression = { $AppPool = $_.Name;")
    ps_cmd.append("$AppPath = 'machine/webroot/apphost';")
    ps_cmd.append("$FilterBase = '/system.applicationHost/sites/site/application';")
    ps_cmd.append("$FilterBase += \"[@applicationPool = '$($AppPool)' and @path\";")
    ps_cmd.append("$FilterRoot = \"$($FilterBase) = '/']/parent::*\";")
    ps_cmd.append("$FilterNonRoot = \"$($FilterBase) != '/']\";")
    ps_cmd.append(
        "Get-WebConfigurationProperty -Filter $FilterRoot -PsPath $AppPath -Name Name"
    )
    ps_cmd.append(r"| ForEach-Object { $_.Value };")
    ps_cmd.append(
        "Get-WebConfigurationProperty -Filter $FilterNonRoot -PsPath $AppPath -Name"
        " Path"
    )
    ps_cmd.append(r"| ForEach-Object { $_.Value } | Where-Object { $_ -ne '/' }")
    ps_cmd.append("} }")
    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)
    try:
        items = salt.utils.json.loads(cmd_ret["stdout"], strict=False)
    except ValueError:
        raise CommandExecutionError("Unable to parse return data as Json.")
    for item in items:
        applications = list()
        if isinstance(item["Applications"], dict):
            if "value" in item["Applications"]:
                applications += item["Applications"]["value"]
        else:
            applications.append(item["Applications"])
        ret[item["name"]] = {"state": item["state"], "applications": applications}
    if not ret:
        log.warning("No application pools found in output: %s", cmd_ret["stdout"])
    return ret
def create_apppool(name):
    current_apppools = list_apppools()
    apppool_path = r"IIS:\AppPools\{}".format(name)
    if name in current_apppools:
        log.debug("Application pool '%s' already present.", name)
        return True
    ps_cmd = ["New-Item", "-Path", r"'{}'".format(apppool_path)]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to create application pool: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    log.debug("Application pool created successfully: %s", name)
    return True
def remove_apppool(name):
    current_apppools = list_apppools()
    apppool_path = r"IIS:\AppPools\{}".format(name)
    if name not in current_apppools:
        log.debug("Application pool already absent: %s", name)
        return True
    ps_cmd = ["Remove-Item", "-Path", r"'{}'".format(apppool_path), "-Recurse"]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to remove application pool: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    log.debug("Application pool removed successfully: %s", name)
    return True
def stop_apppool(name):
    ps_cmd = ["Stop-WebAppPool", r"'{}'".format(name)]
    cmd_ret = _srvmgr(ps_cmd)
    return cmd_ret["retcode"] == 0
def start_apppool(name):
    ps_cmd = ["Start-WebAppPool", r"'{}'".format(name)]
    cmd_ret = _srvmgr(ps_cmd)
    return cmd_ret["retcode"] == 0
def restart_apppool(name):
    ps_cmd = ["Restart-WebAppPool", r"'{}'".format(name)]
    cmd_ret = _srvmgr(ps_cmd)
    return cmd_ret["retcode"] == 0
def get_container_setting(name, container, settings):
    ret = dict()
    ps_cmd = list()
    ps_cmd_validate = list()
    container_path = r"IIS:\{}\{}".format(container, name)
    if not settings:
        log.warning("No settings provided")
        return ret
    ps_cmd.append(r"$Settings = @{};")
    for setting in settings:
        ps_cmd_validate.extend(
            [
                "Get-ItemProperty",
                "-Path",
                "'{}'".format(container_path),
                "-Name",
                "'{}'".format(setting),
                "-ErrorAction",
                "Stop",
                "|",
                "Out-Null;",
            ]
        )
        ps_cmd.append("$Property = Get-ItemProperty -Path '{}'".format(container_path))
        ps_cmd.append("-Name '{}' -ErrorAction Stop;".format(setting))
        ps_cmd.append(r"if (([String]::IsNullOrEmpty($Property) -eq $False) -and")
        ps_cmd.append(r"($Property.GetType()).Name -eq 'ConfigurationAttribute') {")
        ps_cmd.append(r"$Property = $Property | Select-Object")
        ps_cmd.append(r"-ExpandProperty Value };")
        ps_cmd.append("$Settings['{}'] = [String] $Property;".format(setting))
        ps_cmd.append(r"$Property = $Null;")
    cmd_ret = _srvmgr(cmd=ps_cmd_validate, return_json=True)
    if cmd_ret["retcode"] != 0:
        message = (
            "One or more invalid property names were specified for the provided"
            " container."
        )
        raise SaltInvocationError(message)
    ps_cmd.append("$Settings")
    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)
    try:
        items = salt.utils.json.loads(cmd_ret["stdout"], strict=False)
        if isinstance(items, list):
            ret.update(items[0])
        else:
            ret.update(items)
    except ValueError:
        raise CommandExecutionError("Unable to parse return data as Json.")
    return ret
def set_container_setting(name, container, settings):
    identityType_map2string = {
        "0": "LocalSystem",
        "1": "LocalService",
        "2": "NetworkService",
        "3": "SpecificUser",
        "4": "ApplicationPoolIdentity",
    }
    identityType_map2numeric = {
        "LocalSystem": "0",
        "LocalService": "1",
        "NetworkService": "2",
        "SpecificUser": "3",
        "ApplicationPoolIdentity": "4",
    }
    ps_cmd = list()
    container_path = r"IIS:\{}\{}".format(container, name)
    if not settings:
        log.warning("No settings provided")
        return False
    for setting in settings:
        settings[setting] = str(settings[setting])
    current_settings = get_container_setting(
        name=name, container=container, settings=settings.keys()
    )
    if settings == current_settings:
        log.debug("Settings already contain the provided values.")
        return True
    for setting in settings:
        try:
            complex(settings[setting])
            value = settings[setting]
        except ValueError:
            value = "'{}'".format(settings[setting])
        if (
            setting == "processModel.identityType"
            and settings[setting] in identityType_map2numeric.keys()
        ):
            value = identityType_map2numeric[settings[setting]]
        ps_cmd.extend(
            [
                "Set-ItemProperty",
                "-Path",
                "'{}'".format(container_path),
                "-Name",
                "'{}'".format(setting),
                "-Value",
                "{};".format(value),
            ]
        )
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to set settings for {}: {}".format(container, name)
        raise CommandExecutionError(msg)
    new_settings = get_container_setting(
        name=name, container=container, settings=settings.keys()
    )
    failed_settings = dict()
    for setting in settings:
        if (
            setting == "processModel.identityType"
            and settings[setting] in identityType_map2string.keys()
        ):
            settings[setting] = identityType_map2string[settings[setting]]
        if str(settings[setting]) != str(new_settings[setting]):
            failed_settings[setting] = settings[setting]
    if failed_settings:
        log.error("Failed to change settings: %s", failed_settings)
        return False
    log.debug("Settings configured successfully: %s", settings.keys())
    return True
def list_apps(site):
    ret = dict()
    ps_cmd = list()
    ps_cmd.append("Get-WebApplication -Site '{}'".format(site))
    ps_cmd.append(
        r"| Select-Object applicationPool, path, PhysicalPath, preloadEnabled,"
    )
    ps_cmd.append(r"@{ Name='name'; Expression={ $_.path.Split('/', 2)[-1] } },")
    ps_cmd.append(
        r"@{ Name='protocols'; Expression={ @( $_.enabledProtocols.Split(',')"
    )
    ps_cmd.append(r"| Foreach-Object { $_.Trim() } ) } }")
    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)
    try:
        items = salt.utils.json.loads(cmd_ret["stdout"], strict=False)
    except ValueError:
        raise CommandExecutionError("Unable to parse return data as Json.")
    for item in items:
        protocols = list()
        if isinstance(item["protocols"], dict):
            if "value" in item["protocols"]:
                protocols += item["protocols"]["value"]
        else:
            protocols.append(item["protocols"])
        ret[item["name"]] = {
            "apppool": item["applicationPool"],
            "path": item["path"],
            "preload": item["preloadEnabled"],
            "protocols": protocols,
            "sourcepath": item["PhysicalPath"],
        }
    if not ret:
        log.warning("No apps found in output: %s", cmd_ret)
    return ret
def create_app(name, site, sourcepath, apppool=None):
    current_apps = list_apps(site)
    if name in current_apps:
        log.debug("Application already present: %s", name)
        return True
    if not os.path.isdir(sourcepath):
        log.error("Path is not present: %s", sourcepath)
        return False
    ps_cmd = [
        "New-WebApplication",
        "-Name",
        "'{}'".format(name),
        "-Site",
        "'{}'".format(site),
        "-PhysicalPath",
        "'{}'".format(sourcepath),
    ]
    if apppool:
        ps_cmd.extend(["-ApplicationPool", "'{}'".format(apppool)])
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to create application: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    new_apps = list_apps(site)
    if name in new_apps:
        log.debug("Application created successfully: %s", name)
        return True
    log.error("Unable to create application: %s", name)
    return False
def remove_app(name, site):
    current_apps = list_apps(site)
    if name not in current_apps:
        log.debug("Application already absent: %s", name)
        return True
    ps_cmd = [
        "Remove-WebApplication",
        "-Name",
        "'{}'".format(name),
        "-Site",
        "'{}'".format(site),
    ]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to remove application: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    new_apps = list_apps(site)
    if name not in new_apps:
        log.debug("Application removed successfully: %s", name)
        return True
    log.error("Unable to remove application: %s", name)
    return False
def list_vdirs(site, app=_DEFAULT_APP):
    ret = dict()
    ps_cmd = [
        "Get-WebVirtualDirectory",
        "-Site",
        r"'{}'".format(site),
        "-Application",
        r"'{}'".format(app),
        "|",
        "Select-Object PhysicalPath, @{ Name = 'name';",
        r"Expression = { $_.path.Trim('/') } }",
    ]
    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)
    try:
        items = salt.utils.json.loads(cmd_ret["stdout"], strict=False)
    except ValueError:
        raise CommandExecutionError("Unable to parse return data as Json.")
    for item in items:
        ret[item["name"]] = {"sourcepath": item["physicalPath"]}
    if not ret:
        log.warning("No vdirs found in output: %s", cmd_ret)
    return ret
def create_vdir(name, site, sourcepath, app=_DEFAULT_APP):
    current_vdirs = list_vdirs(site, app)
    if name in current_vdirs:
        log.debug("Virtual directory already present: %s", name)
        return True
    if not os.path.isdir(sourcepath):
        log.error("Path is not present: %s", sourcepath)
        return False
    ps_cmd = [
        "New-WebVirtualDirectory",
        "-Name",
        r"'{}'".format(name),
        "-Site",
        r"'{}'".format(site),
        "-PhysicalPath",
        r"'{}'".format(sourcepath),
    ]
    if app != _DEFAULT_APP:
        ps_cmd.extend(["-Application", r"'{}'".format(app)])
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to create virtual directory: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    new_vdirs = list_vdirs(site, app)
    if name in new_vdirs:
        log.debug("Virtual directory created successfully: %s", name)
        return True
    log.error("Unable to create virtual directory: %s", name)
    return False
def remove_vdir(name, site, app=_DEFAULT_APP):
    current_vdirs = list_vdirs(site, app)
    app_path = os.path.join(*app.rstrip("/").split("/"))
    if app_path:
        app_path = "{}\\".format(app_path)
    vdir_path = r"IIS:\Sites\{}\{}{}".format(site, app_path, name)
    if name not in current_vdirs:
        log.debug("Virtual directory already absent: %s", name)
        return True
    ps_cmd = ["Remove-Item", "-Path", r"'{}'".format(vdir_path), "-Recurse"]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to remove virtual directory: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    new_vdirs = list_vdirs(site, app)
    if name not in new_vdirs:
        log.debug("Virtual directory removed successfully: %s", name)
        return True
    log.error("Unable to remove virtual directory: %s", name)
    return False
def list_backups():
    r"""
    List the IIS Configuration Backups on the System.
    .. versionadded:: 2017.7.0
    .. note::
        Backups are made when a configuration is edited. Manual backups are
        stored in the ``$env:Windir\System32\inetsrv\backup`` folder.
    Returns:
        dict: A dictionary of IIS Configurations backed up on the system.
    CLI Example:
    .. code-block:: bash
        salt '*' win_iis.list_backups
    if name in list_backups():
        raise CommandExecutionError("Backup already present: {}".format(name))
    ps_cmd = ["Backup-WebConfiguration", "-Name", "'{}'".format(name)]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to backup web configuration: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    return name in list_backups()
def remove_backup(name):
    if name not in list_backups():
        log.debug("Backup already removed: %s", name)
        return True
    ps_cmd = ["Remove-WebConfigurationBackup", "-Name", "'{}'".format(name)]
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to remove web configuration: {}\nError: {}".format(
            name, cmd_ret["stderr"]
        )
        raise CommandExecutionError(msg)
    return name not in list_backups()
def list_worker_processes(apppool):
    ps_cmd = ["Get-ChildItem", r"'IIS:\AppPools\{}\WorkerProcesses'".format(apppool)]
    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)
    try:
        items = salt.utils.json.loads(cmd_ret["stdout"], strict=False)
    except ValueError:
        raise CommandExecutionError("Unable to parse return data as Json.")
    ret = dict()
    for item in items:
        ret[item["processId"]] = item["appPoolName"]
    if not ret:
        log.warning("No backups found in output: %s", cmd_ret)
    return ret
def get_webapp_settings(name, site, settings):
    r"""
    .. versionadded:: 2017.7.0
    Get the value of the setting for the IIS web application.
    .. note::
        Params are case sensitive
    :param str name: The name of the IIS web application.
    :param str site: The site name contains the web application.
        Example: Default Web Site
    :param str settings: A dictionary of the setting names and their values.
        Available settings: physicalPath, applicationPool, userName, password
    Returns:
        dict: A dictionary of the provided settings and their values.
    CLI Example:
    .. code-block:: bash
        salt '*' win_iis.get_webapp_settings name='app0' site='Default Web Site'
            settings="['physicalPath','applicationPool']"
    pscmd = list()
    current_apps = list_apps(site)
    current_sites = list_sites()
    availableSettings = ("physicalPath", "applicationPool", "userName", "password")
    if name not in current_apps:
        msg = "Application" + name + "doesn't exist"
        raise SaltInvocationError(msg)
    if site not in current_sites:
        msg = "Site" + site + "doesn't exist"
        raise SaltInvocationError(msg)
    if not settings:
        msg = "No settings provided"
        raise SaltInvocationError(msg)
    for setting in settings.keys():
        if setting in availableSettings:
            settings[setting] = str(settings[setting])
        else:
            availSetStr = ", ".join(availableSettings)
            log.error("Unexpected setting: %s ", setting)
            log.error("Available settings: %s", availSetStr)
            msg = "Unexpected setting:" + setting + " Available settings:" + availSetStr
            raise SaltInvocationError(msg)
    current_settings = get_webapp_settings(
        name=name, site=site, settings=settings.keys()
    )
    if settings == current_settings:
        log.warning("Settings already contain the provided values.")
        return True
    for setting in settings:
        try:
            complex(settings[setting])
            value = settings[setting]
        except ValueError:
            value = "'{}'".format(settings[setting])
        if setting == "userName" or setting == "password":
            pscmd.append(
                " Set-WebConfigurationProperty -Filter"
                " \"system.applicationHost/sites/site[@name='{}']/application[@path='/{}']/virtualDirectory[@path='/']\"".format(
                    site, name
                )
            )
            pscmd.append(' -Name "{}" -Value {};'.format(setting, value))
        if setting == "physicalPath" or setting == "applicationPool":
            pscmd.append(
                r' Set-ItemProperty "IIS:\Sites\{}\{}" -Name {} -Value {};'.format(
                    site, name, setting, value
                )
            )
            if setting == "physicalPath":
                if not os.path.isdir(settings[setting]):
                    msg = "Path is not present: " + settings[setting]
                    raise SaltInvocationError(msg)
    cmd_ret = _srvmgr(pscmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to set settings for web application {}".format(name)
        raise SaltInvocationError(msg)
    new_settings = get_webapp_settings(name=name, site=site, settings=settings.keys())
    failed_settings = dict()
    for setting in settings:
        if str(settings[setting]) != str(new_settings[setting]):
            failed_settings[setting] = settings[setting]
    if failed_settings:
        log.error("Failed to change settings: %s", failed_settings)
        return False
    log.debug("Settings configured successfully: %s", list(settings))
    return True
def get_webconfiguration_settings(name, settings):
    r"""
    Get the webconfiguration settings for the IIS PSPath.
    Args:
        name (str): The PSPath of the IIS webconfiguration settings.
        settings (list): A list of dictionaries containing setting name and filter.
    Returns:
        dict: A list of dictionaries containing setting name, filter and value.
    CLI Example:
    .. code-block:: bash
        salt '*' win_iis.get_webconfiguration_settings name='IIS:\' settings="[{'name': 'enabled', 'filter': 'system.webServer/security/authentication/anonymousAuthentication'}]"
    ps_cmd = []
    settings = _prepare_settings(name, settings)
    if not settings:
        log.warning("No settings provided")
        return False
    for idx, setting in enumerate(settings):
        if setting["name"].split(".")[-1] != "Collection":
            settings[idx]["value"] = str(setting["value"])
    current_settings = get_webconfiguration_settings(name=name, settings=settings)
    if settings == current_settings:
        log.debug("Settings already contain the provided values.")
        return True
    for setting in settings:
        if setting["name"].split(".")[-1] != "Collection":
            try:
                complex(setting["value"])
                value = setting["value"]
            except ValueError:
                value = "'{}'".format(setting["value"])
        else:
            configelement_list = []
            for value_item in setting["value"]:
                configelement_construct = []
                for key, value in value_item.items():
                    configelement_construct.append("{}='{}'".format(key, value))
                configelement_list.append(
                    "@{" + ";".join(configelement_construct) + "}"
                )
            value = ",".join(configelement_list)
        ps_cmd.extend(
            [
                "Set-WebConfigurationProperty",
                "-PSPath",
                "'{}'".format(name),
                "-Filter",
                "'{}'".format(setting["filter"]),
                "-Name",
                "'{}'".format(setting["name"]),
                "-Value",
                "{};".format(value),
            ]
        )
    cmd_ret = _srvmgr(ps_cmd)
    if cmd_ret["retcode"] != 0:
        msg = "Unable to set settings for {}".format(name)
        raise CommandExecutionError(msg)
    new_settings = get_webconfiguration_settings(name=name, settings=settings)
    failed_settings = []
    for idx, setting in enumerate(settings):
        is_collection = setting["name"].split(".")[-1] == "Collection"
        if (
            not is_collection
            and str(setting["value"]) != str(new_settings[idx]["value"])
        ) or (
            is_collection
            and list(map(dict, setting["value"]))
            != list(map(dict, new_settings[idx]["value"]))
        ):
            failed_settings.append(setting)
    if failed_settings:
        log.error("Failed to change settings: %s", failed_settings)
        return False
    log.debug("Settings configured successfully: %s", settings)
    return True
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
