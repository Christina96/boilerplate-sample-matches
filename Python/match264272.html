<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for pkg_resource.py & win_iis_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for pkg_resource.py & win_iis_1.py
      </h3>
      <h1 align="center">
        0.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>pkg_resource.py (3.1662269%)<TH>win_iis_1.py (0.5479452%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match264272-0.html#0',2,'match264272-1.html#0',3)" NAME="0">(7-18)<TD><A HREF="javascript:ZweiFrames('match264272-0.html#0',2,'match264272-1.html#0',3)" NAME="0">(11-23)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pkg_resource.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Resources needed by pkg providers
&quot;&quot;&quot;
<A NAME="0"></A>

import copy
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match264272-1.html#0',3,'match264272-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import fnmatch
import logging
import os
import pprint

import salt.utils.data
import salt.utils.versions
import salt.utils.yaml
from salt.exceptions import SaltInvocationError

log = logging.getLogger(__name__)
__SUFFIX_NOT_NEEDED =</B></FONT> (&quot;x86_64&quot;, &quot;noarch&quot;)


def _repack_pkgs(pkgs, normalize=True):
    &quot;&quot;&quot;
    Repack packages specified using &quot;pkgs&quot; argument to pkg states into a single
    dictionary
    &quot;&quot;&quot;
    if normalize and &quot;pkg.normalize_name&quot; in __salt__:
        _normalize_name = __salt__[&quot;pkg.normalize_name&quot;]
    else:
        _normalize_name = lambda pkgname: pkgname
    return {
        _normalize_name(str(x)): str(y) if y is not None else y
        for x, y in salt.utils.data.repack_dictlist(pkgs).items()
    }


def pack_sources(sources, normalize=True):
    &quot;&quot;&quot;
    Accepts list of dicts (or a string representing a list of dicts) and packs
    the key/value pairs into a single dict.

    ``'[{&quot;foo&quot;: &quot;salt://foo.rpm&quot;}, {&quot;bar&quot;: &quot;salt://bar.rpm&quot;}]'`` would become
    ``{&quot;foo&quot;: &quot;salt://foo.rpm&quot;, &quot;bar&quot;: &quot;salt://bar.rpm&quot;}``

    normalize : True
        Normalize the package name by removing the architecture, if the
        architecture of the package is different from the architecture of the
        operating system. The ability to disable this behavior is useful for
        poorly-created packages which include the architecture as an actual
        part of the name, such as kernel modules which match a specific kernel
        version.

        .. versionadded:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' pkg_resource.pack_sources '[{&quot;foo&quot;: &quot;salt://foo.rpm&quot;}, {&quot;bar&quot;: &quot;salt://bar.rpm&quot;}]'
    &quot;&quot;&quot;
    if normalize and &quot;pkg.normalize_name&quot; in __salt__:
        _normalize_name = __salt__[&quot;pkg.normalize_name&quot;]
    else:
        _normalize_name = lambda pkgname: pkgname

    if isinstance(sources, str):
        try:
            sources = salt.utils.yaml.safe_load(sources)
        except salt.utils.yaml.parser.ParserError as err:
            log.error(err)
            return {}
    ret = {}
    for source in sources:
        if (not isinstance(source, dict)) or len(source) != 1:
            log.error(&quot;Invalid input: %s&quot;, pprint.pformat(sources))
            log.error(&quot;Input must be a list of 1-element dicts&quot;)
            return {}
        else:
            key = next(iter(source))
            ret[_normalize_name(key)] = source[key]
    return ret


def parse_targets(
    name=None, pkgs=None, sources=None, saltenv=&quot;base&quot;, normalize=True, **kwargs
):
    &quot;&quot;&quot;
    Parses the input to pkg.install and returns back the package(s) to be
    installed. Returns a list of packages, as well as a string noting whether
    the packages are to come from a repository or a binary package.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg_resource.parse_targets
    &quot;&quot;&quot;
    if &quot;__env__&quot; in kwargs:
        # &quot;env&quot; is not supported; Use &quot;saltenv&quot;.
        kwargs.pop(&quot;__env__&quot;)

    if __grains__[&quot;os&quot;] == &quot;MacOS&quot; and sources:
        log.warning('Parameter &quot;sources&quot; ignored on MacOS hosts.')

    version = kwargs.get(&quot;version&quot;)

    if pkgs and sources:
        log.error('Only one of &quot;pkgs&quot; and &quot;sources&quot; can be used.')
        return None, None

    elif &quot;advisory_ids&quot; in kwargs:
        if pkgs:
            log.error('Cannot use &quot;advisory_ids&quot; and &quot;pkgs&quot; at the same time')
            return None, None
        elif kwargs[&quot;advisory_ids&quot;]:
            return kwargs[&quot;advisory_ids&quot;], &quot;advisory&quot;
        else:
            return [name], &quot;advisory&quot;

    elif pkgs:
        if version is not None:
            log.warning(
                &quot;'version' argument will be ignored for multiple package targets&quot;
            )
        pkgs = _repack_pkgs(pkgs, normalize=normalize)
        if not pkgs:
            return None, None
        else:
            return pkgs, &quot;repository&quot;

    elif sources and __grains__[&quot;os&quot;] != &quot;MacOS&quot;:
        if version is not None:
            log.warning(
                &quot;'version' argument will be ignored for multiple package targets&quot;
            )
        sources = pack_sources(sources, normalize=normalize)
        if not sources:
            return None, None

        srcinfo = []
        for pkg_name, pkg_src in sources.items():
            if __salt__[&quot;config.valid_fileproto&quot;](pkg_src):
                # Cache package from remote source (salt master, HTTP, FTP) and
                # append the cached path.
                srcinfo.append(__salt__[&quot;cp.cache_file&quot;](pkg_src, saltenv))
            else:
                # Package file local to the minion, just append the path to the
                # package file.
                if not os.path.isabs(pkg_src):
                    raise SaltInvocationError(
                        &quot;Path {} for package {} is either not absolute or &quot;
                        &quot;an invalid protocol&quot;.format(pkg_src, pkg_name)
                    )
                srcinfo.append(pkg_src)

        return srcinfo, &quot;file&quot;

    elif name:
        if normalize:
            _normalize_name = __salt__.get(
                &quot;pkg.normalize_name&quot;, lambda pkgname: pkgname
            )
            packed = {_normalize_name(x): version for x in name.split(&quot;,&quot;)}
        else:
            packed = {x: version for x in name.split(&quot;,&quot;)}
        return packed, &quot;repository&quot;

    else:
        log.error(&quot;No package sources provided&quot;)
        return None, None


def version(*names, **kwargs):
    &quot;&quot;&quot;
    Common interface for obtaining the version of installed packages.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg_resource.version vim
        salt '*' pkg_resource.version foo bar baz
        salt '*' pkg_resource.version 'python*'
    &quot;&quot;&quot;
    ret = {}
    versions_as_list = salt.utils.data.is_true(kwargs.pop(&quot;versions_as_list&quot;, False))
    pkg_glob = False
    if len(names) != 0:
        pkgs = __salt__[&quot;pkg.list_pkgs&quot;](versions_as_list=True, **kwargs)
        for name in names:
            if &quot;*&quot; in name:
                pkg_glob = True
                for match in fnmatch.filter(pkgs, name):
                    ret[match] = pkgs.get(match, [])
            else:
                ret[name] = pkgs.get(name, [])
    if not versions_as_list:
        __salt__[&quot;pkg_resource.stringify&quot;](ret)
    # Return a string if no globbing is used, and there is one item in the
    # return dict
    if len(ret) == 1 and not pkg_glob:
        try:
            return next(iter(ret.values()))
        except StopIteration:
            return &quot;&quot;
    return ret


def add_pkg(pkgs, name, pkgver):
    &quot;&quot;&quot;
    Add a package to a dict of installed packages.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg_resource.add_pkg '{}' bind 9
    &quot;&quot;&quot;
    try:
        pkgs.setdefault(name, []).append(pkgver)
    except AttributeError as exc:
        log.exception(exc)


def sort_pkglist(pkgs):
    &quot;&quot;&quot;
    Accepts a dict obtained from pkg.list_pkgs() and sorts in place the list of
    versions for any packages that have multiple versions installed, so that
    two package lists can be compared to one another.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg_resource.sort_pkglist '[&quot;3.45&quot;, &quot;2.13&quot;]'
    &quot;&quot;&quot;
    # It doesn't matter that ['4.9','4.10'] would be sorted to ['4.10','4.9'],
    # so long as the sorting is consistent.
    try:
        for key in pkgs:
            # Passing the pkglist to set() also removes duplicate version
            # numbers (if present).
            pkgs[key] = sorted(set(pkgs[key]))
    except AttributeError as exc:
        log.exception(exc)


def stringify(pkgs):
    &quot;&quot;&quot;
    Takes a dict of package name/version information and joins each list of
    installed versions into a string.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg_resource.stringify 'vim: 7.127'
    &quot;&quot;&quot;
    try:
        for key in pkgs:
            pkgs[key] = &quot;,&quot;.join(pkgs[key])
    except AttributeError as exc:
        log.exception(exc)


def version_clean(verstr):
    &quot;&quot;&quot;
    Clean the version string removing extra data.
    This function will simply try to call ``pkg.version_clean``.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg_resource.version_clean &lt;version_string&gt;
    &quot;&quot;&quot;
    if verstr and &quot;pkg.version_clean&quot; in __salt__:
        return __salt__[&quot;pkg.version_clean&quot;](verstr)
    return verstr


def version_compare(ver1, oper, ver2, ignore_epoch=False):
    &quot;&quot;&quot;
    .. versionadded:: 3001

    Perform a version comparison, using (where available) platform-specific
    version comparison tools to make the comparison.

    ver1
        The first version to be compared

    oper
        One of `==`, `!=`, `&gt;=`, `&lt;=`, `&gt;`, `&lt;`

    ver2
        The second version to be compared

    .. note::
        To avoid shell interpretation, each of the above values should be
        quoted when this function is used on the CLI.

    ignore_epoch : False
        If ``True``, both package versions will have their epoch prefix
        stripped before comparison.

    This function is useful in Jinja templates, to perform specific actions
    when a package's version meets certain criteria. For example:

    .. code-block:: jinja

        {%- set postfix_version = salt.pkg.version('postfix') %}
        {%- if postfix_version and salt.pkg_resource.version_compare(postfix_version, '&gt;=', '3.3', ignore_epoch=True) %}
          {#- do stuff #}
        {%- endif %}

    CLI Examples:

    .. code-block:: bash

        salt myminion pkg_resource.version_compare '3.5' '&lt;=' '2.4'
        salt myminion pkg_resource.version_compare '3.5' '&lt;=' '2.4' ignore_epoch=True
    &quot;&quot;&quot;
    return salt.utils.versions.compare(
        ver1,
        oper,
        ver2,
        ignore_epoch=ignore_epoch,
        cmp_func=__salt__.get(&quot;version_cmp&quot;),
    )


def check_extra_requirements(pkgname, pkgver):
    &quot;&quot;&quot;
    Check if the installed package already has the given requirements.
    This function will return the result of ``pkg.check_extra_requirements`` if
    this function exists for the minion, otherwise it will return True.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg_resource.check_extra_requirements &lt;pkgname&gt; &lt;extra_requirements&gt;
    &quot;&quot;&quot;
    if pkgver and &quot;pkg.check_extra_requirements&quot; in __salt__:
        return __salt__[&quot;pkg.check_extra_requirements&quot;](pkgname, pkgver)

    return True


def format_pkg_list(packages, versions_as_list, attr):
    &quot;&quot;&quot;
    Formats packages according to parameters for list_pkgs.
    &quot;&quot;&quot;
    ret = copy.deepcopy(packages)
    if attr:
        ret_attr = {}
        requested_attr = {
            &quot;epoch&quot;,
            &quot;version&quot;,
            &quot;release&quot;,
            &quot;arch&quot;,
            &quot;install_date&quot;,
            &quot;install_date_time_t&quot;,
        }

        if attr != &quot;all&quot;:
            requested_attr &amp;= set(attr + [&quot;version&quot;] + [&quot;arch&quot;])

        for name in ret:
            if &quot;pkg.parse_arch&quot; in __salt__:
                _parse_arch = __salt__[&quot;pkg.parse_arch&quot;](name)
            else:
                _parse_arch = {&quot;name&quot;: name, &quot;arch&quot;: None}
            _name = _parse_arch[&quot;name&quot;]
            _arch = _parse_arch[&quot;arch&quot;]

            versions = []
            pkgname = None
            for all_attr in ret[name]:
                filtered_attr = {}
                for key in requested_attr:
                    if key in all_attr:
                        filtered_attr[key] = all_attr[key]
                versions.append(filtered_attr)
                if _name and filtered_attr.get(&quot;arch&quot;, None) == _arch:
                    pkgname = _name
            ret_attr.setdefault(pkgname or name, []).extend(versions)
        return ret_attr

    for name in ret:
        ret[name] = [
            format_version(d[&quot;epoch&quot;], d[&quot;version&quot;], d[&quot;release&quot;]) for d in ret[name]
        ]
    if not versions_as_list:
        stringify(ret)
    return ret


def format_version(epoch, version, release):
    &quot;&quot;&quot;
    Formats a version string for list_pkgs.
    &quot;&quot;&quot;
    full_version = &quot;{}:{}&quot;.format(epoch, version) if epoch else version
    if release:
        full_version += &quot;-{}&quot;.format(release)
    return full_version
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_iis_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Microsoft IIS site management via WebAdministration powershell module

:maintainer:    Shane Lee &lt;slee@saltstack.com&gt;, Robert Booth &lt;rbooth@saltstack.com&gt;
:platform:      Windows
:depends:       PowerShell
:depends:       WebAdministration module (PowerShell) (IIS)
<A NAME="0"></A>
.. versionadded:: 2016.3.0
&quot;&quot;&quot;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match264272-0.html#0',2,'match264272-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import decimal
import logging
import os
import re

import salt.utils.json
import salt.utils.platform
import yaml
from salt.exceptions import CommandExecutionError, SaltInvocationError

log = logging.getLogger(__name__)

_DEFAULT_APP =</B></FONT> &quot;/&quot;
_VALID_PROTOCOLS = (&quot;ftp&quot;, &quot;http&quot;, &quot;https&quot;)
_VALID_SSL_FLAGS = tuple(range(0, 4))

# Define the module's virtual name
__virtualname__ = &quot;win_iis&quot;


def __virtual__():
    &quot;&quot;&quot;
    Load only on Windows
    Requires PowerShell and the WebAdministration module
    &quot;&quot;&quot;
    if not salt.utils.platform.is_windows():
        return False, &quot;Only available on Windows systems&quot;

    powershell_info = __salt__[&quot;cmd.shell_info&quot;](&quot;powershell&quot;, True)
    if not powershell_info[&quot;installed&quot;]:
        return False, &quot;PowerShell not available&quot;

    if &quot;WebAdministration&quot; not in powershell_info[&quot;modules&quot;]:
        return False, &quot;IIS is not installed&quot;

    return __virtualname__


def _get_binding_info(host_header=&quot;&quot;, ip_address=&quot;*&quot;, port=80):
    &quot;&quot;&quot;
    Combine the host header, IP address, and TCP port into bindingInformation
    format. Binding Information specifies information to communicate with a
    site. It includes the IP address, the port number, and an optional host
    header (usually a host name) to communicate with the site.

    Args:
        host_header (str): Usually a hostname
        ip_address (str): The IP address
        port (int): The port

    Returns:
        str: A properly formatted bindingInformation string (IP:port:hostheader)
            eg: 192.168.0.12:80:www.contoso.com
    &quot;&quot;&quot;
    return &quot;:&quot;.join([ip_address, str(port), host_header.replace(&quot; &quot;, &quot;&quot;)])


def _list_certs(certificate_store=&quot;My&quot;):
    &quot;&quot;&quot;
    List details of available certificates in the LocalMachine certificate
    store.

    Args:
        certificate_store (str): The name of the certificate store on the local
            machine.

    Returns:
        dict: A dictionary of certificates found in the store
    &quot;&quot;&quot;
    ret = dict()
    blacklist_keys = [&quot;DnsNameList&quot;, &quot;Thumbprint&quot;]

    ps_cmd = [
        &quot;Get-ChildItem&quot;,
        &quot;-Path&quot;,
        r&quot;'Cert:\LocalMachine\{}'&quot;.format(certificate_store),
        &quot;|&quot;,
        &quot;Select-Object DnsNameList, SerialNumber, Subject, Thumbprint, Version&quot;,
    ]

    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)

    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)
    except ValueError:
        raise CommandExecutionError(&quot;Unable to parse return data as Json.&quot;)

    for item in items:

        cert_info = dict()
        for key in item:
            if key not in blacklist_keys:
                cert_info[key.lower()] = item[key]

        cert_info[&quot;dnsnames&quot;] = []
        if item[&quot;DnsNameList&quot;]:
            cert_info[&quot;dnsnames&quot;] = [name[&quot;Unicode&quot;] for name in item[&quot;DnsNameList&quot;]]

        ret[item[&quot;Thumbprint&quot;]] = cert_info

    return ret


def _iisVersion():
    pscmd = []
    pscmd.append(r&quot;Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\InetStp\\&quot;)
    pscmd.append(&quot; | Select-Object MajorVersion, MinorVersion&quot;)

    cmd_ret = _srvmgr(pscmd, return_json=True)

    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)
    except ValueError:
        log.error(&quot;Unable to parse return data as Json.&quot;)
        return -1

    return decimal.Decimal(
        &quot;{}.{}&quot;.format(items[0][&quot;MajorVersion&quot;], items[0][&quot;MinorVersion&quot;])
    )


def _srvmgr(cmd, return_json=False):
    &quot;&quot;&quot;
    Execute a powershell command from the WebAdministration PS module.

    Args:
        cmd (list): The command to execute in a list
        return_json (bool): True formats the return in JSON, False just returns
            the output of the command.

    Returns:
        str: The output from the command
    &quot;&quot;&quot;
    if isinstance(cmd, list):
        cmd = &quot; &quot;.join(cmd)

    if return_json:
        cmd = &quot;ConvertTo-Json -Compress -Depth 4 -InputObject @({})&quot;.format(cmd)

    cmd = &quot;Import-Module WebAdministration; {}&quot;.format(cmd)

    ret = __salt__[&quot;cmd.run_all&quot;](cmd, shell=&quot;powershell&quot;, python_shell=True)

    if ret[&quot;retcode&quot;] != 0:
        log.error(&quot;Unable to execute command: %s\nError: %s&quot;, cmd, ret[&quot;stderr&quot;])

    return ret


def _collection_match_to_index(pspath, colfilter, name, match):
    &quot;&quot;&quot;
    Returns index of collection item matching the match dictionary.
    &quot;&quot;&quot;
    collection = get_webconfiguration_settings(
        pspath, [{&quot;name&quot;: name, &quot;filter&quot;: colfilter}]
    )[0][&quot;value&quot;]
    for idx, collect_dict in enumerate(collection):
        if all(item in collect_dict.items() for item in match.items()):
            return idx
    return -1


def _prepare_settings(pspath, settings):
    &quot;&quot;&quot;
    Prepare settings before execution with get or set functions.
    Removes settings with a match parameter when index is not found.
    &quot;&quot;&quot;
    prepared_settings = []
    for setting in settings:
        if setting.get(&quot;name&quot;, None) is None:
            log.warning(&quot;win_iis: Setting has no name: %s&quot;, setting)
            continue
        if setting.get(&quot;filter&quot;, None) is None:
            log.warning(&quot;win_iis: Setting has no filter: %s&quot;, setting)
            continue
        match = re.search(r&quot;Collection\[(\{.*\})\]&quot;, setting[&quot;name&quot;])
        if match:
            name = setting[&quot;name&quot;][: match.start(1) - 1]
            match_dict = yaml.load(match.group(1))
            index = _collection_match_to_index(
                pspath, setting[&quot;filter&quot;], name, match_dict
            )
            if index == -1:
                log.warning(&quot;win_iis: No match found for setting: %s&quot;, setting)
            else:
                setting[&quot;name&quot;] = setting[&quot;name&quot;].replace(match.group(1), str(index))
                prepared_settings.append(setting)
        else:
            prepared_settings.append(setting)
    return prepared_settings


def list_sites():
    &quot;&quot;&quot;
    List all the currently deployed websites.

    Returns:
        dict: A dictionary of the IIS sites and their properties.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.list_sites
    &quot;&quot;&quot;
    ret = dict()
    ps_cmd = [
        &quot;Get-ChildItem&quot;,
        &quot;-Path&quot;,
        r&quot;'IIS:\Sites'&quot;,
        &quot;|&quot;,
        &quot;Select-Object applicationPool, Bindings, ID, Name, PhysicalPath, State&quot;,
    ]

    keep_keys = (&quot;certificateHash&quot;, &quot;certificateStoreName&quot;, &quot;protocol&quot;, &quot;sslFlags&quot;)

    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)

    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)
    except ValueError:
        raise CommandExecutionError(&quot;Unable to parse return data as Json.&quot;)

    for item in items:
        bindings = dict()

        for binding in item[&quot;bindings&quot;][&quot;Collection&quot;]:

            # Ignore bindings which do not have host names
            if binding[&quot;protocol&quot;] not in [&quot;http&quot;, &quot;https&quot;]:
                continue

            filtered_binding = dict()

            for key in binding:
                if key in keep_keys:
                    filtered_binding.update({key.lower(): binding[key]})

            binding_info = binding[&quot;bindingInformation&quot;].split(&quot;:&quot;, 2)
            ipaddress, port, hostheader = (element.strip() for element in binding_info)
            filtered_binding.update(
                {&quot;hostheader&quot;: hostheader, &quot;ipaddress&quot;: ipaddress, &quot;port&quot;: port}
            )
            bindings[binding[&quot;bindingInformation&quot;]] = filtered_binding

        ret[item[&quot;name&quot;]] = {
            &quot;apppool&quot;: item[&quot;applicationPool&quot;],
            &quot;bindings&quot;: bindings,
            &quot;id&quot;: item[&quot;id&quot;],
            &quot;state&quot;: item[&quot;state&quot;],
            &quot;sourcepath&quot;: item[&quot;physicalPath&quot;],
        }

    if not ret:
        log.warning(&quot;No sites found in output: %s&quot;, cmd_ret[&quot;stdout&quot;])

    return ret


def create_site(
    name, sourcepath, apppool=&quot;&quot;, hostheader=&quot;&quot;, ipaddress=&quot;*&quot;, port=80, protocol=&quot;http&quot;
):
    &quot;&quot;&quot;
    Create a basic website in IIS.

    .. note::

        This function only validates against the site name, and will return True
        even if the site already exists with a different configuration. It will
        not modify the configuration of an existing site.

    Args:
        name (str): The IIS site name.
        sourcepath (str): The physical path of the IIS site.
        apppool (str): The name of the IIS application pool.
        hostheader (str): The host header of the binding. Usually the hostname
            or website name, ie: www.contoso.com
        ipaddress (str): The IP address of the binding.
        port (int): The TCP port of the binding.
        protocol (str): The application protocol of the binding. (http, https,
            etc.)

    Returns:
        bool: True if successful, otherwise False.

    .. note::

        If an application pool is specified, and that application pool does not
        already exist, it will be created.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.create_site name='My Test Site' sourcepath='c:\\stage' apppool='TestPool'
    &quot;&quot;&quot;
    protocol = str(protocol).lower()
    site_path = r&quot;IIS:\Sites\{}&quot;.format(name)
    binding_info = _get_binding_info(hostheader, ipaddress, port)
    current_sites = list_sites()

    if name in current_sites:
        log.debug(&quot;Site '%s' already present.&quot;, name)
        return True

    if protocol not in _VALID_PROTOCOLS:
        message = &quot;Invalid protocol '{}' specified. Valid formats: {}&quot;.format(
            protocol, _VALID_PROTOCOLS
        )
        raise SaltInvocationError(message)

    ps_cmd = [
        &quot;New-Item&quot;,
        &quot;-Path&quot;,
        r&quot;'{}'&quot;.format(site_path),
        &quot;-PhysicalPath&quot;,
        r&quot;'{}'&quot;.format(sourcepath),
        &quot;-Bindings&quot;,
        &quot;@{{ protocol='{0}'; bindingInformation='{1}' }};&quot;.format(
            protocol, binding_info
        ),
    ]

    if apppool:
        if apppool in list_apppools():
            log.debug(&quot;Utilizing pre-existing application pool: %s&quot;, apppool)
        else:
            log.debug(&quot;Application pool will be created: %s&quot;, apppool)
            create_apppool(apppool)

        ps_cmd.extend(
            [
                &quot;Set-ItemProperty&quot;,
                &quot;-Path&quot;,
                &quot;'{}'&quot;.format(site_path),
                &quot;-Name&quot;,
                &quot;ApplicationPool&quot;,
                &quot;-Value&quot;,
                &quot;'{}'&quot;.format(apppool),
            ]
        )

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to create site: {}\nError: {}&quot;.format(name, cmd_ret[&quot;stderr&quot;])
        raise CommandExecutionError(msg)

    log.debug(&quot;Site created successfully: %s&quot;, name)
    return True


def modify_site(name, sourcepath=None, apppool=None):
    &quot;&quot;&quot;
    Modify a basic website in IIS.

    .. versionadded:: 2017.7.0

    Args:
        name (str): The IIS site name.
        sourcepath (str): The physical path of the IIS site.
        apppool (str): The name of the IIS application pool.

    Returns:
        bool: True if successful, otherwise False.

    .. note::

        If an application pool is specified, and that application pool does not
        already exist, it will be created.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.modify_site name='My Test Site' sourcepath='c:\\new_path' apppool='NewTestPool'
    &quot;&quot;&quot;
    site_path = r&quot;IIS:\Sites\{}&quot;.format(name)
    current_sites = list_sites()

    if name not in current_sites:
        log.debug(&quot;Site '%s' not defined.&quot;, name)
        return False

    ps_cmd = list()

    if sourcepath:
        ps_cmd.extend(
            [
                &quot;Set-ItemProperty&quot;,
                &quot;-Path&quot;,
                r&quot;'{}'&quot;.format(site_path),
                &quot;-Name&quot;,
                &quot;PhysicalPath&quot;,
                &quot;-Value&quot;,
                r&quot;'{}'&quot;.format(sourcepath),
            ]
        )

    if apppool:

        if apppool in list_apppools():
            log.debug(&quot;Utilizing pre-existing application pool: %s&quot;, apppool)
        else:
            log.debug(&quot;Application pool will be created: %s&quot;, apppool)
            create_apppool(apppool)

        # If ps_cmd isn't empty, we need to add a semi-colon to run two commands
        if ps_cmd:
            ps_cmd.append(&quot;;&quot;)

        ps_cmd.extend(
            [
                &quot;Set-ItemProperty&quot;,
                &quot;-Path&quot;,
                r&quot;'{}'&quot;.format(site_path),
                &quot;-Name&quot;,
                &quot;ApplicationPool&quot;,
                &quot;-Value&quot;,
                r&quot;'{}'&quot;.format(apppool),
            ]
        )

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to modify site: {}\nError: {}&quot;.format(name, cmd_ret[&quot;stderr&quot;])
        raise CommandExecutionError(msg)

    log.debug(&quot;Site modified successfully: %s&quot;, name)
    return True


def remove_site(name):
    &quot;&quot;&quot;
    Delete a website from IIS.

    Args:
        name (str): The IIS site name.

    Returns:
        bool: True if successful, otherwise False

    .. note::

        This will not remove the application pool used by the site.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.remove_site name='My Test Site'

    &quot;&quot;&quot;
    current_sites = list_sites()

    if name not in current_sites:
        log.debug(&quot;Site already absent: %s&quot;, name)
        return True

    ps_cmd = [&quot;Remove-WebSite&quot;, &quot;-Name&quot;, r&quot;'{}'&quot;.format(name)]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to remove site: {}\nError: {}&quot;.format(name, cmd_ret[&quot;stderr&quot;])
        raise CommandExecutionError(msg)

    log.debug(&quot;Site removed successfully: %s&quot;, name)
    return True


def stop_site(name):
    &quot;&quot;&quot;
    Stop a Web Site in IIS.

    .. versionadded:: 2017.7.0

    Args:
        name (str): The name of the website to stop.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.stop_site name='My Test Site'
    &quot;&quot;&quot;
    ps_cmd = [&quot;Stop-WebSite&quot;, r&quot;'{}'&quot;.format(name)]

    cmd_ret = _srvmgr(ps_cmd)

    return cmd_ret[&quot;retcode&quot;] == 0


def start_site(name):
    &quot;&quot;&quot;
    Start a Web Site in IIS.

    .. versionadded:: 2017.7.0

    Args:
        name (str): The name of the website to start.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.start_site name='My Test Site'
    &quot;&quot;&quot;
    ps_cmd = [&quot;Start-WebSite&quot;, r&quot;'{}'&quot;.format(name)]

    cmd_ret = _srvmgr(ps_cmd)

    return cmd_ret[&quot;retcode&quot;] == 0


def restart_site(name):
    &quot;&quot;&quot;
    Restart a Web Site in IIS.

    .. versionadded:: 2017.7.0

    Args:
        name (str): The name of the website to restart.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.restart_site name='My Test Site'
    &quot;&quot;&quot;
    return stop_site(name) and start_site(name)


def list_bindings(site):
    &quot;&quot;&quot;
    Get all configured IIS bindings for the specified site.

    Args:
        site (str): The name if the IIS Site

    Returns:
        dict: A dictionary of the binding names and properties.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.list_bindings site
    &quot;&quot;&quot;
    ret = dict()
    sites = list_sites()

    if site not in sites:
        log.warning(&quot;Site not found: %s&quot;, site)
        return ret

    ret = sites[site][&quot;bindings&quot;]

    if not ret:
        log.warning(&quot;No bindings found for site: %s&quot;, site)

    return ret


def create_binding(
    site, hostheader=&quot;&quot;, ipaddress=&quot;*&quot;, port=80, protocol=&quot;http&quot;, sslflags=None
):
    &quot;&quot;&quot;
    Create an IIS Web Binding.

    .. note::

        This function only validates against the binding
        ipaddress:port:hostheader combination, and will return True even if the
        binding already exists with a different configuration. It will not
        modify the configuration of an existing binding.

    Args:
        site (str): The IIS site name.
        hostheader (str): The host header of the binding. Usually a hostname.
        ipaddress (str): The IP address of the binding.
        port (int): The TCP port of the binding.
        protocol (str): The application protocol of the binding.
        sslflags (str): The flags representing certificate type and storage of
            the binding.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.create_binding site='site0' hostheader='example.com' ipaddress='*' port='80'
    &quot;&quot;&quot;
    protocol = str(protocol).lower()
    name = _get_binding_info(hostheader, ipaddress, port)

    if protocol not in _VALID_PROTOCOLS:
        message = &quot;Invalid protocol '{}' specified. Valid formats: {}&quot;.format(
            protocol, _VALID_PROTOCOLS
        )
        raise SaltInvocationError(message)

    if sslflags:
        sslflags = int(sslflags)
        if sslflags not in _VALID_SSL_FLAGS:
            raise SaltInvocationError(
                &quot;Invalid sslflags '{}' specified. Valid sslflags range: {}..{}&quot;.format(
                    sslflags, _VALID_SSL_FLAGS[0], _VALID_SSL_FLAGS[-1]
                )
            )

    current_bindings = list_bindings(site)

    if name in current_bindings:
        log.debug(&quot;Binding already present: %s&quot;, name)
        return True

    if sslflags:
        ps_cmd = [
            &quot;New-WebBinding&quot;,
            &quot;-Name&quot;,
            &quot;'{}'&quot;.format(site),
            &quot;-HostHeader&quot;,
            &quot;'{}'&quot;.format(hostheader),
            &quot;-IpAddress&quot;,
            &quot;'{}'&quot;.format(ipaddress),
            &quot;-Port&quot;,
            &quot;'{}'&quot;.format(port),
            &quot;-Protocol&quot;,
            &quot;'{}'&quot;.format(protocol),
            &quot;-SslFlags&quot;,
            &quot;{}&quot;.format(sslflags),
        ]
    else:
        ps_cmd = [
            &quot;New-WebBinding&quot;,
            &quot;-Name&quot;,
            &quot;'{}'&quot;.format(site),
            &quot;-HostHeader&quot;,
            &quot;'{}'&quot;.format(hostheader),
            &quot;-IpAddress&quot;,
            &quot;'{}'&quot;.format(ipaddress),
            &quot;-Port&quot;,
            &quot;'{}'&quot;.format(port),
            &quot;-Protocol&quot;,
            &quot;'{}'&quot;.format(protocol),
        ]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to create binding: {}\nError: {}&quot;.format(site, cmd_ret[&quot;stderr&quot;])
        raise CommandExecutionError(msg)

    if name in list_bindings(site):
        log.debug(&quot;Binding created successfully: %s&quot;, site)
        return True

    log.error(&quot;Unable to create binding: %s&quot;, site)
    return False


def modify_binding(
    site, binding, hostheader=None, ipaddress=None, port=None, sslflags=None
):
    &quot;&quot;&quot;
    Modify an IIS Web Binding. Use ``site`` and ``binding`` to target the
    binding.

    .. versionadded:: 2017.7.0

    Args:
        site (str): The IIS site name.
        binding (str): The binding to edit. This is a combination of the
            IP address, port, and hostheader. It is in the following format:
            ipaddress:port:hostheader. For example, ``*:80:`` or
            ``*:80:salt.com``
        hostheader (str): The host header of the binding. Usually the hostname.
        ipaddress (str): The IP address of the binding.
        port (int): The TCP port of the binding.
        sslflags (str): The flags representing certificate type and storage of
            the binding.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    The following will seat the host header of binding ``*:80:`` for ``site0``
    to ``example.com``

    .. code-block:: bash

        salt '*' win_iis.modify_binding site='site0' binding='*:80:' hostheader='example.com'
    &quot;&quot;&quot;
    if sslflags is not None and sslflags not in _VALID_SSL_FLAGS:
        raise SaltInvocationError(
            &quot;Invalid sslflags '{}' specified. Valid sslflags range: {}..{}&quot;.format(
                sslflags, _VALID_SSL_FLAGS[0], _VALID_SSL_FLAGS[-1]
            )
        )

    current_sites = list_sites()

    if site not in current_sites:
        log.debug(&quot;Site '%s' not defined.&quot;, site)
        return False

    current_bindings = list_bindings(site)

    if binding not in current_bindings:
        log.debug(&quot;Binding '%s' not defined.&quot;, binding)
        return False

    # Split out the binding so we can insert new ones
    # Use the existing value if not passed
    i, p, h = binding.split(&quot;:&quot;)
    new_binding = &quot;:&quot;.join(
        [
            ipaddress if ipaddress is not None else i,
            str(port) if port is not None else str(p),
            hostheader if hostheader is not None else h,
        ]
    )

    if new_binding != binding:
        ps_cmd = [
            &quot;Set-WebBinding&quot;,
            &quot;-Name&quot;,
            &quot;'{}'&quot;.format(site),
            &quot;-BindingInformation&quot;,
            &quot;'{}'&quot;.format(binding),
            &quot;-PropertyName&quot;,
            &quot;BindingInformation&quot;,
            &quot;-Value&quot;,
            &quot;'{}'&quot;.format(new_binding),
        ]

        cmd_ret = _srvmgr(ps_cmd)

        if cmd_ret[&quot;retcode&quot;] != 0:
            msg = &quot;Unable to modify binding: {}\nError: {}&quot;.format(
                binding, cmd_ret[&quot;stderr&quot;]
            )
            raise CommandExecutionError(msg)

    if (
        sslflags is not None
        and sslflags != current_sites[site][&quot;bindings&quot;][binding][&quot;sslflags&quot;]
    ):
        ps_cmd = [
            &quot;Set-WebBinding&quot;,
            &quot;-Name&quot;,
            &quot;'{}'&quot;.format(site),
            &quot;-BindingInformation&quot;,
            &quot;'{}'&quot;.format(new_binding),
            &quot;-PropertyName&quot;,
            &quot;sslflags&quot;,
            &quot;-Value&quot;,
            &quot;'{}'&quot;.format(sslflags),
        ]

        cmd_ret = _srvmgr(ps_cmd)

        if cmd_ret[&quot;retcode&quot;] != 0:
            msg = &quot;Unable to modify binding SSL Flags: {}\nError: {}&quot;.format(
                sslflags, cmd_ret[&quot;stderr&quot;]
            )
            raise CommandExecutionError(msg)

    log.debug(&quot;Binding modified successfully: %s&quot;, binding)
    return True


def remove_binding(site, hostheader=&quot;&quot;, ipaddress=&quot;*&quot;, port=80):
    &quot;&quot;&quot;
    Remove an IIS binding.

    Args:
        site (str): The IIS site name.
        hostheader (str): The host header of the binding.
        ipaddress (str): The IP address of the binding.
        port (int): The TCP port of the binding.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.remove_binding site='site0' hostheader='example.com' ipaddress='*' port='80'
    &quot;&quot;&quot;
    name = _get_binding_info(hostheader, ipaddress, port)
    current_bindings = list_bindings(site)

    if name not in current_bindings:
        log.debug(&quot;Binding already absent: %s&quot;, name)
        return True
    ps_cmd = [
        &quot;Remove-WebBinding&quot;,
        &quot;-HostHeader&quot;,
        &quot;'{}'&quot;.format(hostheader),
        &quot;-IpAddress&quot;,
        &quot;'{}'&quot;.format(ipaddress),
        &quot;-Port&quot;,
        &quot;'{}'&quot;.format(port),
    ]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to remove binding: {}\nError: {}&quot;.format(site, cmd_ret[&quot;stderr&quot;])
        raise CommandExecutionError(msg)

    if name not in list_bindings(site):
        log.debug(&quot;Binding removed successfully: %s&quot;, site)
        return True

    log.error(&quot;Unable to remove binding: %s&quot;, site)
    return False


def list_cert_bindings(site):
    &quot;&quot;&quot;
    List certificate bindings for an IIS site.

    .. versionadded:: 2016.11.0

    Args:
        site (str): The IIS site name.

    Returns:
        dict: A dictionary of the binding names and properties.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.list_bindings site
    &quot;&quot;&quot;
    ret = dict()
    sites = list_sites()

    if site not in sites:
        log.warning(&quot;Site not found: %s&quot;, site)
        return ret

    for binding in sites[site][&quot;bindings&quot;]:
        if sites[site][&quot;bindings&quot;][binding][&quot;certificatehash&quot;]:
            ret[binding] = sites[site][&quot;bindings&quot;][binding]

    if not ret:
        log.warning(&quot;No certificate bindings found for site: %s&quot;, site)

    return ret


def create_cert_binding(name, site, hostheader=&quot;&quot;, ipaddress=&quot;*&quot;, port=443, sslflags=0):
    &quot;&quot;&quot;
    Assign a certificate to an IIS Web Binding.

    .. versionadded:: 2016.11.0

    .. note::

        The web binding that the certificate is being assigned to must already
        exist.

    Args:
        name (str): The thumbprint of the certificate.
        site (str): The IIS site name.
        hostheader (str): The host header of the binding.
        ipaddress (str): The IP address of the binding.
        port (int): The TCP port of the binding.
        sslflags (int): Flags representing certificate type and certificate storage of the binding.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.create_cert_binding name='AAA000' site='site0' hostheader='example.com' ipaddress='*' port='443'
    &quot;&quot;&quot;
    name = str(name).upper()
    binding_info = _get_binding_info(hostheader, ipaddress, port)

    if _iisVersion() &lt; 8:
        # IIS 7.5 and earlier don't support SNI for HTTPS, therefore cert bindings don't contain the host header
        binding_info = binding_info.rpartition(&quot;:&quot;)[0] + &quot;:&quot;

    binding_path = r&quot;IIS:\SslBindings\{}&quot;.format(binding_info.replace(&quot;:&quot;, &quot;!&quot;))

    if sslflags not in _VALID_SSL_FLAGS:
        raise SaltInvocationError(
            &quot;Invalid sslflags '{}' specified. Valid sslflags range: {}..{}&quot;.format(
                sslflags, _VALID_SSL_FLAGS[0], _VALID_SSL_FLAGS[-1]
            )
        )

    # Verify that the target binding exists.
    current_bindings = list_bindings(site)

    if binding_info not in current_bindings:
        log.error(&quot;Binding not present: %s&quot;, binding_info)
        return False

    # Check to see if the certificate is already assigned.
    current_name = None

    for current_binding in current_bindings:
        if binding_info == current_binding:
            current_name = current_bindings[current_binding][&quot;certificatehash&quot;]

    log.debug(&quot;Current certificate thumbprint: %s&quot;, current_name)
    log.debug(&quot;New certificate thumbprint: %s&quot;, name)

    if name == current_name:
        log.debug(&quot;Certificate already present for binding: %s&quot;, name)
        return True

    # Verify that the certificate exists.
    certs = _list_certs()

    if name not in certs:
        log.error(&quot;Certificate not present: %s&quot;, name)
        return False

    if _iisVersion() &lt; 8:
        # IIS 7.5 and earlier have different syntax for associating a certificate with a site
        # Modify IP spec to IIS 7.5 format
        iis7path = binding_path.replace(r&quot;\*!&quot;, &quot;\\0.0.0.0!&quot;)
        # win 2008 uses the following format: ip!port and not ip!port!
        if iis7path.endswith(&quot;!&quot;):
            iis7path = iis7path[:-1]

        ps_cmd = [
            &quot;New-Item&quot;,
            &quot;-Path&quot;,
            &quot;'{}'&quot;.format(iis7path),
            &quot;-Thumbprint&quot;,
            &quot;'{}'&quot;.format(name),
        ]
    else:
        ps_cmd = [
            &quot;New-Item&quot;,
            &quot;-Path&quot;,
            &quot;'{}'&quot;.format(binding_path),
            &quot;-Thumbprint&quot;,
            &quot;'{}'&quot;.format(name),
            &quot;-SSLFlags&quot;,
            &quot;{}&quot;.format(sslflags),
        ]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to create certificate binding: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    new_cert_bindings = list_cert_bindings(site)

    if binding_info not in new_cert_bindings:
        log.error(&quot;Binding not present: %s&quot;, binding_info)
        return False

    if name == new_cert_bindings[binding_info][&quot;certificatehash&quot;]:
        log.debug(&quot;Certificate binding created successfully: %s&quot;, name)
        return True

    log.error(&quot;Unable to create certificate binding: %s&quot;, name)

    return False


def remove_cert_binding(name, site, hostheader=&quot;&quot;, ipaddress=&quot;*&quot;, port=443):
    &quot;&quot;&quot;
    Remove a certificate from an IIS Web Binding.

    .. versionadded:: 2016.11.0

    .. note::

        This function only removes the certificate from the web binding. It does
        not remove the web binding itself.

    Args:
        name (str): The thumbprint of the certificate.
        site (str): The IIS site name.
        hostheader (str): The host header of the binding.
        ipaddress (str): The IP address of the binding.
        port (int): The TCP port of the binding.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.remove_cert_binding name='AAA000' site='site0' hostheader='example.com' ipaddress='*' port='443'
    &quot;&quot;&quot;
    name = str(name).upper()
    binding_info = _get_binding_info(hostheader, ipaddress, port)

    # Child items of IIS:\SslBindings do not return populated host header info
    # in all circumstances, so it's necessary to use IIS:\Sites instead.
    ps_cmd = [
        &quot;$Site = Get-ChildItem&quot;,
        &quot;-Path&quot;,
        r&quot;'IIS:\Sites'&quot;,
        &quot;|&quot;,
        &quot;Where-Object&quot;,
        r&quot; {{ $_.Name -Eq '{0}' }};&quot;.format(site),
        &quot;$Binding = $Site.Bindings.Collection&quot;,
        r&quot;| Where-Object { $_.bindingInformation&quot;,
        r&quot;-Eq '{0}' }};&quot;.format(binding_info),
        &quot;$Binding.RemoveSslCertificate()&quot;,
    ]

    # Verify that the binding exists for the site, and that the target
    # certificate is assigned to the binding.
    current_cert_bindings = list_cert_bindings(site)

    if binding_info not in current_cert_bindings:
        log.warning(&quot;Binding not found: %s&quot;, binding_info)
        return True

    if name != current_cert_bindings[binding_info][&quot;certificatehash&quot;]:
        log.debug(&quot;Certificate binding already absent: %s&quot;, name)
        return True

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to remove certificate binding: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    new_cert_bindings = list_cert_bindings(site)

    if binding_info not in new_cert_bindings:
        log.warning(&quot;Binding not found: %s&quot;, binding_info)
        return True

    if name != new_cert_bindings[binding_info][&quot;certificatehash&quot;]:
        log.debug(&quot;Certificate binding removed successfully: %s&quot;, name)
        return True

    log.error(&quot;Unable to remove certificate binding: %s&quot;, name)
    return False


def list_apppools():
    &quot;&quot;&quot;
    List all configured IIS application pools.

    Returns:
        dict: A dictionary of IIS application pools and their details.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.list_apppools
    &quot;&quot;&quot;
    ret = dict()
    ps_cmd = []
    ps_cmd.append(r&quot;Get-ChildItem -Path 'IIS:\AppPools' | Select-Object Name, State&quot;)

    # Include the equivalent of output from the Applications column, since this
    # isn't a normal property, we have to populate it via filtered output from
    # the Get-WebConfigurationProperty cmdlet.
    ps_cmd.append(r&quot;, @{ Name = 'Applications'; Expression = { $AppPool = $_.Name;&quot;)
    ps_cmd.append(&quot;$AppPath = 'machine/webroot/apphost';&quot;)
    ps_cmd.append(&quot;$FilterBase = '/system.applicationHost/sites/site/application';&quot;)
    ps_cmd.append(&quot;$FilterBase += \&quot;[@applicationPool = '$($AppPool)' and @path\&quot;;&quot;)
    ps_cmd.append(&quot;$FilterRoot = \&quot;$($FilterBase) = '/']/parent::*\&quot;;&quot;)
    ps_cmd.append(&quot;$FilterNonRoot = \&quot;$($FilterBase) != '/']\&quot;;&quot;)
    ps_cmd.append(
        &quot;Get-WebConfigurationProperty -Filter $FilterRoot -PsPath $AppPath -Name Name&quot;
    )
    ps_cmd.append(r&quot;| ForEach-Object { $_.Value };&quot;)
    ps_cmd.append(
        &quot;Get-WebConfigurationProperty -Filter $FilterNonRoot -PsPath $AppPath -Name&quot;
        &quot; Path&quot;
    )
    ps_cmd.append(r&quot;| ForEach-Object { $_.Value } | Where-Object { $_ -ne '/' }&quot;)
    ps_cmd.append(&quot;} }&quot;)

    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)

    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)
    except ValueError:
        raise CommandExecutionError(&quot;Unable to parse return data as Json.&quot;)

    for item in items:
        applications = list()

        # If there are no associated apps, Applications will be an empty dict,
        # if there is one app, it will be a string, and if there are multiple,
        # it will be a dict with 'Count' and 'value' as the keys.

        if isinstance(item[&quot;Applications&quot;], dict):
            if &quot;value&quot; in item[&quot;Applications&quot;]:
                applications += item[&quot;Applications&quot;][&quot;value&quot;]
        else:
            applications.append(item[&quot;Applications&quot;])

        ret[item[&quot;name&quot;]] = {&quot;state&quot;: item[&quot;state&quot;], &quot;applications&quot;: applications}

    if not ret:
        log.warning(&quot;No application pools found in output: %s&quot;, cmd_ret[&quot;stdout&quot;])

    return ret


def create_apppool(name):
    &quot;&quot;&quot;
    Create an IIS application pool.

    .. note::

        This function only validates against the application pool name, and will
        return True even if the application pool already exists with a different
        configuration. It will not modify the configuration of an existing
        application pool.

    Args:
        name (str): The name of the IIS application pool.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.create_apppool name='MyTestPool'
    &quot;&quot;&quot;
    current_apppools = list_apppools()
    apppool_path = r&quot;IIS:\AppPools\{}&quot;.format(name)

    if name in current_apppools:
        log.debug(&quot;Application pool '%s' already present.&quot;, name)
        return True

    ps_cmd = [&quot;New-Item&quot;, &quot;-Path&quot;, r&quot;'{}'&quot;.format(apppool_path)]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to create application pool: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    log.debug(&quot;Application pool created successfully: %s&quot;, name)
    return True


def remove_apppool(name):
    &quot;&quot;&quot;
    Remove an IIS application pool.

    Args:
        name (str): The name of the IIS application pool.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.remove_apppool name='MyTestPool'
    &quot;&quot;&quot;
    current_apppools = list_apppools()
    apppool_path = r&quot;IIS:\AppPools\{}&quot;.format(name)

    if name not in current_apppools:
        log.debug(&quot;Application pool already absent: %s&quot;, name)
        return True

    ps_cmd = [&quot;Remove-Item&quot;, &quot;-Path&quot;, r&quot;'{}'&quot;.format(apppool_path), &quot;-Recurse&quot;]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to remove application pool: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    log.debug(&quot;Application pool removed successfully: %s&quot;, name)
    return True


def stop_apppool(name):
    &quot;&quot;&quot;
    Stop an IIS application pool.

    .. versionadded:: 2017.7.0

    Args:
        name (str): The name of the App Pool to stop.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.stop_apppool name='MyTestPool'
    &quot;&quot;&quot;
    ps_cmd = [&quot;Stop-WebAppPool&quot;, r&quot;'{}'&quot;.format(name)]

    cmd_ret = _srvmgr(ps_cmd)

    return cmd_ret[&quot;retcode&quot;] == 0


def start_apppool(name):
    &quot;&quot;&quot;
    Start an IIS application pool.

    .. versionadded:: 2017.7.0

    Args:
        name (str): The name of the App Pool to start.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.start_apppool name='MyTestPool'
    &quot;&quot;&quot;
    ps_cmd = [&quot;Start-WebAppPool&quot;, r&quot;'{}'&quot;.format(name)]

    cmd_ret = _srvmgr(ps_cmd)

    return cmd_ret[&quot;retcode&quot;] == 0


def restart_apppool(name):
    &quot;&quot;&quot;
    Restart an IIS application pool.

    .. versionadded:: 2016.11.0

    Args:
        name (str): The name of the IIS application pool.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.restart_apppool name='MyTestPool'
    &quot;&quot;&quot;
    ps_cmd = [&quot;Restart-WebAppPool&quot;, r&quot;'{}'&quot;.format(name)]

    cmd_ret = _srvmgr(ps_cmd)

    return cmd_ret[&quot;retcode&quot;] == 0


def get_container_setting(name, container, settings):
    &quot;&quot;&quot;
    Get the value of the setting for the IIS container.

    .. versionadded:: 2016.11.0

    Args:
        name (str): The name of the IIS container.
        container (str): The type of IIS container. The container types are:
            AppPools, Sites, SslBindings
        settings (dict): A dictionary of the setting names and their values.

    Returns:
        dict: A dictionary of the provided settings and their values.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.get_container_setting name='MyTestPool' container='AppPools'
            settings=&quot;['processModel.identityType']&quot;
    &quot;&quot;&quot;
    ret = dict()
    ps_cmd = list()
    ps_cmd_validate = list()
    container_path = r&quot;IIS:\{}\{}&quot;.format(container, name)

    if not settings:
        log.warning(&quot;No settings provided&quot;)
        return ret

    ps_cmd.append(r&quot;$Settings = @{};&quot;)

    for setting in settings:
        # Build the commands to verify that the property names are valid.
        ps_cmd_validate.extend(
            [
                &quot;Get-ItemProperty&quot;,
                &quot;-Path&quot;,
                &quot;'{}'&quot;.format(container_path),
                &quot;-Name&quot;,
                &quot;'{}'&quot;.format(setting),
                &quot;-ErrorAction&quot;,
                &quot;Stop&quot;,
                &quot;|&quot;,
                &quot;Out-Null;&quot;,
            ]
        )

        # Some ItemProperties are Strings and others are ConfigurationAttributes.
        # Since the former doesn't have a Value property, we need to account
        # for this.
        ps_cmd.append(&quot;$Property = Get-ItemProperty -Path '{}'&quot;.format(container_path))
        ps_cmd.append(&quot;-Name '{}' -ErrorAction Stop;&quot;.format(setting))
        ps_cmd.append(r&quot;if (([String]::IsNullOrEmpty($Property) -eq $False) -and&quot;)
        ps_cmd.append(r&quot;($Property.GetType()).Name -eq 'ConfigurationAttribute') {&quot;)
        ps_cmd.append(r&quot;$Property = $Property | Select-Object&quot;)
        ps_cmd.append(r&quot;-ExpandProperty Value };&quot;)
        ps_cmd.append(&quot;$Settings['{}'] = [String] $Property;&quot;.format(setting))
        ps_cmd.append(r&quot;$Property = $Null;&quot;)

    # Validate the setting names that were passed in.
    cmd_ret = _srvmgr(cmd=ps_cmd_validate, return_json=True)

    if cmd_ret[&quot;retcode&quot;] != 0:
        message = (
            &quot;One or more invalid property names were specified for the provided&quot;
            &quot; container.&quot;
        )
        raise SaltInvocationError(message)

    ps_cmd.append(&quot;$Settings&quot;)
    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)

    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)

        if isinstance(items, list):
            ret.update(items[0])
        else:
            ret.update(items)

    except ValueError:
        raise CommandExecutionError(&quot;Unable to parse return data as Json.&quot;)

    return ret


def set_container_setting(name, container, settings):
    &quot;&quot;&quot;
    Set the value of the setting for an IIS container.

    .. versionadded:: 2016.11.0

    Args:
        name (str): The name of the IIS container.
        container (str): The type of IIS container. The container types are:
            AppPools, Sites, SslBindings
        settings (dict): A dictionary of the setting names and their values.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.set_container_setting name='MyTestPool' container='AppPools'
            settings=&quot;{'managedPipeLineMode': 'Integrated'}&quot;
    &quot;&quot;&quot;

    identityType_map2string = {
        &quot;0&quot;: &quot;LocalSystem&quot;,
        &quot;1&quot;: &quot;LocalService&quot;,
        &quot;2&quot;: &quot;NetworkService&quot;,
        &quot;3&quot;: &quot;SpecificUser&quot;,
        &quot;4&quot;: &quot;ApplicationPoolIdentity&quot;,
    }
    identityType_map2numeric = {
        &quot;LocalSystem&quot;: &quot;0&quot;,
        &quot;LocalService&quot;: &quot;1&quot;,
        &quot;NetworkService&quot;: &quot;2&quot;,
        &quot;SpecificUser&quot;: &quot;3&quot;,
        &quot;ApplicationPoolIdentity&quot;: &quot;4&quot;,
    }
    ps_cmd = list()
    container_path = r&quot;IIS:\{}\{}&quot;.format(container, name)

    if not settings:
        log.warning(&quot;No settings provided&quot;)
        return False

    # Treat all values as strings for the purpose of comparing them to existing values.
    for setting in settings:
        settings[setting] = str(settings[setting])

    current_settings = get_container_setting(
        name=name, container=container, settings=settings.keys()
    )

    if settings == current_settings:
        log.debug(&quot;Settings already contain the provided values.&quot;)
        return True

    for setting in settings:
        # If the value is numeric, don't treat it as a string in PowerShell.
        try:
            complex(settings[setting])
            value = settings[setting]
        except ValueError:
            value = &quot;'{}'&quot;.format(settings[setting])

        # Map to numeric to support server 2008
        if (
            setting == &quot;processModel.identityType&quot;
            and settings[setting] in identityType_map2numeric.keys()
        ):
            value = identityType_map2numeric[settings[setting]]

        ps_cmd.extend(
            [
                &quot;Set-ItemProperty&quot;,
                &quot;-Path&quot;,
                &quot;'{}'&quot;.format(container_path),
                &quot;-Name&quot;,
                &quot;'{}'&quot;.format(setting),
                &quot;-Value&quot;,
                &quot;{};&quot;.format(value),
            ]
        )

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to set settings for {}: {}&quot;.format(container, name)
        raise CommandExecutionError(msg)

    # Get the fields post-change so that we can verify tht all values
    # were modified successfully. Track the ones that weren't.
    new_settings = get_container_setting(
        name=name, container=container, settings=settings.keys()
    )

    failed_settings = dict()

    for setting in settings:
        # map identity type from numeric to string for comparing
        if (
            setting == &quot;processModel.identityType&quot;
            and settings[setting] in identityType_map2string.keys()
        ):
            settings[setting] = identityType_map2string[settings[setting]]

        if str(settings[setting]) != str(new_settings[setting]):
            failed_settings[setting] = settings[setting]

    if failed_settings:
        log.error(&quot;Failed to change settings: %s&quot;, failed_settings)
        return False

    log.debug(&quot;Settings configured successfully: %s&quot;, settings.keys())
    return True


def list_apps(site):
    &quot;&quot;&quot;
    Get all configured IIS applications for the specified site.

    Args:
        site (str): The IIS site name.

    Returns: A dictionary of the application names and properties.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.list_apps site
    &quot;&quot;&quot;
    ret = dict()
    ps_cmd = list()
    ps_cmd.append(&quot;Get-WebApplication -Site '{}'&quot;.format(site))
    ps_cmd.append(
        r&quot;| Select-Object applicationPool, path, PhysicalPath, preloadEnabled,&quot;
    )
    ps_cmd.append(r&quot;@{ Name='name'; Expression={ $_.path.Split('/', 2)[-1] } },&quot;)
    ps_cmd.append(
        r&quot;@{ Name='protocols'; Expression={ @( $_.enabledProtocols.Split(',')&quot;
    )
    ps_cmd.append(r&quot;| Foreach-Object { $_.Trim() } ) } }&quot;)

    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)

    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)
    except ValueError:
        raise CommandExecutionError(&quot;Unable to parse return data as Json.&quot;)

    for item in items:
        protocols = list()

        # If there are no associated protocols, protocols will be an empty dict,
        # if there is one protocol, it will be a string, and if there are
        # multiple, it will be a dict with 'Count' and 'value' as the keys.

        if isinstance(item[&quot;protocols&quot;], dict):
            if &quot;value&quot; in item[&quot;protocols&quot;]:
                protocols += item[&quot;protocols&quot;][&quot;value&quot;]
        else:
            protocols.append(item[&quot;protocols&quot;])

        ret[item[&quot;name&quot;]] = {
            &quot;apppool&quot;: item[&quot;applicationPool&quot;],
            &quot;path&quot;: item[&quot;path&quot;],
            &quot;preload&quot;: item[&quot;preloadEnabled&quot;],
            &quot;protocols&quot;: protocols,
            &quot;sourcepath&quot;: item[&quot;PhysicalPath&quot;],
        }

    if not ret:
        log.warning(&quot;No apps found in output: %s&quot;, cmd_ret)

    return ret


def create_app(name, site, sourcepath, apppool=None):
    &quot;&quot;&quot;
    Create an IIS application.

    .. note::

        This function only validates against the application name, and will
        return True even if the application already exists with a different
        configuration. It will not modify the configuration of an existing
        application.

    Args:
        name (str): The IIS application.
        site (str): The IIS site name.
        sourcepath (str): The physical path.
        apppool (str): The name of the IIS application pool.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.create_app name='app0' site='site0' sourcepath='C:\\site0' apppool='site0'
    &quot;&quot;&quot;
    current_apps = list_apps(site)

    if name in current_apps:
        log.debug(&quot;Application already present: %s&quot;, name)
        return True

    # The target physical path must exist.
    if not os.path.isdir(sourcepath):
        log.error(&quot;Path is not present: %s&quot;, sourcepath)
        return False

    ps_cmd = [
        &quot;New-WebApplication&quot;,
        &quot;-Name&quot;,
        &quot;'{}'&quot;.format(name),
        &quot;-Site&quot;,
        &quot;'{}'&quot;.format(site),
        &quot;-PhysicalPath&quot;,
        &quot;'{}'&quot;.format(sourcepath),
    ]

    if apppool:
        ps_cmd.extend([&quot;-ApplicationPool&quot;, &quot;'{}'&quot;.format(apppool)])

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to create application: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    new_apps = list_apps(site)

    if name in new_apps:
        log.debug(&quot;Application created successfully: %s&quot;, name)
        return True

    log.error(&quot;Unable to create application: %s&quot;, name)
    return False


def remove_app(name, site):
    &quot;&quot;&quot;
    Remove an IIS application.

    Args:
        name (str): The application name.
        site (str): The IIS site name.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.remove_app name='app0' site='site0'
    &quot;&quot;&quot;
    current_apps = list_apps(site)

    if name not in current_apps:
        log.debug(&quot;Application already absent: %s&quot;, name)
        return True

    ps_cmd = [
        &quot;Remove-WebApplication&quot;,
        &quot;-Name&quot;,
        &quot;'{}'&quot;.format(name),
        &quot;-Site&quot;,
        &quot;'{}'&quot;.format(site),
    ]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to remove application: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    new_apps = list_apps(site)

    if name not in new_apps:
        log.debug(&quot;Application removed successfully: %s&quot;, name)
        return True

    log.error(&quot;Unable to remove application: %s&quot;, name)
    return False


def list_vdirs(site, app=_DEFAULT_APP):
    &quot;&quot;&quot;
    Get all configured IIS virtual directories for the specified site, or for
    the combination of site and application.

    Args:
        site (str): The IIS site name.
        app (str): The IIS application.

    Returns:
        dict: A dictionary of the virtual directory names and properties.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.list_vdirs site
    &quot;&quot;&quot;
    ret = dict()

    ps_cmd = [
        &quot;Get-WebVirtualDirectory&quot;,
        &quot;-Site&quot;,
        r&quot;'{}'&quot;.format(site),
        &quot;-Application&quot;,
        r&quot;'{}'&quot;.format(app),
        &quot;|&quot;,
        &quot;Select-Object PhysicalPath, @{ Name = 'name';&quot;,
        r&quot;Expression = { $_.path.Trim('/') } }&quot;,
    ]

    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)

    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)
    except ValueError:
        raise CommandExecutionError(&quot;Unable to parse return data as Json.&quot;)

    for item in items:
        ret[item[&quot;name&quot;]] = {&quot;sourcepath&quot;: item[&quot;physicalPath&quot;]}

    if not ret:
        log.warning(&quot;No vdirs found in output: %s&quot;, cmd_ret)

    return ret


def create_vdir(name, site, sourcepath, app=_DEFAULT_APP):
    &quot;&quot;&quot;
    Create an IIS virtual directory.

    .. note::

        This function only validates against the virtual directory name, and
        will return True even if the virtual directory already exists with a
        different configuration. It will not modify the configuration of an
        existing virtual directory.

    Args:
        name (str): The virtual directory name.
        site (str): The IIS site name.
        sourcepath (str): The physical path.
        app (str): The IIS application.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.create_vdir name='vd0' site='site0' sourcepath='C:\\inetpub\\vdirs\\vd0'
    &quot;&quot;&quot;
    current_vdirs = list_vdirs(site, app)

    if name in current_vdirs:
        log.debug(&quot;Virtual directory already present: %s&quot;, name)
        return True

    # The target physical path must exist.
    if not os.path.isdir(sourcepath):
        log.error(&quot;Path is not present: %s&quot;, sourcepath)
        return False

    ps_cmd = [
        &quot;New-WebVirtualDirectory&quot;,
        &quot;-Name&quot;,
        r&quot;'{}'&quot;.format(name),
        &quot;-Site&quot;,
        r&quot;'{}'&quot;.format(site),
        &quot;-PhysicalPath&quot;,
        r&quot;'{}'&quot;.format(sourcepath),
    ]

    if app != _DEFAULT_APP:
        ps_cmd.extend([&quot;-Application&quot;, r&quot;'{}'&quot;.format(app)])

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to create virtual directory: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    new_vdirs = list_vdirs(site, app)

    if name in new_vdirs:
        log.debug(&quot;Virtual directory created successfully: %s&quot;, name)
        return True

    log.error(&quot;Unable to create virtual directory: %s&quot;, name)
    return False


def remove_vdir(name, site, app=_DEFAULT_APP):
    &quot;&quot;&quot;
    Remove an IIS virtual directory.

    Args:
        name (str): The virtual directory name.
        site (str): The IIS site name.
        app (str): The IIS application.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.remove_vdir name='vdir0' site='site0'
    &quot;&quot;&quot;
    current_vdirs = list_vdirs(site, app)
    app_path = os.path.join(*app.rstrip(&quot;/&quot;).split(&quot;/&quot;))

    if app_path:
        app_path = &quot;{}\\&quot;.format(app_path)
    vdir_path = r&quot;IIS:\Sites\{}\{}{}&quot;.format(site, app_path, name)

    if name not in current_vdirs:
        log.debug(&quot;Virtual directory already absent: %s&quot;, name)
        return True

    # We use Remove-Item here instead of Remove-WebVirtualDirectory, since the
    # latter has a bug that causes it to always prompt for user input.

    ps_cmd = [&quot;Remove-Item&quot;, &quot;-Path&quot;, r&quot;'{}'&quot;.format(vdir_path), &quot;-Recurse&quot;]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to remove virtual directory: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    new_vdirs = list_vdirs(site, app)

    if name not in new_vdirs:
        log.debug(&quot;Virtual directory removed successfully: %s&quot;, name)
        return True

    log.error(&quot;Unable to remove virtual directory: %s&quot;, name)
    return False


def list_backups():
    r&quot;&quot;&quot;
    List the IIS Configuration Backups on the System.

    .. versionadded:: 2017.7.0

    .. note::
        Backups are made when a configuration is edited. Manual backups are
        stored in the ``$env:Windir\System32\inetsrv\backup`` folder.

    Returns:
        dict: A dictionary of IIS Configurations backed up on the system.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.list_backups
    &quot;&quot;&quot;
    ret = dict()

    ps_cmd = [
        &quot;Get-WebConfigurationBackup&quot;,
        &quot;|&quot;,
        &quot;Select Name, CreationDate,&quot;,
        '@{N=&quot;FormattedDate&quot;; E={$_.CreationDate.ToString(&quot;G&quot;)}}',
    ]

    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)

    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)
    except ValueError:
        raise CommandExecutionError(&quot;Unable to parse return data as Json.&quot;)

    for item in items:
        if item[&quot;FormattedDate&quot;]:
            ret[item[&quot;Name&quot;]] = item[&quot;FormattedDate&quot;]
        else:
            ret[item[&quot;Name&quot;]] = item[&quot;CreationDate&quot;]

    if not ret:
        log.warning(&quot;No backups found in output: %s&quot;, cmd_ret)

    return ret


def create_backup(name):
    r&quot;&quot;&quot;
    Backup an IIS Configuration on the System.

    .. versionadded:: 2017.7.0

    .. note::
        Backups are stored in the ``$env:Windir\System32\inetsrv\backup``
        folder.

    Args:
        name (str): The name to give the backup

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.create_backup good_config_20170209
    &quot;&quot;&quot;
    if name in list_backups():
        raise CommandExecutionError(&quot;Backup already present: {}&quot;.format(name))

    ps_cmd = [&quot;Backup-WebConfiguration&quot;, &quot;-Name&quot;, &quot;'{}'&quot;.format(name)]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to backup web configuration: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    return name in list_backups()


def remove_backup(name):
    &quot;&quot;&quot;
    Remove an IIS Configuration backup from the System.

    .. versionadded:: 2017.7.0

    Args:
        name (str): The name of the backup to remove

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.remove_backup backup_20170209
    &quot;&quot;&quot;
    if name not in list_backups():
        log.debug(&quot;Backup already removed: %s&quot;, name)
        return True

    ps_cmd = [&quot;Remove-WebConfigurationBackup&quot;, &quot;-Name&quot;, &quot;'{}'&quot;.format(name)]

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to remove web configuration: {}\nError: {}&quot;.format(
            name, cmd_ret[&quot;stderr&quot;]
        )
        raise CommandExecutionError(msg)

    return name not in list_backups()


def list_worker_processes(apppool):
    &quot;&quot;&quot;
    Returns a list of worker processes that correspond to the passed
    application pool.

    .. versionadded:: 2017.7.0

    Args:
        apppool (str): The application pool to query

    Returns:
        dict: A dictionary of worker processes with their process IDs

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.list_worker_processes 'My App Pool'
    &quot;&quot;&quot;
    ps_cmd = [&quot;Get-ChildItem&quot;, r&quot;'IIS:\AppPools\{}\WorkerProcesses'&quot;.format(apppool)]

    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)

    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)
    except ValueError:
        raise CommandExecutionError(&quot;Unable to parse return data as Json.&quot;)

    ret = dict()
    for item in items:
        ret[item[&quot;processId&quot;]] = item[&quot;appPoolName&quot;]

    if not ret:
        log.warning(&quot;No backups found in output: %s&quot;, cmd_ret)

    return ret


def get_webapp_settings(name, site, settings):
    r&quot;&quot;&quot;
    .. versionadded:: 2017.7.0

    Get the value of the setting for the IIS web application.

    .. note::
        Params are case sensitive

    :param str name: The name of the IIS web application.
    :param str site: The site name contains the web application.
        Example: Default Web Site
    :param str settings: A dictionary of the setting names and their values.
        Available settings: physicalPath, applicationPool, userName, password
    Returns:
        dict: A dictionary of the provided settings and their values.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.get_webapp_settings name='app0' site='Default Web Site'
            settings=&quot;['physicalPath','applicationPool']&quot;
    &quot;&quot;&quot;
    ret = dict()
    pscmd = list()
    availableSettings = (&quot;physicalPath&quot;, &quot;applicationPool&quot;, &quot;userName&quot;, &quot;password&quot;)

    if not settings:
        log.warning(&quot;No settings provided&quot;)
        return ret

    pscmd.append(r&quot;$Settings = @{};&quot;)

    # Verify setting is ine predefined settings and append relevant query command per setting key
    for setting in settings:
        if setting in availableSettings:
            if setting == &quot;userName&quot; or setting == &quot;password&quot;:
                pscmd.append(
                    &quot; $Property = Get-WebConfigurationProperty -Filter&quot;
                    &quot; \&quot;system.applicationHost/sites/site[@name='{}']/application[@path='/{}']/virtualDirectory[@path='/']\&quot;&quot;.format(
                        site, name
                    )
                )
                pscmd.append(
                    r' -Name &quot;{}&quot; -ErrorAction Stop | select Value;'.format(setting)
                )
                pscmd.append(
                    r&quot; $Property = $Property | Select-Object -ExpandProperty Value;&quot;
                )
                pscmd.append(r&quot; $Settings['{}'] = [String] $Property;&quot;.format(setting))
                pscmd.append(r&quot; $Property = $Null;&quot;)

            if setting == &quot;physicalPath&quot; or setting == &quot;applicationPool&quot;:
                pscmd.append(
                    r&quot; $Property = (get-webapplication {}).{};&quot;.format(name, setting)
                )
                pscmd.append(r&quot; $Settings['{}'] = [String] $Property;&quot;.format(setting))
                pscmd.append(r&quot; $Property = $Null;&quot;)

        else:
            availSetStr = &quot;, &quot;.join(availableSettings)
            message = (
                &quot;Unexpected setting:&quot;
                + setting
                + &quot;. Available settings are: &quot;
                + availSetStr
            )
            raise SaltInvocationError(message)

    pscmd.append(&quot; $Settings&quot;)
    # Run commands and return data as json
    cmd_ret = _srvmgr(cmd=&quot;&quot;.join(pscmd), return_json=True)

    # Update dict var to return data
    try:
        items = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)

        if isinstance(items, list):
            ret.update(items[0])
        else:
            ret.update(items)
    except ValueError:
        log.error(&quot;Unable to parse return data as Json.&quot;)

    if None in ret.values():
        message = (
            &quot;Some values are empty - please validate site and web application names.&quot;
            &quot; Some commands are case sensitive&quot;
        )
        raise SaltInvocationError(message)

    return ret


def set_webapp_settings(name, site, settings):
    r&quot;&quot;&quot;
    .. versionadded:: 2017.7.0

    Configure an IIS application.

    .. note::
        This function only configures an existing app. Params are case
        sensitive.

    :param str name: The IIS application.
    :param str site: The IIS site name.
    :param str settings: A dictionary of the setting names and their values.
        - physicalPath: The physical path of the webapp.
        - applicationPool: The application pool for the webapp.
        - userName: &quot;connectAs&quot; user
        - password: &quot;connectAs&quot; password for user
    :return: A boolean representing whether all changes succeeded.
    :rtype: bool

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.set_webapp_settings name='app0' site='site0' settings=&quot;{'physicalPath': 'C:\site0', 'apppool': 'site0'}&quot;
    &quot;&quot;&quot;
    pscmd = list()
    current_apps = list_apps(site)
    current_sites = list_sites()
    availableSettings = (&quot;physicalPath&quot;, &quot;applicationPool&quot;, &quot;userName&quot;, &quot;password&quot;)

    # Validate params
    if name not in current_apps:
        msg = &quot;Application&quot; + name + &quot;doesn't exist&quot;
        raise SaltInvocationError(msg)

    if site not in current_sites:
        msg = &quot;Site&quot; + site + &quot;doesn't exist&quot;
        raise SaltInvocationError(msg)

    if not settings:
        msg = &quot;No settings provided&quot;
        raise SaltInvocationError(msg)

    # Treat all values as strings for the purpose of comparing them to existing values &amp; validate settings exists in predefined settings list
    for setting in settings.keys():
        if setting in availableSettings:
            settings[setting] = str(settings[setting])
        else:
            availSetStr = &quot;, &quot;.join(availableSettings)
            log.error(&quot;Unexpected setting: %s &quot;, setting)
            log.error(&quot;Available settings: %s&quot;, availSetStr)
            msg = &quot;Unexpected setting:&quot; + setting + &quot; Available settings:&quot; + availSetStr
            raise SaltInvocationError(msg)

    # Check if settings already configured
    current_settings = get_webapp_settings(
        name=name, site=site, settings=settings.keys()
    )

    if settings == current_settings:
        log.warning(&quot;Settings already contain the provided values.&quot;)
        return True

    for setting in settings:
        # If the value is numeric, don't treat it as a string in PowerShell.
        try:
            complex(settings[setting])
            value = settings[setting]
        except ValueError:
            value = &quot;'{}'&quot;.format(settings[setting])

        # Append relevant update command per setting key
        if setting == &quot;userName&quot; or setting == &quot;password&quot;:
            pscmd.append(
                &quot; Set-WebConfigurationProperty -Filter&quot;
                &quot; \&quot;system.applicationHost/sites/site[@name='{}']/application[@path='/{}']/virtualDirectory[@path='/']\&quot;&quot;.format(
                    site, name
                )
            )
            pscmd.append(' -Name &quot;{}&quot; -Value {};'.format(setting, value))

        if setting == &quot;physicalPath&quot; or setting == &quot;applicationPool&quot;:
            pscmd.append(
                r' Set-ItemProperty &quot;IIS:\Sites\{}\{}&quot; -Name {} -Value {};'.format(
                    site, name, setting, value
                )
            )
            if setting == &quot;physicalPath&quot;:
                if not os.path.isdir(settings[setting]):
                    msg = &quot;Path is not present: &quot; + settings[setting]
                    raise SaltInvocationError(msg)

    # Run commands
    cmd_ret = _srvmgr(pscmd)

    # Verify commands completed successfully
    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to set settings for web application {}&quot;.format(name)
        raise SaltInvocationError(msg)

    # verify changes
    new_settings = get_webapp_settings(name=name, site=site, settings=settings.keys())
    failed_settings = dict()

    for setting in settings:
        if str(settings[setting]) != str(new_settings[setting]):
            failed_settings[setting] = settings[setting]

    if failed_settings:
        log.error(&quot;Failed to change settings: %s&quot;, failed_settings)
        return False

    log.debug(&quot;Settings configured successfully: %s&quot;, list(settings))
    return True


def get_webconfiguration_settings(name, settings):
    r&quot;&quot;&quot;
    Get the webconfiguration settings for the IIS PSPath.

    Args:
        name (str): The PSPath of the IIS webconfiguration settings.
        settings (list): A list of dictionaries containing setting name and filter.

    Returns:
        dict: A list of dictionaries containing setting name, filter and value.

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.get_webconfiguration_settings name='IIS:\' settings=&quot;[{'name': 'enabled', 'filter': 'system.webServer/security/authentication/anonymousAuthentication'}]&quot;
    &quot;&quot;&quot;
    ret = {}
    ps_cmd = [r&quot;$Settings = New-Object System.Collections.ArrayList;&quot;]
    ps_cmd_validate = []
    settings = _prepare_settings(name, settings)

    if not settings:
        log.warning(&quot;No settings provided&quot;)
        return ret

    for setting in settings:

        # Build the commands to verify that the property names are valid.

        ps_cmd_validate.extend(
            [
                &quot;Get-WebConfigurationProperty&quot;,
                &quot;-PSPath&quot;,
                &quot;'{}'&quot;.format(name),
                &quot;-Filter&quot;,
                &quot;'{}'&quot;.format(setting[&quot;filter&quot;]),
                &quot;-Name&quot;,
                &quot;'{}'&quot;.format(setting[&quot;name&quot;]),
                &quot;-ErrorAction&quot;,
                &quot;Stop&quot;,
                &quot;|&quot;,
                &quot;Out-Null;&quot;,
            ]
        )

        # Some ItemProperties are Strings and others are ConfigurationAttributes.
        # Since the former doesn't have a Value property, we need to account
        # for this.
        ps_cmd.append(
            &quot;$Property = Get-WebConfigurationProperty -PSPath '{}'&quot;.format(name)
        )
        ps_cmd.append(
            &quot;-Name '{}' -Filter '{}' -ErrorAction Stop;&quot;.format(
                setting[&quot;name&quot;], setting[&quot;filter&quot;]
            )
        )
        if setting[&quot;name&quot;].split(&quot;.&quot;)[-1] == &quot;Collection&quot;:
            if &quot;value&quot; in setting:
                ps_cmd.append(
                    &quot;$Property = $Property | select -Property {} ;&quot;.format(
                        &quot;,&quot;.join(list(setting[&quot;value&quot;][0].keys()))
                    )
                )
            ps_cmd.append(
                &quot;$Settings.add(@{{filter='{0}';name='{1}';value=[System.Collections.ArrayList]&quot;
                &quot; @($Property)}})| Out-Null;&quot;.format(setting[&quot;filter&quot;], setting[&quot;name&quot;])
            )
        else:
            ps_cmd.append(r&quot;if (([String]::IsNullOrEmpty($Property) -eq $False) -and&quot;)
            ps_cmd.append(r&quot;($Property.GetType()).Name -eq 'ConfigurationAttribute') {&quot;)
            ps_cmd.append(r&quot;$Property = $Property | Select-Object&quot;)
            ps_cmd.append(r&quot;-ExpandProperty Value };&quot;)
            ps_cmd.append(
                &quot;$Settings.add(@{{filter='{0}';name='{1}';value=[String] $Property}})|&quot;
                &quot; Out-Null;&quot;.format(setting[&quot;filter&quot;], setting[&quot;name&quot;])
            )
        ps_cmd.append(r&quot;$Property = $Null;&quot;)

    # Validate the setting names that were passed in.
    cmd_ret = _srvmgr(cmd=ps_cmd_validate, return_json=True)

    if cmd_ret[&quot;retcode&quot;] != 0:
        message = (
            &quot;One or more invalid property names were specified for the provided&quot;
            &quot; container.&quot;
        )
        raise SaltInvocationError(message)

    ps_cmd.append(&quot;$Settings&quot;)
    cmd_ret = _srvmgr(cmd=ps_cmd, return_json=True)

    try:
        ret = salt.utils.json.loads(cmd_ret[&quot;stdout&quot;], strict=False)

    except ValueError:
        raise CommandExecutionError(&quot;Unable to parse return data as Json.&quot;)

    return ret


def set_webconfiguration_settings(name, settings):
    r&quot;&quot;&quot;
    Set the value of the setting for an IIS container.

    Args:
        name (str): The PSPath of the IIS webconfiguration settings.
        settings (list): A list of dictionaries containing setting name, filter and value.

    Returns:
        bool: True if successful, otherwise False

    CLI Example:

    .. code-block:: bash

        salt '*' win_iis.set_webconfiguration_settings name='IIS:\' settings=&quot;[{'name': 'enabled', 'filter': 'system.webServer/security/authentication/anonymousAuthentication', 'value': False}]&quot;
    &quot;&quot;&quot;
    ps_cmd = []
    settings = _prepare_settings(name, settings)

    if not settings:
        log.warning(&quot;No settings provided&quot;)
        return False

    # Treat all values as strings for the purpose of comparing them to existing values.
    for idx, setting in enumerate(settings):
        if setting[&quot;name&quot;].split(&quot;.&quot;)[-1] != &quot;Collection&quot;:
            settings[idx][&quot;value&quot;] = str(setting[&quot;value&quot;])

    current_settings = get_webconfiguration_settings(name=name, settings=settings)

    if settings == current_settings:
        log.debug(&quot;Settings already contain the provided values.&quot;)
        return True

    for setting in settings:
        # If the value is numeric, don't treat it as a string in PowerShell.
        if setting[&quot;name&quot;].split(&quot;.&quot;)[-1] != &quot;Collection&quot;:
            try:
                complex(setting[&quot;value&quot;])
                value = setting[&quot;value&quot;]
            except ValueError:
                value = &quot;'{}'&quot;.format(setting[&quot;value&quot;])
        else:
            configelement_list = []
            for value_item in setting[&quot;value&quot;]:
                configelement_construct = []
                for key, value in value_item.items():
                    configelement_construct.append(&quot;{}='{}'&quot;.format(key, value))
                configelement_list.append(
                    &quot;@{&quot; + &quot;;&quot;.join(configelement_construct) + &quot;}&quot;
                )
            value = &quot;,&quot;.join(configelement_list)

        ps_cmd.extend(
            [
                &quot;Set-WebConfigurationProperty&quot;,
                &quot;-PSPath&quot;,
                &quot;'{}'&quot;.format(name),
                &quot;-Filter&quot;,
                &quot;'{}'&quot;.format(setting[&quot;filter&quot;]),
                &quot;-Name&quot;,
                &quot;'{}'&quot;.format(setting[&quot;name&quot;]),
                &quot;-Value&quot;,
                &quot;{};&quot;.format(value),
            ]
        )

    cmd_ret = _srvmgr(ps_cmd)

    if cmd_ret[&quot;retcode&quot;] != 0:
        msg = &quot;Unable to set settings for {}&quot;.format(name)
        raise CommandExecutionError(msg)

    # Get the fields post-change so that we can verify tht all values
    # were modified successfully. Track the ones that weren't.
    new_settings = get_webconfiguration_settings(name=name, settings=settings)

    failed_settings = []

    for idx, setting in enumerate(settings):

        is_collection = setting[&quot;name&quot;].split(&quot;.&quot;)[-1] == &quot;Collection&quot;

        if (
            not is_collection
            and str(setting[&quot;value&quot;]) != str(new_settings[idx][&quot;value&quot;])
        ) or (
            is_collection
            and list(map(dict, setting[&quot;value&quot;]))
            != list(map(dict, new_settings[idx][&quot;value&quot;]))
        ):
            failed_settings.append(setting)

    if failed_settings:
        log.error(&quot;Failed to change settings: %s&quot;, failed_settings)
        return False

    log.debug(&quot;Settings configured successfully: %s&quot;, settings)
    return True
</PRE>
</div>
  </div>
</body>
</html>
