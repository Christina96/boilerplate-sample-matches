
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_operations.py</h3>
            <pre><code>1  import argparse
2  import json
3  import sys
4  from bitstring import BitStream
5  import esptool
6  from . import base_fields
7  from . import util
8  def add_common_commands(subparsers, efuses):
9      class ActionEfuseValuePair(argparse.Action):
10          def __init__(self, option_strings, dest, nargs=None, **kwargs):
11              self._nargs = nargs
12              self._choices = kwargs.get(&quot;efuse_choices&quot;)
13              self.efuses = kwargs.get(&quot;efuses&quot;)
14              del kwargs[&quot;efuse_choices&quot;]
15              del kwargs[&quot;efuses&quot;]
16              super(ActionEfuseValuePair, self).__init__(
17                  option_strings, dest, nargs=nargs, **kwargs
18              )
19          def __call__(self, parser, namespace, values, option_string=None):
20              def check_efuse_name(efuse_name, efuse_list):
21                  if efuse_name not in self._choices:
22                      raise esptool.FatalError(
23                          &quot;Invalid the efuse name &#x27;{}&#x27;. &quot;
24                          &quot;Available the efuse names: {}&quot;.format(
25                              efuse_name, self._choices
26                          )
27                      )
28              efuse_value_pairs = {}
29              if len(values) &gt; 1:
30                  if len(values) % 2:
31                      raise esptool.FatalError(
32                          &quot;The list does not have a valid pair (name value) {}&quot;.format(
33                              values
34                          )
35                      )
36                  for i in range(0, len(values), 2):
37                      efuse_name, new_value = values[i : i + 2 :]
38                      check_efuse_name(efuse_name, self._choices)
39                      check_arg = base_fields.CheckArgValue(self.efuses, efuse_name)
40                      efuse_value_pairs[efuse_name] = check_arg(new_value)
41              else:
42                  efuse_name = values[0]
43                  check_efuse_name(efuse_name, self._choices)
44                  check_arg = base_fields.CheckArgValue(self.efuses, efuse_name)
45                  efuse_value_pairs[efuse_name] = check_arg(None)
46              setattr(namespace, self.dest, efuse_value_pairs)
47      burn = subparsers.add_parser(
48          &quot;burn_efuse&quot;, help=&quot;Burn the efuse with the specified name&quot;
49      )
50      burn.add_argument(
51          &quot;name_value_pairs&quot;,
52          help=&quot;Name of efuse register and New value pairs to burn&quot;,
53          action=ActionEfuseValuePair,
54          nargs=&quot;+&quot;,
55          metavar=&quot;[EFUSE_NAME VALUE] [{} VALUE&quot;.format(
56              &quot; VALUE] [&quot;.join([e.name for e in efuses.efuses])
57          ),
58          efuse_choices=[e.name for e in efuses.efuses]
59          + [name for e in efuses.efuses for name in e.alt_names if name != &quot;&quot;],
60          efuses=efuses,
61      )
62      read_protect_efuse = subparsers.add_parser(
63          &quot;read_protect_efuse&quot;,
64          help=&quot;Disable readback for the efuse with the specified name&quot;,
65      )
66      read_protect_efuse.add_argument(
67          &quot;efuse_name&quot;,
68          help=&quot;Name of efuse register to burn&quot;,
69          nargs=&quot;+&quot;,
70          choices=[e.name for e in efuses.efuses if e.read_disable_bit is not None]
71          + [
72              name
73              for e in efuses.efuses
74              if e.read_disable_bit is not None
75              for name in e.alt_names
76              if name != &quot;&quot;
77          ],
78      )
79      write_protect_efuse = subparsers.add_parser(
80          &quot;write_protect_efuse&quot;,
81          help=&quot;Disable writing to the efuse with the specified name&quot;,
82      )
83      write_protect_efuse.add_argument(
84          &quot;efuse_name&quot;,
85          help=&quot;Name of efuse register to burn&quot;,
86          nargs=&quot;+&quot;,
87          choices=[e.name for e in efuses.efuses if e.write_disable_bit is not None]
88          + [
89              name
90              for e in efuses.efuses
91              if e.write_disable_bit is not None
92              for name in e.alt_names
93              if name != &quot;&quot;
94          ],
95      )
96      burn_block_data = subparsers.add_parser(
97          &quot;burn_block_data&quot;,
98          help=&quot;Burn non-key data to EFUSE blocks. &quot;
99          &quot;(Don&#x27;t use this command to burn key data for Flash Encryption or &quot;
100          &quot;ESP32 Secure Boot V1, as the byte order of keys is swapped (use burn_key)).&quot;,
101      )
102      add_force_write_always(burn_block_data)
103      burn_block_data.add_argument(
104          &quot;--offset&quot;, &quot;-o&quot;, help=&quot;Byte offset in the efuse block&quot;, type=int, default=0
105      )
106      burn_block_data.add_argument(
107          &quot;block&quot;,
108          help=&quot;Efuse block to burn.&quot;,
109          action=&quot;append&quot;,
110          choices=efuses.BURN_BLOCK_DATA_NAMES,
111      )
112      burn_block_data.add_argument(
113          &quot;datafile&quot;,
114          help=&quot;File containing data to burn into the efuse block&quot;,
115          action=&quot;append&quot;,
116          type=argparse.FileType(&quot;rb&quot;),
117      )
118      for _ in range(0, len(efuses.BURN_BLOCK_DATA_NAMES)):
119          burn_block_data.add_argument(
120              &quot;block&quot;,
121              help=&quot;Efuse block to burn.&quot;,
122              metavar=&quot;BLOCK&quot;,
123              nargs=&quot;?&quot;,
124              action=&quot;append&quot;,
125              choices=efuses.BURN_BLOCK_DATA_NAMES,
126          )
127          burn_block_data.add_argument(
128              &quot;datafile&quot;,
129              nargs=&quot;?&quot;,
130              help=&quot;File containing data to burn into the efuse block&quot;,
131              metavar=&quot;DATAFILE&quot;,
132              action=&quot;append&quot;,
133              type=argparse.FileType(&quot;rb&quot;),
134          )
135      set_bit_cmd = subparsers.add_parser(&quot;burn_bit&quot;, help=&quot;Burn bit in the efuse block.&quot;)
136      add_force_write_always(set_bit_cmd)
137      set_bit_cmd.add_argument(
138          &quot;block&quot;, help=&quot;Efuse block to burn.&quot;, choices=efuses.BURN_BLOCK_DATA_NAMES
139      )
140      set_bit_cmd.add_argument(
141          &quot;bit_number&quot;,
142          help=&quot;Bit number in the efuse block [0..BLK_LEN-1]&quot;,
143          nargs=&quot;+&quot;,
144          type=int,
145      )
146      subparsers.add_parser(
147          &quot;adc_info&quot;,
148          help=&quot;Display information about ADC calibration data stored in efuse.&quot;,
149      )
150      dump_cmd = subparsers.add_parser(&quot;dump&quot;, help=&quot;Dump raw hex values of all efuses&quot;)
151      dump_cmd.add_argument(
152          &quot;--file_name&quot;,
153          help=&quot;Saves dump for each block into separate file. Provide the common &quot;
154          &quot;path name /path/blk.bin, it will create: blk0.bin, blk1.bin ... blkN.bin. &quot;
155          &quot;Use burn_block_data to write it back to another chip.&quot;,
156      )
157      summary_cmd = subparsers.add_parser(
158          &quot;summary&quot;, help=&quot;Print human-readable summary of efuse values&quot;
159      )
160      summary_cmd.add_argument(
161          &quot;--format&quot;,
162          help=&quot;Select the summary format&quot;,
163          choices=[&quot;summary&quot;, &quot;json&quot;],
164          default=&quot;summary&quot;,
165      )
166      summary_cmd.add_argument(
167          &quot;--file&quot;,
168          help=&quot;File to save the efuse summary&quot;,
169          type=argparse.FileType(&quot;w&quot;),
170          default=sys.stdout,
171      )
172      execute_scripts = subparsers.add_parser(
173          &quot;execute_scripts&quot;, help=&quot;Executes scripts to burn at one time.&quot;
174      )
175      execute_scripts.add_argument(
176          &quot;scripts&quot;,
177          help=&quot;The special format of python scripts.&quot;,
178          nargs=&quot;+&quot;,
179          type=argparse.FileType(&quot;r&quot;),
180      )
181      execute_scripts.add_argument(
182          &quot;--index&quot;,
183          help=&quot;integer index. &quot;
184          &quot;It allows to retrieve unique data per chip from configfiles &quot;
185          &quot;and then burn them (ex. CUSTOM_MAC, UNIQUE_ID).&quot;,
186          type=int,
187      )
188      execute_scripts.add_argument(
189          &quot;--configfiles&quot;,
190          help=&quot;List of configfiles with data&quot;,
191          nargs=&quot;?&quot;,
192          action=&quot;append&quot;,
193          type=argparse.FileType(&quot;r&quot;),
194      )
195      check_error_cmd = subparsers.add_parser(&quot;check_error&quot;, help=&quot;Checks eFuse errors&quot;)
196      check_error_cmd.add_argument(
197          &quot;--recovery&quot;,
198          help=&quot;Recovery of BLOCKs after encoding errors&quot;,
199          action=&quot;store_true&quot;,
200      )
201  def add_force_write_always(p):
202      p.add_argument(
203          &quot;--force-write-always&quot;,
204          help=&quot;Write the efuse even if it looks like it&#x27;s already been written, &quot;
205          &quot;or is write protected. Note that this option can&#x27;t disable write protection, &quot;
206          &quot;or clear any bit which has already been set.&quot;,
207          action=&quot;store_true&quot;,
208      )
209  def add_show_sensitive_info_option(p):
210      p.add_argument(
211          &quot;--show-sensitive-info&quot;,
212          help=&quot;Show data to be burned (may expose sensitive data). &quot;
213          &quot;Enabled if --debug is used.&quot;,
214          action=&quot;store_true&quot;,
215          default=False,
216      )
217  def summary(esp, efuses, args):
218      ROW_FORMAT = &quot;%-50s %-50s%s = %s %s %s&quot;
219      human_output = args.format == &quot;summary&quot;
220      json_efuse = {}
221      if args.file != sys.stdout:
222          print(&quot;Saving efuse values to &quot; + args.file.name)
223      if human_output:
224          print(
225              ROW_FORMAT.replace(&quot;-50&quot;, &quot;-12&quot;)
226              % (
227                  &quot;EFUSE_NAME (Block)&quot;,
228                  &quot;Description&quot;,
229                  &quot;&quot;,
230                  &quot;[Meaningful Value]&quot;,
231                  &quot;[Readable/Writeable]&quot;,
232                  &quot;(Hex Value)&quot;,
233              ),
234              file=args.file,
235          )
236          print(&quot;-&quot; * 88, file=args.file)
237      for category in sorted(set(e.category for e in efuses), key=lambda c: c.title()):
238          if human_output:
239              print(&quot;%s fuses:&quot; % category.title(), file=args.file)
240          for e in (e for e in efuses if e.category == category):
241              if e.efuse_type.startswith(&quot;bytes&quot;):
242                  raw = &quot;&quot;
243              else:
244                  raw = &quot;({})&quot;.format(e.get_bitstring())
245              (readable, writeable) = (e.is_readable(), e.is_writeable())
246              if readable and writeable:
247                  perms = &quot;R/W&quot;
248              elif readable:
249                  perms = &quot;R/-&quot;
250              elif writeable:
251                  perms = &quot;-/W&quot;
252              else:
253                  perms = &quot;-/-&quot;
254              base_value = e.get_meaning()
255              value = str(base_value)
256              if not readable:
257                  count_read_disable_bits = e.get_count_read_disable_bits()
258                  if count_read_disable_bits == 2:
259                      v = [value[: (len(value) // 2)], value[(len(value) // 2) :]]
260                      for i in range(count_read_disable_bits):
261                          if not e.is_readable(blk_part=i):
262                              v[i] = v[i].replace(&quot;0&quot;, &quot;?&quot;)
263                      value = &quot;&quot;.join(v)
264                  else:
265                      value = value.replace(&quot;0&quot;, &quot;?&quot;)
266              if human_output:
267                  print(
268                      ROW_FORMAT
269                      % (
270                          e.get_info(),
271                          e.description[:50],
272                          &quot;\n  &quot; if len(value) &gt; 20 else &quot;&quot;,
273                          value,
274                          perms,
275                          raw,
276                      ),
277                      file=args.file,
278                  )
279                  desc_len = len(e.description[50:])
280                  if desc_len:
281                      desc_len += 50
282                      for i in range(50, desc_len, 50):
283                          print(
284                              &quot;%-50s %-50s&quot; % (&quot;&quot;, e.description[i : (50 + i)]),
285                              file=args.file,
286                          )
287              if args.format == &quot;json&quot;:
288                  json_efuse[e.name] = {
289                      &quot;name&quot;: e.name,
290                      &quot;value&quot;: base_value if readable else value,
291                      &quot;readable&quot;: readable,
292                      &quot;writeable&quot;: writeable,
293                      &quot;description&quot;: e.description,
294                      &quot;category&quot;: e.category,
295                      &quot;block&quot;: e.block,
296                      &quot;word&quot;: e.word,
297                      &quot;pos&quot;: e.pos,
298                      &quot;efuse_type&quot;: e.efuse_type,
299                      &quot;bit_len&quot;: e.bit_len,
300                  }
301          if human_output:
302              print(&quot;&quot;, file=args.file)
303      if human_output:
304          print(efuses.summary(), file=args.file)
305          warnings = efuses.get_coding_scheme_warnings()
306          if warnings:
307              print(
308                  &quot;WARNING: Coding scheme has encoding bit error warnings&quot;, file=args.file
309              )
310          if args.file != sys.stdout:
311              args.file.close()
312              print(&quot;Done&quot;)
313      if args.format == &quot;json&quot;:
314          json.dump(json_efuse, args.file, sort_keys=True, indent=4)
315          print(&quot;&quot;)
316  def dump(esp, efuses, args):
317      if args.file_name:
318          for block in efuses.blocks:
319              file_dump_name = args.file_name
320              place_for_index = file_dump_name.find(&quot;.bin&quot;)
321              file_dump_name = (
322                  file_dump_name[:place_for_index]
323                  + str(block.id)
324                  + file_dump_name[place_for_index:]
325              )
326              print(file_dump_name)
327              with open(file_dump_name, &quot;wb&quot;) as f:
328                  block.get_bitstring().byteswap()
329                  block.get_bitstring().tofile(f)
330  def burn_efuse(esp, efuses, args):
331      def print_attention(blocked_efuses_after_burn):
332          if len(blocked_efuses_after_burn):
333              print(
334                  &quot;    ATTENTION! This BLOCK uses NOT the NONE coding scheme &quot;
335                  &quot;and after &#x27;BURN&#x27;, these efuses can not be burned in the feature:&quot;
336              )
337              for i in range(0, len(blocked_efuses_after_burn), 5):
338                  print(
339                      &quot;              &quot;,
340                      &quot;&quot;.join(&quot;{}&quot;.format(blocked_efuses_after_burn[i : i + 5 :])),
341                  )
342      efuse_name_list = [name for name in args.name_value_pairs.keys()]
343      burn_efuses_list = [efuses[name] for name in efuse_name_list]
344      old_value_list = [efuses[name].get_raw() for name in efuse_name_list]
345      new_value_list = [value for value in args.name_value_pairs.values()]
346      util.check_duplicate_name_in_list(efuse_name_list)
347      attention = &quot;&quot;
348      print(&quot;The efuses to burn:&quot;)
349      for block in efuses.blocks:
350          burn_list_a_block = [e for e in burn_efuses_list if e.block == block.id]
351          if len(burn_list_a_block):
352              print(&quot;  from BLOCK%d&quot; % (block.id))
353              for field in burn_list_a_block:
354                  print(&quot;     - %s&quot; % (field.name))
355                  if (
356                      efuses.blocks[field.block].get_coding_scheme()
357                      != efuses.REGS.CODING_SCHEME_NONE
358                  ):
359                      using_the_same_block_names = [
360                          e.name for e in efuses if e.block == field.block
361                      ]
362                      wr_names = [e.name for e in burn_list_a_block]
363                      blocked_efuses_after_burn = [
364                          name
365                          for name in using_the_same_block_names
366                          if name not in wr_names
367                      ]
368                      attention = &quot; (see &#x27;ATTENTION!&#x27; above)&quot;
369              if attention:
370                  print_attention(blocked_efuses_after_burn)
371      print(&quot;\nBurning efuses{}:&quot;.format(attention))
372      for efuse, new_value in zip(burn_efuses_list, new_value_list):
373          print(
374              &quot;\n    - &#x27;{}&#x27; ({}) {} -&gt; {}&quot;.format(
375                  efuse.name,
376                  efuse.description,
377                  efuse.get_bitstring(),
378                  efuse.convert_to_bitstring(new_value),
379              )
380          )
381          efuse.save(new_value)
382      print()
383      if &quot;ENABLE_SECURITY_DOWNLOAD&quot; in efuse_name_list:
384          print(
385              &quot;ENABLE_SECURITY_DOWNLOAD -&gt; 1: eFuses will not be read back &quot;
386              &quot;for confirmation because this mode disables &quot;
387              &quot;any SRAM and register operations.&quot;
388          )
389          print(&quot;                               espefuse will not work.&quot;)
390          print(&quot;                               esptool can read/write only flash.&quot;)
391      if &quot;DIS_DOWNLOAD_MODE&quot; in efuse_name_list:
392          print(
393              &quot;DIS_DOWNLOAD_MODE -&gt; 1: eFuses will not be read back for &quot;
394              &quot;confirmation because this mode disables any communication with the chip.&quot;
395          )
396          print(
397              &quot;                        espefuse/esptool will not work because &quot;
398              &quot;they will not be able to connect to the chip.&quot;
399          )
400      if (
401          esp.CHIP_NAME == &quot;ESP32&quot;
402          and esp.get_chip_revision() &gt;= 300
403          and &quot;UART_DOWNLOAD_DIS&quot; in efuse_name_list
404      ):
405          print(
406              &quot;UART_DOWNLOAD_DIS -&gt; 1: eFuses will be read for confirmation, &quot;
407              &quot;but after that connection to the chip will become impossible.&quot;
408          )
409          print(&quot;                        espefuse/esptool will not work.&quot;)
410      if not efuses.burn_all(check_batch_mode=True):
411          return
412      print(&quot;Checking efuses...&quot;)
413      raise_error = False
414      for efuse, old_value, new_value in zip(
415          burn_efuses_list, old_value_list, new_value_list
416      ):
417          if not efuse.is_readable():
418              print(
419                  &quot;Efuse %s is read-protected. Read back the burn value is not possible.&quot;
420                  % efuse.name
421              )
422          else:
423              new_value = efuse.convert_to_bitstring(new_value)
424              burned_value = efuse.get_bitstring()
425              if burned_value != new_value:
426                  print(
427                      burned_value,
428                      &quot;-&gt;&quot;,
429                      new_value,
430                      &quot;Efuse %s failed to burn. Protected?&quot; % efuse.name,
431                  )
432                  raise_error = True
433      if raise_error:
434          raise esptool.FatalError(&quot;The burn was not successful.&quot;)
435      else:
436          print(&quot;Successful&quot;)
437  def read_protect_efuse(esp, efuses, args):
438      util.check_duplicate_name_in_list(args.efuse_name)
439      for efuse_name in args.efuse_name:
<span onclick='openModal()' class='match'>440          efuse = efuses[efuse_name]
441          if not efuse.is_readable():
442              print(&quot;Efuse %s is already read protected&quot; % efuse.name)
443          else:
444              if esp.CHIP_NAME == &quot;ESP32&quot;:
</span>445                  if (
446                      efuse_name == &quot;BLOCK2&quot;
447                      and not efuses[&quot;ABS_DONE_0&quot;].get()
448                      and esp.get_chip_revision() &gt;= 300
449                  ):
450                      if efuses[&quot;ABS_DONE_1&quot;].get():
451                          raise esptool.FatalError(
452                              &quot;Secure Boot V2 is on (ABS_DONE_1 = True), &quot;
453                              &quot;BLOCK2 must be readable, stop this operation!&quot;
454                          )
455                      else:
456                          print(
457                              &quot;If Secure Boot V2 is used, BLOCK2 must be readable, &quot;
458                              &quot;please stop this operation!&quot;
459                          )
460              elif esp.CHIP_NAME == &quot;ESP32-C2&quot;:
461                  error = (
462                      not efuses[&quot;XTS_KEY_LENGTH_256&quot;].get()
463                      and efuse_name == &quot;BLOCK_KEY0&quot;
464                  )
465                  error |= efuses[&quot;SECURE_BOOT_EN&quot;].get() and efuse_name in [
466                      &quot;BLOCK_KEY0&quot;,
467                      &quot;BLOCK_KEY0_HI_128&quot;,
468                  ]
469                  if error:
470                      raise esptool.FatalError(
471                          &quot;%s must be readable, stop this operation!&quot; % efuse_name
472                      )
473              else:
474                  for block in efuses.Blocks.BLOCKS:
475                      block = efuses.Blocks.get(block)
476                      if block.name == efuse_name and block.key_purpose is not None:
477                          if not efuses[block.key_purpose].need_rd_protect(
478                              efuses[block.key_purpose].get()
479                          ):
480                              raise esptool.FatalError(
481                                  &quot;%s must be readable, stop this operation!&quot; % efuse_name
482                              )
483                          break
484              all_disabling = [
485                  e for e in efuses if e.read_disable_bit == efuse.read_disable_bit
486              ]
487              names = &quot;, &quot;.join(e.name for e in all_disabling)
488              print(
489                  &quot;Permanently read-disabling efuse%s %s&quot;
490                  % (&quot;s&quot; if len(all_disabling) &gt; 1 else &quot;&quot;, names)
491              )
492              efuse.disable_read()
493      if not efuses.burn_all(check_batch_mode=True):
494          return
495      print(&quot;Checking efuses...&quot;)
496      raise_error = False
497      for efuse_name in args.efuse_name:
498          efuse = efuses[efuse_name]
499          if efuse.is_readable():
500              print(&quot;Efuse %s is not read-protected.&quot; % efuse.name)
501              raise_error = True
502      if raise_error:
503          raise esptool.FatalError(&quot;The burn was not successful.&quot;)
504      else:
505          print(&quot;Successful&quot;)
506  def write_protect_efuse(esp, efuses, args):
507      util.check_duplicate_name_in_list(args.efuse_name)
508      for efuse_name in args.efuse_name:
509          efuse = efuses[efuse_name]
510          if not efuse.is_writeable():
511              print(&quot;Efuse %s is already write protected&quot; % efuse.name)
512          else:
513              all_disabling = [
514                  e for e in efuses if e.write_disable_bit == efuse.write_disable_bit
515              ]
516              names = &quot;, &quot;.join(e.name for e in all_disabling)
517              print(
518                  &quot;Permanently write-disabling efuse%s %s&quot;
519                  % (&quot;s&quot; if len(all_disabling) &gt; 1 else &quot;&quot;, names)
520              )
521              efuse.disable_write()
522      if not efuses.burn_all(check_batch_mode=True):
523          return
524      print(&quot;Checking efuses...&quot;)
525      raise_error = False
526      for efuse_name in args.efuse_name:
527          efuse = efuses[efuse_name]
528          if efuse.is_writeable():
529              print(&quot;Efuse %s is not write-protected.&quot; % efuse.name)
530              raise_error = True
531      if raise_error:
532          raise esptool.FatalError(&quot;The burn was not successful.&quot;)
533      else:
534          print(&quot;Successful&quot;)
535  def burn_block_data(esp, efuses, args):
536      block_name_list = args.block[
537          0 : len([name for name in args.block if name is not None]) :
538      ]
539      datafile_list = args.datafile[
540          0 : len([name for name in args.datafile if name is not None]) :
541      ]
542      efuses.force_write_always = args.force_write_always
543      util.check_duplicate_name_in_list(block_name_list)
544      if args.offset and len(block_name_list) &gt; 1:
545          raise esptool.FatalError(
546              &quot;The &#x27;offset&#x27; option is not applicable when a few blocks are passed. &quot;
547              &quot;With &#x27;offset&#x27;, should only one block be used.&quot;
548          )
549      else:
550          offset = args.offset
551          if offset:
552              num_block = efuses.get_index_block_by_name(block_name_list[0])
553              block = efuses.blocks[num_block]
554              num_bytes = block.get_block_len()
555              if offset &gt;= num_bytes:
556                  raise esptool.FatalError(
557                      &quot;Invalid offset: the block%d only holds %d bytes.&quot;
558                      % (block.id, num_bytes)
559                  )
560      if len(block_name_list) != len(datafile_list):
561          raise esptool.FatalError(
562              &quot;The number of block_name (%d) and datafile (%d) should be the same.&quot;
563              % (len(block_name_list), len(datafile_list))
564          )
565      for block_name, datafile in zip(block_name_list, datafile_list):
566          num_block = efuses.get_index_block_by_name(block_name)
567          block = efuses.blocks[num_block]
568          data = datafile.read()
569          num_bytes = block.get_block_len()
570          if offset != 0:
571              data = (b&quot;\x00&quot; * offset) + data
572              data = data + (b&quot;\x00&quot; * (num_bytes - len(data)))
573          if len(data) != num_bytes:
574              raise esptool.FatalError(
575                  &quot;Data does not fit: the block%d size is %d bytes, &quot;
576                  &quot;data file is %d bytes, offset %d&quot;
577                  % (block.id, num_bytes, len(data), offset)
578              )
579          print(
580              &quot;[{:02}] {:20} size={:02} bytes, offset={:02} - &gt; [{}].&quot;.format(
581                  block.id, block.name, len(data), offset, util.hexify(data, &quot; &quot;)
582              )
583          )
584          block.save(data)
585      if not efuses.burn_all(check_batch_mode=True):
586          return
587      print(&quot;Successful&quot;)
588  def burn_bit(esp, efuses, args):
589      efuses.force_write_always = args.force_write_always
590      num_block = efuses.get_index_block_by_name(args.block)
591      block = efuses.blocks[num_block]
592      data_block = BitStream(block.get_block_len() * 8)
593      data_block.set(0)
594      try:
595          data_block.set(True, args.bit_number)
596      except IndexError:
597          raise esptool.FatalError(
598              &quot;%s has bit_number in [0..%d]&quot; % (args.block, data_block.len - 1)
599          )
600      data_block.reverse()
601      print(
602          &quot;bit_number:   &quot;
603          &quot;[%-03d]........................................................[0]&quot;
604          % (data_block.len - 1)
605      )
606      print(&quot;BLOCK%-2d   :&quot; % block.id, data_block)
607      block.print_block(data_block, &quot;regs_to_write&quot;, debug=True)
608      block.save(data_block.bytes[::-1])
609      if not efuses.burn_all(check_batch_mode=True):
610          return
611      print(&quot;Successful&quot;)
612  def get_error_summary(efuses):
613      error_in_blocks = efuses.get_coding_scheme_warnings()
614      if not error_in_blocks:
615          return False
616      writable = True
617      for blk in efuses.blocks:
618          if blk.fail or blk.num_errors:
619              if blk.id == 0:
620                  for field in efuses:
621                      if field.block == blk.id and (field.fail or field.num_errors):
622                          wr = &quot;writable&quot; if field.is_writeable() else &quot;not writable&quot;
623                          writable &amp;= wr == &quot;writable&quot;
624                          name = field.name
625                          val = field.get()
626                          print(f&quot;BLOCK{field.block:&lt;2}: {name:&lt;40} = {val:&lt;8} ({wr})&quot;)
627              else:
628                  wr = &quot;writable&quot; if blk.is_writeable() else &quot;not writable&quot;
629                  writable &amp;= wr == &quot;writable&quot;
630                  name = f&quot;{blk.name} [ERRORS:{blk.num_errors} FAIL:{int(blk.fail)}]&quot;
631                  val = str(blk.get_bitstring())
632                  print(f&quot;BLOCK{blk.id:&lt;2}: {name:&lt;40} = {val:&lt;8} ({wr})&quot;)
633      if not writable and error_in_blocks:
634          print(&quot;Not all errors can be fixed because some fields are write-protected!&quot;)
635      return True
636  def check_error(esp, efuses, args):
637      error_in_blocks = get_error_summary(efuses)
638      if args.recovery and error_in_blocks:
639          confirmed = False
640          for block in reversed(efuses.blocks):
641              if block.fail or block.num_errors &gt; 0:
642                  if not block.get_bitstring().all(False):
643                      block.save(block.get_bitstring().bytes[::-1])
644                      if not confirmed:
645                          confirmed = True
646                          efuses.confirm(
647                              &quot;Recovery of block coding errors&quot;, args.do_not_confirm
648                          )
649                      block.burn()
650          if confirmed:
651              efuses.update_efuses()
652          error_in_blocks = get_error_summary(efuses)
653      if error_in_blocks:
654          raise esptool.FatalError(&quot;Error(s) were detected in eFuses&quot;)
655      print(&quot;No errors detected&quot;)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_operations.py</h3>
            <pre><code>1  import argparse
2  import json
3  import sys
4  from bitstring import BitStream
5  import esptool
6  from . import base_fields
7  from . import util
8  def add_common_commands(subparsers, efuses):
9      class ActionEfuseValuePair(argparse.Action):
10          def __init__(self, option_strings, dest, nargs=None, **kwargs):
11              self._nargs = nargs
12              self._choices = kwargs.get(&quot;efuse_choices&quot;)
13              self.efuses = kwargs.get(&quot;efuses&quot;)
14              del kwargs[&quot;efuse_choices&quot;]
15              del kwargs[&quot;efuses&quot;]
16              super(ActionEfuseValuePair, self).__init__(
17                  option_strings, dest, nargs=nargs, **kwargs
18              )
19          def __call__(self, parser, namespace, values, option_string=None):
20              def check_efuse_name(efuse_name, efuse_list):
21                  if efuse_name not in self._choices:
22                      raise esptool.FatalError(
23                          &quot;Invalid the efuse name &#x27;{}&#x27;. &quot;
24                          &quot;Available the efuse names: {}&quot;.format(
25                              efuse_name, self._choices
26                          )
27                      )
28              efuse_value_pairs = {}
29              if len(values) &gt; 1:
30                  if len(values) % 2:
31                      raise esptool.FatalError(
32                          &quot;The list does not have a valid pair (name value) {}&quot;.format(
33                              values
34                          )
35                      )
36                  for i in range(0, len(values), 2):
37                      efuse_name, new_value = values[i : i + 2 :]
38                      check_efuse_name(efuse_name, self._choices)
39                      check_arg = base_fields.CheckArgValue(self.efuses, efuse_name)
40                      efuse_value_pairs[efuse_name] = check_arg(new_value)
41              else:
42                  efuse_name = values[0]
43                  check_efuse_name(efuse_name, self._choices)
44                  check_arg = base_fields.CheckArgValue(self.efuses, efuse_name)
45                  efuse_value_pairs[efuse_name] = check_arg(None)
46              setattr(namespace, self.dest, efuse_value_pairs)
47      burn = subparsers.add_parser(
48          &quot;burn_efuse&quot;, help=&quot;Burn the efuse with the specified name&quot;
49      )
50      burn.add_argument(
51          &quot;name_value_pairs&quot;,
52          help=&quot;Name of efuse register and New value pairs to burn&quot;,
53          action=ActionEfuseValuePair,
54          nargs=&quot;+&quot;,
55          metavar=&quot;[EFUSE_NAME VALUE] [{} VALUE&quot;.format(
56              &quot; VALUE] [&quot;.join([e.name for e in efuses.efuses])
57          ),
58          efuse_choices=[e.name for e in efuses.efuses]
59          + [name for e in efuses.efuses for name in e.alt_names if name != &quot;&quot;],
60          efuses=efuses,
61      )
62      read_protect_efuse = subparsers.add_parser(
63          &quot;read_protect_efuse&quot;,
64          help=&quot;Disable readback for the efuse with the specified name&quot;,
65      )
66      read_protect_efuse.add_argument(
67          &quot;efuse_name&quot;,
68          help=&quot;Name of efuse register to burn&quot;,
69          nargs=&quot;+&quot;,
70          choices=[e.name for e in efuses.efuses if e.read_disable_bit is not None]
71          + [
72              name
73              for e in efuses.efuses
74              if e.read_disable_bit is not None
75              for name in e.alt_names
76              if name != &quot;&quot;
77          ],
78      )
79      write_protect_efuse = subparsers.add_parser(
80          &quot;write_protect_efuse&quot;,
81          help=&quot;Disable writing to the efuse with the specified name&quot;,
82      )
83      write_protect_efuse.add_argument(
84          &quot;efuse_name&quot;,
85          help=&quot;Name of efuse register to burn&quot;,
86          nargs=&quot;+&quot;,
87          choices=[e.name for e in efuses.efuses if e.write_disable_bit is not None]
88          + [
89              name
90              for e in efuses.efuses
91              if e.write_disable_bit is not None
92              for name in e.alt_names
93              if name != &quot;&quot;
94          ],
95      )
96      burn_block_data = subparsers.add_parser(
97          &quot;burn_block_data&quot;,
98          help=&quot;Burn non-key data to EFUSE blocks. &quot;
99          &quot;(Don&#x27;t use this command to burn key data for Flash Encryption or &quot;
100          &quot;ESP32 Secure Boot V1, as the byte order of keys is swapped (use burn_key)).&quot;,
101      )
102      add_force_write_always(burn_block_data)
103      burn_block_data.add_argument(
104          &quot;--offset&quot;, &quot;-o&quot;, help=&quot;Byte offset in the efuse block&quot;, type=int, default=0
105      )
106      burn_block_data.add_argument(
107          &quot;block&quot;,
108          help=&quot;Efuse block to burn.&quot;,
109          action=&quot;append&quot;,
110          choices=efuses.BURN_BLOCK_DATA_NAMES,
111      )
112      burn_block_data.add_argument(
113          &quot;datafile&quot;,
114          help=&quot;File containing data to burn into the efuse block&quot;,
115          action=&quot;append&quot;,
116          type=argparse.FileType(&quot;rb&quot;),
117      )
118      for _ in range(0, len(efuses.BURN_BLOCK_DATA_NAMES)):
119          burn_block_data.add_argument(
120              &quot;block&quot;,
121              help=&quot;Efuse block to burn.&quot;,
122              metavar=&quot;BLOCK&quot;,
123              nargs=&quot;?&quot;,
124              action=&quot;append&quot;,
125              choices=efuses.BURN_BLOCK_DATA_NAMES,
126          )
127          burn_block_data.add_argument(
128              &quot;datafile&quot;,
129              nargs=&quot;?&quot;,
130              help=&quot;File containing data to burn into the efuse block&quot;,
131              metavar=&quot;DATAFILE&quot;,
132              action=&quot;append&quot;,
133              type=argparse.FileType(&quot;rb&quot;),
134          )
135      set_bit_cmd = subparsers.add_parser(&quot;burn_bit&quot;, help=&quot;Burn bit in the efuse block.&quot;)
136      add_force_write_always(set_bit_cmd)
137      set_bit_cmd.add_argument(
138          &quot;block&quot;, help=&quot;Efuse block to burn.&quot;, choices=efuses.BURN_BLOCK_DATA_NAMES
139      )
140      set_bit_cmd.add_argument(
141          &quot;bit_number&quot;,
142          help=&quot;Bit number in the efuse block [0..BLK_LEN-1]&quot;,
143          nargs=&quot;+&quot;,
144          type=int,
145      )
146      subparsers.add_parser(
147          &quot;adc_info&quot;,
148          help=&quot;Display information about ADC calibration data stored in efuse.&quot;,
149      )
150      dump_cmd = subparsers.add_parser(&quot;dump&quot;, help=&quot;Dump raw hex values of all efuses&quot;)
151      dump_cmd.add_argument(
152          &quot;--file_name&quot;,
153          help=&quot;Saves dump for each block into separate file. Provide the common &quot;
154          &quot;path name /path/blk.bin, it will create: blk0.bin, blk1.bin ... blkN.bin. &quot;
155          &quot;Use burn_block_data to write it back to another chip.&quot;,
156      )
157      summary_cmd = subparsers.add_parser(
158          &quot;summary&quot;, help=&quot;Print human-readable summary of efuse values&quot;
159      )
160      summary_cmd.add_argument(
161          &quot;--format&quot;,
162          help=&quot;Select the summary format&quot;,
163          choices=[&quot;summary&quot;, &quot;json&quot;],
164          default=&quot;summary&quot;,
165      )
166      summary_cmd.add_argument(
167          &quot;--file&quot;,
168          help=&quot;File to save the efuse summary&quot;,
169          type=argparse.FileType(&quot;w&quot;),
170          default=sys.stdout,
171      )
172      execute_scripts = subparsers.add_parser(
173          &quot;execute_scripts&quot;, help=&quot;Executes scripts to burn at one time.&quot;
174      )
175      execute_scripts.add_argument(
176          &quot;scripts&quot;,
177          help=&quot;The special format of python scripts.&quot;,
178          nargs=&quot;+&quot;,
179          type=argparse.FileType(&quot;r&quot;),
180      )
181      execute_scripts.add_argument(
182          &quot;--index&quot;,
183          help=&quot;integer index. &quot;
184          &quot;It allows to retrieve unique data per chip from configfiles &quot;
185          &quot;and then burn them (ex. CUSTOM_MAC, UNIQUE_ID).&quot;,
186          type=int,
187      )
188      execute_scripts.add_argument(
189          &quot;--configfiles&quot;,
190          help=&quot;List of configfiles with data&quot;,
191          nargs=&quot;?&quot;,
192          action=&quot;append&quot;,
193          type=argparse.FileType(&quot;r&quot;),
194      )
195      check_error_cmd = subparsers.add_parser(&quot;check_error&quot;, help=&quot;Checks eFuse errors&quot;)
196      check_error_cmd.add_argument(
197          &quot;--recovery&quot;,
198          help=&quot;Recovery of BLOCKs after encoding errors&quot;,
199          action=&quot;store_true&quot;,
200      )
201  def add_force_write_always(p):
202      p.add_argument(
203          &quot;--force-write-always&quot;,
204          help=&quot;Write the efuse even if it looks like it&#x27;s already been written, &quot;
205          &quot;or is write protected. Note that this option can&#x27;t disable write protection, &quot;
206          &quot;or clear any bit which has already been set.&quot;,
207          action=&quot;store_true&quot;,
208      )
209  def add_show_sensitive_info_option(p):
210      p.add_argument(
211          &quot;--show-sensitive-info&quot;,
212          help=&quot;Show data to be burned (may expose sensitive data). &quot;
213          &quot;Enabled if --debug is used.&quot;,
214          action=&quot;store_true&quot;,
215          default=False,
216      )
217  def summary(esp, efuses, args):
218      ROW_FORMAT = &quot;%-50s %-50s%s = %s %s %s&quot;
219      human_output = args.format == &quot;summary&quot;
220      json_efuse = {}
221      if args.file != sys.stdout:
222          print(&quot;Saving efuse values to &quot; + args.file.name)
223      if human_output:
224          print(
225              ROW_FORMAT.replace(&quot;-50&quot;, &quot;-12&quot;)
226              % (
227                  &quot;EFUSE_NAME (Block)&quot;,
228                  &quot;Description&quot;,
229                  &quot;&quot;,
230                  &quot;[Meaningful Value]&quot;,
231                  &quot;[Readable/Writeable]&quot;,
232                  &quot;(Hex Value)&quot;,
233              ),
234              file=args.file,
235          )
236          print(&quot;-&quot; * 88, file=args.file)
237      for category in sorted(set(e.category for e in efuses), key=lambda c: c.title()):
238          if human_output:
239              print(&quot;%s fuses:&quot; % category.title(), file=args.file)
240          for e in (e for e in efuses if e.category == category):
241              if e.efuse_type.startswith(&quot;bytes&quot;):
242                  raw = &quot;&quot;
243              else:
244                  raw = &quot;({})&quot;.format(e.get_bitstring())
245              (readable, writeable) = (e.is_readable(), e.is_writeable())
246              if readable and writeable:
247                  perms = &quot;R/W&quot;
248              elif readable:
249                  perms = &quot;R/-&quot;
250              elif writeable:
251                  perms = &quot;-/W&quot;
252              else:
253                  perms = &quot;-/-&quot;
254              base_value = e.get_meaning()
255              value = str(base_value)
256              if not readable:
257                  count_read_disable_bits = e.get_count_read_disable_bits()
258                  if count_read_disable_bits == 2:
259                      v = [value[: (len(value) // 2)], value[(len(value) // 2) :]]
260                      for i in range(count_read_disable_bits):
261                          if not e.is_readable(blk_part=i):
262                              v[i] = v[i].replace(&quot;0&quot;, &quot;?&quot;)
263                      value = &quot;&quot;.join(v)
264                  else:
265                      value = value.replace(&quot;0&quot;, &quot;?&quot;)
266              if human_output:
267                  print(
268                      ROW_FORMAT
269                      % (
270                          e.get_info(),
271                          e.description[:50],
272                          &quot;\n  &quot; if len(value) &gt; 20 else &quot;&quot;,
273                          value,
274                          perms,
275                          raw,
276                      ),
277                      file=args.file,
278                  )
279                  desc_len = len(e.description[50:])
280                  if desc_len:
281                      desc_len += 50
282                      for i in range(50, desc_len, 50):
283                          print(
284                              &quot;%-50s %-50s&quot; % (&quot;&quot;, e.description[i : (50 + i)]),
285                              file=args.file,
286                          )
287              if args.format == &quot;json&quot;:
288                  json_efuse[e.name] = {
289                      &quot;name&quot;: e.name,
290                      &quot;value&quot;: base_value if readable else value,
291                      &quot;readable&quot;: readable,
292                      &quot;writeable&quot;: writeable,
293                      &quot;description&quot;: e.description,
294                      &quot;category&quot;: e.category,
295                      &quot;block&quot;: e.block,
296                      &quot;word&quot;: e.word,
297                      &quot;pos&quot;: e.pos,
298                      &quot;efuse_type&quot;: e.efuse_type,
299                      &quot;bit_len&quot;: e.bit_len,
300                  }
301          if human_output:
302              print(&quot;&quot;, file=args.file)
303      if human_output:
304          print(efuses.summary(), file=args.file)
305          warnings = efuses.get_coding_scheme_warnings()
306          if warnings:
307              print(
308                  &quot;WARNING: Coding scheme has encoding bit error warnings&quot;, file=args.file
309              )
310          if args.file != sys.stdout:
311              args.file.close()
312              print(&quot;Done&quot;)
313      if args.format == &quot;json&quot;:
314          json.dump(json_efuse, args.file, sort_keys=True, indent=4)
315          print(&quot;&quot;)
316  def dump(esp, efuses, args):
317      if args.file_name:
318          for block in efuses.blocks:
319              file_dump_name = args.file_name
320              place_for_index = file_dump_name.find(&quot;.bin&quot;)
321              file_dump_name = (
322                  file_dump_name[:place_for_index]
323                  + str(block.id)
324                  + file_dump_name[place_for_index:]
325              )
326              print(file_dump_name)
327              with open(file_dump_name, &quot;wb&quot;) as f:
328                  block.get_bitstring().byteswap()
329                  block.get_bitstring().tofile(f)
330  def burn_efuse(esp, efuses, args):
331      def print_attention(blocked_efuses_after_burn):
332          if len(blocked_efuses_after_burn):
333              print(
334                  &quot;    ATTENTION! This BLOCK uses NOT the NONE coding scheme &quot;
335                  &quot;and after &#x27;BURN&#x27;, these efuses can not be burned in the feature:&quot;
336              )
337              for i in range(0, len(blocked_efuses_after_burn), 5):
338                  print(
339                      &quot;              &quot;,
340                      &quot;&quot;.join(&quot;{}&quot;.format(blocked_efuses_after_burn[i : i + 5 :])),
341                  )
342      efuse_name_list = [name for name in args.name_value_pairs.keys()]
343      burn_efuses_list = [efuses[name] for name in efuse_name_list]
344      old_value_list = [efuses[name].get_raw() for name in efuse_name_list]
345      new_value_list = [value for value in args.name_value_pairs.values()]
346      util.check_duplicate_name_in_list(efuse_name_list)
347      attention = &quot;&quot;
348      print(&quot;The efuses to burn:&quot;)
349      for block in efuses.blocks:
350          burn_list_a_block = [e for e in burn_efuses_list if e.block == block.id]
351          if len(burn_list_a_block):
352              print(&quot;  from BLOCK%d&quot; % (block.id))
353              for field in burn_list_a_block:
354                  print(&quot;     - %s&quot; % (field.name))
355                  if (
356                      efuses.blocks[field.block].get_coding_scheme()
357                      != efuses.REGS.CODING_SCHEME_NONE
358                  ):
359                      using_the_same_block_names = [
360                          e.name for e in efuses if e.block == field.block
361                      ]
362                      wr_names = [e.name for e in burn_list_a_block]
363                      blocked_efuses_after_burn = [
364                          name
365                          for name in using_the_same_block_names
366                          if name not in wr_names
367                      ]
368                      attention = &quot; (see &#x27;ATTENTION!&#x27; above)&quot;
369              if attention:
370                  print_attention(blocked_efuses_after_burn)
371      print(&quot;\nBurning efuses{}:&quot;.format(attention))
372      for efuse, new_value in zip(burn_efuses_list, new_value_list):
373          print(
374              &quot;\n    - &#x27;{}&#x27; ({}) {} -&gt; {}&quot;.format(
375                  efuse.name,
376                  efuse.description,
377                  efuse.get_bitstring(),
378                  efuse.convert_to_bitstring(new_value),
379              )
380          )
381          efuse.save(new_value)
382      print()
383      if &quot;ENABLE_SECURITY_DOWNLOAD&quot; in efuse_name_list:
384          print(
385              &quot;ENABLE_SECURITY_DOWNLOAD -&gt; 1: eFuses will not be read back &quot;
386              &quot;for confirmation because this mode disables &quot;
387              &quot;any SRAM and register operations.&quot;
388          )
389          print(&quot;                               espefuse will not work.&quot;)
390          print(&quot;                               esptool can read/write only flash.&quot;)
391      if &quot;DIS_DOWNLOAD_MODE&quot; in efuse_name_list:
392          print(
393              &quot;DIS_DOWNLOAD_MODE -&gt; 1: eFuses will not be read back for &quot;
394              &quot;confirmation because this mode disables any communication with the chip.&quot;
395          )
396          print(
397              &quot;                        espefuse/esptool will not work because &quot;
398              &quot;they will not be able to connect to the chip.&quot;
399          )
400      if (
401          esp.CHIP_NAME == &quot;ESP32&quot;
402          and esp.get_chip_revision() &gt;= 300
403          and &quot;UART_DOWNLOAD_DIS&quot; in efuse_name_list
404      ):
405          print(
406              &quot;UART_DOWNLOAD_DIS -&gt; 1: eFuses will be read for confirmation, &quot;
407              &quot;but after that connection to the chip will become impossible.&quot;
408          )
409          print(&quot;                        espefuse/esptool will not work.&quot;)
410      if not efuses.burn_all(check_batch_mode=True):
411          return
412      print(&quot;Checking efuses...&quot;)
413      raise_error = False
414      for efuse, old_value, new_value in zip(
415          burn_efuses_list, old_value_list, new_value_list
416      ):
417          if not efuse.is_readable():
418              print(
419                  &quot;Efuse %s is read-protected. Read back the burn value is not possible.&quot;
420                  % efuse.name
421              )
422          else:
423              new_value = efuse.convert_to_bitstring(new_value)
424              burned_value = efuse.get_bitstring()
425              if burned_value != new_value:
426                  print(
427                      burned_value,
428                      &quot;-&gt;&quot;,
429                      new_value,
430                      &quot;Efuse %s failed to burn. Protected?&quot; % efuse.name,
431                  )
432                  raise_error = True
433      if raise_error:
434          raise esptool.FatalError(&quot;The burn was not successful.&quot;)
435      else:
436          print(&quot;Successful&quot;)
437  def read_protect_efuse(esp, efuses, args):
438      util.check_duplicate_name_in_list(args.efuse_name)
439      for efuse_name in args.efuse_name:
440          efuse = efuses[efuse_name]
441          if not efuse.is_readable():
442              print(&quot;Efuse %s is already read protected&quot; % efuse.name)
443          else:
444              if esp.CHIP_NAME == &quot;ESP32&quot;:
445                  if (
446                      efuse_name == &quot;BLOCK2&quot;
447                      and not efuses[&quot;ABS_DONE_0&quot;].get()
448                      and esp.get_chip_revision() &gt;= 300
449                  ):
450                      if efuses[&quot;ABS_DONE_1&quot;].get():
451                          raise esptool.FatalError(
452                              &quot;Secure Boot V2 is on (ABS_DONE_1 = True), &quot;
453                              &quot;BLOCK2 must be readable, stop this operation!&quot;
454                          )
455                      else:
456                          print(
457                              &quot;If Secure Boot V2 is used, BLOCK2 must be readable, &quot;
458                              &quot;please stop this operation!&quot;
459                          )
460              elif esp.CHIP_NAME == &quot;ESP32-C2&quot;:
461                  error = (
462                      not efuses[&quot;XTS_KEY_LENGTH_256&quot;].get()
463                      and efuse_name == &quot;BLOCK_KEY0&quot;
464                  )
465                  error |= efuses[&quot;SECURE_BOOT_EN&quot;].get() and efuse_name in [
466                      &quot;BLOCK_KEY0&quot;,
467                      &quot;BLOCK_KEY0_HI_128&quot;,
468                  ]
469                  if error:
470                      raise esptool.FatalError(
471                          &quot;%s must be readable, stop this operation!&quot; % efuse_name
472                      )
473              else:
474                  for block in efuses.Blocks.BLOCKS:
475                      block = efuses.Blocks.get(block)
476                      if block.name == efuse_name and block.key_purpose is not None:
477                          if not efuses[block.key_purpose].need_rd_protect(
478                              efuses[block.key_purpose].get()
479                          ):
480                              raise esptool.FatalError(
481                                  &quot;%s must be readable, stop this operation!&quot; % efuse_name
482                              )
483                          break
484              all_disabling = [
485                  e for e in efuses if e.read_disable_bit == efuse.read_disable_bit
486              ]
487              names = &quot;, &quot;.join(e.name for e in all_disabling)
488              print(
489                  &quot;Permanently read-disabling efuse%s %s&quot;
490                  % (&quot;s&quot; if len(all_disabling) &gt; 1 else &quot;&quot;, names)
491              )
492              efuse.disable_read()
493      if not efuses.burn_all(check_batch_mode=True):
494          return
495      print(&quot;Checking efuses...&quot;)
496      raise_error = False
497      for efuse_name in args.efuse_name:
498          efuse = efuses[efuse_name]
499          if efuse.is_readable():
500              print(&quot;Efuse %s is not read-protected.&quot; % efuse.name)
501              raise_error = True
502      if raise_error:
503          raise esptool.FatalError(&quot;The burn was not successful.&quot;)
504      else:
505          print(&quot;Successful&quot;)
506  def write_protect_efuse(esp, efuses, args):
507      util.check_duplicate_name_in_list(args.efuse_name)
508      for efuse_name in args.efuse_name:
<span onclick='openModal()' class='match'>509          efuse = efuses[efuse_name]
510          if not efuse.is_writeable():
511              print(&quot;Efuse %s is already write protected&quot; % efuse.name)
512          else:
513              all_disabling = [
</span>514                  e for e in efuses if e.write_disable_bit == efuse.write_disable_bit
515              ]
516              names = &quot;, &quot;.join(e.name for e in all_disabling)
517              print(
518                  &quot;Permanently write-disabling efuse%s %s&quot;
519                  % (&quot;s&quot; if len(all_disabling) &gt; 1 else &quot;&quot;, names)
520              )
521              efuse.disable_write()
522      if not efuses.burn_all(check_batch_mode=True):
523          return
524      print(&quot;Checking efuses...&quot;)
525      raise_error = False
526      for efuse_name in args.efuse_name:
527          efuse = efuses[efuse_name]
528          if efuse.is_writeable():
529              print(&quot;Efuse %s is not write-protected.&quot; % efuse.name)
530              raise_error = True
531      if raise_error:
532          raise esptool.FatalError(&quot;The burn was not successful.&quot;)
533      else:
534          print(&quot;Successful&quot;)
535  def burn_block_data(esp, efuses, args):
536      block_name_list = args.block[
537          0 : len([name for name in args.block if name is not None]) :
538      ]
539      datafile_list = args.datafile[
540          0 : len([name for name in args.datafile if name is not None]) :
541      ]
542      efuses.force_write_always = args.force_write_always
543      util.check_duplicate_name_in_list(block_name_list)
544      if args.offset and len(block_name_list) &gt; 1:
545          raise esptool.FatalError(
546              &quot;The &#x27;offset&#x27; option is not applicable when a few blocks are passed. &quot;
547              &quot;With &#x27;offset&#x27;, should only one block be used.&quot;
548          )
549      else:
550          offset = args.offset
551          if offset:
552              num_block = efuses.get_index_block_by_name(block_name_list[0])
553              block = efuses.blocks[num_block]
554              num_bytes = block.get_block_len()
555              if offset &gt;= num_bytes:
556                  raise esptool.FatalError(
557                      &quot;Invalid offset: the block%d only holds %d bytes.&quot;
558                      % (block.id, num_bytes)
559                  )
560      if len(block_name_list) != len(datafile_list):
561          raise esptool.FatalError(
562              &quot;The number of block_name (%d) and datafile (%d) should be the same.&quot;
563              % (len(block_name_list), len(datafile_list))
564          )
565      for block_name, datafile in zip(block_name_list, datafile_list):
566          num_block = efuses.get_index_block_by_name(block_name)
567          block = efuses.blocks[num_block]
568          data = datafile.read()
569          num_bytes = block.get_block_len()
570          if offset != 0:
571              data = (b&quot;\x00&quot; * offset) + data
572              data = data + (b&quot;\x00&quot; * (num_bytes - len(data)))
573          if len(data) != num_bytes:
574              raise esptool.FatalError(
575                  &quot;Data does not fit: the block%d size is %d bytes, &quot;
576                  &quot;data file is %d bytes, offset %d&quot;
577                  % (block.id, num_bytes, len(data), offset)
578              )
579          print(
580              &quot;[{:02}] {:20} size={:02} bytes, offset={:02} - &gt; [{}].&quot;.format(
581                  block.id, block.name, len(data), offset, util.hexify(data, &quot; &quot;)
582              )
583          )
584          block.save(data)
585      if not efuses.burn_all(check_batch_mode=True):
586          return
587      print(&quot;Successful&quot;)
588  def burn_bit(esp, efuses, args):
589      efuses.force_write_always = args.force_write_always
590      num_block = efuses.get_index_block_by_name(args.block)
591      block = efuses.blocks[num_block]
592      data_block = BitStream(block.get_block_len() * 8)
593      data_block.set(0)
594      try:
595          data_block.set(True, args.bit_number)
596      except IndexError:
597          raise esptool.FatalError(
598              &quot;%s has bit_number in [0..%d]&quot; % (args.block, data_block.len - 1)
599          )
600      data_block.reverse()
601      print(
602          &quot;bit_number:   &quot;
603          &quot;[%-03d]........................................................[0]&quot;
604          % (data_block.len - 1)
605      )
606      print(&quot;BLOCK%-2d   :&quot; % block.id, data_block)
607      block.print_block(data_block, &quot;regs_to_write&quot;, debug=True)
608      block.save(data_block.bytes[::-1])
609      if not efuses.burn_all(check_batch_mode=True):
610          return
611      print(&quot;Successful&quot;)
612  def get_error_summary(efuses):
613      error_in_blocks = efuses.get_coding_scheme_warnings()
614      if not error_in_blocks:
615          return False
616      writable = True
617      for blk in efuses.blocks:
618          if blk.fail or blk.num_errors:
619              if blk.id == 0:
620                  for field in efuses:
621                      if field.block == blk.id and (field.fail or field.num_errors):
622                          wr = &quot;writable&quot; if field.is_writeable() else &quot;not writable&quot;
623                          writable &amp;= wr == &quot;writable&quot;
624                          name = field.name
625                          val = field.get()
626                          print(f&quot;BLOCK{field.block:&lt;2}: {name:&lt;40} = {val:&lt;8} ({wr})&quot;)
627              else:
628                  wr = &quot;writable&quot; if blk.is_writeable() else &quot;not writable&quot;
629                  writable &amp;= wr == &quot;writable&quot;
630                  name = f&quot;{blk.name} [ERRORS:{blk.num_errors} FAIL:{int(blk.fail)}]&quot;
631                  val = str(blk.get_bitstring())
632                  print(f&quot;BLOCK{blk.id:&lt;2}: {name:&lt;40} = {val:&lt;8} ({wr})&quot;)
633      if not writable and error_in_blocks:
634          print(&quot;Not all errors can be fixed because some fields are write-protected!&quot;)
635      return True
636  def check_error(esp, efuses, args):
637      error_in_blocks = get_error_summary(efuses)
638      if args.recovery and error_in_blocks:
639          confirmed = False
640          for block in reversed(efuses.blocks):
641              if block.fail or block.num_errors &gt; 0:
642                  if not block.get_bitstring().all(False):
643                      block.save(block.get_bitstring().bytes[::-1])
644                      if not confirmed:
645                          confirmed = True
646                          efuses.confirm(
647                              &quot;Recovery of block coding errors&quot;, args.do_not_confirm
648                          )
649                      block.burn()
650          if confirmed:
651              efuses.update_efuses()
652          error_in_blocks = get_error_summary(efuses)
653      if error_in_blocks:
654          raise esptool.FatalError(&quot;Error(s) were detected in eFuses&quot;)
655      print(&quot;No errors detected&quot;)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_operations.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_operations.py</div>
                </div>
                <div class="column column_space"><pre><code>440          efuse = efuses[efuse_name]
441          if not efuse.is_readable():
442              print(&quot;Efuse %s is already read protected&quot; % efuse.name)
443          else:
444              if esp.CHIP_NAME == &quot;ESP32&quot;:
</pre></code></div>
                <div class="column column_space"><pre><code>509          efuse = efuses[efuse_name]
510          if not efuse.is_writeable():
511              print(&quot;Efuse %s is already write protected&quot; % efuse.name)
512          else:
513              all_disabling = [
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    