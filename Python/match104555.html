<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_mac_xattr_1.py &amp; tls_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_mac_xattr_1.py &amp; tls_1.py
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_mac_xattr_1.py (17.37288%)<th>tls_1.py (1.8181819%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(149-161)<td><a href="#" name="0">(1155-1158)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(105-117)<td><a href="#" name="1">(836-839)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(66-73)<td><a href="#" name="2">(1684-1690)</a><td align="center"><font color="#ec0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mac_xattr_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import pytest
3 from tests.support.case import ModuleCase
4 from tests.support.helpers import runs_on
5 from tests.support.runtests import RUNTIME_VARS
6 @runs_on(kernel="Darwin")
7 @pytest.mark.skip_if_binaries_missing("xattr")
8 class MacXattrModuleTest(ModuleCase):
9     @classmethod
10     def setUpClass(cls):
11         cls.test_file = os.path.join(RUNTIME_VARS.TMP, "xattr_test_file.txt")
12         cls.no_file = os.path.join(RUNTIME_VARS.TMP, "xattr_no_file.txt")
13     def setUp(self):
14         self.run_function("file.touch", [self.test_file])
15     def tearDown(self):
16         if os.path.exists(self.test_file):
17             os.remove(self.test_file)
18     @pytest.mark.slow_test
19     def test_list_no_xattr(self):
20         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
21         self.assertEqual(self.run_function("xattr.list", [self.test_file]), {})
22         self.assertEqual(
23             self.run_function("xattr.list", [self.no_file]),
24             "ERROR: File not found: {}".format(self.no_file),
25         )
26     @pytest.mark.slow_test
27     def test_write(self):
28         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
29         self.assertTrue(
30             self.run_function(
31                 "xattr.write", [<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>self.test_file, "spongebob", "squarepants"]
32             )
33         )
34         self.assertTrue(
35             self.run_function("xattr.write", [self.test_file, "squidward", "plankton"])
36         )
37         self.assertTrue(
38             self.run_function("xattr.write", [self</b></font>.test_file, "crabby", "patty"])
39         )
40         self.assertEqual(
41             self.run_function("xattr.list", [self.test_file]),
42             {"spongebob": "squarepants", "squidward": "plankton", "crabby": "patty"},
43         )
44         self.assertEqual(
45             self.run_function("xattr.write", [self.no_file, "patrick", "jellyfish"]),
46             "ERROR: File not found: {}".format(self.no_file),
47         )
48     @pytest.mark.slow_test
49     def test_read(self):
50         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
51         self.assertTrue(
52             self.run_function(
53                 "xattr.write", [self.test_file, "spongebob", "squarepants"]
54             )
55         )
56 <a name="1"></a>
57         self.assertEqual(
58             self.run_function("xattr.read", [<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>self.test_file, "spongebob"]),
59             "squarepants",
60         )
61         self.assertEqual(
62             self.run_function("xattr.read", [self.no_file, "spongebob"]),
63             "ERROR: File not found: {}".format(self.no_file),
64         )
65         self.assertEqual(
66             self.</b></font>run_function("xattr.read", [self.test_file, "patrick"]),
67             "ERROR: Attribute not found: patrick",
68         )
69     @pytest.mark.slow_test
70     def test_delete(self):
71         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
72         self.assertTrue(
73             self.run_function(
74                 "xattr.write", [self.test_file, "spongebob", "squarepants"]
75             )
76         )
77         self.assertTrue(
78             self.run_function("xattr.write", [self.test_file, "squidward", "plankton"])
79         )
80         self.assertTrue(
81             self.run_function("xattr.write", [self.test_file, "crabby", "patty"])
82         )
83         self.assertTrue(
84             self.run_function("xattr.delete", [self.test_file, "squidward"])
85         )
86 <a name="0"></a>
87         self.assertEqual(
88             self.run_function("xattr.list", [self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.test_file]),
89             {"spongebob": "squarepants", "crabby": "patty"},
90         )
91         self.assertEqual(
92             self.run_function("xattr.delete", [self.no_file, "spongebob"]),
93             "ERROR: File not found: {}".format(self.no_file),
94         )
95         self.assertEqual(
96             self.</b></font>run_function("xattr.delete", [self.test_file, "patrick"]),
97             "ERROR: Attribute not found: patrick",
98         )
99     @pytest.mark.slow_test
100     def test_clear(self):
101         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
102         self.assertTrue(
103             self.run_function(
104                 "xattr.write", [self.test_file, "spongebob", "squarepants"]
105             )
106         )
107         self.assertTrue(
108             self.run_function("xattr.write", [self.test_file, "squidward", "plankton"])
109         )
110         self.assertTrue(
111             self.run_function("xattr.write", [self.test_file, "crabby", "patty"])
112         )
113         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
114         self.assertEqual(
115             self.run_function("xattr.clear", [self.no_file]),
116             "ERROR: File not found: {}".format(self.no_file),
117         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tls_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 r"""
2 A salt module for SSL/TLS.  Can create a Certificate Authority (CA)
3 or use Self-Signed certificates.
4 :depends: PyOpenSSL Python module (0.10 or later, 0.14 or later for X509
5     extension support)
6 :configuration: Add the following values in /etc/salt/minion for the CA module
7     to function properly:
8     .. code-block:: yaml
9         ca.cert_base_path: '/etc/pki'
10 CLI Example #1:
11 Creating a CA, a server request and its signed certificate:
12 .. code-block:: bash
13     days=5 \
14     CN='My Little CA' \
15     C=US \
16     ST=Utah \
17     L=Salt Lake City \
18     O=Saltstack \
19     emailAddress=pleasedontemail@example.com
20     Created Private Key: "/etc/pki/my_little/my_little_ca_cert.key"
21     Created CA "my_little_ca": "/etc/pki/my_little_ca/my_little_ca_cert.crt"
22     Created Private Key: "/etc/pki/my_little/certs/www.example.com.key
23     Created CSR for "www.example.com": "/etc/pki/my_little/certs/www.example.com.csr"
24     Created Certificate for "www.example.com": /etc/pki/my_little/certs/www.example.com.crt"
25 CLI Example #2:
26 Creating a client request and its signed certificate
27 .. code-block:: bash
28     Created Private Key: "/etc/pki/my_little/certs//DBReplica_No.1.key."
29     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.csr."
30     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
31 CLI Example #3:
32 Creating both a server and client req + cert for the same CN
33 .. code-block:: bash
34         cert_type=client
35     Created Private Key: "/etc/pki/my_little/certs/MasterDBReplica_No.2.key."
36     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/MasterDBReplica_No.2.csr."
37     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
38         cert_type=server
39     Certificate "MasterDBReplica_No.2" already exists
40     (doh!)
41         cert_type=server type_ext=True
42     Created Private Key: "/etc/pki/my_little/certs/DBReplica_No.1_client.key."
43     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1_client.csr."
44     Certificate "MasterDBReplica_No.2" already exists
45     (DOH!)
46         cert_type=server type_ext=True
47     Created Certificate for "MasterDBReplica_No.2": "/etc/pki/my_little/certs/MasterDBReplica_No.2_server.crt"
48 CLI Example #4:
49 Create a server req + cert with non-CN filename for the cert
50 .. code-block:: bash
51         cert_type=server type_ext=True
52     Created Private Key: "/etc/pki/my_little/certs/www.anothersometh.ing_server.key."
53     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/www.anothersometh.ing_server.csr."
54         cert_type=server cert_filename="something_completely_different"
55     Created Certificate for "www.anothersometh.ing": /etc/pki/my_little/certs/something_completely_different.crt
56     Only load this module if the ca config options are set
57     Return a Unix timestamp as a string of digits
58     :return:
59     Return the base path for certs from CLI or from options
60     cacert_path
61         absolute path to ca certificates root directory
62     CLI Example:
63     .. code-block:: bash
64         salt '*' tls.cert_base_path
65     Retrocompatible wrapper
66     If wanted, store the aforementioned cacert_path in context
67     to be used as the basepath for further operations
68     CLI Example:
69     .. code-block:: bash
70         salt '*' tls.set_ca_path /etc/certs
71     Return a serial number in hex using os.urandom() and a Unix timestamp
72     in microseconds.
73     ca_name
74         name of the CA
75     CN
76         common name in the request
77     Get basic info to write out to the index.txt
78     write out the index.txt database file in the appropriate directory to
79     track certificates
80     ca_name
81         name of the CA
82     cert
83         certificate to be recorded
84     Check that the X509 version is correct
85     (was incorrectly set in previous salt versions).
86     This will fix the version if needed.
87     ca_name
88         ca authority name
89     cacert_path
90         absolute path to ca certificates root directory
91     ca_filename
92         alternative filename for the CA
93         .. versionadded:: 2015.5.3
94     CLI Example:
95     .. code-block:: bash
96         salt '*' tls.maybe_fix_ssl_version test_ca /etc/certs
97     Verify whether a Certificate Authority (CA) already exists
98     ca_name
99         name of the CA
100     cacert_path
101         absolute path to ca certificates root directory
102     ca_filename
103         alternative filename for the CA
104         .. versionadded:: 2015.5.3
105     CLI Example:
106     .. code-block:: bash
107         salt '*' tls.ca_exists test_ca /etc/certs
108     Get the certificate path or content
109     ca_name
110         name of the CA
111     as_text
112         if true, return the certificate content instead of the path
113     cacert_path
114         absolute path to ca certificates root directory
115     CLI Example:
116     .. code-block:: bash
117         salt '*' tls.get_ca test_ca as_text=False cacert_path=/etc/certs
118     Get the certificate path or content
119     ca_name
120         name of the CA
121     CN
122         common name of the certificate
123     as_text
124         if true, return the certificate content instead of the path
125     cacert_path
126         absolute path to certificates root directory
127     cert_filename
128         alternative filename for the certificate, useful when using special characters in the CN
129         .. versionadded:: 2015.5.3
130     CLI Example:
131     .. code-block:: bash
132         salt '*' tls.get_ca_signed_cert test_ca CN=localhost as_text=False cacert_path=/etc/certs
133     Get the certificate path or content
134     ca_name
135         name of the CA
136     CN
137         common name of the certificate
138     as_text
139         if true, return the certificate content instead of the path
140     cacert_path
141         absolute path to certificates root directory
142     key_filename
143         alternative filename for the key, useful when using special characters
144         .. versionadded:: 2015.5.3
145         in the CN
146     CLI Example:
147     .. code-block:: bash
148         salt '*' tls.get_ca_signed_key \
149                 test_ca CN=localhost \
150                 as_text=False \
151                 cacert_path=/etc/certs
152     .. versionadded:: 3000
153     Validate a certificate against a given CA/CRL.
154     cert
155         path to the certifiate PEM file or string
156     ca_name
157         name of the CA
158     crl_file
159         full path to the CRL file
160     Returns a datetime.datetime object
161     .. versionadded:: 2019.2.0
162     Get a certificate's expiration date
163     cert
164         Full path to the certificate
165     date_format
166         By default this will return the expiration date in YYYY-MM-DD format,
167         use this to specify a different strftime format string. Note that the
168         expiration time will be in UTC.
169     CLI Examples:
170     .. code-block:: bash
171         salt '*' tls.get_expiration_date /path/to/foo.crt
172         salt '*' tls.get_expiration_date /path/to/foo.crt date_format='%d/%m/%Y'
173     Create a Certificate Authority (CA)
174     ca_name
175         name of the CA
176     bits
177         number of RSA key bits, default is 2048
178     days
179         number of days the CA will be valid, default is 365
180     CN
181         common name in the request, default is "localhost"
182     C
183         country, default is "US"
184     ST
185         state, default is "Utah"
186     L
187         locality, default is "Centerville", the city where SaltStack originated
188     O
189         organization, default is "SaltStack"
190     OU
191         organizational unit, default is None
192     emailAddress
193         email address for the CA owner, default is None
194     cacert_path
195         absolute path to ca certificates root directory
196     ca_filename
197         alternative filename for the CA
198         .. versionadded:: 2015.5.3
199     digest
200         The message digest algorithm. Must be a string describing a digest
201         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
202         For example, "md5" or "sha1". Default: 'sha256'
203     replace
204         Replace this certificate even if it exists
205         .. versionadded:: 2015.5.1
206     Writes out a CA certificate based upon defined config values. If the file
207     already exists, the function just returns assuming the CA certificate
208     already exists.
209     If the following values were set::
210         ca.cert_base_path='/etc/pki'
211         ca_name='koji'
212     the resulting CA, and corresponding key, would be written in the following
213     location with appropriate permissions::
214         /etc/pki/koji/koji_ca_cert.crt
215         /etc/pki/koji/koji_ca_cert.key
216     CLI Example:
217     .. code-block:: bash
218         salt '*' tls.create_ca test_ca
219     with salt<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(certp, "wb") as ca_crt:
220         ca_crt.write(
221             salt.utils.stringutils.to_bytes(
222                 OpenSSL.crypto.dump_certificate(OpenSSL.</b></font>crypto.FILETYPE_PEM, ca)
223             )
224         )
225     _write_cert_to_database(ca_name, ca)
226     ret = 'Created Private Key: "{}/{}/{}.key." '.format(
227         cert_base_path(), ca_name, ca_filename
228     )
229     ret += 'Created CA "{0}": "{1}/{0}/{2}.crt."'.format(
230         ca_name, cert_base_path(), ca_filename
231     )
232     return ret
233 def get_extensions(cert_type):
234     assert X509_EXT_ENABLED, (
235         "X509 extensions are not supported in "
236         "pyOpenSSL prior to version 0.15.1. Your "
237         "version: {}".format(OpenSSL_version)
238     )
239     ext = {}
240     if cert_type == "":
241         log.error(
242             "cert_type set to empty in tls_ca.get_extensions(); "
243             "defaulting to ``server``"
244         )
245         cert_type = "server"
246     try:
247         ext["common"] = __salt__["pillar.get"]("tls.extensions:common", False)
248     except NameError as err:
249         log.debug(err)
250     if not ext["common"] or ext["common"] == "":
251         ext["common"] = {
252             "csr": {"basicConstraints": "CA:FALSE"},
253             "cert": {
254                 "authorityKeyIdentifier": "keyid,issuer:always",
255                 "subjectKeyIdentifier": "hash",
256             },
257         }
258     try:
259         ext["server"] = __salt__["pillar.get"]("tls.extensions:server", False)
260     except NameError as err:
261         log.debug(err)
262     if not ext["server"] or ext["server"] == "":
263         ext["server"] = {
264             "csr": {
265                 "extendedKeyUsage": "serverAuth",
266                 "keyUsage": "digitalSignature, keyEncipherment",
267             },
268             "cert": {},
269         }
270     try:
271         ext["client"] = __salt__["pillar.get"]("tls.extensions:client", False)
272     except NameError as err:
273         log.debug(err)
274     if not ext["client"] or ext["client"] == "":
275         ext["client"] = {
276             "csr": {
277                 "extendedKeyUsage": "clientAuth",
278                 "keyUsage": "nonRepudiation, digitalSignature, keyEncipherment",
279             },
280             "cert": {},
281         }
282     if cert_type not in ext:
283         try:
284             ext[cert_type] = __salt__["pillar.get"](
285                 "tls.extensions:{}".format(cert_type)
286             )
287         except NameError as e:
288             log.debug(
289                 "pillar, tls:extensions:%s not available or "
290                 "not operating in a salt context\n%s",
291                 cert_type,
292                 e,
293             )
294     retval = ext["common"]
295     for Use in retval:
296         retval[Use].update(ext[cert_type][Use])
297     return retval
298 def create_csr(
299     ca_name,
300     bits=2048,
301     CN="localhost",
302     C="US",
303     ST="Utah",
304     L="Salt Lake City",
305     O="SaltStack",
306     OU=None,
307     emailAddress=None,
308     subjectAltName=None,
309     cacert_path=None,
310     ca_filename=None,
311     csr_path=None,
312     csr_filename=None,
313     digest="sha256",
314     type_ext=False,
315     cert_type="server",
316     replace=False,
317 ):
318     set_ca_path(cacert_path)
319     if not ca_filename:
320         ca_filename = "{}_ca_cert".format(ca_name)
321     if not ca_exists(ca_name, ca_filename=ca_filename):
322         return 'Certificate for CA named "{}" does not exist, please create it first.'.format(
323             ca_name
324         )
325     if not csr_path:
326         csr_path = "{}/{}/certs/".format(cert_base_path(), ca_name)
327     if not os.path.exists(csr_path):
328         os.makedirs(csr_path)
329     CN_ext = "_{}".format(cert_type) if type_ext else ""
330     if not csr_filename:
331         csr_filename = "{}{}".format(CN, CN_ext)
332     csr_f = "{}/{}.csr".format(csr_path, csr_filename)
333     if not replace and os.path.exists(csr_f):
334         return 'Certificate Request "{}" already exists'.format(csr_f)
335     key = OpenSSL.crypto.PKey()
336     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
337     req = OpenSSL.crypto.X509Req()
338     req.get_subject().C = C
339     req.get_subject().ST = ST
340     req.get_subject().L = L
341     req.get_subject().O = O
342     if OU:
343         req.get_subject().OU = OU
344     req.get_subject().CN = CN
345     if emailAddress:
346         req.get_subject().emailAddress = emailAddress
347     try:
348         extensions = get_extensions(cert_type)["csr"]
349         extension_adds = []
350         for ext, value in extensions.items():
351             if isinstance(value, str):
352                 value = salt.utils.stringutils.to_bytes(value)
353             extension_adds.append(
354                 OpenSSL.crypto.X509Extension(
355                     salt.utils.stringutils.to_bytes(ext), False, value
356                 )
357             )
358     except AssertionError as err:
359         log.error(err)
360         extensions = []
361     if subjectAltName:
362         if X509_EXT_ENABLED:
363             if isinstance(subjectAltName, str):
364                 subjectAltName = [subjectAltName]
365             extension_adds.append(
366                 OpenSSL.crypto.X509Extension(
367                     b"subjectAltName",
368                     False,
369                     b", ".join(salt.utils.data.encode(subjectAltName)),
370                 )
371             )
372         else:
373             raise ValueError(
374                 "subjectAltName cannot be set as X509 "
375                 "extensions are not supported in pyOpenSSL "
376                 "prior to version 0.15.1. Your "
377                 "version: {}.".format(OpenSSL_version)
378             )
379     if X509_EXT_ENABLED:
380         req.add_extensions(extension_adds)
381     req.set_pubkey(key)
382     req.sign(key, salt.utils.stringutils.to_str(digest))
383     priv_keyp = "{}/{}.key".format(csr_path, csr_filename)
384     fp = os.open(priv_keyp, os.O_CREAT | os.O_RDWR, 0o600)
385     with salt<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(fp, "wb+") as priv_key:
386         priv_key.write(
387             salt.utils.stringutils.to_bytes(
388                 OpenSSL.crypto.dump_privatekey(OpenSSL.</b></font>crypto.FILETYPE_PEM, key)
389             )
390         )
391     with salt.utils.files.fopen(csr_f, "wb+") as csr:
392         csr.write(
393             salt.utils.stringutils.to_bytes(
394                 OpenSSL.crypto.dump_certificate_request(
395                     OpenSSL.crypto.FILETYPE_PEM, req
396                 )
397             )
398         )
399     ret = 'Created Private Key: "{}{}.key." '.format(csr_path, csr_filename)
400     ret += 'Created CSR for "{}": "{}{}.csr."'.format(CN, csr_path, csr_filename)
401     return ret
402 def create_self_signed_cert(
403     tls_dir="tls",
404     bits=2048,
405     days=365,
406     CN="localhost",
407     C="US",
408     ST="Utah",
409     L="Salt Lake City",
410     O="SaltStack",
411     OU=None,
412     emailAddress=None,
413     cacert_path=None,
414     cert_filename=None,
415     digest="sha256",
416     replace=False,
417 ):
418     set_ca_path(cacert_path)
419     if not os.path.exists("{}/{}/certs/".format(cert_base_path(), tls_dir)):
420         os.makedirs("{}/{}/certs/".format(cert_base_path(), tls_dir))
421     if not cert_filename:
422         cert_filename = CN
423     if not replace and os.path.exists(
424         "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
425     ):
426         return 'Certificate "{}" already exists'.format(cert_filename)
427     key = OpenSSL.crypto.PKey()
428     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
429     cert = OpenSSL.crypto.X509()
430     cert.set_version(2)
431     cert.gmtime_adj_notBefore(0)
432     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
433     cert.get_subject().C = C
434     cert.get_subject().ST = ST
435     cert.get_subject().L = L
436     cert.get_subject().O = O
437     if OU:
438         cert.get_subject().OU = OU
439     cert.get_subject().CN = CN
440     if emailAddress:
441         cert.get_subject().emailAddress = emailAddress
442     cert.set_serial_number(_new_serial(tls_dir))
443     cert.set_issuer(cert.get_subject())
444     cert.set_pubkey(key)
445     cert.sign(key, salt.utils.stringutils.to_str(digest))
446     priv_key_path = "{}/{}/certs/{}.key".format(
447         cert_base_path(), tls_dir, cert_filename
448     )
449     fp = os.open(priv_key_path, os.O_CREAT | os.O_RDWR, 0o600)
450     with salt.utils.files.fopen(fp, "wb+") as priv_key:
451         priv_key.write(
452             salt.utils.stringutils.to_bytes(
453                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
454             )
455         )
456     crt_path = "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
457     with salt.utils.files.fopen(crt_path, "wb+") as crt:
458         crt.write(
459             salt.utils.stringutils.to_bytes(
460                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
461             )
462         )
463     _write_cert_to_database(tls_dir, cert)
464     ret = 'Created Private Key: "{}/{}/certs/{}.key." '.format(
465         cert_base_path(), tls_dir, cert_filename
466     )
467     ret += 'Created Certificate: "{}/{}/certs/{}.crt."'.format(
468         cert_base_path(), tls_dir, cert_filename
469     )
470     return ret
471 def create_ca_signed_cert(
472     ca_name,
473     CN,
474     days=365,
475     cacert_path=None,
476     ca_filename=None,
477     cert_path=None,
478     cert_filename=None,
479     digest="sha256",
480     cert_type=None,
481     type_ext=False,
482     replace=False,
483 ):
484     ret = {}
485     set_ca_path(cacert_path)
486     if not ca_filename:
487         ca_filename = "{}_ca_cert".format(ca_name)
488     if not cert_path:
489         cert_path = "{}/{}/certs".format(cert_base_path(), ca_name)
490     if type_ext:
491         if not cert_type:
492             log.error(
493                 "type_ext = True but cert_type is unset. Certificate not written."
494             )
495             return ret
496         elif cert_type:
497             CN_ext = "_{}".format(cert_type)
498     else:
499         CN_ext = ""
500     csr_filename = "{}{}".format(CN, CN_ext)
501     if not cert_filename:
502         cert_filename = "{}{}".format(CN, CN_ext)
503     if not replace and os.path.exists(
504         os.path.join(
505             os.path.sep.join(
506                 "{}/{}/certs/{}.crt".format(
507                     cert_base_path(), ca_name, cert_filename
508                 ).split("/")
509             )
510         )
511     ):
512         return 'Certificate "{}" already exists'.format(cert_filename)
513     try:
514         maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
515         with salt.utils.files.fopen(
516             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
517         ) as fhr:
518             ca_cert = OpenSSL.crypto.load_certificate(
519                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
520             )
521         with salt.utils.files.fopen(
522             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
523         ) as fhr:
524             ca_key = OpenSSL.crypto.load_privatekey(
525                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
526             )
527     except OSError:
528         ret["retcode"] = 1
529         ret["comment"] = 'There is no CA named "{}"'.format(ca_name)
530         return ret
531     try:
532         csr_path = "{}/{}.csr".format(cert_path, csr_filename)
533         with salt.utils.files.fopen(csr_path) as fhr:
534             req = OpenSSL.crypto.load_certificate_request(
535                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
536             )
537     except OSError:
538         ret["retcode"] = 1
539         ret["comment"] = 'There is no CSR that matches the CN "{}"'.format(
540             cert_filename
541         )
542         return ret
543     exts = []
544     try:
545         exts.extend(req.get_extensions())
546     except AttributeError:
547         try:
548             log.info(
549                 "req.get_extensions() not supported in pyOpenSSL versions "
550                 "prior to 0.15. Processing extensions internally. "
551                 "Your version: %s",
552                 OpenSSL_version,
553             )
554             native_exts_obj = OpenSSL._util.lib.X509_REQ_get_extensions(req._req)
555             for i in range(OpenSSL._util.lib.sk_X509_EXTENSION_num(native_exts_obj)):
556                 ext = OpenSSL.crypto.X509Extension.__new__(OpenSSL.crypto.X509Extension)
557                 ext._extension = OpenSSL._util.lib.sk_X509_EXTENSION_value(
558                     native_exts_obj, i
559                 )
560                 exts.append(ext)
561         except Exception:  # pylint: disable=broad-except
562             log.error(
563                 "X509 extensions are unsupported in pyOpenSSL "
564                 "versions prior to 0.14. Upgrade required to "
565                 "use extensions. Current version: %s",
566                 OpenSSL_version,
567             )
568     cert = OpenSSL.crypto.X509()
569     cert.set_version(2)
570     cert.set_subject(req.get_subject())
571     cert.gmtime_adj_notBefore(0)
572     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
573     cert.set_serial_number(_new_serial(ca_name))
574     cert.set_issuer(ca_cert.get_subject())
575     cert.set_pubkey(req.get_pubkey())
576     cert.add_extensions(exts)
577     cert.sign(ca_key, salt.utils.stringutils.to_str(digest))
578     cert_full_path = "{}/{}.crt".format(cert_path, cert_filename)
579     with salt.utils.files.fopen(cert_full_path, "wb+") as crt:
580         crt.write(
581             salt.utils.stringutils.to_bytes(
582                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
583             )
584         )
585     _write_cert_to_database(ca_name, cert)
586     return 'Created Certificate for "{}": "{}/{}.crt"'.format(
587         CN, cert_path, cert_filename
588     )
589 def create_pkcs12(ca_name, CN, passphrase="", cacert_path=None, replace=False):
590     set_ca_path(cacert_path)
591     if not replace and os.path.exists(
592         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN)
593     ):
594         return 'Certificate "{}" already exists'.format(CN)
595     try:
596         with salt.utils.files.fopen(
597             "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
598         ) as fhr:
599             ca_cert = OpenSSL.crypto.load_certificate(
600                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
601             )
602     except OSError:
603         return 'There is no CA named "{}"'.format(ca_name)
604     try:
605         with salt.utils.files.fopen(
606             "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, CN)
607         ) as fhr:
608             cert = OpenSSL.crypto.load_certificate(
609                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
610             )
611         with salt.utils.files.fopen(
612             "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, CN)
613         ) as fhr:
614             key = OpenSSL.crypto.load_privatekey(
615                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
616             )
617     except OSError:
618         return 'There is no certificate that matches the CN "{}"'.format(CN)
619     pkcs12 = OpenSSL.crypto.PKCS12()
620     pkcs12.set_certificate(cert)
621     pkcs12.set_ca_certificates([ca_cert])
622     pkcs12.set_privatekey(key)
623     with salt.utils.files.fopen(
624         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN), "wb"
625     ) as ofile:
626         ofile.write(
627             pkcs12.export(passphrase=salt.utils.stringutils.to_bytes(passphrase))
628         )
629     return 'Created PKCS#12 Certificate for "{0}": "{1}/{2}/certs/{0}.p12"'.format(
630         CN,
631         cert_base_path(),
632         ca_name,
633     )
634 def cert_info(cert, digest="sha256"):
635     date_fmt = "%Y%m%d%H%M%SZ"
636     if "-----BEGIN" not in cert:
637         with salt.utils.files.fopen(cert) as cert_file:
638             cert = cert_file.read()
639     cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
640     issuer = {}
641     for key, value in cert.get_issuer().get_components():
642         if isinstance(key, bytes):
643             key = salt.utils.stringutils.to_unicode(key)
644         if isinstance(value, bytes):
645             value = salt.utils.stringutils.to_unicode(value)
646         issuer[key] = value
647     subject = {}
648     for key, value in cert.get_subject().get_components():
649         if isinstance(key, bytes):
650             key = salt.utils.stringutils.to_unicode(key)
651         if isinstance(value, bytes):
652             value = salt.utils.stringutils.to_unicode(value)
653 <a name="2"></a>        subject[key] = value
654     ret = {
655         "fingerprint": salt<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.stringutils.to_unicode(
656             cert.digest(salt.utils.stringutils.to_str(digest))
657         ),
658         "subject": subject,
659         "issuer": issuer,
660         "serial_number": cert.get_serial_number(),
661         "not_before": calendar.</b></font>timegm(
662             time.strptime(
663                 str(cert.get_notBefore().decode(__salt_system_encoding__)), date_fmt
664             )
665         ),
666         "not_after": calendar.timegm(
667             time.strptime(
668                 cert.get_notAfter().decode(__salt_system_encoding__), date_fmt
669             )
670         ),
671     }
672     if hasattr(cert, "get_extension_count"):
673         ret["extensions"] = {}
674         for i in range(cert.get_extension_count()):
675             try:
676                 ext = cert.get_extension(i)
677                 key = salt.utils.stringutils.to_unicode(ext.get_short_name())
678                 ret["extensions"][key] = str(ext).strip()
679             except AttributeError:
680                 continue
681     if "subjectAltName" in ret.get("extensions", {}):
682         valid_entries = ("DNS", "IP Address")
683         valid_names = set()
684         for name in str(ret["extensions"]["subjectAltName"]).split(", "):
685             entry, name = name.split(":", 1)
686             if entry not in valid_entries:
687                 log.error(
688                     "Cert %s has an entry (%s) which does not start with %s",
689                     ret["subject"],
690                     name,
691                     "/".join(valid_entries),
692                 )
693             else:
694                 valid_names.add(name)
695         ret["subject_alt_names"] = list(valid_names)
696     if hasattr(cert, "get_signature_algorithm"):
697         try:
698             value = cert.get_signature_algorithm()
699             if isinstance(value, bytes):
700                 value = salt.utils.stringutils.to_unicode(value)
701             ret["signature_algorithm"] = value
702         except AttributeError:
703             pass
704     return ret
705 def create_empty_crl(
706     ca_name, cacert_path=None, ca_filename=None, crl_file=None, digest="sha256"
707 ):
708     set_ca_path(cacert_path)
709     if not ca_filename:
710         ca_filename = "{}_ca_cert".format(ca_name)
711     if not crl_file:
712         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
713     if os.path.exists("{}".format(crl_file)):
714         return 'CRL "{}" already exists'.format(crl_file)
715     try:
716         with salt.utils.files.fopen(
717             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
718         ) as fp_:
719             ca_cert = OpenSSL.crypto.load_certificate(
720                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
721             )
722         with salt.utils.files.fopen(
723             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
724         ) as fp_:
725             ca_key = OpenSSL.crypto.load_privatekey(
726                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
727             )
728     except OSError:
729         return 'There is no CA named "{}"'.format(ca_name)
730     crl = OpenSSL.crypto.CRL()
731     crl_text = crl.export(
732         ca_cert,
733         ca_key,
734         digest=salt.utils.stringutils.to_bytes(digest),
735     )
736     with salt.utils.files.fopen(crl_file, "w") as f:
737         f.write(salt.utils.stringutils.to_str(crl_text))
738     return 'Created an empty CRL: "{}"'.format(crl_file)
739 def revoke_cert(
740     ca_name,
741     CN,
742     cacert_path=None,
743     ca_filename=None,
744     cert_path=None,
745     cert_filename=None,
746     crl_file=None,
747     digest="sha256",
748 ):
749     set_ca_path(cacert_path)
750     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
751     if ca_filename is None:
752         ca_filename = "{}_ca_cert".format(ca_name)
753     if cert_path is None:
754         cert_path = "{}/{}/certs".format(_cert_base_path(), ca_name)
755     if cert_filename is None:
756         cert_filename = "{}".format(CN)
757     try:
758         with salt.utils.files.fopen(
759             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
760         ) as fp_:
761             ca_cert = OpenSSL.crypto.load_certificate(
762                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
763             )
764         with salt.utils.files.fopen(
765             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
766         ) as fp_:
767             ca_key = OpenSSL.crypto.load_privatekey(
768                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
769             )
770     except OSError:
771         return 'There is no CA named "{}"'.format(ca_name)
772     client_cert = _read_cert("{}/{}.crt".format(cert_path, cert_filename))
773     if client_cert is None:
774         return 'There is no client certificate named "{}"'.format(CN)
775     index_file, expire_date, serial_number, subject = _get_basic_info(
776         ca_name, client_cert, ca_dir
777     )
778     index_serial_subject = "{}\tunknown\t{}".format(serial_number, subject)
779     index_v_data = "V\t{}\t\t{}".format(expire_date, index_serial_subject)
780     index_r_data_pattern = re.compile(
781         r"R\t" + expire_date + r"\t\d{12}Z\t" + re.escape(index_serial_subject)
782     )
783     index_r_data = "R\t{}\t{}\t{}".format(
784         expire_date,
785         _four_digit_year_to_two_digit(datetime.utcnow()),
786         index_serial_subject,
787     )
788     ret = {}
789     with salt.utils.files.fopen(index_file) as fp_:
790         for line in fp_:
791             line = salt.utils.stringutils.to_unicode(line)
792             if index_r_data_pattern.match(line):
793                 revoke_date = line.split("\t")[2]
794                 try:
795                     datetime.strptime(revoke_date, two_digit_year_fmt)
796                     return '"{}/{}.crt" was already revoked, serial number: {}'.format(
797                         cert_path, cert_filename, serial_number
798                     )
799                 except ValueError:
800                     ret["retcode"] = 1
801                     ret[
802                         "comment"
803                     ] = "Revocation date '{}' does not matchformat '{}'".format(
804                         revoke_date, two_digit_year_fmt
805                     )
806                     return ret
807             elif index_serial_subject in line:
808                 __salt__["file.replace"](
809                     index_file, index_v_data, index_r_data, backup=False
810                 )
811                 break
812     crl = OpenSSL.crypto.CRL()
813     with salt.utils.files.fopen(index_file) as fp_:
814         for line in fp_:
815             line = salt.utils.stringutils.to_unicode(line)
816             if line.startswith("R"):
817                 fields = line.split("\t")
818                 revoked = OpenSSL.crypto.Revoked()
819                 revoked.set_serial(salt.utils.stringutils.to_bytes(fields[3]))
820                 revoke_date_2_digit = datetime.strptime(fields[2], two_digit_year_fmt)
821                 revoked.set_rev_date(
822                     salt.utils.stringutils.to_bytes(
823                         revoke_date_2_digit.strftime(four_digit_year_fmt)
824                     )
825                 )
826                 crl.add_revoked(revoked)
827     crl_text = crl.export(
828         ca_cert, ca_key, digest=salt.utils.stringutils.to_bytes(digest)
829     )
830     if crl_file is None:
831         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
832     if os.path.isdir(crl_file):
833         ret["retcode"] = 1
834         ret["comment"] = 'crl_file "{}" is an existing directory'.format(crl_file)
835         return ret
836     with salt.utils.files.fopen(crl_file, "w") as fp_:
837         fp_.write(salt.utils.stringutils.to_str(crl_text))
838     return 'Revoked Certificate: "{}/{}.crt", serial number: {}'.format(
839         cert_path, cert_filename, serial_number
840     )
841 if __name__ == "__main__":
842     create_csr(
843         "koji",
844         CN="test_system",
845         C="US",
846         ST="Utah",
847         L="Centerville",
848         O="SaltStack",
849         OU=None,
850         emailAddress="test_system@saltstack.org",
851     )
852     create_ca_signed_cert("koji", "test_system")
853     create_pkcs12("koji", "test_system", passphrase="test")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
