<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_mac_xattr_1.py &amp; tls_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_mac_xattr_1.py &amp; tls_1.py
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_mac_xattr_1.py (17.37288%)<th>tls_1.py (1.8181819%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(149-161)<td><a href="#" name="0">(1155-1158)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(105-117)<td><a href="#" name="1">(836-839)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(66-73)<td><a href="#" name="2">(1684-1690)</a><td align="center"><font color="#ec0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mac_xattr_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import pytest
3 from tests.support.case import ModuleCase
4 from tests.support.helpers import runs_on
5 from tests.support.runtests import RUNTIME_VARS
6 @runs_on(kernel="Darwin")
7 @pytest.mark.skip_if_binaries_missing("xattr")
8 class MacXattrModuleTest(ModuleCase):
9     @classmethod
10     def setUpClass(cls):
11         cls.test_file = os.path.join(RUNTIME_VARS.TMP, "xattr_test_file.txt")
12         cls.no_file = os.path.join(RUNTIME_VARS.TMP, "xattr_no_file.txt")
13     def setUp(self):
14         self.run_function("file.touch", [self.test_file])
15     def tearDown(self):
16         if os.path.exists(self.test_file):
17             os.remove(self.test_file)
18     @pytest.mark.slow_test
19     def test_list_no_xattr(self):
20         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
21         self.assertEqual(self.run_function("xattr.list", [self.test_file]), {})
22         self.assertEqual(
23             self.run_function("xattr.list", [self.no_file]),
24             "ERROR: File not found: {}".format(self.no_file),
25         )
26     @pytest.mark.slow_test
27     def test_write(self):
28         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
29         self.assertTrue(
30             self.run_function(
31                 "xattr.write", [<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>self.test_file, "spongebob", "squarepants"]
32             )
33         )
34         self.assertTrue(
35             self.run_function("xattr.write", [self.test_file, "squidward", "plankton"])
36         )
37         self.assertTrue(
38             self.run_function("xattr.write", [self</b></font>.test_file, "crabby", "patty"])
39         )
40         self.assertEqual(
41             self.run_function("xattr.list", [self.test_file]),
42             {"spongebob": "squarepants", "squidward": "plankton", "crabby": "patty"},
43         )
44         self.assertEqual(
45             self.run_function("xattr.write", [self.no_file, "patrick", "jellyfish"]),
46             "ERROR: File not found: {}".format(self.no_file),
47         )
48     @pytest.mark.slow_test
49     def test_read(self):
50         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
51         self.assertTrue(
52             self.run_function(
53                 "xattr.write", [self.test_file, "spongebob", "squarepants"]
54             )
55         )
56         self.assertEqual(
57             self.run_function("xattr.read", [<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>self.test_file, "spongebob"]),
58             "squarepants",
59         )
60         self.assertEqual(
61             self.run_function("xattr.read", [self.no_file, "spongebob"]),
62             "ERROR: File not found: {}".format(self.no_file),
63         )
64         self.assertEqual(
65             self.</b></font>run_function("xattr.read", [self.test_file, "patrick"]),
66             "ERROR: Attribute not found: patrick",
67         )
68     @pytest.mark.slow_test
69     def test_delete(self):
70         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
71         self.assertTrue(
72             self.run_function(
73                 "xattr.write", [self.test_file, "spongebob", "squarepants"]
74             )
75         )
76         self.assertTrue(
77             self.run_function("xattr.write", [self.test_file, "squidward", "plankton"])
78         )
79         self.assertTrue(
80             self.run_function("xattr.write", [self.test_file, "crabby", "patty"])
81         )
82         self.assertTrue(
83             self.run_function("xattr.delete", [self.test_file, "squidward"])
84         )
85         self.assertEqual(
86             self.run_function("xattr.list", [self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.test_file]),
87             {"spongebob": "squarepants", "crabby": "patty"},
88         )
89         self.assertEqual(
90             self.run_function("xattr.delete", [self.no_file, "spongebob"]),
91             "ERROR: File not found: {}".format(self.no_file),
92         )
93         self.assertEqual(
94             self.</b></font>run_function("xattr.delete", [self.test_file, "patrick"]),
95             "ERROR: Attribute not found: patrick",
96         )
97     @pytest.mark.slow_test
98     def test_clear(self):
99         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
100         self.assertTrue(
101             self.run_function(
102                 "xattr.write", [self.test_file, "spongebob", "squarepants"]
103             )
104         )
105         self.assertTrue(
106             self.run_function("xattr.write", [self.test_file, "squidward", "plankton"])
107         )
108         self.assertTrue(
109             self.run_function("xattr.write", [self.test_file, "crabby", "patty"])
110         )
111         self.assertTrue(self.run_function("xattr.clear", [self.test_file]))
112         self.assertEqual(
113             self.run_function("xattr.clear", [self.no_file]),
114             "ERROR: File not found: {}".format(self.no_file),
115         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tls_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 r"""
2 A salt module for SSL/TLS.  Can create a Certificate Authority (CA)
3 or use Self-Signed certificates.
4 :depends: PyOpenSSL Python module (0.10 or later, 0.14 or later for X509
5     extension support)
6 :configuration: Add the following values in /etc/salt/minion for the CA module
7     to function properly:
8     .. code-block:: yaml
9         ca.cert_base_path: '/etc/pki'
10 CLI Example #1:
11 Creating a CA, a server request and its signed certificate:
12 .. code-block:: bash
13     days=5 \
14     CN='My Little CA' \
15     C=US \
16     ST=Utah \
17     L=Salt Lake City \
18     O=Saltstack \
19     emailAddress=pleasedontemail@example.com
20     Created Private Key: "/etc/pki/my_little/my_little_ca_cert.key"
21     Created CA "my_little_ca": "/etc/pki/my_little_ca/my_little_ca_cert.crt"
22     Created Private Key: "/etc/pki/my_little/certs/www.example.com.key
23     Created CSR for "www.example.com": "/etc/pki/my_little/certs/www.example.com.csr"
24     Created Certificate for "www.example.com": /etc/pki/my_little/certs/www.example.com.crt"
25 CLI Example #2:
26 Creating a client request and its signed certificate
27 .. code-block:: bash
28     Created Private Key: "/etc/pki/my_little/certs//DBReplica_No.1.key."
29     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.csr."
30     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
31 CLI Example #3:
32 Creating both a server and client req + cert for the same CN
33 .. code-block:: bash
34         cert_type=client
35     Created Private Key: "/etc/pki/my_little/certs/MasterDBReplica_No.2.key."
36     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/MasterDBReplica_No.2.csr."
37     Created Certificate for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1.crt"
38         cert_type=server
39     Certificate "MasterDBReplica_No.2" already exists
40     (doh!)
41         cert_type=server type_ext=True
42     Created Private Key: "/etc/pki/my_little/certs/DBReplica_No.1_client.key."
43     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/DBReplica_No.1_client.csr."
44     Certificate "MasterDBReplica_No.2" already exists
45     (DOH!)
46         cert_type=server type_ext=True
47     Created Certificate for "MasterDBReplica_No.2": "/etc/pki/my_little/certs/MasterDBReplica_No.2_server.crt"
48 CLI Example #4:
49 Create a server req + cert with non-CN filename for the cert
50 .. code-block:: bash
51         cert_type=server type_ext=True
52     Created Private Key: "/etc/pki/my_little/certs/www.anothersometh.ing_server.key."
53     Created CSR for "DBReplica_No.1": "/etc/pki/my_little/certs/www.anothersometh.ing_server.csr."
54         cert_type=server cert_filename="something_completely_different"
55     Created Certificate for "www.anothersometh.ing": /etc/pki/my_little/certs/something_completely_different.crt
56     Only load this module if the ca config options are set
57     Return a Unix timestamp as a string of digits
58     :return:
59     Return the base path for certs from CLI or from options
60     cacert_path
61         absolute path to ca certificates root directory
62     CLI Example:
63     .. code-block:: bash
64         salt '*' tls.cert_base_path
65     Retrocompatible wrapper
66     If wanted, store the aforementioned cacert_path in context
67     to be used as the basepath for further operations
68     CLI Example:
69     .. code-block:: bash
70         salt '*' tls.set_ca_path /etc/certs
71     Return a serial number in hex using os.urandom() and a Unix timestamp
72     in microseconds.
73     ca_name
74         name of the CA
75     CN
76         common name in the request
77     Get basic info to write out to the index.txt
78     write out the index.txt database file in the appropriate directory to
79     track certificates
80     ca_name
81         name of the CA
82     cert
83         certificate to be recorded
84     Check that the X509 version is correct
85     (was incorrectly set in previous salt versions).
86     This will fix the version if needed.
87     ca_name
88         ca authority name
89     cacert_path
90         absolute path to ca certificates root directory
91     ca_filename
92         alternative filename for the CA
93         .. versionadded:: 2015.5.3
94     CLI Example:
95     .. code-block:: bash
96         salt '*' tls.maybe_fix_ssl_version test_ca /etc/certs
97     Verify whether a Certificate Authority (CA) already exists
98     ca_name
99         name of the CA
100     cacert_path
101         absolute path to ca certificates root directory
102     ca_filename
103         alternative filename for the CA
104         .. versionadded:: 2015.5.3
105     CLI Example:
106     .. code-block:: bash
107         salt '*' tls.ca_exists test_ca /etc/certs
108     Get the certificate path or content
109     ca_name
110         name of the CA
111     as_text
112         if true, return the certificate content instead of the path
113     cacert_path
114         absolute path to ca certificates root directory
115     CLI Example:
116     .. code-block:: bash
117         salt '*' tls.get_ca test_ca as_text=False cacert_path=/etc/certs
118     Get the certificate path or content
119     ca_name
120         name of the CA
121     CN
122         common name of the certificate
123     as_text
124         if true, return the certificate content instead of the path
125     cacert_path
126         absolute path to certificates root directory
127     cert_filename
128         alternative filename for the certificate, useful when using special characters in the CN
129         .. versionadded:: 2015.5.3
130     CLI Example:
131     .. code-block:: bash
132         salt '*' tls.get_ca_signed_cert test_ca CN=localhost as_text=False cacert_path=/etc/certs
133     Get the certificate path or content
134     ca_name
135         name of the CA
136     CN
137         common name of the certificate
138     as_text
139         if true, return the certificate content instead of the path
140     cacert_path
141         absolute path to certificates root directory
142     key_filename
143         alternative filename for the key, useful when using special characters
144         .. versionadded:: 2015.5.3
145         in the CN
146     CLI Example:
147     .. code-block:: bash
148         salt '*' tls.get_ca_signed_key \
149                 test_ca CN=localhost \
150                 as_text=False \
151                 cacert_path=/etc/certs
152     .. versionadded:: 3000
153     Validate a certificate against a given CA/CRL.
154     cert
155         path to the certifiate PEM file or string
156     ca_name
157         name of the CA
158     crl_file
159         full path to the CRL file
160     Returns a datetime.datetime object
161     .. versionadded:: 2019.2.0
162     Get a certificate's expiration date
163     cert
164         Full path to the certificate
165     date_format
166         By default this will return the expiration date in YYYY-MM-DD format,
167         use this to specify a different strftime format string. Note that the
168         expiration time will be in UTC.
169     CLI Examples:
170     .. code-block:: bash
171         salt '*' tls.get_expiration_date /path/to/foo.crt
172         salt '*' tls.get_expiration_date /path/to/foo.crt date_format='%d/%m/%Y'
173     Create a Certificate Authority (CA)
174     ca_name
175         name of the CA
176     bits
177         number of RSA key bits, default is 2048
178     days
179         number of days the CA will be valid, default is 365
180     CN
181         common name in the request, default is "localhost"
182     C
183         country, default is "US"
184     ST
185         state, default is "Utah"
186     L
187         locality, default is "Centerville", the city where SaltStack originated
188     O
189         organization, default is "SaltStack"
190     OU
191         organizational unit, default is None
192     emailAddress
193         email address for the CA owner, default is None
194     cacert_path
195         absolute path to ca certificates root directory
196     ca_filename
197         alternative filename for the CA
198         .. versionadded:: 2015.5.3
199     digest
200         The message digest algorithm. Must be a string describing a digest
201         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
202         For example, "md5" or "sha1". Default: 'sha256'
203     replace
204         Replace this certificate even if it exists
205         .. versionadded:: 2015.5.1
206     Writes out a CA certificate based upon defined config values. If the file
207     already exists, the function just returns assuming the CA certificate
208     already exists.
209     If the following values were set::
210         ca.cert_base_path='/etc/pki'
211         ca_name='koji'
212     the resulting CA, and corresponding key, would be written in the following
213     location with appropriate permissions::
214         /etc/pki/koji/koji_ca_cert.crt
215         /etc/pki/koji/koji_ca_cert.key
216     CLI Example:
217     .. code-block:: bash
218         salt '*' tls.create_ca test_ca
219     """
220     with salt<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(certp, "wb") as ca_crt:
221         ca_crt.write(
222             salt.utils.stringutils.to_bytes(
223                 OpenSSL.crypto.dump_certificate(OpenSSL.</b></font>crypto.FILETYPE_PEM, ca)
224             )
225         )
226     _write_cert_to_database(ca_name, ca)
227     ret = 'Created Private Key: "{}/{}/{}.key." '.format(
228         cert_base_path(), ca_name, ca_filename
229     )
230     ret += 'Created CA "{0}": "{1}/{0}/{2}.crt."'.format(
231         ca_name, cert_base_path(), ca_filename
232     )
233     return ret
234 def get_extensions(cert_type):
235     """
236     Fetch X509 and CSR extension definitions from tls:extensions:
237     (common|server|client) or set them to standard defaults.
238     .. versionadded:: 2015.8.0
239     cert_type:
240         The type of certificate such as ``server`` or ``client``.
241     CLI Example:
242     .. code-block:: bash
243         salt '*' tls.get_extensions client
244     """
245     assert X509_EXT_ENABLED, (
246         "X509 extensions are not supported in "
247         "pyOpenSSL prior to version 0.15.1. Your "
248         "version: {}".format(OpenSSL_version)
249     )
250     ext = {}
251     if cert_type == "":
252         log.error(
253             "cert_type set to empty in tls_ca.get_extensions(); "
254             "defaulting to ``server``"
255         )
256         cert_type = "server"
257     try:
258         ext["common"] = __salt__["pillar.get"]("tls.extensions:common", False)
259     except NameError as err:
260         log.debug(err)
261     if not ext["common"] or ext["common"] == "":
262         ext["common"] = {
263             "csr": {"basicConstraints": "CA:FALSE"},
264             "cert": {
265                 "authorityKeyIdentifier": "keyid,issuer:always",
266                 "subjectKeyIdentifier": "hash",
267             },
268         }
269     try:
270         ext["server"] = __salt__["pillar.get"]("tls.extensions:server", False)
271     except NameError as err:
272         log.debug(err)
273     if not ext["server"] or ext["server"] == "":
274         ext["server"] = {
275             "csr": {
276                 "extendedKeyUsage": "serverAuth",
277                 "keyUsage": "digitalSignature, keyEncipherment",
278             },
279             "cert": {},
280         }
281     try:
282         ext["client"] = __salt__["pillar.get"]("tls.extensions:client", False)
283     except NameError as err:
284         log.debug(err)
285     if not ext["client"] or ext["client"] == "":
286         ext["client"] = {
287             "csr": {
288                 "extendedKeyUsage": "clientAuth",
289                 "keyUsage": "nonRepudiation, digitalSignature, keyEncipherment",
290             },
291             "cert": {},
292         }
293     if cert_type not in ext:
294         try:
295             ext[cert_type] = __salt__["pillar.get"](
296                 "tls.extensions:{}".format(cert_type)
297             )
298         except NameError as e:
299             log.debug(
300                 "pillar, tls:extensions:%s not available or "
301                 "not operating in a salt context\n%s",
302                 cert_type,
303                 e,
304             )
305     retval = ext["common"]
306     for Use in retval:
307         retval[Use].update(ext[cert_type][Use])
308     return retval
309 def create_csr(
310     ca_name,
311     bits=2048,
312     CN="localhost",
313     C="US",
314     ST="Utah",
315     L="Salt Lake City",
316     O="SaltStack",
317     OU=None,
318     emailAddress=None,
319     subjectAltName=None,
320     cacert_path=None,
321     ca_filename=None,
322     csr_path=None,
323     csr_filename=None,
324     digest="sha256",
325     type_ext=False,
326     cert_type="server",
327     replace=False,
328 ):
329     """
330     Create a Certificate Signing Request (CSR) for a
331     particular Certificate Authority (CA)
332     ca_name
333         name of the CA
334     bits
335         number of RSA key bits, default is 2048
336     CN
337         common name in the request, default is "localhost"
338     C
339         country, default is "US"
340     ST
341         state, default is "Utah"
342     L
343         locality, default is "Centerville", the city where SaltStack originated
344     O
345         organization, default is "SaltStack"
346         NOTE: Must the same as CA certificate or an error will be raised
347     OU
348         organizational unit, default is None
349     emailAddress
350         email address for the request, default is None
351     subjectAltName
352         valid subjectAltNames in full form, e.g. to add DNS entry you would call
353         this function with this value:
354         examples: ['DNS:somednsname.com',
355                 'DNS:1.2.3.4',
356                 'IP:1.2.3.4',
357                 'IP:2001:4801:7821:77:be76:4eff:fe11:e51',
358                 'email:me@i.like.pie.com']
359     .. note::
360         some libraries do not properly query IP: prefixes, instead looking
361         for the given req. source with a DNS: prefix. To be thorough, you
362         may want to include both DNS: and IP: entries if you are using
363         subjectAltNames for destinations for your TLS connections.
364         e.g.:
365         requests to https://1.2.3.4 will fail from python's
366         requests library w/out the second entry in the above list
367     .. versionadded:: 2015.8.0
368     cert_type
369         Specify the general certificate type. Can be either `server` or
370         `client`. Indicates the set of common extensions added to the CSR.
371         .. code-block:: cfg
372             server: {
373                'basicConstraints': 'CA:FALSE',
374                'extendedKeyUsage': 'serverAuth',
375                'keyUsage': 'digitalSignature, keyEncipherment'
376             }
377             client: {
378                'basicConstraints': 'CA:FALSE',
379                'extendedKeyUsage': 'clientAuth',
380                'keyUsage': 'nonRepudiation, digitalSignature, keyEncipherment'
381             }
382     type_ext
383         boolean.  Whether or not to extend the filename with CN_[cert_type]
384         This can be useful if a server and client certificate are needed for
385         the same CN. Defaults to False to avoid introducing an unexpected file
386         naming pattern
387         The files normally named some_subject_CN.csr and some_subject_CN.key
388         will then be saved
389     replace
390         Replace this signing request even if it exists
391         .. versionadded:: 2015.5.1
392     Writes out a Certificate Signing Request (CSR) If the file already
393     exists, the function just returns assuming the CSR already exists.
394     If the following values were set::
395         ca.cert_base_path='/etc/pki'
396         ca_name='koji'
397         CN='test.egavas.org'
398     the resulting CSR, and corresponding key, would be written in the
399     following location with appropriate permissions::
400         /etc/pki/koji/certs/test.egavas.org.csr
401         /etc/pki/koji/certs/test.egavas.org.key
402     CLI Example:
403     .. code-block:: bash
404         salt '*' tls.create_csr test
405     """
406     set_ca_path(cacert_path)
407     if not ca_filename:
408         ca_filename = "{}_ca_cert".format(ca_name)
409     if not ca_exists(ca_name, ca_filename=ca_filename):
410         return 'Certificate for CA named "{}" does not exist, please create it first.'.format(
411             ca_name
412         )
413     if not csr_path:
414         csr_path = "{}/{}/certs/".format(cert_base_path(), ca_name)
415     if not os.path.exists(csr_path):
416         os.makedirs(csr_path)
417     CN_ext = "_{}".format(cert_type) if type_ext else ""
418     if not csr_filename:
419         csr_filename = "{}{}".format(CN, CN_ext)
420     csr_f = "{}/{}.csr".format(csr_path, csr_filename)
421     if not replace and os.path.exists(csr_f):
422         return 'Certificate Request "{}" already exists'.format(csr_f)
423     key = OpenSSL.crypto.PKey()
424     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
425     req = OpenSSL.crypto.X509Req()
426     req.get_subject().C = C
427     req.get_subject().ST = ST
428     req.get_subject().L = L
429     req.get_subject().O = O
430     if OU:
431         req.get_subject().OU = OU
432     req.get_subject().CN = CN
433     if emailAddress:
434         req.get_subject().emailAddress = emailAddress
435     try:
436         extensions = get_extensions(cert_type)["csr"]
437         extension_adds = []
438         for ext, value in extensions.items():
439             if isinstance(value, str):
440                 value = salt.utils.stringutils.to_bytes(value)
441             extension_adds.append(
442                 OpenSSL.crypto.X509Extension(
443                     salt.utils.stringutils.to_bytes(ext), False, value
444                 )
445             )
446     except AssertionError as err:
447         log.error(err)
448         extensions = []
449     if subjectAltName:
450         if X509_EXT_ENABLED:
451             if isinstance(subjectAltName, str):
452                 subjectAltName = [subjectAltName]
453             extension_adds.append(
454                 OpenSSL.crypto.X509Extension(
455                     b"subjectAltName",
456                     False,
457                     b", ".join(salt.utils.data.encode(subjectAltName)),
458                 )
459             )
460         else:
461             raise ValueError(
462                 "subjectAltName cannot be set as X509 "
463                 "extensions are not supported in pyOpenSSL "
464                 "prior to version 0.15.1. Your "
465                 "version: {}.".format(OpenSSL_version)
466             )
467     if X509_EXT_ENABLED:
468         req.add_extensions(extension_adds)
469     req.set_pubkey(key)
470     req.sign(key, salt.utils.stringutils.to_str(digest))
471     priv_keyp = "{}/{}.key".format(csr_path, csr_filename)
472     fp = os.open(priv_keyp, os.O_CREAT | os.O_RDWR, 0o600)
473     with salt<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(fp, "wb+") as priv_key:
474         priv_key.write(
475             salt.utils.stringutils.to_bytes(
476                 OpenSSL.crypto.dump_privatekey(OpenSSL.</b></font>crypto.FILETYPE_PEM, key)
477             )
478         )
479     with salt.utils.files.fopen(csr_f, "wb+") as csr:
480         csr.write(
481             salt.utils.stringutils.to_bytes(
482                 OpenSSL.crypto.dump_certificate_request(
483                     OpenSSL.crypto.FILETYPE_PEM, req
484                 )
485             )
486         )
487     ret = 'Created Private Key: "{}{}.key." '.format(csr_path, csr_filename)
488     ret += 'Created CSR for "{}": "{}{}.csr."'.format(CN, csr_path, csr_filename)
489     return ret
490 def create_self_signed_cert(
491     tls_dir="tls",
492     bits=2048,
493     days=365,
494     CN="localhost",
495     C="US",
496     ST="Utah",
497     L="Salt Lake City",
498     O="SaltStack",
499     OU=None,
500     emailAddress=None,
501     cacert_path=None,
502     cert_filename=None,
503     digest="sha256",
504     replace=False,
505 ):
506     """
507     Create a Self-Signed Certificate (CERT)
508     tls_dir
509         location appended to the ca.cert_base_path, default is 'tls'
510     bits
511         number of RSA key bits, default is 2048
512     CN
513         common name in the request, default is "localhost"
514     C
515         country, default is "US"
516     ST
517         state, default is "Utah"
518     L
519         locality, default is "Centerville", the city where SaltStack originated
520     O
521         organization, default is "SaltStack"
522         NOTE: Must the same as CA certificate or an error will be raised
523     OU
524         organizational unit, default is None
525     emailAddress
526         email address for the request, default is None
527     cacert_path
528         absolute path to ca certificates root directory
529     digest
530         The message digest algorithm. Must be a string describing a digest
531         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
532         For example, "md5" or "sha1". Default: 'sha256'
533     replace
534         Replace this certificate even if it exists
535         .. versionadded:: 2015.5.1
536     Writes out a Self-Signed Certificate (CERT). If the file already
537     exists, the function just returns.
538     If the following values were set::
539         ca.cert_base_path='/etc/pki'
540         tls_dir='koji'
541         CN='test.egavas.org'
542     the resulting CERT, and corresponding key, would be written in the
543     following location with appropriate permissions::
544         /etc/pki/koji/certs/test.egavas.org.crt
545         /etc/pki/koji/certs/test.egavas.org.key
546     CLI Example:
547     .. code-block:: bash
548         salt '*' tls.create_self_signed_cert
549     Passing options from the command line:
550     .. code-block:: bash
551         salt 'minion' tls.create_self_signed_cert CN='test.mysite.org'
552     """
553     set_ca_path(cacert_path)
554     if not os.path.exists("{}/{}/certs/".format(cert_base_path(), tls_dir)):
555         os.makedirs("{}/{}/certs/".format(cert_base_path(), tls_dir))
556     if not cert_filename:
557         cert_filename = CN
558     if not replace and os.path.exists(
559         "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
560     ):
561         return 'Certificate "{}" already exists'.format(cert_filename)
562     key = OpenSSL.crypto.PKey()
563     key.generate_key(OpenSSL.crypto.TYPE_RSA, bits)
564     cert = OpenSSL.crypto.X509()
565     cert.set_version(2)
566     cert.gmtime_adj_notBefore(0)
567     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
568     cert.get_subject().C = C
569     cert.get_subject().ST = ST
570     cert.get_subject().L = L
571     cert.get_subject().O = O
572     if OU:
573         cert.get_subject().OU = OU
574     cert.get_subject().CN = CN
575     if emailAddress:
576         cert.get_subject().emailAddress = emailAddress
577     cert.set_serial_number(_new_serial(tls_dir))
578     cert.set_issuer(cert.get_subject())
579     cert.set_pubkey(key)
580     cert.sign(key, salt.utils.stringutils.to_str(digest))
581     priv_key_path = "{}/{}/certs/{}.key".format(
582         cert_base_path(), tls_dir, cert_filename
583     )
584     fp = os.open(priv_key_path, os.O_CREAT | os.O_RDWR, 0o600)
585     with salt.utils.files.fopen(fp, "wb+") as priv_key:
586         priv_key.write(
587             salt.utils.stringutils.to_bytes(
588                 OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, key)
589             )
590         )
591     crt_path = "{}/{}/certs/{}.crt".format(cert_base_path(), tls_dir, cert_filename)
592     with salt.utils.files.fopen(crt_path, "wb+") as crt:
593         crt.write(
594             salt.utils.stringutils.to_bytes(
595                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
596             )
597         )
598     _write_cert_to_database(tls_dir, cert)
599     ret = 'Created Private Key: "{}/{}/certs/{}.key." '.format(
600         cert_base_path(), tls_dir, cert_filename
601     )
602     ret += 'Created Certificate: "{}/{}/certs/{}.crt."'.format(
603         cert_base_path(), tls_dir, cert_filename
604     )
605     return ret
606 def create_ca_signed_cert(
607     ca_name,
608     CN,
609     days=365,
610     cacert_path=None,
611     ca_filename=None,
612     cert_path=None,
613     cert_filename=None,
614     digest="sha256",
615     cert_type=None,
616     type_ext=False,
617     replace=False,
618 ):
619     """
620     Create a Certificate (CERT) signed by a named Certificate Authority (CA)
621     If the certificate file already exists, the function just returns assuming
622     the CERT already exists.
623     The CN *must* match an existing CSR generated by create_csr. If it
624     does not, this method does nothing.
625     ca_name
626         name of the CA
627     CN
628         common name matching the certificate signing request
629     days
630         number of days certificate is valid, default is 365 (1 year)
631     cacert_path
632         absolute path to ca certificates root directory
633     ca_filename
634         alternative filename for the CA
635         .. versionadded:: 2015.5.3
636     cert_path
637         full path to the certificates directory
638     cert_filename
639         alternative filename for the certificate, useful when using special
640         characters in the CN. If this option is set it will override
641         the certificate filename output effects of ``cert_type``.
642         ``type_ext`` will be completely overridden.
643         .. versionadded:: 2015.5.3
644     digest
645         The message digest algorithm. Must be a string describing a digest
646         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
647         For example, "md5" or "sha1". Default: 'sha256'
648     replace
649         Replace this certificate even if it exists
650         .. versionadded:: 2015.5.1
651     cert_type
652         string. Either 'server' or 'client' (see create_csr() for details).
653         If create_csr(type_ext=True) this function **must** be called with the
654         same cert_type so it can find the CSR file.
655     .. note::
656         create_csr() defaults to cert_type='server'; therefore, if it was also
657         called with type_ext, cert_type becomes a required argument for
658         create_ca_signed_cert()
659     type_ext
660         bool. If set True, use ``cert_type`` as an extension to the CN when
661         formatting the filename.
662         e.g.: some_subject_CN_server.crt or some_subject_CN_client.crt
663         This facilitates the context where both types are required for the same
664         subject
665         If ``cert_filename`` is `not None`, setting ``type_ext`` has no
666         effect
667     If the following values were set:
668     .. code-block:: text
669         ca.cert_base_path='/etc/pki'
670         ca_name='koji'
671         CN='test.egavas.org'
672     the resulting signed certificate would be written in the following
673     location:
674     .. code-block:: text
675         /etc/pki/koji/certs/test.egavas.org.crt
676     CLI Example:
677     .. code-block:: bash
678         salt '*' tls.create_ca_signed_cert test localhost
679     """
680     ret = {}
681     set_ca_path(cacert_path)
682     if not ca_filename:
683         ca_filename = "{}_ca_cert".format(ca_name)
684     if not cert_path:
685         cert_path = "{}/{}/certs".format(cert_base_path(), ca_name)
686     if type_ext:
687         if not cert_type:
688             log.error(
689                 "type_ext = True but cert_type is unset. Certificate not written."
690             )
691             return ret
692         elif cert_type:
693             CN_ext = "_{}".format(cert_type)
694     else:
695         CN_ext = ""
696     csr_filename = "{}{}".format(CN, CN_ext)
697     if not cert_filename:
698         cert_filename = "{}{}".format(CN, CN_ext)
699     if not replace and os.path.exists(
700         os.path.join(
701             os.path.sep.join(
702                 "{}/{}/certs/{}.crt".format(
703                     cert_base_path(), ca_name, cert_filename
704                 ).split("/")
705             )
706         )
707     ):
708         return 'Certificate "{}" already exists'.format(cert_filename)
709     try:
710         maybe_fix_ssl_version(ca_name, cacert_path=cacert_path, ca_filename=ca_filename)
711         with salt.utils.files.fopen(
712             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
713         ) as fhr:
714             ca_cert = OpenSSL.crypto.load_certificate(
715                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
716             )
717         with salt.utils.files.fopen(
718             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
719         ) as fhr:
720             ca_key = OpenSSL.crypto.load_privatekey(
721                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
722             )
723     except OSError:
724         ret["retcode"] = 1
725         ret["comment"] = 'There is no CA named "{}"'.format(ca_name)
726         return ret
727     try:
728         csr_path = "{}/{}.csr".format(cert_path, csr_filename)
729         with salt.utils.files.fopen(csr_path) as fhr:
730             req = OpenSSL.crypto.load_certificate_request(
731                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
732             )
733     except OSError:
734         ret["retcode"] = 1
735         ret["comment"] = 'There is no CSR that matches the CN "{}"'.format(
736             cert_filename
737         )
738         return ret
739     exts = []
740     try:
741         exts.extend(req.get_extensions())
742     except AttributeError:
743         try:
744             log.info(
745                 "req.get_extensions() not supported in pyOpenSSL versions "
746                 "prior to 0.15. Processing extensions internally. "
747                 "Your version: %s",
748                 OpenSSL_version,
749             )
750             native_exts_obj = OpenSSL._util.lib.X509_REQ_get_extensions(req._req)
751             for i in range(OpenSSL._util.lib.sk_X509_EXTENSION_num(native_exts_obj)):
752                 ext = OpenSSL.crypto.X509Extension.__new__(OpenSSL.crypto.X509Extension)
753                 ext._extension = OpenSSL._util.lib.sk_X509_EXTENSION_value(
754                     native_exts_obj, i
755                 )
756                 exts.append(ext)
757         except Exception:  # pylint: disable=broad-except
758             log.error(
759                 "X509 extensions are unsupported in pyOpenSSL "
760                 "versions prior to 0.14. Upgrade required to "
761                 "use extensions. Current version: %s",
762                 OpenSSL_version,
763             )
764     cert = OpenSSL.crypto.X509()
765     cert.set_version(2)
766     cert.set_subject(req.get_subject())
767     cert.gmtime_adj_notBefore(0)
768     cert.gmtime_adj_notAfter(int(days) * 24 * 60 * 60)
769     cert.set_serial_number(_new_serial(ca_name))
770     cert.set_issuer(ca_cert.get_subject())
771     cert.set_pubkey(req.get_pubkey())
772     cert.add_extensions(exts)
773     cert.sign(ca_key, salt.utils.stringutils.to_str(digest))
774     cert_full_path = "{}/{}.crt".format(cert_path, cert_filename)
775     with salt.utils.files.fopen(cert_full_path, "wb+") as crt:
776         crt.write(
777             salt.utils.stringutils.to_bytes(
778                 OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
779             )
780         )
781     _write_cert_to_database(ca_name, cert)
782     return 'Created Certificate for "{}": "{}/{}.crt"'.format(
783         CN, cert_path, cert_filename
784     )
785 def create_pkcs12(ca_name, CN, passphrase="", cacert_path=None, replace=False):
786     """
787     Create a PKCS#12 browser certificate for a particular Certificate (CN)
788     ca_name
789         name of the CA
790     CN
791         common name matching the certificate signing request
792     passphrase
793         used to unlock the PKCS#12 certificate when loaded into the browser
794     cacert_path
795         absolute path to ca certificates root directory
796     replace
797         Replace this certificate even if it exists
798         .. versionadded:: 2015.5.1
799     If the following values were set::
800         ca.cert_base_path='/etc/pki'
801         ca_name='koji'
802         CN='test.egavas.org'
803     the resulting signed certificate would be written in the
804     following location::
805         /etc/pki/koji/certs/test.egavas.org.p12
806     CLI Example:
807     .. code-block:: bash
808         salt '*' tls.create_pkcs12 test localhost
809     """
810     set_ca_path(cacert_path)
811     if not replace and os.path.exists(
812         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN)
813     ):
814         return 'Certificate "{}" already exists'.format(CN)
815     try:
816         with salt.utils.files.fopen(
817             "{0}/{1}/{1}_ca_cert.crt".format(cert_base_path(), ca_name)
818         ) as fhr:
819             ca_cert = OpenSSL.crypto.load_certificate(
820                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
821             )
822     except OSError:
823         return 'There is no CA named "{}"'.format(ca_name)
824     try:
825         with salt.utils.files.fopen(
826             "{}/{}/certs/{}.crt".format(cert_base_path(), ca_name, CN)
827         ) as fhr:
828             cert = OpenSSL.crypto.load_certificate(
829                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
830             )
831         with salt.utils.files.fopen(
832             "{}/{}/certs/{}.key".format(cert_base_path(), ca_name, CN)
833         ) as fhr:
834             key = OpenSSL.crypto.load_privatekey(
835                 OpenSSL.crypto.FILETYPE_PEM, fhr.read()
836             )
837     except OSError:
838         return 'There is no certificate that matches the CN "{}"'.format(CN)
839     pkcs12 = OpenSSL.crypto.PKCS12()
840     pkcs12.set_certificate(cert)
841     pkcs12.set_ca_certificates([ca_cert])
842     pkcs12.set_privatekey(key)
843     with salt.utils.files.fopen(
844         "{}/{}/certs/{}.p12".format(cert_base_path(), ca_name, CN), "wb"
845     ) as ofile:
846         ofile.write(
847             pkcs12.export(passphrase=salt.utils.stringutils.to_bytes(passphrase))
848         )
849     return 'Created PKCS#12 Certificate for "{0}": "{1}/{2}/certs/{0}.p12"'.format(
850         CN,
851         cert_base_path(),
852         ca_name,
853     )
854 def cert_info(cert, digest="sha256"):
855     """
856     Return information for a particular certificate
857     cert
858         path to the certifiate PEM file or string
859         .. versionchanged:: 2018.3.4
860     digest
861         what digest to use for fingerprinting
862     CLI Example:
863     .. code-block:: bash
864         salt '*' tls.cert_info /dir/for/certs/cert.pem
865     """
866     date_fmt = "%Y%m%d%H%M%SZ"
867     if "-----BEGIN" not in cert:
868         with salt.utils.files.fopen(cert) as cert_file:
869             cert = cert_file.read()
870     cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)
871     issuer = {}
872     for key, value in cert.get_issuer().get_components():
873         if isinstance(key, bytes):
874             key = salt.utils.stringutils.to_unicode(key)
875         if isinstance(value, bytes):
876             value = salt.utils.stringutils.to_unicode(value)
877         issuer[key] = value
878     subject = {}
879     for key, value in cert.get_subject().get_components():
880         if isinstance(key, bytes):
881             key = salt.utils.stringutils.to_unicode(key)
882         if isinstance(value, bytes):
883             value = salt.utils.stringutils.to_unicode(value)
884     ret = {
885         "fingerprint": salt<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.stringutils.to_unicode(
886             cert.digest(salt.utils.stringutils.to_str(digest))
887         ),
888         "subject": subject,
889         "issuer": issuer,
890         "serial_number": cert.get_serial_number(),
891         "not_before": calendar.</b></font>timegm(
892             time.strptime(
893                 str(cert.get_notBefore().decode(__salt_system_encoding__)), date_fmt
894             )
895         ),
896         "not_after": calendar.timegm(
897             time.strptime(
898                 cert.get_notAfter().decode(__salt_system_encoding__), date_fmt
899             )
900         ),
901     }
902     if hasattr(cert, "get_extension_count"):
903         ret["extensions"] = {}
904         for i in range(cert.get_extension_count()):
905             try:
906                 ext = cert.get_extension(i)
907                 key = salt.utils.stringutils.to_unicode(ext.get_short_name())
908                 ret["extensions"][key] = str(ext).strip()
909             except AttributeError:
910                 continue
911     if "subjectAltName" in ret.get("extensions", {}):
912         valid_entries = ("DNS", "IP Address")
913         valid_names = set()
914         for name in str(ret["extensions"]["subjectAltName"]).split(", "):
915             entry, name = name.split(":", 1)
916             if entry not in valid_entries:
917                 log.error(
918                     "Cert %s has an entry (%s) which does not start with %s",
919                     ret["subject"],
920                     name,
921                     "/".join(valid_entries),
922                 )
923             else:
924                 valid_names.add(name)
925         ret["subject_alt_names"] = list(valid_names)
926     if hasattr(cert, "get_signature_algorithm"):
927         try:
928             value = cert.get_signature_algorithm()
929             if isinstance(value, bytes):
930                 value = salt.utils.stringutils.to_unicode(value)
931             ret["signature_algorithm"] = value
932         except AttributeError:
933             pass
934     return ret
935 def create_empty_crl(
936     ca_name, cacert_path=None, ca_filename=None, crl_file=None, digest="sha256"
937 ):
938     """
939     Create an empty Certificate Revocation List.
940     .. versionadded:: 2015.8.0
941     ca_name
942         name of the CA
943     cacert_path
944         absolute path to ca certificates root directory
945     ca_filename
946         alternative filename for the CA
947         .. versionadded:: 2015.5.3
948     crl_file
949         full path to the CRL file
950     digest
951         The message digest algorithm. Must be a string describing a digest
952         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
953         For example, "md5" or "sha1". Default: 'sha256'
954     CLI Example:
955     .. code-block:: bash
956         salt '*' tls.create_empty_crl ca_name='koji' \
957                 ca_filename='ca' \
958                 crl_file='/etc/openvpn/team1/crl.pem'
959     """
960     set_ca_path(cacert_path)
961     if not ca_filename:
962         ca_filename = "{}_ca_cert".format(ca_name)
963     if not crl_file:
964         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
965     if os.path.exists("{}".format(crl_file)):
966         return 'CRL "{}" already exists'.format(crl_file)
967     try:
968         with salt.utils.files.fopen(
969             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
970         ) as fp_:
971             ca_cert = OpenSSL.crypto.load_certificate(
972                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
973             )
974         with salt.utils.files.fopen(
975             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
976         ) as fp_:
977             ca_key = OpenSSL.crypto.load_privatekey(
978                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
979             )
980     except OSError:
981         return 'There is no CA named "{}"'.format(ca_name)
982     crl = OpenSSL.crypto.CRL()
983     crl_text = crl.export(
984         ca_cert,
985         ca_key,
986         digest=salt.utils.stringutils.to_bytes(digest),
987     )
988     with salt.utils.files.fopen(crl_file, "w") as f:
989         f.write(salt.utils.stringutils.to_str(crl_text))
990     return 'Created an empty CRL: "{}"'.format(crl_file)
991 def revoke_cert(
992     ca_name,
993     CN,
994     cacert_path=None,
995     ca_filename=None,
996     cert_path=None,
997     cert_filename=None,
998     crl_file=None,
999     digest="sha256",
1000 ):
1001     """
1002     Revoke a certificate.
1003     .. versionadded:: 2015.8.0
1004     ca_name
1005         Name of the CA.
1006     CN
1007         Common name matching the certificate signing request.
1008     cacert_path
1009         Absolute path to ca certificates root directory.
1010     ca_filename
1011         Alternative filename for the CA.
1012     cert_path
1013         Path to the cert file.
1014     cert_filename
1015         Alternative filename for the certificate, useful when using special
1016         characters in the CN.
1017     crl_file
1018         Full path to the CRL file.
1019     digest
1020         The message digest algorithm. Must be a string describing a digest
1021         algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).
1022         For example, "md5" or "sha1". Default: 'sha256'
1023     CLI Example:
1024     .. code-block:: bash
1025         salt '*' tls.revoke_cert ca_name='koji' \
1026                 ca_filename='ca' \
1027                 crl_file='/etc/openvpn/team1/crl.pem'
1028     """
1029     set_ca_path(cacert_path)
1030     ca_dir = "{}/{}".format(cert_base_path(), ca_name)
1031     if ca_filename is None:
1032         ca_filename = "{}_ca_cert".format(ca_name)
1033     if cert_path is None:
1034         cert_path = "{}/{}/certs".format(_cert_base_path(), ca_name)
1035     if cert_filename is None:
1036         cert_filename = "{}".format(CN)
1037     try:
1038         with salt.utils.files.fopen(
1039             "{}/{}/{}.crt".format(cert_base_path(), ca_name, ca_filename)
1040         ) as fp_:
1041             ca_cert = OpenSSL.crypto.load_certificate(
1042                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1043             )
1044         with salt.utils.files.fopen(
1045             "{}/{}/{}.key".format(cert_base_path(), ca_name, ca_filename)
1046         ) as fp_:
1047             ca_key = OpenSSL.crypto.load_privatekey(
1048                 OpenSSL.crypto.FILETYPE_PEM, fp_.read()
1049             )
1050     except OSError:
1051         return 'There is no CA named "{}"'.format(ca_name)
1052     client_cert = _read_cert("{}/{}.crt".format(cert_path, cert_filename))
1053     if client_cert is None:
1054         return 'There is no client certificate named "{}"'.format(CN)
1055     index_file, expire_date, serial_number, subject = _get_basic_info(
1056         ca_name, client_cert, ca_dir
1057     )
1058     index_serial_subject = "{}\tunknown\t{}".format(serial_number, subject)
1059     index_v_data = "V\t{}\t\t{}".format(expire_date, index_serial_subject)
1060     index_r_data_pattern = re.compile(
1061         r"R\t" + expire_date + r"\t\d{12}Z\t" + re.escape(index_serial_subject)
1062     )
1063     index_r_data = "R\t{}\t{}\t{}".format(
1064         expire_date,
1065         _four_digit_year_to_two_digit(datetime.utcnow()),
1066         index_serial_subject,
1067     )
1068     ret = {}
1069     with salt.utils.files.fopen(index_file) as fp_:
1070         for line in fp_:
1071             line = salt.utils.stringutils.to_unicode(line)
1072             if index_r_data_pattern.match(line):
1073                 revoke_date = line.split("\t")[2]
1074                 try:
1075                     datetime.strptime(revoke_date, two_digit_year_fmt)
1076                     return '"{}/{}.crt" was already revoked, serial number: {}'.format(
1077                         cert_path, cert_filename, serial_number
1078                     )
1079                 except ValueError:
1080                     ret["retcode"] = 1
1081                     ret[
1082                         "comment"
1083                     ] = "Revocation date '{}' does not matchformat '{}'".format(
1084                         revoke_date, two_digit_year_fmt
1085                     )
1086                     return ret
1087             elif index_serial_subject in line:
1088                 __salt__["file.replace"](
1089                     index_file, index_v_data, index_r_data, backup=False
1090                 )
1091                 break
1092     crl = OpenSSL.crypto.CRL()
1093     with salt.utils.files.fopen(index_file) as fp_:
1094         for line in fp_:
1095             line = salt.utils.stringutils.to_unicode(line)
1096             if line.startswith("R"):
1097                 fields = line.split("\t")
1098                 revoked = OpenSSL.crypto.Revoked()
1099                 revoked.set_serial(salt.utils.stringutils.to_bytes(fields[3]))
1100                 revoke_date_2_digit = datetime.strptime(fields[2], two_digit_year_fmt)
1101                 revoked.set_rev_date(
1102                     salt.utils.stringutils.to_bytes(
1103                         revoke_date_2_digit.strftime(four_digit_year_fmt)
1104                     )
1105                 )
1106                 crl.add_revoked(revoked)
1107     crl_text = crl.export(
1108         ca_cert, ca_key, digest=salt.utils.stringutils.to_bytes(digest)
1109     )
1110     if crl_file is None:
1111         crl_file = "{}/{}/crl.pem".format(_cert_base_path(), ca_name)
1112     if os.path.isdir(crl_file):
1113         ret["retcode"] = 1
1114         ret["comment"] = 'crl_file "{}" is an existing directory'.format(crl_file)
1115         return ret
1116     with salt.utils.files.fopen(crl_file, "w") as fp_:
1117         fp_.write(salt.utils.stringutils.to_str(crl_text))
1118     return 'Revoked Certificate: "{}/{}.crt", serial number: {}'.format(
1119         cert_path, cert_filename, serial_number
1120     )
1121 if __name__ == "__main__":
1122     create_csr(
1123         "koji",
1124         CN="test_system",
1125         C="US",
1126         ST="Utah",
1127         L="Centerville",
1128         O="SaltStack",
1129         OU=None,
1130         emailAddress="test_system@saltstack.org",
1131     )
1132     create_ca_signed_cert("koji", "test_system")
1133     create_pkcs12("koji", "test_system", passphrase="test")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
