
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-initializers_test.py</h3>
            <pre><code>1  import itertools
2  from absl.testing import parameterized
3  import numpy as np
4  from sonnet.src import initializers
5  from sonnet.src import test_utils
6  import tensorflow as tf
7  class InitializersTest(test_utils.TestCase, parameterized.TestCase):
8    def assertDifferentInitializerValues(self,
9                                         init,
10                                         shape=None,
11                                         dtype=tf.float32):
12      if shape is None:
13        shape = (100,)
14      t1 = self.evaluate(init(shape, dtype))
15      t2 = self.evaluate(init(shape, dtype))
16      self.assertEqual(t1.shape, shape)
17      self.assertEqual(t2.shape, shape)
18      self.assertFalse(np.allclose(t1, t2, rtol=1e-15, atol=1e-15))
19    def assertRange(self,
20                    init,
21                    shape,
22                    target_mean=None,
23                    target_std=None,
24                    target_max=None,
25                    target_min=None,
26                    dtype=tf.float32):
27      output = self.evaluate(init(shape, dtype))
28      self.assertEqual(output.shape, shape)
29      lim = 4e-2
30      if target_std is not None:
31        self.assertNear(output.std(), target_std, err=lim)
32      if target_mean is not None:
33        self.assertNear(output.mean(), target_mean, err=lim)
34      if target_max is not None:
35        self.assertNear(output.max(), target_max, err=lim)
36      if target_min is not None:
37        self.assertNear(output.min(), target_min, err=lim)
38  class ConstantInitializersTest(InitializersTest):
39    @parameterized.parameters(tf.float32, tf.int32)
40    def testZeros(self, dtype):
41      self.assertRange(
42          initializers.Zeros(),
43          shape=(4, 5),
44          target_mean=0.,
45          target_max=0.,
<span onclick='openModal()' class='match'>46          dtype=dtype)
47    @parameterized.parameters(tf.float32, tf.int32)
48    def testOnes(self, dtype):
49      self.assertRange(
</span>50          initializers.Ones(),
51          shape=(4, 5),
52          target_mean=1.,
53          target_max=1.,
54          dtype=dtype)
55    @parameterized.named_parameters(
56        (&quot;Tensor&quot;, lambda: tf.constant([1.0, 2.0, 3.0]), &quot;Tensor&quot;),
57        (&quot;Variable&quot;, lambda: tf.Variable([3.0, 2.0, 1.0]), &quot;Variable&quot;),
58        (&quot;List&quot;, lambda: [], &quot;list&quot;), (&quot;Tuple&quot;, lambda: (), &quot;tuple&quot;))
59    def testConstantInvalidValue(self, value, value_type):
60      with self.assertRaisesRegex(
61          TypeError, r&quot;Invalid type for value: .*{}.*&quot;.format(value_type)):
62        initializers.Constant(value())
63    @parameterized.parameters((42, tf.float32), (42.0, tf.float32),
64                              (42, tf.int32))
65    def testConstantValidValue(self, value, dtype):
66      self.assertRange(
67          initializers.Constant(value),
68          shape=(4, 5),
69          target_mean=42.,
70          target_max=42.,
71          dtype=dtype)
72    @parameterized.parameters(initializers.Zeros, initializers.Ones)
73    def testInvalidDataType(self, initializer):
74      init = initializer()
75      with self.assertRaisesRegex(
76          ValueError, r&quot;Expected integer or floating point type, got &quot;):
77        init([1], dtype=tf.string)
78    def testInvalidDataTypeConstant(self):
79      init = initializers.Constant(0)
80      with self.assertRaisesRegex(
81          ValueError, r&quot;Expected integer or floating point type, got &quot;):
82        init([1], dtype=tf.string)
83    def testTFFunction(self):
84      init = initializers.Constant(2)
85      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
86      expected = init([7, 4], tf.float32)
87      x = f(tf.zeros([7, 4]))
88      self.assertAllEqual(expected, x)
89    def testBatchAgnostic(self):
90      init = initializers.Constant(2)
91      spec = tf.TensorSpec(shape=[None, None])
92      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
93      f = f.get_concrete_function(spec)
94      expected = init([7, 4], tf.float32)
95      x = f(tf.ones([7, 4]))
96      self.assertAllEqual(expected, x)
97  class RandomUniformInitializerTest(InitializersTest):
98    def testRangeInitializer(self):
99      shape = (16, 8, 128)
100      self.assertRange(
101          initializers.RandomUniform(minval=-1., maxval=1., seed=124.),
102          shape,
103          target_mean=0.,
104          target_max=1,
105          target_min=-1)
106    @parameterized.parameters(tf.float32, tf.int32)
107    def testDifferentInitializer(self, dtype):
108      init = initializers.RandomUniform(0, 10)
109      self.assertDifferentInitializerValues(init, dtype=dtype)
110    def testInvalidDataType(self):
111      init = initializers.RandomUniform()
112      with self.assertRaisesRegex(
113          ValueError, r&quot;Expected integer or floating point type, got &quot;):
114        init([1], dtype=tf.string)
115    def testTFFunction(self):
116      init = initializers.RandomUniform(seed=42)
117      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
118      expected = init([7, 4], tf.float32)
119      x = f(tf.zeros([7, 4]))
120      self.assertEqual(x.shape, [7, 4])
121      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
122        self.assertAllEqual(expected, x)
123    def testBatchAgnostic(self):
124      init = initializers.RandomUniform(seed=42)
125      spec = tf.TensorSpec(shape=[None, None])
126      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
127      f = f.get_concrete_function(spec)
128      expected = init([7, 4], tf.float32)
129      x = f(tf.ones([7, 4]))
130      self.assertEqual(x.shape, [7, 4])
131      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
132        self.assertAllEqual(expected, x)
133  class RandomNormalInitializerTest(InitializersTest):
134    def testRangeInitializer(self):
135      self.assertRange(
136          initializers.RandomNormal(mean=0, stddev=1, seed=153),
137          shape=(16, 8, 128),
138          target_mean=0.,
139          target_std=1)
140    def testDifferentInitializer(self):
141      init = initializers.RandomNormal(0.0, 1.0)
142      self.assertDifferentInitializerValues(init)
143    @parameterized.parameters(tf.int32, tf.string)
144    def testInvalidDataType(self, dtype):
145      init = initializers.RandomNormal(0.0, 1.0)
146      with self.assertRaisesRegex(ValueError,
147                                  r&quot;Expected floating point type, got &quot;):
148        init([1], dtype=dtype)
149    def testTFFunction(self):
150      init = initializers.RandomNormal(seed=42)
151      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
152      expected = init([7, 4], tf.float32)
153      x = f(tf.zeros([7, 4]))
154      self.assertEqual(x.shape, [7, 4])
155      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
156        self.assertAllEqual(expected, x)
157    def testBatchAgnostic(self):
158      init = initializers.RandomNormal(seed=42)
159      spec = tf.TensorSpec(shape=[None, None])
160      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
161      f = f.get_concrete_function(spec)
162      expected = init([7, 4], tf.float32)
163      x = f(tf.ones([7, 4]))
164      self.assertEqual(x.shape, [7, 4])
165      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
166        self.assertAllEqual(expected, x)
167  class TruncatedNormalInitializerTest(InitializersTest):
168    def testRangeInitializer(self):
169      self.assertRange(
170          initializers.TruncatedNormal(mean=0, stddev=1, seed=126),
171          shape=(16, 8, 128),
172          target_mean=0.,
173          target_max=2,
174          target_min=-2)
175    def testDifferentInitializer(self):
176      init = initializers.TruncatedNormal(0.0, 1.0)
177      self.assertDifferentInitializerValues(init)
178    @parameterized.parameters(tf.int32, tf.string)
179    def testInvalidDataType(self, dtype):
180      init = initializers.TruncatedNormal(0.0, 1.0)
181      with self.assertRaisesRegex(ValueError,
182                                  r&quot;Expected floating point type, got &quot;):
183        init([1], dtype=dtype)
184    def testTFFunction(self):
185      init = initializers.TruncatedNormal(seed=42)
186      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
187      expected = init([7, 4], tf.float32)
188      x = f(tf.zeros([7, 4]))
189      self.assertEqual(x.shape, [7, 4])
190      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
191        self.assertAllEqual(expected, x)
192    def testBatchAgnostic(self):
193      init = initializers.TruncatedNormal(seed=42)
194      spec = tf.TensorSpec(shape=[None, None])
195      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
196      f = f.get_concrete_function(spec)
197      expected = init([7, 4], tf.float32)
198      x = f(tf.ones([7, 4]))
199      self.assertEqual(x.shape, [7, 4])
200      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
201        self.assertAllEqual(expected, x)
202  class IdentityInitializerTest(InitializersTest):
203    @parameterized.parameters(
204        *itertools.product([(4, 5), (3, 3), (3, 4, 5),
205                            (6, 2, 3, 3)], [3, 1], [tf.float32, tf.int32]))
206    def testRange(self, shape, gain, dtype):
207      if self.primary_device == &quot;GPU&quot; and dtype == tf.int32:
208        self.skipTest(&quot;tf.int32 not supported on GPU&quot;)
209      self.assertRange(
210          initializers.Identity(gain),
211          shape=shape,
212          target_mean=gain / shape[-1],
213          target_max=gain,
214          dtype=dtype)
215    def testInvalidDataType(self):
216      init = initializers.Identity()
217      with self.assertRaisesRegex(
218          ValueError, r&quot;Expected integer or floating point type, got &quot;):
219        init([1, 2], dtype=tf.string)
220    @parameterized.parameters(tf.float32, tf.int32)
221    def testInvalidShape(self, dtype):
222      init = initializers.Identity()
223      with self.assertRaisesRegex(
224          ValueError,
225          &quot;The tensor to initialize must be at least two-dimensional&quot;):
226        init([1], dtype=dtype)
227    def testTFFunction(self):
228      init = initializers.Identity()
229      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
230      expected = init([4, 4], tf.float32)
231      x = f(tf.ones([4, 4]))
232      self.assertAllEqual(expected, x)
233    def testTFFunction4D(self):
234      init = initializers.Identity()
235      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
236      expected = init([4, 4, 3, 2], tf.float32)
237      x = f(tf.ones([4, 4, 3, 2]))
238      self.assertAllEqual(expected, x)
239    def testBatchAgnostic(self):
240      init = initializers.Identity()
241      spec = tf.TensorSpec(shape=[None, None])
242      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
243      f = f.get_concrete_function(spec)
244      expected = init([7, 4], tf.float32)
245      x = f(tf.ones([7, 4]))
246      self.assertAllEqual(expected, x)
247  class OrthogonalInitializerTest(InitializersTest):
248    def testRangeInitializer(self):
249      self.assertRange(
250          initializers.Orthogonal(seed=123), shape=(20, 20), target_mean=0.)
251    def testDuplicatedInitializer(self):
252      init = initializers.Orthogonal()
253      self.assertDifferentInitializerValues(init, (10, 10))
254    @parameterized.parameters(tf.int32, tf.string)
255    def testInvalidDataType(self, dtype):
256      init = initializers.Orthogonal()
257      with self.assertRaisesRegex(ValueError,
258                                  r&quot;Expected floating point type, got &quot;):
259        init([1, 2], dtype=dtype)
260    def testInvalidShape(self):
261      init = initializers.Orthogonal()
262      with self.assertRaisesRegex(
263          ValueError,
264          &quot;The tensor to initialize must be at least two-dimensional&quot;):
265        init([1], tf.float32)
266    @parameterized.named_parameters(
267        (&quot;Square&quot;, (10, 10)), (&quot;3DSquare&quot;, (100, 5, 5)),
268        (&quot;3DRectangle&quot;, (10, 9, 8)), (&quot;TallRectangle&quot;, (50, 40)),
269        (&quot;WideRectangle&quot;, (40, 50)))
270    def testShapesValues(self, shape):
271      init = initializers.Orthogonal()
272      tol = 1e-5
273      t = self.evaluate(init(shape, tf.float32))
274      self.assertAllEqual(tuple(shape), t.shape)
275      t = t.reshape((np.prod(t.shape[:-1]), t.shape[-1]))
276      if t.shape[0] &gt; t.shape[1]:
277        self.assertAllClose(
278            np.dot(t.T, t), np.eye(t.shape[1]), rtol=tol, atol=tol)
279      else:
280        self.assertAllClose(
281            np.dot(t, t.T), np.eye(t.shape[0]), rtol=tol, atol=tol)
282    def testTFFunctionSimple(self):
283      init = initializers.Orthogonal(seed=42)
284      f = tf.function(init)
285      x = f([4, 4], tf.float32)
286      self.assertAllEqual(x.shape, [4, 4])
287    def testTFFunction(self):
288      if self.primary_device == &quot;TPU&quot;:
289        self.skipTest(&quot;Dynamic slice not supported on TPU&quot;)
290      init = initializers.Orthogonal(seed=42)
291      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
292      expected = init([4, 4], tf.float32)
293      x = f(tf.ones([4, 4]))
294      self.assertAllEqual(expected, x)
295    def testBatchAgnostic(self):
296      if self.primary_device == &quot;TPU&quot;:
297        self.skipTest(&quot;Dynamic slice not supported on TPU&quot;)
298      init = initializers.Orthogonal(seed=42)
299      spec = tf.TensorSpec(shape=[None, None])
300      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
301      f = f.get_concrete_function(spec)
302      expected = init([7, 4], tf.float32)
303      x = f(tf.ones([7, 4]))
304      self.assertAllEqual(expected, x)
305  class VarianceScalingInitializerTest(InitializersTest):
306    def testTruncatedNormalDistribution(self):
307      shape = (100, 100)
308      init = initializers.VarianceScaling(distribution=&quot;truncated_normal&quot;)
309      self.assertRange(
310          init, shape=shape, target_mean=0., target_std=1. / np.sqrt(shape[0]))
311    def testNormalDistribution(self):
312      shape = (100, 100)
313      init = initializers.VarianceScaling(distribution=&quot;normal&quot;)
314      self.assertRange(
315          init, shape=shape, target_mean=0., target_std=1. / np.sqrt(shape[0]))
316    def testUniformDistribution(self):
317      shape = (100, 100)
318      init = initializers.VarianceScaling(distribution=&quot;uniform&quot;)
319      self.assertRange(
320          init, shape=shape, target_mean=0., target_std=1. / np.sqrt(shape[0]))
321    def testGlorotUniform(self):
322      shape = (5, 6, 4, 2)
323      fan_in, fan_out = initializers._compute_fans(shape)
324      std = np.sqrt(2. / (fan_in + fan_out))
325      self.assertRange(
326          initializers.VarianceScaling(
327              scale=1.0, mode=&quot;fan_avg&quot;, distribution=&quot;uniform&quot;, seed=123),
328          shape,
329          target_mean=0.,
330          target_std=std)
331    def test_GlorotNormal(self):
332      shape = (5, 6, 4, 2)
333      fan_in, fan_out = initializers._compute_fans(shape)
334      std = np.sqrt(2. / (fan_in + fan_out))
335      self.assertRange(
336          initializers.VarianceScaling(
337              scale=1.0,
338              mode=&quot;fan_avg&quot;,
339              distribution=&quot;truncated_normal&quot;,
340              seed=123),
341          shape,
342          target_mean=0.,
343          target_std=std)
344    def testLecunUniform(self):
345      shape = (5, 6, 4, 2)
346      fan_in, _ = initializers._compute_fans(shape)
347      std = np.sqrt(1. / fan_in)
348      self.assertRange(
349          initializers.VarianceScaling(
350              scale=1.0, mode=&quot;fan_in&quot;, distribution=&quot;uniform&quot;, seed=123),
351          shape,
352          target_mean=0.,
353          target_std=std)
354    def testLecunNormal(self):
355      shape = (5, 6, 4, 2)
356      fan_in, _ = initializers._compute_fans(shape)
357      std = np.sqrt(1. / fan_in)
358      self.assertRange(
359          initializers.VarianceScaling(
360              scale=1.0, mode=&quot;fan_in&quot;, distribution=&quot;truncated_normal&quot;,
361              seed=123),
362          shape,
363          target_mean=0.,
364          target_std=std)
365    def testHeUniform(self):
366      shape = (5, 6, 4, 2)
367      fan_in, _ = initializers._compute_fans(shape)
368      std = np.sqrt(2. / fan_in)
369      self.assertRange(
370          initializers.VarianceScaling(
371              scale=2.0, mode=&quot;fan_in&quot;, distribution=&quot;uniform&quot;, seed=123),
372          shape,
373          target_mean=0.,
374          target_std=std)
375    def testHeNormal(self):
376      shape = (5, 6, 4, 2)
377      fan_in, _ = initializers._compute_fans(shape)
378      std = np.sqrt(2. / fan_in)
379      self.assertRange(
380          initializers.VarianceScaling(
381              scale=2.0, mode=&quot;fan_in&quot;, distribution=&quot;truncated_normal&quot;,
382              seed=123),
383          shape,
384          target_mean=0.,
385          target_std=std)
386    @parameterized.parameters(
387        itertools.product([&quot;fan_in&quot;, &quot;fan_out&quot;, &quot;fan_avg&quot;],
388                          [&quot;uniform&quot;, &quot;truncated_normal&quot;, &quot;normal&quot;]))
389    def testMixedShape(self, mode, distribution):
390      init = initializers.VarianceScaling(mode=mode, distribution=distribution)
391      tf.random.set_seed(42)
392      x = init([tf.constant(4), 2], tf.float32)
393      tf.random.set_seed(42)
394      expected = init([4, 2], tf.float32)
395      self.assertEqual(x.shape, [4, 2])
396      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
397        self.assertAllEqual(expected, x)
398    @parameterized.parameters(
399        itertools.product([&quot;fan_in&quot;, &quot;fan_out&quot;, &quot;fan_avg&quot;],
400                          [&quot;uniform&quot;, &quot;truncated_normal&quot;, &quot;normal&quot;]))
401    def testWithTFFunction(self, mode, distribution):
402      init = initializers.VarianceScaling(
403          mode=mode, distribution=distribution, seed=42)
404      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
405      x = f(tf.zeros([4, 2]))
406      expected = init([4, 2], tf.float32)
407      self.assertEqual(x.shape, [4, 2])
408      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
409        self.assertAllClose(expected, x)
410    @parameterized.parameters(
411        itertools.product([&quot;fan_in&quot;, &quot;fan_out&quot;, &quot;fan_avg&quot;],
412                          [&quot;uniform&quot;, &quot;truncated_normal&quot;, &quot;normal&quot;]))
413    def testBatchAgnostic(self, mode, distribution):
414      init = initializers.VarianceScaling(
415          mode=mode, distribution=distribution, seed=42)
416      spec = tf.TensorSpec(shape=[None, None])
417      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
418      f = f.get_concrete_function(spec)
419      expected = init([7, 4], tf.float32)
420      x = f(tf.ones([7, 4]))
421      self.assertEqual(x.shape, [7, 4])
422      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
423        self.assertAllClose(expected, x)
424    @parameterized.parameters(tf.int32, tf.string)
425    def testInvalidDataType(self, dtype):
426      init = initializers.VarianceScaling()
427      with self.assertRaisesRegex(ValueError,
428                                  r&quot;Expected floating point type, got &quot;):
429        init([1, 2], dtype=dtype)
430    def testCheckInitializersInvalidType(self):
431      with self.assertRaisesRegex(TypeError,
432                                  &quot;Initializers must be a dict-like object.&quot;):
433        initializers.check_initializers([1, 2, 3], (&quot;a&quot;))
434    def testCheckInitalizersEmpty(self):
435      a = initializers.check_initializers(None, (&quot;b&quot;))
436      self.assertEqual(a, {})
437    @parameterized.named_parameters((&quot;Tuple&quot;, (&quot;a&quot;, &quot;b&quot;)), (&quot;List&quot;, [&quot;a&quot;, &quot;b&quot;]),
438                                    (&quot;Set&quot;, {&quot;a&quot;, &quot;b&quot;}))
439    def testCheckInitalizersValid(self, keys):
440      initializers.check_initializers({
441          &quot;a&quot;: lambda x, y: 0,
442          &quot;b&quot;: lambda x, y: 1
443      }, keys)
444    def testCheckInitalizersInvalid(self):
445      with self.assertRaisesRegex(
446          KeyError,
447          r&quot;Invalid initializer keys &#x27;a&#x27;, initializers can only be provided for&quot;):
448        initializers.check_initializers({
449            &quot;a&quot;: lambda x, y: 0,
450            &quot;b&quot;: lambda x, y: 1
451        }, (&quot;b&quot;))
452  if __name__ == &quot;__main__&quot;:
453    tf.test.main()
</code></pre>
        </div>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-initializers_test.py</h3>
            <pre><code>1  import itertools
2  from absl.testing import parameterized
3  import numpy as np
4  from sonnet.src import initializers
5  from sonnet.src import test_utils
6  import tensorflow as tf
7  class InitializersTest(test_utils.TestCase, parameterized.TestCase):
8    def assertDifferentInitializerValues(self,
9                                         init,
10                                         shape=None,
11                                         dtype=tf.float32):
12      if shape is None:
13        shape = (100,)
14      t1 = self.evaluate(init(shape, dtype))
15      t2 = self.evaluate(init(shape, dtype))
16      self.assertEqual(t1.shape, shape)
17      self.assertEqual(t2.shape, shape)
18      self.assertFalse(np.allclose(t1, t2, rtol=1e-15, atol=1e-15))
19    def assertRange(self,
20                    init,
21                    shape,
22                    target_mean=None,
23                    target_std=None,
24                    target_max=None,
25                    target_min=None,
26                    dtype=tf.float32):
27      output = self.evaluate(init(shape, dtype))
28      self.assertEqual(output.shape, shape)
29      lim = 4e-2
30      if target_std is not None:
31        self.assertNear(output.std(), target_std, err=lim)
32      if target_mean is not None:
33        self.assertNear(output.mean(), target_mean, err=lim)
34      if target_max is not None:
35        self.assertNear(output.max(), target_max, err=lim)
36      if target_min is not None:
37        self.assertNear(output.min(), target_min, err=lim)
38  class ConstantInitializersTest(InitializersTest):
39    @parameterized.parameters(tf.float32, tf.int32)
40    def testZeros(self, dtype):
41      self.assertRange(
42          initializers.Zeros(),
43          shape=(4, 5),
44          target_mean=0.,
45          target_max=0.,
46          dtype=dtype)
47    @parameterized.parameters(tf.float32, tf.int32)
48    def testOnes(self, dtype):
49      self.assertRange(
50          initializers.Ones(),
51          shape=(4, 5),
52          target_mean=1.,
53          target_max=1.,
54          dtype=dtype)
55    @parameterized.named_parameters(
56        (&quot;Tensor&quot;, lambda: tf.constant([1.0, 2.0, 3.0]), &quot;Tensor&quot;),
57        (&quot;Variable&quot;, lambda: tf.Variable([3.0, 2.0, 1.0]), &quot;Variable&quot;),
58        (&quot;List&quot;, lambda: [], &quot;list&quot;), (&quot;Tuple&quot;, lambda: (), &quot;tuple&quot;))
59    def testConstantInvalidValue(self, value, value_type):
60      with self.assertRaisesRegex(
61          TypeError, r&quot;Invalid type for value: .*{}.*&quot;.format(value_type)):
62        initializers.Constant(value())
63    @parameterized.parameters((42, tf.float32), (42.0, tf.float32),
64                              (42, tf.int32))
65    def testConstantValidValue(self, value, dtype):
66      self.assertRange(
67          initializers.Constant(value),
68          shape=(4, 5),
69          target_mean=42.,
70          target_max=42.,
<span onclick='openModal()' class='match'>71          dtype=dtype)
72    @parameterized.parameters(initializers.Zeros, initializers.Ones)
73    def testInvalidDataType(self, initializer):
74      init = initializer()
</span>75      with self.assertRaisesRegex(
76          ValueError, r&quot;Expected integer or floating point type, got &quot;):
77        init([1], dtype=tf.string)
78    def testInvalidDataTypeConstant(self):
79      init = initializers.Constant(0)
80      with self.assertRaisesRegex(
81          ValueError, r&quot;Expected integer or floating point type, got &quot;):
82        init([1], dtype=tf.string)
83    def testTFFunction(self):
84      init = initializers.Constant(2)
85      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
86      expected = init([7, 4], tf.float32)
87      x = f(tf.zeros([7, 4]))
88      self.assertAllEqual(expected, x)
89    def testBatchAgnostic(self):
90      init = initializers.Constant(2)
91      spec = tf.TensorSpec(shape=[None, None])
92      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
93      f = f.get_concrete_function(spec)
94      expected = init([7, 4], tf.float32)
95      x = f(tf.ones([7, 4]))
96      self.assertAllEqual(expected, x)
97  class RandomUniformInitializerTest(InitializersTest):
98    def testRangeInitializer(self):
99      shape = (16, 8, 128)
100      self.assertRange(
101          initializers.RandomUniform(minval=-1., maxval=1., seed=124.),
102          shape,
103          target_mean=0.,
104          target_max=1,
105          target_min=-1)
106    @parameterized.parameters(tf.float32, tf.int32)
107    def testDifferentInitializer(self, dtype):
108      init = initializers.RandomUniform(0, 10)
109      self.assertDifferentInitializerValues(init, dtype=dtype)
110    def testInvalidDataType(self):
111      init = initializers.RandomUniform()
112      with self.assertRaisesRegex(
113          ValueError, r&quot;Expected integer or floating point type, got &quot;):
114        init([1], dtype=tf.string)
115    def testTFFunction(self):
116      init = initializers.RandomUniform(seed=42)
117      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
118      expected = init([7, 4], tf.float32)
119      x = f(tf.zeros([7, 4]))
120      self.assertEqual(x.shape, [7, 4])
121      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
122        self.assertAllEqual(expected, x)
123    def testBatchAgnostic(self):
124      init = initializers.RandomUniform(seed=42)
125      spec = tf.TensorSpec(shape=[None, None])
126      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
127      f = f.get_concrete_function(spec)
128      expected = init([7, 4], tf.float32)
129      x = f(tf.ones([7, 4]))
130      self.assertEqual(x.shape, [7, 4])
131      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
132        self.assertAllEqual(expected, x)
133  class RandomNormalInitializerTest(InitializersTest):
134    def testRangeInitializer(self):
135      self.assertRange(
136          initializers.RandomNormal(mean=0, stddev=1, seed=153),
137          shape=(16, 8, 128),
138          target_mean=0.,
139          target_std=1)
140    def testDifferentInitializer(self):
141      init = initializers.RandomNormal(0.0, 1.0)
142      self.assertDifferentInitializerValues(init)
143    @parameterized.parameters(tf.int32, tf.string)
144    def testInvalidDataType(self, dtype):
145      init = initializers.RandomNormal(0.0, 1.0)
146      with self.assertRaisesRegex(ValueError,
147                                  r&quot;Expected floating point type, got &quot;):
148        init([1], dtype=dtype)
149    def testTFFunction(self):
150      init = initializers.RandomNormal(seed=42)
151      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
152      expected = init([7, 4], tf.float32)
153      x = f(tf.zeros([7, 4]))
154      self.assertEqual(x.shape, [7, 4])
155      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
156        self.assertAllEqual(expected, x)
157    def testBatchAgnostic(self):
158      init = initializers.RandomNormal(seed=42)
159      spec = tf.TensorSpec(shape=[None, None])
160      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
161      f = f.get_concrete_function(spec)
162      expected = init([7, 4], tf.float32)
163      x = f(tf.ones([7, 4]))
164      self.assertEqual(x.shape, [7, 4])
165      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
166        self.assertAllEqual(expected, x)
167  class TruncatedNormalInitializerTest(InitializersTest):
168    def testRangeInitializer(self):
169      self.assertRange(
170          initializers.TruncatedNormal(mean=0, stddev=1, seed=126),
171          shape=(16, 8, 128),
172          target_mean=0.,
173          target_max=2,
174          target_min=-2)
175    def testDifferentInitializer(self):
176      init = initializers.TruncatedNormal(0.0, 1.0)
177      self.assertDifferentInitializerValues(init)
178    @parameterized.parameters(tf.int32, tf.string)
179    def testInvalidDataType(self, dtype):
180      init = initializers.TruncatedNormal(0.0, 1.0)
181      with self.assertRaisesRegex(ValueError,
182                                  r&quot;Expected floating point type, got &quot;):
183        init([1], dtype=dtype)
184    def testTFFunction(self):
185      init = initializers.TruncatedNormal(seed=42)
186      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
187      expected = init([7, 4], tf.float32)
188      x = f(tf.zeros([7, 4]))
189      self.assertEqual(x.shape, [7, 4])
190      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
191        self.assertAllEqual(expected, x)
192    def testBatchAgnostic(self):
193      init = initializers.TruncatedNormal(seed=42)
194      spec = tf.TensorSpec(shape=[None, None])
195      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
196      f = f.get_concrete_function(spec)
197      expected = init([7, 4], tf.float32)
198      x = f(tf.ones([7, 4]))
199      self.assertEqual(x.shape, [7, 4])
200      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
201        self.assertAllEqual(expected, x)
202  class IdentityInitializerTest(InitializersTest):
203    @parameterized.parameters(
204        *itertools.product([(4, 5), (3, 3), (3, 4, 5),
205                            (6, 2, 3, 3)], [3, 1], [tf.float32, tf.int32]))
206    def testRange(self, shape, gain, dtype):
207      if self.primary_device == &quot;GPU&quot; and dtype == tf.int32:
208        self.skipTest(&quot;tf.int32 not supported on GPU&quot;)
209      self.assertRange(
210          initializers.Identity(gain),
211          shape=shape,
212          target_mean=gain / shape[-1],
213          target_max=gain,
214          dtype=dtype)
215    def testInvalidDataType(self):
216      init = initializers.Identity()
217      with self.assertRaisesRegex(
218          ValueError, r&quot;Expected integer or floating point type, got &quot;):
219        init([1, 2], dtype=tf.string)
220    @parameterized.parameters(tf.float32, tf.int32)
221    def testInvalidShape(self, dtype):
222      init = initializers.Identity()
223      with self.assertRaisesRegex(
224          ValueError,
225          &quot;The tensor to initialize must be at least two-dimensional&quot;):
226        init([1], dtype=dtype)
227    def testTFFunction(self):
228      init = initializers.Identity()
229      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
230      expected = init([4, 4], tf.float32)
231      x = f(tf.ones([4, 4]))
232      self.assertAllEqual(expected, x)
233    def testTFFunction4D(self):
234      init = initializers.Identity()
235      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
236      expected = init([4, 4, 3, 2], tf.float32)
237      x = f(tf.ones([4, 4, 3, 2]))
238      self.assertAllEqual(expected, x)
239    def testBatchAgnostic(self):
240      init = initializers.Identity()
241      spec = tf.TensorSpec(shape=[None, None])
242      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
243      f = f.get_concrete_function(spec)
244      expected = init([7, 4], tf.float32)
245      x = f(tf.ones([7, 4]))
246      self.assertAllEqual(expected, x)
247  class OrthogonalInitializerTest(InitializersTest):
248    def testRangeInitializer(self):
249      self.assertRange(
250          initializers.Orthogonal(seed=123), shape=(20, 20), target_mean=0.)
251    def testDuplicatedInitializer(self):
252      init = initializers.Orthogonal()
253      self.assertDifferentInitializerValues(init, (10, 10))
254    @parameterized.parameters(tf.int32, tf.string)
255    def testInvalidDataType(self, dtype):
256      init = initializers.Orthogonal()
257      with self.assertRaisesRegex(ValueError,
258                                  r&quot;Expected floating point type, got &quot;):
259        init([1, 2], dtype=dtype)
260    def testInvalidShape(self):
261      init = initializers.Orthogonal()
262      with self.assertRaisesRegex(
263          ValueError,
264          &quot;The tensor to initialize must be at least two-dimensional&quot;):
265        init([1], tf.float32)
266    @parameterized.named_parameters(
267        (&quot;Square&quot;, (10, 10)), (&quot;3DSquare&quot;, (100, 5, 5)),
268        (&quot;3DRectangle&quot;, (10, 9, 8)), (&quot;TallRectangle&quot;, (50, 40)),
269        (&quot;WideRectangle&quot;, (40, 50)))
270    def testShapesValues(self, shape):
271      init = initializers.Orthogonal()
272      tol = 1e-5
273      t = self.evaluate(init(shape, tf.float32))
274      self.assertAllEqual(tuple(shape), t.shape)
275      t = t.reshape((np.prod(t.shape[:-1]), t.shape[-1]))
276      if t.shape[0] &gt; t.shape[1]:
277        self.assertAllClose(
278            np.dot(t.T, t), np.eye(t.shape[1]), rtol=tol, atol=tol)
279      else:
280        self.assertAllClose(
281            np.dot(t, t.T), np.eye(t.shape[0]), rtol=tol, atol=tol)
282    def testTFFunctionSimple(self):
283      init = initializers.Orthogonal(seed=42)
284      f = tf.function(init)
285      x = f([4, 4], tf.float32)
286      self.assertAllEqual(x.shape, [4, 4])
287    def testTFFunction(self):
288      if self.primary_device == &quot;TPU&quot;:
289        self.skipTest(&quot;Dynamic slice not supported on TPU&quot;)
290      init = initializers.Orthogonal(seed=42)
291      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
292      expected = init([4, 4], tf.float32)
293      x = f(tf.ones([4, 4]))
294      self.assertAllEqual(expected, x)
295    def testBatchAgnostic(self):
296      if self.primary_device == &quot;TPU&quot;:
297        self.skipTest(&quot;Dynamic slice not supported on TPU&quot;)
298      init = initializers.Orthogonal(seed=42)
299      spec = tf.TensorSpec(shape=[None, None])
300      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
301      f = f.get_concrete_function(spec)
302      expected = init([7, 4], tf.float32)
303      x = f(tf.ones([7, 4]))
304      self.assertAllEqual(expected, x)
305  class VarianceScalingInitializerTest(InitializersTest):
306    def testTruncatedNormalDistribution(self):
307      shape = (100, 100)
308      init = initializers.VarianceScaling(distribution=&quot;truncated_normal&quot;)
309      self.assertRange(
310          init, shape=shape, target_mean=0., target_std=1. / np.sqrt(shape[0]))
311    def testNormalDistribution(self):
312      shape = (100, 100)
313      init = initializers.VarianceScaling(distribution=&quot;normal&quot;)
314      self.assertRange(
315          init, shape=shape, target_mean=0., target_std=1. / np.sqrt(shape[0]))
316    def testUniformDistribution(self):
317      shape = (100, 100)
318      init = initializers.VarianceScaling(distribution=&quot;uniform&quot;)
319      self.assertRange(
320          init, shape=shape, target_mean=0., target_std=1. / np.sqrt(shape[0]))
321    def testGlorotUniform(self):
322      shape = (5, 6, 4, 2)
323      fan_in, fan_out = initializers._compute_fans(shape)
324      std = np.sqrt(2. / (fan_in + fan_out))
325      self.assertRange(
326          initializers.VarianceScaling(
327              scale=1.0, mode=&quot;fan_avg&quot;, distribution=&quot;uniform&quot;, seed=123),
328          shape,
329          target_mean=0.,
330          target_std=std)
331    def test_GlorotNormal(self):
332      shape = (5, 6, 4, 2)
333      fan_in, fan_out = initializers._compute_fans(shape)
334      std = np.sqrt(2. / (fan_in + fan_out))
335      self.assertRange(
336          initializers.VarianceScaling(
337              scale=1.0,
338              mode=&quot;fan_avg&quot;,
339              distribution=&quot;truncated_normal&quot;,
340              seed=123),
341          shape,
342          target_mean=0.,
343          target_std=std)
344    def testLecunUniform(self):
345      shape = (5, 6, 4, 2)
346      fan_in, _ = initializers._compute_fans(shape)
347      std = np.sqrt(1. / fan_in)
348      self.assertRange(
349          initializers.VarianceScaling(
350              scale=1.0, mode=&quot;fan_in&quot;, distribution=&quot;uniform&quot;, seed=123),
351          shape,
352          target_mean=0.,
353          target_std=std)
354    def testLecunNormal(self):
355      shape = (5, 6, 4, 2)
356      fan_in, _ = initializers._compute_fans(shape)
357      std = np.sqrt(1. / fan_in)
358      self.assertRange(
359          initializers.VarianceScaling(
360              scale=1.0, mode=&quot;fan_in&quot;, distribution=&quot;truncated_normal&quot;,
361              seed=123),
362          shape,
363          target_mean=0.,
364          target_std=std)
365    def testHeUniform(self):
366      shape = (5, 6, 4, 2)
367      fan_in, _ = initializers._compute_fans(shape)
368      std = np.sqrt(2. / fan_in)
369      self.assertRange(
370          initializers.VarianceScaling(
371              scale=2.0, mode=&quot;fan_in&quot;, distribution=&quot;uniform&quot;, seed=123),
372          shape,
373          target_mean=0.,
374          target_std=std)
375    def testHeNormal(self):
376      shape = (5, 6, 4, 2)
377      fan_in, _ = initializers._compute_fans(shape)
378      std = np.sqrt(2. / fan_in)
379      self.assertRange(
380          initializers.VarianceScaling(
381              scale=2.0, mode=&quot;fan_in&quot;, distribution=&quot;truncated_normal&quot;,
382              seed=123),
383          shape,
384          target_mean=0.,
385          target_std=std)
386    @parameterized.parameters(
387        itertools.product([&quot;fan_in&quot;, &quot;fan_out&quot;, &quot;fan_avg&quot;],
388                          [&quot;uniform&quot;, &quot;truncated_normal&quot;, &quot;normal&quot;]))
389    def testMixedShape(self, mode, distribution):
390      init = initializers.VarianceScaling(mode=mode, distribution=distribution)
391      tf.random.set_seed(42)
392      x = init([tf.constant(4), 2], tf.float32)
393      tf.random.set_seed(42)
394      expected = init([4, 2], tf.float32)
395      self.assertEqual(x.shape, [4, 2])
396      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
397        self.assertAllEqual(expected, x)
398    @parameterized.parameters(
399        itertools.product([&quot;fan_in&quot;, &quot;fan_out&quot;, &quot;fan_avg&quot;],
400                          [&quot;uniform&quot;, &quot;truncated_normal&quot;, &quot;normal&quot;]))
401    def testWithTFFunction(self, mode, distribution):
402      init = initializers.VarianceScaling(
403          mode=mode, distribution=distribution, seed=42)
404      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
405      x = f(tf.zeros([4, 2]))
406      expected = init([4, 2], tf.float32)
407      self.assertEqual(x.shape, [4, 2])
408      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
409        self.assertAllClose(expected, x)
410    @parameterized.parameters(
411        itertools.product([&quot;fan_in&quot;, &quot;fan_out&quot;, &quot;fan_avg&quot;],
412                          [&quot;uniform&quot;, &quot;truncated_normal&quot;, &quot;normal&quot;]))
413    def testBatchAgnostic(self, mode, distribution):
414      init = initializers.VarianceScaling(
415          mode=mode, distribution=distribution, seed=42)
416      spec = tf.TensorSpec(shape=[None, None])
417      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
418      f = f.get_concrete_function(spec)
419      expected = init([7, 4], tf.float32)
420      x = f(tf.ones([7, 4]))
421      self.assertEqual(x.shape, [7, 4])
422      if self.primary_device != &quot;TPU&quot;:  # Seeds don&#x27;t work as expected on TPU
423        self.assertAllClose(expected, x)
424    @parameterized.parameters(tf.int32, tf.string)
425    def testInvalidDataType(self, dtype):
426      init = initializers.VarianceScaling()
427      with self.assertRaisesRegex(ValueError,
428                                  r&quot;Expected floating point type, got &quot;):
429        init([1, 2], dtype=dtype)
430    def testCheckInitializersInvalidType(self):
431      with self.assertRaisesRegex(TypeError,
432                                  &quot;Initializers must be a dict-like object.&quot;):
433        initializers.check_initializers([1, 2, 3], (&quot;a&quot;))
434    def testCheckInitalizersEmpty(self):
435      a = initializers.check_initializers(None, (&quot;b&quot;))
436      self.assertEqual(a, {})
437    @parameterized.named_parameters((&quot;Tuple&quot;, (&quot;a&quot;, &quot;b&quot;)), (&quot;List&quot;, [&quot;a&quot;, &quot;b&quot;]),
438                                    (&quot;Set&quot;, {&quot;a&quot;, &quot;b&quot;}))
439    def testCheckInitalizersValid(self, keys):
440      initializers.check_initializers({
441          &quot;a&quot;: lambda x, y: 0,
442          &quot;b&quot;: lambda x, y: 1
443      }, keys)
444    def testCheckInitalizersInvalid(self):
445      with self.assertRaisesRegex(
446          KeyError,
447          r&quot;Invalid initializer keys &#x27;a&#x27;, initializers can only be provided for&quot;):
448        initializers.check_initializers({
449            &quot;a&quot;: lambda x, y: 0,
450            &quot;b&quot;: lambda x, y: 1
451        }, (&quot;b&quot;))
452  if __name__ == &quot;__main__&quot;:
453    tf.test.main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-initializers_test.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-initializers_test.py</div>
                </div>
                <div class="column column_space"><pre><code>46          dtype=dtype)
47    @parameterized.parameters(tf.float32, tf.int32)
48    def testOnes(self, dtype):
49      self.assertRange(
</pre></code></div>
                <div class="column column_space"><pre><code>71          dtype=dtype)
72    @parameterized.parameters(initializers.Zeros, initializers.Ones)
73    def testInvalidDataType(self, initializer):
74      init = initializer()
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    