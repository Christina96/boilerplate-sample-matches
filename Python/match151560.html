<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for cache_3.py &amp; test_find.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for cache_3.py &amp; test_find.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>cache_3.py (4.5028143%)<th>test_find.py (1.5665796%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(145-147)<td><a href="#" name="0">(412-416)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(75-88)<td><a href="#" name="1">(258-264)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cache_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
In-memory caching used by Salt
"""

import functools
import logging
import os
import re
import time

import salt.config
import salt.payload
import salt.utils.atomicfile
import salt.utils.data
import salt.utils.dictupdate
import salt.utils.files
import salt.utils.msgpack
from salt.utils.zeromq import zmq

log = logging.getLogger(__name__)


class CacheFactory:
    """
    Cache which can use a number of backends
    """

    @classmethod
    def factory(cls, backend, ttl, *args, **kwargs):
        log.debug("Factory backend: %s", backend)
        if backend == "memory":
            return CacheDict(ttl, *args, **kwargs)
        elif backend == "disk":
            return CacheDisk(ttl, kwargs["minion_cache_path"], *args, **kwargs)
        else:
            log.error("CacheFactory received unrecognized cache type")


class CacheDict(dict):
    """
    Subclass of dict that will lazily delete items past ttl
    """

    def __init__(self, ttl, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self._ttl = ttl
        self._key_cache_time = {}

    def _enforce_ttl_key(self, key):
        """
        Enforce the TTL to a specific key, delete if its past TTL
        """
        if key not in self._key_cache_time:
            return
        if time.time() - self._key_cache_time[key] &gt; self._ttl:
            del self._key_cache_time[key]
            dict.__delitem__(self, key)

    def __getitem__(self, key):
        """
        Check if the key is ttld out, then do the get
        """
        self._enforce_ttl_key(key)
        return dict.__getitem__(self, key)

    def __setitem__(self, key, val):
        """
        Make sure to update the key cache time
        """
        self._key_cache_time[key] = time.time()
        dict.__setitem__(self, key, val)
<a name="1"></a>
    def __contains__(self, key):
        self._enforce_ttl_key(key)
        return dict<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.__contains__(self, key)


class CacheDisk(CacheDict):
    """
    Class that represents itself as a dictionary to a consumer
    but uses a disk-based backend. Serialization and de-serialization
    is done with msgpack
    """

    def __init__(self, ttl, path, *args, **kwargs):
        super().__init__(ttl, *args, **kwargs)
        self._path = path
        self.</b></font>_dict = {}
        self._read()

    def _enforce_ttl_key(self, key):
        """
        Enforce the TTL to a specific key, delete if its past TTL
        """
        if key not in self._key_cache_time:
            return
        if time.time() - self._key_cache_time[key] &gt; self._ttl:
            del self._key_cache_time[key]
            self._dict.__delitem__(key)

    def __contains__(self, key):
        self._enforce_ttl_key(key)
        return self._dict.__contains__(key)

    def __getitem__(self, key):
        """
        Check if the key is ttld out, then do the get
        """
        self._enforce_ttl_key(key)
        return self._dict.__getitem__(key)

    def __setitem__(self, key, val):
        """
        Make sure to update the key cache time
        """
        self._key_cache_time[key] = time.time()
        self._dict.__setitem__(key, val)
        # Do the same as the parent but also persist
        self._write()

    def __delitem__(self, key):
        """
        Make sure to remove the key cache time
        """
        del self._key_cache_time[key]
        self._dict.__delitem__(key)
        # Do the same as the parent but also persist
        self._write()

    def clear(self):
        """
        Clear the cache
        """
        self._key_cache_time.clear()
        self._dict.clear()
        # Do the same as the parent but also persist
        self._write()

    def _read(self):
        """
        Read in from disk
<a name="0"></a>        """
        if not salt.utils.msgpack.HAS_MSGPACK or not os.path.exists(self._path):
            return
        with salt<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.files.fopen(self._path, "rb") as fp_:
            cache = salt.utils.data.decode(
                salt.utils.</b></font>msgpack.load(fp_, encoding=__salt_system_encoding__)
            )
        if "CacheDisk_cachetime" in cache:  # new format
            self._dict = cache["CacheDisk_data"]
            self._key_cache_time = cache["CacheDisk_cachetime"]
        else:  # old format
            self._dict = cache
            timestamp = os.path.getmtime(self._path)
            for key in self._dict:
                self._key_cache_time[key] = timestamp
        if log.isEnabledFor(logging.DEBUG):
            log.debug("Disk cache retrieved: %s", cache)

    def _write(self):
        """
        Write out to disk
        """
        if not salt.utils.msgpack.HAS_MSGPACK:
            return
        # TODO Add check into preflight to ensure dir exists
        # TODO Dir hashing?
        with salt.utils.atomicfile.atomic_open(self._path, "wb+") as fp_:
            cache = {
                "CacheDisk_data": self._dict,
                "CacheDisk_cachetime": self._key_cache_time,
            }
            salt.utils.msgpack.dump(cache, fp_, use_bin_type=True)


class CacheCli:
    """
    Connection client for the ConCache. Should be used by all
    components that need the list of currently connected minions
    """

    def __init__(self, opts):
        """
        Sets up the zmq-connection to the ConCache
        """
        self.opts = opts
        self.cache_sock = os.path.join(self.opts["sock_dir"], "con_cache.ipc")
        self.cache_upd_sock = os.path.join(self.opts["sock_dir"], "con_upd.ipc")

        context = zmq.Context()

        # the socket for talking to the cache
        self.creq_out = context.socket(zmq.REQ)
        self.creq_out.setsockopt(zmq.LINGER, 100)
        self.creq_out.connect("ipc://" + self.cache_sock)

        # the socket for sending updates to the cache
        self.cupd_out = context.socket(zmq.PUB)
        self.cupd_out.setsockopt(zmq.LINGER, 1)
        self.cupd_out.connect("ipc://" + self.cache_upd_sock)

    def put_cache(self, minions):
        """
        published the given minions to the ConCache
        """
        self.cupd_out.send(salt.payload.dumps(minions))

    def get_cached(self):
        """
        queries the ConCache for a list of currently connected minions
        """
        msg = salt.payload.dumps("minions")
        self.creq_out.send(msg)
        min_list = salt.payload.loads(self.creq_out.recv())
        return min_list


class CacheRegex:
    """
    Create a regular expression object cache for the most frequently
    used patterns to minimize compilation of the same patterns over
    and over again
    """

    def __init__(
        self, prepend="", append="", size=1000, keep_fraction=0.8, max_age=3600
    ):
        self.prepend = prepend
        self.append = append
        self.size = size
        self.clear_size = int(size - size * (keep_fraction))
        if self.clear_size &gt;= size:
            self.clear_size = int(size / 2) + 1
            if self.clear_size &gt; size:
                self.clear_size = size
        self.max_age = max_age
        self.cache = {}
        self.timestamp = time.time()

    def clear(self):
        """
        Clear the cache
        """
        self.cache.clear()

    def sweep(self):
        """
        Sweep the cache and remove the outdated or least frequently
        used entries
        """
        if self.max_age &lt; time.time() - self.timestamp:
            self.clear()
            self.timestamp = time.time()
        else:
            paterns = list(self.cache.values())
            paterns.sort()
            for idx in range(self.clear_size):
                del self.cache[paterns[idx][2]]

    def get(self, pattern):
        """
        Get a compiled regular expression object based on pattern and
        cache it when it is not in the cache already
        """
        try:
            self.cache[pattern][0] += 1
            return self.cache[pattern][1]
        except KeyError:
            pass
        if len(self.cache) &gt; self.size:
            self.sweep()
        regex = re.compile("{}{}{}".format(self.prepend, pattern, self.append))
        self.cache[pattern] = [1, regex, pattern, time.time()]
        return regex


class ContextCache:
    def __init__(self, opts, name):
        """
        Create a context cache
        """
        self.opts = opts
        self.cache_path = os.path.join(opts["cachedir"], "context", "{}.p".format(name))

    def cache_context(self, context):
        """
        Cache the given context to disk
        """
        if not os.path.isdir(os.path.dirname(self.cache_path)):
            os.mkdir(os.path.dirname(self.cache_path))
        with salt.utils.files.fopen(self.cache_path, "w+b") as cache:
            salt.payload.dump(context, cache)

    def get_cache_context(self):
        """
        Retrieve a context cache from disk
        """
        with salt.utils.files.fopen(self.cache_path, "rb") as cache:
            return salt.utils.data.decode(salt.payload.load(cache))


def context_cache(func):
    """
    A decorator to be used module functions which need to cache their
    context.

    To evaluate a __context__ and re-hydrate it if a given key
    is empty or contains no items, pass a list of keys to evaulate.
    """

    @functools.wraps(func)
    def context_cache_wrap(*args, **kwargs):
        try:
            func_context = func.__globals__["__context__"].value()
        except AttributeError:
            func_context = func.__globals__["__context__"]
        try:
            func_opts = func.__globals__["__opts__"].value()
        except AttributeError:
            func_opts = func.__globals__["__opts__"]
        func_name = func.__globals__["__name__"]

        context_cache = ContextCache(func_opts, func_name)
        if not func_context and os.path.isfile(context_cache.cache_path):
            salt.utils.dictupdate.update(
                func_context, context_cache.get_cache_context()
            )
        else:
            context_cache.cache_context(func_context)
        return func(*args, **kwargs)

    return context_cache_wrap
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_find.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os
import shutil
import stat
import sys
import tempfile

import salt.utils.files
import salt.utils.find
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import TestCase, skipIf


class TestFind(TestCase):
    def test_parse_interval(self):
        self.assertRaises(ValueError, salt.utils.find._parse_interval, "w")
        self.assertRaises(ValueError, salt.utils.find._parse_interval, "1")
        self.assertRaises(ValueError, salt.utils.find._parse_interval, "1s1w")
        self.assertRaises(ValueError, salt.utils.find._parse_interval, "1s1s")

        result, resolution, modifier = salt.utils.find._parse_interval("")
        self.assertEqual(result, 0)
        self.assertIs(resolution, None)
        self.assertEqual(modifier, "")

        result, resolution, modifier = salt.utils.find._parse_interval("1s")
        self.assertEqual(result, 1.0)
        self.assertEqual(resolution, 1)
        self.assertEqual(modifier, "")

        result, resolution, modifier = salt.utils.find._parse_interval("1m")
        self.assertEqual(result, 60.0)
        self.assertEqual(resolution, 60)
        self.assertEqual(modifier, "")

        result, resolution, modifier = salt.utils.find._parse_interval("1h")
        self.assertEqual(result, 3600.0)
        self.assertEqual(resolution, 3600)
        self.assertEqual(modifier, "")

        result, resolution, modifier = salt.utils.find._parse_interval("1d")
        self.assertEqual(result, 86400.0)
        self.assertEqual(resolution, 86400)
        self.assertEqual(modifier, "")

        result, resolution, modifier = salt.utils.find._parse_interval("1w")
        self.assertEqual(result, 604800.0)
        self.assertEqual(resolution, 604800)
        self.assertEqual(modifier, "")

        result, resolution, modifier = salt.utils.find._parse_interval("1w3d6h")
        self.assertEqual(result, 885600.0)
        self.assertEqual(resolution, 3600)
        self.assertEqual(modifier, "")

        result, resolution, modifier = salt.utils.find._parse_interval("1m1s")
        self.assertEqual(result, 61.0)
        self.assertEqual(resolution, 1)
        self.assertEqual(modifier, "")

        result, resolution, modifier = salt.utils.find._parse_interval("1m2s")
        self.assertEqual(result, 62.0)
        self.assertEqual(resolution, 1)
        self.assertEqual(modifier, "")

        result, resolution, modifier = salt.utils.find._parse_interval("+1d")
        self.assertEqual(result, 86400.0)
        self.assertEqual(resolution, 86400)
        self.assertEqual(modifier, "+")

        result, resolution, modifier = salt.utils.find._parse_interval("-1d")
        self.assertEqual(result, 86400.0)
        self.assertEqual(resolution, 86400)
        self.assertEqual(modifier, "-")

    def test_parse_size(self):
        self.assertRaises(ValueError, salt.utils.find._parse_size, "")
        self.assertRaises(ValueError, salt.utils.find._parse_size, "1s1s")
        min_size, max_size = salt.utils.find._parse_size("1")
        self.assertEqual(min_size, 1)
        self.assertEqual(max_size, 1)

        min_size, max_size = salt.utils.find._parse_size("1b")
        self.assertEqual(min_size, 1)
        self.assertEqual(max_size, 1)

        min_size, max_size = salt.utils.find._parse_size("1k")
        self.assertEqual(min_size, 1024)
        self.assertEqual(max_size, 2047)

        min_size, max_size = salt.utils.find._parse_size("1m")
        self.assertEqual(min_size, 1048576)
        self.assertEqual(max_size, 2097151)

        min_size, max_size = salt.utils.find._parse_size("1g")
        self.assertEqual(min_size, 1073741824)
        self.assertEqual(max_size, 2147483647)

        min_size, max_size = salt.utils.find._parse_size("1t")
        self.assertEqual(min_size, 1099511627776)
        self.assertEqual(max_size, 2199023255551)

        min_size, max_size = salt.utils.find._parse_size("0m")
        self.assertEqual(min_size, 0)
        self.assertEqual(max_size, 1048575)

        min_size, max_size = salt.utils.find._parse_size("-1m")
        self.assertEqual(min_size, 0)
        self.assertEqual(max_size, 1048576)

        min_size, max_size = salt.utils.find._parse_size("+1m")
        self.assertEqual(min_size, 1048576)
        self.assertEqual(max_size, sys.maxsize)

        min_size, max_size = salt.utils.find._parse_size("+1M")
        self.assertEqual(min_size, 1048576)
        self.assertEqual(max_size, sys.maxsize)

    def test_option_requires(self):
        option = salt.utils.find.Option()
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_PATH)

    def test_name_option_match(self):
        option = salt.utils.find.NameOption("name", "*.txt")
        self.assertIs(option.match("", "", ""), None)
        self.assertIs(option.match("", "hello.txt", "").group(), "hello.txt")
        self.assertIs(option.match("", "HELLO.TXT", ""), None)

    def test_iname_option_match(self):
        option = salt.utils.find.InameOption("name", "*.txt")
        self.assertIs(option.match("", "", ""), None)
        self.assertIs(option.match("", "hello.txt", "").group(), "hello.txt")
        self.assertIs(option.match("", "HELLO.TXT", "").group(), "HELLO.TXT")

    def test_regex_option_match(self):
        self.assertRaises(ValueError, salt.utils.find.RegexOption, "name", "(.*}")

        option = salt.utils.find.RegexOption("name", r".*\.txt")
        self.assertIs(option.match("", "", ""), None)
        self.assertIs(option.match("", "hello.txt", "").group(), "hello.txt")
        self.assertIs(option.match("", "HELLO.TXT", ""), None)

    def test_iregex_option_match(self):
        self.assertRaises(ValueError, salt.utils.find.IregexOption, "name", "(.*}")

        option = salt.utils.find.IregexOption("name", r".*\.txt")
        self.assertIs(option.match("", "", ""), None)
        self.assertIs(option.match("", "hello.txt", "").group(), "hello.txt")
        self.assertIs(option.match("", "HELLO.TXT", "").group(), "HELLO.TXT")

    def test_type_option_requires(self):
        self.assertRaises(ValueError, salt.utils.find.TypeOption, "type", "w")

        option = salt.utils.find.TypeOption("type", "d")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_STAT)

    def test_type_option_match(self):
        option = salt.utils.find.TypeOption("type", "b")
        self.assertEqual(option.match("", "", [stat.S_IFREG]), False)

        option = salt.utils.find.TypeOption("type", "c")
        self.assertEqual(option.match("", "", [stat.S_IFREG]), False)

        option = salt.utils.find.TypeOption("type", "d")
        self.assertEqual(option.match("", "", [stat.S_IFREG]), False)

        option = salt.utils.find.TypeOption("type", "f")
        self.assertEqual(option.match("", "", [stat.S_IFREG]), True)

        option = salt.utils.find.TypeOption("type", "l")
        self.assertEqual(option.match("", "", [stat.S_IFREG]), False)

        option = salt.utils.find.TypeOption("type", "p")
        self.assertEqual(option.match("", "", [stat.S_IFREG]), False)

        option = salt.utils.find.TypeOption("type", "s")
        self.assertEqual(option.match("", "", [stat.S_IFREG]), False)

        option = salt.utils.find.TypeOption("type", "b")
        self.assertEqual(option.match("", "", [stat.S_IFBLK]), True)

        option = salt.utils.find.TypeOption("type", "c")
        self.assertEqual(option.match("", "", [stat.S_IFCHR]), True)

        option = salt.utils.find.TypeOption("type", "d")
        self.assertEqual(option.match("", "", [stat.S_IFDIR]), True)

        option = salt.utils.find.TypeOption("type", "l")
        self.assertEqual(option.match("", "", [stat.S_IFLNK]), True)

        option = salt.utils.find.TypeOption("type", "p")
        self.assertEqual(option.match("", "", [stat.S_IFIFO]), True)

        option = salt.utils.find.TypeOption("type", "s")
        self.assertEqual(option.match("", "", [stat.S_IFSOCK]), True)

    @skipIf(sys.platform.startswith("win"), "pwd not available on Windows")
    def test_owner_option_requires(self):
        self.assertRaises(ValueError, salt.utils.find.OwnerOption, "owner", "notexist")

        option = salt.utils.find.OwnerOption("owner", "root")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_STAT)

    @skipIf(sys.platform.startswith("win"), "pwd not available on Windows")
    def test_owner_option_match(self):
        option = salt.utils.find.OwnerOption("owner", "root")
        self.assertEqual(option.match("", "", [0] * 5), True)

        option = salt.utils.find.OwnerOption("owner", "500")
        self.assertEqual(option.match("", "", [500] * 5), True)

    @skipIf(sys.platform.startswith("win"), "grp not available on Windows")
    def test_group_option_requires(self):
        self.assertRaises(ValueError, salt.utils.find.GroupOption, "group", "notexist")

        if sys.platform.startswith(("darwin", "freebsd", "openbsd")):
            group_name = "wheel"
        else:
            group_name = "root"
        option = salt.utils.find.GroupOption("group", group_name)
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_STAT)

    @skipIf(sys.platform.startswith("win"), "grp not available on Windows")
    def test_group_option_match(self):
        if sys.platform.startswith(("darwin", "freebsd", "openbsd")):
            group_name = "wheel"
        else:
            group_name = "root"
        option = salt.utils.find.GroupOption("group", group_name)
        self.assertEqual(option.match("", "", [0] * 6), True)

        option = salt.utils.find.GroupOption("group", "500")
        self.assertEqual(option.match("", "", [500] * 6), True)

    def test_size_option_requires(self):
        self.assertRaises(ValueError, salt.utils.find.SizeOption, "size", "1s1s")

        option = salt.utils.find.SizeOption("size", "+1G")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_STAT)

    def test_size_option_match(self):
        option = salt.utils.find.SizeOption("size", "+1k")
        self.assertEqual(option.match("", "", [10000] * 7), True)

        option = salt.utils.find.SizeOption("size", "+1G")
        self.assertEqual(option.match("", "", [10000] * 7), False)

    def test_mtime_option_requires(self):
        self.assertRaises(ValueError, salt.utils.find.MtimeOption, "mtime", "4g")

        option = salt.utils.find.MtimeOption("mtime", "1d")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_STAT)

    def test_mtime_option_match(self):
        option = salt.utils.find.MtimeOption("mtime", "-1w")
<a name="1"></a>        self.assertEqual(option.match("", "", [1] * 9), False)

        option = salt.utils.find.MtimeOption("mtime", "-1s")
        self.assertEqual(option<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.match("", "", [10 ** 10] * 9), True)


class TestGrepOption(TestCase):
    def setUp(self):
        super().setUp()
        self.tmpdir = tempfile.</b></font>mkdtemp(dir=RUNTIME_VARS.TMP)

    def tearDown(self):
        shutil.rmtree(self.tmpdir)
        super().tearDown()

    def test_grep_option_requires(self):
        self.assertRaises(ValueError, salt.utils.find.GrepOption, "grep", "(foo)|(bar}")

        option = salt.utils.find.GrepOption("grep", "(foo)|(bar)")
        find = salt.utils.find
        self.assertEqual(
            option.requires(), (find._REQUIRES_CONTENTS | find._REQUIRES_STAT)
        )

    def test_grep_option_match_regular_file(self):
        hello_file = os.path.join(self.tmpdir, "hello.txt")
        with salt.utils.files.fopen(hello_file, "w") as fp_:
            fp_.write(salt.utils.stringutils.to_str("foo"))
        option = salt.utils.find.GrepOption("grep", "foo")
        self.assertEqual(
            option.match(self.tmpdir, "hello.txt", os.stat(hello_file)), hello_file
        )

        option = salt.utils.find.GrepOption("grep", "bar")
        self.assertEqual(
            option.match(self.tmpdir, "hello.txt", os.stat(hello_file)), None
        )

    @skipIf(sys.platform.startswith("win"), "No /dev/null on Windows")
    def test_grep_option_match_dev_null(self):
        option = salt.utils.find.GrepOption("grep", "foo")
        self.assertEqual(option.match("dev", "null", os.stat("/dev/null")), None)


class TestPrintOption(TestCase):
    def setUp(self):
        super().setUp()
        self.tmpdir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)

    def tearDown(self):
        shutil.rmtree(self.tmpdir)
        super().tearDown()

    def test_print_option_defaults(self):
        option = salt.utils.find.PrintOption("print", "")
        self.assertEqual(option.need_stat, False)
        self.assertEqual(option.print_title, False)
        self.assertEqual(option.fmt, ["path"])

    def test_print_option_requires(self):
        option = salt.utils.find.PrintOption("print", "")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_PATH)

        option = salt.utils.find.PrintOption("print", "name")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_PATH)

        option = salt.utils.find.PrintOption("print", "path")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_PATH)

        option = salt.utils.find.PrintOption("print", "name,path")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_PATH)

        option = salt.utils.find.PrintOption("print", "user")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_STAT)

        option = salt.utils.find.PrintOption("print", "path user")
        self.assertEqual(option.requires(), salt.utils.find._REQUIRES_STAT)

    def test_print_option_execute(self):
        hello_file = os.path.join(self.tmpdir, "hello.txt")
        with salt.utils.files.fopen(hello_file, "w") as fp_:
            fp_.write(salt.utils.stringutils.to_str("foo"))

        option = salt.utils.find.PrintOption("print", "")
        self.assertEqual(option.execute("", [0] * 9), "")

        option = salt.utils.find.PrintOption("print", "path")
        self.assertEqual(option.execute("test_name", [0] * 9), "test_name")

        option = salt.utils.find.PrintOption("print", "name")
        self.assertEqual(option.execute("test_name", [0] * 9), "test_name")

        option = salt.utils.find.PrintOption("print", "size")
        self.assertEqual(option.execute(hello_file, os.stat(hello_file)), 3)

        option = salt.utils.find.PrintOption("print", "type")
        self.assertEqual(option.execute(hello_file, os.stat(hello_file)), "f")

        option = salt.utils.find.PrintOption("print", "mode")
        self.assertEqual(option.execute(hello_file, range(10)), 0)

        option = salt.utils.find.PrintOption("print", "mtime")
        self.assertEqual(option.execute(hello_file, range(10)), 8)

        option = salt.utils.find.PrintOption("print", "md5")
        self.assertEqual(
            option.execute(hello_file, os.stat(hello_file)),
            "acbd18db4cc2f85cedef654fccc4a4d8",
        )

        option = salt.utils.find.PrintOption("print", "path name")
        self.assertEqual(
            option.execute("test_name", [0] * 9), ["test_name", "test_name"]
        )

        option = salt.utils.find.PrintOption("print", "size name")
        self.assertEqual(option.execute("test_name", [0] * 9), [0, "test_name"])

    @skipIf(sys.platform.startswith("win"), "pwd not available on Windows")
    def test_print_user(self):
        option = salt.utils.find.PrintOption("print", "user")
        self.assertEqual(option.execute("", [0] * 10), "root")

        option = salt.utils.find.PrintOption("print", "user")
        self.assertEqual(option.execute("", [2 ** 31] * 10), 2 ** 31)

    @skipIf(sys.platform.startswith("win"), "grp not available on Windows")
    def test_print_group(self):
        option = salt.utils.find.PrintOption("print", "group")
        if sys.platform.startswith(("darwin", "freebsd", "openbsd")):
            group_name = "wheel"
        else:
            group_name = "root"
        self.assertEqual(option.execute("", [0] * 10), group_name)

        # This seems to be not working in Ubuntu 12.04 32 bit
        # option = salt.utils.find.PrintOption('print', 'group')
        # self.assertEqual(option.execute('', [2 ** 31] * 10), 2 ** 31)

    @skipIf(sys.platform.startswith("win"), "no /dev/null on windows")
    def test_print_md5(self):
        option = salt.utils.find.PrintOption("print", "md5")
        self.assertEqual(option.execute("/dev/null", os.stat("/dev/null")), "")


class TestFinder(TestCase):
    def setUp(self):
        super().setUp()
        self.tmpdir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)

    def tearDown(self):
        shutil.rmtree(self.tmpdir)
        super().tearDown()

<a name="0"></a>    @skipIf(sys.platform.startswith("win"), "No /dev/null on Windows")
    def test_init(self):
        finder = salt.utils.find.Finder({})
        self.assertEqual(str(finder.actions[0]<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.__class__)[-13:-2], "PrintOption")
        self.assertEqual(finder.criteria, [])

        finder = salt.utils.find.Finder({"_": None})
        self.</b></font>assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(finder.criteria, [])

        self.assertRaises(ValueError, salt.utils.find.Finder, {"": None})
        self.assertRaises(ValueError, salt.utils.find.Finder, {"name": None})
        self.assertRaises(ValueError, salt.utils.find.Finder, {"nonexist": "somevalue"})

        finder = salt.utils.find.Finder({"name": "test_name"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-12:-2], "NameOption")

        finder = salt.utils.find.Finder({"iname": "test_name"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-13:-2], "InameOption")

        finder = salt.utils.find.Finder({"regex": r".*\.txt"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-13:-2], "RegexOption")

        finder = salt.utils.find.Finder({"iregex": r".*\.txt"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-14:-2], "IregexOption")

        finder = salt.utils.find.Finder({"type": "d"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-12:-2], "TypeOption")

        finder = salt.utils.find.Finder({"owner": "root"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-13:-2], "OwnerOption")

        if sys.platform.startswith(("darwin", "freebsd", "openbsd")):
            group_name = "wheel"
        else:
            group_name = "root"
        finder = salt.utils.find.Finder({"group": group_name})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-13:-2], "GroupOption")

        finder = salt.utils.find.Finder({"size": "+1G"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-12:-2], "SizeOption")

        finder = salt.utils.find.Finder({"mtime": "1d"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-13:-2], "MtimeOption")

        finder = salt.utils.find.Finder({"grep": "foo"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(str(finder.criteria[0].__class__)[-12:-2], "GrepOption")

        finder = salt.utils.find.Finder({"print": "name"})
        self.assertEqual(str(finder.actions[0].__class__)[-13:-2], "PrintOption")
        self.assertEqual(finder.criteria, [])

    def test_find(self):
        hello_file = os.path.join(self.tmpdir, "hello.txt")
        with salt.utils.files.fopen(hello_file, "w") as fp_:
            fp_.write(salt.utils.stringutils.to_str("foo"))

        finder = salt.utils.find.Finder({})
        self.assertEqual(list(finder.find(self.tmpdir)), [self.tmpdir, hello_file])

        finder = salt.utils.find.Finder({"mindepth": 1})
        self.assertEqual(list(finder.find(self.tmpdir)), [hello_file])

        finder = salt.utils.find.Finder({"maxdepth": 0})
        self.assertEqual(list(finder.find(self.tmpdir)), [self.tmpdir])

        finder = salt.utils.find.Finder({"name": "hello.txt"})
        self.assertEqual(list(finder.find(self.tmpdir)), [hello_file])

        finder = salt.utils.find.Finder({"type": "f", "print": "path"})
        self.assertEqual(list(finder.find(self.tmpdir)), [hello_file])

        finder = salt.utils.find.Finder({"size": "+1G", "print": "path"})
        self.assertEqual(list(finder.find(self.tmpdir)), [])

        finder = salt.utils.find.Finder({"name": "hello.txt", "print": "path name"})
        self.assertEqual(list(finder.find(self.tmpdir)), [[hello_file, "hello.txt"]])

        finder = salt.utils.find.Finder({"name": "test_name"})
        self.assertEqual(list(finder.find("")), [])
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
