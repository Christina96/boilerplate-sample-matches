
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>wxpy-MDEwOlJlcG9zaXRvcnk4MjU4ODU5Nw==-flat-bot.py</h3>
            <pre><code>1  from __future__ import unicode_literals
2  import atexit
3  import functools
4  import logging
5  import os.path
6  import tempfile
7  import time
8  from pprint import pformat
9  from threading import Thread
10  try:
11      import queue
12  except ImportError:
13      import Queue as queue
14  import itchat
15  from ..api.chats import Chat, Chats, Friend, Group, MP, User
16  from ..api.consts import SYSTEM
17  from ..api.messages import Message, MessageConfig, Messages, Registered
18  from ..compatible import PY2
19  from ..compatible.utils import force_encoded_string_output
20  from ..utils import PuidMap
21  from ..utils import enhance_connection, enhance_webwx_request, ensure_list, get_user_name, handle_response, \
22      start_new_thread, wrap_user_name
23  logger = logging.getLogger(__name__)
24  class Bot(object):
25      def __init__(
26              self, cache_path=None, console_qr=False, qr_path=None,
27              qr_callback=None, login_callback=None, logout_callback=None
28      ):
29          self.core = itchat.Core()
30          itchat.instanceList.append(self)
31          enhance_connection(self.core.s)
32          if cache_path is True:
33              cache_path = 'wxpy.pkl'
34          self.cache_path = cache_path
35          if console_qr is True:
36              console_qr = 2
37          try:
38              self.core.auto_login(
39                  hotReload=bool(cache_path), statusStorageDir=cache_path,
40                  enableCmdQR=console_qr, picDir=qr_path, qrCallback=qr_callback,
41                  loginCallback=login_callback, exitCallback=logout_callback
42              )
43          except FileNotFoundError as e:
44              if 'xdg-open' in e.strerror:
45                  raise Exception('use `console_qr` arg while under pure console environment')
46              raise
47          self._sync_check_iterations = int(time.time() * 1000)
48          enhance_webwx_request(self)
49          self.self = User(self.core.loginInfo['User'], self)
50          self.file_helper = Chat(wrap_user_name('filehelper'), self)
51          self.messages = Messages()
52          self.registered = Registered(self)
53          self.puid_map = None
54          self.auto_mark_as_read = False
55          self.is_listening = False
56          self.listening_thread = None
57          if PY2:
58              from wxpy.compatible.utils import TemporaryDirectory
59              self.temp_dir = TemporaryDirectory(prefix='wxpy_')
60          else:
61              self.temp_dir = tempfile.TemporaryDirectory(prefix='wxpy_')
62          self.start()
63          atexit.register(self._cleanup)
64      @force_encoded_string_output
65      def __repr__(self):
66          return '<{}: {}>'.format(self.__class__.__name__, self.self.name)
67      def __unicode__(self):
68          return '<{}: {}>'.format(self.__class__.__name__, self.self.name)
69      @handle_response()
70      def logout(self):
71          logger.info('{}: logging out'.format(self))
72          return self.core.logout()
73      @property
74      def alive(self):
75          return self.core.alive
76      @alive.setter
77      def alive(self, value):
78          self.core.alive = value
79      def dump_login_status(self, cache_path=None):
80          logger.debug('{}: dumping login status'.format(self))
81          return self.core.dump_login_status(cache_path or self.cache_path)
82      def enable_puid(self, path='wxpy_puid.pkl'):
83          self.puid_map = PuidMap(path)
84          return self.puid_map
85      def except_self(self, chats_or_dicts):
86          return list(filter(lambda x: get_user_name(x) != self.self.user_name, chats_or_dicts))
87      def chats(self, update=False):
88          return Chats(self.friends(update) + self.groups(update) + self.mps(update), self)
89      def _retrieve_itchat_storage(self, attr):
90          with self.core.storageClass.updateLock:
91              return getattr(self.core.storageClass, attr)
92      @handle_response(Friend)
93      def friends(self, update=False):
94          if update:
95              logger.info('{}: updating friends'.format(self))
96              return self.core.get_friends(update=update)
97          else:
98              return self._retrieve_itchat_storage('memberList')
99      @handle_response(Group)
100      def groups(self, update=False, contact_only=False):
101          if update or contact_only:
102              logger.info('{}: updating groups'.format(self))
103              return self.core.get_chatrooms(update=update, contactOnly=contact_only)
104          else:
105              return self._retrieve_itchat_storage('chatroomList')
106      @handle_response(MP)
107      def mps(self, update=False):
108          if update:
109              logger.info('{}: updating mps'.format(self))
110              return self.core.get_mps(update=update)
111          else:
112              return self._retrieve_itchat_storage('mpList')
113      @handle_response(User)
114      def user_details(self, user_or_users, chunk_size=50):
115          def chunks():
116              total = ensure_list(user_or_users)
117              for i in range(0, len(total), chunk_size):
118                  yield total[i:i + chunk_size]
119          @handle_response()
120          def process_one_chunk(_chunk):
121              return self.core.update_friend(userName=get_user_name(_chunk))
122          if isinstance(user_or_users, (list, tuple)):
123              ret = list()
124              for chunk in chunks():
125                  chunk_ret = process_one_chunk(chunk)
126                  if isinstance(chunk_ret, list):
127                      ret += chunk_ret
128                  else:
129                      ret.append(chunk_ret)
130              return ret
131          else:
132              return process_one_chunk(user_or_users)
133      def search(self, keywords=None, **attributes):
134          return self.chats().search(keywords, **attributes)
135      @handle_response()
136      def add_friend(self, user, verify_content=''):
137          logger.info('{}: adding {} (verify_content: {})'.format(self, user, verify_content))
138          user_name = get_user_name(user)
139          return self.core.add_friend(
140              userName=user_name,
<span onclick='openModal()' class='match'>141              status=2,
142              verifyContent=verify_content,
143              autoUpdate=True
144          )
145      @handle_response()
</span>146      def add_mp(self, user):
147          logger.info('{}: adding {}'.format(self, user))
148          user_name = get_user_name(user)
149          return self.core.add_friend(
150              userName=user_name,
151              status=1,
152              autoUpdate=True
153          )
154      def accept_friend(self, user, verify_content=''):
155          logger.info('{}: accepting {} (verify_content: {})'.format(self, user, verify_content))
156          @handle_response()
157          def do():
158              return self.core.add_friend(
159                  userName=get_user_name(user),
160                  status=3,
161                  verifyContent=verify_content,
162                  autoUpdate=True
163              )
164          do()
165          for friend in self.friends():
166              if friend == user:
167                  return friend
168      def create_group(self, users, topic=None):
169          logger.info('{}: creating group (topic: {}), with users:\n{}'.format(
170              self, topic, pformat(users)))
171          @handle_response()
172          def request():
173              return self.core.create_chatroom(
174                  memberList=dict_list,
175                  topic=topic or ''
176              )
177          dict_list = wrap_user_name(self.except_self(ensure_list(users)))
178          ret = request()
179          user_name = ret.get('ChatRoomName')
180          if user_name:
181              return Group(self.core.update_chatroom(userName=user_name), self)
182          else:
183              from wxpy.utils import decode_text_from_webwx
184              ret = decode_text_from_webwx(pformat(ret))
185              raise Exception('Failed to create group:\n{}'.format(ret))
186      def upload_file(self, path):
187          logger.info('{}: uploading file: {}'.format(self, path))
188          @handle_response()
189          def do():
190              upload = functools.partial(self.core.upload_file, fileDir=path)
191              ext = os.path.splitext(path)[1].lower()
192              if ext in ('.bmp', '.png', '.jpeg', '.jpg', '.gif'):
193                  return upload(isPicture=True)
194              elif ext == '.mp4':
195                  return upload(isVideo=True)
196              else:
197                  return upload()
198          return do().get('MediaId')
199      def _process_message(self, msg):
200          if not self.alive:
201              return
202          config = self.registered.get_config(msg)
203          logger.debug('{}: new message (func: {}):\n{}'.format(
204              self, config.func.__name__ if config else None, msg))
205          if config:
206              def process():
207                  try:
208                      ret = config.func(msg)
209                      if ret is not None:
210                          msg.reply(ret)
211                  except:
212                      logger.exception('an error occurred in {}.'.format(config.func))
213                  if self.auto_mark_as_read and not msg.type == SYSTEM and msg.sender != self.self:
214                      from wxpy import ResponseError
215                      try:
216                          msg.chat.mark_as_read()
217                      except ResponseError as e:
218                          logger.warning('failed to mark as read: {}'.format(e))
219              if config.run_async:
220                  start_new_thread(process, use_caller_name=True)
221              else:
222                  process()
223      def register(
224              self, chats=None, msg_types=None,
225              except_self=True, run_async=True, enabled=True
226      ):
227          def do_register(func):
228              self.registered.append(MessageConfig(
229                  bot=self, func=func, chats=chats, msg_types=msg_types,
230                  except_self=except_self, run_async=run_async, enabled=enabled
231              ))
232              return func
233          return do_register
234      def _listen(self):
235          try:
236              logger.info('{}: started'.format(self))
237              self.is_listening = True
238              while self.alive and self.is_listening:
239                  try:
240                      msg = Message(self.core.msgList.get(timeout=0.5), self)
241                  except queue.Empty:
242                      continue
243                  if msg.type != SYSTEM:
244                      self.messages.append(msg)
245                  try:
246                      self._process_message(msg)
247                  except:
248                      logger.exception('an error occurred while processing msg:\n{}'.format(msg))
249          finally:
250              self.is_listening = False
251              logger.info('{}: stopped'.format(self))
252      def start(self):
253          if not self.alive:
254              logger.warning('{} has been logged out!'.format(self))
255          elif self.is_listening:
256              logger.warning('{} is already running, no need to start again.'.format(self))
257          else:
258              self.listening_thread = start_new_thread(self._listen)
259      def stop(self):
260          if self.is_listening:
261              self.is_listening = False
262              self.listening_thread.join()
263          else:
264              logger.warning('{} is not running.'.format(self))
265      def join(self):
266          if isinstance(self.listening_thread, Thread):
267              try:
268                  logger.info('{}: joined'.format(self))
269                  self.listening_thread.join()
270              except KeyboardInterrupt:
271                  pass
272      def _cleanup(self):
273          if self.is_listening:
274              self.stop()
275          if self.alive and self.core.useHotReload:
276              self.dump_login_status()
277          self.temp_dir.cleanup()
</code></pre>
        </div>
        <div class="column">
            <h3>wxpy-MDEwOlJlcG9zaXRvcnk4MjU4ODU5Nw==-flat-bot.py</h3>
            <pre><code>1  from __future__ import unicode_literals
2  import atexit
3  import functools
4  import logging
5  import os.path
6  import tempfile
7  import time
8  from pprint import pformat
9  from threading import Thread
10  try:
11      import queue
12  except ImportError:
13      import Queue as queue
14  import itchat
15  from ..api.chats import Chat, Chats, Friend, Group, MP, User
16  from ..api.consts import SYSTEM
17  from ..api.messages import Message, MessageConfig, Messages, Registered
18  from ..compatible import PY2
19  from ..compatible.utils import force_encoded_string_output
20  from ..utils import PuidMap
21  from ..utils import enhance_connection, enhance_webwx_request, ensure_list, get_user_name, handle_response, \
22      start_new_thread, wrap_user_name
23  logger = logging.getLogger(__name__)
24  class Bot(object):
25      def __init__(
26              self, cache_path=None, console_qr=False, qr_path=None,
27              qr_callback=None, login_callback=None, logout_callback=None
28      ):
29          self.core = itchat.Core()
30          itchat.instanceList.append(self)
31          enhance_connection(self.core.s)
32          if cache_path is True:
33              cache_path = 'wxpy.pkl'
34          self.cache_path = cache_path
35          if console_qr is True:
36              console_qr = 2
37          try:
38              self.core.auto_login(
39                  hotReload=bool(cache_path), statusStorageDir=cache_path,
40                  enableCmdQR=console_qr, picDir=qr_path, qrCallback=qr_callback,
41                  loginCallback=login_callback, exitCallback=logout_callback
42              )
43          except FileNotFoundError as e:
44              if 'xdg-open' in e.strerror:
45                  raise Exception('use `console_qr` arg while under pure console environment')
46              raise
47          self._sync_check_iterations = int(time.time() * 1000)
48          enhance_webwx_request(self)
49          self.self = User(self.core.loginInfo['User'], self)
50          self.file_helper = Chat(wrap_user_name('filehelper'), self)
51          self.messages = Messages()
52          self.registered = Registered(self)
53          self.puid_map = None
54          self.auto_mark_as_read = False
55          self.is_listening = False
56          self.listening_thread = None
57          if PY2:
58              from wxpy.compatible.utils import TemporaryDirectory
59              self.temp_dir = TemporaryDirectory(prefix='wxpy_')
60          else:
61              self.temp_dir = tempfile.TemporaryDirectory(prefix='wxpy_')
62          self.start()
63          atexit.register(self._cleanup)
64      @force_encoded_string_output
65      def __repr__(self):
66          return '<{}: {}>'.format(self.__class__.__name__, self.self.name)
67      def __unicode__(self):
68          return '<{}: {}>'.format(self.__class__.__name__, self.self.name)
69      @handle_response()
70      def logout(self):
71          logger.info('{}: logging out'.format(self))
72          return self.core.logout()
73      @property
74      def alive(self):
75          return self.core.alive
76      @alive.setter
77      def alive(self, value):
78          self.core.alive = value
79      def dump_login_status(self, cache_path=None):
80          logger.debug('{}: dumping login status'.format(self))
81          return self.core.dump_login_status(cache_path or self.cache_path)
82      def enable_puid(self, path='wxpy_puid.pkl'):
83          self.puid_map = PuidMap(path)
84          return self.puid_map
85      def except_self(self, chats_or_dicts):
86          return list(filter(lambda x: get_user_name(x) != self.self.user_name, chats_or_dicts))
87      def chats(self, update=False):
88          return Chats(self.friends(update) + self.groups(update) + self.mps(update), self)
89      def _retrieve_itchat_storage(self, attr):
90          with self.core.storageClass.updateLock:
91              return getattr(self.core.storageClass, attr)
92      @handle_response(Friend)
93      def friends(self, update=False):
94          if update:
95              logger.info('{}: updating friends'.format(self))
96              return self.core.get_friends(update=update)
97          else:
98              return self._retrieve_itchat_storage('memberList')
99      @handle_response(Group)
100      def groups(self, update=False, contact_only=False):
101          if update or contact_only:
102              logger.info('{}: updating groups'.format(self))
103              return self.core.get_chatrooms(update=update, contactOnly=contact_only)
104          else:
105              return self._retrieve_itchat_storage('chatroomList')
106      @handle_response(MP)
107      def mps(self, update=False):
108          if update:
109              logger.info('{}: updating mps'.format(self))
110              return self.core.get_mps(update=update)
111          else:
112              return self._retrieve_itchat_storage('mpList')
113      @handle_response(User)
114      def user_details(self, user_or_users, chunk_size=50):
115          def chunks():
116              total = ensure_list(user_or_users)
117              for i in range(0, len(total), chunk_size):
118                  yield total[i:i + chunk_size]
119          @handle_response()
120          def process_one_chunk(_chunk):
121              return self.core.update_friend(userName=get_user_name(_chunk))
122          if isinstance(user_or_users, (list, tuple)):
123              ret = list()
124              for chunk in chunks():
125                  chunk_ret = process_one_chunk(chunk)
126                  if isinstance(chunk_ret, list):
127                      ret += chunk_ret
128                  else:
129                      ret.append(chunk_ret)
130              return ret
131          else:
132              return process_one_chunk(user_or_users)
133      def search(self, keywords=None, **attributes):
134          return self.chats().search(keywords, **attributes)
135      @handle_response()
136      def add_friend(self, user, verify_content=''):
137          logger.info('{}: adding {} (verify_content: {})'.format(self, user, verify_content))
138          user_name = get_user_name(user)
139          return self.core.add_friend(
140              userName=user_name,
141              status=2,
142              verifyContent=verify_content,
143              autoUpdate=True
144          )
145      @handle_response()
146      def add_mp(self, user):
147          logger.info('{}: adding {}'.format(self, user))
148          user_name = get_user_name(user)
149          return self.core.add_friend(
150              userName=user_name,
151              status=1,
152              autoUpdate=True
153          )
154      def accept_friend(self, user, verify_content=''):
155          logger.info('{}: accepting {} (verify_content: {})'.format(self, user, verify_content))
156          @handle_response()
157          def do():
158              return self.core.add_friend(
159                  userName=get_user_name(user),
<span onclick='openModal()' class='match'>160                  status=3,
161                  verifyContent=verify_content,
162                  autoUpdate=True
163              )
164          do()
</span>165          for friend in self.friends():
166              if friend == user:
167                  return friend
168      def create_group(self, users, topic=None):
169          logger.info('{}: creating group (topic: {}), with users:\n{}'.format(
170              self, topic, pformat(users)))
171          @handle_response()
172          def request():
173              return self.core.create_chatroom(
174                  memberList=dict_list,
175                  topic=topic or ''
176              )
177          dict_list = wrap_user_name(self.except_self(ensure_list(users)))
178          ret = request()
179          user_name = ret.get('ChatRoomName')
180          if user_name:
181              return Group(self.core.update_chatroom(userName=user_name), self)
182          else:
183              from wxpy.utils import decode_text_from_webwx
184              ret = decode_text_from_webwx(pformat(ret))
185              raise Exception('Failed to create group:\n{}'.format(ret))
186      def upload_file(self, path):
187          logger.info('{}: uploading file: {}'.format(self, path))
188          @handle_response()
189          def do():
190              upload = functools.partial(self.core.upload_file, fileDir=path)
191              ext = os.path.splitext(path)[1].lower()
192              if ext in ('.bmp', '.png', '.jpeg', '.jpg', '.gif'):
193                  return upload(isPicture=True)
194              elif ext == '.mp4':
195                  return upload(isVideo=True)
196              else:
197                  return upload()
198          return do().get('MediaId')
199      def _process_message(self, msg):
200          if not self.alive:
201              return
202          config = self.registered.get_config(msg)
203          logger.debug('{}: new message (func: {}):\n{}'.format(
204              self, config.func.__name__ if config else None, msg))
205          if config:
206              def process():
207                  try:
208                      ret = config.func(msg)
209                      if ret is not None:
210                          msg.reply(ret)
211                  except:
212                      logger.exception('an error occurred in {}.'.format(config.func))
213                  if self.auto_mark_as_read and not msg.type == SYSTEM and msg.sender != self.self:
214                      from wxpy import ResponseError
215                      try:
216                          msg.chat.mark_as_read()
217                      except ResponseError as e:
218                          logger.warning('failed to mark as read: {}'.format(e))
219              if config.run_async:
220                  start_new_thread(process, use_caller_name=True)
221              else:
222                  process()
223      def register(
224              self, chats=None, msg_types=None,
225              except_self=True, run_async=True, enabled=True
226      ):
227          def do_register(func):
228              self.registered.append(MessageConfig(
229                  bot=self, func=func, chats=chats, msg_types=msg_types,
230                  except_self=except_self, run_async=run_async, enabled=enabled
231              ))
232              return func
233          return do_register
234      def _listen(self):
235          try:
236              logger.info('{}: started'.format(self))
237              self.is_listening = True
238              while self.alive and self.is_listening:
239                  try:
240                      msg = Message(self.core.msgList.get(timeout=0.5), self)
241                  except queue.Empty:
242                      continue
243                  if msg.type != SYSTEM:
244                      self.messages.append(msg)
245                  try:
246                      self._process_message(msg)
247                  except:
248                      logger.exception('an error occurred while processing msg:\n{}'.format(msg))
249          finally:
250              self.is_listening = False
251              logger.info('{}: stopped'.format(self))
252      def start(self):
253          if not self.alive:
254              logger.warning('{} has been logged out!'.format(self))
255          elif self.is_listening:
256              logger.warning('{} is already running, no need to start again.'.format(self))
257          else:
258              self.listening_thread = start_new_thread(self._listen)
259      def stop(self):
260          if self.is_listening:
261              self.is_listening = False
262              self.listening_thread.join()
263          else:
264              logger.warning('{} is not running.'.format(self))
265      def join(self):
266          if isinstance(self.listening_thread, Thread):
267              try:
268                  logger.info('{}: joined'.format(self))
269                  self.listening_thread.join()
270              except KeyboardInterrupt:
271                  pass
272      def _cleanup(self):
273          if self.is_listening:
274              self.stop()
275          if self.alive and self.core.useHotReload:
276              self.dump_login_status()
277          self.temp_dir.cleanup()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from wxpy-MDEwOlJlcG9zaXRvcnk4MjU4ODU5Nw==-flat-bot.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from wxpy-MDEwOlJlcG9zaXRvcnk4MjU4ODU5Nw==-flat-bot.py</div>
                </div>
                <div class="column column_space"><pre><code>141              status=2,
142              verifyContent=verify_content,
143              autoUpdate=True
144          )
145      @handle_response()
</pre></code></div>
                <div class="column column_space"><pre><code>160                  status=3,
161                  verifyContent=verify_content,
162                  autoUpdate=True
163              )
164          do()
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    