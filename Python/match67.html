<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for animation.py &amp; controller.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for animation.py &amp; controller.py
      </h3>
<h1 align="center">
        6.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>animation.py (30.120481%)<th>controller.py (3.387534%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(38-42)<td><a href="#" name="0">(43-47)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(22-28)<td><a href="#" name="1">(100-107)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>animation.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from collada import source
2 from collada.common import DaeObject
3 from collada.common import DaeError
4     def __init__(self, id, name, sourceById, children, xmlnode<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None):
5         self.id = id
6         self.name = name
7         self.children = children
8         self.sourceById = sourceById
9         self.xmlnode = xmlnode
10         if</b></font> self.xmlnode is None:
11             self.xmlnode = None
12     @staticmethod
13     def load( collada, localscope, node ):
14         id = node.get('id') or ''
15         name = node.get('name') or ''
16         sourcebyid = localscope
17         sources = []
18         sourcenodes = node.findall(collada<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.tag('source'))
19         for sourcenode in sourcenodes:
20             ch = source.Source.load(collada, {}, sourcenode)
21             sources.append(ch)
22             sourcebyid[ch.id] =</b></font> ch
23         child_nodes = node.findall(collada.tag('animation'))
24         children = []
25         for child in child_nodes:
26             try:
27                 child = Animation.load(collada, sourcebyid, child)
28                 children.append(child)
29             except DaeError as ex:
30                 collada.handleError(ex)
31         anim = Animation(id, name, sourcebyid, children, node)
32         return anim
33     def __str__(self): return '&lt;Animation id=%s, children=%d&gt;' % (self.id, len(self.children))
34     def __repr__(self): return str(self)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>controller.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """Contains objects representing controllers. Currently has partial
2         sourcenodes = node.findall('%s/%s'%(controller.tag, collada<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.tag('source')))
3         for sourcenode in sourcenodes:
4             ch = source.Source.load(collada, {}, sourcenode)
5             sources.append(ch)
6             sourcebyid[ch.id] =</b></font> ch
7         if controller.tag == collada.tag('skin'):
8             return Skin.load(collada, sourcebyid, controller, node)
9         else:
10             return Morph.load(collada, sourcebyid, controller, node)
11 class BoundController( object ):
12 class Skin(Controller):
13     def __init__(self, sourcebyid, bind_shape_matrix, joint_source, joint_matrix_source,
14                  weight_source, weight_joint_source, vcounts, vertex_weight_index,
15                  offsets, geometry, controller_node=None, skin_node=None):
16         """Create a skin.
17         :Parameters:
18           sourceById
19             A dict mapping id's to a collada source
20           bind_shape_matrix
21             A numpy array of floats (pre-shape)
22           joint_source
23             The string id for the joint source
24           joint_matrix_source
25             The string id for the joint matrix source
26           weight_source
27             The string id for the weight source
28           weight_joint_source
29             The string id for the joint source of weights
30           vcounts
31             A list with the number of influences on each vertex
32           vertex_weight_index
33             An array with the indexes as they come from &lt;v&gt; array
34           offsets
35             A list with the offsets in the weight index array for each source
36             in (joint, weight)
37           geometry
38             The source geometry this should be applied to (geometry.Geometry)
39           controller_node
40             XML node of the &lt;controller&gt; tag which is the parent of this
41           skin_node
42             XML node of the &lt;skin&gt; tag if this is from there
43         """
44         self.sourcebyid = sourcebyid
45         self.bind_shape_matrix = bind_shape_matrix
46         self.joint_source = joint_source
47         self.joint_matrix_source = joint_matrix_source
48         self.weight_joint_source = weight_joint_source
49         self.vcounts = vcounts
50         self.vertex_weight_index <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= vertex_weight_index
51         self.offsets = offsets
52         self.geometry = geometry
53         self.controller_node = controller_node
54         self.skin_node = skin_node
55         self.xmlnode = controller_node
56         if</b></font> not type(self.geometry) is Geometry:
57             raise DaeMalformedError('Invalid reference geometry in skin')
58         self.id = controller_node.get('id')
59         if self.id is None:
60             raise DaeMalformedError('Controller node requires an ID')
61         self.nindices = max(self.offsets) + 1
62         if len(bind_shape_matrix) != 16:
63             raise DaeMalformedError('Corrupted bind shape matrix in skin')
64         self.bind_shape_matrix.shape = (4,4)
65         if not(joint_source in sourcebyid and joint_matrix_source in sourcebyid):
66             raise DaeBrokenRefError("Input in joints not found")
67         if not(type(sourcebyid[joint_source]) is source.NameSource or type(sourcebyid[joint_source]) is source.IDRefSource):
68             raise DaeIncompleteError("Could not find joint name input for skin")
69         if not type(sourcebyid[joint_matrix_source]) is source.FloatSource:
70             raise DaeIncompleteError("Could not find joint matrix source for skin")
71         joint_names = [j for j in sourcebyid[joint_source]]
72         joint_matrices = sourcebyid[joint_matrix_source].data
73         joint_matrices.shape = (-1,4,4)
74         if len(joint_names) != len(joint_matrices):
75             raise DaeMalformedError("Skin joint and matrix inputs must be same length")
76         self.joint_matrices = {}
77         for n,m in zip(joint_names, joint_matrices):
78             self.joint_matrices[n] = m
79         if not(weight_source in sourcebyid and weight_joint_source in sourcebyid):
80             raise DaeBrokenRefError("Weights input in joints not found")
81         if not type(sourcebyid[weight_source]) is source.FloatSource:
82             raise DaeIncompleteError("Could not find weight inputs for skin")
83         if not(type(sourcebyid[weight_joint_source]) is source.NameSource or type(sourcebyid[weight_joint_source]) is source.IDRefSource):
84             raise DaeIncompleteError("Could not find weight joint source input for skin")
85         self.weights = sourcebyid[weight_source]
86         self.weight_joints = sourcebyid[weight_joint_source]
87         try:
88             newshape = []
89             at = 0
90             for ct in self.vcounts:
91                 this_set = self.vertex_weight_index[self.nindices*at:self.nindices*(at+ct)]
92                 this_set.shape = (ct, self.nindices)
93                 newshape.append(numpy.array(this_set))
94                 at+=ct
95             self.index = newshape
96         except:
97             raise DaeMalformedError('Corrupted vcounts or index in skin weights')
98         try:
99             self.joint_index = [influence[:, self.offsets[0]] for influence in self.index]
100             self.weight_index = [influence[:, self.offsets[1]] for influence in self.index]
101         except:
102             raise DaeMalformedError('Corrupted joint or weight index in skin')
103         self.max_joint_index = numpy.max( [numpy.max(joint) if len(joint) &gt; 0 else 0 for joint in self.joint_index] )
104         self.max_weight_index = numpy.max( [numpy.max(weight) if len(weight) &gt; 0 else 0 for weight in self.weight_index] )
105         checkSource(self.weight_joints, ('JOINT',), self.max_joint_index)
106         checkSource(self.weights, ('WEIGHT',), self.max_weight_index)
107     def __len__(self):
108         return len(self.index)
109     def __getitem__(self, i):
110         return self.index[i]
111     def bind(self, matrix, materialnodebysymbol):
112         return BoundSkin(self, matrix, materialnodebysymbol)
113     @staticmethod
114     def load( collada, localscope, skinnode, controllernode ):
115         if len(localscope) &lt; 3:
116             raise DaeMalformedError('Not enough sources in skin')
117         geometry_source = skinnode.get('source')
118         if geometry_source is None or len(geometry_source) &lt; 2 \
119                 or geometry_source[0] != '#':
120             raise DaeBrokenRefError('Invalid source attribute of skin node')
121         if not geometry_source[1:] in collada.geometries:
122             raise DaeBrokenRefError('Source geometry for skin node not found')
123         geometry = collada.geometries[geometry_source[1:]]
124         bind_shape_mat = skinnode.find(collada.tag('bind_shape_matrix'))
125         if bind_shape_mat is None:
126             bind_shape_mat = numpy.identity(4, dtype=numpy.float32)
127             bind_shape_mat.shape = (-1,)
128         else:
129             try:
130                 values = [ float(v) for v in bind_shape_mat.text.split()]
131             except ValueError:
132                 raise DaeMalformedError('Corrupted bind shape matrix in skin')
133             bind_shape_mat = numpy.array( values, dtype=numpy.float32 )
134         inputnodes = skinnode.findall('%s/%s'%(collada.tag('joints'), collada.tag('input')))
135         if inputnodes is None or len(inputnodes) &lt; 2:
136             raise DaeIncompleteError("Not enough inputs in skin joints")
137         try:
138             inputs = [(i.get('semantic'), i.get('source')) for i in inputnodes]
139         except ValueError as ex:
140             raise DaeMalformedError('Corrupted inputs in skin')
141         joint_source = None
142         matrix_source = None
143         for i in inputs:
144             if len(i[1]) &lt; 2 or i[1][0] != '#':
145                 raise DaeBrokenRefError('Input in skin node %s not found'%i[1])
146             if i[0] == 'JOINT':
147                 joint_source = i[1][1:]
148             elif i[0] == 'INV_BIND_MATRIX':
149                 matrix_source = i[1][1:]
150         weightsnode = skinnode.find(collada.tag('vertex_weights'))
151         if weightsnode is None:
152             raise DaeIncompleteError("No vertex_weights found in skin")
153         indexnode = weightsnode.find(collada.tag('v'))
154         if indexnode is None:
155             raise DaeIncompleteError('Missing indices in skin vertex weights')
156         vcountnode = weightsnode.find(collada.tag('vcount'))
157         if vcountnode is None:
158             raise DaeIncompleteError('Missing vcount in skin vertex weights')
159         inputnodes = weightsnode.findall(collada.tag('input'))
160         try:
161             index = numpy.array([float(v)
162                 for v in indexnode.text.split()], dtype=numpy.int32)
163             vcounts = numpy.array([int(v)
164                 for v in vcountnode.text.split()], dtype=numpy.int32)
165             inputs = [(i.get('semantic'), i.get('source'), int(i.get('offset')))
166                            for i in inputnodes]
167         except ValueError as ex:
168             raise DaeMalformedError('Corrupted index or offsets in skin vertex weights')
169         weight_joint_source = None
170         weight_source = None
171         offsets = [0, 0]
172         for i in inputs:
173             if len(i[1]) &lt; 2 or i[1][0] != '#':
174                 raise DaeBrokenRefError('Input in skin node %s not found' % i[1])
175             if i[0] == 'JOINT':
176                 weight_joint_source = i[1][1:]
177                 offsets[0] = i[2]
178             elif i[0] == 'WEIGHT':
179                 weight_source = i[1][1:]
180                 offsets[1] = i[2]
181         if joint_source is None or weight_source is None:
182             raise DaeMalformedError('Not enough inputs for vertex weights in skin')
183         return Skin(localscope, bind_shape_mat, joint_source, matrix_source,
184                 weight_source, weight_joint_source, vcounts, index, offsets,
185                 geometry, controllernode, skinnode)
186 class BoundSkin(BoundController):
187     def __init__(self, skin, matrix, materialnodebysymbol):
188         self.matrix = matrix
189         self.materialnodebysymbol = materialnodebysymbol
190         self.skin = skin
191         self.id = skin.id
192         self.index = skin.index
193         self.joint_matrices = skin.joint_matrices
194         self.geometry = skin.geometry.bind(numpy.dot(matrix,skin.bind_shape_matrix), materialnodebysymbol)
195     def __len__(self):
196         return len(self.index)
197     def __getitem__(self, i):
198         return self.index[i]
199     def getJoint(self, i):
200         return self.skin.weight_joints[i]
201     def getWeight(self, i):
202         return self.skin.weights[i]
203     def primitives(self):
204         for prim in self.geometry.primitives():
205             bsp = BoundSkinPrimitive(prim, self)
206             yield bsp
207 class BoundSkinPrimitive(object):
208     def __init__(self, primitive, boundskin):
209         self.primitive = primitive
210         self.boundskin = boundskin
211     def __len__(self):
212         return len(self.primitive)
213     def shapes(self):
214         for shape in self.primitive.shapes():
215             indices = shape.indices
216             yield shape
217 class Morph(Controller):
218     def __init__(self, source_geometry, target_list, xmlnode=None):
219         """Create a morph instance
220         :Parameters:
221           source_geometry
222             The source geometry (Geometry)
223           targets
224             A list of tuples where each tuple (g,w) contains
225             a Geometry (g) and a float weight value (w)
226           xmlnode
227             When loaded, the xmlnode it comes from
228         """
229         self.id = xmlnode.get('id')
230         if self.id is None:
231             raise DaeMalformedError('Controller node requires an ID')
232         self.source_geometry = source_geometry
233         self.target_list = target_list
234         """A list of tuples where each tuple (g,w) contains
235             a Geometry (g) and a float weight value (w)"""
236         self.xmlnode = xmlnode
237     def __len__(self):
238         return len(self.target_list)
239     def __getitem__(self, i):
240         return self.target_list[i]
241     def bind(self, matrix, materialnodebysymbol):
242         return BoundMorph(self, matrix, materialnodebysymbol)
243     @staticmethod
244     def load( collada, localscope, morphnode, controllernode ):
245         baseid = morphnode.get('source')
246         if len(baseid) &lt; 2 or baseid[0] != '#' or \
247                 not baseid[1:] in collada.geometries:
248             raise DaeBrokenRefError('Base source of morph %s not found' % baseid)
249         basegeom = collada.geometries[baseid[1:]]
250         method = morphnode.get('method')
251         if method is None:
252             method = 'NORMALIZED'
253         if not (method == 'NORMALIZED' or method == 'RELATIVE'):
254             raise DaeMalformedError("Morph method must be either NORMALIZED or RELATIVE. Found '%s'" % method)
255         inputnodes = morphnode.findall('%s/%s'%(collada.tag('targets'), collada.tag('input')))
256         if inputnodes is None or len(inputnodes) &lt; 2:
257             raise DaeIncompleteError("Not enough inputs in a morph")
258         try:
259             inputs = [(i.get('semantic'), i.get('source')) for i in inputnodes]
260         except ValueError as ex:
261             raise DaeMalformedError('Corrupted inputs in morph')
262         target_source = None
263         weight_source = None
264         for i in inputs:
265             if len(i[1]) &lt; 2 or i[1][0] != '#' or not i[1][1:] in localscope:
266                 raise DaeBrokenRefError('Input in morph node %s not found' % i[1])
267             if i[0] == 'MORPH_TARGET':
268                 target_source = localscope[i[1][1:]]
269             elif i[0] == 'MORPH_WEIGHT':
270                 weight_source = localscope[i[1][1:]]
271         if not type(target_source) is source.IDRefSource or \
272                 not type(weight_source) is source.FloatSource:
273             raise DaeIncompleteError("Not enough inputs in targets of morph")
274         if len(target_source) != len(weight_source):
275             raise DaeMalformedError("Morph inputs must be of same length")
276         target_list = []
277         for target, weight in zip(target_source, weight_source):
278             if len(target) &lt; 1 or not(target in collada.geometries):
279                 raise DaeBrokenRefError("Targeted geometry %s in morph not found"%target)
280             target_list.append((collada.geometries[target], weight[0]))
281         return Morph(basegeom, target_list, controllernode)
282     def save(self):
283         pass
284 class BoundMorph(BoundController):
285     def __init__(self, morph, matrix, materialnodebysymbol):
286         self.matrix = matrix
287         self.materialnodebysymbol = materialnodebysymbol
288         self.original = morph
289     def __len__(self):
290         return len(self.original)
291     def __getitem__(self, i):
292         return self.original[i]
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
