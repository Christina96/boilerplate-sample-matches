
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-mute.py</h3>
            <pre><code>1  from telethon import events
2  from telethon.utils import get_display_name
3  from pyUltroid.dB.mute_db import is_muted, mute, unmute
4  from pyUltroid.fns.admins import ban_time
5  from . import asst, eod, get_string, inline_mention, ultroid_bot, ultroid_cmd
6  @ultroid_bot.on(events.NewMessage(incoming=True))
7  async def watcher(event):
8      if is_muted(event.chat_id, event.sender_id):
9          await event.delete()
10      if event.via_bot and is_muted(event.chat_id, event.via_bot_id):
11          await event.delete()
12  @ultroid_cmd(
13      pattern="dmute( (.*)|$)",
14  )
15  async def startmute(event):
16      xx = await event.eor("`Muting...`")
17      if input_ := event.pattern_match.group(1).strip():
18          try:
19              userid = await event.client.parse_id(input_)
20          except Exception as x:
21              return await xx.edit(str(x))
22      elif event.reply_to_msg_id:
23          reply = await event.get_reply_message()
24          userid = reply.sender_id
25          if reply.out or userid in [ultroid_bot.me.id, asst.me.id]:
26              return await xx.eor("`You cannot mute yourself or your assistant bot.`")
27      elif event.is_private:
28          userid = event.chat_id
29      else:
30          return await xx.eor("`Reply to a user or add their userid.`", time=5)
31      chat = await event.get_chat()
32      if "admin_rights" in vars(chat) and vars(chat)["admin_rights"] is not None:
33          if not chat.admin_rights.delete_messages:
34              return await xx.eor("`No proper admin rights...`", time=5)
35      elif "creator" not in vars(chat) and not event.is_private:
36          return await xx.eor("`No proper admin rights...`", time=5)
37      if is_muted(event.chat_id, userid):
38          return await xx.eor("`This user is already muted in this chat.`", time=5)
39      mute(event.chat_id, userid)
40      await xx.eor("`Successfully muted...`", time=3)
41  @ultroid_cmd(
42      pattern="undmute( (.*)|$)",
43  )
44  async def endmute(event):
45      xx = await event.eor("`Unmuting...`")
46      if input_ := event.pattern_match.group(1).strip():
47          try:
48              userid = await event.client.parse_id(input_)
49          except Exception as x:
50              return await xx.edit(str(x))
51      elif event.reply_to_msg_id:
52          userid = (await event.get_reply_message()).sender_id
53      elif event.is_private:
54          userid = event.chat_id
55      else:
56          return await xx.eor("`Reply to a user or add their userid.`", time=5)
57      if not is_muted(event.chat_id, userid):
58          return await xx.eor("`This user is not muted in this chat.`", time=3)
59      unmute(event.chat_id, userid)
60      await xx.eor("`Successfully unmuted...`", time=3)
61  @ultroid_cmd(
62      pattern="tmute",
63      groups_only=True,
64      manager=True,
65  )
66  async def _(e):
67      xx = await e.eor("`Muting...`")
68      huh = e.text.split()
69      try:
70          tme = huh[1]
71      except IndexError:
72          return await xx.eor("`Time till mute?`", time=5)
<span onclick='openModal()' class='match'>73      try:
74          input_ = huh[2]
75      except IndexError:
76          input_ = ""
77      chat = await e.get_chat()
</span>78      if e.reply_to_msg_id:
79          reply = await e.get_reply_message()
80          userid = reply.sender_id
81          name = (await reply.get_sender()).first_name
82      elif input_:
83          userid = await e.client.parse_id(input_)
84          name = (await e.client.get_entity(userid)).first_name
85      else:
86          return await xx.eor(get_string("tban_1"), time=3)
87      if userid == ultroid_bot.uid:
88          return await xx.eor("`I can't mute myself.`", time=3)
89      try:
90          bun = ban_time(tme)
91          await e.client.edit_permissions(
92              chat.id,
93              userid,
94              until_date=bun,
95              send_messages=False,
96          )
97          await eod(
98              xx,
99              f"`Successfully Muted` [{name}](tg://user?id={userid}) `in {chat.title} for {tme}`",
100              time=5,
101          )
102      except BaseException as m:
103          await xx.eor(f"`{m}`", time=5)
104  @ultroid_cmd(
105      pattern="unmute( (.*)|$)",
106      admins_only=True,
107      manager=True,
108  )
109  async def _(e):
110      xx = await e.eor("`Unmuting...`")
111      input = e.pattern_match.group(1).strip()
112      chat = await e.get_chat()
113      if e.reply_to_msg_id:
114          reply = await e.get_reply_message()
115          userid = reply.sender_id
116          name = (await reply.get_sender()).first_name
117      elif input:
118          userid = await e.client.parse_id(input)
119          name = (await e.client.get_entity(userid)).first_name
120      else:
121          return await xx.eor(get_string("tban_1"), time=3)
122      try:
123          await e.client.edit_permissions(
124              chat.id,
125              userid,
126              until_date=None,
127              send_messages=True,
128          )
129          await eod(
130              xx,
131              f"`Successfully Unmuted` [{name}](tg://user?id={userid}) `in {chat.title}`",
132              time=5,
133          )
134      except BaseException as m:
135          await xx.eor(f"`{m}`", time=5)
136  @ultroid_cmd(
137      pattern="mute( (.*)|$)", admins_only=True, manager=True, require="ban_users"
138  )
139  async def _(e):
140      xx = await e.eor("`Muting...`")
141      input = e.pattern_match.group(1).strip()
142      chat = await e.get_chat()
143      if e.reply_to_msg_id:
144          userid = (await e.get_reply_message()).sender_id
145          name = get_display_name(await e.client.get_entity(userid))
146      elif input:
147          try:
148              userid = await e.client.parse_id(input)
149              name = inline_mention(await e.client.get_entity(userid))
150          except Exception as x:
151              return await xx.edit(str(x))
152      else:
153          return await xx.eor(get_string("tban_1"), time=3)
154      if userid == ultroid_bot.uid:
155          return await xx.eor("`I can't mute myself.`", time=3)
156      try:
157          await e.client.edit_permissions(
158              chat.id,
159              userid,
160              until_date=None,
161              send_messages=False,
162          )
163          await eod(
164              xx,
165              f"`Successfully Muted` {name} `in {chat.title}`",
166          )
167      except BaseException as m:
168          await xx.eor(f"`{m}`", time=5)
</code></pre>
        </div>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-ytdl_7.py</h3>
            <pre><code>1  import os
2  import re
3  try:
4      from PIL import Image
5  except ImportError:
6      Image = None
7  from telethon import Button
8  from telethon.errors.rpcerrorlist import FilePartLengthInvalidError, MediaEmptyError
9  from telethon.tl.types import DocumentAttributeAudio, DocumentAttributeVideo
10  from telethon.tl.types import InputWebDocument as wb
11  from pyUltroid.fns.helper import (
12      bash,
13      fast_download,
14      humanbytes,
15      numerize,
16      time_formatter,
17  )
18  from pyUltroid.fns.ytdl import dler, get_buttons, get_formats
19  from . import LOGS, asst, callback, in_pattern, udB
20  try:
21      from youtubesearchpython import VideosSearch
22  except ImportError:
23      LOGS.info("'youtubesearchpython' not installed!")
24      VideosSearch = None
25  ytt = "https://graph.org/file/afd04510c13914a06dd03.jpg"
26  _yt_base_url = "https://www.youtube.com/watch?v="
27  BACK_BUTTON = {}
28  @in_pattern("yt", owner=True)
29  async def _(event):
30      try:
31          string = event.text.split(" ", maxsplit=1)[1]
32      except IndexError:
33          fuk = event.builder.article(
34              title="Search Something",
35              thumb=wb(ytt, 0, "image/jpeg", []),
36              text="**YᴏᴜTᴜʙᴇ Sᴇᴀʀᴄʜ**\n\nYou didn't search anything",
37              buttons=Button.switch_inline(
38                  "Sᴇᴀʀᴄʜ Aɢᴀɪɴ",
39                  query="yt ",
40                  same_peer=True,
41              ),
42          )
43          await event.answer([fuk])
44          return
45      results = []
46      search = VideosSearch(string, limit=50)
47      nub = search.result()
48      nibba = nub["result"]
49      for v in nibba:
50          ids = v["id"]
51          link = _yt_base_url + ids
52          title = v["title"]
53          duration = v["duration"]
54          views = v["viewCount"]["short"]
55          publisher = v["channel"]["name"]
56          published_on = v["publishedTime"]
57          description = (
58              v["descriptionSnippet"][0]["text"]
59              if v.get("descriptionSnippet")
60              and len(v["descriptionSnippet"][0]["text"]) < 500
61              else "None"
62          )
63          thumb = f"https://i.ytimg.com/vi/{ids}/hqdefault.jpg"
64          text = f"**Title: [{title}]({link})**\n\n"
65          text += f"`Description: {description}\n\n"
66          text += f"「 Duration: {duration} 」\n"
67          text += f"「 Views: {views} 」\n"
68          text += f"「 Publisher: {publisher} 」\n"
69          text += f"「 Published on: {published_on} 」`"
70          desc = f"{title}\n{duration}"
71          file = wb(thumb, 0, "image/jpeg", [])
72          buttons = [
73              [
74                  Button.inline("Audio", data=f"ytdl:audio:{ids}"),
75                  Button.inline("Video", data=f"ytdl:video:{ids}"),
76              ],
77              [
78                  Button.switch_inline(
79                      "Sᴇᴀʀᴄʜ Aɢᴀɪɴ",
80                      query="yt ",
81                      same_peer=True,
82                  ),
83                  Button.switch_inline(
84                      "Sʜᴀʀᴇ",
85                      query=f"yt {string}",
86                      same_peer=False,
87                  ),
88              ],
89          ]
90          BACK_BUTTON.update({ids: {"text": text, "buttons": buttons}})
91          results.append(
92              await event.builder.article(
93                  type="photo",
94                  title=title,
95                  description=desc,
96                  thumb=file,
97                  content=file,
98                  text=text,
99                  include_media=True,
100                  buttons=buttons,
101              ),
102          )
103      await event.answer(results[:50])
104  @callback(
105      re.compile(
106          "ytdl:(.*)",
107      ),
108      owner=True,
109  )
110  async def _(e):
111      _e = e.pattern_match.group(1).strip().decode("UTF-8")
112      _lets_split = _e.split(":")
113      _ytdl_data = await dler(e, _yt_base_url + _lets_split[1])
114      _data = get_formats(_lets_split[0], _lets_split[1], _ytdl_data)
115      _buttons = get_buttons(_data)
116      _text = (
117          "`Select Your Format.`"
118          if _buttons
119          else "`Error downloading from YouTube.\nTry Restarting your bot.`"
120      )
121      await e.edit(_text, buttons=_buttons)
122  @callback(
123      re.compile(
124          "ytdownload:(.*)",
125      ),
126      owner=True,
127  )
128  async def _(event):
129      url = event.pattern_match.group(1).strip().decode("UTF-8")
130      lets_split = url.split(":")
131      vid_id = lets_split[2]
132      link = _yt_base_url + vid_id
133      format = lets_split[1]
<span onclick='openModal()' class='match'>134      try:
135          ext = lets_split[3]
136      except IndexError:
137          ext = "mp3"
138      if lets_split[0] == "audio":
</span>139          opts = {
140              "format": "bestaudio",
141              "addmetadata": True,
142              "key": "FFmpegMetadata",
143              "prefer_ffmpeg": True,
144              "geo_bypass": True,
145              "outtmpl": f"%(id)s.{ext}",
146              "logtostderr": False,
147              "postprocessors": [
148                  {
149                      "key": "FFmpegExtractAudio",
150                      "preferredcodec": ext,
151                      "preferredquality": format,
152                  },
153                  {"key": "FFmpegMetadata"},
154              ],
155          }
156          ytdl_data = await dler(event, link, opts, True)
157          title = ytdl_data["title"]
158          if ytdl_data.get("artist"):
159              artist = ytdl_data["artist"]
160          elif ytdl_data.get("creator"):
161              artist = ytdl_data["creator"]
162          elif ytdl_data.get("channel"):
163              artist = ytdl_data["channel"]
164          views = numerize(ytdl_data.get("view_count")) or 0
165          thumb, _ = await fast_download(ytdl_data["thumbnail"], filename=f"{vid_id}.jpg")
166          likes = numerize(ytdl_data.get("like_count")) or 0
167          duration = ytdl_data.get("duration") or 0
168          description = (
169              ytdl_data["description"]
170              if len(ytdl_data["description"]) < 100
171              else ytdl_data["description"][:100]
172          )
173          description = description or "None"
174          filepath = f"{vid_id}.{ext}"
175          if not os.path.exists(filepath):
176              filepath = f"{filepath}.{ext}"
177          size = os.path.getsize(filepath)
178          file, _ = await event.client.fast_uploader(
179              filepath,
180              filename=f"{title}.{ext}",
181              show_progress=True,
182              event=event,
183              to_delete=True,
184          )
185          attributes = [
186              DocumentAttributeAudio(
187                  duration=int(duration),
188                  title=title,
189                  performer=artist,
190              ),
191          ]
192      elif lets_split[0] == "video":
193          opts = {
194              "format": str(format),
195              "addmetadata": True,
196              "key": "FFmpegMetadata",
197              "prefer_ffmpeg": True,
198              "geo_bypass": True,
199              "outtmpl": f"%(id)s.{ext}",
200              "logtostderr": False,
201              "postprocessors": [{"key": "FFmpegMetadata"}],
202          }
203          ytdl_data = await dler(event, link, opts, True)
204          title = ytdl_data["title"]
205          if ytdl_data.get("artist"):
206              artist = ytdl_data["artist"]
207          elif ytdl_data.get("creator"):
208              artist = ytdl_data["creator"]
209          elif ytdl_data.get("channel"):
210              artist = ytdl_data["channel"]
211          views = numerize(ytdl_data.get("view_count")) or 0
212          thumb, _ = await fast_download(ytdl_data["thumbnail"], filename=f"{vid_id}.jpg")
213          try:
214              Image.open(thumb).save(thumb, "JPEG")
215          except Exception as er:
216              LOGS.exception(er)
217              thumb = None
218          description = (
219              ytdl_data["description"]
220              if len(ytdl_data["description"]) < 100
221              else ytdl_data["description"][:100]
222          )
223          likes = numerize(ytdl_data.get("like_count")) or 0
224          hi, wi = ytdl_data.get("height") or 720, ytdl_data.get("width") or 1280
225          duration = ytdl_data.get("duration") or 0
226          filepath = f"{vid_id}.mkv"
227          if not os.path.exists(filepath):
228              filepath = f"{filepath}.webm"
229          size = os.path.getsize(filepath)
230          file, _ = await event.client.fast_uploader(
231              filepath,
232              filename=f"{title}.mkv",
233              show_progress=True,
234              event=event,
235              to_delete=True,
236          )
237          attributes = [
238              DocumentAttributeVideo(
239                  duration=int(duration),
240                  w=wi,
241                  h=hi,
242                  supports_streaming=True,
243              ),
244          ]
245      description = description if description != "" else "None"
246      text = f"**Title: [{title}]({_yt_base_url}{vid_id})**\n\n"
247      text += f"`📝 Description: {description}\n\n"
248      text += f"「 Duration: {time_formatter(int(duration)*1000)} 」\n"
249      text += f"「 Artist: {artist} 」\n"
250      text += f"「 Views: {views} 」\n"
251      text += f"「 Likes: {likes} 」\n"
252      text += f"「 Size: {humanbytes(size)} 」`"
253      button = Button.switch_inline("Search More", query="yt ", same_peer=True)
254      try:
255          await event.edit(
256              text,
257              file=file,
258              buttons=button,
259              attributes=attributes,
260              thumb=thumb,
261          )
262      except (FilePartLengthInvalidError, MediaEmptyError):
263          file = await asst.send_message(
264              udB.get_key("LOG_CHANNEL"),
265              text,
266              file=file,
267              buttons=button,
268              attributes=attributes,
269              thumb=thumb,
270          )
271          await event.edit(text, file=file.media, buttons=button)
272      await bash(f"rm {vid_id}.jpg")
273  @callback(re.compile("ytdl_back:(.*)"), owner=True)
274  async def ytdl_back(event):
275      id_ = event.data_match.group(1).decode("utf-8")
276      if not BACK_BUTTON.get(id_):
277          return await event.answer("Query Expired! Search again 🔍")
278      await event.edit(**BACK_BUTTON[id_])
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-mute.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-ytdl_7.py</div>
                </div>
                <div class="column column_space"><pre><code>73      try:
74          input_ = huh[2]
75      except IndexError:
76          input_ = ""
77      chat = await e.get_chat()
</pre></code></div>
                <div class="column column_space"><pre><code>134      try:
135          ext = lets_split[3]
136      except IndexError:
137          ext = "mp3"
138      if lets_split[0] == "audio":
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    