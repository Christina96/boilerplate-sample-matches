<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_nxos_2.py &amp; esxi_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_nxos_2.py &amp; esxi_3.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_nxos_2.py (2.0378456%)<th>esxi_3.py (0.77691454%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(165-172)<td><a href="#" name="0">(1585-1598)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_nxos_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import salt.proxy.nxos as nxos_proxy
import salt.utils.nxos as nxos_utils
from salt.exceptions import CommandExecutionError
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, create_autospec, patch
from tests.support.unit import TestCase
from tests.unit.modules.nxos.nxos_grains import n9k_grains
from tests.unit.modules.nxos.nxos_show_cmd_output import n9k_show_ver_list
class NxosNxapiProxyTestCase(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {nxos_proxy: {"CONNECTION": "nxapi"}}
    def test_check_virtual(self):
        result = nxos_proxy.__virtual__()
        self.assertIn("nxos", result)
    def test_init(self):
        with patch.object(nxos_proxy, "__opts__", {"proxy": {"connection": "nxapi"}}):
            with patch("salt.proxy.nxos._init_nxapi", autospec=True) as init_nxapi:
                result = nxos_proxy.init()
                self.assertEqual(result, init_nxapi.return_value)
    def test_init_opts_none(self):
        with patch.object(nxos_proxy, "__opts__", {"proxy": {"connection": None}}):
            with patch("salt.proxy.nxos._init_nxapi", autospec=True) as init_nxapi:
                result = nxos_proxy.init()
                self.assertEqual(result, init_nxapi.return_value)
    def test_init_bad_connection_type(self):
        with patch.object(nxos_proxy, "__opts__", {"proxy": {"connection": "unknown"}}):
            self.assertFalse(nxos_proxy.init())
    def test_initialized(self):
        with patch(
            "salt.proxy.nxos._initialized_nxapi", autospec=True
        ) as initialized_nxapi:
            result = nxos_proxy.initialized()
            self.assertEqual(result, initialized_nxapi.return_value)
    def test_ping(self):
        with patch("salt.proxy.nxos._ping_nxapi", autospec=True) as ping_nxapi:
            result = nxos_proxy.ping()
            self.assertEqual(result, ping_nxapi.return_value)
    def test_grains(self):
        with patch(
            "salt.proxy.nxos.sendline", autospec=True, return_value=n9k_show_ver_list
        ):
            result = nxos_proxy.grains()
            self.assertEqual(result, n9k_grains)
    def test_grains_cache_set(self):
        with patch(
            "salt.proxy.nxos.DEVICE_DETAILS", {"grains_cache": n9k_grains["nxos"]}
        ):
            with patch(
                "salt.proxy.nxos.sendline",
                autospec=True,
                return_value=n9k_show_ver_list,
            ):
                result = nxos_proxy.grains()
                self.assertEqual(result, n9k_grains)
    def test_grains_refresh(self):
        device_details = {"grains_cache": None}
        with patch("salt.proxy.nxos.DEVICE_DETAILS", device_details):
            with patch("salt.proxy.nxos.grains", autospec=True) as grains:
                result = nxos_proxy.grains_refresh()
                self.assertEqual(nxos_proxy.DEVICE_DETAILS["grains_cache"], {})
                self.assertEqual(result, grains.return_value)
    def test_sendline(self):
        command = "show version"
        with patch("salt.proxy.nxos._nxapi_request", autospec=True) as nxapi_request:
            result = nxos_proxy.sendline(command)
            self.assertEqual(result, nxapi_request.return_value)
    def test_proxy_config(self):
        commands = ["feature bgp", "router bgp 65535"]
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {"save_config": False}):
            with patch(
                "salt.proxy.nxos._nxapi_request", autospec=True
            ) as nxapi_request:
                result = nxos_proxy.proxy_config(commands)
                self.assertEqual(result, [commands, nxapi_request.return_value])
    def test_proxy_config_save_config(self):
        commands = ["feature bgp", "router bgp 65535"]
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {"save_config": None}):
            with patch(
                "salt.proxy.nxos._nxapi_request", autospec=True
            ) as nxapi_request:
                result = nxos_proxy.proxy_config(commands, save_config=True)
                self.assertEqual(result, [commands, nxapi_request.return_value])
    def test__init_nxapi(self):
        opts = {"proxy": {"arg1": None}}
        nxapi_request = create_autospec(nxos_utils.nxapi_request, return_value="data")
<a name="0"></a>
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {}) as device_details:
            with patch(
                "salt.proxy.nxos.__utils__", {<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"nxos.nxapi_request": nxapi_request}
            ):
                result = nxos_proxy._init_nxapi(opts)
                self.assertTrue(device_details["initialized"])
                self.assertTrue(device_details["up"])
                self.assertTrue(device_details["save_config"])
                self.</b></font>assertTrue(result)
                nxapi_request.assert_called_with("show clock", **opts["proxy"])
    def test_bad__init_nxapi(self):
        class NXAPIException(Exception):
            pass
        nxapi_request = create_autospec(
            nxos_utils.nxapi_request, side_effect=NXAPIException
        )
        with patch("salt.proxy.nxos.__utils__", {"nxos.nxapi_request": nxapi_request}):
            with patch("salt.proxy.nxos.log", autospec=True) as log:
                with self.assertRaises(NXAPIException):
                    nxos_proxy._init_nxapi({"proxy": {"host": "HOST"}})
                log.error.assert_called()
    def test__initialized_nxapi(self):
        result = nxos_proxy._initialized_nxapi()
        self.assertFalse(result)
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {"initialized": True}):
            result = nxos_proxy._initialized_nxapi()
            self.assertTrue(result)
    def test__ping_nxapi(self):
        result = nxos_proxy._ping_nxapi()
        self.assertFalse(result)
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {"up": True}):
            result = nxos_proxy._ping_nxapi()
            self.assertTrue(result)
    def test__shutdown_nxapi(self):
        opts = {"id": "value"}
        with patch("salt.proxy.nxos.log", autospec=True):
            nxos_proxy._shutdown_nxapi()
    def test__nxapi_request_ssh_return(self):
        commands = "show version"
        with patch("salt.proxy.nxos.CONNECTION", "ssh"):
            result = nxos_proxy._nxapi_request(commands)
            self.assertEqual("_nxapi_request is not available for ssh proxy", result)
    def test__nxapi_request_connect(self):
        commands = "show version"
        nxapi_request = create_autospec(nxos_utils.nxapi_request, return_value="data")
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {"conn_args": {"arg1": None}}):
            with patch(
                "salt.proxy.nxos.__utils__", {"nxos.nxapi_request": nxapi_request}
            ):
                result = nxos_proxy._nxapi_request(commands)
                self.assertEqual("data", result)
                nxapi_request.assert_called_with(commands, method="cli_conf", arg1=None)
class NxosSSHProxyTestCase(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {
            nxos_proxy: {
                "__opts__": {
                    "proxy": {
                        "host": "dt-n9k5-1.cisco.com",
                        "username": "admin",
                        "password": "password",
                    }
                },
                "CONNECTION": "ssh",
            }
        }
    def test_init(self):
        with patch("salt.proxy.nxos._init_ssh", autospec=True) as init_ssh:
            result = nxos_proxy.init()
            self.assertEqual(result, init_ssh.return_value)
    def test_init_opts_none(self):
        with patch("salt.proxy.nxos.__opts__", {"proxy": {"connection": None}}):
            with patch("salt.proxy.nxos._init_ssh", autospec=True) as init_ssh:
                result = nxos_proxy.init()
                self.assertEqual(result, init_ssh.return_value)
    def test_initialized(self):
        with patch(
            "salt.proxy.nxos._initialized_ssh", autospec=True
        ) as initialized_ssh:
            result = nxos_proxy.initialized()
            self.assertEqual(result, initialized_ssh.return_value)
    def test_ping(self):
        with patch("salt.proxy.nxos._ping_ssh", autospec=True) as ping_ssh:
            result = nxos_proxy.ping()
            self.assertEqual(result, ping_ssh.return_value)
    def test_grains(self):
        with patch(
            "salt.proxy.nxos.sendline", autospec=True, return_value=n9k_show_ver_list[0]
        ):
            result = nxos_proxy.grains()
            self.assertEqual(result, n9k_grains)
    def test_sendline(self):
        command = "show version"
        with patch("salt.proxy.nxos._sendline_ssh", autospec=True) as sendline_ssh:
            result = nxos_proxy.sendline(command)
            self.assertEqual(result, sendline_ssh.return_value)
    def test_proxy_config(self):
        commands = ["feature bgp", "router bgp 65535"]
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {"save_config": False}):
            with patch("salt.proxy.nxos._sendline_ssh", autospec=True) as sendline_ssh:
                result = nxos_proxy.proxy_config(commands)
                self.assertEqual(result, [commands, sendline_ssh.return_value])
    def test_proxy_config_save_config(self):
        commands = ["feature bgp", "router bgp 65535"]
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {"save_config": None}):
            with patch("salt.proxy.nxos._sendline_ssh", autospec=True) as sendline_ssh:
                result = nxos_proxy.proxy_config(commands, save_config=True)
                self.assertEqual(result, [commands, sendline_ssh.return_value])
    def test_proxy_config_error(self):
        with patch(
            "salt.proxy.nxos._sendline_ssh",
            autospec=True,
            side_effect=CommandExecutionError,
        ):
            with self.assertRaises(CommandExecutionError):
                nxos_proxy.proxy_config("show version", save_config=True)
    def test__init_ssh_device_details(self):
        with patch("salt.proxy.nxos.SSHConnection", autospec=True) as SSHConnection:
            SSHConnection().sendline.return_value = ["", ""]
            with patch("salt.proxy.nxos.DEVICE_DETAILS", {}) as device_details:
                nxos_proxy._init_ssh(None)
                self.assertIn(nxos_proxy._worker_name(), device_details)
                self.assertTrue(device_details["initialized"])
                self.assertTrue(device_details["save_config"])
            with patch.dict(nxos_proxy.__opts__["proxy"], {"save_config": False}):
                with patch("salt.proxy.nxos.DEVICE_DETAILS", {}) as device_details:
                    nxos_proxy._init_ssh(None)
                    self.assertIn(nxos_proxy._worker_name(), device_details)
                    self.assertTrue(device_details["initialized"])
                    self.assertFalse(device_details["save_config"])
    def test__init_ssh_opts(self):
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {}):
            with patch("salt.proxy.nxos.SSHConnection", autospec=True) as SSHConnection:
                SSHConnection().sendline.return_value = ["", ""]
                nxos_proxy._init_ssh(None)
                self.assertEqual(
                    nxos_proxy.__opts__["proxy"]["host"],
                    SSHConnection.call_args[1]["host"],
                )
                opts = MagicMock()
                nxos_proxy._init_ssh(opts)
                self.assertEqual(
                    opts["proxy"]["host"], SSHConnection.call_args[1]["host"]
                )
    def test__init_ssh_prompt(self):
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {}):
            with patch("salt.proxy.nxos.SSHConnection", autospec=True) as SSHConnection:
                SSHConnection().sendline.return_value = ["", ""]
                with patch.dict(
                    nxos_proxy.__opts__["proxy"], {"prompt_regex": "n9k.*device"}
                ):
                    nxos_proxy._init_ssh(None)
                    self.assertEqual(
                        "n9k.*device", SSHConnection.call_args[1]["prompt"]
                    )
                with patch.dict(
                    nxos_proxy.__opts__["proxy"], {"prompt_name": "n9k-device"}
                ):
                    nxos_proxy._init_ssh(None)
                    self.assertEqual(
                        "n9k-device.*#", SSHConnection.call_args[1]["prompt"]
                    )
                nxos_proxy._init_ssh(None)
                self.assertEqual(".+#$", SSHConnection.call_args[1]["prompt"])
    def test__initialized_ssh(self):
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {"initialized": True}):
            result = nxos_proxy._initialized_ssh()
            self.assertTrue(result)
        with patch("salt.proxy.nxos.DEVICE_DETAILS", {}):
            result = nxos_proxy._initialized_ssh()
            self.assertFalse(result)
    def test__parse_output_for_errors(self):
        data = "% Incomplete command at '^' marker."
        command = "show"
        with self.assertRaises(CommandExecutionError):
            nxos_proxy._parse_output_for_errors(
                data, command, error_pattern="Incomplete"
            )
        data = "% Incomplete command at '^' marker."
        command = "show"
        with self.assertRaises(CommandExecutionError):
            nxos_proxy._parse_output_for_errors(
                data, command, error_pattern=["Incomplete", "marker"]
            )
        data = "% Invalid command at '^' marker."
        command = "show bep"
        with self.assertRaises(CommandExecutionError):
            nxos_proxy._parse_output_for_errors(data, command)
        data = "% Incomplete command at '^' marker."
        command = "show"
        nxos_proxy._parse_output_for_errors(data, command)
        data = "% Incomplete command at '^' marker."
        command = "show"
        nxos_proxy._parse_output_for_errors(data, command, error_pattern="foo")
    def test__init_ssh_raise_exception(self):
        class SSHException(Exception):
            pass
        with patch("salt.proxy.nxos.SSHConnection", autospec=True) as SSHConnection:
            with patch("salt.proxy.nxos.log", autospec=True) as log:
                with self.assertRaises(SSHException):
                    SSHConnection.side_effect = SSHException
                    nxos_proxy._init_ssh(None)
                log.error.assert_called()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>esxi_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import re
import sys
import salt.utils.files
from salt.config.schemas.esxi import DiskGroupsDiskScsiAddressSchema, HostCacheSchema
from salt.exceptions import (
    ArgumentValueError,
    CommandExecutionError,
    InvalidConfigError,
    VMwareApiError,
    VMwareObjectRetrievalError,
    VMwareSaltError,
)
from salt.utils.decorators import depends
try:
    import jsonschema
    HAS_JSONSCHEMA = True
except ImportError:
    HAS_JSONSCHEMA = False
log = logging.getLogger(__name__)
try:
    from pyVmomi import VmomiSupport
    if (
        "vim25/6.0" in VmomiSupport.versionMap
        and sys.version_info &gt; (2, 7)
        and sys.version_info &lt; (2, 7, 9)
    ):
        log.debug(
            "pyVmomi not loaded: Incompatible versions of Python. See Issue #29537."
        )
        raise ImportError()
    HAS_PYVMOMI = True
except ImportError:
    HAS_PYVMOMI = False
def __virtual__():
    if "esxi.cmd" in __salt__:
        return True
    return (False, "esxi module could not be loaded")
def coredump_configured(name, enabled, dump_ip, host_vnic="vmk0", dump_port=6500):
    ret = {"name": name, "result": False, "changes": {}, "comment": ""}
    esxi_cmd = "esxi.cmd"
    enabled_msg = (
        "ESXi requires that the core dump must be enabled "
        "before any other parameters may be set."
    )
    host = __pillar__["proxy"]["host"]
    current_config = __salt__[esxi_cmd]("get_coredump_network_config").get(host)
    error = current_config.get("Error")
    if error:
        ret["comment"] = "Error: {}".format(error)
        return ret
    current_config = current_config.get("Coredump Config")
    current_enabled = current_config.get("enabled")
    if current_enabled != enabled:
        enabled_changes = {"enabled": {"old": current_enabled, "new": enabled}}
        if not __opts__["test"]:
            response = __salt__[esxi_cmd](
                "coredump_network_enable", enabled=enabled
            ).get(host)
            error = response.get("Error")
            if error:
                ret["comment"] = "Error: {}".format(error)
                return ret
            if not enabled:
                ret["result"] = True
                ret["comment"] = enabled_msg
                ret["changes"].update(enabled_changes)
                return ret
        ret["changes"].update(enabled_changes)
    elif not enabled:
        ret["result"] = True
        ret["comment"] = enabled_msg
        return ret
    changes = False
    current_ip = current_config.get("ip")
    if current_ip != dump_ip:
        ret["changes"].update({"dump_ip": {"old": current_ip, "new": dump_ip}})
        changes = True
    current_vnic = current_config.get("host_vnic")
    if current_vnic != host_vnic:
        ret["changes"].update({"host_vnic": {"old": current_vnic, "new": host_vnic}})
        changes = True
    current_port = current_config.get("port")
    if current_port != str(dump_port):
        ret["changes"].update(
            {"dump_port": {"old": current_port, "new": str(dump_port)}}
        )
        changes = True
    if not __opts__["test"] and changes is True:
        response = __salt__[esxi_cmd](
            "set_coredump_network_config",
            dump_ip=dump_ip,
            host_vnic=host_vnic,
            dump_port=dump_port,
        ).get(host)
        if response.get("success") is False:
            msg = response.get("stderr")
            if not msg:
                msg = response.get("stdout")
            ret["comment"] = "Error: {}".format(msg)
            return ret
    ret["result"] = True
    if ret["changes"] == {}:
        ret["comment"] = "Core Dump configuration is already in the desired state."
        return ret
    if __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "Core dump configuration will change."
    return ret
def password_present(name, password):
    ret = {
        "name": name,
        "result": True,
        "changes": {"old": "unknown", "new": "********"},
        "comment": "Host password was updated.",
    }
    esxi_cmd = "esxi.cmd"
    if __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "Host password will change."
        return ret
    else:
        try:
            __salt__[esxi_cmd]("update_host_password", new_password=password)
        except CommandExecutionError as err:
            ret["result"] = False
            ret["comment"] = "Error: {}".format(err)
            return ret
    return ret
def ntp_configured(
    name,
    service_running,
    ntp_servers=None,
    service_policy=None,
    service_restart=False,
    update_datetime=False,
):
    ret = {"name": name, "result": False, "changes": {}, "comment": ""}
    esxi_cmd = "esxi.cmd"
    host = __pillar__["proxy"]["host"]
    ntpd = "ntpd"
    ntp_config = __salt__[esxi_cmd]("get_ntp_config").get(host)
    ntp_running = __salt__[esxi_cmd]("get_service_running", service_name=ntpd).get(host)
    error = ntp_running.get("Error")
    if error:
        ret["comment"] = "Error: {}".format(error)
        return ret
    ntp_running = ntp_running.get(ntpd)
    if ntp_servers and set(ntp_servers) != set(ntp_config):
        if not __opts__["test"]:
            response = __salt__[esxi_cmd](
                "set_ntp_config", ntp_servers=ntp_servers
            ).get(host)
            error = response.get("Error")
            if error:
                ret["comment"] = "Error: {}".format(error)
                return ret
        ret["changes"].update({"ntp_servers": {"old": ntp_config, "new": ntp_servers}})
    if service_running != ntp_running:
        if not __opts__["test"]:
            if ntp_running is True:
                response = __salt__[esxi_cmd]("service_start", service_name=ntpd).get(
                    host
                )
                error = response.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
            else:
                response = __salt__[esxi_cmd]("service_stop", service_name=ntpd).get(
                    host
                )
                error = response.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
        ret["changes"].update(
            {"service_running": {"old": ntp_running, "new": service_running}}
        )
    if service_policy:
        current_service_policy = __salt__[esxi_cmd](
            "get_service_policy", service_name=ntpd
        ).get(host)
        error = current_service_policy.get("Error")
        if error:
            ret["comment"] = "Error: {}".format(error)
            return ret
        current_service_policy = current_service_policy.get(ntpd)
        if service_policy != current_service_policy:
            if not __opts__["test"]:
                response = __salt__[esxi_cmd](
                    "set_service_policy",
                    service_name=ntpd,
                    service_policy=service_policy,
                ).get(host)
                error = response.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
            ret["changes"].update(
                {
                    "service_policy": {
                        "old": current_service_policy,
                        "new": service_policy,
                    }
                }
            )
    if update_datetime:
        if not __opts__["test"]:
            response = __salt__[esxi_cmd]("update_host_datetime").get(host)
            error = response.get("Error")
            if error:
                ret["comment"] = "Error: {}".format(error)
                return ret
        ret["changes"].update(
            {"update_datetime": {"old": "", "new": "Host datetime was updated."}}
        )
    if service_restart:
        if not __opts__["test"]:
            response = __salt__[esxi_cmd]("service_restart", service_name=ntpd).get(
                host
            )
            error = response.get("Error")
            if error:
                ret["comment"] = "Error: {}".format(error)
                return ret
        ret["changes"].update(
            {"service_restart": {"old": "", "new": "NTP Daemon Restarted."}}
        )
    ret["result"] = True
    if ret["changes"] == {}:
        ret["comment"] = "NTP is already in the desired state."
        return ret
    if __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "NTP state will change."
    return ret
def vmotion_configured(name, enabled, device="vmk0"):
    ret = {"name": name, "result": False, "changes": {}, "comment": ""}
    esxi_cmd = "esxi.cmd"
    host = __pillar__["proxy"]["host"]
    current_vmotion_enabled = __salt__[esxi_cmd]("get_vmotion_enabled").get(host)
    current_vmotion_enabled = current_vmotion_enabled.get("VMotion Enabled")
    if enabled != current_vmotion_enabled:
        if not __opts__["test"]:
            if enabled is True:
                response = __salt__[esxi_cmd]("vmotion_enable", device=device).get(host)
                error = response.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
            else:
                response = __salt__[esxi_cmd]("vmotion_disable").get(host)
                error = response.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
        ret["changes"].update(
            {"enabled": {"old": current_vmotion_enabled, "new": enabled}}
        )
    ret["result"] = True
    if ret["changes"] == {}:
        ret["comment"] = "VMotion configuration is already in the desired state."
        return ret
    if __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "VMotion configuration will change."
    return ret
def vsan_configured(name, enabled, add_disks_to_vsan=False):
    ret = {"name": name, "result": False, "changes": {}, "comment": ""}
    esxi_cmd = "esxi.cmd"
    host = __pillar__["proxy"]["host"]
    current_vsan_enabled = __salt__[esxi_cmd]("get_vsan_enabled").get(host)
    error = current_vsan_enabled.get("Error")
    if error:
        ret["comment"] = "Error: {}".format(error)
        return ret
    current_vsan_enabled = current_vsan_enabled.get("VSAN Enabled")
    if enabled != current_vsan_enabled:
        if not __opts__["test"]:
            if enabled is True:
                response = __salt__[esxi_cmd]("vsan_enable").get(host)
                error = response.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
            else:
                response = __salt__[esxi_cmd]("vsan_disable").get(host)
                error = response.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
        ret["changes"].update(
            {"enabled": {"old": current_vsan_enabled, "new": enabled}}
        )
    if add_disks_to_vsan:
        current_eligible_disks = __salt__[esxi_cmd]("get_vsan_eligible_disks").get(host)
        error = current_eligible_disks.get("Error")
        if error:
            ret["comment"] = "Error: {}".format(error)
            return ret
        disks = current_eligible_disks.get("Eligible")
        if disks and isinstance(disks, list):
            if not __opts__["test"]:
                response = __salt__[esxi_cmd]("vsan_add_disks").get(host)
                error = response.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
            ret["changes"].update({"add_disks_to_vsan": {"old": "", "new": disks}})
    ret["result"] = True
    if ret["changes"] == {}:
        ret["comment"] = "VSAN configuration is already in the desired state."
        return ret
    if __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "VSAN configuration will change."
    return ret
def ssh_configured(
    name,
    service_running,
    ssh_key=None,
    ssh_key_file=None,
    service_policy=None,
    service_restart=False,
    certificate_verify=None,
):
    if certificate_verify is None:
        certificate_verify = True
    ret = {"name": name, "result": False, "changes": {}, "comment": ""}
    esxi_cmd = "esxi.cmd"
    host = __pillar__["proxy"]["host"]
    ssh = "ssh"
    ssh_running = __salt__[esxi_cmd]("get_service_running", service_name=ssh).get(host)
    error = ssh_running.get("Error")
    if error:
        ret["comment"] = "Error: {}".format(error)
        return ret
    ssh_running = ssh_running.get(ssh)
    if service_running != ssh_running:
        if not __opts__["test"]:
            if service_running is True:
                enable = __salt__[esxi_cmd]("service_start", service_name=ssh).get(host)
                error = enable.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
            else:
                disable = __salt__[esxi_cmd]("service_stop", service_name=ssh).get(host)
                error = disable.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
        ret["changes"].update(
            {"service_running": {"old": ssh_running, "new": service_running}}
        )
    current_ssh_key, ssh_key_changed = None, False
    if ssh_key or ssh_key_file:
        current_ssh_key = __salt__[esxi_cmd](
            "get_ssh_key", certificate_verify=certificate_verify
        )
        error = current_ssh_key.get("Error")
        if error:
            ret["comment"] = "Error: {}".format(error)
            return ret
        current_ssh_key = current_ssh_key.get("key")
        if current_ssh_key:
            clean_current_key = _strip_key(current_ssh_key).split(" ")
            if not ssh_key:
                ssh_key = ""
                with salt.utils.files.fopen(ssh_key_file, "r") as key_file:
                    for line in key_file:
                        if line.startswith("#"):
                            continue
                        ssh_key = ssh_key + line
            clean_ssh_key = _strip_key(ssh_key).split(" ")
            if (
                clean_current_key[0] != clean_ssh_key[0]
                or clean_current_key[1] != clean_ssh_key[1]
            ):
                ssh_key_changed = True
        else:
            ssh_key_changed = True
    if ssh_key_changed:
        if not __opts__["test"]:
            response = __salt__[esxi_cmd](
                "upload_ssh_key",
                ssh_key=ssh_key,
                ssh_key_file=ssh_key_file,
                certificate_verify=certificate_verify,
            )
            error = response.get("Error")
            if error:
                ret["comment"] = "Error: {}".format(error)
                return ret
        ret["changes"].update(
            {
                "SSH Key": {
                    "old": current_ssh_key,
                    "new": ssh_key if ssh_key else ssh_key_file,
                }
            }
        )
    if service_policy:
        current_service_policy = __salt__[esxi_cmd](
            "get_service_policy", service_name=ssh
        ).get(host)
        error = current_service_policy.get("Error")
        if error:
            ret["comment"] = "Error: {}".format(error)
            return ret
        current_service_policy = current_service_policy.get(ssh)
        if service_policy != current_service_policy:
            if not __opts__["test"]:
                response = __salt__[esxi_cmd](
                    "set_service_policy",
                    service_name=ssh,
                    service_policy=service_policy,
                ).get(host)
                error = response.get("Error")
                if error:
                    ret["comment"] = "Error: {}".format(error)
                    return ret
            ret["changes"].update(
                {
                    "service_policy": {
                        "old": current_service_policy,
                        "new": service_policy,
                    }
                }
            )
    if service_restart:
        if not __opts__["test"]:
            response = __salt__[esxi_cmd]("service_restart", service_name=ssh).get(host)
            error = response.get("Error")
            if error:
                ret["comment"] = "Error: {}".format(error)
                return ret
        ret["changes"].update(
            {"service_restart": {"old": "", "new": "SSH service restarted."}}
        )
    ret["result"] = True
    if ret["changes"] == {}:
        ret["comment"] = "SSH service is already in the desired state."
        return ret
    if __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "SSH service state will change."
    return ret
def syslog_configured(
    name,
    syslog_configs,
    firewall=True,
    reset_service=True,
    reset_syslog_config=False,
    reset_configs=None,
):
    ret = {"name": name, "result": False, "changes": {}, "comment": ""}
    esxi_cmd = "esxi.cmd"
    host = __pillar__["proxy"]["host"]
    if reset_syslog_config:
        if not reset_configs:
            reset_configs = "all"
        if not __opts__["test"]:
            reset = __salt__[esxi_cmd](
                "reset_syslog_config", syslog_config=reset_configs
            ).get(host)
            for key, val in reset.items():
                if isinstance(val, bool):
                    continue
                if not val.get("success"):
                    msg = val.get("message")
                    if not msg:
                        msg = (
                            "There was an error resetting a syslog config '{}'."
                            "Please check debug logs.".format(val)
                        )
                    ret["comment"] = "Error: {}".format(msg)
                    return ret
        ret["changes"].update(
            {"reset_syslog_config": {"old": "", "new": reset_configs}}
        )
    current_firewall = __salt__[esxi_cmd]("get_firewall_status").get(host)
    error = current_firewall.get("Error")
    if error:
        ret["comment"] = "Error: {}".format(error)
        return ret
    current_firewall = current_firewall.get("rulesets").get("syslog")
    if current_firewall != firewall:
        if not __opts__["test"]:
            enabled = __salt__[esxi_cmd](
                "enable_firewall_ruleset",
                ruleset_enable=firewall,
                ruleset_name="syslog",
            ).get(host)
            if enabled.get("retcode") != 0:
                err = enabled.get("stderr")
                out = enabled.get("stdout")
                ret["comment"] = "Error: {}".format(err if err else out)
                return ret
        ret["changes"].update({"firewall": {"old": current_firewall, "new": firewall}})
    current_syslog_config = __salt__[esxi_cmd]("get_syslog_config").get(host)
    for key, val in syslog_configs.items():
        try:
            lookup_key = _lookup_syslog_config(key)
        except KeyError:
            ret["comment"] = "'{}' is not a valid config variable.".format(key)
            return ret
        current_val = current_syslog_config[lookup_key]
        if str(current_val) != str(val):
            if not __opts__["test"]:
                response = __salt__[esxi_cmd](
                    "set_syslog_config",
                    syslog_config=key,
                    config_value=val,
                    firewall=firewall,
                    reset_service=reset_service,
                ).get(host)
                success = response.get(key).get("success")
                if not success:
                    msg = response.get(key).get("message")
                    if not msg:
                        msg = (
                            "There was an error setting syslog config '{}'. "
                            "Please check debug logs.".format(key)
                        )
                    ret["comment"] = msg
                    return ret
            if not ret["changes"].get("syslog_config"):
                ret["changes"].update({"syslog_config": {}})
            ret["changes"]["syslog_config"].update(
                {key: {"old": current_val, "new": val}}
            )
    ret["result"] = True
    if ret["changes"] == {}:
        ret["comment"] = "Syslog is already in the desired state."
        return ret
    if __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "Syslog state will change."
    return ret
@depends(HAS_PYVMOMI)
@depends(HAS_JSONSCHEMA)
def diskgroups_configured(name, diskgroups, erase_disks=False):
    proxy_details = __salt__["esxi.get_details"]()
    hostname = (
        proxy_details["host"]
        if not proxy_details.get("vcenter")
        else proxy_details["esxi_host"]
    )
    log.info("Running state %s for host '%s'", name, hostname)
    ret = {"name": name, "result": None, "changes": {}, "comments": None}
    errors = False
    changes = False
    comments = []
    diskgroup_changes = {}
    si = None
    try:
        log.trace("Validating diskgroups_configured input")
        schema = DiskGroupsDiskScsiAddressSchema.serialize()
        try:
            jsonschema.validate(
                {"diskgroups": diskgroups, "erase_disks": erase_disks}, schema
            )
        except jsonschema.exceptions.ValidationError as exc:
            raise InvalidConfigError(exc)
        si = __salt__["vsphere.get_service_instance_via_proxy"]()
        host_disks = __salt__["vsphere.list_disks"](service_instance=si)
        if not host_disks:
            raise VMwareObjectRetrievalError(
                "No disks retrieved from host '{}'".format(hostname)
            )
        scsi_addr_to_disk_map = {d["scsi_address"]: d for d in host_disks}
        log.trace("scsi_addr_to_disk_map = %s", scsi_addr_to_disk_map)
        existing_diskgroups = __salt__["vsphere.list_diskgroups"](service_instance=si)
        cache_disk_to_existing_diskgroup_map = {
            dg["cache_disk"]: dg for dg in existing_diskgroups
        }
    except CommandExecutionError as err:
        log.error("Error: %s", err)
        if si:
            __salt__["vsphere.disconnect"](si)
        ret.update(
            {"result": False if not __opts__["test"] else None, "comment": str(err)}
        )
        return ret
    for idx, dg in enumerate(diskgroups):
        if not dg["cache_scsi_addr"] in scsi_addr_to_disk_map:
            comments.append(
                "No cache disk with scsi address '{}' was found.".format(
                    dg["cache_scsi_addr"]
                )
            )
            log.error(comments[-1])
            errors = True
            continue
        cache_disk_id = scsi_addr_to_disk_map[dg["cache_scsi_addr"]]["id"]
        cache_disk_display = "{} (id:{})".format(dg["cache_scsi_addr"], cache_disk_id)
        bad_scsi_addrs = []
        capacity_disk_ids = []
        capacity_disk_displays = []
        for scsi_addr in dg["capacity_scsi_addrs"]:
            if scsi_addr not in scsi_addr_to_disk_map:
                bad_scsi_addrs.append(scsi_addr)
                continue
            capacity_disk_ids.append(scsi_addr_to_disk_map[scsi_addr]["id"])
            capacity_disk_displays.append(
                "{} (id:{})".format(scsi_addr, capacity_disk_ids[-1])
            )
        if bad_scsi_addrs:
            comments.append(
                "Error in diskgroup #{}: capacity disks with scsi addresses {} "
                "were not found.".format(
                    idx, ", ".join(["'{}'".format(a) for a in bad_scsi_addrs])
                )
            )
            log.error(comments[-1])
            errors = True
            continue
        if not cache_disk_to_existing_diskgroup_map.get(cache_disk_id):
            log.trace("erase_disks = %s", erase_disks)
            if erase_disks:
                if __opts__["test"]:
                    comments.append(
                        "State {} will "
                        "erase all disks of disk group #{}; "
                        "cache disk: '{}', "
                        "capacity disk(s): {}."
                        "".format(
                            name,
                            idx,
                            cache_disk_display,
                            ", ".join(
                                ["'{}'".format(a) for a in capacity_disk_displays]
                            ),
                        )
                    )
                else:
                    for disk_id in [cache_disk_id] + capacity_disk_ids:
                        __salt__["vsphere.erase_disk_partitions"](
                            disk_id=disk_id, service_instance=si
                        )
                    comments.append(
                        "Erased disks of diskgroup #{}; "
                        "cache disk: '{}', capacity disk(s): "
                        "{}".format(
                            idx,
                            cache_disk_display,
                            ", ".join(
                                ["'{}'".format(a) for a in capacity_disk_displays]
                            ),
                        )
                    )
                    log.info(comments[-1])
            if __opts__["test"]:
                comments.append(
                    "State {} will create "
                    "the disk group #{}; cache disk: '{}', "
                    "capacity disk(s): {}.".format(
                        name,
                        idx,
                        cache_disk_display,
                        ", ".join(["'{}'".format(a) for a in capacity_disk_displays]),
                    )
                )
                log.info(comments[-1])
                changes = True
                continue
            try:
                __salt__["vsphere.create_diskgroup"](
                    cache_disk_id,
                    capacity_disk_ids,
                    safety_checks=False,
                    service_instance=si,
                )
            except VMwareSaltError as err:
                comments.append("Error creating disk group #{}: {}.".format(idx, err))
                log.error(comments[-1])
                errors = True
                continue
            comments.append("Created disk group #'{}'.".format(idx))
            log.info(comments[-1])
            diskgroup_changes[str(idx)] = {
                "new": {"cache": cache_disk_display, "capacity": capacity_disk_displays}
            }
            changes = True
            continue
        log.debug(
            "Disk group #%s exists. Checking capacity disks: %s.",
            idx,
            capacity_disk_displays,
        )
        existing_diskgroup = cache_disk_to_existing_diskgroup_map.get(cache_disk_id)
        existing_capacity_disk_displays = [
            "{} (id:{})".format(
                [d["scsi_address"] for d in host_disks if d["id"] == disk_id][0],
                disk_id,
            )
            for disk_id in existing_diskgroup["capacity_disks"]
        ]
        added_capacity_disk_ids = []
        added_capacity_disk_displays = []
        removed_capacity_disk_ids = []
        removed_capacity_disk_displays = []
        for disk_id in capacity_disk_ids:
            if disk_id not in existing_diskgroup["capacity_disks"]:
                disk_scsi_addr = [
                    d["scsi_address"] for d in host_disks if d["id"] == disk_id
                ][0]
                added_capacity_disk_ids.append(disk_id)
                added_capacity_disk_displays.append(
                    "{} (id:{})".format(disk_scsi_addr, disk_id)
                )
        for disk_id in existing_diskgroup["capacity_disks"]:
            if disk_id not in capacity_disk_ids:
                disk_scsi_addr = [
                    d["scsi_address"] for d in host_disks if d["id"] == disk_id
                ][0]
                removed_capacity_disk_ids.append(disk_id)
                removed_capacity_disk_displays.append(
                    "{} (id:{})".format(disk_scsi_addr, disk_id)
                )
        log.debug(
            "Disk group #%s: existing capacity disk ids: %s; added "
            "capacity disk ids: %s; removed capacity disk ids: %s",
            idx,
            existing_capacity_disk_displays,
            added_capacity_disk_displays,
            removed_capacity_disk_displays,
        )
        if removed_capacity_disk_ids:
            comments.append(
                "Error removing capacity disk(s) {} from disk group #{}; "
                "operation is not supported."
                "".format(
                    ", ".join(
                        ["'{}'".format(id) for id in removed_capacity_disk_displays]
                    ),
                    idx,
                )
            )
            log.error(comments[-1])
            errors = True
            continue
        if added_capacity_disk_ids:
            s = ", ".join(["'{}'".format(id) for id in added_capacity_disk_displays])
            if __opts__["test"]:
                comments.append(
                    "State {} will add capacity disk(s) {} to disk group #{}.".format(
                        name, s, idx
                    )
                )
                log.info(comments[-1])
                changes = True
                continue
            try:
                __salt__["vsphere.add_capacity_to_diskgroup"](
                    cache_disk_id,
                    added_capacity_disk_ids,
                    safety_checks=False,
                    service_instance=si,
                )
            except VMwareSaltError as err:
                comments.append(
                    "Error adding capacity disk(s) {} to disk group #{}: {}.".format(
                        s, idx, err
                    )
                )
                log.error(comments[-1])
                errors = True
                continue
            com = "Added capacity disk(s) {} to disk group #{}".format(s, idx)
            log.info(com)
            comments.append(com)
            diskgroup_changes[str(idx)] = {
                "new": {
                    "cache": cache_disk_display,
                    "capacity": capacity_disk_displays,
                },
                "old": {
                    "cache": cache_disk_display,
                    "capacity": existing_capacity_disk_displays,
                },
            }
            changes = True
            continue
        s = "Disk group #{} is correctly configured. Nothing to be done.".format(idx)
        log.info(s)
        comments.append(s)
    __salt__["vsphere.disconnect"](si)
    result = (
        True
        if not (changes or errors)
        else None  # no changes/errors
        if __opts__["test"]
        else False  # running in test mode
        if errors
        else True
    )  # found errors; defaults to True
    ret.update(
        {"result": result, "comment": "\n".join(comments), "changes": diskgroup_changes}
    )
    return ret
@depends(HAS_PYVMOMI)
@depends(HAS_JSONSCHEMA)
def host_cache_configured(
    name,
    enabled,
    datastore,
    swap_size="100%",
    dedicated_backing_disk=False,
    erase_backing_disk=False,
):
    log.trace("enabled = %s", enabled)
    log.trace("datastore = %s", datastore)
    log.trace("swap_size = %s", swap_size)
    log.trace("erase_backing_disk = %s", erase_backing_disk)
    proxy_details = __salt__["esxi.get_details"]()
    hostname = (
        proxy_details["host"]
        if not proxy_details.get("vcenter")
        else proxy_details["esxi_host"]
    )
    log.trace("hostname = %s", hostname)
    log.info("Running host_cache_swap_configured for host '%s'", hostname)
    ret = {
        "name": hostname,
        "comment": "Default comments",
        "result": None,
        "changes": {},
    }
    result = None if __opts__["test"] else True  # We assume success
    needs_setting = False
    comments = []
    changes = {}
    si = None
    try:
        log.debug("Validating host_cache_configured input")
        schema = HostCacheSchema.serialize()
        try:
            jsonschema.validate(
                {
                    "enabled": enabled,
                    "datastore": datastore,
                    "swap_size": swap_size,
                    "erase_backing_disk": erase_backing_disk,
                },
                schema,
            )
        except jsonschema.exceptions.ValidationError as exc:
            raise InvalidConfigError(exc)
        m = re.match(r"(\d+)(%|GiB)", swap_size)
        swap_size_value = int(m.group(1))
        swap_type = m.group(2)
        log.trace("swap_size_value = %s; swap_type = %s", swap_size_value, swap_type)
        si = __salt__["vsphere.get_service_instance_via_proxy"]()
        host_cache = __salt__["vsphere.get_host_cache"](service_instance=si)
        if host_cache["enabled"] != enabled:
            changes.update({"enabled": {"old": host_cache["enabled"], "new": enabled}})
            needs_setting = True
        existing_datastores = None
        if host_cache.get("datastore"):
            existing_datastores = __salt__["vsphere.list_datastores_via_proxy"](
                datastore_names=[datastore["name"]], service_instance=si
            )
        existing_disks = __salt__["vsphere.list_disks"](
            scsi_addresses=[datastore["backing_disk_scsi_addr"]], service_instance=si
        )
        if not existing_disks:
            raise VMwareObjectRetrievalError(
                "Disk with scsi address '{}' was not found in host '{}'".format(
                    datastore["backing_disk_scsi_addr"], hostname
                )
            )
        backing_disk = existing_disks[0]
        backing_disk_display = "{} (id:{})".format(
            backing_disk["scsi_address"], backing_disk["id"]
        )
        log.trace("backing_disk = %s", backing_disk_display)
        existing_datastore = None
        if not existing_datastores:
            if erase_backing_disk:
                if __opts__["test"]:
                    comments.append(
                        "State {} will erase the backing disk '{}' on host '{}'.".format(
                            name, backing_disk_display, hostname
                        )
                    )
                    log.info(comments[-1])
                else:
                    __salt__["vsphere.erase_disk_partitions"](
                        disk_id=backing_disk["id"], service_instance=si
                    )
                    comments.append(
                        "Erased backing disk '{}' on host '{}'.".format(
                            backing_disk_display, hostname
                        )
                    )
                    log.info(comments[-1])
            if __opts__["test"]:
                comments.append(
                    "State {} will create the datastore '{}', with backing disk "
                    "'{}', on host '{}'.".format(
                        name, datastore["name"], backing_disk_display, hostname
                    )
                )
                log.info(comments[-1])
            else:
                if dedicated_backing_disk:
                    partitions = __salt__["vsphere.list_disk_partitions"](
                        disk_id=backing_disk["id"], service_instance=si
                    )
                    log.trace("partitions = %s", partitions)
                    non_mbr_partitions = [p for p in partitions if p["format"] != "mbr"]
                    if len(non_mbr_partitions) &gt; 0:
                        raise VMwareApiError(
                            "Backing disk '{}' has unexpected partitions".format(
                                backing_disk_display
                            )
                        )
<a name="0"></a>                __salt__["vsphere.create_vmfs_datastore"](
                    datastore["name"],
                    existing_disks[0]["id"],
                    datastore<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vmfs_version"],
                    service_instance=si,
                )
                comments.append(
                    "Created vmfs datastore '{}', backed by "
                    "disk '{}', on host '{}'.".format(
                        datastore["name"], backing_disk_display, hostname
                    )
                )
                log.info(comments[-1])
                changes.update(
                    {
                        "datastore": {
                            "new"</b></font>: {
                                "name": datastore["name"],
                                "backing_disk": backing_disk_display,
                            }
                        }
                    }
                )
                existing_datastore = __salt__["vsphere.list_datastores_via_proxy"](
                    datastore_names=[datastore["name"]], service_instance=si
                )[0]
            needs_setting = True
        else:
            if not existing_datastores[0].get("backing_disk_ids"):
                raise VMwareSaltError(
                    "Datastore '{}' doesn't have a backing disk".format(
                        datastore["name"]
                    )
                )
            if backing_disk["id"] not in existing_datastores[0]["backing_disk_ids"]:
                raise VMwareSaltError(
                    "Datastore '{}' is not backed by the correct disk: "
                    "expected '{}'; got {}".format(
                        datastore["name"],
                        backing_disk["id"],
                        ", ".join(
                            [
                                "'{}'".format(disk)
                                for disk in existing_datastores[0]["backing_disk_ids"]
                            ]
                        ),
                    )
                )
            comments.append(
                "Datastore '{}' already exists on host '{}' "
                "and is backed by disk '{}'. Nothing to be "
                "done.".format(datastore["name"], hostname, backing_disk_display)
            )
            existing_datastore = existing_datastores[0]
            log.trace("existing_datastore = %s", existing_datastore)
            log.info(comments[-1])
        if existing_datastore:
            if swap_type == "%":
                raw_size_MiB = (swap_size_value / 100.0) * (
                    existing_datastore["capacity"] / 1024 / 1024
                )
            else:
                raw_size_MiB = swap_size_value * 1024
            log.trace("raw_size = %sMiB", raw_size_MiB)
            swap_size_MiB = int(raw_size_MiB / 1024) * 1024
            log.trace("adjusted swap_size = %sMiB", swap_size_MiB)
            existing_swap_size_MiB = 0
            m = (
                re.match(r"(\d+)MiB", host_cache.get("swap_size"))
                if host_cache.get("swap_size")
                else None
            )
            if m:
                existing_swap_size_MiB = int(m.group(1))
            if not existing_swap_size_MiB == swap_size_MiB:
                needs_setting = True
                changes.update(
                    {
                        "swap_size": {
                            "old": "{}GiB".format(existing_swap_size_MiB / 1024),
                            "new": "{}GiB".format(swap_size_MiB / 1024),
                        }
                    }
                )
        if needs_setting:
            if __opts__["test"]:
                comments.append(
                    "State {} will configure the host cache on host '{}' to: {}.".format(
                        name,
                        hostname,
                        {
                            "enabled": enabled,
                            "datastore_name": datastore["name"],
                            "swap_size": swap_size,
                        },
                    )
                )
            else:
                if (existing_datastore["capacity"] / 1024.0 ** 2) &lt; swap_size_MiB:
                    raise ArgumentValueError(
                        "Capacity of host cache datastore '{}' ({} MiB) is "
                        "smaller than the required swap size ({} MiB)".format(
                            existing_datastore["name"],
                            existing_datastore["capacity"] / 1024.0 ** 2,
                            swap_size_MiB,
                        )
                    )
                __salt__["vsphere.configure_host_cache"](
                    enabled,
                    datastore["name"],
                    swap_size_MiB=swap_size_MiB,
                    service_instance=si,
                )
                comments.append("Host cache configured on host '{}'.".format(hostname))
        else:
            comments.append(
                "Host cache on host '{}' is already correctly "
                "configured. Nothing to be done.".format(hostname)
            )
            result = True
        __salt__["vsphere.disconnect"](si)
        log.info(comments[-1])
        ret.update(
            {"comment": "\n".join(comments), "result": result, "changes": changes}
        )
        return ret
    except CommandExecutionError as err:
        log.error("Error: %s.", err)
        if si:
            __salt__["vsphere.disconnect"](si)
        ret.update(
            {
                "result": False if not __opts__["test"] else None,
                "comment": "{}.".format(err),
            }
        )
        return ret
def _lookup_syslog_config(config):
    lookup = {
        "default-timeout": "Default Network Retry Timeout",
        "logdir": "Local Log Output",
        "default-size": "Local Logging Default Rotation Size",
        "logdir-unique": "Log To Unique Subdirectory",
        "default-rotate": "Local Logging Default Rotations",
        "loghost": "Remote Host",
    }
    return lookup.get(config)
def _strip_key(key_string):
    key_string.strip()
    key_string.replace("\n", "")
    key_string.replace("\r\n", "")
    return key_string
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
