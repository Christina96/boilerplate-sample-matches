<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_app.py & salt_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_app.py & salt_1.py
      </h3>
      <h1 align="center">
        3.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_app.py (5.263158%)<TH>salt_1.py (3.128621%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match84663-0.html#0',2,'match84663-1.html#0',3)" NAME="0">(312-313)<TD><A HREF="javascript:ZweiFrames('match84663-0.html#0',2,'match84663-1.html#0',3)" NAME="0">(306-309)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match84663-0.html#1',2,'match84663-1.html#1',3)" NAME="1">(372-373)<TD><A HREF="javascript:ZweiFrames('match84663-0.html#1',2,'match84663-1.html#1',3)" NAME="1">(340-342)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_app.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import os
import urllib.parse

import pytest
import salt.utils.json
import salt.utils.stringutils
import tests.support.cherrypy_testclasses as cptc


class TestAuth(cptc.BaseRestCherryPyTest):
    def test_get_root_noauth(self):
        &quot;&quot;&quot;
        GET requests to the root URL should not require auth
        &quot;&quot;&quot;
        request, response = self.request(&quot;/&quot;)
        self.assertEqual(response.status, &quot;200 OK&quot;)

    def test_post_root_auth(self):
        &quot;&quot;&quot;
        POST requests to the root URL redirect to login
        &quot;&quot;&quot;
        request, response = self.request(&quot;/&quot;, method=&quot;POST&quot;, data={})
        self.assertEqual(response.status, &quot;401 Unauthorized&quot;)

    def test_login_noauth(self):
        &quot;&quot;&quot;
        GET requests to the login URL should not require auth
        &quot;&quot;&quot;
        request, response = self.request(&quot;/login&quot;)
        self.assertEqual(response.status, &quot;200 OK&quot;)

    def test_webhook_auth(self):
        &quot;&quot;&quot;
        Requests to the webhook URL require auth by default
        &quot;&quot;&quot;
        request, response = self.request(&quot;/hook&quot;, method=&quot;POST&quot;, data={})
        self.assertEqual(response.status, &quot;401 Unauthorized&quot;)


class TestLogin(cptc.BaseRestCherryPyTest):
    auth_creds = ((&quot;username&quot;, &quot;saltdev&quot;), (&quot;password&quot;, &quot;saltdev&quot;), (&quot;eauth&quot;, &quot;auto&quot;))

    def test_good_login(self):
        &quot;&quot;&quot;
        Test logging in
        &quot;&quot;&quot;
        body = urllib.parse.urlencode(self.auth_creds)
        request, response = self.request(
            &quot;/login&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        self.assertEqual(response.status, &quot;200 OK&quot;)
        return response

    def test_leak(self):
        &quot;&quot;&quot;
        Test perms leak array is becoming bigger and bigger after each call
        &quot;&quot;&quot;
        lengthOfPerms = []
        run_tests = 2

        for x in range(0, run_tests):
            body = urllib.parse.urlencode(self.auth_creds)
            request, response = self.request(
                &quot;/login&quot;,
                method=&quot;POST&quot;,
                body=body,
                headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
            )

            response = salt.utils.json.loads(response.body[0])
            lengthOfPerms.append(len(response[&quot;return&quot;][0][&quot;perms&quot;]))
        self.assertEqual(lengthOfPerms[0], lengthOfPerms[run_tests - 1])
        return response

    def test_bad_login(self):
        &quot;&quot;&quot;
        Test logging in
        &quot;&quot;&quot;
        body = urllib.parse.urlencode({&quot;totally&quot;: &quot;invalid_creds&quot;})
        request, response = self.request(
            &quot;/login&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        self.assertEqual(response.status, &quot;401 Unauthorized&quot;)

    def test_logout(self):
        ret = self.test_good_login()
        token = ret.headers[&quot;X-Auth-Token&quot;]

        body = urllib.parse.urlencode({})
        request, response = self.request(
            &quot;/logout&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={
                &quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;,
                &quot;X-Auth-Token&quot;: token,
            },
        )
        self.assertEqual(response.status, &quot;200 OK&quot;)


class TestRun(cptc.BaseRestCherryPyTest):
    auth_creds = (
        (&quot;username&quot;, &quot;saltdev_auto&quot;),
        (&quot;password&quot;, &quot;saltdev&quot;),
        (&quot;eauth&quot;, &quot;auto&quot;),
    )

    low = (
        (&quot;client&quot;, &quot;local&quot;),
        (&quot;tgt&quot;, &quot;*&quot;),
        (&quot;fun&quot;, &quot;test.ping&quot;),
    )

    @pytest.mark.slow_test
    def test_run_good_login(self):
        &quot;&quot;&quot;
        Test the run URL with good auth credentials
        &quot;&quot;&quot;
        cmd = dict(self.low, **dict(self.auth_creds))
        body = urllib.parse.urlencode(cmd)

        request, response = self.request(
            &quot;/run&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        self.assertEqual(response.status, &quot;200 OK&quot;)

    def test_run_bad_login(self):
        &quot;&quot;&quot;
        Test the run URL with bad auth credentials
        &quot;&quot;&quot;
        cmd = dict(self.low, **{&quot;totally&quot;: &quot;invalid_creds&quot;})
        body = urllib.parse.urlencode(cmd)

        request, response = self.request(
            &quot;/run&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        self.assertEqual(response.status, &quot;401 Unauthorized&quot;)

    def test_run_empty_token(self):
        &quot;&quot;&quot;
        Test the run URL with empty token
        &quot;&quot;&quot;
        cmd = dict(self.low, **{&quot;token&quot;: &quot;&quot;})
        body = urllib.parse.urlencode(cmd)

        request, response = self.request(
            &quot;/run&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        assert response.status == &quot;401 Unauthorized&quot;

    def test_run_empty_token_upercase(self):
        &quot;&quot;&quot;
        Test the run URL with empty token with upercase characters
        &quot;&quot;&quot;
        cmd = dict(self.low, **{&quot;ToKen&quot;: &quot;&quot;})
        body = urllib.parse.urlencode(cmd)

        request, response = self.request(
            &quot;/run&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        assert response.status == &quot;401 Unauthorized&quot;

    def test_run_wrong_token(self):
        &quot;&quot;&quot;
        Test the run URL with incorrect token
        &quot;&quot;&quot;
        cmd = dict(self.low, **{&quot;token&quot;: &quot;bad&quot;})
        body = urllib.parse.urlencode(cmd)

        request, response = self.request(
            &quot;/run&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        assert response.status == &quot;401 Unauthorized&quot;

    def test_run_pathname_token(self):
        &quot;&quot;&quot;
        Test the run URL with path that exists in token
        &quot;&quot;&quot;
        cmd = dict(self.low, **{&quot;token&quot;: os.path.join(&quot;etc&quot;, &quot;passwd&quot;)})
        body = urllib.parse.urlencode(cmd)

        request, response = self.request(
            &quot;/run&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        assert response.status == &quot;401 Unauthorized&quot;

    def test_run_pathname_not_exists_token(self):
        &quot;&quot;&quot;
        Test the run URL with path that does not exist in token
        &quot;&quot;&quot;
        cmd = dict(self.low, **{&quot;token&quot;: os.path.join(&quot;tmp&quot;, &quot;doesnotexist&quot;)})
        body = urllib.parse.urlencode(cmd)

        request, response = self.request(
            &quot;/run&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        assert response.status == &quot;401 Unauthorized&quot;

    @pytest.mark.slow_test
    def test_run_extra_parameters(self):
        &quot;&quot;&quot;
        Test the run URL with good auth credentials
        &quot;&quot;&quot;
        cmd = dict(self.low, **dict(self.auth_creds))
        cmd[&quot;id_&quot;] = &quot;someminionname&quot;
        body = urllib.parse.urlencode(cmd)

        request, response = self.request(
            &quot;/run&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        self.assertEqual(response.status, &quot;200 OK&quot;)


class TestWebhookDisableAuth(cptc.BaseRestCherryPyTest):
    def __get_opts__(self):
        return {
            &quot;rest_cherrypy&quot;: {
                &quot;port&quot;: 8000,
                &quot;debug&quot;: True,
                &quot;webhook_disable_auth&quot;: True,
            },
        }

    def test_webhook_noauth(self):
        &quot;&quot;&quot;
        Auth can be disabled for requests to the webhook URL
        &quot;&quot;&quot;
        body = urllib.parse.urlencode({&quot;foo&quot;: &quot;Foo!&quot;})
        request, response = self.request(
            &quot;/hook&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        self.assertEqual(response.status, &quot;200 OK&quot;)


class TestArgKwarg(cptc.BaseRestCherryPyTest):
    auth_creds = ((&quot;username&quot;, &quot;saltdev&quot;), (&quot;password&quot;, &quot;saltdev&quot;), (&quot;eauth&quot;, &quot;auto&quot;))

    low = (
        (&quot;client&quot;, &quot;runner&quot;),
        (&quot;fun&quot;, &quot;test.arg&quot;),
        # use singular form for arg and kwarg
        (&quot;arg&quot;, [1234]),
        (&quot;kwarg&quot;, {&quot;ext_source&quot;: &quot;redis&quot;}),
    )

    def _token(self):
        &quot;&quot;&quot;
        Return the token
        &quot;&quot;&quot;
        body = urllib.parse.urlencode(self.auth_creds)
        request, response = self.request(
            &quot;/login&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        return response.headers[&quot;X-Auth-Token&quot;]

    @pytest.mark.slow_test
    def test_accepts_arg_kwarg_keys(self):
        &quot;&quot;&quot;
        Ensure that (singular) arg and kwarg keys (for passing parameters)
        are supported by runners.
        &quot;&quot;&quot;
        cmd = dict(self.low)
        body = salt.utils.json.dumps(cmd)

        request, response = self.request(
            &quot;/&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={
                &quot;content-type&quot;: &quot;application/json&quot;,
                &quot;X-Auth-Token&quot;: self._token(),
<A NAME="0"></A>                &quot;Accept&quot;: &quot;application/json&quot;,
            },
        )
        resp = salt<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match84663-1.html#0',3,'match84663-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.utils.json.loads(salt.utils.stringutils.to_str(response.body[0]))
        self.assertEqual(resp[&quot;return&quot;][0][</B></FONT>&quot;args&quot;], [1234])
        self.assertEqual(resp[&quot;return&quot;][0][&quot;kwargs&quot;], {&quot;ext_source&quot;: &quot;redis&quot;})


class TestJobs(cptc.BaseRestCherryPyTest):
    auth_creds = (
        (&quot;username&quot;, &quot;saltdev_auto&quot;),
        (&quot;password&quot;, &quot;saltdev&quot;),
        (&quot;eauth&quot;, &quot;auto&quot;),
    )

    low = (
        (&quot;client&quot;, &quot;local&quot;),
        (&quot;tgt&quot;, &quot;*&quot;),
        (&quot;fun&quot;, &quot;test.ping&quot;),
    )

    def _token(self):
        &quot;&quot;&quot;
        Return the token
        &quot;&quot;&quot;
        body = urllib.parse.urlencode(self.auth_creds)
        request, response = self.request(
            &quot;/login&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        return response.headers[&quot;X-Auth-Token&quot;]

    def _add_job(self):
        &quot;&quot;&quot;
        Helper function to add a job to the job cache
        &quot;&quot;&quot;
        cmd = dict(self.low, **dict(self.auth_creds))
        body = urllib.parse.urlencode(cmd)

        request, response = self.request(
            &quot;/run&quot;,
            method=&quot;POST&quot;,
            body=body,
            headers={&quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;},
        )
        self.assertEqual(response.status, &quot;200 OK&quot;)

    @pytest.mark.flaky(max_runs=4)
    @pytest.mark.slow_test
    def test_all_jobs(self):
        &quot;&quot;&quot;
        test query to /jobs returns job data
        &quot;&quot;&quot;
        self._add_job()

        request, response = self.request(
            &quot;/jobs&quot;,
            method=&quot;GET&quot;,
<A NAME="1"></A>            headers={&quot;Accept&quot;: &quot;application/json&quot;, &quot;X-Auth-Token&quot;: self._token()},
        )

        resp = salt<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match84663-1.html#1',3,'match84663-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.utils.json.loads(salt.utils.stringutils.to_str(response.body[0]))
        self.assertIn(</B></FONT>&quot;test.ping&quot;, str(resp[&quot;return&quot;]))
        self.assertEqual(response.status, &quot;200 OK&quot;)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>salt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import os
import sys

import salt.defaults.exitcodes
import salt.log
import salt.utils.parsers
import salt.utils.stringutils
from salt.exceptions import (
    AuthenticationError,
    AuthorizationError,
    EauthAuthenticationError,
    LoaderError,
    SaltClientError,
    SaltInvocationError,
    SaltSystemExit,
)
from salt.utils.args import yamlify_arg
from salt.utils.verify import verify_log

sys.modules[&quot;pkg_resources&quot;] = None


class SaltCMD(salt.utils.parsers.SaltCMDOptionParser):
    &quot;&quot;&quot;
    The execution of a salt command happens here
    &quot;&quot;&quot;

    def run(self):
        &quot;&quot;&quot;
        Execute the salt command line
        &quot;&quot;&quot;
        import salt.client

        self.parse_args()

        if self.config[&quot;log_level&quot;] not in (&quot;quiet&quot;,):
            # Setup file logging!
            self.setup_logfile_logger()
            verify_log(self.config)

        try:
            # We don't need to bail on config file permission errors
            # if the CLI process is run with the -a flag
            skip_perm_errors = self.options.eauth != &quot;&quot;

            self.local_client = salt.client.get_local_client(
                self.get_config_file_path(),
                skip_perm_errors=skip_perm_errors,
                auto_reconnect=True,
            )
        except SaltClientError as exc:
            self.exit(2, &quot;{}\n&quot;.format(exc))
            return

        if self.options.batch or self.options.static:
            # _run_batch() will handle all output and
            # exit with the appropriate error condition
            # Execution will not continue past this point
            # in batch mode.
            self._run_batch()
            return

        if self.options.preview_target:
            minion_list = self._preview_target()
            self._output_ret(minion_list, self.config.get(&quot;output&quot;, &quot;nested&quot;))
            return

        if self.options.timeout &lt;= 0:
            self.options.timeout = self.local_client.opts[&quot;timeout&quot;]

        kwargs = {
            &quot;tgt&quot;: self.config[&quot;tgt&quot;],
            &quot;fun&quot;: self.config[&quot;fun&quot;],
            &quot;arg&quot;: self.config[&quot;arg&quot;],
            &quot;timeout&quot;: self.options.timeout,
            &quot;show_timeout&quot;: self.options.show_timeout,
            &quot;show_jid&quot;: self.options.show_jid,
        }

        if &quot;token&quot; in self.config:
            import salt.utils.files

            try:
                with salt.utils.files.fopen(
                    os.path.join(self.config[&quot;cachedir&quot;], &quot;.root_key&quot;), &quot;r&quot;
                ) as fp_:
                    kwargs[&quot;key&quot;] = fp_.readline()
            except OSError:
                kwargs[&quot;token&quot;] = self.config[&quot;token&quot;]

        kwargs[&quot;delimiter&quot;] = self.options.delimiter

        if self.selected_target_option:
            kwargs[&quot;tgt_type&quot;] = self.selected_target_option
        else:
            kwargs[&quot;tgt_type&quot;] = &quot;glob&quot;

        # If batch_safe_limit is set, check minions matching target and
        # potentially switch to batch execution
        if self.options.batch_safe_limit &gt; 1:
            if len(self._preview_target()) &gt;= self.options.batch_safe_limit:
                salt.utils.stringutils.print_cli(
                    &quot;\nNOTICE: Too many minions targeted, switching to batch execution.&quot;
                )
                self.options.batch = self.options.batch_safe_size
                try:
                    self._run_batch()
                finally:
                    self.local_client.destroy()
                return

        if getattr(self.options, &quot;return&quot;):
            kwargs[&quot;ret&quot;] = getattr(self.options, &quot;return&quot;)

        if getattr(self.options, &quot;return_config&quot;):
            kwargs[&quot;ret_config&quot;] = getattr(self.options, &quot;return_config&quot;)

        if getattr(self.options, &quot;return_kwargs&quot;):
            kwargs[&quot;ret_kwargs&quot;] = yamlify_arg(getattr(self.options, &quot;return_kwargs&quot;))

        if getattr(self.options, &quot;module_executors&quot;):
            kwargs[&quot;module_executors&quot;] = yamlify_arg(
                getattr(self.options, &quot;module_executors&quot;)
            )

        if getattr(self.options, &quot;executor_opts&quot;):
            kwargs[&quot;executor_opts&quot;] = yamlify_arg(
                getattr(self.options, &quot;executor_opts&quot;)
            )

        if getattr(self.options, &quot;metadata&quot;):
            kwargs[&quot;metadata&quot;] = yamlify_arg(getattr(self.options, &quot;metadata&quot;))

        # If using eauth and a token hasn't already been loaded into
        # kwargs, prompt the user to enter auth credentials
        if &quot;token&quot; not in kwargs and &quot;key&quot; not in kwargs and self.options.eauth:
            # This is expensive. Don't do it unless we need to.
            import salt.auth

            resolver = salt.auth.Resolver(self.config)
            res = resolver.cli(self.options.eauth)
            if self.options.mktoken and res:
                tok = resolver.token_cli(self.options.eauth, res)
                if tok:
                    kwargs[&quot;token&quot;] = tok.get(&quot;token&quot;, &quot;&quot;)
            if not res:
                sys.stderr.write(&quot;ERROR: Authentication failed\n&quot;)
                sys.exit(2)
            kwargs.update(res)
            kwargs[&quot;eauth&quot;] = self.options.eauth

        if self.config[&quot;async&quot;]:
            jid = self.local_client.cmd_async(**kwargs)
            salt.utils.stringutils.print_cli(
                &quot;Executed command with job ID: {}&quot;.format(jid)
            )
            return

        # local will be None when there was an error
        if not self.local_client:
            return

        retcodes = []
        errors = []

        try:
            if self.options.subset:
                cmd_func = self.local_client.cmd_subset
                kwargs[&quot;subset&quot;] = self.options.subset
                kwargs[&quot;cli&quot;] = True
            else:
                cmd_func = self.local_client.cmd_cli

            if self.options.progress:
                kwargs[&quot;progress&quot;] = True
                self.config[&quot;progress&quot;] = True
                ret = {}
                for progress in cmd_func(**kwargs):
                    out = &quot;progress&quot;
                    try:
                        self._progress_ret(progress, out)
                    except LoaderError as exc:
                        raise SaltSystemExit(exc)
                    if &quot;return_count&quot; not in progress:
                        ret.update(progress)
                self._progress_end(out)
                self._print_returns_summary(ret)
            elif self.config[&quot;fun&quot;] == &quot;sys.doc&quot;:
                ret = {}
                out = &quot;&quot;
                for full_ret in self.local_client.cmd_cli(**kwargs):
                    ret_, out, retcode = self._format_ret(full_ret)
                    ret.update(ret_)
                self._output_ret(ret, out, retcode=retcode)
            else:
                if self.options.verbose:
                    kwargs[&quot;verbose&quot;] = True
                ret = {}
                for full_ret in cmd_func(**kwargs):
                    try:
                        ret_, out, retcode = self._format_ret(full_ret)
                        retcodes.append(retcode)
                        self._output_ret(ret_, out, retcode=retcode)
                        ret.update(full_ret)
                    except KeyError:
                        errors.append(full_ret)

            # Returns summary
            if self.config[&quot;cli_summary&quot;] is True:
                if self.config[&quot;fun&quot;] != &quot;sys.doc&quot;:
                    if self.options.output is None:
                        self._print_returns_summary(ret)
                        self._print_errors_summary(errors)

            # NOTE: Return code is set here based on if all minions
            # returned 'ok' with a retcode of 0.
            # This is the final point before the 'salt' cmd returns,
            # which is why we set the retcode here.
            if not all(
                exit_code == salt.defaults.exitcodes.EX_OK for exit_code in retcodes
            ):
                sys.stderr.write(&quot;ERROR: Minions returned with non-zero exit code\n&quot;)
                sys.exit(salt.defaults.exitcodes.EX_GENERIC)

        except (
            AuthenticationError,
            AuthorizationError,
            SaltInvocationError,
            EauthAuthenticationError,
            SaltClientError,
        ) as exc:
            ret = str(exc)
            self._output_ret(ret, &quot;&quot;, retcode=1)
        finally:
            self.local_client.destroy()

    def _preview_target(self):
        &quot;&quot;&quot;
        Return a list of minions from a given target
        &quot;&quot;&quot;
        return self.local_client.gather_minions(
            self.config[&quot;tgt&quot;], self.selected_target_option or &quot;glob&quot;
        )

    def _run_batch(self):
        import salt.cli.batch

        eauth = {}
        if &quot;token&quot; in self.config:
            eauth[&quot;token&quot;] = self.config[&quot;token&quot;]

        # If using eauth and a token hasn't already been loaded into
        # kwargs, prompt the user to enter auth credentials
        if &quot;token&quot; not in eauth and self.options.eauth:
            # This is expensive. Don't do it unless we need to.
            import salt.auth

            resolver = salt.auth.Resolver(self.config)
            res = resolver.cli(self.options.eauth)
            if self.options.mktoken and res:
                tok = resolver.token_cli(self.options.eauth, res)
                if tok:
                    eauth[&quot;token&quot;] = tok.get(&quot;token&quot;, &quot;&quot;)
            if not res:
                sys.stderr.write(&quot;ERROR: Authentication failed\n&quot;)
                sys.exit(2)
            eauth.update(res)
            eauth[&quot;eauth&quot;] = self.options.eauth

        if self.options.static:

            if not self.options.batch:
                self.config[&quot;batch&quot;] = &quot;100%&quot;

            try:
                batch = salt.cli.batch.Batch(self.config, eauth=eauth, quiet=True)
            except SaltClientError:
                sys.exit(2)

            ret = {}

            for res, _ in batch.run():
                ret.update(res)

            self._output_ret(ret, &quot;&quot;)

        else:
            try:
                self.config[&quot;batch&quot;] = self.options.batch
                batch = salt.cli.batch.Batch(
                    self.config, eauth=eauth, _parser=self.options
                )
            except SaltClientError:
                # We will print errors to the console further down the stack
                sys.exit(1)
            # Printing the output is already taken care of in run() itself
            retcode = 0
            for res, job_retcode in batch.run():
                if job_retcode &gt; retcode:
                    # Exit with the highest retcode we find
                    retcode = job_retcode
            sys.exit(retcode)
<A NAME="0"></A>
    def _print_errors_summary(self, errors):
        if errors:
            salt<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match84663-0.html#0',2,'match84663-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.utils.stringutils.print_cli(&quot;\n&quot;)
            salt.utils.stringutils.print_cli(&quot;---------------------------&quot;)
            salt.utils.stringutils.print_cli(&quot;Errors&quot;)
            salt.utils.stringutils.</B></FONT>print_cli(&quot;---------------------------&quot;)
            for error in errors:
                salt.utils.stringutils.print_cli(self._format_error(error))

    def _print_returns_summary(self, ret):
        &quot;&quot;&quot;
        Display returns summary
        &quot;&quot;&quot;
        return_counter = 0
        not_return_counter = 0
        not_return_minions = []
        not_response_minions = []
        not_connected_minions = []
        failed_minions = []
        for each_minion in ret:
            minion_ret = ret[each_minion]
            if isinstance(minion_ret, dict) and &quot;ret&quot; in minion_ret:
                minion_ret = ret[each_minion].get(&quot;ret&quot;)
            if isinstance(minion_ret, str) and minion_ret.startswith(
                &quot;Minion did not return&quot;
            ):
                if &quot;Not connected&quot; in minion_ret:
                    not_connected_minions.append(each_minion)
                elif &quot;No response&quot; in minion_ret:
                    not_response_minions.append(each_minion)
                not_return_counter += 1
                not_return_minions.append(each_minion)
            else:
<A NAME="1"></A>                return_counter += 1
                if self._get_retcode(ret[each_minion]):
                    failed_minions.append(each_minion)
        salt<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match84663-0.html#1',2,'match84663-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.utils.stringutils.print_cli(&quot;\n&quot;)
        salt.utils.stringutils.print_cli(&quot;-------------------------------------------&quot;)
        salt.utils.stringutils.print_cli(</B></FONT>&quot;Summary&quot;)
        salt.utils.stringutils.print_cli(&quot;-------------------------------------------&quot;)
        salt.utils.stringutils.print_cli(
            &quot;# of minions targeted: {}&quot;.format(return_counter + not_return_counter)
        )
        salt.utils.stringutils.print_cli(
            &quot;# of minions returned: {}&quot;.format(return_counter)
        )
        salt.utils.stringutils.print_cli(
            &quot;# of minions that did not return: {}&quot;.format(not_return_counter)
        )
        salt.utils.stringutils.print_cli(
            &quot;# of minions with errors: {}&quot;.format(len(failed_minions))
        )
        if self.options.verbose:
            if not_connected_minions:
                salt.utils.stringutils.print_cli(
                    &quot;Minions not connected: {}&quot;.format(&quot; &quot;.join(not_connected_minions))
                )
            if not_response_minions:
                salt.utils.stringutils.print_cli(
                    &quot;Minions not responding: {}&quot;.format(&quot; &quot;.join(not_response_minions))
                )
            if failed_minions:
                salt.utils.stringutils.print_cli(
                    &quot;Minions with failures: {}&quot;.format(&quot; &quot;.join(failed_minions))
                )
        salt.utils.stringutils.print_cli(&quot;-------------------------------------------&quot;)

    def _progress_end(self, out):
        import salt.output

        salt.output.progress_end(self.progress_bar)

    def _progress_ret(self, progress, out):
        &quot;&quot;&quot;
        Print progress events
        &quot;&quot;&quot;
        import salt.output

        # Get the progress bar
        if not hasattr(self, &quot;progress_bar&quot;):
            try:
                self.progress_bar = salt.output.get_progress(self.config, out, progress)
            except Exception:  # pylint: disable=broad-except
                raise LoaderError(
                    &quot;\nWARNING: Install the `progressbar` python package. &quot;
                    &quot;Requested job was still run but output cannot be displayed.\n&quot;
                )
        salt.output.update_progress(self.config, progress, self.progress_bar, out)

    def _output_ret(self, ret, out, retcode=0):
        &quot;&quot;&quot;
        Print the output from a single return to the terminal
        &quot;&quot;&quot;
        import salt.output

        # Handle special case commands
        if self.config[&quot;fun&quot;] == &quot;sys.doc&quot; and not isinstance(ret, Exception):
            self._print_docs(ret)
        else:
            # Determine the proper output method and run it
            salt.output.display_output(ret, out=out, opts=self.config, _retcode=retcode)
        if not ret:
            sys.stderr.write(&quot;ERROR: No return received\n&quot;)
            sys.exit(2)

    def _format_ret(self, full_ret):
        &quot;&quot;&quot;
        Take the full return data and format it to simple output
        &quot;&quot;&quot;
        ret = {}
        out = &quot;&quot;
        retcode = 0
        for key, data in full_ret.items():
            ret[key] = data[&quot;ret&quot;]
            if &quot;out&quot; in data:
                out = data[&quot;out&quot;]
            ret_retcode = self._get_retcode(data)
            if ret_retcode &gt; retcode:
                retcode = ret_retcode
        return ret, out, retcode

    def _get_retcode(self, ret):
        &quot;&quot;&quot;
        Determine a retcode for a given return
        &quot;&quot;&quot;
        retcode = 0
        # if there is a dict with retcode, use that
        if isinstance(ret, dict) and ret.get(&quot;retcode&quot;, 0) != 0:
            if isinstance(ret.get(&quot;retcode&quot;, 0), dict):
                return max(ret.get(&quot;retcode&quot;, {0: 0}).values())
            return ret[&quot;retcode&quot;]
        # if its a boolean, False means 1
        elif isinstance(ret, bool) and not ret:
            return 1
        return retcode

    def _format_error(self, minion_error):
        for minion, error_doc in minion_error.items():
            error = &quot;Minion [{}] encountered exception '{}'&quot;.format(
                minion, error_doc[&quot;message&quot;]
            )
        return error

    def _print_docs(self, ret):
        &quot;&quot;&quot;
        Print out the docstrings for all of the functions on the minions
        &quot;&quot;&quot;
        import salt.output

        docs = {}
        if not ret:
            self.exit(2, &quot;No minions found to gather docs from\n&quot;)
        if isinstance(ret, str):
            self.exit(2, &quot;{}\n&quot;.format(ret))
        for host in ret:
            if isinstance(ret[host], str) and (
                ret[host].startswith(&quot;Minion did not return&quot;)
                or ret[host] == &quot;VALUE_TRIMMED&quot;
            ):
                continue
            for fun in ret[host]:
                if fun not in docs and ret[host][fun]:
                    docs[fun] = ret[host][fun]
        if self.options.output:
            for fun in sorted(docs):
                salt.output.display_output({fun: docs[fun]}, &quot;nested&quot;, self.config)
        else:
            for fun in sorted(docs):
                salt.utils.stringutils.print_cli(&quot;{}:&quot;.format(fun))
                salt.utils.stringutils.print_cli(docs[fun])
                salt.utils.stringutils.print_cli(&quot;&quot;)
</PRE>
</div>
  </div>
</body>
</html>
