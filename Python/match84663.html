<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_app.py &amp; salt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_app.py &amp; salt_1.py
      </h3>
<h1 align="center">
        3.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_app.py (5.263158%)<th>salt_1.py (3.128621%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(312-313)<td><a href="#" name="0">(306-309)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(372-373)<td><a href="#" name="1">(340-342)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_app.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import urllib.parse
3 import pytest
4 import salt.utils.json
5 import salt.utils.stringutils
6 import tests.support.cherrypy_testclasses as cptc
7 class TestAuth(cptc.BaseRestCherryPyTest):
8     def test_get_root_noauth(self):
9         request, response = self.request("/")
10         self.assertEqual(response.status, "200 OK")
11     def test_post_root_auth(self):
12         request, response = self.request("/", method="POST", data={})
13         self.assertEqual(response.status, "401 Unauthorized")
14     def test_login_noauth(self):
15         request, response = self.request("/login")
16         self.assertEqual(response.status, "200 OK")
17     def test_webhook_auth(self):
18         request, response = self.request("/hook", method="POST", data={})
19         self.assertEqual(response.status, "401 Unauthorized")
20 class TestLogin(cptc.BaseRestCherryPyTest):
21     auth_creds = (("username", "saltdev"), ("password", "saltdev"), ("eauth", "auto"))
22     def test_good_login(self):
23         body = urllib.parse.urlencode(self.auth_creds)
24         request, response = self.request(
25             "/login",
26             method="POST",
27             body=body,
28             headers={"content-type": "application/x-www-form-urlencoded"},
29         )
30         self.assertEqual(response.status, "200 OK")
31         return response
32     def test_leak(self):
33         lengthOfPerms = []
34         run_tests = 2
35         for x in range(0, run_tests):
36             body = urllib.parse.urlencode(self.auth_creds)
37             request, response = self.request(
38                 "/login",
39                 method="POST",
40                 body=body,
41                 headers={"content-type": "application/x-www-form-urlencoded"},
42             )
43             response = salt.utils.json.loads(response.body[0])
44             lengthOfPerms.append(len(response["return"][0]["perms"]))
45         self.assertEqual(lengthOfPerms[0], lengthOfPerms[run_tests - 1])
46         return response
47     def test_bad_login(self):
48         body = urllib.parse.urlencode({"totally": "invalid_creds"})
49         request, response = self.request(
50             "/login",
51             method="POST",
52             body=body,
53             headers={"content-type": "application/x-www-form-urlencoded"},
54         )
55         self.assertEqual(response.status, "401 Unauthorized")
56     def test_logout(self):
57         ret = self.test_good_login()
58         token = ret.headers["X-Auth-Token"]
59         body = urllib.parse.urlencode({})
60         request, response = self.request(
61             "/logout",
62             method="POST",
63             body=body,
64             headers={
65                 "content-type": "application/x-www-form-urlencoded",
66                 "X-Auth-Token": token,
67             },
68         )
69         self.assertEqual(response.status, "200 OK")
70 class TestRun(cptc.BaseRestCherryPyTest):
71     auth_creds = (
72         ("username", "saltdev_auto"),
73         ("password", "saltdev"),
74         ("eauth", "auto"),
75     )
76     low = (
77         ("client", "local"),
78         ("tgt", "*"),
79         ("fun", "test.ping"),
80     )
81     @pytest.mark.slow_test
82     def test_run_good_login(self):
83         cmd = dict(self.low, **dict(self.auth_creds))
84         body = urllib.parse.urlencode(cmd)
85         request, response = self.request(
86             "/run",
87             method="POST",
88             body=body,
89             headers={"content-type": "application/x-www-form-urlencoded"},
90         )
91         self.assertEqual(response.status, "200 OK")
92     def test_run_bad_login(self):
93         cmd = dict(self.low, **{"totally": "invalid_creds"})
94         body = urllib.parse.urlencode(cmd)
95         request, response = self.request(
96             "/run",
97             method="POST",
98             body=body,
99             headers={"content-type": "application/x-www-form-urlencoded"},
100         )
101         self.assertEqual(response.status, "401 Unauthorized")
102     def test_run_empty_token(self):
103         cmd = dict(self.low, **{"token": ""})
104         body = urllib.parse.urlencode(cmd)
105         request, response = self.request(
106             "/run",
107             method="POST",
108             body=body,
109             headers={"content-type": "application/x-www-form-urlencoded"},
110         )
111         assert response.status == "401 Unauthorized"
112     def test_run_empty_token_upercase(self):
113         cmd = dict(self.low, **{"ToKen": ""})
114         body = urllib.parse.urlencode(cmd)
115         request, response = self.request(
116             "/run",
117             method="POST",
118             body=body,
119             headers={"content-type": "application/x-www-form-urlencoded"},
120         )
121         assert response.status == "401 Unauthorized"
122     def test_run_wrong_token(self):
123         cmd = dict(self.low, **{"token": "bad"})
124         body = urllib.parse.urlencode(cmd)
125         request, response = self.request(
126             "/run",
127             method="POST",
128             body=body,
129             headers={"content-type": "application/x-www-form-urlencoded"},
130         )
131         assert response.status == "401 Unauthorized"
132     def test_run_pathname_token(self):
133         cmd = dict(self.low, **{"token": os.path.join("etc", "passwd")})
134         body = urllib.parse.urlencode(cmd)
135         request, response = self.request(
136             "/run",
137             method="POST",
138             body=body,
139             headers={"content-type": "application/x-www-form-urlencoded"},
140         )
141         assert response.status == "401 Unauthorized"
142     def test_run_pathname_not_exists_token(self):
143         cmd = dict(self.low, **{"token": os.path.join("tmp", "doesnotexist")})
144         body = urllib.parse.urlencode(cmd)
145         request, response = self.request(
146             "/run",
147             method="POST",
148             body=body,
149             headers={"content-type": "application/x-www-form-urlencoded"},
150         )
151         assert response.status == "401 Unauthorized"
152     @pytest.mark.slow_test
153     def test_run_extra_parameters(self):
154         cmd = dict(self.low, **dict(self.auth_creds))
155         cmd["id_"] = "someminionname"
156         body = urllib.parse.urlencode(cmd)
157         request, response = self.request(
158             "/run",
159             method="POST",
160             body=body,
161             headers={"content-type": "application/x-www-form-urlencoded"},
162         )
163         self.assertEqual(response.status, "200 OK")
164 class TestWebhookDisableAuth(cptc.BaseRestCherryPyTest):
165     def __get_opts__(self):
166         return {
167             "rest_cherrypy": {
168                 "port": 8000,
169                 "debug": True,
170                 "webhook_disable_auth": True,
171             },
172         }
173     def test_webhook_noauth(self):
174         body = urllib.parse.urlencode({"foo": "Foo!"})
175         request, response = self.request(
176             "/hook",
177             method="POST",
178             body=body,
179             headers={"content-type": "application/x-www-form-urlencoded"},
180         )
181         self.assertEqual(response.status, "200 OK")
182 class TestArgKwarg(cptc.BaseRestCherryPyTest):
183     auth_creds = (("username", "saltdev"), ("password", "saltdev"), ("eauth", "auto"))
184     low = (
185         ("client", "runner"),
186         ("fun", "test.arg"),
187         ("arg", [1234]),
188         ("kwarg", {"ext_source": "redis"}),
189     )
190     def _token(self):
191         body = urllib.parse.urlencode(self.auth_creds)
192         request, response = self.request(
193             "/login",
194             method="POST",
195             body=body,
196             headers={"content-type": "application/x-www-form-urlencoded"},
197         )
198         return response.headers["X-Auth-Token"]
199     @pytest.mark.slow_test
200     def test_accepts_arg_kwarg_keys(self):
201         cmd = dict(self.low)
202         body = salt.utils.json.dumps(cmd)
203         request, response = self.request(
204             "/",
205             method="POST",
206             body=body,
207             headers={
208                 "content-type": "application/json",
209                 "X-Auth-Token": self._token(),
210             },
211         )
212         resp = salt<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.json.loads(salt.utils.stringutils.to_str(response.body[0]))
213         self.assertEqual(resp["return"][0][</b></font>"args"], [1234])
214         self.assertEqual(resp["return"][0]["kwargs"], {"ext_source": "redis"})
215 class TestJobs(cptc.BaseRestCherryPyTest):
216     auth_creds = (
217         ("username", "saltdev_auto"),
218         ("password", "saltdev"),
219         ("eauth", "auto"),
220     )
221     low = (
222         ("client", "local"),
223         ("tgt", "*"),
224         ("fun", "test.ping"),
225     )
226     def _token(self):
227         body = urllib.parse.urlencode(self.auth_creds)
228         request, response = self.request(
229             "/login",
230             method="POST",
231             body=body,
232             headers={"content-type": "application/x-www-form-urlencoded"},
233         )
234         return response.headers["X-Auth-Token"]
235     def _add_job(self):
236         cmd = dict(self.low, **dict(self.auth_creds))
237         body = urllib.parse.urlencode(cmd)
238         request, response = self.request(
239             "/run",
240             method="POST",
241             body=body,
242             headers={"content-type": "application/x-www-form-urlencoded"},
243         )
244         self.assertEqual(response.status, "200 OK")
245     @pytest.mark.flaky(max_runs=4)
246     @pytest.mark.slow_test
247     def test_all_jobs(self):
248         self._add_job()
249         request, response = self.request(
250             "/jobs",
251             method="GET",
252         )
253         resp = salt<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.json.loads(salt.utils.stringutils.to_str(response.body[0]))
254         self.assertIn(</b></font>"test.ping", str(resp["return"]))
255         self.assertEqual(response.status, "200 OK")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>salt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import sys
3 import salt.defaults.exitcodes
4 import salt.log
5 import salt.utils.parsers
6 import salt.utils.stringutils
7 from salt.exceptions import (
8     AuthenticationError,
9     AuthorizationError,
10     EauthAuthenticationError,
11     LoaderError,
12     SaltClientError,
13     SaltInvocationError,
14     SaltSystemExit,
15 )
16 from salt.utils.args import yamlify_arg
17 from salt.utils.verify import verify_log
18 sys.modules["pkg_resources"] = None
19 class SaltCMD(salt.utils.parsers.SaltCMDOptionParser):
20     def run(self):
21         import salt.client
22         self.parse_args()
23         if self.config["log_level"] not in ("quiet",):
24             self.setup_logfile_logger()
25             verify_log(self.config)
26         try:
27             skip_perm_errors = self.options.eauth != ""
28             self.local_client = salt.client.get_local_client(
29                 self.get_config_file_path(),
30                 skip_perm_errors=skip_perm_errors,
31                 auto_reconnect=True,
32             )
33         except SaltClientError as exc:
34             self.exit(2, "{}\n".format(exc))
35             return
36         if self.options.batch or self.options.static:
37             self._run_batch()
38             return
39         if self.options.preview_target:
40             minion_list = self._preview_target()
41             self._output_ret(minion_list, self.config.get("output", "nested"))
42             return
43         if self.options.timeout &lt;= 0:
44             self.options.timeout = self.local_client.opts["timeout"]
45         kwargs = {
46             "tgt": self.config["tgt"],
47             "fun": self.config["fun"],
48             "arg": self.config["arg"],
49             "timeout": self.options.timeout,
50             "show_timeout": self.options.show_timeout,
51             "show_jid": self.options.show_jid,
52         }
53         if "token" in self.config:
54             import salt.utils.files
55             try:
56                 with salt.utils.files.fopen(
57                     os.path.join(self.config["cachedir"], ".root_key"), "r"
58                 ) as fp_:
59                     kwargs["key"] = fp_.readline()
60             except OSError:
61                 kwargs["token"] = self.config["token"]
62         kwargs["delimiter"] = self.options.delimiter
63         if self.selected_target_option:
64             kwargs["tgt_type"] = self.selected_target_option
65         else:
66             kwargs["tgt_type"] = "glob"
67         if self.options.batch_safe_limit &gt; 1:
68             if len(self._preview_target()) &gt;= self.options.batch_safe_limit:
69                 salt.utils.stringutils.print_cli(
70                     "\nNOTICE: Too many minions targeted, switching to batch execution."
71                 )
72                 self.options.batch = self.options.batch_safe_size
73                 try:
74                     self._run_batch()
75                 finally:
76                     self.local_client.destroy()
77                 return
78         if getattr(self.options, "return"):
79             kwargs["ret"] = getattr(self.options, "return")
80         if getattr(self.options, "return_config"):
81             kwargs["ret_config"] = getattr(self.options, "return_config")
82         if getattr(self.options, "return_kwargs"):
83             kwargs["ret_kwargs"] = yamlify_arg(getattr(self.options, "return_kwargs"))
84         if getattr(self.options, "module_executors"):
85             kwargs["module_executors"] = yamlify_arg(
86                 getattr(self.options, "module_executors")
87             )
88         if getattr(self.options, "executor_opts"):
89             kwargs["executor_opts"] = yamlify_arg(
90                 getattr(self.options, "executor_opts")
91             )
92         if getattr(self.options, "metadata"):
93             kwargs["metadata"] = yamlify_arg(getattr(self.options, "metadata"))
94         if "token" not in kwargs and "key" not in kwargs and self.options.eauth:
95             import salt.auth
96             resolver = salt.auth.Resolver(self.config)
97             res = resolver.cli(self.options.eauth)
98             if self.options.mktoken and res:
99                 tok = resolver.token_cli(self.options.eauth, res)
100                 if tok:
101                     kwargs["token"] = tok.get("token", "")
102             if not res:
103                 sys.stderr.write("ERROR: Authentication failed\n")
104                 sys.exit(2)
105             kwargs.update(res)
106             kwargs["eauth"] = self.options.eauth
107         if self.config["async"]:
108             jid = self.local_client.cmd_async(**kwargs)
109             salt.utils.stringutils.print_cli(
110                 "Executed command with job ID: {}".format(jid)
111             )
112             return
113         if not self.local_client:
114             return
115         retcodes = []
116         errors = []
117         try:
118             if self.options.subset:
119                 cmd_func = self.local_client.cmd_subset
120                 kwargs["subset"] = self.options.subset
121                 kwargs["cli"] = True
122             else:
123                 cmd_func = self.local_client.cmd_cli
124             if self.options.progress:
125                 kwargs["progress"] = True
126                 self.config["progress"] = True
127                 ret = {}
128                 for progress in cmd_func(**kwargs):
129                     out = "progress"
130                     try:
131                         self._progress_ret(progress, out)
132                     except LoaderError as exc:
133                         raise SaltSystemExit(exc)
134                     if "return_count" not in progress:
135                         ret.update(progress)
136                 self._progress_end(out)
137                 self._print_returns_summary(ret)
138             elif self.config["fun"] == "sys.doc":
139                 ret = {}
140                 out = ""
141                 for full_ret in self.local_client.cmd_cli(**kwargs):
142                     ret_, out, retcode = self._format_ret(full_ret)
143                     ret.update(ret_)
144                 self._output_ret(ret, out, retcode=retcode)
145             else:
146                 if self.options.verbose:
147                     kwargs["verbose"] = True
148                 ret = {}
149                 for full_ret in cmd_func(**kwargs):
150                     try:
151                         ret_, out, retcode = self._format_ret(full_ret)
152                         retcodes.append(retcode)
153                         self._output_ret(ret_, out, retcode=retcode)
154                         ret.update(full_ret)
155                     except KeyError:
156                         errors.append(full_ret)
157             if self.config["cli_summary"] is True:
158                 if self.config["fun"] != "sys.doc":
159                     if self.options.output is None:
160                         self._print_returns_summary(ret)
161                         self._print_errors_summary(errors)
162             if not all(
163                 exit_code == salt.defaults.exitcodes.EX_OK for exit_code in retcodes
164             ):
165                 sys.stderr.write("ERROR: Minions returned with non-zero exit code\n")
166                 sys.exit(salt.defaults.exitcodes.EX_GENERIC)
167         except (
168             AuthenticationError,
169             AuthorizationError,
170             SaltInvocationError,
171             EauthAuthenticationError,
172             SaltClientError,
173         ) as exc:
174             ret = str(exc)
175             self._output_ret(ret, "", retcode=1)
176         finally:
177             self.local_client.destroy()
178     def _preview_target(self):
179         return self.local_client.gather_minions(
180             self.config["tgt"], self.selected_target_option or "glob"
181         )
182     def _run_batch(self):
183         import salt.cli.batch
184         eauth = {}
185         if "token" in self.config:
186             eauth["token"] = self.config["token"]
187         if "token" not in eauth and self.options.eauth:
188             import salt.auth
189             resolver = salt.auth.Resolver(self.config)
190             res = resolver.cli(self.options.eauth)
191             if self.options.mktoken and res:
192                 tok = resolver.token_cli(self.options.eauth, res)
193                 if tok:
194                     eauth["token"] = tok.get("token", "")
195             if not res:
196                 sys.stderr.write("ERROR: Authentication failed\n")
197                 sys.exit(2)
198             eauth.update(res)
199             eauth["eauth"] = self.options.eauth
200         if self.options.static:
201             if not self.options.batch:
202                 self.config["batch"] = "100%"
203             try:
204                 batch = salt.cli.batch.Batch(self.config, eauth=eauth, quiet=True)
205             except SaltClientError:
206                 sys.exit(2)
207             ret = {}
208             for res, _ in batch.run():
209                 ret.update(res)
210             self._output_ret(ret, "")
211         else:
212             try:
213                 self.config["batch"] = self.options.batch
214                 batch = salt.cli.batch.Batch(
215                     self.config, eauth=eauth, _parser=self.options
216                 )
217             except SaltClientError:
218                 sys.exit(1)
219             retcode = 0
220             for res, job_retcode in batch.run():
221                 if job_retcode &gt; retcode:
222                     retcode = job_retcode
223             sys.exit(retcode)
224     def _print_errors_summary(self, errors):
225         if errors:
226             salt<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.stringutils.print_cli("\n")
227             salt.utils.stringutils.print_cli("---------------------------")
228             salt.utils.stringutils.print_cli("Errors")
229             salt.utils.stringutils.</b></font>print_cli("---------------------------")
230             for error in errors:
231                 salt.utils.stringutils.print_cli(self._format_error(error))
232     def _print_returns_summary(self, ret):
233         return_counter = 0
234         not_return_counter = 0
235         not_return_minions = []
236         not_response_minions = []
237         not_connected_minions = []
238         failed_minions = []
239         for each_minion in ret:
240             minion_ret = ret[each_minion]
241             if isinstance(minion_ret, dict) and "ret" in minion_ret:
242                 minion_ret = ret[each_minion].get("ret")
243             if isinstance(minion_ret, str) and minion_ret.startswith(
244                 "Minion did not return"
245             ):
246                 if "Not connected" in minion_ret:
247                     not_connected_minions.append(each_minion)
248                 elif "No response" in minion_ret:
249                     not_response_minions.append(each_minion)
250                 not_return_counter += 1
251                 not_return_minions.append(each_minion)
252             else:
253                 if self._get_retcode(ret[each_minion]):
254                     failed_minions.append(each_minion)
255         salt<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.stringutils.print_cli("\n")
256         salt.utils.stringutils.print_cli("-------------------------------------------")
257         salt.utils.stringutils.print_cli(</b></font>"Summary")
258         salt.utils.stringutils.print_cli("-------------------------------------------")
259         salt.utils.stringutils.print_cli(
260             "# of minions targeted: {}".format(return_counter + not_return_counter)
261         )
262         salt.utils.stringutils.print_cli(
263             "# of minions returned: {}".format(return_counter)
264         )
265         salt.utils.stringutils.print_cli(
266             "# of minions that did not return: {}".format(not_return_counter)
267         )
268         salt.utils.stringutils.print_cli(
269             "# of minions with errors: {}".format(len(failed_minions))
270         )
271         if self.options.verbose:
272             if not_connected_minions:
273                 salt.utils.stringutils.print_cli(
274                     "Minions not connected: {}".format(" ".join(not_connected_minions))
275                 )
276             if not_response_minions:
277                 salt.utils.stringutils.print_cli(
278                     "Minions not responding: {}".format(" ".join(not_response_minions))
279                 )
280             if failed_minions:
281                 salt.utils.stringutils.print_cli(
282                     "Minions with failures: {}".format(" ".join(failed_minions))
283                 )
284         salt.utils.stringutils.print_cli("-------------------------------------------")
285     def _progress_end(self, out):
286         import salt.output
287         salt.output.progress_end(self.progress_bar)
288     def _progress_ret(self, progress, out):
289         import salt.output
290         if not hasattr(self, "progress_bar"):
291             try:
292                 self.progress_bar = salt.output.get_progress(self.config, out, progress)
293             except Exception:  # pylint: disable=broad-except
294                 raise LoaderError(
295                     "\nWARNING: Install the `progressbar` python package. "
296                     "Requested job was still run but output cannot be displayed.\n"
297                 )
298         salt.output.update_progress(self.config, progress, self.progress_bar, out)
299     def _output_ret(self, ret, out, retcode=0):
300         import salt.output
301         if self.config["fun"] == "sys.doc" and not isinstance(ret, Exception):
302             self._print_docs(ret)
303         else:
304             salt.output.display_output(ret, out=out, opts=self.config, _retcode=retcode)
305         if not ret:
306             sys.stderr.write("ERROR: No return received\n")
307             sys.exit(2)
308     def _format_ret(self, full_ret):
309         ret = {}
310         out = ""
311         retcode = 0
312         for key, data in full_ret.items():
313             ret[key] = data["ret"]
314             if "out" in data:
315                 out = data["out"]
316             ret_retcode = self._get_retcode(data)
317             if ret_retcode &gt; retcode:
318                 retcode = ret_retcode
319         return ret, out, retcode
320     def _get_retcode(self, ret):
321         retcode = 0
322         if isinstance(ret, dict) and ret.get("retcode", 0) != 0:
323             if isinstance(ret.get("retcode", 0), dict):
324                 return max(ret.get("retcode", {0: 0}).values())
325             return ret["retcode"]
326         elif isinstance(ret, bool) and not ret:
327             return 1
328         return retcode
329     def _format_error(self, minion_error):
330         for minion, error_doc in minion_error.items():
331             error = "Minion [{}] encountered exception '{}'".format(
332                 minion, error_doc["message"]
333             )
334         return error
335     def _print_docs(self, ret):
336         import salt.output
337         docs = {}
338         if not ret:
339             self.exit(2, "No minions found to gather docs from\n")
340         if isinstance(ret, str):
341             self.exit(2, "{}\n".format(ret))
342         for host in ret:
343             if isinstance(ret[host], str) and (
344                 ret[host].startswith("Minion did not return")
345                 or ret[host] == "VALUE_TRIMMED"
346             ):
347                 continue
348             for fun in ret[host]:
349                 if fun not in docs and ret[host][fun]:
350                     docs[fun] = ret[host][fun]
351         if self.options.output:
352             for fun in sorted(docs):
353                 salt.output.display_output({fun: docs[fun]}, "nested", self.config)
354         else:
355             for fun in sorted(docs):
356                 salt.utils.stringutils.print_cli("{}:".format(fun))
357                 salt.utils.stringutils.print_cli(docs[fun])
358                 salt.utils.stringutils.print_cli("")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
