<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_node_link.py &amp; test_weighted.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_node_link.py &amp; test_weighted.py
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_node_link.py (14.4%)<th>test_weighted.py (2.0316026%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-67)<td><a href="#" name="0">(909-915)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(35-40)<td><a href="#" name="1">(314-320)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(11-17)<td><a href="#" name="2">(524-530)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_node_link.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import json
2 import pytest
3 import networkx as nx
4 from networkx.readwrite.json_graph import node_link_data, node_link_graph
5 class TestNodeLink:
6         G = nx.path_graph(4)
7         H = node_link_graph(node_link_data(G))
8         assert nx.is_isomorphic(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>G, H)
9     def test_graph_attributes(self):
10         G = nx.path_graph(4)
11         G.add_node(1, color="red")
12         G.add_edge(1, 2, width=7)
13         G.</b></font>graph[1] = "one"
14         G.graph["foo"] = "bar"
15         H = node_link_graph(node_link_data(G))
16         assert H.graph["foo"] == "bar"
17         assert H.nodes[1]["color"] == "red"
18         assert H[1][2]["width"] == 7
19         d = json.dumps(node_link_data(G))
20         H = node_link_graph(json.loads(d))
21         assert H.graph["foo"] == "bar"
22         assert H.graph["1"] == "one"
23         assert H.nodes[1]["color"] == "red"
24         assert H[1][2]["width"] == 7
25         G = nx.DiGraph()
26         H = node_link_graph(node_link_data(G))
27         assert H.is_directed(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>)
28     def test_multigraph(self):
29         G = nx.MultiGraph()
30         G.add_edge(1, 2, key="first")
31         G.add_edge(1, 2, key="second", color=</b></font>"blue")
32         H = node_link_graph(node_link_data(G))
33         nx.is_isomorphic(G, H)
34         assert H[1][2]["second"]["color"] == "blue"
35     def test_graph_with_tuple_nodes(self):
36         G = nx.Graph()
37         G.add_edge((0, 0), (1, 0), color=[255, 255, 0])
38         d = node_link_data(G)
39         dumped_d = json.dumps(d)
40         dd = json.loads(dumped_d)
41         H = node_link_graph(dd)
42         assert H.nodes[(0, 0)] == G.nodes[(0, 0)]
43         assert H[(0, 0)][(1, 0)]["color"] == [255, 255, 0]
44     def test_unicode_keys(self):
45         q = "qualité"
46         G = nx.Graph()
47         G.add_node(1, **{q: q})
48         s = node_link_data(G)
49         data = json.loads(output)
50         H = node_link_graph(data)
51         assert H<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.nodes[1][q] == q
52     def test_exception(self):
53         with pytest.raises(nx.NetworkXError):
54             G = nx.MultiDiGraph(</b></font>)
55             attrs = dict(name="node", source="node", target="node", key="node")
56             node_link_data(G, attrs)
57     def test_string_ids(self):
58         q = "qualité"
59         G = nx.DiGraph()
60         G.add_node("A")
61         G.add_node(q)
62         G.add_edge("A", q)
63         data = node_link_data(G)
64         assert data["links"][0]["source"] == "A"
65         assert data["links"][0]["target"] == q
66         H = node_link_graph(data)
67         assert nx.is_isomorphic(G, H)
68     def test_custom_attrs(self):
69         G = nx.path_graph(4)
70         G.add_node(1, color="red")
71         G.add_edge(1, 2, width=7)
72         G.graph[1] = "one"
73         G.graph["foo"] = "bar"
74         attrs = dict(
75             source="c_source",
76             target="c_target",
77             name="c_id",
78             key="c_key",
79             link="c_links",
80         )
81         H = node_link_graph(
82             node_link_data(G, attrs=attrs), multigraph=False, attrs=attrs
83         )
84         assert nx.is_isomorphic(G, H)
85         assert H.graph["foo"] == "bar"
86         assert H.nodes[1]["color"] == "red"
87         assert H[1][2]["width"] == 7
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_weighted.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import networkx as nx
3 from networkx.utils import pairwise
4 def validate_path(G, s, t, soln_len, path, weight="weight"):
5     assert path[0] == s
6     assert path[-1] == t
7     if callable(weight):
8         weight_f = weight
9     else:
10         if G.is_multigraph():
11             def weight_f(u, v, d):
12                 return min(e.get(weight, 1) for e in d.values())
13         else:
14             def weight_f(u, v, d):
15                 return d.get(weight, 1)
16     computed = sum(weight_f(u, v, G[u][v]) for u, v in pairwise(path))
17     assert soln_len == computed
18 def validate_length_path(G, s, t, soln_len, length, path, weight="weight"):
19     assert soln_len == length
20     validate_path(G, s, t, length, path, weight=weight)
21 class WeightedTestBase:
22     def setup(self):
23         cnlti = nx.convert_node_labels_to_integers
24         self.grid = cnlti(nx.grid_2d_graph(4, 4), first_label=1, ordering="sorted")
25         self.cycle = nx.cycle_graph(7)
26         self.directed_cycle = nx.cycle_graph(7, create_using=nx.DiGraph())
27         self.XG = nx.DiGraph()
28         self.XG.add_weighted_edges_from(
29             [
30                 ("s", "u", 10),
31                 ("s", "x", 5),
32                 ("u", "v", 1),
33                 ("u", "x", 2),
34                 ("v", "y", 1),
35                 ("x", "u", 3),
36                 ("x", "v", 5),
37                 ("x", "y", 2),
38                 ("y", "s", 7),
39                 ("y", "v", 6),
40             ]
41         )
42         self.MXG = nx.MultiDiGraph(self.XG)
43         self.MXG.add_edge("s", "u", weight=15)
44         self.XG2 = nx.DiGraph()
45         self.XG2.add_weighted_edges_from(
46             [
47                 [1, 4, 1],
48                 [4, 5, 1],
49                 [5, 6, 1],
50                 [6, 3, 1],
51                 [1, 3, 50],
52                 [1, 2, 100],
53                 [2, 3, 100],
54             ]
55         )
56         self.XG3 = nx.Graph()
57         self.XG3.add_weighted_edges_from(
58             [[0, 1, 2], [1, 2, 12], [2, 3, 1], [3, 4, 5], [4, 5, 1], [5, 0, 10]]
59         )
60         self.XG4 = nx.Graph()
61         self.XG4.add_weighted_edges_from(
62             [
63                 [0, 1, 2],
64                 [1, 2, 2],
65                 [2, 3, 1],
66                 [3, 4, 1],
67                 [4, 5, 1],
68                 [5, 6, 1],
69                 [6, 7, 1],
70                 [7, 0, 1],
71             ]
72         )
73         self.MXG4 = nx.MultiGraph(self.XG4)
74         self.MXG4.add_edge(0, 1, weight=3)
75         self.G = nx.DiGraph()  # no weights
76         self.G.add_edges_from(
77             [
78                 ("s", "u"),
79                 ("s", "x"),
80                 ("u", "v"),
81                 ("u", "x"),
82                 ("v", "y"),
83                 ("x", "u"),
84                 ("x", "v"),
85                 ("x", "y"),
86                 ("y", "s"),
87                 ("y", "v"),
88             ]
89         )
90 class TestWeightedPath(WeightedTestBase):
91     def test_dijkstra(self):
92         (D, P) = nx.single_source_dijkstra(self.XG, "s")
93         validate_path(self.XG, "s", "v", 9, P["v"])
94         assert D["v"] == 9
95         validate_path(
96             self.XG, "s", "v", 9, nx.single_source_dijkstra_path(self.XG, "s")["v"]
97         )
98         assert dict(nx.single_source_dijkstra_path_length(self.XG, "s"))["v"] == 9
99         validate_path(
100             self.XG, "s", "v", 9, nx.single_source_dijkstra(self.XG, "s")[1]["v"]
101         )
102         validate_path(
103             self.MXG, "s", "v", 9, nx.single_source_dijkstra_path(self.MXG, "s")["v"]
104         )
105         GG = self.XG.to_undirected()
106         GG["u"]["x"]["weight"] = 2
107         (D, P) = nx.single_source_dijkstra(GG, "s")
108         validate_path(GG, "s", "v", 8, P["v"])
109         assert D["v"] == 8  # uses lower weight of 2 on u&lt;-&gt;x edge
110         validate_path(GG, "s", "v", 8, nx.dijkstra_path(GG, "s", "v"))
111         assert nx.dijkstra_path_length(GG, "s", "v") == 8
112         validate_path(self.XG2, 1, 3, 4, nx.dijkstra_path(self.XG2, 1, 3))
113         validate_path(self.XG3, 0, 3, 15, nx.dijkstra_path(self.XG3, 0, 3))
114         assert nx.dijkstra_path_length(self.XG3, 0, 3) == 15
115         validate_path(self.XG4, 0, 2, 4, nx.dijkstra_path(self.XG4, 0, 2))
116         assert nx.dijkstra_path_length(self.XG4, 0, 2) == 4
117         validate_path(self.MXG4, 0, 2, 4, nx.dijkstra_path(self.MXG4, 0, 2))
118         validate_path(
119             self.G, "s", "v", 2, nx.single_source_dijkstra(self.G, "s", "v")[1]
120         )
121         validate_path(
122             self.G, "s", "v", 2, nx.single_source_dijkstra(self.G, "s")[1]["v"]
123         )
124         validate_path(self.G, "s", "v", 2, nx.dijkstra_path(self.G, "s", "v"))
125         assert nx.dijkstra_path_length(self.G, "s", "v") == 2
126         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path, self.G, "s", "moon")
127         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path_length, self.G, "s", "moon")
128         validate_path(self.cycle, 0, 3, 3, nx.dijkstra_path(self.cycle, 0, 3))
129         validate_path(self.cycle, 0, 4, 3, nx.dijkstra_path(self.cycle, 0, 4))
130         assert nx.single_source_dijkstra(self.cycle, 0, 0) == (0, [0])
131     def test_bidirectional_dijkstra(self):
132         validate_length_path(
133             self.XG, "s", "v", 9, *nx.bidirectional_dijkstra(self.XG, "s", "v")
134         )
135         validate_length_path(
136             self.G, "s", "v", 2, *nx.bidirectional_dijkstra(self.G, "s", "v")
137         )
138         validate_length_path(
139             self.cycle, 0, 3, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 3)
140         )
141         validate_length_path(
142             self.cycle, 0, 4, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 4)
143         )
144         validate_length_path(
145             self.XG3, 0, 3, 15, *nx.bidirectional_dijkstra(self.XG3, 0, 3)
146         )
147         validate_length_path(
148             self.XG4, 0, 2, 4, *nx.bidirectional_dijkstra(self.XG4, 0, 2)
149         )
150         P = nx.single_source_dijkstra_path(self.XG, "s")["v"]
151         validate_path(
152             self.XG,
153             "s",
154             "v",
155             sum(self.XG[u][v]["weight"] for u, v in zip(P[:-1], P[1:])),
156             nx.dijkstra_path(self.XG, "s", "v"),
157         )
158         G = nx.path_graph(2)
159         pytest.raises(nx.NodeNotFound, nx.bidirectional_dijkstra, G, 3, 0)
160     def test_weight_functions(self):
161         def heuristic(*z):
162             return sum(val ** 2 for val in z)
163         def getpath(pred, v, s):
164             return [v] if v == s else getpath(pred, pred[v], s) + [v]
165         def goldberg_radzik(g, s, t, weight="weight"):
166             pred, dist = nx.goldberg_radzik(g, s, weight=weight)
167             dist = dist[t]
168             return dist, getpath(pred, t, s)
169         def astar(g, s, t, weight="weight"):
170             path = nx.astar_path(g, s, t, heuristic, weight=weight)
171             dist = nx.astar_path_length(g, s, t, heuristic, weight=weight)
172             return dist, path
173         def vlp(G, s, t, l, F, w):
174             res = F(G, s, t, weight=w)
175             validate_length_path(G, s, t, l, *res, weight=w)
176         G = self.cycle
177         s = 6
178         t = 4
179         path = [6] + list(range(t + 1))
180         def weight(u, v, _):
181             return 1 + v ** 2
182         length = sum(weight(u, v, None) for u, v in pairwise(path))
183         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
184         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
185         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
186         vlp(G, s, t, length, goldberg_radzik, weight)
187         vlp(G, s, t, length, astar, weight)
188         def weight(u, v, _):
189             return 2 ** (u * v)
190         length = sum(weight(u, v, None) for u, v in pairwise(path))
191         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
192         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
193         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
194         vlp(G, s, t, length, goldberg_radzik, weight)
195         vlp(G, s, t, length, astar, weight)
196     def test_bidirectional_dijkstra_no_path(self):
197         with pytest.raises(nx.NetworkXNoPath):
198             G = nx.Graph()
199             nx.add_path(G, [1, 2, 3])
200             nx.add_path(G, [4, 5, 6])
201             path = nx.bidirectional_dijkstra(G, 1, 6)
202     @pytest.mark.parametrize(
203         "fn",
204         (
205             nx.dijkstra_path,
206             nx.dijkstra_path_length,
207             nx.single_source_dijkstra_path,
208             nx.single_source_dijkstra_path_length,
209             nx.single_source_dijkstra,
210             nx.dijkstra_predecessor_and_distance,
211         ),
212     )
213     def test_absent_source(self, fn):
214         G = nx.path_graph(2)
215         with pytest.raises(nx.NodeNotFound):
216             fn(G, 3, 0)
217         with pytest.raises(nx.NodeNotFound):
218             fn(G, 3, 3)
219     def test_dijkstra_predecessor1(self):
220         G = nx.path_graph(4)
221         assert nx.dijkstra_predecessor_and_distance(G, 0) == (
222             {0: [], 1: [0], 2: [1], 3: [2]},
223             {0: 0, 1: 1, 2: 2, 3: 3},
224         )
225     def test_dijkstra_predecessor2(self):
226         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
227         pred, dist = nx.dijkstra_predecessor_and_distance(G, (0))
228         assert pred[0] == []
229         assert pred[1] == [0]
230         assert pred[2] in [[1, 3], [3, 1]]
231         assert pred[3] == [0]
232         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
233     def test_dijkstra_predecessor3(self):
234         XG = nx.DiGraph()
235         XG.add_weighted_edges_from(
236             [
237                 ("s", "u", 10),
238                 ("s", "x", 5),
239                 ("u", "v", 1),
240                 ("u", "x", 2),
241                 ("v", "y", 1),
242                 ("x", "u", 3),
243                 ("x", "v", 5),
244                 ("x", "y", 2),
245                 ("y", "s", 7),
246                 ("y", "v", 6),
247             ]
248         )
249         (P, D) = nx.dijkstra_predecessor_and_distance(XG, "s")
250         assert P["v"] == ["u"]
251         assert D["v"] == 9
252         (P, D) = nx.dijkstra_predecessor_and_distance(XG, "s", cutoff=8)
253         assert "v" not in D
254     def test_single_source_dijkstra_path_length(self):
255         assert dict(pl(self.MXG4, 0))[2] == 4
256         spl = pl(self.MXG4, 0, cutoff=2)
257         a<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ssert 2 not in spl
258     def test_bidirectional_dijkstra_multigraph(self):
259         G = nx.MultiGraph()
260         G.add_edge("a", "b", weight=10)
261         G.add_edge("a", "b", weight=100)
262         dp =</b></font> nx.bidirectional_dijkstra(G, "a", "b")
263         assert dp == (10, ["a", "b"])
264     def test_dijkstra_pred_distance_multigraph(self):
265         G = nx.MultiGraph()
266         G.add_edge("a", "b", key="short", foo=5, weight=100)
267         G.add_edge("a", "b", key="long", bar=1, weight=110)
268         p, d = nx.dijkstra_predecessor_and_distance(G, "a")
269         assert p == {"a": [], "b": ["a"]}
270         assert d == {"a": 0, "b": 100}
271     def test_negative_edge_cycle(self):
272         G = nx.cycle_graph(5, create_using=nx.DiGraph())
273         assert not nx.negative_edge_cycle(G)
274         G.add_edge(8, 9, weight=-7)
275         G.add_edge(9, 8, weight=3)
276         graph_size = len(G)
277         assert nx.negative_edge_cycle(G)
278         assert graph_size == len(G)
279         pytest.raises(ValueError, nx.single_source_dijkstra_path_length, G, 8)
280         pytest.raises(ValueError, nx.single_source_dijkstra, G, 8)
281         pytest.raises(ValueError, nx.dijkstra_predecessor_and_distance, G, 8)
282         G.add_edge(9, 10)
283         pytest.raises(ValueError, nx.bidirectional_dijkstra, G, 8, 10)
284     def test_negative_edge_cycle_custom_weight_key(self):
285         d = nx.DiGraph()
286         d.add_edge("a", "b", w=-2)
287         d.add_edge("b", "a", w=-1)
288         assert nx.negative_edge_cycle(d, weight="w")
289     def test_weight_function(self):
290         G = nx.complete_graph(3)
291         G.adj[0][2]["weight"] = 10
292         G.adj[0][1]["weight"] = 1
293         G.adj[1][2]["weight"] = 1
294         def weight(u, v, d):
295             return 1 / d["weight"]
296         distance, path = nx.single_source_dijkstra(G, 0, 2)
297         assert distance == 2
298         assert path == [0, 1, 2]
299         distance, path = nx.single_source_dijkstra(G, 0, 2, weight=weight)
300         assert distance == 1 / 10
301         assert path == [0, 2]
302     def test_all_pairs_dijkstra_path(self):
303         cycle = nx.cycle_graph(7)
304         p = dict(nx.all_pairs_dijkstra_path(cycle))
305         assert p[0][3] == [0, 1, 2, 3]
306         cycle[1][2]["weight"] = 10
307         p = dict(nx.all_pairs_dijkstra_path(cycle))
308         assert p[0][3] == [0, 6, 5, 4, 3]
309     def test_all_pairs_dijkstra_path_length(self):
310         cycle = nx.cycle_graph(7)
311         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
312         assert pl[0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
313         cycle[1][2]["weight"] = 10
314         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
315         assert pl[0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
316     def test_all_pairs_dijkstra(self):
317         cycle = nx.cycle_graph(7)
318         out = dict(nx.all_pairs_dijkstra(cycle))
319         assert out[0][0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
320         assert out[0][1][3] == [0, 1, 2, 3]
321         cycle[1][2]["weight"] = 10
322         out = dict(nx.all_pairs_dijkstra(cycle))
323         assert out[0][0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
324         assert out[0][1][3] == [0, 6, 5, 4, 3]
325 class TestDijkstraPathLength:
326     def test_weight_function(self):
327         G = nx.complete_graph(3)
328         G.adj[0][2]["weight"] = 10
329         G.adj[0][1]["weight"] = 1
330         G.adj[1][2]["weight"] = 1
331         def weight(u, v, d):
332             return 1 / d["weight"]
333         length = nx.dijkstra_path_length(G, 0, 2, weight=weight)
334         assert length == 1 / 10
335 class TestMultiSourceDijkstra:
336     def test_no_sources(self):
337         with pytest.raises(ValueError):
338             nx.multi_source_dijkstra(nx.Graph(), {})
339     def test_path_no_sources(self):
340         with pytest.raises(ValueError):
341             nx.multi_source_dijkstra_path(nx.Graph(), {})
342     def test_path_length_no_sources(self):
343         with pytest.raises(ValueError):
344             nx.multi_source_dijkstra_path_length(nx.Graph(), {})
345     @pytest.mark.parametrize(
346         "fn",
347         (
348             nx.multi_source_dijkstra_path,
349             nx.multi_source_dijkstra_path_length,
350             nx.multi_source_dijkstra,
351         ),
352     )
353     def test_absent_source(self, fn):
354         G = nx.path_graph(2)
355         with pytest.raises(nx.NodeNotFound):
356             fn(G, [3], 0)
357         with pytest.raises(nx.NodeNotFound):
358             fn(G, [3], 3)
359     def test_two_sources(self):
360         edges = [(0, 1, 1), (1, 2, 1), (2, 3, 10), (3, 4, 1)]
361         G = nx.Graph()
362         G.add_weighted_edges_from(edges)
363         sources = {0, 4}
364         distances, paths = nx.multi_source_dijkstra(G, sources)
365         expected_distances = {0: 0, 1: 1, 2: 2, 3: 1, 4: 0}
366         expected_paths = {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [4, 3], 4: [4]}
367         assert distances == expected_distances
368         assert paths == expected_paths
369     def test_simple_paths(self):
370         G = nx.path_graph(4)
371         lengths = nx.multi_source_dijkstra_path_length(G, [0])
372         assert lengths == {n: n for n in G}
373         paths = nx.multi_source_dijkstra_path(G, [0])
374         assert paths == {n: list(range(n + 1)) for n in G}
375 class TestBellmanFordAndGoldbergRadzik(WeightedTestBase):
376     def test_single_node_graph(self):
377         G = nx.DiGraph()
378         G.add_node(0)
379         assert nx.single_source_bellman_ford_path(G, 0) == {0: [0]}
380         assert nx.single_source_bellman_ford_path_length(G, 0) == {0: 0}
381         assert nx.single_source_bellman_ford(G, 0) == ({0: 0}, {0: [0]})
382         assert nx.bellman_ford_predecessor_and_distance(G, 0) == ({0: []}, {0: 0})
383         assert nx.goldberg_radzik(G, 0) == ({0: None}, {0: 0})
384     def test_absent_source_bellman_ford(self):
385         G = nx.path_graph(2)
386         for fn in (
387             nx.bellman_ford_predecessor_and_distance,
388             nx.bellman_ford_path,
389             nx.bellman_ford_path_length,
390             nx.single_source_bellman_ford_path,
391             nx.single_source_bellman_ford_path_length,
392             nx.single_source_bellman_ford,
393         ):
394             pytest.raises(nx.NodeNotFound, fn, G, 3, 0)
395             pytest.raises(nx.NodeNotFound, fn, G, 3, 3)
396         with pytest.raises(nx.NodeNotFound):
397             G = nx.path_graph(2)
398             nx.goldberg_radzik(G<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>, 3, 0)
399     def test_negative_cycle_heuristic(self):
400         G = nx.DiGraph()
401         G.add_edge(0, 1, weight=-1)
402         G.add_edge(1, 2, weight=-1)
403         G.</b></font>add_edge(2, 3, weight=-1)
404         G.add_edge(3, 0, weight=3)
405         assert not nx.negative_edge_cycle(G, heuristic=True)
406         G.add_edge(2, 0, weight=1.999)
407         assert nx.negative_edge_cycle(G, heuristic=True)
408         G.edges[2, 0]["weight"] = 2
409         assert not nx.negative_edge_cycle(G, heuristic=True)
410     def test_negative_cycle_consistency(self):
411         import random
412         unif = random.uniform
413         for random_seed in range(2):  # range(20):
414             random.seed(random_seed)
415             for density in [0.1, 0.9]:  # .3, .7, .9]:
416                 for N in [1, 10, 20]:  # range(1, 60 - int(30 * density)):
417                     for max_cost in [1, 90]:  # [1, 10, 40, 90]:
418                         G = nx.binomial_graph(N, density, seed=4, directed=True)
419                         edges = ((u, v, unif(-1, max_cost)) for u, v in G.edges)
420                         G.add_weighted_edges_from(edges)
421                         no_heuristic = nx.negative_edge_cycle(G, heuristic=False)
422                         with_heuristic = nx.negative_edge_cycle(G, heuristic=True)
423                         assert no_heuristic == with_heuristic
424     def test_negative_cycle(self):
425         G = nx.cycle_graph(5, create_using=nx.DiGraph())
426         G.add_edge(1, 2, weight=-7)
427         for i in range(5):
428             pytest.raises(
429                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
430             )
431             pytest.raises(
432                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
433             )
434             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
435             pytest.raises(
436                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
437             )
438             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
439         G = nx.cycle_graph(5)  # undirected Graph
440         G.add_edge(1, 2, weight=-3)
441         for i in range(5):
442             pytest.raises(
443                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
444             )
445             pytest.raises(
446                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
447             )
448             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
449             pytest.raises(
450                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
451             )
452             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
453         G = nx.DiGraph([(1, 1, {"weight": -1})])
454         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, 1)
455         pytest.raises(
456             nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, 1
457         )
458         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, 1)
459         pytest.raises(
460             nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, 1
461         )
462         pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, 1)
463     def test_find_negative_cycle_longer_cycle(self):
464         G = nx.cycle_graph(5, create_using=nx.DiGraph())
465         nx.add_cycle(G, [3, 5, 6, 7, 8, 9])
466         G.add_edge(1, 2, weight=-30)
467         assert nx.find_negative_cycle(G, 1) == [0, 1, 2, 3, 4, 0]
468         assert nx.find_negative_cycle(G, 7) == [2, 3, 4, 0, 1, 2]
469     def test_find_negative_cycle_no_cycle(self):
470         G = nx.path_graph(5, create_using=nx.DiGraph())
471         pytest.raises(nx.NetworkXError, nx.find_negative_cycle, G, 3)
472     def test_find_negative_cycle_single_edge(self):
473         G = nx.Graph()
474         G.add_edge(0, 1, weight=-1)
475         assert nx.find_negative_cycle(G, 1) == [1, 0, 1]
476     def test_negative_weight(self):
477         G = nx.cycle_graph(5, create_using=nx.DiGraph())
478         G.add_edge(1, 2, weight=-3)
479         assert nx.single_source_bellman_ford_path(G, 0) == {
480             0: [0],
481             1: [0, 1],
482             2: [0, 1, 2],
483             3: [0, 1, 2, 3],
484             4: [0, 1, 2, 3, 4],
485         }
486         assert nx.single_source_bellman_ford_path_length(G, 0) == {
487             0: 0,
488             1: 1,
489             2: -2,
490             3: -1,
491             4: 0,
492         }
493         assert nx.single_source_bellman_ford(G, 0) == (
494             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
495             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3], 4: [0, 1, 2, 3, 4]},
496         )
497         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
498             {0: [], 1: [0], 2: [1], 3: [2], 4: [3]},
499             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
500         )
501         assert nx.goldberg_radzik(G, 0) == (
502             {0: None, 1: 0, 2: 1, 3: 2, 4: 3},
503             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
504         )
505     def test_not_connected(self):
506         G = nx.complete_graph(6)
507         G.add_edge(10, 11)
508         G.add_edge(10, 12)
509         assert nx.single_source_bellman_ford_path(G, 0) == {
510             0: [0],
511             1: [0, 1],
512             2: [0, 2],
513             3: [0, 3],
514             4: [0, 4],
515             5: [0, 5],
516         }
517         assert nx.single_source_bellman_ford_path_length(G, 0) == {
518             0: 0,
519             1: 1,
520             2: 1,
521             3: 1,
522             4: 1,
523             5: 1,
524         }
525         assert nx.single_source_bellman_ford(G, 0) == (
526             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
527             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
528         )
529         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
530             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
531             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
532         )
533         assert nx.goldberg_radzik(G, 0) == (
534             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
535             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
536         )
537         G = nx.complete_graph(6)
538         G.add_edges_from(
539             [
540                 ("A", "B", {"load": 3}),
541                 ("B", "C", {"load": -10}),
542                 ("C", "A", {"load": 2}),
543             ]
544         )
545         assert nx.single_source_bellman_ford_path(G, 0, weight="load") == {
546             0: [0],
547             1: [0, 1],
548             2: [0, 2],
549             3: [0, 3],
550             4: [0, 4],
551             5: [0, 5],
552         }
553         assert nx.single_source_bellman_ford_path_length(G, 0, weight="load") == {
554             0: 0,
555             1: 1,
556             2: 1,
557             3: 1,
558             4: 1,
559             5: 1,
560         }
561         assert nx.single_source_bellman_ford(G, 0, weight="load") == (
562             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
563             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
564         )
565         assert nx.bellman_ford_predecessor_and_distance(G, 0, weight="load") == (
566             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
567             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
568         )
569         assert nx.goldberg_radzik(G, 0, weight="load") == (
570             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
571             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
572         )
573     def test_multigraph(self):
574         assert nx.bellman_ford_path(self.MXG, "s", "v") == ["s", "x", "u", "v"]
575         assert nx.bellman_ford_path_length(self.MXG, "s", "v") == 9
576         assert nx.single_source_bellman_ford_path(self.MXG, "s")["v"] == [
577             "s",
578             "x",
579             "u",
580             "v",
581         ]
582         assert nx.single_source_bellman_ford_path_length(self.MXG, "s")["v"] == 9
583         D, P = nx.single_source_bellman_ford(self.MXG, "s", target="v")
584         assert D == 9
585         assert P == ["s", "x", "u", "v"]
586         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG, "s")
587         assert P["v"] == ["u"]
588         assert D["v"] == 9
589         P, D = nx.goldberg_radzik(self.MXG, "s")
590         assert P["v"] == "u"
591         assert D["v"] == 9
592         assert nx.bellman_ford_path(self.MXG4, 0, 2) == [0, 1, 2]
593         assert nx.bellman_ford_path_length(self.MXG4, 0, 2) == 4
594         assert nx.single_source_bellman_ford_path(self.MXG4, 0)[2] == [0, 1, 2]
595         assert nx.single_source_bellman_ford_path_length(self.MXG4, 0)[2] == 4
596         D, P = nx.single_source_bellman_ford(self.MXG4, 0, target=2)
597         assert D == 4
598         assert P == [0, 1, 2]
599         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG4, 0)
600         assert P[2] == [1]
601         assert D[2] == 4
602         P, D = nx.goldberg_radzik(self.MXG4, 0)
603         assert P[2] == 1
604         assert D[2] == 4
605     def test_others(self):
606         assert nx.bellman_ford_path(self.XG, "s", "v") == ["s", "x", "u", "v"]
607         assert nx.bellman_ford_path_length(self.XG, "s", "v") == 9
608         assert nx.single_source_bellman_ford_path(self.XG, "s")["v"] == [
609             "s",
610             "x",
611             "u",
612             "v",
613         ]
614         assert nx.single_source_bellman_ford_path_length(self.XG, "s")["v"] == 9
615         D, P = nx.single_source_bellman_ford(self.XG, "s", target="v")
616         assert D == 9
617         assert P == ["s", "x", "u", "v"]
618         (P, D) = nx.bellman_ford_predecessor_and_distance(self.XG, "s")
619         assert P["v"] == ["u"]
620         assert D["v"] == 9
621         (P, D) = nx.goldberg_radzik(self.XG, "s")
622         assert P["v"] == "u"
623         assert D["v"] == 9
624     def test_path_graph(self):
625         G = nx.path_graph(4)
626         assert nx.single_source_bellman_ford_path(G, 0) == {
627             0: [0],
628             1: [0, 1],
629             2: [0, 1, 2],
630             3: [0, 1, 2, 3],
631         }
632         assert nx.single_source_bellman_ford_path_length(G, 0) == {
633             0: 0,
634             1: 1,
635             2: 2,
636             3: 3,
637         }
638         assert nx.single_source_bellman_ford(G, 0) == (
639             {0: 0, 1: 1, 2: 2, 3: 3},
640             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3]},
641         )
642         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
643             {0: [], 1: [0], 2: [1], 3: [2]},
644             {0: 0, 1: 1, 2: 2, 3: 3},
645         )
646         assert nx.goldberg_radzik(G, 0) == (
647             {0: None, 1: 0, 2: 1, 3: 2},
648             {0: 0, 1: 1, 2: 2, 3: 3},
649         )
650         assert nx.single_source_bellman_ford_path(G, 3) == {
651             0: [3, 2, 1, 0],
652             1: [3, 2, 1],
653             2: [3, 2],
654             3: [3],
655         }
656         assert nx.single_source_bellman_ford_path_length(G, 3) == {
657             0: 3,
658             1: 2,
659             2: 1,
660             3: 0,
661         }
662         assert nx.single_source_bellman_ford(G, 3) == (
663             {0: 3, 1: 2, 2: 1, 3: 0},
664             {0: [3, 2, 1, 0], 1: [3, 2, 1], 2: [3, 2], 3: [3]},
665         )
666         assert nx.bellman_ford_predecessor_and_distance(G, 3) == (
667             {0: [1], 1: [2], 2: [3], 3: []},
668             {0: 3, 1: 2, 2: 1, 3: 0},
669         )
670         assert nx.goldberg_radzik(G, 3) == (
671             {0: 1, 1: 2, 2: 3, 3: None},
672             {0: 3, 1: 2, 2: 1, 3: 0},
673         )
674     def test_4_cycle(self):
675         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
676         dist, path = nx.single_source_bellman_ford(G, 0)
677         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
678         assert path[0] == [0]
679         assert path[1] == [0, 1]
680         assert path[2] in [[0, 1, 2], [0, 3, 2]]
681         assert path[3] == [0, 3]
682         pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0)
683         assert pred[0] == []
684         assert pred[1] == [0]
685         assert pred[2] in [[1, 3], [3, 1]]
686         assert pred[3] == [0]
687         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
688         pred, dist = nx.goldberg_radzik(G, 0)
689         assert pred[0] is None
690         assert pred[1] == 0
691         assert pred[2] in [1, 3]
692         assert pred[3] == 0
693         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
694     def test_negative_weight_bf_path(self):
695         G = nx.DiGraph()
696         G.add_nodes_from("abcd")
697         G.add_edge("a", "d", weight=0)
698         G.add_edge("a", "b", weight=1)
699         G.add_edge("b", "c", weight=-3)
700         G.add_edge("c", "d", weight=1)
701         assert nx.bellman_ford_path(G, "a", "d") == ["a", "b", "c", "d"]
702         assert nx.bellman_ford_path_length(G, "a", "d") == -1
703     def test_zero_cycle_smoke(self):
704         D = nx.DiGraph()
705         D.add_weighted_edges_from([(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 1, -2)])
706         nx.bellman_ford_path(D, 1, 3)
707         nx.dijkstra_path(D, 1, 3)
708         nx.bidirectional_dijkstra(D, 1, 3)
709 class TestJohnsonAlgorithm(WeightedTestBase):
710     def test_single_node_graph(self):
711         with pytest.raises(nx.NetworkXError):
712             G = nx.DiGraph()
713             G.add_node(0)
714             nx.johnson(G)
715     def test_negative_cycle(self):
716         G = nx.DiGraph()
717         G.add_weighted_edges_from(
718             [
719                 ("0", "3", 3),
720                 ("0", "1", -5),
721                 ("1", "0", -5),
722                 ("0", "2", 2),
723                 ("1", "2", 4),
724                 ("2", "3", 1),
725             ]
726         )
727         pytest.raises(nx.NetworkXUnbounded, nx.johnson, G)
728         G = nx.Graph()
729         G.add_weighted_edges_from(
730             [
731                 ("0", "3", 3),
732                 ("0", "1", -5),
733                 ("1", "0", -5),
734                 ("0", "2", 2),
735                 ("1", "2", 4),
736                 ("2", "3", 1),
737             ]
738         )
739         pytest.raises(nx.NetworkXUnbounded, nx.johnson, G)
740     def test_negative_weights(self):
741         G = nx.DiGraph()
742         G.add_weighted_edges_from(
743             [("0", "3", 3), ("0", "1", -5), ("0", "2", 2), ("1", "2", 4), ("2", "3", 1)]
744         )
745         paths = nx.johnson(G)
746         assert paths == {
747             "1": {"1": ["1"], "3": ["1", "2", "3"], "2": ["1", "2"]},
748             "0": {
749                 "1": ["0", "1"],
750                 "0": ["0"],
751                 "2": ["0", "1", "2"],
752             },
753             "3": {<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"3": ["3"]},
754             "2": {"3": ["2", "3"], "2": ["2"]},
755         }
756     def test_unweighted_graph(self):
757         with pytest.raises(nx.NetworkXError):
758             G = nx.path_graph(</b></font>5)
759             nx.johnson(G)
760     def test_graphs(self):
761         validate_path(self.XG, "s", "v", 9, nx.johnson(self.XG)["s"]["v"])
762         validate_path(self.MXG, "s", "v", 9, nx.johnson(self.MXG)["s"]["v"])
763         validate_path(self.XG2, 1, 3, 4, nx.johnson(self.XG2)[1][3])
764         validate_path(self.XG3, 0, 3, 15, nx.johnson(self.XG3)[0][3])
765         validate_path(self.XG4, 0, 2, 4, nx.johnson(self.XG4)[0][2])
766         validate_path(self.MXG4, 0, 2, 4, nx.johnson(self.MXG4)[0][2])
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
