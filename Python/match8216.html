<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_node_link.py &amp; test_weighted.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_node_link.py &amp; test_weighted.py
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_node_link.py (14.4%)<th>test_weighted.py (2.0316026%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-67)<td><a href="#" name="0">(909-915)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(35-40)<td><a href="#" name="1">(314-320)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(11-17)<td><a href="#" name="2">(524-530)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_node_link.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import json
2 import pytest
3 import networkx as nx
4 from networkx.readwrite.json_graph import node_link_data, node_link_graph
5 class TestNodeLink:
6 <a name="2"></a>    def test_graph(self):
7         G = nx.path_graph(4)
8         H = node_link_graph(node_link_data(G))
9         assert nx.is_isomorphic(<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>G, H)
10     def test_graph_attributes(self):
11         G = nx.path_graph(4)
12         G.add_node(1, color="red")
13         G.add_edge(1, 2, width=7)
14         G.</b></font>graph[1] = "one"
15         G.graph["foo"] = "bar"
16         H = node_link_graph(node_link_data(G))
17         assert H.graph["foo"] == "bar"
18         assert H.nodes[1]["color"] == "red"
19         assert H[1][2]["width"] == 7
20         d = json.dumps(node_link_data(G))
21         H = node_link_graph(json.loads(d))
22         assert H.graph["foo"] == "bar"
23         assert H.graph["1"] == "one"
24         assert H.nodes[1]["color"] == "red"
25         assert H[1][2]["width"] == 7
26 <a name="1"></a>    def test_digraph(self):
27         G = nx.DiGraph()
28         H = node_link_graph(node_link_data(G))
29         assert H.is_directed(<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>)
30     def test_multigraph(self):
31         G = nx.MultiGraph()
32         G.add_edge(1, 2, key="first")
33         G.add_edge(1, 2, key="second", color=</b></font>"blue")
34         H = node_link_graph(node_link_data(G))
35         nx.is_isomorphic(G, H)
36         assert H[1][2]["second"]["color"] == "blue"
37     def test_graph_with_tuple_nodes(self):
38         G = nx.Graph()
39         G.add_edge((0, 0), (1, 0), color=[255, 255, 0])
40         d = node_link_data(G)
41         dumped_d = json.dumps(d)
42         dd = json.loads(dumped_d)
43         H = node_link_graph(dd)
44         assert H.nodes[(0, 0)] == G.nodes[(0, 0)]
45         assert H[(0, 0)][(1, 0)]["color"] == [255, 255, 0]
46     def test_unicode_keys(self):
47         q = "qualité"
48         G = nx.Graph()
49         G.add_node(1, **{q: q})
50         s = node_link_data(G)
51 <a name="0"></a>        output = json.dumps(s, ensure_ascii=False)
52         data = json.loads(output)
53         H = node_link_graph(data)
54         assert H<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.nodes[1][q] == q
55     def test_exception(self):
56         with pytest.raises(nx.NetworkXError):
57             G = nx.MultiDiGraph(</b></font>)
58             attrs = dict(name="node", source="node", target="node", key="node")
59             node_link_data(G, attrs)
60     def test_string_ids(self):
61         q = "qualité"
62         G = nx.DiGraph()
63         G.add_node("A")
64         G.add_node(q)
65         G.add_edge("A", q)
66         data = node_link_data(G)
67         assert data["links"][0]["source"] == "A"
68         assert data["links"][0]["target"] == q
69         H = node_link_graph(data)
70         assert nx.is_isomorphic(G, H)
71     def test_custom_attrs(self):
72         G = nx.path_graph(4)
73         G.add_node(1, color="red")
74         G.add_edge(1, 2, width=7)
75         G.graph[1] = "one"
76         G.graph["foo"] = "bar"
77         attrs = dict(
78             source="c_source",
79             target="c_target",
80             name="c_id",
81             key="c_key",
82             link="c_links",
83         )
84         H = node_link_graph(
85             node_link_data(G, attrs=attrs), multigraph=False, attrs=attrs
86         )
87         assert nx.is_isomorphic(G, H)
88         assert H.graph["foo"] == "bar"
89         assert H.nodes[1]["color"] == "red"
90         assert H[1][2]["width"] == 7
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_weighted.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import networkx as nx
3 from networkx.utils import pairwise
4 def validate_path(G, s, t, soln_len, path, weight="weight"):
5     assert path[0] == s
6     assert path[-1] == t
7     if callable(weight):
8         weight_f = weight
9     else:
10         if G.is_multigraph():
11             def weight_f(u, v, d):
12                 return min(e.get(weight, 1) for e in d.values())
13         else:
14             def weight_f(u, v, d):
15                 return d.get(weight, 1)
16     computed = sum(weight_f(u, v, G[u][v]) for u, v in pairwise(path))
17     assert soln_len == computed
18 def validate_length_path(G, s, t, soln_len, length, path, weight="weight"):
19     assert soln_len == length
20     validate_path(G, s, t, length, path, weight=weight)
21 class WeightedTestBase:
22     def setup(self):
23         cnlti = nx.convert_node_labels_to_integers
24         self.grid = cnlti(nx.grid_2d_graph(4, 4), first_label=1, ordering="sorted")
25         self.cycle = nx.cycle_graph(7)
26         self.directed_cycle = nx.cycle_graph(7, create_using=nx.DiGraph())
27         self.XG = nx.DiGraph()
28         self.XG.add_weighted_edges_from(
29             [
30                 ("s", "u", 10),
31                 ("s", "x", 5),
32                 ("u", "v", 1),
33                 ("u", "x", 2),
34                 ("v", "y", 1),
35                 ("x", "u", 3),
36                 ("x", "v", 5),
37                 ("x", "y", 2),
38                 ("y", "s", 7),
39                 ("y", "v", 6),
40             ]
41         )
42         self.MXG = nx.MultiDiGraph(self.XG)
43         self.MXG.add_edge("s", "u", weight=15)
44         self.XG2 = nx.DiGraph()
45         self.XG2.add_weighted_edges_from(
46             [
47                 [1, 4, 1],
48                 [4, 5, 1],
49                 [5, 6, 1],
50                 [6, 3, 1],
51                 [1, 3, 50],
52                 [1, 2, 100],
53                 [2, 3, 100],
54             ]
55         )
56         self.XG3 = nx.Graph()
57         self.XG3.add_weighted_edges_from(
58             [[0, 1, 2], [1, 2, 12], [2, 3, 1], [3, 4, 5], [4, 5, 1], [5, 0, 10]]
59         )
60         self.XG4 = nx.Graph()
61         self.XG4.add_weighted_edges_from(
62             [
63                 [0, 1, 2],
64                 [1, 2, 2],
65                 [2, 3, 1],
66                 [3, 4, 1],
67                 [4, 5, 1],
68                 [5, 6, 1],
69                 [6, 7, 1],
70                 [7, 0, 1],
71             ]
72         )
73         self.MXG4 = nx.MultiGraph(self.XG4)
74         self.MXG4.add_edge(0, 1, weight=3)
75         self.G = nx.DiGraph()  # no weights
76         self.G.add_edges_from(
77             [
78                 ("s", "u"),
79                 ("s", "x"),
80                 ("u", "v"),
81                 ("u", "x"),
82                 ("v", "y"),
83                 ("x", "u"),
84                 ("x", "v"),
85                 ("x", "y"),
86                 ("y", "s"),
87                 ("y", "v"),
88             ]
89         )
90 class TestWeightedPath(WeightedTestBase):
91     def test_dijkstra(self):
92         (D, P) = nx.single_source_dijkstra(self.XG, "s")
93         validate_path(self.XG, "s", "v", 9, P["v"])
94         assert D["v"] == 9
95         validate_path(
96             self.XG, "s", "v", 9, nx.single_source_dijkstra_path(self.XG, "s")["v"]
97         )
98         assert dict(nx.single_source_dijkstra_path_length(self.XG, "s"))["v"] == 9
99         validate_path(
100             self.XG, "s", "v", 9, nx.single_source_dijkstra(self.XG, "s")[1]["v"]
101         )
102         validate_path(
103             self.MXG, "s", "v", 9, nx.single_source_dijkstra_path(self.MXG, "s")["v"]
104         )
105         GG = self.XG.to_undirected()
106         GG["u"]["x"]["weight"] = 2
107         (D, P) = nx.single_source_dijkstra(GG, "s")
108         validate_path(GG, "s", "v", 8, P["v"])
109         assert D["v"] == 8  # uses lower weight of 2 on u&lt;-&gt;x edge
110         validate_path(GG, "s", "v", 8, nx.dijkstra_path(GG, "s", "v"))
111         assert nx.dijkstra_path_length(GG, "s", "v") == 8
112         validate_path(self.XG2, 1, 3, 4, nx.dijkstra_path(self.XG2, 1, 3))
113         validate_path(self.XG3, 0, 3, 15, nx.dijkstra_path(self.XG3, 0, 3))
114         assert nx.dijkstra_path_length(self.XG3, 0, 3) == 15
115         validate_path(self.XG4, 0, 2, 4, nx.dijkstra_path(self.XG4, 0, 2))
116         assert nx.dijkstra_path_length(self.XG4, 0, 2) == 4
117         validate_path(self.MXG4, 0, 2, 4, nx.dijkstra_path(self.MXG4, 0, 2))
118         validate_path(
119             self.G, "s", "v", 2, nx.single_source_dijkstra(self.G, "s", "v")[1]
120         )
121         validate_path(
122             self.G, "s", "v", 2, nx.single_source_dijkstra(self.G, "s")[1]["v"]
123         )
124         validate_path(self.G, "s", "v", 2, nx.dijkstra_path(self.G, "s", "v"))
125         assert nx.dijkstra_path_length(self.G, "s", "v") == 2
126         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path, self.G, "s", "moon")
127         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path_length, self.G, "s", "moon")
128         validate_path(self.cycle, 0, 3, 3, nx.dijkstra_path(self.cycle, 0, 3))
129         validate_path(self.cycle, 0, 4, 3, nx.dijkstra_path(self.cycle, 0, 4))
130         assert nx.single_source_dijkstra(self.cycle, 0, 0) == (0, [0])
131     def test_bidirectional_dijkstra(self):
132         validate_length_path(
133             self.XG, "s", "v", 9, *nx.bidirectional_dijkstra(self.XG, "s", "v")
134         )
135         validate_length_path(
136             self.G, "s", "v", 2, *nx.bidirectional_dijkstra(self.G, "s", "v")
137         )
138         validate_length_path(
139             self.cycle, 0, 3, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 3)
140         )
141         validate_length_path(
142             self.cycle, 0, 4, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 4)
143         )
144         validate_length_path(
145             self.XG3, 0, 3, 15, *nx.bidirectional_dijkstra(self.XG3, 0, 3)
146         )
147         validate_length_path(
148             self.XG4, 0, 2, 4, *nx.bidirectional_dijkstra(self.XG4, 0, 2)
149         )
150         P = nx.single_source_dijkstra_path(self.XG, "s")["v"]
151         validate_path(
152             self.XG,
153             "s",
154             "v",
155             sum(self.XG[u][v]["weight"] for u, v in zip(P[:-1], P[1:])),
156             nx.dijkstra_path(self.XG, "s", "v"),
157         )
158         G = nx.path_graph(2)
159         pytest.raises(nx.NodeNotFound, nx.bidirectional_dijkstra, G, 3, 0)
160     def test_weight_functions(self):
161         def heuristic(*z):
162             return sum(val ** 2 for val in z)
163         def getpath(pred, v, s):
164             return [v] if v == s else getpath(pred, pred[v], s) + [v]
165         def goldberg_radzik(g, s, t, weight="weight"):
166             pred, dist = nx.goldberg_radzik(g, s, weight=weight)
167             dist = dist[t]
168             return dist, getpath(pred, t, s)
169         def astar(g, s, t, weight="weight"):
170             path = nx.astar_path(g, s, t, heuristic, weight=weight)
171             dist = nx.astar_path_length(g, s, t, heuristic, weight=weight)
172             return dist, path
173         def vlp(G, s, t, l, F, w):
174             res = F(G, s, t, weight=w)
175             validate_length_path(G, s, t, l, *res, weight=w)
176         G = self.cycle
177         s = 6
178         t = 4
179         path = [6] + list(range(t + 1))
180         def weight(u, v, _):
181             return 1 + v ** 2
182         length = sum(weight(u, v, None) for u, v in pairwise(path))
183         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
184         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
185         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
186         vlp(G, s, t, length, goldberg_radzik, weight)
187         vlp(G, s, t, length, astar, weight)
188         def weight(u, v, _):
189             return 2 ** (u * v)
190         length = sum(weight(u, v, None) for u, v in pairwise(path))
191         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
192         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
193         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
194         vlp(G, s, t, length, goldberg_radzik, weight)
195         vlp(G, s, t, length, astar, weight)
196     def test_bidirectional_dijkstra_no_path(self):
197         with pytest.raises(nx.NetworkXNoPath):
198             G = nx.Graph()
199             nx.add_path(G, [1, 2, 3])
200             nx.add_path(G, [4, 5, 6])
201             path = nx.bidirectional_dijkstra(G, 1, 6)
202     @pytest.mark.parametrize(
203         "fn",
204         (
205             nx.dijkstra_path,
206             nx.dijkstra_path_length,
207             nx.single_source_dijkstra_path,
208             nx.single_source_dijkstra_path_length,
209             nx.single_source_dijkstra,
210             nx.dijkstra_predecessor_and_distance,
211         ),
212     )
213     def test_absent_source(self, fn):
214         G = nx.path_graph(2)
215         with pytest.raises(nx.NodeNotFound):
216             fn(G, 3, 0)
217         with pytest.raises(nx.NodeNotFound):
218             fn(G, 3, 3)
219     def test_dijkstra_predecessor1(self):
220         G = nx.path_graph(4)
221         assert nx.dijkstra_predecessor_and_distance(G, 0) == (
222             {0: [], 1: [0], 2: [1], 3: [2]},
223             {0: 0, 1: 1, 2: 2, 3: 3},
224         )
225     def test_dijkstra_predecessor2(self):
226         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
227         pred, dist = nx.dijkstra_predecessor_and_distance(G, (0))
228         assert pred[0] == []
229         assert pred[1] == [0]
230         assert pred[2] in [[1, 3], [3, 1]]
231         assert pred[3] == [0]
232         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
233     def test_dijkstra_predecessor3(self):
234         XG = nx.DiGraph()
235         XG.add_weighted_edges_from(
236             [
237                 ("s", "u", 10),
238                 ("s", "x", 5),
239                 ("u", "v", 1),
240                 ("u", "x", 2),
241                 ("v", "y", 1),
242                 ("x", "u", 3),
243                 ("x", "v", 5),
244                 ("x", "y", 2),
245                 ("y", "s", 7),
246                 ("y", "v", 6),
247             ]
248         )
249         (P, D) = nx.dijkstra_predecessor_and_distance(XG, "s")
250         assert P["v"] == ["u"]
251         assert D["v"] == 9
252         (P, D) = nx.dijkstra_predecessor_and_distance(XG, "s", cutoff=8)
253         assert "v" not in D
254     def test_single_source_dijkstra_path_length(self):
255 <a name="1"></a>        pl = nx.single_source_dijkstra_path_length
256         assert dict(pl(self.MXG4, 0))[2] == 4
257         spl = pl(self.MXG4, 0, cutoff=2)
258         a<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ssert 2 not in spl
259     def test_bidirectional_dijkstra_multigraph(self):
260         G = nx.MultiGraph()
261         G.add_edge("a", "b", weight=10)
262         G.add_edge("a", "b", weight=100)
263         dp =</b></font> nx.bidirectional_dijkstra(G, "a", "b")
264         assert dp == (10, ["a", "b"])
265     def test_dijkstra_pred_distance_multigraph(self):
266         G = nx.MultiGraph()
267         G.add_edge("a", "b", key="short", foo=5, weight=100)
268         G.add_edge("a", "b", key="long", bar=1, weight=110)
269         p, d = nx.dijkstra_predecessor_and_distance(G, "a")
270         assert p == {"a": [], "b": ["a"]}
271         assert d == {"a": 0, "b": 100}
272     def test_negative_edge_cycle(self):
273         G = nx.cycle_graph(5, create_using=nx.DiGraph())
274         assert not nx.negative_edge_cycle(G)
275         G.add_edge(8, 9, weight=-7)
276         G.add_edge(9, 8, weight=3)
277         graph_size = len(G)
278         assert nx.negative_edge_cycle(G)
279         assert graph_size == len(G)
280         pytest.raises(ValueError, nx.single_source_dijkstra_path_length, G, 8)
281         pytest.raises(ValueError, nx.single_source_dijkstra, G, 8)
282         pytest.raises(ValueError, nx.dijkstra_predecessor_and_distance, G, 8)
283         G.add_edge(9, 10)
284         pytest.raises(ValueError, nx.bidirectional_dijkstra, G, 8, 10)
285     def test_negative_edge_cycle_custom_weight_key(self):
286         d = nx.DiGraph()
287         d.add_edge("a", "b", w=-2)
288         d.add_edge("b", "a", w=-1)
289         assert nx.negative_edge_cycle(d, weight="w")
290     def test_weight_function(self):
291         G = nx.complete_graph(3)
292         G.adj[0][2]["weight"] = 10
293         G.adj[0][1]["weight"] = 1
294         G.adj[1][2]["weight"] = 1
295         def weight(u, v, d):
296             return 1 / d["weight"]
297         distance, path = nx.single_source_dijkstra(G, 0, 2)
298         assert distance == 2
299         assert path == [0, 1, 2]
300         distance, path = nx.single_source_dijkstra(G, 0, 2, weight=weight)
301         assert distance == 1 / 10
302         assert path == [0, 2]
303     def test_all_pairs_dijkstra_path(self):
304         cycle = nx.cycle_graph(7)
305         p = dict(nx.all_pairs_dijkstra_path(cycle))
306         assert p[0][3] == [0, 1, 2, 3]
307         cycle[1][2]["weight"] = 10
308         p = dict(nx.all_pairs_dijkstra_path(cycle))
309         assert p[0][3] == [0, 6, 5, 4, 3]
310     def test_all_pairs_dijkstra_path_length(self):
311         cycle = nx.cycle_graph(7)
312         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
313         assert pl[0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
314         cycle[1][2]["weight"] = 10
315         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
316         assert pl[0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
317     def test_all_pairs_dijkstra(self):
318         cycle = nx.cycle_graph(7)
319         out = dict(nx.all_pairs_dijkstra(cycle))
320         assert out[0][0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
321         assert out[0][1][3] == [0, 1, 2, 3]
322         cycle[1][2]["weight"] = 10
323         out = dict(nx.all_pairs_dijkstra(cycle))
324         assert out[0][0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
325         assert out[0][1][3] == [0, 6, 5, 4, 3]
326 class TestDijkstraPathLength:
327     def test_weight_function(self):
328         G = nx.complete_graph(3)
329         G.adj[0][2]["weight"] = 10
330         G.adj[0][1]["weight"] = 1
331         G.adj[1][2]["weight"] = 1
332         def weight(u, v, d):
333             return 1 / d["weight"]
334         length = nx.dijkstra_path_length(G, 0, 2, weight=weight)
335         assert length == 1 / 10
336 class TestMultiSourceDijkstra:
337     def test_no_sources(self):
338         with pytest.raises(ValueError):
339             nx.multi_source_dijkstra(nx.Graph(), {})
340     def test_path_no_sources(self):
341         with pytest.raises(ValueError):
342             nx.multi_source_dijkstra_path(nx.Graph(), {})
343     def test_path_length_no_sources(self):
344         with pytest.raises(ValueError):
345             nx.multi_source_dijkstra_path_length(nx.Graph(), {})
346     @pytest.mark.parametrize(
347         "fn",
348         (
349             nx.multi_source_dijkstra_path,
350             nx.multi_source_dijkstra_path_length,
351             nx.multi_source_dijkstra,
352         ),
353     )
354     def test_absent_source(self, fn):
355         G = nx.path_graph(2)
356         with pytest.raises(nx.NodeNotFound):
357             fn(G, [3], 0)
358         with pytest.raises(nx.NodeNotFound):
359             fn(G, [3], 3)
360     def test_two_sources(self):
361         edges = [(0, 1, 1), (1, 2, 1), (2, 3, 10), (3, 4, 1)]
362         G = nx.Graph()
363         G.add_weighted_edges_from(edges)
364         sources = {0, 4}
365         distances, paths = nx.multi_source_dijkstra(G, sources)
366         expected_distances = {0: 0, 1: 1, 2: 2, 3: 1, 4: 0}
367         expected_paths = {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [4, 3], 4: [4]}
368         assert distances == expected_distances
369         assert paths == expected_paths
370     def test_simple_paths(self):
371         G = nx.path_graph(4)
372         lengths = nx.multi_source_dijkstra_path_length(G, [0])
373         assert lengths == {n: n for n in G}
374         paths = nx.multi_source_dijkstra_path(G, [0])
375         assert paths == {n: list(range(n + 1)) for n in G}
376 class TestBellmanFordAndGoldbergRadzik(WeightedTestBase):
377     def test_single_node_graph(self):
378         G = nx.DiGraph()
379         G.add_node(0)
380         assert nx.single_source_bellman_ford_path(G, 0) == {0: [0]}
381         assert nx.single_source_bellman_ford_path_length(G, 0) == {0: 0}
382         assert nx.single_source_bellman_ford(G, 0) == ({0: 0}, {0: [0]})
383         assert nx.bellman_ford_predecessor_and_distance(G, 0) == ({0: []}, {0: 0})
384         assert nx.goldberg_radzik(G, 0) == ({0: None}, {0: 0})
385     def test_absent_source_bellman_ford(self):
386         G = nx.path_graph(2)
387         for fn in (
388             nx.bellman_ford_predecessor_and_distance,
389             nx.bellman_ford_path,
390             nx.bellman_ford_path_length,
391             nx.single_source_bellman_ford_path,
392             nx.single_source_bellman_ford_path_length,
393             nx.single_source_bellman_ford,
394         ):
395             pytest.raises(nx.NodeNotFound, fn, G, 3, 0)
396             pytest.raises(nx.NodeNotFound, fn, G, 3, 3)
397 <a name="2"></a>    def test_absent_source_goldberg_radzik(self):
398         with pytest.raises(nx.NodeNotFound):
399             G = nx.path_graph(2)
400             nx.goldberg_radzik(G<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>, 3, 0)
401     def test_negative_cycle_heuristic(self):
402         G = nx.DiGraph()
403         G.add_edge(0, 1, weight=-1)
404         G.add_edge(1, 2, weight=-1)
405         G.</b></font>add_edge(2, 3, weight=-1)
406         G.add_edge(3, 0, weight=3)
407         assert not nx.negative_edge_cycle(G, heuristic=True)
408         G.add_edge(2, 0, weight=1.999)
409         assert nx.negative_edge_cycle(G, heuristic=True)
410         G.edges[2, 0]["weight"] = 2
411         assert not nx.negative_edge_cycle(G, heuristic=True)
412     def test_negative_cycle_consistency(self):
413         import random
414         unif = random.uniform
415         for random_seed in range(2):  # range(20):
416             random.seed(random_seed)
417             for density in [0.1, 0.9]:  # .3, .7, .9]:
418                 for N in [1, 10, 20]:  # range(1, 60 - int(30 * density)):
419                     for max_cost in [1, 90]:  # [1, 10, 40, 90]:
420                         G = nx.binomial_graph(N, density, seed=4, directed=True)
421                         edges = ((u, v, unif(-1, max_cost)) for u, v in G.edges)
422                         G.add_weighted_edges_from(edges)
423                         no_heuristic = nx.negative_edge_cycle(G, heuristic=False)
424                         with_heuristic = nx.negative_edge_cycle(G, heuristic=True)
425                         assert no_heuristic == with_heuristic
426     def test_negative_cycle(self):
427         G = nx.cycle_graph(5, create_using=nx.DiGraph())
428         G.add_edge(1, 2, weight=-7)
429         for i in range(5):
430             pytest.raises(
431                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
432             )
433             pytest.raises(
434                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
435             )
436             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
437             pytest.raises(
438                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
439             )
440             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
441         G = nx.cycle_graph(5)  # undirected Graph
442         G.add_edge(1, 2, weight=-3)
443         for i in range(5):
444             pytest.raises(
445                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
446             )
447             pytest.raises(
448                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
449             )
450             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
451             pytest.raises(
452                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
453             )
454             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
455         G = nx.DiGraph([(1, 1, {"weight": -1})])
456         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, 1)
457         pytest.raises(
458             nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, 1
459         )
460         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, 1)
461         pytest.raises(
462             nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, 1
463         )
464         pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, 1)
465     def test_find_negative_cycle_longer_cycle(self):
466         G = nx.cycle_graph(5, create_using=nx.DiGraph())
467         nx.add_cycle(G, [3, 5, 6, 7, 8, 9])
468         G.add_edge(1, 2, weight=-30)
469         assert nx.find_negative_cycle(G, 1) == [0, 1, 2, 3, 4, 0]
470         assert nx.find_negative_cycle(G, 7) == [2, 3, 4, 0, 1, 2]
471     def test_find_negative_cycle_no_cycle(self):
472         G = nx.path_graph(5, create_using=nx.DiGraph())
473         pytest.raises(nx.NetworkXError, nx.find_negative_cycle, G, 3)
474     def test_find_negative_cycle_single_edge(self):
475         G = nx.Graph()
476         G.add_edge(0, 1, weight=-1)
477         assert nx.find_negative_cycle(G, 1) == [1, 0, 1]
478     def test_negative_weight(self):
479         G = nx.cycle_graph(5, create_using=nx.DiGraph())
480         G.add_edge(1, 2, weight=-3)
481         assert nx.single_source_bellman_ford_path(G, 0) == {
482             0: [0],
483             1: [0, 1],
484             2: [0, 1, 2],
485             3: [0, 1, 2, 3],
486             4: [0, 1, 2, 3, 4],
487         }
488         assert nx.single_source_bellman_ford_path_length(G, 0) == {
489             0: 0,
490             1: 1,
491             2: -2,
492             3: -1,
493             4: 0,
494         }
495         assert nx.single_source_bellman_ford(G, 0) == (
496             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
497             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3], 4: [0, 1, 2, 3, 4]},
498         )
499         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
500             {0: [], 1: [0], 2: [1], 3: [2], 4: [3]},
501             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
502         )
503         assert nx.goldberg_radzik(G, 0) == (
504             {0: None, 1: 0, 2: 1, 3: 2, 4: 3},
505             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
506         )
507     def test_not_connected(self):
508         G = nx.complete_graph(6)
509         G.add_edge(10, 11)
510         G.add_edge(10, 12)
511         assert nx.single_source_bellman_ford_path(G, 0) == {
512             0: [0],
513             1: [0, 1],
514             2: [0, 2],
515             3: [0, 3],
516             4: [0, 4],
517             5: [0, 5],
518         }
519         assert nx.single_source_bellman_ford_path_length(G, 0) == {
520             0: 0,
521             1: 1,
522             2: 1,
523             3: 1,
524             4: 1,
525             5: 1,
526         }
527         assert nx.single_source_bellman_ford(G, 0) == (
528             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
529             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
530         )
531         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
532             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
533             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
534         )
535         assert nx.goldberg_radzik(G, 0) == (
536             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
537             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
538         )
539         G = nx.complete_graph(6)
540         G.add_edges_from(
541             [
542                 ("A", "B", {"load": 3}),
543                 ("B", "C", {"load": -10}),
544                 ("C", "A", {"load": 2}),
545             ]
546         )
547         assert nx.single_source_bellman_ford_path(G, 0, weight="load") == {
548             0: [0],
549             1: [0, 1],
550             2: [0, 2],
551             3: [0, 3],
552             4: [0, 4],
553             5: [0, 5],
554         }
555         assert nx.single_source_bellman_ford_path_length(G, 0, weight="load") == {
556             0: 0,
557             1: 1,
558             2: 1,
559             3: 1,
560             4: 1,
561             5: 1,
562         }
563         assert nx.single_source_bellman_ford(G, 0, weight="load") == (
564             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
565             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
566         )
567         assert nx.bellman_ford_predecessor_and_distance(G, 0, weight="load") == (
568             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
569             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
570         )
571         assert nx.goldberg_radzik(G, 0, weight="load") == (
572             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
573             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
574         )
575     def test_multigraph(self):
576         assert nx.bellman_ford_path(self.MXG, "s", "v") == ["s", "x", "u", "v"]
577         assert nx.bellman_ford_path_length(self.MXG, "s", "v") == 9
578         assert nx.single_source_bellman_ford_path(self.MXG, "s")["v"] == [
579             "s",
580             "x",
581             "u",
582             "v",
583         ]
584         assert nx.single_source_bellman_ford_path_length(self.MXG, "s")["v"] == 9
585         D, P = nx.single_source_bellman_ford(self.MXG, "s", target="v")
586         assert D == 9
587         assert P == ["s", "x", "u", "v"]
588         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG, "s")
589         assert P["v"] == ["u"]
590         assert D["v"] == 9
591         P, D = nx.goldberg_radzik(self.MXG, "s")
592         assert P["v"] == "u"
593         assert D["v"] == 9
594         assert nx.bellman_ford_path(self.MXG4, 0, 2) == [0, 1, 2]
595         assert nx.bellman_ford_path_length(self.MXG4, 0, 2) == 4
596         assert nx.single_source_bellman_ford_path(self.MXG4, 0)[2] == [0, 1, 2]
597         assert nx.single_source_bellman_ford_path_length(self.MXG4, 0)[2] == 4
598         D, P = nx.single_source_bellman_ford(self.MXG4, 0, target=2)
599         assert D == 4
600         assert P == [0, 1, 2]
601         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG4, 0)
602         assert P[2] == [1]
603         assert D[2] == 4
604         P, D = nx.goldberg_radzik(self.MXG4, 0)
605         assert P[2] == 1
606         assert D[2] == 4
607     def test_others(self):
608         assert nx.bellman_ford_path(self.XG, "s", "v") == ["s", "x", "u", "v"]
609         assert nx.bellman_ford_path_length(self.XG, "s", "v") == 9
610         assert nx.single_source_bellman_ford_path(self.XG, "s")["v"] == [
611             "s",
612             "x",
613             "u",
614             "v",
615         ]
616         assert nx.single_source_bellman_ford_path_length(self.XG, "s")["v"] == 9
617         D, P = nx.single_source_bellman_ford(self.XG, "s", target="v")
618         assert D == 9
619         assert P == ["s", "x", "u", "v"]
620         (P, D) = nx.bellman_ford_predecessor_and_distance(self.XG, "s")
621         assert P["v"] == ["u"]
622         assert D["v"] == 9
623         (P, D) = nx.goldberg_radzik(self.XG, "s")
624         assert P["v"] == "u"
625         assert D["v"] == 9
626     def test_path_graph(self):
627         G = nx.path_graph(4)
628         assert nx.single_source_bellman_ford_path(G, 0) == {
629             0: [0],
630             1: [0, 1],
631             2: [0, 1, 2],
632             3: [0, 1, 2, 3],
633         }
634         assert nx.single_source_bellman_ford_path_length(G, 0) == {
635             0: 0,
636             1: 1,
637             2: 2,
638             3: 3,
639         }
640         assert nx.single_source_bellman_ford(G, 0) == (
641             {0: 0, 1: 1, 2: 2, 3: 3},
642             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3]},
643         )
644         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
645             {0: [], 1: [0], 2: [1], 3: [2]},
646             {0: 0, 1: 1, 2: 2, 3: 3},
647         )
648         assert nx.goldberg_radzik(G, 0) == (
649             {0: None, 1: 0, 2: 1, 3: 2},
650             {0: 0, 1: 1, 2: 2, 3: 3},
651         )
652         assert nx.single_source_bellman_ford_path(G, 3) == {
653             0: [3, 2, 1, 0],
654             1: [3, 2, 1],
655             2: [3, 2],
656             3: [3],
657         }
658         assert nx.single_source_bellman_ford_path_length(G, 3) == {
659             0: 3,
660             1: 2,
661             2: 1,
662             3: 0,
663         }
664         assert nx.single_source_bellman_ford(G, 3) == (
665             {0: 3, 1: 2, 2: 1, 3: 0},
666             {0: [3, 2, 1, 0], 1: [3, 2, 1], 2: [3, 2], 3: [3]},
667         )
668         assert nx.bellman_ford_predecessor_and_distance(G, 3) == (
669             {0: [1], 1: [2], 2: [3], 3: []},
670             {0: 3, 1: 2, 2: 1, 3: 0},
671         )
672         assert nx.goldberg_radzik(G, 3) == (
673             {0: 1, 1: 2, 2: 3, 3: None},
674             {0: 3, 1: 2, 2: 1, 3: 0},
675         )
676     def test_4_cycle(self):
677         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
678         dist, path = nx.single_source_bellman_ford(G, 0)
679         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
680         assert path[0] == [0]
681         assert path[1] == [0, 1]
682         assert path[2] in [[0, 1, 2], [0, 3, 2]]
683         assert path[3] == [0, 3]
684         pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0)
685         assert pred[0] == []
686         assert pred[1] == [0]
687         assert pred[2] in [[1, 3], [3, 1]]
688         assert pred[3] == [0]
689         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
690         pred, dist = nx.goldberg_radzik(G, 0)
691         assert pred[0] is None
692         assert pred[1] == 0
693         assert pred[2] in [1, 3]
694         assert pred[3] == 0
695         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
696     def test_negative_weight_bf_path(self):
697         G = nx.DiGraph()
698         G.add_nodes_from("abcd")
699         G.add_edge("a", "d", weight=0)
700         G.add_edge("a", "b", weight=1)
701         G.add_edge("b", "c", weight=-3)
702         G.add_edge("c", "d", weight=1)
703         assert nx.bellman_ford_path(G, "a", "d") == ["a", "b", "c", "d"]
704         assert nx.bellman_ford_path_length(G, "a", "d") == -1
705     def test_zero_cycle_smoke(self):
706         D = nx.DiGraph()
707         D.add_weighted_edges_from([(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 1, -2)])
708         nx.bellman_ford_path(D, 1, 3)
709         nx.dijkstra_path(D, 1, 3)
710         nx.bidirectional_dijkstra(D, 1, 3)
711 class TestJohnsonAlgorithm(WeightedTestBase):
712     def test_single_node_graph(self):
713         with pytest.raises(nx.NetworkXError):
714             G = nx.DiGraph()
715             G.add_node(0)
716             nx.johnson(G)
717     def test_negative_cycle(self):
718         G = nx.DiGraph()
719         G.add_weighted_edges_from(
720             [
721                 ("0", "3", 3),
722                 ("0", "1", -5),
723                 ("1", "0", -5),
724                 ("0", "2", 2),
725                 ("1", "2", 4),
726                 ("2", "3", 1),
727             ]
728         )
729         pytest.raises(nx.NetworkXUnbounded, nx.johnson, G)
730         G = nx.Graph()
731         G.add_weighted_edges_from(
732             [
733                 ("0", "3", 3),
734                 ("0", "1", -5),
735                 ("1", "0", -5),
736                 ("0", "2", 2),
737                 ("1", "2", 4),
738                 ("2", "3", 1),
739             ]
740         )
741         pytest.raises(nx.NetworkXUnbounded, nx.johnson, G)
742     def test_negative_weights(self):
743         G = nx.DiGraph()
744         G.add_weighted_edges_from(
745             [("0", "3", 3), ("0", "1", -5), ("0", "2", 2), ("1", "2", 4), ("2", "3", 1)]
746         )
747         paths = nx.johnson(G)
748         assert paths == {
749             "1": {"1": ["1"], "3": ["1", "2", "3"], "2": ["1", "2"]},
750             "0": {
751                 "1": ["0", "1"],
752                 "0": ["0"],
753 <a name="0"></a>                "3": ["0", "1", "2", "3"],
754                 "2": ["0", "1", "2"],
755             },
756             "3": {<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"3": ["3"]},
757             "2": {"3": ["2", "3"], "2": ["2"]},
758         }
759     def test_unweighted_graph(self):
760         with pytest.raises(nx.NetworkXError):
761             G = nx.path_graph(</b></font>5)
762             nx.johnson(G)
763     def test_graphs(self):
764         validate_path(self.XG, "s", "v", 9, nx.johnson(self.XG)["s"]["v"])
765         validate_path(self.MXG, "s", "v", 9, nx.johnson(self.MXG)["s"]["v"])
766         validate_path(self.XG2, 1, 3, 4, nx.johnson(self.XG2)[1][3])
767         validate_path(self.XG3, 0, 3, 15, nx.johnson(self.XG3)[0][3])
768         validate_path(self.XG4, 0, 2, 4, nx.johnson(self.XG4)[0][2])
769         validate_path(self.MXG4, 0, 2, 4, nx.johnson(self.MXG4)[0][2])
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
