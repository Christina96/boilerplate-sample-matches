<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for __init___43.py &amp; test_virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for __init___43.py &amp; test_virt_1.py
      </h3>
<h1 align="center">
        2.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>__init___43.py (7.6578817%)<th>test_virt_1.py (1.8335516%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(117-137)<td><a href="#" name="0">(558-563)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(896-900)<td><a href="#" name="1">(5595-5599)</a><td align="center"><font color="#b90000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(763-766)<td><a href="#" name="2">(1745-1759)</a><td align="center"><font color="#ad0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(7-22)<td><a href="#" name="3">(8-25)</a><td align="center"><font color="#ad0000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(788-801)<td><a href="#" name="4">(5998-6005)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(214-216)<td><a href="#" name="5">(280-299)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(718-725)<td><a href="#" name="6">(110-116)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(618-622)<td><a href="#" name="7">(1813-1837)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(546-553)<td><a href="#" name="8">(1404-1416)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(330-335)<td><a href="#" name="9">(1363-1376)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(308-310)<td><a href="#" name="10">(6840-6844)</a><td align="center"><font color="#8b0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___43.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import hashlib
2 import logging
3 import os
4 import shutil
5 import sys
6 import tarfile
7 import salt.cache
8 import salt.client
9 import salt.config
10 import salt.loader
11 import salt.syspaths as syspaths
12 import salt.utils.files
13 import salt.utils.http as http
14 import salt.utils.path
15 import</b></font> salt.utils.platform
16 import salt.utils.win_functions
17 import salt.utils.yaml
18 from salt.template import compile_template
19 try:
20     import pwd
21     import grp
22 except ImportError:
23     pass
24 log = logging.getLogger(__name__)
25 FILE_TYPES = ("c", "d", "g", "l", "r", "s", "m")
26 class SPMException(Exception):
27 class SPMInvocationError(SPMException):
28 class SPMPackageError(SPMException):
29 class SPMDatabaseError(SPMException):
30 class SPMOperationCanceled(SPMException):
31 class SPMClient:
32     def __init__(self, ui, opts=None):  # pylint: disable=W0231
33         self.ui = ui
34         if not opts:
35             opts = salt.config.spm_config(os.path.join(syspaths.CONFIG_DIR, "spm"))
36         self.opts = opts
37         self.db_prov = self.opts.get("spm_db_provider", "sqlite3")
38         self.files_prov = self.opts.get("spm_files_provider", "local")
39         self._prep_pkgdb()
40         self._prep_pkgfiles()
41         self.db_conn = None
42         self.files_conn = None
43         self._init()
44     def _prep_pkgdb(self):
45         self.pkgdb = salt.loader.pkgdb(self.opts)
46     def _prep_pkgfiles(self):
47         self.pkgfiles = salt.loader.pkgfiles(self.opts)
48     def _init(self):
49         if not self.db_conn:
50             self.db_conn = self._pkgdb_fun("init")
51         if not self.files_conn:
52             self.files_conn = self._pkgfiles_fun("init")
53     def _close(self):
54         if self.db_conn:
55             self.db_conn.close()
56     def run(self, args):
57         try:
58             if command == "install":
59                 self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._install(args)
60             elif command == "local":
61                 self._local(args)
62             elif command == "repo":
63                 self._repo(args)
64             elif command == "remove":
65                 self._remove(args)
66             elif command == "build":
67                 self._build(args)
68             elif command == "update_repo":
69                 self._download_repo_metadata(args)
70             elif command == "create_repo":
71                 self._create_repo(args)
72             elif command == "files":
73                 self._list_files(args)
74             elif command == "info":
75                 self._info(args)
76             elif command == "list":
77                 self._list(args)
78             elif command == "close":
79                 self._close(</b></font>)
80             else:
81                 raise SPMInvocationError("Invalid command '{}'".format(command))
82         except SPMException as exc:
83             self.ui.error(str(exc))
84     def _pkgdb_fun(self, func, *args, **kwargs):
85         try:
86             return getattr(getattr(self.pkgdb, self.db_prov), func)(*args, **kwargs)
87         except AttributeError:
88             return self.pkgdb["{}.{}".format(self.db_prov, func)](*args, **kwargs)
89     def _pkgfiles_fun(self, func, *args, **kwargs):
90         try:
91             return getattr(getattr(self.pkgfiles, self.files_prov), func)(
92                 *args, **kwargs
93             )
94         except AttributeError:
95             return self.pkgfiles["{}.{}".format(self.files_prov, func)](*args, **kwargs)
96     def _list(self, args):
97         args.pop(0)
98         command = args[0]
99         if command == "packages":
100             self._list_packages(args)
101         elif command == "files":
102             self._list_files(args)
103         elif command == "repos":
104             self._repo_list(args)
105         else:
106             raise SPMInvocationError("Invalid list command '{}'".format(command))
107     def _local(self, args):
108         args.pop(0)
109         command = args[0]
110         if command == "install":
111             self._local_install(args)
112         elif command == "files":
113             self._local_list_files(args)
114         elif command == "info":
115             self._local_info(args)
116         else:
117             raise SPMInvocationError("Invalid local command '{}'".format(command))
118     def _repo(self, args):
119         args.pop(0)
120         command = args[0]
121         if command == "list":
122             self._repo_list(args)
123         elif command == "packages":
124             self._repo_packages(args)
125         elif command == "search":
126             self._repo_packages(args, search=True)
127         elif command == "update":
128             self._download_repo_metadata(args)
129         elif command == "create":
130             self._create_repo(args)
131         else:
132             raise SPMInvocationError("Invalid repo command '{}'".format(command))
133     def _repo_packages(self, args, search=False):
134         packages = []
135         for repo in repo_metadata:
136             for pkg in repo_metadata[repo]["packages"]:
137                 if args<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[1] in pkg:
138                     version = repo_metadata[repo]["packages"][pkg]["info"]["version"]
139                     release = repo_metadata[repo]["packages"][pkg]["info"][</b></font>"release"]
140                     packages.append((pkg, version, release, repo))
141         for pkg in sorted(packages):
142             self.ui.status("{}\t{}-{}\t{}".format(pkg[0], pkg[1], pkg[2], pkg[3]))
143         return packages
144     def _repo_list(self, args):
145         repo_metadata = self._get_repo_metadata()
146         for repo in repo_metadata:
147             self.ui.status(repo)
148     def _install(self, args):
149         if len(args) &lt; 2:
150             raise SPMInvocationError("A package must be specified")
151         caller_opts = self.opts.copy()
152         caller_opts["file_client"] = "local"
153         self.caller = salt.client.Caller(mopts=caller_opts)
154         self.client = salt.client.get_local_client(self.opts["conf_file"])
155         cache = salt.cache.Cache(self.opts)
156         packages = args[1:]
157         file_map = {}
158         optional = []
159         recommended = []
160         to_install = []
161         for pkg in packages:
162             if pkg.endswith(".spm"):
163                 if self._pkgfiles_fun("path_exists", pkg):
164                     comps = pkg.split("-")
165                     comps = os.path.split("-".join(comps[:-2]))
166                     pkg_name = comps[-1]
167                     formula_tar = tarfile.open(pkg, "r:bz2")
168                     formula_ref = formula_tar.extractfile("{}/FORMULA".format(pkg_name))
169                     formula_def = salt.utils.yaml.safe_load(formula_ref)
170                     file_map[pkg_name] = pkg
171                     to_, op_, re_ = self._check_all_deps(
172                         pkg_name=pkg_name, pkg_file=pkg, formula_def=formula_def
173                     )
174                     to_install.extend(to_)
175                     optional.extend(op_)
176                     recommended.extend(re_)
177                     formula_tar.close()
178                 else:
179                     raise SPMInvocationError("Package file {} not found".format(pkg))
180             else:
181                 to_, op_, re_ = self._check_all_deps(pkg_name=pkg)
182                 to_install.extend(to_)
183                 optional.extend(op_)
184                 recommended.extend(re_)
185         optional = set(filter(len, optional))
186         if optional:
187             self.ui.status(
188                 "The following dependencies are optional:\n\t{}\n".format(
189                     "\n\t".join(optional)
190                 )
191             )
192         recommended = set(filter(len, recommended))
193         if recommended:
194             self.ui.status(
195                 "The following dependencies are recommended:\n\t{}\n".format(
196                     "\n\t".join(recommended)
197                 )
198             )
199         to_install = set(filter(len, to_install))
200         msg = "Installing packages:\n\t{}\n".format("\n\t".join(to_install))
201         if not self.opts["assume_yes"]:
202             self.ui.confirm(msg)
203         repo_metadata = self._get_repo_metadata()
204         dl_list = {}
205         for package in to_install:
206             if package in file_map:
207                 self._install_indv_pkg(package, file_map[package])
208             else:
209                 for repo in repo_metadata:
210                     if package in repo_info["packages"]:
211                         dl_package = False
212                         repo_ver <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= repo_info["packages"][package]["info"]["version"]
213                         repo_rel = repo_info["packages"][package]["info"]["release"]
214                         repo_url = repo_info[</b></font>"info"]["url"]
215                         if package in dl_list:
216                             if repo_ver == dl_list[package]["version"]:
217                                 if repo_rel &gt; dl_list[package]["release"]:
218                                     dl_package = True
219                                 elif repo_rel == dl_list[package]["release"]:
220                                     if dl_list[package]["source"].startswith("file://"):
221                                         if not repo_url.startswith("file://"):
222                                             dl_package = True
223                             elif repo_ver &gt; dl_list[package]["version"]:
224                                 dl_package = True
225                         else:
226                             dl_package = True
227                         if dl_package is True:
228                             cache_path = os<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.join(self.opts["spm_cache_dir"], repo)
229                             dl_url = "{}/{}".format(
230                                 repo_info["info"]["url"],
231                                 repo_info["packages"][</b></font>package]["filename"],
232                             )
233                             out_file = os.path.join(
234                                 cache_path, repo_info["packages"][package]["filename"]
235                             )
236                             dl_list[package] = {
237                                 "version": repo_ver,
238                                 "release": repo_rel,
239                                 "source": dl_url,
240                                 "dest_dir": cache_path,
241                                 "dest_file": out_file,
242                             }
243         for package in dl_list:
244             dl_url = dl_list[package]["source"]
245             cache_path = dl_list[package]["dest_dir"]
246             out_file = dl_list[package]["dest_file"]
247             if not os.path.exists(cache_path):
248                 os.makedirs(cache_path)
249             if dl_url.startswith("file://"):
250                 dl_url = dl_url.replace("file://", "")
251                 shutil.copyfile(dl_url, out_file)
252             else:
253                 with salt.utils.files.fopen(out_file, "wb") as outf:
254                     outf.write(
255                         self._query_http(dl_url, repo_info["info"], decode_body=False)
256                     )
257         for package in dl_list:
258             out_file = dl_list[package]["dest_file"]
259             self._install_indv_pkg(package, out_file)
260         return
261     def _local_install(self, args, pkg_name=None):
262         if len(args) &lt; 2:
263             raise SPMInvocationError("A package file must be specified")
264         self._install(args)
265     def _check_all_deps(self, pkg_name=None, pkg_file=None, formula_def=None):
266         if pkg_file and not os.path.exists(pkg_file):
267             raise SPMInvocationError("Package file {} not found".format(pkg_file))
268         self.repo_metadata = self._get_repo_metadata()
269         if not formula_def:
270             for repo in self.repo_metadata:
271                 if not isinstance(self.repo_metadata[repo]["packages"], dict):
272                     continue
273                 if pkg_name in self.repo_metadata[repo]["packages"]:
274                     formula_def = self.repo_metadata[repo]["packages"][pkg_name]["info"]
275         if not formula_def:
276             raise SPMInvocationError("Unable to read formula for {}".format(pkg_name))
277         pkg_info = self._pkgdb_fun("info", pkg_name, self.db_conn)
278         pkgs_to_install = []
279         if pkg_info is None or self.opts["force"]:
280             pkgs_to_install.append(pkg_name)
281         elif pkg_info is not None and not self.opts["force"]:
282             raise SPMPackageError(
283                 "Package {} already installed, not installing again".format(
284                     formula_def["name"]
285                 )
286             )
287         optional_install = []
288         recommended_install = []
289         if (
290             "dependencies" in formula_def
291             or "optional" in formula_def
292             or "recommended" in formula_def
293         ):
294             self.avail_pkgs = {}
295             for repo in self.repo_metadata:
296                 if not isinstance(self.repo_metadata[repo]["packages"], dict):
297                     continue
298                 for pkg in self.repo_metadata[repo]["packages"]:
299                     self.avail_pkgs[pkg] = repo
300             needs, unavail, optional, recommended = self._resolve_deps(formula_def)
301             if len(unavail) &gt; 0:
302                 raise SPMPackageError(
303                     "Cannot install {}, the following dependencies are needed:\n\n{}".format(
304                         formula_def["name"], "\n".join(unavail)
305                     )
306                 )
307             if optional:
308                 optional_install.extend(optional)
309                 for dep_pkg in optional:
310                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
311                     msg = dep_pkg
312                     if isinstance(pkg_info, dict):
313                         msg = "{} [Installed]".format(dep_pkg)
314                     optional_install.append(msg)
315             if recommended:
316                 recommended_install.extend(recommended)
317                 for dep_pkg in recommended:
318                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
319                     msg = dep_pkg
320                     if isinstance(pkg_info, dict):
321                         msg = "{} [Installed]".format(dep_pkg)
322                     recommended_install.append(msg)
323             if needs:
324                 pkgs_to_install.extend(needs)
325                 for dep_pkg in needs:
326                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
327                     msg = dep_pkg
328                     if isinstance(pkg_info, dict):
329                         msg = "{} [Installed]".format(dep_pkg)
330         return pkgs_to_install, optional_install, recommended_install
331     def _install_indv_pkg(self, pkg_name, pkg_file):
332         self.ui.status("... installing {}".format(pkg_name))
333         formula_tar = tarfile.open(pkg_file, "r:bz2")
334         formula_ref = formula_tar.extractfile("{}/FORMULA".format(pkg_name))
335         formula_def = salt.utils.yaml.safe_load(formula_ref)
336         for field in ("version", "release", "summary", "description"):
337             if field not in formula_def:
338                 raise SPMPackageError(
339                     "Invalid package: the {} was not found".format(field)
340                 )
341         pkg_files = formula_tar.getmembers()
342         existing_files = self._pkgfiles_fun(
343             "check_existing", pkg_name, pkg_files, formula_def
344         )
345         if existing_files and not self.opts["force"]:
346             raise SPMPackageError(
347                 "Not installing {} due to existing files:\n\n{}".format(
348                     pkg_name, "\n".join(existing_files)
349                 )
350             )
351         self._pkgdb_fun("register_pkg", pkg_name, formula_def, self.db_conn)
352         if "pre_local_state" in formula_def:
353             high_data = self._render(formula_def["pre_local_state"], formula_def)
354             ret = self.caller.cmd("state.high", data=high_data)
355         if "pre_tgt_state" in formula_def:
356             log.debug("Executing pre_tgt_state script")
357             high_data = self._render(formula_def["pre_tgt_state"]["data"], formula_def)
358             tgt = formula_def["pre_tgt_state"]["tgt"]
359             ret = self.client.run_job(
360                 tgt=formula_def["pre_tgt_state"]["tgt"],
361                 fun="state.high",
362                 tgt_type=formula_def["pre_tgt_state"].get("tgt_type", "glob"),
363                 timout=self.opts["timeout"],
364                 data=high_data,
365             )
366         if salt.utils.platform.is_windows():
367             uname = gname = salt.utils.win_functions.get_current_user()
368             uname_sid = salt.utils.win_functions.get_sid_from_name(uname)
369             uid = self.opts.get("spm_uid", uname_sid)
370             gid = self.opts.get("spm_gid", uname_sid)
371         else:
372             uid = self.opts.get("spm_uid", os.getuid())
373             gid = self.opts.get("spm_gid", os.getgid())
374             uname = pwd.getpwuid(uid)[0]
375             gname = grp.getgrgid(gid)[0]
376         for member in pkg_files:
377             member.uid = uid
378             member.gid = gid
379             member.uname = uname
380             member.gname = gname
381             out_path = self._pkgfiles_fun(
382                 "install_file",
383                 pkg_name,
384                 formula_tar,
385                 member,
386                 formula_def,
387                 self.files_conn,
388             )
389             if out_path is not False:
390                 if member.isdir():
391                     digest = ""
392                     self._verbose(
393                         "Installing file {} to {}".format(member.name, out_path),
394                         log<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.trace,
395                     )
396                     file_hash = hashlib.sha1()
397                     digest = self._pkgfiles_fun(
398                         "hash_file",
399                         os.path.join(out_path, member.name),
400                         file_hash,
401                         self.</b></font>files_conn,
402                     )
403                 self._pkgdb_fun(
404                     "register_file", pkg_name, member, out_path, digest, self.db_conn
405                 )
406         if "post_local_state" in formula_def:
407             log.debug("Executing post_local_state script")
408             high_data = self._render(formula_def["post_local_state"], formula_def)
409             self.caller.cmd("state.high", data=high_data)
410         if "post_tgt_state" in formula_def:
411             log.debug("Executing post_tgt_state script")
412             high_data = self._render(formula_def["post_tgt_state"]["data"], formula_def)
413             tgt = formula_def["post_tgt_state"]["tgt"]
414             ret = self.client.run_job(
415                 tgt=formula_def["post_tgt_state"]["tgt"],
416                 fun="state.high",
417                 tgt_type=formula_def["post_tgt_state"].get("tgt_type", "glob"),
418                 timout=self.opts["timeout"],
419                 data=high_data,
420             )
421         formula_tar.close()
422     def _resolve_deps(self, formula_def):
423         pkg_info = self.pkgdb["{}.info".format(self.db_prov)](formula_def["name"])
424         if not isinstance(pkg_info, dict):
425             pkg_info = {}
426         can_has = {}
427         cant_has = []
428         if "dependencies" in formula_def and formula_def["dependencies"] is None:
429             formula_def["dependencies"] = ""
430         for dep in formula_def.get("dependencies", "").split(","):
431             dep = dep.strip()
432             if not dep:
433                 continue
434             if self.pkgdb["{}.info".format(self.db_prov)](dep):
435                 continue
436             if dep in self.avail_pkgs:
437                 can_has[dep] = self.avail_pkgs[dep]
438             else:
439                 cant_has.append(dep)
440         optional = formula_def.get("optional", "").split(",")
441         recommended = formula_def.get("recommended", "").split(",")
442         inspected = []
443         to_inspect = can_has.copy()
444         while len(to_inspect) &gt; 0:
445             dep = next(iter(to_inspect.keys()))
446             del to_inspect[dep]
447             if dep in inspected:
448                 continue
449             repo_contents = self.repo_metadata.get(can_has[dep], {})
450             repo_packages = repo_contents<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get("packages", {})
451             dep_formula = repo_packages.get(dep, {}).get("info", {})
452             also_can, also_cant, opt_dep, rec_dep = self._resolve_deps(dep_formula)
453             can_has.update(</b></font>also_can)
454             cant_has = sorted(set(cant_has + also_cant))
455             optional = sorted(set(optional + opt_dep))
456             recommended = sorted(set(recommended + rec_dep))
457         return can_has, cant_has, optional, recommended
458     def _traverse_repos(self, callback, repo_name=None):
459         repo_files = []
460         if os.path.exists(self.opts["spm_repos_config"]):
461             repo_files.append(self.opts["spm_repos_config"])
462         for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(
463             "{}.d".format(self.opts["spm_repos_config"])
464         ):
465             for repo_file in filenames:
466                 if not repo_file.endswith(".repo"):
467                     continue
468                 repo_files.append(repo_file)
469         for repo_file in repo_files:
470             repo_path = "{}.d/{}".format(self.opts["spm_repos_config"], repo_file)
471             with salt.utils.files.fopen(repo_path) as rph:
472                 repo_data = salt.utils.yaml.safe_load(rph)
473                 for repo in repo_data:
474                     if repo_data[repo].get("enabled", True) is False:
475                         continue
476                     if repo_name is not None and repo != repo_name:
477                         continue
478                     callback(repo, repo_data[repo])
479     def _query_http(self, dl_path, repo_info, decode_body=True):
480         query = None
481         response = None
482         try:
483             if "username" in repo_info:
484                 try:
485                     if "password" in repo_info:
486                         query = http.query(
487                             dl_path,
488                             text=True,
489                             username=repo_info["username"],
490                             password=repo_info["password"],
491                             decode_body=decode_body,
492                         )
493                     else:
494                         raise SPMException(
495                             "Auth defined, but password is not set for username: '{}'".format(
496                                 repo_info["username"]
497                             )
498                         )
499                 except SPMException as exc:
500                     self.ui.error(str(exc))
501             else:
502                 query = http.query(dl_path, text=True, decode_body=decode_body)
503         except SPMException as exc:
504             self.ui.error(str(exc))
505         try:
506             if query:
507                 if "SPM-METADATA" in dl_path:
508                     response = salt.utils.yaml.safe_load(query.get("text", "{}"))
509                 else:
510                     response = query.get("text")
511             else:
512                 raise SPMException("Response is empty, please check for Errors above.")
513         except SPMException as exc:
514             self.ui.error(str(exc))
515         return response
516     def _download_repo_metadata(self, args):
517         cache = salt.cache.Cache(self.opts, self.opts["spm_cache_dir"])
518         def _update_metadata(repo, repo_info):
519             dl_path = "{}/SPM-METADATA".format(repo_info["url"])
520             if dl_path.startswith("file://"):
521                 dl_path = dl_path.replace("file://", "")
522                 with salt.utils.files.fopen(dl_path, "r") as rpm:
523                     metadata = salt.utils.yaml.safe_load(rpm)
524             else:
525                 metadata = self._query_http(dl_path, repo_info)
526             cache.store(".", repo, metadata)
527         repo_name = args<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[1] if len(args) &gt; 1 else None
528         self._traverse_repos(_update_metadata, repo_name)
529     def _get_repo_metadata(self):
530         cache = salt.cache.Cache(self.opts, self.</b></font>opts["spm_cache_dir"])
531         metadata = {}
532         def _read_metadata(repo, repo_info):
533             if cache.updated(".", repo) is None:
534                 log.warning("Updating repo metadata")
535                 self._download_repo_metadata({})
536             metadata[repo] = {
537                 "info": repo_info,
538                 "packages": cache.fetch(".", repo),
539             }
540         self._traverse_repos(_read_metadata)
541         return metadata
542     def _create_repo(self, args):
543         if len(args) &lt; 2:
544             raise SPMInvocationError("A path to a directory must be specified")
545         if args[1] == ".":
546             repo_path = os.getcwdu()
547         else:
548             repo_path = args[1]
549         old_files = []
550         repo_metadata = {}
551         for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(repo_path):
552             for spm_file in filenames:
553                 if not spm_file.endswith(".spm"):
554                     continue
555                 if not tarfile.is_tarfile(spm_path):
556                     continue
557                 comps <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= spm_file.split("-")
558                 spm_name = "-".join(comps[:-2])
559                 spm_fh = tarfile.open(spm_path, "r:bz2")
560                 formula_handle = spm_fh.extractfile("{}/FORMULA".format(</b></font>spm_name))
561                 formula_conf = salt.utils.yaml.safe_load(formula_handle.read())
562                 use_formula = True
563                 if spm_name in repo_metadata:
564                     cur_info = repo_metadata[spm_name]["info"]
565                     new_info = formula_conf
566                     if int(new_info["version"]) == int(cur_info["version"]):
567                         if int(new_info["release"]) &lt; int(cur_info["release"]):
568                             use_formula = False
569                     elif int(new_info["version"]) &lt; int(cur_info["version"]):
570                         use_formula = False
571                     if use_formula is True:
572                             "%s %s-%s had been added, but %s-%s will replace it",
573                             spm_name,
574                             cur_info<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["version"],
575                             cur_info["release"],
576                             new_info["version"],
577                             new_info["release"],
578                         )
579                         old_files.append(repo_metadata[spm_name]["filename"])
580                     else:
581                         log.debug(
582                             "%s %s-%s has been found, but is older than %s-%s",
583                             spm_name,
584                             new_info["version"],
585                             new_info["release"],
586                             cur_info[</b></font>"version"],
587                             cur_info["release"],
588                         )
589                         old_files.append(spm_file)
590                 if use_formula is True:
591                     log.debug(
592                         "adding %s-%s-%s to the repo",
593                         formula_conf["name"],
594                         formula_conf["version"],
595                         formula_conf["release"],
596                     )
597                     repo_metadata[spm_name] = {
598                         "info": formula_conf.copy(),
599                     }
600                     repo_metadata[spm_name]["filename"] = spm_file
601         metadata_filename = "{}/SPM-METADATA".format(repo_path)
602         with salt.utils.files.fopen(metadata_filename, "w") as mfh:
603             salt.utils.yaml.safe_dump(
604                 repo_metadata,
605                 mfh,
606                 indent=4,
607                 canonical=False,
608                 default_flow_style=False,
609             )
610         log.debug("Wrote %s", metadata_filename)
611         for file_ in old_files:
612             if self.opts["spm_repo_dups"] == "ignore":
613                 log.debug("%s will be left in the directory", file_)
614             elif self.opts["spm_repo_dups"] == "archive":
615                 if not os.path.exists("./archive"):
616                     try:
617                         os.makedirs("./archive")
618                         log.debug("%s has been archived", file_)
619                     except OSError:
620                         log.error("Unable to create archive directory")
621                 try:
622                     shutil.move(file_, "./archive")
623                 except OSError:
624                     log.error("Unable to archive %s", file_)
625             elif self.opts["spm_repo_dups"] == "delete":
626                 try:
627                     os.remove(file_)
628                     log.debug("%s has been deleted", file_)
629                 except OSError:
630                     log.error("Unable to delete %s", file_)
631                 except OSError:  # pylint: disable=duplicate-except
632                     pass
633     def _remove(self, args):
634         if len(args) &lt; 2:
635             raise SPMInvocationError("A package must be specified")
636         packages = args[1:]
637         msg = "Removing packages:\n\t{}".format("\n\t".join(packages))
638         if not self.opts["assume_yes"]:
639             self.ui.confirm(msg)
640         for package in packages:
641             self.ui.status("... removing {}".format(package))
642             if not self._pkgdb_fun("db_exists", self.opts["spm_db"]):
643                 raise SPMDatabaseError(
644                     "No database at {}, cannot remove {}".format(
645                         self.opts["spm_db"], package
646                     )
647                 )
648             pkg_info = self._pkgdb_fun("info", package, self.db_conn)
649             if pkg_info is None:
650                 raise SPMInvocationError("Package {} not installed".format(package))
651             files = self._pkgdb_fun("list_files", package, self.db_conn)
652             dirs = []
653             for filerow in files:
654                 if self._pkgfiles_fun("path_isdir", filerow[0]):
655                     dirs.append(filerow[0])
656                     continue
657                 file_hash = hashlib.sha1()
658                     "hash_file", filerow[0], file_hash, self.files_conn
659                 )
660                 if filerow<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[1] == digest:
661                     self._verbose("Removing file {}".format(filerow[0]), log.trace)
662                     self._pkgfiles_fun("remove_file", filerow[0], self.files_conn)
663                 else:
664                     self._verbose("Not removing file {}".format(filerow[</b></font>0]), log.trace)
665                 self._pkgdb_fun("unregister_file", filerow[0], package, self.db_conn)
666             for dir_ in sorted(dirs, reverse=True):
667                 self._pkgdb_fun("unregister_file", dir_, package, self.db_conn)
668                 try:
669                     self._verbose("Removing directory {}".format(dir_), log.trace)
670                     os.rmdir(dir_)
671                 except OSError:
672                     self._verbose(
673                         "Cannot remove directory {}, probably not empty".format(dir_),
674                         log.trace,
675                     )
676             self._pkgdb_fun("unregister_pkg", package, self.db_conn)
677     def _verbose(self, msg, level=log.debug):
678         if self.opts.get("verbose", False) is True:
679             self.ui.status(msg)
680         level(msg)
681     def _local_info(self, args):
682         if len(args) &lt; 2:
683             raise SPMInvocationError("A package filename must be specified")
684         pkg_file = args[1]
685         if not os.path.exists(pkg_file):
686             raise SPMInvocationError("Package file {} not found".format(pkg_file))
687         comps = pkg_file.split("-")
688         comps = "-".join(comps[:-2]).split("/")
689         name = comps[-1]
690         formula_tar = tarfile.open(pkg_file, "r:bz2")
691         formula_ref = formula_tar.extractfile("{}/FORMULA".format(name))
692         formula_def = salt.utils.yaml.safe_load(formula_ref)
693         self.ui.status(self._get_info(formula_def))
694         formula_tar.close()
695     def _info(self, args):
696         if len(args) &lt; 2:
697             raise SPMInvocationError("A package must be specified")
698         package = args[1]
699         pkg_info = self._pkgdb_fun("info", package, self.db_conn)
700         if pkg_info is None:
701             raise SPMPackageError("package {} not installed".format(package))
702         self.ui.status(self._get_info(pkg_info))
703     def _get_info(self, formula_def):
704         fields = (
705             "name",
706             "os",
707             "os_family",
708             "release",
709             "version",
710             "dependencies",
711             "os_dependencies",
712             "os_family_dependencies",
713             "summary",
714             "description",
715         )
716         for item in fields:
717             if item not in formula_def:
718                 formula_def[item] = "None"
719         if "installed" not in formula_def:
720             formula_def["installed"] = "Not installed"
721         return (
722             "Name: {name}\n"
723             "Version: {version}\n"
724             "Release: {release}\n"
725             "Install Date: {installed}\n"
726             "Supported OSes: {os}\n"
727             "Supported OS families: {os_family}\n"
728             "Dependencies: {dependencies}\n"
729             "OS Dependencies: {os_dependencies}\n"
730             "OS Family Dependencies: {os_family_dependencies}\n"
731             "Summary: {summary}\n"
732             "Description:\n"
733             "{description}".format(**formula_def)
734         )
735     def _local_list_files(self, args):
736         if len(args) &lt; 2:
737             raise SPMInvocationError("A package filename must be specified")
738         pkg_file = args[1]
739         if not os.path.exists(pkg_file):
740             raise SPMPackageError("Package file {} not found".format(pkg_file))
741         formula_tar = tarfile.open(pkg_file, "r:bz2")
742         pkg_files = formula_tar.getmembers()
743         for member in pkg_files:
744             self.ui.status(member.name)
745     def _list_packages(self, args):
746         packages = self._pkgdb_fun("list_packages", self.db_conn)
747         for package in packages:
748             if self.opts["verbose"]:
749                 status_msg = ",".join(package)
750             else:
751                 status_msg = package[0]
752             self.ui.status(status_msg)
753     def _list_files(self, args):
754         if len(args) &lt; 2:
755             raise SPMInvocationError("A package name must be specified")
756         package = args[-1]
757         files = self._pkgdb_fun("list_files", package, self.db_conn)
758         if files is None:
759             raise SPMPackageError("package {} not installed".format(package))
760         else:
761             for file_ in files:
762                 if self.opts["verbose"]:
763                     status_msg = ",".join(file_)
764                 else:
765                     status_msg = file_[0]
766                 self.ui.status(status_msg)
767     def _build(self, args):
768         if len(args) &lt; 2:
769             raise SPMInvocationError("A path to a formula must be specified")
770         self.abspath = args[1].rstrip("/")
771         comps = self.abspath.split("/")
772         self.relpath = comps[-1]
773         formula_path = "{}/FORMULA".format(self.abspath)
774         if not os.path.exists(formula_path):
775             raise SPMPackageError("Formula file {} not found".format(formula_path))
776         with salt.utils.files.fopen(formula_path) as fp_:
777             formula_conf = salt.utils.yaml.safe_load(fp_)
778         for field in ("name", "version", "release", "summary", "description"):
779             if field not in formula_conf:
780                 raise SPMPackageError(
781                     "Invalid package: a {} must be defined".format(field)
782                 )
783         out_path = "{}/{}-{}-{}.spm".format(
784             self.opts["spm_build_dir"],
785             formula_conf["name"],
786             formula_conf["version"],
787             formula_conf["release"],
788         )
789         if not os.path.exists(self.opts["spm_build_dir"]):
790             os.mkdir(self.opts["spm_build_dir"])
791         self.formula_conf = formula_conf
792         formula_tar = tarfile.open(out_path, "w:bz2")
793         if "files" in formula_conf:
794             if isinstance(formula_conf["files"], list):
795                 formula_dir = tarfile.TarInfo(formula_conf["name"])
796                 formula_dir.type = tarfile.DIRTYPE
797                 formula_tar.addfile(formula_dir)
798                 for file_ in formula_conf["files"]:
799                     for ftype in FILE_TYPES:
800                         if file_.startswith("{}|".format(ftype)):
801                             file_ = file_.lstrip("{}|".format(ftype))
802                     formula_tar.add(
803                         os.path.join(os.getcwd(), file_),
804                         os.path.join(formula_conf["name"], file_),
805                     )
806         else:
807             try:
808                 formula_tar.add(
809                     formula_path, formula_conf["name"], filter=self._exclude
810                 )
811                 formula_tar.add(
812                     self.abspath, formula_conf["name"], filter=self._exclude
813                 )
814             except TypeError:
815                 formula_tar.add(
816                     formula_path, formula_conf["name"], exclude=self._exclude
817                 )
818                 formula_tar.add(
819                     self.abspath, formula_conf["name"], exclude=self._exclude
820                 )
821         formula_tar.close()
822         self.ui.status("Built package {}".format(out_path))
823     def _exclude(self, member):
824         if isinstance(member, str):
825             return None
826         for item in self.opts["spm_build_exclude"]:
827             if member.name.startswith("{}/{}".format(self.formula_conf["name"], item)):
828                 return None
829             elif member.name.startswith("{}/{}".format(self.abspath, item)):
830                 return None
831         return member
832     def _render(self, data, formula_def):
833         renderer = formula_def.get("renderer", self.opts.get("renderer", "jinja|yaml"))
834         rend = salt.loader.render(self.opts, {})
835         blacklist = self.opts.get("renderer_blacklist")
836         whitelist = self.opts.get("renderer_whitelist")
837         template_vars = formula_def.copy()
838         template_vars["opts"] = self.opts.copy()
839         return compile_template(
840             ":string:",
841             rend,
842             renderer,
843             blacklist,
844             whitelist,
845             input_data=data,
846             **template_vars
847         )
848 class SPMUserInterface:
849     def status(self, msg):
850         raise NotImplementedError()
851     def error(self, msg):
852         raise NotImplementedError()
853     def confirm(self, action):
854         raise NotImplementedError()
855 class SPMCmdlineInterface(SPMUserInterface):
856     def status(self, msg):
857         print(msg)
858     def error(self, msg):
859         print(msg, file=sys.stderr)
860     def confirm(self, action):
861         print(action)
862         res = input("Proceed? [N/y] ")
863         if not res.lower().startswith("y"):
864             raise SPMOperationCanceled("canceled")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import datetime
2 import os
3 import shutil
4 import tempfile
5 import xml.etree.ElementTree as ET
6 import salt.config
7 import salt.modules.config as config
8 import salt.modules.virt as virt
9 import salt.syspaths
10 import salt.utils.yaml
11 from salt.exceptions import CommandExecutionError, SaltInvocationError
12 from tests.support.helpers import dedent
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from</b></font> tests.support.unit import TestCase
16 class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
17     class virDomain(MagicMock):
18     class libvirtError(Exception):
19         def __init__(self, msg):
20             super().__init__(msg)
21             self.msg = msg
22         def get_error_message(self):
23             return self.msg
24 class VirtTestCase(TestCase, LoaderModuleMockMixin):
25     def setup_loader_modules(self):
26         self.mock_libvirt = LibvirtMock()
27         self.mock_conn = MagicMock()
28         self.mock_conn.getStoragePoolCapabilities.return_value = (
29             "&lt;storagepoolCapabilities/&gt;"
30         )
31         self.mock_libvirt.openAuth.return_value = self.mock_conn
32         self.mock_popen = MagicMock()
33         self.addCleanup(delattr, self, "mock_libvirt")
34         self.addCleanup(delattr, self, "mock_conn")
35         self.addCleanup(delattr, self, "mock_popen")
36         self.mock_subprocess = MagicMock()
37         self.mock_subprocess.return_value = (
38             self.mock_subprocess
39         )  # pylint: disable=no-member
40         self.mock_subprocess.Popen.return_value = (
41             self.mock_popen
42         )  # pylint: disable=no-member
43         loader_globals = {
44             "__salt__": {"config.get": config.get, "config.option": config.option},
45             "libvirt": self.mock_libvirt,
46             "subprocess": self.mock_subprocess,
47         }
48         return {virt: loader_globals, config: loader_globals}
49     def set_mock_vm(self, name, xml):
50         self.mock_conn.listDefinedDomains.return_value = [
51             name
52         ]  # pylint: disable=no-member
53         mock_domain = self.mock_libvirt.virDomain()
54         self.mock_conn.lookupByName.return_value = (
55             mock_domain  # pylint: disable=no-member
56         )
57         mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member
58         mock_domain.info.return_value = [
59             4,
60             2048 * 1024,
61             1024 * 1024,
62             2,
63             1234,
64         ]  # pylint: disable=no-member
65         mock_domain.ID.return_value = 1
66         mock_domain.name.return_value = name
67         return mock_domain
68     def assert_equal_unit(self, actual, expected, unit="KiB"):
69         self.assertEqual(actual.get("unit"), unit)
70         self<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(actual.text, str(expected))
71     def test_disk_profile_merge(self):
72         root_dir = os.path.join(salt.syspaths.</b></font>ROOT_DIR, "srv", "salt-images")
73         userdisks = [
74             {"name": "system", "image": "/path/to/image"},
75             {"name": "data", "size": 16384, "format": "raw"},
76         ]
77         disks = virt._disk_profile(self.mock_conn, "default", "kvm", userdisks, "myvm")
78         self.assertEqual(
79             [
80                 {
81                     "name": "system",
82                     "device": "disk",
83                     "size": 8192,
84                     "format": "qcow2",
85                     "model": "virtio",
86                     "filename": "myvm_system.qcow2",
87                     "image": "/path/to/image",
88                     "source_file": "{}{}myvm_system.qcow2".format(root_dir, os.sep),
89                 },
90                 {
91                     "name": "data",
92                     "device": "disk",
93                     "size": 16384,
94                     "format": "raw",
95                     "model": "virtio",
96                     "filename": "myvm_data.raw",
97                     "source_file": "{}{}myvm_data.raw".format(root_dir, os.sep),
98                 },
99             ],
100             disks,
101         )
102     def test_boot_default_dev(self):
103         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
104         nicp = virt._nic_profile("default", "kvm")
105         xml_data = virt._gen_xml(
106             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
107         )
108         root = ET.fromstring(xml_data)
109         self.assertEqual(root.find("os/boot").attrib["dev"], "hd")
110         self.assertEqual(root.find("os/type").attrib["arch"], "x86_64")
111         self.assertEqual(root.find("os/type").text, "hvm")
112     def test_boot_custom_dev(self):
113         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
114         nicp = virt._nic_profile("default", "kvm")
115         xml_data = virt._gen_xml(
116             self.mock_conn,
117             "hello",
118             1,
119             512,
120             diskp,
121             nicp,
122             "kvm",
123             "hvm",
124             "x86_64",
125             boot_dev="cdrom",
126         )
127         root = ET.fromstring(xml_data)
128         self.assertEqual(root.find("os/boot").attrib["dev"], "cdrom")
129     def test_boot_multiple_devs(self):
130         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
131         nicp = virt._nic_profile("default", "kvm")
132         xml_data = virt._gen_xml(
133             self.mock_conn,
134             "hello",
135             1,
136             512,
137             diskp,
138             nicp,
139             "kvm",
140             "hvm",
141             "x86_64",
142             boot_dev="cdrom network",
143         )
144         root = ET.fromstring(xml_data)
145         devs = root.findall(".//boot")
146         self.assertTrue(len(devs) == 2)
147     def test_gen_xml_no_nic(self):
148         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
149         nicp = virt._nic_profile("default", "kvm")
150         xml_data = virt._gen_xml(
151             self.mock_conn,
152             "hello",
153             1,
154             512,
155             diskp,
156             nicp,
157             "kvm",
158             "hvm",
159             "x86_64",
160             serials=[{"type": "pty"}],
161         )
162         root = ET.fromstring(xml_data)
163         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
164     def test_gen_xml_for_telnet_serial(self):
165         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
166         nicp = virt._nic_profile("default", "kvm")
167         xml_data = virt._gen_xml(
168             self.mock_conn,
169             "hello",
170             1,
171             512,
172             diskp,
173             nicp,
174             "kvm",
175             "hvm",
176             "x86_64",
177             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
178         )
179         root = ET.fromstring(xml_data)
180         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
181         self.assertEqual(root.find("devices/serial/source").attrib["service"], "22223")
182         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
183     def test_gen_xml_for_telnet_serial_unspecified_port(self):
184         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
185         nicp = virt._nic_profile("default", "kvm")
186         xml_data = virt._gen_xml(
187             self.mock_conn,
188             "hello",
189             1,
190             512,
191             diskp,
192             nicp,
193             "kvm",
194             "hvm",
195             "x86_64",
196             serials=[{"type": "tcp"}],
197         )
198         root = ET.fromstring(xml_data)
199         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
200         self.assertEqual(root.find("devices/serial/source").attrib["service"], "23023")
201         self.assertFalse("tls" in root.find("devices/serial/source").keys())
202         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
203     def test_gen_xml_for_chardev_types(self):
204         nicp = virt._nic_profile("default", "kvm")
205         xml_data = virt._gen_xml(
206             self<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.mock_conn,
207             "hello",
208             1,
209             512,
210             diskp,
211             nicp,
212             "kvm",
213             "hvm",
214             "x86_64",
215             consoles=[
216                 {"type": "pty", "path": "/dev/pts/2", "target_port": 2},
217                 {"type": "pty", "target_type": "usb-serial"},
218                 {"type": "stdio"},
219                 {"type": "file", "path": "/path/to/serial.log"},
220             ],
221             serials=[
222                 {"type": "pipe", "path": "/tmp/mypipe"},
223                 {"type": "udp", "host": "127.0.0.1", "port": 1234},
224                 {"type": "tcp", "port": 22223, "protocol": "raw", "tls": True},
225                 {"type"</b></font>: "unix", "path": "/path/to/socket"},
226             ],
227         )
228         root = ET.fromstring(xml_data)
229         self.assertEqual(root.find("devices/console[1]").attrib["type"], "pty")
230         self.assertEqual(
231             root.find("devices/console[1]/source").attrib["path"], "/dev/pts/2"
232         )
233         self.assertEqual(root.find("devices/console[1]/target").attrib["port"], "2")
234         self.assertEqual(root.find("devices/console[2]").attrib["type"], "pty")
235         self.assertIsNone(root.find("devices/console[2]/source"))
236         self.assertEqual(
237             root.find("devices/console[2]/target").attrib["type"], "usb-serial"
238         )
239         self.assertEqual(root.find("devices/console[3]").attrib["type"], "stdio")
240         self.assertIsNone(root.find("devices/console[3]/source"))
241         self.assertEqual(root.find("devices/console[4]").attrib["type"], "file")
242         self.assertEqual(
243             root.find("devices/console[4]/source").attrib["path"], "/path/to/serial.log"
244         )
245         self.assertEqual(root.find("devices/serial[1]").attrib["type"], "pipe")
246         self.assertEqual(
247             root.find("devices/serial[1]/source").attrib["path"], "/tmp/mypipe"
248         )
249         self.assertEqual(root.find("devices/serial[2]").attrib["type"], "udp")
250         self.assertEqual(root.find("devices/serial[2]/source").attrib["mode"], "bind")
251         self.assertEqual(
252             root.find("devices/serial[2]/source").attrib["service"], "1234"
253         )
254         self.assertEqual(
255             root.find("devices/serial[2]/source").attrib["host"], "127.0.0.1"
256         )
257         self.assertEqual(root.find("devices/serial[3]").attrib["type"], "tcp")
258         self.assertEqual(root.find("devices/serial[3]/source").attrib["mode"], "bind")
259         self.assertEqual(
260             root.find("devices/serial[3]/source").attrib["service"], "22223"
261         )
262         self.assertEqual(root.find("devices/serial[3]/source").attrib["tls"], "yes")
263         self.assertEqual(root.find("devices/serial[3]/protocol").attrib["type"], "raw")
264         self.assertEqual(root.find("devices/serial[4]").attrib["type"], "unix")
265         self.assertEqual(
266             root.find("devices/serial[4]/source").attrib["path"], "/path/to/socket"
267         )
268     def test_gen_xml_no_nic_console(self):
269         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
270         nicp = virt._nic_profile("default", "kvm")
271         xml_data = virt._gen_xml(
272             self.mock_conn,
273             "hello",
274             1,
275             512,
276             diskp,
277             nicp,
278             "kvm",
279             "hvm",
280             "x86_64",
281             consoles=[{"type": "pty"}],
282         )
283         root = ET.fromstring(xml_data)
284         self.assertEqual(root.find("devices/console").attrib["type"], "pty")
285     def test_gen_xml_for_telnet_console(self):
286         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
287         nicp = virt._nic_profile("default", "kvm")
288         xml_data = virt._gen_xml(
289             self.mock_conn,
290             "hello",
291             1,
292             512,
293             diskp,
294             nicp,
295             "kvm",
296             "hvm",
297             "x86_64",
298             consoles=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
299         )
300         root = ET.fromstring(xml_data)
301         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
302         self.assertEqual(root.find("devices/console/source").attrib["service"], "22223")
303         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
304     def test_gen_xml_for_telnet_console_unspecified_port(self):
305         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
306         nicp = virt._nic_profile("default", "kvm")
307         xml_data = virt._gen_xml(
308             self.mock_conn,
309             "hello",
310             1,
311             512,
312             diskp,
313             nicp,
314             "kvm",
315             "hvm",
316             "x86_64",
317             consoles=[{"type": "tcp"}],
318         )
319         root = ET.fromstring(xml_data)
320         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
321         self.assertEqual(root.find("devices/console/source").attrib["service"], "23023")
322         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
323     def test_gen_xml_for_serial_no_console(self):
324         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
325         nicp = virt._nic_profile("default", "kvm")
326         xml_data = virt._gen_xml(
327             self.mock_conn,
328             "hello",
329             1,
330             512,
331             diskp,
332             nicp,
333             "kvm",
334             "hvm",
335             "x86_64",
336             serials=[{"type": "pty"}],
337             consoles=[],
338         )
339         root = ET.fromstring(xml_data)
340         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
341         self.assertEqual(root.find("devices/console"), None)
342     def test_gen_xml_for_telnet_no_console(self):
343         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
344         nicp = virt._nic_profile("default", "kvm")
345         xml_data = virt._gen_xml(
346             self.mock_conn,
347             "hello",
348             1,
349             512,
350             diskp,
351             nicp,
352             "kvm",
353             "hvm",
354             "x86_64",
355             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
356             consoles=[],
357         )
358         root = ET.fromstring(xml_data)
359         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
360         self.assertEqual(root.find("devices/console"), None)
361     def test_gen_xml_nographics_default(self):
362         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
363         nicp = virt._nic_profile("default", "kvm")
364         xml_data = virt._gen_xml(
365             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
366         )
367         root = ET.fromstring(xml_data)
368         self.assertIsNone(root.find("devices/graphics"))
369     def test_gen_xml_noloader_default(self):
370         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
371         nicp = virt._nic_profile("default", "kvm")
372         xml_data = virt._gen_xml(
373             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
374         )
375         root = ET.fromstring(xml_data)
376         self.assertIsNone(root.find("os/loader"))
377     def test_gen_xml_vnc_default(self):
378         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
379         nicp = virt._nic_profile("default", "kvm")
380         xml_data = virt._gen_xml(
381             self.mock_conn,
382             "hello",
383             1,
384             512,
385             diskp,
386             nicp,
387             "kvm",
388             "hvm",
389             "x86_64",
390             graphics={
391                 "type": "vnc",
392                 "port": 1234,
393                 "tlsPort": 5678,
394                 "listen": {"type": "address", "address": "myhost"},
395             },
396         )
397         root = ET.fromstring(xml_data)
398         self.assertEqual(root.find("devices/graphics").attrib["type"], "vnc")
399         self.assertEqual(root.find("devices/graphics").attrib["autoport"], "no")
400         self.assertEqual(root.find("devices/graphics").attrib["port"], "1234")
401         self.assertFalse("tlsPort" in root.find("devices/graphics").attrib)
402         self.assertEqual(root.find("devices/graphics").attrib["listen"], "myhost")
403         self.assertEqual(root.find("devices/graphics/listen").attrib["type"], "address")
404         self.assertEqual(
405             root.find("devices/graphics/listen").attrib["address"], "myhost"
406         )
407     def test_gen_xml_memory(self):
408         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
409         nicp = virt._nic_profile("default", "kvm")
410         xml_data = virt._gen_xml(
411             self.mock_conn,
412             "hello",
413             1,
414             {
415                 "boot": "512m",
416                 "current": "256m",
417                 "max": "1g",
418                 "hard_limit": "1024",
419                 "soft_limit": "512m",
420                 "swap_hard_limit": "1g",
421                 "min_guarantee": "256m",
422                 "hugepages": [
423                     {"size": "128m"},
424                     {"nodeset": "0", "size": "256m"},
425                     {"nodeset": "1", "size": "512m"},
426                 ],
427                 "nosharepages": True,
428                 "locked": True,
429                 "source": "file",
430                 "access": "shared",
431                 "allocation": "immediate",
432                 "discard": True,
433             },
434             diskp,
435             nicp,
436             "kvm",
437             "x86_64",
438         )
439         root = ET<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.fromstring(xml_data)
440         self.assert_equal_unit(root.find("memory"), 512 * 1024)
441         self.assert_equal_unit(root.find("currentMemory"), 256 * 1024)
442         self.assert_equal_unit(root.find("maxMemory"), 1024 * 1024)
443         self.assertFalse("slots" in root.find("maxMemory").keys())
444         self.assert_equal_unit(</b></font>root.find("memtune/hard_limit"), 1024 * 1024)
445         self.assert_equal_unit(root.find("memtune/soft_limit"), 512 * 1024)
446         self.assert_equal_unit(root.find("memtune/swap_hard_limit"), 1024 ** 2)
447         self.assert_equal_unit(root.find("memtune/min_guarantee"), 256 * 1024)
448         self.assertEqual(
449             [
450                 {"nodeset": page.get("nodeset"), "size": page.get("size")}
451                 for page in root.findall("memoryBacking/hugepages/page")
452             ],
453             [
454                 {"nodeset": None, "size": str(128 * 1024)},
455                 {"nodeset": "0", "size": str(256 * 1024)},
456                 {"nodeset": "1", "size": str(512 * 1024)},
457             ],
458         )
459         self.assertIsNotNone(root.find("memoryBacking/nosharepages"))
460         self.assertIsNotNone(root.find("memoryBacking/locked"))
461         self.assertIsNotNone(root.find("memoryBacking/discard"))
462         self.assertEqual(root.find("memoryBacking/source").get("type"), "file")
463         self.assertEqual(root.find("memoryBacking/access").get("mode"), "shared")
464         self.assertEqual(root.find("memoryBacking/allocation").get("mode"), "immediate")
465     def test_gen_xml_cpu(self):
466         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
467         nicp = virt._nic_profile("default", "kvm")
468         xml_data = virt._gen_xml(
469             self.mock_conn,
470             "hello",
471             {
472                 "maximum": 12,
473                 "placement": "static",
474                 "cpuset": "0-11",
475                 "current": 5,
476                 "mode": "custom",
477                 "match": "minimum",
478                 "check": "full",
479                 "vendor": "Intel",
480                 "model": {
481                     "name": "core2duo",
482                     "fallback": "allow",
483                     "vendor_id": "GenuineIntel",
484                 },
485                 "cache": {"level": 3, "mode": "emulate"},
486                 "features": {"lahf": "optional", "vmx": "require"},
487                 "vcpus": {
488                     0: {"enabled": True, "hotpluggable": True},
489                     1: {"enabled": False},
490                 },
491             },
492             512,
493             diskp,
494             nicp,
495             "kvm",
496             "hvm",
497             "x86_64",
498         )
499         root = ET.fromstring(xml_data)
500         self.assertEqual(root.find("vcpu").get("current"), "5")
501         self.assertEqual(root.find("vcpu").get("placement"), "static")
502         self.assertEqual(root.find("vcpu").get("cpuset"), "0-11")
503         self.assertEqual(root.find("vcpu").text, "12")
504         self.assertEqual(root.find("cpu").get("match"), "minimum")
505         self.assertEqual(root.find("cpu").get("mode"), "custom")
506         self.assertEqual(root.find("cpu").get("check"), "full")
507         self.assertEqual(root.find("cpu/vendor").text, "Intel")
508         self.assertEqual(root.find("cpu/model").text, "core2duo")
509         self.assertEqual(root.find("cpu/model").get("fallback"), "allow")
510         self.assertEqual(root.find("cpu/model").get("vendor_id"), "GenuineIntel")
511         self.assertEqual(root.find("cpu/cache").get("level"), "3")
512         self.assertEqual(root.find("cpu/cache").get("mode"), "emulate")
513         self.assertEqual(
514             {f.get("name"): f.get("policy") for f in root.findall("cpu/feature")},
515             {"lahf": "optional", "vmx": "require"},
516         )
517         self.assertEqual(
518             {
519                 v.get("id"): {
520                     "enabled": v.get("enabled"),
521                     "hotpluggable": v.get("hotpluggable"),
522                 }
523                 for v in root.findall("vcpus/vcpu")
524             },
525             {
526                 "0": {"enabled": "yes", "hotpluggable": "yes"},
527                 "1": {"enabled": "no", "hotpluggable": None},
528             },
529         )
530     def test_gen_xml_cpu_topology(self):
531         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
532         nicp = virt._nic_profile("default", "kvm")
533         xml_data = virt._gen_xml(
534             self.mock_conn,
535             "hello",
536             {"maximum": 1, "topology": {"sockets": 4, "cores": 16, "threads": 2}},
537             512,
538             diskp,
539             nicp,
540             "kvm",
541             "hvm",
542             "x86_64",
543         )
544         root = ET.fromstring(xml_data)
545         self.assertEqual(root.find("cpu/topology").get("sockets"), "4")
546         self.assertEqual(root.find("cpu/topology").get("cores"), "16")
547         self.assertEqual(root.find("cpu/topology").get("threads"), "2")
548     def test_gen_xml_cpu_numa(self):
549         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
550         nicp = virt._nic_profile("default", "kvm")
551         xml_data = virt._gen_xml(
552             self.mock_conn,
553             "hello",
554             {
555                 "maximum": 1,
556                 "numa": {
557                     0: {
558                         "cpus": "0-3",
559                         "memory": "1g",
560                         "discard": True,
561                         "distances": {0: 10, 1: 20},
562                     },
563                     1: {"cpus": "4-7", "memory": "2g", "distances": {0: 20, 1: 10}},
564                 },
565             },
566             512,
567             diskp,
568             nicp,
569             "kvm",
570             "hvm",
571             "x86_64",
572         )
573         root = ET.fromstring(xml_data)
574         cell0 = root.find("cpu/numa/cell[@id='0']")
575         self.assertEqual(cell0.get("cpus"), "0-3")
576         self.assertIsNone(cell0.get("unit"))
577         self.assertEqual(cell0.get("memory"), str(1024 ** 2))
578         self.assertEqual(cell0.get("discard"), "yes")
579         self.assertEqual(
580             {d.get("id"): d.get("value") for d in cell0.findall("distances/sibling")},
581             {"0": "10", "1": "20"},
582         )
583         cell1 = root.find("cpu/numa/cell[@id='1']")
584         self.assertEqual(cell1.get("cpus"), "4-7")
585         self.assertIsNone(cell0.get("unit"))
586         self.assertEqual(cell1.get("memory"), str(2 * 1024 ** 2))
587         self.assertFalse("discard" in cell1.keys())
588         self.assertEqual(
589             {d.get("id"): d.get("value") for d in cell1.findall("distances/sibling")},
590             {"0": "20", "1": "10"},
591         )
592     def test_gen_xml_cputune(self):
593         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
594         nicp = virt._nic_profile("default", "kvm")
595         cputune = {
596             "shares": 2048,
597             "period": 122000,
598             "quota": -1,
599             "global_period": 1000000,
600             "global_quota": -3,
601             "emulator_period": 1200000,
602             "emulator_quota": -10,
603             "iothread_period": 133000,
604             "iothread_quota": -1,
605             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
606             "emulatorpin": "1-3",
607             "iothreadpin": {1: "5-6", 2: "7-8"},
608             "vcpusched": [
609                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
610                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
611                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
612             ],
613             "iothreadsched": [
614                 {"scheduler": "idle"},
615                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1},
616             ],
617             "emulatorsched": {"scheduler": "rr", "priority": 2},
618             "cachetune": {
619                 "0-3": {
620                     0: {"level": 3, "type": "both", "size": 3},
621                     1: {"level": 3, "type": "both", "size": 3},
622                     "monitor": {1: 3, "0-3": 3},
623                 },
624                 "4-5": {"monitor": {4: 3, 5: 2}},
625             },
626             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
627         }
628         xml_data = virt._gen_xml(
629             self.mock_conn,
630             "hello",
631             {"maximum": 1, "tuning": cputune, "iothreads": 2},
632             512,
633             diskp,
634             nicp,
635             "kvm",
636             "hvm",
637             "x86_64",
638         )
639         root = ET.fromstring(xml_data)
640         self.assertEqual(root.find("cputune").find("shares").text, "2048")
641         self.assertEqual(root.find("cputune").find("period").text, "122000")
642         self.assertEqual(root.find("cputune").find("quota").text, "-1")
643         self.assertEqual(root.find("cputune").find("global_period").text, "1000000")
644         self.assertEqual(root.find("cputune").find("global_quota").text, "-3")
645         self.assertEqual(root.find("cputune").find("emulator_period").text, "1200000")
646         self.assertEqual(root.find("cputune").find("emulator_quota").text, "-10")
647         self.assertEqual(root.find("cputune").find("iothread_period").text, "133000")
648         self.assertEqual(root.find("cputune").find("iothread_quota").text, "-1")
649         self.assertEqual(
650             root.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
651             "1-4,^2",
652         )
653         self.assertEqual(
654             root.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
655             "0,1",
656         )
657         self.assertEqual(
658             root.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
659             "2,3",
660         )
661         self.assertEqual(
662             root.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
663             "0,4",
664         )
665         self.assertEqual(
666             root.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1-3"
667         )
668         self.assertEqual(
669             root.find("cputune")
670             .find("iothreadpin[@iothread='1']")
671             .attrib.get("cpuset"),
672             "5-6",
673         )
674         self.assertEqual(
675             root.find("cputune")
676             .find("iothreadpin[@iothread='2']")
677             .attrib.get("cpuset"),
678             "7-8",
679         )
680         self.assertDictEqual(
681             {
682                 s.get("vcpus"): {
683                     "scheduler": s.get("scheduler"),
684                     "priority": s.get("priority"),
685                 }
686                 for s in root.findall("cputune/vcpusched")
687             },
688             {
689                 "0": {"scheduler": "fifo", "priority": "1"},
690                 "1": {"scheduler": "fifo", "priority": "2"},
691                 "2": {"scheduler": "idle", "priority": "3"},
692             },
693         )
694         self.assertDictEqual(
695             {
696                 s.get("iothreads"): {
697                     "scheduler": s.get("scheduler"),
698                     "priority": s.get("priority"),
699                 }
700                 for s in root.findall("cputune/iothreadsched")
701             },
702             {
703                 None: {"scheduler": "idle", "priority": None},
704                 "5-7": {"scheduler": "batch", "priority": "1"},
705             },
706         )
707         self.assertEqual(root.find("cputune/emulatorsched").get("scheduler"), "rr")
708         self.assertEqual(root.find("cputune/emulatorsched").get("priority"), "2")
709         self.assertEqual(
710             root.find("./cputune/cachetune[@vcpus='0-3']").attrib.get("vcpus"), "0-3"
711         )
712         self.assertEqual(
713             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
714                 "level"
715             ),
716             "3",
717         )
718         self.assertEqual(
719             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
720                 "type"
721             ),
722             "both",
723         )
724         self.assertEqual(
725             root.find(
726                 "./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"
727             ).attrib.get("level"),
728             "3",
729         )
730         self.assertNotEqual(
731             root.find("./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"), None
732         )
733         self.assertNotEqual(
734             root.find("./cputune/cachetune[@vcpus='4-5']").attrib.get("vcpus"), None
735         )
736         self.assertEqual(
737             root.find("./cputune/cachetune[@vcpus='4-5']/cache[@id='0']"), None
738         )
739         self.assertEqual(
740             root.find(
741                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']"
742             ).attrib.get("level"),
743             "3",
744         )
745         self.assertEqual(
746             root.find(
747                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']"
748             ).attrib.get("level"),
749             "2",
750         )
751         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='0-2']"), None)
752         self.assertEqual(
753             root.find("./cputune/memorytune[@vcpus='0-2']/node[@id='0']").attrib.get(
754                 "bandwidth"
755             ),
756             "60",
757         )
758         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='3-4']"), None)
759         self.assertEqual(
760             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='0']").attrib.get(
761                 "bandwidth"
762             ),
763             "50",
764         )
765         self.assertEqual(
766             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='1']").attrib.get(
767                 "bandwidth"
768             ),
769             "70",
770         )
771         self.assertEqual(root.find("iothreads").text, "2")
772     def test_default_disk_profile_hypervisor_esxi(self):
773         mock = MagicMock(return_value={})
774         with patch.dict(
775             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
776         ):
777             ret = virt._disk_profile(
778                 self.mock_conn, "nonexistent", "vmware", None, "test-vm"
779             )
780             self.assertTrue(len(ret) == 1)
781             found = [disk for disk in ret if disk["name"] == "system"]
782             self.assertTrue(bool(found))
783             system = found[0]
784             self.assertEqual(system["format"], "vmdk")
785             self.assertEqual(system["model"], "scsi")
786             self.assertTrue(int(system["size"]) &gt;= 1)
787     def test_default_disk_profile_hypervisor_kvm(self):
788         mock = MagicMock(side_effect=[{}, "/images/dir"])
789         with patch.dict(
790             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
791         ):
792             ret = virt._disk_profile(
793                 self.mock_conn, "nonexistent", "kvm", None, "test-vm"
794             )
795             self.assertTrue(len(ret) == 1)
796             found = [disk for disk in ret if disk["name"] == "system"]
797             self.assertTrue(bool(found))
798             system = found[0]
799             self.assertEqual(system["format"], "qcow2")
800             self.assertEqual(system["model"], "virtio")
801             self.assertTrue(int(system["size"]) &gt;= 1)
802     def test_default_disk_profile_hypervisor_xen(self):
803         mock = MagicMock(side_effect=[{}, "/images/dir"])
804         with patch.dict(
805             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
806         ):
807             ret = virt._disk_profile(
808                 self.mock_conn, "nonexistent", "xen", None, "test-vm"
809             )
810             self.assertTrue(len(ret) == 1)
811             found = [disk for disk in ret if disk["name"] == "system"]
812             self.assertTrue(bool(found))
813             system = found[0]
814             self.assertEqual(system["format"], "qcow2")
815             self.assertEqual(system["model"], "xen")
816             self.assertTrue(int(system["size"]) &gt;= 1)
817     def test_default_nic_profile_hypervisor_esxi(self):
818         mock = MagicMock(return_value={})
819         with patch.dict(
820             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
821         ):
822             ret = virt._nic_profile("nonexistent", "vmware")
823             self.assertTrue(len(ret) == 1)
824             eth0 = ret[0]
825             self.assertEqual(eth0["name"], "eth0")
826             self.assertEqual(eth0["type"], "bridge")
827             self.assertEqual(eth0["source"], "DEFAULT")
828             self.assertEqual(eth0["model"], "e1000")
829     def test_default_nic_profile_hypervisor_kvm(self):
830         mock = MagicMock(return_value={})
831         with patch.dict(
832             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
833         ):
834             ret = virt._nic_profile("nonexistent", "kvm")
835             self.assertTrue(len(ret) == 1)
836             eth0 = ret[0]
837             self.assertEqual(eth0["name"], "eth0")
838             self.assertEqual(eth0["type"], "bridge")
839             self.assertEqual(eth0["source"], "br0")
840             self.assertEqual(eth0["model"], "virtio")
841     def test_default_nic_profile_hypervisor_xen(self):
842         mock = MagicMock(return_value={})
843         with patch.dict(
844             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
845         ):
846             ret = virt._nic_profile("nonexistent", "xen")
847             self.assertTrue(len(ret) == 1)
848             eth0 = ret[0]
849             self.assertEqual(eth0["name"], "eth0")
850             self.assertEqual(eth0["type"], "bridge")
851             self.assertEqual(eth0["source"], "br0")
852             self.assertFalse(eth0["model"])
853     def test_gen_vol_xml_esx(self):
854         xml_data = virt._gen_vol_xml("vmname/system.vmdk", 8192, format="vmdk")
855         root = ET.fromstring(xml_data)
856         self.assertIsNone(root.get("type"))
857         self.assertEqual(root.find("name").text, "vmname/system.vmdk")
858         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
859         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
860         self.assertEqual(root.find("allocation").text, str(0))
861         self.assertEqual(root.find("target/format").get("type"), "vmdk")
862         self.assertIsNone(root.find("target/permissions"))
863         self.assertIsNone(root.find("target/nocow"))
864         self.assertIsNone(root.find("backingStore"))
865     def test_gen_vol_xml_file(self):
866         xml_data = virt._gen_vol_xml(
867             "myvm_system.qcow2",
868             8192,
869             format="qcow2",
870             allocation=4096,
871             type="file",
872             permissions={
873                 "mode": "0775",
874                 "owner": "123",
875                 "group": "456",
876                 "label": "sec_label",
877             },
878             backing_store={"path": "/backing/image", "format": "raw"},
879             nocow=True,
880         )
881         root = ET.fromstring(xml_data)
882         self.assertEqual(root.get("type"), "file")
883         self.assertEqual(root.find("name").text, "myvm_system.qcow2")
884         self.assertIsNone(root.find("key"))
885         self.assertIsNone(root.find("target/path"))
886         self.assertEqual(root.find("target/format").get("type"), "qcow2")
887         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
888         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
889         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
890         self.assertEqual(root.find("allocation").text, str(4096 * 1024))
891         self.assertEqual(root.find("target/permissions/mode").text, "0775")
892         self.assertEqual(root.find("target/permissions/owner").text, "123")
893         self.assertEqual(root.find("target/permissions/group").text, "456")
894         self.assertEqual(root.find("target/permissions/label").text, "sec_label")
895         self.assertIsNotNone(root.find("target/nocow"))
896         self.assertEqual(root.find("backingStore/path").text, "/backing/image")
897         self.assertEqual(root.find("backingStore/format").get("type"), "raw")
898     def test_gen_xml_for_kvm_default_profile(self):
899         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
900         nicp = virt._nic_profile("default", "kvm")
901         xml_data = virt._gen_xml(
902             self.mock_conn,
903             "hello",
904             1,
905             512,
906             diskp,
907             nicp,
908             "kvm",
909             "hvm",
910             "x86_64",
911         )
912         root = ET.fromstring(xml_data)
913         self.assertEqual(root.attrib["type"], "kvm")
914         self.assertEqual(root.find("vcpu").text, "1")
915         self.assertEqual(root.find("memory").text, str(512 * 1024))
916         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
917         disks = root.findall(".//disk")
918         self.assertEqual(len(disks), 1)
919         disk = disks[0]
920         root_dir = salt.config.DEFAULT_MINION_OPTS.get("root_dir")
921         self.assertTrue(disk.find("source").attrib["file"].startswith(root_dir))
922         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
923         self.assertEqual(disk.find("target").attrib["dev"], "vda")
924         self.assertEqual(disk.find("target").attrib["bus"], "virtio")
925         self.assertEqual(disk.find("driver").attrib["name"], "qemu")
926         self.assertEqual(disk.find("driver").attrib["type"], "qcow2")
927         interfaces = root.findall(".//interface")
928         self.assertEqual(len(interfaces), 1)
929         iface = interfaces[0]
930         self.assertEqual(iface.attrib["type"], "bridge")
931         self.assertEqual(iface.find("source").attrib["bridge"], "br0")
932         self.assertEqual(iface.find("model").attrib["type"], "virtio")
933     def test_gen_xml_for_esxi_default_profile(self):
934         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
935         nicp = virt._nic_profile("default", "vmware")
936         xml_data = virt._gen_xml(
937             self.mock_conn,
938             "hello",
939             1,
940             512,
941             diskp,
942             nicp,
943             "vmware",
944             "hvm",
945             "x86_64",
946         )
947         root = ET.fromstring(xml_data)
948         self.assertEqual(root.attrib["type"], "vmware")
949         self.assertEqual(root.find("vcpu").text, "1")
950         self.assertEqual(root.find("memory").text, str(512 * 1024))
951         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
952         disks = root.findall(".//disk")
953         self.assertEqual(len(disks), 1)
954         disk = disks[0]
955         self.assertTrue("[0]" in disk.find("source").attrib["file"])
956         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
957         self.assertEqual(disk.find("target").attrib["dev"], "sda")
958         self.assertEqual(disk.find("target").attrib["bus"], "scsi")
959         self.assertEqual(disk.find("address").attrib["unit"], "0")
960         interfaces = root.findall(".//interface")
961         self.assertEqual(len(interfaces), 1)
962         iface = interfaces[0]
963         self.assertEqual(iface.attrib["type"], "bridge")
964         self.assertEqual(iface.find("source").attrib["bridge"], "DEFAULT")
965         self.assertEqual(iface.find("model").attrib["type"], "e1000")
966     def test_gen_xml_for_esxi_custom_profile(self):
967         disks = {
968             "noeffect": [
969                 {"first": {"size": 8192, "pool": "datastore1"}},
970                 {"second": {"size": 4096, "pool": "datastore2"}},
971             ]
972         }
973         nics = {
974             "noeffect": [
975                 {"name": "eth1", "source": "ONENET"},
976                 {"name": "eth2", "source": "TWONET"},
977             ]
978         }
979         with patch.dict(
980             virt.__salt__,  # pylint: disable=no-member
981             {"config.get": MagicMock(side_effect=[disks, nics])},
982         ):
983             diskp = virt._disk_profile(
984                 self.mock_conn, "noeffect", "vmware", [], "hello"
985             )
986             nicp = virt._nic_profile("noeffect", "vmware")
987             xml_data = virt._gen_xml(
988                 self.mock_conn,
989                 "hello",
990                 1,
991                 512,
992                 diskp,
993                 nicp,
994                 "vmware",
995                 "hvm",
996                 "x86_64",
997             )
998             root = ET.fromstring(xml_data)
999             self.assertEqual(root.attrib["type"], "vmware")
1000             self.assertEqual(root.find("vcpu").text, "1")
1001             self.assertEqual(root.find("memory").text, str(512 * 1024))
1002             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1003             self.assertTrue(len(root.findall(".//disk")) == 2)
1004             self.assertTrue(len(root.findall(".//interface")) == 2)
1005     def test_gen_xml_for_kvm_custom_profile(self):
1006         disks = {
1007             "noeffect": [
1008                 {"first": {"size": 8192, "pool": "/var/lib/images"}},
1009                 {"second": {"size": 4096, "pool": "/var/lib/images"}},
1010             ]
1011         }
1012         nics = {
1013             "noeffect": [
1014                 {"name": "eth1", "source": "b2"},
1015                 {"name": "eth2", "source": "b2"},
1016             ]
1017         }
1018         with patch.dict(
1019             virt.__salt__,  # pylint: disable=no-member
1020             {"config.get": MagicMock(side_effect=[disks, nics])},
1021         ):
1022             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1023             nicp = virt._nic_profile("noeffect", "kvm")
1024             xml_data = virt._gen_xml(
1025                 self.mock_conn,
1026                 "hello",
1027                 1,
1028                 512,
1029                 diskp,
1030                 nicp,
1031                 "kvm",
1032                 "hvm",
1033                 "x86_64",
1034             )
1035             root = ET.fromstring(xml_data)
1036             self.assertEqual(root.attrib["type"], "kvm")
1037             self.assertEqual(root.find("vcpu").text, "1")
1038             self.assertEqual(root.find("memory").text, str(512 * 1024))
1039             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1040             disks = root.findall(".//disk")
1041             self.assertTrue(len(disks) == 2)
1042             self.assertEqual(disks[0].find("target").get("dev"), "vda")
1043             self.assertEqual(disks[1].find("target").get("dev"), "vdb")
1044             self.assertTrue(len(root.findall(".//interface")) == 2)
1045     def test_disk_profile_kvm_disk_pool(self):
1046         disks = {
1047             "noeffect": [
1048                 {"first": {"size": 8192, "pool": "mypool"}},
1049                 {"second": {"size": 4096}},
1050             ]
1051         }
1052         with patch.dict(
1053             virt.__salt__,
1054             {
1055                 "config.get": MagicMock(
1056                     side_effect=[
1057                         disks,
1058                         os.path.join(salt.syspaths.ROOT_DIR, "default", "path"),
1059                     ]
1060                 )
1061             },
1062         ):
1063             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1064             pools_path = (
1065                 os.path.join(salt.syspaths.ROOT_DIR, "pools", "mypool") + os.sep
1066             )
1067             default_path = (
1068                 os.path.join(salt.syspaths.ROOT_DIR, "default", "path") + os.sep
1069             )
1070             self.assertEqual(len(diskp), 2)
1071             self.assertTrue(diskp[1]["source_file"].startswith(default_path))
1072     def test_disk_profile_kvm_disk_external_image(self):
1073         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1074             diskp = virt._disk_profile(
1075                 self.mock_conn,
1076                 None,
1077                 "kvm",
1078                 [{"name": "mydisk", "source_file": "/path/to/my/image.qcow2"}],
1079                 "hello",
1080             )
1081             self.assertEqual(len(diskp), 1)
1082             self.assertEqual(diskp[0]["source_file"], "/path/to/my/image.qcow2")
1083     def test_disk_profile_cdrom_default(self):
1084         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1085             diskp = virt._disk_profile(
1086                 self.mock_conn,
1087                 None,
1088                 "kvm",
1089                 [
1090                     {
1091                         "name": "mydisk",
1092                         "device": "cdrom",
1093                         "source_file": "/path/to/my.iso",
1094                     }
1095                 ],
1096                 "hello",
1097             )
1098             self.assertEqual(len(diskp), 1)
1099             self.assertEqual(diskp[0]["model"], "ide")
1100             self.assertEqual(diskp[0]["format"], "raw")
1101     def test_disk_profile_pool_disk_type(self):
1102         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1103         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1104             &lt;pool type="disk"&gt;
1105               &lt;name&gt;test-vdb&lt;/name&gt;
1106               &lt;source&gt;
1107                 &lt;device path='/dev/vdb'/&gt;
1108               &lt;/source&gt;
1109               &lt;target&gt;
1110                 &lt;path&gt;/dev&lt;/path&gt;
1111               &lt;/target&gt;
1112             &lt;/pool&gt;
1113         """
1114         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = (
1115             []
1116         )
1117         diskp = virt._disk_profile(
1118             self.mock_conn,
1119             None,
1120             "kvm",
1121             [{"name": "mydisk", "pool": "test-vdb"}],
1122             "hello",
1123         )
1124         self.assertEqual(diskp[0]["filename"], "vdb1")
1125         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1126             "vdb1",
1127             "vdb2",
1128         ]
1129         diskp = virt._disk_profile(
1130             self.mock_conn,
1131             None,
1132             "kvm",
1133             [{"name": "mydisk", "pool": "test-vdb"}],
1134             "hello",
1135         )
1136         self.assertEqual(diskp[0]["filename"], "vdb3")
1137         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1138             "vdb1",
1139             "vdb3",
1140         ]
1141         diskp = virt._disk_profile(
1142             None,
1143             "kvm",
1144             [{<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"name": "mydisk", "pool": "test-vdb"}],
1145             "hello",
1146         )
1147         self.assertEqual(diskp[0]["filename"], "vdb2")
1148         diskp = virt._disk_profile(
1149             self.mock_conn,
1150             None,
1151             "kvm",
1152             [{"name": "mydisk", "pool": "test-vdb", "source_file": "vdb1"}],
1153             "hello",
1154         )
1155         self.</b></font>assertEqual(diskp[0]["filename"], "vdb1")
1156     def test_gen_xml_volume(self):
1157         self.mock_conn.listStoragePools.return_value = ["default"]
1158         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1159             "&lt;pool type='dir'/&gt;"
1160         )
1161         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1162             "myvolume"
1163         ]
1164         diskp = virt._disk_profile(
1165             self.mock_conn,
1166             None,
1167             "kvm",
1168             [
1169                 {"name": "system", "pool": "default"},
1170                 {"name": "data", "pool": "default", "source_file": "myvolume"},
1171             ],
1172             "hello",
1173         )
1174         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1175             "&lt;pool type='dir'/&gt;"
1176         nicp = virt._nic_profile(None, "kvm")
1177         xml_data = virt._gen_xml(
1178             self<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.mock_conn,
1179             "hello",
1180             1,
1181             512,
1182             diskp,
1183             nicp,
1184             "kvm",
1185             "hvm",
1186             "x86_64",
1187         )
1188         root = ET.fromstring(xml_data)
1189         disk = root.findall(".//disk")[0]
1190         self.assertEqual(disk.attrib[</b></font>"device"], "disk")
1191         self.assertEqual(disk.attrib["type"], "volume")
1192         source = disk.find("source")
1193         self.assertEqual("default", source.attrib["pool"])
1194         self.assertEqual("hello_system", source.attrib["volume"])
1195         self.assertEqual("myvolume", root.find(".//disk[2]/source").get("volume"))
1196         self.mock_conn.listStoragePools.return_value = ["test-rbd"]
1197         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1198             &lt;pool type='rbd'&gt;
1199               &lt;name&gt;test-rbd&lt;/name&gt;
1200               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1201               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1202               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1203               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1204               &lt;source&gt;
1205                 &lt;host name='ses2.tf.local'/&gt;
1206                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1207                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1208                 &lt;auth type='ceph' username='libvirt'&gt;
1209                   &lt;secret usage='pool_test-rbd'/&gt;
1210                 &lt;/auth&gt;
1211               &lt;/source&gt;
1212             &lt;/pool&gt;
1213         """
1214         self.mock_conn.getStoragePoolCapabilities.return_value = """
1215             &lt;storagepoolCapabilities&gt;
1216               &lt;pool type='rbd' supported='yes'&gt;
1217                 &lt;volOptions&gt;
1218                   &lt;defaultFormat type='raw'/&gt;
1219                   &lt;enum name='targetFormatType'&gt;
1220                   &lt;/enum&gt;
1221                 &lt;/volOptions&gt;
1222               &lt;/pool&gt;
1223             &lt;/storagepoolCapabilities&gt;
1224         """
1225         diskp = virt._disk_profile(
1226             self.mock_conn,
1227             None,
1228             "kvm",
1229             [{"name": "system", "pool": "test-rbd"}],
1230             "test-vm",
1231         )
1232         xml_data = virt._gen_xml(
1233             self.mock_conn,
1234             "hello",
1235             1,
1236             512,
1237             diskp,
1238             nicp,
1239             "kvm",
1240             "hvm",
1241             "x86_64",
1242         )
1243         root = ET.fromstring(xml_data)
1244         disk = root.findall(".//disk")[0]
1245         self.assertDictEqual(
1246             {
1247                 "type": "network",
1248                 "device": "disk",
1249                 "source": {
1250                     "protocol": "rbd",
1251                     "name": "libvirt-pool/test-vm_system",
1252                     "host": [
1253                         {"name": "ses2.tf.local"},
1254                         {"name": "ses3.tf.local", "port": "1234"},
1255                     ],
1256                     "auth": {
1257                         "username": "libvirt",
1258                         "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1259                     },
1260                 },
1261                 "target": {"dev": "vda", "bus": "virtio"},
1262                 "driver": {
1263                     "name": "qemu",
1264                     "type": "raw",
1265                     "cache": "none",
1266                     "io": "native",
1267                 },
1268             },
1269             salt.utils.xmlutil.to_dict(disk, True),
1270         )
1271         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1272             &lt;pool type='rbd'&gt;
1273               &lt;name&gt;test-rbd&lt;/name&gt;
1274               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1275               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1276               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1277               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1278               &lt;source&gt;
1279                 &lt;host name='ses2.tf.local'/&gt;
1280                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1281                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1282                 &lt;auth type='ceph' username='libvirt'&gt;
1283                   &lt;secret uuid='some-uuid'/&gt;
1284                 &lt;/auth&gt;
1285               &lt;/source&gt;
1286             &lt;/pool&gt;
1287         """
1288         self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
1289             "pool_test-rbd"
1290         )
1291         diskp = virt._disk_profile(
1292             self.mock_conn,
1293             None,
1294             "kvm",
1295             [{"name": "system", "pool": "test-rbd"}],
1296             "test-vm",
1297         )
1298         xml_data = virt._gen_xml(
1299             self.mock_conn,
1300             "hello",
1301             1,
1302             512,
1303             diskp,
1304             nicp,
1305             "kvm",
1306             "hvm",
1307             "x86_64",
1308         )
1309         root = ET.fromstring(xml_data)
1310         self.assertDictEqual(
1311             {
1312                 "username": "libvirt",
1313                 "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1314             },
1315             salt.utils.xmlutil.to_dict(root.find(".//disk/source/auth"), True),
1316         )
1317         self.mock_conn.secretLookupByUUIDString.assert_called_once_with("some-uuid")
1318         self.mock_conn.getStoragePoolCapabilities.return_value = """
1319             &lt;storagepoolCapabilities&gt;
1320               &lt;pool type='disk' supported='yes'&gt;
1321                 &lt;volOptions&gt;
1322                   &lt;defaultFormat type='none'/&gt;
1323                   &lt;enum name='targetFormatType'&gt;
1324                     &lt;value&gt;none&lt;/value&gt;
1325                     &lt;value&gt;linux&lt;/value&gt;
1326                     &lt;value&gt;fat16&lt;/value&gt;
1327                   &lt;/enum&gt;
1328                 &lt;/volOptions&gt;
1329               &lt;/pool&gt;
1330             &lt;/storagepoolCapabilities&gt;
1331         """
1332         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1333             &lt;pool type='disk'&gt;
1334               &lt;name&gt;test-vdb&lt;/name&gt;
1335               &lt;source&gt;
1336                 &lt;device path='/dev/vdb'/&gt;
1337                 &lt;format type='gpt'/&gt;
1338               &lt;/source&gt;
1339             &lt;/pool&gt;
1340         """
1341         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1342         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1343             "vdb1",
1344         ]
1345         diskp = virt._disk_profile(
1346             self.mock_conn,
1347             None,
1348             "kvm",
1349             [{"name": "system", "pool": "test-vdb"}],
1350             "test-vm",
1351         )
1352         xml_data = virt._gen_xml(
1353             self.mock_conn,
1354             "hello",
1355             1,
1356             512,
1357             diskp,
1358             nicp,
1359             "kvm",
1360             "hvm",
1361             "x86_64",
1362         )
1363         root = ET.fromstring(xml_data)
1364         disk = root.findall(".//disk")[0]
1365         self.assertEqual(disk.attrib["type"], "volume")
1366         source = disk.find("source")
1367         self.assertEqual("test-vdb", source.attrib["pool"])
1368         self.assertEqual("vdb2", source.attrib["volume"])
1369         self.assertEqual("raw", disk.find("driver").get("type"))
1370     def test_get_xml_volume_xen_dir(self):
1371         self.mock_conn.listStoragePools.return_value = ["default"]
1372         pool_mock = MagicMock()
1373         pool_mock.XMLDesc.return_value = (
1374             "&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;"
1375         )
1376         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1377         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1378         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1379         diskp = virt._disk_profile(
1380             self.mock_conn,
1381             None,
1382             "xen",
1383             [{"name": "system", "pool": "default"}],
1384             "hello",
1385         )
1386         xml_data = virt._gen_xml(
1387             self.mock_conn,
1388             "hello",
1389             1,
1390             512,
1391             diskp,
1392             [],
1393             "xen",
1394             "hvm",
1395             "x86_64",
1396         )
1397         root = ET.fromstring(xml_data)
1398         disk = root.findall(".//disk")[0]
1399         self.assertEqual(disk.attrib["type"], "file")
1400         self.assertEqual(
1401             "/path/to/images/hello_system", disk.find("source").attrib["file"]
1402         )
1403     def test_get_xml_volume_xen_block(self):
1404         self.mock_conn.listStoragePools.return_value = ["default"]
1405         pool_mock = MagicMock()
1406         pool_mock.listVolumes.return_value = ["vol01"]
1407         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1408         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1409         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1410         for pool_type in ["logical", "disk", "iscsi", "scsi"]:
1411             pool_mock.XMLDesc.return_value = "&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;".format(
1412                 pool_type
1413             )
1414             diskp = virt._disk_profile(
1415                 self.mock_conn,
1416                 None,
1417                 "xen",
1418                 [{"name": "system", "pool": "default", "source_file": "vol01"}],
1419                 "hello",
1420             )
1421             xml_data = virt._gen_xml(
1422                 self.mock_conn,
1423                 "hello",
1424                 1,
1425                 512,
1426                 diskp,
1427                 [],
1428                 "xen",
1429                 "hvm",
1430                 "x86_64",
1431             )
1432             root = ET.fromstring(xml_data)
1433             disk = root.findall(".//disk")[0]
1434             self.assertEqual(disk.attrib["type"], "block")
1435             self.assertEqual("/dev/to/vol01", disk.find("source").attrib["dev"])
1436     def test_gen_xml_cdrom(self):
1437         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1438             "&lt;pool type='dir'/&gt;"
1439         )
1440         diskp = virt._disk_profile(
1441             self.mock_conn,
1442             None,
1443             "kvm",
1444             [
1445                 {"name": "system", "pool": "default"},
1446                 {
1447                     "name": "tested",
1448                     "device": "cdrom",
1449                     "source_file": None,
1450                     "model": "ide",
1451                 },
1452                 {
1453                     "name": "remote",
1454                     "device": "cdrom",
1455                     "source_file": (
1456                         "http://myhost:8080/url/to/image?query=foo&amp;filter=bar"
1457                     ),
1458                     "model": "ide",
1459                 },
1460             ],
1461             "hello",
1462         )
1463         nicp = virt._nic_profile(None, "kvm")
1464         xml_data = virt._gen_xml(
1465             self.mock_conn,
1466             "hello",
1467             1,
1468             512,
1469             diskp,
1470             nicp,
1471             "kvm",
1472             "hvm",
1473             "x86_64",
1474         )
1475         root = ET.fromstring(xml_data)
1476         disk = root.findall(".//disk")[1]
1477         self.assertEqual(disk.get("type"), "file")
1478         self.assertEqual(disk.attrib["device"], "cdrom")
1479         self.assertIsNone(disk.find("source"))
1480         self.assertEqual(disk.find("target").get("dev"), "hda")
1481         disk = root.findall(".//disk")[2]
1482         self.assertEqual(disk.get("type"), "network")
1483         self.assertEqual(disk.attrib["device"], "cdrom")
1484         self.assertEqual(
1485             {
1486                 "protocol": "http",
1487                 "name": "/url/to/image",
1488                 "query": "query=foo&amp;filter=bar",
1489                 "host": {"name": "myhost", "port": "8080"},
1490             },
1491             salt.utils.xmlutil.to_dict(disk.find("source"), True),
1492         )
1493     def test_controller_for_esxi(self):
1494         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
1495         nicp <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= virt._nic_profile("default", "vmware")
1496         xml_data = virt._gen_xml(
1497             self.mock_conn,
1498             "hello",
1499             1,
1500             512,
1501             diskp,
1502             nicp,
1503             "vmware",
1504             "hvm",
1505             "x86_64",
1506         )
1507         root = ET.fromstring(xml_data)
1508         controllers = root.findall(".//devices/controller")
1509         self.assertTrue(</b></font>len(controllers) == 1)
1510         controller = controllers[0]
1511         self.assertEqual(controller.attrib["model"], "lsilogic")
1512     def test_controller_for_kvm(self):
1513         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
1514         nicp = virt._nic_profile("default", "kvm")
1515         xml_data = virt._gen_xml(
1516             self.mock_conn,
1517             "hello",
1518             1,
1519             512,
1520             diskp,
1521             nicp,
1522             "kvm",
1523             "hvm",
1524             "x86_64",
1525         )
1526         root = ET.fromstring(xml_data)
1527         controllers = root.findall(".//devices/controller")
1528         self.assertTrue(len(controllers) == 0)
1529     def test_diff_disks(self):
1530         old_disks = ET.fromstring(
1531         )<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("disk")
1532         new_disks = ET.fromstring(
1533         ).findall("disk")
1534         ret = virt._diff_disk_lists(old_disks, new_disks)
1535         self.assertEqual(</b></font>
1536             [
1537                 disk.find("source").get("file")
1538                 if disk.find("source") is not None
1539                 else None
1540                 for disk in ret["unchanged"]
1541             ],
1542             [],
1543         )
1544         self.assertEqual(
1545             [
1546                 disk.find("source").get("file")
1547                 if disk.find("source") is not None
1548                 else None
1549                 for disk in ret["new"]
1550             ],
1551             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1552         )
1553         self.assertEqual(
1554             [disk.find("target").get("dev") for disk in ret["sorted"]],
1555             ["vda", "vdb", "vdc", "hda"],
1556         )
1557         self.assertEqual(
1558             [
1559                 disk.find("source").get("file")
1560                 if disk.find("source") is not None
1561                 else None
1562                 for disk in ret["sorted"]
1563             ],
1564             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1565         )
1566         self.assertEqual(ret["new"][1].find("target").get("bus"), "virtio")
1567         self.assertEqual(
1568             [
1569                 disk.find("source").get("file")
1570                 if disk.find("source") is not None
1571                 else None
1572                 for disk in ret["deleted"]
1573             ],
1574             [
1575                 "/path/to/img0.qcow2",
1576                 "/path/to/img1.qcow2",
1577                 "/path/to/img2.qcow2",
1578                 "/path/to/img4.qcow2",
1579                 None,
1580             ],
1581         )
1582     def test_init(self):
1583         xml = """
1584 &lt;capabilities&gt;
1585   &lt;host&gt;
1586     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
1587     &lt;cpu&gt;
1588       &lt;arch&gt;x86_64&lt;/arch&gt;
1589       &lt;model&gt;Nehalem&lt;/model&gt;
1590       &lt;vendor&gt;Intel&lt;/vendor&gt;
1591       &lt;microcode version='25'/&gt;
1592       &lt;topology sockets='1' cores='4' threads='2'/&gt;
1593       &lt;feature name='vme'/&gt;
1594       &lt;feature name='ds'/&gt;
1595       &lt;feature name='acpi'/&gt;
1596       &lt;pages unit='KiB' size='4'/&gt;
1597       &lt;pages unit='KiB' size='2048'/&gt;
1598     &lt;/cpu&gt;
1599     &lt;power_management&gt;
1600       &lt;suspend_mem/&gt;
1601       &lt;suspend_disk/&gt;
1602       &lt;suspend_hybrid/&gt;
1603     &lt;/power_management&gt;
1604     &lt;migration_features&gt;
1605       &lt;live/&gt;
1606       &lt;uri_transports&gt;
1607         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
1608         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
1609       &lt;/uri_transports&gt;
1610     &lt;/migration_features&gt;
1611     &lt;topology&gt;
1612       &lt;cells num='1'&gt;
1613         &lt;cell id='0'&gt;
1614           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
1615           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
1616           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
1617           &lt;distances&gt;
1618             &lt;sibling id='0' value='10'/&gt;
1619           &lt;/distances&gt;
1620           &lt;cpus num='8'&gt;
1621             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
1622             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
1623             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
1624             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
1625             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
1626             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
1627             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
1628             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
1629           &lt;/cpus&gt;
1630         &lt;/cell&gt;
1631       &lt;/cells&gt;
1632     &lt;/topology&gt;
1633     &lt;cache&gt;
1634       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
1635     &lt;/cache&gt;
1636     &lt;secmodel&gt;
1637       &lt;model&gt;apparmor&lt;/model&gt;
1638       &lt;doi&gt;0&lt;/doi&gt;
1639     &lt;/secmodel&gt;
1640     &lt;secmodel&gt;
1641       &lt;model&gt;dac&lt;/model&gt;
1642       &lt;doi&gt;0&lt;/doi&gt;
1643       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
1644       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
1645     &lt;/secmodel&gt;
1646   &lt;/host&gt;
1647   &lt;guest&gt;
1648     &lt;os_type&gt;hvm&lt;/os_type&gt;
1649     &lt;arch name='i686'&gt;
1650       &lt;wordsize&gt;32&lt;/wordsize&gt;
1651       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
1652       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1653       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1654       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1655       &lt;domain type='qemu'/&gt;
1656       &lt;domain type='kvm'&gt;
1657         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1658         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1659         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1660         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1661       &lt;/domain&gt;
1662     &lt;/arch&gt;
1663     &lt;features&gt;
1664       &lt;cpuselection/&gt;
1665       &lt;deviceboot/&gt;
1666       &lt;disksnapshot default='on' toggle='no'/&gt;
1667       &lt;acpi default='on' toggle='yes'/&gt;
1668       &lt;apic default='on' toggle='no'/&gt;
1669       &lt;pae/&gt;
1670       &lt;nonpae/&gt;
1671     &lt;/features&gt;
1672   &lt;/guest&gt;
1673   &lt;guest&gt;
1674     &lt;os_type&gt;hvm&lt;/os_type&gt;
1675     &lt;arch name='x86_64'&gt;
1676       &lt;wordsize&gt;64&lt;/wordsize&gt;
1677       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
1678       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1679       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1680       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1681       &lt;domain type='qemu'/&gt;
1682       &lt;domain type='kvm'&gt;
1683         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1684         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1685         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1686         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1687       &lt;/domain&gt;
1688     &lt;/arch&gt;
1689     &lt;features&gt;
1690       &lt;cpuselection/&gt;
1691       &lt;deviceboot/&gt;
1692       &lt;disksnapshot default='on' toggle='no'/&gt;
1693       &lt;acpi default='on' toggle='yes'/&gt;
1694       &lt;apic default='on' toggle='no'/&gt;
1695     &lt;/features&gt;
1696   &lt;/guest&gt;
1697 &lt;/capabilities&gt;
1698         """
1699         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
1700         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
1701         defineMock = MagicMock(return_value=1)
1702         self.mock_conn.defineXML = defineMock
1703         mock_chmod = MagicMock()
1704         mock_run = MagicMock()
1705         with patch.dict(
1706             os.__dict__, {"chmod": mock_chmod, "makedirs": MagicMock()}
1707         ):  # pylint: disable=no-member
1708             with patch.dict(
1709                 virt.__salt__, {"cmd.run": mock_run}
1710             ):  # pylint: disable=no-member
1711                 virt.init(
1712                     "test vm", 2, 1234, nic=None, disk=None, seed=False, start=False
1713                 )
1714                 definition = defineMock.call_args_list[0][0][0]
1715                 self.assertFalse("&lt;interface" in definition)
1716                 self.assertFalse("&lt;disk" in definition)
1717                 defineMock.reset_mock()
1718                 mock_run.reset_mock()
1719                 boot = {
1720                     "kernel": "/root/f8-i386-vmlinuz",
1721                     "initrd": "/root/f8-i386-initrd",
1722                     "cmdline": "console=ttyS0 ks=http://example.com/f8-i386/os/",
1723                 }
1724                 retval = virt.init(
1725                     "test vm boot params",
1726                     2,
1727                     1234,
1728                     nic=None,
1729                     disk=None,
1730                     seed=False,
1731                     start=False,
1732                     boot=boot,
1733                 )
1734                 definition = defineMock.call_args_list[0][0][0]
1735                 self.assertEqual("&lt;kernel" in definition, True)
1736                 self.assertEqual("&lt;initrd" in definition, True)
1737                 self.assertEqual("&lt;cmdline" in definition, True)
1738                 self.assertEqual(retval, True)
1739                 mock_response = MagicMock()
1740                 mock_response.read = MagicMock(return_value="filecontent")
1741                 cache_dir = tempfile.mkdtemp()
1742                 with patch.dict(virt.__dict__, {"CACHE_DIR": cache_dir}):
1743                     with patch(
1744                         "urllib.request.urlopen",
1745                         MagicMock(return_value=mock_response),
1746                     ):
1747                         with patch(
1748                             "salt.utils.files.fopen", return_value=mock_response
1749                         ):
1750                             defineMock.reset_mock()
1751                             mock_run.reset_mock()
1752                             boot = {
1753                                 "kernel": "https://www.example.com/download/vmlinuz",
1754                                 "initrd": "",
1755                                 "cmdline": (
1756                                     "console=ttyS0 ks=http://example.com/f8-i386/os/"
1757                                 ),
1758                             }
1759                             retval = virt.init(
1760                                 "test remote vm boot params",
1761                                 2,
1762                                 1234,
1763                                 nic=None,
1764                                 disk=None,
1765                                 seed=False,
1766                                 start=False,
1767                                 boot=boot,
1768                             )
1769                             definition = defineMock.call_args_list[0][0][0]
1770                             self.assertEqual(cache_dir in definition, True)
1771                     shutil.rmtree(cache_dir)
1772                 defineMock.reset_mock()
1773                 mock_run.reset_mock()
1774                 pool_mock = MagicMock()
1775                 pool_mock.XMLDesc.return_value = '&lt;pool type="dir"/&gt;'
1776                 self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1777                 virt.init(
1778                     "test vm",
1779                     2,
1780                     1234,
1781                     nic=None,
1782                     disk=None,
1783                     disks=[
1784                         {"name": "system", "size": 10240},
1785                         {
1786                             "name": "cddrive",
1787                             "device": "cdrom",
1788                             "source_file": None,
1789                             "model": "ide",
1790                         },
1791                     ],
1792                     seed=False,
1793                     start=False,
1794                 )
1795                 definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1796                 expected_disk_path = os.path.join(root_dir, "test vm_system.qcow2")
1797                 self.assertEqual(
1798                     expected_disk_path,
1799                     definition.find("./devices/disk[1]/source").get("file"),
1800                 )
1801                 self.assertIsNone(definition.find("./devices/disk[2]/source"))
1802                 self.assertEqual(
1803                     mock_run.call_args[0][0],
1804                     'qemu-img create -f qcow2 "{}" 10240M'.format(expected_disk_path),
1805                 )
1806                 self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)
1807                 defineMock.reset_mock()
1808                 mock_run.reset_mock()
1809                 vol_mock = MagicMock()
1810                 pool_mock.storageVolLookupByName.return_value = vol_mock
1811                 pool_mock.listVolumes.return_value = ["test vm_data"]
1812                 stream_mock = MagicMock()
1813                 self.mock_conn.newStream.return_value = stream_mock
1814                 self.mock_conn.listStoragePools.return_value = ["default", "test"]
1815                 with patch.dict(
1816                     os.__dict__, {"open": MagicMock(), "close": MagicMock()}
1817                 ):
1818                     cache_mock = MagicMock()
1819                     with patch.dict(virt.__salt__, {"cp.cache_file": cache_mock}):
1820                         virt.init(
1821                             "test vm",
1822                             2,
1823                             1234,
1824                             nic=None,
1825                             disk=None,
1826                             disks=[
1827                                 {
1828                                     "name": "system",
1829                                     "size": 10240,
1830                                     "image": "/path/to/image",
1831                                     "pool": "test",
1832                                 },
1833                                 {"name": "data", "size": 10240, "pool": "default"},
1834                                 {
1835                                     "name": "test",
1836                                     "size": 1024,
1837                                     "pool": "default",
1838                                     "format": "qcow2",
1839                                     "backing_store_path": "/backing/path",
1840                                     "backing_store_format": "raw",
1841                                 },
1842                             ],
1843                             seed=False,
1844                             start=False,
1845                         )
1846                         definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1847                         self.assertTrue(
1848                             all(
1849                                 [
1850                                     disk.get("type") == "volume"
1851                                     for disk in definition.findall("./devices/disk")
1852                                 ]
1853                             )
1854                         )
1855                         self.assertEqual(
1856                             ["test", "default", "default"],
1857                             [
1858                                 src.get("pool")
1859                                 for src in definition.findall("./devices/disk/source")
1860                             ],
1861                         )
1862                         self.assertEqual(
1863                             ["test vm_system", "test vm_data", "test vm_test"],
1864                             [
1865                                 src.get("volume")
1866                                 for src in definition.findall("./devices/disk/source")
1867                             ],
1868                         )
1869                         create_calls = pool_mock.createXML.call_args_list
1870                         vol_names = [
1871                             ET.fromstring(call[0][0]).find("name").text
1872                             for call in create_calls
1873                         ]
1874                         self.assertEqual(
1875                             ["test vm_system", "test vm_test"],
1876                             vol_names,
1877                         )
1878                         stream_mock.sendAll.assert_called_once()
1879                         stream_mock.finish.assert_called_once()
1880                         vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
1881     def test_update_backing_store(self):
1882         xml = """
1883             &lt;domain type='kvm' id='7'&gt;
1884               &lt;name&gt;my_vm&lt;/name&gt;
1885               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1886               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1887               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1888               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
1889               &lt;os&gt;
1890                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1891               &lt;/os&gt;
1892               &lt;devices&gt;
1893                 &lt;disk type='volume' device='disk'&gt;
1894                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
1895                   &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
1896                   &lt;backingStore type='file' index='2'&gt;
1897                     &lt;format type='qcow2'/&gt;
1898                     &lt;source file='/path/to/base.qcow2'/&gt;
1899                     &lt;backingStore/&gt;
1900                   &lt;/backingStore&gt;
1901                   &lt;target dev='vda' bus='virtio'/&gt;
1902                   &lt;alias name='virtio-disk0'/&gt;
1903                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
1904                 &lt;/disk&gt;
1905               &lt;/devices&gt;
1906             &lt;/domain&gt;
1907         """
1908         domain_mock = self.set_mock_vm("my_vm", xml)
1909         domain_mock.OSType.return_value = "hvm"
1910         self.mock_conn.defineXML.return_value = True
1911         updatedev_mock = MagicMock(return_value=0)
1912         domain_mock.updateDeviceFlags = updatedev_mock
1913         self.mock_conn.listStoragePools.return_value = ["default"]
1914         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1915             "&lt;pool type='dir'/&gt;"
1916         )
1917         ret = virt.update(
1918             "my_vm",
1919             disks=[
1920                 {
1921                     "name": "system",
1922                     "pool": "default",
1923                     "backing_store_path": "/path/to/base.qcow2",
1924                     "backing_store_format": "qcow2",
1925                 },
1926             ],
1927         )
1928         self.assertFalse(ret["definition"])
1929         self.assertFalse(ret["disk"]["attached"])
1930         self.assertFalse(ret["disk"]["detached"])
1931     def test_update_removables(self):
1932         xml = """
1933             &lt;domain type='kvm' id='7'&gt;
1934               &lt;name&gt;my_vm&lt;/name&gt;
1935               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1936               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1937               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1938               &lt;os&gt;
1939                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1940               &lt;/os&gt;
1941               &lt;devices&gt;
1942                 &lt;disk type='network' device='cdrom'&gt;
1943                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1944                   &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
1945                     &lt;host name='test-srv.local' port='80'/&gt;
1946                   &lt;/source&gt;
1947                   &lt;backingStore/&gt;
1948                   &lt;target dev='hda' bus='ide'/&gt;
1949                   &lt;readonly/&gt;
1950                   &lt;alias name='ide0-0-0'/&gt;
1951                   &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
1952                 &lt;/disk&gt;
1953                 &lt;disk type='file' device='cdrom'&gt;
1954                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1955                   &lt;target dev='hdb' bus='ide'/&gt;
1956                   &lt;readonly/&gt;
1957                   &lt;alias name='ide0-0-1'/&gt;
1958                   &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
1959                 &lt;/disk&gt;
1960                 &lt;disk type='file' device='cdrom'&gt;
1961                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1962                   &lt;source file='/srv/dvd-image-2.iso'/&gt;
1963                   &lt;backingStore/&gt;
1964                   &lt;target dev='hdc' bus='ide'/&gt;
1965                   &lt;readonly/&gt;
1966                   &lt;alias name='ide0-0-2'/&gt;
1967                   &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
1968                 &lt;/disk&gt;
1969                 &lt;disk type='file' device='cdrom'&gt;
1970                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1971                   &lt;source file='/srv/dvd-image-3.iso'/&gt;
1972                   &lt;backingStore/&gt;
1973                   &lt;target dev='hdd' bus='ide'/&gt;
1974                   &lt;readonly/&gt;
1975                   &lt;alias name='ide0-0-3'/&gt;
1976                   &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
1977                 &lt;/disk&gt;
1978                 &lt;disk type='network' device='cdrom'&gt;
1979                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1980                   &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
1981                     &lt;host name='test-srv.local' port='80'/&gt;
1982                   &lt;/source&gt;
1983                   &lt;backingStore/&gt;
1984                   &lt;target dev='hde' bus='ide'/&gt;
1985                   &lt;readonly/&gt;
1986                 &lt;/disk&gt;
1987               &lt;/devices&gt;
1988             &lt;/domain&gt;
1989         """
1990         domain_mock = self.set_mock_vm("my_vm", xml)
1991         domain_mock.OSType.return_value = "hvm"
1992         self.mock_conn.defineXML.return_value = True
1993         updatedev_mock = MagicMock(return_value=0)
1994         domain_mock.updateDeviceFlags = updatedev_mock
1995         ret = virt.update(
1996             "my_vm",
1997             disks=[
1998                 {
1999                     "name": "dvd1",
2000                     "device": "cdrom",
2001                     "source_file": None,
2002                     "model": "ide",
2003                 },
2004                 {
2005                     "name": "dvd2",
2006                     "device": "cdrom",
2007                     "source_file": "/srv/dvd-image-4.iso",
2008                     "model": "ide",
2009                 },
2010                 {
2011                     "name": "dvd3",
2012                     "device": "cdrom",
2013                     "source_file": "/srv/dvd-image-2.iso",
2014                     "model": "ide",
2015                 },
2016                 {
2017                     "name": "dvd4",
2018                     "device": "cdrom",
2019                     "source_file": "/srv/dvd-image-5.iso",
2020                     "model": "ide",
2021                 },
2022                 {
2023                     "name": "dvd5",
2024                     "device": "cdrom",
2025                     "source_file": "/srv/dvd-image-6.iso",
2026                     "model": "ide",
2027                 },
2028             ],
2029         )
2030         self.assertTrue(ret["definition"])
2031         self.assertFalse(ret["disk"].get("attached"))
2032         self.assertFalse(ret["disk"].get("detached"))
2033         self.assertEqual(
2034             [
2035                 {
2036                     "type": "file",
2037                     "device": "cdrom",
2038                     "driver": {
2039                         "name": "qemu",
2040                         "type": "raw",
2041                         "cache": "none",
2042                         "io": "native",
2043                     },
2044                     "backingStore": None,
2045                     "target": {"dev": "hda", "bus": "ide"},
2046                     "readonly": None,
2047                     "alias": {"name": "ide0-0-0"},
2048                     "address": {
2049                         "type": "drive",
2050                         "controller": "0",
2051                         "bus": "0",
2052                         "target": "0",
2053                         "unit": "0",
2054                     },
2055                 },
2056                 {
2057                     "type": "file",
2058                     "device": "cdrom",
2059                     "driver": {
2060                         "name": "qemu",
2061                         "type": "raw",
2062                         "cache": "none",
2063                         "io": "native",
2064                     },
2065                     "target": {"dev": "hdb", "bus": "ide"},
2066                     "readonly": None,
2067                     "alias": {"name": "ide0-0-1"},
2068                     "address": {
2069                         "type": "drive",
2070                         "controller": "0",
2071                         "bus": "0",
2072                         "target": "0",
2073                         "unit": "1",
2074                     },
2075                     "source": {"file": "/srv/dvd-image-4.iso"},
2076                 },
2077                 {
2078                     "type": "file",
2079                     "device": "cdrom",
2080                     "driver": {
2081                         "name": "qemu",
2082                         "type": "raw",
2083                         "cache": "none",
2084                         "io": "native",
2085                     },
2086                     "backingStore": None,
2087                     "target": {"dev": "hdd", "bus": "ide"},
2088                     "readonly": None,
2089                     "alias": {"name": "ide0-0-3"},
2090                     "address": {
2091                         "type": "drive",
2092                         "controller": "0",
2093                         "bus": "0",
2094                         "target": "0",
2095                         "unit": "3",
2096                     },
2097                     "source": {"file": "/srv/dvd-image-5.iso"},
2098                 },
2099                 {
2100                     "type": "file",
2101                     "device": "cdrom",
2102                     "driver": {
2103                         "name": "qemu",
2104                         "type": "raw",
2105                         "cache": "none",
2106                         "io": "native",
2107                     },
2108                     "backingStore": None,
2109                     "target": {"dev": "hde", "bus": "ide"},
2110                     "readonly": None,
2111                     "source": {"file": "/srv/dvd-image-6.iso"},
2112                 },
2113             ],
2114             [
2115                 salt.utils.xmlutil.to_dict(ET.fromstring(disk), True)
2116                 for disk in ret["disk"]["updated"]
2117             ],
2118         )
2119     def test_update_xen_boot_params(self):
2120         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
2121         xml_boot = """
2122             &lt;domain type='xen' id='8'&gt;
2123               &lt;name&gt;vm&lt;/name&gt;
2124               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2125               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2126               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2127               &lt;os&gt;
2128                 &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
2129                 &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
2130               &lt;/os&gt;
2131             &lt;/domain&gt;
2132         """
2133         domain_mock_boot = self.set_mock_vm("vm", xml_boot)
2134         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2135         define_mock_boot = MagicMock(return_value=True)
2136         define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
2137         self.mock_conn.defineXML = define_mock_boot
2138         self.assertEqual(
2139             {
2140                 "cpu": False,
2141                 "definition": True,
2142                 "disk": {"attached": [], "detached": [], "updated": []},
2143                 "interface": {"attached": [], "detached": []},
2144             },
2145             virt.update("vm", cpu=2),
2146         )
2147         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2148         self.assertEqual(setxml.find("os").find("loader").attrib.get("type"), "rom")
2149         self.assertEqual(
2150             setxml.find("os").find("loader").text, "/usr/lib/xen/boot/hvmloader"
2151         )
2152     def test_update_existing_boot_params(self):
2153         xml_boot = """
2154             &lt;domain type='kvm' id='8'&gt;
2155               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2156               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2157               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2158               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2159               &lt;os&gt;
2160                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2161                 &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
2162                 &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
2163                 &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
2164                 &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
2165                 &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
2166               &lt;/os&gt;
2167             &lt;/domain&gt;
2168         """
2169         domain_mock_boot = self.set_mock_vm("vm_with_boot_param", xml_boot)
2170         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2171         define_mock_boot = MagicMock(return_value=True)
2172         self.mock_conn.defineXML = define_mock_boot
2173         boot_new = {
2174             "kernel": "/root/new-vmlinuz",
2175             "initrd": "/root/new-initrd",
2176             "cmdline": "console=ttyS0 ks=http://example.com/new/os/",
2177         }
2178         uefi_boot_new = {
2179             "loader": "/usr/share/new/OVMF_CODE.fd",
2180             "nvram": "/usr/share/new/OVMF_VARS.ms.fd",
2181         }
2182         self.assertEqual(
2183             {
2184                 "definition": True,
2185                 "disk": {"attached": [], "detached": [], "updated": []},
2186                 "interface": {"attached": [], "detached": []},
2187             },
2188             virt.update("vm_with_boot_param", boot=boot_new),
2189         )
2190         setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
2191         self.assertEqual(
2192             setxml_boot.find("os").find("kernel").text, "/root/new-vmlinuz"
2193         )
2194         self.assertEqual(setxml_boot.find("os").find("initrd").text, "/root/new-initrd")
2195         self.assertEqual(
2196             setxml_boot.find("os").find("cmdline").text,
2197             "console=ttyS0 ks=http://example.com/new/os/",
2198         )
2199         self.assertEqual(
2200             {
2201                 "definition": True,
2202                 "disk": {"attached": [], "detached": [], "updated": []},
2203                 "interface": {"attached": [], "detached": []},
2204             },
2205             virt.update("vm_with_boot_param", boot=uefi_boot_new),
2206         )
2207         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2208         self.assertEqual(
2209             setxml.find("os").find("loader").text, "/usr/share/new/OVMF_CODE.fd"
2210         )
2211         self.assertEqual(setxml.find("os").find("loader").attrib.get("readonly"), "yes")
2212         self.assertEqual(setxml.find("os").find("loader").attrib["type"], "pflash")
2213         self.assertEqual(
2214             setxml.find("os").find("nvram").attrib["template"],
2215             "/usr/share/new/OVMF_VARS.ms.fd",
2216         )
2217         kernel_none = {
2218             "kernel": None,
2219             "initrd": None,
2220             "cmdline": None,
2221         }
2222         uefi_none = {"loader": None, "nvram": None}
2223         self.assertEqual(
2224             {
2225                 "definition": True,
2226                 "disk": {"attached": [], "detached": [], "updated": []},
2227                 "interface": {"attached": [], "detached": []},
2228             },
2229             virt.update("vm_with_boot_param", boot=kernel_none),
2230         )
2231         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2232         self.assertEqual(setxml.find("os").find("kernel"), None)
2233         self.assertEqual(setxml.find("os").find("initrd"), None)
2234         self.assertEqual(setxml.find("os").find("cmdline"), None)
2235         self.assertEqual(
2236             {
2237                 "definition": True,
2238                 "disk": {"attached": [], "detached": [], "updated": []},
2239                 "interface": {"attached": [], "detached": []},
2240             },
2241             virt.update("vm_with_boot_param", boot={"efi": False}),
2242         )
2243         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2244         self.assertEqual(setxml.find("os").find("nvram"), None)
2245         self.assertEqual(setxml.find("os").find("loader"), None)
2246         self.assertEqual(
2247             {
2248                 "definition": True,
2249                 "disk": {"attached": [], "detached": [], "updated": []},
2250                 "interface": {"attached": [], "detached": []},
2251             },
2252             virt.update("vm_with_boot_param", boot=uefi_none),
2253         )
2254         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2255         self.assertEqual(setxml.find("os").find("loader"), None)
2256         self.assertEqual(setxml.find("os").find("nvram"), None)
2257     def test_update_existing_numatune_params(self):
2258         xml_numatune = """
2259             &lt;domain type='kvm' id='8'&gt;
2260               &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
2261               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2262               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2263               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
2264               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2265               &lt;numatune&gt;
2266                 &lt;memory mode="strict" nodeset="0-11"/&gt;
2267                 &lt;memnode cellid="1" mode="strict" nodeset="3"/&gt;
2268                 &lt;memnode cellid="3" mode="preferred" nodeset="7"/&gt;
2269               &lt;/numatune&gt;
2270               &lt;os&gt;
2271                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2272               &lt;/os&gt;
2273               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
2274             &lt;/domain&gt;
2275         """
2276         domain_mock = self.set_mock_vm("vm_with_numatune_param", xml_numatune)
2277         domain_mock.OSType = MagicMock(return_value="hvm")
2278         define_mock = MagicMock(return_value=True)
2279         self.mock_conn.defineXML = define_mock
2280         numatune = {
2281             "memory": {"mode": "preferred", "nodeset": "0-5"},
2282             "memnodes": {
2283                 0: {"mode": "strict", "nodeset": "4"},
2284                 3: {"mode": "preferred", "nodeset": "7"},
2285                 4: {"mode": "strict", "nodeset": "6"},
2286             },
2287         }
2288         self.assertEqual(
2289             {
2290                 "definition": True,
2291                 "disk": {"attached": [], "detached": [], "updated": []},
2292                 "interface": {"attached": [], "detached": []},
2293             },
2294             virt.update("vm_with_numatune_param", numatune=numatune),
2295         )
2296         setxml = ET.fromstring(define_mock.call_args[0][0])
2297         self.assertEqual(
2298             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2299         )
2300         self.assertEqual(
2301             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2302             ",".join([str(i) for i in range(0, 6)]),
2303         )
2304         self.assertEqual(
2305             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2306         )
2307         self.assertEqual(
2308             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2309         )
2310         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='1']"), None)
2311         self.assertEqual(
2312             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2313             "preferred",
2314         )
2315         self.assertEqual(
2316             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2317         )
2318         self.assertEqual(
2319             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("mode"), "strict"
2320         )
2321         self.assertEqual(
2322             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("nodeset"), "6"
2323         )
2324         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2325         numatune_mem_none = {
2326             "memory": None,
2327             "memnodes": {
2328                 0: {"mode": "strict", "nodeset": "4"},
2329                 3: {"mode": "preferred", "nodeset": "7"},
2330                 4: {"mode": "strict", "nodeset": "6"},
2331             },
2332         }
2333         self.assertEqual(
2334             {
2335                 "definition": True,
2336                 "disk": {"attached": [], "detached": [], "updated": []},
2337                 "interface": {"attached": [], "detached": []},
2338             },
2339             virt.update("vm_with_numatune_param", numatune=numatune_mem_none),
2340         )
2341         setxml = ET.fromstring(define_mock.call_args[0][0])
2342         self.assertEqual(setxml.find("numatune").find("memory"), None)
2343         self.assertEqual(
2344             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2345         )
2346         self.assertEqual(
2347             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2348         )
2349         self.assertEqual(
2350             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2351             "preferred",
2352         )
2353         self.assertEqual(
2354             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2355         )
2356         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2357         numatune_mnodes_none = {
2358             "memory": {"mode": "preferred", "nodeset": "0-5"},
2359             "memnodes": None,
2360         }
2361         self.assertEqual(
2362             {
2363                 "definition": True,
2364                 "disk": {"attached": [], "detached": [], "updated": []},
2365                 "interface": {"attached": [], "detached": []},
2366             },
2367             virt.update("vm_with_numatune_param", numatune=numatune_mnodes_none),
2368         )
2369         setxml = ET.fromstring(define_mock.call_args[0][0])
2370         self.assertEqual(
2371             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2372         )
2373         self.assertEqual(
2374             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2375             ",".join([str(i) for i in range(0, 6)]),
2376         )
2377         self.assertEqual(setxml.find("./numatune/memnode"), None)
2378         numatune_without_change = {
2379             "memory": {"mode": "strict", "nodeset": "0-5,6,7-11"},
2380             "memnodes": {
2381                 1: {"mode": "strict", "nodeset": "3"},
2382                 3: {"mode": "preferred", "nodeset": "7"},
2383             },
2384         }
2385         self.assertEqual(
2386             {
2387                 "definition": False,
2388                 "disk": {"attached": [], "detached": [], "updated": []},
2389                 "interface": {"attached": [], "detached": []},
2390             },
2391             virt.update("vm_with_numatune_param", numatune=numatune_without_change),
2392         )
2393         self.assertEqual(
2394             {
2395                 "definition": True,
2396                 "disk": {"attached": [], "detached": [], "updated": []},
2397                 "interface": {"attached": [], "detached": []},
2398             },
2399             virt.update(
2400                 "vm_with_numatune_param", numatune={"memory": None, "memnodes": None}
2401             ),
2402         )
2403         setxml = ET.fromstring(define_mock.call_args[0][0])
2404         self.assertEqual(setxml.find("numatune"), None)
2405     def test_update_existing_cpu_params(self):
2406         xml_with_existing_params = """
2407             &lt;domain type='kvm' id='8'&gt;
2408               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2409               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2410               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2411               &lt;vcpu placement="static" cpuset="0-11" current="3"&gt;6&lt;/vcpu&gt;
2412               &lt;vcpus&gt;
2413                 &lt;vcpu id="0" enabled="yes" hotpluggable="no" order="1"/&gt;
2414                 &lt;vcpu id="1" enabled="no" hotpluggable="yes"/&gt;
2415                 &lt;vcpu id="2" enabled="no" hotpluggable="yes"/&gt;
2416                 &lt;vcpu id="3" enabled="no" hotpluggable="yes"/&gt;
2417                 &lt;vcpu id="4" enabled="no" hotpluggable="yes"/&gt;
2418                 &lt;vcpu id="5" enabled="no" hotpluggable="yes"/&gt;
2419                 &lt;vcpu id="6" enabled="no" hotpluggable="yes"/&gt;
2420                 &lt;vcpu id="7" enabled="no" hotpluggable="yes"/&gt;
2421                 &lt;vcpu id="8" enabled="no" hotpluggable="yes"/&gt;
2422                 &lt;vcpu id="9" enabled="no" hotpluggable="yes"/&gt;
2423                 &lt;vcpu id="10" enabled="no" hotpluggable="yes"/&gt;
2424                 &lt;vcpu id="11" enabled="no" hotpluggable="yes"/&gt;
2425               &lt;/vcpus&gt;
2426               &lt;cpu mode="custom" match="exact" check="full"&gt;
2427                  &lt;model fallback="allow" vendor_id="Genuine20201"&gt;core2duo&lt;/model&gt;
2428                  &lt;vendor&gt;Intel&lt;/vendor&gt;
2429                  &lt;topology sockets="2" cores="5" threads="2"/&gt;
2430                  &lt;cache level="3" mode="emulate"/&gt;
2431                  &lt;feature policy="optional" name="lahf_lm"/&gt;
2432                  &lt;feature policy="require" name="pcid"/&gt;
2433                  &lt;numa&gt;
2434                     &lt;cell id="0" cpus="0-3" memory="1073741824" unit="KiB" discard="no"&gt;
2435                         &lt;distances&gt;
2436                             &lt;sibling id="0" value="10"/&gt;
2437                             &lt;sibling id="1" value="21"/&gt;
2438                             &lt;sibling id="2" value="31"/&gt;
2439                             &lt;sibling id="3" value="41"/&gt;
2440                         &lt;/distances&gt;
2441                     &lt;/cell&gt;
2442                     &lt;cell id="1" cpus="4-6" memory="1073741824" unit="KiB" memAccess="private"&gt;
2443                         &lt;distances&gt;
2444                             &lt;sibling id="0" value="21"/&gt;
2445                             &lt;sibling id="1" value="10"/&gt;
2446                             &lt;sibling id="2" value="21"/&gt;
2447                             &lt;sibling id="3" value="31"/&gt;
2448                         &lt;/distances&gt;
2449                     &lt;/cell&gt;
2450                  &lt;/numa&gt;
2451               &lt;/cpu&gt;
2452               &lt;os&gt;
2453                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2454               &lt;/os&gt;
2455               &lt;/domain&gt;
2456          """
2457         domain_mock = self.set_mock_vm(
2458             "vm_with_existing_param", xml_with_existing_params
2459         )
2460         domain_mock.OSType = MagicMock(return_value="hvm")
2461         define_mock = MagicMock(return_value=True)
2462         self.mock_conn.defineXML = define_mock
2463         setvcpus_mock = MagicMock(return_value=0)
2464         domain_mock.setVcpusFlags = setvcpus_mock
2465         cpu_attr = {"placement": "static", "cpuset": "0-5", "current": 3, "maximum": 5}
2466         self.assertEqual(
2467             {
2468                 "definition": True,
2469                 "cpu": True,
2470                 "disk": {"attached": [], "detached": [], "updated": []},
2471                 "interface": {"attached": [], "detached": []},
2472             },
2473             virt.update("vm_with_existing_param", cpu=cpu_attr),
2474         )
2475         setxml = ET.fromstring(define_mock.call_args[0][0])
2476         self.assertEqual(setxml.find("vcpu").text, "5")
2477         self.assertEqual(setxml.find("vcpu").attrib["placement"], "static")
2478         self.assertEqual(
2479             setxml.find("vcpu").attrib["cpuset"],
2480             ",".join([str(i) for i in range(0, 6)]),
2481         )
2482         self.assertEqual(setxml.find("vcpu").attrib["current"], "3")
2483         cpu_none = {"placement": "auto", "cpuset": None, "current": 2, "maximum": 5}
2484         self.assertEqual(
2485             {
2486                 "definition": True,
2487                 "cpu": True,
2488                 "disk": {"attached": [], "detached": [], "updated": []},
2489                 "interface": {"attached": [], "detached": []},
2490             },
2491             virt.update("vm_with_existing_param", cpu=cpu_none),
2492         )
2493         setxml = ET.fromstring(define_mock.call_args[0][0])
2494         self.assertEqual(setxml.find("vcpu").text, "5")
2495         self.assertEqual(setxml.find("vcpu").attrib["placement"], "auto")
2496         self.assertEqual(setxml.find("vcpu").attrib.get("cpuset"), None)
2497         self.assertEqual(setxml.find("vcpu").attrib.get("current"), "2")
2498         vcpus = {
2499             "vcpus": {
2500                 "0": {"enabled": False, "hotpluggable": True, "order": 5},
2501                 "3": {"enabled": True, "hotpluggable": False, "order": 3},
2502                 "7": {"enabled": True, "hotpluggable": False},
2503             }
2504         }
2505         self.assertEqual(
2506             {
2507                 "definition": True,
2508                 "disk": {"attached": [], "detached": [], "updated": []},
2509                 "interface": {"attached": [], "detached": []},
2510             },
2511             virt.update("vm_with_existing_param", cpu=vcpus),
2512         )
2513         setxml = ET.fromstring(define_mock.call_args[0][0])
2514         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["id"], "0")
2515         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["enabled"], "no")
2516         self.assertEqual(
2517             setxml.find("./vcpus/vcpu/[@id='0']").attrib["hotpluggable"], "yes"
2518         )
2519         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["order"], "5")
2520         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["id"], "3")
2521         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2522         self.assertEqual(
2523             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2524         )
2525         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["order"], "3")
2526         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["id"], "7")
2527         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["enabled"], "yes")
2528         self.assertEqual(
2529             setxml.find("./vcpus/vcpu/[@id='7']").attrib["hotpluggable"], "no"
2530         )
2531         self.assertEqual(
2532             setxml.find("./vcpus/vcpu/[@id='7']").attrib.get("order"), None
2533         )
2534         ind_vcpu = {
2535             "vcpus": {"3": {"enabled": True, "hotpluggable": False, "order": None}}
2536         }
2537         self.assertEqual(
2538             {
2539                 "definition": True,
2540                 "disk": {"attached": [], "detached": [], "updated": []},
2541                 "interface": {"attached": [], "detached": []},
2542             },
2543             virt.update("vm_with_existing_param", cpu=ind_vcpu),
2544         )
2545         setxml = ET.fromstring(define_mock.call_args[0][0])
2546         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']"), None)
2547         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2548         self.assertEqual(
2549             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2550         )
2551         self.assertEqual(
2552             setxml.find("./vcpus/vcpu/[@id='3']").attrib.get("order"), None
2553         )
2554         vcpus_none = {"vcpus": None}
2555         self.assertEqual(
2556             {
2557                 "definition": True,
2558                 "disk": {"attached": [], "detached": [], "updated": []},
2559                 "interface": {"attached": [], "detached": []},
2560             },
2561             virt.update("vm_with_existing_param", cpu=vcpus_none),
2562         )
2563         setxml = ET.fromstring(define_mock.call_args[0][0])
2564         self.assertEqual(setxml.find("vcpus"), None)
2565         cpu_atr_none = {"match": None, "mode": None, "check": None}
2566         self.assertEqual(
2567             {
2568                 "definition": True,
2569                 "disk": {"attached": [], "detached": [], "updated": []},
2570                 "interface": {"attached": [], "detached": []},
2571             },
2572             virt.update("vm_with_existing_param", cpu=cpu_atr_none),
2573         )
2574         setxml = ET.fromstring(define_mock.call_args[0][0])
2575         self.assertEqual(setxml.find("cpu").attrib, {})
2576         cpu_atr_mn = {"match": None}
2577         self.assertEqual(
2578             {
2579                 "definition": True,
2580                 "disk": {"attached": [], "detached": [], "updated": []},
2581                 "interface": {"attached": [], "detached": []},
2582             },
2583             virt.update("vm_with_existing_param", cpu=cpu_atr_mn),
2584         )
2585         setxml = ET.fromstring(define_mock.call_args[0][0])
2586         self.assertEqual(setxml.find("cpu").attrib.get("match"), None)
2587         self.assertEqual(setxml.find("cpu").attrib.get("mode"), "custom")
2588         self.assertEqual(setxml.find("cpu").attrib.get("check"), "full")
2589         cpu_model_none = {"model": None}
2590         self.assertEqual(
2591             {
2592                 "definition": True,
2593                 "disk": {"attached": [], "detached": [], "updated": []},
2594                 "interface": {"attached": [], "detached": []},
2595             },
2596             virt.update("vm_with_existing_param", cpu=cpu_model_none),
2597         )
2598         setxml = ET.fromstring(define_mock.call_args[0][0])
2599         self.assertEqual(setxml.find("cpu").find("model"), None)
2600         cpu_model_atr_none = {
2601             "model": {"name": "coresolo", "fallback": "forbid", "vendor_id": None}
2602         }
2603         self.assertEqual(
2604             {
2605                 "definition": True,
2606                 "disk": {"attached": [], "detached": [], "updated": []},
2607                 "interface": {"attached": [], "detached": []},
2608             },
2609             virt.update("vm_with_existing_param", cpu=cpu_model_atr_none),
2610         )
2611         setxml = ET.fromstring(define_mock.call_args[0][0])
2612         self.assertEqual(setxml.find("cpu").find("model").attrib.get("vendor_id"), None)
2613         self.assertEqual(
2614             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2615         )
2616         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2617         cpu_model_atr = {
2618             "model": {
2619                 "name": "coresolo",
2620                 "fallback": "forbid",
2621                 "vendor_id": "AuthenticAMD",
2622             }
2623         }
2624         self.assertEqual(
2625             {
2626                 "definition": True,
2627                 "disk": {"attached": [], "detached": [], "updated": []},
2628                 "interface": {"attached": [], "detached": []},
2629             },
2630             virt.update("vm_with_existing_param", cpu=cpu_model_atr),
2631         )
2632         setxml = ET.fromstring(define_mock.call_args[0][0])
2633         self.assertEqual(
2634             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2635         )
2636         self.assertEqual(
2637             setxml.find("cpu").find("model").attrib.get("vendor_id"), "AuthenticAMD"
2638         )
2639         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2640         cpu_vendor = {"vendor": "AMD"}
2641         self.assertEqual(
2642             {
2643                 "definition": True,
2644                 "disk": {"attached": [], "detached": [], "updated": []},
2645                 "interface": {"attached": [], "detached": []},
2646             },
2647             virt.update("vm_with_existing_param", cpu=cpu_vendor),
2648         )
2649         setxml = ET.fromstring(define_mock.call_args[0][0])
2650         self.assertEqual(setxml.find("cpu").find("vendor").text, "AMD")
2651         cpu_vendor_none = {"vendor": None}
2652         self.assertEqual(
2653             {
2654                 "definition": True,
2655                 "disk": {"attached": [], "detached": [], "updated": []},
2656                 "interface": {"attached": [], "detached": []},
2657             },
2658             virt.update("vm_with_existing_param", cpu=cpu_vendor_none),
2659         )
2660         setxml = ET.fromstring(define_mock.call_args[0][0])
2661         self.assertEqual(setxml.find("cpu").find("vendor"), None)
2662         cpu_topology = {"topology": {"sockets": 1, "cores": 12, "threads": 1}}
2663         self.assertEqual(
2664             {
2665                 "definition": True,
2666                 "disk": {"attached": [], "detached": [], "updated": []},
2667                 "interface": {"attached": [], "detached": []},
2668             },
2669             virt.update("vm_with_existing_param", cpu=cpu_topology),
2670         )
2671         setxml = ET.fromstring(define_mock.call_args[0][0])
2672         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("sockets"), "1")
2673         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2674         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2675         cpu_topology_atr_none = {
2676             "topology": {"sockets": None, "cores": 12, "threads": 1}
2677         }
2678         self.assertEqual(
2679             {
2680                 "definition": True,
2681                 "disk": {"attached": [], "detached": [], "updated": []},
2682                 "interface": {"attached": [], "detached": []},
2683             },
2684             virt.update("vm_with_existing_param", cpu=cpu_topology_atr_none),
2685         )
2686         setxml = ET.fromstring(define_mock.call_args[0][0])
2687         self.assertEqual(
2688             setxml.find("cpu").find("topology").attrib.get("sockets"), None
2689         )
2690         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2691         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2692         cpu_topology_none = {"topology": None}
2693         self.assertEqual(
2694             {
2695                 "definition": True,
2696                 "disk": {"attached": [], "detached": [], "updated": []},
2697                 "interface": {"attached": [], "detached": []},
2698             },
2699             virt.update("vm_with_existing_param", cpu=cpu_topology_none),
2700         )
2701         setxml = ET.fromstring(define_mock.call_args[0][0])
2702         self.assertEqual(setxml.find("cpu").find("topology"), None)
2703         cpu_cache = {"cache": {"mode": "passthrough", "level": 2}}
2704         self.assertEqual(
2705             {
2706                 "definition": True,
2707                 "disk": {"attached": [], "detached": [], "updated": []},
2708                 "interface": {"attached": [], "detached": []},
2709             },
2710             virt.update("vm_with_existing_param", cpu=cpu_cache),
2711         )
2712         setxml = ET.fromstring(define_mock.call_args[0][0])
2713         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), "2")
2714         self.assertEqual(
2715             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2716         )
2717         cpu_cache_atr_none = {"cache": {"mode": "passthrough", "level": None}}
2718         self.assertEqual(
2719             {
2720                 "definition": True,
2721                 "disk": {"attached": [], "detached": [], "updated": []},
2722                 "interface": {"attached": [], "detached": []},
2723             },
2724             virt.update("vm_with_existing_param", cpu=cpu_cache_atr_none),
2725         )
2726         setxml = ET.fromstring(define_mock.call_args[0][0])
2727         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), None)
2728         self.assertEqual(
2729             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2730         )
2731         cpu_cache_none = {"cache": None}
2732         self.assertEqual(
2733             {
2734                 "definition": True,
2735                 "disk": {"attached": [], "detached": [], "updated": []},
2736                 "interface": {"attached": [], "detached": []},
2737             },
2738             virt.update("vm_with_existing_param", cpu=cpu_cache_none),
2739         )
2740         setxml = ET.fromstring(define_mock.call_args[0][0])
2741         self.assertEqual(setxml.find("cpu").find("cache"), None)
2742         cpu_feature = {"features": {"lahf_lm": "require", "pcid": "optional"}}
2743         self.assertEqual(
2744             {
2745                 "definition": True,
2746                 "disk": {"attached": [], "detached": [], "updated": []},
2747                 "interface": {"attached": [], "detached": []},
2748             },
2749             virt.update("vm_with_existing_param", cpu=cpu_feature),
2750         )
2751         setxml = ET.fromstring(define_mock.call_args[0][0])
2752         self.assertEqual(
2753             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2754         )
2755         self.assertEqual(
2756             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2757             "require",
2758         )
2759         cpu_feature_atr_none = {"features": {"pcid": "optional", "lahf_lm": "disable"}}
2760         self.assertEqual(
2761             {
2762                 "definition": True,
2763                 "disk": {"attached": [], "detached": [], "updated": []},
2764                 "interface": {"attached": [], "detached": []},
2765             },
2766             virt.update("vm_with_existing_param", cpu=cpu_feature_atr_none),
2767         )
2768         setxml = ET.fromstring(define_mock.call_args[0][0])
2769         self.assertEqual(
2770             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2771             "disable",
2772         )
2773         self.assertEqual(
2774             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2775         )
2776         cpu_feature_none = {"features": {"lahf_lm": None, "pcid": None}}
2777         self.assertEqual(
2778             {
2779                 "definition": True,
2780                 "disk": {"attached": [], "detached": [], "updated": []},
2781                 "interface": {"attached": [], "detached": []},
2782             },
2783             virt.update("vm_with_existing_param", cpu=cpu_feature_none),
2784         )
2785         setxml = ET.fromstring(define_mock.call_args[0][0])
2786         self.assertEqual(setxml.find("./cpu/feature"), None)
2787         numa_cell = {
2788             "numa": {
2789                 0: {
2790                     "cpus": "0-6",
2791                     "memory": "512m",
2792                     "discard": True,
2793                     "distances": {0: 15, 1: 16, 2: 17, 3: 18},
2794                 },
2795                 1: {
2796                     "cpus": "7-12",
2797                     "memory": "2g",
2798                     "discard": True,
2799                     "memAccess": "shared",
2800                     "distances": {0: 23, 1: 24, 2: 25, 3: 26},
2801                 },
2802             }
2803         }
2804         self.assertEqual(
2805             {
2806                 "definition": True,
2807                 "disk": {"attached": [], "detached": [], "updated": []},
2808                 "interface": {"attached": [], "detached": []},
2809             },
2810             virt.update("vm_with_existing_param", cpu=numa_cell),
2811         )
2812         setxml = ET.fromstring(define_mock.call_args[0][0])
2813         self.assertEqual(
2814             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2815             ",".join([str(i) for i in range(0, 7)]),
2816         )
2817         self.assertEqual(
2818             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2819             str(512 * 1024 ** 2),
2820         )
2821         self.assertEqual(
2822             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2823             "bytes",
2824         )
2825         self.assertEqual(
2826             setxml.find("./cpu/numa/cell/[@id='0']").attrib["discard"], "yes"
2827         )
2828         self.assertEqual(
2829             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2830                 "value"
2831             ],
2832             "15",
2833         )
2834         self.assertEqual(
2835             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']").attrib[
2836                 "value"
2837             ],
2838             "16",
2839         )
2840         self.assertEqual(
2841             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2842                 "value"
2843             ],
2844             "17",
2845         )
2846         self.assertEqual(
2847             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2848                 "value"
2849             ],
2850             "18",
2851         )
2852         self.assertEqual(
2853             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2854             ",".join([str(i) for i in range(7, 13)]),
2855         )
2856         self.assertEqual(
2857             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2858             str(int(2 * 1024 ** 3)),
2859         )
2860         self.assertEqual(
2861             setxml.find("./cpu/numa/cell/[@id='1']").get("unit"),
2862             "bytes",
2863         )
2864         self.assertEqual(
2865             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2866         )
2867         self.assertEqual(
2868             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memAccess"], "shared"
2869         )
2870         self.assertEqual(
2871             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2872                 "value"
2873             ],
2874             "23",
2875         )
2876         self.assertEqual(
2877             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2878                 "value"
2879             ],
2880             "24",
2881         )
2882         self.assertEqual(
2883             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2884                 "value"
2885             ],
2886             "25",
2887         )
2888         self.assertEqual(
2889             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']").attrib[
2890                 "value"
2891             ],
2892             "26",
2893         )
2894         numa_cell_atr_none = {
2895             "numa": {
2896                 "0": {
2897                     "cpus": "0-6",
2898                     "memory": "512m",
2899                     "discard": False,
2900                     "distances": {0: 15, 2: 17, 3: 18},
2901                 },
2902                 "1": {
2903                     "cpus": "7-12",
2904                     "memory": "2g",
2905                     "discard": True,
2906                     "distances": {0: 23, 1: 24, 2: 25},
2907                 },
2908             }
2909         }
2910         self.assertEqual(
2911             {
2912                 "definition": True,
2913                 "disk": {"attached": [], "detached": [], "updated": []},
2914                 "interface": {"attached": [], "detached": []},
2915             },
2916             virt.update("vm_with_existing_param", cpu=numa_cell_atr_none),
2917         )
2918         setxml = ET.fromstring(define_mock.call_args[0][0])
2919         self.assertEqual(
2920             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2921             ",".join([str(i) for i in range(0, 7)]),
2922         )
2923         self.assertEqual(
2924             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2925             str(512 * 1024 ** 2),
2926         )
2927         self.assertEqual(
2928             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2929             "bytes",
2930         )
2931         self.assertEqual(
2932             setxml.find("./cpu/numa/cell/[@id='0']").attrib.get("discard"), "no"
2933         )
2934         self.assertEqual(
2935             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2936                 "value"
2937             ],
2938             "15",
2939         )
2940         self.assertEqual(
2941             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']"), None
2942         )
2943         self.assertEqual(
2944             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2945                 "value"
2946             ],
2947             "17",
2948         )
2949         self.assertEqual(
2950             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2951                 "value"
2952             ],
2953             "18",
2954         )
2955         self.assertEqual(
2956             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2957             ",".join([str(i) for i in range(7, 13)]),
2958         )
2959         self.assertEqual(
2960             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2961             str(int(2 * 1024 ** 3)),
2962         )
2963         self.assertEqual(
2964             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2965         )
2966         self.assertEqual(
2967             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2968                 "value"
2969             ],
2970             "23",
2971         )
2972         self.assertEqual(
2973             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2974                 "value"
2975             ],
2976             "24",
2977         )
2978         self.assertEqual(
2979             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2980                 "value"
2981             ],
2982             "25",
2983         )
2984         self.assertEqual(
2985             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"), None
2986         )
2987         self.assertEqual(
2988             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2989             ",".join([str(i) for i in range(7, 13)]),
2990         )
2991         self.assertEqual(
2992             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2993             str(int(1024 ** 3 * 2)),
2994         )
2995         self.assertEqual(
2996             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2997         )
2998         self.assertEqual(
2999             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
3000                 "value"
3001             ],
3002             "23",
3003         )
3004         self.assertEqual(
3005             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3006                 "value"
3007             ],
3008             "24",
3009         )
3010         self.assertEqual(
3011             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3012                 "value"
3013             ],
3014             "25",
3015         )
3016         self.assertEqual(
3017             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"),
3018             None,
3019         )
3020     def test_update_memtune_params(self):
3021         xml_with_memtune_params = """
3022             &lt;domain type='kvm' id='8'&gt;
3023               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
3024               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3025               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3026               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
3027               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3028               &lt;memtune&gt;
3029                 &lt;hard_limit unit="KiB"&gt;1048576&lt;/hard_limit&gt;
3030                 &lt;soft_limit unit="KiB"&gt;2097152&lt;/soft_limit&gt;
3031                 &lt;swap_hard_limit unit="KiB"&gt;2621440&lt;/swap_hard_limit&gt;
3032                 &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
3033               &lt;/memtune&gt;
3034               &lt;os&gt;
3035                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3036               &lt;/os&gt;
3037             &lt;/domain&gt;
3038         """
3039         domain_mock = self.set_mock_vm("vm_with_memtune_param", xml_with_memtune_params)
3040         domain_mock.OSType = MagicMock(return_value="hvm")
3041         define_mock = MagicMock(return_value=True)
3042         self.mock_conn.defineXML = define_mock
3043         memtune_new_val = {
3044             "boot": "0.7g",
3045             "current": "2.5g",
3046             "max": "3096m",
3047             "slots": "10",
3048             "soft_limit": "2048m",
3049             "hard_limit": "1024",
3050             "swap_hard_limit": "2.5g",
3051             "min_guarantee": "1 g",
3052         }
3053         domain_mock.setMemoryFlags.return_value = 0
3054         self.assertEqual(
3055             {
3056                 "definition": True,
3057                 "disk": {"attached": [], "detached": [], "updated": []},
3058                 "interface": {"attached": [], "detached": []},
3059                 "mem": True,
3060             },
3061             virt.update("vm_with_memtune_param", mem=memtune_new_val),
3062         )
3063         self.assertEqual(
3064             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3065         )
3066         setxml = ET.fromstring(define_mock.call_args[0][0])
3067         self.assertEqual(
3068             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3069         )
3070         self.assertEqual(
3071             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3072         )
3073         self.assertEqual(
3074             setxml.find("memtune").find("swap_hard_limit").text,
3075             str(int(2.5 * 1024 ** 2)),
3076         )
3077         self.assertEqual(
3078             setxml.find("memtune").find("swap_hard_limit").get("unit"),
3079             "KiB",
3080         )
3081         self.assertEqual(
3082             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3083         )
3084         self.assertEqual(
3085             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3086         )
3087         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3088         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3089         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3090         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3091         max_slot_reverse = {
3092             "slots": "10",
3093             "max": "3096m",
3094         }
3095         self.assertEqual(
3096             {
3097                 "definition": True,
3098                 "disk": {"attached": [], "detached": [], "updated": []},
3099                 "interface": {"attached": [], "detached": []},
3100             },
3101             virt.update("vm_with_memtune_param", mem=max_slot_reverse),
3102         )
3103         setxml = ET.fromstring(define_mock.call_args[0][0])
3104         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3105         self.assertEqual(setxml.find("maxMemory").get("unit"), "bytes")
3106         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3107         max_swap_none = {
3108             "boot": "0.7g",
3109             "current": "2.5g",
3110             "max": None,
3111             "slots": "10",
3112             "soft_limit": "2048m",
3113             "hard_limit": "1024",
3114             "swap_hard_limit": None,
3115             "min_guarantee": "1 g",
3116         }
3117         domain_mock.setMemoryFlags.reset_mock()
3118         self.assertEqual(
3119             {
3120                 "definition": True,
3121                 "disk": {"attached": [], "detached": [], "updated": []},
3122                 "interface": {"attached": [], "detached": []},
3123                 "mem": True,
3124             },
3125             virt.update("vm_with_memtune_param", mem=max_swap_none),
3126         )
3127         self.assertEqual(
3128             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3129         )
3130         setxml = ET.fromstring(define_mock.call_args[0][0])
3131         self.assertEqual(
3132             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3133         )
3134         self.assertEqual(
3135             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3136         )
3137         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3138         self.assertEqual(
3139             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3140         )
3141         self.assertEqual(
3142             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3143         )
3144         self.assertEqual(setxml.find("maxMemory").text, None)
3145         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3146         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3147         memtune_none = {
3148             "soft_limit": None,
3149             "hard_limit": None,
3150             "swap_hard_limit": None,
3151             "min_guarantee": None,
3152         }
3153         self.assertEqual(
3154             {
3155                 "definition": True,
3156                 "disk": {"attached": [], "detached": [], "updated": []},
3157                 "interface": {"attached": [], "detached": []},
3158             },
3159             virt.update("vm_with_memtune_param", mem=memtune_none),
3160         )
3161         setxml = ET.fromstring(define_mock.call_args[0][0])
3162         self.assertEqual(setxml.find("memtune").find("soft_limit"), None)
3163         self.assertEqual(setxml.find("memtune").find("hard_limit"), None)
3164         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3165         self.assertEqual(setxml.find("memtune").find("min_guarantee"), None)
3166         max_none = {
3167             "max": None,
3168         }
3169         self.assertEqual(
3170             {
3171                 "definition": True,
3172                 "disk": {"attached": [], "detached": [], "updated": []},
3173                 "interface": {"attached": [], "detached": []},
3174             },
3175             virt.update("vm_with_memtune_param", mem=max_none),
3176         )
3177         setxml = ET.fromstring(define_mock.call_args[0][0])
3178         self.assertEqual(setxml.find("maxMemory"), None)
3179         self.assertEqual(setxml.find("currentMemory").text, str(int(1 * 1024 ** 2)))
3180         self.assertEqual(setxml.find("memory").text, str(int(1 * 1024 ** 2)))
3181     def test_update_exist_memorybacking_params(self):
3182         xml_with_memback_params = """
3183             &lt;domain type='kvm' id='8'&gt;
3184               &lt;name&gt;vm_with_memback_param&lt;/name&gt;
3185               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3186               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3187               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3188               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3189               &lt;memoryBacking&gt;
3190                 &lt;hugepages&gt;
3191                   &lt;page size="2048" unit="KiB"/&gt;
3192                   &lt;page size="3145728" nodeset="1-4,^3" unit="KiB"/&gt;
3193                   &lt;page size="1048576" nodeset="3" unit="KiB"/&gt;
3194                 &lt;/hugepages&gt;
3195                 &lt;nosharepages/&gt;
3196                 &lt;locked/&gt;
3197                 &lt;source type="file"/&gt;
3198                 &lt;access mode="shared"/&gt;
3199                 &lt;discard/&gt;
3200               &lt;/memoryBacking&gt;
3201               &lt;os&gt;
3202                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3203               &lt;/os&gt;
3204               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
3205             &lt;/domain&gt;
3206         """
3207         domain_mock = self.set_mock_vm("vm_with_memback_param", xml_with_memback_params)
3208         domain_mock.OSType = MagicMock(return_value="hvm")
3209         define_mock = MagicMock(return_value=True)
3210         self.mock_conn.defineXML = define_mock
3211         mem_back_param = {
3212             "hugepages": [
3213                 {"nodeset": "1-4,^3", "size": "1g"},
3214                 {"nodeset": "3", "size": "2g"},
3215             ],
3216             "nosharepages": None,
3217             "locked": None,
3218             "source": "anonymous",
3219             "access": "private",
3220             "allocation": "ondemand",
3221             "discard": None,
3222         }
3223         self.assertEqual(
3224             {
3225                 "definition": True,
3226                 "disk": {"attached": [], "detached": [], "updated": []},
3227                 "interface": {"attached": [], "detached": []},
3228             },
3229             virt.update("vm_with_memback_param", mem=mem_back_param),
3230         )
3231         setxml = ET.fromstring(define_mock.call_args[0][0])
3232         self.assertDictEqual(
3233             {
3234                 p.get("nodeset"): {"size": p.get("size"), "unit": p.get("unit")}
3235                 for p in setxml.findall("memoryBacking/hugepages/page")
3236             },
3237             {
3238                 "1,2,4": {"size": str(1024 ** 3), "unit": "bytes"},
3239                 "3": {"size": str(2 * 1024 ** 3), "unit": "bytes"},
3240             },
3241         )
3242         self.assertEqual(setxml.find("./memoryBacking/nosharepages"), None)
3243         self.assertEqual(setxml.find("./memoryBacking/locked"), None)
3244         self.assertEqual(
3245             setxml.find("./memoryBacking/source").attrib["type"], "anonymous"
3246         )
3247         self.assertEqual(
3248             setxml.find("./memoryBacking/access").attrib["mode"], "private"
3249         )
3250         self.assertEqual(
3251             setxml.find("./memoryBacking/allocation").attrib["mode"], "ondemand"
3252         )
3253         self.assertEqual(setxml.find("./memoryBacking/discard"), None)
3254         unchanged_page = {
3255             "hugepages": [
3256                 {"size": "2m"},
3257                 {"nodeset": "1-4,^3", "size": "3g"},
3258                 {"nodeset": "3", "size": "1g"},
3259             ],
3260         }
3261         self.assertEqual(
3262             {
3263                 "definition": False,
3264                 "disk": {"attached": [], "detached": [], "updated": []},
3265                 "interface": {"attached": [], "detached": []},
3266             },
3267             virt.update("vm_with_memback_param", mem=unchanged_page),
3268         )
3269     def test_update_iothreads_params(self):
3270         xml_with_iothreads_params = """
3271             &lt;domain type='kvm' id='8'&gt;
3272               &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
3273               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3274               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3275               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3276               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3277               &lt;iothreads&gt;6&lt;/iothreads&gt;
3278               &lt;os&gt;
3279                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3280               &lt;/os&gt;
3281             &lt;/domain&gt;
3282         """
3283         domain_mock = self.set_mock_vm(
3284             "xml_with_iothreads_params", xml_with_iothreads_params
3285         )
3286         domain_mock.OSType = MagicMock(return_value="hvm")
3287         define_mock = MagicMock(return_value=True)
3288         self.mock_conn.defineXML = define_mock
3289         self.assertEqual(
3290             {
3291                 "definition": True,
3292                 "disk": {"attached": [], "detached": [], "updated": []},
3293                 "interface": {"attached": [], "detached": []},
3294             },
3295             virt.update("xml_with_iothreads_params", cpu={"iothreads": 7}),
3296         )
3297         setxml = ET.fromstring(define_mock.call_args[0][0])
3298         self.assertEqual(setxml.find("iothreads").text, "7")
3299     def test_update_cputune_paramters(self):
3300         xml_with_cputune_params = """
3301                     &lt;domain type='kvm' id='8'&gt;
3302                       &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
3303                       &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3304                       &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3305                       &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3306                       &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3307                       &lt;iothreads&gt;4&lt;/iothreads&gt;
3308                       &lt;cputune&gt;
3309                         &lt;shares&gt;2048&lt;/shares&gt;
3310                         &lt;period&gt;1000000&lt;/period&gt;
3311                         &lt;quota&gt;-1&lt;/quota&gt;
3312                         &lt;global_period&gt;1000000&lt;/global_period&gt;
3313                         &lt;global_quota&gt;-1&lt;/global_quota&gt;
3314                         &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
3315                         &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
3316                         &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
3317                         &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
3318                         &lt;vcpupin vcpu="0" cpuset="0-2"/&gt;
3319                         &lt;vcpupin vcpu="1" cpuset="3"/&gt;
3320                         &lt;vcpupin vcpu="2" cpuset="4"/&gt;
3321                         &lt;vcpupin vcpu="3" cpuset="5-7"/&gt;
3322                         &lt;emulatorpin cpuset="1-2"/&gt;
3323                         &lt;iothreadpin iothread="1" cpuset="1-5"/&gt;
3324                         &lt;iothreadpin iothread="2" cpuset="6-7"/&gt;
3325                         &lt;vcpusched vcpus="0" scheduler="idle" priority="3"/&gt;
3326                         &lt;vcpusched vcpus="1" scheduler="rr" priority="1"/&gt;
3327                         &lt;vcpusched vcpus="2" scheduler="fifo" priority="2"/&gt;
3328                         &lt;iothreadsched iothreads="4" scheduler="fifo"/&gt;
3329                         &lt;emulatorsched scheduler="idle"/&gt;
3330                         &lt;cachetune vcpus="0-4"&gt;
3331                           &lt;cache id="0" level="2" type="both" size="4" unit="KiB"/&gt;
3332                           &lt;cache id="1" level="2" type="both" size="4" unit="KiB"/&gt;
3333                           &lt;monitor level="5" vcpus="0-2"/&gt;
3334                           &lt;monitor level="6" vcpus="1-3"/&gt;
3335                         &lt;/cachetune&gt;
3336                         &lt;cachetune vcpus="5-8"&gt;
3337                           &lt;monitor level="5" vcpus="5-6"/&gt;
3338                           &lt;monitor level="3" vcpus="7-8"/&gt;
3339                         &lt;/cachetune&gt;
3340                         &lt;memorytune vcpus="0-6"&gt;
3341                           &lt;node id="0" bandwidth="45"/&gt;
3342                         &lt;/memorytune&gt;
3343                         &lt;memorytune vcpus="7-8"&gt;
3344                           &lt;node id="0" bandwidth="120"/&gt;
3345                         &lt;/memorytune&gt;
3346                       &lt;/cputune&gt;
3347                       &lt;os&gt;
3348                         &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3349                       &lt;/os&gt;
3350                     &lt;/domain&gt;
3351                 """
3352         domain_mock = self.set_mock_vm(
3353             "xml_with_cputune_params", xml_with_cputune_params
3354         )
3355         domain_mock.OSType = MagicMock(return_value="hvm")
3356         define_mock = MagicMock(return_value=True)
3357         self.mock_conn.defineXML = define_mock
3358         cputune = {
3359             "shares": 1024,
3360             "period": 5000,
3361             "quota": -20,
3362             "global_period": 4000,
3363             "global_quota": -30,
3364             "emulator_period": 3000,
3365             "emulator_quota": -4,
3366             "iothread_period": 7000,
3367             "iothread_quota": -5,
3368             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
3369             "emulatorpin": "1-3",
3370             "iothreadpin": {1: "5-6", 2: "7-8"},
3371             "vcpusched": [
3372                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
3373                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
3374                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
3375             ],
3376             "iothreadsched": [
3377                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1}
3378             ],
3379             "emulatorsched": {"scheduler": "rr", "priority": 2},
3380             "cachetune": {
3381                 "0-3": {
3382                     0: {"level": 3, "type": "both", "size": 3},
3383                     1: {"level": 3, "type": "both", "size": 3},
3384                     "monitor": {1: 3, "0-3": 3},
3385                 },
3386                 "4-5": {"monitor": {4: 3, 5: 2}},
3387             },
3388             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
3389         }
3390         self.assertEqual(
3391             {
3392                 "definition": True,
3393                 "disk": {"attached": [], "detached": [], "updated": []},
3394                 "interface": {"attached": [], "detached": []},
3395             },
3396             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3397         )
3398         setxml = ET.fromstring(define_mock.call_args[0][0])
3399         self.assertEqual(setxml.find("cputune").find("shares").text, "1024")
3400         self.assertEqual(setxml.find("cputune").find("period").text, "5000")
3401         self.assertEqual(setxml.find("cputune").find("quota").text, "-20")
3402         self.assertEqual(setxml.find("cputune").find("global_period").text, "4000")
3403         self.assertEqual(setxml.find("cputune").find("global_quota").text, "-30")
3404         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "3000")
3405         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3406         self.assertEqual(setxml.find("cputune").find("iothread_period").text, "7000")
3407         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3408         self.assertEqual(
3409             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3410             "1,3,4",
3411         )
3412         self.assertEqual(
3413             setxml.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
3414             "0,1",
3415         )
3416         self.assertEqual(
3417             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3418             "2,3",
3419         )
3420         self.assertEqual(
3421             setxml.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
3422             "0,4",
3423         )
3424         self.assertEqual(
3425             setxml.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1,2,3"
3426         )
3427         self.assertEqual(
3428             setxml.find("cputune")
3429             .find("iothreadpin[@iothread='1']")
3430             .attrib.get("cpuset"),
3431             "5,6",
3432         )
3433         self.assertEqual(
3434             setxml.find("cputune")
3435             .find("iothreadpin[@iothread='2']")
3436             .attrib.get("cpuset"),
3437             "7,8",
3438         )
3439         self.assertDictEqual(
3440             {
3441                 s.get("vcpus"): {
3442                     "scheduler": s.get("scheduler"),
3443                     "priority": s.get("priority"),
3444                 }
3445                 for s in setxml.findall("cputune/vcpusched")
3446             },
3447             {
3448                 "0": {"scheduler": "fifo", "priority": "1"},
3449                 "1": {"scheduler": "fifo", "priority": "2"},
3450                 "2": {"scheduler": "idle", "priority": "3"},
3451             },
3452         )
3453         self.assertDictEqual(
3454             {
3455                 s.get("iothreads"): {
3456                     "scheduler": s.get("scheduler"),
3457                     "priority": s.get("priority"),
3458                 }
3459                 for s in setxml.findall("cputune/iothreadsched")
3460             },
3461             {"5,6,7": {"scheduler": "batch", "priority": "1"}},
3462         )
3463         self.assertEqual(setxml.find("cputune/emulatorsched").get("scheduler"), "rr")
3464         self.assertEqual(setxml.find("cputune/emulatorsched").get("priority"), "2")
3465         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3466         self.assertEqual(
3467             setxml.find(
3468                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3469             ).attrib.get("level"),
3470             "3",
3471         )
3472         self.assertEqual(
3473             setxml.find(
3474                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3475             ).attrib.get("type"),
3476             "both",
3477         )
3478         self.assertEqual(
3479             setxml.find(
3480                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"
3481             ).attrib.get("level"),
3482             "3",
3483         )
3484         self.assertNotEqual(
3485             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"),
3486             None,
3487         )
3488         self.assertNotEqual(
3489             setxml.find("./cputune/cachetune[@vcpus='4,5']").attrib.get("vcpus"), None
3490         )
3491         self.assertEqual(
3492             setxml.find("./cputune/cachetune[@vcpus='4,5']/cache[@id='0']"), None
3493         )
3494         self.assertEqual(
3495             setxml.find(
3496                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']"
3497             ).attrib.get("level"),
3498             "3",
3499         )
3500         self.assertEqual(
3501             setxml.find(
3502                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']"
3503             ).attrib.get("level"),
3504             "2",
3505         )
3506         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3507         self.assertEqual(
3508             setxml.find(
3509                 "./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']"
3510             ).attrib.get("bandwidth"),
3511             "60",
3512         )
3513         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='3,4']"), None)
3514         self.assertEqual(
3515             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3516                 "bandwidth"
3517             ),
3518             "50",
3519         )
3520         self.assertEqual(
3521             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3522                 "bandwidth"
3523             ),
3524             "70",
3525         )
3526         cputune = {
3527             "shares": None,
3528             "period": 20000,
3529             "quota": None,
3530             "global_period": 5000,
3531             "global_quota": None,
3532             "emulator_period": 2000,
3533             "emulator_quota": -4,
3534             "iothread_period": None,
3535             "iothread_quota": -5,
3536             "vcpupin": {0: "1-4,^2", 2: "2,4"},
3537             "emulatorpin": None,
3538             "iothreadpin": {1: "5-6"},
3539             "vcpusched": [{"scheduler": "idle", "priority": 5, "vcpus": "1"}],
3540             "iothreadsched": None,
3541             "cachetune": {
3542                 "0-3": {
3543                     0: {"level": 4, "type": "data", "size": 7},
3544                     "monitor": {"1-2": 11},
3545                 },
3546             },
3547             "memorytune": {"3-4": {0: 37, 1: 73}},
3548         }
3549         self.assertEqual(
3550             {
3551                 "definition": True,
3552                 "disk": {"attached": [], "detached": [], "updated": []},
3553                 "interface": {"attached": [], "detached": []},
3554             },
3555             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3556         )
3557         setxml = ET.fromstring(define_mock.call_args[0][0])
3558         self.assertEqual(setxml.find("cputune").find("shares"), None)
3559         self.assertEqual(setxml.find("cputune").find("period").text, "20000")
3560         self.assertEqual(setxml.find("cputune").find("quota"), None)
3561         self.assertEqual(setxml.find("cputune").find("global_period").text, "5000")
3562         self.assertEqual(setxml.find("cputune").find("global_quota"), None)
3563         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "2000")
3564         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3565         self.assertEqual(setxml.find("cputune").find("iothread_period"), None)
3566         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3567         self.assertEqual(
3568             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3569             "1,3,4",
3570         )
3571         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='1']"), None)
3572         self.assertEqual(
3573             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3574             "2,4",
3575         )
3576         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='3']"), None)
3577         self.assertEqual(setxml.find("cputune").find("emulatorpin"), None)
3578         self.assertEqual(
3579             setxml.find("cputune")
3580             .find("iothreadpin[@iothread='1']")
3581             .attrib.get("cpuset"),
3582             "5,6",
3583         )
3584         self.assertEqual(
3585             setxml.find("cputune").find("iothreadpin[@iothread='2']"), None
3586         )
3587         self.assertDictEqual(
3588             {
3589                 s.get("vcpus"): {
3590                     "scheduler": s.get("scheduler"),
3591                     "priority": s.get("priority"),
3592                 }
3593                 for s in setxml.findall("cputune/vcpusched")
3594             },
3595             {"1": {"scheduler": "idle", "priority": "5"}},
3596         )
3597         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3598         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3599         self.assertEqual(
3600             setxml.find(
3601                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3602             ).attrib.get("size"),
3603             "7",
3604         )
3605         self.assertEqual(
3606             setxml.find(
3607                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3608             ).attrib.get("level"),
3609             "4",
3610         )
3611         self.assertEqual(
3612             setxml.find(
3613                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3614             ).attrib.get("type"),
3615             "data",
3616         )
3617         self.assertEqual(
3618             setxml.find(
3619                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']"
3620             ).attrib.get("level"),
3621             "11",
3622         )
3623         self.assertEqual(
3624             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']"),
3625             None,
3626         )
3627         self.assertEqual(
3628             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']"), None
3629         )
3630         self.assertEqual(setxml.find("./cputune/cachetune[@vcpus='4,5']"), None)
3631         self.assertEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3632         self.assertEqual(
3633             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3634                 "bandwidth"
3635             ),
3636             "37",
3637         )
3638         self.assertEqual(
3639             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3640                 "bandwidth"
3641             ),
3642             "73",
3643         )
3644         cputune_subelement = {
3645             "vcpupin": None,
3646             "iothreadpin": None,
3647             "vcpusched": None,
3648             "iothreadsched": None,
3649             "cachetune": None,
3650             "memorytune": None,
3651         }
3652         self.assertEqual(
3653             {
3654                 "definition": True,
3655                 "disk": {"attached": [], "detached": [], "updated": []},
3656                 "interface": {"attached": [], "detached": []},
3657             },
3658             virt.update("xml_with_cputune_params", cpu={"tuning": cputune_subelement}),
3659         )
3660         setxml = ET.fromstring(define_mock.call_args[0][0])
3661         self.assertEqual(setxml.find("cputune").find("vcpupin"), None)
3662         self.assertEqual(setxml.find("cputune").find("iothreadpin"), None)
3663         self.assertEqual(setxml.find("cputune").find("vcpusched"), None)
3664         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3665         self.assertEqual(setxml.find("cputune").find("cachetune"), None)
3666         self.assertEqual(setxml.find("cputune").find("memorytune"), None)
3667     def test_handle_unit(self):
3668         valid_case = [
3669             ("2", 2097152),
3670             ("42", 44040192),
3671             ("5b", 5),
3672             ("2.3Kib", 2355),
3673             ("5.8Kb", 5800),
3674             ("16MiB", 16777216),
3675             ("20 GB", 20000000000),
3676             ("16KB", 16000),
3677             (".5k", 512),
3678             ("2.k", 2048),
3679         ]
3680         for key, val in valid_case:
3681             self.assertEqual(virt._handle_unit(key), val)
3682         invalid_case = [
3683             ("9ib", "invalid units"),
3684             ("8byte", "invalid units"),
3685             ("512bytes", "invalid units"),
3686             ("4 Kbytes", "invalid units"),
3687             ("3.4.MB", "invalid number"),
3688             ("", "invalid number"),
3689             ("bytes", "invalid number"),
3690             ("2HB", "invalid units"),
3691         ]
3692         for key, val in invalid_case:
3693             with self.assertRaises(SaltInvocationError):
3694                 virt._handle_unit(key)
3695     def test_mixed_dict_and_list_as_profile_objects(self):
3696         yaml_config = """
3697           virt:
3698              nic:
3699                 new-listonly-profile:
3700                    - bridge: br0
3701                      name: eth0
3702                    - model: virtio
3703                      name: eth1
3704                      source: test_network
3705                      type: network
3706                 new-list-with-legacy-names:
3707                    - eth0:
3708                         bridge: br0
3709                    - eth1:
3710                         bridge: br1
3711                         model: virtio
3712                 non-default-legacy-profile:
3713                    eth0:
3714                       bridge: br0
3715                    eth1:
3716                       bridge: br1
3717                       model: virtio
3718         Test virt.get_xml()
3719         domain = self.set_mock_vm("test-vm", xml)
3720         self.assertEqual(xml, virt.get_xml("test-vm"))
3721         self.assertEqual(xml, virt.get_xml(domain))
3722     def test_get_loader(self):
3723         xml = """&lt;domain type='kvm' id='7'&gt;
3724               &lt;name&gt;test-vm&lt;/name&gt;
3725               &lt;os&gt;
3726                 &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
3727               &lt;/os&gt;
3728             &lt;/domain&gt;
3729         """
3730         self.set_mock_vm("test-vm", xml)
3731         loader = virt.get_loader("test-vm")
3732         self.assertEqual("/foo/bar", loader["path"])
3733         self.assertEqual("yes", loader["readonly"])
3734     def test_cpu_baseline(self):
3735         capabilities_xml = dedent(
3736         Make sure that qemu-img info output is properly parsed
3737         Test virt.purge() with default parameters
3738         self.set_mock_vm("test-vm", xml)
3739         qemu_infos = """[{
3740             "virtual-size": 25769803776,
3741             "filename": "/disks/test.qcow2",
3742             "cluster-size": 65536,
3743             "format": "qcow2",
3744             "actual-size": 217088,
3745             "format-specific": {
3746                 "type": "qcow2",
3747                 "data": {
3748                     "compat": "1.1",
3749                     "lazy-refcounts": false,
3750                     "refcount-bits": 16,
3751                     "corrupt": false
3752                 }
3753             },
3754             "dirty-flag": false
3755         }]"""
3756         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3757         self.mock_popen.returncode = 0
3758         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3759             res = virt.purge("test-vm")
3760             self.assertTrue(res)
3761             mock_remove.assert_called_once()
3762             mock_remove.assert_any_call("/disks/test.qcow2")
3763     @patch("salt.modules.virt.stop", return_value=True)
3764     @patch("salt.modules.virt.undefine")
3765     def test_purge_volumes(self, mock_undefine, mock_stop):
3766         xml = """&lt;domain type='kvm' id='7'&gt;
3767               &lt;name&gt;test-vm&lt;/name&gt;
3768               &lt;devices&gt;
3769                 &lt;disk type='volume' device='disk'&gt;
3770                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
3771                   &lt;source pool='default' volume='vm05_system'/&gt;
3772                   &lt;backingStore type='file' index='1'&gt;
3773                     &lt;format type='qcow2'/&gt;
3774                     &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
3775                     &lt;backingStore type='file' index='2'&gt;
3776                       &lt;format type='qcow2'/&gt;
3777                       &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
3778                       &lt;backingStore/&gt;
3779                     &lt;/backingStore&gt;
3780                   &lt;/backingStore&gt;
3781                   &lt;target dev='vda' bus='virtio'/&gt;
3782                   &lt;alias name='virtio-disk0'/&gt;
3783                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
3784                 &lt;/disk&gt;
3785               &lt;/devices&gt;
3786             &lt;/domain&gt;
3787         """
3788         self.set_mock_vm("test-vm", xml)
3789         pool_mock = MagicMock()
3790         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3791             0,
3792             1234567,
3793             12345,
3794         ]
3795         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3796         ]
3797         pool_mock.listVolumes.return_value = ["vm05_system", "vm04_system.qcow2"]
3798         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3799         self.mock_conn.listStoragePools.return_value = ["default"]
3800         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3801             res = virt.purge("test-vm")
3802             self.assertTrue(res)
3803             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3804     @patch("salt.modules.virt.stop", return_value=True)
3805     @patch("salt.modules.virt.undefine")
3806     def test_purge_rbd(self, mock_undefine, mock_stop):
3807         xml = """&lt;domain type='kvm' id='7'&gt;
3808               &lt;name&gt;test-vm&lt;/name&gt;
3809               &lt;devices&gt;
3810                 &lt;disk type="network" device="disk"&gt;
3811                   &lt;driver name='raw' type='qcow2'/&gt;
3812                   &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
3813                     &lt;host name='ses2.tf.local'/&gt;
3814                     &lt;host name='ses3.tf.local' port='1234'/&gt;
3815                     &lt;auth username='libvirt'&gt;
3816                       &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
3817                     &lt;/auth&gt;
3818                   &lt;/source&gt;
3819                   &lt;target dev='vdc' bus='virtio'/&gt;
3820                   &lt;alias name='virtio-disk2'/&gt;
3821                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
3822                 &lt;/disk&gt;
3823               &lt;/devices&gt;
3824             &lt;/domain&gt;
3825         """
3826         self.set_mock_vm("test-vm", xml)
3827         pool_mock = MagicMock()
3828         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3829             0,
3830             1234567,
3831             12345,
3832         ]
3833         pool_mock.XMLDesc.return_value = """
3834         &lt;pool type='rbd'&gt;
3835           &lt;name&gt;test-ses&lt;/name&gt;
3836           &lt;source&gt;
3837             &lt;host name='ses2.tf.local'/&gt;
3838             &lt;name&gt;libvirt-pool&lt;/name&gt;
3839             &lt;auth type='ceph' username='libvirt'&gt;
3840               &lt;secret usage='pool_test-ses'/&gt;
3841             &lt;/auth&gt;
3842           &lt;/source&gt;
3843         &lt;/pool&gt;
3844         """
3845         pool_mock.name.return_value = "test-ses"
3846         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3847         ]
3848         pool_mock.listVolumes.return_value = ["my_vm_data2"]
3849         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
3850         self.mock_conn.listStoragePools.return_value = ["test-ses"]
3851         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3852         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3853             res = virt.purge("test-vm")
3854             self.assertTrue(res)
3855             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3856     @patch("salt.modules.virt.stop", return_value=True)
3857     @patch("salt.modules.virt.undefine")
3858     @patch("os.remove")
3859     def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
3860         xml = """&lt;domain type="kvm" id="7"&gt;
3861               &lt;name&gt;test-vm&lt;/name&gt;
3862               &lt;devices&gt;
3863                 &lt;disk type='file' device='disk'&gt;
3864                 &lt;driver name='qemu' type='qcow2'/&gt;
3865                 &lt;source file='/disks/test.qcow2'/&gt;
3866                 &lt;target dev='vda' bus='virtio'/&gt;
3867               &lt;/disk&gt;
3868               &lt;disk type='file' device='cdrom'&gt;
3869                 &lt;driver name='qemu' type='raw'/&gt;
3870                 &lt;source file='/disks/test-cdrom.iso'/&gt;
3871                 &lt;target dev='hda' bus='ide'/&gt;
3872                 &lt;readonly/&gt;
3873               &lt;/disk&gt;
3874               &lt;disk type='file' device='floppy'&gt;
3875                 &lt;driver name='qemu' type='raw'/&gt;
3876                 &lt;source file='/disks/test-floppy.iso'/&gt;
3877                 &lt;target dev='hdb' bus='ide'/&gt;
3878                 &lt;readonly/&gt;
3879               &lt;/disk&gt;
3880               &lt;/devices&gt;
3881             &lt;/domain&gt;
3882         """
3883         self.set_mock_vm("test-vm", xml)
3884         qemu_infos = """[{
3885             "virtual-size": 25769803776,
3886             "filename": "/disks/test.qcow2",
3887             "cluster-size": 65536,
3888             "format": "qcow2",
3889             "actual-size": 217088,
3890             "format-specific": {
3891                 "type": "qcow2",
3892                 "data": {
3893                     "compat": "1.1",
3894                     "lazy-refcounts": false,
3895                     "refcount-bits": 16,
3896                     "corrupt": false
3897                 }
3898             },
3899             "dirty-flag": false
3900         }]"""
3901         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3902         self.mock_popen.returncode = 0
3903         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3904             res = virt.purge("test-vm", removables=True)
3905             self.assertTrue(res)
3906             mock_remove.assert_any_call("/disks/test.qcow2")
3907             mock_remove.assert_any_call("/disks/test-cdrom.iso")
3908     def test_capabilities(self):
3909         xml = """
3910 &lt;capabilities&gt;
3911   &lt;host&gt;
3912     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
3913     &lt;cpu&gt;
3914       &lt;arch&gt;x86_64&lt;/arch&gt;
3915       &lt;model&gt;Nehalem&lt;/model&gt;
3916       &lt;vendor&gt;Intel&lt;/vendor&gt;
3917       &lt;microcode version='25'/&gt;
3918       &lt;topology sockets='1' cores='4' threads='2'/&gt;
3919       &lt;feature name='vme'/&gt;
3920       &lt;feature name='ds'/&gt;
3921       &lt;feature name='acpi'/&gt;
3922       &lt;pages unit='KiB' size='4'/&gt;
3923       &lt;pages unit='KiB' size='2048'/&gt;
3924     &lt;/cpu&gt;
3925     &lt;power_management&gt;
3926       &lt;suspend_mem/&gt;
3927       &lt;suspend_disk/&gt;
3928       &lt;suspend_hybrid/&gt;
3929     &lt;/power_management&gt;
3930     &lt;migration_features&gt;
3931       &lt;live/&gt;
3932       &lt;uri_transports&gt;
3933         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
3934         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
3935       &lt;/uri_transports&gt;
3936     &lt;/migration_features&gt;
3937     &lt;topology&gt;
3938       &lt;cells num='1'&gt;
3939         &lt;cell id='0'&gt;
3940           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
3941           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
3942           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
3943           &lt;distances&gt;
3944             &lt;sibling id='0' value='10'/&gt;
3945           &lt;/distances&gt;
3946           &lt;cpus num='8'&gt;
3947             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
3948             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
3949             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
3950             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
3951             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
3952             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
3953             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
3954             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
3955           &lt;/cpus&gt;
3956         &lt;/cell&gt;
3957       &lt;/cells&gt;
3958     &lt;/topology&gt;
3959     &lt;cache&gt;
3960       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
3961     &lt;/cache&gt;
3962     &lt;secmodel&gt;
3963       &lt;model&gt;apparmor&lt;/model&gt;
3964       &lt;doi&gt;0&lt;/doi&gt;
3965     &lt;/secmodel&gt;
3966     &lt;secmodel&gt;
3967       &lt;model&gt;dac&lt;/model&gt;
3968       &lt;doi&gt;0&lt;/doi&gt;
3969       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
3970       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
3971     &lt;/secmodel&gt;
3972   &lt;/host&gt;
3973   &lt;guest&gt;
3974     &lt;os_type&gt;hvm&lt;/os_type&gt;
3975     &lt;arch name='i686'&gt;
3976       &lt;wordsize&gt;32&lt;/wordsize&gt;
3977       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
3978       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3979       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3980       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3981       &lt;domain type='qemu'/&gt;
3982       &lt;domain type='kvm'&gt;
3983         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
3984         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3985         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3986         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3987       &lt;/domain&gt;
3988     &lt;/arch&gt;
3989     &lt;features&gt;
3990       &lt;cpuselection/&gt;
3991       &lt;deviceboot/&gt;
3992       &lt;disksnapshot default='on' toggle='no'/&gt;
3993       &lt;acpi default='off' toggle='yes'/&gt;
3994       &lt;apic default='on' toggle='no'/&gt;
3995       &lt;pae/&gt;
3996       &lt;nonpae/&gt;
3997     &lt;/features&gt;
3998   &lt;/guest&gt;
3999   &lt;guest&gt;
4000     &lt;os_type&gt;hvm&lt;/os_type&gt;
4001     &lt;arch name='x86_64'&gt;
4002       &lt;wordsize&gt;64&lt;/wordsize&gt;
4003       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4004       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4005       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4006       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4007       &lt;domain type='qemu'/&gt;
4008       &lt;domain type='kvm'&gt;
4009         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4010         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4011         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4012         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4013       &lt;/domain&gt;
4014     &lt;/arch&gt;
4015     &lt;features&gt;
4016       &lt;cpuselection/&gt;
4017       &lt;deviceboot/&gt;
4018       &lt;disksnapshot default='on' toggle='no'/&gt;
4019       &lt;acpi default='on' toggle='yes'/&gt;
4020       &lt;apic default='off' toggle='no'/&gt;
4021     &lt;/features&gt;
4022   &lt;/guest&gt;
4023   &lt;guest&gt;
4024     &lt;os_type&gt;xen&lt;/os_type&gt;
4025     &lt;arch name='x86_64'&gt;
4026       &lt;wordsize&gt;64&lt;/wordsize&gt;
4027       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4028       &lt;machine&gt;xenpv&lt;/machine&gt;
4029       &lt;domain type='xen'/&gt;
4030     &lt;/arch&gt;
4031   &lt;/guest&gt;
4032 &lt;/capabilities&gt;
4033         """
4034         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
4035         caps = virt.capabilities()
4036         expected = {
4037             "host": {
4038                 "uuid": "44454c4c-3400-105a-8033-b3c04f4b344a",
4039                 "cpu": {
4040                     "arch": "x86_64",
4041                     "model": "Nehalem",
4042                     "vendor": "Intel",
4043                     "microcode": "25",
4044                     "sockets": 1,
4045                     "cores": 4,
4046                     "threads": 2,
4047                     "features": ["vme", "ds", "acpi"],
4048                     "pages": [{"size": "4 KiB"}, {"size": "2048 KiB"}],
4049                 },
4050                 "power_management": ["suspend_mem", "suspend_disk", "suspend_hybrid"],
4051                 "migration": {"live": True, "transports": ["tcp", "rdma"]},
4052                 "topology": {
4053                     "cells": [
4054                         {
4055                             "id": 0,
4056                             "memory": "12367120 KiB",
4057                             "pages": [
4058                                 {"size": "4 KiB", "available": 3091780},
4059                                 {"size": "2048 KiB", "available": 0},
4060                             ],
4061                             "distances": {0: 10},
4062                             "cpus": [
4063                                 {
4064                                     "id": 0,
4065                                     "socket_id": 0,
4066                                     "core_id": 0,
4067                                     "siblings": "0,4",
4068                                 },
4069                                 {
4070                                     "id": 1,
4071                                     "socket_id": 0,
4072                                     "core_id": 1,
4073                                     "siblings": "1,5",
4074                                 },
4075                                 {
4076                                     "id": 2,
4077                                     "socket_id": 0,
4078                                     "core_id": 2,
4079                                     "siblings": "2,6",
4080                                 },
4081                                 {
4082                                     "id": 3,
4083                                     "socket_id": 0,
4084                                     "core_id": 3,
4085                                     "siblings": "3,7",
4086                                 },
4087                                 {
4088                                     "id": 4,
4089                                     "socket_id": 0,
4090                                     "core_id": 0,
4091                                     "siblings": "0,4",
4092                                 },
4093                                 {
4094                                     "id": 5,
4095                                     "socket_id": 0,
4096                                     "core_id": 1,
4097                                     "siblings": "1,5",
4098                                 },
4099                                 {
4100                                     "id": 6,
4101                                     "socket_id": 0,
4102                                     "core_id": 2,
4103                                     "siblings": "2,6",
4104                                 },
4105                                 {
4106                                     "id": 7,
4107                                     "socket_id": 0,
4108                                     "core_id": 3,
4109                                     "siblings": "3,7",
4110                                 },
4111                             ],
4112                         }
4113                     ]
4114                 },
4115                 "cache": {
4116                     "banks": [
4117                         {
4118                             "id": 0,
4119                             "level": 3,
4120                             "type": "both",
4121                             "size": "8 MiB",
4122                             "cpus": "0-7",
4123                         }
4124                     ]
4125                 },
4126                 "security": [
4127                     {"model": "apparmor", "doi": "0", "baselabels": []},
4128                     {
4129                         "model": "dac",
4130                         "doi": "0",
4131                         "baselabels": [
4132                             {"type": "kvm", "label": "+487:+486"},
4133                             {"type": "qemu", "label": "+487:+486"},
4134                         ],
4135                     },
4136                 ],
4137             },
4138             "guests": [
4139                 {
4140                     "os_type": "hvm",
4141                     "arch": {
4142                         "name": "i686",
4143                         "wordsize": 32,
4144                         "emulator": "/usr/bin/qemu-system-i386",
4145                         "machines": {
4146                             "pc-i440fx-2.6": {
4147                                 "maxcpus": 255,
4148                                 "alternate_names": ["pc"],
4149                             },
4150                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4151                         },
4152                         "domains": {
4153                             "qemu": {"emulator": None, "machines": {}},
4154                             "kvm": {
4155                                 "emulator": "/usr/bin/qemu-kvm",
4156                                 "machines": {
4157                                     "pc-i440fx-2.6": {
4158                                         "maxcpus": 255,
4159                                         "alternate_names": ["pc"],
4160                                     },
4161                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4162                                 },
4163                             },
4164                         },
4165                     },
4166                     "features": {
4167                         "cpuselection": {"default": True, "toggle": False},
4168                         "deviceboot": {"default": True, "toggle": False},
4169                         "disksnapshot": {"default": True, "toggle": False},
4170                         "acpi": {"default": False, "toggle": True},
4171                         "apic": {"default": True, "toggle": False},
4172                         "pae": {"default": True, "toggle": False},
4173                         "nonpae": {"default": True, "toggle": False},
4174                     },
4175                 },
4176                 {
4177                     "os_type": "hvm",
4178                     "arch": {
4179                         "name": "x86_64",
4180                         "wordsize": 64,
4181                         "emulator": "/usr/bin/qemu-system-x86_64",
4182                         "machines": {
4183                             "pc-i440fx-2.6": {
4184                                 "maxcpus": 255,
4185                                 "alternate_names": ["pc"],
4186                             },
4187                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4188                         },
4189                         "domains": {
4190                             "qemu": {"emulator": None, "machines": {}},
4191                             "kvm": {
4192                                 "emulator": "/usr/bin/qemu-kvm",
4193                                 "machines": {
4194                                     "pc-i440fx-2.6": {
4195                                         "maxcpus": 255,
4196                                         "alternate_names": ["pc"],
4197                                     },
4198                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4199                                 },
4200                             },
4201                         },
4202                     },
4203                     "features": {
4204                         "cpuselection": {"default": True, "toggle": False},
4205                         "deviceboot": {"default": True, "toggle": False},
4206                         "disksnapshot": {"default": True, "toggle": False},
4207                         "acpi": {"default": True, "toggle": True},
4208                         "apic": {"default": False, "toggle": False},
4209                     },
4210                 },
4211                 {
4212                     "os_type": "xen",
4213                     "arch": {
4214                         "name": "x86_64",
4215                         "wordsize": 64,
4216                         "emulator": "/usr/bin/qemu-system-x86_64",
4217                         "machines": {"xenpv": {"alternate_names": []}},
4218                         "domains": {"xen": {"emulator": None, "machines": {}}},
4219                     },
4220                 },
4221             ],
4222         }
4223         self.assertEqual(expected, caps)
4224     def test_domain_capabilities(self):
4225         xml = """
4226 &lt;domainCapabilities&gt;
4227   &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
4228   &lt;domain&gt;kvm&lt;/domain&gt;
4229   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4230   &lt;arch&gt;aarch64&lt;/arch&gt;
4231   &lt;vcpu max='255'/&gt;
4232   &lt;iothreads supported='yes'/&gt;
4233   &lt;os supported='yes'&gt;
4234     &lt;loader supported='yes'&gt;
4235       &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
4236       &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
4237       &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
4238       &lt;enum name='type'&gt;
4239         &lt;value&gt;rom&lt;/value&gt;
4240         &lt;value&gt;pflash&lt;/value&gt;
4241       &lt;/enum&gt;
4242       &lt;enum name='readonly'&gt;
4243         &lt;value&gt;yes&lt;/value&gt;
4244         &lt;value&gt;no&lt;/value&gt;
4245       &lt;/enum&gt;
4246     &lt;/loader&gt;
4247   &lt;/os&gt;
4248   &lt;cpu&gt;
4249     &lt;mode name='host-passthrough' supported='yes'/&gt;
4250     &lt;mode name='host-model' supported='yes'&gt;
4251       &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
4252       &lt;vendor&gt;ACME&lt;/vendor&gt;
4253       &lt;feature policy='require' name='vme'/&gt;
4254       &lt;feature policy='require' name='ss'/&gt;
4255     &lt;/mode&gt;
4256     &lt;mode name='custom' supported='yes'&gt;
4257       &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
4258       &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
4259       &lt;model usable='no'&gt;arm1136&lt;/model&gt;
4260     &lt;/mode&gt;
4261   &lt;/cpu&gt;
4262   &lt;devices&gt;
4263     &lt;disk supported='yes'&gt;
4264       &lt;enum name='diskDevice'&gt;
4265         &lt;value&gt;disk&lt;/value&gt;
4266         &lt;value&gt;cdrom&lt;/value&gt;
4267         &lt;value&gt;floppy&lt;/value&gt;
4268         &lt;value&gt;lun&lt;/value&gt;
4269       &lt;/enum&gt;
4270       &lt;enum name='bus'&gt;
4271         &lt;value&gt;fdc&lt;/value&gt;
4272         &lt;value&gt;scsi&lt;/value&gt;
4273         &lt;value&gt;virtio&lt;/value&gt;
4274         &lt;value&gt;usb&lt;/value&gt;
4275         &lt;value&gt;sata&lt;/value&gt;
4276       &lt;/enum&gt;
4277     &lt;/disk&gt;
4278     &lt;graphics supported='yes'&gt;
4279       &lt;enum name='type'&gt;
4280         &lt;value&gt;sdl&lt;/value&gt;
4281         &lt;value&gt;vnc&lt;/value&gt;
4282       &lt;/enum&gt;
4283     &lt;/graphics&gt;
4284     &lt;video supported='yes'&gt;
4285       &lt;enum name='modelType'&gt;
4286         &lt;value&gt;vga&lt;/value&gt;
4287         &lt;value&gt;virtio&lt;/value&gt;
4288       &lt;/enum&gt;
4289     &lt;/video&gt;
4290     &lt;hostdev supported='yes'&gt;
4291       &lt;enum name='mode'&gt;
4292         &lt;value&gt;subsystem&lt;/value&gt;
4293       &lt;/enum&gt;
4294       &lt;enum name='startupPolicy'&gt;
4295         &lt;value&gt;default&lt;/value&gt;
4296         &lt;value&gt;mandatory&lt;/value&gt;
4297         &lt;value&gt;requisite&lt;/value&gt;
4298         &lt;value&gt;optional&lt;/value&gt;
4299       &lt;/enum&gt;
4300       &lt;enum name='subsysType'&gt;
4301         &lt;value&gt;usb&lt;/value&gt;
4302         &lt;value&gt;pci&lt;/value&gt;
4303         &lt;value&gt;scsi&lt;/value&gt;
4304       &lt;/enum&gt;
4305       &lt;enum name='capsType'/&gt;
4306       &lt;enum name='pciBackend'&gt;
4307         &lt;value&gt;default&lt;/value&gt;
4308         &lt;value&gt;kvm&lt;/value&gt;
4309         &lt;value&gt;vfio&lt;/value&gt;
4310       &lt;/enum&gt;
4311     &lt;/hostdev&gt;
4312   &lt;/devices&gt;
4313   &lt;features&gt;
4314     &lt;gic supported='yes'&gt;
4315       &lt;enum name='version'&gt;
4316         &lt;value&gt;3&lt;/value&gt;
4317       &lt;/enum&gt;
4318     &lt;/gic&gt;
4319     &lt;vmcoreinfo supported='yes'/&gt;
4320   &lt;/features&gt;
4321 &lt;/domainCapabilities&gt;
4322         """
4323         self.mock_conn.getDomainCapabilities.return_value = (
4324             xml  # pylint: disable=no-member
4325         )
4326         caps = virt.domain_capabilities()
4327         expected = {
4328             "emulator": "/usr/bin/qemu-system-aarch64",
4329             "domain": "kvm",
4330             "machine": "virt-2.12",
4331             "arch": "aarch64",
4332             "max_vcpus": 255,
4333             "iothreads": True,
4334             "os": {
4335                 "loader": {
4336                     "type": ["rom", "pflash"],
4337                     "readonly": ["yes", "no"],
4338                     "values": [
4339                         "/usr/share/AAVMF/AAVMF_CODE.fd",
4340                         "/usr/share/AAVMF/AAVMF32_CODE.fd",
4341                         "/usr/share/OVMF/OVMF_CODE.fd",
4342                     ],
4343                 }
4344             },
4345             "cpu": {
4346                 "host-passthrough": True,
4347                 "host-model": {
4348                     "model": {"name": "sample-cpu", "fallback": "forbid"},
4349                     "vendor": "ACME",
4350                     "features": {"vme": "require", "ss": "require"},
4351                 },
4352                 "custom": {
4353                     "models": {"pxa262": "unknown", "pxa270-a0": "yes", "arm1136": "no"}
4354                 },
4355             },
4356             "devices": {
4357                 "disk": {
4358                     "diskDevice": ["disk", "cdrom", "floppy", "lun"],
4359                     "bus": ["fdc", "scsi", "virtio", "usb", "sata"],
4360                 },
4361                 "graphics": {"type": ["sdl", "vnc"]},
4362                 "video": {"modelType": ["vga", "virtio"]},
4363                 "hostdev": {
4364                     "mode": ["subsystem"],
4365                     "startupPolicy": ["default", "mandatory", "requisite", "optional"],
4366                     "subsysType": ["usb", "pci", "scsi"],
4367                     "capsType": [],
4368                     "pciBackend": ["default", "kvm", "vfio"],
4369                 },
4370             },
4371             "features": {"gic": {"version": ["3"]}, "vmcoreinfo": {}},
4372         }
4373         self.assertEqual(expected, caps)
4374     def test_all_capabilities(self):
4375         domainXml = """
4376 &lt;domainCapabilities&gt;
4377   &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
4378   &lt;domain&gt;kvm&lt;/domain&gt;
4379   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4380   &lt;arch&gt;x86_64&lt;/arch&gt;
4381   &lt;vcpu max='255'/&gt;
4382   &lt;iothreads supported='yes'/&gt;
4383 &lt;/domainCapabilities&gt;
4384         """
4385         hostXml = """
4386 &lt;capabilities&gt;
4387   &lt;host&gt;
4388     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
4389     &lt;cpu&gt;
4390       &lt;arch&gt;x86_64&lt;/arch&gt;
4391       &lt;model&gt;Nehalem&lt;/model&gt;
4392       &lt;vendor&gt;Intel&lt;/vendor&gt;
4393       &lt;microcode version='25'/&gt;
4394       &lt;topology sockets='1' cores='4' threads='2'/&gt;
4395     &lt;/cpu&gt;
4396   &lt;/host&gt;
4397   &lt;guest&gt;
4398     &lt;os_type&gt;hvm&lt;/os_type&gt;
4399     &lt;arch name='x86_64'&gt;
4400       &lt;wordsize&gt;64&lt;/wordsize&gt;
4401       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4402       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4403       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4404       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4405       &lt;domain type='qemu'/&gt;
4406       &lt;domain type='kvm'&gt;
4407         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4408         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4409         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4410         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4411       &lt;/domain&gt;
4412     &lt;/arch&gt;
4413   &lt;/guest&gt;
4414 &lt;/capabilities&gt;
4415         """
4416         self.mock_conn.getCapabilities.return_value = hostXml
4417         self.mock_conn.getDomainCapabilities.side_effect = [
4418             domainXml,
4419             domainXml.replace("&lt;domain&gt;kvm", "&lt;domain&gt;qemu"),
4420         ]
4421         caps = virt.all_capabilities()
4422         self.assertEqual(
4423             "44454c4c-3400-105a-8033-b3c04f4b344a", caps["host"]["host"]["uuid"]
4424         )
4425         self.assertEqual(
4426             {"qemu", "kvm"},
4427             {domainCaps["domain"] for domainCaps in caps["domains"]},
4428         )
4429         self.assertEqual(
4430             {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
4431             {
4432                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "kvm"),
4433                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "qemu"),
4434             },
4435         )
4436     def test_network_tag(self):
4437         xml_data = virt._gen_net_xml("network", "main", "bridge", "openvswitch", 1001)
4438         root = ET.fromstring(xml_data)
4439         self.assertEqual(root.find("name").text, "network")
4440         self.assertEqual(root.find("bridge").attrib["name"], "main")
4441         self.assertEqual(root.find("forward").attrib["mode"], "bridge")
4442         self.assertEqual(root.find("virtualport").attrib["type"], "openvswitch")
4443         self.assertEqual(root.find("vlan/tag").attrib["id"], "1001")
4444     def test_list_networks(self):
4445         names = ["net1", "default", "net2"]
4446         net_mocks = [MagicMock(), MagicMock(), MagicMock()]
4447         for i, value in enumerate(names):
4448             net_mocks[i].name.return_value = value
4449         self.mock_conn.listAllNetworks.return_value = (
4450             net_mocks  # pylint: disable=no-member
4451         )
4452         actual = virt.list_networks()
4453         self.assertEqual(names, actual)
4454     def test_network_info(self):
4455         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4456         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4457         net_mock = MagicMock()
4458         net_mock.name.return_value = "foo"
4459         net_mock.UUIDString.return_value = "some-uuid"
4460         net_mock.bridgeName.return_value = "br0"
4461         net_mock.autostart.return_value = True
4462         net_mock.isActive.return_value = False
4463         net_mock.isPersistent.return_value = True
4464         net_mock.DHCPLeases.return_value = [
4465             {
4466                 "iface": "virbr0",
4467                 "expirytime": 1527757552,
4468                 "type": 0,
4469                 "mac": "52:54:00:01:71:bd",
4470                 "ipaddr": "192.168.122.45",
4471                 "prefix": 24,
4472                 "hostname": "py3-test",
4473                 "clientid": "01:52:54:00:01:71:bd",
4474                 "iaid": None,
4475             }
4476         ]
4477         self.mock_conn.listAllNetworks.return_value = [net_mock]
4478         net = virt.network_info("foo")
4479         self.assertEqual(
4480             {
4481                 "foo": {
4482                     "uuid": "some-uuid",
4483                     "bridge": "br0",
4484                     "autostart": True,
4485                     "active": False,
4486                     "persistent": True,
4487                     "leases": [
4488                         {
4489                             "iface": "virbr0",
4490                             "expirytime": 1527757552,
4491                             "type": "ipv4",
4492                             "mac": "52:54:00:01:71:bd",
4493                             "ipaddr": "192.168.122.45",
4494                             "prefix": 24,
4495                             "hostname": "py3-test",
4496                             "clientid": "01:52:54:00:01:71:bd",
4497                             "iaid": None,
4498                         }
4499                     ],
4500                 }
4501             },
4502             net,
4503         )
4504     def test_network_info_all(self):
4505         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4506         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4507         net_mocks = []
4508         for i in range(2):
4509             net_mock = MagicMock()
4510             net_mock.name.return_value = "net{}".format(i)
4511             net_mock.UUIDString.return_value = "some-uuid"
4512             net_mock.bridgeName.return_value = "br{}".format(i)
4513             net_mock.autostart.return_value = True
4514             net_mock.isActive.return_value = False
4515             net_mock.isPersistent.return_value = True
4516             net_mock.DHCPLeases.return_value = []
4517             net_mocks.append(net_mock)
4518         self.mock_conn.listAllNetworks.return_value = net_mocks
4519         net = virt.network_info()
4520         self.assertEqual(
4521             {
4522                 "net0": {
4523                     "uuid": "some-uuid",
4524                     "bridge": "br0",
4525                     "autostart": True,
4526                     "active": False,
4527                     "persistent": True,
4528                     "leases": [],
4529                 },
4530                 "net1": {
4531                     "uuid": "some-uuid",
4532                     "bridge": "br1",
4533                     "autostart": True,
4534                     "active": False,
4535                     "persistent": True,
4536                     "leases": [],
4537                 },
4538             },
4539             net,
4540         )
4541     def test_network_info_notfound(self):
4542         self.mock_conn.listAllNetworks.return_value = []
4543         net = virt.network_info("foo")
4544         self.assertEqual({}, net)
4545     def test_network_get_xml(self):
4546         network_mock = MagicMock()
4547         network_mock.XMLDesc.return_value = "&lt;net&gt;Raw XML&lt;/net&gt;"
4548         self.mock_conn.networkLookupByName.return_value = network_mock
4549         self.assertEqual("&lt;net&gt;Raw XML&lt;/net&gt;", virt.network_get_xml("default"))
4550     def test_pool(self):
4551         xml_data = virt._gen_pool_xml("pool", "logical", "/dev/base")
4552         root = ET.fromstring(xml_data)
4553         self.assertEqual(root.find("name").text, "pool")
4554         self.assertEqual(root.attrib["type"], "logical")
4555         self.assertEqual(root.find("target/path").text, "/dev/base")
4556     def test_pool_with_source(self):
4557         xml_data = virt._gen_pool_xml(
4558             "pool", "logical", "/dev/base", source_devices=[{"path": "/dev/sda"}]
4559         )
4560         root = ET.fromstring(xml_data)
4561         self.assertEqual(root.find("name").text, "pool")
4562         self.assertEqual(root.attrib["type"], "logical")
4563         self.assertEqual(root.find("target/path").text, "/dev/base")
4564         self.assertEqual(root.find("source/device").attrib["path"], "/dev/sda")
4565     def test_pool_with_scsi(self):
4566         xml_data = virt._gen_pool_xml(
4567             "pool",
4568             "scsi",
4569             "/dev/disk/by-path",
4570             source_devices=[{"path": "/dev/sda"}],
4571             source_adapter={
4572                 "type": "scsi_host",
4573                 "parent_address": {
4574                     "unique_id": 5,
4575                     "address": {
4576                         "domain": "0x0000",
4577                         "bus": "0x00",
4578                         "slot": "0x1f",
4579                         "function": "0x2",
4580                     },
4581                 },
4582             },
4583             source_name="srcname",
4584         )
4585         root = ET.fromstring(xml_data)
4586         self.assertEqual(root.find("name").text, "pool")
4587         self.assertEqual(root.attrib["type"], "scsi")
4588         self.assertEqual(root.find("target/path").text, "/dev/disk/by-path")
4589         self.assertEqual(root.find("source/device"), None)
4590         self.assertEqual(root.find("source/name"), None)
4591         self.assertEqual(root.find("source/adapter").attrib["type"], "scsi_host")
4592         self.assertEqual(
4593             root.find("source/adapter/parentaddr").attrib["unique_id"], "5"
4594         )
4595         self.assertEqual(
4596             root.find("source/adapter/parentaddr/address").attrib["domain"], "0x0000"
4597         )
4598         self.assertEqual(
4599             root.find("source/adapter/parentaddr/address").attrib["bus"], "0x00"
4600         )
4601         self.assertEqual(
4602             root.find("source/adapter/parentaddr/address").attrib["slot"], "0x1f"
4603         )
4604         self.assertEqual(
4605             root.find("source/adapter/parentaddr/address").attrib["function"], "0x2"
4606         )
4607     def test_pool_with_rbd(self):
4608         xml_data = virt._gen_pool_xml(
4609             "pool",
4610             "rbd",
4611             source_devices=[{"path": "/dev/sda"}],
4612             source_hosts=["1.2.3.4", "my.ceph.monitor:69"],
4613             source_auth={
4614                 "type": "ceph",
4615                 "username": "admin",
4616                 "secret": {"type": "uuid", "value": "someuuid"},
4617             },
4618             source_name="srcname",
4619             source_adapter={"type": "scsi_host", "name": "host0"},
4620             source_dir="/some/dir",
4621             source_format="fmt",
4622         )
4623         root = ET.fromstring(xml_data)
4624         self.assertEqual(root.find("name").text, "pool")
4625         self.assertEqual(root.attrib["type"], "rbd")
4626         self.assertEqual(root.find("target"), None)
4627         self.assertEqual(root.find("source/device"), None)
4628         self.assertEqual(root.find("source/name").text, "srcname")
4629         self.assertEqual(root.find("source/adapter"), None)
4630         self.assertEqual(root.find("source/dir"), None)
4631         self.assertEqual(root.find("source/format"), None)
4632         self.assertEqual(root.findall("source/host")[0].attrib["name"], "1.2.3.4")
4633         self.assertTrue("port" not in root.findall("source/host")[0].attrib)
4634         self.assertEqual(
4635             root.findall("source/host")[1].attrib["name"], "my.ceph.monitor"
4636         )
4637         self.assertEqual(root.findall("source/host")[1].attrib["port"], "69")
4638         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4639         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4640         self.assertEqual(root.find("source/auth/secret").attrib["uuid"], "someuuid")
4641     def test_pool_with_netfs(self):
4642         xml_data = virt._gen_pool_xml(
4643             "pool",
4644             "netfs",
4645             target="/path/to/target",
4646             permissions={
4647                 "mode": "0770",
4648                 "owner": 1000,
4649                 "group": 100,
4650                 "label": "seclabel",
4651             },
4652             source_devices=[{"path": "/dev/sda"}],
4653             source_hosts=["nfs.host"],
4654             source_name="srcname",
4655             source_adapter={"type": "scsi_host", "name": "host0"},
4656             source_dir="/some/dir",
4657             source_format="nfs",
4658         )
4659         root = ET.fromstring(xml_data)
4660         self.assertEqual(root.find("name").text, "pool")
4661         self.assertEqual(root.attrib["type"], "netfs")
4662         self.assertEqual(root.find("target/path").text, "/path/to/target")
4663         self.assertEqual(root.find("target/permissions/mode").text, "0770")
4664         self.assertEqual(root.find("target/permissions/owner").text, "1000")
4665         self.assertEqual(root.find("target/permissions/group").text, "100")
4666         self.assertEqual(root.find("target/permissions/label").text, "seclabel")
4667         self.assertEqual(root.find("source/device"), None)
4668         self.assertEqual(root.find("source/name"), None)
4669         self.assertEqual(root.find("source/adapter"), None)
4670         self.assertEqual(root.find("source/dir").attrib["path"], "/some/dir")
4671         self.assertEqual(root.find("source/format").attrib["type"], "nfs")
4672         self.assertEqual(root.find("source/host").attrib["name"], "nfs.host")
4673         self.assertEqual(root.find("source/auth"), None)
4674     def test_pool_with_iscsi_direct(self):
4675         xml_data = virt._gen_pool_xml(
4676             "pool",
4677             "iscsi-direct",
4678             source_hosts=["iscsi.example.com"],
4679             source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4680             source_initiator="iqn.2013-06.com.example:iscsi-initiator",
4681         )
4682         root = ET.fromstring(xml_data)
4683         self.assertEqual(root.find("name").text, "pool")
4684         self.assertEqual(root.attrib["type"], "iscsi-direct")
4685         self.assertEqual(root.find("target"), None)
4686         self.assertEqual(
4687             root.find("source/device").attrib["path"],
4688             "iqn.2013-06.com.example:iscsi-pool",
4689         )
4690         self.assertEqual(
4691             root.findall("source/host")[0].attrib["name"], "iscsi.example.com"
4692         )
4693         self.assertEqual(
4694             root.find("source/initiator/iqn").attrib["name"],
4695             "iqn.2013-06.com.example:iscsi-initiator",
4696         )
4697     def test_pool_define(self):
4698         mock_pool = MagicMock()
4699         mock_secret = MagicMock()
4700         mock_secret_define = MagicMock(return_value=mock_secret)
4701         self.mock_conn.secretDefineXML = mock_secret_define
4702         self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
4703         self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)
4704         mocks = [
4705             mock_pool,
4706             mock_secret,
4707             mock_secret_define,
4708             self.mock_conn.storagePoolCreateXML,
4709             self.mock_conn.secretDefineXML,
4710             self.mock_conn.storagePoolDefineXML,
4711         ]
4712         self.assertTrue(
4713             virt.pool_define(
4714                 "default",
4715                 "rbd",
4716                 source_hosts=["one.example.com", "two.example.com"],
4717                 source_name="rbdvol",
4718                 source_auth={
4719                     "type": "ceph",
4720                     "username": "admin",
4721                     "secret": {"type": "uuid", "value": "someuuid"},
4722                 },
4723             )
4724         )
4725         self.mock_conn.storagePoolDefineXML.assert_called_once()
4726         self.mock_conn.storagePoolCreateXML.assert_not_called()
4727         mock_pool.create.assert_called_once()
4728         mock_secret_define.assert_not_called()
4729         for mock in mocks:
4730             mock.reset_mock()
4731         self.assertTrue(
4732             virt.pool_define(
4733                 "default",
4734                 "rbd",
4735                 transient=True,
4736                 source_hosts=["one.example.com", "two.example.com"],
4737                 source_name="rbdvol",
4738                 source_auth={"username": "admin", "password": "c2VjcmV0"},
4739             )
4740         )
4741         self.mock_conn.storagePoolDefineXML.assert_not_called()
4742         pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
4743         root = ET.fromstring(pool_xml)
4744         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4745         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4746         self.assertEqual(
4747             root.find("source/auth/secret").attrib["usage"], "pool_default"
4748         )
4749         mock_pool.create.assert_not_called()
4750         mock_secret.setValue.assert_called_once_with(b"secret")
4751         secret_xml = mock_secret_define.call_args[0][0]
4752         root = ET.fromstring(secret_xml)
4753         self.assertEqual(root.find("usage/name")<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.text, "pool_default")
4754         self.assertEqual(root.find("usage").attrib["type"], "ceph")
4755         self.assertEqual(root.attrib["private"], "yes")
4756         self.assertEqual(
4757             root.find("description").</b></font>text, "Passphrase for default pool created by Salt"
4758         )
4759         for mock in mocks:
4760             mock.reset_mock()
4761         self.assertTrue(
4762             virt.pool_define(
4763                 "default",
4764                 "iscsi",
4765                 target="/dev/disk/by-path",
4766                 source_hosts=["iscsi.example.com"],
4767                 source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4768                 source_auth={"username": "admin", "password": "secret"},
4769                 start=False,
4770             )
4771         )
4772         self.mock_conn.storagePoolCreateXML.assert_not_called()
4773         pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
4774         root = ET.fromstring(pool_xml)
4775         self.assertEqual(root.find("source/auth").attrib["type"], "chap")
4776         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4777         self.assertEqual(
4778             root.find("source/auth/secret").attrib["usage"], "pool_default"
4779         )
4780         mock_pool.create.assert_not_called()
4781         mock_secret.setValue.assert_called_once_with("secret")
4782         secret_xml = mock_secret_define.call_args[0][0]
4783         root = ET.fromstring(secret_xml)
4784         self.assertEqual(root.find("usage/target").text, "pool_default")
4785         self.assertEqual(root.find("usage").attrib["type"], "iscsi")
4786         self.assertEqual(root.attrib["private"], "yes")
4787         self.assertEqual(
4788             root.find("description").text, "Passphrase for default pool created by Salt"
4789         )
4790     def test_list_pools(self):
4791         names = ["pool1", "default", "pool2"]
4792         pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
4793         for i, value in enumerate(names):
4794             pool_mocks[i].name.return_value = value
4795         self.mock_conn.listAllStoragePools.return_value = (
4796             pool_mocks  # pylint: disable=no-member
4797         )
4798         actual = virt.list_pools()
4799         self.assertEqual(names, actual)
4800     def test_pool_info(self):
4801         pool_mock = MagicMock()
4802         pool_mock.name.return_value = "foo"
4803         pool_mock.UUIDString.return_value = "some-uuid"
4804         pool_mock.info.return_value = [0, 1234, 5678, 123]
4805         pool_mock.autostart.return_value = True
4806         pool_mock.isPersistent.return_value = True
4807         pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4808   &lt;name&gt;default&lt;/name&gt;
4809   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4810   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4811   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4812   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4813   &lt;source&gt;
4814   &lt;/source&gt;
4815   &lt;target&gt;
4816     &lt;path&gt;/srv/vms&lt;/path&gt;
4817     &lt;permissions&gt;
4818       &lt;mode&gt;0755&lt;/mode&gt;
4819       &lt;owner&gt;0&lt;/owner&gt;
4820       &lt;group&gt;0&lt;/group&gt;
4821     &lt;/permissions&gt;
4822   &lt;/target&gt;
4823 &lt;/pool&gt;"""
4824         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4825         pool = virt.pool_info("foo")
4826         self.assertEqual(
4827             {
4828                 "foo": {
4829                     "uuid": "some-uuid",
4830                     "state": "inactive",
4831                     "capacity": 1234,
4832                     "allocation": 5678,
4833                     "free": 123,
4834                     "autostart": True,
4835                     "persistent": True,
4836                     "type": "dir",
4837                     "target_path": "/srv/vms",
4838                 }
4839             },
4840             pool,
4841         )
4842     def test_pool_info_notarget(self):
4843         pool_mock = MagicMock()
4844         pool_mock.name.return_value = "ceph"
4845         pool_mock.UUIDString.return_value = "some-uuid"
4846         pool_mock.info.return_value = [0, 0, 0, 0]
4847         pool_mock.autostart.return_value = True
4848         pool_mock.isPersistent.return_value = True
4849         pool_mock.XMLDesc.return_value = """&lt;pool type='rbd'&gt;
4850   &lt;name&gt;ceph&lt;/name&gt;
4851   &lt;uuid&gt;some-uuid&lt;/uuid&gt;
4852   &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
4853   &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
4854   &lt;available unit='bytes'&gt;0&lt;/available&gt;
4855   &lt;source&gt;
4856     &lt;host name='localhost' port='6789'/&gt;
4857     &lt;host name='localhost' port='6790'/&gt;
4858     &lt;name&gt;rbd&lt;/name&gt;
4859     &lt;auth type='ceph' username='admin'&gt;
4860       &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
4861     &lt;/auth&gt;
4862   &lt;/source&gt;
4863 &lt;/pool&gt;"""
4864         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4865         pool = virt.pool_info("ceph")
4866         self.assertEqual(
4867             {
4868                 "ceph": {
4869                     "uuid": "some-uuid",
4870                     "state": "inactive",
4871                     "capacity": 0,
4872                     "allocation": 0,
4873                     "free": 0,
4874                     "autostart": True,
4875                     "persistent": True,
4876                     "type": "rbd",
4877                     "target_path": None,
4878                 }
4879             },
4880             pool,
4881         )
4882     def test_pool_info_notfound(self):
4883         self.mock_conn.listAllStoragePools.return_value = []
4884         pool = virt.pool_info("foo")
4885         self.assertEqual({}, pool)
4886     def test_pool_info_all(self):
4887         pool_mocks = []
4888         for i in range(2):
4889             pool_mock = MagicMock()
4890             pool_mock.name.return_value = "pool{}".format(i)
4891             pool_mock.UUIDString.return_value = "some-uuid-{}".format(i)
4892             pool_mock.info.return_value = [0, 1234, 5678, 123]
4893             pool_mock.autostart.return_value = True
4894             pool_mock.isPersistent.return_value = True
4895             pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4896   &lt;name&gt;default&lt;/name&gt;
4897   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4898   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4899   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4900   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4901   &lt;source&gt;
4902   &lt;/source&gt;
4903   &lt;target&gt;
4904     &lt;path&gt;/srv/vms&lt;/path&gt;
4905     &lt;permissions&gt;
4906       &lt;mode&gt;0755&lt;/mode&gt;
4907       &lt;owner&gt;0&lt;/owner&gt;
4908       &lt;group&gt;0&lt;/group&gt;
4909     &lt;/permissions&gt;
4910   &lt;/target&gt;
4911 &lt;/pool&gt;"""
4912             pool_mocks.append(pool_mock)
4913         self.mock_conn.listAllStoragePools.return_value = pool_mocks
4914         pool = virt.pool_info()
4915         self.assertEqual(
4916             {
4917                 "pool0": {
4918                     "uuid": "some-uuid-0",
4919                     "state": "inactive",
4920                     "capacity": 1234,
4921                     "allocation": 5678,
4922                     "free": 123,
4923                     "autostart": True,
4924                     "persistent": True,
4925                     "type": "dir",
4926                     "target_path": "/srv/vms",
4927                 },
4928                 "pool1": {
4929                     "uuid": "some-uuid-1",
4930                     "state": "inactive",
4931                     "capacity": 1234,
4932                     "allocation": 5678,
4933                     "free": 123,
4934                     "autostart": True,
4935                     "persistent": True,
4936                     "type": "dir",
4937                     "target_path": "/srv/vms",
4938                 },
4939             },
4940             pool,
4941         )
4942     def test_pool_get_xml(self):
4943         pool_mock = MagicMock()
4944         pool_mock.XMLDesc.return_value = "&lt;pool&gt;Raw XML&lt;/pool&gt;"
4945         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
4946         self.assertEqual("&lt;pool&gt;Raw XML&lt;/pool&gt;", virt.pool_get_xml("default"))
4947     def test_pool_list_volumes(self):
4948         names = ["volume1", "volume2"]
4949         mock_pool = MagicMock()
4950         mock_pool.listVolumes.return_value = names
4951         self.mock_conn.storagePoolLookupByName.return_value = mock_pool
4952         self.assertEqual(names, virt.pool_list_volumes("default"))
4953     @patch("salt.modules.virt._is_bhyve_hyper", return_value=False)
4954     @patch("salt.modules.virt._is_kvm_hyper", return_value=True)
4955     @patch("salt.modules.virt._is_xen_hyper", return_value=False)
4956     def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
4957         self.assertEqual("kvm", virt.get_hypervisor())
4958         iskvm_mock.return_value = False
4959         self.assertIsNone(virt.get_hypervisor())
4960         is_bhyve_mock.return_value = False
4961         self.assertIsNone(virt.get_hypervisor())
4962         isxen_mock.return_value = True
4963         self.assertEqual("xen", virt.get_hypervisor())
4964     def test_pool_delete(self):
4965         mock_pool = MagicMock()
4966         mock_pool.delete = MagicMock(return_value=0)
4967         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4968         res = virt.pool_delete("test-pool")
4969         self.assertTrue(res)
4970         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-pool")
4971         mock_pool.delete.assert_called_once_with(
4972             self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
4973         )
4974     def test_pool_undefine_secret(self):
4975         mock_pool = MagicMock()
4976         mock_pool.undefine = MagicMock(return_value=0)
4977         mock_pool.XMLDesc.return_value = """
4978             &lt;pool type='rbd'&gt;
4979               &lt;name&gt;test-ses&lt;/name&gt;
4980               &lt;source&gt;
4981                 &lt;host name='myhost'/&gt;
4982                 &lt;name&gt;libvirt-pool&lt;/name&gt;
4983                 &lt;auth type='ceph' username='libvirt'&gt;
4984                   &lt;secret usage='pool_test-ses'/&gt;
4985                 &lt;/auth&gt;
4986               &lt;/source&gt;
4987             &lt;/pool&gt;
4988         """
4989         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4990         mock_undefine = MagicMock(return_value=0)
4991         self.mock_conn.secretLookupByUsage.return_value.undefine = mock_undefine
4992         res = virt.pool_undefine("test-ses")
4993         self.assertTrue(res)
4994         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-ses")
4995         mock_pool.undefine.assert_called_once_with()
4996         self.mock_conn.secretLookupByUsage.assert_called_once_with(
4997             self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, "pool_test-ses"
4998         )
4999         mock_undefine.assert_called_once()
5000     def test_full_info(self):
5001         xml = """&lt;domain type='kvm' id='7'&gt;
5002               &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
5003               &lt;name&gt;test-vm&lt;/name&gt;
5004               &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
5005               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
5006               &lt;on_crash&gt;destroy&lt;/on_crash&gt;
5007               &lt;devices&gt;
5008                 &lt;disk type='file' device='disk'&gt;
5009                 &lt;driver name='qemu' type='qcow2'/&gt;
5010                 &lt;source file='/disks/test.qcow2'/&gt;
5011                 &lt;target dev='vda' bus='virtio'/&gt;
5012               &lt;/disk&gt;
5013               &lt;disk type='file' device='cdrom'&gt;
5014                 &lt;driver name='qemu' type='raw'/&gt;
5015                 &lt;source file='/disks/test-cdrom.iso'/&gt;
5016                 &lt;target dev='hda' bus='ide'/&gt;
5017                 &lt;readonly/&gt;
5018               &lt;/disk&gt;
5019               &lt;interface type='bridge'&gt;
5020                 &lt;mac address='ac:de:48:b6:8b:59'/&gt;
5021                 &lt;source bridge='br0'/&gt;
5022                 &lt;model type='virtio'/&gt;
5023                 &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
5024               &lt;/interface&gt;
5025               &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
5026                 &lt;listen type='address' address='0.0.0.0'/&gt;
5027               &lt;/graphics&gt;
5028               &lt;/devices&gt;
5029             &lt;/domain&gt;
5030         """
5031         self.set_mock_vm("test-vm", xml)
5032         qemu_infos = """[{
5033             "virtual-size": 25769803776,
5034             "filename": "/disks/test.qcow2",
5035             "cluster-size": 65536,
5036             "format": "qcow2",
5037             "actual-size": 217088,
5038             "format-specific": {
5039                 "type": "qcow2",
5040                 "data": {
5041                     "compat": "1.1",
5042                     "lazy-refcounts": false,
5043                     "refcount-bits": 16,
5044                     "corrupt": false
5045                 }
5046             },
5047             "full-backing-filename": "/disks/mybacking.qcow2",
5048             "backing-filename": "mybacking.qcow2",
5049             "dirty-flag": false
5050         },
5051         {
5052             "virtual-size": 25769803776,
5053             "filename": "/disks/mybacking.qcow2",
5054             "cluster-size": 65536,
5055             "format": "qcow2",
5056             "actual-size": 393744384,
5057             "format-specific": {
5058                 "type": "qcow2",
5059                 "data": {
5060                     "compat": "1.1",
5061                     "lazy-refcounts": false,
5062                     "refcount-bits": 16,
5063                     "corrupt": false
5064                 }
5065             },
5066             "dirty-flag": false
5067         }]"""
5068         self.mock_popen.communicate.return_value = [qemu_infos, ""]
5069         self.mock_popen.returncode = 0
5070         self.mock_conn.getInfo = MagicMock(
5071             return_value=["x86_64", 4096, 8, 2712, 1, 2, 4, 2]
5072         )
5073         actual = virt.full_info()
5074         qemu_img_call = [
5075             call
5076             for call in self.mock_subprocess.Popen<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.call_args_list
5077             if "qemu-img" in call[0][0]
5078         ][0]
5079         self.assertIn("info", qemu_img_call[0][0])
5080         self.assertIn("-U", qemu_img_call[0][0])
5081         self.</b></font>assertEqual(2816, actual["freemem"])
5082         self.assertEqual(6, actual["freecpu"])
5083         self.assertEqual(4, actual["node_info"]["cpucores"])
5084         self.assertEqual(2712, actual["node_info"]["cpumhz"])
5085         self.assertEqual("x86_64", actual["node_info"]["cpumodel"])
5086         self.assertEqual(8, actual["node_info"]["cpus"])
5087         self.assertEqual(2, actual["node_info"]["cputhreads"])
5088         self.assertEqual(1, actual["node_info"]["numanodes"])
5089         self.assertEqual(4096, actual["node_info"]["phymemory"])
5090         self.assertEqual(2, actual["node_info"]["sockets"])
5091         self.assertEqual(2, actual["vm_info"]["test-vm"]["cpu"])
5092         self.assertEqual(1234, actual["vm_info"]["test-vm"]["cputime"])
5093         self.assertEqual(1024 * 1024, actual["vm_info"]["test-vm"]["mem"])
5094         self.assertEqual(2048 * 1024, actual["vm_info"]["test-vm"]["maxMem"])
5095         self.assertEqual("shutdown", actual["vm_info"]["test-vm"]["state"])
5096         self.assertEqual(
5097             "28deee33-4859-4f23-891c-ee239cffec94", actual["vm_info"]["test-vm"]["uuid"]
5098         )
5099         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_crash"])
5100         self.assertEqual("restart", actual["vm_info"]["test-vm"]["on_reboot"])
5101         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_poweroff"])
5102         nic = actual["vm_info"]["test-vm"]["nics"]["ac:de:48:b6:8b:59"]
5103         self.assertEqual("bridge", nic["type"])
5104         self.assertEqual("ac:de:48:b6:8b:59", nic["mac"])
5105         disks = actual["vm_info"]["test-vm"]["disks"]
5106         disk = disks.get("vda")
5107         self.assertEqual("/disks/test.qcow2", disk["file"])
5108         self.assertEqual("disk", disk["type"])
5109         self.assertEqual("/disks/mybacking.qcow2", disk["backing file"]["file"])
5110         cdrom = disks.get("hda")
5111         self.assertEqual("/disks/test-cdrom.iso", cdrom["file"])
5112         self.assertEqual("cdrom", cdrom["type"])
5113         self.assertFalse("backing file" in cdrom.keys())
5114         graphics = actual["vm_info"]["test-vm"]["graphics"]
5115         self.assertEqual("vnc", graphics["type"])
5116         self.assertEqual("5900", graphics["port"])
5117         self.assertEqual("0.0.0.0", graphics["listen"])
5118     def test_pool_update(self):
5119         current_xml = """&lt;pool type='dir'&gt;
5120           &lt;name&gt;default&lt;/name&gt;
5121           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5122           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5123           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5124           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5125           &lt;source&gt;
5126           &lt;/source&gt;
5127           &lt;target&gt;
5128             &lt;path&gt;/path/to/pool&lt;/path&gt;
5129             &lt;permissions&gt;
5130               &lt;mode&gt;0775&lt;/mode&gt;
5131               &lt;owner&gt;0&lt;/owner&gt;
5132               &lt;group&gt;100&lt;/group&gt;
5133             &lt;/permissions&gt;
5134           &lt;/target&gt;
5135         &lt;/pool&gt;"""
5136         expected_xml = (
5137             '&lt;pool type="netfs"&gt;'
5138             "&lt;name&gt;default&lt;/name&gt;"
5139             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5140             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5141             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5142             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5143             "&lt;target&gt;"
5144             "&lt;path&gt;/mnt/cifs&lt;/path&gt;"
5145             "&lt;permissions&gt;"
5146             "&lt;mode&gt;0774&lt;/mode&gt;"
5147             "&lt;owner&gt;1234&lt;/owner&gt;"
5148             "&lt;group&gt;123&lt;/group&gt;"
5149             "&lt;/permissions&gt;"
5150             "&lt;/target&gt;"
5151             "&lt;source&gt;"
5152             '&lt;dir path="samba_share" /&gt;'
5153             '&lt;host name="one.example.com" /&gt;'
5154             '&lt;host name="two.example.com" /&gt;'
5155             '&lt;format type="cifs" /&gt;'
5156             "&lt;/source&gt;"
5157             "&lt;/pool&gt;"
5158         )
5159         mocked_pool = MagicMock()
5160         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5161         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5162         self.mock_conn.storagePoolDefineXML = MagicMock()
5163         self.assertTrue(
5164             virt.pool_update(
5165                 "default",
5166                 "netfs",
5167                 target="/mnt/cifs",
5168                 permissions={"mode": "0774", "owner": "1234", "group": "123"},
5169                 source_format="cifs",
5170                 source_dir="samba_share",
5171                 source_hosts=["one.example.com", "two.example.com"],
5172             )
5173         )
5174         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5175     def test_pool_update_nochange(self):
5176         current_xml = """&lt;pool type='dir'&gt;
5177           &lt;name&gt;default&lt;/name&gt;
5178           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5179           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5180           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5181           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5182           &lt;source&gt;
5183           &lt;/source&gt;
5184           &lt;target&gt;
5185             &lt;path&gt;/path/to/pool&lt;/path&gt;
5186             &lt;permissions&gt;
5187               &lt;mode&gt;0775&lt;/mode&gt;
5188               &lt;owner&gt;0&lt;/owner&gt;
5189               &lt;group&gt;100&lt;/group&gt;
5190             &lt;/permissions&gt;
5191           &lt;/target&gt;
5192         &lt;/pool&gt;"""
5193         mocked_pool = MagicMock()
5194         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5195         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5196         self.mock_conn.storagePoolDefineXML = MagicMock()
5197         self.assertFalse(
5198             virt.pool_update(
5199                 "default",
5200                 "dir",
5201                 target="/path/to/pool",
5202                 permissions={"mode": "0775", "owner": "0", "group": "100"},
5203                 test=True,
5204             )
5205         )
5206         self.mock_conn.storagePoolDefineXML.assert_not_called()
5207     def test_pool_update_password(self):
5208         current_xml = """&lt;pool type='rbd'&gt;
5209           &lt;name&gt;default&lt;/name&gt;
5210           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5211           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5212           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5213           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5214           &lt;source&gt;
5215             &lt;name&gt;iscsi-images&lt;/name&gt;
5216             &lt;host name='ses4.tf.local'/&gt;
5217             &lt;host name='ses5.tf.local'/&gt;
5218             &lt;auth username='libvirt' type='ceph'&gt;
5219               &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
5220             &lt;/auth&gt;
5221           &lt;/source&gt;
5222         &lt;/pool&gt;"""
5223         mock_secret = MagicMock()
5224         self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)
5225         mocked_pool = MagicMock()
5226         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5227         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5228         self.mock_conn.storagePoolDefineXML = MagicMock()
5229         self.assertFalse(
5230             virt.pool_update(
5231                 "default",
5232                 "rbd",
5233                 source_name="iscsi-images",
5234                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5235                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5236             )
5237         )
5238         self.mock_conn.storagePoolDefineXML.assert_not_called()
5239         mock_secret.setValue.assert_called_once_with(b"secret")
5240         self.mock_conn.secretLookupByUUIDString = MagicMock(
5241             side_effect=self.mock_libvirt.libvirtError("secret not found")
5242         )
5243         self.assertFalse(
5244             virt.pool_update(
5245                 "default",
5246                 "rbd",
5247                 source_name="iscsi-images",
5248                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5249                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5250             )
5251         )
5252         self.mock_conn.storagePoolDefineXML.assert_not_called()
5253         self.mock_conn.secretDefineXML.assert_called_once()
5254         mock_secret.setValue.assert_called_once_with(b"secret")
5255     def test_pool_update_password_create(self):
5256         current_xml = """&lt;pool type='rbd'&gt;
5257           &lt;name&gt;default&lt;/name&gt;
5258           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5259           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5260           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5261           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5262           &lt;source&gt;
5263             &lt;name&gt;iscsi-images&lt;/name&gt;
5264             &lt;host name='ses4.tf.local'/&gt;
5265             &lt;host name='ses5.tf.local'/&gt;
5266           &lt;/source&gt;
5267         &lt;/pool&gt;"""
5268         expected_xml = (
5269             '&lt;pool type="rbd"&gt;'
5270             "&lt;name&gt;default&lt;/name&gt;"
5271             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5272             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5273             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5274             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5275             "&lt;source&gt;"
5276             '&lt;host name="ses4.tf.local" /&gt;'
5277             '&lt;host name="ses5.tf.local" /&gt;'
5278             '&lt;auth type="ceph" username="libvirt"&gt;'
5279             '&lt;secret usage="pool_default" /&gt;'
5280             "&lt;/auth&gt;"
5281             "&lt;name&gt;iscsi-images&lt;/name&gt;"
5282             "&lt;/source&gt;"
5283             "&lt;/pool&gt;"
5284         )
5285         mock_secret = MagicMock()
5286         self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)
5287         mocked_pool = MagicMock()
5288         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5289         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5290         self.mock_conn.storagePoolDefineXML = MagicMock()
5291         self.assertTrue(
5292             virt.pool_update(
5293                 "default",
5294                 "rbd",
5295                 source_name="iscsi-images",
5296                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5297                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5298             )
5299         )
5300         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5301         mock_secret.setValue.assert_called_once_with(b"secret")
5302     def test_volume_infos(self):
5303         vms_disks = [
5304         ]
5305         mock_vms = []
5306         for idx, disk in enumerate(vms_disks):
5307             vm = MagicMock()
5308             vm.name.return_value = "vm{}".format(idx)
5309             vm.XMLDesc.return_value = """
5310                     &lt;domain type='kvm' id='1'&gt;
5311                       &lt;name&gt;vm{}&lt;/name&gt;
5312                       &lt;devices&gt;{}&lt;/devices&gt;
5313                     &lt;/domain&gt;
5314                 """.format(
5315                 idx, disk
5316             )
5317             mock_vms.append(vm)
5318         mock_pool_data = [
5319             {
5320                 "name": "pool0",
5321                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5322                 "volumes": [
5323                     {
5324                         "key": "/key/of/vol0",
5325                         "name": "vol0",
5326                         "path": "/path/to/vol0.qcow2",
5327                         "info": [0, 123456789, 123456],
5328                         "backingStore": None,
5329                     }
5330                 ],
5331             },
5332             {
5333                 "name": "pool1",
5334                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5335                 "volumes": [
5336                     {
5337                         "key": "/key/of/vol0bad",
5338                         "name": "vol0bad",
5339                         "path": "/path/to/vol0bad.qcow2",
5340                         "info": None,
5341                         "backingStore": None,
5342                     },
5343                     {
5344                         "key": "/key/of/vol1",
5345                         "name": "vol1",
5346                         "path": "/path/to/vol1.qcow2",
5347                         "info": [0, 12345, 1234],
5348                         "backingStore": None,
5349                     },
5350                     {
5351                         "key": "/key/of/vol2",
5352                         "name": "vol2",
5353                         "path": "/path/to/vol2.qcow2",
5354                         "info": [0, 12345, 1234],
5355                         "backingStore": "/path/to/vol0.qcow2",
5356                     },
5357                 ],
5358             },
5359         ]
5360         mock_pools = []
5361         for pool_data in mock_pool_data:
5362             mock_pool = MagicMock()
5363             mock_pool.name.return_value = pool_data["name"]  # pylint: disable=no-member
5364             mock_pool.info.return_value = [pool_data["state"]]
5365             mock_volumes = []
5366             for vol_data in pool_data["volumes"]:
5367                 mock_volume = MagicMock()
5368                 mock_volume.name.return_value = vol_data["name"]
5369                 mock_volume.key.return_value = vol_data["key"]
5370                 mock_volume.path.return_value = "/path/to/{}.qcow2".format(
5371                     vol_data["name"]
5372                 )
5373                 if vol_data["info"]:
5374                     mock_volume.info.return_value = vol_data["info"]
5375                     backing_store = (
5376                             vol_data["backingStore"]
5377                         )
5378                         if vol_data["backingStore"]
5379                         else "&lt;backingStore/&gt;"
5380                     )
5381                     mock_volume.XMLDesc.return_value = """
5382                         &lt;volume type='file'&gt;
5383                           &lt;name&gt;{0}&lt;/name&gt;
5384                           &lt;target&gt;
5385                             &lt;format type="qcow2"/&gt;
5386                             &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
5387                           &lt;/target&gt;
5388                           {1}
5389                         &lt;/volume&gt;
5390                     """.format(
5391                         vol_data["name"], backing_store
5392                     )
5393                 else:
5394                     mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
5395                         "No such volume"
5396                     )
5397                     mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
5398                         "No such volume"
5399                     )
5400                 mock_volumes.append(mock_volume)
5401             mock_pool.listAllVolumes.return_value = (
5402                 mock_volumes  # pylint: disable=no-member
5403             )
5404             mock_pools.append(mock_pool)
5405         inactive_pool = MagicMock()
5406         inactive_pool.name.return_value = "pool2"
5407         inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
5408         inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
5409             "pool is inactive"
5410         )
5411         mock_pools.append(inactive_pool)
5412         self.mock_conn.listAllStoragePools.return_value = (
5413             mock_pools  # pylint: disable=no-member
5414         )
5415         with patch("salt.modules.virt._get_domain", MagicMock(return_value=mock_vms)):
5416             actual = virt.volume_infos("pool0", "vol0")
5417             self.assertEqual(1, len(actual.keys()))
5418             self.assertEqual(1, len(actual["pool0"].keys()))
5419             self.assertEqual(["vm0", "vm2"], sorted(actual["pool0"]["vol0"]["used_by"]))
5420             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5421             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5422             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5423             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5424             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5425             self.assertEqual(
5426                 virt.volume_infos("pool1", None),
5427                 {
5428                     "pool1": {
5429                         "vol1": {
5430                             "type": "file",
5431                             "key": "/key/of/vol1",
5432                             "path": "/path/to/vol1.qcow2",
5433                             "capacity": 12345,
5434                             "allocation": 1234,
5435                             "used_by": [],
5436                             "backing_store": None,
5437                             "format": "qcow2",
5438                         },
5439                         "vol2": {
5440                             "type": "file",
5441                             "key": "/key/of/vol2",
5442                             "path": "/path/to/vol2.qcow2",
5443                             "capacity": 12345,
5444                             "allocation": 1234,
5445                             "used_by": ["vm2"],
5446                             "backing_store": {
5447                                 "path": "/path/to/vol0.qcow2",
5448                                 "format": "qcow2",
5449                             },
5450                             "format": "qcow2",
5451                         },
5452                     }
5453                 },
5454             )
5455             self.assertEqual(
5456                 virt.volume_infos(None, "vol2"),
5457                 {
5458                     "pool1": {
5459                         "vol2": {
5460                             "type": "file",
5461                             "key": "/key/of/vol2",
5462                             "path": "/path/to/vol2.qcow2",
5463                             "capacity": 12345,
5464                             "allocation": 1234,
5465                             "used_by": ["vm2"],
5466                             "backing_store": {
5467                                 "path": "/path/to/vol0.qcow2",
5468                                 "format": "qcow2",
5469                             },
5470                             "format": "qcow2",
5471                         }
5472                     }
5473                 },
5474             )
5475         with patch(
5476             "salt.modules.virt._get_domain", MagicMock(return_value=mock_vms[0])
5477         ):
5478             actual = virt.volume_infos("pool0", "vol0")
5479             self.assertEqual(1, len(actual.keys()))
5480             self.assertEqual(1, len(actual["pool0"].keys()))
5481             self.assertEqual(["vm0"], sorted(actual["pool0"]["vol0"]["used_by"]))
5482             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5483             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5484             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5485             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5486             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5487             self.assertEqual(
5488                 virt.volume_infos("pool1", None),
5489                 {
5490                     "pool1": {
5491                         "vol1": {
5492                             "type": "file",
5493                             "key": "/key/of/vol1",
5494                             "path": "/path/to/vol1.qcow2",
5495                             "capacity": 12345,
5496                             "allocation": 1234,
5497                             "used_by": [],
5498                             "backing_store": None,
5499                             "format": "qcow2",
5500                         },
5501                         "vol2": {
5502                             "type": "file",
5503                             "key": "/key/of/vol2",
5504                             "path": "/path/to/vol2.qcow2",
5505                             "capacity": 12345,
5506                             "allocation": 1234,
5507                             "used_by": [],
5508                             "backing_store": {
5509                                 "path": "/path/to/vol0.qcow2",
5510                                 "format": "qcow2",
5511                             },
5512                             "format": "qcow2",
5513                         },
5514                     }
5515                 },
5516             )
5517             self.assertEqual(
5518                 virt.volume_infos(None, "vol2"),
5519                 {
5520                     "pool1": {
5521                         "vol2": {
5522                             "type": "file",
5523                             "key": "/key/of/vol2",
5524                             "path": "/path/to/vol2.qcow2",
5525                             "capacity": 12345,
5526                             "allocation": 1234,
5527                             "used_by": [],
5528                             "backing_store": {
5529                                 "path": "/path/to/vol0.qcow2",
5530                                 "format": "qcow2",
5531                             },
5532                             "format": "qcow2",
5533                         }
5534                     }
5535                 },
5536             )
5537         with patch(
5538             "salt.modules.virt._get_domain",
5539             MagicMock(side_effect=CommandExecutionError("no VM")),
5540         ):
5541             actual = virt.volume_infos("pool0", "vol0")
5542             self.assertEqual(1, len(actual.keys()))
5543             self.assertEqual(1, len(actual["pool0"].keys()))
5544             self.assertEqual([], sorted(actual["pool0"]["vol0"]["used_by"]))
5545             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5546             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5547             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5548             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5549             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5550             self.assertEqual(
5551                 virt.volume_infos("pool1", None),
5552                 {
5553                     "pool1": {
5554                         "vol1": {
5555                             "type": "file",
5556                             "key": "/key/of/vol1",
5557                             "path": "/path/to/vol1.qcow2",
5558                             "capacity": 12345,
5559                             "allocation": 1234,
5560                             "used_by": [],
5561                             "backing_store": None,
5562                             "format": "qcow2",
5563                         },
5564                         "vol2": {
5565                             "type": "file",
5566                             "key": "/key/of/vol2",
5567                             "path": "/path/to/vol2.qcow2",
5568                             "capacity": 12345,
5569                             "allocation": 1234,
5570                             "used_by": [],
5571                             "backing_store": {
5572                                 "path": "/path/to/vol0.qcow2",
5573                                 "format": "qcow2",
5574                             },
5575                             "format": "qcow2",
5576                         },
5577                     }
5578                 },
5579             )
5580             self.assertEqual(
5581                 virt.volume_infos(None, "vol2"),
5582                 {
5583                     "pool1": {
5584                         "vol2": {
5585                             "type": "file",
5586                             "key": "/key/of/vol2",
5587                             "path": "/path/to/vol2.qcow2",
5588                             "capacity": 12345,
5589                             "allocation": 1234,
5590                             "used_by": [],
5591                             "backing_store": {
5592                                 "path": "/path/to/vol0.qcow2",
5593                                 "format": "qcow2",
5594                             },
5595                             "format": "qcow2",
5596                         }
5597                     }
5598                 },
5599             )
5600     def test_volume_delete(self):
5601         mock_delete = MagicMock(side_effect=[0, 1])
5602         mock_volume = MagicMock()
5603         mock_volume.delete = mock_delete  # pylint: disable=no-member
5604         mock_pool = MagicMock()
5605         mock_pool.storageVolLookupByName.side_effect = [
5606             mock_volume,
5607             mock_volume,
5608             self.mock_libvirt.libvirtError("Missing volume"),
5609             mock_volume,
5610         ]
5611         self.mock_conn.storagePoolLookupByName.side_effect = [
5612             mock_pool,
5613             mock_pool,
5614             mock_pool,
5615             self.mock_libvirt.libvirtError("Missing pool"),
5616         ]
5617         self.assertTrue(virt.volume_delete("default", "test_volume"))
5618         self.assertFalse(virt.volume_delete("default", "test_volume"))
5619         with self.assertRaises(self.mock_libvirt.libvirtError):
5620             virt.volume_delete("default", "missing")
5621             virt.volume_delete("missing", "test_volume")
5622         self.assertEqual(mock_delete.call_count, 2)
5623     def test_pool_capabilities(self):
5624         xml_caps = """
5625 &lt;storagepoolCapabilities&gt;
5626   &lt;pool type='disk' supported='yes'&gt;
5627     &lt;poolOptions&gt;
5628       &lt;defaultFormat type='unknown'/&gt;
5629       &lt;enum name='sourceFormatType'&gt;
5630         &lt;value&gt;unknown&lt;/value&gt;
5631         &lt;value&gt;dos&lt;/value&gt;
5632         &lt;value&gt;dvh&lt;/value&gt;
5633       &lt;/enum&gt;
5634     &lt;/poolOptions&gt;
5635     &lt;volOptions&gt;
5636       &lt;defaultFormat type='none'/&gt;
5637       &lt;enum name='targetFormatType'&gt;
5638         &lt;value&gt;none&lt;/value&gt;
5639         &lt;value&gt;linux&lt;/value&gt;
5640       &lt;/enum&gt;
5641     &lt;/volOptions&gt;
5642   &lt;/pool&gt;
5643   &lt;pool type='iscsi' supported='yes'&gt;
5644   &lt;/pool&gt;
5645   &lt;pool type='rbd' supported='yes'&gt;
5646     &lt;volOptions&gt;
5647       &lt;defaultFormat type='raw'/&gt;
5648       &lt;enum name='targetFormatType'&gt;
5649       &lt;/enum&gt;
5650     &lt;/volOptions&gt;
5651   &lt;/pool&gt;
5652   &lt;pool type='sheepdog' supported='no'&gt;
5653   &lt;/pool&gt;
5654 &lt;/storagepoolCapabilities&gt;
5655         """
5656         self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)
5657         actual = virt.pool_capabilities()
5658         self.assertEqual(
5659             {
5660                 "computed": False,
5661                 "pool_types": [
5662                     {
5663                         "name": "disk",
5664                         "supported": True,
5665                         "options": {
5666                             "pool": {
5667                                 "default_format": "unknown",
5668                                 "sourceFormatType": ["unknown", "dos", "dvh"],
5669                             },
5670                             "volume": {
5671                                 "default_format": "none",
5672                                 "targetFormatType": ["none", "linux"],
5673                             },
5674                         },
5675                     },
5676                     {"name": "iscsi", "supported": True},
5677                     {
5678                         "name": "rbd",
5679                         "supported": True,
5680                         "options": {
5681                             "volume": {"default_format": "raw", "targetFormatType": []}
5682                         },
5683                     },
5684                     {"name": "sheepdog", "supported": False},
5685                 ],
5686             },
5687             actual,
5688         )
5689     @patch("salt.modules.virt.get_hypervisor", return_value="kvm")
5690     def test_pool_capabilities_computed(self, mock_get_hypervisor):
5691         self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
5692         del self.mock_conn.getStoragePoolCapabilities
5693         actual = virt.pool_capabilities()
5694         self.assertTrue(actual["computed"])
5695         backends = actual["pool_types"]
5696         self.assertFalse(
5697             [backend for backend in backends if backend["name"] == "iscsi-direct"][0][
5698                 "supported"
5699             ]
5700         )
5701         self.assertTrue(
5702             [backend for backend in backends if backend["name"] == "gluster"][0][
5703                 "supported"
5704             ]
5705         )
5706         self.assertFalse(
5707             [backend for backend in backends if backend["name"] == "zfs"][0][
5708                 "supported"
5709             ]
5710         )
5711         mock_get_hypervisor.return_value = "xen"
5712         backends = virt.pool_capabilities()["pool_types"]
5713         self.assertFalse(
5714             [backend for backend in backends if backend["name"] == "gluster"][0][
5715                 "supported"
5716             ]
5717         )
5718         mock_get_hypervisor.return_value = "bhyve"
5719         backends = virt.pool_capabilities()["pool_types"]
5720         self.assertFalse(
5721             [backend for backend in backends if backend["name"] == "gluster"][0][
5722                 "supported"
5723             ]
5724         )
5725         self.assertTrue(
5726             [backend for backend in backends if backend["name"] == "zfs"][0][
5727                 "supported"
5728             ]
5729         )
5730         self.assertNotIn(
5731             "options",
5732             [backend for backend in backends if backend["name"] == "iscsi"][0],
5733         )
5734         self.assertNotIn(
5735             "pool",
5736             [backend for backend in backends if backend["name"] == "dir"][0]["options"],
5737         )
5738         self.assertNotIn(
5739             "volume",
5740             [backend for backend in backends if backend["name"] == "logical"][0][
5741                 "options"
5742             ],
5743         )
5744         self.assertEqual(
5745             {
5746                 "pool": {
5747                     "default_format": "auto",
5748                     "sourceFormatType": ["auto", "nfs", "glusterfs", "cifs"],
5749                 },
5750                 "volume": {
5751                     "default_format": "raw",
5752                     "targetFormatType": [
5753                         "none",
5754                         "raw",
5755                         "dir",
5756                         "bochs",
5757                         "cloop",
5758                         "dmg",
5759                         "iso",
5760                         "vpc",
5761                         "vdi",
5762                         "fat",
5763                         "vhd",
5764                         "ploop",
5765                         "cow",
5766                         "qcow",
5767                         "qcow2",
5768                         "qed",
5769                         "vmdk",
5770                     ],
5771                 },
5772             },
5773             [backend for backend in backends if backend["name"] == "netfs"][0][
5774                 "options"
5775             ],
5776         )
5777     def test_get_domain(self):
5778         self.mock_conn.listDomainsID.return_value = []
5779         self.mock_conn.listDefinedDomains.return_value = []
5780         self.assertEqual([], virt._get_domain(self.mock_conn))
5781         self.assertRaisesRegex(
5782             CommandExecutionError,
5783             "No virtual machines found.",
5784             virt._get_domain,
5785             self.mock_conn,
5786             "vm2",
5787         )
5788         self.mock_conn.listDomainsID.return_value = [1]
5789         def create_mock_vm(idx):
5790             mock_vm = MagicMock()
5791             mock_vm.name.return_value = "vm{}".format(idx)
5792         mock_vms = [create_mock_vm(idx) for idx in range(3)]
5793         self.mock_conn.lookupByID.return_value <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= mock_vms[0]
5794         self.mock_conn.listDefinedDomains.return_value = ["vm1", "vm2"]
5795         self.mock_conn.lookupByName.side_effect = mock_vms
5796         self.</b></font>assertEqual(mock_vms, virt._get_domain(self.mock_conn))
5797         self.mock_conn.lookupByName.side_effect = None
5798         self.mock_conn.lookupByName.return_value = mock_vms[0]
5799         self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))
5800         self.mock_conn.lookupByName.return_value = None
5801         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5802         self.assertEqual(
5803             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
5804         )
5805         self.mock_conn.reset_mock()
5806         self.mock_conn.lookupByName.return_value = None
5807         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5808         self.assertEqual(
5809             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, "vm1", "vm2")
5810         )
5811         self.assertRaisesRegex(
5812             CommandExecutionError,
5813             'The VM "vm2" is not present',
5814             virt._get_domain,
5815             self.mock_conn,
5816             "vm2",
5817             inactive=False,
5818         )
5819     def test_volume_define(self):
5820         pool_mock = MagicMock()
5821         pool_mock.XMLDesc.return_value = "&lt;pool type='dir'&gt;&lt;/pool&gt;"
5822         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5823         self.assertTrue(
5824             virt.volume_define(
5825                 "testpool",
5826                 "myvm_system.qcow2",
5827                 8192,
5828                 allocation=4096,
5829                 format="qcow2",
5830                 type="file",
5831             )
5832         )
5833         expected_xml = (
5834             "&lt;volume type='file'&gt;\n"
5835             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5836             "  &lt;source&gt;\n"
5837             "  &lt;/source&gt;\n"
5838             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5839             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5840             "  &lt;target&gt;\n"
5841             "    &lt;format type='qcow2'/&gt;\n"
5842             "  &lt;/target&gt;\n"
5843             "&lt;/volume&gt;"
5844         )
5845         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5846         pool_mock.reset_mock()
5847         self.assertTrue(
5848             virt.volume_define(
5849                 "testpool",
5850                 "myvm_system.qcow2",
5851                 8192,
5852                 allocation=4096,
5853                 format="qcow2",
5854                 type="file",
5855                 backing_store={"path": "/path/to/base.raw", "format": "raw"},
5856             )
5857         )
5858         expected_xml = (
5859             "&lt;volume type='file'&gt;\n"
5860             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5861             "  &lt;source&gt;\n"
5862             "  &lt;/source&gt;\n"
5863             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5864             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5865             "  &lt;target&gt;\n"
5866             "    &lt;format type='qcow2'/&gt;\n"
5867             "  &lt;/target&gt;\n"
5868             "  &lt;backingStore&gt;\n"
5869             "    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n"
5870             "    &lt;format type='raw'/&gt;\n"
5871             "  &lt;/backingStore&gt;\n"
5872             "&lt;/volume&gt;"
5873         )
5874         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5875         pool_mock.reset_mock()
5876         pool_mock.XMLDesc.return_value = "&lt;pool type='logical'&gt;&lt;/pool&gt;"
5877         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5878         self.assertTrue(
5879             virt.volume_define(
5880                 "testVG",
5881                 "myvm_system",
5882                 8192,
5883                 backing_store={"path": "/dev/testVG/base"},
5884             )
5885         )
5886         expected_xml = (
5887             "&lt;volume&gt;\n"
5888             "  &lt;name&gt;myvm_system&lt;/name&gt;\n"
5889             "  &lt;source&gt;\n"
5890             "  &lt;/source&gt;\n"
5891             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5892             "  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n"
5893             "  &lt;target&gt;\n"
5894             "  &lt;/target&gt;\n"
5895             "  &lt;backingStore&gt;\n"
5896             "    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n"
5897             "  &lt;/backingStore&gt;\n"
5898             "&lt;/volume&gt;"
5899         )
5900         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5901     def test_volume_upload(self):
5902         pool_mock = MagicMock()
5903         vol_mock = MagicMock()
5904         pool_mock.storageVolLookupByName.return_value = vol_mock
5905         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5906         stream_mock = MagicMock()
5907         self.mock_conn.newStream.return_value = stream_mock
5908         open_mock = MagicMock()
5909         close_mock = MagicMock()
5910         with patch.dict(
5911             os.__dict__, {"open": open_mock, "close": close_mock}
5912         ):  # pylint: disable=no-member
5913             self.assertTrue(virt.volume_upload("pool0", "vol1.qcow2", "/path/to/file"))
5914             stream_mock.sendAll.assert_called_once()
5915             stream_mock.finish.assert_called_once()
5916             self.mock_conn.close.assert_called_once()
5917             vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
5918             stream_mock.sendAll.reset_mock()
5919             vol_mock.upload.reset_mock()
5920             self.assertTrue(
5921                 virt.volume_upload(
5922                     "pool0",
5923                     "vol1.qcow2",
5924                     "/path/to/file",
5925                     offset=123,
5926                     length=456,
5927                     sparse=True,
5928                 )
5929             )
5930             stream_mock.sendAll.assert_not_called()
5931             stream_mock.sparseSendAll.assert_called_once()
5932             vol_mock.upload.assert_called_once_with(
5933                 stream_mock,
5934                 123,
5935                 456,
5936                 self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
5937             )
5938             vol_mock.upload.side_effect = self.mock_libvirt.libvirtError("Unsupported")
5939             self.assertRaisesRegex(
5940                 CommandExecutionError,
5941                 "Unsupported",
5942                 virt.volume_upload,
5943                 "pool0",
5944                 "vol1.qcow2",
5945                 "/path/to/file",
5946             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
