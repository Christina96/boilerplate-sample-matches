<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for __init___43.py &amp; test_virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for __init___43.py &amp; test_virt_1.py
      </h3>
<h1 align="center">
        2.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>__init___43.py (7.6578817%)<th>test_virt_1.py (1.8335516%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(117-137)<td><a href="#" name="0">(558-563)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(896-900)<td><a href="#" name="1">(5595-5599)</a><td align="center"><font color="#b90000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(763-766)<td><a href="#" name="2">(1745-1759)</a><td align="center"><font color="#ad0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(7-22)<td><a href="#" name="3">(8-25)</a><td align="center"><font color="#ad0000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(788-801)<td><a href="#" name="4">(5998-6005)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(214-216)<td><a href="#" name="5">(280-299)</a><td align="center"><font color="#960000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(718-725)<td><a href="#" name="6">(110-116)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(618-622)<td><a href="#" name="7">(1813-1837)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(546-553)<td><a href="#" name="8">(1404-1416)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(330-335)<td><a href="#" name="9">(1363-1376)</a><td align="center"><font color="#8b0000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(308-310)<td><a href="#" name="10">(6840-6844)</a><td align="center"><font color="#8b0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___43.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import hashlib
2 import logging
3 import os
4 import shutil
5 import sys
6 import tarfile
7 import salt.cache
8 import salt.client
9 import salt.config
10 import salt.loader
11 import salt.syspaths as syspaths
12 import salt.utils.files
13 import salt.utils.http as http
14 import salt.utils.path
15 import</b></font> salt.utils.platform
16 import salt.utils.win_functions
17 import salt.utils.yaml
18 from salt.template import compile_template
19 try:
20     import pwd
21     import grp
22 except ImportError:
23     pass
24 log = logging.getLogger(__name__)
25 FILE_TYPES = ("c", "d", "g", "l", "r", "s", "m")
26 class SPMException(Exception):
27 class SPMInvocationError(SPMException):
28 class SPMPackageError(SPMException):
29 class SPMDatabaseError(SPMException):
30 class SPMOperationCanceled(SPMException):
31 class SPMClient:
32     def __init__(self, ui, opts=None):  # pylint: disable=W0231
33         self.ui = ui
34         if not opts:
35             opts = salt.config.spm_config(os.path.join(syspaths.CONFIG_DIR, "spm"))
36         self.opts = opts
37         self.db_prov = self.opts.get("spm_db_provider", "sqlite3")
38         self.files_prov = self.opts.get("spm_files_provider", "local")
39         self._prep_pkgdb()
40         self._prep_pkgfiles()
41         self.db_conn = None
42         self.files_conn = None
43         self._init()
44     def _prep_pkgdb(self):
45         self.pkgdb = salt.loader.pkgdb(self.opts)
46     def _prep_pkgfiles(self):
47         self.pkgfiles = salt.loader.pkgfiles(self.opts)
48     def _init(self):
49         if not self.db_conn:
50             self.db_conn = self._pkgdb_fun("init")
51         if not self.files_conn:
52             self.files_conn = self._pkgfiles_fun("init")
53     def _close(self):
54         if self.db_conn:
55             self.db_conn.close()
56     def run(self, args):
57 <a name="0"></a>        command = args[0]
58         try:
59             if command == "install":
60                 self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._install(args)
61             elif command == "local":
62                 self._local(args)
63             elif command == "repo":
64                 self._repo(args)
65             elif command == "remove":
66                 self._remove(args)
67             elif command == "build":
68                 self._build(args)
69             elif command == "update_repo":
70                 self._download_repo_metadata(args)
71             elif command == "create_repo":
72                 self._create_repo(args)
73             elif command == "files":
74                 self._list_files(args)
75             elif command == "info":
76                 self._info(args)
77             elif command == "list":
78                 self._list(args)
79             elif command == "close":
80                 self._close(</b></font>)
81             else:
82                 raise SPMInvocationError("Invalid command '{}'".format(command))
83         except SPMException as exc:
84             self.ui.error(str(exc))
85     def _pkgdb_fun(self, func, *args, **kwargs):
86         try:
87             return getattr(getattr(self.pkgdb, self.db_prov), func)(*args, **kwargs)
88         except AttributeError:
89             return self.pkgdb["{}.{}".format(self.db_prov, func)](*args, **kwargs)
90     def _pkgfiles_fun(self, func, *args, **kwargs):
91         try:
92             return getattr(getattr(self.pkgfiles, self.files_prov), func)(
93                 *args, **kwargs
94             )
95         except AttributeError:
96             return self.pkgfiles["{}.{}".format(self.files_prov, func)](*args, **kwargs)
97     def _list(self, args):
98         args.pop(0)
99         command = args[0]
100         if command == "packages":
101             self._list_packages(args)
102         elif command == "files":
103             self._list_files(args)
104         elif command == "repos":
105             self._repo_list(args)
106         else:
107             raise SPMInvocationError("Invalid list command '{}'".format(command))
108     def _local(self, args):
109         args.pop(0)
110         command = args[0]
111         if command == "install":
112             self._local_install(args)
113         elif command == "files":
114             self._local_list_files(args)
115         elif command == "info":
116             self._local_info(args)
117         else:
118             raise SPMInvocationError("Invalid local command '{}'".format(command))
119     def _repo(self, args):
120         args.pop(0)
121         command = args[0]
122         if command == "list":
123             self._repo_list(args)
124         elif command == "packages":
125             self._repo_packages(args)
126         elif command == "search":
127             self._repo_packages(args, search=True)
128         elif command == "update":
129             self._download_repo_metadata(args)
130         elif command == "create":
131             self._create_repo(args)
132         else:
133             raise SPMInvocationError("Invalid repo command '{}'".format(command))
134     def _repo_packages(self, args, search=False):
135         packages = []
136 <a name="5"></a>        repo_metadata = self._get_repo_metadata()
137         for repo in repo_metadata:
138             for pkg in repo_metadata[repo]["packages"]:
139                 if args<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[1] in pkg:
140                     version = repo_metadata[repo]["packages"][pkg]["info"]["version"]
141                     release = repo_metadata[repo]["packages"][pkg]["info"][</b></font>"release"]
142                     packages.append((pkg, version, release, repo))
143         for pkg in sorted(packages):
144             self.ui.status("{}\t{}-{}\t{}".format(pkg[0], pkg[1], pkg[2], pkg[3]))
145         return packages
146     def _repo_list(self, args):
147         repo_metadata = self._get_repo_metadata()
148         for repo in repo_metadata:
149             self.ui.status(repo)
150     def _install(self, args):
151         if len(args) &lt; 2:
152             raise SPMInvocationError("A package must be specified")
153         caller_opts = self.opts.copy()
154         caller_opts["file_client"] = "local"
155         self.caller = salt.client.Caller(mopts=caller_opts)
156         self.client = salt.client.get_local_client(self.opts["conf_file"])
157         cache = salt.cache.Cache(self.opts)
158         packages = args[1:]
159         file_map = {}
160         optional = []
161         recommended = []
162         to_install = []
163         for pkg in packages:
164             if pkg.endswith(".spm"):
165                 if self._pkgfiles_fun("path_exists", pkg):
166                     comps = pkg.split("-")
167                     comps = os.path.split("-".join(comps[:-2]))
168                     pkg_name = comps[-1]
169                     formula_tar = tarfile.open(pkg, "r:bz2")
170                     formula_ref = formula_tar.extractfile("{}/FORMULA".format(pkg_name))
171                     formula_def = salt.utils.yaml.safe_load(formula_ref)
172                     file_map[pkg_name] = pkg
173                     to_, op_, re_ = self._check_all_deps(
174                         pkg_name=pkg_name, pkg_file=pkg, formula_def=formula_def
175                     )
176                     to_install.extend(to_)
177                     optional.extend(op_)
178                     recommended.extend(re_)
179                     formula_tar.close()
180                 else:
181                     raise SPMInvocationError("Package file {} not found".format(pkg))
182             else:
183                 to_, op_, re_ = self._check_all_deps(pkg_name=pkg)
184                 to_install.extend(to_)
185                 optional.extend(op_)
186                 recommended.extend(re_)
187         optional = set(filter(len, optional))
188         if optional:
189             self.ui.status(
190                 "The following dependencies are optional:\n\t{}\n".format(
191                     "\n\t".join(optional)
192                 )
193             )
194         recommended = set(filter(len, recommended))
195         if recommended:
196             self.ui.status(
197                 "The following dependencies are recommended:\n\t{}\n".format(
198                     "\n\t".join(recommended)
199                 )
200             )
201         to_install = set(filter(len, to_install))
202         msg = "Installing packages:\n\t{}\n".format("\n\t".join(to_install))
203         if not self.opts["assume_yes"]:
204             self.ui.confirm(msg)
205         repo_metadata = self._get_repo_metadata()
206         dl_list = {}
207         for package in to_install:
208             if package in file_map:
209                 self._install_indv_pkg(package, file_map[package])
210             else:
211                 for repo in repo_metadata:
212 <a name="10"></a>                    repo_info = repo_metadata[repo]
213                     if package in repo_info["packages"]:
214                         dl_package = False
215                         repo_ver <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= repo_info["packages"][package]["info"]["version"]
216                         repo_rel = repo_info["packages"][package]["info"]["release"]
217                         repo_url = repo_info[</b></font>"info"]["url"]
218                         if package in dl_list:
219                             if repo_ver == dl_list[package]["version"]:
220                                 if repo_rel &gt; dl_list[package]["release"]:
221                                     dl_package = True
222                                 elif repo_rel == dl_list[package]["release"]:
223                                     if dl_list[package]["source"].startswith("file://"):
224                                         if not repo_url.startswith("file://"):
225                                             dl_package = True
226                             elif repo_ver &gt; dl_list[package]["version"]:
227                                 dl_package = True
228                         else:
229                             dl_package = True
230 <a name="9"></a>
231                         if dl_package is True:
232                             cache_path = os<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.join(self.opts["spm_cache_dir"], repo)
233                             dl_url = "{}/{}".format(
234                                 repo_info["info"]["url"],
235                                 repo_info["packages"][</b></font>package]["filename"],
236                             )
237                             out_file = os.path.join(
238                                 cache_path, repo_info["packages"][package]["filename"]
239                             )
240                             dl_list[package] = {
241                                 "version": repo_ver,
242                                 "release": repo_rel,
243                                 "source": dl_url,
244                                 "dest_dir": cache_path,
245                                 "dest_file": out_file,
246                             }
247         for package in dl_list:
248             dl_url = dl_list[package]["source"]
249             cache_path = dl_list[package]["dest_dir"]
250             out_file = dl_list[package]["dest_file"]
251             if not os.path.exists(cache_path):
252                 os.makedirs(cache_path)
253             if dl_url.startswith("file://"):
254                 dl_url = dl_url.replace("file://", "")
255                 shutil.copyfile(dl_url, out_file)
256             else:
257                 with salt.utils.files.fopen(out_file, "wb") as outf:
258                     outf.write(
259                         self._query_http(dl_url, repo_info["info"], decode_body=False)
260                     )
261         for package in dl_list:
262             out_file = dl_list[package]["dest_file"]
263             self._install_indv_pkg(package, out_file)
264         return
265     def _local_install(self, args, pkg_name=None):
266         if len(args) &lt; 2:
267             raise SPMInvocationError("A package file must be specified")
268         self._install(args)
269     def _check_all_deps(self, pkg_name=None, pkg_file=None, formula_def=None):
270         if pkg_file and not os.path.exists(pkg_file):
271             raise SPMInvocationError("Package file {} not found".format(pkg_file))
272         self.repo_metadata = self._get_repo_metadata()
273         if not formula_def:
274             for repo in self.repo_metadata:
275                 if not isinstance(self.repo_metadata[repo]["packages"], dict):
276                     continue
277                 if pkg_name in self.repo_metadata[repo]["packages"]:
278                     formula_def = self.repo_metadata[repo]["packages"][pkg_name]["info"]
279         if not formula_def:
280             raise SPMInvocationError("Unable to read formula for {}".format(pkg_name))
281         pkg_info = self._pkgdb_fun("info", pkg_name, self.db_conn)
282         pkgs_to_install = []
283         if pkg_info is None or self.opts["force"]:
284             pkgs_to_install.append(pkg_name)
285         elif pkg_info is not None and not self.opts["force"]:
286             raise SPMPackageError(
287                 "Package {} already installed, not installing again".format(
288                     formula_def["name"]
289                 )
290             )
291         optional_install = []
292         recommended_install = []
293         if (
294             "dependencies" in formula_def
295             or "optional" in formula_def
296             or "recommended" in formula_def
297         ):
298             self.avail_pkgs = {}
299             for repo in self.repo_metadata:
300                 if not isinstance(self.repo_metadata[repo]["packages"], dict):
301                     continue
302                 for pkg in self.repo_metadata[repo]["packages"]:
303                     self.avail_pkgs[pkg] = repo
304             needs, unavail, optional, recommended = self._resolve_deps(formula_def)
305             if len(unavail) &gt; 0:
306                 raise SPMPackageError(
307                     "Cannot install {}, the following dependencies are needed:\n\n{}".format(
308                         formula_def["name"], "\n".join(unavail)
309                     )
310                 )
311             if optional:
312                 optional_install.extend(optional)
313                 for dep_pkg in optional:
314                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
315                     msg = dep_pkg
316                     if isinstance(pkg_info, dict):
317                         msg = "{} [Installed]".format(dep_pkg)
318                     optional_install.append(msg)
319             if recommended:
320                 recommended_install.extend(recommended)
321                 for dep_pkg in recommended:
322                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
323                     msg = dep_pkg
324                     if isinstance(pkg_info, dict):
325                         msg = "{} [Installed]".format(dep_pkg)
326                     recommended_install.append(msg)
327             if needs:
328                 pkgs_to_install.extend(needs)
329                 for dep_pkg in needs:
330                     pkg_info = self._pkgdb_fun("info", formula_def["name"])
331                     msg = dep_pkg
332                     if isinstance(pkg_info, dict):
333                         msg = "{} [Installed]".format(dep_pkg)
334         return pkgs_to_install, optional_install, recommended_install
335     def _install_indv_pkg(self, pkg_name, pkg_file):
336         self.ui.status("... installing {}".format(pkg_name))
337         formula_tar = tarfile.open(pkg_file, "r:bz2")
338         formula_ref = formula_tar.extractfile("{}/FORMULA".format(pkg_name))
339         formula_def = salt.utils.yaml.safe_load(formula_ref)
340         for field in ("version", "release", "summary", "description"):
341             if field not in formula_def:
342                 raise SPMPackageError(
343                     "Invalid package: the {} was not found".format(field)
344                 )
345         pkg_files = formula_tar.getmembers()
346         existing_files = self._pkgfiles_fun(
347             "check_existing", pkg_name, pkg_files, formula_def
348         )
349         if existing_files and not self.opts["force"]:
350             raise SPMPackageError(
351                 "Not installing {} due to existing files:\n\n{}".format(
352                     pkg_name, "\n".join(existing_files)
353                 )
354             )
355         self._pkgdb_fun("register_pkg", pkg_name, formula_def, self.db_conn)
356         if "pre_local_state" in formula_def:
357             high_data = self._render(formula_def["pre_local_state"], formula_def)
358             ret = self.caller.cmd("state.high", data=high_data)
359         if "pre_tgt_state" in formula_def:
360             log.debug("Executing pre_tgt_state script")
361             high_data = self._render(formula_def["pre_tgt_state"]["data"], formula_def)
362             tgt = formula_def["pre_tgt_state"]["tgt"]
363             ret = self.client.run_job(
364                 tgt=formula_def["pre_tgt_state"]["tgt"],
365                 fun="state.high",
366                 tgt_type=formula_def["pre_tgt_state"].get("tgt_type", "glob"),
367                 timout=self.opts["timeout"],
368                 data=high_data,
369             )
370         if salt.utils.platform.is_windows():
371             uname = gname = salt.utils.win_functions.get_current_user()
372             uname_sid = salt.utils.win_functions.get_sid_from_name(uname)
373             uid = self.opts.get("spm_uid", uname_sid)
374             gid = self.opts.get("spm_gid", uname_sid)
375         else:
376             uid = self.opts.get("spm_uid", os.getuid())
377             gid = self.opts.get("spm_gid", os.getgid())
378             uname = pwd.getpwuid(uid)[0]
379             gname = grp.getgrgid(gid)[0]
380         for member in pkg_files:
381             member.uid = uid
382             member.gid = gid
383             member.uname = uname
384             member.gname = gname
385             out_path = self._pkgfiles_fun(
386                 "install_file",
387                 pkg_name,
388                 formula_tar,
389                 member,
390                 formula_def,
391                 self.files_conn,
392             )
393             if out_path is not False:
394                 if member.isdir():
395                     digest = ""
396 <a name="8"></a>                else:
397                     self._verbose(
398                         "Installing file {} to {}".format(member.name, out_path),
399                         log<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.trace,
400                     )
401                     file_hash = hashlib.sha1()
402                     digest = self._pkgfiles_fun(
403                         "hash_file",
404                         os.path.join(out_path, member.name),
405                         file_hash,
406                         self.</b></font>files_conn,
407                     )
408                 self._pkgdb_fun(
409                     "register_file", pkg_name, member, out_path, digest, self.db_conn
410                 )
411         if "post_local_state" in formula_def:
412             log.debug("Executing post_local_state script")
413             high_data = self._render(formula_def["post_local_state"], formula_def)
414             self.caller.cmd("state.high", data=high_data)
415         if "post_tgt_state" in formula_def:
416             log.debug("Executing post_tgt_state script")
417             high_data = self._render(formula_def["post_tgt_state"]["data"], formula_def)
418             tgt = formula_def["post_tgt_state"]["tgt"]
419             ret = self.client.run_job(
420                 tgt=formula_def["post_tgt_state"]["tgt"],
421                 fun="state.high",
422                 tgt_type=formula_def["post_tgt_state"].get("tgt_type", "glob"),
423                 timout=self.opts["timeout"],
424                 data=high_data,
425             )
426         formula_tar.close()
427     def _resolve_deps(self, formula_def):
428         pkg_info = self.pkgdb["{}.info".format(self.db_prov)](formula_def["name"])
429         if not isinstance(pkg_info, dict):
430             pkg_info = {}
431         can_has = {}
432         cant_has = []
433         if "dependencies" in formula_def and formula_def["dependencies"] is None:
434             formula_def["dependencies"] = ""
435         for dep in formula_def.get("dependencies", "").split(","):
436             dep = dep.strip()
437             if not dep:
438                 continue
439             if self.pkgdb["{}.info".format(self.db_prov)](dep):
440                 continue
441             if dep in self.avail_pkgs:
442                 can_has[dep] = self.avail_pkgs[dep]
443             else:
444                 cant_has.append(dep)
445         optional = formula_def.get("optional", "").split(",")
446         recommended = formula_def.get("recommended", "").split(",")
447         inspected = []
448         to_inspect = can_has.copy()
449         while len(to_inspect) &gt; 0:
450             dep = next(iter(to_inspect.keys()))
451             del to_inspect[dep]
452             if dep in inspected:
453                 continue
454 <a name="7"></a>            inspected.append(dep)
455             repo_contents = self.repo_metadata.get(can_has[dep], {})
456             repo_packages = repo_contents<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get("packages", {})
457             dep_formula = repo_packages.get(dep, {}).get("info", {})
458             also_can, also_cant, opt_dep, rec_dep = self._resolve_deps(dep_formula)
459             can_has.update(</b></font>also_can)
460             cant_has = sorted(set(cant_has + also_cant))
461             optional = sorted(set(optional + opt_dep))
462             recommended = sorted(set(recommended + rec_dep))
463         return can_has, cant_has, optional, recommended
464     def _traverse_repos(self, callback, repo_name=None):
465         repo_files = []
466         if os.path.exists(self.opts["spm_repos_config"]):
467             repo_files.append(self.opts["spm_repos_config"])
468         for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(
469             "{}.d".format(self.opts["spm_repos_config"])
470         ):
471             for repo_file in filenames:
472                 if not repo_file.endswith(".repo"):
473                     continue
474                 repo_files.append(repo_file)
475         for repo_file in repo_files:
476             repo_path = "{}.d/{}".format(self.opts["spm_repos_config"], repo_file)
477             with salt.utils.files.fopen(repo_path) as rph:
478                 repo_data = salt.utils.yaml.safe_load(rph)
479                 for repo in repo_data:
480                     if repo_data[repo].get("enabled", True) is False:
481                         continue
482                     if repo_name is not None and repo != repo_name:
483                         continue
484                     callback(repo, repo_data[repo])
485     def _query_http(self, dl_path, repo_info, decode_body=True):
486         query = None
487         response = None
488         try:
489             if "username" in repo_info:
490                 try:
491                     if "password" in repo_info:
492                         query = http.query(
493                             dl_path,
494                             text=True,
495                             username=repo_info["username"],
496                             password=repo_info["password"],
497                             decode_body=decode_body,
498                         )
499                     else:
500                         raise SPMException(
501                             "Auth defined, but password is not set for username: '{}'".format(
502                                 repo_info["username"]
503                             )
504                         )
505                 except SPMException as exc:
506                     self.ui.error(str(exc))
507             else:
508                 query = http.query(dl_path, text=True, decode_body=decode_body)
509         except SPMException as exc:
510             self.ui.error(str(exc))
511         try:
512             if query:
513                 if "SPM-METADATA" in dl_path:
514                     response = salt.utils.yaml.safe_load(query.get("text", "{}"))
515                 else:
516                     response = query.get("text")
517             else:
518                 raise SPMException("Response is empty, please check for Errors above.")
519         except SPMException as exc:
520             self.ui.error(str(exc))
521         return response
522     def _download_repo_metadata(self, args):
523         cache = salt.cache.Cache(self.opts, self.opts["spm_cache_dir"])
524         def _update_metadata(repo, repo_info):
525             dl_path = "{}/SPM-METADATA".format(repo_info["url"])
526             if dl_path.startswith("file://"):
527                 dl_path = dl_path.replace("file://", "")
528                 with salt.utils.files.fopen(dl_path, "r") as rpm:
529                     metadata = salt.utils.yaml.safe_load(rpm)
530             else:
531                 metadata = self._query_http(dl_path, repo_info)
532 <a name="6"></a>
533             cache.store(".", repo, metadata)
534         repo_name = args<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[1] if len(args) &gt; 1 else None
535         self._traverse_repos(_update_metadata, repo_name)
536     def _get_repo_metadata(self):
537         cache = salt.cache.Cache(self.opts, self.</b></font>opts["spm_cache_dir"])
538         metadata = {}
539         def _read_metadata(repo, repo_info):
540             if cache.updated(".", repo) is None:
541                 log.warning("Updating repo metadata")
542                 self._download_repo_metadata({})
543             metadata[repo] = {
544                 "info": repo_info,
545                 "packages": cache.fetch(".", repo),
546             }
547         self._traverse_repos(_read_metadata)
548         return metadata
549     def _create_repo(self, args):
550         if len(args) &lt; 2:
551             raise SPMInvocationError("A path to a directory must be specified")
552         if args[1] == ".":
553             repo_path = os.getcwdu()
554         else:
555             repo_path = args[1]
556         old_files = []
557         repo_metadata = {}
558         for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(repo_path):
559             for spm_file in filenames:
560                 if not spm_file.endswith(".spm"):
561                     continue
562 <a name="2"></a>                spm_path = "{}/{}".format(repo_path, spm_file)
563                 if not tarfile.is_tarfile(spm_path):
564                     continue
565                 comps <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= spm_file.split("-")
566                 spm_name = "-".join(comps[:-2])
567                 spm_fh = tarfile.open(spm_path, "r:bz2")
568                 formula_handle = spm_fh.extractfile("{}/FORMULA".format(</b></font>spm_name))
569                 formula_conf = salt.utils.yaml.safe_load(formula_handle.read())
570                 use_formula = True
571                 if spm_name in repo_metadata:
572                     cur_info = repo_metadata[spm_name]["info"]
573                     new_info = formula_conf
574                     if int(new_info["version"]) == int(cur_info["version"]):
575                         if int(new_info["release"]) &lt; int(cur_info["release"]):
576                             use_formula = False
577                     elif int(new_info["version"]) &lt; int(cur_info["version"]):
578                         use_formula = False
579                     if use_formula is True:
580 <a name="4"></a>                        log.debug(
581                             "%s %s-%s had been added, but %s-%s will replace it",
582                             spm_name,
583                             cur_info<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["version"],
584                             cur_info["release"],
585                             new_info["version"],
586                             new_info["release"],
587                         )
588                         old_files.append(repo_metadata[spm_name]["filename"])
589                     else:
590                         log.debug(
591                             "%s %s-%s has been found, but is older than %s-%s",
592                             spm_name,
593                             new_info["version"],
594                             new_info["release"],
595                             cur_info[</b></font>"version"],
596                             cur_info["release"],
597                         )
598                         old_files.append(spm_file)
599                 if use_formula is True:
600                     log.debug(
601                         "adding %s-%s-%s to the repo",
602                         formula_conf["name"],
603                         formula_conf["version"],
604                         formula_conf["release"],
605                     )
606                     repo_metadata[spm_name] = {
607                         "info": formula_conf.copy(),
608                     }
609                     repo_metadata[spm_name]["filename"] = spm_file
610         metadata_filename = "{}/SPM-METADATA".format(repo_path)
611         with salt.utils.files.fopen(metadata_filename, "w") as mfh:
612             salt.utils.yaml.safe_dump(
613                 repo_metadata,
614                 mfh,
615                 indent=4,
616                 canonical=False,
617                 default_flow_style=False,
618             )
619         log.debug("Wrote %s", metadata_filename)
620         for file_ in old_files:
621             if self.opts["spm_repo_dups"] == "ignore":
622                 log.debug("%s will be left in the directory", file_)
623             elif self.opts["spm_repo_dups"] == "archive":
624                 if not os.path.exists("./archive"):
625                     try:
626                         os.makedirs("./archive")
627                         log.debug("%s has been archived", file_)
628                     except OSError:
629                         log.error("Unable to create archive directory")
630                 try:
631                     shutil.move(file_, "./archive")
632                 except OSError:
633                     log.error("Unable to archive %s", file_)
634             elif self.opts["spm_repo_dups"] == "delete":
635                 try:
636                     os.remove(file_)
637                     log.debug("%s has been deleted", file_)
638                 except OSError:
639                     log.error("Unable to delete %s", file_)
640                 except OSError:  # pylint: disable=duplicate-except
641                     pass
642     def _remove(self, args):
643         if len(args) &lt; 2:
644             raise SPMInvocationError("A package must be specified")
645         packages = args[1:]
646         msg = "Removing packages:\n\t{}".format("\n\t".join(packages))
647         if not self.opts["assume_yes"]:
648             self.ui.confirm(msg)
649         for package in packages:
650             self.ui.status("... removing {}".format(package))
651             if not self._pkgdb_fun("db_exists", self.opts["spm_db"]):
652                 raise SPMDatabaseError(
653                     "No database at {}, cannot remove {}".format(
654                         self.opts["spm_db"], package
655                     )
656                 )
657             pkg_info = self._pkgdb_fun("info", package, self.db_conn)
658             if pkg_info is None:
659                 raise SPMInvocationError("Package {} not installed".format(package))
660             files = self._pkgdb_fun("list_files", package, self.db_conn)
661             dirs = []
662             for filerow in files:
663                 if self._pkgfiles_fun("path_isdir", filerow[0]):
664                     dirs.append(filerow[0])
665                     continue
666                 file_hash = hashlib.sha1()
667 <a name="1"></a>                digest = self._pkgfiles_fun(
668                     "hash_file", filerow[0], file_hash, self.files_conn
669                 )
670                 if filerow<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[1] == digest:
671                     self._verbose("Removing file {}".format(filerow[0]), log.trace)
672                     self._pkgfiles_fun("remove_file", filerow[0], self.files_conn)
673                 else:
674                     self._verbose("Not removing file {}".format(filerow[</b></font>0]), log.trace)
675                 self._pkgdb_fun("unregister_file", filerow[0], package, self.db_conn)
676             for dir_ in sorted(dirs, reverse=True):
677                 self._pkgdb_fun("unregister_file", dir_, package, self.db_conn)
678                 try:
679                     self._verbose("Removing directory {}".format(dir_), log.trace)
680                     os.rmdir(dir_)
681                 except OSError:
682                     self._verbose(
683                         "Cannot remove directory {}, probably not empty".format(dir_),
684                         log.trace,
685                     )
686             self._pkgdb_fun("unregister_pkg", package, self.db_conn)
687     def _verbose(self, msg, level=log.debug):
688         if self.opts.get("verbose", False) is True:
689             self.ui.status(msg)
690         level(msg)
691     def _local_info(self, args):
692         if len(args) &lt; 2:
693             raise SPMInvocationError("A package filename must be specified")
694         pkg_file = args[1]
695         if not os.path.exists(pkg_file):
696             raise SPMInvocationError("Package file {} not found".format(pkg_file))
697         comps = pkg_file.split("-")
698         comps = "-".join(comps[:-2]).split("/")
699         name = comps[-1]
700         formula_tar = tarfile.open(pkg_file, "r:bz2")
701         formula_ref = formula_tar.extractfile("{}/FORMULA".format(name))
702         formula_def = salt.utils.yaml.safe_load(formula_ref)
703         self.ui.status(self._get_info(formula_def))
704         formula_tar.close()
705     def _info(self, args):
706         if len(args) &lt; 2:
707             raise SPMInvocationError("A package must be specified")
708         package = args[1]
709         pkg_info = self._pkgdb_fun("info", package, self.db_conn)
710         if pkg_info is None:
711             raise SPMPackageError("package {} not installed".format(package))
712         self.ui.status(self._get_info(pkg_info))
713     def _get_info(self, formula_def):
714         fields = (
715             "name",
716             "os",
717             "os_family",
718             "release",
719             "version",
720             "dependencies",
721             "os_dependencies",
722             "os_family_dependencies",
723             "summary",
724             "description",
725         )
726         for item in fields:
727             if item not in formula_def:
728                 formula_def[item] = "None"
729         if "installed" not in formula_def:
730             formula_def["installed"] = "Not installed"
731         return (
732             "Name: {name}\n"
733             "Version: {version}\n"
734             "Release: {release}\n"
735             "Install Date: {installed}\n"
736             "Supported OSes: {os}\n"
737             "Supported OS families: {os_family}\n"
738             "Dependencies: {dependencies}\n"
739             "OS Dependencies: {os_dependencies}\n"
740             "OS Family Dependencies: {os_family_dependencies}\n"
741             "Summary: {summary}\n"
742             "Description:\n"
743             "{description}".format(**formula_def)
744         )
745     def _local_list_files(self, args):
746         if len(args) &lt; 2:
747             raise SPMInvocationError("A package filename must be specified")
748         pkg_file = args[1]
749         if not os.path.exists(pkg_file):
750             raise SPMPackageError("Package file {} not found".format(pkg_file))
751         formula_tar = tarfile.open(pkg_file, "r:bz2")
752         pkg_files = formula_tar.getmembers()
753         for member in pkg_files:
754             self.ui.status(member.name)
755     def _list_packages(self, args):
756         packages = self._pkgdb_fun("list_packages", self.db_conn)
757         for package in packages:
758             if self.opts["verbose"]:
759                 status_msg = ",".join(package)
760             else:
761                 status_msg = package[0]
762             self.ui.status(status_msg)
763     def _list_files(self, args):
764         if len(args) &lt; 2:
765             raise SPMInvocationError("A package name must be specified")
766         package = args[-1]
767         files = self._pkgdb_fun("list_files", package, self.db_conn)
768         if files is None:
769             raise SPMPackageError("package {} not installed".format(package))
770         else:
771             for file_ in files:
772                 if self.opts["verbose"]:
773                     status_msg = ",".join(file_)
774                 else:
775                     status_msg = file_[0]
776                 self.ui.status(status_msg)
777     def _build(self, args):
778         if len(args) &lt; 2:
779             raise SPMInvocationError("A path to a formula must be specified")
780         self.abspath = args[1].rstrip("/")
781         comps = self.abspath.split("/")
782         self.relpath = comps[-1]
783         formula_path = "{}/FORMULA".format(self.abspath)
784         if not os.path.exists(formula_path):
785             raise SPMPackageError("Formula file {} not found".format(formula_path))
786         with salt.utils.files.fopen(formula_path) as fp_:
787             formula_conf = salt.utils.yaml.safe_load(fp_)
788         for field in ("name", "version", "release", "summary", "description"):
789             if field not in formula_conf:
790                 raise SPMPackageError(
791                     "Invalid package: a {} must be defined".format(field)
792                 )
793         out_path = "{}/{}-{}-{}.spm".format(
794             self.opts["spm_build_dir"],
795             formula_conf["name"],
796             formula_conf["version"],
797             formula_conf["release"],
798         )
799         if not os.path.exists(self.opts["spm_build_dir"]):
800             os.mkdir(self.opts["spm_build_dir"])
801         self.formula_conf = formula_conf
802         formula_tar = tarfile.open(out_path, "w:bz2")
803         if "files" in formula_conf:
804             if isinstance(formula_conf["files"], list):
805                 formula_dir = tarfile.TarInfo(formula_conf["name"])
806                 formula_dir.type = tarfile.DIRTYPE
807                 formula_tar.addfile(formula_dir)
808                 for file_ in formula_conf["files"]:
809                     for ftype in FILE_TYPES:
810                         if file_.startswith("{}|".format(ftype)):
811                             file_ = file_.lstrip("{}|".format(ftype))
812                     formula_tar.add(
813                         os.path.join(os.getcwd(), file_),
814                         os.path.join(formula_conf["name"], file_),
815                     )
816         else:
817             try:
818                 formula_tar.add(
819                     formula_path, formula_conf["name"], filter=self._exclude
820                 )
821                 formula_tar.add(
822                     self.abspath, formula_conf["name"], filter=self._exclude
823                 )
824             except TypeError:
825                 formula_tar.add(
826                     formula_path, formula_conf["name"], exclude=self._exclude
827                 )
828                 formula_tar.add(
829                     self.abspath, formula_conf["name"], exclude=self._exclude
830                 )
831         formula_tar.close()
832         self.ui.status("Built package {}".format(out_path))
833     def _exclude(self, member):
834         if isinstance(member, str):
835             return None
836         for item in self.opts["spm_build_exclude"]:
837             if member.name.startswith("{}/{}".format(self.formula_conf["name"], item)):
838                 return None
839             elif member.name.startswith("{}/{}".format(self.abspath, item)):
840                 return None
841         return member
842     def _render(self, data, formula_def):
843         renderer = formula_def.get("renderer", self.opts.get("renderer", "jinja|yaml"))
844         rend = salt.loader.render(self.opts, {})
845         blacklist = self.opts.get("renderer_blacklist")
846         whitelist = self.opts.get("renderer_whitelist")
847         template_vars = formula_def.copy()
848         template_vars["opts"] = self.opts.copy()
849         return compile_template(
850             ":string:",
851             rend,
852             renderer,
853             blacklist,
854             whitelist,
855             input_data=data,
856             **template_vars
857         )
858 class SPMUserInterface:
859     def status(self, msg):
860         raise NotImplementedError()
861     def error(self, msg):
862         raise NotImplementedError()
863     def confirm(self, action):
864         raise NotImplementedError()
865 class SPMCmdlineInterface(SPMUserInterface):
866     def status(self, msg):
867         print(msg)
868     def error(self, msg):
869         print(msg, file=sys.stderr)
870     def confirm(self, action):
871         print(action)
872         res = input("Proceed? [N/y] ")
873         if not res.lower().startswith("y"):
874             raise SPMOperationCanceled("canceled")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import datetime
2 import os
3 import shutil
4 import tempfile
5 import xml.etree.ElementTree as ET
6 import salt.config
7 import salt.modules.config as config
8 import salt.modules.virt as virt
9 import salt.syspaths
10 import salt.utils.yaml
11 from salt.exceptions import CommandExecutionError, SaltInvocationError
12 from tests.support.helpers import dedent
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from</b></font> tests.support.unit import TestCase
16 class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
17     class virDomain(MagicMock):
18     class libvirtError(Exception):
19         def __init__(self, msg):
20             super().__init__(msg)
21             self.msg = msg
22         def get_error_message(self):
23             return self.msg
24 class VirtTestCase(TestCase, LoaderModuleMockMixin):
25     def setup_loader_modules(self):
26         self.mock_libvirt = LibvirtMock()
27         self.mock_conn = MagicMock()
28         self.mock_conn.getStoragePoolCapabilities.return_value = (
29             "&lt;storagepoolCapabilities/&gt;"
30         )
31         self.mock_libvirt.openAuth.return_value = self.mock_conn
32         self.mock_popen = MagicMock()
33         self.addCleanup(delattr, self, "mock_libvirt")
34         self.addCleanup(delattr, self, "mock_conn")
35         self.addCleanup(delattr, self, "mock_popen")
36         self.mock_subprocess = MagicMock()
37         self.mock_subprocess.return_value = (
38             self.mock_subprocess
39         )  # pylint: disable=no-member
40         self.mock_subprocess.Popen.return_value = (
41             self.mock_popen
42         )  # pylint: disable=no-member
43         loader_globals = {
44             "__salt__": {"config.get": config.get, "config.option": config.option},
45             "libvirt": self.mock_libvirt,
46             "subprocess": self.mock_subprocess,
47         }
48         return {virt: loader_globals, config: loader_globals}
49     def set_mock_vm(self, name, xml):
50         self.mock_conn.listDefinedDomains.return_value = [
51             name
52         ]  # pylint: disable=no-member
53         mock_domain = self.mock_libvirt.virDomain()
54         self.mock_conn.lookupByName.return_value = (
55             mock_domain  # pylint: disable=no-member
56         )
57         mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member
58         mock_domain.info.return_value = [
59             4,
60             2048 * 1024,
61             1024 * 1024,
62             2,
63             1234,
64         ]  # pylint: disable=no-member
65         mock_domain.ID.return_value = 1
66         mock_domain.name.return_value = name
67         return mock_domain
68 <a name="6"></a>
69     def assert_equal_unit(self, actual, expected, unit="KiB"):
70         self.assertEqual(actual.get("unit"), unit)
71         self<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(actual.text, str(expected))
72     def test_disk_profile_merge(self):
73         root_dir = os.path.join(salt.syspaths.</b></font>ROOT_DIR, "srv", "salt-images")
74         userdisks = [
75             {"name": "system", "image": "/path/to/image"},
76             {"name": "data", "size": 16384, "format": "raw"},
77         ]
78         disks = virt._disk_profile(self.mock_conn, "default", "kvm", userdisks, "myvm")
79         self.assertEqual(
80             [
81                 {
82                     "name": "system",
83                     "device": "disk",
84                     "size": 8192,
85                     "format": "qcow2",
86                     "model": "virtio",
87                     "filename": "myvm_system.qcow2",
88                     "image": "/path/to/image",
89                     "source_file": "{}{}myvm_system.qcow2".format(root_dir, os.sep),
90                 },
91                 {
92                     "name": "data",
93                     "device": "disk",
94                     "size": 16384,
95                     "format": "raw",
96                     "model": "virtio",
97                     "filename": "myvm_data.raw",
98                     "source_file": "{}{}myvm_data.raw".format(root_dir, os.sep),
99                 },
100             ],
101             disks,
102         )
103     def test_boot_default_dev(self):
104         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
105         nicp = virt._nic_profile("default", "kvm")
106         xml_data = virt._gen_xml(
107             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
108         )
109         root = ET.fromstring(xml_data)
110         self.assertEqual(root.find("os/boot").attrib["dev"], "hd")
111         self.assertEqual(root.find("os/type").attrib["arch"], "x86_64")
112         self.assertEqual(root.find("os/type").text, "hvm")
113     def test_boot_custom_dev(self):
114         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
115         nicp = virt._nic_profile("default", "kvm")
116         xml_data = virt._gen_xml(
117             self.mock_conn,
118             "hello",
119             1,
120             512,
121             diskp,
122             nicp,
123             "kvm",
124             "hvm",
125             "x86_64",
126             boot_dev="cdrom",
127         )
128         root = ET.fromstring(xml_data)
129         self.assertEqual(root.find("os/boot").attrib["dev"], "cdrom")
130     def test_boot_multiple_devs(self):
131         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
132         nicp = virt._nic_profile("default", "kvm")
133         xml_data = virt._gen_xml(
134             self.mock_conn,
135             "hello",
136             1,
137             512,
138             diskp,
139             nicp,
140             "kvm",
141             "hvm",
142             "x86_64",
143             boot_dev="cdrom network",
144         )
145         root = ET.fromstring(xml_data)
146         devs = root.findall(".//boot")
147         self.assertTrue(len(devs) == 2)
148     def test_gen_xml_no_nic(self):
149         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
150         nicp = virt._nic_profile("default", "kvm")
151         xml_data = virt._gen_xml(
152             self.mock_conn,
153             "hello",
154             1,
155             512,
156             diskp,
157             nicp,
158             "kvm",
159             "hvm",
160             "x86_64",
161             serials=[{"type": "pty"}],
162         )
163         root = ET.fromstring(xml_data)
164         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
165     def test_gen_xml_for_telnet_serial(self):
166         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
167         nicp = virt._nic_profile("default", "kvm")
168         xml_data = virt._gen_xml(
169             self.mock_conn,
170             "hello",
171             1,
172             512,
173             diskp,
174             nicp,
175             "kvm",
176             "hvm",
177             "x86_64",
178             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
179         )
180         root = ET.fromstring(xml_data)
181         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
182         self.assertEqual(root.find("devices/serial/source").attrib["service"], "22223")
183         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
184     def test_gen_xml_for_telnet_serial_unspecified_port(self):
185         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
186         nicp = virt._nic_profile("default", "kvm")
187         xml_data = virt._gen_xml(
188             self.mock_conn,
189             "hello",
190             1,
191             512,
192             diskp,
193             nicp,
194             "kvm",
195             "hvm",
196             "x86_64",
197             serials=[{"type": "tcp"}],
198         )
199         root = ET.fromstring(xml_data)
200         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
201         self.assertEqual(root.find("devices/serial/source").attrib["service"], "23023")
202         self.assertFalse("tls" in root.find("devices/serial/source").keys())
203         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
204     def test_gen_xml_for_chardev_types(self):
205 <a name="5"></a>        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
206         nicp = virt._nic_profile("default", "kvm")
207         xml_data = virt._gen_xml(
208             self<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.mock_conn,
209             "hello",
210             1,
211             512,
212             diskp,
213             nicp,
214             "kvm",
215             "hvm",
216             "x86_64",
217             consoles=[
218                 {"type": "pty", "path": "/dev/pts/2", "target_port": 2},
219                 {"type": "pty", "target_type": "usb-serial"},
220                 {"type": "stdio"},
221                 {"type": "file", "path": "/path/to/serial.log"},
222             ],
223             serials=[
224                 {"type": "pipe", "path": "/tmp/mypipe"},
225                 {"type": "udp", "host": "127.0.0.1", "port": 1234},
226                 {"type": "tcp", "port": 22223, "protocol": "raw", "tls": True},
227                 {"type"</b></font>: "unix", "path": "/path/to/socket"},
228             ],
229         )
230         root = ET.fromstring(xml_data)
231         self.assertEqual(root.find("devices/console[1]").attrib["type"], "pty")
232         self.assertEqual(
233             root.find("devices/console[1]/source").attrib["path"], "/dev/pts/2"
234         )
235         self.assertEqual(root.find("devices/console[1]/target").attrib["port"], "2")
236         self.assertEqual(root.find("devices/console[2]").attrib["type"], "pty")
237         self.assertIsNone(root.find("devices/console[2]/source"))
238         self.assertEqual(
239             root.find("devices/console[2]/target").attrib["type"], "usb-serial"
240         )
241         self.assertEqual(root.find("devices/console[3]").attrib["type"], "stdio")
242         self.assertIsNone(root.find("devices/console[3]/source"))
243         self.assertEqual(root.find("devices/console[4]").attrib["type"], "file")
244         self.assertEqual(
245             root.find("devices/console[4]/source").attrib["path"], "/path/to/serial.log"
246         )
247         self.assertEqual(root.find("devices/serial[1]").attrib["type"], "pipe")
248         self.assertEqual(
249             root.find("devices/serial[1]/source").attrib["path"], "/tmp/mypipe"
250         )
251         self.assertEqual(root.find("devices/serial[2]").attrib["type"], "udp")
252         self.assertEqual(root.find("devices/serial[2]/source").attrib["mode"], "bind")
253         self.assertEqual(
254             root.find("devices/serial[2]/source").attrib["service"], "1234"
255         )
256         self.assertEqual(
257             root.find("devices/serial[2]/source").attrib["host"], "127.0.0.1"
258         )
259         self.assertEqual(root.find("devices/serial[3]").attrib["type"], "tcp")
260         self.assertEqual(root.find("devices/serial[3]/source").attrib["mode"], "bind")
261         self.assertEqual(
262             root.find("devices/serial[3]/source").attrib["service"], "22223"
263         )
264         self.assertEqual(root.find("devices/serial[3]/source").attrib["tls"], "yes")
265         self.assertEqual(root.find("devices/serial[3]/protocol").attrib["type"], "raw")
266         self.assertEqual(root.find("devices/serial[4]").attrib["type"], "unix")
267         self.assertEqual(
268             root.find("devices/serial[4]/source").attrib["path"], "/path/to/socket"
269         )
270     def test_gen_xml_no_nic_console(self):
271         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
272         nicp = virt._nic_profile("default", "kvm")
273         xml_data = virt._gen_xml(
274             self.mock_conn,
275             "hello",
276             1,
277             512,
278             diskp,
279             nicp,
280             "kvm",
281             "hvm",
282             "x86_64",
283             consoles=[{"type": "pty"}],
284         )
285         root = ET.fromstring(xml_data)
286         self.assertEqual(root.find("devices/console").attrib["type"], "pty")
287     def test_gen_xml_for_telnet_console(self):
288         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
289         nicp = virt._nic_profile("default", "kvm")
290         xml_data = virt._gen_xml(
291             self.mock_conn,
292             "hello",
293             1,
294             512,
295             diskp,
296             nicp,
297             "kvm",
298             "hvm",
299             "x86_64",
300             consoles=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
301         )
302         root = ET.fromstring(xml_data)
303         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
304         self.assertEqual(root.find("devices/console/source").attrib["service"], "22223")
305         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
306     def test_gen_xml_for_telnet_console_unspecified_port(self):
307         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
308         nicp = virt._nic_profile("default", "kvm")
309         xml_data = virt._gen_xml(
310             self.mock_conn,
311             "hello",
312             1,
313             512,
314             diskp,
315             nicp,
316             "kvm",
317             "hvm",
318             "x86_64",
319             consoles=[{"type": "tcp"}],
320         )
321         root = ET.fromstring(xml_data)
322         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
323         self.assertEqual(root.find("devices/console/source").attrib["service"], "23023")
324         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
325     def test_gen_xml_for_serial_no_console(self):
326         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
327         nicp = virt._nic_profile("default", "kvm")
328         xml_data = virt._gen_xml(
329             self.mock_conn,
330             "hello",
331             1,
332             512,
333             diskp,
334             nicp,
335             "kvm",
336             "hvm",
337             "x86_64",
338             serials=[{"type": "pty"}],
339             consoles=[],
340         )
341         root = ET.fromstring(xml_data)
342         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
343         self.assertEqual(root.find("devices/console"), None)
344     def test_gen_xml_for_telnet_no_console(self):
345         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
346         nicp = virt._nic_profile("default", "kvm")
347         xml_data = virt._gen_xml(
348             self.mock_conn,
349             "hello",
350             1,
351             512,
352             diskp,
353             nicp,
354             "kvm",
355             "hvm",
356             "x86_64",
357             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
358             consoles=[],
359         )
360         root = ET.fromstring(xml_data)
361         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
362         self.assertEqual(root.find("devices/console"), None)
363     def test_gen_xml_nographics_default(self):
364         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
365         nicp = virt._nic_profile("default", "kvm")
366         xml_data = virt._gen_xml(
367             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
368         )
369         root = ET.fromstring(xml_data)
370         self.assertIsNone(root.find("devices/graphics"))
371     def test_gen_xml_noloader_default(self):
372         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
373         nicp = virt._nic_profile("default", "kvm")
374         xml_data = virt._gen_xml(
375             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
376         )
377         root = ET.fromstring(xml_data)
378         self.assertIsNone(root.find("os/loader"))
379     def test_gen_xml_vnc_default(self):
380         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
381         nicp = virt._nic_profile("default", "kvm")
382         xml_data = virt._gen_xml(
383             self.mock_conn,
384             "hello",
385             1,
386             512,
387             diskp,
388             nicp,
389             "kvm",
390             "hvm",
391             "x86_64",
392             graphics={
393                 "type": "vnc",
394                 "port": 1234,
395                 "tlsPort": 5678,
396                 "listen": {"type": "address", "address": "myhost"},
397             },
398         )
399         root = ET.fromstring(xml_data)
400         self.assertEqual(root.find("devices/graphics").attrib["type"], "vnc")
401         self.assertEqual(root.find("devices/graphics").attrib["autoport"], "no")
402         self.assertEqual(root.find("devices/graphics").attrib["port"], "1234")
403         self.assertFalse("tlsPort" in root.find("devices/graphics").attrib)
404         self.assertEqual(root.find("devices/graphics").attrib["listen"], "myhost")
405         self.assertEqual(root.find("devices/graphics/listen").attrib["type"], "address")
406         self.assertEqual(
407             root.find("devices/graphics/listen").attrib["address"], "myhost"
408         )
409     def test_gen_xml_memory(self):
410         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
411         nicp = virt._nic_profile("default", "kvm")
412         xml_data = virt._gen_xml(
413             self.mock_conn,
414             "hello",
415             1,
416             {
417                 "boot": "512m",
418                 "current": "256m",
419                 "max": "1g",
420                 "hard_limit": "1024",
421                 "soft_limit": "512m",
422                 "swap_hard_limit": "1g",
423                 "min_guarantee": "256m",
424                 "hugepages": [
425                     {"size": "128m"},
426                     {"nodeset": "0", "size": "256m"},
427                     {"nodeset": "1", "size": "512m"},
428                 ],
429                 "nosharepages": True,
430                 "locked": True,
431                 "source": "file",
432                 "access": "shared",
433                 "allocation": "immediate",
434                 "discard": True,
435             },
436             diskp,
437             nicp,
438             "kvm",
439 <a name="0"></a>            "hvm",
440             "x86_64",
441         )
442         root = ET<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.fromstring(xml_data)
443         self.assert_equal_unit(root.find("memory"), 512 * 1024)
444         self.assert_equal_unit(root.find("currentMemory"), 256 * 1024)
445         self.assert_equal_unit(root.find("maxMemory"), 1024 * 1024)
446         self.assertFalse("slots" in root.find("maxMemory").keys())
447         self.assert_equal_unit(</b></font>root.find("memtune/hard_limit"), 1024 * 1024)
448         self.assert_equal_unit(root.find("memtune/soft_limit"), 512 * 1024)
449         self.assert_equal_unit(root.find("memtune/swap_hard_limit"), 1024 ** 2)
450         self.assert_equal_unit(root.find("memtune/min_guarantee"), 256 * 1024)
451         self.assertEqual(
452             [
453                 {"nodeset": page.get("nodeset"), "size": page.get("size")}
454                 for page in root.findall("memoryBacking/hugepages/page")
455             ],
456             [
457                 {"nodeset": None, "size": str(128 * 1024)},
458                 {"nodeset": "0", "size": str(256 * 1024)},
459                 {"nodeset": "1", "size": str(512 * 1024)},
460             ],
461         )
462         self.assertIsNotNone(root.find("memoryBacking/nosharepages"))
463         self.assertIsNotNone(root.find("memoryBacking/locked"))
464         self.assertIsNotNone(root.find("memoryBacking/discard"))
465         self.assertEqual(root.find("memoryBacking/source").get("type"), "file")
466         self.assertEqual(root.find("memoryBacking/access").get("mode"), "shared")
467         self.assertEqual(root.find("memoryBacking/allocation").get("mode"), "immediate")
468     def test_gen_xml_cpu(self):
469         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
470         nicp = virt._nic_profile("default", "kvm")
471         xml_data = virt._gen_xml(
472             self.mock_conn,
473             "hello",
474             {
475                 "maximum": 12,
476                 "placement": "static",
477                 "cpuset": "0-11",
478                 "current": 5,
479                 "mode": "custom",
480                 "match": "minimum",
481                 "check": "full",
482                 "vendor": "Intel",
483                 "model": {
484                     "name": "core2duo",
485                     "fallback": "allow",
486                     "vendor_id": "GenuineIntel",
487                 },
488                 "cache": {"level": 3, "mode": "emulate"},
489                 "features": {"lahf": "optional", "vmx": "require"},
490                 "vcpus": {
491                     0: {"enabled": True, "hotpluggable": True},
492                     1: {"enabled": False},
493                 },
494             },
495             512,
496             diskp,
497             nicp,
498             "kvm",
499             "hvm",
500             "x86_64",
501         )
502         root = ET.fromstring(xml_data)
503         self.assertEqual(root.find("vcpu").get("current"), "5")
504         self.assertEqual(root.find("vcpu").get("placement"), "static")
505         self.assertEqual(root.find("vcpu").get("cpuset"), "0-11")
506         self.assertEqual(root.find("vcpu").text, "12")
507         self.assertEqual(root.find("cpu").get("match"), "minimum")
508         self.assertEqual(root.find("cpu").get("mode"), "custom")
509         self.assertEqual(root.find("cpu").get("check"), "full")
510         self.assertEqual(root.find("cpu/vendor").text, "Intel")
511         self.assertEqual(root.find("cpu/model").text, "core2duo")
512         self.assertEqual(root.find("cpu/model").get("fallback"), "allow")
513         self.assertEqual(root.find("cpu/model").get("vendor_id"), "GenuineIntel")
514         self.assertEqual(root.find("cpu/cache").get("level"), "3")
515         self.assertEqual(root.find("cpu/cache").get("mode"), "emulate")
516         self.assertEqual(
517             {f.get("name"): f.get("policy") for f in root.findall("cpu/feature")},
518             {"lahf": "optional", "vmx": "require"},
519         )
520         self.assertEqual(
521             {
522                 v.get("id"): {
523                     "enabled": v.get("enabled"),
524                     "hotpluggable": v.get("hotpluggable"),
525                 }
526                 for v in root.findall("vcpus/vcpu")
527             },
528             {
529                 "0": {"enabled": "yes", "hotpluggable": "yes"},
530                 "1": {"enabled": "no", "hotpluggable": None},
531             },
532         )
533     def test_gen_xml_cpu_topology(self):
534         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
535         nicp = virt._nic_profile("default", "kvm")
536         xml_data = virt._gen_xml(
537             self.mock_conn,
538             "hello",
539             {"maximum": 1, "topology": {"sockets": 4, "cores": 16, "threads": 2}},
540             512,
541             diskp,
542             nicp,
543             "kvm",
544             "hvm",
545             "x86_64",
546         )
547         root = ET.fromstring(xml_data)
548         self.assertEqual(root.find("cpu/topology").get("sockets"), "4")
549         self.assertEqual(root.find("cpu/topology").get("cores"), "16")
550         self.assertEqual(root.find("cpu/topology").get("threads"), "2")
551     def test_gen_xml_cpu_numa(self):
552         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
553         nicp = virt._nic_profile("default", "kvm")
554         xml_data = virt._gen_xml(
555             self.mock_conn,
556             "hello",
557             {
558                 "maximum": 1,
559                 "numa": {
560                     0: {
561                         "cpus": "0-3",
562                         "memory": "1g",
563                         "discard": True,
564                         "distances": {0: 10, 1: 20},
565                     },
566                     1: {"cpus": "4-7", "memory": "2g", "distances": {0: 20, 1: 10}},
567                 },
568             },
569             512,
570             diskp,
571             nicp,
572             "kvm",
573             "hvm",
574             "x86_64",
575         )
576         root = ET.fromstring(xml_data)
577         cell0 = root.find("cpu/numa/cell[@id='0']")
578         self.assertEqual(cell0.get("cpus"), "0-3")
579         self.assertIsNone(cell0.get("unit"))
580         self.assertEqual(cell0.get("memory"), str(1024 ** 2))
581         self.assertEqual(cell0.get("discard"), "yes")
582         self.assertEqual(
583             {d.get("id"): d.get("value") for d in cell0.findall("distances/sibling")},
584             {"0": "10", "1": "20"},
585         )
586         cell1 = root.find("cpu/numa/cell[@id='1']")
587         self.assertEqual(cell1.get("cpus"), "4-7")
588         self.assertIsNone(cell0.get("unit"))
589         self.assertEqual(cell1.get("memory"), str(2 * 1024 ** 2))
590         self.assertFalse("discard" in cell1.keys())
591         self.assertEqual(
592             {d.get("id"): d.get("value") for d in cell1.findall("distances/sibling")},
593             {"0": "20", "1": "10"},
594         )
595     def test_gen_xml_cputune(self):
596         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
597         nicp = virt._nic_profile("default", "kvm")
598         cputune = {
599             "shares": 2048,
600             "period": 122000,
601             "quota": -1,
602             "global_period": 1000000,
603             "global_quota": -3,
604             "emulator_period": 1200000,
605             "emulator_quota": -10,
606             "iothread_period": 133000,
607             "iothread_quota": -1,
608             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
609             "emulatorpin": "1-3",
610             "iothreadpin": {1: "5-6", 2: "7-8"},
611             "vcpusched": [
612                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
613                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
614                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
615             ],
616             "iothreadsched": [
617                 {"scheduler": "idle"},
618                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1},
619             ],
620             "emulatorsched": {"scheduler": "rr", "priority": 2},
621             "cachetune": {
622                 "0-3": {
623                     0: {"level": 3, "type": "both", "size": 3},
624                     1: {"level": 3, "type": "both", "size": 3},
625                     "monitor": {1: 3, "0-3": 3},
626                 },
627                 "4-5": {"monitor": {4: 3, 5: 2}},
628             },
629             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
630         }
631         xml_data = virt._gen_xml(
632             self.mock_conn,
633             "hello",
634             {"maximum": 1, "tuning": cputune, "iothreads": 2},
635             512,
636             diskp,
637             nicp,
638             "kvm",
639             "hvm",
640             "x86_64",
641         )
642         root = ET.fromstring(xml_data)
643         self.assertEqual(root.find("cputune").find("shares").text, "2048")
644         self.assertEqual(root.find("cputune").find("period").text, "122000")
645         self.assertEqual(root.find("cputune").find("quota").text, "-1")
646         self.assertEqual(root.find("cputune").find("global_period").text, "1000000")
647         self.assertEqual(root.find("cputune").find("global_quota").text, "-3")
648         self.assertEqual(root.find("cputune").find("emulator_period").text, "1200000")
649         self.assertEqual(root.find("cputune").find("emulator_quota").text, "-10")
650         self.assertEqual(root.find("cputune").find("iothread_period").text, "133000")
651         self.assertEqual(root.find("cputune").find("iothread_quota").text, "-1")
652         self.assertEqual(
653             root.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
654             "1-4,^2",
655         )
656         self.assertEqual(
657             root.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
658             "0,1",
659         )
660         self.assertEqual(
661             root.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
662             "2,3",
663         )
664         self.assertEqual(
665             root.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
666             "0,4",
667         )
668         self.assertEqual(
669             root.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1-3"
670         )
671         self.assertEqual(
672             root.find("cputune")
673             .find("iothreadpin[@iothread='1']")
674             .attrib.get("cpuset"),
675             "5-6",
676         )
677         self.assertEqual(
678             root.find("cputune")
679             .find("iothreadpin[@iothread='2']")
680             .attrib.get("cpuset"),
681             "7-8",
682         )
683         self.assertDictEqual(
684             {
685                 s.get("vcpus"): {
686                     "scheduler": s.get("scheduler"),
687                     "priority": s.get("priority"),
688                 }
689                 for s in root.findall("cputune/vcpusched")
690             },
691             {
692                 "0": {"scheduler": "fifo", "priority": "1"},
693                 "1": {"scheduler": "fifo", "priority": "2"},
694                 "2": {"scheduler": "idle", "priority": "3"},
695             },
696         )
697         self.assertDictEqual(
698             {
699                 s.get("iothreads"): {
700                     "scheduler": s.get("scheduler"),
701                     "priority": s.get("priority"),
702                 }
703                 for s in root.findall("cputune/iothreadsched")
704             },
705             {
706                 None: {"scheduler": "idle", "priority": None},
707                 "5-7": {"scheduler": "batch", "priority": "1"},
708             },
709         )
710         self.assertEqual(root.find("cputune/emulatorsched").get("scheduler"), "rr")
711         self.assertEqual(root.find("cputune/emulatorsched").get("priority"), "2")
712         self.assertEqual(
713             root.find("./cputune/cachetune[@vcpus='0-3']").attrib.get("vcpus"), "0-3"
714         )
715         self.assertEqual(
716             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
717                 "level"
718             ),
719             "3",
720         )
721         self.assertEqual(
722             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
723                 "type"
724             ),
725             "both",
726         )
727         self.assertEqual(
728             root.find(
729                 "./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"
730             ).attrib.get("level"),
731             "3",
732         )
733         self.assertNotEqual(
734             root.find("./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"), None
735         )
736         self.assertNotEqual(
737             root.find("./cputune/cachetune[@vcpus='4-5']").attrib.get("vcpus"), None
738         )
739         self.assertEqual(
740             root.find("./cputune/cachetune[@vcpus='4-5']/cache[@id='0']"), None
741         )
742         self.assertEqual(
743             root.find(
744                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']"
745             ).attrib.get("level"),
746             "3",
747         )
748         self.assertEqual(
749             root.find(
750                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']"
751             ).attrib.get("level"),
752             "2",
753         )
754         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='0-2']"), None)
755         self.assertEqual(
756             root.find("./cputune/memorytune[@vcpus='0-2']/node[@id='0']").attrib.get(
757                 "bandwidth"
758             ),
759             "60",
760         )
761         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='3-4']"), None)
762         self.assertEqual(
763             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='0']").attrib.get(
764                 "bandwidth"
765             ),
766             "50",
767         )
768         self.assertEqual(
769             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='1']").attrib.get(
770                 "bandwidth"
771             ),
772             "70",
773         )
774         self.assertEqual(root.find("iothreads").text, "2")
775     def test_default_disk_profile_hypervisor_esxi(self):
776         mock = MagicMock(return_value={})
777         with patch.dict(
778             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
779         ):
780             ret = virt._disk_profile(
781                 self.mock_conn, "nonexistent", "vmware", None, "test-vm"
782             )
783             self.assertTrue(len(ret) == 1)
784             found = [disk for disk in ret if disk["name"] == "system"]
785             self.assertTrue(bool(found))
786             system = found[0]
787             self.assertEqual(system["format"], "vmdk")
788             self.assertEqual(system["model"], "scsi")
789             self.assertTrue(int(system["size"]) &gt;= 1)
790     def test_default_disk_profile_hypervisor_kvm(self):
791         mock = MagicMock(side_effect=[{}, "/images/dir"])
792         with patch.dict(
793             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
794         ):
795             ret = virt._disk_profile(
796                 self.mock_conn, "nonexistent", "kvm", None, "test-vm"
797             )
798             self.assertTrue(len(ret) == 1)
799             found = [disk for disk in ret if disk["name"] == "system"]
800             self.assertTrue(bool(found))
801             system = found[0]
802             self.assertEqual(system["format"], "qcow2")
803             self.assertEqual(system["model"], "virtio")
804             self.assertTrue(int(system["size"]) &gt;= 1)
805     def test_default_disk_profile_hypervisor_xen(self):
806         mock = MagicMock(side_effect=[{}, "/images/dir"])
807         with patch.dict(
808             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
809         ):
810             ret = virt._disk_profile(
811                 self.mock_conn, "nonexistent", "xen", None, "test-vm"
812             )
813             self.assertTrue(len(ret) == 1)
814             found = [disk for disk in ret if disk["name"] == "system"]
815             self.assertTrue(bool(found))
816             system = found[0]
817             self.assertEqual(system["format"], "qcow2")
818             self.assertEqual(system["model"], "xen")
819             self.assertTrue(int(system["size"]) &gt;= 1)
820     def test_default_nic_profile_hypervisor_esxi(self):
821         mock = MagicMock(return_value={})
822         with patch.dict(
823             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
824         ):
825             ret = virt._nic_profile("nonexistent", "vmware")
826             self.assertTrue(len(ret) == 1)
827             eth0 = ret[0]
828             self.assertEqual(eth0["name"], "eth0")
829             self.assertEqual(eth0["type"], "bridge")
830             self.assertEqual(eth0["source"], "DEFAULT")
831             self.assertEqual(eth0["model"], "e1000")
832     def test_default_nic_profile_hypervisor_kvm(self):
833         mock = MagicMock(return_value={})
834         with patch.dict(
835             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
836         ):
837             ret = virt._nic_profile("nonexistent", "kvm")
838             self.assertTrue(len(ret) == 1)
839             eth0 = ret[0]
840             self.assertEqual(eth0["name"], "eth0")
841             self.assertEqual(eth0["type"], "bridge")
842             self.assertEqual(eth0["source"], "br0")
843             self.assertEqual(eth0["model"], "virtio")
844     def test_default_nic_profile_hypervisor_xen(self):
845         mock = MagicMock(return_value={})
846         with patch.dict(
847             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
848         ):
849             ret = virt._nic_profile("nonexistent", "xen")
850             self.assertTrue(len(ret) == 1)
851             eth0 = ret[0]
852             self.assertEqual(eth0["name"], "eth0")
853             self.assertEqual(eth0["type"], "bridge")
854             self.assertEqual(eth0["source"], "br0")
855             self.assertFalse(eth0["model"])
856     def test_gen_vol_xml_esx(self):
857         xml_data = virt._gen_vol_xml("vmname/system.vmdk", 8192, format="vmdk")
858         root = ET.fromstring(xml_data)
859         self.assertIsNone(root.get("type"))
860         self.assertEqual(root.find("name").text, "vmname/system.vmdk")
861         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
862         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
863         self.assertEqual(root.find("allocation").text, str(0))
864         self.assertEqual(root.find("target/format").get("type"), "vmdk")
865         self.assertIsNone(root.find("target/permissions"))
866         self.assertIsNone(root.find("target/nocow"))
867         self.assertIsNone(root.find("backingStore"))
868     def test_gen_vol_xml_file(self):
869         xml_data = virt._gen_vol_xml(
870             "myvm_system.qcow2",
871             8192,
872             format="qcow2",
873             allocation=4096,
874             type="file",
875             permissions={
876                 "mode": "0775",
877                 "owner": "123",
878                 "group": "456",
879                 "label": "sec_label",
880             },
881             backing_store={"path": "/backing/image", "format": "raw"},
882             nocow=True,
883         )
884         root = ET.fromstring(xml_data)
885         self.assertEqual(root.get("type"), "file")
886         self.assertEqual(root.find("name").text, "myvm_system.qcow2")
887         self.assertIsNone(root.find("key"))
888         self.assertIsNone(root.find("target/path"))
889         self.assertEqual(root.find("target/format").get("type"), "qcow2")
890         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
891         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
892         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
893         self.assertEqual(root.find("allocation").text, str(4096 * 1024))
894         self.assertEqual(root.find("target/permissions/mode").text, "0775")
895         self.assertEqual(root.find("target/permissions/owner").text, "123")
896         self.assertEqual(root.find("target/permissions/group").text, "456")
897         self.assertEqual(root.find("target/permissions/label").text, "sec_label")
898         self.assertIsNotNone(root.find("target/nocow"))
899         self.assertEqual(root.find("backingStore/path").text, "/backing/image")
900         self.assertEqual(root.find("backingStore/format").get("type"), "raw")
901     def test_gen_xml_for_kvm_default_profile(self):
902         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
903         nicp = virt._nic_profile("default", "kvm")
904         xml_data = virt._gen_xml(
905             self.mock_conn,
906             "hello",
907             1,
908             512,
909             diskp,
910             nicp,
911             "kvm",
912             "hvm",
913             "x86_64",
914         )
915         root = ET.fromstring(xml_data)
916         self.assertEqual(root.attrib["type"], "kvm")
917         self.assertEqual(root.find("vcpu").text, "1")
918         self.assertEqual(root.find("memory").text, str(512 * 1024))
919         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
920         disks = root.findall(".//disk")
921         self.assertEqual(len(disks), 1)
922         disk = disks[0]
923         root_dir = salt.config.DEFAULT_MINION_OPTS.get("root_dir")
924         self.assertTrue(disk.find("source").attrib["file"].startswith(root_dir))
925         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
926         self.assertEqual(disk.find("target").attrib["dev"], "vda")
927         self.assertEqual(disk.find("target").attrib["bus"], "virtio")
928         self.assertEqual(disk.find("driver").attrib["name"], "qemu")
929         self.assertEqual(disk.find("driver").attrib["type"], "qcow2")
930         interfaces = root.findall(".//interface")
931         self.assertEqual(len(interfaces), 1)
932         iface = interfaces[0]
933         self.assertEqual(iface.attrib["type"], "bridge")
934         self.assertEqual(iface.find("source").attrib["bridge"], "br0")
935         self.assertEqual(iface.find("model").attrib["type"], "virtio")
936     def test_gen_xml_for_esxi_default_profile(self):
937         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
938         nicp = virt._nic_profile("default", "vmware")
939         xml_data = virt._gen_xml(
940             self.mock_conn,
941             "hello",
942             1,
943             512,
944             diskp,
945             nicp,
946             "vmware",
947             "hvm",
948             "x86_64",
949         )
950         root = ET.fromstring(xml_data)
951         self.assertEqual(root.attrib["type"], "vmware")
952         self.assertEqual(root.find("vcpu").text, "1")
953         self.assertEqual(root.find("memory").text, str(512 * 1024))
954         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
955         disks = root.findall(".//disk")
956         self.assertEqual(len(disks), 1)
957         disk = disks[0]
958         self.assertTrue("[0]" in disk.find("source").attrib["file"])
959         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
960         self.assertEqual(disk.find("target").attrib["dev"], "sda")
961         self.assertEqual(disk.find("target").attrib["bus"], "scsi")
962         self.assertEqual(disk.find("address").attrib["unit"], "0")
963         interfaces = root.findall(".//interface")
964         self.assertEqual(len(interfaces), 1)
965         iface = interfaces[0]
966         self.assertEqual(iface.attrib["type"], "bridge")
967         self.assertEqual(iface.find("source").attrib["bridge"], "DEFAULT")
968         self.assertEqual(iface.find("model").attrib["type"], "e1000")
969     def test_gen_xml_for_esxi_custom_profile(self):
970         disks = {
971             "noeffect": [
972                 {"first": {"size": 8192, "pool": "datastore1"}},
973                 {"second": {"size": 4096, "pool": "datastore2"}},
974             ]
975         }
976         nics = {
977             "noeffect": [
978                 {"name": "eth1", "source": "ONENET"},
979                 {"name": "eth2", "source": "TWONET"},
980             ]
981         }
982         with patch.dict(
983             virt.__salt__,  # pylint: disable=no-member
984             {"config.get": MagicMock(side_effect=[disks, nics])},
985         ):
986             diskp = virt._disk_profile(
987                 self.mock_conn, "noeffect", "vmware", [], "hello"
988             )
989             nicp = virt._nic_profile("noeffect", "vmware")
990             xml_data = virt._gen_xml(
991                 self.mock_conn,
992                 "hello",
993                 1,
994                 512,
995                 diskp,
996                 nicp,
997                 "vmware",
998                 "hvm",
999                 "x86_64",
1000             )
1001             root = ET.fromstring(xml_data)
1002             self.assertEqual(root.attrib["type"], "vmware")
1003             self.assertEqual(root.find("vcpu").text, "1")
1004             self.assertEqual(root.find("memory").text, str(512 * 1024))
1005             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1006             self.assertTrue(len(root.findall(".//disk")) == 2)
1007             self.assertTrue(len(root.findall(".//interface")) == 2)
1008     def test_gen_xml_for_kvm_custom_profile(self):
1009         disks = {
1010             "noeffect": [
1011                 {"first": {"size": 8192, "pool": "/var/lib/images"}},
1012                 {"second": {"size": 4096, "pool": "/var/lib/images"}},
1013             ]
1014         }
1015         nics = {
1016             "noeffect": [
1017                 {"name": "eth1", "source": "b2"},
1018                 {"name": "eth2", "source": "b2"},
1019             ]
1020         }
1021         with patch.dict(
1022             virt.__salt__,  # pylint: disable=no-member
1023             {"config.get": MagicMock(side_effect=[disks, nics])},
1024         ):
1025             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1026             nicp = virt._nic_profile("noeffect", "kvm")
1027             xml_data = virt._gen_xml(
1028                 self.mock_conn,
1029                 "hello",
1030                 1,
1031                 512,
1032                 diskp,
1033                 nicp,
1034                 "kvm",
1035                 "hvm",
1036                 "x86_64",
1037             )
1038             root = ET.fromstring(xml_data)
1039             self.assertEqual(root.attrib["type"], "kvm")
1040             self.assertEqual(root.find("vcpu").text, "1")
1041             self.assertEqual(root.find("memory").text, str(512 * 1024))
1042             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1043             disks = root.findall(".//disk")
1044             self.assertTrue(len(disks) == 2)
1045             self.assertEqual(disks[0].find("target").get("dev"), "vda")
1046             self.assertEqual(disks[1].find("target").get("dev"), "vdb")
1047             self.assertTrue(len(root.findall(".//interface")) == 2)
1048     def test_disk_profile_kvm_disk_pool(self):
1049         disks = {
1050             "noeffect": [
1051                 {"first": {"size": 8192, "pool": "mypool"}},
1052                 {"second": {"size": 4096}},
1053             ]
1054         }
1055         with patch.dict(
1056             virt.__salt__,
1057             {
1058                 "config.get": MagicMock(
1059                     side_effect=[
1060                         disks,
1061                         os.path.join(salt.syspaths.ROOT_DIR, "default", "path"),
1062                     ]
1063                 )
1064             },
1065         ):
1066             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1067             pools_path = (
1068                 os.path.join(salt.syspaths.ROOT_DIR, "pools", "mypool") + os.sep
1069             )
1070             default_path = (
1071                 os.path.join(salt.syspaths.ROOT_DIR, "default", "path") + os.sep
1072             )
1073             self.assertEqual(len(diskp), 2)
1074             self.assertTrue(diskp[1]["source_file"].startswith(default_path))
1075     def test_disk_profile_kvm_disk_external_image(self):
1076         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1077             diskp = virt._disk_profile(
1078                 self.mock_conn,
1079                 None,
1080                 "kvm",
1081                 [{"name": "mydisk", "source_file": "/path/to/my/image.qcow2"}],
1082                 "hello",
1083             )
1084             self.assertEqual(len(diskp), 1)
1085             self.assertEqual(diskp[0]["source_file"], "/path/to/my/image.qcow2")
1086     def test_disk_profile_cdrom_default(self):
1087         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1088             diskp = virt._disk_profile(
1089                 self.mock_conn,
1090                 None,
1091                 "kvm",
1092                 [
1093                     {
1094                         "name": "mydisk",
1095                         "device": "cdrom",
1096                         "source_file": "/path/to/my.iso",
1097                     }
1098                 ],
1099                 "hello",
1100             )
1101             self.assertEqual(len(diskp), 1)
1102             self.assertEqual(diskp[0]["model"], "ide")
1103             self.assertEqual(diskp[0]["format"], "raw")
1104     def test_disk_profile_pool_disk_type(self):
1105         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1106         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1107             &lt;pool type="disk"&gt;
1108               &lt;name&gt;test-vdb&lt;/name&gt;
1109               &lt;source&gt;
1110                 &lt;device path='/dev/vdb'/&gt;
1111               &lt;/source&gt;
1112               &lt;target&gt;
1113                 &lt;path&gt;/dev&lt;/path&gt;
1114               &lt;/target&gt;
1115             &lt;/pool&gt;
1116         """
1117         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = (
1118             []
1119         )
1120         diskp = virt._disk_profile(
1121             self.mock_conn,
1122             None,
1123             "kvm",
1124             [{"name": "mydisk", "pool": "test-vdb"}],
1125             "hello",
1126         )
1127         self.assertEqual(diskp[0]["filename"], "vdb1")
1128         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1129             "vdb1",
1130             "vdb2",
1131         ]
1132         diskp = virt._disk_profile(
1133             self.mock_conn,
1134             None,
1135             "kvm",
1136             [{"name": "mydisk", "pool": "test-vdb"}],
1137             "hello",
1138         )
1139         self.assertEqual(diskp[0]["filename"], "vdb3")
1140         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1141             "vdb1",
1142             "vdb3",
1143         ]
1144         diskp = virt._disk_profile(
1145 <a name="9"></a>            self.mock_conn,
1146             None,
1147             "kvm",
1148             [{<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"name": "mydisk", "pool": "test-vdb"}],
1149             "hello",
1150         )
1151         self.assertEqual(diskp[0]["filename"], "vdb2")
1152         diskp = virt._disk_profile(
1153             self.mock_conn,
1154             None,
1155             "kvm",
1156             [{"name": "mydisk", "pool": "test-vdb", "source_file": "vdb1"}],
1157             "hello",
1158         )
1159         self.</b></font>assertEqual(diskp[0]["filename"], "vdb1")
1160     def test_gen_xml_volume(self):
1161         self.mock_conn.listStoragePools.return_value = ["default"]
1162         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1163             "&lt;pool type='dir'/&gt;"
1164         )
1165         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1166             "myvolume"
1167         ]
1168         diskp = virt._disk_profile(
1169             self.mock_conn,
1170             None,
1171             "kvm",
1172             [
1173                 {"name": "system", "pool": "default"},
1174                 {"name": "data", "pool": "default", "source_file": "myvolume"},
1175             ],
1176             "hello",
1177         )
1178         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1179             "&lt;pool type='dir'/&gt;"
1180 <a name="8"></a>        )
1181         nicp = virt._nic_profile(None, "kvm")
1182         xml_data = virt._gen_xml(
1183             self<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.mock_conn,
1184             "hello",
1185             1,
1186             512,
1187             diskp,
1188             nicp,
1189             "kvm",
1190             "hvm",
1191             "x86_64",
1192         )
1193         root = ET.fromstring(xml_data)
1194         disk = root.findall(".//disk")[0]
1195         self.assertEqual(disk.attrib[</b></font>"device"], "disk")
1196         self.assertEqual(disk.attrib["type"], "volume")
1197         source = disk.find("source")
1198         self.assertEqual("default", source.attrib["pool"])
1199         self.assertEqual("hello_system", source.attrib["volume"])
1200         self.assertEqual("myvolume", root.find(".//disk[2]/source").get("volume"))
1201         self.mock_conn.listStoragePools.return_value = ["test-rbd"]
1202         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1203             &lt;pool type='rbd'&gt;
1204               &lt;name&gt;test-rbd&lt;/name&gt;
1205               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1206               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1207               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1208               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1209               &lt;source&gt;
1210                 &lt;host name='ses2.tf.local'/&gt;
1211                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1212                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1213                 &lt;auth type='ceph' username='libvirt'&gt;
1214                   &lt;secret usage='pool_test-rbd'/&gt;
1215                 &lt;/auth&gt;
1216               &lt;/source&gt;
1217             &lt;/pool&gt;
1218         """
1219         self.mock_conn.getStoragePoolCapabilities.return_value = """
1220             &lt;storagepoolCapabilities&gt;
1221               &lt;pool type='rbd' supported='yes'&gt;
1222                 &lt;volOptions&gt;
1223                   &lt;defaultFormat type='raw'/&gt;
1224                   &lt;enum name='targetFormatType'&gt;
1225                   &lt;/enum&gt;
1226                 &lt;/volOptions&gt;
1227               &lt;/pool&gt;
1228             &lt;/storagepoolCapabilities&gt;
1229         """
1230         diskp = virt._disk_profile(
1231             self.mock_conn,
1232             None,
1233             "kvm",
1234             [{"name": "system", "pool": "test-rbd"}],
1235             "test-vm",
1236         )
1237         xml_data = virt._gen_xml(
1238             self.mock_conn,
1239             "hello",
1240             1,
1241             512,
1242             diskp,
1243             nicp,
1244             "kvm",
1245             "hvm",
1246             "x86_64",
1247         )
1248         root = ET.fromstring(xml_data)
1249         disk = root.findall(".//disk")[0]
1250         self.assertDictEqual(
1251             {
1252                 "type": "network",
1253                 "device": "disk",
1254                 "source": {
1255                     "protocol": "rbd",
1256                     "name": "libvirt-pool/test-vm_system",
1257                     "host": [
1258                         {"name": "ses2.tf.local"},
1259                         {"name": "ses3.tf.local", "port": "1234"},
1260                     ],
1261                     "auth": {
1262                         "username": "libvirt",
1263                         "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1264                     },
1265                 },
1266                 "target": {"dev": "vda", "bus": "virtio"},
1267                 "driver": {
1268                     "name": "qemu",
1269                     "type": "raw",
1270                     "cache": "none",
1271                     "io": "native",
1272                 },
1273             },
1274             salt.utils.xmlutil.to_dict(disk, True),
1275         )
1276         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1277             &lt;pool type='rbd'&gt;
1278               &lt;name&gt;test-rbd&lt;/name&gt;
1279               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1280               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1281               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1282               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1283               &lt;source&gt;
1284                 &lt;host name='ses2.tf.local'/&gt;
1285                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1286                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1287                 &lt;auth type='ceph' username='libvirt'&gt;
1288                   &lt;secret uuid='some-uuid'/&gt;
1289                 &lt;/auth&gt;
1290               &lt;/source&gt;
1291             &lt;/pool&gt;
1292         """
1293         self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
1294             "pool_test-rbd"
1295         )
1296         diskp = virt._disk_profile(
1297             self.mock_conn,
1298             None,
1299             "kvm",
1300             [{"name": "system", "pool": "test-rbd"}],
1301             "test-vm",
1302         )
1303         xml_data = virt._gen_xml(
1304             self.mock_conn,
1305             "hello",
1306             1,
1307             512,
1308             diskp,
1309             nicp,
1310             "kvm",
1311             "hvm",
1312             "x86_64",
1313         )
1314         root = ET.fromstring(xml_data)
1315         self.assertDictEqual(
1316             {
1317                 "username": "libvirt",
1318                 "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1319             },
1320             salt.utils.xmlutil.to_dict(root.find(".//disk/source/auth"), True),
1321         )
1322         self.mock_conn.secretLookupByUUIDString.assert_called_once_with("some-uuid")
1323         self.mock_conn.getStoragePoolCapabilities.return_value = """
1324             &lt;storagepoolCapabilities&gt;
1325               &lt;pool type='disk' supported='yes'&gt;
1326                 &lt;volOptions&gt;
1327                   &lt;defaultFormat type='none'/&gt;
1328                   &lt;enum name='targetFormatType'&gt;
1329                     &lt;value&gt;none&lt;/value&gt;
1330                     &lt;value&gt;linux&lt;/value&gt;
1331                     &lt;value&gt;fat16&lt;/value&gt;
1332                   &lt;/enum&gt;
1333                 &lt;/volOptions&gt;
1334               &lt;/pool&gt;
1335             &lt;/storagepoolCapabilities&gt;
1336         """
1337         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1338             &lt;pool type='disk'&gt;
1339               &lt;name&gt;test-vdb&lt;/name&gt;
1340               &lt;source&gt;
1341                 &lt;device path='/dev/vdb'/&gt;
1342                 &lt;format type='gpt'/&gt;
1343               &lt;/source&gt;
1344             &lt;/pool&gt;
1345         """
1346         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1347         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1348             "vdb1",
1349         ]
1350         diskp = virt._disk_profile(
1351             self.mock_conn,
1352             None,
1353             "kvm",
1354             [{"name": "system", "pool": "test-vdb"}],
1355             "test-vm",
1356         )
1357         xml_data = virt._gen_xml(
1358             self.mock_conn,
1359             "hello",
1360             1,
1361             512,
1362             diskp,
1363             nicp,
1364             "kvm",
1365             "hvm",
1366             "x86_64",
1367         )
1368         root = ET.fromstring(xml_data)
1369         disk = root.findall(".//disk")[0]
1370         self.assertEqual(disk.attrib["type"], "volume")
1371         source = disk.find("source")
1372         self.assertEqual("test-vdb", source.attrib["pool"])
1373         self.assertEqual("vdb2", source.attrib["volume"])
1374         self.assertEqual("raw", disk.find("driver").get("type"))
1375     def test_get_xml_volume_xen_dir(self):
1376         self.mock_conn.listStoragePools.return_value = ["default"]
1377         pool_mock = MagicMock()
1378         pool_mock.XMLDesc.return_value = (
1379             "&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;"
1380         )
1381         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1382         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1383         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1384         diskp = virt._disk_profile(
1385             self.mock_conn,
1386             None,
1387             "xen",
1388             [{"name": "system", "pool": "default"}],
1389             "hello",
1390         )
1391         xml_data = virt._gen_xml(
1392             self.mock_conn,
1393             "hello",
1394             1,
1395             512,
1396             diskp,
1397             [],
1398             "xen",
1399             "hvm",
1400             "x86_64",
1401         )
1402         root = ET.fromstring(xml_data)
1403         disk = root.findall(".//disk")[0]
1404         self.assertEqual(disk.attrib["type"], "file")
1405         self.assertEqual(
1406             "/path/to/images/hello_system", disk.find("source").attrib["file"]
1407         )
1408     def test_get_xml_volume_xen_block(self):
1409         self.mock_conn.listStoragePools.return_value = ["default"]
1410         pool_mock = MagicMock()
1411         pool_mock.listVolumes.return_value = ["vol01"]
1412         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1413         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1414         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1415         for pool_type in ["logical", "disk", "iscsi", "scsi"]:
1416             pool_mock.XMLDesc.return_value = "&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;".format(
1417                 pool_type
1418             )
1419             diskp = virt._disk_profile(
1420                 self.mock_conn,
1421                 None,
1422                 "xen",
1423                 [{"name": "system", "pool": "default", "source_file": "vol01"}],
1424                 "hello",
1425             )
1426             xml_data = virt._gen_xml(
1427                 self.mock_conn,
1428                 "hello",
1429                 1,
1430                 512,
1431                 diskp,
1432                 [],
1433                 "xen",
1434                 "hvm",
1435                 "x86_64",
1436             )
1437             root = ET.fromstring(xml_data)
1438             disk = root.findall(".//disk")[0]
1439             self.assertEqual(disk.attrib["type"], "block")
1440             self.assertEqual("/dev/to/vol01", disk.find("source").attrib["dev"])
1441     def test_gen_xml_cdrom(self):
1442         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1443             "&lt;pool type='dir'/&gt;"
1444         )
1445         diskp = virt._disk_profile(
1446             self.mock_conn,
1447             None,
1448             "kvm",
1449             [
1450                 {"name": "system", "pool": "default"},
1451                 {
1452                     "name": "tested",
1453                     "device": "cdrom",
1454                     "source_file": None,
1455                     "model": "ide",
1456                 },
1457                 {
1458                     "name": "remote",
1459                     "device": "cdrom",
1460                     "source_file": (
1461                         "http://myhost:8080/url/to/image?query=foo&amp;filter=bar"
1462                     ),
1463                     "model": "ide",
1464                 },
1465             ],
1466             "hello",
1467         )
1468         nicp = virt._nic_profile(None, "kvm")
1469         xml_data = virt._gen_xml(
1470             self.mock_conn,
1471             "hello",
1472             1,
1473             512,
1474             diskp,
1475             nicp,
1476             "kvm",
1477             "hvm",
1478             "x86_64",
1479         )
1480         root = ET.fromstring(xml_data)
1481         disk = root.findall(".//disk")[1]
1482         self.assertEqual(disk.get("type"), "file")
1483         self.assertEqual(disk.attrib["device"], "cdrom")
1484         self.assertIsNone(disk.find("source"))
1485         self.assertEqual(disk.find("target").get("dev"), "hda")
1486         disk = root.findall(".//disk")[2]
1487         self.assertEqual(disk.get("type"), "network")
1488         self.assertEqual(disk.attrib["device"], "cdrom")
1489         self.assertEqual(
1490             {
1491                 "protocol": "http",
1492                 "name": "/url/to/image",
1493                 "query": "query=foo&amp;filter=bar",
1494                 "host": {"name": "myhost", "port": "8080"},
1495             },
1496             salt.utils.xmlutil.to_dict(disk.find("source"), True),
1497         )
1498     def test_controller_for_esxi(self):
1499         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
1500         nicp <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= virt._nic_profile("default", "vmware")
1501         xml_data = virt._gen_xml(
1502             self.mock_conn,
1503             "hello",
1504             1,
1505             512,
1506             diskp,
1507             nicp,
1508             "vmware",
1509             "hvm",
1510             "x86_64",
1511         )
1512         root = ET.fromstring(xml_data)
1513         controllers = root.findall(".//devices/controller")
1514         self.assertTrue(</b></font>len(controllers) == 1)
1515         controller = controllers[0]
1516         self.assertEqual(controller.attrib["model"], "lsilogic")
1517     def test_controller_for_kvm(self):
1518         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
1519         nicp = virt._nic_profile("default", "kvm")
1520         xml_data = virt._gen_xml(
1521             self.mock_conn,
1522             "hello",
1523             1,
1524             512,
1525             diskp,
1526             nicp,
1527             "kvm",
1528             "hvm",
1529             "x86_64",
1530         )
1531         root = ET.fromstring(xml_data)
1532         controllers = root.findall(".//devices/controller")
1533         self.assertTrue(len(controllers) == 0)
1534     def test_diff_disks(self):
1535         old_disks = ET.fromstring(
1536         )<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("disk")
1537         new_disks = ET.fromstring(
1538         ).findall("disk")
1539         ret = virt._diff_disk_lists(old_disks, new_disks)
1540         self.assertEqual(</b></font>
1541             [
1542                 disk.find("source").get("file")
1543                 if disk.find("source") is not None
1544                 else None
1545                 for disk in ret["unchanged"]
1546             ],
1547             [],
1548         )
1549         self.assertEqual(
1550             [
1551                 disk.find("source").get("file")
1552                 if disk.find("source") is not None
1553                 else None
1554                 for disk in ret["new"]
1555             ],
1556             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1557         )
1558         self.assertEqual(
1559             [disk.find("target").get("dev") for disk in ret["sorted"]],
1560             ["vda", "vdb", "vdc", "hda"],
1561         )
1562         self.assertEqual(
1563             [
1564                 disk.find("source").get("file")
1565                 if disk.find("source") is not None
1566                 else None
1567                 for disk in ret["sorted"]
1568             ],
1569             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1570         )
1571         self.assertEqual(ret["new"][1].find("target").get("bus"), "virtio")
1572         self.assertEqual(
1573             [
1574                 disk.find("source").get("file")
1575                 if disk.find("source") is not None
1576                 else None
1577                 for disk in ret["deleted"]
1578             ],
1579             [
1580                 "/path/to/img0.qcow2",
1581                 "/path/to/img1.qcow2",
1582                 "/path/to/img2.qcow2",
1583                 "/path/to/img4.qcow2",
1584                 None,
1585             ],
1586         )
1587     def test_init(self):
1588         xml = """
1589 &lt;capabilities&gt;
1590   &lt;host&gt;
1591     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
1592     &lt;cpu&gt;
1593       &lt;arch&gt;x86_64&lt;/arch&gt;
1594       &lt;model&gt;Nehalem&lt;/model&gt;
1595       &lt;vendor&gt;Intel&lt;/vendor&gt;
1596       &lt;microcode version='25'/&gt;
1597       &lt;topology sockets='1' cores='4' threads='2'/&gt;
1598       &lt;feature name='vme'/&gt;
1599       &lt;feature name='ds'/&gt;
1600       &lt;feature name='acpi'/&gt;
1601       &lt;pages unit='KiB' size='4'/&gt;
1602       &lt;pages unit='KiB' size='2048'/&gt;
1603     &lt;/cpu&gt;
1604     &lt;power_management&gt;
1605       &lt;suspend_mem/&gt;
1606       &lt;suspend_disk/&gt;
1607       &lt;suspend_hybrid/&gt;
1608     &lt;/power_management&gt;
1609     &lt;migration_features&gt;
1610       &lt;live/&gt;
1611       &lt;uri_transports&gt;
1612         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
1613         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
1614       &lt;/uri_transports&gt;
1615     &lt;/migration_features&gt;
1616     &lt;topology&gt;
1617       &lt;cells num='1'&gt;
1618         &lt;cell id='0'&gt;
1619           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
1620           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
1621           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
1622           &lt;distances&gt;
1623             &lt;sibling id='0' value='10'/&gt;
1624           &lt;/distances&gt;
1625           &lt;cpus num='8'&gt;
1626             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
1627             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
1628             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
1629             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
1630             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
1631             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
1632             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
1633             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
1634           &lt;/cpus&gt;
1635         &lt;/cell&gt;
1636       &lt;/cells&gt;
1637     &lt;/topology&gt;
1638     &lt;cache&gt;
1639       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
1640     &lt;/cache&gt;
1641     &lt;secmodel&gt;
1642       &lt;model&gt;apparmor&lt;/model&gt;
1643       &lt;doi&gt;0&lt;/doi&gt;
1644     &lt;/secmodel&gt;
1645     &lt;secmodel&gt;
1646       &lt;model&gt;dac&lt;/model&gt;
1647       &lt;doi&gt;0&lt;/doi&gt;
1648       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
1649       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
1650     &lt;/secmodel&gt;
1651   &lt;/host&gt;
1652   &lt;guest&gt;
1653     &lt;os_type&gt;hvm&lt;/os_type&gt;
1654     &lt;arch name='i686'&gt;
1655       &lt;wordsize&gt;32&lt;/wordsize&gt;
1656       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
1657       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1658       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1659       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1660       &lt;domain type='qemu'/&gt;
1661       &lt;domain type='kvm'&gt;
1662         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1663         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1664         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1665         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1666       &lt;/domain&gt;
1667     &lt;/arch&gt;
1668     &lt;features&gt;
1669       &lt;cpuselection/&gt;
1670       &lt;deviceboot/&gt;
1671       &lt;disksnapshot default='on' toggle='no'/&gt;
1672       &lt;acpi default='on' toggle='yes'/&gt;
1673       &lt;apic default='on' toggle='no'/&gt;
1674       &lt;pae/&gt;
1675       &lt;nonpae/&gt;
1676     &lt;/features&gt;
1677   &lt;/guest&gt;
1678   &lt;guest&gt;
1679     &lt;os_type&gt;hvm&lt;/os_type&gt;
1680     &lt;arch name='x86_64'&gt;
1681       &lt;wordsize&gt;64&lt;/wordsize&gt;
1682       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
1683       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1684       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1685       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1686       &lt;domain type='qemu'/&gt;
1687       &lt;domain type='kvm'&gt;
1688         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1689         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1690         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1691         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1692       &lt;/domain&gt;
1693     &lt;/arch&gt;
1694     &lt;features&gt;
1695       &lt;cpuselection/&gt;
1696       &lt;deviceboot/&gt;
1697       &lt;disksnapshot default='on' toggle='no'/&gt;
1698       &lt;acpi default='on' toggle='yes'/&gt;
1699       &lt;apic default='on' toggle='no'/&gt;
1700     &lt;/features&gt;
1701   &lt;/guest&gt;
1702 &lt;/capabilities&gt;
1703         """
1704         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
1705         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
1706         defineMock = MagicMock(return_value=1)
1707         self.mock_conn.defineXML = defineMock
1708         mock_chmod = MagicMock()
1709         mock_run = MagicMock()
1710         with patch.dict(
1711             os.__dict__, {"chmod": mock_chmod, "makedirs": MagicMock()}
1712         ):  # pylint: disable=no-member
1713             with patch.dict(
1714                 virt.__salt__, {"cmd.run": mock_run}
1715             ):  # pylint: disable=no-member
1716                 virt.init(
1717                     "test vm", 2, 1234, nic=None, disk=None, seed=False, start=False
1718                 )
1719                 definition = defineMock.call_args_list[0][0][0]
1720                 self.assertFalse("&lt;interface" in definition)
1721                 self.assertFalse("&lt;disk" in definition)
1722                 defineMock.reset_mock()
1723                 mock_run.reset_mock()
1724                 boot = {
1725                     "kernel": "/root/f8-i386-vmlinuz",
1726                     "initrd": "/root/f8-i386-initrd",
1727                     "cmdline": "console=ttyS0 ks=http://example.com/f8-i386/os/",
1728                 }
1729                 retval = virt.init(
1730                     "test vm boot params",
1731                     2,
1732                     1234,
1733                     nic=None,
1734                     disk=None,
1735                     seed=False,
1736                     start=False,
1737                     boot=boot,
1738                 )
1739                 definition = defineMock.call_args_list[0][0][0]
1740                 self.assertEqual("&lt;kernel" in definition, True)
1741                 self.assertEqual("&lt;initrd" in definition, True)
1742                 self.assertEqual("&lt;cmdline" in definition, True)
1743                 self.assertEqual(retval, True)
1744                 mock_response = MagicMock()
1745                 mock_response.read = MagicMock(return_value="filecontent")
1746                 cache_dir = tempfile.mkdtemp()
1747                 with patch.dict(virt.__dict__, {"CACHE_DIR": cache_dir}):
1748                     with patch(
1749                         "urllib.request.urlopen",
1750                         MagicMock(return_value=mock_response),
1751                     ):
1752                         with patch(
1753                             "salt.utils.files.fopen", return_value=mock_response
1754                         ):
1755                             defineMock.reset_mock()
1756                             mock_run.reset_mock()
1757                             boot = {
1758                                 "kernel": "https://www.example.com/download/vmlinuz",
1759                                 "initrd": "",
1760                                 "cmdline": (
1761                                     "console=ttyS0 ks=http://example.com/f8-i386/os/"
1762                                 ),
1763                             }
1764                             retval = virt.init(
1765                                 "test remote vm boot params",
1766                                 2,
1767                                 1234,
1768                                 nic=None,
1769                                 disk=None,
1770                                 seed=False,
1771                                 start=False,
1772                                 boot=boot,
1773                             )
1774                             definition = defineMock.call_args_list[0][0][0]
1775                             self.assertEqual(cache_dir in definition, True)
1776                     shutil.rmtree(cache_dir)
1777                 defineMock.reset_mock()
1778                 mock_run.reset_mock()
1779                 pool_mock = MagicMock()
1780                 pool_mock.XMLDesc.return_value = '&lt;pool type="dir"/&gt;'
1781                 self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1782                 virt.init(
1783                     "test vm",
1784                     2,
1785                     1234,
1786                     nic=None,
1787                     disk=None,
1788                     disks=[
1789                         {"name": "system", "size": 10240},
1790                         {
1791                             "name": "cddrive",
1792                             "device": "cdrom",
1793                             "source_file": None,
1794                             "model": "ide",
1795                         },
1796                     ],
1797                     seed=False,
1798                     start=False,
1799                 )
1800                 definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1801                 expected_disk_path = os.path.join(root_dir, "test vm_system.qcow2")
1802                 self.assertEqual(
1803                     expected_disk_path,
1804                     definition.find("./devices/disk[1]/source").get("file"),
1805                 )
1806                 self.assertIsNone(definition.find("./devices/disk[2]/source"))
1807                 self.assertEqual(
1808                     mock_run.call_args[0][0],
1809                     'qemu-img create -f qcow2 "{}" 10240M'.format(expected_disk_path),
1810                 )
1811                 self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)
1812                 defineMock.reset_mock()
1813                 mock_run.reset_mock()
1814                 vol_mock = MagicMock()
1815                 pool_mock.storageVolLookupByName.return_value = vol_mock
1816                 pool_mock.listVolumes.return_value = ["test vm_data"]
1817                 stream_mock = MagicMock()
1818                 self.mock_conn.newStream.return_value = stream_mock
1819                 self.mock_conn.listStoragePools.return_value = ["default", "test"]
1820                 with patch.dict(
1821                     os.__dict__, {"open": MagicMock(), "close": MagicMock()}
1822                 ):
1823                     cache_mock = MagicMock()
1824                     with patch.dict(virt.__salt__, {"cp.cache_file": cache_mock}):
1825                         virt.init(
1826                             "test vm",
1827                             2,
1828                             1234,
1829                             nic=None,
1830                             disk=None,
1831                             disks=[
1832                                 {
1833                                     "name": "system",
1834                                     "size": 10240,
1835                                     "image": "/path/to/image",
1836                                     "pool": "test",
1837                                 },
1838                                 {"name": "data", "size": 10240, "pool": "default"},
1839                                 {
1840                                     "name": "test",
1841                                     "size": 1024,
1842                                     "pool": "default",
1843                                     "format": "qcow2",
1844                                     "backing_store_path": "/backing/path",
1845                                     "backing_store_format": "raw",
1846                                 },
1847                             ],
1848                             seed=False,
1849                             start=False,
1850                         )
1851                         definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1852                         self.assertTrue(
1853                             all(
1854                                 [
1855                                     disk.get("type") == "volume"
1856                                     for disk in definition.findall("./devices/disk")
1857                                 ]
1858                             )
1859                         )
1860                         self.assertEqual(
1861                             ["test", "default", "default"],
1862                             [
1863                                 src.get("pool")
1864                                 for src in definition.findall("./devices/disk/source")
1865                             ],
1866                         )
1867                         self.assertEqual(
1868                             ["test vm_system", "test vm_data", "test vm_test"],
1869                             [
1870                                 src.get("volume")
1871                                 for src in definition.findall("./devices/disk/source")
1872                             ],
1873                         )
1874                         create_calls = pool_mock.createXML.call_args_list
1875                         vol_names = [
1876                             ET.fromstring(call[0][0]).find("name").text
1877                             for call in create_calls
1878                         ]
1879                         self.assertEqual(
1880                             ["test vm_system", "test vm_test"],
1881                             vol_names,
1882                         )
1883                         stream_mock.sendAll.assert_called_once()
1884                         stream_mock.finish.assert_called_once()
1885                         vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
1886     def test_update_backing_store(self):
1887         xml = """
1888             &lt;domain type='kvm' id='7'&gt;
1889               &lt;name&gt;my_vm&lt;/name&gt;
1890               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1891               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1892               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1893               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
1894               &lt;os&gt;
1895                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1896               &lt;/os&gt;
1897               &lt;devices&gt;
1898                 &lt;disk type='volume' device='disk'&gt;
1899                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
1900                   &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
1901                   &lt;backingStore type='file' index='2'&gt;
1902                     &lt;format type='qcow2'/&gt;
1903                     &lt;source file='/path/to/base.qcow2'/&gt;
1904                     &lt;backingStore/&gt;
1905                   &lt;/backingStore&gt;
1906                   &lt;target dev='vda' bus='virtio'/&gt;
1907                   &lt;alias name='virtio-disk0'/&gt;
1908                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
1909                 &lt;/disk&gt;
1910               &lt;/devices&gt;
1911             &lt;/domain&gt;
1912         """
1913         domain_mock = self.set_mock_vm("my_vm", xml)
1914         domain_mock.OSType.return_value = "hvm"
1915         self.mock_conn.defineXML.return_value = True
1916         updatedev_mock = MagicMock(return_value=0)
1917         domain_mock.updateDeviceFlags = updatedev_mock
1918         self.mock_conn.listStoragePools.return_value = ["default"]
1919         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1920             "&lt;pool type='dir'/&gt;"
1921         )
1922         ret = virt.update(
1923             "my_vm",
1924             disks=[
1925                 {
1926                     "name": "system",
1927                     "pool": "default",
1928                     "backing_store_path": "/path/to/base.qcow2",
1929                     "backing_store_format": "qcow2",
1930                 },
1931             ],
1932         )
1933         self.assertFalse(ret["definition"])
1934         self.assertFalse(ret["disk"]["attached"])
1935         self.assertFalse(ret["disk"]["detached"])
1936     def test_update_removables(self):
1937         xml = """
1938             &lt;domain type='kvm' id='7'&gt;
1939               &lt;name&gt;my_vm&lt;/name&gt;
1940               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1941               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1942               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1943               &lt;os&gt;
1944                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1945               &lt;/os&gt;
1946               &lt;devices&gt;
1947                 &lt;disk type='network' device='cdrom'&gt;
1948                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1949                   &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
1950                     &lt;host name='test-srv.local' port='80'/&gt;
1951                   &lt;/source&gt;
1952                   &lt;backingStore/&gt;
1953                   &lt;target dev='hda' bus='ide'/&gt;
1954                   &lt;readonly/&gt;
1955                   &lt;alias name='ide0-0-0'/&gt;
1956                   &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
1957                 &lt;/disk&gt;
1958                 &lt;disk type='file' device='cdrom'&gt;
1959                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1960                   &lt;target dev='hdb' bus='ide'/&gt;
1961                   &lt;readonly/&gt;
1962                   &lt;alias name='ide0-0-1'/&gt;
1963                   &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
1964                 &lt;/disk&gt;
1965                 &lt;disk type='file' device='cdrom'&gt;
1966                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1967                   &lt;source file='/srv/dvd-image-2.iso'/&gt;
1968                   &lt;backingStore/&gt;
1969                   &lt;target dev='hdc' bus='ide'/&gt;
1970                   &lt;readonly/&gt;
1971                   &lt;alias name='ide0-0-2'/&gt;
1972                   &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
1973                 &lt;/disk&gt;
1974                 &lt;disk type='file' device='cdrom'&gt;
1975                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1976                   &lt;source file='/srv/dvd-image-3.iso'/&gt;
1977                   &lt;backingStore/&gt;
1978                   &lt;target dev='hdd' bus='ide'/&gt;
1979                   &lt;readonly/&gt;
1980                   &lt;alias name='ide0-0-3'/&gt;
1981                   &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
1982                 &lt;/disk&gt;
1983                 &lt;disk type='network' device='cdrom'&gt;
1984                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1985                   &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
1986                     &lt;host name='test-srv.local' port='80'/&gt;
1987                   &lt;/source&gt;
1988                   &lt;backingStore/&gt;
1989                   &lt;target dev='hde' bus='ide'/&gt;
1990                   &lt;readonly/&gt;
1991                 &lt;/disk&gt;
1992               &lt;/devices&gt;
1993             &lt;/domain&gt;
1994         """
1995         domain_mock = self.set_mock_vm("my_vm", xml)
1996         domain_mock.OSType.return_value = "hvm"
1997         self.mock_conn.defineXML.return_value = True
1998         updatedev_mock = MagicMock(return_value=0)
1999         domain_mock.updateDeviceFlags = updatedev_mock
2000         ret = virt.update(
2001             "my_vm",
2002             disks=[
2003                 {
2004                     "name": "dvd1",
2005                     "device": "cdrom",
2006                     "source_file": None,
2007                     "model": "ide",
2008                 },
2009                 {
2010                     "name": "dvd2",
2011                     "device": "cdrom",
2012                     "source_file": "/srv/dvd-image-4.iso",
2013                     "model": "ide",
2014                 },
2015                 {
2016                     "name": "dvd3",
2017                     "device": "cdrom",
2018                     "source_file": "/srv/dvd-image-2.iso",
2019                     "model": "ide",
2020                 },
2021                 {
2022                     "name": "dvd4",
2023                     "device": "cdrom",
2024                     "source_file": "/srv/dvd-image-5.iso",
2025                     "model": "ide",
2026                 },
2027                 {
2028                     "name": "dvd5",
2029                     "device": "cdrom",
2030                     "source_file": "/srv/dvd-image-6.iso",
2031                     "model": "ide",
2032                 },
2033             ],
2034         )
2035         self.assertTrue(ret["definition"])
2036         self.assertFalse(ret["disk"].get("attached"))
2037         self.assertFalse(ret["disk"].get("detached"))
2038         self.assertEqual(
2039             [
2040                 {
2041                     "type": "file",
2042                     "device": "cdrom",
2043                     "driver": {
2044                         "name": "qemu",
2045                         "type": "raw",
2046                         "cache": "none",
2047                         "io": "native",
2048                     },
2049                     "backingStore": None,
2050                     "target": {"dev": "hda", "bus": "ide"},
2051                     "readonly": None,
2052                     "alias": {"name": "ide0-0-0"},
2053                     "address": {
2054                         "type": "drive",
2055                         "controller": "0",
2056                         "bus": "0",
2057                         "target": "0",
2058                         "unit": "0",
2059                     },
2060                 },
2061                 {
2062                     "type": "file",
2063                     "device": "cdrom",
2064                     "driver": {
2065                         "name": "qemu",
2066                         "type": "raw",
2067                         "cache": "none",
2068                         "io": "native",
2069                     },
2070                     "target": {"dev": "hdb", "bus": "ide"},
2071                     "readonly": None,
2072                     "alias": {"name": "ide0-0-1"},
2073                     "address": {
2074                         "type": "drive",
2075                         "controller": "0",
2076                         "bus": "0",
2077                         "target": "0",
2078                         "unit": "1",
2079                     },
2080                     "source": {"file": "/srv/dvd-image-4.iso"},
2081                 },
2082                 {
2083                     "type": "file",
2084                     "device": "cdrom",
2085                     "driver": {
2086                         "name": "qemu",
2087                         "type": "raw",
2088                         "cache": "none",
2089                         "io": "native",
2090                     },
2091                     "backingStore": None,
2092                     "target": {"dev": "hdd", "bus": "ide"},
2093                     "readonly": None,
2094                     "alias": {"name": "ide0-0-3"},
2095                     "address": {
2096                         "type": "drive",
2097                         "controller": "0",
2098                         "bus": "0",
2099                         "target": "0",
2100                         "unit": "3",
2101                     },
2102                     "source": {"file": "/srv/dvd-image-5.iso"},
2103                 },
2104                 {
2105                     "type": "file",
2106                     "device": "cdrom",
2107                     "driver": {
2108                         "name": "qemu",
2109                         "type": "raw",
2110                         "cache": "none",
2111                         "io": "native",
2112                     },
2113                     "backingStore": None,
2114                     "target": {"dev": "hde", "bus": "ide"},
2115                     "readonly": None,
2116                     "source": {"file": "/srv/dvd-image-6.iso"},
2117                 },
2118             ],
2119             [
2120                 salt.utils.xmlutil.to_dict(ET.fromstring(disk), True)
2121                 for disk in ret["disk"]["updated"]
2122             ],
2123         )
2124     def test_update_xen_boot_params(self):
2125         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
2126         xml_boot = """
2127             &lt;domain type='xen' id='8'&gt;
2128               &lt;name&gt;vm&lt;/name&gt;
2129               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2130               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2131               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2132               &lt;os&gt;
2133                 &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
2134                 &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
2135               &lt;/os&gt;
2136             &lt;/domain&gt;
2137         """
2138         domain_mock_boot = self.set_mock_vm("vm", xml_boot)
2139         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2140         define_mock_boot = MagicMock(return_value=True)
2141         define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
2142         self.mock_conn.defineXML = define_mock_boot
2143         self.assertEqual(
2144             {
2145                 "cpu": False,
2146                 "definition": True,
2147                 "disk": {"attached": [], "detached": [], "updated": []},
2148                 "interface": {"attached": [], "detached": []},
2149             },
2150             virt.update("vm", cpu=2),
2151         )
2152         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2153         self.assertEqual(setxml.find("os").find("loader").attrib.get("type"), "rom")
2154         self.assertEqual(
2155             setxml.find("os").find("loader").text, "/usr/lib/xen/boot/hvmloader"
2156         )
2157     def test_update_existing_boot_params(self):
2158         xml_boot = """
2159             &lt;domain type='kvm' id='8'&gt;
2160               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2161               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2162               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2163               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2164               &lt;os&gt;
2165                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2166                 &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
2167                 &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
2168                 &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
2169                 &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
2170                 &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
2171               &lt;/os&gt;
2172             &lt;/domain&gt;
2173         """
2174         domain_mock_boot = self.set_mock_vm("vm_with_boot_param", xml_boot)
2175         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2176         define_mock_boot = MagicMock(return_value=True)
2177         self.mock_conn.defineXML = define_mock_boot
2178         boot_new = {
2179             "kernel": "/root/new-vmlinuz",
2180             "initrd": "/root/new-initrd",
2181             "cmdline": "console=ttyS0 ks=http://example.com/new/os/",
2182         }
2183         uefi_boot_new = {
2184             "loader": "/usr/share/new/OVMF_CODE.fd",
2185             "nvram": "/usr/share/new/OVMF_VARS.ms.fd",
2186         }
2187         self.assertEqual(
2188             {
2189                 "definition": True,
2190                 "disk": {"attached": [], "detached": [], "updated": []},
2191                 "interface": {"attached": [], "detached": []},
2192             },
2193             virt.update("vm_with_boot_param", boot=boot_new),
2194         )
2195         setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
2196         self.assertEqual(
2197             setxml_boot.find("os").find("kernel").text, "/root/new-vmlinuz"
2198         )
2199         self.assertEqual(setxml_boot.find("os").find("initrd").text, "/root/new-initrd")
2200         self.assertEqual(
2201             setxml_boot.find("os").find("cmdline").text,
2202             "console=ttyS0 ks=http://example.com/new/os/",
2203         )
2204         self.assertEqual(
2205             {
2206                 "definition": True,
2207                 "disk": {"attached": [], "detached": [], "updated": []},
2208                 "interface": {"attached": [], "detached": []},
2209             },
2210             virt.update("vm_with_boot_param", boot=uefi_boot_new),
2211         )
2212         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2213         self.assertEqual(
2214             setxml.find("os").find("loader").text, "/usr/share/new/OVMF_CODE.fd"
2215         )
2216         self.assertEqual(setxml.find("os").find("loader").attrib.get("readonly"), "yes")
2217         self.assertEqual(setxml.find("os").find("loader").attrib["type"], "pflash")
2218         self.assertEqual(
2219             setxml.find("os").find("nvram").attrib["template"],
2220             "/usr/share/new/OVMF_VARS.ms.fd",
2221         )
2222         kernel_none = {
2223             "kernel": None,
2224             "initrd": None,
2225             "cmdline": None,
2226         }
2227         uefi_none = {"loader": None, "nvram": None}
2228         self.assertEqual(
2229             {
2230                 "definition": True,
2231                 "disk": {"attached": [], "detached": [], "updated": []},
2232                 "interface": {"attached": [], "detached": []},
2233             },
2234             virt.update("vm_with_boot_param", boot=kernel_none),
2235         )
2236         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2237         self.assertEqual(setxml.find("os").find("kernel"), None)
2238         self.assertEqual(setxml.find("os").find("initrd"), None)
2239         self.assertEqual(setxml.find("os").find("cmdline"), None)
2240         self.assertEqual(
2241             {
2242                 "definition": True,
2243                 "disk": {"attached": [], "detached": [], "updated": []},
2244                 "interface": {"attached": [], "detached": []},
2245             },
2246             virt.update("vm_with_boot_param", boot={"efi": False}),
2247         )
2248         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2249         self.assertEqual(setxml.find("os").find("nvram"), None)
2250         self.assertEqual(setxml.find("os").find("loader"), None)
2251         self.assertEqual(
2252             {
2253                 "definition": True,
2254                 "disk": {"attached": [], "detached": [], "updated": []},
2255                 "interface": {"attached": [], "detached": []},
2256             },
2257             virt.update("vm_with_boot_param", boot=uefi_none),
2258         )
2259         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2260         self.assertEqual(setxml.find("os").find("loader"), None)
2261         self.assertEqual(setxml.find("os").find("nvram"), None)
2262     def test_update_existing_numatune_params(self):
2263         xml_numatune = """
2264             &lt;domain type='kvm' id='8'&gt;
2265               &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
2266               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2267               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2268               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
2269               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2270               &lt;numatune&gt;
2271                 &lt;memory mode="strict" nodeset="0-11"/&gt;
2272                 &lt;memnode cellid="1" mode="strict" nodeset="3"/&gt;
2273                 &lt;memnode cellid="3" mode="preferred" nodeset="7"/&gt;
2274               &lt;/numatune&gt;
2275               &lt;os&gt;
2276                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2277               &lt;/os&gt;
2278               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
2279             &lt;/domain&gt;
2280         """
2281         domain_mock = self.set_mock_vm("vm_with_numatune_param", xml_numatune)
2282         domain_mock.OSType = MagicMock(return_value="hvm")
2283         define_mock = MagicMock(return_value=True)
2284         self.mock_conn.defineXML = define_mock
2285         numatune = {
2286             "memory": {"mode": "preferred", "nodeset": "0-5"},
2287             "memnodes": {
2288                 0: {"mode": "strict", "nodeset": "4"},
2289                 3: {"mode": "preferred", "nodeset": "7"},
2290                 4: {"mode": "strict", "nodeset": "6"},
2291             },
2292         }
2293         self.assertEqual(
2294             {
2295                 "definition": True,
2296                 "disk": {"attached": [], "detached": [], "updated": []},
2297                 "interface": {"attached": [], "detached": []},
2298             },
2299             virt.update("vm_with_numatune_param", numatune=numatune),
2300         )
2301         setxml = ET.fromstring(define_mock.call_args[0][0])
2302         self.assertEqual(
2303             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2304         )
2305         self.assertEqual(
2306             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2307             ",".join([str(i) for i in range(0, 6)]),
2308         )
2309         self.assertEqual(
2310             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2311         )
2312         self.assertEqual(
2313             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2314         )
2315         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='1']"), None)
2316         self.assertEqual(
2317             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2318             "preferred",
2319         )
2320         self.assertEqual(
2321             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2322         )
2323         self.assertEqual(
2324             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("mode"), "strict"
2325         )
2326         self.assertEqual(
2327             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("nodeset"), "6"
2328         )
2329         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2330         numatune_mem_none = {
2331             "memory": None,
2332             "memnodes": {
2333                 0: {"mode": "strict", "nodeset": "4"},
2334                 3: {"mode": "preferred", "nodeset": "7"},
2335                 4: {"mode": "strict", "nodeset": "6"},
2336             },
2337         }
2338         self.assertEqual(
2339             {
2340                 "definition": True,
2341                 "disk": {"attached": [], "detached": [], "updated": []},
2342                 "interface": {"attached": [], "detached": []},
2343             },
2344             virt.update("vm_with_numatune_param", numatune=numatune_mem_none),
2345         )
2346         setxml = ET.fromstring(define_mock.call_args[0][0])
2347         self.assertEqual(setxml.find("numatune").find("memory"), None)
2348         self.assertEqual(
2349             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2350         )
2351         self.assertEqual(
2352             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2353         )
2354         self.assertEqual(
2355             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2356             "preferred",
2357         )
2358         self.assertEqual(
2359             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2360         )
2361         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2362         numatune_mnodes_none = {
2363             "memory": {"mode": "preferred", "nodeset": "0-5"},
2364             "memnodes": None,
2365         }
2366         self.assertEqual(
2367             {
2368                 "definition": True,
2369                 "disk": {"attached": [], "detached": [], "updated": []},
2370                 "interface": {"attached": [], "detached": []},
2371             },
2372             virt.update("vm_with_numatune_param", numatune=numatune_mnodes_none),
2373         )
2374         setxml = ET.fromstring(define_mock.call_args[0][0])
2375         self.assertEqual(
2376             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2377         )
2378         self.assertEqual(
2379             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2380             ",".join([str(i) for i in range(0, 6)]),
2381         )
2382         self.assertEqual(setxml.find("./numatune/memnode"), None)
2383         numatune_without_change = {
2384             "memory": {"mode": "strict", "nodeset": "0-5,6,7-11"},
2385             "memnodes": {
2386                 1: {"mode": "strict", "nodeset": "3"},
2387                 3: {"mode": "preferred", "nodeset": "7"},
2388             },
2389         }
2390         self.assertEqual(
2391             {
2392                 "definition": False,
2393                 "disk": {"attached": [], "detached": [], "updated": []},
2394                 "interface": {"attached": [], "detached": []},
2395             },
2396             virt.update("vm_with_numatune_param", numatune=numatune_without_change),
2397         )
2398         self.assertEqual(
2399             {
2400                 "definition": True,
2401                 "disk": {"attached": [], "detached": [], "updated": []},
2402                 "interface": {"attached": [], "detached": []},
2403             },
2404             virt.update(
2405                 "vm_with_numatune_param", numatune={"memory": None, "memnodes": None}
2406             ),
2407         )
2408         setxml = ET.fromstring(define_mock.call_args[0][0])
2409         self.assertEqual(setxml.find("numatune"), None)
2410     def test_update_existing_cpu_params(self):
2411         xml_with_existing_params = """
2412             &lt;domain type='kvm' id='8'&gt;
2413               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2414               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2415               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2416               &lt;vcpu placement="static" cpuset="0-11" current="3"&gt;6&lt;/vcpu&gt;
2417               &lt;vcpus&gt;
2418                 &lt;vcpu id="0" enabled="yes" hotpluggable="no" order="1"/&gt;
2419                 &lt;vcpu id="1" enabled="no" hotpluggable="yes"/&gt;
2420                 &lt;vcpu id="2" enabled="no" hotpluggable="yes"/&gt;
2421                 &lt;vcpu id="3" enabled="no" hotpluggable="yes"/&gt;
2422                 &lt;vcpu id="4" enabled="no" hotpluggable="yes"/&gt;
2423                 &lt;vcpu id="5" enabled="no" hotpluggable="yes"/&gt;
2424                 &lt;vcpu id="6" enabled="no" hotpluggable="yes"/&gt;
2425                 &lt;vcpu id="7" enabled="no" hotpluggable="yes"/&gt;
2426                 &lt;vcpu id="8" enabled="no" hotpluggable="yes"/&gt;
2427                 &lt;vcpu id="9" enabled="no" hotpluggable="yes"/&gt;
2428                 &lt;vcpu id="10" enabled="no" hotpluggable="yes"/&gt;
2429                 &lt;vcpu id="11" enabled="no" hotpluggable="yes"/&gt;
2430               &lt;/vcpus&gt;
2431               &lt;cpu mode="custom" match="exact" check="full"&gt;
2432                  &lt;model fallback="allow" vendor_id="Genuine20201"&gt;core2duo&lt;/model&gt;
2433                  &lt;vendor&gt;Intel&lt;/vendor&gt;
2434                  &lt;topology sockets="2" cores="5" threads="2"/&gt;
2435                  &lt;cache level="3" mode="emulate"/&gt;
2436                  &lt;feature policy="optional" name="lahf_lm"/&gt;
2437                  &lt;feature policy="require" name="pcid"/&gt;
2438                  &lt;numa&gt;
2439                     &lt;cell id="0" cpus="0-3" memory="1073741824" unit="KiB" discard="no"&gt;
2440                         &lt;distances&gt;
2441                             &lt;sibling id="0" value="10"/&gt;
2442                             &lt;sibling id="1" value="21"/&gt;
2443                             &lt;sibling id="2" value="31"/&gt;
2444                             &lt;sibling id="3" value="41"/&gt;
2445                         &lt;/distances&gt;
2446                     &lt;/cell&gt;
2447                     &lt;cell id="1" cpus="4-6" memory="1073741824" unit="KiB" memAccess="private"&gt;
2448                         &lt;distances&gt;
2449                             &lt;sibling id="0" value="21"/&gt;
2450                             &lt;sibling id="1" value="10"/&gt;
2451                             &lt;sibling id="2" value="21"/&gt;
2452                             &lt;sibling id="3" value="31"/&gt;
2453                         &lt;/distances&gt;
2454                     &lt;/cell&gt;
2455                  &lt;/numa&gt;
2456               &lt;/cpu&gt;
2457               &lt;os&gt;
2458                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2459               &lt;/os&gt;
2460               &lt;/domain&gt;
2461          """
2462         domain_mock = self.set_mock_vm(
2463             "vm_with_existing_param", xml_with_existing_params
2464         )
2465         domain_mock.OSType = MagicMock(return_value="hvm")
2466         define_mock = MagicMock(return_value=True)
2467         self.mock_conn.defineXML = define_mock
2468         setvcpus_mock = MagicMock(return_value=0)
2469         domain_mock.setVcpusFlags = setvcpus_mock
2470         cpu_attr = {"placement": "static", "cpuset": "0-5", "current": 3, "maximum": 5}
2471         self.assertEqual(
2472             {
2473                 "definition": True,
2474                 "cpu": True,
2475                 "disk": {"attached": [], "detached": [], "updated": []},
2476                 "interface": {"attached": [], "detached": []},
2477             },
2478             virt.update("vm_with_existing_param", cpu=cpu_attr),
2479         )
2480         setxml = ET.fromstring(define_mock.call_args[0][0])
2481         self.assertEqual(setxml.find("vcpu").text, "5")
2482         self.assertEqual(setxml.find("vcpu").attrib["placement"], "static")
2483         self.assertEqual(
2484             setxml.find("vcpu").attrib["cpuset"],
2485             ",".join([str(i) for i in range(0, 6)]),
2486         )
2487         self.assertEqual(setxml.find("vcpu").attrib["current"], "3")
2488         cpu_none = {"placement": "auto", "cpuset": None, "current": 2, "maximum": 5}
2489         self.assertEqual(
2490             {
2491                 "definition": True,
2492                 "cpu": True,
2493                 "disk": {"attached": [], "detached": [], "updated": []},
2494                 "interface": {"attached": [], "detached": []},
2495             },
2496             virt.update("vm_with_existing_param", cpu=cpu_none),
2497         )
2498         setxml = ET.fromstring(define_mock.call_args[0][0])
2499         self.assertEqual(setxml.find("vcpu").text, "5")
2500         self.assertEqual(setxml.find("vcpu").attrib["placement"], "auto")
2501         self.assertEqual(setxml.find("vcpu").attrib.get("cpuset"), None)
2502         self.assertEqual(setxml.find("vcpu").attrib.get("current"), "2")
2503         vcpus = {
2504             "vcpus": {
2505                 "0": {"enabled": False, "hotpluggable": True, "order": 5},
2506                 "3": {"enabled": True, "hotpluggable": False, "order": 3},
2507                 "7": {"enabled": True, "hotpluggable": False},
2508             }
2509         }
2510         self.assertEqual(
2511             {
2512                 "definition": True,
2513                 "disk": {"attached": [], "detached": [], "updated": []},
2514                 "interface": {"attached": [], "detached": []},
2515             },
2516             virt.update("vm_with_existing_param", cpu=vcpus),
2517         )
2518         setxml = ET.fromstring(define_mock.call_args[0][0])
2519         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["id"], "0")
2520         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["enabled"], "no")
2521         self.assertEqual(
2522             setxml.find("./vcpus/vcpu/[@id='0']").attrib["hotpluggable"], "yes"
2523         )
2524         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["order"], "5")
2525         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["id"], "3")
2526         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2527         self.assertEqual(
2528             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2529         )
2530         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["order"], "3")
2531         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["id"], "7")
2532         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["enabled"], "yes")
2533         self.assertEqual(
2534             setxml.find("./vcpus/vcpu/[@id='7']").attrib["hotpluggable"], "no"
2535         )
2536         self.assertEqual(
2537             setxml.find("./vcpus/vcpu/[@id='7']").attrib.get("order"), None
2538         )
2539         ind_vcpu = {
2540             "vcpus": {"3": {"enabled": True, "hotpluggable": False, "order": None}}
2541         }
2542         self.assertEqual(
2543             {
2544                 "definition": True,
2545                 "disk": {"attached": [], "detached": [], "updated": []},
2546                 "interface": {"attached": [], "detached": []},
2547             },
2548             virt.update("vm_with_existing_param", cpu=ind_vcpu),
2549         )
2550         setxml = ET.fromstring(define_mock.call_args[0][0])
2551         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']"), None)
2552         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2553         self.assertEqual(
2554             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2555         )
2556         self.assertEqual(
2557             setxml.find("./vcpus/vcpu/[@id='3']").attrib.get("order"), None
2558         )
2559         vcpus_none = {"vcpus": None}
2560         self.assertEqual(
2561             {
2562                 "definition": True,
2563                 "disk": {"attached": [], "detached": [], "updated": []},
2564                 "interface": {"attached": [], "detached": []},
2565             },
2566             virt.update("vm_with_existing_param", cpu=vcpus_none),
2567         )
2568         setxml = ET.fromstring(define_mock.call_args[0][0])
2569         self.assertEqual(setxml.find("vcpus"), None)
2570         cpu_atr_none = {"match": None, "mode": None, "check": None}
2571         self.assertEqual(
2572             {
2573                 "definition": True,
2574                 "disk": {"attached": [], "detached": [], "updated": []},
2575                 "interface": {"attached": [], "detached": []},
2576             },
2577             virt.update("vm_with_existing_param", cpu=cpu_atr_none),
2578         )
2579         setxml = ET.fromstring(define_mock.call_args[0][0])
2580         self.assertEqual(setxml.find("cpu").attrib, {})
2581         cpu_atr_mn = {"match": None}
2582         self.assertEqual(
2583             {
2584                 "definition": True,
2585                 "disk": {"attached": [], "detached": [], "updated": []},
2586                 "interface": {"attached": [], "detached": []},
2587             },
2588             virt.update("vm_with_existing_param", cpu=cpu_atr_mn),
2589         )
2590         setxml = ET.fromstring(define_mock.call_args[0][0])
2591         self.assertEqual(setxml.find("cpu").attrib.get("match"), None)
2592         self.assertEqual(setxml.find("cpu").attrib.get("mode"), "custom")
2593         self.assertEqual(setxml.find("cpu").attrib.get("check"), "full")
2594         cpu_model_none = {"model": None}
2595         self.assertEqual(
2596             {
2597                 "definition": True,
2598                 "disk": {"attached": [], "detached": [], "updated": []},
2599                 "interface": {"attached": [], "detached": []},
2600             },
2601             virt.update("vm_with_existing_param", cpu=cpu_model_none),
2602         )
2603         setxml = ET.fromstring(define_mock.call_args[0][0])
2604         self.assertEqual(setxml.find("cpu").find("model"), None)
2605         cpu_model_atr_none = {
2606             "model": {"name": "coresolo", "fallback": "forbid", "vendor_id": None}
2607         }
2608         self.assertEqual(
2609             {
2610                 "definition": True,
2611                 "disk": {"attached": [], "detached": [], "updated": []},
2612                 "interface": {"attached": [], "detached": []},
2613             },
2614             virt.update("vm_with_existing_param", cpu=cpu_model_atr_none),
2615         )
2616         setxml = ET.fromstring(define_mock.call_args[0][0])
2617         self.assertEqual(setxml.find("cpu").find("model").attrib.get("vendor_id"), None)
2618         self.assertEqual(
2619             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2620         )
2621         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2622         cpu_model_atr = {
2623             "model": {
2624                 "name": "coresolo",
2625                 "fallback": "forbid",
2626                 "vendor_id": "AuthenticAMD",
2627             }
2628         }
2629         self.assertEqual(
2630             {
2631                 "definition": True,
2632                 "disk": {"attached": [], "detached": [], "updated": []},
2633                 "interface": {"attached": [], "detached": []},
2634             },
2635             virt.update("vm_with_existing_param", cpu=cpu_model_atr),
2636         )
2637         setxml = ET.fromstring(define_mock.call_args[0][0])
2638         self.assertEqual(
2639             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2640         )
2641         self.assertEqual(
2642             setxml.find("cpu").find("model").attrib.get("vendor_id"), "AuthenticAMD"
2643         )
2644         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2645         cpu_vendor = {"vendor": "AMD"}
2646         self.assertEqual(
2647             {
2648                 "definition": True,
2649                 "disk": {"attached": [], "detached": [], "updated": []},
2650                 "interface": {"attached": [], "detached": []},
2651             },
2652             virt.update("vm_with_existing_param", cpu=cpu_vendor),
2653         )
2654         setxml = ET.fromstring(define_mock.call_args[0][0])
2655         self.assertEqual(setxml.find("cpu").find("vendor").text, "AMD")
2656         cpu_vendor_none = {"vendor": None}
2657         self.assertEqual(
2658             {
2659                 "definition": True,
2660                 "disk": {"attached": [], "detached": [], "updated": []},
2661                 "interface": {"attached": [], "detached": []},
2662             },
2663             virt.update("vm_with_existing_param", cpu=cpu_vendor_none),
2664         )
2665         setxml = ET.fromstring(define_mock.call_args[0][0])
2666         self.assertEqual(setxml.find("cpu").find("vendor"), None)
2667         cpu_topology = {"topology": {"sockets": 1, "cores": 12, "threads": 1}}
2668         self.assertEqual(
2669             {
2670                 "definition": True,
2671                 "disk": {"attached": [], "detached": [], "updated": []},
2672                 "interface": {"attached": [], "detached": []},
2673             },
2674             virt.update("vm_with_existing_param", cpu=cpu_topology),
2675         )
2676         setxml = ET.fromstring(define_mock.call_args[0][0])
2677         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("sockets"), "1")
2678         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2679         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2680         cpu_topology_atr_none = {
2681             "topology": {"sockets": None, "cores": 12, "threads": 1}
2682         }
2683         self.assertEqual(
2684             {
2685                 "definition": True,
2686                 "disk": {"attached": [], "detached": [], "updated": []},
2687                 "interface": {"attached": [], "detached": []},
2688             },
2689             virt.update("vm_with_existing_param", cpu=cpu_topology_atr_none),
2690         )
2691         setxml = ET.fromstring(define_mock.call_args[0][0])
2692         self.assertEqual(
2693             setxml.find("cpu").find("topology").attrib.get("sockets"), None
2694         )
2695         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2696         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2697         cpu_topology_none = {"topology": None}
2698         self.assertEqual(
2699             {
2700                 "definition": True,
2701                 "disk": {"attached": [], "detached": [], "updated": []},
2702                 "interface": {"attached": [], "detached": []},
2703             },
2704             virt.update("vm_with_existing_param", cpu=cpu_topology_none),
2705         )
2706         setxml = ET.fromstring(define_mock.call_args[0][0])
2707         self.assertEqual(setxml.find("cpu").find("topology"), None)
2708         cpu_cache = {"cache": {"mode": "passthrough", "level": 2}}
2709         self.assertEqual(
2710             {
2711                 "definition": True,
2712                 "disk": {"attached": [], "detached": [], "updated": []},
2713                 "interface": {"attached": [], "detached": []},
2714             },
2715             virt.update("vm_with_existing_param", cpu=cpu_cache),
2716         )
2717         setxml = ET.fromstring(define_mock.call_args[0][0])
2718         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), "2")
2719         self.assertEqual(
2720             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2721         )
2722         cpu_cache_atr_none = {"cache": {"mode": "passthrough", "level": None}}
2723         self.assertEqual(
2724             {
2725                 "definition": True,
2726                 "disk": {"attached": [], "detached": [], "updated": []},
2727                 "interface": {"attached": [], "detached": []},
2728             },
2729             virt.update("vm_with_existing_param", cpu=cpu_cache_atr_none),
2730         )
2731         setxml = ET.fromstring(define_mock.call_args[0][0])
2732         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), None)
2733         self.assertEqual(
2734             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2735         )
2736         cpu_cache_none = {"cache": None}
2737         self.assertEqual(
2738             {
2739                 "definition": True,
2740                 "disk": {"attached": [], "detached": [], "updated": []},
2741                 "interface": {"attached": [], "detached": []},
2742             },
2743             virt.update("vm_with_existing_param", cpu=cpu_cache_none),
2744         )
2745         setxml = ET.fromstring(define_mock.call_args[0][0])
2746         self.assertEqual(setxml.find("cpu").find("cache"), None)
2747         cpu_feature = {"features": {"lahf_lm": "require", "pcid": "optional"}}
2748         self.assertEqual(
2749             {
2750                 "definition": True,
2751                 "disk": {"attached": [], "detached": [], "updated": []},
2752                 "interface": {"attached": [], "detached": []},
2753             },
2754             virt.update("vm_with_existing_param", cpu=cpu_feature),
2755         )
2756         setxml = ET.fromstring(define_mock.call_args[0][0])
2757         self.assertEqual(
2758             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2759         )
2760         self.assertEqual(
2761             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2762             "require",
2763         )
2764         cpu_feature_atr_none = {"features": {"pcid": "optional", "lahf_lm": "disable"}}
2765         self.assertEqual(
2766             {
2767                 "definition": True,
2768                 "disk": {"attached": [], "detached": [], "updated": []},
2769                 "interface": {"attached": [], "detached": []},
2770             },
2771             virt.update("vm_with_existing_param", cpu=cpu_feature_atr_none),
2772         )
2773         setxml = ET.fromstring(define_mock.call_args[0][0])
2774         self.assertEqual(
2775             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2776             "disable",
2777         )
2778         self.assertEqual(
2779             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2780         )
2781         cpu_feature_none = {"features": {"lahf_lm": None, "pcid": None}}
2782         self.assertEqual(
2783             {
2784                 "definition": True,
2785                 "disk": {"attached": [], "detached": [], "updated": []},
2786                 "interface": {"attached": [], "detached": []},
2787             },
2788             virt.update("vm_with_existing_param", cpu=cpu_feature_none),
2789         )
2790         setxml = ET.fromstring(define_mock.call_args[0][0])
2791         self.assertEqual(setxml.find("./cpu/feature"), None)
2792         numa_cell = {
2793             "numa": {
2794                 0: {
2795                     "cpus": "0-6",
2796                     "memory": "512m",
2797                     "discard": True,
2798                     "distances": {0: 15, 1: 16, 2: 17, 3: 18},
2799                 },
2800                 1: {
2801                     "cpus": "7-12",
2802                     "memory": "2g",
2803                     "discard": True,
2804                     "memAccess": "shared",
2805                     "distances": {0: 23, 1: 24, 2: 25, 3: 26},
2806                 },
2807             }
2808         }
2809         self.assertEqual(
2810             {
2811                 "definition": True,
2812                 "disk": {"attached": [], "detached": [], "updated": []},
2813                 "interface": {"attached": [], "detached": []},
2814             },
2815             virt.update("vm_with_existing_param", cpu=numa_cell),
2816         )
2817         setxml = ET.fromstring(define_mock.call_args[0][0])
2818         self.assertEqual(
2819             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2820             ",".join([str(i) for i in range(0, 7)]),
2821         )
2822         self.assertEqual(
2823             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2824             str(512 * 1024 ** 2),
2825         )
2826         self.assertEqual(
2827             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2828             "bytes",
2829         )
2830         self.assertEqual(
2831             setxml.find("./cpu/numa/cell/[@id='0']").attrib["discard"], "yes"
2832         )
2833         self.assertEqual(
2834             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2835                 "value"
2836             ],
2837             "15",
2838         )
2839         self.assertEqual(
2840             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']").attrib[
2841                 "value"
2842             ],
2843             "16",
2844         )
2845         self.assertEqual(
2846             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2847                 "value"
2848             ],
2849             "17",
2850         )
2851         self.assertEqual(
2852             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2853                 "value"
2854             ],
2855             "18",
2856         )
2857         self.assertEqual(
2858             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2859             ",".join([str(i) for i in range(7, 13)]),
2860         )
2861         self.assertEqual(
2862             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2863             str(int(2 * 1024 ** 3)),
2864         )
2865         self.assertEqual(
2866             setxml.find("./cpu/numa/cell/[@id='1']").get("unit"),
2867             "bytes",
2868         )
2869         self.assertEqual(
2870             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2871         )
2872         self.assertEqual(
2873             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memAccess"], "shared"
2874         )
2875         self.assertEqual(
2876             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2877                 "value"
2878             ],
2879             "23",
2880         )
2881         self.assertEqual(
2882             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2883                 "value"
2884             ],
2885             "24",
2886         )
2887         self.assertEqual(
2888             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2889                 "value"
2890             ],
2891             "25",
2892         )
2893         self.assertEqual(
2894             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']").attrib[
2895                 "value"
2896             ],
2897             "26",
2898         )
2899         numa_cell_atr_none = {
2900             "numa": {
2901                 "0": {
2902                     "cpus": "0-6",
2903                     "memory": "512m",
2904                     "discard": False,
2905                     "distances": {0: 15, 2: 17, 3: 18},
2906                 },
2907                 "1": {
2908                     "cpus": "7-12",
2909                     "memory": "2g",
2910                     "discard": True,
2911                     "distances": {0: 23, 1: 24, 2: 25},
2912                 },
2913             }
2914         }
2915         self.assertEqual(
2916             {
2917                 "definition": True,
2918                 "disk": {"attached": [], "detached": [], "updated": []},
2919                 "interface": {"attached": [], "detached": []},
2920             },
2921             virt.update("vm_with_existing_param", cpu=numa_cell_atr_none),
2922         )
2923         setxml = ET.fromstring(define_mock.call_args[0][0])
2924         self.assertEqual(
2925             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2926             ",".join([str(i) for i in range(0, 7)]),
2927         )
2928         self.assertEqual(
2929             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2930             str(512 * 1024 ** 2),
2931         )
2932         self.assertEqual(
2933             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2934             "bytes",
2935         )
2936         self.assertEqual(
2937             setxml.find("./cpu/numa/cell/[@id='0']").attrib.get("discard"), "no"
2938         )
2939         self.assertEqual(
2940             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2941                 "value"
2942             ],
2943             "15",
2944         )
2945         self.assertEqual(
2946             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']"), None
2947         )
2948         self.assertEqual(
2949             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2950                 "value"
2951             ],
2952             "17",
2953         )
2954         self.assertEqual(
2955             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2956                 "value"
2957             ],
2958             "18",
2959         )
2960         self.assertEqual(
2961             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2962             ",".join([str(i) for i in range(7, 13)]),
2963         )
2964         self.assertEqual(
2965             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2966             str(int(2 * 1024 ** 3)),
2967         )
2968         self.assertEqual(
2969             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2970         )
2971         self.assertEqual(
2972             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2973                 "value"
2974             ],
2975             "23",
2976         )
2977         self.assertEqual(
2978             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2979                 "value"
2980             ],
2981             "24",
2982         )
2983         self.assertEqual(
2984             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2985                 "value"
2986             ],
2987             "25",
2988         )
2989         self.assertEqual(
2990             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"), None
2991         )
2992         self.assertEqual(
2993             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2994             ",".join([str(i) for i in range(7, 13)]),
2995         )
2996         self.assertEqual(
2997             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2998             str(int(1024 ** 3 * 2)),
2999         )
3000         self.assertEqual(
3001             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
3002         )
3003         self.assertEqual(
3004             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
3005                 "value"
3006             ],
3007             "23",
3008         )
3009         self.assertEqual(
3010             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3011                 "value"
3012             ],
3013             "24",
3014         )
3015         self.assertEqual(
3016             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3017                 "value"
3018             ],
3019             "25",
3020         )
3021         self.assertEqual(
3022             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"),
3023             None,
3024         )
3025     def test_update_memtune_params(self):
3026         xml_with_memtune_params = """
3027             &lt;domain type='kvm' id='8'&gt;
3028               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
3029               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3030               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3031               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
3032               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3033               &lt;memtune&gt;
3034                 &lt;hard_limit unit="KiB"&gt;1048576&lt;/hard_limit&gt;
3035                 &lt;soft_limit unit="KiB"&gt;2097152&lt;/soft_limit&gt;
3036                 &lt;swap_hard_limit unit="KiB"&gt;2621440&lt;/swap_hard_limit&gt;
3037                 &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
3038               &lt;/memtune&gt;
3039               &lt;os&gt;
3040                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3041               &lt;/os&gt;
3042             &lt;/domain&gt;
3043         """
3044         domain_mock = self.set_mock_vm("vm_with_memtune_param", xml_with_memtune_params)
3045         domain_mock.OSType = MagicMock(return_value="hvm")
3046         define_mock = MagicMock(return_value=True)
3047         self.mock_conn.defineXML = define_mock
3048         memtune_new_val = {
3049             "boot": "0.7g",
3050             "current": "2.5g",
3051             "max": "3096m",
3052             "slots": "10",
3053             "soft_limit": "2048m",
3054             "hard_limit": "1024",
3055             "swap_hard_limit": "2.5g",
3056             "min_guarantee": "1 g",
3057         }
3058         domain_mock.setMemoryFlags.return_value = 0
3059         self.assertEqual(
3060             {
3061                 "definition": True,
3062                 "disk": {"attached": [], "detached": [], "updated": []},
3063                 "interface": {"attached": [], "detached": []},
3064                 "mem": True,
3065             },
3066             virt.update("vm_with_memtune_param", mem=memtune_new_val),
3067         )
3068         self.assertEqual(
3069             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3070         )
3071         setxml = ET.fromstring(define_mock.call_args[0][0])
3072         self.assertEqual(
3073             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3074         )
3075         self.assertEqual(
3076             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3077         )
3078         self.assertEqual(
3079             setxml.find("memtune").find("swap_hard_limit").text,
3080             str(int(2.5 * 1024 ** 2)),
3081         )
3082         self.assertEqual(
3083             setxml.find("memtune").find("swap_hard_limit").get("unit"),
3084             "KiB",
3085         )
3086         self.assertEqual(
3087             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3088         )
3089         self.assertEqual(
3090             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3091         )
3092         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3093         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3094         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3095         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3096         max_slot_reverse = {
3097             "slots": "10",
3098             "max": "3096m",
3099         }
3100         self.assertEqual(
3101             {
3102                 "definition": True,
3103                 "disk": {"attached": [], "detached": [], "updated": []},
3104                 "interface": {"attached": [], "detached": []},
3105             },
3106             virt.update("vm_with_memtune_param", mem=max_slot_reverse),
3107         )
3108         setxml = ET.fromstring(define_mock.call_args[0][0])
3109         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3110         self.assertEqual(setxml.find("maxMemory").get("unit"), "bytes")
3111         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3112         max_swap_none = {
3113             "boot": "0.7g",
3114             "current": "2.5g",
3115             "max": None,
3116             "slots": "10",
3117             "soft_limit": "2048m",
3118             "hard_limit": "1024",
3119             "swap_hard_limit": None,
3120             "min_guarantee": "1 g",
3121         }
3122         domain_mock.setMemoryFlags.reset_mock()
3123         self.assertEqual(
3124             {
3125                 "definition": True,
3126                 "disk": {"attached": [], "detached": [], "updated": []},
3127                 "interface": {"attached": [], "detached": []},
3128                 "mem": True,
3129             },
3130             virt.update("vm_with_memtune_param", mem=max_swap_none),
3131         )
3132         self.assertEqual(
3133             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3134         )
3135         setxml = ET.fromstring(define_mock.call_args[0][0])
3136         self.assertEqual(
3137             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3138         )
3139         self.assertEqual(
3140             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3141         )
3142         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3143         self.assertEqual(
3144             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3145         )
3146         self.assertEqual(
3147             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3148         )
3149         self.assertEqual(setxml.find("maxMemory").text, None)
3150         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3151         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3152         memtune_none = {
3153             "soft_limit": None,
3154             "hard_limit": None,
3155             "swap_hard_limit": None,
3156             "min_guarantee": None,
3157         }
3158         self.assertEqual(
3159             {
3160                 "definition": True,
3161                 "disk": {"attached": [], "detached": [], "updated": []},
3162                 "interface": {"attached": [], "detached": []},
3163             },
3164             virt.update("vm_with_memtune_param", mem=memtune_none),
3165         )
3166         setxml = ET.fromstring(define_mock.call_args[0][0])
3167         self.assertEqual(setxml.find("memtune").find("soft_limit"), None)
3168         self.assertEqual(setxml.find("memtune").find("hard_limit"), None)
3169         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3170         self.assertEqual(setxml.find("memtune").find("min_guarantee"), None)
3171         max_none = {
3172             "max": None,
3173         }
3174         self.assertEqual(
3175             {
3176                 "definition": True,
3177                 "disk": {"attached": [], "detached": [], "updated": []},
3178                 "interface": {"attached": [], "detached": []},
3179             },
3180             virt.update("vm_with_memtune_param", mem=max_none),
3181         )
3182         setxml = ET.fromstring(define_mock.call_args[0][0])
3183         self.assertEqual(setxml.find("maxMemory"), None)
3184         self.assertEqual(setxml.find("currentMemory").text, str(int(1 * 1024 ** 2)))
3185         self.assertEqual(setxml.find("memory").text, str(int(1 * 1024 ** 2)))
3186     def test_update_exist_memorybacking_params(self):
3187         xml_with_memback_params = """
3188             &lt;domain type='kvm' id='8'&gt;
3189               &lt;name&gt;vm_with_memback_param&lt;/name&gt;
3190               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3191               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3192               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3193               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3194               &lt;memoryBacking&gt;
3195                 &lt;hugepages&gt;
3196                   &lt;page size="2048" unit="KiB"/&gt;
3197                   &lt;page size="3145728" nodeset="1-4,^3" unit="KiB"/&gt;
3198                   &lt;page size="1048576" nodeset="3" unit="KiB"/&gt;
3199                 &lt;/hugepages&gt;
3200                 &lt;nosharepages/&gt;
3201                 &lt;locked/&gt;
3202                 &lt;source type="file"/&gt;
3203                 &lt;access mode="shared"/&gt;
3204                 &lt;discard/&gt;
3205               &lt;/memoryBacking&gt;
3206               &lt;os&gt;
3207                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3208               &lt;/os&gt;
3209               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
3210             &lt;/domain&gt;
3211         """
3212         domain_mock = self.set_mock_vm("vm_with_memback_param", xml_with_memback_params)
3213         domain_mock.OSType = MagicMock(return_value="hvm")
3214         define_mock = MagicMock(return_value=True)
3215         self.mock_conn.defineXML = define_mock
3216         mem_back_param = {
3217             "hugepages": [
3218                 {"nodeset": "1-4,^3", "size": "1g"},
3219                 {"nodeset": "3", "size": "2g"},
3220             ],
3221             "nosharepages": None,
3222             "locked": None,
3223             "source": "anonymous",
3224             "access": "private",
3225             "allocation": "ondemand",
3226             "discard": None,
3227         }
3228         self.assertEqual(
3229             {
3230                 "definition": True,
3231                 "disk": {"attached": [], "detached": [], "updated": []},
3232                 "interface": {"attached": [], "detached": []},
3233             },
3234             virt.update("vm_with_memback_param", mem=mem_back_param),
3235         )
3236         setxml = ET.fromstring(define_mock.call_args[0][0])
3237         self.assertDictEqual(
3238             {
3239                 p.get("nodeset"): {"size": p.get("size"), "unit": p.get("unit")}
3240                 for p in setxml.findall("memoryBacking/hugepages/page")
3241             },
3242             {
3243                 "1,2,4": {"size": str(1024 ** 3), "unit": "bytes"},
3244                 "3": {"size": str(2 * 1024 ** 3), "unit": "bytes"},
3245             },
3246         )
3247         self.assertEqual(setxml.find("./memoryBacking/nosharepages"), None)
3248         self.assertEqual(setxml.find("./memoryBacking/locked"), None)
3249         self.assertEqual(
3250             setxml.find("./memoryBacking/source").attrib["type"], "anonymous"
3251         )
3252         self.assertEqual(
3253             setxml.find("./memoryBacking/access").attrib["mode"], "private"
3254         )
3255         self.assertEqual(
3256             setxml.find("./memoryBacking/allocation").attrib["mode"], "ondemand"
3257         )
3258         self.assertEqual(setxml.find("./memoryBacking/discard"), None)
3259         unchanged_page = {
3260             "hugepages": [
3261                 {"size": "2m"},
3262                 {"nodeset": "1-4,^3", "size": "3g"},
3263                 {"nodeset": "3", "size": "1g"},
3264             ],
3265         }
3266         self.assertEqual(
3267             {
3268                 "definition": False,
3269                 "disk": {"attached": [], "detached": [], "updated": []},
3270                 "interface": {"attached": [], "detached": []},
3271             },
3272             virt.update("vm_with_memback_param", mem=unchanged_page),
3273         )
3274     def test_update_iothreads_params(self):
3275         xml_with_iothreads_params = """
3276             &lt;domain type='kvm' id='8'&gt;
3277               &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
3278               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3279               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3280               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3281               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3282               &lt;iothreads&gt;6&lt;/iothreads&gt;
3283               &lt;os&gt;
3284                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3285               &lt;/os&gt;
3286             &lt;/domain&gt;
3287         """
3288         domain_mock = self.set_mock_vm(
3289             "xml_with_iothreads_params", xml_with_iothreads_params
3290         )
3291         domain_mock.OSType = MagicMock(return_value="hvm")
3292         define_mock = MagicMock(return_value=True)
3293         self.mock_conn.defineXML = define_mock
3294         self.assertEqual(
3295             {
3296                 "definition": True,
3297                 "disk": {"attached": [], "detached": [], "updated": []},
3298                 "interface": {"attached": [], "detached": []},
3299             },
3300             virt.update("xml_with_iothreads_params", cpu={"iothreads": 7}),
3301         )
3302         setxml = ET.fromstring(define_mock.call_args[0][0])
3303         self.assertEqual(setxml.find("iothreads").text, "7")
3304     def test_update_cputune_paramters(self):
3305         xml_with_cputune_params = """
3306                     &lt;domain type='kvm' id='8'&gt;
3307                       &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
3308                       &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3309                       &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3310                       &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3311                       &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3312                       &lt;iothreads&gt;4&lt;/iothreads&gt;
3313                       &lt;cputune&gt;
3314                         &lt;shares&gt;2048&lt;/shares&gt;
3315                         &lt;period&gt;1000000&lt;/period&gt;
3316                         &lt;quota&gt;-1&lt;/quota&gt;
3317                         &lt;global_period&gt;1000000&lt;/global_period&gt;
3318                         &lt;global_quota&gt;-1&lt;/global_quota&gt;
3319                         &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
3320                         &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
3321                         &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
3322                         &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
3323                         &lt;vcpupin vcpu="0" cpuset="0-2"/&gt;
3324                         &lt;vcpupin vcpu="1" cpuset="3"/&gt;
3325                         &lt;vcpupin vcpu="2" cpuset="4"/&gt;
3326                         &lt;vcpupin vcpu="3" cpuset="5-7"/&gt;
3327                         &lt;emulatorpin cpuset="1-2"/&gt;
3328                         &lt;iothreadpin iothread="1" cpuset="1-5"/&gt;
3329                         &lt;iothreadpin iothread="2" cpuset="6-7"/&gt;
3330                         &lt;vcpusched vcpus="0" scheduler="idle" priority="3"/&gt;
3331                         &lt;vcpusched vcpus="1" scheduler="rr" priority="1"/&gt;
3332                         &lt;vcpusched vcpus="2" scheduler="fifo" priority="2"/&gt;
3333                         &lt;iothreadsched iothreads="4" scheduler="fifo"/&gt;
3334                         &lt;emulatorsched scheduler="idle"/&gt;
3335                         &lt;cachetune vcpus="0-4"&gt;
3336                           &lt;cache id="0" level="2" type="both" size="4" unit="KiB"/&gt;
3337                           &lt;cache id="1" level="2" type="both" size="4" unit="KiB"/&gt;
3338                           &lt;monitor level="5" vcpus="0-2"/&gt;
3339                           &lt;monitor level="6" vcpus="1-3"/&gt;
3340                         &lt;/cachetune&gt;
3341                         &lt;cachetune vcpus="5-8"&gt;
3342                           &lt;monitor level="5" vcpus="5-6"/&gt;
3343                           &lt;monitor level="3" vcpus="7-8"/&gt;
3344                         &lt;/cachetune&gt;
3345                         &lt;memorytune vcpus="0-6"&gt;
3346                           &lt;node id="0" bandwidth="45"/&gt;
3347                         &lt;/memorytune&gt;
3348                         &lt;memorytune vcpus="7-8"&gt;
3349                           &lt;node id="0" bandwidth="120"/&gt;
3350                         &lt;/memorytune&gt;
3351                       &lt;/cputune&gt;
3352                       &lt;os&gt;
3353                         &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3354                       &lt;/os&gt;
3355                     &lt;/domain&gt;
3356                 """
3357         domain_mock = self.set_mock_vm(
3358             "xml_with_cputune_params", xml_with_cputune_params
3359         )
3360         domain_mock.OSType = MagicMock(return_value="hvm")
3361         define_mock = MagicMock(return_value=True)
3362         self.mock_conn.defineXML = define_mock
3363         cputune = {
3364             "shares": 1024,
3365             "period": 5000,
3366             "quota": -20,
3367             "global_period": 4000,
3368             "global_quota": -30,
3369             "emulator_period": 3000,
3370             "emulator_quota": -4,
3371             "iothread_period": 7000,
3372             "iothread_quota": -5,
3373             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
3374             "emulatorpin": "1-3",
3375             "iothreadpin": {1: "5-6", 2: "7-8"},
3376             "vcpusched": [
3377                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
3378                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
3379                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
3380             ],
3381             "iothreadsched": [
3382                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1}
3383             ],
3384             "emulatorsched": {"scheduler": "rr", "priority": 2},
3385             "cachetune": {
3386                 "0-3": {
3387                     0: {"level": 3, "type": "both", "size": 3},
3388                     1: {"level": 3, "type": "both", "size": 3},
3389                     "monitor": {1: 3, "0-3": 3},
3390                 },
3391                 "4-5": {"monitor": {4: 3, 5: 2}},
3392             },
3393             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
3394         }
3395         self.assertEqual(
3396             {
3397                 "definition": True,
3398                 "disk": {"attached": [], "detached": [], "updated": []},
3399                 "interface": {"attached": [], "detached": []},
3400             },
3401             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3402         )
3403         setxml = ET.fromstring(define_mock.call_args[0][0])
3404         self.assertEqual(setxml.find("cputune").find("shares").text, "1024")
3405         self.assertEqual(setxml.find("cputune").find("period").text, "5000")
3406         self.assertEqual(setxml.find("cputune").find("quota").text, "-20")
3407         self.assertEqual(setxml.find("cputune").find("global_period").text, "4000")
3408         self.assertEqual(setxml.find("cputune").find("global_quota").text, "-30")
3409         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "3000")
3410         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3411         self.assertEqual(setxml.find("cputune").find("iothread_period").text, "7000")
3412         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3413         self.assertEqual(
3414             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3415             "1,3,4",
3416         )
3417         self.assertEqual(
3418             setxml.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
3419             "0,1",
3420         )
3421         self.assertEqual(
3422             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3423             "2,3",
3424         )
3425         self.assertEqual(
3426             setxml.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
3427             "0,4",
3428         )
3429         self.assertEqual(
3430             setxml.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1,2,3"
3431         )
3432         self.assertEqual(
3433             setxml.find("cputune")
3434             .find("iothreadpin[@iothread='1']")
3435             .attrib.get("cpuset"),
3436             "5,6",
3437         )
3438         self.assertEqual(
3439             setxml.find("cputune")
3440             .find("iothreadpin[@iothread='2']")
3441             .attrib.get("cpuset"),
3442             "7,8",
3443         )
3444         self.assertDictEqual(
3445             {
3446                 s.get("vcpus"): {
3447                     "scheduler": s.get("scheduler"),
3448                     "priority": s.get("priority"),
3449                 }
3450                 for s in setxml.findall("cputune/vcpusched")
3451             },
3452             {
3453                 "0": {"scheduler": "fifo", "priority": "1"},
3454                 "1": {"scheduler": "fifo", "priority": "2"},
3455                 "2": {"scheduler": "idle", "priority": "3"},
3456             },
3457         )
3458         self.assertDictEqual(
3459             {
3460                 s.get("iothreads"): {
3461                     "scheduler": s.get("scheduler"),
3462                     "priority": s.get("priority"),
3463                 }
3464                 for s in setxml.findall("cputune/iothreadsched")
3465             },
3466             {"5,6,7": {"scheduler": "batch", "priority": "1"}},
3467         )
3468         self.assertEqual(setxml.find("cputune/emulatorsched").get("scheduler"), "rr")
3469         self.assertEqual(setxml.find("cputune/emulatorsched").get("priority"), "2")
3470         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3471         self.assertEqual(
3472             setxml.find(
3473                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3474             ).attrib.get("level"),
3475             "3",
3476         )
3477         self.assertEqual(
3478             setxml.find(
3479                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3480             ).attrib.get("type"),
3481             "both",
3482         )
3483         self.assertEqual(
3484             setxml.find(
3485                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"
3486             ).attrib.get("level"),
3487             "3",
3488         )
3489         self.assertNotEqual(
3490             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"),
3491             None,
3492         )
3493         self.assertNotEqual(
3494             setxml.find("./cputune/cachetune[@vcpus='4,5']").attrib.get("vcpus"), None
3495         )
3496         self.assertEqual(
3497             setxml.find("./cputune/cachetune[@vcpus='4,5']/cache[@id='0']"), None
3498         )
3499         self.assertEqual(
3500             setxml.find(
3501                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']"
3502             ).attrib.get("level"),
3503             "3",
3504         )
3505         self.assertEqual(
3506             setxml.find(
3507                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']"
3508             ).attrib.get("level"),
3509             "2",
3510         )
3511         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3512         self.assertEqual(
3513             setxml.find(
3514                 "./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']"
3515             ).attrib.get("bandwidth"),
3516             "60",
3517         )
3518         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='3,4']"), None)
3519         self.assertEqual(
3520             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3521                 "bandwidth"
3522             ),
3523             "50",
3524         )
3525         self.assertEqual(
3526             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3527                 "bandwidth"
3528             ),
3529             "70",
3530         )
3531         cputune = {
3532             "shares": None,
3533             "period": 20000,
3534             "quota": None,
3535             "global_period": 5000,
3536             "global_quota": None,
3537             "emulator_period": 2000,
3538             "emulator_quota": -4,
3539             "iothread_period": None,
3540             "iothread_quota": -5,
3541             "vcpupin": {0: "1-4,^2", 2: "2,4"},
3542             "emulatorpin": None,
3543             "iothreadpin": {1: "5-6"},
3544             "vcpusched": [{"scheduler": "idle", "priority": 5, "vcpus": "1"}],
3545             "iothreadsched": None,
3546             "cachetune": {
3547                 "0-3": {
3548                     0: {"level": 4, "type": "data", "size": 7},
3549                     "monitor": {"1-2": 11},
3550                 },
3551             },
3552             "memorytune": {"3-4": {0: 37, 1: 73}},
3553         }
3554         self.assertEqual(
3555             {
3556                 "definition": True,
3557                 "disk": {"attached": [], "detached": [], "updated": []},
3558                 "interface": {"attached": [], "detached": []},
3559             },
3560             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3561         )
3562         setxml = ET.fromstring(define_mock.call_args[0][0])
3563         self.assertEqual(setxml.find("cputune").find("shares"), None)
3564         self.assertEqual(setxml.find("cputune").find("period").text, "20000")
3565         self.assertEqual(setxml.find("cputune").find("quota"), None)
3566         self.assertEqual(setxml.find("cputune").find("global_period").text, "5000")
3567         self.assertEqual(setxml.find("cputune").find("global_quota"), None)
3568         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "2000")
3569         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3570         self.assertEqual(setxml.find("cputune").find("iothread_period"), None)
3571         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3572         self.assertEqual(
3573             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3574             "1,3,4",
3575         )
3576         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='1']"), None)
3577         self.assertEqual(
3578             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3579             "2,4",
3580         )
3581         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='3']"), None)
3582         self.assertEqual(setxml.find("cputune").find("emulatorpin"), None)
3583         self.assertEqual(
3584             setxml.find("cputune")
3585             .find("iothreadpin[@iothread='1']")
3586             .attrib.get("cpuset"),
3587             "5,6",
3588         )
3589         self.assertEqual(
3590             setxml.find("cputune").find("iothreadpin[@iothread='2']"), None
3591         )
3592         self.assertDictEqual(
3593             {
3594                 s.get("vcpus"): {
3595                     "scheduler": s.get("scheduler"),
3596                     "priority": s.get("priority"),
3597                 }
3598                 for s in setxml.findall("cputune/vcpusched")
3599             },
3600             {"1": {"scheduler": "idle", "priority": "5"}},
3601         )
3602         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3603         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3604         self.assertEqual(
3605             setxml.find(
3606                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3607             ).attrib.get("size"),
3608             "7",
3609         )
3610         self.assertEqual(
3611             setxml.find(
3612                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3613             ).attrib.get("level"),
3614             "4",
3615         )
3616         self.assertEqual(
3617             setxml.find(
3618                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3619             ).attrib.get("type"),
3620             "data",
3621         )
3622         self.assertEqual(
3623             setxml.find(
3624                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']"
3625             ).attrib.get("level"),
3626             "11",
3627         )
3628         self.assertEqual(
3629             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']"),
3630             None,
3631         )
3632         self.assertEqual(
3633             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']"), None
3634         )
3635         self.assertEqual(setxml.find("./cputune/cachetune[@vcpus='4,5']"), None)
3636         self.assertEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3637         self.assertEqual(
3638             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3639                 "bandwidth"
3640             ),
3641             "37",
3642         )
3643         self.assertEqual(
3644             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3645                 "bandwidth"
3646             ),
3647             "73",
3648         )
3649         cputune_subelement = {
3650             "vcpupin": None,
3651             "iothreadpin": None,
3652             "vcpusched": None,
3653             "iothreadsched": None,
3654             "cachetune": None,
3655             "memorytune": None,
3656         }
3657         self.assertEqual(
3658             {
3659                 "definition": True,
3660                 "disk": {"attached": [], "detached": [], "updated": []},
3661                 "interface": {"attached": [], "detached": []},
3662             },
3663             virt.update("xml_with_cputune_params", cpu={"tuning": cputune_subelement}),
3664         )
3665         setxml = ET.fromstring(define_mock.call_args[0][0])
3666         self.assertEqual(setxml.find("cputune").find("vcpupin"), None)
3667         self.assertEqual(setxml.find("cputune").find("iothreadpin"), None)
3668         self.assertEqual(setxml.find("cputune").find("vcpusched"), None)
3669         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3670         self.assertEqual(setxml.find("cputune").find("cachetune"), None)
3671         self.assertEqual(setxml.find("cputune").find("memorytune"), None)
3672     def test_handle_unit(self):
3673         valid_case = [
3674             ("2", 2097152),
3675             ("42", 44040192),
3676             ("5b", 5),
3677             ("2.3Kib", 2355),
3678             ("5.8Kb", 5800),
3679             ("16MiB", 16777216),
3680             ("20 GB", 20000000000),
3681             ("16KB", 16000),
3682             (".5k", 512),
3683             ("2.k", 2048),
3684         ]
3685         for key, val in valid_case:
3686             self.assertEqual(virt._handle_unit(key), val)
3687         invalid_case = [
3688             ("9ib", "invalid units"),
3689             ("8byte", "invalid units"),
3690             ("512bytes", "invalid units"),
3691             ("4 Kbytes", "invalid units"),
3692             ("3.4.MB", "invalid number"),
3693             ("", "invalid number"),
3694             ("bytes", "invalid number"),
3695             ("2HB", "invalid units"),
3696         ]
3697         for key, val in invalid_case:
3698             with self.assertRaises(SaltInvocationError):
3699                 virt._handle_unit(key)
3700     def test_mixed_dict_and_list_as_profile_objects(self):
3701         yaml_config = """
3702           virt:
3703              nic:
3704                 new-listonly-profile:
3705                    - bridge: br0
3706                      name: eth0
3707                    - model: virtio
3708                      name: eth1
3709                      source: test_network
3710                      type: network
3711                 new-list-with-legacy-names:
3712                    - eth0:
3713                         bridge: br0
3714                    - eth1:
3715                         bridge: br1
3716                         model: virtio
3717                 non-default-legacy-profile:
3718                    eth0:
3719                       bridge: br0
3720                    eth1:
3721                       bridge: br1
3722                       model: virtio
3723         Test virt.get_xml()
3724         domain = self.set_mock_vm("test-vm", xml)
3725         self.assertEqual(xml, virt.get_xml("test-vm"))
3726         self.assertEqual(xml, virt.get_xml(domain))
3727     def test_get_loader(self):
3728         xml = """&lt;domain type='kvm' id='7'&gt;
3729               &lt;name&gt;test-vm&lt;/name&gt;
3730               &lt;os&gt;
3731                 &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
3732               &lt;/os&gt;
3733             &lt;/domain&gt;
3734         """
3735         self.set_mock_vm("test-vm", xml)
3736         loader = virt.get_loader("test-vm")
3737         self.assertEqual("/foo/bar", loader["path"])
3738         self.assertEqual("yes", loader["readonly"])
3739     def test_cpu_baseline(self):
3740         capabilities_xml = dedent(
3741         Make sure that qemu-img info output is properly parsed
3742         Test virt.purge() with default parameters
3743         self.set_mock_vm("test-vm", xml)
3744         qemu_infos = """[{
3745             "virtual-size": 25769803776,
3746             "filename": "/disks/test.qcow2",
3747             "cluster-size": 65536,
3748             "format": "qcow2",
3749             "actual-size": 217088,
3750             "format-specific": {
3751                 "type": "qcow2",
3752                 "data": {
3753                     "compat": "1.1",
3754                     "lazy-refcounts": false,
3755                     "refcount-bits": 16,
3756                     "corrupt": false
3757                 }
3758             },
3759             "dirty-flag": false
3760         }]"""
3761         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3762         self.mock_popen.returncode = 0
3763         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3764             res = virt.purge("test-vm")
3765             self.assertTrue(res)
3766             mock_remove.assert_called_once()
3767             mock_remove.assert_any_call("/disks/test.qcow2")
3768     @patch("salt.modules.virt.stop", return_value=True)
3769     @patch("salt.modules.virt.undefine")
3770     def test_purge_volumes(self, mock_undefine, mock_stop):
3771         xml = """&lt;domain type='kvm' id='7'&gt;
3772               &lt;name&gt;test-vm&lt;/name&gt;
3773               &lt;devices&gt;
3774                 &lt;disk type='volume' device='disk'&gt;
3775                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
3776                   &lt;source pool='default' volume='vm05_system'/&gt;
3777                   &lt;backingStore type='file' index='1'&gt;
3778                     &lt;format type='qcow2'/&gt;
3779                     &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
3780                     &lt;backingStore type='file' index='2'&gt;
3781                       &lt;format type='qcow2'/&gt;
3782                       &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
3783                       &lt;backingStore/&gt;
3784                     &lt;/backingStore&gt;
3785                   &lt;/backingStore&gt;
3786                   &lt;target dev='vda' bus='virtio'/&gt;
3787                   &lt;alias name='virtio-disk0'/&gt;
3788                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
3789                 &lt;/disk&gt;
3790               &lt;/devices&gt;
3791             &lt;/domain&gt;
3792         """
3793         self.set_mock_vm("test-vm", xml)
3794         pool_mock = MagicMock()
3795         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3796             0,
3797             1234567,
3798             12345,
3799         ]
3800         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3801         ]
3802         pool_mock.listVolumes.return_value = ["vm05_system", "vm04_system.qcow2"]
3803         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3804         self.mock_conn.listStoragePools.return_value = ["default"]
3805         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3806             res = virt.purge("test-vm")
3807             self.assertTrue(res)
3808             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3809     @patch("salt.modules.virt.stop", return_value=True)
3810     @patch("salt.modules.virt.undefine")
3811     def test_purge_rbd(self, mock_undefine, mock_stop):
3812         xml = """&lt;domain type='kvm' id='7'&gt;
3813               &lt;name&gt;test-vm&lt;/name&gt;
3814               &lt;devices&gt;
3815                 &lt;disk type="network" device="disk"&gt;
3816                   &lt;driver name='raw' type='qcow2'/&gt;
3817                   &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
3818                     &lt;host name='ses2.tf.local'/&gt;
3819                     &lt;host name='ses3.tf.local' port='1234'/&gt;
3820                     &lt;auth username='libvirt'&gt;
3821                       &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
3822                     &lt;/auth&gt;
3823                   &lt;/source&gt;
3824                   &lt;target dev='vdc' bus='virtio'/&gt;
3825                   &lt;alias name='virtio-disk2'/&gt;
3826                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
3827                 &lt;/disk&gt;
3828               &lt;/devices&gt;
3829             &lt;/domain&gt;
3830         """
3831         self.set_mock_vm("test-vm", xml)
3832         pool_mock = MagicMock()
3833         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3834             0,
3835             1234567,
3836             12345,
3837         ]
3838         pool_mock.XMLDesc.return_value = """
3839         &lt;pool type='rbd'&gt;
3840           &lt;name&gt;test-ses&lt;/name&gt;
3841           &lt;source&gt;
3842             &lt;host name='ses2.tf.local'/&gt;
3843             &lt;name&gt;libvirt-pool&lt;/name&gt;
3844             &lt;auth type='ceph' username='libvirt'&gt;
3845               &lt;secret usage='pool_test-ses'/&gt;
3846             &lt;/auth&gt;
3847           &lt;/source&gt;
3848         &lt;/pool&gt;
3849         """
3850         pool_mock.name.return_value = "test-ses"
3851         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3852         ]
3853         pool_mock.listVolumes.return_value = ["my_vm_data2"]
3854         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
3855         self.mock_conn.listStoragePools.return_value = ["test-ses"]
3856         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3857         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3858             res = virt.purge("test-vm")
3859             self.assertTrue(res)
3860             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3861     @patch("salt.modules.virt.stop", return_value=True)
3862     @patch("salt.modules.virt.undefine")
3863     @patch("os.remove")
3864     def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
3865         xml = """&lt;domain type="kvm" id="7"&gt;
3866               &lt;name&gt;test-vm&lt;/name&gt;
3867               &lt;devices&gt;
3868                 &lt;disk type='file' device='disk'&gt;
3869                 &lt;driver name='qemu' type='qcow2'/&gt;
3870                 &lt;source file='/disks/test.qcow2'/&gt;
3871                 &lt;target dev='vda' bus='virtio'/&gt;
3872               &lt;/disk&gt;
3873               &lt;disk type='file' device='cdrom'&gt;
3874                 &lt;driver name='qemu' type='raw'/&gt;
3875                 &lt;source file='/disks/test-cdrom.iso'/&gt;
3876                 &lt;target dev='hda' bus='ide'/&gt;
3877                 &lt;readonly/&gt;
3878               &lt;/disk&gt;
3879               &lt;disk type='file' device='floppy'&gt;
3880                 &lt;driver name='qemu' type='raw'/&gt;
3881                 &lt;source file='/disks/test-floppy.iso'/&gt;
3882                 &lt;target dev='hdb' bus='ide'/&gt;
3883                 &lt;readonly/&gt;
3884               &lt;/disk&gt;
3885               &lt;/devices&gt;
3886             &lt;/domain&gt;
3887         """
3888         self.set_mock_vm("test-vm", xml)
3889         qemu_infos = """[{
3890             "virtual-size": 25769803776,
3891             "filename": "/disks/test.qcow2",
3892             "cluster-size": 65536,
3893             "format": "qcow2",
3894             "actual-size": 217088,
3895             "format-specific": {
3896                 "type": "qcow2",
3897                 "data": {
3898                     "compat": "1.1",
3899                     "lazy-refcounts": false,
3900                     "refcount-bits": 16,
3901                     "corrupt": false
3902                 }
3903             },
3904             "dirty-flag": false
3905         }]"""
3906         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3907         self.mock_popen.returncode = 0
3908         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3909             res = virt.purge("test-vm", removables=True)
3910             self.assertTrue(res)
3911             mock_remove.assert_any_call("/disks/test.qcow2")
3912             mock_remove.assert_any_call("/disks/test-cdrom.iso")
3913     def test_capabilities(self):
3914         xml = """
3915 &lt;capabilities&gt;
3916   &lt;host&gt;
3917     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
3918     &lt;cpu&gt;
3919       &lt;arch&gt;x86_64&lt;/arch&gt;
3920       &lt;model&gt;Nehalem&lt;/model&gt;
3921       &lt;vendor&gt;Intel&lt;/vendor&gt;
3922       &lt;microcode version='25'/&gt;
3923       &lt;topology sockets='1' cores='4' threads='2'/&gt;
3924       &lt;feature name='vme'/&gt;
3925       &lt;feature name='ds'/&gt;
3926       &lt;feature name='acpi'/&gt;
3927       &lt;pages unit='KiB' size='4'/&gt;
3928       &lt;pages unit='KiB' size='2048'/&gt;
3929     &lt;/cpu&gt;
3930     &lt;power_management&gt;
3931       &lt;suspend_mem/&gt;
3932       &lt;suspend_disk/&gt;
3933       &lt;suspend_hybrid/&gt;
3934     &lt;/power_management&gt;
3935     &lt;migration_features&gt;
3936       &lt;live/&gt;
3937       &lt;uri_transports&gt;
3938         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
3939         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
3940       &lt;/uri_transports&gt;
3941     &lt;/migration_features&gt;
3942     &lt;topology&gt;
3943       &lt;cells num='1'&gt;
3944         &lt;cell id='0'&gt;
3945           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
3946           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
3947           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
3948           &lt;distances&gt;
3949             &lt;sibling id='0' value='10'/&gt;
3950           &lt;/distances&gt;
3951           &lt;cpus num='8'&gt;
3952             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
3953             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
3954             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
3955             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
3956             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
3957             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
3958             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
3959             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
3960           &lt;/cpus&gt;
3961         &lt;/cell&gt;
3962       &lt;/cells&gt;
3963     &lt;/topology&gt;
3964     &lt;cache&gt;
3965       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
3966     &lt;/cache&gt;
3967     &lt;secmodel&gt;
3968       &lt;model&gt;apparmor&lt;/model&gt;
3969       &lt;doi&gt;0&lt;/doi&gt;
3970     &lt;/secmodel&gt;
3971     &lt;secmodel&gt;
3972       &lt;model&gt;dac&lt;/model&gt;
3973       &lt;doi&gt;0&lt;/doi&gt;
3974       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
3975       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
3976     &lt;/secmodel&gt;
3977   &lt;/host&gt;
3978   &lt;guest&gt;
3979     &lt;os_type&gt;hvm&lt;/os_type&gt;
3980     &lt;arch name='i686'&gt;
3981       &lt;wordsize&gt;32&lt;/wordsize&gt;
3982       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
3983       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3984       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3985       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3986       &lt;domain type='qemu'/&gt;
3987       &lt;domain type='kvm'&gt;
3988         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
3989         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3990         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3991         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3992       &lt;/domain&gt;
3993     &lt;/arch&gt;
3994     &lt;features&gt;
3995       &lt;cpuselection/&gt;
3996       &lt;deviceboot/&gt;
3997       &lt;disksnapshot default='on' toggle='no'/&gt;
3998       &lt;acpi default='off' toggle='yes'/&gt;
3999       &lt;apic default='on' toggle='no'/&gt;
4000       &lt;pae/&gt;
4001       &lt;nonpae/&gt;
4002     &lt;/features&gt;
4003   &lt;/guest&gt;
4004   &lt;guest&gt;
4005     &lt;os_type&gt;hvm&lt;/os_type&gt;
4006     &lt;arch name='x86_64'&gt;
4007       &lt;wordsize&gt;64&lt;/wordsize&gt;
4008       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4009       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4010       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4011       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4012       &lt;domain type='qemu'/&gt;
4013       &lt;domain type='kvm'&gt;
4014         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4015         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4016         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4017         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4018       &lt;/domain&gt;
4019     &lt;/arch&gt;
4020     &lt;features&gt;
4021       &lt;cpuselection/&gt;
4022       &lt;deviceboot/&gt;
4023       &lt;disksnapshot default='on' toggle='no'/&gt;
4024       &lt;acpi default='on' toggle='yes'/&gt;
4025       &lt;apic default='off' toggle='no'/&gt;
4026     &lt;/features&gt;
4027   &lt;/guest&gt;
4028   &lt;guest&gt;
4029     &lt;os_type&gt;xen&lt;/os_type&gt;
4030     &lt;arch name='x86_64'&gt;
4031       &lt;wordsize&gt;64&lt;/wordsize&gt;
4032       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4033       &lt;machine&gt;xenpv&lt;/machine&gt;
4034       &lt;domain type='xen'/&gt;
4035     &lt;/arch&gt;
4036   &lt;/guest&gt;
4037 &lt;/capabilities&gt;
4038         """
4039         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
4040         caps = virt.capabilities()
4041         expected = {
4042             "host": {
4043                 "uuid": "44454c4c-3400-105a-8033-b3c04f4b344a",
4044                 "cpu": {
4045                     "arch": "x86_64",
4046                     "model": "Nehalem",
4047                     "vendor": "Intel",
4048                     "microcode": "25",
4049                     "sockets": 1,
4050                     "cores": 4,
4051                     "threads": 2,
4052                     "features": ["vme", "ds", "acpi"],
4053                     "pages": [{"size": "4 KiB"}, {"size": "2048 KiB"}],
4054                 },
4055                 "power_management": ["suspend_mem", "suspend_disk", "suspend_hybrid"],
4056                 "migration": {"live": True, "transports": ["tcp", "rdma"]},
4057                 "topology": {
4058                     "cells": [
4059                         {
4060                             "id": 0,
4061                             "memory": "12367120 KiB",
4062                             "pages": [
4063                                 {"size": "4 KiB", "available": 3091780},
4064                                 {"size": "2048 KiB", "available": 0},
4065                             ],
4066                             "distances": {0: 10},
4067                             "cpus": [
4068                                 {
4069                                     "id": 0,
4070                                     "socket_id": 0,
4071                                     "core_id": 0,
4072                                     "siblings": "0,4",
4073                                 },
4074                                 {
4075                                     "id": 1,
4076                                     "socket_id": 0,
4077                                     "core_id": 1,
4078                                     "siblings": "1,5",
4079                                 },
4080                                 {
4081                                     "id": 2,
4082                                     "socket_id": 0,
4083                                     "core_id": 2,
4084                                     "siblings": "2,6",
4085                                 },
4086                                 {
4087                                     "id": 3,
4088                                     "socket_id": 0,
4089                                     "core_id": 3,
4090                                     "siblings": "3,7",
4091                                 },
4092                                 {
4093                                     "id": 4,
4094                                     "socket_id": 0,
4095                                     "core_id": 0,
4096                                     "siblings": "0,4",
4097                                 },
4098                                 {
4099                                     "id": 5,
4100                                     "socket_id": 0,
4101                                     "core_id": 1,
4102                                     "siblings": "1,5",
4103                                 },
4104                                 {
4105                                     "id": 6,
4106                                     "socket_id": 0,
4107                                     "core_id": 2,
4108                                     "siblings": "2,6",
4109                                 },
4110                                 {
4111                                     "id": 7,
4112                                     "socket_id": 0,
4113                                     "core_id": 3,
4114                                     "siblings": "3,7",
4115                                 },
4116                             ],
4117                         }
4118                     ]
4119                 },
4120                 "cache": {
4121                     "banks": [
4122                         {
4123                             "id": 0,
4124                             "level": 3,
4125                             "type": "both",
4126                             "size": "8 MiB",
4127                             "cpus": "0-7",
4128                         }
4129                     ]
4130                 },
4131                 "security": [
4132                     {"model": "apparmor", "doi": "0", "baselabels": []},
4133                     {
4134                         "model": "dac",
4135                         "doi": "0",
4136                         "baselabels": [
4137                             {"type": "kvm", "label": "+487:+486"},
4138                             {"type": "qemu", "label": "+487:+486"},
4139                         ],
4140                     },
4141                 ],
4142             },
4143             "guests": [
4144                 {
4145                     "os_type": "hvm",
4146                     "arch": {
4147                         "name": "i686",
4148                         "wordsize": 32,
4149                         "emulator": "/usr/bin/qemu-system-i386",
4150                         "machines": {
4151                             "pc-i440fx-2.6": {
4152                                 "maxcpus": 255,
4153                                 "alternate_names": ["pc"],
4154                             },
4155                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4156                         },
4157                         "domains": {
4158                             "qemu": {"emulator": None, "machines": {}},
4159                             "kvm": {
4160                                 "emulator": "/usr/bin/qemu-kvm",
4161                                 "machines": {
4162                                     "pc-i440fx-2.6": {
4163                                         "maxcpus": 255,
4164                                         "alternate_names": ["pc"],
4165                                     },
4166                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4167                                 },
4168                             },
4169                         },
4170                     },
4171                     "features": {
4172                         "cpuselection": {"default": True, "toggle": False},
4173                         "deviceboot": {"default": True, "toggle": False},
4174                         "disksnapshot": {"default": True, "toggle": False},
4175                         "acpi": {"default": False, "toggle": True},
4176                         "apic": {"default": True, "toggle": False},
4177                         "pae": {"default": True, "toggle": False},
4178                         "nonpae": {"default": True, "toggle": False},
4179                     },
4180                 },
4181                 {
4182                     "os_type": "hvm",
4183                     "arch": {
4184                         "name": "x86_64",
4185                         "wordsize": 64,
4186                         "emulator": "/usr/bin/qemu-system-x86_64",
4187                         "machines": {
4188                             "pc-i440fx-2.6": {
4189                                 "maxcpus": 255,
4190                                 "alternate_names": ["pc"],
4191                             },
4192                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4193                         },
4194                         "domains": {
4195                             "qemu": {"emulator": None, "machines": {}},
4196                             "kvm": {
4197                                 "emulator": "/usr/bin/qemu-kvm",
4198                                 "machines": {
4199                                     "pc-i440fx-2.6": {
4200                                         "maxcpus": 255,
4201                                         "alternate_names": ["pc"],
4202                                     },
4203                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4204                                 },
4205                             },
4206                         },
4207                     },
4208                     "features": {
4209                         "cpuselection": {"default": True, "toggle": False},
4210                         "deviceboot": {"default": True, "toggle": False},
4211                         "disksnapshot": {"default": True, "toggle": False},
4212                         "acpi": {"default": True, "toggle": True},
4213                         "apic": {"default": False, "toggle": False},
4214                     },
4215                 },
4216                 {
4217                     "os_type": "xen",
4218                     "arch": {
4219                         "name": "x86_64",
4220                         "wordsize": 64,
4221                         "emulator": "/usr/bin/qemu-system-x86_64",
4222                         "machines": {"xenpv": {"alternate_names": []}},
4223                         "domains": {"xen": {"emulator": None, "machines": {}}},
4224                     },
4225                 },
4226             ],
4227         }
4228         self.assertEqual(expected, caps)
4229     def test_domain_capabilities(self):
4230         xml = """
4231 &lt;domainCapabilities&gt;
4232   &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
4233   &lt;domain&gt;kvm&lt;/domain&gt;
4234   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4235   &lt;arch&gt;aarch64&lt;/arch&gt;
4236   &lt;vcpu max='255'/&gt;
4237   &lt;iothreads supported='yes'/&gt;
4238   &lt;os supported='yes'&gt;
4239     &lt;loader supported='yes'&gt;
4240       &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
4241       &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
4242       &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
4243       &lt;enum name='type'&gt;
4244         &lt;value&gt;rom&lt;/value&gt;
4245         &lt;value&gt;pflash&lt;/value&gt;
4246       &lt;/enum&gt;
4247       &lt;enum name='readonly'&gt;
4248         &lt;value&gt;yes&lt;/value&gt;
4249         &lt;value&gt;no&lt;/value&gt;
4250       &lt;/enum&gt;
4251     &lt;/loader&gt;
4252   &lt;/os&gt;
4253   &lt;cpu&gt;
4254     &lt;mode name='host-passthrough' supported='yes'/&gt;
4255     &lt;mode name='host-model' supported='yes'&gt;
4256       &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
4257       &lt;vendor&gt;ACME&lt;/vendor&gt;
4258       &lt;feature policy='require' name='vme'/&gt;
4259       &lt;feature policy='require' name='ss'/&gt;
4260     &lt;/mode&gt;
4261     &lt;mode name='custom' supported='yes'&gt;
4262       &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
4263       &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
4264       &lt;model usable='no'&gt;arm1136&lt;/model&gt;
4265     &lt;/mode&gt;
4266   &lt;/cpu&gt;
4267   &lt;devices&gt;
4268     &lt;disk supported='yes'&gt;
4269       &lt;enum name='diskDevice'&gt;
4270         &lt;value&gt;disk&lt;/value&gt;
4271         &lt;value&gt;cdrom&lt;/value&gt;
4272         &lt;value&gt;floppy&lt;/value&gt;
4273         &lt;value&gt;lun&lt;/value&gt;
4274       &lt;/enum&gt;
4275       &lt;enum name='bus'&gt;
4276         &lt;value&gt;fdc&lt;/value&gt;
4277         &lt;value&gt;scsi&lt;/value&gt;
4278         &lt;value&gt;virtio&lt;/value&gt;
4279         &lt;value&gt;usb&lt;/value&gt;
4280         &lt;value&gt;sata&lt;/value&gt;
4281       &lt;/enum&gt;
4282     &lt;/disk&gt;
4283     &lt;graphics supported='yes'&gt;
4284       &lt;enum name='type'&gt;
4285         &lt;value&gt;sdl&lt;/value&gt;
4286         &lt;value&gt;vnc&lt;/value&gt;
4287       &lt;/enum&gt;
4288     &lt;/graphics&gt;
4289     &lt;video supported='yes'&gt;
4290       &lt;enum name='modelType'&gt;
4291         &lt;value&gt;vga&lt;/value&gt;
4292         &lt;value&gt;virtio&lt;/value&gt;
4293       &lt;/enum&gt;
4294     &lt;/video&gt;
4295     &lt;hostdev supported='yes'&gt;
4296       &lt;enum name='mode'&gt;
4297         &lt;value&gt;subsystem&lt;/value&gt;
4298       &lt;/enum&gt;
4299       &lt;enum name='startupPolicy'&gt;
4300         &lt;value&gt;default&lt;/value&gt;
4301         &lt;value&gt;mandatory&lt;/value&gt;
4302         &lt;value&gt;requisite&lt;/value&gt;
4303         &lt;value&gt;optional&lt;/value&gt;
4304       &lt;/enum&gt;
4305       &lt;enum name='subsysType'&gt;
4306         &lt;value&gt;usb&lt;/value&gt;
4307         &lt;value&gt;pci&lt;/value&gt;
4308         &lt;value&gt;scsi&lt;/value&gt;
4309       &lt;/enum&gt;
4310       &lt;enum name='capsType'/&gt;
4311       &lt;enum name='pciBackend'&gt;
4312         &lt;value&gt;default&lt;/value&gt;
4313         &lt;value&gt;kvm&lt;/value&gt;
4314         &lt;value&gt;vfio&lt;/value&gt;
4315       &lt;/enum&gt;
4316     &lt;/hostdev&gt;
4317   &lt;/devices&gt;
4318   &lt;features&gt;
4319     &lt;gic supported='yes'&gt;
4320       &lt;enum name='version'&gt;
4321         &lt;value&gt;3&lt;/value&gt;
4322       &lt;/enum&gt;
4323     &lt;/gic&gt;
4324     &lt;vmcoreinfo supported='yes'/&gt;
4325   &lt;/features&gt;
4326 &lt;/domainCapabilities&gt;
4327         """
4328         self.mock_conn.getDomainCapabilities.return_value = (
4329             xml  # pylint: disable=no-member
4330         )
4331         caps = virt.domain_capabilities()
4332         expected = {
4333             "emulator": "/usr/bin/qemu-system-aarch64",
4334             "domain": "kvm",
4335             "machine": "virt-2.12",
4336             "arch": "aarch64",
4337             "max_vcpus": 255,
4338             "iothreads": True,
4339             "os": {
4340                 "loader": {
4341                     "type": ["rom", "pflash"],
4342                     "readonly": ["yes", "no"],
4343                     "values": [
4344                         "/usr/share/AAVMF/AAVMF_CODE.fd",
4345                         "/usr/share/AAVMF/AAVMF32_CODE.fd",
4346                         "/usr/share/OVMF/OVMF_CODE.fd",
4347                     ],
4348                 }
4349             },
4350             "cpu": {
4351                 "host-passthrough": True,
4352                 "host-model": {
4353                     "model": {"name": "sample-cpu", "fallback": "forbid"},
4354                     "vendor": "ACME",
4355                     "features": {"vme": "require", "ss": "require"},
4356                 },
4357                 "custom": {
4358                     "models": {"pxa262": "unknown", "pxa270-a0": "yes", "arm1136": "no"}
4359                 },
4360             },
4361             "devices": {
4362                 "disk": {
4363                     "diskDevice": ["disk", "cdrom", "floppy", "lun"],
4364                     "bus": ["fdc", "scsi", "virtio", "usb", "sata"],
4365                 },
4366                 "graphics": {"type": ["sdl", "vnc"]},
4367                 "video": {"modelType": ["vga", "virtio"]},
4368                 "hostdev": {
4369                     "mode": ["subsystem"],
4370                     "startupPolicy": ["default", "mandatory", "requisite", "optional"],
4371                     "subsysType": ["usb", "pci", "scsi"],
4372                     "capsType": [],
4373                     "pciBackend": ["default", "kvm", "vfio"],
4374                 },
4375             },
4376             "features": {"gic": {"version": ["3"]}, "vmcoreinfo": {}},
4377         }
4378         self.assertEqual(expected, caps)
4379     def test_all_capabilities(self):
4380         domainXml = """
4381 &lt;domainCapabilities&gt;
4382   &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
4383   &lt;domain&gt;kvm&lt;/domain&gt;
4384   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4385   &lt;arch&gt;x86_64&lt;/arch&gt;
4386   &lt;vcpu max='255'/&gt;
4387   &lt;iothreads supported='yes'/&gt;
4388 &lt;/domainCapabilities&gt;
4389         """
4390         hostXml = """
4391 &lt;capabilities&gt;
4392   &lt;host&gt;
4393     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
4394     &lt;cpu&gt;
4395       &lt;arch&gt;x86_64&lt;/arch&gt;
4396       &lt;model&gt;Nehalem&lt;/model&gt;
4397       &lt;vendor&gt;Intel&lt;/vendor&gt;
4398       &lt;microcode version='25'/&gt;
4399       &lt;topology sockets='1' cores='4' threads='2'/&gt;
4400     &lt;/cpu&gt;
4401   &lt;/host&gt;
4402   &lt;guest&gt;
4403     &lt;os_type&gt;hvm&lt;/os_type&gt;
4404     &lt;arch name='x86_64'&gt;
4405       &lt;wordsize&gt;64&lt;/wordsize&gt;
4406       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4407       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4408       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4409       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4410       &lt;domain type='qemu'/&gt;
4411       &lt;domain type='kvm'&gt;
4412         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4413         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4414         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4415         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4416       &lt;/domain&gt;
4417     &lt;/arch&gt;
4418   &lt;/guest&gt;
4419 &lt;/capabilities&gt;
4420         """
4421         self.mock_conn.getCapabilities.return_value = hostXml
4422         self.mock_conn.getDomainCapabilities.side_effect = [
4423             domainXml,
4424             domainXml.replace("&lt;domain&gt;kvm", "&lt;domain&gt;qemu"),
4425         ]
4426         caps = virt.all_capabilities()
4427         self.assertEqual(
4428             "44454c4c-3400-105a-8033-b3c04f4b344a", caps["host"]["host"]["uuid"]
4429         )
4430         self.assertEqual(
4431             {"qemu", "kvm"},
4432             {domainCaps["domain"] for domainCaps in caps["domains"]},
4433         )
4434         self.assertEqual(
4435             {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
4436             {
4437                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "kvm"),
4438                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "qemu"),
4439             },
4440         )
4441     def test_network_tag(self):
4442         xml_data = virt._gen_net_xml("network", "main", "bridge", "openvswitch", 1001)
4443         root = ET.fromstring(xml_data)
4444         self.assertEqual(root.find("name").text, "network")
4445         self.assertEqual(root.find("bridge").attrib["name"], "main")
4446         self.assertEqual(root.find("forward").attrib["mode"], "bridge")
4447         self.assertEqual(root.find("virtualport").attrib["type"], "openvswitch")
4448         self.assertEqual(root.find("vlan/tag").attrib["id"], "1001")
4449     def test_list_networks(self):
4450         names = ["net1", "default", "net2"]
4451         net_mocks = [MagicMock(), MagicMock(), MagicMock()]
4452         for i, value in enumerate(names):
4453             net_mocks[i].name.return_value = value
4454         self.mock_conn.listAllNetworks.return_value = (
4455             net_mocks  # pylint: disable=no-member
4456         )
4457         actual = virt.list_networks()
4458         self.assertEqual(names, actual)
4459     def test_network_info(self):
4460         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4461         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4462         net_mock = MagicMock()
4463         net_mock.name.return_value = "foo"
4464         net_mock.UUIDString.return_value = "some-uuid"
4465         net_mock.bridgeName.return_value = "br0"
4466         net_mock.autostart.return_value = True
4467         net_mock.isActive.return_value = False
4468         net_mock.isPersistent.return_value = True
4469         net_mock.DHCPLeases.return_value = [
4470             {
4471                 "iface": "virbr0",
4472                 "expirytime": 1527757552,
4473                 "type": 0,
4474                 "mac": "52:54:00:01:71:bd",
4475                 "ipaddr": "192.168.122.45",
4476                 "prefix": 24,
4477                 "hostname": "py3-test",
4478                 "clientid": "01:52:54:00:01:71:bd",
4479                 "iaid": None,
4480             }
4481         ]
4482         self.mock_conn.listAllNetworks.return_value = [net_mock]
4483         net = virt.network_info("foo")
4484         self.assertEqual(
4485             {
4486                 "foo": {
4487                     "uuid": "some-uuid",
4488                     "bridge": "br0",
4489                     "autostart": True,
4490                     "active": False,
4491                     "persistent": True,
4492                     "leases": [
4493                         {
4494                             "iface": "virbr0",
4495                             "expirytime": 1527757552,
4496                             "type": "ipv4",
4497                             "mac": "52:54:00:01:71:bd",
4498                             "ipaddr": "192.168.122.45",
4499                             "prefix": 24,
4500                             "hostname": "py3-test",
4501                             "clientid": "01:52:54:00:01:71:bd",
4502                             "iaid": None,
4503                         }
4504                     ],
4505                 }
4506             },
4507             net,
4508         )
4509     def test_network_info_all(self):
4510         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4511         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4512         net_mocks = []
4513         for i in range(2):
4514             net_mock = MagicMock()
4515             net_mock.name.return_value = "net{}".format(i)
4516             net_mock.UUIDString.return_value = "some-uuid"
4517             net_mock.bridgeName.return_value = "br{}".format(i)
4518             net_mock.autostart.return_value = True
4519             net_mock.isActive.return_value = False
4520             net_mock.isPersistent.return_value = True
4521             net_mock.DHCPLeases.return_value = []
4522             net_mocks.append(net_mock)
4523         self.mock_conn.listAllNetworks.return_value = net_mocks
4524         net = virt.network_info()
4525         self.assertEqual(
4526             {
4527                 "net0": {
4528                     "uuid": "some-uuid",
4529                     "bridge": "br0",
4530                     "autostart": True,
4531                     "active": False,
4532                     "persistent": True,
4533                     "leases": [],
4534                 },
4535                 "net1": {
4536                     "uuid": "some-uuid",
4537                     "bridge": "br1",
4538                     "autostart": True,
4539                     "active": False,
4540                     "persistent": True,
4541                     "leases": [],
4542                 },
4543             },
4544             net,
4545         )
4546     def test_network_info_notfound(self):
4547         self.mock_conn.listAllNetworks.return_value = []
4548         net = virt.network_info("foo")
4549         self.assertEqual({}, net)
4550     def test_network_get_xml(self):
4551         network_mock = MagicMock()
4552         network_mock.XMLDesc.return_value = "&lt;net&gt;Raw XML&lt;/net&gt;"
4553         self.mock_conn.networkLookupByName.return_value = network_mock
4554         self.assertEqual("&lt;net&gt;Raw XML&lt;/net&gt;", virt.network_get_xml("default"))
4555     def test_pool(self):
4556         xml_data = virt._gen_pool_xml("pool", "logical", "/dev/base")
4557         root = ET.fromstring(xml_data)
4558         self.assertEqual(root.find("name").text, "pool")
4559         self.assertEqual(root.attrib["type"], "logical")
4560         self.assertEqual(root.find("target/path").text, "/dev/base")
4561     def test_pool_with_source(self):
4562         xml_data = virt._gen_pool_xml(
4563             "pool", "logical", "/dev/base", source_devices=[{"path": "/dev/sda"}]
4564         )
4565         root = ET.fromstring(xml_data)
4566         self.assertEqual(root.find("name").text, "pool")
4567         self.assertEqual(root.attrib["type"], "logical")
4568         self.assertEqual(root.find("target/path").text, "/dev/base")
4569         self.assertEqual(root.find("source/device").attrib["path"], "/dev/sda")
4570     def test_pool_with_scsi(self):
4571         xml_data = virt._gen_pool_xml(
4572             "pool",
4573             "scsi",
4574             "/dev/disk/by-path",
4575             source_devices=[{"path": "/dev/sda"}],
4576             source_adapter={
4577                 "type": "scsi_host",
4578                 "parent_address": {
4579                     "unique_id": 5,
4580                     "address": {
4581                         "domain": "0x0000",
4582                         "bus": "0x00",
4583                         "slot": "0x1f",
4584                         "function": "0x2",
4585                     },
4586                 },
4587             },
4588             source_name="srcname",
4589         )
4590         root = ET.fromstring(xml_data)
4591         self.assertEqual(root.find("name").text, "pool")
4592         self.assertEqual(root.attrib["type"], "scsi")
4593         self.assertEqual(root.find("target/path").text, "/dev/disk/by-path")
4594         self.assertEqual(root.find("source/device"), None)
4595         self.assertEqual(root.find("source/name"), None)
4596         self.assertEqual(root.find("source/adapter").attrib["type"], "scsi_host")
4597         self.assertEqual(
4598             root.find("source/adapter/parentaddr").attrib["unique_id"], "5"
4599         )
4600         self.assertEqual(
4601             root.find("source/adapter/parentaddr/address").attrib["domain"], "0x0000"
4602         )
4603         self.assertEqual(
4604             root.find("source/adapter/parentaddr/address").attrib["bus"], "0x00"
4605         )
4606         self.assertEqual(
4607             root.find("source/adapter/parentaddr/address").attrib["slot"], "0x1f"
4608         )
4609         self.assertEqual(
4610             root.find("source/adapter/parentaddr/address").attrib["function"], "0x2"
4611         )
4612     def test_pool_with_rbd(self):
4613         xml_data = virt._gen_pool_xml(
4614             "pool",
4615             "rbd",
4616             source_devices=[{"path": "/dev/sda"}],
4617             source_hosts=["1.2.3.4", "my.ceph.monitor:69"],
4618             source_auth={
4619                 "type": "ceph",
4620                 "username": "admin",
4621                 "secret": {"type": "uuid", "value": "someuuid"},
4622             },
4623             source_name="srcname",
4624             source_adapter={"type": "scsi_host", "name": "host0"},
4625             source_dir="/some/dir",
4626             source_format="fmt",
4627         )
4628         root = ET.fromstring(xml_data)
4629         self.assertEqual(root.find("name").text, "pool")
4630         self.assertEqual(root.attrib["type"], "rbd")
4631         self.assertEqual(root.find("target"), None)
4632         self.assertEqual(root.find("source/device"), None)
4633         self.assertEqual(root.find("source/name").text, "srcname")
4634         self.assertEqual(root.find("source/adapter"), None)
4635         self.assertEqual(root.find("source/dir"), None)
4636         self.assertEqual(root.find("source/format"), None)
4637         self.assertEqual(root.findall("source/host")[0].attrib["name"], "1.2.3.4")
4638         self.assertTrue("port" not in root.findall("source/host")[0].attrib)
4639         self.assertEqual(
4640             root.findall("source/host")[1].attrib["name"], "my.ceph.monitor"
4641         )
4642         self.assertEqual(root.findall("source/host")[1].attrib["port"], "69")
4643         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4644         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4645         self.assertEqual(root.find("source/auth/secret").attrib["uuid"], "someuuid")
4646     def test_pool_with_netfs(self):
4647         xml_data = virt._gen_pool_xml(
4648             "pool",
4649             "netfs",
4650             target="/path/to/target",
4651             permissions={
4652                 "mode": "0770",
4653                 "owner": 1000,
4654                 "group": 100,
4655                 "label": "seclabel",
4656             },
4657             source_devices=[{"path": "/dev/sda"}],
4658             source_hosts=["nfs.host"],
4659             source_name="srcname",
4660             source_adapter={"type": "scsi_host", "name": "host0"},
4661             source_dir="/some/dir",
4662             source_format="nfs",
4663         )
4664         root = ET.fromstring(xml_data)
4665         self.assertEqual(root.find("name").text, "pool")
4666         self.assertEqual(root.attrib["type"], "netfs")
4667         self.assertEqual(root.find("target/path").text, "/path/to/target")
4668         self.assertEqual(root.find("target/permissions/mode").text, "0770")
4669         self.assertEqual(root.find("target/permissions/owner").text, "1000")
4670         self.assertEqual(root.find("target/permissions/group").text, "100")
4671         self.assertEqual(root.find("target/permissions/label").text, "seclabel")
4672         self.assertEqual(root.find("source/device"), None)
4673         self.assertEqual(root.find("source/name"), None)
4674         self.assertEqual(root.find("source/adapter"), None)
4675         self.assertEqual(root.find("source/dir").attrib["path"], "/some/dir")
4676         self.assertEqual(root.find("source/format").attrib["type"], "nfs")
4677         self.assertEqual(root.find("source/host").attrib["name"], "nfs.host")
4678         self.assertEqual(root.find("source/auth"), None)
4679     def test_pool_with_iscsi_direct(self):
4680         xml_data = virt._gen_pool_xml(
4681             "pool",
4682             "iscsi-direct",
4683             source_hosts=["iscsi.example.com"],
4684             source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4685             source_initiator="iqn.2013-06.com.example:iscsi-initiator",
4686         )
4687         root = ET.fromstring(xml_data)
4688         self.assertEqual(root.find("name").text, "pool")
4689         self.assertEqual(root.attrib["type"], "iscsi-direct")
4690         self.assertEqual(root.find("target"), None)
4691         self.assertEqual(
4692             root.find("source/device").attrib["path"],
4693             "iqn.2013-06.com.example:iscsi-pool",
4694         )
4695         self.assertEqual(
4696             root.findall("source/host")[0].attrib["name"], "iscsi.example.com"
4697         )
4698         self.assertEqual(
4699             root.find("source/initiator/iqn").attrib["name"],
4700             "iqn.2013-06.com.example:iscsi-initiator",
4701         )
4702     def test_pool_define(self):
4703         mock_pool = MagicMock()
4704         mock_secret = MagicMock()
4705         mock_secret_define = MagicMock(return_value=mock_secret)
4706         self.mock_conn.secretDefineXML = mock_secret_define
4707         self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
4708         self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)
4709         mocks = [
4710             mock_pool,
4711             mock_secret,
4712             mock_secret_define,
4713             self.mock_conn.storagePoolCreateXML,
4714             self.mock_conn.secretDefineXML,
4715             self.mock_conn.storagePoolDefineXML,
4716         ]
4717         self.assertTrue(
4718             virt.pool_define(
4719                 "default",
4720                 "rbd",
4721                 source_hosts=["one.example.com", "two.example.com"],
4722                 source_name="rbdvol",
4723                 source_auth={
4724                     "type": "ceph",
4725                     "username": "admin",
4726                     "secret": {"type": "uuid", "value": "someuuid"},
4727                 },
4728             )
4729         )
4730         self.mock_conn.storagePoolDefineXML.assert_called_once()
4731         self.mock_conn.storagePoolCreateXML.assert_not_called()
4732         mock_pool.create.assert_called_once()
4733         mock_secret_define.assert_not_called()
4734         for mock in mocks:
4735             mock.reset_mock()
4736         self.assertTrue(
4737             virt.pool_define(
4738                 "default",
4739                 "rbd",
4740                 transient=True,
4741                 source_hosts=["one.example.com", "two.example.com"],
4742                 source_name="rbdvol",
4743                 source_auth={"username": "admin", "password": "c2VjcmV0"},
4744             )
4745         )
4746         self.mock_conn.storagePoolDefineXML.assert_not_called()
4747         pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
4748         root = ET.fromstring(pool_xml)
4749         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4750         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4751         self.assertEqual(
4752             root.find("source/auth/secret").attrib["usage"], "pool_default"
4753         )
4754         mock_pool.create.assert_not_called()
4755         mock_secret.setValue.assert_called_once_with(b"secret")
4756 <a name="1"></a>
4757         secret_xml = mock_secret_define.call_args[0][0]
4758         root = ET.fromstring(secret_xml)
4759         self.assertEqual(root.find("usage/name")<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.text, "pool_default")
4760         self.assertEqual(root.find("usage").attrib["type"], "ceph")
4761         self.assertEqual(root.attrib["private"], "yes")
4762         self.assertEqual(
4763             root.find("description").</b></font>text, "Passphrase for default pool created by Salt"
4764         )
4765         for mock in mocks:
4766             mock.reset_mock()
4767         self.assertTrue(
4768             virt.pool_define(
4769                 "default",
4770                 "iscsi",
4771                 target="/dev/disk/by-path",
4772                 source_hosts=["iscsi.example.com"],
4773                 source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4774                 source_auth={"username": "admin", "password": "secret"},
4775                 start=False,
4776             )
4777         )
4778         self.mock_conn.storagePoolCreateXML.assert_not_called()
4779         pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
4780         root = ET.fromstring(pool_xml)
4781         self.assertEqual(root.find("source/auth").attrib["type"], "chap")
4782         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4783         self.assertEqual(
4784             root.find("source/auth/secret").attrib["usage"], "pool_default"
4785         )
4786         mock_pool.create.assert_not_called()
4787         mock_secret.setValue.assert_called_once_with("secret")
4788         secret_xml = mock_secret_define.call_args[0][0]
4789         root = ET.fromstring(secret_xml)
4790         self.assertEqual(root.find("usage/target").text, "pool_default")
4791         self.assertEqual(root.find("usage").attrib["type"], "iscsi")
4792         self.assertEqual(root.attrib["private"], "yes")
4793         self.assertEqual(
4794             root.find("description").text, "Passphrase for default pool created by Salt"
4795         )
4796     def test_list_pools(self):
4797         names = ["pool1", "default", "pool2"]
4798         pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
4799         for i, value in enumerate(names):
4800             pool_mocks[i].name.return_value = value
4801         self.mock_conn.listAllStoragePools.return_value = (
4802             pool_mocks  # pylint: disable=no-member
4803         )
4804         actual = virt.list_pools()
4805         self.assertEqual(names, actual)
4806     def test_pool_info(self):
4807         pool_mock = MagicMock()
4808         pool_mock.name.return_value = "foo"
4809         pool_mock.UUIDString.return_value = "some-uuid"
4810         pool_mock.info.return_value = [0, 1234, 5678, 123]
4811         pool_mock.autostart.return_value = True
4812         pool_mock.isPersistent.return_value = True
4813         pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4814   &lt;name&gt;default&lt;/name&gt;
4815   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4816   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4817   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4818   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4819   &lt;source&gt;
4820   &lt;/source&gt;
4821   &lt;target&gt;
4822     &lt;path&gt;/srv/vms&lt;/path&gt;
4823     &lt;permissions&gt;
4824       &lt;mode&gt;0755&lt;/mode&gt;
4825       &lt;owner&gt;0&lt;/owner&gt;
4826       &lt;group&gt;0&lt;/group&gt;
4827     &lt;/permissions&gt;
4828   &lt;/target&gt;
4829 &lt;/pool&gt;"""
4830         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4831         pool = virt.pool_info("foo")
4832         self.assertEqual(
4833             {
4834                 "foo": {
4835                     "uuid": "some-uuid",
4836                     "state": "inactive",
4837                     "capacity": 1234,
4838                     "allocation": 5678,
4839                     "free": 123,
4840                     "autostart": True,
4841                     "persistent": True,
4842                     "type": "dir",
4843                     "target_path": "/srv/vms",
4844                 }
4845             },
4846             pool,
4847         )
4848     def test_pool_info_notarget(self):
4849         pool_mock = MagicMock()
4850         pool_mock.name.return_value = "ceph"
4851         pool_mock.UUIDString.return_value = "some-uuid"
4852         pool_mock.info.return_value = [0, 0, 0, 0]
4853         pool_mock.autostart.return_value = True
4854         pool_mock.isPersistent.return_value = True
4855         pool_mock.XMLDesc.return_value = """&lt;pool type='rbd'&gt;
4856   &lt;name&gt;ceph&lt;/name&gt;
4857   &lt;uuid&gt;some-uuid&lt;/uuid&gt;
4858   &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
4859   &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
4860   &lt;available unit='bytes'&gt;0&lt;/available&gt;
4861   &lt;source&gt;
4862     &lt;host name='localhost' port='6789'/&gt;
4863     &lt;host name='localhost' port='6790'/&gt;
4864     &lt;name&gt;rbd&lt;/name&gt;
4865     &lt;auth type='ceph' username='admin'&gt;
4866       &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
4867     &lt;/auth&gt;
4868   &lt;/source&gt;
4869 &lt;/pool&gt;"""
4870         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4871         pool = virt.pool_info("ceph")
4872         self.assertEqual(
4873             {
4874                 "ceph": {
4875                     "uuid": "some-uuid",
4876                     "state": "inactive",
4877                     "capacity": 0,
4878                     "allocation": 0,
4879                     "free": 0,
4880                     "autostart": True,
4881                     "persistent": True,
4882                     "type": "rbd",
4883                     "target_path": None,
4884                 }
4885             },
4886             pool,
4887         )
4888     def test_pool_info_notfound(self):
4889         self.mock_conn.listAllStoragePools.return_value = []
4890         pool = virt.pool_info("foo")
4891         self.assertEqual({}, pool)
4892     def test_pool_info_all(self):
4893         pool_mocks = []
4894         for i in range(2):
4895             pool_mock = MagicMock()
4896             pool_mock.name.return_value = "pool{}".format(i)
4897             pool_mock.UUIDString.return_value = "some-uuid-{}".format(i)
4898             pool_mock.info.return_value = [0, 1234, 5678, 123]
4899             pool_mock.autostart.return_value = True
4900             pool_mock.isPersistent.return_value = True
4901             pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4902   &lt;name&gt;default&lt;/name&gt;
4903   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4904   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4905   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4906   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4907   &lt;source&gt;
4908   &lt;/source&gt;
4909   &lt;target&gt;
4910     &lt;path&gt;/srv/vms&lt;/path&gt;
4911     &lt;permissions&gt;
4912       &lt;mode&gt;0755&lt;/mode&gt;
4913       &lt;owner&gt;0&lt;/owner&gt;
4914       &lt;group&gt;0&lt;/group&gt;
4915     &lt;/permissions&gt;
4916   &lt;/target&gt;
4917 &lt;/pool&gt;"""
4918             pool_mocks.append(pool_mock)
4919         self.mock_conn.listAllStoragePools.return_value = pool_mocks
4920         pool = virt.pool_info()
4921         self.assertEqual(
4922             {
4923                 "pool0": {
4924                     "uuid": "some-uuid-0",
4925                     "state": "inactive",
4926                     "capacity": 1234,
4927                     "allocation": 5678,
4928                     "free": 123,
4929                     "autostart": True,
4930                     "persistent": True,
4931                     "type": "dir",
4932                     "target_path": "/srv/vms",
4933                 },
4934                 "pool1": {
4935                     "uuid": "some-uuid-1",
4936                     "state": "inactive",
4937                     "capacity": 1234,
4938                     "allocation": 5678,
4939                     "free": 123,
4940                     "autostart": True,
4941                     "persistent": True,
4942                     "type": "dir",
4943                     "target_path": "/srv/vms",
4944                 },
4945             },
4946             pool,
4947         )
4948     def test_pool_get_xml(self):
4949         pool_mock = MagicMock()
4950         pool_mock.XMLDesc.return_value = "&lt;pool&gt;Raw XML&lt;/pool&gt;"
4951         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
4952         self.assertEqual("&lt;pool&gt;Raw XML&lt;/pool&gt;", virt.pool_get_xml("default"))
4953     def test_pool_list_volumes(self):
4954         names = ["volume1", "volume2"]
4955         mock_pool = MagicMock()
4956         mock_pool.listVolumes.return_value = names
4957         self.mock_conn.storagePoolLookupByName.return_value = mock_pool
4958         self.assertEqual(names, virt.pool_list_volumes("default"))
4959     @patch("salt.modules.virt._is_bhyve_hyper", return_value=False)
4960     @patch("salt.modules.virt._is_kvm_hyper", return_value=True)
4961     @patch("salt.modules.virt._is_xen_hyper", return_value=False)
4962     def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
4963         self.assertEqual("kvm", virt.get_hypervisor())
4964         iskvm_mock.return_value = False
4965         self.assertIsNone(virt.get_hypervisor())
4966         is_bhyve_mock.return_value = False
4967         self.assertIsNone(virt.get_hypervisor())
4968         isxen_mock.return_value = True
4969         self.assertEqual("xen", virt.get_hypervisor())
4970     def test_pool_delete(self):
4971         mock_pool = MagicMock()
4972         mock_pool.delete = MagicMock(return_value=0)
4973         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4974         res = virt.pool_delete("test-pool")
4975         self.assertTrue(res)
4976         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-pool")
4977         mock_pool.delete.assert_called_once_with(
4978             self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
4979         )
4980     def test_pool_undefine_secret(self):
4981         mock_pool = MagicMock()
4982         mock_pool.undefine = MagicMock(return_value=0)
4983         mock_pool.XMLDesc.return_value = """
4984             &lt;pool type='rbd'&gt;
4985               &lt;name&gt;test-ses&lt;/name&gt;
4986               &lt;source&gt;
4987                 &lt;host name='myhost'/&gt;
4988                 &lt;name&gt;libvirt-pool&lt;/name&gt;
4989                 &lt;auth type='ceph' username='libvirt'&gt;
4990                   &lt;secret usage='pool_test-ses'/&gt;
4991                 &lt;/auth&gt;
4992               &lt;/source&gt;
4993             &lt;/pool&gt;
4994         """
4995         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4996         mock_undefine = MagicMock(return_value=0)
4997         self.mock_conn.secretLookupByUsage.return_value.undefine = mock_undefine
4998         res = virt.pool_undefine("test-ses")
4999         self.assertTrue(res)
5000         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-ses")
5001         mock_pool.undefine.assert_called_once_with()
5002         self.mock_conn.secretLookupByUsage.assert_called_once_with(
5003             self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, "pool_test-ses"
5004         )
5005         mock_undefine.assert_called_once()
5006     def test_full_info(self):
5007         xml = """&lt;domain type='kvm' id='7'&gt;
5008               &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
5009               &lt;name&gt;test-vm&lt;/name&gt;
5010               &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
5011               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
5012               &lt;on_crash&gt;destroy&lt;/on_crash&gt;
5013               &lt;devices&gt;
5014                 &lt;disk type='file' device='disk'&gt;
5015                 &lt;driver name='qemu' type='qcow2'/&gt;
5016                 &lt;source file='/disks/test.qcow2'/&gt;
5017                 &lt;target dev='vda' bus='virtio'/&gt;
5018               &lt;/disk&gt;
5019               &lt;disk type='file' device='cdrom'&gt;
5020                 &lt;driver name='qemu' type='raw'/&gt;
5021                 &lt;source file='/disks/test-cdrom.iso'/&gt;
5022                 &lt;target dev='hda' bus='ide'/&gt;
5023                 &lt;readonly/&gt;
5024               &lt;/disk&gt;
5025               &lt;interface type='bridge'&gt;
5026                 &lt;mac address='ac:de:48:b6:8b:59'/&gt;
5027                 &lt;source bridge='br0'/&gt;
5028                 &lt;model type='virtio'/&gt;
5029                 &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
5030               &lt;/interface&gt;
5031               &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
5032                 &lt;listen type='address' address='0.0.0.0'/&gt;
5033               &lt;/graphics&gt;
5034               &lt;/devices&gt;
5035             &lt;/domain&gt;
5036         """
5037         self.set_mock_vm("test-vm", xml)
5038         qemu_infos = """[{
5039             "virtual-size": 25769803776,
5040             "filename": "/disks/test.qcow2",
5041             "cluster-size": 65536,
5042             "format": "qcow2",
5043             "actual-size": 217088,
5044             "format-specific": {
5045                 "type": "qcow2",
5046                 "data": {
5047                     "compat": "1.1",
5048                     "lazy-refcounts": false,
5049                     "refcount-bits": 16,
5050                     "corrupt": false
5051                 }
5052             },
5053             "full-backing-filename": "/disks/mybacking.qcow2",
5054             "backing-filename": "mybacking.qcow2",
5055             "dirty-flag": false
5056         },
5057         {
5058             "virtual-size": 25769803776,
5059             "filename": "/disks/mybacking.qcow2",
5060             "cluster-size": 65536,
5061             "format": "qcow2",
5062             "actual-size": 393744384,
5063             "format-specific": {
5064                 "type": "qcow2",
5065                 "data": {
5066                     "compat": "1.1",
5067                     "lazy-refcounts": false,
5068                     "refcount-bits": 16,
5069                     "corrupt": false
5070                 }
5071             },
5072             "dirty-flag": false
5073         }]"""
5074         self.mock_popen.communicate.return_value = [qemu_infos, ""]
5075         self.mock_popen.returncode = 0
5076         self.mock_conn.getInfo = MagicMock(
5077             return_value=["x86_64", 4096, 8, 2712, 1, 2, 4, 2]
5078         )
5079         actual = virt.full_info()
5080         qemu_img_call = [
5081             call
5082             for call in self.mock_subprocess.Popen<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.call_args_list
5083             if "qemu-img" in call[0][0]
5084         ][0]
5085         self.assertIn("info", qemu_img_call[0][0])
5086         self.assertIn("-U", qemu_img_call[0][0])
5087         self.</b></font>assertEqual(2816, actual["freemem"])
5088         self.assertEqual(6, actual["freecpu"])
5089         self.assertEqual(4, actual["node_info"]["cpucores"])
5090         self.assertEqual(2712, actual["node_info"]["cpumhz"])
5091         self.assertEqual("x86_64", actual["node_info"]["cpumodel"])
5092         self.assertEqual(8, actual["node_info"]["cpus"])
5093         self.assertEqual(2, actual["node_info"]["cputhreads"])
5094         self.assertEqual(1, actual["node_info"]["numanodes"])
5095         self.assertEqual(4096, actual["node_info"]["phymemory"])
5096         self.assertEqual(2, actual["node_info"]["sockets"])
5097         self.assertEqual(2, actual["vm_info"]["test-vm"]["cpu"])
5098         self.assertEqual(1234, actual["vm_info"]["test-vm"]["cputime"])
5099         self.assertEqual(1024 * 1024, actual["vm_info"]["test-vm"]["mem"])
5100         self.assertEqual(2048 * 1024, actual["vm_info"]["test-vm"]["maxMem"])
5101         self.assertEqual("shutdown", actual["vm_info"]["test-vm"]["state"])
5102         self.assertEqual(
5103             "28deee33-4859-4f23-891c-ee239cffec94", actual["vm_info"]["test-vm"]["uuid"]
5104         )
5105         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_crash"])
5106         self.assertEqual("restart", actual["vm_info"]["test-vm"]["on_reboot"])
5107         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_poweroff"])
5108         nic = actual["vm_info"]["test-vm"]["nics"]["ac:de:48:b6:8b:59"]
5109         self.assertEqual("bridge", nic["type"])
5110         self.assertEqual("ac:de:48:b6:8b:59", nic["mac"])
5111         disks = actual["vm_info"]["test-vm"]["disks"]
5112         disk = disks.get("vda")
5113         self.assertEqual("/disks/test.qcow2", disk["file"])
5114         self.assertEqual("disk", disk["type"])
5115         self.assertEqual("/disks/mybacking.qcow2", disk["backing file"]["file"])
5116         cdrom = disks.get("hda")
5117         self.assertEqual("/disks/test-cdrom.iso", cdrom["file"])
5118         self.assertEqual("cdrom", cdrom["type"])
5119         self.assertFalse("backing file" in cdrom.keys())
5120         graphics = actual["vm_info"]["test-vm"]["graphics"]
5121         self.assertEqual("vnc", graphics["type"])
5122         self.assertEqual("5900", graphics["port"])
5123         self.assertEqual("0.0.0.0", graphics["listen"])
5124     def test_pool_update(self):
5125         current_xml = """&lt;pool type='dir'&gt;
5126           &lt;name&gt;default&lt;/name&gt;
5127           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5128           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5129           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5130           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5131           &lt;source&gt;
5132           &lt;/source&gt;
5133           &lt;target&gt;
5134             &lt;path&gt;/path/to/pool&lt;/path&gt;
5135             &lt;permissions&gt;
5136               &lt;mode&gt;0775&lt;/mode&gt;
5137               &lt;owner&gt;0&lt;/owner&gt;
5138               &lt;group&gt;100&lt;/group&gt;
5139             &lt;/permissions&gt;
5140           &lt;/target&gt;
5141         &lt;/pool&gt;"""
5142         expected_xml = (
5143             '&lt;pool type="netfs"&gt;'
5144             "&lt;name&gt;default&lt;/name&gt;"
5145             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5146             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5147             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5148             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5149             "&lt;target&gt;"
5150             "&lt;path&gt;/mnt/cifs&lt;/path&gt;"
5151             "&lt;permissions&gt;"
5152             "&lt;mode&gt;0774&lt;/mode&gt;"
5153             "&lt;owner&gt;1234&lt;/owner&gt;"
5154             "&lt;group&gt;123&lt;/group&gt;"
5155             "&lt;/permissions&gt;"
5156             "&lt;/target&gt;"
5157             "&lt;source&gt;"
5158             '&lt;dir path="samba_share" /&gt;'
5159             '&lt;host name="one.example.com" /&gt;'
5160             '&lt;host name="two.example.com" /&gt;'
5161             '&lt;format type="cifs" /&gt;'
5162             "&lt;/source&gt;"
5163             "&lt;/pool&gt;"
5164         )
5165         mocked_pool = MagicMock()
5166         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5167         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5168         self.mock_conn.storagePoolDefineXML = MagicMock()
5169         self.assertTrue(
5170             virt.pool_update(
5171                 "default",
5172                 "netfs",
5173                 target="/mnt/cifs",
5174                 permissions={"mode": "0774", "owner": "1234", "group": "123"},
5175                 source_format="cifs",
5176                 source_dir="samba_share",
5177                 source_hosts=["one.example.com", "two.example.com"],
5178             )
5179         )
5180         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5181     def test_pool_update_nochange(self):
5182         current_xml = """&lt;pool type='dir'&gt;
5183           &lt;name&gt;default&lt;/name&gt;
5184           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5185           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5186           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5187           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5188           &lt;source&gt;
5189           &lt;/source&gt;
5190           &lt;target&gt;
5191             &lt;path&gt;/path/to/pool&lt;/path&gt;
5192             &lt;permissions&gt;
5193               &lt;mode&gt;0775&lt;/mode&gt;
5194               &lt;owner&gt;0&lt;/owner&gt;
5195               &lt;group&gt;100&lt;/group&gt;
5196             &lt;/permissions&gt;
5197           &lt;/target&gt;
5198         &lt;/pool&gt;"""
5199         mocked_pool = MagicMock()
5200         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5201         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5202         self.mock_conn.storagePoolDefineXML = MagicMock()
5203         self.assertFalse(
5204             virt.pool_update(
5205                 "default",
5206                 "dir",
5207                 target="/path/to/pool",
5208                 permissions={"mode": "0775", "owner": "0", "group": "100"},
5209                 test=True,
5210             )
5211         )
5212         self.mock_conn.storagePoolDefineXML.assert_not_called()
5213     def test_pool_update_password(self):
5214         current_xml = """&lt;pool type='rbd'&gt;
5215           &lt;name&gt;default&lt;/name&gt;
5216           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5217           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5218           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5219           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5220           &lt;source&gt;
5221             &lt;name&gt;iscsi-images&lt;/name&gt;
5222             &lt;host name='ses4.tf.local'/&gt;
5223             &lt;host name='ses5.tf.local'/&gt;
5224             &lt;auth username='libvirt' type='ceph'&gt;
5225               &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
5226             &lt;/auth&gt;
5227           &lt;/source&gt;
5228         &lt;/pool&gt;"""
5229         mock_secret = MagicMock()
5230         self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)
5231         mocked_pool = MagicMock()
5232         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5233         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5234         self.mock_conn.storagePoolDefineXML = MagicMock()
5235         self.assertFalse(
5236             virt.pool_update(
5237                 "default",
5238                 "rbd",
5239                 source_name="iscsi-images",
5240                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5241                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5242             )
5243         )
5244         self.mock_conn.storagePoolDefineXML.assert_not_called()
5245         mock_secret.setValue.assert_called_once_with(b"secret")
5246         self.mock_conn.secretLookupByUUIDString = MagicMock(
5247             side_effect=self.mock_libvirt.libvirtError("secret not found")
5248         )
5249         self.assertFalse(
5250             virt.pool_update(
5251                 "default",
5252                 "rbd",
5253                 source_name="iscsi-images",
5254                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5255                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5256             )
5257         )
5258         self.mock_conn.storagePoolDefineXML.assert_not_called()
5259         self.mock_conn.secretDefineXML.assert_called_once()
5260         mock_secret.setValue.assert_called_once_with(b"secret")
5261     def test_pool_update_password_create(self):
5262         current_xml = """&lt;pool type='rbd'&gt;
5263           &lt;name&gt;default&lt;/name&gt;
5264           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5265           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5266           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5267           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5268           &lt;source&gt;
5269             &lt;name&gt;iscsi-images&lt;/name&gt;
5270             &lt;host name='ses4.tf.local'/&gt;
5271             &lt;host name='ses5.tf.local'/&gt;
5272           &lt;/source&gt;
5273         &lt;/pool&gt;"""
5274         expected_xml = (
5275             '&lt;pool type="rbd"&gt;'
5276             "&lt;name&gt;default&lt;/name&gt;"
5277             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5278             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5279             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5280             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5281             "&lt;source&gt;"
5282             '&lt;host name="ses4.tf.local" /&gt;'
5283             '&lt;host name="ses5.tf.local" /&gt;'
5284             '&lt;auth type="ceph" username="libvirt"&gt;'
5285             '&lt;secret usage="pool_default" /&gt;'
5286             "&lt;/auth&gt;"
5287             "&lt;name&gt;iscsi-images&lt;/name&gt;"
5288             "&lt;/source&gt;"
5289             "&lt;/pool&gt;"
5290         )
5291         mock_secret = MagicMock()
5292         self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)
5293         mocked_pool = MagicMock()
5294         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5295         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5296         self.mock_conn.storagePoolDefineXML = MagicMock()
5297         self.assertTrue(
5298             virt.pool_update(
5299                 "default",
5300                 "rbd",
5301                 source_name="iscsi-images",
5302                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5303                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5304             )
5305         )
5306         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5307         mock_secret.setValue.assert_called_once_with(b"secret")
5308     def test_volume_infos(self):
5309         vms_disks = [
5310         ]
5311         mock_vms = []
5312         for idx, disk in enumerate(vms_disks):
5313             vm = MagicMock()
5314             vm.name.return_value = "vm{}".format(idx)
5315             vm.XMLDesc.return_value = """
5316                     &lt;domain type='kvm' id='1'&gt;
5317                       &lt;name&gt;vm{}&lt;/name&gt;
5318                       &lt;devices&gt;{}&lt;/devices&gt;
5319                     &lt;/domain&gt;
5320                 """.format(
5321                 idx, disk
5322             )
5323             mock_vms.append(vm)
5324         mock_pool_data = [
5325             {
5326                 "name": "pool0",
5327                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5328                 "volumes": [
5329                     {
5330                         "key": "/key/of/vol0",
5331                         "name": "vol0",
5332                         "path": "/path/to/vol0.qcow2",
5333                         "info": [0, 123456789, 123456],
5334                         "backingStore": None,
5335                     }
5336                 ],
5337             },
5338             {
5339                 "name": "pool1",
5340                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5341                 "volumes": [
5342                     {
5343                         "key": "/key/of/vol0bad",
5344                         "name": "vol0bad",
5345                         "path": "/path/to/vol0bad.qcow2",
5346                         "info": None,
5347                         "backingStore": None,
5348                     },
5349                     {
5350                         "key": "/key/of/vol1",
5351                         "name": "vol1",
5352                         "path": "/path/to/vol1.qcow2",
5353                         "info": [0, 12345, 1234],
5354                         "backingStore": None,
5355                     },
5356                     {
5357                         "key": "/key/of/vol2",
5358                         "name": "vol2",
5359                         "path": "/path/to/vol2.qcow2",
5360                         "info": [0, 12345, 1234],
5361                         "backingStore": "/path/to/vol0.qcow2",
5362                     },
5363                 ],
5364             },
5365         ]
5366         mock_pools = []
5367         for pool_data in mock_pool_data:
5368             mock_pool = MagicMock()
5369             mock_pool.name.return_value = pool_data["name"]  # pylint: disable=no-member
5370             mock_pool.info.return_value = [pool_data["state"]]
5371             mock_volumes = []
5372             for vol_data in pool_data["volumes"]:
5373                 mock_volume = MagicMock()
5374                 mock_volume.name.return_value = vol_data["name"]
5375                 mock_volume.key.return_value = vol_data["key"]
5376                 mock_volume.path.return_value = "/path/to/{}.qcow2".format(
5377                     vol_data["name"]
5378                 )
5379                 if vol_data["info"]:
5380                     mock_volume.info.return_value = vol_data["info"]
5381                     backing_store = (
5382                             vol_data["backingStore"]
5383                         )
5384                         if vol_data["backingStore"]
5385                         else "&lt;backingStore/&gt;"
5386                     )
5387                     mock_volume.XMLDesc.return_value = """
5388                         &lt;volume type='file'&gt;
5389                           &lt;name&gt;{0}&lt;/name&gt;
5390                           &lt;target&gt;
5391                             &lt;format type="qcow2"/&gt;
5392                             &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
5393                           &lt;/target&gt;
5394                           {1}
5395                         &lt;/volume&gt;
5396                     """.format(
5397                         vol_data["name"], backing_store
5398                     )
5399                 else:
5400                     mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
5401                         "No such volume"
5402                     )
5403                     mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
5404                         "No such volume"
5405                     )
5406                 mock_volumes.append(mock_volume)
5407             mock_pool.listAllVolumes.return_value = (
5408                 mock_volumes  # pylint: disable=no-member
5409             )
5410             mock_pools.append(mock_pool)
5411         inactive_pool = MagicMock()
5412         inactive_pool.name.return_value = "pool2"
5413         inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
5414         inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
5415             "pool is inactive"
5416         )
5417         mock_pools.append(inactive_pool)
5418         self.mock_conn.listAllStoragePools.return_value = (
5419             mock_pools  # pylint: disable=no-member
5420         )
5421         with patch("salt.modules.virt._get_domain", MagicMock(return_value=mock_vms)):
5422             actual = virt.volume_infos("pool0", "vol0")
5423             self.assertEqual(1, len(actual.keys()))
5424             self.assertEqual(1, len(actual["pool0"].keys()))
5425             self.assertEqual(["vm0", "vm2"], sorted(actual["pool0"]["vol0"]["used_by"]))
5426             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5427             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5428             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5429             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5430             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5431             self.assertEqual(
5432                 virt.volume_infos("pool1", None),
5433                 {
5434                     "pool1": {
5435                         "vol1": {
5436                             "type": "file",
5437                             "key": "/key/of/vol1",
5438                             "path": "/path/to/vol1.qcow2",
5439                             "capacity": 12345,
5440                             "allocation": 1234,
5441                             "used_by": [],
5442                             "backing_store": None,
5443                             "format": "qcow2",
5444                         },
5445                         "vol2": {
5446                             "type": "file",
5447                             "key": "/key/of/vol2",
5448                             "path": "/path/to/vol2.qcow2",
5449                             "capacity": 12345,
5450                             "allocation": 1234,
5451                             "used_by": ["vm2"],
5452                             "backing_store": {
5453                                 "path": "/path/to/vol0.qcow2",
5454                                 "format": "qcow2",
5455                             },
5456                             "format": "qcow2",
5457                         },
5458                     }
5459                 },
5460             )
5461             self.assertEqual(
5462                 virt.volume_infos(None, "vol2"),
5463                 {
5464                     "pool1": {
5465                         "vol2": {
5466                             "type": "file",
5467                             "key": "/key/of/vol2",
5468                             "path": "/path/to/vol2.qcow2",
5469                             "capacity": 12345,
5470                             "allocation": 1234,
5471                             "used_by": ["vm2"],
5472                             "backing_store": {
5473                                 "path": "/path/to/vol0.qcow2",
5474                                 "format": "qcow2",
5475                             },
5476                             "format": "qcow2",
5477                         }
5478                     }
5479                 },
5480             )
5481         with patch(
5482             "salt.modules.virt._get_domain", MagicMock(return_value=mock_vms[0])
5483         ):
5484             actual = virt.volume_infos("pool0", "vol0")
5485             self.assertEqual(1, len(actual.keys()))
5486             self.assertEqual(1, len(actual["pool0"].keys()))
5487             self.assertEqual(["vm0"], sorted(actual["pool0"]["vol0"]["used_by"]))
5488             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5489             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5490             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5491             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5492             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5493             self.assertEqual(
5494                 virt.volume_infos("pool1", None),
5495                 {
5496                     "pool1": {
5497                         "vol1": {
5498                             "type": "file",
5499                             "key": "/key/of/vol1",
5500                             "path": "/path/to/vol1.qcow2",
5501                             "capacity": 12345,
5502                             "allocation": 1234,
5503                             "used_by": [],
5504                             "backing_store": None,
5505                             "format": "qcow2",
5506                         },
5507                         "vol2": {
5508                             "type": "file",
5509                             "key": "/key/of/vol2",
5510                             "path": "/path/to/vol2.qcow2",
5511                             "capacity": 12345,
5512                             "allocation": 1234,
5513                             "used_by": [],
5514                             "backing_store": {
5515                                 "path": "/path/to/vol0.qcow2",
5516                                 "format": "qcow2",
5517                             },
5518                             "format": "qcow2",
5519                         },
5520                     }
5521                 },
5522             )
5523             self.assertEqual(
5524                 virt.volume_infos(None, "vol2"),
5525                 {
5526                     "pool1": {
5527                         "vol2": {
5528                             "type": "file",
5529                             "key": "/key/of/vol2",
5530                             "path": "/path/to/vol2.qcow2",
5531                             "capacity": 12345,
5532                             "allocation": 1234,
5533                             "used_by": [],
5534                             "backing_store": {
5535                                 "path": "/path/to/vol0.qcow2",
5536                                 "format": "qcow2",
5537                             },
5538                             "format": "qcow2",
5539                         }
5540                     }
5541                 },
5542             )
5543         with patch(
5544             "salt.modules.virt._get_domain",
5545             MagicMock(side_effect=CommandExecutionError("no VM")),
5546         ):
5547             actual = virt.volume_infos("pool0", "vol0")
5548             self.assertEqual(1, len(actual.keys()))
5549             self.assertEqual(1, len(actual["pool0"].keys()))
5550             self.assertEqual([], sorted(actual["pool0"]["vol0"]["used_by"]))
5551             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5552             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5553             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5554             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5555             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5556             self.assertEqual(
5557                 virt.volume_infos("pool1", None),
5558                 {
5559                     "pool1": {
5560                         "vol1": {
5561                             "type": "file",
5562                             "key": "/key/of/vol1",
5563                             "path": "/path/to/vol1.qcow2",
5564                             "capacity": 12345,
5565                             "allocation": 1234,
5566                             "used_by": [],
5567                             "backing_store": None,
5568                             "format": "qcow2",
5569                         },
5570                         "vol2": {
5571                             "type": "file",
5572                             "key": "/key/of/vol2",
5573                             "path": "/path/to/vol2.qcow2",
5574                             "capacity": 12345,
5575                             "allocation": 1234,
5576                             "used_by": [],
5577                             "backing_store": {
5578                                 "path": "/path/to/vol0.qcow2",
5579                                 "format": "qcow2",
5580                             },
5581                             "format": "qcow2",
5582                         },
5583                     }
5584                 },
5585             )
5586             self.assertEqual(
5587                 virt.volume_infos(None, "vol2"),
5588                 {
5589                     "pool1": {
5590                         "vol2": {
5591                             "type": "file",
5592                             "key": "/key/of/vol2",
5593                             "path": "/path/to/vol2.qcow2",
5594                             "capacity": 12345,
5595                             "allocation": 1234,
5596                             "used_by": [],
5597                             "backing_store": {
5598                                 "path": "/path/to/vol0.qcow2",
5599                                 "format": "qcow2",
5600                             },
5601                             "format": "qcow2",
5602                         }
5603                     }
5604                 },
5605             )
5606     def test_volume_delete(self):
5607         mock_delete = MagicMock(side_effect=[0, 1])
5608         mock_volume = MagicMock()
5609         mock_volume.delete = mock_delete  # pylint: disable=no-member
5610         mock_pool = MagicMock()
5611         mock_pool.storageVolLookupByName.side_effect = [
5612             mock_volume,
5613             mock_volume,
5614             self.mock_libvirt.libvirtError("Missing volume"),
5615             mock_volume,
5616         ]
5617         self.mock_conn.storagePoolLookupByName.side_effect = [
5618             mock_pool,
5619             mock_pool,
5620             mock_pool,
5621             self.mock_libvirt.libvirtError("Missing pool"),
5622         ]
5623         self.assertTrue(virt.volume_delete("default", "test_volume"))
5624         self.assertFalse(virt.volume_delete("default", "test_volume"))
5625         with self.assertRaises(self.mock_libvirt.libvirtError):
5626             virt.volume_delete("default", "missing")
5627             virt.volume_delete("missing", "test_volume")
5628         self.assertEqual(mock_delete.call_count, 2)
5629     def test_pool_capabilities(self):
5630         xml_caps = """
5631 &lt;storagepoolCapabilities&gt;
5632   &lt;pool type='disk' supported='yes'&gt;
5633     &lt;poolOptions&gt;
5634       &lt;defaultFormat type='unknown'/&gt;
5635       &lt;enum name='sourceFormatType'&gt;
5636         &lt;value&gt;unknown&lt;/value&gt;
5637         &lt;value&gt;dos&lt;/value&gt;
5638         &lt;value&gt;dvh&lt;/value&gt;
5639       &lt;/enum&gt;
5640     &lt;/poolOptions&gt;
5641     &lt;volOptions&gt;
5642       &lt;defaultFormat type='none'/&gt;
5643       &lt;enum name='targetFormatType'&gt;
5644         &lt;value&gt;none&lt;/value&gt;
5645         &lt;value&gt;linux&lt;/value&gt;
5646       &lt;/enum&gt;
5647     &lt;/volOptions&gt;
5648   &lt;/pool&gt;
5649   &lt;pool type='iscsi' supported='yes'&gt;
5650   &lt;/pool&gt;
5651   &lt;pool type='rbd' supported='yes'&gt;
5652     &lt;volOptions&gt;
5653       &lt;defaultFormat type='raw'/&gt;
5654       &lt;enum name='targetFormatType'&gt;
5655       &lt;/enum&gt;
5656     &lt;/volOptions&gt;
5657   &lt;/pool&gt;
5658   &lt;pool type='sheepdog' supported='no'&gt;
5659   &lt;/pool&gt;
5660 &lt;/storagepoolCapabilities&gt;
5661         """
5662         self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)
5663         actual = virt.pool_capabilities()
5664         self.assertEqual(
5665             {
5666                 "computed": False,
5667                 "pool_types": [
5668                     {
5669                         "name": "disk",
5670                         "supported": True,
5671                         "options": {
5672                             "pool": {
5673                                 "default_format": "unknown",
5674                                 "sourceFormatType": ["unknown", "dos", "dvh"],
5675                             },
5676                             "volume": {
5677                                 "default_format": "none",
5678                                 "targetFormatType": ["none", "linux"],
5679                             },
5680                         },
5681                     },
5682                     {"name": "iscsi", "supported": True},
5683                     {
5684                         "name": "rbd",
5685                         "supported": True,
5686                         "options": {
5687                             "volume": {"default_format": "raw", "targetFormatType": []}
5688                         },
5689                     },
5690                     {"name": "sheepdog", "supported": False},
5691                 ],
5692             },
5693             actual,
5694         )
5695     @patch("salt.modules.virt.get_hypervisor", return_value="kvm")
5696     def test_pool_capabilities_computed(self, mock_get_hypervisor):
5697         self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
5698         del self.mock_conn.getStoragePoolCapabilities
5699         actual = virt.pool_capabilities()
5700         self.assertTrue(actual["computed"])
5701         backends = actual["pool_types"]
5702         self.assertFalse(
5703             [backend for backend in backends if backend["name"] == "iscsi-direct"][0][
5704                 "supported"
5705             ]
5706         )
5707         self.assertTrue(
5708             [backend for backend in backends if backend["name"] == "gluster"][0][
5709                 "supported"
5710             ]
5711         )
5712         self.assertFalse(
5713             [backend for backend in backends if backend["name"] == "zfs"][0][
5714                 "supported"
5715             ]
5716         )
5717         mock_get_hypervisor.return_value = "xen"
5718         backends = virt.pool_capabilities()["pool_types"]
5719         self.assertFalse(
5720             [backend for backend in backends if backend["name"] == "gluster"][0][
5721                 "supported"
5722             ]
5723         )
5724         mock_get_hypervisor.return_value = "bhyve"
5725         backends = virt.pool_capabilities()["pool_types"]
5726         self.assertFalse(
5727             [backend for backend in backends if backend["name"] == "gluster"][0][
5728                 "supported"
5729             ]
5730         )
5731         self.assertTrue(
5732             [backend for backend in backends if backend["name"] == "zfs"][0][
5733                 "supported"
5734             ]
5735         )
5736         self.assertNotIn(
5737             "options",
5738             [backend for backend in backends if backend["name"] == "iscsi"][0],
5739         )
5740         self.assertNotIn(
5741             "pool",
5742             [backend for backend in backends if backend["name"] == "dir"][0]["options"],
5743         )
5744         self.assertNotIn(
5745             "volume",
5746             [backend for backend in backends if backend["name"] == "logical"][0][
5747                 "options"
5748             ],
5749         )
5750         self.assertEqual(
5751             {
5752                 "pool": {
5753                     "default_format": "auto",
5754                     "sourceFormatType": ["auto", "nfs", "glusterfs", "cifs"],
5755                 },
5756                 "volume": {
5757                     "default_format": "raw",
5758                     "targetFormatType": [
5759                         "none",
5760                         "raw",
5761                         "dir",
5762                         "bochs",
5763                         "cloop",
5764                         "dmg",
5765                         "iso",
5766                         "vpc",
5767                         "vdi",
5768                         "fat",
5769                         "vhd",
5770                         "ploop",
5771                         "cow",
5772                         "qcow",
5773                         "qcow2",
5774                         "qed",
5775                         "vmdk",
5776                     ],
5777                 },
5778             },
5779             [backend for backend in backends if backend["name"] == "netfs"][0][
5780                 "options"
5781             ],
5782         )
5783     def test_get_domain(self):
5784         self.mock_conn.listDomainsID.return_value = []
5785         self.mock_conn.listDefinedDomains.return_value = []
5786         self.assertEqual([], virt._get_domain(self.mock_conn))
5787         self.assertRaisesRegex(
5788             CommandExecutionError,
5789             "No virtual machines found.",
5790             virt._get_domain,
5791             self.mock_conn,
5792             "vm2",
5793         )
5794         self.mock_conn.listDomainsID.return_value = [1]
5795         def create_mock_vm(idx):
5796             mock_vm = MagicMock()
5797             mock_vm.name.return_value = "vm{}".format(idx)
5798 <a name="10"></a>            return mock_vm
5799         mock_vms = [create_mock_vm(idx) for idx in range(3)]
5800         self.mock_conn.lookupByID.return_value <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= mock_vms[0]
5801         self.mock_conn.listDefinedDomains.return_value = ["vm1", "vm2"]
5802         self.mock_conn.lookupByName.side_effect = mock_vms
5803         self.</b></font>assertEqual(mock_vms, virt._get_domain(self.mock_conn))
5804         self.mock_conn.lookupByName.side_effect = None
5805         self.mock_conn.lookupByName.return_value = mock_vms[0]
5806         self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))
5807         self.mock_conn.lookupByName.return_value = None
5808         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5809         self.assertEqual(
5810             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
5811         )
5812         self.mock_conn.reset_mock()
5813         self.mock_conn.lookupByName.return_value = None
5814         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5815         self.assertEqual(
5816             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, "vm1", "vm2")
5817         )
5818         self.assertRaisesRegex(
5819             CommandExecutionError,
5820             'The VM "vm2" is not present',
5821             virt._get_domain,
5822             self.mock_conn,
5823             "vm2",
5824             inactive=False,
5825         )
5826     def test_volume_define(self):
5827         pool_mock = MagicMock()
5828         pool_mock.XMLDesc.return_value = "&lt;pool type='dir'&gt;&lt;/pool&gt;"
5829         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5830         self.assertTrue(
5831             virt.volume_define(
5832                 "testpool",
5833                 "myvm_system.qcow2",
5834                 8192,
5835                 allocation=4096,
5836                 format="qcow2",
5837                 type="file",
5838             )
5839         )
5840         expected_xml = (
5841             "&lt;volume type='file'&gt;\n"
5842             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5843             "  &lt;source&gt;\n"
5844             "  &lt;/source&gt;\n"
5845             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5846             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5847             "  &lt;target&gt;\n"
5848             "    &lt;format type='qcow2'/&gt;\n"
5849             "  &lt;/target&gt;\n"
5850             "&lt;/volume&gt;"
5851         )
5852         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5853         pool_mock.reset_mock()
5854         self.assertTrue(
5855             virt.volume_define(
5856                 "testpool",
5857                 "myvm_system.qcow2",
5858                 8192,
5859                 allocation=4096,
5860                 format="qcow2",
5861                 type="file",
5862                 backing_store={"path": "/path/to/base.raw", "format": "raw"},
5863             )
5864         )
5865         expected_xml = (
5866             "&lt;volume type='file'&gt;\n"
5867             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5868             "  &lt;source&gt;\n"
5869             "  &lt;/source&gt;\n"
5870             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5871             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5872             "  &lt;target&gt;\n"
5873             "    &lt;format type='qcow2'/&gt;\n"
5874             "  &lt;/target&gt;\n"
5875             "  &lt;backingStore&gt;\n"
5876             "    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n"
5877             "    &lt;format type='raw'/&gt;\n"
5878             "  &lt;/backingStore&gt;\n"
5879             "&lt;/volume&gt;"
5880         )
5881         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5882         pool_mock.reset_mock()
5883         pool_mock.XMLDesc.return_value = "&lt;pool type='logical'&gt;&lt;/pool&gt;"
5884         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5885         self.assertTrue(
5886             virt.volume_define(
5887                 "testVG",
5888                 "myvm_system",
5889                 8192,
5890                 backing_store={"path": "/dev/testVG/base"},
5891             )
5892         )
5893         expected_xml = (
5894             "&lt;volume&gt;\n"
5895             "  &lt;name&gt;myvm_system&lt;/name&gt;\n"
5896             "  &lt;source&gt;\n"
5897             "  &lt;/source&gt;\n"
5898             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5899             "  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n"
5900             "  &lt;target&gt;\n"
5901             "  &lt;/target&gt;\n"
5902             "  &lt;backingStore&gt;\n"
5903             "    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n"
5904             "  &lt;/backingStore&gt;\n"
5905             "&lt;/volume&gt;"
5906         )
5907         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5908     def test_volume_upload(self):
5909         pool_mock = MagicMock()
5910         vol_mock = MagicMock()
5911         pool_mock.storageVolLookupByName.return_value = vol_mock
5912         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5913         stream_mock = MagicMock()
5914         self.mock_conn.newStream.return_value = stream_mock
5915         open_mock = MagicMock()
5916         close_mock = MagicMock()
5917         with patch.dict(
5918             os.__dict__, {"open": open_mock, "close": close_mock}
5919         ):  # pylint: disable=no-member
5920             self.assertTrue(virt.volume_upload("pool0", "vol1.qcow2", "/path/to/file"))
5921             stream_mock.sendAll.assert_called_once()
5922             stream_mock.finish.assert_called_once()
5923             self.mock_conn.close.assert_called_once()
5924             vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
5925             stream_mock.sendAll.reset_mock()
5926             vol_mock.upload.reset_mock()
5927             self.assertTrue(
5928                 virt.volume_upload(
5929                     "pool0",
5930                     "vol1.qcow2",
5931                     "/path/to/file",
5932                     offset=123,
5933                     length=456,
5934                     sparse=True,
5935                 )
5936             )
5937             stream_mock.sendAll.assert_not_called()
5938             stream_mock.sparseSendAll.assert_called_once()
5939             vol_mock.upload.assert_called_once_with(
5940                 stream_mock,
5941                 123,
5942                 456,
5943                 self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
5944             )
5945             vol_mock.upload.side_effect = self.mock_libvirt.libvirtError("Unsupported")
5946             self.assertRaisesRegex(
5947                 CommandExecutionError,
5948                 "Unsupported",
5949                 virt.volume_upload,
5950                 "pool0",
5951                 "vol1.qcow2",
5952                 "/path/to/file",
5953             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
