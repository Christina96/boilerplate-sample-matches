<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for __init___43.py & test_virt_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for __init___43.py & test_virt_1.py
      </h3>
      <h1 align="center">
        2.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>__init___43.py (7.6578817%)<TH>test_virt_1.py (1.8335516%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#0',2,'match118032-1.html#0',3)" NAME="0">(117-137)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#0',2,'match118032-1.html#0',3)" NAME="0">(558-563)</A><TD ALIGN=center><FONT COLOR="#ff0000">22</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#1',2,'match118032-1.html#1',3)" NAME="1">(896-900)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#1',2,'match118032-1.html#1',3)" NAME="1">(5595-5599)</A><TD ALIGN=center><FONT COLOR="#b90000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#2',2,'match118032-1.html#2',3)" NAME="2">(763-766)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#2',2,'match118032-1.html#2',3)" NAME="2">(1745-1759)</A><TD ALIGN=center><FONT COLOR="#ad0000">15</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#3',2,'match118032-1.html#3',3)" NAME="3">(7-22)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#3',2,'match118032-1.html#3',3)" NAME="3">(8-25)</A><TD ALIGN=center><FONT COLOR="#ad0000">15</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#4',2,'match118032-1.html#4',3)" NAME="4">(788-801)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#4',2,'match118032-1.html#4',3)" NAME="4">(5998-6005)</A><TD ALIGN=center><FONT COLOR="#960000">13</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#5',2,'match118032-1.html#5',3)" NAME="5">(214-216)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#5',2,'match118032-1.html#5',3)" NAME="5">(280-299)</A><TD ALIGN=center><FONT COLOR="#960000">13</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#6',2,'match118032-1.html#6',3)" NAME="6">(718-725)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#6',2,'match118032-1.html#6',3)" NAME="6">(110-116)</A><TD ALIGN=center><FONT COLOR="#8b0000">12</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#7',2,'match118032-1.html#7',3)" NAME="7">(618-622)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#7',2,'match118032-1.html#7',3)" NAME="7">(1813-1837)</A><TD ALIGN=center><FONT COLOR="#8b0000">12</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#8',2,'match118032-1.html#8',3)" NAME="8">(546-553)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#8',2,'match118032-1.html#8',3)" NAME="8">(1404-1416)</A><TD ALIGN=center><FONT COLOR="#8b0000">12</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#9',2,'match118032-1.html#9',3)" NAME="9">(330-335)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#9',2,'match118032-1.html#9',3)" NAME="9">(1363-1376)</A><TD ALIGN=center><FONT COLOR="#8b0000">12</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match118032-0.html#10',2,'match118032-1.html#10',3)" NAME="10">(308-310)<TD><A HREF="javascript:ZweiFrames('match118032-0.html#10',2,'match118032-1.html#10',3)" NAME="10">(6840-6844)</A><TD ALIGN=center><FONT COLOR="#8b0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___43.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
This module provides the point of entry to SPM, the Salt Package Manager

<A NAME="3"></A>.. versionadded:: 2015.8.0
&quot;&quot;&quot;

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match118032-1.html#3',3,'match118032-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import hashlib
import logging
import os
import shutil
import sys
import tarfile

import salt.cache
import salt.client
import salt.config
import salt.loader
import salt.syspaths as syspaths
import salt.utils.files
import salt.utils.http as http
import salt.utils.path
import</B></FONT> salt.utils.platform
import salt.utils.win_functions
import salt.utils.yaml
from salt.template import compile_template

try:
    import pwd
    import grp
except ImportError:
    pass


log = logging.getLogger(__name__)

FILE_TYPES = (&quot;c&quot;, &quot;d&quot;, &quot;g&quot;, &quot;l&quot;, &quot;r&quot;, &quot;s&quot;, &quot;m&quot;)
# c: config file
# d: documentation file
# g: ghost file (i.e. the file contents are not included in the package payload)
# l: license file
# r: readme file
# s: SLS file
# m: Salt module


class SPMException(Exception):
    &quot;&quot;&quot;
    Base class for SPMClient exceptions
    &quot;&quot;&quot;


class SPMInvocationError(SPMException):
    &quot;&quot;&quot;
    Wrong number of arguments or other usage error
    &quot;&quot;&quot;


class SPMPackageError(SPMException):
    &quot;&quot;&quot;
    Problem with package file or package installation
    &quot;&quot;&quot;


class SPMDatabaseError(SPMException):
    &quot;&quot;&quot;
    SPM database not found, etc
    &quot;&quot;&quot;


class SPMOperationCanceled(SPMException):
    &quot;&quot;&quot;
    SPM install or uninstall was canceled
    &quot;&quot;&quot;


class SPMClient:
    &quot;&quot;&quot;
    Provide an SPM Client
    &quot;&quot;&quot;

    def __init__(self, ui, opts=None):  # pylint: disable=W0231
        self.ui = ui
        if not opts:
            opts = salt.config.spm_config(os.path.join(syspaths.CONFIG_DIR, &quot;spm&quot;))
        self.opts = opts
        self.db_prov = self.opts.get(&quot;spm_db_provider&quot;, &quot;sqlite3&quot;)
        self.files_prov = self.opts.get(&quot;spm_files_provider&quot;, &quot;local&quot;)
        self._prep_pkgdb()
        self._prep_pkgfiles()
        self.db_conn = None
        self.files_conn = None
        self._init()

    def _prep_pkgdb(self):
        self.pkgdb = salt.loader.pkgdb(self.opts)

    def _prep_pkgfiles(self):
        self.pkgfiles = salt.loader.pkgfiles(self.opts)

    def _init(self):
        if not self.db_conn:
            self.db_conn = self._pkgdb_fun(&quot;init&quot;)
        if not self.files_conn:
            self.files_conn = self._pkgfiles_fun(&quot;init&quot;)

    def _close(self):
        if self.db_conn:
            self.db_conn.close()

    def run(self, args):
        &quot;&quot;&quot;
        Run the SPM command
        &quot;&quot;&quot;
<A NAME="0"></A>        command = args[0]
        try:
            if command == &quot;install&quot;:
                self<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match118032-1.html#0',3,'match118032-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>._install(args)
            elif command == &quot;local&quot;:
                self._local(args)
            elif command == &quot;repo&quot;:
                self._repo(args)
            elif command == &quot;remove&quot;:
                self._remove(args)
            elif command == &quot;build&quot;:
                self._build(args)
            elif command == &quot;update_repo&quot;:
                self._download_repo_metadata(args)
            elif command == &quot;create_repo&quot;:
                self._create_repo(args)
            elif command == &quot;files&quot;:
                self._list_files(args)
            elif command == &quot;info&quot;:
                self._info(args)
            elif command == &quot;list&quot;:
                self._list(args)
            elif command == &quot;close&quot;:
                self._close(</B></FONT>)
            else:
                raise SPMInvocationError(&quot;Invalid command '{}'&quot;.format(command))
        except SPMException as exc:
            self.ui.error(str(exc))

    def _pkgdb_fun(self, func, *args, **kwargs):
        try:
            return getattr(getattr(self.pkgdb, self.db_prov), func)(*args, **kwargs)
        except AttributeError:
            return self.pkgdb[&quot;{}.{}&quot;.format(self.db_prov, func)](*args, **kwargs)

    def _pkgfiles_fun(self, func, *args, **kwargs):
        try:
            return getattr(getattr(self.pkgfiles, self.files_prov), func)(
                *args, **kwargs
            )
        except AttributeError:
            return self.pkgfiles[&quot;{}.{}&quot;.format(self.files_prov, func)](*args, **kwargs)

    def _list(self, args):
        &quot;&quot;&quot;
        Process local commands
        &quot;&quot;&quot;
        args.pop(0)
        command = args[0]
        if command == &quot;packages&quot;:
            self._list_packages(args)
        elif command == &quot;files&quot;:
            self._list_files(args)
        elif command == &quot;repos&quot;:
            self._repo_list(args)
        else:
            raise SPMInvocationError(&quot;Invalid list command '{}'&quot;.format(command))

    def _local(self, args):
        &quot;&quot;&quot;
        Process local commands
        &quot;&quot;&quot;
        args.pop(0)
        command = args[0]
        if command == &quot;install&quot;:
            self._local_install(args)
        elif command == &quot;files&quot;:
            self._local_list_files(args)
        elif command == &quot;info&quot;:
            self._local_info(args)
        else:
            raise SPMInvocationError(&quot;Invalid local command '{}'&quot;.format(command))

    def _repo(self, args):
        &quot;&quot;&quot;
        Process repo commands
        &quot;&quot;&quot;
        args.pop(0)
        command = args[0]
        if command == &quot;list&quot;:
            self._repo_list(args)
        elif command == &quot;packages&quot;:
            self._repo_packages(args)
        elif command == &quot;search&quot;:
            self._repo_packages(args, search=True)
        elif command == &quot;update&quot;:
            self._download_repo_metadata(args)
        elif command == &quot;create&quot;:
            self._create_repo(args)
        else:
            raise SPMInvocationError(&quot;Invalid repo command '{}'&quot;.format(command))

    def _repo_packages(self, args, search=False):
        &quot;&quot;&quot;
        List packages for one or more configured repos
        &quot;&quot;&quot;
        packages = []
<A NAME="5"></A>        repo_metadata = self._get_repo_metadata()
        for repo in repo_metadata:
            for pkg in repo_metadata[repo][&quot;packages&quot;]:
                if args<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match118032-1.html#5',3,'match118032-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[1] in pkg:
                    version = repo_metadata[repo][&quot;packages&quot;][pkg][&quot;info&quot;][&quot;version&quot;]
                    release = repo_metadata[repo][&quot;packages&quot;][pkg][&quot;info&quot;][</B></FONT>&quot;release&quot;]
                    packages.append((pkg, version, release, repo))
        for pkg in sorted(packages):
            self.ui.status(&quot;{}\t{}-{}\t{}&quot;.format(pkg[0], pkg[1], pkg[2], pkg[3]))
        return packages

    def _repo_list(self, args):
        &quot;&quot;&quot;
        List configured repos

        This can be called either as a ``repo`` command or a ``list`` command
        &quot;&quot;&quot;
        repo_metadata = self._get_repo_metadata()
        for repo in repo_metadata:
            self.ui.status(repo)

    def _install(self, args):
        &quot;&quot;&quot;
        Install a package from a repo
        &quot;&quot;&quot;
        if len(args) &lt; 2:
            raise SPMInvocationError(&quot;A package must be specified&quot;)

        caller_opts = self.opts.copy()
        caller_opts[&quot;file_client&quot;] = &quot;local&quot;
        self.caller = salt.client.Caller(mopts=caller_opts)
        self.client = salt.client.get_local_client(self.opts[&quot;conf_file&quot;])
        cache = salt.cache.Cache(self.opts)

        packages = args[1:]
        file_map = {}
        optional = []
        recommended = []
        to_install = []
        for pkg in packages:
            if pkg.endswith(&quot;.spm&quot;):
                if self._pkgfiles_fun(&quot;path_exists&quot;, pkg):
                    comps = pkg.split(&quot;-&quot;)
                    comps = os.path.split(&quot;-&quot;.join(comps[:-2]))
                    pkg_name = comps[-1]

                    formula_tar = tarfile.open(pkg, &quot;r:bz2&quot;)
                    formula_ref = formula_tar.extractfile(&quot;{}/FORMULA&quot;.format(pkg_name))
                    formula_def = salt.utils.yaml.safe_load(formula_ref)

                    file_map[pkg_name] = pkg
                    to_, op_, re_ = self._check_all_deps(
                        pkg_name=pkg_name, pkg_file=pkg, formula_def=formula_def
                    )
                    to_install.extend(to_)
                    optional.extend(op_)
                    recommended.extend(re_)
                    formula_tar.close()
                else:
                    raise SPMInvocationError(&quot;Package file {} not found&quot;.format(pkg))
            else:
                to_, op_, re_ = self._check_all_deps(pkg_name=pkg)
                to_install.extend(to_)
                optional.extend(op_)
                recommended.extend(re_)

        optional = set(filter(len, optional))
        if optional:
            self.ui.status(
                &quot;The following dependencies are optional:\n\t{}\n&quot;.format(
                    &quot;\n\t&quot;.join(optional)
                )
            )
        recommended = set(filter(len, recommended))
        if recommended:
            self.ui.status(
                &quot;The following dependencies are recommended:\n\t{}\n&quot;.format(
                    &quot;\n\t&quot;.join(recommended)
                )
            )

        to_install = set(filter(len, to_install))
        msg = &quot;Installing packages:\n\t{}\n&quot;.format(&quot;\n\t&quot;.join(to_install))
        if not self.opts[&quot;assume_yes&quot;]:
            self.ui.confirm(msg)

        repo_metadata = self._get_repo_metadata()

        dl_list = {}
        for package in to_install:
            if package in file_map:
                self._install_indv_pkg(package, file_map[package])
            else:
                for repo in repo_metadata:
<A NAME="10"></A>                    repo_info = repo_metadata[repo]
                    if package in repo_info[&quot;packages&quot;]:
                        dl_package = False
                        repo_ver <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match118032-1.html#10',3,'match118032-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= repo_info[&quot;packages&quot;][package][&quot;info&quot;][&quot;version&quot;]
                        repo_rel = repo_info[&quot;packages&quot;][package][&quot;info&quot;][&quot;release&quot;]
                        repo_url = repo_info[</B></FONT>&quot;info&quot;][&quot;url&quot;]
                        if package in dl_list:
                            # Check package version, replace if newer version
                            if repo_ver == dl_list[package][&quot;version&quot;]:
                                # Version is the same, check release
                                if repo_rel &gt; dl_list[package][&quot;release&quot;]:
                                    dl_package = True
                                elif repo_rel == dl_list[package][&quot;release&quot;]:
                                    # Version and release are the same, give
                                    # preference to local (file://) repos
                                    if dl_list[package][&quot;source&quot;].startswith(&quot;file://&quot;):
                                        if not repo_url.startswith(&quot;file://&quot;):
                                            dl_package = True
                            elif repo_ver &gt; dl_list[package][&quot;version&quot;]:
                                dl_package = True
                        else:
                            dl_package = True
<A NAME="9"></A>
                        if dl_package is True:
                            # Put together download directory
                            cache_path = os<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match118032-1.html#9',3,'match118032-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.path.join(self.opts[&quot;spm_cache_dir&quot;], repo)

                            # Put together download paths
                            dl_url = &quot;{}/{}&quot;.format(
                                repo_info[&quot;info&quot;][&quot;url&quot;],
                                repo_info[&quot;packages&quot;][</B></FONT>package][&quot;filename&quot;],
                            )
                            out_file = os.path.join(
                                cache_path, repo_info[&quot;packages&quot;][package][&quot;filename&quot;]
                            )
                            dl_list[package] = {
                                &quot;version&quot;: repo_ver,
                                &quot;release&quot;: repo_rel,
                                &quot;source&quot;: dl_url,
                                &quot;dest_dir&quot;: cache_path,
                                &quot;dest_file&quot;: out_file,
                            }

        for package in dl_list:
            dl_url = dl_list[package][&quot;source&quot;]
            cache_path = dl_list[package][&quot;dest_dir&quot;]
            out_file = dl_list[package][&quot;dest_file&quot;]

            # Make sure download directory exists
            if not os.path.exists(cache_path):
                os.makedirs(cache_path)

            # Download the package
            if dl_url.startswith(&quot;file://&quot;):
                dl_url = dl_url.replace(&quot;file://&quot;, &quot;&quot;)
                shutil.copyfile(dl_url, out_file)
            else:
                with salt.utils.files.fopen(out_file, &quot;wb&quot;) as outf:
                    outf.write(
                        self._query_http(dl_url, repo_info[&quot;info&quot;], decode_body=False)
                    )

        # First we download everything, then we install
        for package in dl_list:
            out_file = dl_list[package][&quot;dest_file&quot;]
            # Kick off the install
            self._install_indv_pkg(package, out_file)
        return

    def _local_install(self, args, pkg_name=None):
        &quot;&quot;&quot;
        Install a package from a file
        &quot;&quot;&quot;
        if len(args) &lt; 2:
            raise SPMInvocationError(&quot;A package file must be specified&quot;)

        self._install(args)

    def _check_all_deps(self, pkg_name=None, pkg_file=None, formula_def=None):
        &quot;&quot;&quot;
        Starting with one package, check all packages for dependencies
        &quot;&quot;&quot;
        if pkg_file and not os.path.exists(pkg_file):
            raise SPMInvocationError(&quot;Package file {} not found&quot;.format(pkg_file))

        self.repo_metadata = self._get_repo_metadata()
        if not formula_def:
            for repo in self.repo_metadata:
                if not isinstance(self.repo_metadata[repo][&quot;packages&quot;], dict):
                    continue
                if pkg_name in self.repo_metadata[repo][&quot;packages&quot;]:
                    formula_def = self.repo_metadata[repo][&quot;packages&quot;][pkg_name][&quot;info&quot;]

        if not formula_def:
            raise SPMInvocationError(&quot;Unable to read formula for {}&quot;.format(pkg_name))

        # Check to see if the package is already installed
        pkg_info = self._pkgdb_fun(&quot;info&quot;, pkg_name, self.db_conn)
        pkgs_to_install = []
        if pkg_info is None or self.opts[&quot;force&quot;]:
            pkgs_to_install.append(pkg_name)
        elif pkg_info is not None and not self.opts[&quot;force&quot;]:
            raise SPMPackageError(
                &quot;Package {} already installed, not installing again&quot;.format(
                    formula_def[&quot;name&quot;]
                )
            )

        optional_install = []
        recommended_install = []
        if (
            &quot;dependencies&quot; in formula_def
            or &quot;optional&quot; in formula_def
            or &quot;recommended&quot; in formula_def
        ):
            self.avail_pkgs = {}
            for repo in self.repo_metadata:
                if not isinstance(self.repo_metadata[repo][&quot;packages&quot;], dict):
                    continue
                for pkg in self.repo_metadata[repo][&quot;packages&quot;]:
                    self.avail_pkgs[pkg] = repo

            needs, unavail, optional, recommended = self._resolve_deps(formula_def)

            if len(unavail) &gt; 0:
                raise SPMPackageError(
                    &quot;Cannot install {}, the following dependencies are needed:\n\n{}&quot;.format(
                        formula_def[&quot;name&quot;], &quot;\n&quot;.join(unavail)
                    )
                )

            if optional:
                optional_install.extend(optional)
                for dep_pkg in optional:
                    pkg_info = self._pkgdb_fun(&quot;info&quot;, formula_def[&quot;name&quot;])
                    msg = dep_pkg
                    if isinstance(pkg_info, dict):
                        msg = &quot;{} [Installed]&quot;.format(dep_pkg)
                    optional_install.append(msg)

            if recommended:
                recommended_install.extend(recommended)
                for dep_pkg in recommended:
                    pkg_info = self._pkgdb_fun(&quot;info&quot;, formula_def[&quot;name&quot;])
                    msg = dep_pkg
                    if isinstance(pkg_info, dict):
                        msg = &quot;{} [Installed]&quot;.format(dep_pkg)
                    recommended_install.append(msg)

            if needs:
                pkgs_to_install.extend(needs)
                for dep_pkg in needs:
                    pkg_info = self._pkgdb_fun(&quot;info&quot;, formula_def[&quot;name&quot;])
                    msg = dep_pkg
                    if isinstance(pkg_info, dict):
                        msg = &quot;{} [Installed]&quot;.format(dep_pkg)

        return pkgs_to_install, optional_install, recommended_install

    def _install_indv_pkg(self, pkg_name, pkg_file):
        &quot;&quot;&quot;
        Install one individual package
        &quot;&quot;&quot;
        self.ui.status(&quot;... installing {}&quot;.format(pkg_name))
        formula_tar = tarfile.open(pkg_file, &quot;r:bz2&quot;)
        formula_ref = formula_tar.extractfile(&quot;{}/FORMULA&quot;.format(pkg_name))
        formula_def = salt.utils.yaml.safe_load(formula_ref)

        for field in (&quot;version&quot;, &quot;release&quot;, &quot;summary&quot;, &quot;description&quot;):
            if field not in formula_def:
                raise SPMPackageError(
                    &quot;Invalid package: the {} was not found&quot;.format(field)
                )

        pkg_files = formula_tar.getmembers()

        # First pass: check for files that already exist
        existing_files = self._pkgfiles_fun(
            &quot;check_existing&quot;, pkg_name, pkg_files, formula_def
        )

        if existing_files and not self.opts[&quot;force&quot;]:
            raise SPMPackageError(
                &quot;Not installing {} due to existing files:\n\n{}&quot;.format(
                    pkg_name, &quot;\n&quot;.join(existing_files)
                )
            )

        # We've decided to install
        self._pkgdb_fun(&quot;register_pkg&quot;, pkg_name, formula_def, self.db_conn)

        # Run the pre_local_state script, if present
        if &quot;pre_local_state&quot; in formula_def:
            high_data = self._render(formula_def[&quot;pre_local_state&quot;], formula_def)
            ret = self.caller.cmd(&quot;state.high&quot;, data=high_data)
        if &quot;pre_tgt_state&quot; in formula_def:
            log.debug(&quot;Executing pre_tgt_state script&quot;)
            high_data = self._render(formula_def[&quot;pre_tgt_state&quot;][&quot;data&quot;], formula_def)
            tgt = formula_def[&quot;pre_tgt_state&quot;][&quot;tgt&quot;]
            ret = self.client.run_job(
                tgt=formula_def[&quot;pre_tgt_state&quot;][&quot;tgt&quot;],
                fun=&quot;state.high&quot;,
                tgt_type=formula_def[&quot;pre_tgt_state&quot;].get(&quot;tgt_type&quot;, &quot;glob&quot;),
                timout=self.opts[&quot;timeout&quot;],
                data=high_data,
            )

        # No defaults for this in config.py; default to the current running
        # user and group
        if salt.utils.platform.is_windows():
            uname = gname = salt.utils.win_functions.get_current_user()
            uname_sid = salt.utils.win_functions.get_sid_from_name(uname)
            uid = self.opts.get(&quot;spm_uid&quot;, uname_sid)
            gid = self.opts.get(&quot;spm_gid&quot;, uname_sid)
        else:
            uid = self.opts.get(&quot;spm_uid&quot;, os.getuid())
            gid = self.opts.get(&quot;spm_gid&quot;, os.getgid())
            uname = pwd.getpwuid(uid)[0]
            gname = grp.getgrgid(gid)[0]

        # Second pass: install the files
        for member in pkg_files:
            member.uid = uid
            member.gid = gid
            member.uname = uname
            member.gname = gname

            out_path = self._pkgfiles_fun(
                &quot;install_file&quot;,
                pkg_name,
                formula_tar,
                member,
                formula_def,
                self.files_conn,
            )
            if out_path is not False:
                if member.isdir():
                    digest = &quot;&quot;
<A NAME="8"></A>                else:
                    self._verbose(
                        &quot;Installing file {} to {}&quot;.format(member.name, out_path),
                        log<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match118032-1.html#8',3,'match118032-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.trace,
                    )
                    file_hash = hashlib.sha1()
                    digest = self._pkgfiles_fun(
                        &quot;hash_file&quot;,
                        os.path.join(out_path, member.name),
                        file_hash,
                        self.</B></FONT>files_conn,
                    )
                self._pkgdb_fun(
                    &quot;register_file&quot;, pkg_name, member, out_path, digest, self.db_conn
                )

        # Run the post_local_state script, if present
        if &quot;post_local_state&quot; in formula_def:
            log.debug(&quot;Executing post_local_state script&quot;)
            high_data = self._render(formula_def[&quot;post_local_state&quot;], formula_def)
            self.caller.cmd(&quot;state.high&quot;, data=high_data)
        if &quot;post_tgt_state&quot; in formula_def:
            log.debug(&quot;Executing post_tgt_state script&quot;)
            high_data = self._render(formula_def[&quot;post_tgt_state&quot;][&quot;data&quot;], formula_def)
            tgt = formula_def[&quot;post_tgt_state&quot;][&quot;tgt&quot;]
            ret = self.client.run_job(
                tgt=formula_def[&quot;post_tgt_state&quot;][&quot;tgt&quot;],
                fun=&quot;state.high&quot;,
                tgt_type=formula_def[&quot;post_tgt_state&quot;].get(&quot;tgt_type&quot;, &quot;glob&quot;),
                timout=self.opts[&quot;timeout&quot;],
                data=high_data,
            )

        formula_tar.close()

    def _resolve_deps(self, formula_def):
        &quot;&quot;&quot;
        Return a list of packages which need to be installed, to resolve all
        dependencies
        &quot;&quot;&quot;
        pkg_info = self.pkgdb[&quot;{}.info&quot;.format(self.db_prov)](formula_def[&quot;name&quot;])
        if not isinstance(pkg_info, dict):
            pkg_info = {}

        can_has = {}
        cant_has = []
        if &quot;dependencies&quot; in formula_def and formula_def[&quot;dependencies&quot;] is None:
            formula_def[&quot;dependencies&quot;] = &quot;&quot;
        for dep in formula_def.get(&quot;dependencies&quot;, &quot;&quot;).split(&quot;,&quot;):
            dep = dep.strip()
            if not dep:
                continue
            if self.pkgdb[&quot;{}.info&quot;.format(self.db_prov)](dep):
                continue

            if dep in self.avail_pkgs:
                can_has[dep] = self.avail_pkgs[dep]
            else:
                cant_has.append(dep)

        optional = formula_def.get(&quot;optional&quot;, &quot;&quot;).split(&quot;,&quot;)
        recommended = formula_def.get(&quot;recommended&quot;, &quot;&quot;).split(&quot;,&quot;)

        inspected = []
        to_inspect = can_has.copy()
        while len(to_inspect) &gt; 0:
            dep = next(iter(to_inspect.keys()))
            del to_inspect[dep]

            # Don't try to resolve the same package more than once
            if dep in inspected:
                continue
<A NAME="7"></A>            inspected.append(dep)

            repo_contents = self.repo_metadata.get(can_has[dep], {})
            repo_packages = repo_contents<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match118032-1.html#7',3,'match118032-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.get(&quot;packages&quot;, {})
            dep_formula = repo_packages.get(dep, {}).get(&quot;info&quot;, {})

            also_can, also_cant, opt_dep, rec_dep = self._resolve_deps(dep_formula)
            can_has.update(</B></FONT>also_can)
            cant_has = sorted(set(cant_has + also_cant))
            optional = sorted(set(optional + opt_dep))
            recommended = sorted(set(recommended + rec_dep))

        return can_has, cant_has, optional, recommended

    def _traverse_repos(self, callback, repo_name=None):
        &quot;&quot;&quot;
        Traverse through all repo files and apply the functionality provided in
        the callback to them
        &quot;&quot;&quot;
        repo_files = []
        if os.path.exists(self.opts[&quot;spm_repos_config&quot;]):
            repo_files.append(self.opts[&quot;spm_repos_config&quot;])

        for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(
            &quot;{}.d&quot;.format(self.opts[&quot;spm_repos_config&quot;])
        ):
            for repo_file in filenames:
                if not repo_file.endswith(&quot;.repo&quot;):
                    continue
                repo_files.append(repo_file)

        for repo_file in repo_files:
            repo_path = &quot;{}.d/{}&quot;.format(self.opts[&quot;spm_repos_config&quot;], repo_file)
            with salt.utils.files.fopen(repo_path) as rph:
                repo_data = salt.utils.yaml.safe_load(rph)
                for repo in repo_data:
                    if repo_data[repo].get(&quot;enabled&quot;, True) is False:
                        continue
                    if repo_name is not None and repo != repo_name:
                        continue
                    callback(repo, repo_data[repo])

    def _query_http(self, dl_path, repo_info, decode_body=True):
        &quot;&quot;&quot;
        Download files via http
        &quot;&quot;&quot;
        query = None
        response = None

        try:
            if &quot;username&quot; in repo_info:
                try:
                    if &quot;password&quot; in repo_info:
                        query = http.query(
                            dl_path,
                            text=True,
                            username=repo_info[&quot;username&quot;],
                            password=repo_info[&quot;password&quot;],
                            decode_body=decode_body,
                        )
                    else:
                        raise SPMException(
                            &quot;Auth defined, but password is not set for username: '{}'&quot;.format(
                                repo_info[&quot;username&quot;]
                            )
                        )
                except SPMException as exc:
                    self.ui.error(str(exc))
            else:
                query = http.query(dl_path, text=True, decode_body=decode_body)
        except SPMException as exc:
            self.ui.error(str(exc))

        try:
            if query:
                if &quot;SPM-METADATA&quot; in dl_path:
                    response = salt.utils.yaml.safe_load(query.get(&quot;text&quot;, &quot;{}&quot;))
                else:
                    response = query.get(&quot;text&quot;)
            else:
                raise SPMException(&quot;Response is empty, please check for Errors above.&quot;)
        except SPMException as exc:
            self.ui.error(str(exc))

        return response

    def _download_repo_metadata(self, args):
        &quot;&quot;&quot;
        Connect to all repos and download metadata
        &quot;&quot;&quot;
        cache = salt.cache.Cache(self.opts, self.opts[&quot;spm_cache_dir&quot;])

        def _update_metadata(repo, repo_info):
            dl_path = &quot;{}/SPM-METADATA&quot;.format(repo_info[&quot;url&quot;])
            if dl_path.startswith(&quot;file://&quot;):
                dl_path = dl_path.replace(&quot;file://&quot;, &quot;&quot;)
                with salt.utils.files.fopen(dl_path, &quot;r&quot;) as rpm:
                    metadata = salt.utils.yaml.safe_load(rpm)
            else:
                metadata = self._query_http(dl_path, repo_info)
<A NAME="6"></A>
            cache.store(&quot;.&quot;, repo, metadata)

        repo_name = args<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match118032-1.html#6',3,'match118032-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[1] if len(args) &gt; 1 else None
        self._traverse_repos(_update_metadata, repo_name)

    def _get_repo_metadata(self):
        &quot;&quot;&quot;
        Return cached repo metadata
        &quot;&quot;&quot;
        cache = salt.cache.Cache(self.opts, self.</B></FONT>opts[&quot;spm_cache_dir&quot;])
        metadata = {}

        def _read_metadata(repo, repo_info):
            if cache.updated(&quot;.&quot;, repo) is None:
                log.warning(&quot;Updating repo metadata&quot;)
                self._download_repo_metadata({})

            metadata[repo] = {
                &quot;info&quot;: repo_info,
                &quot;packages&quot;: cache.fetch(&quot;.&quot;, repo),
            }

        self._traverse_repos(_read_metadata)
        return metadata

    def _create_repo(self, args):
        &quot;&quot;&quot;
        Scan a directory and create an SPM-METADATA file which describes
        all of the SPM files in that directory.
        &quot;&quot;&quot;
        if len(args) &lt; 2:
            raise SPMInvocationError(&quot;A path to a directory must be specified&quot;)

        if args[1] == &quot;.&quot;:
            repo_path = os.getcwdu()
        else:
            repo_path = args[1]

        old_files = []
        repo_metadata = {}
        for (dirpath, dirnames, filenames) in salt.utils.path.os_walk(repo_path):
            for spm_file in filenames:
                if not spm_file.endswith(&quot;.spm&quot;):
                    continue
<A NAME="2"></A>                spm_path = &quot;{}/{}&quot;.format(repo_path, spm_file)
                if not tarfile.is_tarfile(spm_path):
                    continue
                comps <FONT color="#980517"><A HREF="javascript:ZweiFrames('match118032-1.html#2',3,'match118032-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= spm_file.split(&quot;-&quot;)
                spm_name = &quot;-&quot;.join(comps[:-2])
                spm_fh = tarfile.open(spm_path, &quot;r:bz2&quot;)
                formula_handle = spm_fh.extractfile(&quot;{}/FORMULA&quot;.format(</B></FONT>spm_name))
                formula_conf = salt.utils.yaml.safe_load(formula_handle.read())

                use_formula = True
                if spm_name in repo_metadata:
                    # This package is already in the repo; use the latest
                    cur_info = repo_metadata[spm_name][&quot;info&quot;]
                    new_info = formula_conf
                    if int(new_info[&quot;version&quot;]) == int(cur_info[&quot;version&quot;]):
                        # Version is the same, check release
                        if int(new_info[&quot;release&quot;]) &lt; int(cur_info[&quot;release&quot;]):
                            # This is an old release; don't use it
                            use_formula = False
                    elif int(new_info[&quot;version&quot;]) &lt; int(cur_info[&quot;version&quot;]):
                        # This is an old version; don't use it
                        use_formula = False

                    if use_formula is True:
                        # Ignore/archive/delete the old version
<A NAME="4"></A>                        log.debug(
                            &quot;%s %s-%s had been added, but %s-%s will replace it&quot;,
                            spm_name,
                            cur_info<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match118032-1.html#4',3,'match118032-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;version&quot;],
                            cur_info[&quot;release&quot;],
                            new_info[&quot;version&quot;],
                            new_info[&quot;release&quot;],
                        )
                        old_files.append(repo_metadata[spm_name][&quot;filename&quot;])
                    else:
                        # Ignore/archive/delete the new version
                        log.debug(
                            &quot;%s %s-%s has been found, but is older than %s-%s&quot;,
                            spm_name,
                            new_info[&quot;version&quot;],
                            new_info[&quot;release&quot;],
                            cur_info[</B></FONT>&quot;version&quot;],
                            cur_info[&quot;release&quot;],
                        )
                        old_files.append(spm_file)

                if use_formula is True:
                    log.debug(
                        &quot;adding %s-%s-%s to the repo&quot;,
                        formula_conf[&quot;name&quot;],
                        formula_conf[&quot;version&quot;],
                        formula_conf[&quot;release&quot;],
                    )
                    repo_metadata[spm_name] = {
                        &quot;info&quot;: formula_conf.copy(),
                    }
                    repo_metadata[spm_name][&quot;filename&quot;] = spm_file

        metadata_filename = &quot;{}/SPM-METADATA&quot;.format(repo_path)
        with salt.utils.files.fopen(metadata_filename, &quot;w&quot;) as mfh:
            salt.utils.yaml.safe_dump(
                repo_metadata,
                mfh,
                indent=4,
                canonical=False,
                default_flow_style=False,
            )

        log.debug(&quot;Wrote %s&quot;, metadata_filename)

        for file_ in old_files:
            if self.opts[&quot;spm_repo_dups&quot;] == &quot;ignore&quot;:
                # ignore old packages, but still only add the latest
                log.debug(&quot;%s will be left in the directory&quot;, file_)
            elif self.opts[&quot;spm_repo_dups&quot;] == &quot;archive&quot;:
                # spm_repo_archive_path is where old packages are moved
                if not os.path.exists(&quot;./archive&quot;):
                    try:
                        os.makedirs(&quot;./archive&quot;)
                        log.debug(&quot;%s has been archived&quot;, file_)
                    except OSError:
                        log.error(&quot;Unable to create archive directory&quot;)
                try:
                    shutil.move(file_, &quot;./archive&quot;)
                except OSError:
                    log.error(&quot;Unable to archive %s&quot;, file_)
            elif self.opts[&quot;spm_repo_dups&quot;] == &quot;delete&quot;:
                # delete old packages from the repo
                try:
                    os.remove(file_)
                    log.debug(&quot;%s has been deleted&quot;, file_)
                except OSError:
                    log.error(&quot;Unable to delete %s&quot;, file_)
                except OSError:  # pylint: disable=duplicate-except
                    # The file has already been deleted
                    pass

    def _remove(self, args):
        &quot;&quot;&quot;
        Remove a package
        &quot;&quot;&quot;
        if len(args) &lt; 2:
            raise SPMInvocationError(&quot;A package must be specified&quot;)

        packages = args[1:]
        msg = &quot;Removing packages:\n\t{}&quot;.format(&quot;\n\t&quot;.join(packages))

        if not self.opts[&quot;assume_yes&quot;]:
            self.ui.confirm(msg)

        for package in packages:
            self.ui.status(&quot;... removing {}&quot;.format(package))

            if not self._pkgdb_fun(&quot;db_exists&quot;, self.opts[&quot;spm_db&quot;]):
                raise SPMDatabaseError(
                    &quot;No database at {}, cannot remove {}&quot;.format(
                        self.opts[&quot;spm_db&quot;], package
                    )
                )

            # Look at local repo index
            pkg_info = self._pkgdb_fun(&quot;info&quot;, package, self.db_conn)
            if pkg_info is None:
                raise SPMInvocationError(&quot;Package {} not installed&quot;.format(package))

            # Find files that have not changed and remove them
            files = self._pkgdb_fun(&quot;list_files&quot;, package, self.db_conn)
            dirs = []
            for filerow in files:
                if self._pkgfiles_fun(&quot;path_isdir&quot;, filerow[0]):
                    dirs.append(filerow[0])
                    continue
                file_hash = hashlib.sha1()
<A NAME="1"></A>                digest = self._pkgfiles_fun(
                    &quot;hash_file&quot;, filerow[0], file_hash, self.files_conn
                )
                if filerow<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match118032-1.html#1',3,'match118032-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[1] == digest:
                    self._verbose(&quot;Removing file {}&quot;.format(filerow[0]), log.trace)
                    self._pkgfiles_fun(&quot;remove_file&quot;, filerow[0], self.files_conn)
                else:
                    self._verbose(&quot;Not removing file {}&quot;.format(filerow[</B></FONT>0]), log.trace)
                self._pkgdb_fun(&quot;unregister_file&quot;, filerow[0], package, self.db_conn)

            # Clean up directories
            for dir_ in sorted(dirs, reverse=True):
                self._pkgdb_fun(&quot;unregister_file&quot;, dir_, package, self.db_conn)
                try:
                    self._verbose(&quot;Removing directory {}&quot;.format(dir_), log.trace)
                    os.rmdir(dir_)
                except OSError:
                    # Leave directories in place that still have files in them
                    self._verbose(
                        &quot;Cannot remove directory {}, probably not empty&quot;.format(dir_),
                        log.trace,
                    )

            self._pkgdb_fun(&quot;unregister_pkg&quot;, package, self.db_conn)

    def _verbose(self, msg, level=log.debug):
        &quot;&quot;&quot;
        Display verbose information
        &quot;&quot;&quot;
        if self.opts.get(&quot;verbose&quot;, False) is True:
            self.ui.status(msg)
        level(msg)

    def _local_info(self, args):
        &quot;&quot;&quot;
        List info for a package file
        &quot;&quot;&quot;
        if len(args) &lt; 2:
            raise SPMInvocationError(&quot;A package filename must be specified&quot;)

        pkg_file = args[1]

        if not os.path.exists(pkg_file):
            raise SPMInvocationError(&quot;Package file {} not found&quot;.format(pkg_file))

        comps = pkg_file.split(&quot;-&quot;)
        comps = &quot;-&quot;.join(comps[:-2]).split(&quot;/&quot;)
        name = comps[-1]

        formula_tar = tarfile.open(pkg_file, &quot;r:bz2&quot;)
        formula_ref = formula_tar.extractfile(&quot;{}/FORMULA&quot;.format(name))
        formula_def = salt.utils.yaml.safe_load(formula_ref)

        self.ui.status(self._get_info(formula_def))
        formula_tar.close()

    def _info(self, args):
        &quot;&quot;&quot;
        List info for a package
        &quot;&quot;&quot;
        if len(args) &lt; 2:
            raise SPMInvocationError(&quot;A package must be specified&quot;)

        package = args[1]

        pkg_info = self._pkgdb_fun(&quot;info&quot;, package, self.db_conn)
        if pkg_info is None:
            raise SPMPackageError(&quot;package {} not installed&quot;.format(package))
        self.ui.status(self._get_info(pkg_info))

    def _get_info(self, formula_def):
        &quot;&quot;&quot;
        Get package info
        &quot;&quot;&quot;
        fields = (
            &quot;name&quot;,
            &quot;os&quot;,
            &quot;os_family&quot;,
            &quot;release&quot;,
            &quot;version&quot;,
            &quot;dependencies&quot;,
            &quot;os_dependencies&quot;,
            &quot;os_family_dependencies&quot;,
            &quot;summary&quot;,
            &quot;description&quot;,
        )
        for item in fields:
            if item not in formula_def:
                formula_def[item] = &quot;None&quot;

        if &quot;installed&quot; not in formula_def:
            formula_def[&quot;installed&quot;] = &quot;Not installed&quot;

        return (
            &quot;Name: {name}\n&quot;
            &quot;Version: {version}\n&quot;
            &quot;Release: {release}\n&quot;
            &quot;Install Date: {installed}\n&quot;
            &quot;Supported OSes: {os}\n&quot;
            &quot;Supported OS families: {os_family}\n&quot;
            &quot;Dependencies: {dependencies}\n&quot;
            &quot;OS Dependencies: {os_dependencies}\n&quot;
            &quot;OS Family Dependencies: {os_family_dependencies}\n&quot;
            &quot;Summary: {summary}\n&quot;
            &quot;Description:\n&quot;
            &quot;{description}&quot;.format(**formula_def)
        )

    def _local_list_files(self, args):
        &quot;&quot;&quot;
        List files for a package file
        &quot;&quot;&quot;
        if len(args) &lt; 2:
            raise SPMInvocationError(&quot;A package filename must be specified&quot;)

        pkg_file = args[1]
        if not os.path.exists(pkg_file):
            raise SPMPackageError(&quot;Package file {} not found&quot;.format(pkg_file))
        formula_tar = tarfile.open(pkg_file, &quot;r:bz2&quot;)
        pkg_files = formula_tar.getmembers()

        for member in pkg_files:
            self.ui.status(member.name)

    def _list_packages(self, args):
        &quot;&quot;&quot;
        List files for an installed package
        &quot;&quot;&quot;
        packages = self._pkgdb_fun(&quot;list_packages&quot;, self.db_conn)
        for package in packages:
            if self.opts[&quot;verbose&quot;]:
                status_msg = &quot;,&quot;.join(package)
            else:
                status_msg = package[0]
            self.ui.status(status_msg)

    def _list_files(self, args):
        &quot;&quot;&quot;
        List files for an installed package
        &quot;&quot;&quot;
        if len(args) &lt; 2:
            raise SPMInvocationError(&quot;A package name must be specified&quot;)

        package = args[-1]

        files = self._pkgdb_fun(&quot;list_files&quot;, package, self.db_conn)
        if files is None:
            raise SPMPackageError(&quot;package {} not installed&quot;.format(package))
        else:
            for file_ in files:
                if self.opts[&quot;verbose&quot;]:
                    status_msg = &quot;,&quot;.join(file_)
                else:
                    status_msg = file_[0]
                self.ui.status(status_msg)

    def _build(self, args):
        &quot;&quot;&quot;
        Build a package
        &quot;&quot;&quot;
        if len(args) &lt; 2:
            raise SPMInvocationError(&quot;A path to a formula must be specified&quot;)

        self.abspath = args[1].rstrip(&quot;/&quot;)
        comps = self.abspath.split(&quot;/&quot;)
        self.relpath = comps[-1]

        formula_path = &quot;{}/FORMULA&quot;.format(self.abspath)
        if not os.path.exists(formula_path):
            raise SPMPackageError(&quot;Formula file {} not found&quot;.format(formula_path))
        with salt.utils.files.fopen(formula_path) as fp_:
            formula_conf = salt.utils.yaml.safe_load(fp_)

        for field in (&quot;name&quot;, &quot;version&quot;, &quot;release&quot;, &quot;summary&quot;, &quot;description&quot;):
            if field not in formula_conf:
                raise SPMPackageError(
                    &quot;Invalid package: a {} must be defined&quot;.format(field)
                )

        out_path = &quot;{}/{}-{}-{}.spm&quot;.format(
            self.opts[&quot;spm_build_dir&quot;],
            formula_conf[&quot;name&quot;],
            formula_conf[&quot;version&quot;],
            formula_conf[&quot;release&quot;],
        )

        if not os.path.exists(self.opts[&quot;spm_build_dir&quot;]):
            os.mkdir(self.opts[&quot;spm_build_dir&quot;])

        self.formula_conf = formula_conf

        formula_tar = tarfile.open(out_path, &quot;w:bz2&quot;)

        if &quot;files&quot; in formula_conf:
            # This allows files to be added to the SPM file in a specific order.
            # It also allows for files to be tagged as a certain type, as with
            # RPM files. This tag is ignored here, but is used when installing
            # the SPM file.
            if isinstance(formula_conf[&quot;files&quot;], list):
                formula_dir = tarfile.TarInfo(formula_conf[&quot;name&quot;])
                formula_dir.type = tarfile.DIRTYPE
                formula_tar.addfile(formula_dir)
                for file_ in formula_conf[&quot;files&quot;]:
                    for ftype in FILE_TYPES:
                        if file_.startswith(&quot;{}|&quot;.format(ftype)):
                            file_ = file_.lstrip(&quot;{}|&quot;.format(ftype))
                    formula_tar.add(
                        os.path.join(os.getcwd(), file_),
                        os.path.join(formula_conf[&quot;name&quot;], file_),
                    )
        else:
            # If no files are specified, then the whole directory will be added.
            try:
                formula_tar.add(
                    formula_path, formula_conf[&quot;name&quot;], filter=self._exclude
                )
                formula_tar.add(
                    self.abspath, formula_conf[&quot;name&quot;], filter=self._exclude
                )
            except TypeError:
                formula_tar.add(
                    formula_path, formula_conf[&quot;name&quot;], exclude=self._exclude
                )
                formula_tar.add(
                    self.abspath, formula_conf[&quot;name&quot;], exclude=self._exclude
                )
        formula_tar.close()

        self.ui.status(&quot;Built package {}&quot;.format(out_path))

    def _exclude(self, member):
        &quot;&quot;&quot;
        Exclude based on opts
        &quot;&quot;&quot;
        if isinstance(member, str):
            return None

        for item in self.opts[&quot;spm_build_exclude&quot;]:
            if member.name.startswith(&quot;{}/{}&quot;.format(self.formula_conf[&quot;name&quot;], item)):
                return None
            elif member.name.startswith(&quot;{}/{}&quot;.format(self.abspath, item)):
                return None
        return member

    def _render(self, data, formula_def):
        &quot;&quot;&quot;
        Render a [pre|post]_local_state or [pre|post]_tgt_state script
        &quot;&quot;&quot;
        # FORMULA can contain a renderer option
        renderer = formula_def.get(&quot;renderer&quot;, self.opts.get(&quot;renderer&quot;, &quot;jinja|yaml&quot;))
        rend = salt.loader.render(self.opts, {})
        blacklist = self.opts.get(&quot;renderer_blacklist&quot;)
        whitelist = self.opts.get(&quot;renderer_whitelist&quot;)
        template_vars = formula_def.copy()
        template_vars[&quot;opts&quot;] = self.opts.copy()
        return compile_template(
            &quot;:string:&quot;,
            rend,
            renderer,
            blacklist,
            whitelist,
            input_data=data,
            **template_vars
        )


class SPMUserInterface:
    &quot;&quot;&quot;
    Handle user interaction with an SPMClient object
    &quot;&quot;&quot;

    def status(self, msg):
        &quot;&quot;&quot;
        Report an SPMClient status message
        &quot;&quot;&quot;
        raise NotImplementedError()

    def error(self, msg):
        &quot;&quot;&quot;
        Report an SPM error message
        &quot;&quot;&quot;
        raise NotImplementedError()

    def confirm(self, action):
        &quot;&quot;&quot;
        Get confirmation from the user before performing an SPMClient action.
        Return if the action is confirmed, or raise SPMOperationCanceled(&lt;msg&gt;)
        if canceled.
        &quot;&quot;&quot;
        raise NotImplementedError()


class SPMCmdlineInterface(SPMUserInterface):
    &quot;&quot;&quot;
    Command-line interface to SPMClient
    &quot;&quot;&quot;

    def status(self, msg):
        print(msg)

    def error(self, msg):
        print(msg, file=sys.stderr)

    def confirm(self, action):
        print(action)
        res = input(&quot;Proceed? [N/y] &quot;)
        if not res.lower().startswith(&quot;y&quot;):
            raise SPMOperationCanceled(&quot;canceled&quot;)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
virt execution module unit tests
&quot;&quot;&quot;

<A NAME="3"></A># pylint: disable=3rd-party-module-not-gated


<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#3',2,'match118032-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import datetime
import os
import shutil
import tempfile
import xml.etree.ElementTree as ET

import salt.config
import salt.modules.config as config
import salt.modules.virt as virt
import salt.syspaths
import salt.utils.yaml
from salt.exceptions import CommandExecutionError, SaltInvocationError

# pylint: disable=import-error
from tests.support.helpers import dedent
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from</B></FONT> tests.support.unit import TestCase

# pylint: disable=invalid-name,protected-access,attribute-defined-outside-init,too-many-public-methods,unused-argument


class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
    &quot;&quot;&quot;
    Libvirt library mock
    &quot;&quot;&quot;

    class virDomain(MagicMock):
        &quot;&quot;&quot;
        virDomain mock
        &quot;&quot;&quot;

    class libvirtError(Exception):
        &quot;&quot;&quot;
        libvirtError mock
        &quot;&quot;&quot;

        def __init__(self, msg):
            super().__init__(msg)
            self.msg = msg

        def get_error_message(self):
            return self.msg


class VirtTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.module.virt
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        self.mock_libvirt = LibvirtMock()
        self.mock_conn = MagicMock()
        self.mock_conn.getStoragePoolCapabilities.return_value = (
            &quot;&lt;storagepoolCapabilities/&gt;&quot;
        )
        self.mock_libvirt.openAuth.return_value = self.mock_conn
        self.mock_popen = MagicMock()
        self.addCleanup(delattr, self, &quot;mock_libvirt&quot;)
        self.addCleanup(delattr, self, &quot;mock_conn&quot;)
        self.addCleanup(delattr, self, &quot;mock_popen&quot;)
        self.mock_subprocess = MagicMock()
        self.mock_subprocess.return_value = (
            self.mock_subprocess
        )  # pylint: disable=no-member
        self.mock_subprocess.Popen.return_value = (
            self.mock_popen
        )  # pylint: disable=no-member
        loader_globals = {
            &quot;__salt__&quot;: {&quot;config.get&quot;: config.get, &quot;config.option&quot;: config.option},
            &quot;libvirt&quot;: self.mock_libvirt,
            &quot;subprocess&quot;: self.mock_subprocess,
        }
        return {virt: loader_globals, config: loader_globals}

    def set_mock_vm(self, name, xml):
        &quot;&quot;&quot;
        Define VM to use in tests
        &quot;&quot;&quot;
        self.mock_conn.listDefinedDomains.return_value = [
            name
        ]  # pylint: disable=no-member
        mock_domain = self.mock_libvirt.virDomain()
        self.mock_conn.lookupByName.return_value = (
            mock_domain  # pylint: disable=no-member
        )
        mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member

        # Return state as shutdown
        mock_domain.info.return_value = [
            4,
            2048 * 1024,
            1024 * 1024,
            2,
            1234,
        ]  # pylint: disable=no-member
        mock_domain.ID.return_value = 1
        mock_domain.name.return_value = name
        return mock_domain
<A NAME="6"></A>
    def assert_equal_unit(self, actual, expected, unit=&quot;KiB&quot;):
        self.assertEqual(actual.get(&quot;unit&quot;), unit)
        self<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#6',2,'match118032-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertEqual(actual.text, str(expected))

    def test_disk_profile_merge(self):
        &quot;&quot;&quot;
        Test virt._disk_profile() when merging with user-defined disks
        &quot;&quot;&quot;
        root_dir = os.path.join(salt.syspaths.</B></FONT>ROOT_DIR, &quot;srv&quot;, &quot;salt-images&quot;)
        userdisks = [
            {&quot;name&quot;: &quot;system&quot;, &quot;image&quot;: &quot;/path/to/image&quot;},
            {&quot;name&quot;: &quot;data&quot;, &quot;size&quot;: 16384, &quot;format&quot;: &quot;raw&quot;},
        ]

        disks = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, userdisks, &quot;myvm&quot;)
        self.assertEqual(
            [
                {
                    &quot;name&quot;: &quot;system&quot;,
                    &quot;device&quot;: &quot;disk&quot;,
                    &quot;size&quot;: 8192,
                    &quot;format&quot;: &quot;qcow2&quot;,
                    &quot;model&quot;: &quot;virtio&quot;,
                    &quot;filename&quot;: &quot;myvm_system.qcow2&quot;,
                    &quot;image&quot;: &quot;/path/to/image&quot;,
                    &quot;source_file&quot;: &quot;{}{}myvm_system.qcow2&quot;.format(root_dir, os.sep),
                },
                {
                    &quot;name&quot;: &quot;data&quot;,
                    &quot;device&quot;: &quot;disk&quot;,
                    &quot;size&quot;: 16384,
                    &quot;format&quot;: &quot;raw&quot;,
                    &quot;model&quot;: &quot;virtio&quot;,
                    &quot;filename&quot;: &quot;myvm_data.raw&quot;,
                    &quot;source_file&quot;: &quot;{}{}myvm_data.raw&quot;.format(root_dir, os.sep),
                },
            ],
            disks,
        )

    def test_boot_default_dev(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() default boot device
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn, &quot;hello&quot;, 1, 512, diskp, nicp, &quot;kvm&quot;, &quot;hvm&quot;, &quot;x86_64&quot;
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;os/boot&quot;).attrib[&quot;dev&quot;], &quot;hd&quot;)
        self.assertEqual(root.find(&quot;os/type&quot;).attrib[&quot;arch&quot;], &quot;x86_64&quot;)
        self.assertEqual(root.find(&quot;os/type&quot;).text, &quot;hvm&quot;)

    def test_boot_custom_dev(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() custom boot device
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            boot_dev=&quot;cdrom&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;os/boot&quot;).attrib[&quot;dev&quot;], &quot;cdrom&quot;)

    def test_boot_multiple_devs(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() multiple boot devices
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            boot_dev=&quot;cdrom network&quot;,
        )
        root = ET.fromstring(xml_data)
        devs = root.findall(&quot;.//boot&quot;)
        self.assertTrue(len(devs) == 2)

    def test_gen_xml_no_nic(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() serial console
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            serials=[{&quot;type&quot;: &quot;pty&quot;}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;devices/serial&quot;).attrib[&quot;type&quot;], &quot;pty&quot;)

    def test_gen_xml_for_telnet_serial(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() telnet serial
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            serials=[{&quot;type&quot;: &quot;tcp&quot;, &quot;port&quot;: 22223, &quot;protocol&quot;: &quot;telnet&quot;}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;devices/serial&quot;).attrib[&quot;type&quot;], &quot;tcp&quot;)
        self.assertEqual(root.find(&quot;devices/serial/source&quot;).attrib[&quot;service&quot;], &quot;22223&quot;)
        self.assertEqual(root.find(&quot;devices/serial/protocol&quot;).attrib[&quot;type&quot;], &quot;telnet&quot;)

    def test_gen_xml_for_telnet_serial_unspecified_port(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() telnet serial without any specified port
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            serials=[{&quot;type&quot;: &quot;tcp&quot;}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;devices/serial&quot;).attrib[&quot;type&quot;], &quot;tcp&quot;)
        self.assertEqual(root.find(&quot;devices/serial/source&quot;).attrib[&quot;service&quot;], &quot;23023&quot;)
        self.assertFalse(&quot;tls&quot; in root.find(&quot;devices/serial/source&quot;).keys())
        self.assertEqual(root.find(&quot;devices/serial/protocol&quot;).attrib[&quot;type&quot;], &quot;telnet&quot;)

    def test_gen_xml_for_chardev_types(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() consoles and serials of various types
        &quot;&quot;&quot;
<A NAME="5"></A>        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#5',2,'match118032-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            consoles=[
                {&quot;type&quot;: &quot;pty&quot;, &quot;path&quot;: &quot;/dev/pts/2&quot;, &quot;target_port&quot;: 2},
                {&quot;type&quot;: &quot;pty&quot;, &quot;target_type&quot;: &quot;usb-serial&quot;},
                {&quot;type&quot;: &quot;stdio&quot;},
                {&quot;type&quot;: &quot;file&quot;, &quot;path&quot;: &quot;/path/to/serial.log&quot;},
            ],
            serials=[
                {&quot;type&quot;: &quot;pipe&quot;, &quot;path&quot;: &quot;/tmp/mypipe&quot;},
                {&quot;type&quot;: &quot;udp&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 1234},
                {&quot;type&quot;: &quot;tcp&quot;, &quot;port&quot;: 22223, &quot;protocol&quot;: &quot;raw&quot;, &quot;tls&quot;: True},
                {&quot;type&quot;</B></FONT>: &quot;unix&quot;, &quot;path&quot;: &quot;/path/to/socket&quot;},
            ],
        )
        root = ET.fromstring(xml_data)

        self.assertEqual(root.find(&quot;devices/console[1]&quot;).attrib[&quot;type&quot;], &quot;pty&quot;)
        self.assertEqual(
            root.find(&quot;devices/console[1]/source&quot;).attrib[&quot;path&quot;], &quot;/dev/pts/2&quot;
        )
        self.assertEqual(root.find(&quot;devices/console[1]/target&quot;).attrib[&quot;port&quot;], &quot;2&quot;)

        self.assertEqual(root.find(&quot;devices/console[2]&quot;).attrib[&quot;type&quot;], &quot;pty&quot;)
        self.assertIsNone(root.find(&quot;devices/console[2]/source&quot;))
        self.assertEqual(
            root.find(&quot;devices/console[2]/target&quot;).attrib[&quot;type&quot;], &quot;usb-serial&quot;
        )

        self.assertEqual(root.find(&quot;devices/console[3]&quot;).attrib[&quot;type&quot;], &quot;stdio&quot;)
        self.assertIsNone(root.find(&quot;devices/console[3]/source&quot;))

        self.assertEqual(root.find(&quot;devices/console[4]&quot;).attrib[&quot;type&quot;], &quot;file&quot;)
        self.assertEqual(
            root.find(&quot;devices/console[4]/source&quot;).attrib[&quot;path&quot;], &quot;/path/to/serial.log&quot;
        )

        self.assertEqual(root.find(&quot;devices/serial[1]&quot;).attrib[&quot;type&quot;], &quot;pipe&quot;)
        self.assertEqual(
            root.find(&quot;devices/serial[1]/source&quot;).attrib[&quot;path&quot;], &quot;/tmp/mypipe&quot;
        )

        self.assertEqual(root.find(&quot;devices/serial[2]&quot;).attrib[&quot;type&quot;], &quot;udp&quot;)
        self.assertEqual(root.find(&quot;devices/serial[2]/source&quot;).attrib[&quot;mode&quot;], &quot;bind&quot;)
        self.assertEqual(
            root.find(&quot;devices/serial[2]/source&quot;).attrib[&quot;service&quot;], &quot;1234&quot;
        )
        self.assertEqual(
            root.find(&quot;devices/serial[2]/source&quot;).attrib[&quot;host&quot;], &quot;127.0.0.1&quot;
        )

        self.assertEqual(root.find(&quot;devices/serial[3]&quot;).attrib[&quot;type&quot;], &quot;tcp&quot;)
        self.assertEqual(root.find(&quot;devices/serial[3]/source&quot;).attrib[&quot;mode&quot;], &quot;bind&quot;)
        self.assertEqual(
            root.find(&quot;devices/serial[3]/source&quot;).attrib[&quot;service&quot;], &quot;22223&quot;
        )
        self.assertEqual(root.find(&quot;devices/serial[3]/source&quot;).attrib[&quot;tls&quot;], &quot;yes&quot;)
        self.assertEqual(root.find(&quot;devices/serial[3]/protocol&quot;).attrib[&quot;type&quot;], &quot;raw&quot;)

        self.assertEqual(root.find(&quot;devices/serial[4]&quot;).attrib[&quot;type&quot;], &quot;unix&quot;)
        self.assertEqual(
            root.find(&quot;devices/serial[4]/source&quot;).attrib[&quot;path&quot;], &quot;/path/to/socket&quot;
        )

    def test_gen_xml_no_nic_console(self):
        &quot;&quot;&quot;
        Test virt._gen_xml()  console
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            consoles=[{&quot;type&quot;: &quot;pty&quot;}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;devices/console&quot;).attrib[&quot;type&quot;], &quot;pty&quot;)

    def test_gen_xml_for_telnet_console(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() telnet console
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            consoles=[{&quot;type&quot;: &quot;tcp&quot;, &quot;port&quot;: 22223, &quot;protocol&quot;: &quot;telnet&quot;}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;devices/console&quot;).attrib[&quot;type&quot;], &quot;tcp&quot;)
        self.assertEqual(root.find(&quot;devices/console/source&quot;).attrib[&quot;service&quot;], &quot;22223&quot;)
        self.assertEqual(root.find(&quot;devices/console/protocol&quot;).attrib[&quot;type&quot;], &quot;telnet&quot;)

    def test_gen_xml_for_telnet_console_unspecified_port(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() telnet console without any specified port
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            consoles=[{&quot;type&quot;: &quot;tcp&quot;}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;devices/console&quot;).attrib[&quot;type&quot;], &quot;tcp&quot;)
        self.assertEqual(root.find(&quot;devices/console/source&quot;).attrib[&quot;service&quot;], &quot;23023&quot;)
        self.assertEqual(root.find(&quot;devices/console/protocol&quot;).attrib[&quot;type&quot;], &quot;telnet&quot;)

    def test_gen_xml_for_serial_no_console(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with no serial console
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            serials=[{&quot;type&quot;: &quot;pty&quot;}],
            consoles=[],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;devices/serial&quot;).attrib[&quot;type&quot;], &quot;pty&quot;)
        self.assertEqual(root.find(&quot;devices/console&quot;), None)

    def test_gen_xml_for_telnet_no_console(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with no telnet console
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            serials=[{&quot;type&quot;: &quot;tcp&quot;, &quot;port&quot;: 22223, &quot;protocol&quot;: &quot;telnet&quot;}],
            consoles=[],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;devices/serial&quot;).attrib[&quot;type&quot;], &quot;tcp&quot;)
        self.assertEqual(root.find(&quot;devices/console&quot;), None)

    def test_gen_xml_nographics_default(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with default no graphics device
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn, &quot;hello&quot;, 1, 512, diskp, nicp, &quot;kvm&quot;, &quot;hvm&quot;, &quot;x86_64&quot;
        )
        root = ET.fromstring(xml_data)
        self.assertIsNone(root.find(&quot;devices/graphics&quot;))

    def test_gen_xml_noloader_default(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with default no loader
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn, &quot;hello&quot;, 1, 512, diskp, nicp, &quot;kvm&quot;, &quot;hvm&quot;, &quot;x86_64&quot;
        )
        root = ET.fromstring(xml_data)
        self.assertIsNone(root.find(&quot;os/loader&quot;))

    def test_gen_xml_vnc_default(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with default vnc graphics device
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
            graphics={
                &quot;type&quot;: &quot;vnc&quot;,
                &quot;port&quot;: 1234,
                &quot;tlsPort&quot;: 5678,
                &quot;listen&quot;: {&quot;type&quot;: &quot;address&quot;, &quot;address&quot;: &quot;myhost&quot;},
            },
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;devices/graphics&quot;).attrib[&quot;type&quot;], &quot;vnc&quot;)
        self.assertEqual(root.find(&quot;devices/graphics&quot;).attrib[&quot;autoport&quot;], &quot;no&quot;)
        self.assertEqual(root.find(&quot;devices/graphics&quot;).attrib[&quot;port&quot;], &quot;1234&quot;)
        self.assertFalse(&quot;tlsPort&quot; in root.find(&quot;devices/graphics&quot;).attrib)
        self.assertEqual(root.find(&quot;devices/graphics&quot;).attrib[&quot;listen&quot;], &quot;myhost&quot;)
        self.assertEqual(root.find(&quot;devices/graphics/listen&quot;).attrib[&quot;type&quot;], &quot;address&quot;)
        self.assertEqual(
            root.find(&quot;devices/graphics/listen&quot;).attrib[&quot;address&quot;], &quot;myhost&quot;
        )

    def test_gen_xml_memory(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with advanced memory settings
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            {
                &quot;boot&quot;: &quot;512m&quot;,
                &quot;current&quot;: &quot;256m&quot;,
                &quot;max&quot;: &quot;1g&quot;,
                &quot;hard_limit&quot;: &quot;1024&quot;,
                &quot;soft_limit&quot;: &quot;512m&quot;,
                &quot;swap_hard_limit&quot;: &quot;1g&quot;,
                &quot;min_guarantee&quot;: &quot;256m&quot;,
                &quot;hugepages&quot;: [
                    {&quot;size&quot;: &quot;128m&quot;},
                    {&quot;nodeset&quot;: &quot;0&quot;, &quot;size&quot;: &quot;256m&quot;},
                    {&quot;nodeset&quot;: &quot;1&quot;, &quot;size&quot;: &quot;512m&quot;},
                ],
                &quot;nosharepages&quot;: True,
                &quot;locked&quot;: True,
                &quot;source&quot;: &quot;file&quot;,
                &quot;access&quot;: &quot;shared&quot;,
                &quot;allocation&quot;: &quot;immediate&quot;,
                &quot;discard&quot;: True,
            },
            diskp,
            nicp,
            &quot;kvm&quot;,
<A NAME="0"></A>            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#0',2,'match118032-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.fromstring(xml_data)
        self.assert_equal_unit(root.find(&quot;memory&quot;), 512 * 1024)
        self.assert_equal_unit(root.find(&quot;currentMemory&quot;), 256 * 1024)
        self.assert_equal_unit(root.find(&quot;maxMemory&quot;), 1024 * 1024)
        self.assertFalse(&quot;slots&quot; in root.find(&quot;maxMemory&quot;).keys())
        self.assert_equal_unit(</B></FONT>root.find(&quot;memtune/hard_limit&quot;), 1024 * 1024)
        self.assert_equal_unit(root.find(&quot;memtune/soft_limit&quot;), 512 * 1024)
        self.assert_equal_unit(root.find(&quot;memtune/swap_hard_limit&quot;), 1024 ** 2)
        self.assert_equal_unit(root.find(&quot;memtune/min_guarantee&quot;), 256 * 1024)
        self.assertEqual(
            [
                {&quot;nodeset&quot;: page.get(&quot;nodeset&quot;), &quot;size&quot;: page.get(&quot;size&quot;)}
                for page in root.findall(&quot;memoryBacking/hugepages/page&quot;)
            ],
            [
                {&quot;nodeset&quot;: None, &quot;size&quot;: str(128 * 1024)},
                {&quot;nodeset&quot;: &quot;0&quot;, &quot;size&quot;: str(256 * 1024)},
                {&quot;nodeset&quot;: &quot;1&quot;, &quot;size&quot;: str(512 * 1024)},
            ],
        )
        self.assertIsNotNone(root.find(&quot;memoryBacking/nosharepages&quot;))
        self.assertIsNotNone(root.find(&quot;memoryBacking/locked&quot;))
        self.assertIsNotNone(root.find(&quot;memoryBacking/discard&quot;))
        self.assertEqual(root.find(&quot;memoryBacking/source&quot;).get(&quot;type&quot;), &quot;file&quot;)
        self.assertEqual(root.find(&quot;memoryBacking/access&quot;).get(&quot;mode&quot;), &quot;shared&quot;)
        self.assertEqual(root.find(&quot;memoryBacking/allocation&quot;).get(&quot;mode&quot;), &quot;immediate&quot;)

    def test_gen_xml_cpu(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with CPU advanced properties
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            {
                &quot;maximum&quot;: 12,
                &quot;placement&quot;: &quot;static&quot;,
                &quot;cpuset&quot;: &quot;0-11&quot;,
                &quot;current&quot;: 5,
                &quot;mode&quot;: &quot;custom&quot;,
                &quot;match&quot;: &quot;minimum&quot;,
                &quot;check&quot;: &quot;full&quot;,
                &quot;vendor&quot;: &quot;Intel&quot;,
                &quot;model&quot;: {
                    &quot;name&quot;: &quot;core2duo&quot;,
                    &quot;fallback&quot;: &quot;allow&quot;,
                    &quot;vendor_id&quot;: &quot;GenuineIntel&quot;,
                },
                &quot;cache&quot;: {&quot;level&quot;: 3, &quot;mode&quot;: &quot;emulate&quot;},
                &quot;features&quot;: {&quot;lahf&quot;: &quot;optional&quot;, &quot;vmx&quot;: &quot;require&quot;},
                &quot;vcpus&quot;: {
                    0: {&quot;enabled&quot;: True, &quot;hotpluggable&quot;: True},
                    1: {&quot;enabled&quot;: False},
                },
            },
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;vcpu&quot;).get(&quot;current&quot;), &quot;5&quot;)
        self.assertEqual(root.find(&quot;vcpu&quot;).get(&quot;placement&quot;), &quot;static&quot;)
        self.assertEqual(root.find(&quot;vcpu&quot;).get(&quot;cpuset&quot;), &quot;0-11&quot;)
        self.assertEqual(root.find(&quot;vcpu&quot;).text, &quot;12&quot;)
        self.assertEqual(root.find(&quot;cpu&quot;).get(&quot;match&quot;), &quot;minimum&quot;)
        self.assertEqual(root.find(&quot;cpu&quot;).get(&quot;mode&quot;), &quot;custom&quot;)
        self.assertEqual(root.find(&quot;cpu&quot;).get(&quot;check&quot;), &quot;full&quot;)
        self.assertEqual(root.find(&quot;cpu/vendor&quot;).text, &quot;Intel&quot;)
        self.assertEqual(root.find(&quot;cpu/model&quot;).text, &quot;core2duo&quot;)
        self.assertEqual(root.find(&quot;cpu/model&quot;).get(&quot;fallback&quot;), &quot;allow&quot;)
        self.assertEqual(root.find(&quot;cpu/model&quot;).get(&quot;vendor_id&quot;), &quot;GenuineIntel&quot;)
        self.assertEqual(root.find(&quot;cpu/cache&quot;).get(&quot;level&quot;), &quot;3&quot;)
        self.assertEqual(root.find(&quot;cpu/cache&quot;).get(&quot;mode&quot;), &quot;emulate&quot;)
        self.assertEqual(
            {f.get(&quot;name&quot;): f.get(&quot;policy&quot;) for f in root.findall(&quot;cpu/feature&quot;)},
            {&quot;lahf&quot;: &quot;optional&quot;, &quot;vmx&quot;: &quot;require&quot;},
        )
        self.assertEqual(
            {
                v.get(&quot;id&quot;): {
                    &quot;enabled&quot;: v.get(&quot;enabled&quot;),
                    &quot;hotpluggable&quot;: v.get(&quot;hotpluggable&quot;),
                }
                for v in root.findall(&quot;vcpus/vcpu&quot;)
            },
            {
                &quot;0&quot;: {&quot;enabled&quot;: &quot;yes&quot;, &quot;hotpluggable&quot;: &quot;yes&quot;},
                &quot;1&quot;: {&quot;enabled&quot;: &quot;no&quot;, &quot;hotpluggable&quot;: None},
            },
        )

    def test_gen_xml_cpu_topology(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with CPU topology
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            {&quot;maximum&quot;: 1, &quot;topology&quot;: {&quot;sockets&quot;: 4, &quot;cores&quot;: 16, &quot;threads&quot;: 2}},
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;cpu/topology&quot;).get(&quot;sockets&quot;), &quot;4&quot;)
        self.assertEqual(root.find(&quot;cpu/topology&quot;).get(&quot;cores&quot;), &quot;16&quot;)
        self.assertEqual(root.find(&quot;cpu/topology&quot;).get(&quot;threads&quot;), &quot;2&quot;)

    def test_gen_xml_cpu_numa(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with CPU numa settings
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            {
                &quot;maximum&quot;: 1,
                &quot;numa&quot;: {
                    0: {
                        &quot;cpus&quot;: &quot;0-3&quot;,
                        &quot;memory&quot;: &quot;1g&quot;,
                        &quot;discard&quot;: True,
                        &quot;distances&quot;: {0: 10, 1: 20},
                    },
                    1: {&quot;cpus&quot;: &quot;4-7&quot;, &quot;memory&quot;: &quot;2g&quot;, &quot;distances&quot;: {0: 20, 1: 10}},
                },
            },
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        cell0 = root.find(&quot;cpu/numa/cell[@id='0']&quot;)
        self.assertEqual(cell0.get(&quot;cpus&quot;), &quot;0-3&quot;)
        self.assertIsNone(cell0.get(&quot;unit&quot;))
        self.assertEqual(cell0.get(&quot;memory&quot;), str(1024 ** 2))
        self.assertEqual(cell0.get(&quot;discard&quot;), &quot;yes&quot;)
        self.assertEqual(
            {d.get(&quot;id&quot;): d.get(&quot;value&quot;) for d in cell0.findall(&quot;distances/sibling&quot;)},
            {&quot;0&quot;: &quot;10&quot;, &quot;1&quot;: &quot;20&quot;},
        )

        cell1 = root.find(&quot;cpu/numa/cell[@id='1']&quot;)
        self.assertEqual(cell1.get(&quot;cpus&quot;), &quot;4-7&quot;)
        self.assertIsNone(cell0.get(&quot;unit&quot;))
        self.assertEqual(cell1.get(&quot;memory&quot;), str(2 * 1024 ** 2))
        self.assertFalse(&quot;discard&quot; in cell1.keys())
        self.assertEqual(
            {d.get(&quot;id&quot;): d.get(&quot;value&quot;) for d in cell1.findall(&quot;distances/sibling&quot;)},
            {&quot;0&quot;: &quot;20&quot;, &quot;1&quot;: &quot;10&quot;},
        )

    def test_gen_xml_cputune(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() with CPU tuning
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        cputune = {
            &quot;shares&quot;: 2048,
            &quot;period&quot;: 122000,
            &quot;quota&quot;: -1,
            &quot;global_period&quot;: 1000000,
            &quot;global_quota&quot;: -3,
            &quot;emulator_period&quot;: 1200000,
            &quot;emulator_quota&quot;: -10,
            &quot;iothread_period&quot;: 133000,
            &quot;iothread_quota&quot;: -1,
            &quot;vcpupin&quot;: {0: &quot;1-4,^2&quot;, 1: &quot;0,1&quot;, 2: &quot;2,3&quot;, 3: &quot;0,4&quot;},
            &quot;emulatorpin&quot;: &quot;1-3&quot;,
            &quot;iothreadpin&quot;: {1: &quot;5-6&quot;, 2: &quot;7-8&quot;},
            &quot;vcpusched&quot;: [
                {&quot;scheduler&quot;: &quot;fifo&quot;, &quot;priority&quot;: 1, &quot;vcpus&quot;: &quot;0&quot;},
                {&quot;scheduler&quot;: &quot;fifo&quot;, &quot;priority&quot;: 2, &quot;vcpus&quot;: &quot;1&quot;},
                {&quot;scheduler&quot;: &quot;idle&quot;, &quot;priority&quot;: 3, &quot;vcpus&quot;: &quot;2&quot;},
            ],
            &quot;iothreadsched&quot;: [
                {&quot;scheduler&quot;: &quot;idle&quot;},
                {&quot;scheduler&quot;: &quot;batch&quot;, &quot;iothreads&quot;: &quot;5-7&quot;, &quot;priority&quot;: 1},
            ],
            &quot;emulatorsched&quot;: {&quot;scheduler&quot;: &quot;rr&quot;, &quot;priority&quot;: 2},
            &quot;cachetune&quot;: {
                &quot;0-3&quot;: {
                    0: {&quot;level&quot;: 3, &quot;type&quot;: &quot;both&quot;, &quot;size&quot;: 3},
                    1: {&quot;level&quot;: 3, &quot;type&quot;: &quot;both&quot;, &quot;size&quot;: 3},
                    &quot;monitor&quot;: {1: 3, &quot;0-3&quot;: 3},
                },
                &quot;4-5&quot;: {&quot;monitor&quot;: {4: 3, 5: 2}},
            },
            &quot;memorytune&quot;: {&quot;0-2&quot;: {0: 60}, &quot;3-4&quot;: {0: 50, 1: 70}},
        }
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            {&quot;maximum&quot;: 1, &quot;tuning&quot;: cputune, &quot;iothreads&quot;: 2},
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;cputune&quot;).find(&quot;shares&quot;).text, &quot;2048&quot;)
        self.assertEqual(root.find(&quot;cputune&quot;).find(&quot;period&quot;).text, &quot;122000&quot;)
        self.assertEqual(root.find(&quot;cputune&quot;).find(&quot;quota&quot;).text, &quot;-1&quot;)
        self.assertEqual(root.find(&quot;cputune&quot;).find(&quot;global_period&quot;).text, &quot;1000000&quot;)
        self.assertEqual(root.find(&quot;cputune&quot;).find(&quot;global_quota&quot;).text, &quot;-3&quot;)
        self.assertEqual(root.find(&quot;cputune&quot;).find(&quot;emulator_period&quot;).text, &quot;1200000&quot;)
        self.assertEqual(root.find(&quot;cputune&quot;).find(&quot;emulator_quota&quot;).text, &quot;-10&quot;)
        self.assertEqual(root.find(&quot;cputune&quot;).find(&quot;iothread_period&quot;).text, &quot;133000&quot;)
        self.assertEqual(root.find(&quot;cputune&quot;).find(&quot;iothread_quota&quot;).text, &quot;-1&quot;)
        self.assertEqual(
            root.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='0']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;1-4,^2&quot;,
        )
        self.assertEqual(
            root.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='1']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;0,1&quot;,
        )
        self.assertEqual(
            root.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='2']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;2,3&quot;,
        )
        self.assertEqual(
            root.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='3']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;0,4&quot;,
        )
        self.assertEqual(
            root.find(&quot;cputune&quot;).find(&quot;emulatorpin&quot;).attrib.get(&quot;cpuset&quot;), &quot;1-3&quot;
        )
        self.assertEqual(
            root.find(&quot;cputune&quot;)
            .find(&quot;iothreadpin[@iothread='1']&quot;)
            .attrib.get(&quot;cpuset&quot;),
            &quot;5-6&quot;,
        )
        self.assertEqual(
            root.find(&quot;cputune&quot;)
            .find(&quot;iothreadpin[@iothread='2']&quot;)
            .attrib.get(&quot;cpuset&quot;),
            &quot;7-8&quot;,
        )
        self.assertDictEqual(
            {
                s.get(&quot;vcpus&quot;): {
                    &quot;scheduler&quot;: s.get(&quot;scheduler&quot;),
                    &quot;priority&quot;: s.get(&quot;priority&quot;),
                }
                for s in root.findall(&quot;cputune/vcpusched&quot;)
            },
            {
                &quot;0&quot;: {&quot;scheduler&quot;: &quot;fifo&quot;, &quot;priority&quot;: &quot;1&quot;},
                &quot;1&quot;: {&quot;scheduler&quot;: &quot;fifo&quot;, &quot;priority&quot;: &quot;2&quot;},
                &quot;2&quot;: {&quot;scheduler&quot;: &quot;idle&quot;, &quot;priority&quot;: &quot;3&quot;},
            },
        )
        self.assertDictEqual(
            {
                s.get(&quot;iothreads&quot;): {
                    &quot;scheduler&quot;: s.get(&quot;scheduler&quot;),
                    &quot;priority&quot;: s.get(&quot;priority&quot;),
                }
                for s in root.findall(&quot;cputune/iothreadsched&quot;)
            },
            {
                None: {&quot;scheduler&quot;: &quot;idle&quot;, &quot;priority&quot;: None},
                &quot;5-7&quot;: {&quot;scheduler&quot;: &quot;batch&quot;, &quot;priority&quot;: &quot;1&quot;},
            },
        )
        self.assertEqual(root.find(&quot;cputune/emulatorsched&quot;).get(&quot;scheduler&quot;), &quot;rr&quot;)
        self.assertEqual(root.find(&quot;cputune/emulatorsched&quot;).get(&quot;priority&quot;), &quot;2&quot;)
        self.assertEqual(
            root.find(&quot;./cputune/cachetune[@vcpus='0-3']&quot;).attrib.get(&quot;vcpus&quot;), &quot;0-3&quot;
        )
        self.assertEqual(
            root.find(&quot;./cputune/cachetune[@vcpus='0-3']/cache[@id='0']&quot;).attrib.get(
                &quot;level&quot;
            ),
            &quot;3&quot;,
        )
        self.assertEqual(
            root.find(&quot;./cputune/cachetune[@vcpus='0-3']/cache[@id='0']&quot;).attrib.get(
                &quot;type&quot;
            ),
            &quot;both&quot;,
        )
        self.assertEqual(
            root.find(
                &quot;./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']&quot;
            ).attrib.get(&quot;level&quot;),
            &quot;3&quot;,
        )
        self.assertNotEqual(
            root.find(&quot;./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']&quot;), None
        )
        self.assertNotEqual(
            root.find(&quot;./cputune/cachetune[@vcpus='4-5']&quot;).attrib.get(&quot;vcpus&quot;), None
        )
        self.assertEqual(
            root.find(&quot;./cputune/cachetune[@vcpus='4-5']/cache[@id='0']&quot;), None
        )
        self.assertEqual(
            root.find(
                &quot;./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']&quot;
            ).attrib.get(&quot;level&quot;),
            &quot;3&quot;,
        )
        self.assertEqual(
            root.find(
                &quot;./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']&quot;
            ).attrib.get(&quot;level&quot;),
            &quot;2&quot;,
        )
        self.assertNotEqual(root.find(&quot;./cputune/memorytune[@vcpus='0-2']&quot;), None)
        self.assertEqual(
            root.find(&quot;./cputune/memorytune[@vcpus='0-2']/node[@id='0']&quot;).attrib.get(
                &quot;bandwidth&quot;
            ),
            &quot;60&quot;,
        )
        self.assertNotEqual(root.find(&quot;./cputune/memorytune[@vcpus='3-4']&quot;), None)
        self.assertEqual(
            root.find(&quot;./cputune/memorytune[@vcpus='3-4']/node[@id='0']&quot;).attrib.get(
                &quot;bandwidth&quot;
            ),
            &quot;50&quot;,
        )
        self.assertEqual(
            root.find(&quot;./cputune/memorytune[@vcpus='3-4']/node[@id='1']&quot;).attrib.get(
                &quot;bandwidth&quot;
            ),
            &quot;70&quot;,
        )
        self.assertEqual(root.find(&quot;iothreads&quot;).text, &quot;2&quot;)

    def test_default_disk_profile_hypervisor_esxi(self):
        &quot;&quot;&quot;
        Test virt._disk_profile() default ESXi profile
        &quot;&quot;&quot;
        mock = MagicMock(return_value={})
        with patch.dict(
            virt.__salt__, {&quot;config.get&quot;: mock}  # pylint: disable=no-member
        ):
            ret = virt._disk_profile(
                self.mock_conn, &quot;nonexistent&quot;, &quot;vmware&quot;, None, &quot;test-vm&quot;
            )
            self.assertTrue(len(ret) == 1)
            found = [disk for disk in ret if disk[&quot;name&quot;] == &quot;system&quot;]
            self.assertTrue(bool(found))
            system = found[0]
            self.assertEqual(system[&quot;format&quot;], &quot;vmdk&quot;)
            self.assertEqual(system[&quot;model&quot;], &quot;scsi&quot;)
            self.assertTrue(int(system[&quot;size&quot;]) &gt;= 1)

    def test_default_disk_profile_hypervisor_kvm(self):
        &quot;&quot;&quot;
        Test virt._disk_profile() default KVM profile
        &quot;&quot;&quot;
        mock = MagicMock(side_effect=[{}, &quot;/images/dir&quot;])
        with patch.dict(
            virt.__salt__, {&quot;config.get&quot;: mock}  # pylint: disable=no-member
        ):
            ret = virt._disk_profile(
                self.mock_conn, &quot;nonexistent&quot;, &quot;kvm&quot;, None, &quot;test-vm&quot;
            )
            self.assertTrue(len(ret) == 1)
            found = [disk for disk in ret if disk[&quot;name&quot;] == &quot;system&quot;]
            self.assertTrue(bool(found))
            system = found[0]
            self.assertEqual(system[&quot;format&quot;], &quot;qcow2&quot;)
            self.assertEqual(system[&quot;model&quot;], &quot;virtio&quot;)
            self.assertTrue(int(system[&quot;size&quot;]) &gt;= 1)

    def test_default_disk_profile_hypervisor_xen(self):
        &quot;&quot;&quot;
        Test virt._disk_profile() default XEN profile
        &quot;&quot;&quot;
        mock = MagicMock(side_effect=[{}, &quot;/images/dir&quot;])
        with patch.dict(
            virt.__salt__, {&quot;config.get&quot;: mock}  # pylint: disable=no-member
        ):
            ret = virt._disk_profile(
                self.mock_conn, &quot;nonexistent&quot;, &quot;xen&quot;, None, &quot;test-vm&quot;
            )
            self.assertTrue(len(ret) == 1)
            found = [disk for disk in ret if disk[&quot;name&quot;] == &quot;system&quot;]
            self.assertTrue(bool(found))
            system = found[0]
            self.assertEqual(system[&quot;format&quot;], &quot;qcow2&quot;)
            self.assertEqual(system[&quot;model&quot;], &quot;xen&quot;)
            self.assertTrue(int(system[&quot;size&quot;]) &gt;= 1)

    def test_default_nic_profile_hypervisor_esxi(self):
        &quot;&quot;&quot;
        Test virt._nic_profile() default ESXi profile
        &quot;&quot;&quot;
        mock = MagicMock(return_value={})
        with patch.dict(
            virt.__salt__, {&quot;config.get&quot;: mock}  # pylint: disable=no-member
        ):
            ret = virt._nic_profile(&quot;nonexistent&quot;, &quot;vmware&quot;)
            self.assertTrue(len(ret) == 1)
            eth0 = ret[0]
            self.assertEqual(eth0[&quot;name&quot;], &quot;eth0&quot;)
            self.assertEqual(eth0[&quot;type&quot;], &quot;bridge&quot;)
            self.assertEqual(eth0[&quot;source&quot;], &quot;DEFAULT&quot;)
            self.assertEqual(eth0[&quot;model&quot;], &quot;e1000&quot;)

    def test_default_nic_profile_hypervisor_kvm(self):
        &quot;&quot;&quot;
        Test virt._nic_profile() default KVM profile
        &quot;&quot;&quot;
        mock = MagicMock(return_value={})
        with patch.dict(
            virt.__salt__, {&quot;config.get&quot;: mock}  # pylint: disable=no-member
        ):
            ret = virt._nic_profile(&quot;nonexistent&quot;, &quot;kvm&quot;)
            self.assertTrue(len(ret) == 1)
            eth0 = ret[0]
            self.assertEqual(eth0[&quot;name&quot;], &quot;eth0&quot;)
            self.assertEqual(eth0[&quot;type&quot;], &quot;bridge&quot;)
            self.assertEqual(eth0[&quot;source&quot;], &quot;br0&quot;)
            self.assertEqual(eth0[&quot;model&quot;], &quot;virtio&quot;)

    def test_default_nic_profile_hypervisor_xen(self):
        &quot;&quot;&quot;
        Test virt._nic_profile() default XEN profile
        &quot;&quot;&quot;
        mock = MagicMock(return_value={})
        with patch.dict(
            virt.__salt__, {&quot;config.get&quot;: mock}  # pylint: disable=no-member
        ):
            ret = virt._nic_profile(&quot;nonexistent&quot;, &quot;xen&quot;)
            self.assertTrue(len(ret) == 1)
            eth0 = ret[0]
            self.assertEqual(eth0[&quot;name&quot;], &quot;eth0&quot;)
            self.assertEqual(eth0[&quot;type&quot;], &quot;bridge&quot;)
            self.assertEqual(eth0[&quot;source&quot;], &quot;br0&quot;)
            self.assertFalse(eth0[&quot;model&quot;])

    def test_gen_vol_xml_esx(self):
        &quot;&quot;&quot;
        Test virt._get_vol_xml() for the ESX case
        &quot;&quot;&quot;
        xml_data = virt._gen_vol_xml(&quot;vmname/system.vmdk&quot;, 8192, format=&quot;vmdk&quot;)
        root = ET.fromstring(xml_data)
        self.assertIsNone(root.get(&quot;type&quot;))
        self.assertEqual(root.find(&quot;name&quot;).text, &quot;vmname/system.vmdk&quot;)
        self.assertEqual(root.find(&quot;capacity&quot;).attrib[&quot;unit&quot;], &quot;KiB&quot;)
        self.assertEqual(root.find(&quot;capacity&quot;).text, str(8192 * 1024))
        self.assertEqual(root.find(&quot;allocation&quot;).text, str(0))
        self.assertEqual(root.find(&quot;target/format&quot;).get(&quot;type&quot;), &quot;vmdk&quot;)
        self.assertIsNone(root.find(&quot;target/permissions&quot;))
        self.assertIsNone(root.find(&quot;target/nocow&quot;))
        self.assertIsNone(root.find(&quot;backingStore&quot;))

    def test_gen_vol_xml_file(self):
        &quot;&quot;&quot;
        Test virt._get_vol_xml() for a file volume
        &quot;&quot;&quot;
        xml_data = virt._gen_vol_xml(
            &quot;myvm_system.qcow2&quot;,
            8192,
            format=&quot;qcow2&quot;,
            allocation=4096,
            type=&quot;file&quot;,
            permissions={
                &quot;mode&quot;: &quot;0775&quot;,
                &quot;owner&quot;: &quot;123&quot;,
                &quot;group&quot;: &quot;456&quot;,
                &quot;label&quot;: &quot;sec_label&quot;,
            },
            backing_store={&quot;path&quot;: &quot;/backing/image&quot;, &quot;format&quot;: &quot;raw&quot;},
            nocow=True,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.get(&quot;type&quot;), &quot;file&quot;)
        self.assertEqual(root.find(&quot;name&quot;).text, &quot;myvm_system.qcow2&quot;)
        self.assertIsNone(root.find(&quot;key&quot;))
        self.assertIsNone(root.find(&quot;target/path&quot;))
        self.assertEqual(root.find(&quot;target/format&quot;).get(&quot;type&quot;), &quot;qcow2&quot;)
        self.assertEqual(root.find(&quot;capacity&quot;).attrib[&quot;unit&quot;], &quot;KiB&quot;)
        self.assertEqual(root.find(&quot;capacity&quot;).text, str(8192 * 1024))
        self.assertEqual(root.find(&quot;capacity&quot;).attrib[&quot;unit&quot;], &quot;KiB&quot;)
        self.assertEqual(root.find(&quot;allocation&quot;).text, str(4096 * 1024))
        self.assertEqual(root.find(&quot;target/permissions/mode&quot;).text, &quot;0775&quot;)
        self.assertEqual(root.find(&quot;target/permissions/owner&quot;).text, &quot;123&quot;)
        self.assertEqual(root.find(&quot;target/permissions/group&quot;).text, &quot;456&quot;)
        self.assertEqual(root.find(&quot;target/permissions/label&quot;).text, &quot;sec_label&quot;)
        self.assertIsNotNone(root.find(&quot;target/nocow&quot;))
        self.assertEqual(root.find(&quot;backingStore/path&quot;).text, &quot;/backing/image&quot;)
        self.assertEqual(root.find(&quot;backingStore/format&quot;).get(&quot;type&quot;), &quot;raw&quot;)

    def test_gen_xml_for_kvm_default_profile(self):
        &quot;&quot;&quot;
        Test virt._gen_xml(), KVM default profile case
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.attrib[&quot;type&quot;], &quot;kvm&quot;)
        self.assertEqual(root.find(&quot;vcpu&quot;).text, &quot;1&quot;)
        self.assertEqual(root.find(&quot;memory&quot;).text, str(512 * 1024))
        self.assertEqual(root.find(&quot;memory&quot;).attrib[&quot;unit&quot;], &quot;KiB&quot;)

        disks = root.findall(&quot;.//disk&quot;)
        self.assertEqual(len(disks), 1)
        disk = disks[0]
        root_dir = salt.config.DEFAULT_MINION_OPTS.get(&quot;root_dir&quot;)
        self.assertTrue(disk.find(&quot;source&quot;).attrib[&quot;file&quot;].startswith(root_dir))
        self.assertTrue(&quot;hello_system&quot; in disk.find(&quot;source&quot;).attrib[&quot;file&quot;])
        self.assertEqual(disk.find(&quot;target&quot;).attrib[&quot;dev&quot;], &quot;vda&quot;)
        self.assertEqual(disk.find(&quot;target&quot;).attrib[&quot;bus&quot;], &quot;virtio&quot;)
        self.assertEqual(disk.find(&quot;driver&quot;).attrib[&quot;name&quot;], &quot;qemu&quot;)
        self.assertEqual(disk.find(&quot;driver&quot;).attrib[&quot;type&quot;], &quot;qcow2&quot;)

        interfaces = root.findall(&quot;.//interface&quot;)
        self.assertEqual(len(interfaces), 1)
        iface = interfaces[0]
        self.assertEqual(iface.attrib[&quot;type&quot;], &quot;bridge&quot;)
        self.assertEqual(iface.find(&quot;source&quot;).attrib[&quot;bridge&quot;], &quot;br0&quot;)
        self.assertEqual(iface.find(&quot;model&quot;).attrib[&quot;type&quot;], &quot;virtio&quot;)

    def test_gen_xml_for_esxi_default_profile(self):
        &quot;&quot;&quot;
        Test virt._gen_xml(), ESXi/vmware default profile case
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;vmware&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;vmware&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;vmware&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.attrib[&quot;type&quot;], &quot;vmware&quot;)
        self.assertEqual(root.find(&quot;vcpu&quot;).text, &quot;1&quot;)
        self.assertEqual(root.find(&quot;memory&quot;).text, str(512 * 1024))
        self.assertEqual(root.find(&quot;memory&quot;).attrib[&quot;unit&quot;], &quot;KiB&quot;)

        disks = root.findall(&quot;.//disk&quot;)
        self.assertEqual(len(disks), 1)
        disk = disks[0]
        self.assertTrue(&quot;[0]&quot; in disk.find(&quot;source&quot;).attrib[&quot;file&quot;])
        self.assertTrue(&quot;hello_system&quot; in disk.find(&quot;source&quot;).attrib[&quot;file&quot;])
        self.assertEqual(disk.find(&quot;target&quot;).attrib[&quot;dev&quot;], &quot;sda&quot;)
        self.assertEqual(disk.find(&quot;target&quot;).attrib[&quot;bus&quot;], &quot;scsi&quot;)
        self.assertEqual(disk.find(&quot;address&quot;).attrib[&quot;unit&quot;], &quot;0&quot;)

        interfaces = root.findall(&quot;.//interface&quot;)
        self.assertEqual(len(interfaces), 1)
        iface = interfaces[0]
        self.assertEqual(iface.attrib[&quot;type&quot;], &quot;bridge&quot;)
        self.assertEqual(iface.find(&quot;source&quot;).attrib[&quot;bridge&quot;], &quot;DEFAULT&quot;)
        self.assertEqual(iface.find(&quot;model&quot;).attrib[&quot;type&quot;], &quot;e1000&quot;)

    def test_gen_xml_for_esxi_custom_profile(self):
        &quot;&quot;&quot;
        Test virt._gen_xml(), ESXi/vmware custom profile case
        &quot;&quot;&quot;
        disks = {
            &quot;noeffect&quot;: [
                {&quot;first&quot;: {&quot;size&quot;: 8192, &quot;pool&quot;: &quot;datastore1&quot;}},
                {&quot;second&quot;: {&quot;size&quot;: 4096, &quot;pool&quot;: &quot;datastore2&quot;}},
            ]
        }
        nics = {
            &quot;noeffect&quot;: [
                {&quot;name&quot;: &quot;eth1&quot;, &quot;source&quot;: &quot;ONENET&quot;},
                {&quot;name&quot;: &quot;eth2&quot;, &quot;source&quot;: &quot;TWONET&quot;},
            ]
        }
        with patch.dict(
            virt.__salt__,  # pylint: disable=no-member
            {&quot;config.get&quot;: MagicMock(side_effect=[disks, nics])},
        ):
            diskp = virt._disk_profile(
                self.mock_conn, &quot;noeffect&quot;, &quot;vmware&quot;, [], &quot;hello&quot;
            )
            nicp = virt._nic_profile(&quot;noeffect&quot;, &quot;vmware&quot;)
            xml_data = virt._gen_xml(
                self.mock_conn,
                &quot;hello&quot;,
                1,
                512,
                diskp,
                nicp,
                &quot;vmware&quot;,
                &quot;hvm&quot;,
                &quot;x86_64&quot;,
            )
            root = ET.fromstring(xml_data)
            self.assertEqual(root.attrib[&quot;type&quot;], &quot;vmware&quot;)
            self.assertEqual(root.find(&quot;vcpu&quot;).text, &quot;1&quot;)
            self.assertEqual(root.find(&quot;memory&quot;).text, str(512 * 1024))
            self.assertEqual(root.find(&quot;memory&quot;).attrib[&quot;unit&quot;], &quot;KiB&quot;)
            self.assertTrue(len(root.findall(&quot;.//disk&quot;)) == 2)
            self.assertTrue(len(root.findall(&quot;.//interface&quot;)) == 2)

    def test_gen_xml_for_kvm_custom_profile(self):
        &quot;&quot;&quot;
        Test virt._gen_xml(), KVM custom profile case
        &quot;&quot;&quot;
        disks = {
            &quot;noeffect&quot;: [
                {&quot;first&quot;: {&quot;size&quot;: 8192, &quot;pool&quot;: &quot;/var/lib/images&quot;}},
                {&quot;second&quot;: {&quot;size&quot;: 4096, &quot;pool&quot;: &quot;/var/lib/images&quot;}},
            ]
        }
        nics = {
            &quot;noeffect&quot;: [
                {&quot;name&quot;: &quot;eth1&quot;, &quot;source&quot;: &quot;b2&quot;},
                {&quot;name&quot;: &quot;eth2&quot;, &quot;source&quot;: &quot;b2&quot;},
            ]
        }
        with patch.dict(
            virt.__salt__,  # pylint: disable=no-member
            {&quot;config.get&quot;: MagicMock(side_effect=[disks, nics])},
        ):
            diskp = virt._disk_profile(self.mock_conn, &quot;noeffect&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
            nicp = virt._nic_profile(&quot;noeffect&quot;, &quot;kvm&quot;)
            xml_data = virt._gen_xml(
                self.mock_conn,
                &quot;hello&quot;,
                1,
                512,
                diskp,
                nicp,
                &quot;kvm&quot;,
                &quot;hvm&quot;,
                &quot;x86_64&quot;,
            )
            root = ET.fromstring(xml_data)
            self.assertEqual(root.attrib[&quot;type&quot;], &quot;kvm&quot;)
            self.assertEqual(root.find(&quot;vcpu&quot;).text, &quot;1&quot;)
            self.assertEqual(root.find(&quot;memory&quot;).text, str(512 * 1024))
            self.assertEqual(root.find(&quot;memory&quot;).attrib[&quot;unit&quot;], &quot;KiB&quot;)
            disks = root.findall(&quot;.//disk&quot;)
            self.assertTrue(len(disks) == 2)
            self.assertEqual(disks[0].find(&quot;target&quot;).get(&quot;dev&quot;), &quot;vda&quot;)
            self.assertEqual(disks[1].find(&quot;target&quot;).get(&quot;dev&quot;), &quot;vdb&quot;)
            self.assertTrue(len(root.findall(&quot;.//interface&quot;)) == 2)

    def test_disk_profile_kvm_disk_pool(self):
        &quot;&quot;&quot;
        Test virt._disk_profile(), KVM case with pools defined.
        &quot;&quot;&quot;
        disks = {
            &quot;noeffect&quot;: [
                {&quot;first&quot;: {&quot;size&quot;: 8192, &quot;pool&quot;: &quot;mypool&quot;}},
                {&quot;second&quot;: {&quot;size&quot;: 4096}},
            ]
        }

        # pylint: disable=no-member
        with patch.dict(
            virt.__salt__,
            {
                &quot;config.get&quot;: MagicMock(
                    side_effect=[
                        disks,
                        os.path.join(salt.syspaths.ROOT_DIR, &quot;default&quot;, &quot;path&quot;),
                    ]
                )
            },
        ):

            diskp = virt._disk_profile(self.mock_conn, &quot;noeffect&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)

            pools_path = (
                os.path.join(salt.syspaths.ROOT_DIR, &quot;pools&quot;, &quot;mypool&quot;) + os.sep
            )
            default_path = (
                os.path.join(salt.syspaths.ROOT_DIR, &quot;default&quot;, &quot;path&quot;) + os.sep
            )

            self.assertEqual(len(diskp), 2)
            self.assertTrue(diskp[1][&quot;source_file&quot;].startswith(default_path))
        # pylint: enable=no-member

    def test_disk_profile_kvm_disk_external_image(self):
        &quot;&quot;&quot;
        Test virt._gen_xml(), KVM case with an external image.
        &quot;&quot;&quot;
        with patch.dict(os.path.__dict__, {&quot;exists&quot;: MagicMock(return_value=True)}):
            diskp = virt._disk_profile(
                self.mock_conn,
                None,
                &quot;kvm&quot;,
                [{&quot;name&quot;: &quot;mydisk&quot;, &quot;source_file&quot;: &quot;/path/to/my/image.qcow2&quot;}],
                &quot;hello&quot;,
            )

            self.assertEqual(len(diskp), 1)
            self.assertEqual(diskp[0][&quot;source_file&quot;], &quot;/path/to/my/image.qcow2&quot;)

    def test_disk_profile_cdrom_default(self):
        &quot;&quot;&quot;
        Test virt._gen_xml(), KVM case with cdrom.
        &quot;&quot;&quot;
        with patch.dict(os.path.__dict__, {&quot;exists&quot;: MagicMock(return_value=True)}):
            diskp = virt._disk_profile(
                self.mock_conn,
                None,
                &quot;kvm&quot;,
                [
                    {
                        &quot;name&quot;: &quot;mydisk&quot;,
                        &quot;device&quot;: &quot;cdrom&quot;,
                        &quot;source_file&quot;: &quot;/path/to/my.iso&quot;,
                    }
                ],
                &quot;hello&quot;,
            )

            self.assertEqual(len(diskp), 1)
            self.assertEqual(diskp[0][&quot;model&quot;], &quot;ide&quot;)
            self.assertEqual(diskp[0][&quot;format&quot;], &quot;raw&quot;)

    def test_disk_profile_pool_disk_type(self):
        &quot;&quot;&quot;
        Test virt._disk_profile(), with a disk pool of disk type
        &quot;&quot;&quot;
        self.mock_conn.listStoragePools.return_value = [&quot;test-vdb&quot;]
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = &quot;&quot;&quot;
            &lt;pool type=&quot;disk&quot;&gt;
              &lt;name&gt;test-vdb&lt;/name&gt;
              &lt;source&gt;
                &lt;device path='/dev/vdb'/&gt;
              &lt;/source&gt;
              &lt;target&gt;
                &lt;path&gt;/dev&lt;/path&gt;
              &lt;/target&gt;
            &lt;/pool&gt;
        &quot;&quot;&quot;

        # No existing disk case
        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = (
            []
        )
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            &quot;kvm&quot;,
            [{&quot;name&quot;: &quot;mydisk&quot;, &quot;pool&quot;: &quot;test-vdb&quot;}],
            &quot;hello&quot;,
        )
        self.assertEqual(diskp[0][&quot;filename&quot;], &quot;vdb1&quot;)

        # Append to the end case
        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
            &quot;vdb1&quot;,
            &quot;vdb2&quot;,
        ]
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            &quot;kvm&quot;,
            [{&quot;name&quot;: &quot;mydisk&quot;, &quot;pool&quot;: &quot;test-vdb&quot;}],
            &quot;hello&quot;,
        )
        self.assertEqual(diskp[0][&quot;filename&quot;], &quot;vdb3&quot;)

        # Hole in the middle case
        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
            &quot;vdb1&quot;,
            &quot;vdb3&quot;,
        ]
        diskp = virt._disk_profile(
<A NAME="9"></A>            self.mock_conn,
            None,
            &quot;kvm&quot;,
            [{<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#9',2,'match118032-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;name&quot;: &quot;mydisk&quot;, &quot;pool&quot;: &quot;test-vdb&quot;}],
            &quot;hello&quot;,
        )
        self.assertEqual(diskp[0][&quot;filename&quot;], &quot;vdb2&quot;)

        # Reuse existing volume case
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            &quot;kvm&quot;,
            [{&quot;name&quot;: &quot;mydisk&quot;, &quot;pool&quot;: &quot;test-vdb&quot;, &quot;source_file&quot;: &quot;vdb1&quot;}],
            &quot;hello&quot;,
        )
        self.</B></FONT>assertEqual(diskp[0][&quot;filename&quot;], &quot;vdb1&quot;)

    def test_gen_xml_volume(self):
        &quot;&quot;&quot;
        Test virt._gen_xml(), generating a disk of volume type
        &quot;&quot;&quot;
        self.mock_conn.listStoragePools.return_value = [&quot;default&quot;]
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
            &quot;&lt;pool type='dir'/&gt;&quot;
        )
        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
            &quot;myvolume&quot;
        ]
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            &quot;kvm&quot;,
            [
                {&quot;name&quot;: &quot;system&quot;, &quot;pool&quot;: &quot;default&quot;},
                {&quot;name&quot;: &quot;data&quot;, &quot;pool&quot;: &quot;default&quot;, &quot;source_file&quot;: &quot;myvolume&quot;},
            ],
            &quot;hello&quot;,
        )
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
            &quot;&lt;pool type='dir'/&gt;&quot;
<A NAME="8"></A>        )
        nicp = virt._nic_profile(None, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#8',2,'match118032-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        disk = root.findall(&quot;.//disk&quot;)[0]
        self.assertEqual(disk.attrib[</B></FONT>&quot;device&quot;], &quot;disk&quot;)
        self.assertEqual(disk.attrib[&quot;type&quot;], &quot;volume&quot;)
        source = disk.find(&quot;source&quot;)
        self.assertEqual(&quot;default&quot;, source.attrib[&quot;pool&quot;])
        self.assertEqual(&quot;hello_system&quot;, source.attrib[&quot;volume&quot;])
        self.assertEqual(&quot;myvolume&quot;, root.find(&quot;.//disk[2]/source&quot;).get(&quot;volume&quot;))

        # RBD volume usage auth test case
        self.mock_conn.listStoragePools.return_value = [&quot;test-rbd&quot;]
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = &quot;&quot;&quot;
            &lt;pool type='rbd'&gt;
              &lt;name&gt;test-rbd&lt;/name&gt;
              &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
              &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
              &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
              &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
              &lt;source&gt;
                &lt;host name='ses2.tf.local'/&gt;
                &lt;host name='ses3.tf.local' port='1234'/&gt;
                &lt;name&gt;libvirt-pool&lt;/name&gt;
                &lt;auth type='ceph' username='libvirt'&gt;
                  &lt;secret usage='pool_test-rbd'/&gt;
                &lt;/auth&gt;
              &lt;/source&gt;
            &lt;/pool&gt;
        &quot;&quot;&quot;
        self.mock_conn.getStoragePoolCapabilities.return_value = &quot;&quot;&quot;
            &lt;storagepoolCapabilities&gt;
              &lt;pool type='rbd' supported='yes'&gt;
                &lt;volOptions&gt;
                  &lt;defaultFormat type='raw'/&gt;
                  &lt;enum name='targetFormatType'&gt;
                  &lt;/enum&gt;
                &lt;/volOptions&gt;
              &lt;/pool&gt;
            &lt;/storagepoolCapabilities&gt;
        &quot;&quot;&quot;
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            &quot;kvm&quot;,
            [{&quot;name&quot;: &quot;system&quot;, &quot;pool&quot;: &quot;test-rbd&quot;}],
            &quot;test-vm&quot;,
        )
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        disk = root.findall(&quot;.//disk&quot;)[0]
        self.assertDictEqual(
            {
                &quot;type&quot;: &quot;network&quot;,
                &quot;device&quot;: &quot;disk&quot;,
                &quot;source&quot;: {
                    &quot;protocol&quot;: &quot;rbd&quot;,
                    &quot;name&quot;: &quot;libvirt-pool/test-vm_system&quot;,
                    &quot;host&quot;: [
                        {&quot;name&quot;: &quot;ses2.tf.local&quot;},
                        {&quot;name&quot;: &quot;ses3.tf.local&quot;, &quot;port&quot;: &quot;1234&quot;},
                    ],
                    &quot;auth&quot;: {
                        &quot;username&quot;: &quot;libvirt&quot;,
                        &quot;secret&quot;: {&quot;type&quot;: &quot;ceph&quot;, &quot;usage&quot;: &quot;pool_test-rbd&quot;},
                    },
                },
                &quot;target&quot;: {&quot;dev&quot;: &quot;vda&quot;, &quot;bus&quot;: &quot;virtio&quot;},
                &quot;driver&quot;: {
                    &quot;name&quot;: &quot;qemu&quot;,
                    &quot;type&quot;: &quot;raw&quot;,
                    &quot;cache&quot;: &quot;none&quot;,
                    &quot;io&quot;: &quot;native&quot;,
                },
            },
            salt.utils.xmlutil.to_dict(disk, True),
        )

        # RBD volume UUID auth test case
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = &quot;&quot;&quot;
            &lt;pool type='rbd'&gt;
              &lt;name&gt;test-rbd&lt;/name&gt;
              &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
              &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
              &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
              &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
              &lt;source&gt;
                &lt;host name='ses2.tf.local'/&gt;
                &lt;host name='ses3.tf.local' port='1234'/&gt;
                &lt;name&gt;libvirt-pool&lt;/name&gt;
                &lt;auth type='ceph' username='libvirt'&gt;
                  &lt;secret uuid='some-uuid'/&gt;
                &lt;/auth&gt;
              &lt;/source&gt;
            &lt;/pool&gt;
        &quot;&quot;&quot;
        self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
            &quot;pool_test-rbd&quot;
        )
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            &quot;kvm&quot;,
            [{&quot;name&quot;: &quot;system&quot;, &quot;pool&quot;: &quot;test-rbd&quot;}],
            &quot;test-vm&quot;,
        )
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertDictEqual(
            {
                &quot;username&quot;: &quot;libvirt&quot;,
                &quot;secret&quot;: {&quot;type&quot;: &quot;ceph&quot;, &quot;usage&quot;: &quot;pool_test-rbd&quot;},
            },
            salt.utils.xmlutil.to_dict(root.find(&quot;.//disk/source/auth&quot;), True),
        )
        self.mock_conn.secretLookupByUUIDString.assert_called_once_with(&quot;some-uuid&quot;)

        # Disk volume test case
        self.mock_conn.getStoragePoolCapabilities.return_value = &quot;&quot;&quot;
            &lt;storagepoolCapabilities&gt;
              &lt;pool type='disk' supported='yes'&gt;
                &lt;volOptions&gt;
                  &lt;defaultFormat type='none'/&gt;
                  &lt;enum name='targetFormatType'&gt;
                    &lt;value&gt;none&lt;/value&gt;
                    &lt;value&gt;linux&lt;/value&gt;
                    &lt;value&gt;fat16&lt;/value&gt;
                  &lt;/enum&gt;
                &lt;/volOptions&gt;
              &lt;/pool&gt;
            &lt;/storagepoolCapabilities&gt;
        &quot;&quot;&quot;
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = &quot;&quot;&quot;
            &lt;pool type='disk'&gt;
              &lt;name&gt;test-vdb&lt;/name&gt;
              &lt;source&gt;
                &lt;device path='/dev/vdb'/&gt;
                &lt;format type='gpt'/&gt;
              &lt;/source&gt;
            &lt;/pool&gt;
        &quot;&quot;&quot;
        self.mock_conn.listStoragePools.return_value = [&quot;test-vdb&quot;]
        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
            &quot;vdb1&quot;,
        ]
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            &quot;kvm&quot;,
            [{&quot;name&quot;: &quot;system&quot;, &quot;pool&quot;: &quot;test-vdb&quot;}],
            &quot;test-vm&quot;,
        )
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        disk = root.findall(&quot;.//disk&quot;)[0]
        self.assertEqual(disk.attrib[&quot;type&quot;], &quot;volume&quot;)
        source = disk.find(&quot;source&quot;)
        self.assertEqual(&quot;test-vdb&quot;, source.attrib[&quot;pool&quot;])
        self.assertEqual(&quot;vdb2&quot;, source.attrib[&quot;volume&quot;])
        self.assertEqual(&quot;raw&quot;, disk.find(&quot;driver&quot;).get(&quot;type&quot;))

    def test_get_xml_volume_xen_dir(self):
        &quot;&quot;&quot;
        Test virt._gen_xml generating disks for a Xen hypervisor
        &quot;&quot;&quot;
        self.mock_conn.listStoragePools.return_value = [&quot;default&quot;]
        pool_mock = MagicMock()
        pool_mock.XMLDesc.return_value = (
            &quot;&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;&quot;
        )
        volume_xml = &quot;&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;&quot;
        pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            &quot;xen&quot;,
            [{&quot;name&quot;: &quot;system&quot;, &quot;pool&quot;: &quot;default&quot;}],
            &quot;hello&quot;,
        )
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            [],
            &quot;xen&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        disk = root.findall(&quot;.//disk&quot;)[0]
        self.assertEqual(disk.attrib[&quot;type&quot;], &quot;file&quot;)
        self.assertEqual(
            &quot;/path/to/images/hello_system&quot;, disk.find(&quot;source&quot;).attrib[&quot;file&quot;]
        )

    def test_get_xml_volume_xen_block(self):
        &quot;&quot;&quot;
        Test virt._gen_xml generating disks for a Xen hypervisor
        &quot;&quot;&quot;
        self.mock_conn.listStoragePools.return_value = [&quot;default&quot;]
        pool_mock = MagicMock()
        pool_mock.listVolumes.return_value = [&quot;vol01&quot;]
        volume_xml = &quot;&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;&quot;
        pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        for pool_type in [&quot;logical&quot;, &quot;disk&quot;, &quot;iscsi&quot;, &quot;scsi&quot;]:
            pool_mock.XMLDesc.return_value = &quot;&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;&quot;.format(
                pool_type
            )
            diskp = virt._disk_profile(
                self.mock_conn,
                None,
                &quot;xen&quot;,
                [{&quot;name&quot;: &quot;system&quot;, &quot;pool&quot;: &quot;default&quot;, &quot;source_file&quot;: &quot;vol01&quot;}],
                &quot;hello&quot;,
            )
            xml_data = virt._gen_xml(
                self.mock_conn,
                &quot;hello&quot;,
                1,
                512,
                diskp,
                [],
                &quot;xen&quot;,
                &quot;hvm&quot;,
                &quot;x86_64&quot;,
            )
            root = ET.fromstring(xml_data)
            disk = root.findall(&quot;.//disk&quot;)[0]
            self.assertEqual(disk.attrib[&quot;type&quot;], &quot;block&quot;)
            self.assertEqual(&quot;/dev/to/vol01&quot;, disk.find(&quot;source&quot;).attrib[&quot;dev&quot;])

    def test_gen_xml_cdrom(self):
        &quot;&quot;&quot;
        Test virt._gen_xml(), generating a cdrom device (different disk type, no source)
        &quot;&quot;&quot;
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
            &quot;&lt;pool type='dir'/&gt;&quot;
        )
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            &quot;kvm&quot;,
            [
                {&quot;name&quot;: &quot;system&quot;, &quot;pool&quot;: &quot;default&quot;},
                {
                    &quot;name&quot;: &quot;tested&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;source_file&quot;: None,
                    &quot;model&quot;: &quot;ide&quot;,
                },
                {
                    &quot;name&quot;: &quot;remote&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;source_file&quot;: (
                        &quot;http://myhost:8080/url/to/image?query=foo&amp;filter=bar&quot;
                    ),
                    &quot;model&quot;: &quot;ide&quot;,
                },
            ],
            &quot;hello&quot;,
        )
        nicp = virt._nic_profile(None, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        disk = root.findall(&quot;.//disk&quot;)[1]
        self.assertEqual(disk.get(&quot;type&quot;), &quot;file&quot;)
        self.assertEqual(disk.attrib[&quot;device&quot;], &quot;cdrom&quot;)
        self.assertIsNone(disk.find(&quot;source&quot;))
        self.assertEqual(disk.find(&quot;target&quot;).get(&quot;dev&quot;), &quot;hda&quot;)

        disk = root.findall(&quot;.//disk&quot;)[2]
        self.assertEqual(disk.get(&quot;type&quot;), &quot;network&quot;)
        self.assertEqual(disk.attrib[&quot;device&quot;], &quot;cdrom&quot;)
        self.assertEqual(
            {
                &quot;protocol&quot;: &quot;http&quot;,
                &quot;name&quot;: &quot;/url/to/image&quot;,
                &quot;query&quot;: &quot;query=foo&amp;filter=bar&quot;,
                &quot;host&quot;: {&quot;name&quot;: &quot;myhost&quot;, &quot;port&quot;: &quot;8080&quot;},
            },
            salt.utils.xmlutil.to_dict(disk.find(&quot;source&quot;), True),
        )

    def test_controller_for_esxi(self):
        &quot;&quot;&quot;
<A NAME="2"></A>        Test virt._gen_xml() generated device controller for ESXi/vmware
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;vmware&quot;, [], &quot;hello&quot;)
        nicp <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#2',2,'match118032-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= virt._nic_profile(&quot;default&quot;, &quot;vmware&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;vmware&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        controllers = root.findall(&quot;.//devices/controller&quot;)
        self.assertTrue(</B></FONT>len(controllers) == 1)
        controller = controllers[0]
        self.assertEqual(controller.attrib[&quot;model&quot;], &quot;lsilogic&quot;)

    def test_controller_for_kvm(self):
        &quot;&quot;&quot;
        Test virt._gen_xml() generated device controller for KVM
        &quot;&quot;&quot;
        diskp = virt._disk_profile(self.mock_conn, &quot;default&quot;, &quot;kvm&quot;, [], &quot;hello&quot;)
        nicp = virt._nic_profile(&quot;default&quot;, &quot;kvm&quot;)
        xml_data = virt._gen_xml(
            self.mock_conn,
            &quot;hello&quot;,
            1,
            512,
            diskp,
            nicp,
            &quot;kvm&quot;,
            &quot;hvm&quot;,
            &quot;x86_64&quot;,
        )
        root = ET.fromstring(xml_data)
        controllers = root.findall(&quot;.//devices/controller&quot;)
        # There should be no controller
        self.assertTrue(len(controllers) == 0)

    def test_diff_disks(self):
        &quot;&quot;&quot;
        Test virt._diff_disks()
        &quot;&quot;&quot;
        old_disks = ET.fromstring(
            &quot;&quot;&quot;
            &lt;devices&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img0.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img1.qcow2'/&gt;
                &lt;target dev='vdb' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img2.qcow2'/&gt;
                &lt;target dev='hda' bus='ide'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img4.qcow2'/&gt;
                &lt;target dev='hdb' bus='ide'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;target dev='hdc' bus='ide'/&gt;
<A NAME="7"></A>              &lt;/disk&gt;
            &lt;/devices&gt;
        &quot;&quot;&quot;
        )<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#7',2,'match118032-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.findall(&quot;disk&quot;)

        new_disks = ET.fromstring(
            &quot;&quot;&quot;
            &lt;devices&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img3.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk' cache='default'&gt;
                &lt;source file='/path/to/img0.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img4.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;target dev='hda' bus='ide'/&gt;
              &lt;/disk&gt;
            &lt;/devices&gt;
        &quot;&quot;&quot;
        ).findall(&quot;disk&quot;)
        ret = virt._diff_disk_lists(old_disks, new_disks)
        self.assertEqual(</B></FONT>
            [
                disk.find(&quot;source&quot;).get(&quot;file&quot;)
                if disk.find(&quot;source&quot;) is not None
                else None
                for disk in ret[&quot;unchanged&quot;]
            ],
            [],
        )
        self.assertEqual(
            [
                disk.find(&quot;source&quot;).get(&quot;file&quot;)
                if disk.find(&quot;source&quot;) is not None
                else None
                for disk in ret[&quot;new&quot;]
            ],
            [&quot;/path/to/img3.qcow2&quot;, &quot;/path/to/img0.qcow2&quot;, &quot;/path/to/img4.qcow2&quot;, None],
        )
        self.assertEqual(
            [disk.find(&quot;target&quot;).get(&quot;dev&quot;) for disk in ret[&quot;sorted&quot;]],
            [&quot;vda&quot;, &quot;vdb&quot;, &quot;vdc&quot;, &quot;hda&quot;],
        )
        self.assertEqual(
            [
                disk.find(&quot;source&quot;).get(&quot;file&quot;)
                if disk.find(&quot;source&quot;) is not None
                else None
                for disk in ret[&quot;sorted&quot;]
            ],
            [&quot;/path/to/img3.qcow2&quot;, &quot;/path/to/img0.qcow2&quot;, &quot;/path/to/img4.qcow2&quot;, None],
        )
        self.assertEqual(ret[&quot;new&quot;][1].find(&quot;target&quot;).get(&quot;bus&quot;), &quot;virtio&quot;)
        self.assertEqual(
            [
                disk.find(&quot;source&quot;).get(&quot;file&quot;)
                if disk.find(&quot;source&quot;) is not None
                else None
                for disk in ret[&quot;deleted&quot;]
            ],
            [
                &quot;/path/to/img0.qcow2&quot;,
                &quot;/path/to/img1.qcow2&quot;,
                &quot;/path/to/img2.qcow2&quot;,
                &quot;/path/to/img4.qcow2&quot;,
                None,
            ],
        )

    def test_init(self):
        &quot;&quot;&quot;
        Test init() function
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;
&lt;capabilities&gt;
  &lt;host&gt;
    &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
    &lt;cpu&gt;
      &lt;arch&gt;x86_64&lt;/arch&gt;
      &lt;model&gt;Nehalem&lt;/model&gt;
      &lt;vendor&gt;Intel&lt;/vendor&gt;
      &lt;microcode version='25'/&gt;
      &lt;topology sockets='1' cores='4' threads='2'/&gt;
      &lt;feature name='vme'/&gt;
      &lt;feature name='ds'/&gt;
      &lt;feature name='acpi'/&gt;
      &lt;pages unit='KiB' size='4'/&gt;
      &lt;pages unit='KiB' size='2048'/&gt;
    &lt;/cpu&gt;
    &lt;power_management&gt;
      &lt;suspend_mem/&gt;
      &lt;suspend_disk/&gt;
      &lt;suspend_hybrid/&gt;
    &lt;/power_management&gt;
    &lt;migration_features&gt;
      &lt;live/&gt;
      &lt;uri_transports&gt;
        &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
        &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
      &lt;/uri_transports&gt;
    &lt;/migration_features&gt;
    &lt;topology&gt;
      &lt;cells num='1'&gt;
        &lt;cell id='0'&gt;
          &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
          &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
          &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
          &lt;distances&gt;
            &lt;sibling id='0' value='10'/&gt;
          &lt;/distances&gt;
          &lt;cpus num='8'&gt;
            &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
            &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
            &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
            &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
            &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
            &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
            &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
            &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
          &lt;/cpus&gt;
        &lt;/cell&gt;
      &lt;/cells&gt;
    &lt;/topology&gt;
    &lt;cache&gt;
      &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
    &lt;/cache&gt;
    &lt;secmodel&gt;
      &lt;model&gt;apparmor&lt;/model&gt;
      &lt;doi&gt;0&lt;/doi&gt;
    &lt;/secmodel&gt;
    &lt;secmodel&gt;
      &lt;model&gt;dac&lt;/model&gt;
      &lt;doi&gt;0&lt;/doi&gt;
      &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
      &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
    &lt;/secmodel&gt;
  &lt;/host&gt;

  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='i686'&gt;
      &lt;wordsize&gt;32&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
    &lt;features&gt;
      &lt;cpuselection/&gt;
      &lt;deviceboot/&gt;
      &lt;disksnapshot default='on' toggle='no'/&gt;
      &lt;acpi default='on' toggle='yes'/&gt;
      &lt;apic default='on' toggle='no'/&gt;
      &lt;pae/&gt;
      &lt;nonpae/&gt;
    &lt;/features&gt;
  &lt;/guest&gt;

  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='x86_64'&gt;
      &lt;wordsize&gt;64&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
    &lt;features&gt;
      &lt;cpuselection/&gt;
      &lt;deviceboot/&gt;
      &lt;disksnapshot default='on' toggle='no'/&gt;
      &lt;acpi default='on' toggle='yes'/&gt;
      &lt;apic default='on' toggle='no'/&gt;
    &lt;/features&gt;
  &lt;/guest&gt;

&lt;/capabilities&gt;
        &quot;&quot;&quot;
        self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member

        root_dir = os.path.join(salt.syspaths.ROOT_DIR, &quot;srv&quot;, &quot;salt-images&quot;)

        defineMock = MagicMock(return_value=1)
        self.mock_conn.defineXML = defineMock
        mock_chmod = MagicMock()
        mock_run = MagicMock()
        with patch.dict(
            os.__dict__, {&quot;chmod&quot;: mock_chmod, &quot;makedirs&quot;: MagicMock()}
        ):  # pylint: disable=no-member
            with patch.dict(
                virt.__salt__, {&quot;cmd.run&quot;: mock_run}
            ):  # pylint: disable=no-member

                # Ensure the init() function allows creating VM without NIC and disk
                virt.init(
                    &quot;test vm&quot;, 2, 1234, nic=None, disk=None, seed=False, start=False
                )
                definition = defineMock.call_args_list[0][0][0]
                self.assertFalse(&quot;&lt;interface&quot; in definition)
                self.assertFalse(&quot;&lt;disk&quot; in definition)

                # Ensure the init() function allows creating VM without NIC and
                # disk but with boot parameters.

                defineMock.reset_mock()
                mock_run.reset_mock()
                boot = {
                    &quot;kernel&quot;: &quot;/root/f8-i386-vmlinuz&quot;,
                    &quot;initrd&quot;: &quot;/root/f8-i386-initrd&quot;,
                    &quot;cmdline&quot;: &quot;console=ttyS0 ks=http://example.com/f8-i386/os/&quot;,
                }
                retval = virt.init(
                    &quot;test vm boot params&quot;,
                    2,
                    1234,
                    nic=None,
                    disk=None,
                    seed=False,
                    start=False,
                    boot=boot,
                )
                definition = defineMock.call_args_list[0][0][0]
                self.assertEqual(&quot;&lt;kernel&quot; in definition, True)
                self.assertEqual(&quot;&lt;initrd&quot; in definition, True)
                self.assertEqual(&quot;&lt;cmdline&quot; in definition, True)
                self.assertEqual(retval, True)

                # Verify that remote paths are downloaded and the xml has been
                # modified
                mock_response = MagicMock()
                mock_response.read = MagicMock(return_value=&quot;filecontent&quot;)
                cache_dir = tempfile.mkdtemp()

                with patch.dict(virt.__dict__, {&quot;CACHE_DIR&quot;: cache_dir}):
                    with patch(
                        &quot;urllib.request.urlopen&quot;,
                        MagicMock(return_value=mock_response),
                    ):
                        with patch(
                            &quot;salt.utils.files.fopen&quot;, return_value=mock_response
                        ):

                            defineMock.reset_mock()
                            mock_run.reset_mock()
                            boot = {
                                &quot;kernel&quot;: &quot;https://www.example.com/download/vmlinuz&quot;,
                                &quot;initrd&quot;: &quot;&quot;,
                                &quot;cmdline&quot;: (
                                    &quot;console=ttyS0 ks=http://example.com/f8-i386/os/&quot;
                                ),
                            }

                            retval = virt.init(
                                &quot;test remote vm boot params&quot;,
                                2,
                                1234,
                                nic=None,
                                disk=None,
                                seed=False,
                                start=False,
                                boot=boot,
                            )
                            definition = defineMock.call_args_list[0][0][0]
                            self.assertEqual(cache_dir in definition, True)

                    shutil.rmtree(cache_dir)

                # Test case creating disks
                defineMock.reset_mock()
                mock_run.reset_mock()
                pool_mock = MagicMock()
                pool_mock.XMLDesc.return_value = '&lt;pool type=&quot;dir&quot;/&gt;'
                self.mock_conn.storagePoolLookupByName.return_value = pool_mock
                virt.init(
                    &quot;test vm&quot;,
                    2,
                    1234,
                    nic=None,
                    disk=None,
                    disks=[
                        {&quot;name&quot;: &quot;system&quot;, &quot;size&quot;: 10240},
                        {
                            &quot;name&quot;: &quot;cddrive&quot;,
                            &quot;device&quot;: &quot;cdrom&quot;,
                            &quot;source_file&quot;: None,
                            &quot;model&quot;: &quot;ide&quot;,
                        },
                    ],
                    seed=False,
                    start=False,
                )
                definition = ET.fromstring(defineMock.call_args_list[0][0][0])
                expected_disk_path = os.path.join(root_dir, &quot;test vm_system.qcow2&quot;)
                self.assertEqual(
                    expected_disk_path,
                    definition.find(&quot;./devices/disk[1]/source&quot;).get(&quot;file&quot;),
                )
                self.assertIsNone(definition.find(&quot;./devices/disk[2]/source&quot;))
                self.assertEqual(
                    mock_run.call_args[0][0],
                    'qemu-img create -f qcow2 &quot;{}&quot; 10240M'.format(expected_disk_path),
                )
                self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)

                # Test case creating disks volumes
                defineMock.reset_mock()
                mock_run.reset_mock()
                vol_mock = MagicMock()
                pool_mock.storageVolLookupByName.return_value = vol_mock
                pool_mock.listVolumes.return_value = [&quot;test vm_data&quot;]
                stream_mock = MagicMock()
                self.mock_conn.newStream.return_value = stream_mock
                self.mock_conn.listStoragePools.return_value = [&quot;default&quot;, &quot;test&quot;]
                with patch.dict(
                    os.__dict__, {&quot;open&quot;: MagicMock(), &quot;close&quot;: MagicMock()}
                ):
                    cache_mock = MagicMock()
                    with patch.dict(virt.__salt__, {&quot;cp.cache_file&quot;: cache_mock}):
                        virt.init(
                            &quot;test vm&quot;,
                            2,
                            1234,
                            nic=None,
                            disk=None,
                            disks=[
                                {
                                    &quot;name&quot;: &quot;system&quot;,
                                    &quot;size&quot;: 10240,
                                    &quot;image&quot;: &quot;/path/to/image&quot;,
                                    &quot;pool&quot;: &quot;test&quot;,
                                },
                                {&quot;name&quot;: &quot;data&quot;, &quot;size&quot;: 10240, &quot;pool&quot;: &quot;default&quot;},
                                {
                                    &quot;name&quot;: &quot;test&quot;,
                                    &quot;size&quot;: 1024,
                                    &quot;pool&quot;: &quot;default&quot;,
                                    &quot;format&quot;: &quot;qcow2&quot;,
                                    &quot;backing_store_path&quot;: &quot;/backing/path&quot;,
                                    &quot;backing_store_format&quot;: &quot;raw&quot;,
                                },
                            ],
                            seed=False,
                            start=False,
                        )
                        definition = ET.fromstring(defineMock.call_args_list[0][0][0])
                        self.assertTrue(
                            all(
                                [
                                    disk.get(&quot;type&quot;) == &quot;volume&quot;
                                    for disk in definition.findall(&quot;./devices/disk&quot;)
                                ]
                            )
                        )
                        self.assertEqual(
                            [&quot;test&quot;, &quot;default&quot;, &quot;default&quot;],
                            [
                                src.get(&quot;pool&quot;)
                                for src in definition.findall(&quot;./devices/disk/source&quot;)
                            ],
                        )
                        self.assertEqual(
                            [&quot;test vm_system&quot;, &quot;test vm_data&quot;, &quot;test vm_test&quot;],
                            [
                                src.get(&quot;volume&quot;)
                                for src in definition.findall(&quot;./devices/disk/source&quot;)
                            ],
                        )

                        create_calls = pool_mock.createXML.call_args_list
                        vol_names = [
                            ET.fromstring(call[0][0]).find(&quot;name&quot;).text
                            for call in create_calls
                        ]
                        self.assertEqual(
                            [&quot;test vm_system&quot;, &quot;test vm_test&quot;],
                            vol_names,
                        )

                        stream_mock.sendAll.assert_called_once()
                        stream_mock.finish.assert_called_once()
                        vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)

    def test_update_backing_store(self):
        &quot;&quot;&quot;
        Test updating a disk with a backing store
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;
            &lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;my_vm&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;devices&gt;
                &lt;disk type='volume' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
                  &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
                  &lt;backingStore type='file' index='2'&gt;
                    &lt;format type='qcow2'/&gt;
                    &lt;source file='/path/to/base.qcow2'/&gt;
                    &lt;backingStore/&gt;
                  &lt;/backingStore&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                  &lt;alias name='virtio-disk0'/&gt;
                  &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
                &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        domain_mock = self.set_mock_vm(&quot;my_vm&quot;, xml)
        domain_mock.OSType.return_value = &quot;hvm&quot;
        self.mock_conn.defineXML.return_value = True
        updatedev_mock = MagicMock(return_value=0)
        domain_mock.updateDeviceFlags = updatedev_mock
        self.mock_conn.listStoragePools.return_value = [&quot;default&quot;]
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
            &quot;&lt;pool type='dir'/&gt;&quot;
        )

        ret = virt.update(
            &quot;my_vm&quot;,
            disks=[
                {
                    &quot;name&quot;: &quot;system&quot;,
                    &quot;pool&quot;: &quot;default&quot;,
                    &quot;backing_store_path&quot;: &quot;/path/to/base.qcow2&quot;,
                    &quot;backing_store_format&quot;: &quot;qcow2&quot;,
                },
            ],
        )
        self.assertFalse(ret[&quot;definition&quot;])
        self.assertFalse(ret[&quot;disk&quot;][&quot;attached&quot;])
        self.assertFalse(ret[&quot;disk&quot;][&quot;detached&quot;])

    def test_update_removables(self):
        &quot;&quot;&quot;
        Test attaching, detaching, changing removable devices
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;
            &lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;my_vm&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;devices&gt;
                &lt;disk type='network' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
                    &lt;host name='test-srv.local' port='80'/&gt;
                  &lt;/source&gt;
                  &lt;backingStore/&gt;
                  &lt;target dev='hda' bus='ide'/&gt;
                  &lt;readonly/&gt;
                  &lt;alias name='ide0-0-0'/&gt;
                  &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
                &lt;/disk&gt;
                &lt;disk type='file' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;target dev='hdb' bus='ide'/&gt;
                  &lt;readonly/&gt;
                  &lt;alias name='ide0-0-1'/&gt;
                  &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
                &lt;/disk&gt;
                &lt;disk type='file' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;source file='/srv/dvd-image-2.iso'/&gt;
                  &lt;backingStore/&gt;
                  &lt;target dev='hdc' bus='ide'/&gt;
                  &lt;readonly/&gt;
                  &lt;alias name='ide0-0-2'/&gt;
                  &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
                &lt;/disk&gt;
                &lt;disk type='file' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;source file='/srv/dvd-image-3.iso'/&gt;
                  &lt;backingStore/&gt;
                  &lt;target dev='hdd' bus='ide'/&gt;
                  &lt;readonly/&gt;
                  &lt;alias name='ide0-0-3'/&gt;
                  &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
                &lt;/disk&gt;
                &lt;disk type='network' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
                    &lt;host name='test-srv.local' port='80'/&gt;
                  &lt;/source&gt;
                  &lt;backingStore/&gt;
                  &lt;target dev='hde' bus='ide'/&gt;
                  &lt;readonly/&gt;
                &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        domain_mock = self.set_mock_vm(&quot;my_vm&quot;, xml)
        domain_mock.OSType.return_value = &quot;hvm&quot;
        self.mock_conn.defineXML.return_value = True
        updatedev_mock = MagicMock(return_value=0)
        domain_mock.updateDeviceFlags = updatedev_mock

        ret = virt.update(
            &quot;my_vm&quot;,
            disks=[
                {
                    &quot;name&quot;: &quot;dvd1&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;source_file&quot;: None,
                    &quot;model&quot;: &quot;ide&quot;,
                },
                {
                    &quot;name&quot;: &quot;dvd2&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;source_file&quot;: &quot;/srv/dvd-image-4.iso&quot;,
                    &quot;model&quot;: &quot;ide&quot;,
                },
                {
                    &quot;name&quot;: &quot;dvd3&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;source_file&quot;: &quot;/srv/dvd-image-2.iso&quot;,
                    &quot;model&quot;: &quot;ide&quot;,
                },
                {
                    &quot;name&quot;: &quot;dvd4&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;source_file&quot;: &quot;/srv/dvd-image-5.iso&quot;,
                    &quot;model&quot;: &quot;ide&quot;,
                },
                {
                    &quot;name&quot;: &quot;dvd5&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;source_file&quot;: &quot;/srv/dvd-image-6.iso&quot;,
                    &quot;model&quot;: &quot;ide&quot;,
                },
            ],
        )

        self.assertTrue(ret[&quot;definition&quot;])
        self.assertFalse(ret[&quot;disk&quot;].get(&quot;attached&quot;))
        self.assertFalse(ret[&quot;disk&quot;].get(&quot;detached&quot;))
        self.assertEqual(
            [
                {
                    &quot;type&quot;: &quot;file&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;driver&quot;: {
                        &quot;name&quot;: &quot;qemu&quot;,
                        &quot;type&quot;: &quot;raw&quot;,
                        &quot;cache&quot;: &quot;none&quot;,
                        &quot;io&quot;: &quot;native&quot;,
                    },
                    &quot;backingStore&quot;: None,
                    &quot;target&quot;: {&quot;dev&quot;: &quot;hda&quot;, &quot;bus&quot;: &quot;ide&quot;},
                    &quot;readonly&quot;: None,
                    &quot;alias&quot;: {&quot;name&quot;: &quot;ide0-0-0&quot;},
                    &quot;address&quot;: {
                        &quot;type&quot;: &quot;drive&quot;,
                        &quot;controller&quot;: &quot;0&quot;,
                        &quot;bus&quot;: &quot;0&quot;,
                        &quot;target&quot;: &quot;0&quot;,
                        &quot;unit&quot;: &quot;0&quot;,
                    },
                },
                {
                    &quot;type&quot;: &quot;file&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;driver&quot;: {
                        &quot;name&quot;: &quot;qemu&quot;,
                        &quot;type&quot;: &quot;raw&quot;,
                        &quot;cache&quot;: &quot;none&quot;,
                        &quot;io&quot;: &quot;native&quot;,
                    },
                    &quot;target&quot;: {&quot;dev&quot;: &quot;hdb&quot;, &quot;bus&quot;: &quot;ide&quot;},
                    &quot;readonly&quot;: None,
                    &quot;alias&quot;: {&quot;name&quot;: &quot;ide0-0-1&quot;},
                    &quot;address&quot;: {
                        &quot;type&quot;: &quot;drive&quot;,
                        &quot;controller&quot;: &quot;0&quot;,
                        &quot;bus&quot;: &quot;0&quot;,
                        &quot;target&quot;: &quot;0&quot;,
                        &quot;unit&quot;: &quot;1&quot;,
                    },
                    &quot;source&quot;: {&quot;file&quot;: &quot;/srv/dvd-image-4.iso&quot;},
                },
                {
                    &quot;type&quot;: &quot;file&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;driver&quot;: {
                        &quot;name&quot;: &quot;qemu&quot;,
                        &quot;type&quot;: &quot;raw&quot;,
                        &quot;cache&quot;: &quot;none&quot;,
                        &quot;io&quot;: &quot;native&quot;,
                    },
                    &quot;backingStore&quot;: None,
                    &quot;target&quot;: {&quot;dev&quot;: &quot;hdd&quot;, &quot;bus&quot;: &quot;ide&quot;},
                    &quot;readonly&quot;: None,
                    &quot;alias&quot;: {&quot;name&quot;: &quot;ide0-0-3&quot;},
                    &quot;address&quot;: {
                        &quot;type&quot;: &quot;drive&quot;,
                        &quot;controller&quot;: &quot;0&quot;,
                        &quot;bus&quot;: &quot;0&quot;,
                        &quot;target&quot;: &quot;0&quot;,
                        &quot;unit&quot;: &quot;3&quot;,
                    },
                    &quot;source&quot;: {&quot;file&quot;: &quot;/srv/dvd-image-5.iso&quot;},
                },
                {
                    &quot;type&quot;: &quot;file&quot;,
                    &quot;device&quot;: &quot;cdrom&quot;,
                    &quot;driver&quot;: {
                        &quot;name&quot;: &quot;qemu&quot;,
                        &quot;type&quot;: &quot;raw&quot;,
                        &quot;cache&quot;: &quot;none&quot;,
                        &quot;io&quot;: &quot;native&quot;,
                    },
                    &quot;backingStore&quot;: None,
                    &quot;target&quot;: {&quot;dev&quot;: &quot;hde&quot;, &quot;bus&quot;: &quot;ide&quot;},
                    &quot;readonly&quot;: None,
                    &quot;source&quot;: {&quot;file&quot;: &quot;/srv/dvd-image-6.iso&quot;},
                },
            ],
            [
                salt.utils.xmlutil.to_dict(ET.fromstring(disk), True)
                for disk in ret[&quot;disk&quot;][&quot;updated&quot;]
            ],
        )

    def test_update_xen_boot_params(self):
        &quot;&quot;&quot;
        Test virt.update() a Xen definition no boot parameter.
        &quot;&quot;&quot;
        root_dir = os.path.join(salt.syspaths.ROOT_DIR, &quot;srv&quot;, &quot;salt-images&quot;)
        xml_boot = &quot;&quot;&quot;
            &lt;domain type='xen' id='8'&gt;
              &lt;name&gt;vm&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
                &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        domain_mock_boot = self.set_mock_vm(&quot;vm&quot;, xml_boot)
        domain_mock_boot.OSType = MagicMock(return_value=&quot;hvm&quot;)
        define_mock_boot = MagicMock(return_value=True)
        define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
        self.mock_conn.defineXML = define_mock_boot
        self.assertEqual(
            {
                &quot;cpu&quot;: False,
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm&quot;, cpu=2),
        )
        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;loader&quot;).attrib.get(&quot;type&quot;), &quot;rom&quot;)
        self.assertEqual(
            setxml.find(&quot;os&quot;).find(&quot;loader&quot;).text, &quot;/usr/lib/xen/boot/hvmloader&quot;
        )

    def test_update_existing_boot_params(self):
        &quot;&quot;&quot;
        Test virt.update() with existing boot parameters.
        &quot;&quot;&quot;
        xml_boot = &quot;&quot;&quot;
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_boot_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
                &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
                &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
                &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
                &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
                &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        domain_mock_boot = self.set_mock_vm(&quot;vm_with_boot_param&quot;, xml_boot)
        domain_mock_boot.OSType = MagicMock(return_value=&quot;hvm&quot;)
        define_mock_boot = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock_boot
        boot_new = {
            &quot;kernel&quot;: &quot;/root/new-vmlinuz&quot;,
            &quot;initrd&quot;: &quot;/root/new-initrd&quot;,
            &quot;cmdline&quot;: &quot;console=ttyS0 ks=http://example.com/new/os/&quot;,
        }

        uefi_boot_new = {
            &quot;loader&quot;: &quot;/usr/share/new/OVMF_CODE.fd&quot;,
            &quot;nvram&quot;: &quot;/usr/share/new/OVMF_VARS.ms.fd&quot;,
        }

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_boot_param&quot;, boot=boot_new),
        )
        setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(
            setxml_boot.find(&quot;os&quot;).find(&quot;kernel&quot;).text, &quot;/root/new-vmlinuz&quot;
        )
        self.assertEqual(setxml_boot.find(&quot;os&quot;).find(&quot;initrd&quot;).text, &quot;/root/new-initrd&quot;)
        self.assertEqual(
            setxml_boot.find(&quot;os&quot;).find(&quot;cmdline&quot;).text,
            &quot;console=ttyS0 ks=http://example.com/new/os/&quot;,
        )

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_boot_param&quot;, boot=uefi_boot_new),
        )

        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;os&quot;).find(&quot;loader&quot;).text, &quot;/usr/share/new/OVMF_CODE.fd&quot;
        )
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;loader&quot;).attrib.get(&quot;readonly&quot;), &quot;yes&quot;)
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;loader&quot;).attrib[&quot;type&quot;], &quot;pflash&quot;)
        self.assertEqual(
            setxml.find(&quot;os&quot;).find(&quot;nvram&quot;).attrib[&quot;template&quot;],
            &quot;/usr/share/new/OVMF_VARS.ms.fd&quot;,
        )

        kernel_none = {
            &quot;kernel&quot;: None,
            &quot;initrd&quot;: None,
            &quot;cmdline&quot;: None,
        }

        uefi_none = {&quot;loader&quot;: None, &quot;nvram&quot;: None}

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_boot_param&quot;, boot=kernel_none),
        )

        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;kernel&quot;), None)
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;initrd&quot;), None)
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;cmdline&quot;), None)

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_boot_param&quot;, boot={&quot;efi&quot;: False}),
        )
        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;nvram&quot;), None)
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;loader&quot;), None)

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_boot_param&quot;, boot=uefi_none),
        )

        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;loader&quot;), None)
        self.assertEqual(setxml.find(&quot;os&quot;).find(&quot;nvram&quot;), None)

    def test_update_existing_numatune_params(self):
        &quot;&quot;&quot;
        Test virt.update() with existing numatune parameters.
        &quot;&quot;&quot;
        xml_numatune = &quot;&quot;&quot;
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;maxMemory slots=&quot;12&quot; unit=&quot;bytes&quot;&gt;1048576&lt;/maxMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;numatune&gt;
                &lt;memory mode=&quot;strict&quot; nodeset=&quot;0-11&quot;/&gt;
                &lt;memnode cellid=&quot;1&quot; mode=&quot;strict&quot; nodeset=&quot;3&quot;/&gt;
                &lt;memnode cellid=&quot;3&quot; mode=&quot;preferred&quot; nodeset=&quot;7&quot;/&gt;
              &lt;/numatune&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        domain_mock = self.set_mock_vm(&quot;vm_with_numatune_param&quot;, xml_numatune)
        domain_mock.OSType = MagicMock(return_value=&quot;hvm&quot;)
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        # test update existing numatune node
        numatune = {
            &quot;memory&quot;: {&quot;mode&quot;: &quot;preferred&quot;, &quot;nodeset&quot;: &quot;0-5&quot;},
            &quot;memnodes&quot;: {
                0: {&quot;mode&quot;: &quot;strict&quot;, &quot;nodeset&quot;: &quot;4&quot;},
                3: {&quot;mode&quot;: &quot;preferred&quot;, &quot;nodeset&quot;: &quot;7&quot;},
                4: {&quot;mode&quot;: &quot;strict&quot;, &quot;nodeset&quot;: &quot;6&quot;},
            },
        }

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_numatune_param&quot;, numatune=numatune),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;numatune&quot;).find(&quot;memory&quot;).attrib.get(&quot;mode&quot;), &quot;preferred&quot;
        )

        self.assertEqual(
            setxml.find(&quot;numatune&quot;).find(&quot;memory&quot;).attrib.get(&quot;nodeset&quot;),
            &quot;,&quot;.join([str(i) for i in range(0, 6)]),
        )

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='0']&quot;).attrib.get(&quot;mode&quot;), &quot;strict&quot;
        )

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='0']&quot;).attrib.get(&quot;nodeset&quot;), &quot;4&quot;
        )

        self.assertEqual(setxml.find(&quot;./numatune/memnode/[@cellid='1']&quot;), None)

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='3']&quot;).attrib.get(&quot;mode&quot;),
            &quot;preferred&quot;,
        )

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='3']&quot;).attrib.get(&quot;nodeset&quot;), &quot;7&quot;
        )

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='4']&quot;).attrib.get(&quot;mode&quot;), &quot;strict&quot;
        )

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='4']&quot;).attrib.get(&quot;nodeset&quot;), &quot;6&quot;
        )

        self.assertEqual(setxml.find(&quot;./numatune/memnode/[@cellid='2']&quot;), None)

        numatune_mem_none = {
            &quot;memory&quot;: None,
            &quot;memnodes&quot;: {
                0: {&quot;mode&quot;: &quot;strict&quot;, &quot;nodeset&quot;: &quot;4&quot;},
                3: {&quot;mode&quot;: &quot;preferred&quot;, &quot;nodeset&quot;: &quot;7&quot;},
                4: {&quot;mode&quot;: &quot;strict&quot;, &quot;nodeset&quot;: &quot;6&quot;},
            },
        }

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_numatune_param&quot;, numatune=numatune_mem_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;numatune&quot;).find(&quot;memory&quot;), None)

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='0']&quot;).attrib.get(&quot;mode&quot;), &quot;strict&quot;
        )

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='0']&quot;).attrib.get(&quot;nodeset&quot;), &quot;4&quot;
        )

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='3']&quot;).attrib.get(&quot;mode&quot;),
            &quot;preferred&quot;,
        )

        self.assertEqual(
            setxml.find(&quot;./numatune/memnode/[@cellid='3']&quot;).attrib.get(&quot;nodeset&quot;), &quot;7&quot;
        )

        self.assertEqual(setxml.find(&quot;./numatune/memnode/[@cellid='2']&quot;), None)

        numatune_mnodes_none = {
            &quot;memory&quot;: {&quot;mode&quot;: &quot;preferred&quot;, &quot;nodeset&quot;: &quot;0-5&quot;},
            &quot;memnodes&quot;: None,
        }

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_numatune_param&quot;, numatune=numatune_mnodes_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;numatune&quot;).find(&quot;memory&quot;).attrib.get(&quot;mode&quot;), &quot;preferred&quot;
        )

        self.assertEqual(
            setxml.find(&quot;numatune&quot;).find(&quot;memory&quot;).attrib.get(&quot;nodeset&quot;),
            &quot;,&quot;.join([str(i) for i in range(0, 6)]),
        )

        self.assertEqual(setxml.find(&quot;./numatune/memnode&quot;), None)

        numatune_without_change = {
            &quot;memory&quot;: {&quot;mode&quot;: &quot;strict&quot;, &quot;nodeset&quot;: &quot;0-5,6,7-11&quot;},
            &quot;memnodes&quot;: {
                1: {&quot;mode&quot;: &quot;strict&quot;, &quot;nodeset&quot;: &quot;3&quot;},
                3: {&quot;mode&quot;: &quot;preferred&quot;, &quot;nodeset&quot;: &quot;7&quot;},
            },
        }

        self.assertEqual(
            {
                &quot;definition&quot;: False,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_numatune_param&quot;, numatune=numatune_without_change),
        )

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(
                &quot;vm_with_numatune_param&quot;, numatune={&quot;memory&quot;: None, &quot;memnodes&quot;: None}
            ),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;numatune&quot;), None)

    def test_update_existing_cpu_params(self):
        &quot;&quot;&quot;
        Test virt.update() with existing cpu-related parameters.
        &quot;&quot;&quot;
        xml_with_existing_params = &quot;&quot;&quot;
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_boot_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement=&quot;static&quot; cpuset=&quot;0-11&quot; current=&quot;3&quot;&gt;6&lt;/vcpu&gt;
              &lt;vcpus&gt;
                &lt;vcpu id=&quot;0&quot; enabled=&quot;yes&quot; hotpluggable=&quot;no&quot; order=&quot;1&quot;/&gt;
                &lt;vcpu id=&quot;1&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;2&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;3&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;4&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;5&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;6&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;7&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;8&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;9&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;10&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
                &lt;vcpu id=&quot;11&quot; enabled=&quot;no&quot; hotpluggable=&quot;yes&quot;/&gt;
              &lt;/vcpus&gt;
              &lt;cpu mode=&quot;custom&quot; match=&quot;exact&quot; check=&quot;full&quot;&gt;
                 &lt;model fallback=&quot;allow&quot; vendor_id=&quot;Genuine20201&quot;&gt;core2duo&lt;/model&gt;
                 &lt;vendor&gt;Intel&lt;/vendor&gt;
                 &lt;topology sockets=&quot;2&quot; cores=&quot;5&quot; threads=&quot;2&quot;/&gt;
                 &lt;cache level=&quot;3&quot; mode=&quot;emulate&quot;/&gt;
                 &lt;feature policy=&quot;optional&quot; name=&quot;lahf_lm&quot;/&gt;
                 &lt;feature policy=&quot;require&quot; name=&quot;pcid&quot;/&gt;
                 &lt;numa&gt;
                    &lt;cell id=&quot;0&quot; cpus=&quot;0-3&quot; memory=&quot;1073741824&quot; unit=&quot;KiB&quot; discard=&quot;no&quot;&gt;
                        &lt;distances&gt;
                            &lt;sibling id=&quot;0&quot; value=&quot;10&quot;/&gt;
                            &lt;sibling id=&quot;1&quot; value=&quot;21&quot;/&gt;
                            &lt;sibling id=&quot;2&quot; value=&quot;31&quot;/&gt;
                            &lt;sibling id=&quot;3&quot; value=&quot;41&quot;/&gt;
                        &lt;/distances&gt;
                    &lt;/cell&gt;
                    &lt;cell id=&quot;1&quot; cpus=&quot;4-6&quot; memory=&quot;1073741824&quot; unit=&quot;KiB&quot; memAccess=&quot;private&quot;&gt;
                        &lt;distances&gt;
                            &lt;sibling id=&quot;0&quot; value=&quot;21&quot;/&gt;
                            &lt;sibling id=&quot;1&quot; value=&quot;10&quot;/&gt;
                            &lt;sibling id=&quot;2&quot; value=&quot;21&quot;/&gt;
                            &lt;sibling id=&quot;3&quot; value=&quot;31&quot;/&gt;
                        &lt;/distances&gt;
                    &lt;/cell&gt;
                 &lt;/numa&gt;
              &lt;/cpu&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;/domain&gt;
         &quot;&quot;&quot;
        domain_mock = self.set_mock_vm(
            &quot;vm_with_existing_param&quot;, xml_with_existing_params
        )
        domain_mock.OSType = MagicMock(return_value=&quot;hvm&quot;)
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        # test update vcpu with existing attributes case
        setvcpus_mock = MagicMock(return_value=0)
        domain_mock.setVcpusFlags = setvcpus_mock

        cpu_attr = {&quot;placement&quot;: &quot;static&quot;, &quot;cpuset&quot;: &quot;0-5&quot;, &quot;current&quot;: 3, &quot;maximum&quot;: 5}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;cpu&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_attr),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;vcpu&quot;).text, &quot;5&quot;)
        self.assertEqual(setxml.find(&quot;vcpu&quot;).attrib[&quot;placement&quot;], &quot;static&quot;)
        self.assertEqual(
            setxml.find(&quot;vcpu&quot;).attrib[&quot;cpuset&quot;],
            &quot;,&quot;.join([str(i) for i in range(0, 6)]),
        )
        self.assertEqual(setxml.find(&quot;vcpu&quot;).attrib[&quot;current&quot;], &quot;3&quot;)

        # test removing vcpu attribute
        cpu_none = {&quot;placement&quot;: &quot;auto&quot;, &quot;cpuset&quot;: None, &quot;current&quot;: 2, &quot;maximum&quot;: 5}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;cpu&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;vcpu&quot;).text, &quot;5&quot;)
        self.assertEqual(setxml.find(&quot;vcpu&quot;).attrib[&quot;placement&quot;], &quot;auto&quot;)
        self.assertEqual(setxml.find(&quot;vcpu&quot;).attrib.get(&quot;cpuset&quot;), None)
        self.assertEqual(setxml.find(&quot;vcpu&quot;).attrib.get(&quot;current&quot;), &quot;2&quot;)

        # test update individual vcpu with exisiting attributes
        vcpus = {
            &quot;vcpus&quot;: {
                &quot;0&quot;: {&quot;enabled&quot;: False, &quot;hotpluggable&quot;: True, &quot;order&quot;: 5},
                &quot;3&quot;: {&quot;enabled&quot;: True, &quot;hotpluggable&quot;: False, &quot;order&quot;: 3},
                &quot;7&quot;: {&quot;enabled&quot;: True, &quot;hotpluggable&quot;: False},
            }
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=vcpus),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='0']&quot;).attrib[&quot;id&quot;], &quot;0&quot;)
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='0']&quot;).attrib[&quot;enabled&quot;], &quot;no&quot;)
        self.assertEqual(
            setxml.find(&quot;./vcpus/vcpu/[@id='0']&quot;).attrib[&quot;hotpluggable&quot;], &quot;yes&quot;
        )
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='0']&quot;).attrib[&quot;order&quot;], &quot;5&quot;)
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='3']&quot;).attrib[&quot;id&quot;], &quot;3&quot;)
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='3']&quot;).attrib[&quot;enabled&quot;], &quot;yes&quot;)
        self.assertEqual(
            setxml.find(&quot;./vcpus/vcpu/[@id='3']&quot;).attrib[&quot;hotpluggable&quot;], &quot;no&quot;
        )
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='3']&quot;).attrib[&quot;order&quot;], &quot;3&quot;)
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='7']&quot;).attrib[&quot;id&quot;], &quot;7&quot;)
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='7']&quot;).attrib[&quot;enabled&quot;], &quot;yes&quot;)
        self.assertEqual(
            setxml.find(&quot;./vcpus/vcpu/[@id='7']&quot;).attrib[&quot;hotpluggable&quot;], &quot;no&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./vcpus/vcpu/[@id='7']&quot;).attrib.get(&quot;order&quot;), None
        )

        # test removing vcpu element
        ind_vcpu = {
            &quot;vcpus&quot;: {&quot;3&quot;: {&quot;enabled&quot;: True, &quot;hotpluggable&quot;: False, &quot;order&quot;: None}}
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=ind_vcpu),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='0']&quot;), None)
        self.assertEqual(setxml.find(&quot;./vcpus/vcpu/[@id='3']&quot;).attrib[&quot;enabled&quot;], &quot;yes&quot;)
        self.assertEqual(
            setxml.find(&quot;./vcpus/vcpu/[@id='3']&quot;).attrib[&quot;hotpluggable&quot;], &quot;no&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./vcpus/vcpu/[@id='3']&quot;).attrib.get(&quot;order&quot;), None
        )

        # test removing vcpus element
        vcpus_none = {&quot;vcpus&quot;: None}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=vcpus_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;vcpus&quot;), None)

        # test removing cpu attrbutes
        cpu_atr_none = {&quot;match&quot;: None, &quot;mode&quot;: None, &quot;check&quot;: None}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_atr_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).attrib, {})

        cpu_atr_mn = {&quot;match&quot;: None}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_atr_mn),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).attrib.get(&quot;match&quot;), None)
        self.assertEqual(setxml.find(&quot;cpu&quot;).attrib.get(&quot;mode&quot;), &quot;custom&quot;)
        self.assertEqual(setxml.find(&quot;cpu&quot;).attrib.get(&quot;check&quot;), &quot;full&quot;)

        # test update existing cpu model
        cpu_model_none = {&quot;model&quot;: None}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_model_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;model&quot;), None)

        cpu_model_atr_none = {
            &quot;model&quot;: {&quot;name&quot;: &quot;coresolo&quot;, &quot;fallback&quot;: &quot;forbid&quot;, &quot;vendor_id&quot;: None}
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_model_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;model&quot;).attrib.get(&quot;vendor_id&quot;), None)
        self.assertEqual(
            setxml.find(&quot;cpu&quot;).find(&quot;model&quot;).attrib.get(&quot;fallback&quot;), &quot;forbid&quot;
        )
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;model&quot;).text, &quot;coresolo&quot;)

        cpu_model_atr = {
            &quot;model&quot;: {
                &quot;name&quot;: &quot;coresolo&quot;,
                &quot;fallback&quot;: &quot;forbid&quot;,
                &quot;vendor_id&quot;: &quot;AuthenticAMD&quot;,
            }
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_model_atr),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;cpu&quot;).find(&quot;model&quot;).attrib.get(&quot;fallback&quot;), &quot;forbid&quot;
        )
        self.assertEqual(
            setxml.find(&quot;cpu&quot;).find(&quot;model&quot;).attrib.get(&quot;vendor_id&quot;), &quot;AuthenticAMD&quot;
        )
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;model&quot;).text, &quot;coresolo&quot;)

        # test update existing cpu vendor
        cpu_vendor = {&quot;vendor&quot;: &quot;AMD&quot;}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_vendor),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;vendor&quot;).text, &quot;AMD&quot;)

        cpu_vendor_none = {&quot;vendor&quot;: None}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_vendor_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;vendor&quot;), None)

        # test update exisiting cpu topology
        cpu_topology = {&quot;topology&quot;: {&quot;sockets&quot;: 1, &quot;cores&quot;: 12, &quot;threads&quot;: 1}}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_topology),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;topology&quot;).attrib.get(&quot;sockets&quot;), &quot;1&quot;)
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;topology&quot;).attrib.get(&quot;cores&quot;), &quot;12&quot;)
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;topology&quot;).attrib.get(&quot;threads&quot;), &quot;1&quot;)

        cpu_topology_atr_none = {
            &quot;topology&quot;: {&quot;sockets&quot;: None, &quot;cores&quot;: 12, &quot;threads&quot;: 1}
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_topology_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;cpu&quot;).find(&quot;topology&quot;).attrib.get(&quot;sockets&quot;), None
        )
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;topology&quot;).attrib.get(&quot;cores&quot;), &quot;12&quot;)
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;topology&quot;).attrib.get(&quot;threads&quot;), &quot;1&quot;)

        cpu_topology_none = {&quot;topology&quot;: None}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_topology_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;topology&quot;), None)

        # test update existing cache
        cpu_cache = {&quot;cache&quot;: {&quot;mode&quot;: &quot;passthrough&quot;, &quot;level&quot;: 2}}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_cache),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;cache&quot;).attrib.get(&quot;level&quot;), &quot;2&quot;)
        self.assertEqual(
            setxml.find(&quot;cpu&quot;).find(&quot;cache&quot;).attrib.get(&quot;mode&quot;), &quot;passthrough&quot;
        )

        cpu_cache_atr_none = {&quot;cache&quot;: {&quot;mode&quot;: &quot;passthrough&quot;, &quot;level&quot;: None}}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_cache_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;cache&quot;).attrib.get(&quot;level&quot;), None)
        self.assertEqual(
            setxml.find(&quot;cpu&quot;).find(&quot;cache&quot;).attrib.get(&quot;mode&quot;), &quot;passthrough&quot;
        )

        cpu_cache_none = {&quot;cache&quot;: None}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_cache_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cpu&quot;).find(&quot;cache&quot;), None)

        # test update existing feature
        cpu_feature = {&quot;features&quot;: {&quot;lahf_lm&quot;: &quot;require&quot;, &quot;pcid&quot;: &quot;optional&quot;}}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_feature),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;./cpu/feature[@name='pcid']&quot;).attrib.get(&quot;policy&quot;), &quot;optional&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/feature[@name='lahf_lm']&quot;).attrib.get(&quot;policy&quot;),
            &quot;require&quot;,
        )

        cpu_feature_atr_none = {&quot;features&quot;: {&quot;pcid&quot;: &quot;optional&quot;, &quot;lahf_lm&quot;: &quot;disable&quot;}}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_feature_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;./cpu/feature[@name='lahf_lm']&quot;).attrib.get(&quot;policy&quot;),
            &quot;disable&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/feature[@name='pcid']&quot;).attrib.get(&quot;policy&quot;), &quot;optional&quot;
        )

        cpu_feature_none = {&quot;features&quot;: {&quot;lahf_lm&quot;: None, &quot;pcid&quot;: None}}
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=cpu_feature_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;./cpu/feature&quot;), None)

        # test update existing numa cell
        numa_cell = {
            &quot;numa&quot;: {
                0: {
                    &quot;cpus&quot;: &quot;0-6&quot;,
                    &quot;memory&quot;: &quot;512m&quot;,
                    &quot;discard&quot;: True,
                    &quot;distances&quot;: {0: 15, 1: 16, 2: 17, 3: 18},
                },
                1: {
                    &quot;cpus&quot;: &quot;7-12&quot;,
                    &quot;memory&quot;: &quot;2g&quot;,
                    &quot;discard&quot;: True,
                    &quot;memAccess&quot;: &quot;shared&quot;,
                    &quot;distances&quot;: {0: 23, 1: 24, 2: 25, 3: 26},
                },
            }
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=numa_cell),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']&quot;).attrib[&quot;cpus&quot;],
            &quot;,&quot;.join([str(i) for i in range(0, 7)]),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']&quot;).attrib[&quot;memory&quot;],
            str(512 * 1024 ** 2),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']&quot;).get(&quot;unit&quot;),
            &quot;bytes&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']&quot;).attrib[&quot;discard&quot;], &quot;yes&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;15&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;16&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;17&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;18&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;cpus&quot;],
            &quot;,&quot;.join([str(i) for i in range(7, 13)]),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;memory&quot;],
            str(int(2 * 1024 ** 3)),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).get(&quot;unit&quot;),
            &quot;bytes&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;discard&quot;], &quot;yes&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;memAccess&quot;], &quot;shared&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;23&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;24&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;25&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;26&quot;,
        )

        numa_cell_atr_none = {
            &quot;numa&quot;: {
                &quot;0&quot;: {
                    &quot;cpus&quot;: &quot;0-6&quot;,
                    &quot;memory&quot;: &quot;512m&quot;,
                    &quot;discard&quot;: False,
                    &quot;distances&quot;: {0: 15, 2: 17, 3: 18},
                },
                &quot;1&quot;: {
                    &quot;cpus&quot;: &quot;7-12&quot;,
                    &quot;memory&quot;: &quot;2g&quot;,
                    &quot;discard&quot;: True,
                    &quot;distances&quot;: {0: 23, 1: 24, 2: 25},
                },
            }
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_existing_param&quot;, cpu=numa_cell_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']&quot;).attrib[&quot;cpus&quot;],
            &quot;,&quot;.join([str(i) for i in range(0, 7)]),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']&quot;).attrib[&quot;memory&quot;],
            str(512 * 1024 ** 2),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']&quot;).get(&quot;unit&quot;),
            &quot;bytes&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']&quot;).attrib.get(&quot;discard&quot;), &quot;no&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;15&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']&quot;), None
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;17&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;18&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;cpus&quot;],
            &quot;,&quot;.join([str(i) for i in range(7, 13)]),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;memory&quot;],
            str(int(2 * 1024 ** 3)),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;discard&quot;], &quot;yes&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;23&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;24&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;25&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']&quot;), None
        )

        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;cpus&quot;],
            &quot;,&quot;.join([str(i) for i in range(7, 13)]),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;memory&quot;],
            str(int(1024 ** 3 * 2)),
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']&quot;).attrib[&quot;discard&quot;], &quot;yes&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;23&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;24&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']&quot;).attrib[
                &quot;value&quot;
            ],
            &quot;25&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']&quot;),
            None,
        )

    def test_update_memtune_params(self):
        &quot;&quot;&quot;
        Test virt.update() with memory tuning parameters.
        &quot;&quot;&quot;
        xml_with_memtune_params = &quot;&quot;&quot;
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_boot_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;maxMemory slots=&quot;12&quot; unit=&quot;bytes&quot;&gt;1048576&lt;/maxMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;memtune&gt;
                &lt;hard_limit unit=&quot;KiB&quot;&gt;1048576&lt;/hard_limit&gt;
                &lt;soft_limit unit=&quot;KiB&quot;&gt;2097152&lt;/soft_limit&gt;
                &lt;swap_hard_limit unit=&quot;KiB&quot;&gt;2621440&lt;/swap_hard_limit&gt;
                &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
              &lt;/memtune&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        domain_mock = self.set_mock_vm(&quot;vm_with_memtune_param&quot;, xml_with_memtune_params)
        domain_mock.OSType = MagicMock(return_value=&quot;hvm&quot;)
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        memtune_new_val = {
            &quot;boot&quot;: &quot;0.7g&quot;,
            &quot;current&quot;: &quot;2.5g&quot;,
            &quot;max&quot;: &quot;3096m&quot;,
            &quot;slots&quot;: &quot;10&quot;,
            &quot;soft_limit&quot;: &quot;2048m&quot;,
            &quot;hard_limit&quot;: &quot;1024&quot;,
            &quot;swap_hard_limit&quot;: &quot;2.5g&quot;,
            &quot;min_guarantee&quot;: &quot;1 g&quot;,
        }

        domain_mock.setMemoryFlags.return_value = 0
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
                &quot;mem&quot;: True,
            },
            virt.update(&quot;vm_with_memtune_param&quot;, mem=memtune_new_val),
        )
        self.assertEqual(
            domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;soft_limit&quot;).text, str(2048 * 1024)
        )
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;hard_limit&quot;).text, str(1024 * 1024)
        )
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;swap_hard_limit&quot;).text,
            str(int(2.5 * 1024 ** 2)),
        )
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;swap_hard_limit&quot;).get(&quot;unit&quot;),
            &quot;KiB&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;min_guarantee&quot;).text, str(1 * 1024 ** 3)
        )
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;min_guarantee&quot;).attrib.get(&quot;unit&quot;), &quot;bytes&quot;
        )
        self.assertEqual(setxml.find(&quot;maxMemory&quot;).text, str(3096 * 1024 ** 2))
        self.assertEqual(setxml.find(&quot;maxMemory&quot;).attrib.get(&quot;slots&quot;), &quot;10&quot;)
        self.assertEqual(setxml.find(&quot;currentMemory&quot;).text, str(int(2.5 * 1024 ** 3)))
        self.assertEqual(setxml.find(&quot;memory&quot;).text, str(int(0.7 * 1024 ** 3)))

        max_slot_reverse = {
            &quot;slots&quot;: &quot;10&quot;,
            &quot;max&quot;: &quot;3096m&quot;,
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_memtune_param&quot;, mem=max_slot_reverse),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;maxMemory&quot;).text, str(3096 * 1024 ** 2))
        self.assertEqual(setxml.find(&quot;maxMemory&quot;).get(&quot;unit&quot;), &quot;bytes&quot;)
        self.assertEqual(setxml.find(&quot;maxMemory&quot;).attrib.get(&quot;slots&quot;), &quot;10&quot;)

        max_swap_none = {
            &quot;boot&quot;: &quot;0.7g&quot;,
            &quot;current&quot;: &quot;2.5g&quot;,
            &quot;max&quot;: None,
            &quot;slots&quot;: &quot;10&quot;,
            &quot;soft_limit&quot;: &quot;2048m&quot;,
            &quot;hard_limit&quot;: &quot;1024&quot;,
            &quot;swap_hard_limit&quot;: None,
            &quot;min_guarantee&quot;: &quot;1 g&quot;,
        }

        domain_mock.setMemoryFlags.reset_mock()
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
                &quot;mem&quot;: True,
            },
            virt.update(&quot;vm_with_memtune_param&quot;, mem=max_swap_none),
        )
        self.assertEqual(
            domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;soft_limit&quot;).text, str(2048 * 1024)
        )
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;hard_limit&quot;).text, str(1024 * 1024)
        )
        self.assertEqual(setxml.find(&quot;memtune&quot;).find(&quot;swap_hard_limit&quot;), None)
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;min_guarantee&quot;).text, str(1 * 1024 ** 3)
        )
        self.assertEqual(
            setxml.find(&quot;memtune&quot;).find(&quot;min_guarantee&quot;).attrib.get(&quot;unit&quot;), &quot;bytes&quot;
        )
        self.assertEqual(setxml.find(&quot;maxMemory&quot;).text, None)
        self.assertEqual(setxml.find(&quot;currentMemory&quot;).text, str(int(2.5 * 1024 ** 3)))
        self.assertEqual(setxml.find(&quot;memory&quot;).text, str(int(0.7 * 1024 ** 3)))

        memtune_none = {
            &quot;soft_limit&quot;: None,
            &quot;hard_limit&quot;: None,
            &quot;swap_hard_limit&quot;: None,
            &quot;min_guarantee&quot;: None,
        }

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_memtune_param&quot;, mem=memtune_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;memtune&quot;).find(&quot;soft_limit&quot;), None)
        self.assertEqual(setxml.find(&quot;memtune&quot;).find(&quot;hard_limit&quot;), None)
        self.assertEqual(setxml.find(&quot;memtune&quot;).find(&quot;swap_hard_limit&quot;), None)
        self.assertEqual(setxml.find(&quot;memtune&quot;).find(&quot;min_guarantee&quot;), None)

        max_none = {
            &quot;max&quot;: None,
        }

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_memtune_param&quot;, mem=max_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;maxMemory&quot;), None)
        self.assertEqual(setxml.find(&quot;currentMemory&quot;).text, str(int(1 * 1024 ** 2)))
        self.assertEqual(setxml.find(&quot;memory&quot;).text, str(int(1 * 1024 ** 2)))

    def test_update_exist_memorybacking_params(self):
        &quot;&quot;&quot;
        Test virt.update() with memory backing parameters.
        &quot;&quot;&quot;
        xml_with_memback_params = &quot;&quot;&quot;
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_memback_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;maxMemory slots=&quot;12&quot; unit=&quot;KiB&quot;&gt;1048576&lt;/maxMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;memoryBacking&gt;
                &lt;hugepages&gt;
                  &lt;page size=&quot;2048&quot; unit=&quot;KiB&quot;/&gt;
                  &lt;page size=&quot;3145728&quot; nodeset=&quot;1-4,^3&quot; unit=&quot;KiB&quot;/&gt;
                  &lt;page size=&quot;1048576&quot; nodeset=&quot;3&quot; unit=&quot;KiB&quot;/&gt;
                &lt;/hugepages&gt;
                &lt;nosharepages/&gt;
                &lt;locked/&gt;
                &lt;source type=&quot;file&quot;/&gt;
                &lt;access mode=&quot;shared&quot;/&gt;
                &lt;discard/&gt;
              &lt;/memoryBacking&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        domain_mock = self.set_mock_vm(&quot;vm_with_memback_param&quot;, xml_with_memback_params)
        domain_mock.OSType = MagicMock(return_value=&quot;hvm&quot;)
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        # update memory backing case
        mem_back_param = {
            &quot;hugepages&quot;: [
                {&quot;nodeset&quot;: &quot;1-4,^3&quot;, &quot;size&quot;: &quot;1g&quot;},
                {&quot;nodeset&quot;: &quot;3&quot;, &quot;size&quot;: &quot;2g&quot;},
            ],
            &quot;nosharepages&quot;: None,
            &quot;locked&quot;: None,
            &quot;source&quot;: &quot;anonymous&quot;,
            &quot;access&quot;: &quot;private&quot;,
            &quot;allocation&quot;: &quot;ondemand&quot;,
            &quot;discard&quot;: None,
        }

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_memback_param&quot;, mem=mem_back_param),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertDictEqual(
            {
                p.get(&quot;nodeset&quot;): {&quot;size&quot;: p.get(&quot;size&quot;), &quot;unit&quot;: p.get(&quot;unit&quot;)}
                for p in setxml.findall(&quot;memoryBacking/hugepages/page&quot;)
            },
            {
                &quot;1,2,4&quot;: {&quot;size&quot;: str(1024 ** 3), &quot;unit&quot;: &quot;bytes&quot;},
                &quot;3&quot;: {&quot;size&quot;: str(2 * 1024 ** 3), &quot;unit&quot;: &quot;bytes&quot;},
            },
        )
        self.assertEqual(setxml.find(&quot;./memoryBacking/nosharepages&quot;), None)
        self.assertEqual(setxml.find(&quot;./memoryBacking/locked&quot;), None)
        self.assertEqual(
            setxml.find(&quot;./memoryBacking/source&quot;).attrib[&quot;type&quot;], &quot;anonymous&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./memoryBacking/access&quot;).attrib[&quot;mode&quot;], &quot;private&quot;
        )
        self.assertEqual(
            setxml.find(&quot;./memoryBacking/allocation&quot;).attrib[&quot;mode&quot;], &quot;ondemand&quot;
        )
        self.assertEqual(setxml.find(&quot;./memoryBacking/discard&quot;), None)

        unchanged_page = {
            &quot;hugepages&quot;: [
                {&quot;size&quot;: &quot;2m&quot;},
                {&quot;nodeset&quot;: &quot;1-4,^3&quot;, &quot;size&quot;: &quot;3g&quot;},
                {&quot;nodeset&quot;: &quot;3&quot;, &quot;size&quot;: &quot;1g&quot;},
            ],
        }

        self.assertEqual(
            {
                &quot;definition&quot;: False,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;vm_with_memback_param&quot;, mem=unchanged_page),
        )

    def test_update_iothreads_params(self):
        &quot;&quot;&quot;
        Test virt.update() with iothreads parameters.
        &quot;&quot;&quot;
        xml_with_iothreads_params = &quot;&quot;&quot;
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;maxMemory slots=&quot;12&quot; unit=&quot;KiB&quot;&gt;1048576&lt;/maxMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;iothreads&gt;6&lt;/iothreads&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        domain_mock = self.set_mock_vm(
            &quot;xml_with_iothreads_params&quot;, xml_with_iothreads_params
        )
        domain_mock.OSType = MagicMock(return_value=&quot;hvm&quot;)
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        # test updating existing iothreads
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;xml_with_iothreads_params&quot;, cpu={&quot;iothreads&quot;: 7}),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;iothreads&quot;).text, &quot;7&quot;)

    def test_update_cputune_paramters(self):
        &quot;&quot;&quot;
        Test virt.update() with cputune parameters.
        &quot;&quot;&quot;
        xml_with_cputune_params = &quot;&quot;&quot;
                    &lt;domain type='kvm' id='8'&gt;
                      &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
                      &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
                      &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
                      &lt;maxMemory slots=&quot;12&quot; unit=&quot;KiB&quot;&gt;1048576&lt;/maxMemory&gt;
                      &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
                      &lt;iothreads&gt;4&lt;/iothreads&gt;
                      &lt;cputune&gt;
                        &lt;shares&gt;2048&lt;/shares&gt;
                        &lt;period&gt;1000000&lt;/period&gt;
                        &lt;quota&gt;-1&lt;/quota&gt;
                        &lt;global_period&gt;1000000&lt;/global_period&gt;
                        &lt;global_quota&gt;-1&lt;/global_quota&gt;
                        &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
                        &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
                        &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
                        &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
                        &lt;vcpupin vcpu=&quot;0&quot; cpuset=&quot;0-2&quot;/&gt;
                        &lt;vcpupin vcpu=&quot;1&quot; cpuset=&quot;3&quot;/&gt;
                        &lt;vcpupin vcpu=&quot;2&quot; cpuset=&quot;4&quot;/&gt;
                        &lt;vcpupin vcpu=&quot;3&quot; cpuset=&quot;5-7&quot;/&gt;
                        &lt;emulatorpin cpuset=&quot;1-2&quot;/&gt;
                        &lt;iothreadpin iothread=&quot;1&quot; cpuset=&quot;1-5&quot;/&gt;
                        &lt;iothreadpin iothread=&quot;2&quot; cpuset=&quot;6-7&quot;/&gt;
                        &lt;vcpusched vcpus=&quot;0&quot; scheduler=&quot;idle&quot; priority=&quot;3&quot;/&gt;
                        &lt;vcpusched vcpus=&quot;1&quot; scheduler=&quot;rr&quot; priority=&quot;1&quot;/&gt;
                        &lt;vcpusched vcpus=&quot;2&quot; scheduler=&quot;fifo&quot; priority=&quot;2&quot;/&gt;
                        &lt;iothreadsched iothreads=&quot;4&quot; scheduler=&quot;fifo&quot;/&gt;
                        &lt;emulatorsched scheduler=&quot;idle&quot;/&gt;
                        &lt;cachetune vcpus=&quot;0-4&quot;&gt;
                          &lt;cache id=&quot;0&quot; level=&quot;2&quot; type=&quot;both&quot; size=&quot;4&quot; unit=&quot;KiB&quot;/&gt;
                          &lt;cache id=&quot;1&quot; level=&quot;2&quot; type=&quot;both&quot; size=&quot;4&quot; unit=&quot;KiB&quot;/&gt;
                          &lt;monitor level=&quot;5&quot; vcpus=&quot;0-2&quot;/&gt;
                          &lt;monitor level=&quot;6&quot; vcpus=&quot;1-3&quot;/&gt;
                        &lt;/cachetune&gt;
                        &lt;cachetune vcpus=&quot;5-8&quot;&gt;
                          &lt;monitor level=&quot;5&quot; vcpus=&quot;5-6&quot;/&gt;
                          &lt;monitor level=&quot;3&quot; vcpus=&quot;7-8&quot;/&gt;
                        &lt;/cachetune&gt;
                        &lt;memorytune vcpus=&quot;0-6&quot;&gt;
                          &lt;node id=&quot;0&quot; bandwidth=&quot;45&quot;/&gt;
                        &lt;/memorytune&gt;
                        &lt;memorytune vcpus=&quot;7-8&quot;&gt;
                          &lt;node id=&quot;0&quot; bandwidth=&quot;120&quot;/&gt;
                        &lt;/memorytune&gt;
                      &lt;/cputune&gt;
                      &lt;os&gt;
                        &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
                      &lt;/os&gt;
                    &lt;/domain&gt;
                &quot;&quot;&quot;
        domain_mock = self.set_mock_vm(
            &quot;xml_with_cputune_params&quot;, xml_with_cputune_params
        )
        domain_mock.OSType = MagicMock(return_value=&quot;hvm&quot;)
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        # test updating existing cputune parameters
        cputune = {
            &quot;shares&quot;: 1024,
            &quot;period&quot;: 5000,
            &quot;quota&quot;: -20,
            &quot;global_period&quot;: 4000,
            &quot;global_quota&quot;: -30,
            &quot;emulator_period&quot;: 3000,
            &quot;emulator_quota&quot;: -4,
            &quot;iothread_period&quot;: 7000,
            &quot;iothread_quota&quot;: -5,
            &quot;vcpupin&quot;: {0: &quot;1-4,^2&quot;, 1: &quot;0,1&quot;, 2: &quot;2,3&quot;, 3: &quot;0,4&quot;},
            &quot;emulatorpin&quot;: &quot;1-3&quot;,
            &quot;iothreadpin&quot;: {1: &quot;5-6&quot;, 2: &quot;7-8&quot;},
            &quot;vcpusched&quot;: [
                {&quot;scheduler&quot;: &quot;fifo&quot;, &quot;priority&quot;: 1, &quot;vcpus&quot;: &quot;0&quot;},
                {&quot;scheduler&quot;: &quot;fifo&quot;, &quot;priority&quot;: 2, &quot;vcpus&quot;: &quot;1&quot;},
                {&quot;scheduler&quot;: &quot;idle&quot;, &quot;priority&quot;: 3, &quot;vcpus&quot;: &quot;2&quot;},
            ],
            &quot;iothreadsched&quot;: [
                {&quot;scheduler&quot;: &quot;batch&quot;, &quot;iothreads&quot;: &quot;5-7&quot;, &quot;priority&quot;: 1}
            ],
            &quot;emulatorsched&quot;: {&quot;scheduler&quot;: &quot;rr&quot;, &quot;priority&quot;: 2},
            &quot;cachetune&quot;: {
                &quot;0-3&quot;: {
                    0: {&quot;level&quot;: 3, &quot;type&quot;: &quot;both&quot;, &quot;size&quot;: 3},
                    1: {&quot;level&quot;: 3, &quot;type&quot;: &quot;both&quot;, &quot;size&quot;: 3},
                    &quot;monitor&quot;: {1: 3, &quot;0-3&quot;: 3},
                },
                &quot;4-5&quot;: {&quot;monitor&quot;: {4: 3, 5: 2}},
            },
            &quot;memorytune&quot;: {&quot;0-2&quot;: {0: 60}, &quot;3-4&quot;: {0: 50, 1: 70}},
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;xml_with_cputune_params&quot;, cpu={&quot;tuning&quot;: cputune}),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;shares&quot;).text, &quot;1024&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;period&quot;).text, &quot;5000&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;quota&quot;).text, &quot;-20&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;global_period&quot;).text, &quot;4000&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;global_quota&quot;).text, &quot;-30&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;emulator_period&quot;).text, &quot;3000&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;emulator_quota&quot;).text, &quot;-4&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;iothread_period&quot;).text, &quot;7000&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;iothread_quota&quot;).text, &quot;-5&quot;)
        self.assertEqual(
            setxml.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='0']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;1,3,4&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='1']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;0,1&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='2']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;2,3&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='3']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;0,4&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;cputune&quot;).find(&quot;emulatorpin&quot;).attrib.get(&quot;cpuset&quot;), &quot;1,2,3&quot;
        )
        self.assertEqual(
            setxml.find(&quot;cputune&quot;)
            .find(&quot;iothreadpin[@iothread='1']&quot;)
            .attrib.get(&quot;cpuset&quot;),
            &quot;5,6&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;cputune&quot;)
            .find(&quot;iothreadpin[@iothread='2']&quot;)
            .attrib.get(&quot;cpuset&quot;),
            &quot;7,8&quot;,
        )
        self.assertDictEqual(
            {
                s.get(&quot;vcpus&quot;): {
                    &quot;scheduler&quot;: s.get(&quot;scheduler&quot;),
                    &quot;priority&quot;: s.get(&quot;priority&quot;),
                }
                for s in setxml.findall(&quot;cputune/vcpusched&quot;)
            },
            {
                &quot;0&quot;: {&quot;scheduler&quot;: &quot;fifo&quot;, &quot;priority&quot;: &quot;1&quot;},
                &quot;1&quot;: {&quot;scheduler&quot;: &quot;fifo&quot;, &quot;priority&quot;: &quot;2&quot;},
                &quot;2&quot;: {&quot;scheduler&quot;: &quot;idle&quot;, &quot;priority&quot;: &quot;3&quot;},
            },
        )
        self.assertDictEqual(
            {
                s.get(&quot;iothreads&quot;): {
                    &quot;scheduler&quot;: s.get(&quot;scheduler&quot;),
                    &quot;priority&quot;: s.get(&quot;priority&quot;),
                }
                for s in setxml.findall(&quot;cputune/iothreadsched&quot;)
            },
            {&quot;5,6,7&quot;: {&quot;scheduler&quot;: &quot;batch&quot;, &quot;priority&quot;: &quot;1&quot;}},
        )
        self.assertEqual(setxml.find(&quot;cputune/emulatorsched&quot;).get(&quot;scheduler&quot;), &quot;rr&quot;)
        self.assertEqual(setxml.find(&quot;cputune/emulatorsched&quot;).get(&quot;priority&quot;), &quot;2&quot;)
        self.assertIsNotNone(setxml.find(&quot;./cputune/cachetune[@vcpus='0,1,2,3']&quot;))
        self.assertEqual(
            setxml.find(
                &quot;./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']&quot;
            ).attrib.get(&quot;level&quot;),
            &quot;3&quot;,
        )
        self.assertEqual(
            setxml.find(
                &quot;./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']&quot;
            ).attrib.get(&quot;type&quot;),
            &quot;both&quot;,
        )
        self.assertEqual(
            setxml.find(
                &quot;./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']&quot;
            ).attrib.get(&quot;level&quot;),
            &quot;3&quot;,
        )
        self.assertNotEqual(
            setxml.find(&quot;./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']&quot;),
            None,
        )
        self.assertNotEqual(
            setxml.find(&quot;./cputune/cachetune[@vcpus='4,5']&quot;).attrib.get(&quot;vcpus&quot;), None
        )
        self.assertEqual(
            setxml.find(&quot;./cputune/cachetune[@vcpus='4,5']/cache[@id='0']&quot;), None
        )
        self.assertEqual(
            setxml.find(
                &quot;./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']&quot;
            ).attrib.get(&quot;level&quot;),
            &quot;3&quot;,
        )
        self.assertEqual(
            setxml.find(
                &quot;./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']&quot;
            ).attrib.get(&quot;level&quot;),
            &quot;2&quot;,
        )
        self.assertNotEqual(setxml.find(&quot;./cputune/memorytune[@vcpus='0,1,2']&quot;), None)
        self.assertEqual(
            setxml.find(
                &quot;./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']&quot;
            ).attrib.get(&quot;bandwidth&quot;),
            &quot;60&quot;,
        )
        self.assertNotEqual(setxml.find(&quot;./cputune/memorytune[@vcpus='3,4']&quot;), None)
        self.assertEqual(
            setxml.find(&quot;./cputune/memorytune[@vcpus='3,4']/node[@id='0']&quot;).attrib.get(
                &quot;bandwidth&quot;
            ),
            &quot;50&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cputune/memorytune[@vcpus='3,4']/node[@id='1']&quot;).attrib.get(
                &quot;bandwidth&quot;
            ),
            &quot;70&quot;,
        )

        # test removing cputune attributes and sub elements
        cputune = {
            &quot;shares&quot;: None,
            &quot;period&quot;: 20000,
            &quot;quota&quot;: None,
            &quot;global_period&quot;: 5000,
            &quot;global_quota&quot;: None,
            &quot;emulator_period&quot;: 2000,
            &quot;emulator_quota&quot;: -4,
            &quot;iothread_period&quot;: None,
            &quot;iothread_quota&quot;: -5,
            &quot;vcpupin&quot;: {0: &quot;1-4,^2&quot;, 2: &quot;2,4&quot;},
            &quot;emulatorpin&quot;: None,
            &quot;iothreadpin&quot;: {1: &quot;5-6&quot;},
            &quot;vcpusched&quot;: [{&quot;scheduler&quot;: &quot;idle&quot;, &quot;priority&quot;: 5, &quot;vcpus&quot;: &quot;1&quot;}],
            &quot;iothreadsched&quot;: None,
            &quot;cachetune&quot;: {
                &quot;0-3&quot;: {
                    0: {&quot;level&quot;: 4, &quot;type&quot;: &quot;data&quot;, &quot;size&quot;: 7},
                    &quot;monitor&quot;: {&quot;1-2&quot;: 11},
                },
            },
            &quot;memorytune&quot;: {&quot;3-4&quot;: {0: 37, 1: 73}},
        }
        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;xml_with_cputune_params&quot;, cpu={&quot;tuning&quot;: cputune}),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;shares&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;period&quot;).text, &quot;20000&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;quota&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;global_period&quot;).text, &quot;5000&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;global_quota&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;emulator_period&quot;).text, &quot;2000&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;emulator_quota&quot;).text, &quot;-4&quot;)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;iothread_period&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;iothread_quota&quot;).text, &quot;-5&quot;)
        self.assertEqual(
            setxml.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='0']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;1,3,4&quot;,
        )
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='1']&quot;), None)
        self.assertEqual(
            setxml.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='2']&quot;).attrib.get(&quot;cpuset&quot;),
            &quot;2,4&quot;,
        )
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;vcpupin[@vcpu='3']&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;emulatorpin&quot;), None)
        self.assertEqual(
            setxml.find(&quot;cputune&quot;)
            .find(&quot;iothreadpin[@iothread='1']&quot;)
            .attrib.get(&quot;cpuset&quot;),
            &quot;5,6&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;cputune&quot;).find(&quot;iothreadpin[@iothread='2']&quot;), None
        )
        self.assertDictEqual(
            {
                s.get(&quot;vcpus&quot;): {
                    &quot;scheduler&quot;: s.get(&quot;scheduler&quot;),
                    &quot;priority&quot;: s.get(&quot;priority&quot;),
                }
                for s in setxml.findall(&quot;cputune/vcpusched&quot;)
            },
            {&quot;1&quot;: {&quot;scheduler&quot;: &quot;idle&quot;, &quot;priority&quot;: &quot;5&quot;}},
        )
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;iothreadsched&quot;), None)
        self.assertIsNotNone(setxml.find(&quot;./cputune/cachetune[@vcpus='0,1,2,3']&quot;))
        self.assertEqual(
            setxml.find(
                &quot;./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']&quot;
            ).attrib.get(&quot;size&quot;),
            &quot;7&quot;,
        )
        self.assertEqual(
            setxml.find(
                &quot;./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']&quot;
            ).attrib.get(&quot;level&quot;),
            &quot;4&quot;,
        )
        self.assertEqual(
            setxml.find(
                &quot;./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']&quot;
            ).attrib.get(&quot;type&quot;),
            &quot;data&quot;,
        )
        self.assertEqual(
            setxml.find(
                &quot;./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']&quot;
            ).attrib.get(&quot;level&quot;),
            &quot;11&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']&quot;),
            None,
        )
        self.assertEqual(
            setxml.find(&quot;./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']&quot;), None
        )
        self.assertEqual(setxml.find(&quot;./cputune/cachetune[@vcpus='4,5']&quot;), None)
        self.assertEqual(setxml.find(&quot;./cputune/memorytune[@vcpus='0,1,2']&quot;), None)
        self.assertEqual(
            setxml.find(&quot;./cputune/memorytune[@vcpus='3,4']/node[@id='0']&quot;).attrib.get(
                &quot;bandwidth&quot;
            ),
            &quot;37&quot;,
        )
        self.assertEqual(
            setxml.find(&quot;./cputune/memorytune[@vcpus='3,4']/node[@id='1']&quot;).attrib.get(
                &quot;bandwidth&quot;
            ),
            &quot;73&quot;,
        )

        cputune_subelement = {
            &quot;vcpupin&quot;: None,
            &quot;iothreadpin&quot;: None,
            &quot;vcpusched&quot;: None,
            &quot;iothreadsched&quot;: None,
            &quot;cachetune&quot;: None,
            &quot;memorytune&quot;: None,
        }

        self.assertEqual(
            {
                &quot;definition&quot;: True,
                &quot;disk&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: [], &quot;updated&quot;: []},
                &quot;interface&quot;: {&quot;attached&quot;: [], &quot;detached&quot;: []},
            },
            virt.update(&quot;xml_with_cputune_params&quot;, cpu={&quot;tuning&quot;: cputune_subelement}),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;vcpupin&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;iothreadpin&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;vcpusched&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;iothreadsched&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;cachetune&quot;), None)
        self.assertEqual(setxml.find(&quot;cputune&quot;).find(&quot;memorytune&quot;), None)

    def test_handle_unit(self):
        &quot;&quot;&quot;
        Test regex function for handling units
        &quot;&quot;&quot;
        valid_case = [
            (&quot;2&quot;, 2097152),
            (&quot;42&quot;, 44040192),
            (&quot;5b&quot;, 5),
            (&quot;2.3Kib&quot;, 2355),
            (&quot;5.8Kb&quot;, 5800),
            (&quot;16MiB&quot;, 16777216),
            (&quot;20 GB&quot;, 20000000000),
            (&quot;16KB&quot;, 16000),
            (&quot;.5k&quot;, 512),
            (&quot;2.k&quot;, 2048),
        ]

        for key, val in valid_case:
            self.assertEqual(virt._handle_unit(key), val)

        invalid_case = [
            (&quot;9ib&quot;, &quot;invalid units&quot;),
            (&quot;8byte&quot;, &quot;invalid units&quot;),
            (&quot;512bytes&quot;, &quot;invalid units&quot;),
            (&quot;4 Kbytes&quot;, &quot;invalid units&quot;),
            (&quot;3.4.MB&quot;, &quot;invalid number&quot;),
            (&quot;&quot;, &quot;invalid number&quot;),
            (&quot;bytes&quot;, &quot;invalid number&quot;),
            (&quot;2HB&quot;, &quot;invalid units&quot;),
        ]

        for key, val in invalid_case:
            with self.assertRaises(SaltInvocationError):
                virt._handle_unit(key)

    def test_mixed_dict_and_list_as_profile_objects(self):
        &quot;&quot;&quot;
        Test virt._nic_profile with mixed dictionaries and lists as input.
        &quot;&quot;&quot;
        yaml_config = &quot;&quot;&quot;
          virt:
             nic:
                new-listonly-profile:
                   - bridge: br0
                     name: eth0
                   - model: virtio
                     name: eth1
                     source: test_network
                     type: network
                new-list-with-legacy-names:
                   - eth0:
                        bridge: br0
                   - eth1:
                        bridge: br1
                        model: virtio
                non-default-legacy-profile:
                   eth0:
                      bridge: br0
                   eth1:
                      bridge: br1
                      model: virtio
        &quot;&quot;&quot;
        mock_config = salt.utils.yaml.safe_load(yaml_config)
        with patch.dict(
            salt.modules.config.__opts__, mock_config  # pylint: disable=no-member
        ):

            for name in mock_config[&quot;virt&quot;][&quot;nic&quot;].keys():
                profile = salt.modules.virt._nic_profile(name, &quot;kvm&quot;)
                self.assertEqual(len(profile), 2)

                interface_attrs = profile[0]
                self.assertIn(&quot;source&quot;, interface_attrs)
                self.assertIn(&quot;type&quot;, interface_attrs)
                self.assertIn(&quot;name&quot;, interface_attrs)
                self.assertIn(&quot;model&quot;, interface_attrs)
                self.assertEqual(interface_attrs[&quot;model&quot;], &quot;virtio&quot;)

    def test_get_xml(self):
        &quot;&quot;&quot;
        Test virt.get_xml()
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
                  &lt;listen type='address' address='0.0.0.0'/&gt;
                &lt;/graphics&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        domain = self.set_mock_vm(&quot;test-vm&quot;, xml)
        self.assertEqual(xml, virt.get_xml(&quot;test-vm&quot;))
        self.assertEqual(xml, virt.get_xml(domain))

    def test_get_loader(self):
        &quot;&quot;&quot;
        Test virt.get_loader()
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;os&gt;
                &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        self.set_mock_vm(&quot;test-vm&quot;, xml)

        loader = virt.get_loader(&quot;test-vm&quot;)
        self.assertEqual(&quot;/foo/bar&quot;, loader[&quot;path&quot;])
        self.assertEqual(&quot;yes&quot;, loader[&quot;readonly&quot;])

    def test_cpu_baseline(self):
        &quot;&quot;&quot;
        Test virt.cpu_baseline()
        &quot;&quot;&quot;
        capabilities_xml = dedent(
            &quot;&quot;&quot;&lt;capabilities&gt;
                  &lt;host&gt;
                    &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
                    &lt;cpu&gt;
                      &lt;arch&gt;x86_64&lt;/arch&gt;
                      &lt;vendor&gt;Intel&lt;/vendor&gt;
                    &lt;/cpu&gt;
                  &lt;/host&gt;
                &lt;/capabilities&gt;&quot;&quot;&quot;
        )

        baseline_cpu_xml = b&quot;&quot;&quot;&lt;cpu match=&quot;exact&quot; mode=&quot;custom&quot;&gt;
                                  &lt;vendor&gt;Intel&lt;/vendor&gt;
                                &lt;/cpu&gt;&quot;&quot;&quot;

        self.mock_conn.getCapabilities.return_value = capabilities_xml
        self.mock_conn.baselineCPU.return_value = baseline_cpu_xml
        self.assertMultiLineEqual(str(baseline_cpu_xml), str(virt.cpu_baseline()))

    def test_parse_qemu_img_info(self):
        &quot;&quot;&quot;
        Make sure that qemu-img info output is properly parsed
        &quot;&quot;&quot;
        qemu_infos = &quot;&quot;&quot;[{
            &quot;snapshots&quot;: [
                {
                    &quot;vm-clock-nsec&quot;: 0,
                    &quot;name&quot;: &quot;first-snap&quot;,
                    &quot;date-sec&quot;: 1528877587,
                    &quot;date-nsec&quot;: 380589000,
                    &quot;vm-clock-sec&quot;: 0,
                    &quot;id&quot;: &quot;1&quot;,
                    &quot;vm-state-size&quot;: 1234
                },
                {
                    &quot;vm-clock-nsec&quot;: 0,
                    &quot;name&quot;: &quot;second snap&quot;,
                    &quot;date-sec&quot;: 1528877592,
                    &quot;date-nsec&quot;: 933509000,
                    &quot;vm-clock-sec&quot;: 0,
                    &quot;id&quot;: &quot;2&quot;,
                    &quot;vm-state-size&quot;: 4567
                }
            ],
            &quot;virtual-size&quot;: 25769803776,
            &quot;filename&quot;: &quot;/disks/test.qcow2&quot;,
            &quot;cluster-size&quot;: 65536,
            &quot;format&quot;: &quot;qcow2&quot;,
            &quot;actual-size&quot;: 217088,
            &quot;format-specific&quot;: {
                &quot;type&quot;: &quot;qcow2&quot;,
                &quot;data&quot;: {
                    &quot;compat&quot;: &quot;1.1&quot;,
                    &quot;lazy-refcounts&quot;: false,
                    &quot;refcount-bits&quot;: 16,
                    &quot;corrupt&quot;: false
                }
            },
            &quot;full-backing-filename&quot;: &quot;/disks/mybacking.qcow2&quot;,
            &quot;backing-filename&quot;: &quot;mybacking.qcow2&quot;,
            &quot;dirty-flag&quot;: false
        },
        {
            &quot;virtual-size&quot;: 25769803776,
            &quot;filename&quot;: &quot;/disks/mybacking.qcow2&quot;,
            &quot;cluster-size&quot;: 65536,
            &quot;format&quot;: &quot;qcow2&quot;,
            &quot;actual-size&quot;: 393744384,
            &quot;format-specific&quot;: {
                &quot;type&quot;: &quot;qcow2&quot;,
                &quot;data&quot;: {
                    &quot;compat&quot;: &quot;1.1&quot;,
                    &quot;lazy-refcounts&quot;: false,
                    &quot;refcount-bits&quot;: 16,
                    &quot;corrupt&quot;: false
                }
            },
            &quot;full-backing-filename&quot;: &quot;/disks/root.qcow2&quot;,
            &quot;backing-filename&quot;: &quot;root.qcow2&quot;,
            &quot;dirty-flag&quot;: false
        },
        {
            &quot;virtual-size&quot;: 25769803776,
            &quot;filename&quot;: &quot;/disks/root.qcow2&quot;,
            &quot;cluster-size&quot;: 65536,
            &quot;format&quot;: &quot;qcow2&quot;,
            &quot;actual-size&quot;: 196872192,
            &quot;format-specific&quot;: {
                &quot;type&quot;: &quot;qcow2&quot;,
                &quot;data&quot;: {
                    &quot;compat&quot;: &quot;1.1&quot;,
                    &quot;lazy-refcounts&quot;: false,
                    &quot;refcount-bits&quot;: 16,
                    &quot;corrupt&quot;: false
                }
            },
            &quot;dirty-flag&quot;: false
        }]&quot;&quot;&quot;

        self.assertEqual(
            {
                &quot;file&quot;: &quot;/disks/test.qcow2&quot;,
                &quot;file format&quot;: &quot;qcow2&quot;,
                &quot;backing file&quot;: {
                    &quot;file&quot;: &quot;/disks/mybacking.qcow2&quot;,
                    &quot;file format&quot;: &quot;qcow2&quot;,
                    &quot;disk size&quot;: 393744384,
                    &quot;virtual size&quot;: 25769803776,
                    &quot;cluster size&quot;: 65536,
                    &quot;backing file&quot;: {
                        &quot;file&quot;: &quot;/disks/root.qcow2&quot;,
                        &quot;file format&quot;: &quot;qcow2&quot;,
                        &quot;disk size&quot;: 196872192,
                        &quot;virtual size&quot;: 25769803776,
                        &quot;cluster size&quot;: 65536,
                    },
                },
                &quot;disk size&quot;: 217088,
                &quot;virtual size&quot;: 25769803776,
                &quot;cluster size&quot;: 65536,
                &quot;snapshots&quot;: [
                    {
                        &quot;id&quot;: &quot;1&quot;,
                        &quot;tag&quot;: &quot;first-snap&quot;,
                        &quot;vmsize&quot;: 1234,
                        &quot;date&quot;: datetime.datetime.fromtimestamp(
                            float(&quot;{}.{}&quot;.format(1528877587, 380589000))
                        ).isoformat(),
                        &quot;vmclock&quot;: &quot;00:00:00&quot;,
                    },
                    {
                        &quot;id&quot;: &quot;2&quot;,
                        &quot;tag&quot;: &quot;second snap&quot;,
                        &quot;vmsize&quot;: 4567,
                        &quot;date&quot;: datetime.datetime.fromtimestamp(
                            float(&quot;{}.{}&quot;.format(1528877592, 933509000))
                        ).isoformat(),
                        &quot;vmclock&quot;: &quot;00:00:00&quot;,
                    },
                ],
            },
            virt._parse_qemu_img_info(qemu_infos),
        )

    @patch(&quot;salt.modules.virt.stop&quot;, return_value=True)
    @patch(&quot;salt.modules.virt.undefine&quot;)
    @patch(&quot;os.remove&quot;)
    def test_purge_default(self, mock_remove, mock_undefine, mock_stop):
        &quot;&quot;&quot;
        Test virt.purge() with default parameters
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;disk type='file' device='disk'&gt;
                &lt;driver name='qemu' type='qcow2'/&gt;
                &lt;source file='/disks/test.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;driver name='qemu' type='raw'/&gt;
                &lt;source file='/disks/test-cdrom.iso'/&gt;
                &lt;target dev='hda' bus='ide'/&gt;
                &lt;readonly/&gt;
              &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        self.set_mock_vm(&quot;test-vm&quot;, xml)

        qemu_infos = &quot;&quot;&quot;[{
            &quot;virtual-size&quot;: 25769803776,
            &quot;filename&quot;: &quot;/disks/test.qcow2&quot;,
            &quot;cluster-size&quot;: 65536,
            &quot;format&quot;: &quot;qcow2&quot;,
            &quot;actual-size&quot;: 217088,
            &quot;format-specific&quot;: {
                &quot;type&quot;: &quot;qcow2&quot;,
                &quot;data&quot;: {
                    &quot;compat&quot;: &quot;1.1&quot;,
                    &quot;lazy-refcounts&quot;: false,
                    &quot;refcount-bits&quot;: 16,
                    &quot;corrupt&quot;: false
                }
            },
            &quot;dirty-flag&quot;: false
        }]&quot;&quot;&quot;

        self.mock_popen.communicate.return_value = [qemu_infos, &quot;&quot;]
        self.mock_popen.returncode = 0

        with patch.dict(os.path.__dict__, {&quot;exists&quot;: MagicMock(return_value=True)}):
            res = virt.purge(&quot;test-vm&quot;)
            self.assertTrue(res)
            mock_remove.assert_called_once()
            mock_remove.assert_any_call(&quot;/disks/test.qcow2&quot;)

    @patch(&quot;salt.modules.virt.stop&quot;, return_value=True)
    @patch(&quot;salt.modules.virt.undefine&quot;)
    def test_purge_volumes(self, mock_undefine, mock_stop):
        &quot;&quot;&quot;
        Test virt.purge() with volume disks
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;disk type='volume' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
                  &lt;source pool='default' volume='vm05_system'/&gt;
                  &lt;backingStore type='file' index='1'&gt;
                    &lt;format type='qcow2'/&gt;
                    &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
                    &lt;backingStore type='file' index='2'&gt;
                      &lt;format type='qcow2'/&gt;
                      &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
                      &lt;backingStore/&gt;
                    &lt;/backingStore&gt;
                  &lt;/backingStore&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                  &lt;alias name='virtio-disk0'/&gt;
                  &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
                &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        self.set_mock_vm(&quot;test-vm&quot;, xml)

        pool_mock = MagicMock()
        pool_mock.storageVolLookupByName.return_value.info.return_value = [
            0,
            1234567,
            12345,
        ]
        pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
            &quot;&quot;&quot;
            &lt;volume type='file'&gt;
              &lt;name&gt;vm05_system&lt;/name&gt;
              &lt;target&gt;
                &lt;path&gt;/var/lib/libvirt/images/vm05_system&lt;/path&gt;
                &lt;format type='qcow2'/&gt;
              &lt;/target&gt;
              &lt;backingStore&gt;
                &lt;path&gt;/var/lib/libvirt/images/vm04_system.qcow2&lt;/path&gt;
                &lt;format type='qcow2'/&gt;
              &lt;/backingStore&gt;
            &lt;/volume&gt;
            &quot;&quot;&quot;,
        ]
        pool_mock.listVolumes.return_value = [&quot;vm05_system&quot;, &quot;vm04_system.qcow2&quot;]
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock
        self.mock_conn.listStoragePools.return_value = [&quot;default&quot;]

        with patch.dict(os.path.__dict__, {&quot;exists&quot;: MagicMock(return_value=False)}):
            res = virt.purge(&quot;test-vm&quot;)
            self.assertTrue(res)
            pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()

    @patch(&quot;salt.modules.virt.stop&quot;, return_value=True)
    @patch(&quot;salt.modules.virt.undefine&quot;)
    def test_purge_rbd(self, mock_undefine, mock_stop):
        &quot;&quot;&quot;
        Test virt.purge() with RBD disks
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;disk type=&quot;network&quot; device=&quot;disk&quot;&gt;
                  &lt;driver name='raw' type='qcow2'/&gt;
                  &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
                    &lt;host name='ses2.tf.local'/&gt;
                    &lt;host name='ses3.tf.local' port='1234'/&gt;
                    &lt;auth username='libvirt'&gt;
                      &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
                    &lt;/auth&gt;
                  &lt;/source&gt;
                  &lt;target dev='vdc' bus='virtio'/&gt;
                  &lt;alias name='virtio-disk2'/&gt;
                  &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
                &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        self.set_mock_vm(&quot;test-vm&quot;, xml)

        pool_mock = MagicMock()
        pool_mock.storageVolLookupByName.return_value.info.return_value = [
            0,
            1234567,
            12345,
        ]
        pool_mock.XMLDesc.return_value = &quot;&quot;&quot;
        &lt;pool type='rbd'&gt;
          &lt;name&gt;test-ses&lt;/name&gt;
          &lt;source&gt;
            &lt;host name='ses2.tf.local'/&gt;
            &lt;name&gt;libvirt-pool&lt;/name&gt;
            &lt;auth type='ceph' username='libvirt'&gt;
              &lt;secret usage='pool_test-ses'/&gt;
            &lt;/auth&gt;
          &lt;/source&gt;
        &lt;/pool&gt;
        &quot;&quot;&quot;
        pool_mock.name.return_value = &quot;test-ses&quot;
        pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
            &quot;&quot;&quot;
            &lt;volume type='network'&gt;
              &lt;name&gt;my_vm_data2&lt;/name&gt;
              &lt;source&gt;
              &lt;/source&gt;
              &lt;capacity unit='bytes'&gt;536870912&lt;/capacity&gt;
              &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
              &lt;target&gt;
                &lt;path&gt;libvirt-pool/my_vm_data2&lt;/path&gt;
                &lt;format type='raw'/&gt;
              &lt;/target&gt;
            &lt;/volume&gt;
            &quot;&quot;&quot;,
        ]
        pool_mock.listVolumes.return_value = [&quot;my_vm_data2&quot;]
        self.mock_conn.listAllStoragePools.return_value = [pool_mock]
        self.mock_conn.listStoragePools.return_value = [&quot;test-ses&quot;]
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        with patch.dict(os.path.__dict__, {&quot;exists&quot;: MagicMock(return_value=False)}):
            res = virt.purge(&quot;test-vm&quot;)
            self.assertTrue(res)
            pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()

    @patch(&quot;salt.modules.virt.stop&quot;, return_value=True)
    @patch(&quot;salt.modules.virt.undefine&quot;)
    @patch(&quot;os.remove&quot;)
    def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
        &quot;&quot;&quot;
        Test virt.purge(removables=True)
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;&lt;domain type=&quot;kvm&quot; id=&quot;7&quot;&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;disk type='file' device='disk'&gt;
                &lt;driver name='qemu' type='qcow2'/&gt;
                &lt;source file='/disks/test.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;driver name='qemu' type='raw'/&gt;
                &lt;source file='/disks/test-cdrom.iso'/&gt;
                &lt;target dev='hda' bus='ide'/&gt;
                &lt;readonly/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='floppy'&gt;
                &lt;driver name='qemu' type='raw'/&gt;
                &lt;source file='/disks/test-floppy.iso'/&gt;
                &lt;target dev='hdb' bus='ide'/&gt;
                &lt;readonly/&gt;
              &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        self.set_mock_vm(&quot;test-vm&quot;, xml)

        qemu_infos = &quot;&quot;&quot;[{
            &quot;virtual-size&quot;: 25769803776,
            &quot;filename&quot;: &quot;/disks/test.qcow2&quot;,
            &quot;cluster-size&quot;: 65536,
            &quot;format&quot;: &quot;qcow2&quot;,
            &quot;actual-size&quot;: 217088,
            &quot;format-specific&quot;: {
                &quot;type&quot;: &quot;qcow2&quot;,
                &quot;data&quot;: {
                    &quot;compat&quot;: &quot;1.1&quot;,
                    &quot;lazy-refcounts&quot;: false,
                    &quot;refcount-bits&quot;: 16,
                    &quot;corrupt&quot;: false
                }
            },
            &quot;dirty-flag&quot;: false
        }]&quot;&quot;&quot;

        self.mock_popen.communicate.return_value = [qemu_infos, &quot;&quot;]
        self.mock_popen.returncode = 0

        with patch.dict(os.path.__dict__, {&quot;exists&quot;: MagicMock(return_value=True)}):
            res = virt.purge(&quot;test-vm&quot;, removables=True)
            self.assertTrue(res)
            mock_remove.assert_any_call(&quot;/disks/test.qcow2&quot;)
            mock_remove.assert_any_call(&quot;/disks/test-cdrom.iso&quot;)

    def test_capabilities(self):
        &quot;&quot;&quot;
        Test the virt.capabilities parsing
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;
&lt;capabilities&gt;
  &lt;host&gt;
    &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
    &lt;cpu&gt;
      &lt;arch&gt;x86_64&lt;/arch&gt;
      &lt;model&gt;Nehalem&lt;/model&gt;
      &lt;vendor&gt;Intel&lt;/vendor&gt;
      &lt;microcode version='25'/&gt;
      &lt;topology sockets='1' cores='4' threads='2'/&gt;
      &lt;feature name='vme'/&gt;
      &lt;feature name='ds'/&gt;
      &lt;feature name='acpi'/&gt;
      &lt;pages unit='KiB' size='4'/&gt;
      &lt;pages unit='KiB' size='2048'/&gt;
    &lt;/cpu&gt;
    &lt;power_management&gt;
      &lt;suspend_mem/&gt;
      &lt;suspend_disk/&gt;
      &lt;suspend_hybrid/&gt;
    &lt;/power_management&gt;
    &lt;migration_features&gt;
      &lt;live/&gt;
      &lt;uri_transports&gt;
        &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
        &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
      &lt;/uri_transports&gt;
    &lt;/migration_features&gt;
    &lt;topology&gt;
      &lt;cells num='1'&gt;
        &lt;cell id='0'&gt;
          &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
          &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
          &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
          &lt;distances&gt;
            &lt;sibling id='0' value='10'/&gt;
          &lt;/distances&gt;
          &lt;cpus num='8'&gt;
            &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
            &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
            &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
            &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
            &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
            &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
            &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
            &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
          &lt;/cpus&gt;
        &lt;/cell&gt;
      &lt;/cells&gt;
    &lt;/topology&gt;
    &lt;cache&gt;
      &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
    &lt;/cache&gt;
    &lt;secmodel&gt;
      &lt;model&gt;apparmor&lt;/model&gt;
      &lt;doi&gt;0&lt;/doi&gt;
    &lt;/secmodel&gt;
    &lt;secmodel&gt;
      &lt;model&gt;dac&lt;/model&gt;
      &lt;doi&gt;0&lt;/doi&gt;
      &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
      &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
    &lt;/secmodel&gt;
  &lt;/host&gt;

  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='i686'&gt;
      &lt;wordsize&gt;32&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
    &lt;features&gt;
      &lt;cpuselection/&gt;
      &lt;deviceboot/&gt;
      &lt;disksnapshot default='on' toggle='no'/&gt;
      &lt;acpi default='off' toggle='yes'/&gt;
      &lt;apic default='on' toggle='no'/&gt;
      &lt;pae/&gt;
      &lt;nonpae/&gt;
    &lt;/features&gt;
  &lt;/guest&gt;

  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='x86_64'&gt;
      &lt;wordsize&gt;64&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
    &lt;features&gt;
      &lt;cpuselection/&gt;
      &lt;deviceboot/&gt;
      &lt;disksnapshot default='on' toggle='no'/&gt;
      &lt;acpi default='on' toggle='yes'/&gt;
      &lt;apic default='off' toggle='no'/&gt;
    &lt;/features&gt;
  &lt;/guest&gt;

  &lt;guest&gt;
    &lt;os_type&gt;xen&lt;/os_type&gt;
    &lt;arch name='x86_64'&gt;
      &lt;wordsize&gt;64&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
      &lt;machine&gt;xenpv&lt;/machine&gt;
      &lt;domain type='xen'/&gt;
    &lt;/arch&gt;
  &lt;/guest&gt;

&lt;/capabilities&gt;
        &quot;&quot;&quot;
        self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
        caps = virt.capabilities()

        expected = {
            &quot;host&quot;: {
                &quot;uuid&quot;: &quot;44454c4c-3400-105a-8033-b3c04f4b344a&quot;,
                &quot;cpu&quot;: {
                    &quot;arch&quot;: &quot;x86_64&quot;,
                    &quot;model&quot;: &quot;Nehalem&quot;,
                    &quot;vendor&quot;: &quot;Intel&quot;,
                    &quot;microcode&quot;: &quot;25&quot;,
                    &quot;sockets&quot;: 1,
                    &quot;cores&quot;: 4,
                    &quot;threads&quot;: 2,
                    &quot;features&quot;: [&quot;vme&quot;, &quot;ds&quot;, &quot;acpi&quot;],
                    &quot;pages&quot;: [{&quot;size&quot;: &quot;4 KiB&quot;}, {&quot;size&quot;: &quot;2048 KiB&quot;}],
                },
                &quot;power_management&quot;: [&quot;suspend_mem&quot;, &quot;suspend_disk&quot;, &quot;suspend_hybrid&quot;],
                &quot;migration&quot;: {&quot;live&quot;: True, &quot;transports&quot;: [&quot;tcp&quot;, &quot;rdma&quot;]},
                &quot;topology&quot;: {
                    &quot;cells&quot;: [
                        {
                            &quot;id&quot;: 0,
                            &quot;memory&quot;: &quot;12367120 KiB&quot;,
                            &quot;pages&quot;: [
                                {&quot;size&quot;: &quot;4 KiB&quot;, &quot;available&quot;: 3091780},
                                {&quot;size&quot;: &quot;2048 KiB&quot;, &quot;available&quot;: 0},
                            ],
                            &quot;distances&quot;: {0: 10},
                            &quot;cpus&quot;: [
                                {
                                    &quot;id&quot;: 0,
                                    &quot;socket_id&quot;: 0,
                                    &quot;core_id&quot;: 0,
                                    &quot;siblings&quot;: &quot;0,4&quot;,
                                },
                                {
                                    &quot;id&quot;: 1,
                                    &quot;socket_id&quot;: 0,
                                    &quot;core_id&quot;: 1,
                                    &quot;siblings&quot;: &quot;1,5&quot;,
                                },
                                {
                                    &quot;id&quot;: 2,
                                    &quot;socket_id&quot;: 0,
                                    &quot;core_id&quot;: 2,
                                    &quot;siblings&quot;: &quot;2,6&quot;,
                                },
                                {
                                    &quot;id&quot;: 3,
                                    &quot;socket_id&quot;: 0,
                                    &quot;core_id&quot;: 3,
                                    &quot;siblings&quot;: &quot;3,7&quot;,
                                },
                                {
                                    &quot;id&quot;: 4,
                                    &quot;socket_id&quot;: 0,
                                    &quot;core_id&quot;: 0,
                                    &quot;siblings&quot;: &quot;0,4&quot;,
                                },
                                {
                                    &quot;id&quot;: 5,
                                    &quot;socket_id&quot;: 0,
                                    &quot;core_id&quot;: 1,
                                    &quot;siblings&quot;: &quot;1,5&quot;,
                                },
                                {
                                    &quot;id&quot;: 6,
                                    &quot;socket_id&quot;: 0,
                                    &quot;core_id&quot;: 2,
                                    &quot;siblings&quot;: &quot;2,6&quot;,
                                },
                                {
                                    &quot;id&quot;: 7,
                                    &quot;socket_id&quot;: 0,
                                    &quot;core_id&quot;: 3,
                                    &quot;siblings&quot;: &quot;3,7&quot;,
                                },
                            ],
                        }
                    ]
                },
                &quot;cache&quot;: {
                    &quot;banks&quot;: [
                        {
                            &quot;id&quot;: 0,
                            &quot;level&quot;: 3,
                            &quot;type&quot;: &quot;both&quot;,
                            &quot;size&quot;: &quot;8 MiB&quot;,
                            &quot;cpus&quot;: &quot;0-7&quot;,
                        }
                    ]
                },
                &quot;security&quot;: [
                    {&quot;model&quot;: &quot;apparmor&quot;, &quot;doi&quot;: &quot;0&quot;, &quot;baselabels&quot;: []},
                    {
                        &quot;model&quot;: &quot;dac&quot;,
                        &quot;doi&quot;: &quot;0&quot;,
                        &quot;baselabels&quot;: [
                            {&quot;type&quot;: &quot;kvm&quot;, &quot;label&quot;: &quot;+487:+486&quot;},
                            {&quot;type&quot;: &quot;qemu&quot;, &quot;label&quot;: &quot;+487:+486&quot;},
                        ],
                    },
                ],
            },
            &quot;guests&quot;: [
                {
                    &quot;os_type&quot;: &quot;hvm&quot;,
                    &quot;arch&quot;: {
                        &quot;name&quot;: &quot;i686&quot;,
                        &quot;wordsize&quot;: 32,
                        &quot;emulator&quot;: &quot;/usr/bin/qemu-system-i386&quot;,
                        &quot;machines&quot;: {
                            &quot;pc-i440fx-2.6&quot;: {
                                &quot;maxcpus&quot;: 255,
                                &quot;alternate_names&quot;: [&quot;pc&quot;],
                            },
                            &quot;pc-0.12&quot;: {&quot;maxcpus&quot;: 255, &quot;alternate_names&quot;: []},
                        },
                        &quot;domains&quot;: {
                            &quot;qemu&quot;: {&quot;emulator&quot;: None, &quot;machines&quot;: {}},
                            &quot;kvm&quot;: {
                                &quot;emulator&quot;: &quot;/usr/bin/qemu-kvm&quot;,
                                &quot;machines&quot;: {
                                    &quot;pc-i440fx-2.6&quot;: {
                                        &quot;maxcpus&quot;: 255,
                                        &quot;alternate_names&quot;: [&quot;pc&quot;],
                                    },
                                    &quot;pc-0.12&quot;: {&quot;maxcpus&quot;: 255, &quot;alternate_names&quot;: []},
                                },
                            },
                        },
                    },
                    &quot;features&quot;: {
                        &quot;cpuselection&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: False},
                        &quot;deviceboot&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: False},
                        &quot;disksnapshot&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: False},
                        &quot;acpi&quot;: {&quot;default&quot;: False, &quot;toggle&quot;: True},
                        &quot;apic&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: False},
                        &quot;pae&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: False},
                        &quot;nonpae&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: False},
                    },
                },
                {
                    &quot;os_type&quot;: &quot;hvm&quot;,
                    &quot;arch&quot;: {
                        &quot;name&quot;: &quot;x86_64&quot;,
                        &quot;wordsize&quot;: 64,
                        &quot;emulator&quot;: &quot;/usr/bin/qemu-system-x86_64&quot;,
                        &quot;machines&quot;: {
                            &quot;pc-i440fx-2.6&quot;: {
                                &quot;maxcpus&quot;: 255,
                                &quot;alternate_names&quot;: [&quot;pc&quot;],
                            },
                            &quot;pc-0.12&quot;: {&quot;maxcpus&quot;: 255, &quot;alternate_names&quot;: []},
                        },
                        &quot;domains&quot;: {
                            &quot;qemu&quot;: {&quot;emulator&quot;: None, &quot;machines&quot;: {}},
                            &quot;kvm&quot;: {
                                &quot;emulator&quot;: &quot;/usr/bin/qemu-kvm&quot;,
                                &quot;machines&quot;: {
                                    &quot;pc-i440fx-2.6&quot;: {
                                        &quot;maxcpus&quot;: 255,
                                        &quot;alternate_names&quot;: [&quot;pc&quot;],
                                    },
                                    &quot;pc-0.12&quot;: {&quot;maxcpus&quot;: 255, &quot;alternate_names&quot;: []},
                                },
                            },
                        },
                    },
                    &quot;features&quot;: {
                        &quot;cpuselection&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: False},
                        &quot;deviceboot&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: False},
                        &quot;disksnapshot&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: False},
                        &quot;acpi&quot;: {&quot;default&quot;: True, &quot;toggle&quot;: True},
                        &quot;apic&quot;: {&quot;default&quot;: False, &quot;toggle&quot;: False},
                    },
                },
                {
                    &quot;os_type&quot;: &quot;xen&quot;,
                    &quot;arch&quot;: {
                        &quot;name&quot;: &quot;x86_64&quot;,
                        &quot;wordsize&quot;: 64,
                        &quot;emulator&quot;: &quot;/usr/bin/qemu-system-x86_64&quot;,
                        &quot;machines&quot;: {&quot;xenpv&quot;: {&quot;alternate_names&quot;: []}},
                        &quot;domains&quot;: {&quot;xen&quot;: {&quot;emulator&quot;: None, &quot;machines&quot;: {}}},
                    },
                },
            ],
        }
        self.assertEqual(expected, caps)

    def test_domain_capabilities(self):
        &quot;&quot;&quot;
        Test the virt.domain_capabilities parsing
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;
&lt;domainCapabilities&gt;
  &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
  &lt;domain&gt;kvm&lt;/domain&gt;
  &lt;machine&gt;virt-2.12&lt;/machine&gt;
  &lt;arch&gt;aarch64&lt;/arch&gt;
  &lt;vcpu max='255'/&gt;
  &lt;iothreads supported='yes'/&gt;
  &lt;os supported='yes'&gt;
    &lt;loader supported='yes'&gt;
      &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
      &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
      &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
      &lt;enum name='type'&gt;
        &lt;value&gt;rom&lt;/value&gt;
        &lt;value&gt;pflash&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='readonly'&gt;
        &lt;value&gt;yes&lt;/value&gt;
        &lt;value&gt;no&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/loader&gt;
  &lt;/os&gt;
  &lt;cpu&gt;
    &lt;mode name='host-passthrough' supported='yes'/&gt;
    &lt;mode name='host-model' supported='yes'&gt;
      &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
      &lt;vendor&gt;ACME&lt;/vendor&gt;
      &lt;feature policy='require' name='vme'/&gt;
      &lt;feature policy='require' name='ss'/&gt;
    &lt;/mode&gt;
    &lt;mode name='custom' supported='yes'&gt;
      &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
      &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
      &lt;model usable='no'&gt;arm1136&lt;/model&gt;
    &lt;/mode&gt;
  &lt;/cpu&gt;
  &lt;devices&gt;
    &lt;disk supported='yes'&gt;
      &lt;enum name='diskDevice'&gt;
        &lt;value&gt;disk&lt;/value&gt;
        &lt;value&gt;cdrom&lt;/value&gt;
        &lt;value&gt;floppy&lt;/value&gt;
        &lt;value&gt;lun&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='bus'&gt;
        &lt;value&gt;fdc&lt;/value&gt;
        &lt;value&gt;scsi&lt;/value&gt;
        &lt;value&gt;virtio&lt;/value&gt;
        &lt;value&gt;usb&lt;/value&gt;
        &lt;value&gt;sata&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/disk&gt;
    &lt;graphics supported='yes'&gt;
      &lt;enum name='type'&gt;
        &lt;value&gt;sdl&lt;/value&gt;
        &lt;value&gt;vnc&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/graphics&gt;
    &lt;video supported='yes'&gt;
      &lt;enum name='modelType'&gt;
        &lt;value&gt;vga&lt;/value&gt;
        &lt;value&gt;virtio&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/video&gt;
    &lt;hostdev supported='yes'&gt;
      &lt;enum name='mode'&gt;
        &lt;value&gt;subsystem&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='startupPolicy'&gt;
        &lt;value&gt;default&lt;/value&gt;
        &lt;value&gt;mandatory&lt;/value&gt;
        &lt;value&gt;requisite&lt;/value&gt;
        &lt;value&gt;optional&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='subsysType'&gt;
        &lt;value&gt;usb&lt;/value&gt;
        &lt;value&gt;pci&lt;/value&gt;
        &lt;value&gt;scsi&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='capsType'/&gt;
      &lt;enum name='pciBackend'&gt;
        &lt;value&gt;default&lt;/value&gt;
        &lt;value&gt;kvm&lt;/value&gt;
        &lt;value&gt;vfio&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/hostdev&gt;
  &lt;/devices&gt;
  &lt;features&gt;
    &lt;gic supported='yes'&gt;
      &lt;enum name='version'&gt;
        &lt;value&gt;3&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/gic&gt;
    &lt;vmcoreinfo supported='yes'/&gt;
  &lt;/features&gt;
&lt;/domainCapabilities&gt;
        &quot;&quot;&quot;

        self.mock_conn.getDomainCapabilities.return_value = (
            xml  # pylint: disable=no-member
        )
        caps = virt.domain_capabilities()

        expected = {
            &quot;emulator&quot;: &quot;/usr/bin/qemu-system-aarch64&quot;,
            &quot;domain&quot;: &quot;kvm&quot;,
            &quot;machine&quot;: &quot;virt-2.12&quot;,
            &quot;arch&quot;: &quot;aarch64&quot;,
            &quot;max_vcpus&quot;: 255,
            &quot;iothreads&quot;: True,
            &quot;os&quot;: {
                &quot;loader&quot;: {
                    &quot;type&quot;: [&quot;rom&quot;, &quot;pflash&quot;],
                    &quot;readonly&quot;: [&quot;yes&quot;, &quot;no&quot;],
                    &quot;values&quot;: [
                        &quot;/usr/share/AAVMF/AAVMF_CODE.fd&quot;,
                        &quot;/usr/share/AAVMF/AAVMF32_CODE.fd&quot;,
                        &quot;/usr/share/OVMF/OVMF_CODE.fd&quot;,
                    ],
                }
            },
            &quot;cpu&quot;: {
                &quot;host-passthrough&quot;: True,
                &quot;host-model&quot;: {
                    &quot;model&quot;: {&quot;name&quot;: &quot;sample-cpu&quot;, &quot;fallback&quot;: &quot;forbid&quot;},
                    &quot;vendor&quot;: &quot;ACME&quot;,
                    &quot;features&quot;: {&quot;vme&quot;: &quot;require&quot;, &quot;ss&quot;: &quot;require&quot;},
                },
                &quot;custom&quot;: {
                    &quot;models&quot;: {&quot;pxa262&quot;: &quot;unknown&quot;, &quot;pxa270-a0&quot;: &quot;yes&quot;, &quot;arm1136&quot;: &quot;no&quot;}
                },
            },
            &quot;devices&quot;: {
                &quot;disk&quot;: {
                    &quot;diskDevice&quot;: [&quot;disk&quot;, &quot;cdrom&quot;, &quot;floppy&quot;, &quot;lun&quot;],
                    &quot;bus&quot;: [&quot;fdc&quot;, &quot;scsi&quot;, &quot;virtio&quot;, &quot;usb&quot;, &quot;sata&quot;],
                },
                &quot;graphics&quot;: {&quot;type&quot;: [&quot;sdl&quot;, &quot;vnc&quot;]},
                &quot;video&quot;: {&quot;modelType&quot;: [&quot;vga&quot;, &quot;virtio&quot;]},
                &quot;hostdev&quot;: {
                    &quot;mode&quot;: [&quot;subsystem&quot;],
                    &quot;startupPolicy&quot;: [&quot;default&quot;, &quot;mandatory&quot;, &quot;requisite&quot;, &quot;optional&quot;],
                    &quot;subsysType&quot;: [&quot;usb&quot;, &quot;pci&quot;, &quot;scsi&quot;],
                    &quot;capsType&quot;: [],
                    &quot;pciBackend&quot;: [&quot;default&quot;, &quot;kvm&quot;, &quot;vfio&quot;],
                },
            },
            &quot;features&quot;: {&quot;gic&quot;: {&quot;version&quot;: [&quot;3&quot;]}, &quot;vmcoreinfo&quot;: {}},
        }

        self.assertEqual(expected, caps)

    def test_all_capabilities(self):
        &quot;&quot;&quot;
        Test the virt.domain_capabilities default output
        &quot;&quot;&quot;
        domainXml = &quot;&quot;&quot;
&lt;domainCapabilities&gt;
  &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
  &lt;domain&gt;kvm&lt;/domain&gt;
  &lt;machine&gt;virt-2.12&lt;/machine&gt;
  &lt;arch&gt;x86_64&lt;/arch&gt;
  &lt;vcpu max='255'/&gt;
  &lt;iothreads supported='yes'/&gt;
&lt;/domainCapabilities&gt;
        &quot;&quot;&quot;
        hostXml = &quot;&quot;&quot;
&lt;capabilities&gt;
  &lt;host&gt;
    &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
    &lt;cpu&gt;
      &lt;arch&gt;x86_64&lt;/arch&gt;
      &lt;model&gt;Nehalem&lt;/model&gt;
      &lt;vendor&gt;Intel&lt;/vendor&gt;
      &lt;microcode version='25'/&gt;
      &lt;topology sockets='1' cores='4' threads='2'/&gt;
    &lt;/cpu&gt;
  &lt;/host&gt;
  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='x86_64'&gt;
      &lt;wordsize&gt;64&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
  &lt;/guest&gt;
&lt;/capabilities&gt;
        &quot;&quot;&quot;

        # pylint: disable=no-member
        self.mock_conn.getCapabilities.return_value = hostXml
        self.mock_conn.getDomainCapabilities.side_effect = [
            domainXml,
            domainXml.replace(&quot;&lt;domain&gt;kvm&quot;, &quot;&lt;domain&gt;qemu&quot;),
        ]
        # pylint: enable=no-member

        caps = virt.all_capabilities()
        self.assertEqual(
            &quot;44454c4c-3400-105a-8033-b3c04f4b344a&quot;, caps[&quot;host&quot;][&quot;host&quot;][&quot;uuid&quot;]
        )
        self.assertEqual(
            {&quot;qemu&quot;, &quot;kvm&quot;},
            {domainCaps[&quot;domain&quot;] for domainCaps in caps[&quot;domains&quot;]},
        )

        self.assertEqual(
            {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
            {
                (&quot;/usr/bin/qemu-system-x86_64&quot;, &quot;x86_64&quot;, None, &quot;kvm&quot;),
                (&quot;/usr/bin/qemu-system-x86_64&quot;, &quot;x86_64&quot;, None, &quot;qemu&quot;),
            },
        )

    def test_network_tag(self):
        &quot;&quot;&quot;
        Test virt._get_net_xml() with VLAN tag
        &quot;&quot;&quot;
        xml_data = virt._gen_net_xml(&quot;network&quot;, &quot;main&quot;, &quot;bridge&quot;, &quot;openvswitch&quot;, 1001)
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;name&quot;).text, &quot;network&quot;)
        self.assertEqual(root.find(&quot;bridge&quot;).attrib[&quot;name&quot;], &quot;main&quot;)
        self.assertEqual(root.find(&quot;forward&quot;).attrib[&quot;mode&quot;], &quot;bridge&quot;)
        self.assertEqual(root.find(&quot;virtualport&quot;).attrib[&quot;type&quot;], &quot;openvswitch&quot;)
        self.assertEqual(root.find(&quot;vlan/tag&quot;).attrib[&quot;id&quot;], &quot;1001&quot;)

    def test_list_networks(self):
        &quot;&quot;&quot;
        Test virt.list_networks()
        &quot;&quot;&quot;
        names = [&quot;net1&quot;, &quot;default&quot;, &quot;net2&quot;]
        net_mocks = [MagicMock(), MagicMock(), MagicMock()]
        for i, value in enumerate(names):
            net_mocks[i].name.return_value = value

        self.mock_conn.listAllNetworks.return_value = (
            net_mocks  # pylint: disable=no-member
        )
        actual = virt.list_networks()
        self.assertEqual(names, actual)

    def test_network_info(self):
        &quot;&quot;&quot;
        Test virt.network_info()
        &quot;&quot;&quot;
        self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
        self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1

        net_mock = MagicMock()

        # pylint: disable=no-member
        net_mock.name.return_value = &quot;foo&quot;
        net_mock.UUIDString.return_value = &quot;some-uuid&quot;
        net_mock.bridgeName.return_value = &quot;br0&quot;
        net_mock.autostart.return_value = True
        net_mock.isActive.return_value = False
        net_mock.isPersistent.return_value = True
        net_mock.DHCPLeases.return_value = [
            {
                &quot;iface&quot;: &quot;virbr0&quot;,
                &quot;expirytime&quot;: 1527757552,
                &quot;type&quot;: 0,
                &quot;mac&quot;: &quot;52:54:00:01:71:bd&quot;,
                &quot;ipaddr&quot;: &quot;192.168.122.45&quot;,
                &quot;prefix&quot;: 24,
                &quot;hostname&quot;: &quot;py3-test&quot;,
                &quot;clientid&quot;: &quot;01:52:54:00:01:71:bd&quot;,
                &quot;iaid&quot;: None,
            }
        ]
        self.mock_conn.listAllNetworks.return_value = [net_mock]
        # pylint: enable=no-member

        net = virt.network_info(&quot;foo&quot;)
        self.assertEqual(
            {
                &quot;foo&quot;: {
                    &quot;uuid&quot;: &quot;some-uuid&quot;,
                    &quot;bridge&quot;: &quot;br0&quot;,
                    &quot;autostart&quot;: True,
                    &quot;active&quot;: False,
                    &quot;persistent&quot;: True,
                    &quot;leases&quot;: [
                        {
                            &quot;iface&quot;: &quot;virbr0&quot;,
                            &quot;expirytime&quot;: 1527757552,
                            &quot;type&quot;: &quot;ipv4&quot;,
                            &quot;mac&quot;: &quot;52:54:00:01:71:bd&quot;,
                            &quot;ipaddr&quot;: &quot;192.168.122.45&quot;,
                            &quot;prefix&quot;: 24,
                            &quot;hostname&quot;: &quot;py3-test&quot;,
                            &quot;clientid&quot;: &quot;01:52:54:00:01:71:bd&quot;,
                            &quot;iaid&quot;: None,
                        }
                    ],
                }
            },
            net,
        )

    def test_network_info_all(self):
        &quot;&quot;&quot;
        Test virt.network_info()
        &quot;&quot;&quot;
        self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
        self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1

        net_mocks = []
        # pylint: disable=no-member
        for i in range(2):
            net_mock = MagicMock()

            net_mock.name.return_value = &quot;net{}&quot;.format(i)
            net_mock.UUIDString.return_value = &quot;some-uuid&quot;
            net_mock.bridgeName.return_value = &quot;br{}&quot;.format(i)
            net_mock.autostart.return_value = True
            net_mock.isActive.return_value = False
            net_mock.isPersistent.return_value = True
            net_mock.DHCPLeases.return_value = []
            net_mocks.append(net_mock)
        self.mock_conn.listAllNetworks.return_value = net_mocks
        # pylint: enable=no-member

        net = virt.network_info()
        self.assertEqual(
            {
                &quot;net0&quot;: {
                    &quot;uuid&quot;: &quot;some-uuid&quot;,
                    &quot;bridge&quot;: &quot;br0&quot;,
                    &quot;autostart&quot;: True,
                    &quot;active&quot;: False,
                    &quot;persistent&quot;: True,
                    &quot;leases&quot;: [],
                },
                &quot;net1&quot;: {
                    &quot;uuid&quot;: &quot;some-uuid&quot;,
                    &quot;bridge&quot;: &quot;br1&quot;,
                    &quot;autostart&quot;: True,
                    &quot;active&quot;: False,
                    &quot;persistent&quot;: True,
                    &quot;leases&quot;: [],
                },
            },
            net,
        )

    def test_network_info_notfound(self):
        &quot;&quot;&quot;
        Test virt.network_info() when the network can't be found
        &quot;&quot;&quot;
        # pylint: disable=no-member
        self.mock_conn.listAllNetworks.return_value = []
        # pylint: enable=no-member
        net = virt.network_info(&quot;foo&quot;)
        self.assertEqual({}, net)

    def test_network_get_xml(self):
        &quot;&quot;&quot;
        Test virt.network_get_xml
        &quot;&quot;&quot;
        network_mock = MagicMock()
        network_mock.XMLDesc.return_value = &quot;&lt;net&gt;Raw XML&lt;/net&gt;&quot;
        self.mock_conn.networkLookupByName.return_value = network_mock

        self.assertEqual(&quot;&lt;net&gt;Raw XML&lt;/net&gt;&quot;, virt.network_get_xml(&quot;default&quot;))

    def test_pool(self):
        &quot;&quot;&quot;
        Test virt._gen_pool_xml()
        &quot;&quot;&quot;
        xml_data = virt._gen_pool_xml(&quot;pool&quot;, &quot;logical&quot;, &quot;/dev/base&quot;)
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;name&quot;).text, &quot;pool&quot;)
        self.assertEqual(root.attrib[&quot;type&quot;], &quot;logical&quot;)
        self.assertEqual(root.find(&quot;target/path&quot;).text, &quot;/dev/base&quot;)

    def test_pool_with_source(self):
        &quot;&quot;&quot;
        Test virt._gen_pool_xml() with a source device
        &quot;&quot;&quot;
        xml_data = virt._gen_pool_xml(
            &quot;pool&quot;, &quot;logical&quot;, &quot;/dev/base&quot;, source_devices=[{&quot;path&quot;: &quot;/dev/sda&quot;}]
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;name&quot;).text, &quot;pool&quot;)
        self.assertEqual(root.attrib[&quot;type&quot;], &quot;logical&quot;)
        self.assertEqual(root.find(&quot;target/path&quot;).text, &quot;/dev/base&quot;)
        self.assertEqual(root.find(&quot;source/device&quot;).attrib[&quot;path&quot;], &quot;/dev/sda&quot;)

    def test_pool_with_scsi(self):
        &quot;&quot;&quot;
        Test virt._gen_pool_xml() with a SCSI source
        &quot;&quot;&quot;
        xml_data = virt._gen_pool_xml(
            &quot;pool&quot;,
            &quot;scsi&quot;,
            &quot;/dev/disk/by-path&quot;,
            source_devices=[{&quot;path&quot;: &quot;/dev/sda&quot;}],
            source_adapter={
                &quot;type&quot;: &quot;scsi_host&quot;,
                &quot;parent_address&quot;: {
                    &quot;unique_id&quot;: 5,
                    &quot;address&quot;: {
                        &quot;domain&quot;: &quot;0x0000&quot;,
                        &quot;bus&quot;: &quot;0x00&quot;,
                        &quot;slot&quot;: &quot;0x1f&quot;,
                        &quot;function&quot;: &quot;0x2&quot;,
                    },
                },
            },
            source_name=&quot;srcname&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;name&quot;).text, &quot;pool&quot;)
        self.assertEqual(root.attrib[&quot;type&quot;], &quot;scsi&quot;)
        self.assertEqual(root.find(&quot;target/path&quot;).text, &quot;/dev/disk/by-path&quot;)
        self.assertEqual(root.find(&quot;source/device&quot;), None)
        self.assertEqual(root.find(&quot;source/name&quot;), None)
        self.assertEqual(root.find(&quot;source/adapter&quot;).attrib[&quot;type&quot;], &quot;scsi_host&quot;)
        self.assertEqual(
            root.find(&quot;source/adapter/parentaddr&quot;).attrib[&quot;unique_id&quot;], &quot;5&quot;
        )
        self.assertEqual(
            root.find(&quot;source/adapter/parentaddr/address&quot;).attrib[&quot;domain&quot;], &quot;0x0000&quot;
        )
        self.assertEqual(
            root.find(&quot;source/adapter/parentaddr/address&quot;).attrib[&quot;bus&quot;], &quot;0x00&quot;
        )
        self.assertEqual(
            root.find(&quot;source/adapter/parentaddr/address&quot;).attrib[&quot;slot&quot;], &quot;0x1f&quot;
        )
        self.assertEqual(
            root.find(&quot;source/adapter/parentaddr/address&quot;).attrib[&quot;function&quot;], &quot;0x2&quot;
        )

    def test_pool_with_rbd(self):
        &quot;&quot;&quot;
        Test virt._gen_pool_xml() with an RBD source
        &quot;&quot;&quot;
        xml_data = virt._gen_pool_xml(
            &quot;pool&quot;,
            &quot;rbd&quot;,
            source_devices=[{&quot;path&quot;: &quot;/dev/sda&quot;}],
            source_hosts=[&quot;1.2.3.4&quot;, &quot;my.ceph.monitor:69&quot;],
            source_auth={
                &quot;type&quot;: &quot;ceph&quot;,
                &quot;username&quot;: &quot;admin&quot;,
                &quot;secret&quot;: {&quot;type&quot;: &quot;uuid&quot;, &quot;value&quot;: &quot;someuuid&quot;},
            },
            source_name=&quot;srcname&quot;,
            source_adapter={&quot;type&quot;: &quot;scsi_host&quot;, &quot;name&quot;: &quot;host0&quot;},
            source_dir=&quot;/some/dir&quot;,
            source_format=&quot;fmt&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;name&quot;).text, &quot;pool&quot;)
        self.assertEqual(root.attrib[&quot;type&quot;], &quot;rbd&quot;)
        self.assertEqual(root.find(&quot;target&quot;), None)
        self.assertEqual(root.find(&quot;source/device&quot;), None)
        self.assertEqual(root.find(&quot;source/name&quot;).text, &quot;srcname&quot;)
        self.assertEqual(root.find(&quot;source/adapter&quot;), None)
        self.assertEqual(root.find(&quot;source/dir&quot;), None)
        self.assertEqual(root.find(&quot;source/format&quot;), None)
        self.assertEqual(root.findall(&quot;source/host&quot;)[0].attrib[&quot;name&quot;], &quot;1.2.3.4&quot;)
        self.assertTrue(&quot;port&quot; not in root.findall(&quot;source/host&quot;)[0].attrib)
        self.assertEqual(
            root.findall(&quot;source/host&quot;)[1].attrib[&quot;name&quot;], &quot;my.ceph.monitor&quot;
        )
        self.assertEqual(root.findall(&quot;source/host&quot;)[1].attrib[&quot;port&quot;], &quot;69&quot;)
        self.assertEqual(root.find(&quot;source/auth&quot;).attrib[&quot;type&quot;], &quot;ceph&quot;)
        self.assertEqual(root.find(&quot;source/auth&quot;).attrib[&quot;username&quot;], &quot;admin&quot;)
        self.assertEqual(root.find(&quot;source/auth/secret&quot;).attrib[&quot;uuid&quot;], &quot;someuuid&quot;)

    def test_pool_with_netfs(self):
        &quot;&quot;&quot;
        Test virt._gen_pool_xml() with a netfs source
        &quot;&quot;&quot;
        xml_data = virt._gen_pool_xml(
            &quot;pool&quot;,
            &quot;netfs&quot;,
            target=&quot;/path/to/target&quot;,
            permissions={
                &quot;mode&quot;: &quot;0770&quot;,
                &quot;owner&quot;: 1000,
                &quot;group&quot;: 100,
                &quot;label&quot;: &quot;seclabel&quot;,
            },
            source_devices=[{&quot;path&quot;: &quot;/dev/sda&quot;}],
            source_hosts=[&quot;nfs.host&quot;],
            source_name=&quot;srcname&quot;,
            source_adapter={&quot;type&quot;: &quot;scsi_host&quot;, &quot;name&quot;: &quot;host0&quot;},
            source_dir=&quot;/some/dir&quot;,
            source_format=&quot;nfs&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;name&quot;).text, &quot;pool&quot;)
        self.assertEqual(root.attrib[&quot;type&quot;], &quot;netfs&quot;)
        self.assertEqual(root.find(&quot;target/path&quot;).text, &quot;/path/to/target&quot;)
        self.assertEqual(root.find(&quot;target/permissions/mode&quot;).text, &quot;0770&quot;)
        self.assertEqual(root.find(&quot;target/permissions/owner&quot;).text, &quot;1000&quot;)
        self.assertEqual(root.find(&quot;target/permissions/group&quot;).text, &quot;100&quot;)
        self.assertEqual(root.find(&quot;target/permissions/label&quot;).text, &quot;seclabel&quot;)
        self.assertEqual(root.find(&quot;source/device&quot;), None)
        self.assertEqual(root.find(&quot;source/name&quot;), None)
        self.assertEqual(root.find(&quot;source/adapter&quot;), None)
        self.assertEqual(root.find(&quot;source/dir&quot;).attrib[&quot;path&quot;], &quot;/some/dir&quot;)
        self.assertEqual(root.find(&quot;source/format&quot;).attrib[&quot;type&quot;], &quot;nfs&quot;)
        self.assertEqual(root.find(&quot;source/host&quot;).attrib[&quot;name&quot;], &quot;nfs.host&quot;)
        self.assertEqual(root.find(&quot;source/auth&quot;), None)

    def test_pool_with_iscsi_direct(self):
        &quot;&quot;&quot;
        Test virt._gen_pool_xml() with a iscsi-direct source
        &quot;&quot;&quot;
        xml_data = virt._gen_pool_xml(
            &quot;pool&quot;,
            &quot;iscsi-direct&quot;,
            source_hosts=[&quot;iscsi.example.com&quot;],
            source_devices=[{&quot;path&quot;: &quot;iqn.2013-06.com.example:iscsi-pool&quot;}],
            source_initiator=&quot;iqn.2013-06.com.example:iscsi-initiator&quot;,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find(&quot;name&quot;).text, &quot;pool&quot;)
        self.assertEqual(root.attrib[&quot;type&quot;], &quot;iscsi-direct&quot;)
        self.assertEqual(root.find(&quot;target&quot;), None)
        self.assertEqual(
            root.find(&quot;source/device&quot;).attrib[&quot;path&quot;],
            &quot;iqn.2013-06.com.example:iscsi-pool&quot;,
        )
        self.assertEqual(
            root.findall(&quot;source/host&quot;)[0].attrib[&quot;name&quot;], &quot;iscsi.example.com&quot;
        )
        self.assertEqual(
            root.find(&quot;source/initiator/iqn&quot;).attrib[&quot;name&quot;],
            &quot;iqn.2013-06.com.example:iscsi-initiator&quot;,
        )

    def test_pool_define(self):
        &quot;&quot;&quot;
        Test virt.pool_define()
        &quot;&quot;&quot;
        mock_pool = MagicMock()
        mock_secret = MagicMock()
        mock_secret_define = MagicMock(return_value=mock_secret)
        self.mock_conn.secretDefineXML = mock_secret_define
        self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)

        mocks = [
            mock_pool,
            mock_secret,
            mock_secret_define,
            self.mock_conn.storagePoolCreateXML,
            self.mock_conn.secretDefineXML,
            self.mock_conn.storagePoolDefineXML,
        ]

        # Test case with already defined secret and permanent pool
        self.assertTrue(
            virt.pool_define(
                &quot;default&quot;,
                &quot;rbd&quot;,
                source_hosts=[&quot;one.example.com&quot;, &quot;two.example.com&quot;],
                source_name=&quot;rbdvol&quot;,
                source_auth={
                    &quot;type&quot;: &quot;ceph&quot;,
                    &quot;username&quot;: &quot;admin&quot;,
                    &quot;secret&quot;: {&quot;type&quot;: &quot;uuid&quot;, &quot;value&quot;: &quot;someuuid&quot;},
                },
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_called_once()
        self.mock_conn.storagePoolCreateXML.assert_not_called()
        mock_pool.create.assert_called_once()
        mock_secret_define.assert_not_called()

        # Test case with Ceph secret to be defined and transient pool
        for mock in mocks:
            mock.reset_mock()
        self.assertTrue(
            virt.pool_define(
                &quot;default&quot;,
                &quot;rbd&quot;,
                transient=True,
                source_hosts=[&quot;one.example.com&quot;, &quot;two.example.com&quot;],
                source_name=&quot;rbdvol&quot;,
                source_auth={&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;c2VjcmV0&quot;},
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_not_called()

        pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
        root = ET.fromstring(pool_xml)
        self.assertEqual(root.find(&quot;source/auth&quot;).attrib[&quot;type&quot;], &quot;ceph&quot;)
        self.assertEqual(root.find(&quot;source/auth&quot;).attrib[&quot;username&quot;], &quot;admin&quot;)
        self.assertEqual(
            root.find(&quot;source/auth/secret&quot;).attrib[&quot;usage&quot;], &quot;pool_default&quot;
        )
        mock_pool.create.assert_not_called()
        mock_secret.setValue.assert_called_once_with(b&quot;secret&quot;)
<A NAME="1"></A>
        secret_xml = mock_secret_define.call_args[0][0]
        root = ET.fromstring(secret_xml)
        self.assertEqual(root.find(&quot;usage/name&quot;)<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#1',2,'match118032-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.text, &quot;pool_default&quot;)
        self.assertEqual(root.find(&quot;usage&quot;).attrib[&quot;type&quot;], &quot;ceph&quot;)
        self.assertEqual(root.attrib[&quot;private&quot;], &quot;yes&quot;)
        self.assertEqual(
            root.find(&quot;description&quot;).</B></FONT>text, &quot;Passphrase for default pool created by Salt&quot;
        )

        # Test case with iscsi secret not starting
        for mock in mocks:
            mock.reset_mock()
        self.assertTrue(
            virt.pool_define(
                &quot;default&quot;,
                &quot;iscsi&quot;,
                target=&quot;/dev/disk/by-path&quot;,
                source_hosts=[&quot;iscsi.example.com&quot;],
                source_devices=[{&quot;path&quot;: &quot;iqn.2013-06.com.example:iscsi-pool&quot;}],
                source_auth={&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;secret&quot;},
                start=False,
            )
        )
        self.mock_conn.storagePoolCreateXML.assert_not_called()

        pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
        root = ET.fromstring(pool_xml)
        self.assertEqual(root.find(&quot;source/auth&quot;).attrib[&quot;type&quot;], &quot;chap&quot;)
        self.assertEqual(root.find(&quot;source/auth&quot;).attrib[&quot;username&quot;], &quot;admin&quot;)
        self.assertEqual(
            root.find(&quot;source/auth/secret&quot;).attrib[&quot;usage&quot;], &quot;pool_default&quot;
        )
        mock_pool.create.assert_not_called()
        mock_secret.setValue.assert_called_once_with(&quot;secret&quot;)

        secret_xml = mock_secret_define.call_args[0][0]
        root = ET.fromstring(secret_xml)
        self.assertEqual(root.find(&quot;usage/target&quot;).text, &quot;pool_default&quot;)
        self.assertEqual(root.find(&quot;usage&quot;).attrib[&quot;type&quot;], &quot;iscsi&quot;)
        self.assertEqual(root.attrib[&quot;private&quot;], &quot;yes&quot;)
        self.assertEqual(
            root.find(&quot;description&quot;).text, &quot;Passphrase for default pool created by Salt&quot;
        )

    def test_list_pools(self):
        &quot;&quot;&quot;
        Test virt.list_pools()
        &quot;&quot;&quot;
        names = [&quot;pool1&quot;, &quot;default&quot;, &quot;pool2&quot;]
        pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
        for i, value in enumerate(names):
            pool_mocks[i].name.return_value = value

        self.mock_conn.listAllStoragePools.return_value = (
            pool_mocks  # pylint: disable=no-member
        )
        actual = virt.list_pools()
        self.assertEqual(names, actual)

    def test_pool_info(self):
        &quot;&quot;&quot;
        Test virt.pool_info()
        &quot;&quot;&quot;
        # pylint: disable=no-member
        pool_mock = MagicMock()
        pool_mock.name.return_value = &quot;foo&quot;
        pool_mock.UUIDString.return_value = &quot;some-uuid&quot;
        pool_mock.info.return_value = [0, 1234, 5678, 123]
        pool_mock.autostart.return_value = True
        pool_mock.isPersistent.return_value = True
        pool_mock.XMLDesc.return_value = &quot;&quot;&quot;&lt;pool type='dir'&gt;
  &lt;name&gt;default&lt;/name&gt;
  &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
  &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
  &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
  &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
  &lt;source&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/srv/vms&lt;/path&gt;
    &lt;permissions&gt;
      &lt;mode&gt;0755&lt;/mode&gt;
      &lt;owner&gt;0&lt;/owner&gt;
      &lt;group&gt;0&lt;/group&gt;
    &lt;/permissions&gt;
  &lt;/target&gt;
&lt;/pool&gt;&quot;&quot;&quot;
        self.mock_conn.listAllStoragePools.return_value = [pool_mock]
        # pylint: enable=no-member

        pool = virt.pool_info(&quot;foo&quot;)
        self.assertEqual(
            {
                &quot;foo&quot;: {
                    &quot;uuid&quot;: &quot;some-uuid&quot;,
                    &quot;state&quot;: &quot;inactive&quot;,
                    &quot;capacity&quot;: 1234,
                    &quot;allocation&quot;: 5678,
                    &quot;free&quot;: 123,
                    &quot;autostart&quot;: True,
                    &quot;persistent&quot;: True,
                    &quot;type&quot;: &quot;dir&quot;,
                    &quot;target_path&quot;: &quot;/srv/vms&quot;,
                }
            },
            pool,
        )

    def test_pool_info_notarget(self):
        &quot;&quot;&quot;
        Test virt.pool_info()
        &quot;&quot;&quot;
        # pylint: disable=no-member
        pool_mock = MagicMock()
        pool_mock.name.return_value = &quot;ceph&quot;
        pool_mock.UUIDString.return_value = &quot;some-uuid&quot;
        pool_mock.info.return_value = [0, 0, 0, 0]
        pool_mock.autostart.return_value = True
        pool_mock.isPersistent.return_value = True
        pool_mock.XMLDesc.return_value = &quot;&quot;&quot;&lt;pool type='rbd'&gt;
  &lt;name&gt;ceph&lt;/name&gt;
  &lt;uuid&gt;some-uuid&lt;/uuid&gt;
  &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
  &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
  &lt;available unit='bytes'&gt;0&lt;/available&gt;
  &lt;source&gt;
    &lt;host name='localhost' port='6789'/&gt;
    &lt;host name='localhost' port='6790'/&gt;
    &lt;name&gt;rbd&lt;/name&gt;
    &lt;auth type='ceph' username='admin'&gt;
      &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
    &lt;/auth&gt;
  &lt;/source&gt;
&lt;/pool&gt;&quot;&quot;&quot;
        self.mock_conn.listAllStoragePools.return_value = [pool_mock]
        # pylint: enable=no-member

        pool = virt.pool_info(&quot;ceph&quot;)
        self.assertEqual(
            {
                &quot;ceph&quot;: {
                    &quot;uuid&quot;: &quot;some-uuid&quot;,
                    &quot;state&quot;: &quot;inactive&quot;,
                    &quot;capacity&quot;: 0,
                    &quot;allocation&quot;: 0,
                    &quot;free&quot;: 0,
                    &quot;autostart&quot;: True,
                    &quot;persistent&quot;: True,
                    &quot;type&quot;: &quot;rbd&quot;,
                    &quot;target_path&quot;: None,
                }
            },
            pool,
        )

    def test_pool_info_notfound(self):
        &quot;&quot;&quot;
        Test virt.pool_info() when the pool can't be found
        &quot;&quot;&quot;
        # pylint: disable=no-member
        self.mock_conn.listAllStoragePools.return_value = []
        # pylint: enable=no-member
        pool = virt.pool_info(&quot;foo&quot;)
        self.assertEqual({}, pool)

    def test_pool_info_all(self):
        &quot;&quot;&quot;
        Test virt.pool_info()
        &quot;&quot;&quot;
        # pylint: disable=no-member
        pool_mocks = []
        for i in range(2):
            pool_mock = MagicMock()
            pool_mock.name.return_value = &quot;pool{}&quot;.format(i)
            pool_mock.UUIDString.return_value = &quot;some-uuid-{}&quot;.format(i)
            pool_mock.info.return_value = [0, 1234, 5678, 123]
            pool_mock.autostart.return_value = True
            pool_mock.isPersistent.return_value = True
            pool_mock.XMLDesc.return_value = &quot;&quot;&quot;&lt;pool type='dir'&gt;
  &lt;name&gt;default&lt;/name&gt;
  &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
  &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
  &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
  &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
  &lt;source&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/srv/vms&lt;/path&gt;
    &lt;permissions&gt;
      &lt;mode&gt;0755&lt;/mode&gt;
      &lt;owner&gt;0&lt;/owner&gt;
      &lt;group&gt;0&lt;/group&gt;
    &lt;/permissions&gt;
  &lt;/target&gt;
&lt;/pool&gt;&quot;&quot;&quot;
            pool_mocks.append(pool_mock)
        self.mock_conn.listAllStoragePools.return_value = pool_mocks
        # pylint: enable=no-member

        pool = virt.pool_info()
        self.assertEqual(
            {
                &quot;pool0&quot;: {
                    &quot;uuid&quot;: &quot;some-uuid-0&quot;,
                    &quot;state&quot;: &quot;inactive&quot;,
                    &quot;capacity&quot;: 1234,
                    &quot;allocation&quot;: 5678,
                    &quot;free&quot;: 123,
                    &quot;autostart&quot;: True,
                    &quot;persistent&quot;: True,
                    &quot;type&quot;: &quot;dir&quot;,
                    &quot;target_path&quot;: &quot;/srv/vms&quot;,
                },
                &quot;pool1&quot;: {
                    &quot;uuid&quot;: &quot;some-uuid-1&quot;,
                    &quot;state&quot;: &quot;inactive&quot;,
                    &quot;capacity&quot;: 1234,
                    &quot;allocation&quot;: 5678,
                    &quot;free&quot;: 123,
                    &quot;autostart&quot;: True,
                    &quot;persistent&quot;: True,
                    &quot;type&quot;: &quot;dir&quot;,
                    &quot;target_path&quot;: &quot;/srv/vms&quot;,
                },
            },
            pool,
        )

    def test_pool_get_xml(self):
        &quot;&quot;&quot;
        Test virt.pool_get_xml
        &quot;&quot;&quot;
        pool_mock = MagicMock()
        pool_mock.XMLDesc.return_value = &quot;&lt;pool&gt;Raw XML&lt;/pool&gt;&quot;
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        self.assertEqual(&quot;&lt;pool&gt;Raw XML&lt;/pool&gt;&quot;, virt.pool_get_xml(&quot;default&quot;))

    def test_pool_list_volumes(self):
        &quot;&quot;&quot;
        Test virt.pool_list_volumes
        &quot;&quot;&quot;
        names = [&quot;volume1&quot;, &quot;volume2&quot;]
        mock_pool = MagicMock()
        # pylint: disable=no-member
        mock_pool.listVolumes.return_value = names
        self.mock_conn.storagePoolLookupByName.return_value = mock_pool
        # pylint: enable=no-member
        self.assertEqual(names, virt.pool_list_volumes(&quot;default&quot;))

    @patch(&quot;salt.modules.virt._is_bhyve_hyper&quot;, return_value=False)
    @patch(&quot;salt.modules.virt._is_kvm_hyper&quot;, return_value=True)
    @patch(&quot;salt.modules.virt._is_xen_hyper&quot;, return_value=False)
    def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
        &quot;&quot;&quot;
        test the virt.get_hypervisor() function
        &quot;&quot;&quot;
        self.assertEqual(&quot;kvm&quot;, virt.get_hypervisor())

        iskvm_mock.return_value = False
        self.assertIsNone(virt.get_hypervisor())

        is_bhyve_mock.return_value = False
        self.assertIsNone(virt.get_hypervisor())

        isxen_mock.return_value = True
        self.assertEqual(&quot;xen&quot;, virt.get_hypervisor())

    def test_pool_delete(self):
        &quot;&quot;&quot;
        Test virt.pool_delete function
        &quot;&quot;&quot;
        mock_pool = MagicMock()
        mock_pool.delete = MagicMock(return_value=0)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)

        res = virt.pool_delete(&quot;test-pool&quot;)
        self.assertTrue(res)

        self.mock_conn.storagePoolLookupByName.assert_called_once_with(&quot;test-pool&quot;)

        # Shouldn't be called with another parameter so far since those are not implemented
        # and thus throwing exceptions.
        mock_pool.delete.assert_called_once_with(
            self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
        )

    def test_pool_undefine_secret(self):
        &quot;&quot;&quot;
        Test virt.pool_undefine function where the pool has a secret
        &quot;&quot;&quot;
        mock_pool = MagicMock()
        mock_pool.undefine = MagicMock(return_value=0)
        mock_pool.XMLDesc.return_value = &quot;&quot;&quot;
            &lt;pool type='rbd'&gt;
              &lt;name&gt;test-ses&lt;/name&gt;
              &lt;source&gt;
                &lt;host name='myhost'/&gt;
                &lt;name&gt;libvirt-pool&lt;/name&gt;
                &lt;auth type='ceph' username='libvirt'&gt;
                  &lt;secret usage='pool_test-ses'/&gt;
                &lt;/auth&gt;
              &lt;/source&gt;
            &lt;/pool&gt;
        &quot;&quot;&quot;
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
        mock_undefine = MagicMock(return_value=0)
        self.mock_conn.secretLookupByUsage.return_value.undefine = mock_undefine

        res = virt.pool_undefine(&quot;test-ses&quot;)
        self.assertTrue(res)

        self.mock_conn.storagePoolLookupByName.assert_called_once_with(&quot;test-ses&quot;)
        mock_pool.undefine.assert_called_once_with()

        self.mock_conn.secretLookupByUsage.assert_called_once_with(
            self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, &quot;pool_test-ses&quot;
        )
        mock_undefine.assert_called_once()

    def test_full_info(self):
        &quot;&quot;&quot;
        Test virt.full_info
        &quot;&quot;&quot;
        xml = &quot;&quot;&quot;&lt;domain type='kvm' id='7'&gt;
              &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
              &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
              &lt;on_crash&gt;destroy&lt;/on_crash&gt;
              &lt;devices&gt;
                &lt;disk type='file' device='disk'&gt;
                &lt;driver name='qemu' type='qcow2'/&gt;
                &lt;source file='/disks/test.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;driver name='qemu' type='raw'/&gt;
                &lt;source file='/disks/test-cdrom.iso'/&gt;
                &lt;target dev='hda' bus='ide'/&gt;
                &lt;readonly/&gt;
              &lt;/disk&gt;
              &lt;interface type='bridge'&gt;
                &lt;mac address='ac:de:48:b6:8b:59'/&gt;
                &lt;source bridge='br0'/&gt;
                &lt;model type='virtio'/&gt;
                &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
              &lt;/interface&gt;
              &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
                &lt;listen type='address' address='0.0.0.0'/&gt;
              &lt;/graphics&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        &quot;&quot;&quot;
        self.set_mock_vm(&quot;test-vm&quot;, xml)

        qemu_infos = &quot;&quot;&quot;[{
            &quot;virtual-size&quot;: 25769803776,
            &quot;filename&quot;: &quot;/disks/test.qcow2&quot;,
            &quot;cluster-size&quot;: 65536,
            &quot;format&quot;: &quot;qcow2&quot;,
            &quot;actual-size&quot;: 217088,
            &quot;format-specific&quot;: {
                &quot;type&quot;: &quot;qcow2&quot;,
                &quot;data&quot;: {
                    &quot;compat&quot;: &quot;1.1&quot;,
                    &quot;lazy-refcounts&quot;: false,
                    &quot;refcount-bits&quot;: 16,
                    &quot;corrupt&quot;: false
                }
            },
            &quot;full-backing-filename&quot;: &quot;/disks/mybacking.qcow2&quot;,
            &quot;backing-filename&quot;: &quot;mybacking.qcow2&quot;,
            &quot;dirty-flag&quot;: false
        },
        {
            &quot;virtual-size&quot;: 25769803776,
            &quot;filename&quot;: &quot;/disks/mybacking.qcow2&quot;,
            &quot;cluster-size&quot;: 65536,
            &quot;format&quot;: &quot;qcow2&quot;,
            &quot;actual-size&quot;: 393744384,
            &quot;format-specific&quot;: {
                &quot;type&quot;: &quot;qcow2&quot;,
                &quot;data&quot;: {
                    &quot;compat&quot;: &quot;1.1&quot;,
                    &quot;lazy-refcounts&quot;: false,
                    &quot;refcount-bits&quot;: 16,
                    &quot;corrupt&quot;: false
                }
            },
            &quot;dirty-flag&quot;: false
        }]&quot;&quot;&quot;

        self.mock_popen.communicate.return_value = [qemu_infos, &quot;&quot;]
        self.mock_popen.returncode = 0

        self.mock_conn.getInfo = MagicMock(
            return_value=[&quot;x86_64&quot;, 4096, 8, 2712, 1, 2, 4, 2]
        )

        actual = virt.full_info()

<A NAME="4"></A>        # Check that qemu-img was called with the proper parameters
        qemu_img_call = [
            call
            for call in self.mock_subprocess.Popen<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#4',2,'match118032-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.call_args_list
            if &quot;qemu-img&quot; in call[0][0]
        ][0]
        self.assertIn(&quot;info&quot;, qemu_img_call[0][0])
        self.assertIn(&quot;-U&quot;, qemu_img_call[0][0])

        # Test the hypervisor infos
        self.</B></FONT>assertEqual(2816, actual[&quot;freemem&quot;])
        self.assertEqual(6, actual[&quot;freecpu&quot;])
        self.assertEqual(4, actual[&quot;node_info&quot;][&quot;cpucores&quot;])
        self.assertEqual(2712, actual[&quot;node_info&quot;][&quot;cpumhz&quot;])
        self.assertEqual(&quot;x86_64&quot;, actual[&quot;node_info&quot;][&quot;cpumodel&quot;])
        self.assertEqual(8, actual[&quot;node_info&quot;][&quot;cpus&quot;])
        self.assertEqual(2, actual[&quot;node_info&quot;][&quot;cputhreads&quot;])
        self.assertEqual(1, actual[&quot;node_info&quot;][&quot;numanodes&quot;])
        self.assertEqual(4096, actual[&quot;node_info&quot;][&quot;phymemory&quot;])
        self.assertEqual(2, actual[&quot;node_info&quot;][&quot;sockets&quot;])

        # Test the vm_info output:
        self.assertEqual(2, actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;cpu&quot;])
        self.assertEqual(1234, actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;cputime&quot;])
        self.assertEqual(1024 * 1024, actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;mem&quot;])
        self.assertEqual(2048 * 1024, actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;maxMem&quot;])
        self.assertEqual(&quot;shutdown&quot;, actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;state&quot;])
        self.assertEqual(
            &quot;28deee33-4859-4f23-891c-ee239cffec94&quot;, actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;uuid&quot;]
        )
        self.assertEqual(&quot;destroy&quot;, actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;on_crash&quot;])
        self.assertEqual(&quot;restart&quot;, actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;on_reboot&quot;])
        self.assertEqual(&quot;destroy&quot;, actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;on_poweroff&quot;])

        # Test the nics
        nic = actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;nics&quot;][&quot;ac:de:48:b6:8b:59&quot;]
        self.assertEqual(&quot;bridge&quot;, nic[&quot;type&quot;])
        self.assertEqual(&quot;ac:de:48:b6:8b:59&quot;, nic[&quot;mac&quot;])

        # Test the disks
        disks = actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;disks&quot;]
        disk = disks.get(&quot;vda&quot;)
        self.assertEqual(&quot;/disks/test.qcow2&quot;, disk[&quot;file&quot;])
        self.assertEqual(&quot;disk&quot;, disk[&quot;type&quot;])
        self.assertEqual(&quot;/disks/mybacking.qcow2&quot;, disk[&quot;backing file&quot;][&quot;file&quot;])
        cdrom = disks.get(&quot;hda&quot;)
        self.assertEqual(&quot;/disks/test-cdrom.iso&quot;, cdrom[&quot;file&quot;])
        self.assertEqual(&quot;cdrom&quot;, cdrom[&quot;type&quot;])
        self.assertFalse(&quot;backing file&quot; in cdrom.keys())

        # Test the graphics
        graphics = actual[&quot;vm_info&quot;][&quot;test-vm&quot;][&quot;graphics&quot;]
        self.assertEqual(&quot;vnc&quot;, graphics[&quot;type&quot;])
        self.assertEqual(&quot;5900&quot;, graphics[&quot;port&quot;])
        self.assertEqual(&quot;0.0.0.0&quot;, graphics[&quot;listen&quot;])

    def test_pool_update(self):
        &quot;&quot;&quot;
        Test the pool_update function
        &quot;&quot;&quot;
        current_xml = &quot;&quot;&quot;&lt;pool type='dir'&gt;
          &lt;name&gt;default&lt;/name&gt;
          &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
          &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
          &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
          &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
          &lt;source&gt;
          &lt;/source&gt;
          &lt;target&gt;
            &lt;path&gt;/path/to/pool&lt;/path&gt;
            &lt;permissions&gt;
              &lt;mode&gt;0775&lt;/mode&gt;
              &lt;owner&gt;0&lt;/owner&gt;
              &lt;group&gt;100&lt;/group&gt;
            &lt;/permissions&gt;
          &lt;/target&gt;
        &lt;/pool&gt;&quot;&quot;&quot;

        expected_xml = (
            '&lt;pool type=&quot;netfs&quot;&gt;'
            &quot;&lt;name&gt;default&lt;/name&gt;&quot;
            &quot;&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;&quot;
            '&lt;capacity unit=&quot;bytes&quot;&gt;1999421108224&lt;/capacity&gt;'
            '&lt;allocation unit=&quot;bytes&quot;&gt;713207042048&lt;/allocation&gt;'
            '&lt;available unit=&quot;bytes&quot;&gt;1286214066176&lt;/available&gt;'
            &quot;&lt;target&gt;&quot;
            &quot;&lt;path&gt;/mnt/cifs&lt;/path&gt;&quot;
            &quot;&lt;permissions&gt;&quot;
            &quot;&lt;mode&gt;0774&lt;/mode&gt;&quot;
            &quot;&lt;owner&gt;1234&lt;/owner&gt;&quot;
            &quot;&lt;group&gt;123&lt;/group&gt;&quot;
            &quot;&lt;/permissions&gt;&quot;
            &quot;&lt;/target&gt;&quot;
            &quot;&lt;source&gt;&quot;
            '&lt;dir path=&quot;samba_share&quot; /&gt;'
            '&lt;host name=&quot;one.example.com&quot; /&gt;'
            '&lt;host name=&quot;two.example.com&quot; /&gt;'
            '&lt;format type=&quot;cifs&quot; /&gt;'
            &quot;&lt;/source&gt;&quot;
            &quot;&lt;/pool&gt;&quot;
        )

        mocked_pool = MagicMock()
        mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock()

        self.assertTrue(
            virt.pool_update(
                &quot;default&quot;,
                &quot;netfs&quot;,
                target=&quot;/mnt/cifs&quot;,
                permissions={&quot;mode&quot;: &quot;0774&quot;, &quot;owner&quot;: &quot;1234&quot;, &quot;group&quot;: &quot;123&quot;},
                source_format=&quot;cifs&quot;,
                source_dir=&quot;samba_share&quot;,
                source_hosts=[&quot;one.example.com&quot;, &quot;two.example.com&quot;],
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)

    def test_pool_update_nochange(self):
        &quot;&quot;&quot;
        Test the pool_update function when no change is needed
        &quot;&quot;&quot;

        current_xml = &quot;&quot;&quot;&lt;pool type='dir'&gt;
          &lt;name&gt;default&lt;/name&gt;
          &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
          &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
          &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
          &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
          &lt;source&gt;
          &lt;/source&gt;
          &lt;target&gt;
            &lt;path&gt;/path/to/pool&lt;/path&gt;
            &lt;permissions&gt;
              &lt;mode&gt;0775&lt;/mode&gt;
              &lt;owner&gt;0&lt;/owner&gt;
              &lt;group&gt;100&lt;/group&gt;
            &lt;/permissions&gt;
          &lt;/target&gt;
        &lt;/pool&gt;&quot;&quot;&quot;

        mocked_pool = MagicMock()
        mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock()

        self.assertFalse(
            virt.pool_update(
                &quot;default&quot;,
                &quot;dir&quot;,
                target=&quot;/path/to/pool&quot;,
                permissions={&quot;mode&quot;: &quot;0775&quot;, &quot;owner&quot;: &quot;0&quot;, &quot;group&quot;: &quot;100&quot;},
                test=True,
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_not_called()

    def test_pool_update_password(self):
        &quot;&quot;&quot;
        Test the pool_update function, where the password only is changed
        &quot;&quot;&quot;
        current_xml = &quot;&quot;&quot;&lt;pool type='rbd'&gt;
          &lt;name&gt;default&lt;/name&gt;
          &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
          &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
          &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
          &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
          &lt;source&gt;
            &lt;name&gt;iscsi-images&lt;/name&gt;
            &lt;host name='ses4.tf.local'/&gt;
            &lt;host name='ses5.tf.local'/&gt;
            &lt;auth username='libvirt' type='ceph'&gt;
              &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
            &lt;/auth&gt;
          &lt;/source&gt;
        &lt;/pool&gt;&quot;&quot;&quot;

        mock_secret = MagicMock()
        self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)

        mocked_pool = MagicMock()
        mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock()

        self.assertFalse(
            virt.pool_update(
                &quot;default&quot;,
                &quot;rbd&quot;,
                source_name=&quot;iscsi-images&quot;,
                source_hosts=[&quot;ses4.tf.local&quot;, &quot;ses5.tf.local&quot;],
                source_auth={&quot;username&quot;: &quot;libvirt&quot;, &quot;password&quot;: &quot;c2VjcmV0&quot;},
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_not_called()
        mock_secret.setValue.assert_called_once_with(b&quot;secret&quot;)

        # Case where the secret can't be found
        self.mock_conn.secretLookupByUUIDString = MagicMock(
            side_effect=self.mock_libvirt.libvirtError(&quot;secret not found&quot;)
        )
        self.assertFalse(
            virt.pool_update(
                &quot;default&quot;,
                &quot;rbd&quot;,
                source_name=&quot;iscsi-images&quot;,
                source_hosts=[&quot;ses4.tf.local&quot;, &quot;ses5.tf.local&quot;],
                source_auth={&quot;username&quot;: &quot;libvirt&quot;, &quot;password&quot;: &quot;c2VjcmV0&quot;},
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_not_called()
        self.mock_conn.secretDefineXML.assert_called_once()
        mock_secret.setValue.assert_called_once_with(b&quot;secret&quot;)

    def test_pool_update_password_create(self):
        &quot;&quot;&quot;
        Test the pool_update function, where the password only is changed
        &quot;&quot;&quot;
        current_xml = &quot;&quot;&quot;&lt;pool type='rbd'&gt;
          &lt;name&gt;default&lt;/name&gt;
          &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
          &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
          &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
          &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
          &lt;source&gt;
            &lt;name&gt;iscsi-images&lt;/name&gt;
            &lt;host name='ses4.tf.local'/&gt;
            &lt;host name='ses5.tf.local'/&gt;
          &lt;/source&gt;
        &lt;/pool&gt;&quot;&quot;&quot;

        expected_xml = (
            '&lt;pool type=&quot;rbd&quot;&gt;'
            &quot;&lt;name&gt;default&lt;/name&gt;&quot;
            &quot;&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;&quot;
            '&lt;capacity unit=&quot;bytes&quot;&gt;1999421108224&lt;/capacity&gt;'
            '&lt;allocation unit=&quot;bytes&quot;&gt;713207042048&lt;/allocation&gt;'
            '&lt;available unit=&quot;bytes&quot;&gt;1286214066176&lt;/available&gt;'
            &quot;&lt;source&gt;&quot;
            '&lt;host name=&quot;ses4.tf.local&quot; /&gt;'
            '&lt;host name=&quot;ses5.tf.local&quot; /&gt;'
            '&lt;auth type=&quot;ceph&quot; username=&quot;libvirt&quot;&gt;'
            '&lt;secret usage=&quot;pool_default&quot; /&gt;'
            &quot;&lt;/auth&gt;&quot;
            &quot;&lt;name&gt;iscsi-images&lt;/name&gt;&quot;
            &quot;&lt;/source&gt;&quot;
            &quot;&lt;/pool&gt;&quot;
        )

        mock_secret = MagicMock()
        self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)

        mocked_pool = MagicMock()
        mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock()

        self.assertTrue(
            virt.pool_update(
                &quot;default&quot;,
                &quot;rbd&quot;,
                source_name=&quot;iscsi-images&quot;,
                source_hosts=[&quot;ses4.tf.local&quot;, &quot;ses5.tf.local&quot;],
                source_auth={&quot;username&quot;: &quot;libvirt&quot;, &quot;password&quot;: &quot;c2VjcmV0&quot;},
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
        mock_secret.setValue.assert_called_once_with(b&quot;secret&quot;)

    def test_volume_infos(self):
        &quot;&quot;&quot;
        Test virt.volume_infos
        &quot;&quot;&quot;
        vms_disks = [
            &quot;&quot;&quot;
                &lt;disk type='file' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2'/&gt;
                  &lt;source file='/path/to/vol0.qcow2'/&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                &lt;/disk&gt;
            &quot;&quot;&quot;,
            &quot;&quot;&quot;
                &lt;disk type='file' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2'/&gt;
                  &lt;source file='/path/to/vol3.qcow2'/&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                &lt;/disk&gt;
            &quot;&quot;&quot;,
            &quot;&quot;&quot;
                &lt;disk type='file' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2'/&gt;
                  &lt;source file='/path/to/vol2.qcow2'/&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                &lt;/disk&gt;
            &quot;&quot;&quot;,
        ]
        mock_vms = []
        for idx, disk in enumerate(vms_disks):
            vm = MagicMock()
            # pylint: disable=no-member
            vm.name.return_value = &quot;vm{}&quot;.format(idx)
            vm.XMLDesc.return_value = &quot;&quot;&quot;
                    &lt;domain type='kvm' id='1'&gt;
                      &lt;name&gt;vm{}&lt;/name&gt;
                      &lt;devices&gt;{}&lt;/devices&gt;
                    &lt;/domain&gt;
                &quot;&quot;&quot;.format(
                idx, disk
            )
            # pylint: enable=no-member
            mock_vms.append(vm)

        mock_pool_data = [
            {
                &quot;name&quot;: &quot;pool0&quot;,
                &quot;state&quot;: self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
                &quot;volumes&quot;: [
                    {
                        &quot;key&quot;: &quot;/key/of/vol0&quot;,
                        &quot;name&quot;: &quot;vol0&quot;,
                        &quot;path&quot;: &quot;/path/to/vol0.qcow2&quot;,
                        &quot;info&quot;: [0, 123456789, 123456],
                        &quot;backingStore&quot;: None,
                    }
                ],
            },
            {
                &quot;name&quot;: &quot;pool1&quot;,
                &quot;state&quot;: self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
                &quot;volumes&quot;: [
                    {
                        &quot;key&quot;: &quot;/key/of/vol0bad&quot;,
                        &quot;name&quot;: &quot;vol0bad&quot;,
                        &quot;path&quot;: &quot;/path/to/vol0bad.qcow2&quot;,
                        &quot;info&quot;: None,
                        &quot;backingStore&quot;: None,
                    },
                    {
                        &quot;key&quot;: &quot;/key/of/vol1&quot;,
                        &quot;name&quot;: &quot;vol1&quot;,
                        &quot;path&quot;: &quot;/path/to/vol1.qcow2&quot;,
                        &quot;info&quot;: [0, 12345, 1234],
                        &quot;backingStore&quot;: None,
                    },
                    {
                        &quot;key&quot;: &quot;/key/of/vol2&quot;,
                        &quot;name&quot;: &quot;vol2&quot;,
                        &quot;path&quot;: &quot;/path/to/vol2.qcow2&quot;,
                        &quot;info&quot;: [0, 12345, 1234],
                        &quot;backingStore&quot;: &quot;/path/to/vol0.qcow2&quot;,
                    },
                ],
            },
        ]
        mock_pools = []
        for pool_data in mock_pool_data:
            mock_pool = MagicMock()
            mock_pool.name.return_value = pool_data[&quot;name&quot;]  # pylint: disable=no-member
            mock_pool.info.return_value = [pool_data[&quot;state&quot;]]
            mock_volumes = []
            for vol_data in pool_data[&quot;volumes&quot;]:
                mock_volume = MagicMock()
                # pylint: disable=no-member
                mock_volume.name.return_value = vol_data[&quot;name&quot;]
                mock_volume.key.return_value = vol_data[&quot;key&quot;]
                mock_volume.path.return_value = &quot;/path/to/{}.qcow2&quot;.format(
                    vol_data[&quot;name&quot;]
                )
                if vol_data[&quot;info&quot;]:
                    mock_volume.info.return_value = vol_data[&quot;info&quot;]
                    backing_store = (
                        &quot;&quot;&quot;
                        &lt;backingStore&gt;
                          &lt;format type=&quot;qcow2&quot;/&gt;
                          &lt;path&gt;{}&lt;/path&gt;
                        &lt;/backingStore&gt;
                    &quot;&quot;&quot;.format(
                            vol_data[&quot;backingStore&quot;]
                        )
                        if vol_data[&quot;backingStore&quot;]
                        else &quot;&lt;backingStore/&gt;&quot;
                    )
                    mock_volume.XMLDesc.return_value = &quot;&quot;&quot;
                        &lt;volume type='file'&gt;
                          &lt;name&gt;{0}&lt;/name&gt;
                          &lt;target&gt;
                            &lt;format type=&quot;qcow2&quot;/&gt;
                            &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
                          &lt;/target&gt;
                          {1}
                        &lt;/volume&gt;
                    &quot;&quot;&quot;.format(
                        vol_data[&quot;name&quot;], backing_store
                    )
                else:
                    mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
                        &quot;No such volume&quot;
                    )
                    mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
                        &quot;No such volume&quot;
                    )
                mock_volumes.append(mock_volume)
                # pylint: enable=no-member
            mock_pool.listAllVolumes.return_value = (
                mock_volumes  # pylint: disable=no-member
            )
            mock_pools.append(mock_pool)

        inactive_pool = MagicMock()
        inactive_pool.name.return_value = &quot;pool2&quot;
        inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
        inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
            &quot;pool is inactive&quot;
        )
        mock_pools.append(inactive_pool)

        self.mock_conn.listAllStoragePools.return_value = (
            mock_pools  # pylint: disable=no-member
        )

        with patch(&quot;salt.modules.virt._get_domain&quot;, MagicMock(return_value=mock_vms)):
            actual = virt.volume_infos(&quot;pool0&quot;, &quot;vol0&quot;)
            self.assertEqual(1, len(actual.keys()))
            self.assertEqual(1, len(actual[&quot;pool0&quot;].keys()))
            self.assertEqual([&quot;vm0&quot;, &quot;vm2&quot;], sorted(actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;used_by&quot;]))
            self.assertEqual(&quot;/path/to/vol0.qcow2&quot;, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;path&quot;])
            self.assertEqual(&quot;file&quot;, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;type&quot;])
            self.assertEqual(&quot;/key/of/vol0&quot;, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;key&quot;])
            self.assertEqual(123456789, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;capacity&quot;])
            self.assertEqual(123456, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;allocation&quot;])

            self.assertEqual(
                virt.volume_infos(&quot;pool1&quot;, None),
                {
                    &quot;pool1&quot;: {
                        &quot;vol1&quot;: {
                            &quot;type&quot;: &quot;file&quot;,
                            &quot;key&quot;: &quot;/key/of/vol1&quot;,
                            &quot;path&quot;: &quot;/path/to/vol1.qcow2&quot;,
                            &quot;capacity&quot;: 12345,
                            &quot;allocation&quot;: 1234,
                            &quot;used_by&quot;: [],
                            &quot;backing_store&quot;: None,
                            &quot;format&quot;: &quot;qcow2&quot;,
                        },
                        &quot;vol2&quot;: {
                            &quot;type&quot;: &quot;file&quot;,
                            &quot;key&quot;: &quot;/key/of/vol2&quot;,
                            &quot;path&quot;: &quot;/path/to/vol2.qcow2&quot;,
                            &quot;capacity&quot;: 12345,
                            &quot;allocation&quot;: 1234,
                            &quot;used_by&quot;: [&quot;vm2&quot;],
                            &quot;backing_store&quot;: {
                                &quot;path&quot;: &quot;/path/to/vol0.qcow2&quot;,
                                &quot;format&quot;: &quot;qcow2&quot;,
                            },
                            &quot;format&quot;: &quot;qcow2&quot;,
                        },
                    }
                },
            )

            self.assertEqual(
                virt.volume_infos(None, &quot;vol2&quot;),
                {
                    &quot;pool1&quot;: {
                        &quot;vol2&quot;: {
                            &quot;type&quot;: &quot;file&quot;,
                            &quot;key&quot;: &quot;/key/of/vol2&quot;,
                            &quot;path&quot;: &quot;/path/to/vol2.qcow2&quot;,
                            &quot;capacity&quot;: 12345,
                            &quot;allocation&quot;: 1234,
                            &quot;used_by&quot;: [&quot;vm2&quot;],
                            &quot;backing_store&quot;: {
                                &quot;path&quot;: &quot;/path/to/vol0.qcow2&quot;,
                                &quot;format&quot;: &quot;qcow2&quot;,
                            },
                            &quot;format&quot;: &quot;qcow2&quot;,
                        }
                    }
                },
            )

        # Single VM test
        with patch(
            &quot;salt.modules.virt._get_domain&quot;, MagicMock(return_value=mock_vms[0])
        ):
            actual = virt.volume_infos(&quot;pool0&quot;, &quot;vol0&quot;)
            self.assertEqual(1, len(actual.keys()))
            self.assertEqual(1, len(actual[&quot;pool0&quot;].keys()))
            self.assertEqual([&quot;vm0&quot;], sorted(actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;used_by&quot;]))
            self.assertEqual(&quot;/path/to/vol0.qcow2&quot;, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;path&quot;])
            self.assertEqual(&quot;file&quot;, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;type&quot;])
            self.assertEqual(&quot;/key/of/vol0&quot;, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;key&quot;])
            self.assertEqual(123456789, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;capacity&quot;])
            self.assertEqual(123456, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;allocation&quot;])

            self.assertEqual(
                virt.volume_infos(&quot;pool1&quot;, None),
                {
                    &quot;pool1&quot;: {
                        &quot;vol1&quot;: {
                            &quot;type&quot;: &quot;file&quot;,
                            &quot;key&quot;: &quot;/key/of/vol1&quot;,
                            &quot;path&quot;: &quot;/path/to/vol1.qcow2&quot;,
                            &quot;capacity&quot;: 12345,
                            &quot;allocation&quot;: 1234,
                            &quot;used_by&quot;: [],
                            &quot;backing_store&quot;: None,
                            &quot;format&quot;: &quot;qcow2&quot;,
                        },
                        &quot;vol2&quot;: {
                            &quot;type&quot;: &quot;file&quot;,
                            &quot;key&quot;: &quot;/key/of/vol2&quot;,
                            &quot;path&quot;: &quot;/path/to/vol2.qcow2&quot;,
                            &quot;capacity&quot;: 12345,
                            &quot;allocation&quot;: 1234,
                            &quot;used_by&quot;: [],
                            &quot;backing_store&quot;: {
                                &quot;path&quot;: &quot;/path/to/vol0.qcow2&quot;,
                                &quot;format&quot;: &quot;qcow2&quot;,
                            },
                            &quot;format&quot;: &quot;qcow2&quot;,
                        },
                    }
                },
            )

            self.assertEqual(
                virt.volume_infos(None, &quot;vol2&quot;),
                {
                    &quot;pool1&quot;: {
                        &quot;vol2&quot;: {
                            &quot;type&quot;: &quot;file&quot;,
                            &quot;key&quot;: &quot;/key/of/vol2&quot;,
                            &quot;path&quot;: &quot;/path/to/vol2.qcow2&quot;,
                            &quot;capacity&quot;: 12345,
                            &quot;allocation&quot;: 1234,
                            &quot;used_by&quot;: [],
                            &quot;backing_store&quot;: {
                                &quot;path&quot;: &quot;/path/to/vol0.qcow2&quot;,
                                &quot;format&quot;: &quot;qcow2&quot;,
                            },
                            &quot;format&quot;: &quot;qcow2&quot;,
                        }
                    }
                },
            )

        # No VM test
        with patch(
            &quot;salt.modules.virt._get_domain&quot;,
            MagicMock(side_effect=CommandExecutionError(&quot;no VM&quot;)),
        ):
            actual = virt.volume_infos(&quot;pool0&quot;, &quot;vol0&quot;)
            self.assertEqual(1, len(actual.keys()))
            self.assertEqual(1, len(actual[&quot;pool0&quot;].keys()))
            self.assertEqual([], sorted(actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;used_by&quot;]))
            self.assertEqual(&quot;/path/to/vol0.qcow2&quot;, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;path&quot;])
            self.assertEqual(&quot;file&quot;, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;type&quot;])
            self.assertEqual(&quot;/key/of/vol0&quot;, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;key&quot;])
            self.assertEqual(123456789, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;capacity&quot;])
            self.assertEqual(123456, actual[&quot;pool0&quot;][&quot;vol0&quot;][&quot;allocation&quot;])

            self.assertEqual(
                virt.volume_infos(&quot;pool1&quot;, None),
                {
                    &quot;pool1&quot;: {
                        &quot;vol1&quot;: {
                            &quot;type&quot;: &quot;file&quot;,
                            &quot;key&quot;: &quot;/key/of/vol1&quot;,
                            &quot;path&quot;: &quot;/path/to/vol1.qcow2&quot;,
                            &quot;capacity&quot;: 12345,
                            &quot;allocation&quot;: 1234,
                            &quot;used_by&quot;: [],
                            &quot;backing_store&quot;: None,
                            &quot;format&quot;: &quot;qcow2&quot;,
                        },
                        &quot;vol2&quot;: {
                            &quot;type&quot;: &quot;file&quot;,
                            &quot;key&quot;: &quot;/key/of/vol2&quot;,
                            &quot;path&quot;: &quot;/path/to/vol2.qcow2&quot;,
                            &quot;capacity&quot;: 12345,
                            &quot;allocation&quot;: 1234,
                            &quot;used_by&quot;: [],
                            &quot;backing_store&quot;: {
                                &quot;path&quot;: &quot;/path/to/vol0.qcow2&quot;,
                                &quot;format&quot;: &quot;qcow2&quot;,
                            },
                            &quot;format&quot;: &quot;qcow2&quot;,
                        },
                    }
                },
            )

            self.assertEqual(
                virt.volume_infos(None, &quot;vol2&quot;),
                {
                    &quot;pool1&quot;: {
                        &quot;vol2&quot;: {
                            &quot;type&quot;: &quot;file&quot;,
                            &quot;key&quot;: &quot;/key/of/vol2&quot;,
                            &quot;path&quot;: &quot;/path/to/vol2.qcow2&quot;,
                            &quot;capacity&quot;: 12345,
                            &quot;allocation&quot;: 1234,
                            &quot;used_by&quot;: [],
                            &quot;backing_store&quot;: {
                                &quot;path&quot;: &quot;/path/to/vol0.qcow2&quot;,
                                &quot;format&quot;: &quot;qcow2&quot;,
                            },
                            &quot;format&quot;: &quot;qcow2&quot;,
                        }
                    }
                },
            )

    def test_volume_delete(self):
        &quot;&quot;&quot;
        Test virt.volume_delete
        &quot;&quot;&quot;
        mock_delete = MagicMock(side_effect=[0, 1])
        mock_volume = MagicMock()
        mock_volume.delete = mock_delete  # pylint: disable=no-member
        mock_pool = MagicMock()
        # pylint: disable=no-member
        mock_pool.storageVolLookupByName.side_effect = [
            mock_volume,
            mock_volume,
            self.mock_libvirt.libvirtError(&quot;Missing volume&quot;),
            mock_volume,
        ]
        self.mock_conn.storagePoolLookupByName.side_effect = [
            mock_pool,
            mock_pool,
            mock_pool,
            self.mock_libvirt.libvirtError(&quot;Missing pool&quot;),
        ]

        # pylint: enable=no-member
        self.assertTrue(virt.volume_delete(&quot;default&quot;, &quot;test_volume&quot;))
        self.assertFalse(virt.volume_delete(&quot;default&quot;, &quot;test_volume&quot;))
        with self.assertRaises(self.mock_libvirt.libvirtError):
            virt.volume_delete(&quot;default&quot;, &quot;missing&quot;)
            virt.volume_delete(&quot;missing&quot;, &quot;test_volume&quot;)
        self.assertEqual(mock_delete.call_count, 2)

    def test_pool_capabilities(self):
        &quot;&quot;&quot;
        Test virt.pool_capabilities where libvirt has the pool-capabilities feature
        &quot;&quot;&quot;
        xml_caps = &quot;&quot;&quot;
&lt;storagepoolCapabilities&gt;
  &lt;pool type='disk' supported='yes'&gt;
    &lt;poolOptions&gt;
      &lt;defaultFormat type='unknown'/&gt;
      &lt;enum name='sourceFormatType'&gt;
        &lt;value&gt;unknown&lt;/value&gt;
        &lt;value&gt;dos&lt;/value&gt;
        &lt;value&gt;dvh&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/poolOptions&gt;
    &lt;volOptions&gt;
      &lt;defaultFormat type='none'/&gt;
      &lt;enum name='targetFormatType'&gt;
        &lt;value&gt;none&lt;/value&gt;
        &lt;value&gt;linux&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/volOptions&gt;
  &lt;/pool&gt;
  &lt;pool type='iscsi' supported='yes'&gt;
  &lt;/pool&gt;
  &lt;pool type='rbd' supported='yes'&gt;
    &lt;volOptions&gt;
      &lt;defaultFormat type='raw'/&gt;
      &lt;enum name='targetFormatType'&gt;
      &lt;/enum&gt;
    &lt;/volOptions&gt;
  &lt;/pool&gt;
  &lt;pool type='sheepdog' supported='no'&gt;
  &lt;/pool&gt;
&lt;/storagepoolCapabilities&gt;
        &quot;&quot;&quot;
        self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)

        actual = virt.pool_capabilities()
        self.assertEqual(
            {
                &quot;computed&quot;: False,
                &quot;pool_types&quot;: [
                    {
                        &quot;name&quot;: &quot;disk&quot;,
                        &quot;supported&quot;: True,
                        &quot;options&quot;: {
                            &quot;pool&quot;: {
                                &quot;default_format&quot;: &quot;unknown&quot;,
                                &quot;sourceFormatType&quot;: [&quot;unknown&quot;, &quot;dos&quot;, &quot;dvh&quot;],
                            },
                            &quot;volume&quot;: {
                                &quot;default_format&quot;: &quot;none&quot;,
                                &quot;targetFormatType&quot;: [&quot;none&quot;, &quot;linux&quot;],
                            },
                        },
                    },
                    {&quot;name&quot;: &quot;iscsi&quot;, &quot;supported&quot;: True},
                    {
                        &quot;name&quot;: &quot;rbd&quot;,
                        &quot;supported&quot;: True,
                        &quot;options&quot;: {
                            &quot;volume&quot;: {&quot;default_format&quot;: &quot;raw&quot;, &quot;targetFormatType&quot;: []}
                        },
                    },
                    {&quot;name&quot;: &quot;sheepdog&quot;, &quot;supported&quot;: False},
                ],
            },
            actual,
        )

    @patch(&quot;salt.modules.virt.get_hypervisor&quot;, return_value=&quot;kvm&quot;)
    def test_pool_capabilities_computed(self, mock_get_hypervisor):
        &quot;&quot;&quot;
        Test virt.pool_capabilities where libvirt doesn't have the pool-capabilities feature
        &quot;&quot;&quot;
        self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
        del self.mock_conn.getStoragePoolCapabilities

        actual = virt.pool_capabilities()

        self.assertTrue(actual[&quot;computed&quot;])
        backends = actual[&quot;pool_types&quot;]

        # libvirt version matching check
        self.assertFalse(
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;iscsi-direct&quot;][0][
                &quot;supported&quot;
            ]
        )
        self.assertTrue(
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;gluster&quot;][0][
                &quot;supported&quot;
            ]
        )
        self.assertFalse(
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;zfs&quot;][0][
                &quot;supported&quot;
            ]
        )

        # test case matching other hypervisors
        mock_get_hypervisor.return_value = &quot;xen&quot;
        backends = virt.pool_capabilities()[&quot;pool_types&quot;]
        self.assertFalse(
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;gluster&quot;][0][
                &quot;supported&quot;
            ]
        )

        mock_get_hypervisor.return_value = &quot;bhyve&quot;
        backends = virt.pool_capabilities()[&quot;pool_types&quot;]
        self.assertFalse(
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;gluster&quot;][0][
                &quot;supported&quot;
            ]
        )
        self.assertTrue(
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;zfs&quot;][0][
                &quot;supported&quot;
            ]
        )

        # Test options output
        self.assertNotIn(
            &quot;options&quot;,
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;iscsi&quot;][0],
        )
        self.assertNotIn(
            &quot;pool&quot;,
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;dir&quot;][0][&quot;options&quot;],
        )
        self.assertNotIn(
            &quot;volume&quot;,
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;logical&quot;][0][
                &quot;options&quot;
            ],
        )
        self.assertEqual(
            {
                &quot;pool&quot;: {
                    &quot;default_format&quot;: &quot;auto&quot;,
                    &quot;sourceFormatType&quot;: [&quot;auto&quot;, &quot;nfs&quot;, &quot;glusterfs&quot;, &quot;cifs&quot;],
                },
                &quot;volume&quot;: {
                    &quot;default_format&quot;: &quot;raw&quot;,
                    &quot;targetFormatType&quot;: [
                        &quot;none&quot;,
                        &quot;raw&quot;,
                        &quot;dir&quot;,
                        &quot;bochs&quot;,
                        &quot;cloop&quot;,
                        &quot;dmg&quot;,
                        &quot;iso&quot;,
                        &quot;vpc&quot;,
                        &quot;vdi&quot;,
                        &quot;fat&quot;,
                        &quot;vhd&quot;,
                        &quot;ploop&quot;,
                        &quot;cow&quot;,
                        &quot;qcow&quot;,
                        &quot;qcow2&quot;,
                        &quot;qed&quot;,
                        &quot;vmdk&quot;,
                    ],
                },
            },
            [backend for backend in backends if backend[&quot;name&quot;] == &quot;netfs&quot;][0][
                &quot;options&quot;
            ],
        )

    def test_get_domain(self):
        &quot;&quot;&quot;
        Test the virt._get_domain function
        &quot;&quot;&quot;
        # Tests with no VM
        self.mock_conn.listDomainsID.return_value = []
        self.mock_conn.listDefinedDomains.return_value = []
        self.assertEqual([], virt._get_domain(self.mock_conn))
        self.assertRaisesRegex(
            CommandExecutionError,
            &quot;No virtual machines found.&quot;,
            virt._get_domain,
            self.mock_conn,
            &quot;vm2&quot;,
        )

        # Test with active and inactive VMs
        self.mock_conn.listDomainsID.return_value = [1]

        def create_mock_vm(idx):
            mock_vm = MagicMock()
            mock_vm.name.return_value = &quot;vm{}&quot;.format(idx)
<A NAME="10"></A>            return mock_vm

        mock_vms = [create_mock_vm(idx) for idx in range(3)]
        self.mock_conn.lookupByID.return_value <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match118032-0.html#10',2,'match118032-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= mock_vms[0]
        self.mock_conn.listDefinedDomains.return_value = [&quot;vm1&quot;, &quot;vm2&quot;]

        self.mock_conn.lookupByName.side_effect = mock_vms
        self.</B></FONT>assertEqual(mock_vms, virt._get_domain(self.mock_conn))

        self.mock_conn.lookupByName.side_effect = None
        self.mock_conn.lookupByName.return_value = mock_vms[0]
        self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))

        self.mock_conn.lookupByName.return_value = None
        self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
        self.assertEqual(
            [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
        )

        self.mock_conn.reset_mock()
        self.mock_conn.lookupByName.return_value = None
        self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
        self.assertEqual(
            [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, &quot;vm1&quot;, &quot;vm2&quot;)
        )
        self.assertRaisesRegex(
            CommandExecutionError,
            'The VM &quot;vm2&quot; is not present',
            virt._get_domain,
            self.mock_conn,
            &quot;vm2&quot;,
            inactive=False,
        )

    def test_volume_define(self):
        &quot;&quot;&quot;
        Test virt.volume_define function
        &quot;&quot;&quot;
        # Normal test case
        pool_mock = MagicMock()
        pool_mock.XMLDesc.return_value = &quot;&lt;pool type='dir'&gt;&lt;/pool&gt;&quot;
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        self.assertTrue(
            virt.volume_define(
                &quot;testpool&quot;,
                &quot;myvm_system.qcow2&quot;,
                8192,
                allocation=4096,
                format=&quot;qcow2&quot;,
                type=&quot;file&quot;,
            )
        )

        expected_xml = (
            &quot;&lt;volume type='file'&gt;\n&quot;
            &quot;  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n&quot;
            &quot;  &lt;source&gt;\n&quot;
            &quot;  &lt;/source&gt;\n&quot;
            &quot;  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n&quot;
            &quot;  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n&quot;
            &quot;  &lt;target&gt;\n&quot;
            &quot;    &lt;format type='qcow2'/&gt;\n&quot;
            &quot;  &lt;/target&gt;\n&quot;
            &quot;&lt;/volume&gt;&quot;
        )

        pool_mock.createXML.assert_called_once_with(expected_xml, 0)

        # backing store test case
        pool_mock.reset_mock()
        self.assertTrue(
            virt.volume_define(
                &quot;testpool&quot;,
                &quot;myvm_system.qcow2&quot;,
                8192,
                allocation=4096,
                format=&quot;qcow2&quot;,
                type=&quot;file&quot;,
                backing_store={&quot;path&quot;: &quot;/path/to/base.raw&quot;, &quot;format&quot;: &quot;raw&quot;},
            )
        )

        expected_xml = (
            &quot;&lt;volume type='file'&gt;\n&quot;
            &quot;  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n&quot;
            &quot;  &lt;source&gt;\n&quot;
            &quot;  &lt;/source&gt;\n&quot;
            &quot;  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n&quot;
            &quot;  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n&quot;
            &quot;  &lt;target&gt;\n&quot;
            &quot;    &lt;format type='qcow2'/&gt;\n&quot;
            &quot;  &lt;/target&gt;\n&quot;
            &quot;  &lt;backingStore&gt;\n&quot;
            &quot;    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n&quot;
            &quot;    &lt;format type='raw'/&gt;\n&quot;
            &quot;  &lt;/backingStore&gt;\n&quot;
            &quot;&lt;/volume&gt;&quot;
        )

        pool_mock.createXML.assert_called_once_with(expected_xml, 0)

        # logical pool test case
        pool_mock.reset_mock()
        pool_mock.XMLDesc.return_value = &quot;&lt;pool type='logical'&gt;&lt;/pool&gt;&quot;
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        self.assertTrue(
            virt.volume_define(
                &quot;testVG&quot;,
                &quot;myvm_system&quot;,
                8192,
                backing_store={&quot;path&quot;: &quot;/dev/testVG/base&quot;},
            )
        )

        expected_xml = (
            &quot;&lt;volume&gt;\n&quot;
            &quot;  &lt;name&gt;myvm_system&lt;/name&gt;\n&quot;
            &quot;  &lt;source&gt;\n&quot;
            &quot;  &lt;/source&gt;\n&quot;
            &quot;  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n&quot;
            &quot;  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n&quot;
            &quot;  &lt;target&gt;\n&quot;
            &quot;  &lt;/target&gt;\n&quot;
            &quot;  &lt;backingStore&gt;\n&quot;
            &quot;    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n&quot;
            &quot;  &lt;/backingStore&gt;\n&quot;
            &quot;&lt;/volume&gt;&quot;
        )

        pool_mock.createXML.assert_called_once_with(expected_xml, 0)

    def test_volume_upload(self):
        &quot;&quot;&quot;
        Test virt.volume_upload function
        &quot;&quot;&quot;
        pool_mock = MagicMock()
        vol_mock = MagicMock()
        pool_mock.storageVolLookupByName.return_value = vol_mock
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock
        stream_mock = MagicMock()
        self.mock_conn.newStream.return_value = stream_mock

        open_mock = MagicMock()
        close_mock = MagicMock()
        with patch.dict(
            os.__dict__, {&quot;open&quot;: open_mock, &quot;close&quot;: close_mock}
        ):  # pylint: disable=no-member
            # Normal case
            self.assertTrue(virt.volume_upload(&quot;pool0&quot;, &quot;vol1.qcow2&quot;, &quot;/path/to/file&quot;))
            stream_mock.sendAll.assert_called_once()
            stream_mock.finish.assert_called_once()
            self.mock_conn.close.assert_called_once()
            vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)

            # Sparse upload case
            stream_mock.sendAll.reset_mock()
            vol_mock.upload.reset_mock()
            self.assertTrue(
                virt.volume_upload(
                    &quot;pool0&quot;,
                    &quot;vol1.qcow2&quot;,
                    &quot;/path/to/file&quot;,
                    offset=123,
                    length=456,
                    sparse=True,
                )
            )
            stream_mock.sendAll.assert_not_called()
            stream_mock.sparseSendAll.assert_called_once()
            vol_mock.upload.assert_called_once_with(
                stream_mock,
                123,
                456,
                self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
            )

            # Upload unsupported case
            vol_mock.upload.side_effect = self.mock_libvirt.libvirtError(&quot;Unsupported&quot;)
            self.assertRaisesRegex(
                CommandExecutionError,
                &quot;Unsupported&quot;,
                virt.volume_upload,
                &quot;pool0&quot;,
                &quot;vol1.qcow2&quot;,
                &quot;/path/to/file&quot;,
            )
</PRE>
</div>
  </div>
</body>
</html>
