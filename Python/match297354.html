<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for archive_1.py &amp; test_vsphere.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for archive_1.py &amp; test_vsphere.py
      </h3>
<h1 align="center">
        0.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>archive_1.py (1.0433387%)<th>test_vsphere.py (0.28901735%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(22-35)<td><a href="#" name="0">(8-26)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>archive_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
A module to wrap (non-Windows) archive calls
.. versionadded:: 2014.1.0
"""
import contextlib
import copy
import errno
import glob
import logging
import os
import re
import shlex
import stat
import subprocess
import tarfile
import urllib.parse
import salt.utils.decorators
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import salt.utils.decorators.path
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.templates
from salt.exceptions import CommandExecutionError, SaltInvocationError
try:
    import rarfile
    HAS_RARFILE = True
except ImportError:
    HAS_RARFILE =</b></font> False
if salt.utils.platform.is_windows():
    import win32file
__func_alias__ = {"zip_": "zip", "list_": "list"}
log = logging.getLogger(__name__)
def list_(
    name,
    archive_format=None,
    options=None,
    strip_components=None,
    clean=False,
    verbose=False,
    saltenv="base",
    source_hash=None,
    use_etag=False,
):
    """
    .. versionadded:: 2016.11.0
    .. versionchanged:: 2016.11.2,3005
        The rarfile_ Python module is now supported for listing the contents of
        rar archives. This is necessary on minions with older releases of the
        ``rar`` CLI tool, which do not support listing the contents in a
        parsable format.
    .. _rarfile: https://pypi.python.org/pypi/rarfile
    List the files and directories in an tar, zip, or rar archive.
    .. note::
        This function will only provide results for XZ-compressed archives if
        the xz_ CLI command is available, as Python does not at this time
        natively support XZ compression in its tarfile_ module. Keep in mind
        however that most Linux distros ship with xz_ already installed.
        To check if a given minion has xz_, the following Salt command can be
        run:
        .. code-block:: bash
            salt minion_id cmd.which xz
        If ``None`` is returned, then xz_ is not present and must be installed.
        It is widely available and should be packaged as either ``xz`` or
        ``xz-utils``.
    name
        Path/URL of archive
    archive_format
        Specify the format of the archive (``tar``, ``zip``, or ``rar``). If
        this argument is omitted, the archive format will be guessed based on
        the value of the ``name`` parameter.
    options
        **For tar archives only.** This function will, by default, try to use
        the tarfile_ module from the Python standard library to get a list of
        files/directories. If this method fails, then it will fall back to
        using the shell to decompress the archive to stdout and pipe the
        results to ``tar -tf -`` to produce a list of filenames. XZ-compressed
        archives are already supported automatically, but in the event that the
        tar archive uses a different sort of compression not supported natively
        by tarfile_, this option can be used to specify a command that will
        decompress the archive to stdout. For example:
        .. code-block:: bash
            salt minion_id archive.list /path/to/foo.tar.gz options='gzip --decompress --stdout'
        .. note::
            It is not necessary to manually specify options for gzip'ed
            archives, as gzip compression is natively supported by tarfile_.
    strip_components
        This argument specifies a number of top-level directories to strip from
        the results. This is similar to the paths that would be extracted if
        ``--strip-components`` (or ``--strip``) were used when extracting tar
        archives.
        .. versionadded:: 2016.11.2
    clean : False
        Set this value to ``True`` to delete the path referred to by ``name``
        once the contents have been listed. This option should be used with
        care.
        .. note::
            If there is an error listing the archive's contents, the cached
            file will not be removed, to allow for troubleshooting.
    verbose : False
        If ``False``, this function will return a list of files/dirs in the
        archive. If ``True``, it will return a dictionary categorizing the
        paths into separate keys containing the directory names, file names,
        and also directories/files present in the top level of the archive.
        .. versionchanged:: 2016.11.2
            This option now includes symlinks in their own list. Before, they
            were included with files.
    saltenv : base
        Specifies the fileserver environment from which to retrieve
        ``archive``. This is only applicable when ``archive`` is a file from
        the ``salt://`` fileserver.
    source_hash
        If ``name`` is an http(s)/ftp URL and the file exists in the minion's
        file cache, this option can be passed to keep the minion from
        re-downloading the archive if the cached copy matches the specified
        hash.
        .. versionadded:: 2018.3.0
    use_etag
        If ``True``, remote http/https file sources will attempt to use the
        ETag header to determine if the remote file needs to be downloaded.
        This provides a lightweight mechanism for promptly refreshing files
        changed on a web server without requiring a full hash comparison via
        the ``source_hash`` parameter.
        .. versionadded:: 3005
    .. _tarfile: https://docs.python.org/2/library/tarfile.html
    .. _xz: http://tukaani.org/xz/
    CLI Examples:
    .. code-block:: bash
            salt '*' archive.list /path/to/myfile.tar.gz
            salt '*' archive.list /path/to/myfile.tar.gz strip_components=1
            salt '*' archive.list salt://foo.tar.gz
            salt '*' archive.list https://domain.tld/myfile.zip
            salt '*' archive.list https://domain.tld/myfile.zip source_hash=f1d2d2f924e986ac86fdf7b36c94bcdf32beec15
            salt '*' archive.list ftp://10.1.2.3/foo.rar
    """
    def _list_tar(name, cached, decompress_cmd, failhard=False):
        """
        List the contents of a tar archive.
        """
        dirs = []
        files = []
        links = []
        try:
            open_kwargs = (
                {"name": cached}
                if not isinstance(cached, subprocess.Popen)
                else {"fileobj": cached.stdout, "mode": "r|"}
            )
            with contextlib.closing(tarfile.open(**open_kwargs)) as tar_archive:
                for member in tar_archive.getmembers():
                    _member = salt.utils.data.decode(member.name)
                    if member.issym():
                        links.append(_member)
                    elif member.isdir():
                        dirs.append(_member + "/")
                    else:
                        files.append(_member)
            return dirs, files, links
        except tarfile.ReadError:
            if failhard:
                if isinstance(cached, subprocess.Popen):
                    stderr = cached.communicate()[1]
                    if cached.returncode != 0:
                        raise CommandExecutionError(
                            "Failed to decompress {}".format(name),
                            info={"error": stderr},
                        )
            else:
                if not salt.utils.path.which("tar"):
                    raise CommandExecutionError("'tar' command not available")
                if decompress_cmd is not None and isinstance(decompress_cmd, str):
                    try:
                        decompress_cmd = [
                            shlex.quote(x) for x in shlex.split(decompress_cmd)
                        ]
                    except AttributeError:
                        raise CommandExecutionError("Invalid CLI options")
                else:
                    if (
                        salt.utils.path.which("xz")
                        and __salt__["cmd.retcode"](
                            ["xz", "-t", cached],
                            python_shell=False,
                            ignore_retcode=True,
                        )
                        == 0
                    ):
                        decompress_cmd = ["xz", "--decompress", "--stdout"]
                if decompress_cmd:
                    decompressed = subprocess.Popen(
                        decompress_cmd + [shlex.quote(cached)],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                    )
                    return _list_tar(name, decompressed, None, True)
        raise CommandExecutionError(
            "Unable to list contents of {}. If this is an XZ-compressed tar "
            "archive, install XZ Utils to enable listing its contents. If it "
            "is compressed using something other than XZ, it may be necessary "
            "to specify CLI options to decompress the archive. See the "
            "documentation for details.".format(name)
        )
    def _list_zip(name, cached):
        """
        List the contents of a zip archive.
        Password-protected ZIP archives can still be listed by zipfile, so
        there is no reason to invoke the unzip command.
        """
        dirs = set()
        files = []
        links = []
        try:
            with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
                for member in zip_archive.infolist():
                    path = member.filename
                    if salt.utils.platform.is_windows():
                        if path.endswith("/"):
                            dirs.add(path)
                        else:
                            files.append(path)
                    else:
                        mode = member.external_attr &gt;&gt; 16
                        if stat.S_ISLNK(mode):
                            links.append(path)
                        elif stat.S_ISDIR(mode):
                            dirs.add(path)
                        else:
                            files.append(path)
                _files = copy.deepcopy(files)
                for path in _files:
                    dirname = "".join(path.rpartition("/")[:2])
                    if dirname:
                        dirs.add(dirname)
                        if dirname in files:
                            files.remove(dirname)
            return list(dirs), files, links
        except zipfile.BadZipfile:
            raise CommandExecutionError("{} is not a ZIP file".format(name))
    def _list_rar(name, cached):
        """
        List the contents of a rar archive.
        """
        dirs = []
        files = []
        if HAS_RARFILE:
            with rarfile.RarFile(cached) as rf:
                for member in rf.infolist():
                    path = member.filename.replace("\\", "/")
                    if member.isdir():
                        dirs.append(path + "/")
                    else:
                        files.append(path)
        else:
            if not salt.utils.path.which("rar"):
                raise CommandExecutionError(
                    "rar command not available, is it installed?"
                )
            output = __salt__["cmd.run"](
                ["rar", "lt", name], python_shell=False, ignore_retcode=False
            )
            matches = re.findall(r"Name:\s*([^\n]+)\s*Type:\s*([^\n]+)", output)
            for path, type_ in matches:
                if type_ == "Directory":
                    dirs.append(path + "/")
                else:
                    files.append(path)
            if not dirs and not files:
                raise CommandExecutionError(
                    "Failed to list {}, is it a rar file? If so, the "
                    "installed version of rar may be too old to list data in "
                    "a parsable format. Installing the rarfile Python module "
                    "may be an easier workaround if newer rar is not readily "
                    "available.".format(name),
                    info={"error": output},
                )
        return dirs, files, []
    cached = __salt__["cp.cache_file"](
        name, saltenv, source_hash=source_hash, use_etag=use_etag
    )
    if not cached:
        raise CommandExecutionError("Failed to cache {}".format(name))
    try:
        if strip_components:
            try:
                int(strip_components)
            except ValueError:
                strip_components = -1
            if strip_components &lt;= 0:
                raise CommandExecutionError(
                    "'strip_components' must be a positive integer"
                )
        parsed = urllib.parse.urlparse(name)
        path = parsed.path or parsed.netloc
        def _unsupported_format(archive_format):
            """
            Raise the proper exception message for the given archive format.
            """
            if archive_format is None:
                raise CommandExecutionError(
                    "Unable to guess archive format, please pass an "
                    "'archive_format' argument."
                )
            raise CommandExecutionError(
                "Unsupported archive format '{}'".format(archive_format)
            )
        if not archive_format:
            guessed_format = salt.utils.files.guess_archive_type(path)
            if guessed_format is None:
                _unsupported_format(archive_format)
            archive_format = guessed_format
        func = locals().get("_list_" + archive_format)
        if not hasattr(func, "__call__"):
            _unsupported_format(archive_format)
        args = (options,) if archive_format == "tar" else ()
        try:
            dirs, files, links = func(name, cached, *args)
        except OSError as exc:
            raise CommandExecutionError(
                "Failed to list contents of {}: {}".format(name, exc.__str__())
            )
        except CommandExecutionError as exc:
            raise
        except Exception as exc:  # pylint: disable=broad-except
            raise CommandExecutionError(
                "Uncaught exception '{}' when listing contents of {}".format(exc, name)
            )
        if clean:
            try:
                os.remove(cached)
                log.debug("Cleaned cached archive %s", cached)
            except OSError as exc:
                if exc.errno != errno.ENOENT:
                    log.warning(
                        "Failed to clean cached archive %s: %s", cached, exc.__str__()
                    )
        if strip_components:
            for item in (dirs, files, links):
                for index, path in enumerate(item):
                    try:
                        item[index] = item[index].split(os.sep, strip_components)[
                            strip_components
                        ]
                    except IndexError:
                        item[index] = ""
                item[:] = (x for x in item if x)
                item.sort()
        if verbose:
            ret = {
                "dirs": sorted(salt.utils.data.decode_list(dirs)),
                "files": sorted(salt.utils.data.decode_list(files)),
                "links": sorted(salt.utils.data.decode_list(links)),
            }
            ret["top_level_dirs"] = [x for x in ret["dirs"] if x.count("/") == 1]
            ret["top_level_files"] = [x for x in ret["files"] if x.count("/") == 0]
            ret["top_level_links"] = [x for x in ret["links"] if x.count("/") == 0]
        else:
            ret = sorted(dirs + files + links)
        return ret
    except CommandExecutionError as exc:
        info = exc.info or {}
        info["archive location"] = cached
        raise CommandExecutionError(exc.error, info=info)
_glob_wildcards = re.compile("[*?[]")
def _glob(pathname):
    """
    In case ``pathname`` contains glob wildcards, performs expansion and returns
    the possibly empty list of matching pathnames. Otherwise returns a list that
    contains only ``pathname`` itself.
    """
    if _glob_wildcards.search(pathname) is None:
        return [pathname]
    else:
        return glob.glob(pathname)
def _expand_sources(sources):
    """
    Expands a user-provided specification of source files into a list of paths.
    """
    if sources is None:
        return []
    if isinstance(sources, str):
        sources = [x.strip() for x in sources.split(",")]
    elif isinstance(sources, (float, int)):
        sources = [str(sources)]
    return [path for source in sources for path in _glob(source)]
@salt.utils.decorators.path.which("tar")
def tar(options, tarfile, sources=None, dest=None, cwd=None, template=None, runas=None):
    """
    .. note::
        This function has changed for version 0.17.0. In prior versions, the
        ``cwd`` and ``template`` arguments must be specified, with the source
        directories/files coming as a space-separated list at the end of the
        command. Beginning with 0.17.0, ``sources`` must be a comma-separated
        list, and the ``cwd`` and ``template`` arguments are optional.
    Uses the tar command to pack, unpack, etc. tar files
    options
        Options to pass to the tar command
        .. versionchanged:: 2015.8.0
            The mandatory `-` prefixing has been removed.  An options string
            beginning with a `--long-option`, would have uncharacteristically
            needed its first `-` removed under the former scheme.
            Also, tar will parse its options differently if short options are
            used with or without a preceding `-`, so it is better to not
            confuse the user into thinking they're using the non-`-` format,
            when really they are using the with-`-` format.
    tarfile
        The filename of the tar archive to pack/unpack
    sources
        Comma delimited list of files to **pack** into the tarfile. Can also be
        passed as a Python list.
        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument
    dest
        The destination directory into which to **unpack** the tarfile
    cwd : None
        The directory in which the tar command should be executed. If not
        specified, will default to the home directory of the user under which
        the salt minion process is running.
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.tar cjvf /tmp/salt.tar.bz2 {{grains.saltpath}} template=jinja
    CLI Examples:
    .. code-block:: bash
        salt '*' archive.tar cjvf /tmp/tarfile.tar.bz2 /tmp/file_1,/tmp/file_2
        salt '*' archive.tar cjvf /tmp/tarfile.tar.bz2 '/tmp/file_*'
        salt '*' archive.tar xf foo.tar dest=/target/directory
    """
    if not options:
        raise SaltInvocationError("Tar options can not be empty")
    cmd = ["tar"]
    if options:
        cmd.extend(options.split())
    cmd.extend(["{}".format(tarfile)])
    cmd.extend(_expand_sources(sources))
    if dest:
        cmd.extend(["-C", "{}".format(dest)])
    return __salt__["cmd.run"](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which("gzip")
def gzip(sourcefile, template=None, runas=None, options=None):
    """
    Uses the gzip command to create gzip files
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.gzip template=jinja /tmp/{{grains.id}}.txt
    runas : None
        The user with which to run the gzip command line
    options : None
        Pass any additional arguments to gzip
        .. versionadded:: 2016.3.4
    CLI Example:
    .. code-block:: bash
        salt '*' archive.gzip /tmp/sourcefile.txt
        salt '*' archive.gzip /tmp/sourcefile.txt options='-9 --verbose'
    """
    cmd = ["gzip"]
    if options:
        cmd.append(options)
    cmd.append("{}".format(sourcefile))
    return __salt__["cmd.run"](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which("gunzip")
def gunzip(gzipfile, template=None, runas=None, options=None):
    """
    Uses the gunzip command to unpack gzip files
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.gunzip template=jinja /tmp/{{grains.id}}.txt.gz
    runas : None
        The user with which to run the gzip command line
    options : None
        Pass any additional arguments to gzip
        .. versionadded:: 2016.3.4
    CLI Example:
    .. code-block:: bash
        salt '*' archive.gunzip /tmp/sourcefile.txt.gz
        salt '*' archive.gunzip /tmp/sourcefile.txt options='--verbose'
    """
    cmd = ["gunzip"]
    if options:
        cmd.append(options)
    cmd.append("{}".format(gzipfile))
    return __salt__["cmd.run"](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which("zip")
def cmd_zip(zip_file, sources, template=None, cwd=None, runas=None):
    """
    .. versionadded:: 2015.5.0
        In versions 2014.7.x and earlier, this function was known as
        ``archive.zip``.
    Uses the ``zip`` command to create zip files. This command is part of the
    `Info-ZIP`_ suite of tools, and is typically packaged as simply ``zip``.
    .. _`Info-ZIP`: http://www.info-zip.org/
    zip_file
        Path of zip file to be created
    sources
        Comma-separated list of sources to include in the zip file. Sources can
        also be passed in a Python list.
        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.cmd_zip template=jinja /tmp/zipfile.zip /tmp/sourcefile1,/tmp/{{grains.id}}.txt
    cwd : None
        Use this argument along with relative paths in ``sources`` to create
        zip files which do not contain the leading directories. If not
        specified, the zip file will be created as if the cwd was ``/``, and
        creating a zip file of ``/foo/bar/baz.txt`` will contain the parent
        directories ``foo`` and ``bar``. To create a zip file containing just
        ``baz.txt``, the following command would be used:
        .. code-block:: bash
            salt '*' archive.cmd_zip /tmp/baz.zip baz.txt cwd=/foo/bar
        .. versionadded:: 2014.7.1
    runas : None
        Create the zip file as the specified user. Defaults to the user under
        which the minion is running.
        .. versionadded:: 2015.5.0
    CLI Example:
    .. code-block:: bash
        salt '*' archive.cmd_zip /tmp/zipfile.zip /tmp/sourcefile1,/tmp/sourcefile2
        salt '*' archive.cmd_zip /tmp/zipfile.zip '/tmp/sourcefile*'
    """
    cmd = ["zip", "-r"]
    cmd.append("{}".format(zip_file))
    cmd.extend(_expand_sources(sources))
    return __salt__["cmd.run"](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.depends("zipfile", fallback_function=cmd_zip)
def zip_(zip_file, sources, template=None, cwd=None, runas=None, zip64=False):
    """
    Uses the ``zipfile`` Python module to create zip files
    .. versionchanged:: 2015.5.0
        This function was rewritten to use Python's native zip file support.
        The old functionality has been preserved in the new function
        :mod:`archive.cmd_zip &lt;salt.modules.archive.cmd_zip&gt;`. For versions
        2014.7.x and earlier, see the :mod:`archive.cmd_zip
        &lt;salt.modules.archive.cmd_zip&gt;` documentation.
    zip_file
        Path of zip file to be created
    sources
        Comma-separated list of sources to include in the zip file. Sources can
        also be passed in a Python list.
        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.zip template=jinja /tmp/zipfile.zip /tmp/sourcefile1,/tmp/{{grains.id}}.txt
    cwd : None
        Use this argument along with relative paths in ``sources`` to create
        zip files which do not contain the leading directories. If not
        specified, the zip file will be created as if the cwd was ``/``, and
        creating a zip file of ``/foo/bar/baz.txt`` will contain the parent
        directories ``foo`` and ``bar``. To create a zip file containing just
        ``baz.txt``, the following command would be used:
        .. code-block:: bash
            salt '*' archive.zip /tmp/baz.zip baz.txt cwd=/foo/bar
    runas : None
        Create the zip file as the specified user. Defaults to the user under
        which the minion is running.
    zip64 : False
        Used to enable ZIP64 support, necessary to create archives larger than
        4 GByte in size.
        If true, will create ZIP file with the ZIPp64 extension when the zipfile
        is larger than 2 GB.
        ZIP64 extension is disabled by default in the Python native zip support
        because the default zip and unzip commands on Unix (the InfoZIP utilities)
        don't support these extensions.
    CLI Example:
    .. code-block:: bash
        salt '*' archive.zip /tmp/zipfile.zip /tmp/sourcefile1,/tmp/sourcefile2
        salt '*' archive.zip /tmp/zipfile.zip '/tmp/sourcefile*'
    """
    if runas:
        euid = os.geteuid()
        egid = os.getegid()
        uinfo = __salt__["user.info"](runas)
        if not uinfo:
            raise SaltInvocationError("User '{}' does not exist".format(runas))
    zip_file, sources = _render_filenames(zip_file, sources, None, template)
    sources = _expand_sources(sources)
    if not cwd:
        for src in sources:
            if not os.path.isabs(src):
                raise SaltInvocationError("Relative paths require the 'cwd' parameter")
    else:
        err_msg = "cwd must be absolute"
        try:
            if not os.path.isabs(cwd):
                raise SaltInvocationError(err_msg)
        except AttributeError:
            raise SaltInvocationError(err_msg)
    if runas and (euid != uinfo["uid"] or egid != uinfo["gid"]):
        os.setegid(uinfo["gid"])
        os.seteuid(uinfo["uid"])
    try:
        exc = None
        archived_files = []
        with contextlib.closing(
            zipfile.ZipFile(zip_file, "w", zipfile.ZIP_DEFLATED, zip64)
        ) as zfile:
            for src in sources:
                if cwd:
                    src = os.path.join(cwd, src)
                if os.path.exists(src):
                    if os.path.isabs(src):
                        rel_root = "/"
                    else:
                        rel_root = cwd if cwd is not None else "/"
                    if os.path.isdir(src):
                        for dir_name, sub_dirs, files in salt.utils.path.os_walk(src):
                            if cwd and dir_name.startswith(cwd):
                                arc_dir = os.path.relpath(dir_name, cwd)
                            else:
                                arc_dir = os.path.relpath(dir_name, rel_root)
                            if arc_dir:
                                archived_files.append(arc_dir + "/")
                                zfile.write(dir_name, arc_dir)
                            for filename in files:
                                abs_name = os.path.join(dir_name, filename)
                                arc_name = os.path.join(arc_dir, filename)
                                archived_files.append(arc_name)
                                zfile.write(abs_name, arc_name)
                    else:
                        if cwd and src.startswith(cwd):
                            arc_name = os.path.relpath(src, cwd)
                        else:
                            arc_name = os.path.relpath(src, rel_root)
                        archived_files.append(arc_name)
                        zfile.write(src, arc_name)
    except Exception as exc:  # pylint: disable=broad-except
        pass
    finally:
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
        if exc is not None:
            if exc == zipfile.LargeZipFile:
                raise CommandExecutionError(
                    "Resulting zip file too large, would require ZIP64 support"
                    "which has not been enabled. Rerun command with zip64=True"
                )
            else:
                raise CommandExecutionError(
                    "Exception encountered creating zipfile: {}".format(exc)
                )
    return archived_files
@salt.utils.decorators.path.which("unzip")
def cmd_unzip(
    zip_file,
    dest,
    excludes=None,
    options=None,
    template=None,
    runas=None,
    trim_output=False,
    password=None,
):
    """
    .. versionadded:: 2015.5.0
        In versions 2014.7.x and earlier, this function was known as
        ``archive.unzip``.
    Uses the ``unzip`` command to unpack zip files. This command is part of the
    `Info-ZIP`_ suite of tools, and is typically packaged as simply ``unzip``.
    .. _`Info-ZIP`: http://www.info-zip.org/
    zip_file
        Path of zip file to be unpacked
    dest
        The destination directory into which the file should be unpacked
    excludes : None
        Comma-separated list of files not to unpack. Can also be passed in a
        Python list.
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.cmd_unzip template=jinja /tmp/zipfile.zip '/tmp/{{grains.id}}' excludes=file_1,file_2
    options
        Optional when using ``zip`` archives, ignored when usign other archives
        files. This is mostly used to overwrite existing files with ``o``.
        This options are only used when ``unzip`` binary is used.
        .. versionadded:: 2016.3.1
    runas : None
        Unpack the zip file as the specified user. Defaults to the user under
        which the minion is running.
        .. versionadded:: 2015.5.0
    trim_output : False
        The number of files we should output on success before the rest are trimmed, if this is
        set to True then it will default to 100
    password
        Password to use with password protected zip files
        .. note::
            This is not considered secure. It is recommended to instead use
            :py:func:`archive.unzip &lt;salt.modules.archive.unzip&gt;` for
            password-protected ZIP files. If a password is used here, then the
            unzip command run to extract the ZIP file will not show up in the
            minion log like most shell commands Salt runs do. However, the
            password will still be present in the events logged to the minion
            log at the ``debug`` log level. If the minion is logging at
            ``debug`` (or more verbose), then be advised that the password will
            appear in the log.
        .. versionadded:: 2016.11.0
    CLI Example:
    .. code-block:: bash
        salt '*' archive.cmd_unzip /tmp/zipfile.zip /home/strongbad/ excludes=file_1,file_2
    """
    if isinstance(excludes, str):
        excludes = [x.strip() for x in excludes.split(",")]
    elif isinstance(excludes, (float, int)):
        excludes = [str(excludes)]
    cmd = ["unzip"]
    if password:
        cmd.extend(["-P", password])
    if options:
        cmd.extend(shlex.split(options))
    cmd.extend(["{}".format(zip_file), "-d", "{}".format(dest)])
    if excludes is not None:
        cmd.append("-x")
        cmd.extend(excludes)
    result = __salt__["cmd.run_all"](
        cmd,
        template=template,
        runas=runas,
        python_shell=False,
        redirect_stderr=True,
        output_loglevel="quiet" if password else "debug",
    )
    if result["retcode"] != 0:
        raise CommandExecutionError(result["stdout"])
    return _trim_files(result["stdout"].splitlines(), trim_output)
def unzip(
    zip_file,
    dest,
    excludes=None,
    options=None,
    template=None,
    runas=None,
    trim_output=False,
    password=None,
    extract_perms=True,
):
    """
    Uses the ``zipfile`` Python module to unpack zip files
    .. versionchanged:: 2015.5.0
        This function was rewritten to use Python's native zip file support.
        The old functionality has been preserved in the new function
        :mod:`archive.cmd_unzip &lt;salt.modules.archive.cmd_unzip&gt;`. For versions
        2014.7.x and earlier, see the :mod:`archive.cmd_zip
        &lt;salt.modules.archive.cmd_zip&gt;` documentation.
    zip_file
        Path of zip file to be unpacked
    dest
        The destination directory into which the file should be unpacked
    excludes : None
        Comma-separated list of files not to unpack. Can also be passed in a
        Python list.
    options
        This options are only used when ``unzip`` binary is used. In this
        function is ignored.
        .. versionadded:: 2016.3.1
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.unzip template=jinja /tmp/zipfile.zip /tmp/{{grains.id}}/ excludes=file_1,file_2
    runas : None
        Unpack the zip file as the specified user. Defaults to the user under
        which the minion is running.
    trim_output : False
        The number of files we should output on success before the rest are trimmed, if this is
        set to True then it will default to 100
    CLI Example:
    .. code-block:: bash
        salt '*' archive.unzip /tmp/zipfile.zip /home/strongbad/ excludes=file_1,file_2
    password
        Password to use with password protected zip files
        .. note::
            The password will be present in the events logged to the minion log
            file at the ``debug`` log level. If the minion is logging at
            ``debug`` (or more verbose), then be advised that the password will
            appear in the log.
        .. versionadded:: 2016.3.0
    extract_perms : True
        The Python zipfile_ module does not extract file/directory attributes
        by default. When this argument is set to ``True``, Salt will attempt to
        apply the file permission attributes to the extracted files/folders.
        On Windows, only the read-only flag will be extracted as set within the
        zip file, other attributes (i.e. user/group permissions) are ignored.
        Set this argument to ``False`` to disable this behavior.
        .. versionadded:: 2016.11.0
    .. _zipfile: https://docs.python.org/2/library/zipfile.html
    CLI Example:
    .. code-block:: bash
        salt '*' archive.unzip /tmp/zipfile.zip /home/strongbad/ password='BadPassword'
    """
    if not excludes:
        excludes = []
    if runas:
        euid = os.geteuid()
        egid = os.getegid()
        uinfo = __salt__["user.info"](runas)
        if not uinfo:
            raise SaltInvocationError("User '{}' does not exist".format(runas))
    zip_file, dest = _render_filenames(zip_file, dest, None, template)
    if runas and (euid != uinfo["uid"] or egid != uinfo["gid"]):
        os.setegid(uinfo["gid"])
        os.seteuid(uinfo["uid"])
    try:
        cleaned_files = []
        with contextlib.closing(zipfile.ZipFile(zip_file, "r")) as zfile:
            files = zfile.namelist()
            if isinstance(excludes, str):
                excludes = [x.strip() for x in excludes.split(",")]
            elif isinstance(excludes, (float, int)):
                excludes = [str(excludes)]
            cleaned_files.extend([x for x in files if x not in excludes])
            for target in cleaned_files:
                if target not in excludes:
                    if salt.utils.platform.is_windows() is False:
                        info = zfile.getinfo(target)
                        if stat.S_ISLNK(info.external_attr &gt;&gt; 16):
                            source = zfile.read(target)
                            os.symlink(source, os.path.join(dest, target))
                            continue
                    zfile.extract(target, dest, password)
                    if extract_perms:
                        if not salt.utils.platform.is_windows():
                            perm = zfile.getinfo(target).external_attr &gt;&gt; 16
                            if perm == 0:
                                umask_ = salt.utils.files.get_umask()
                                if target.endswith("/"):
                                    perm = 0o777 &amp; ~umask_
                                else:
                                    perm = 0o666 &amp; ~umask_
                            os.chmod(os.path.join(dest, target), perm)
                        else:
                            win32_attr = zfile.getinfo(target).external_attr &amp; 0xFF
                            win32file.SetFileAttributes(
                                os.path.join(dest, target), win32_attr
                            )
    except Exception as exc:  # pylint: disable=broad-except
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
        raise CommandExecutionError(
            "Exception encountered unpacking zipfile: {}".format(exc)
        )
    finally:
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
    return _trim_files(cleaned_files, trim_output)
def is_encrypted(name, clean=False, saltenv="base", source_hash=None, use_etag=False):
    """
    .. versionadded:: 2016.11.0
    .. versionchanged:: 3005
    Returns ``True`` if the zip archive is password-protected, ``False`` if
    not. If the specified file is not a ZIP archive, an error will be raised.
    name
        The path / URL of the archive to check.
    clean : False
        Set this value to ``True`` to delete the path referred to by ``name``
        once the contents have been listed. This option should be used with
        care.
        .. note::
            If there is an error listing the archive's contents, the cached
            file will not be removed, to allow for troubleshooting.
    saltenv : base
        Specifies the fileserver environment from which to retrieve
        ``archive``. This is only applicable when ``archive`` is a file from
        the ``salt://`` fileserver.
    source_hash
        If ``name`` is an http(s)/ftp URL and the file exists in the minion's
        file cache, this option can be passed to keep the minion from
        re-downloading the archive if the cached copy matches the specified
        hash.
        .. versionadded:: 2018.3.0
    use_etag
        If ``True``, remote http/https file sources will attempt to use the
        ETag header to determine if the remote file needs to be downloaded.
        This provides a lightweight mechanism for promptly refreshing files
        changed on a web server without requiring a full hash comparison via
        the ``source_hash`` parameter.
        .. versionadded:: 3005
    CLI Examples:
    .. code-block:: bash
            salt '*' archive.is_encrypted /path/to/myfile.zip
            salt '*' archive.is_encrypted salt://foo.zip
            salt '*' archive.is_encrypted salt://foo.zip saltenv=dev
            salt '*' archive.is_encrypted https://domain.tld/myfile.zip clean=True
            salt '*' archive.is_encrypted https://domain.tld/myfile.zip source_hash=f1d2d2f924e986ac86fdf7b36c94bcdf32beec15
            salt '*' archive.is_encrypted ftp://10.1.2.3/foo.zip
    """
    cached = __salt__["cp.cache_file"](
        name, saltenv, source_hash=source_hash, use_etag=use_etag
    )
    if not cached:
        raise CommandExecutionError("Failed to cache {}".format(name))
    archive_info = {"archive location": cached}
    try:
        with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
            zip_archive.testzip()
    except RuntimeError:
        ret = True
    except zipfile.BadZipfile:
        raise CommandExecutionError(
            "{} is not a ZIP file".format(name), info=archive_info
        )
    except Exception as exc:  # pylint: disable=broad-except
        raise CommandExecutionError(exc.__str__(), info=archive_info)
    else:
        ret = False
    if clean:
        try:
            os.remove(cached)
            log.debug("Cleaned cached archive %s", cached)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                log.warning(
                    "Failed to clean cached archive %s: %s", cached, exc.__str__()
                )
    return ret
@salt.utils.decorators.path.which("rar")
def rar(rarfile, sources, template=None, cwd=None, runas=None):
    """
    Uses `rar for Linux`_ to create rar files
    .. _`rar for Linux`: http://www.rarlab.com/
    rarfile
        Path of rar file to be created
    sources
        Comma-separated list of sources to include in the rar file. Sources can
        also be passed in a Python list.
        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument
    cwd : None
        Run the rar command from the specified directory. Use this argument
        along with relative file paths to create rar files which do not
        contain the leading directories. If not specified, this will default
        to the home directory of the user under which the salt minion process
        is running.
        .. versionadded:: 2014.7.1
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.rar template=jinja /tmp/rarfile.rar '/tmp/sourcefile1,/tmp/{{grains.id}}.txt'
    CLI Example:
    .. code-block:: bash
        salt '*' archive.rar /tmp/rarfile.rar /tmp/sourcefile1,/tmp/sourcefile2
        salt '*' archive.rar /tmp/rarfile.rar '/tmp/sourcefile*'
    """
    cmd = ["rar", "a", "-idp", "{}".format(rarfile)]
    cmd.extend(_expand_sources(sources))
    return __salt__["cmd.run"](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which_bin(("unrar", "rar"))
def unrar(rarfile, dest, excludes=None, template=None, runas=None, trim_output=False):
    """
    Uses `rar for Linux`_ to unpack rar files
    .. _`rar for Linux`: http://www.rarlab.com/
    rarfile
        Name of rar file to be unpacked
    dest
        The destination directory into which to **unpack** the rar file
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.unrar template=jinja /tmp/rarfile.rar /tmp/{{grains.id}}/ excludes=file_1,file_2
    trim_output : False
        The number of files we should output on success before the rest are trimmed, if this is
        set to True then it will default to 100
    CLI Example:
    .. code-block:: bash
        salt '*' archive.unrar /tmp/rarfile.rar /home/strongbad/ excludes=file_1,file_2
    """
    if isinstance(excludes, str):
        excludes = [entry.strip() for entry in excludes.split(",")]
    cmd = [
        salt.utils.path.which_bin(("unrar", "rar")),
        "x",
        "-idp",
        "{}".format(rarfile),
    ]
    if excludes is not None:
        for exclude in excludes:
            cmd.extend(["-x", "{}".format(exclude)])
    cmd.append("{}".format(dest))
    files = __salt__["cmd.run"](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()
    return _trim_files(files, trim_output)
def _render_filenames(filenames, zip_file, saltenv, template):
    """
    Process markup in the :param:`filenames` and :param:`zipfile` variables (NOT the
    files under the paths they ultimately point to) according to the markup
    format provided by :param:`template`.
    """
    if not template:
        return (filenames, zip_file)
    if template not in salt.utils.templates.TEMPLATE_REGISTRY:
        raise CommandExecutionError(
            "Attempted to render file paths with unavailable engine {}".format(template)
        )
    kwargs = {}
    kwargs["salt"] = __salt__
    kwargs["pillar"] = __pillar__
    kwargs["grains"] = __grains__
    kwargs["opts"] = __opts__
    kwargs["saltenv"] = saltenv
    def _render(contents):
        """
        Render :param:`contents` into a literal pathname by writing it to a
        temp file, rendering that file, and returning the result.
        """
        tmp_path_fn = salt.utils.files.mkstemp()
        with salt.utils.files.fopen(tmp_path_fn, "w+") as fp_:
            fp_.write(salt.utils.stringutils.to_str(contents))
        data = salt.utils.templates.TEMPLATE_REGISTRY[template](
            tmp_path_fn, to_str=True, **kwargs
        )
        salt.utils.files.safe_rm(tmp_path_fn)
        if not data["result"]:
            raise CommandExecutionError(
                "Failed to render file path with error: {}".format(data["data"])
            )
        else:
            return data["data"]
    filenames = _render(filenames)
    zip_file = _render(zip_file)
    return (filenames, zip_file)
def _trim_files(files, trim_output):
    """
    Trim the file list for output.
    """
    count = 100
    if not isinstance(trim_output, bool):
        count = trim_output
    if (
        not (isinstance(trim_output, bool) and trim_output is False)
        and len(files) &gt; count
    ):
        files = files[:count]
        files.append("List trimmed after {} files.".format(count))
    return files
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_vsphere.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Nicole Thomas &lt;nicole@saltstack.com&gt;
    :codeauthor: Alexandru Bleotu &lt;alexandru.bleotu@morganstanley.com&gt;
"""
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.modules.vsphere as vsphere
import salt.utils.args
import salt.utils.vmware
from salt.exceptions import (
    ArgumentValueError,
    CommandExecutionError,
    VMwareObjectRetrievalError,
    VMwareSaltError,
)
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, Mock, call, patch
from tests.support.unit import TestCase, skipIf
try:
    from pyVmomi import vim, vmodl  # pylint: disable=unused-import,no-name-in-module
    HAS_PYVMOMI = True
except ImportError:
    HAS_PYVMOMI =</b></font> False
try:
    from com.vmware.vapi.std_client import DynamicID  # pylint: disable=unused-import
    HAS_VSPHERE_SDK = True
except ImportError:
    HAS_VSPHERE_SDK = False
HOST = "1.2.3.4"
USER = "root"
PASSWORD = "SuperSecret!"
ERROR = "Some Testing Error Message"
class VsphereTestCase(TestCase, LoaderModuleMockMixin):
    """
    Unit TestCase for the salt.modules.vsphere module.
    """
    def setup_loader_modules(self):
        return {vsphere: {}}
    def test_get_coredump_network_config_esxi_hosts_not_list(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.get_coredump_network_config,
            HOST,
            USER,
            PASSWORD,
            esxi_hosts="foo",
        )
    def test_get_coredump_network_config_host_list_bad_retcode(self):
        """
        Tests error message returned with list of esxi_hosts.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {host_1: {"Error": ERROR}},
                vsphere.get_coredump_network_config(
                    HOST, USER, PASSWORD, esxi_hosts=[host_1]
                ),
            )
    def test_get_coredump_network_config_host_list_success(self):
        """
        Tests successful function return when an esxi_host is provided.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            with patch(
                "salt.modules.vsphere._format_coredump_stdout",
                MagicMock(return_value={}),
            ):
                host_1 = "host_1.foo.com"
                self.assertEqual(
                    {host_1: {"Coredump Config": {}}},
                    vsphere.get_coredump_network_config(
                        HOST, USER, PASSWORD, esxi_hosts=[host_1]
                    ),
                )
    def test_get_coredump_network_config_bad_retcode(self):
        """
        Tests error message given for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            self.assertEqual(
                {HOST: {"Error": ERROR}},
                vsphere.get_coredump_network_config(HOST, USER, PASSWORD),
            )
    def test_get_coredump_network_config_success(self):
        """
        Tests successful function return for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            with patch(
                "salt.modules.vsphere._format_coredump_stdout",
                MagicMock(return_value={}),
            ):
                self.assertEqual(
                    {HOST: {"Coredump Config": {}}},
                    vsphere.get_coredump_network_config(HOST, USER, PASSWORD),
                )
    def test_coredump_network_enable_esxi_hosts_not_list(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.coredump_network_enable,
            HOST,
            USER,
            PASSWORD,
            True,
            esxi_hosts="foo",
        )
    def test_coredump_network_enable_host_list_bad_retcode(self):
        """
        Tests error message returned with list of esxi_hosts.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {host_1: {"Error": ERROR}},
                vsphere.coredump_network_enable(
                    HOST, USER, PASSWORD, True, esxi_hosts=[host_1]
                ),
            )
    def test_coredump_network_enable_host_list_success(self):
        """
        Tests successful function return when an esxi_host is provided.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            with patch(
                "salt.modules.vsphere._format_coredump_stdout",
                MagicMock(return_value={}),
            ):
                enabled = True
                host_1 = "host_1.foo.com"
                self.assertEqual(
                    {host_1: {"Coredump Enabled": enabled}},
                    vsphere.coredump_network_enable(
                        HOST, USER, PASSWORD, enabled, esxi_hosts=[host_1]
                    ),
                )
    def test_coredump_network_enable_bad_retcode(self):
        """
        Tests error message given for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            self.assertEqual(
                {HOST: {"Error": ERROR}},
                vsphere.coredump_network_enable(HOST, USER, PASSWORD, True),
            )
    def test_coredump_network_enable_success(self):
        """
        Tests successful function return for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            with patch(
                "salt.modules.vsphere._format_coredump_stdout",
                MagicMock(return_value={}),
            ):
                enabled = True
                self.assertEqual(
                    {HOST: {"Coredump Enabled": enabled}},
                    vsphere.coredump_network_enable(HOST, USER, PASSWORD, enabled),
                )
    def test_set_coredump_network_config_esxi_hosts_not_list(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.set_coredump_network_config,
            HOST,
            USER,
            PASSWORD,
            "loghost",
            "foo",
            esxi_hosts="bar",
        )
    def test_set_coredump_network_config_host_list_bad_retcode(self):
        """
        Tests error message returned with list of esxi_hosts.
        """
        with patch("salt.utils.vmware.esxcli", MagicMock(return_value={"retcode": 1})):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {host_1: {"retcode": 1, "success": False}},
                vsphere.set_coredump_network_config(
                    HOST, USER, PASSWORD, "dump-ip.test.com", esxi_hosts=[host_1]
                ),
            )
    def test_set_coredump_network_config_host_list_success(self):
        """
        Tests successful function return when an esxi_host is provided.
        """
        with patch("salt.utils.vmware.esxcli", MagicMock(return_value={"retcode": 0})):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {host_1: {"retcode": 0, "success": True}},
                vsphere.set_coredump_network_config(
                    HOST, USER, PASSWORD, "dump-ip.test.com", esxi_hosts=[host_1]
                ),
            )
    def test_set_coredump_network_config_bad_retcode(self):
        """
        Tests error message given for a single ESXi host.
        """
        with patch("salt.utils.vmware.esxcli", MagicMock(return_value={"retcode": 1})):
            self.assertEqual(
                {HOST: {"retcode": 1, "success": False}},
                vsphere.set_coredump_network_config(
                    HOST, USER, PASSWORD, "dump-ip.test.com"
                ),
            )
    def test_set_coredump_network_config_success(self):
        """
        Tests successful function return for a single ESXi host.
        """
        with patch("salt.utils.vmware.esxcli", MagicMock(return_value={"retcode": 0})):
            self.assertEqual(
                {HOST: {"retcode": 0, "success": True}},
                vsphere.set_coredump_network_config(
                    HOST, USER, PASSWORD, "dump-ip.test.com"
                ),
            )
    def test_get_firewall_status_esxi_hosts_not_list(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.get_firewall_status,
            HOST,
            USER,
            PASSWORD,
            esxi_hosts="foo",
        )
    def test_get_firewall_status_host_list_bad_retcode(self):
        """
        Tests error message returned with list of esxi_hosts.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {host_1: {"success": False, "Error": ERROR, "rulesets": None}},
                vsphere.get_firewall_status(HOST, USER, PASSWORD, esxi_hosts=[host_1]),
            )
    def test_get_firewall_status_host_list_success(self):
        """
        Tests successful function return when an esxi_host is provided.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {host_1: {"rulesets": {}, "success": True}},
                vsphere.get_firewall_status(HOST, USER, PASSWORD, esxi_hosts=[host_1]),
            )
    def test_get_firewall_status_bad_retcode(self):
        """
        Tests error message given for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            self.assertEqual(
                {HOST: {"success": False, "Error": ERROR, "rulesets": None}},
                vsphere.get_firewall_status(HOST, USER, PASSWORD),
            )
    def test_get_firewall_status_success(self):
        """
        Tests successful function return for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            self.assertEqual(
                {HOST: {"rulesets": {}, "success": True}},
                vsphere.get_firewall_status(HOST, USER, PASSWORD),
            )
    def test_enable_firewall_ruleset_esxi_hosts_not_list(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.enable_firewall_ruleset,
            HOST,
            USER,
            PASSWORD,
            "foo",
            "bar",
            esxi_hosts="baz",
        )
    def test_syslog_service_reload_esxi_hosts_not_list(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.syslog_service_reload,
            HOST,
            USER,
            PASSWORD,
            esxi_hosts="foo",
        )
    def test_set_syslog_config_esxi_hosts_not_list(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list, but we don't enter the 'loghost'/firewall loop.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.set_syslog_config,
            HOST,
            USER,
            PASSWORD,
            "foo",
            "bar",
            esxi_hosts="baz",
        )
    def test_set_syslog_config_esxi_hosts_not_list_firewall(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list, and we enter the 'loghost'/firewall loop.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.set_syslog_config,
            HOST,
            USER,
            PASSWORD,
            "loghost",
            "foo",
            firewall=True,
            esxi_hosts="bar",
        )
    def test_set_syslog_config_host_list_firewall_bad_retcode(self):
        """
        Tests error message returned with list of esxi_hosts with 'loghost' as syslog_config.
        """
        with patch(
            "salt.modules.vsphere.enable_firewall_ruleset",
            MagicMock(return_value={"host_1.foo.com": {"retcode": 1, "stdout": ERROR}}),
        ):
            with patch(
                "salt.modules.vsphere._set_syslog_config_helper",
                MagicMock(return_value={}),
            ):
                host_1 = "host_1.foo.com"
                self.assertEqual(
                    {host_1: {"enable_firewall": {"message": ERROR, "success": False}}},
                    vsphere.set_syslog_config(
                        HOST,
                        USER,
                        PASSWORD,
                        "loghost",
                        "foo",
                        firewall=True,
                        esxi_hosts=[host_1],
                    ),
                )
    def test_set_syslog_config_host_list_firewall_success(self):
        """
        Tests successful function return with list of esxi_hosts with 'loghost' as syslog_config.
        """
        with patch(
            "salt.modules.vsphere.enable_firewall_ruleset",
            MagicMock(return_value={"host_1.foo.com": {"retcode": 0}}),
        ):
            with patch(
                "salt.modules.vsphere._set_syslog_config_helper",
                MagicMock(return_value={}),
            ):
                host_1 = "host_1.foo.com"
                self.assertEqual(
                    {host_1: {"enable_firewall": {"success": True}}},
                    vsphere.set_syslog_config(
                        HOST,
                        USER,
                        PASSWORD,
                        "loghost",
                        "foo",
                        firewall=True,
                        esxi_hosts=[host_1],
                    ),
                )
    def test_set_syslog_config_firewall_bad_retcode(self):
        """
        Tests error message given for a single ESXi host with 'loghost' as syslog_config.
        """
        with patch(
            "salt.modules.vsphere.enable_firewall_ruleset",
            MagicMock(return_value={HOST: {"retcode": 1, "stdout": ERROR}}),
        ):
            with patch(
                "salt.modules.vsphere._set_syslog_config_helper",
                MagicMock(return_value={}),
            ):
                self.assertEqual(
                    {HOST: {"enable_firewall": {"message": ERROR, "success": False}}},
                    vsphere.set_syslog_config(
                        HOST, USER, PASSWORD, "loghost", "foo", firewall=True
                    ),
                )
    def test_set_syslog_config_firewall_success(self):
        """
        Tests successful function return for a single ESXi host with 'loghost' as syslog_config.
        """
        with patch(
            "salt.modules.vsphere.enable_firewall_ruleset",
            MagicMock(return_value={HOST: {"retcode": 0}}),
        ):
            with patch(
                "salt.modules.vsphere._set_syslog_config_helper",
                MagicMock(return_value={}),
            ):
                self.assertEqual(
                    {HOST: {"enable_firewall": {"success": True}}},
                    vsphere.set_syslog_config(
                        HOST, USER, PASSWORD, "loghost", "foo", firewall=True
                    ),
                )
    def test_get_syslog_config_esxi_hosts_not_list(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.get_syslog_config,
            HOST,
            USER,
            PASSWORD,
            esxi_hosts="foo",
        )
    def test_get_syslog_config_host_list_bad_retcode(self):
        """
        Tests error message returned with list of esxi_hosts.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {host_1: {"message": ERROR, "success": False}},
                vsphere.get_syslog_config(HOST, USER, PASSWORD, esxi_hosts=[host_1]),
            )
    def test_get_syslog_config_host_list_success(self):
        """
        Tests successful function return when an esxi_host is provided.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {host_1: {"success": True}},
                vsphere.get_syslog_config(HOST, USER, PASSWORD, esxi_hosts=[host_1]),
            )
    def test_get_syslog_config_bad_retcode(self):
        """
        Tests error message given for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            self.assertEqual(
                {HOST: {"message": ERROR, "success": False}},
                vsphere.get_syslog_config(HOST, USER, PASSWORD),
            )
    def test_get_syslog_config_success(self):
        """
        Tests successful function return for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            self.assertEqual(
                {HOST: {"success": True}},
                vsphere.get_syslog_config(HOST, USER, PASSWORD),
            )
    def test_reset_syslog_config_no_syslog_config(self):
        """
        Tests CommandExecutionError is raised when a syslog_config parameter is missing.
        """
        self.assertRaises(
            CommandExecutionError, vsphere.reset_syslog_config, HOST, USER, PASSWORD
        )
    def test_reset_syslog_config_esxi_hosts_not_list(self):
        """
        Tests CommandExecutionError is raised when esxi_hosts is provided,
        but is not a list.
        """
        self.assertRaises(
            CommandExecutionError,
            vsphere.reset_syslog_config,
            HOST,
            USER,
            PASSWORD,
            syslog_config="test",
            esxi_hosts="foo",
        )
    def test_reset_syslog_config_invalid_config_param(self):
        """
        Tests error message returned when an invalid syslog_config parameter is provided.
        """
        with patch("salt.utils.vmware.esxcli", MagicMock(return_value={})):
            error = "Invalid syslog configuration parameter"
            self.assertEqual(
                {
                    HOST: {
                        "success": False,
                        "test": {"message": error, "success": False},
                    }
                },
                vsphere.reset_syslog_config(HOST, USER, PASSWORD, syslog_config="test"),
            )
    def test_reset_syslog_config_host_list_bad_retcode(self):
        """
        Tests error message returned with list of esxi_hosts.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {
                    host_1: {
                        "success": False,
                        "logdir": {"message": ERROR, "success": False},
                    }
                },
                vsphere.reset_syslog_config(
                    HOST, USER, PASSWORD, syslog_config="logdir", esxi_hosts=[host_1]
                ),
            )
    def test_reset_syslog_config_host_list_success(self):
        """
        Tests successful function return when an esxi_host is provided.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            host_1 = "host_1.foo.com"
            self.assertEqual(
                {host_1: {"success": True, "loghost": {"success": True}}},
                vsphere.reset_syslog_config(
                    HOST, USER, PASSWORD, syslog_config="loghost", esxi_hosts=[host_1]
                ),
            )
    def test_reset_syslog_config_bad_retcode(self):
        """
        Tests error message given for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            self.assertEqual(
                {
                    HOST: {
                        "success": False,
                        "logdir-unique": {"message": ERROR, "success": False},
                    }
                },
                vsphere.reset_syslog_config(
                    HOST, USER, PASSWORD, syslog_config="logdir-unique"
                ),
            )
    def test_reset_syslog_config_success(self):
        """
        Tests successful function return for a single ESXi host.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            self.assertEqual(
                {HOST: {"success": True, "default-rotate": {"success": True}}},
                vsphere.reset_syslog_config(
                    HOST, USER, PASSWORD, syslog_config="default-rotate"
                ),
            )
    def test_reset_syslog_config_success_multiple_configs(self):
        """
        Tests successful function return for a single ESXi host when passing in multiple syslog_config values.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            self.assertEqual(
                {
                    HOST: {
                        "success": True,
                        "default-size": {"success": True},
                        "default-timeout": {"success": True},
                    }
                },
                vsphere.reset_syslog_config(
                    HOST, USER, PASSWORD, syslog_config="default-size,default-timeout"
                ),
            )
    def test_reset_syslog_config_success_all_configs(self):
        """
        Tests successful function return for a single ESXi host when passing in multiple syslog_config values.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 0, "stdout": ""}),
        ):
            self.assertEqual(
                {
                    HOST: {
                        "success": True,
                        "logdir": {"success": True},
                        "loghost": {"success": True},
                        "default-rotate": {"success": True},
                        "default-size": {"success": True},
                        "default-timeout": {"success": True},
                        "logdir-unique": {"success": True},
                    }
                },
                vsphere.reset_syslog_config(HOST, USER, PASSWORD, syslog_config="all"),
            )
    def test_reset_syslog_config_params_no_valid_reset(self):
        """
        Tests function returns False when an invalid syslog config is passed.
        """
        valid_resets = ["hello", "world"]
        config = "foo"
        ret = {
            "success": False,
            config: {
                "success": False,
                "message": "Invalid syslog configuration parameter",
            },
        }
        self.assertEqual(
            ret,
            vsphere._reset_syslog_config_params(
                HOST, USER, PASSWORD, "cmd", config, valid_resets
            ),
        )
    def test_reset_syslog_config_params_error(self):
        """
        Tests function returns False when the esxxli function returns an unsuccessful retcode.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            valid_resets = ["hello", "world"]
            error_dict = {"success": False, "message": ERROR}
            ret = {"success": False, "hello": error_dict, "world": error_dict}
            self.assertDictEqual(
                ret,
                vsphere._reset_syslog_config_params(
                    HOST, USER, PASSWORD, "cmd", valid_resets, valid_resets
                ),
            )
    def test_reset_syslog_config_params_success(self):
        """
        Tests function returns True when the esxxli function returns a successful retcode.
        """
        with patch("salt.utils.vmware.esxcli", MagicMock(return_value={"retcode": 0})):
            valid_resets = ["hello", "world"]
            ret = {
                "success": True,
                "hello": {"success": True},
                "world": {"success": True},
            }
            self.assertDictEqual(
                ret,
                vsphere._reset_syslog_config_params(
                    HOST, USER, PASSWORD, "cmd", valid_resets, valid_resets
                ),
            )
    def test_set_syslog_config_helper_no_valid_reset(self):
        """
        Tests function returns False when an invalid syslog config is passed.
        """
        config = "foo"
        ret = {
            "success": False,
            "message": "'{}' is not a valid config variable.".format(config),
        }
        self.assertEqual(
            ret, vsphere._set_syslog_config_helper(HOST, USER, PASSWORD, config, "bar")
        )
    def test_set_syslog_config_helper_bad_retcode(self):
        """
        Tests function returns False when the esxcli function returns an unsuccessful retcode.
        """
        with patch(
            "salt.utils.vmware.esxcli",
            MagicMock(return_value={"retcode": 1, "stdout": ERROR}),
        ):
            config = "default-rotate"
            self.assertEqual(
                {config: {"success": False, "message": ERROR}},
                vsphere._set_syslog_config_helper(HOST, USER, PASSWORD, config, "foo"),
            )
    def test_set_syslog_config_helper_success(self):
        """
        Tests successful function return.
        """
        with patch("salt.utils.vmware.esxcli", MagicMock(return_value={"retcode": 0})):
            config = "logdir"
            self.assertEqual(
                {config: {"success": True}},
                vsphere._set_syslog_config_helper(HOST, USER, PASSWORD, config, "foo"),
            )
class GetProxyTypeTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.get_proxy_type
    """
    def setup_loader_modules(self):
        return {vsphere: {}}
    def test_output(self):
        with patch.dict(
            vsphere.__pillar__, {"proxy": {"proxytype": "fake_proxy_type"}}
        ):
            ret = vsphere.get_proxy_type()
        self.assertEqual("fake_proxy_type", ret)
class SupportsProxiesTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere._supports_proxies decorator
    """
    def setup_loader_modules(self):
        return {vsphere: {}}
    def test_supported_proxy(self):
        @vsphere._supports_proxies("supported")
        def mock_function():
            return "fake_function"
        with patch(
            "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="supported")
        ):
            ret = mock_function()
        self.assertEqual("fake_function", ret)
    def test_unsupported_proxy(self):
        @vsphere._supports_proxies("supported")
        def mock_function():
            return "fake_function"
        with patch(
            "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="unsupported")
        ):
            with self.assertRaises(CommandExecutionError) as excinfo:
                mock_function()
        self.assertEqual(
            "'unsupported' proxy is not supported by function mock_function",
            excinfo.exception.strerror,
        )
class _GetProxyConnectionDetailsTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere._get_proxy_connection_details
    """
    def setup_loader_modules(self):
        return {vsphere: {}}
    def setUp(self):
        self.esxi_host_details = {
            "host": "fake_host",
            "username": "fake_username",
            "password": "fake_password",
            "protocol": "fake_protocol",
            "port": "fake_port",
            "mechanism": "fake_mechanism",
            "principal": "fake_principal",
            "domain": "fake_domain",
        }
        self.esxi_vcenter_details = {
            "vcenter": "fake_vcenter",
            "username": "fake_username",
            "password": "fake_password",
            "protocol": "fake_protocol",
            "port": "fake_port",
            "mechanism": "fake_mechanism",
            "principal": "fake_principal",
            "domain": "fake_domain",
        }
        self.esxdatacenter_details = {
            "vcenter": "fake_vcenter",
            "datacenter": "fake_dc",
            "username": "fake_username",
            "password": "fake_password",
            "protocol": "fake_protocol",
            "port": "fake_port",
            "mechanism": "fake_mechanism",
            "principal": "fake_principal",
            "domain": "fake_domain",
        }
        self.esxcluster_details = {
            "vcenter": "fake_vcenter",
            "datacenter": "fake_dc",
            "cluster": "fake_cluster",
            "username": "fake_username",
            "password": "fake_password",
            "protocol": "fake_protocol",
            "port": "fake_port",
            "mechanism": "fake_mechanism",
            "principal": "fake_principal",
            "domain": "fake_domain",
        }
        self.vcenter_details = {
            "vcenter": "fake_vcenter",
            "username": "fake_username",
            "password": "fake_password",
            "protocol": "fake_protocol",
            "port": "fake_port",
            "mechanism": "fake_mechanism",
            "principal": "fake_principal",
            "domain": "fake_domain",
        }
    def tearDown(self):
        for attrname in (
            "esxi_host_details",
            "esxi_vcenter_details",
            "esxdatacenter_details",
            "esxcluster_details",
        ):
            try:
                delattr(self, attrname)
            except AttributeError:
                continue
    def test_esxi_proxy_host_details(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="esxi")
        ):
            with patch.dict(
                vsphere.__salt__,
                {"esxi.get_details": MagicMock(return_value=self.esxi_host_details)},
            ):
                ret = vsphere._get_proxy_connection_details()
        self.assertEqual(
            (
                "fake_host",
                "fake_username",
                "fake_password",
                "fake_protocol",
                "fake_port",
                "fake_mechanism",
                "fake_principal",
                "fake_domain",
            ),
            ret,
        )
    def test_esxdatacenter_proxy_details(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type",
            MagicMock(return_value="esxdatacenter"),
        ):
            with patch.dict(
                vsphere.__salt__,
                {
                    "esxdatacenter.get_details": MagicMock(
                        return_value=self.esxdatacenter_details
                    )
                },
            ):
                ret = vsphere._get_proxy_connection_details()
        self.assertEqual(
            (
                "fake_vcenter",
                "fake_username",
                "fake_password",
                "fake_protocol",
                "fake_port",
                "fake_mechanism",
                "fake_principal",
                "fake_domain",
            ),
            ret,
        )
    def test_esxcluster_proxy_details(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="esxcluster")
        ):
            with patch.dict(
                vsphere.__salt__,
                {
                    "esxcluster.get_details": MagicMock(
                        return_value=self.esxcluster_details
                    )
                },
            ):
                ret = vsphere._get_proxy_connection_details()
        self.assertEqual(
            (
                "fake_vcenter",
                "fake_username",
                "fake_password",
                "fake_protocol",
                "fake_port",
                "fake_mechanism",
                "fake_principal",
                "fake_domain",
            ),
            ret,
        )
    def test_esxi_proxy_vcenter_details(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="esxi")
        ):
            with patch.dict(
                vsphere.__salt__,
                {"esxi.get_details": MagicMock(return_value=self.esxi_vcenter_details)},
            ):
                ret = vsphere._get_proxy_connection_details()
        self.assertEqual(
            (
                "fake_vcenter",
                "fake_username",
                "fake_password",
                "fake_protocol",
                "fake_port",
                "fake_mechanism",
                "fake_principal",
                "fake_domain",
            ),
            ret,
        )
    def test_vcenter_proxy_details(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="vcenter")
        ):
            with patch.dict(
                vsphere.__salt__,
                {"vcenter.get_details": MagicMock(return_value=self.vcenter_details)},
            ):
                ret = vsphere._get_proxy_connection_details()
        self.assertEqual(
            (
                "fake_vcenter",
                "fake_username",
                "fake_password",
                "fake_protocol",
                "fake_port",
                "fake_mechanism",
                "fake_principal",
                "fake_domain",
            ),
            ret,
        )
    def test_unsupported_proxy_details(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="unsupported")
        ):
            with self.assertRaises(CommandExecutionError) as excinfo:
                ret = vsphere._get_proxy_connection_details()
        self.assertEqual(
            "'unsupported' proxy is not supported", excinfo.exception.strerror
        )
    def test_vcenter_proxy_details_verify_ssl(self):
        for verify_ssl in [True, False]:
            details = self.vcenter_details.copy()
            details["verify_ssl"] = verify_ssl
            with patch(
                "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="vcenter")
            ):
                with patch.dict(
                    vsphere.__salt__,
                    {"vcenter.get_details": MagicMock(return_value=details)},
                ):
                    ret = vsphere._get_proxy_connection_details()
            self.assertEqual(
                (
                    "fake_vcenter",
                    "fake_username",
                    "fake_password",
                    "fake_protocol",
                    "fake_port",
                    "fake_mechanism",
                    "fake_principal",
                    "fake_domain",
                    verify_ssl,
                ),
                ret,
            )
class GetsServiceInstanceViaProxyTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere._gets_service_instance_via_proxy
    decorator
    """
    def setup_loader_modules(self):
        patcher = patch("salt.utils.vmware.get_service_instance", MagicMock())
        patcher.start()
        self.addCleanup(patcher.stop)
        patcher = patch("salt.utils.vmware.disconnect", MagicMock())
        patcher.start()
        self.addCleanup(patcher.stop)
        return {vsphere: {"_get_proxy_connection_details": MagicMock()}}
    def setUp(self):
        self.mock_si = MagicMock()
        self.mock_details1 = MagicMock()
        self.mock_details2 = MagicMock()
    def tearDown(self):
        for attrname in ("mock_si", "mock_details1", "mock_details2"):
            try:
                delattr(self, attrname)
            except AttributeError:
                continue
    def test_no_service_instance_or_kwargs_parameters(self):
        @vsphere._gets_service_instance_via_proxy
        def mock_function():
            return "fake_function"
        with self.assertRaises(CommandExecutionError) as excinfo:
            mock_function()
        self.assertEqual(
            "Function mock_function must have either a "
            "'service_instance', or a '**kwargs' type "
            "parameter",
            excinfo.exception.strerror,
        )
    def test___get_proxy_connection_details_call(self):
        mock__get_proxy_connection_details = MagicMock()
        @vsphere._gets_service_instance_via_proxy
        def mock_function(service_instance=None):
            return service_instance
        with patch(
            "salt.modules.vsphere._get_proxy_connection_details",
            mock__get_proxy_connection_details,
        ):
            mock_function()
        mock__get_proxy_connection_details.assert_called_once_with()
    def test_service_instance_named_parameter_no_value(self):
        mock_get_service_instance = MagicMock(return_value=self.mock_si)
        mock_disconnect = MagicMock()
        @vsphere._gets_service_instance_via_proxy
        def mock_function(service_instance=None):
            return service_instance
        with patch(
            "salt.modules.vsphere._get_proxy_connection_details",
            MagicMock(return_value=(self.mock_details1, self.mock_details2)),
        ):
            with patch(
                "salt.utils.vmware.get_service_instance", mock_get_service_instance
            ):
                with patch("salt.utils.vmware.disconnect", mock_disconnect):
                    ret = mock_function()
        mock_get_service_instance.assert_called_once_with(
            self.mock_details1, self.mock_details2
        )
        mock_disconnect.assert_called_once_with(self.mock_si)
        self.assertEqual(ret, self.mock_si)
    def test_service_instance_kwargs_parameter_no_value(self):
        mock_get_service_instance = MagicMock(return_value=self.mock_si)
        mock_disconnect = MagicMock()
        @vsphere._gets_service_instance_via_proxy
        def mock_function(**kwargs):
            return kwargs["service_instance"]
        with patch(
            "salt.modules.vsphere._get_proxy_connection_details",
            MagicMock(return_value=(self.mock_details1, self.mock_details2)),
        ):
            with patch(
                "salt.utils.vmware.get_service_instance", mock_get_service_instance
            ):
                with patch("salt.utils.vmware.disconnect", mock_disconnect):
                    ret = mock_function()
        mock_get_service_instance.assert_called_once_with(
            self.mock_details1, self.mock_details2
        )
        mock_disconnect.assert_called_once_with(self.mock_si)
        self.assertEqual(ret, self.mock_si)
    def test_service_instance_positional_parameter_no_default_value(self):
        mock_get_service_instance = MagicMock()
        mock_disconnect = MagicMock()
        @vsphere._gets_service_instance_via_proxy
        def mock_function(service_instance):
            return service_instance
        with patch(
            "salt.modules.vsphere._get_proxy_connection_details",
            MagicMock(return_value=(self.mock_details1, self.mock_details2)),
        ):
            with patch(
                "salt.utils.vmware.get_service_instance", mock_get_service_instance
            ):
                with patch("salt.utils.vmware.disconnect", mock_disconnect):
                    ret = mock_function(self.mock_si)
        self.assertEqual(mock_get_service_instance.call_count, 0)
        self.assertEqual(mock_disconnect.call_count, 0)
        self.assertEqual(ret, self.mock_si)
    def test_service_instance_positional_parameter_with_default_value(self):
        mock_get_service_instance = MagicMock()
        mock_disconnect = MagicMock()
        @vsphere._gets_service_instance_via_proxy
        def mock_function(service_instance=None):
            return service_instance
        with patch(
            "salt.modules.vsphere._get_proxy_connection_details",
            MagicMock(return_value=(self.mock_details1, self.mock_details2)),
        ):
            with patch(
                "salt.utils.vmware.get_service_instance", mock_get_service_instance
            ):
                with patch("salt.utils.vmware.disconnect", mock_disconnect):
                    ret = mock_function(self.mock_si)
        self.assertEqual(mock_get_service_instance.call_count, 0)
        self.assertEqual(mock_disconnect.call_count, 0)
        self.assertEqual(ret, self.mock_si)
    def test_service_instance_named_parameter_with_default_value(self):
        mock_get_service_instance = MagicMock()
        mock_disconnect = MagicMock()
        @vsphere._gets_service_instance_via_proxy
        def mock_function(service_instance=None):
            return service_instance
        with patch(
            "salt.modules.vsphere._get_proxy_connection_details",
            MagicMock(return_value=(self.mock_details1, self.mock_details2)),
        ):
            with patch(
                "salt.utils.vmware.get_service_instance", mock_get_service_instance
            ):
                with patch("salt.utils.vmware.disconnect", mock_disconnect):
                    ret = mock_function(service_instance=self.mock_si)
        self.assertEqual(mock_get_service_instance.call_count, 0)
        self.assertEqual(mock_disconnect.call_count, 0)
        self.assertEqual(ret, self.mock_si)
    def test_service_instance_kwargs_parameter_passthrough(self):
        mock_get_service_instance = MagicMock()
        mock_disconnect = MagicMock()
        @vsphere._gets_service_instance_via_proxy
        def mock_function(**kwargs):
            return kwargs["service_instance"]
        with patch(
            "salt.modules.vsphere._get_proxy_connection_details",
            MagicMock(return_value=(self.mock_details1, self.mock_details2)),
        ):
            with patch(
                "salt.utils.vmware.get_service_instance", mock_get_service_instance
            ):
                with patch("salt.utils.vmware.disconnect", mock_disconnect):
                    ret = mock_function(service_instance=self.mock_si)
        self.assertEqual(mock_get_service_instance.call_count, 0)
        self.assertEqual(mock_disconnect.call_count, 0)
        self.assertEqual(ret, self.mock_si)
class GetServiceInstanceViaProxyTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.get_service_instance_via_proxy
    """
    def setup_loader_modules(self):
        patcher = patch("salt.utils.vmware.get_service_instance", MagicMock())
        patcher.start()
        self.addCleanup(patcher.stop)
        return {
            vsphere: {
                "get_proxy_type": MagicMock(return_value="esxi"),
                "_get_proxy_connection_details": MagicMock(),
            }
        }
    def test_supported_proxies(self):
        supported_proxies = ["esxi", "esxcluster", "esxdatacenter", "vcenter", "esxvm"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.get_service_instance_via_proxy()
    def test_get_service_instance_call(self):
        mock_connection_details = [MagicMock(), MagicMock(), MagicMock()]
        mock_get_service_instance = MagicMock()
        with patch(
            "salt.modules.vsphere._get_proxy_connection_details",
            MagicMock(return_value=mock_connection_details),
        ):
            with patch(
                "salt.utils.vmware.get_service_instance", mock_get_service_instance
            ):
                vsphere.get_service_instance_via_proxy()
        mock_get_service_instance.assert_called_once_with(*mock_connection_details)
    def test_output(self):
        mock_si = MagicMock()
        with patch(
            "salt.utils.vmware.get_service_instance", MagicMock(return_value=mock_si)
        ):
            res = vsphere.get_service_instance_via_proxy()
        self.assertEqual(res, mock_si)
class DisconnectTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.disconnect
    """
    def setup_loader_modules(self):
        self.mock_si = MagicMock()
        self.addCleanup(delattr, self, "mock_si")
        patcher = patch("salt.utils.vmware.disconnect", MagicMock())
        patcher.start()
        self.addCleanup(patcher.stop)
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "get_proxy_type": MagicMock(return_value="esxi"),
            }
        }
    def test_supported_proxies(self):
        supported_proxies = ["esxi", "esxcluster", "esxdatacenter", "vcenter", "esxvm"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.disconnect(self.mock_si)
    def test_disconnect_call(self):
        mock_disconnect = MagicMock()
        with patch("salt.utils.vmware.disconnect", mock_disconnect):
            vsphere.disconnect(self.mock_si)
        mock_disconnect.assert_called_once_with(self.mock_si)
    def test_output(self):
        res = vsphere.disconnect(self.mock_si)
        self.assertEqual(res, True)
class TestVcenterConnectionTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.test_vcenter_connection
    """
    def setup_loader_modules(self):
        self.mock_si = MagicMock()
        self.addCleanup(delattr, self, "mock_si")
        patcher = patch(
            "salt.utils.vmware.get_service_instance",
            MagicMock(return_value=self.mock_si),
        )
        patcher.start()
        self.addCleanup(patcher.stop)
        patcher = patch("salt.utils.vmware.disconnect", MagicMock())
        patcher.start()
        self.addCleanup(patcher.stop)
        patcher = patch("salt.utils.vmware.is_connection_to_a_vcenter", MagicMock())
        patcher.start()
        self.addCleanup(patcher.stop)
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "get_proxy_type": MagicMock(return_value="esxi"),
            }
        }
    def test_supported_proxies(self):
        supported_proxies = ["esxi", "esxcluster", "esxdatacenter", "vcenter", "esxvm"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.test_vcenter_connection()
    def test_is_connection_to_a_vcenter_call_default_service_instance(self):
        mock_is_connection_to_a_vcenter = MagicMock()
        with patch(
            "salt.utils.vmware.is_connection_to_a_vcenter",
            mock_is_connection_to_a_vcenter,
        ):
            vsphere.test_vcenter_connection()
        mock_is_connection_to_a_vcenter.assert_called_once_with(self.mock_si)
    def test_is_connection_to_a_vcenter_call_explicit_service_instance(self):
        expl_mock_si = MagicMock()
        mock_is_connection_to_a_vcenter = MagicMock()
        with patch(
            "salt.utils.vmware.is_connection_to_a_vcenter",
            mock_is_connection_to_a_vcenter,
        ):
            vsphere.test_vcenter_connection(expl_mock_si)
        mock_is_connection_to_a_vcenter.assert_called_once_with(expl_mock_si)
    def test_is_connection_to_a_vcenter_raises_vmware_salt_error(self):
        exc = VMwareSaltError("VMwareSaltError")
        with patch(
            "salt.utils.vmware.is_connection_to_a_vcenter", MagicMock(side_effect=exc)
        ):
            res = vsphere.test_vcenter_connection()
        self.assertEqual(res, False)
    def test_is_connection_to_a_vcenter_raises_non_vmware_salt_error(self):
        exc = Exception("NonVMwareSaltError")
        with patch(
            "salt.utils.vmware.is_connection_to_a_vcenter", MagicMock(side_effect=exc)
        ):
            with self.assertRaises(Exception) as excinfo:
                res = vsphere.test_vcenter_connection()
        self.assertEqual("NonVMwareSaltError", str(excinfo.exception))
    def test_output_true(self):
        with patch(
            "salt.utils.vmware.is_connection_to_a_vcenter", MagicMock(return_value=True)
        ):
            res = vsphere.test_vcenter_connection()
        self.assertEqual(res, True)
    def test_output_false(self):
        with patch(
            "salt.utils.vmware.is_connection_to_a_vcenter",
            MagicMock(return_value=False),
        ):
            res = vsphere.test_vcenter_connection()
        self.assertEqual(res, False)
@skipIf(not HAS_PYVMOMI, "The 'pyvmomi' library is missing")
class ListDatacentersViaProxyTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.list_datacenters_via_proxy
    """
    def setup_loader_modules(self):
        self.mock_si = MagicMock()
        self.addCleanup(delattr, self, "mock_si")
        patcher = patch(
            "salt.utils.vmware.get_service_instance",
            MagicMock(return_value=self.mock_si),
        )
        patcher.start()
        self.addCleanup(patcher.stop)
        patcher = patch("salt.utils.vmware.get_datacenters", MagicMock())
        patcher.start()
        self.addCleanup(patcher.stop)
        patcher = patch("salt.utils.vmware.get_managed_object_name", MagicMock())
        patcher.start()
        self.addCleanup(patcher.stop)
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "get_proxy_type": MagicMock(return_value="esxdatacenter"),
            }
        }
    def test_supported_proxies(self):
        supported_proxies = ["esxcluster", "esxdatacenter", "vcenter", "esxvm"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.list_datacenters_via_proxy()
    def test_default_params(self):
        mock_get_datacenters = MagicMock()
        with patch("salt.utils.vmware.get_datacenters", mock_get_datacenters):
            vsphere.list_datacenters_via_proxy()
        mock_get_datacenters.assert_called_once_with(
            self.mock_si, get_all_datacenters=True
        )
    def test_defined_service_instance(self):
        mock_si = MagicMock()
        mock_get_datacenters = MagicMock()
        with patch("salt.utils.vmware.get_datacenters", mock_get_datacenters):
            vsphere.list_datacenters_via_proxy(service_instance=mock_si)
        mock_get_datacenters.assert_called_once_with(mock_si, get_all_datacenters=True)
    def test_defined_datacenter_names(self):
        mock_datacenters = MagicMock()
        mock_get_datacenters = MagicMock()
        with patch("salt.utils.vmware.get_datacenters", mock_get_datacenters):
            vsphere.list_datacenters_via_proxy(mock_datacenters)
        mock_get_datacenters.assert_called_once_with(self.mock_si, mock_datacenters)
    def test_get_managed_object_name_calls(self):
        mock_get_managed_object_name = MagicMock()
        mock_dcs = [MagicMock(), MagicMock()]
        with patch(
            "salt.utils.vmware.get_datacenters", MagicMock(return_value=mock_dcs)
        ):
            with patch(
                "salt.utils.vmware.get_managed_object_name",
                mock_get_managed_object_name,
            ):
                vsphere.list_datacenters_via_proxy()
        mock_get_managed_object_name.assert_has_calls(
            [call(mock_dcs[0]), call(mock_dcs[1])]
        )
    def test_returned_array(self):
        with patch(
            "salt.utils.vmware.get_datacenters",
            MagicMock(return_value=[MagicMock(), MagicMock()]),
        ):
            with patch(
                "salt.utils.vmware.get_managed_object_name",
                MagicMock(side_effect=["fake_dc1", "fake_dc2", "fake_dc3"]),
            ):
                res = vsphere.list_datacenters_via_proxy()
        self.assertEqual(res, [{"name": "fake_dc1"}, {"name": "fake_dc2"}])
@skipIf(not HAS_PYVMOMI, "The 'pyvmomi' library is missing")
class CreateDatacenterTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.create_datacenter
    """
    def setup_loader_modules(self):
        self.mock_si = MagicMock()
        self.addCleanup(delattr, self, "mock_si")
        patcher = patch(
            "salt.utils.vmware.get_service_instance",
            MagicMock(return_value=self.mock_si),
        )
        patcher.start()
        self.addCleanup(patcher.stop)
        patcher = patch("salt.utils.vmware.create_datacenter", MagicMock())
        patcher.start()
        self.addCleanup(patcher.stop)
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "get_proxy_type": MagicMock(return_value="esxdatacenter"),
            }
        }
    def test_supported_proxies(self):
        supported_proxies = ["esxdatacenter", "vcenter"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.create_datacenter("fake_dc1")
    def test_default_service_instance(self):
        mock_create_datacenter = MagicMock()
        with patch("salt.utils.vmware.create_datacenter", mock_create_datacenter):
            vsphere.create_datacenter("fake_dc1")
        mock_create_datacenter.assert_called_once_with(self.mock_si, "fake_dc1")
    def test_defined_service_instance(self):
        mock_si = MagicMock()
        mock_create_datacenter = MagicMock()
        with patch("salt.utils.vmware.create_datacenter", mock_create_datacenter):
            vsphere.create_datacenter("fake_dc1", service_instance=mock_si)
        mock_create_datacenter.assert_called_once_with(mock_si, "fake_dc1")
    def test_returned_value(self):
        res = vsphere.create_datacenter("fake_dc1")
        self.assertEqual(res, {"create_datacenter": True})
@skipIf(not HAS_PYVMOMI, "The 'pyvmomi' library is missing")
class EraseDiskPartitionsTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.erase_disk_partitions
    """
    def setup_loader_modules(self):
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "__proxy__": {
                    "esxi.get_details": MagicMock(
                        return_value={"esxi_host": "fake_host"}
                    )
                },
            }
        }
    def setUp(self):
        attrs = (("mock_si", MagicMock()), ("mock_host", MagicMock()))
        for attr, mock_obj in attrs:
            setattr(self, attr, mock_obj)
            self.addCleanup(delattr, self, attr)
        attrs = (
            ("mock_proxy_target", MagicMock(return_value=self.mock_host)),
            ("mock_erase_disk_partitions", MagicMock()),
        )
        for attr, mock_obj in attrs:
            setattr(self, attr, mock_obj)
            self.addCleanup(delattr, self, attr)
        patches = (
            (
                "salt.utils.vmware.get_service_instance",
                MagicMock(return_value=self.mock_si),
            ),
            ("salt.modules.vsphere.get_proxy_type", MagicMock(return_value="esxi")),
            (
                "salt.modules.vsphere._get_proxy_target",
                MagicMock(return_value=self.mock_host),
            ),
            (
                "salt.utils.vmware.erase_disk_partitions",
                self.mock_erase_disk_partitions,
            ),
        )
        for module, mock_obj in patches:
            patcher = patch(module, mock_obj)
            patcher.start()
            self.addCleanup(patcher.stop)
    def test_supported_proxies(self):
        supported_proxies = ["esxi"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.erase_disk_partitions(disk_id="fake_disk")
    def test_no_disk_id_or_scsi_address(self):
        with self.assertRaises(ArgumentValueError) as excinfo:
            vsphere.erase_disk_partitions()
        self.assertEqual(
            "Either 'disk_id' or 'scsi_address' needs to be specified",
            excinfo.exception.strerror,
        )
    def test_get_proxy_target(self):
        mock_test_proxy_target = MagicMock()
        with patch("salt.modules.vsphere._get_proxy_target", mock_test_proxy_target):
            vsphere.erase_disk_partitions(disk_id="fake_disk")
        mock_test_proxy_target.assert_called_once_with(self.mock_si)
    def test_scsi_address_not_found(self):
        mock = MagicMock(return_value={"bad_scsi_address": "bad_disk_id"})
        with patch("salt.utils.vmware.get_scsi_address_to_lun_map", mock):
            with self.assertRaises(VMwareObjectRetrievalError) as excinfo:
                vsphere.erase_disk_partitions(scsi_address="fake_scsi_address")
        self.assertEqual(
            "Scsi lun with address 'fake_scsi_address' was "
            "not found on host 'fake_host'",
            excinfo.exception.strerror,
        )
    def test_scsi_address_to_disk_id_map(self):
        mock_disk_id = MagicMock(canonicalName="fake_scsi_disk_id")
        mock_get_scsi_addr_to_lun = MagicMock(
            return_value={"fake_scsi_address": mock_disk_id}
        )
        with patch(
            "salt.utils.vmware.get_scsi_address_to_lun_map", mock_get_scsi_addr_to_lun
        ):
            vsphere.erase_disk_partitions(scsi_address="fake_scsi_address")
        mock_get_scsi_addr_to_lun.assert_called_once_with(self.mock_host)
        self.mock_erase_disk_partitions.assert_called_once_with(
            self.mock_si, self.mock_host, "fake_scsi_disk_id", hostname="fake_host"
        )
    def test_erase_disk_partitions(self):
        vsphere.erase_disk_partitions(disk_id="fake_disk_id")
        self.mock_erase_disk_partitions.assert_called_once_with(
            self.mock_si, self.mock_host, "fake_disk_id", hostname="fake_host"
        )
@skipIf(not HAS_PYVMOMI, "The 'pyvmomi' library is missing")
class RemoveDatastoreTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.remove_datastore
    """
    def setup_loader_modules(self):
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "get_proxy_type": MagicMock(return_value="esxdatacenter"),
            }
        }
    def setUp(self):
        attrs = (
            ("mock_si", MagicMock()),
            ("mock_target", MagicMock()),
            ("mock_ds", MagicMock()),
        )
        for attr, mock_obj in attrs:
            setattr(self, attr, mock_obj)
            self.addCleanup(delattr, self, attr)
        patches = (
            (
                "salt.utils.vmware.get_service_instance",
                MagicMock(return_value=self.mock_si),
            ),
            (
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value="esxdatacenter"),
            ),
            (
                "salt.modules.vsphere._get_proxy_target",
                MagicMock(return_value=self.mock_target),
            ),
            (
                "salt.utils.vmware.get_datastores",
                MagicMock(return_value=[self.mock_ds]),
            ),
            ("salt.utils.vmware.remove_datastore", MagicMock()),
        )
        for module, mock_obj in patches:
            patcher = patch(module, mock_obj)
            patcher.start()
            self.addCleanup(patcher.stop)
    def test_supported_proxes(self):
        supported_proxies = ["esxi", "esxcluster", "esxdatacenter"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.remove_datastore(datastore="fake_ds_name")
    def test__get_proxy_target_call(self):
        mock__get_proxy_target = MagicMock(return_value=self.mock_target)
        with patch("salt.modules.vsphere._get_proxy_target", mock__get_proxy_target):
            vsphere.remove_datastore(datastore="fake_ds_name")
        mock__get_proxy_target.assert_called_once_with(self.mock_si)
    def test_get_datastores_call(self):
        mock_get_datastores = MagicMock()
        with patch("salt.utils.vmware.get_datastores", mock_get_datastores):
            vsphere.remove_datastore(datastore="fake_ds")
        mock_get_datastores.assert_called_once_with(
            self.mock_si, reference=self.mock_target, datastore_names=["fake_ds"]
        )
    def test_datastore_not_found(self):
        with patch("salt.utils.vmware.get_datastores", MagicMock(return_value=[])):
            with self.assertRaises(VMwareObjectRetrievalError) as excinfo:
                vsphere.remove_datastore(datastore="fake_ds")
        self.assertEqual(
            "Datastore 'fake_ds' was not found", excinfo.exception.strerror
        )
    def test_multiple_datastores_found(self):
        with patch(
            "salt.utils.vmware.get_datastores",
            MagicMock(return_value=[MagicMock(), MagicMock()]),
        ):
            with self.assertRaises(VMwareObjectRetrievalError) as excinfo:
                vsphere.remove_datastore(datastore="fake_ds")
        self.assertEqual(
            "Multiple datastores 'fake_ds' were found", excinfo.exception.strerror
        )
    def test_remove_datastore_call(self):
        mock_remove_datastore = MagicMock()
        with patch("salt.utils.vmware.remove_datastore", mock_remove_datastore):
            vsphere.remove_datastore(datastore="fake_ds")
        mock_remove_datastore.assert_called_once_with(self.mock_si, self.mock_ds)
    def test_success_output(self):
        res = vsphere.remove_datastore(datastore="fake_ds")
        self.assertTrue(res)
@skipIf(not HAS_PYVMOMI, "The 'pyvmomi' library is missing")
class RemoveDiskgroupTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.remove_diskgroup
    """
    def setup_loader_modules(self):
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "__proxy__": {
                    "esxi.get_details": MagicMock(
                        return_value={"esxi_host": "fake_host"}
                    )
                },
            }
        }
    def setUp(self):
        attrs = (
            ("mock_si", MagicMock()),
            ("mock_host", MagicMock()),
            ("mock_diskgroup", MagicMock()),
        )
        for attr, mock_obj in attrs:
            setattr(self, attr, mock_obj)
            self.addCleanup(delattr, self, attr)
        patches = (
            (
                "salt.utils.vmware.get_service_instance",
                MagicMock(return_value=self.mock_si),
            ),
            ("salt.modules.vsphere.get_proxy_type", MagicMock(return_value="esxi")),
            (
                "salt.modules.vsphere._get_proxy_target",
                MagicMock(return_value=self.mock_host),
            ),
            (
                "salt.utils.vmware.get_diskgroups",
                MagicMock(return_value=[self.mock_diskgroup]),
            ),
            ("salt.utils.vsan.remove_diskgroup", MagicMock()),
        )
        for module, mock_obj in patches:
            patcher = patch(module, mock_obj)
            patcher.start()
            self.addCleanup(patcher.stop)
    def test_supported_proxes(self):
        supported_proxies = ["esxi"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.remove_diskgroup(cache_disk_id="fake_disk_id")
    def test__get_proxy_target_call(self):
        mock__get_proxy_target = MagicMock(return_value=self.mock_host)
        with patch("salt.modules.vsphere._get_proxy_target", mock__get_proxy_target):
            vsphere.remove_diskgroup(cache_disk_id="fake_disk_id")
        mock__get_proxy_target.assert_called_once_with(self.mock_si)
    def test_get_disk_groups(self):
        mock_get_diskgroups = MagicMock(return_value=[self.mock_diskgroup])
        with patch("salt.utils.vmware.get_diskgroups", mock_get_diskgroups):
            vsphere.remove_diskgroup(cache_disk_id="fake_disk_id")
        mock_get_diskgroups.assert_called_once_with(
            self.mock_host, cache_disk_ids=["fake_disk_id"]
        )
    def test_disk_group_not_found_safety_checks_set(self):
        with patch("salt.utils.vmware.get_diskgroups", MagicMock(return_value=[])):
            with self.assertRaises(VMwareObjectRetrievalError) as excinfo:
                vsphere.remove_diskgroup(cache_disk_id="fake_disk_id")
        self.assertEqual(
            "No diskgroup with cache disk id "
            "'fake_disk_id' was found in ESXi host "
            "'fake_host'",
            excinfo.exception.strerror,
        )
    def test_remove_disk_group(self):
        mock_remove_diskgroup = MagicMock(return_value=None)
        with patch("salt.utils.vsan.remove_diskgroup", mock_remove_diskgroup):
            vsphere.remove_diskgroup(cache_disk_id="fake_disk_id")
        mock_remove_diskgroup.assert_called_once_with(
            self.mock_si, self.mock_host, self.mock_diskgroup, data_accessibility=True
        )
    def test_remove_disk_group_data_accessibility_false(self):
        mock_remove_diskgroup = MagicMock(return_value=None)
        with patch("salt.utils.vsan.remove_diskgroup", mock_remove_diskgroup):
            vsphere.remove_diskgroup(
                cache_disk_id="fake_disk_id", data_accessibility=False
            )
        mock_remove_diskgroup.assert_called_once_with(
            self.mock_si, self.mock_host, self.mock_diskgroup, data_accessibility=False
        )
    def test_success_output(self):
        res = vsphere.remove_diskgroup(cache_disk_id="fake_disk_id")
        self.assertTrue(res)
@skipIf(not HAS_PYVMOMI, "The 'pyvmomi' library is missing")
@skipIf(not vsphere.HAS_JSONSCHEMA, "The 'jsonschema' library is missing")
class RemoveCapacityFromDiskgroupTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.remove_capacity_from_diskgroup
    """
    def setup_loader_modules(self):
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "__proxy__": {
                    "esxi.get_details": MagicMock(
                        return_value={"esxi_host": "fake_host"}
                    )
                },
            }
        }
    def setUp(self):
        attrs = (
            ("mock_si", MagicMock()),
            ("mock_schema", MagicMock()),
            ("mock_host", MagicMock()),
            ("mock_disk1", MagicMock(canonicalName="fake_disk1")),
            ("mock_disk2", MagicMock(canonicalName="fake_disk2")),
            ("mock_disk3", MagicMock(canonicalName="fake_disk3")),
            ("mock_diskgroup", MagicMock()),
        )
        for attr, mock_obj in attrs:
            setattr(self, attr, mock_obj)
            self.addCleanup(delattr, self, attr)
        patches = (
            (
                "salt.utils.vmware.get_service_instance",
                MagicMock(return_value=self.mock_si),
            ),
            (
                "salt.modules.vsphere.DiskGroupsDiskIdSchema.serialize",
                MagicMock(return_value=self.mock_schema),
            ),
            ("salt.modules.vsphere.jsonschema.validate", MagicMock()),
            ("salt.modules.vsphere.get_proxy_type", MagicMock(return_value="esxi")),
            (
                "salt.modules.vsphere._get_proxy_target",
                MagicMock(return_value=self.mock_host),
            ),
            (
                "salt.utils.vmware.get_disks",
                MagicMock(
                    return_value=[self.mock_disk1, self.mock_disk2, self.mock_disk3]
                ),
            ),
            (
                "salt.utils.vmware.get_diskgroups",
                MagicMock(return_value=[self.mock_diskgroup]),
            ),
            ("salt.utils.vsan.remove_capacity_from_diskgroup", MagicMock()),
        )
        for module, mock_obj in patches:
            patcher = patch(module, mock_obj)
            patcher.start()
            self.addCleanup(patcher.stop)
    def test_validate(self):
        mock_schema_validate = MagicMock()
        with patch("salt.modules.vsphere.jsonschema.validate", mock_schema_validate):
            vsphere.remove_capacity_from_diskgroup(
                cache_disk_id="fake_cache_disk_id",
                capacity_disk_ids=["fake_disk1", "fake_disk2"],
            )
        mock_schema_validate.assert_called_once_with(
            {
                "diskgroups": [
                    {
                        "cache_id": "fake_cache_disk_id",
                        "capacity_ids": ["fake_disk1", "fake_disk2"],
                    }
                ]
            },
            self.mock_schema,
        )
    def test_invalid_schema_validation(self):
        mock_schema_validate = MagicMock(
            side_effect=vsphere.jsonschema.exceptions.ValidationError("err")
        )
        with patch("salt.modules.vsphere.jsonschema.validate", mock_schema_validate):
            with self.assertRaises(ArgumentValueError) as excinfo:
                vsphere.remove_capacity_from_diskgroup(
                    cache_disk_id="fake_cache_disk_id",
                    capacity_disk_ids=["fake_disk1", "fake_disk2"],
                )
        self.assertEqual("err", excinfo.exception.strerror)
    def test_supported_proxes(self):
        supported_proxies = ["esxi"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.remove_capacity_from_diskgroup(
                    cache_disk_id="fake_cache_disk_id",
                    capacity_disk_ids=["fake_disk1", "fake_disk2"],
                )
    def test__get_proxy_target_call(self):
        mock__get_proxy_target = MagicMock(return_value=self.mock_host)
        with patch("salt.modules.vsphere._get_proxy_target", mock__get_proxy_target):
            vsphere.remove_capacity_from_diskgroup(
                cache_disk_id="fake_cache_disk_id",
                capacity_disk_ids=["fake_disk1", "fake_disk2"],
            )
        mock__get_proxy_target.assert_called_once_with(self.mock_si)
    def test_get_disks(self):
        mock_get_disks = MagicMock(
            return_value=[self.mock_disk1, self.mock_disk2, self.mock_disk3]
        )
        with patch("salt.utils.vmware.get_disks", mock_get_disks):
            vsphere.remove_capacity_from_diskgroup(
                cache_disk_id="fake_cache_disk_id",
                capacity_disk_ids=["fake_disk1", "fake_disk2"],
            )
        mock_get_disks.assert_called_once_with(
            self.mock_host, disk_ids=["fake_disk1", "fake_disk2"]
        )
    def test_disk_not_found_safety_checks_set(self):
        mock_get_disks = MagicMock(
            return_value=[self.mock_disk1, self.mock_disk2, self.mock_disk3]
        )
        with patch("salt.utils.vmware.get_disks", mock_get_disks):
            with self.assertRaises(VMwareObjectRetrievalError) as excinfo:
                vsphere.remove_capacity_from_diskgroup(
                    cache_disk_id="fake_cache_disk_id",
                    capacity_disk_ids=["fake_disk1", "fake_disk4"],
                    safety_checks=True,
                )
        self.assertEqual(
            "No disk with id 'fake_disk4' was found in ESXi host 'fake_host'",
            excinfo.exception.strerror,
        )
    def test_get_diskgroups(self):
        mock_get_diskgroups = MagicMock(return_value=[self.mock_diskgroup])
        with patch("salt.utils.vmware.get_diskgroups", mock_get_diskgroups):
            vsphere.remove_capacity_from_diskgroup(
                cache_disk_id="fake_cache_disk_id",
                capacity_disk_ids=["fake_disk1", "fake_disk2"],
            )
        mock_get_diskgroups.assert_called_once_with(
            self.mock_host, cache_disk_ids=["fake_cache_disk_id"]
        )
    def test_diskgroup_not_found(self):
        with patch("salt.utils.vmware.get_diskgroups", MagicMock(return_value=[])):
            with self.assertRaises(VMwareObjectRetrievalError) as excinfo:
                vsphere.remove_capacity_from_diskgroup(
                    cache_disk_id="fake_cache_disk_id",
                    capacity_disk_ids=["fake_disk1", "fake_disk2"],
                )
        self.assertEqual(
            "No diskgroup with cache disk id "
            "'fake_cache_disk_id' was found in ESXi host "
            "'fake_host'",
            excinfo.exception.strerror,
        )
    def test_remove_capacity_from_diskgroup(self):
        mock_remove_capacity_from_diskgroup = MagicMock()
        with patch(
            "salt.utils.vsan.remove_capacity_from_diskgroup",
            mock_remove_capacity_from_diskgroup,
        ):
            vsphere.remove_capacity_from_diskgroup(
                cache_disk_id="fake_cache_disk_id",
                capacity_disk_ids=["fake_disk1", "fake_disk2"],
            )
        mock_remove_capacity_from_diskgroup.assert_called_once_with(
            self.mock_si,
            self.mock_host,
            self.mock_diskgroup,
            capacity_disks=[self.mock_disk1, self.mock_disk2],
            data_evacuation=True,
        )
    def test_remove_capacity_from_diskgroup_data_evacuation_false(self):
        mock_remove_capacity_from_diskgroup = MagicMock()
        with patch(
            "salt.utils.vsan.remove_capacity_from_diskgroup",
            mock_remove_capacity_from_diskgroup,
        ):
            vsphere.remove_capacity_from_diskgroup(
                cache_disk_id="fake_cache_disk_id",
                capacity_disk_ids=["fake_disk1", "fake_disk2"],
                data_evacuation=False,
            )
        mock_remove_capacity_from_diskgroup.assert_called_once_with(
            self.mock_si,
            self.mock_host,
            self.mock_diskgroup,
            capacity_disks=[self.mock_disk1, self.mock_disk2],
            data_evacuation=False,
        )
    def test_success_output(self):
        res = vsphere.remove_capacity_from_diskgroup(
            cache_disk_id="fake_cache_disk_id",
            capacity_disk_ids=["fake_disk1", "fake_disk2"],
        )
        self.assertTrue(res)
@skipIf(not HAS_PYVMOMI, "The 'pyvmomi' library is missing")
class ListClusterTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.list_cluster
    """
    def setup_loader_modules(self):
        return {vsphere: {"_get_proxy_connection_details": MagicMock(), "__salt__": {}}}
    def setUp(self):
        attrs = (
            ("mock_si", MagicMock()),
            ("mock_dc", MagicMock()),
            ("mock_cl", MagicMock()),
            ("mock__get_cluster_dict", MagicMock()),
        )
        for attr, mock_obj in attrs:
            setattr(self, attr, mock_obj)
            self.addCleanup(delattr, self, attr)
        attrs = (("mock_get_cluster", MagicMock(return_value=self.mock_cl)),)
        for attr, mock_obj in attrs:
            setattr(self, attr, mock_obj)
            self.addCleanup(delattr, self, attr)
        patches = (
            (
                "salt.utils.vmware.get_service_instance",
                MagicMock(return_value=self.mock_si),
            ),
            (
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value="esxcluster"),
            ),
            (
                "salt.modules.vsphere._get_proxy_target",
                MagicMock(return_value=self.mock_cl),
            ),
            ("salt.utils.vmware.get_cluster", self.mock_get_cluster),
            ("salt.modules.vsphere._get_cluster_dict", self.mock__get_cluster_dict),
        )
        for module, mock_obj in patches:
            patcher = patch(module, mock_obj)
            patcher.start()
            self.addCleanup(patcher.stop)
        patcher = patch.dict(
            vsphere.__salt__,
            {"esxcluster.get_details": MagicMock(return_value={"cluster": "cl"})},
        )
        patcher.start()
        self.addCleanup(patcher.stop)
    def test_supported_proxies(self):
        supported_proxies = ["esxcluster", "esxdatacenter"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.list_cluster(cluster="cl")
    def test_default_service_instance(self):
        mock__get_proxy_target = MagicMock()
        with patch("salt.modules.vsphere._get_proxy_target", mock__get_proxy_target):
            vsphere.list_cluster()
        mock__get_proxy_target.assert_called_once_with(self.mock_si)
    def test_defined_service_instance(self):
        mock_si = MagicMock()
        mock__get_proxy_target = MagicMock()
        with patch("salt.modules.vsphere._get_proxy_target", mock__get_proxy_target):
            vsphere.list_cluster(service_instance=mock_si)
        mock__get_proxy_target.assert_called_once_with(mock_si)
    def test_no_cluster_raises_argument_value_error(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type",
            MagicMock(return_value="esxdatacenter"),
        ):
            with patch("salt.modules.vsphere._get_proxy_target", MagicMock()):
                with self.assertRaises(ArgumentValueError) as excinfo:
                    vsphere.list_cluster()
        self.assertEqual(excinfo.exception.strerror, "'cluster' needs to be specified")
    def test_get_cluster_call(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type",
            MagicMock(return_value="esxdatacenter"),
        ):
            with patch(
                "salt.modules.vsphere._get_proxy_target",
                MagicMock(return_value=self.mock_dc),
            ):
                vsphere.list_cluster(cluster="cl")
        self.mock_get_cluster.assert_called_once_with(self.mock_dc, "cl")
    def test__get_cluster_dict_call(self):
        vsphere.list_cluster()
        self.mock__get_cluster_dict.assert_called_once_with("cl", self.mock_cl)
@skipIf(not HAS_PYVMOMI, "The 'pyvmomi' library is missing")
class RenameDatastoreTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere.rename_datastore
    """
    def setup_loader_modules(self):
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "get_proxy_type": MagicMock(return_value="esxdatacenter"),
            }
        }
    def setUp(self):
        self.mock_si = MagicMock()
        self.mock_target = MagicMock()
        self.mock_ds_ref = MagicMock()
        self.mock_get_datastores = MagicMock(return_value=[self.mock_ds_ref])
        self.mock_rename_datastore = MagicMock()
        patches = (
            (
                "salt.utils.vmware.get_service_instance",
                MagicMock(return_value=self.mock_si),
            ),
            (
                "salt.modules.vsphere._get_proxy_target",
                MagicMock(return_value=self.mock_target),
            ),
            ("salt.utils.vmware.get_datastores", self.mock_get_datastores),
            ("salt.utils.vmware.rename_datastore", self.mock_rename_datastore),
        )
        for mod, mock in patches:
            patcher = patch(mod, mock)
            patcher.start()
            self.addCleanup(patcher.stop)
    def tearDown(self):
        for attr in (
            "mock_si",
            "mock_target",
            "mock_ds_ref",
            "mock_get_datastores",
            "mock_rename_datastore",
        ):
            delattr(self, attr)
    def test_supported_proxes(self):
        supported_proxies = ["esxi", "esxcluster", "esxdatacenter"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere.rename_datastore("current_ds_name", "new_ds_name")
    def test_default_service_instance(self):
        mock__get_proxy_target = MagicMock()
        with patch("salt.modules.vsphere._get_proxy_target", mock__get_proxy_target):
            vsphere.rename_datastore("current_ds_name", "new_ds_name")
        mock__get_proxy_target.assert_called_once_with(self.mock_si)
    def test_defined_service_instance(self):
        mock_si = MagicMock()
        mock__get_proxy_target = MagicMock()
        with patch("salt.modules.vsphere._get_proxy_target", mock__get_proxy_target):
            vsphere.rename_datastore(
                "current_ds_name", "new_ds_name", service_instance=mock_si
            )
        mock__get_proxy_target.assert_called_once_with(mock_si)
    def test_get_datastore_call(self):
        vsphere.rename_datastore("current_ds_name", "new_ds_name")
        self.mock_get_datastores.assert_called_once_with(
            self.mock_si, self.mock_target, datastore_names=["current_ds_name"]
        )
    def test_get_no_datastores(self):
        with patch("salt.utils.vmware.get_datastores", MagicMock(return_value=[])):
            with self.assertRaises(VMwareObjectRetrievalError) as excinfo:
                vsphere.rename_datastore("current_ds_name", "new_ds_name")
        self.assertEqual(
            excinfo.exception.strerror, "Datastore 'current_ds_name' was not found"
        )
    def test_rename_datastore_call(self):
        vsphere.rename_datastore("current_ds_name", "new_ds_name")
        self.mock_rename_datastore.assert_called_once_with(
            self.mock_ds_ref, "new_ds_name"
        )
class _GetProxyTargetTestCase(TestCase, LoaderModuleMockMixin):
    """
    Tests for salt.modules.vsphere._get_proxy_target
    """
    def setup_loader_modules(self):
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "get_proxy_type": MagicMock(return_value="esxdatacenter"),
            }
        }
    def setUp(self):
        attrs = (
            ("mock_si", MagicMock()),
            ("mock_dc", MagicMock()),
            ("mock_cl", MagicMock()),
            ("mock_root", MagicMock()),
        )
        for attr, mock_obj in attrs:
            setattr(self, attr, mock_obj)
            self.addCleanup(delattr, self, attr)
        attrs = (
            ("mock_get_datacenter", MagicMock(return_value=self.mock_dc)),
            ("mock_get_cluster", MagicMock(return_value=self.mock_cl)),
            ("mock_get_root_folder", MagicMock(return_value=self.mock_root)),
        )
        for attr, mock_obj in attrs:
            setattr(self, attr, mock_obj)
            self.addCleanup(delattr, self, attr)
        patches = (
            (
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value="esxcluster"),
            ),
            (
                "salt.utils.vmware.is_connection_to_a_vcenter",
                MagicMock(return_value=True),
            ),
            (
                "salt.modules.vsphere._get_esxcluster_proxy_details",
                MagicMock(
                    return_value=(
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        "datacenter",
                        "cluster",
                    )
                ),
            ),
            (
                "salt.modules.vsphere._get_esxdatacenter_proxy_details",
                MagicMock(
                    return_value=(
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        "datacenter",
                    )
                ),
            ),
            ("salt.utils.vmware.get_datacenter", self.mock_get_datacenter),
            ("salt.utils.vmware.get_cluster", self.mock_get_cluster),
            ("salt.utils.vmware.get_root_folder", self.mock_get_root_folder),
        )
        for module, mock_obj in patches:
            patcher = patch(module, mock_obj)
            patcher.start()
            self.addCleanup(patcher.stop)
    def test_supported_proxies(self):
        supported_proxies = ["esxcluster", "esxdatacenter"]
        for proxy_type in supported_proxies:
            with patch(
                "salt.modules.vsphere.get_proxy_type",
                MagicMock(return_value=proxy_type),
            ):
                vsphere._get_proxy_target(self.mock_si)
    def test_connected_to_esxi(self):
        with patch(
            "salt.utils.vmware.is_connection_to_a_vcenter",
            MagicMock(return_value=False),
        ):
            with self.assertRaises(CommandExecutionError) as excinfo:
                vsphere._get_proxy_target(self.mock_si)
            self.assertEqual(
                excinfo.exception.strerror,
                "'_get_proxy_target' not supported when connected via the ESXi host",
            )
    def test_get_cluster_call(self):
        vsphere._get_proxy_target(self.mock_si)
        self.mock_get_datacenter.assert_called_once_with(self.mock_si, "datacenter")
        self.mock_get_cluster.assert_called_once_with(self.mock_dc, "cluster")
    def test_esxcluster_proxy_return(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="esxcluster")
        ):
            ret = vsphere._get_proxy_target(self.mock_si)
        self.assertEqual(ret, self.mock_cl)
    def test_get_datacenter_call(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type",
            MagicMock(return_value="esxdatacenter"),
        ):
            vsphere._get_proxy_target(self.mock_si)
        self.mock_get_datacenter.assert_called_once_with(self.mock_si, "datacenter")
        self.assertEqual(self.mock_get_cluster.call_count, 0)
    def test_esxdatacenter_proxy_return(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type",
            MagicMock(return_value="esxdatacenter"),
        ):
            ret = vsphere._get_proxy_target(self.mock_si)
        self.assertEqual(ret, self.mock_dc)
    def test_vcenter_proxy_return(self):
        with patch(
            "salt.modules.vsphere.get_proxy_type", MagicMock(return_value="vcenter")
        ):
            ret = vsphere._get_proxy_target(self.mock_si)
        self.mock_get_root_folder.assert_called_once_with(self.mock_si)
        self.assertEqual(ret, self.mock_root)
@skipIf(not HAS_VSPHERE_SDK, "The 'vsphere-automation-sdk' library is missing")
class TestVSphereTagging(TestCase, LoaderModuleMockMixin):
    """
    Tests for:
     - salt.modules.vsphere.create_tag_category
     - salt.modules.vsphere.create_tag
     - salt.modules.vsphere.delete_tag_category
     - salt.modules.vsphere.delete_tag
     - salt.modules.vsphere.list_tag_categories
     - salt.modules.vsphere.list_tags
     - salt.modules.vsphere.attach_tags
     - salt.modules.vsphere.list_attached_tags
    """
    def setup_loader_modules(self):
        return {
            vsphere: {
                "_get_proxy_connection_details": MagicMock(),
                "get_proxy_type": MagicMock(return_value="vcenter"),
            }
        }
    details = {key: None for key in ["vcenter", "username", "password"]}
    func_attrs = {
        key: None
        for key in [
            "category_id",
            "object_id",
            "tag_id",
            "name",
            "description",
            "cardinality",
        ]
    }
    create_tag_category = {
        "Category created": (
            "urn:vmomi:InventoryServiceTag:bb0350b4-85db-46b0-a726-e7c5989fc857:GLOBAL"
        )
    }
    create_tag = {
        "Tag created": (
            "urn:vmomi:InventoryServiceTag:bb0350b4-85db-46b0-a726-e7c5989fc857:GLOBAL"
        )
    }
    delete_tag_category = {
        "Category deleted": (
            "urn:vmomi:InventoryServiceTag:bb0350b4-85db-46b0-a726-e7c5989fc857:GLOBAL"
        )
    }
    delete_tag = {
        "Tag deleted": (
            "urn:vmomi:InventoryServiceTag:bb0350b4-85db-46b0-a726-e7c5989fc857:GLOBAL"
        )
    }
    list_tag_categories_return = [
        "urn:vmomi:InventoryServiceCategory:"
        "b13f4959-a3f3-48d0-8080-15bb586b4355:GLOBAL",
        "urn:vmomi:InventoryServiceCategory:"
        "f4d41f02-c317-422d-9013-dcbebfcd54ad:GLOBAL",
        "urn:vmomi:InventoryServiceCategory:"
        "2db5b00b-f211-4bba-ba42-e2658ebbb283:GLOBAL",
        "urn:vmomi:InventoryServiceCategory:"
        "cd847c3c-687c-4bd9-8e5a-0eb536f0a01d:GLOBAL",
        "urn:vmomi:InventoryServiceCategory:"
        "d51c24f9-cffb-4ce0-af56-7f18b6e649af:GLOBAL",
    ]
    list_tags_return = [
        "urn:vmomi:InventoryServiceTag:a584a83b-3015-45ad-8057-a3630613052f:GLOBAL",
        "urn:vmomi:InventoryServiceTag:db08019c-15de-4bbf-be46-d81aaf8d25c0:GLOBAL",
        "urn:vmomi:InventoryServiceTag:b55ecc77-f4a5-49f8-ab52-38865467cfbe:GLOBAL",
        "urn:vmomi:InventoryServiceTag:f009ab1b-e1b5-4c40-b8f7-951d9d716b39:GLOBAL",
        "urn:vmomi:InventoryServiceTag:102bb4c5-9b76-4d6c-882a-76a91ee3edcc:GLOBAL",
        "urn:vmomi:InventoryServiceTag:bb0350b4-85db-46b0-a726-e7c5989fc857:GLOBAL",
        "urn:vmomi:InventoryServiceTag:71d30f2d-bb23-48e1-995f-630adfb0dc89:GLOBAL",
    ]
    list_attached_tags_return = [
        "urn:vmomi:InventoryServiceTag:b55ecc77-f4a5-49f8-ab52-38865467cfbe:GLOBAL",
        "urn:vmomi:InventoryServiceTag:bb0350b4-85db-46b0-a726-e7c5989fc857:GLOBAL",
    ]
    list_create_category_return = [
        "urn:vmomi:InventoryServiceCategory:0af54c2d-e8cd-4248-931e-2f5807d8c477:GLOBAL"
    ]
    list_create_tag_return = [
        "urn:vmomi:InventoryServiceCategory:0af54c2d-e8cd-4248-931e-2f5807d8c477:GLOBAL"
    ]
    attach_tags_return = {
        "Tag attached": (
            "urn:vmomi:InventoryServiceTag:bb0350b4-85db-46b0-a726-e7c5989fc857:GLOBAL"
        )
    }
    def test_create_tag_category_client_none(self):
        get_details = MagicMock(return_value=self.details)
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware, "get_vsphere_client", return_value=None
                        ) as get_vsphere_client:
                            ret = vsphere.create_tag_category(
                                self.func_attrs["name"],
                                self.func_attrs["description"],
                                self.func_attrs["cardinality"],
                            )
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, {"Category created": None})
    def test_create_tag_category_client(self):
        for verify_ssl in [True, False, None]:
            details = self.details.copy()
            if verify_ssl is None:
                verify_ssl = True
            else:
                details["verify_ssl"] = verify_ssl
            get_details = MagicMock(return_value=details)
            mock_client = Mock(
                tagging=Mock(
                    Category=Mock(
                        CreateSpec=Mock(return_value=Mock()),
                        create=Mock(
                            return_value=self.create_tag_category["Category created"]
                        ),
                    )
                )
            )
            with patch.object(
                vsphere, "get_proxy_type", return_value="vcenter"
            ) as get_proxy_type:
                with patch.object(
                    vsphere, "_get_proxy_connection_details", return_value=[]
                ) as get_proxy_connection:
                    with patch.object(
                        salt.utils.vmware, "get_service_instance", return_value=None
                    ) as get_service_instance:
                        with patch.dict(
                            vsphere.__salt__,
                            {"vcenter.get_details": get_details},
                            clear=True,
                        ) as get_vcenter_details:
                            with patch.object(
                                salt.utils.vmware,
                                "get_vsphere_client",
                                return_value=mock_client,
                            ) as get_vsphere_client:
                                ret = vsphere.create_tag_category(
                                    self.func_attrs["name"],
                                    self.func_attrs["description"],
                                    self.func_attrs["cardinality"],
                                )
                                get_proxy_type.assert_called_once()
                                get_proxy_connection.assert_called_once()
                                get_service_instance.assert_called_once()
                                get_vsphere_client.assert_called_once()
                                self.assertEqual(ret, self.create_tag_category)
                                self.assertEqual(
                                    get_vsphere_client.call_args_list,
                                    [
                                        call(
                                            ca_bundle=None,
                                            password=None,
                                            server=None,
                                            username=None,
                                            verify_ssl=verify_ssl,
                                        )
                                    ],
                                )
    def test_create_tag_client_none(self):
        get_details = MagicMock(return_value=self.details)
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware, "get_vsphere_client", return_value=None
                        ) as get_vsphere_client:
                            ret = vsphere.create_tag(
                                self.func_attrs["name"],
                                self.func_attrs["description"],
                                self.func_attrs["cardinality"],
                            )
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, {"Tag created": None})
    def test_create_tag_client(self):
        get_details = MagicMock(return_value=self.details)
        mock_client = Mock(
            tagging=Mock(
                Tag=Mock(
                    CreateSpec=Mock(return_value=Mock()),
                    create=Mock(return_value=self.create_tag["Tag created"]),
                )
            )
        )
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware,
                            "get_vsphere_client",
                            return_value=mock_client,
                        ) as get_vsphere_client:
                            ret = vsphere.create_tag(
                                self.func_attrs["name"],
                                self.func_attrs["description"],
                                self.func_attrs["cardinality"],
                            )
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, self.create_tag)
    def test_delete_tag_category_client_none(self):
        get_details = MagicMock(return_value=self.details)
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware, "get_vsphere_client", return_value=None
                        ) as get_vsphere_client:
                            ret = vsphere.delete_tag_category(
                                self.func_attrs["category_id"]
                            )
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, {"Category deleted": None})
    def test_delete_tag_category_client(self):
        for verify_ssl in [True, False, None]:
            details = self.details.copy()
            if verify_ssl is None:
                verify_ssl = True
            else:
                details["verify_ssl"] = verify_ssl
            get_details = MagicMock(return_value=details)
            mock_client = Mock(
                tagging=Mock(
                    Category=Mock(
                        delete=Mock(
                            return_value=self.delete_tag_category["Category deleted"]
                        )
                    )
                )
            )
            with patch.object(
                vsphere, "get_proxy_type", return_value="vcenter"
            ) as get_proxy_type:
                with patch.object(
                    vsphere, "_get_proxy_connection_details", return_value=[]
                ) as get_proxy_connection:
                    with patch.object(
                        salt.utils.vmware, "get_service_instance", return_value=None
                    ) as get_service_instance:
                        with patch.dict(
                            vsphere.__salt__,
                            {"vcenter.get_details": get_details},
                            clear=True,
                        ) as get_vcenter_details:
                            with patch.object(
                                salt.utils.vmware,
                                "get_vsphere_client",
                                return_value=mock_client,
                            ) as get_vsphere_client:
                                ret = vsphere.delete_tag_category(
                                    self.func_attrs["category_id"]
                                )
                                get_proxy_type.assert_called_once()
                                get_proxy_connection.assert_called_once()
                                get_service_instance.assert_called_once()
                                get_vsphere_client.assert_called_once()
                                self.assertEqual(ret, self.delete_tag_category)
                                self.assertEqual(
                                    get_vsphere_client.call_args_list,
                                    [
                                        call(
                                            ca_bundle=None,
                                            password=None,
                                            server=None,
                                            username=None,
                                            verify_ssl=verify_ssl,
                                        )
                                    ],
                                )
    def test_delete_tag_client_none(self):
        get_details = MagicMock(return_value=self.details)
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware, "get_vsphere_client", return_value=None
                        ) as get_vsphere_client:
                            ret = vsphere.delete_tag(self.func_attrs["tag_id"])
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, {"Tag deleted": None})
    def test_delete_tag_client(self):
        get_details = MagicMock(return_value=self.details)
        mock_client = Mock(
            tagging=Mock(
                Tag=Mock(delete=Mock(return_value=self.delete_tag["Tag deleted"]))
            )
        )
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware,
                            "get_vsphere_client",
                            return_value=mock_client,
                        ) as get_vsphere_client:
                            ret = vsphere.delete_tag(self.func_attrs["tag_id"])
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, self.delete_tag)
    def test_list_tag_categories_client_none(self):
        get_details = MagicMock(return_value=self.details)
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware, "get_vsphere_client", return_value=None
                        ) as get_vsphere_client:
                            ret = vsphere.list_tag_categories()
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, {"Categories": None})
    def test_list_tag_categories_client(self):
        for verify_ssl in [True, False, None]:
            details = self.details.copy()
            if verify_ssl is not None:
                details["verify_ssl"] = verify_ssl
            else:
                verify_ssl = True
            get_details = MagicMock(return_value=details)
            mock_client = Mock(
                tagging=Mock(
                    Category=Mock(
                        list=Mock(return_value=self.list_tag_categories_return)
                    )
                )
            )
            with patch.object(
                vsphere, "get_proxy_type", return_value="vcenter"
            ) as get_proxy_type:
                with patch.object(
                    vsphere, "_get_proxy_connection_details", return_value=[]
                ) as get_proxy_connection:
                    with patch.object(
                        salt.utils.vmware, "get_service_instance", return_value=None
                    ) as get_service_instance:
                        with patch.dict(
                            vsphere.__salt__,
                            {"vcenter.get_details": get_details},
                            clear=True,
                        ) as get_vcenter_details:
                            with patch.object(
                                salt.utils.vmware,
                                "get_vsphere_client",
                                return_value=mock_client,
                            ) as get_vsphere_client:
                                ret = vsphere.list_tag_categories()
                                get_proxy_type.assert_called_once()
                                get_proxy_connection.assert_called_once()
                                get_service_instance.assert_called_once()
                                get_vsphere_client.assert_called_once()
                                self.assertEqual(
                                    get_vsphere_client.call_args_list,
                                    [
                                        call(
                                            ca_bundle=None,
                                            password=None,
                                            server=None,
                                            username=None,
                                            verify_ssl=verify_ssl,
                                        )
                                    ],
                                )
                                self.assertEqual(
                                    ret, {"Categories": self.list_tag_categories_return}
                                )
    def test_list_tags_client_none(self):
        get_details = MagicMock(return_value=self.details)
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware, "get_vsphere_client", return_value=None
                        ) as get_vsphere_client:
                            ret = vsphere.list_tags()
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, {"Tags": None})
    def test_list_tags_client(self):
        get_details = MagicMock(return_value=self.details)
        mock_client = Mock(
            tagging=Mock(Tag=Mock(list=Mock(return_value=self.list_tags_return)))
        )
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware,
                            "get_vsphere_client",
                            return_value=mock_client,
                        ) as get_vsphere_client:
                            ret = vsphere.list_tags()
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, {"Tags": self.list_tags_return})
    def test_list_tags_client_verify_ssl(self):
        for verify_ssl in [True, False]:
            details = self.details.copy()
            if verify_ssl is not None:
                details["verify_ssl"] = verify_ssl
            else:
                verify_ssl = True
            get_details = MagicMock(return_value=details)
            mock_client = Mock(
                tagging=Mock(Tag=Mock(list=Mock(return_value=self.list_tags_return)))
            )
            with patch.object(
                vsphere, "get_proxy_type", return_value="vcenter"
            ) as get_proxy_type:
                with patch.object(
                    vsphere, "_get_proxy_connection_details", return_value=[]
                ) as get_proxy_connection:
                    with patch.object(
                        salt.utils.vmware, "get_service_instance", return_value=None
                    ) as get_service_instance:
                        with patch.dict(
                            vsphere.__salt__,
                            {"vcenter.get_details": get_details},
                            clear=True,
                        ) as get_vcenter_details:
                            with patch.object(
                                salt.utils.vmware,
                                "get_vsphere_client",
                                return_value=mock_client,
                            ) as get_vsphere_client:
                                ret = vsphere.list_tags()
                                self.assertEqual(ret, {"Tags": self.list_tags_return})
                                self.assertEqual(
                                    get_vsphere_client.call_args_list,
                                    [
                                        call(
                                            ca_bundle=None,
                                            password=None,
                                            server=None,
                                            username=None,
                                            verify_ssl=verify_ssl,
                                        )
                                    ],
                                )
    def test_list_attached_tags_client_none(self):
        get_details = MagicMock(return_value=self.details)
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware, "get_vsphere_client", return_value=None
                        ) as get_vsphere_client:
                            with patch.object(vsphere, "DynamicID") as dynamic_id:
                                ret = vsphere.list_attached_tags("object_id")
                                get_proxy_type.assert_called_once()
                                get_proxy_connection.assert_called_once()
                                get_service_instance.assert_called_once()
                                get_vsphere_client.assert_called_once()
                                self.assertEqual(ret, {"Attached tags": None})
    def test_list_attached_tags_client(self):
        for verify_ssl in [True, False, None]:
            details = self.details.copy()
            if verify_ssl is None:
                verify_ssl = True
            else:
                details["verify_ssl"] = verify_ssl
            get_details = MagicMock(return_value=details)
            mock_client = Mock(
                tagging=Mock(
                    TagAssociation=Mock(
                        list_attached_tags=Mock(
                            return_value=self.list_attached_tags_return
                        )
                    )
                )
            )
            with patch.object(
                vsphere, "get_proxy_type", return_value="vcenter"
            ) as get_proxy_type:
                with patch.object(
                    vsphere, "_get_proxy_connection_details", return_value=[]
                ) as get_proxy_connection:
                    with patch.object(
                        salt.utils.vmware, "get_service_instance", return_value=None
                    ) as get_service_instance:
                        with patch.dict(
                            vsphere.__salt__,
                            {"vcenter.get_details": get_details},
                            clear=True,
                        ) as get_vcenter_details:
                            with patch.object(
                                salt.utils.vmware,
                                "get_vsphere_client",
                                return_value=mock_client,
                            ) as get_vsphere_client:
                                with patch.object(vsphere, "DynamicID") as dynamic_id:
                                    ret = vsphere.list_attached_tags(
                                        self.func_attrs["object_id"]
                                    )
                                    get_proxy_type.assert_called_once()
                                    get_proxy_connection.assert_called_once()
                                    get_service_instance.assert_called_once()
                                    get_vsphere_client.assert_called_once()
                                    self.assertEqual(
                                        ret,
                                        {
                                            "Attached tags": self.list_attached_tags_return
                                        },
                                    )
                                    self.assertEqual(
                                        get_vsphere_client.call_args_list,
                                        [
                                            call(
                                                ca_bundle=None,
                                                password=None,
                                                server=None,
                                                username=None,
                                                verify_ssl=verify_ssl,
                                            )
                                        ],
                                    )
    def test_attach_tags_client_none(self):
        get_details = MagicMock(return_value=self.details)
        with patch.object(
            vsphere, "get_proxy_type", return_value="vcenter"
        ) as get_proxy_type:
            with patch.object(
                vsphere, "_get_proxy_connection_details", return_value=[]
            ) as get_proxy_connection:
                with patch.object(
                    salt.utils.vmware, "get_service_instance", return_value=None
                ) as get_service_instance:
                    with patch.dict(
                        vsphere.__salt__,
                        {"vcenter.get_details": get_details},
                        clear=True,
                    ) as get_vcenter_details:
                        with patch.object(
                            salt.utils.vmware, "get_vsphere_client", return_value=None
                        ) as get_vsphere_client:
                            ret = vsphere.attach_tag(
                                object_id=self.func_attrs["object_id"],
                                tag_id=self.func_attrs["tag_id"],
                            )
                            get_proxy_type.assert_called_once()
                            get_proxy_connection.assert_called_once()
                            get_service_instance.assert_called_once()
                            get_vsphere_client.assert_called_once()
                            self.assertEqual(ret, {"Tag attached": None})
    def test_attach_tags_client(self):
        for verify_ssl in [True, False, None]:
            details = self.details.copy()
            if verify_ssl is None:
                verify_ssl = True
            else:
                details["verify_ssl"] = verify_ssl
            get_details = MagicMock(return_value=details)
            mock_client = Mock(
                tagging=Mock(
                    TagAssociation=Mock(
                        attach=Mock(return_value=self.list_attached_tags_return)
                    )
                )
            )
            with patch.object(
                vsphere, "get_proxy_type", return_value="vcenter"
            ) as get_proxy_type:
                with patch.object(
                    vsphere, "_get_proxy_connection_details", return_value=[]
                ) as get_proxy_connection:
                    with patch.object(
                        salt.utils.vmware, "get_service_instance", return_value=None
                    ) as get_service_instance:
                        with patch.dict(
                            vsphere.__salt__,
                            {"vcenter.get_details": get_details},
                            clear=True,
                        ) as get_vcenter_details:
                            with patch.object(
                                salt.utils.vmware,
                                "get_vsphere_client",
                                return_value=mock_client,
                            ) as get_vsphere_client:
                                with patch.object(vsphere, "DynamicID") as dynamic_id:
                                    ret = vsphere.attach_tag(
                                        object_id=self.func_attrs["object_id"],
                                        tag_id=self.func_attrs["tag_id"],
                                    )
                                    get_proxy_type.assert_called_once()
                                    get_proxy_connection.assert_called_once()
                                    get_service_instance.assert_called_once()
                                    get_vsphere_client.assert_called_once()
                                    self.assertEqual(
                                        get_vsphere_client.call_args_list,
                                        [
                                            call(
                                                ca_bundle=None,
                                                password=None,
                                                server=None,
                                                username=None,
                                                verify_ssl=verify_ssl,
                                            )
                                        ],
                                    )
                                    self.assertEqual(
                                        ret,
                                        {
                                            "Tag attached": self.list_attached_tags_return
                                        },
                                    )
    def test_get_client(self):
        """
        test get_client when verify_ssl and ca_bundle are not passed
        """
        mock_client = MagicMock(return_value=None)
        patch_client = patch("salt.utils.vmware.get_vsphere_client", mock_client)
        cert_path = "/test/ca-certificates.crt"
        mock_ca = MagicMock(return_value=cert_path)
        patch_ca = patch("salt.utils.http.get_ca_bundle", mock_ca)
        mock_details = MagicMock(return_value=self.details)
        patch_details = patch.dict(
            vsphere.__salt__, {"vcenter.get_details": mock_details}
        )
        with patch_client, patch_ca, patch_details:
            vsphere._get_client(
                server="localhost", username="testuser", password="testpassword"
            )
            self.assertEqual(
                mock_client.call_args_list,
                [
                    call(
                        ca_bundle=None,
                        password="testpassword",
                        server="localhost",
                        username="testuser",
                        verify_ssl=True,
                    )
                ],
            )
            self.assertEqual(mock_details.assert_called_once(), None)
            self.assertEqual(mock_ca.assert_not_called(), None)
    def test_get_client_verify_ssl_false(self):
        """
        test get_client when verify_ssl=False is set
        """
        details = self.details.copy()
        details["verify_ssl"] = False
        mock_client = MagicMock(return_value=None)
        patch_client = patch("salt.utils.vmware.get_vsphere_client", mock_client)
        cert_path = "/test/ca-certificates.crt"
        mock_ca = MagicMock(return_value=cert_path)
        patch_ca = patch("salt.utils.http.get_ca_bundle", mock_ca)
        mock_details = MagicMock(return_value=details)
        patch_details = patch.dict(
            vsphere.__salt__, {"vcenter.get_details": mock_details}
        )
        with patch_client, patch_ca, patch_details:
            vsphere._get_client(
                server="localhost", username="testuser", password="testpassword"
            )
            self.assertEqual(
                mock_client.call_args_list,
                [
                    call(
                        ca_bundle=None,
                        password="testpassword",
                        server="localhost",
                        username="testuser",
                        verify_ssl=False,
                    )
                ],
            )
            self.assertEqual(mock_details.assert_called_once(), None)
            self.assertEqual(mock_ca.assert_not_called(), None)
    def test_get_client_verify_ssl_false_ca_bundle(self):
        """
        test get_client when verify_ssl=False and ca_bundle set
        """
        details = self.details.copy()
        details["verify_ssl"] = False
        details["ca_bundle"] = "/tmp/test"
        mock_client = MagicMock(return_value=None)
        patch_client = patch("salt.utils.vmware.get_vsphere_client", mock_client)
        cert_path = "/test/ca-certificates.crt"
        mock_ca = MagicMock(return_value=cert_path)
        patch_ca = patch("salt.utils.http.get_ca_bundle", mock_ca)
        mock_details = MagicMock(return_value=details)
        patch_details = patch.dict(
            vsphere.__salt__, {"vcenter.get_details": mock_details}
        )
        with patch_client, patch_ca, patch_details:
            self.assertFalse(
                vsphere._get_client(
                    server="localhost", username="testuser", password="testpassword"
                )
            )
            self.assertEqual(mock_details.assert_called_once(), None)
            self.assertEqual(mock_ca.assert_not_called(), None)
    def test_get_client_ca_bundle(self):
        """
        test get_client when verify_ssl=False and ca_bundle set
        """
        cert_path = "/test/ca-certificates.crt"
        details = self.details.copy()
        details["ca_bundle"] = cert_path
        mock_client = MagicMock(return_value=None)
        patch_client = patch("salt.utils.vmware.get_vsphere_client", mock_client)
        mock_ca = MagicMock(return_value=cert_path)
        patch_ca = patch("salt.utils.http.get_ca_bundle", mock_ca)
        mock_details = MagicMock(return_value=details)
        patch_details = patch.dict(
            vsphere.__salt__, {"vcenter.get_details": mock_details}
        )
        with patch_client, patch_ca, patch_details:
            vsphere._get_client(
                server="localhost", username="testuser", password="testpassword"
            )
            self.assertEqual(
                mock_client.call_args_list,
                [
                    call(
                        ca_bundle=cert_path,
                        password="testpassword",
                        server="localhost",
                        username="testuser",
                        verify_ssl=True,
                    )
                ],
            )
            self.assertEqual(mock_details.assert_called_once(), None)
            self.assertEqual(mock_ca.assert_called_once(), None)
            self.assertEqual(mock_ca.call_args_list, [call({"ca_bundle": cert_path})])
class TestCertificateVerify(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {vsphere: {}}
    def test_upload_ssh_key(self):
        kwargs_values = [
            ("ssh_key", "TheSSHKeyFile"),
            ("ssh_key_file", "TheSSHKeyFile"),
        ]
        certificate_verify_values = (None, True, False)
        for kw_key, kw_value in kwargs_values:
            kwargs = {kw_key: kw_value}
            if kw_key == "ssh_key":
                expected_kwargs = {"data": kw_value}
            else:
                expected_kwargs = {"data_file": kw_value, "data_render": False}
            for certificate_verify_value in certificate_verify_values:
                http_query_mock = MagicMock()
                if certificate_verify_value is None:
                    certificate_verify_value = True
                with patch("salt.utils.http.query", http_query_mock):
                    vsphere.upload_ssh_key(
                        HOST,
                        USER,
                        PASSWORD,
                        certificate_verify=certificate_verify_value,
                        **kwargs
                    )
                http_query_mock.assert_called_once_with(
                    "https://1.2.3.4:443/host/ssh_root_authorized_keys",
                    method="PUT",
                    password="SuperSecret!",
                    status=True,
                    text=True,
                    username="root",
                    verify_ssl=certificate_verify_value,
                    **expected_kwargs
                )
    def test_get_ssh_key(self):
        certificate_verify_values = (None, True, False)
        for certificate_verify_value in certificate_verify_values:
            http_query_mock = MagicMock()
            if certificate_verify_value is None:
                certificate_verify_value = True
            with patch("salt.utils.http.query", http_query_mock):
                vsphere.get_ssh_key(
                    HOST, USER, PASSWORD, certificate_verify=certificate_verify_value
                )
            http_query_mock.assert_called_once_with(
                "https://1.2.3.4:443/host/ssh_root_authorized_keys",
                method="GET",
                password="SuperSecret!",
                status=True,
                text=True,
                username="root",
                verify_ssl=certificate_verify_value,
            )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
