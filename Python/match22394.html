<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_redismod.py & test_http_3.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_redismod.py & test_http_3.py
      </h3>
      <h1 align="center">
        9.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_redismod.py (16.0%)<TH>test_http_3.py (6.818182%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match22394-0.html#0',2,'match22394-1.html#0',3)" NAME="0">(23-31)<TD><A HREF="javascript:ZweiFrames('match22394-0.html#0',2,'match22394-1.html#0',3)" NAME="0">(39-42)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_redismod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
&quot;&quot;&quot;

import pytest
import salt.states.redismod as redismod
from tests.support.mock import MagicMock, patch


@pytest.fixture
def configure_loader_modules():
    return {redismod: {}}


def test_string():
    &quot;&quot;&quot;
    Test to ensure that the key exists in redis with the value specified.
    &quot;&quot;&quot;
    name = &quot;key_in_redis&quot;
<A NAME="0"></A>    value = &quot;string data&quot;

    ret = {
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match22394-1.html#0',3,'match22394-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>&quot;name&quot;: name,
        &quot;changes&quot;: {},
        &quot;result&quot;: True,
        &quot;comment&quot;: &quot;Key already set to defined value&quot;,
    }

    mock = MagicMock(return_value=value)
    with patch.dict(redismod.__salt__, {&quot;redis.get_key&quot;: mock}):
        assert redismod.string(</B></FONT>name, value) == ret


def test_absent():
    &quot;&quot;&quot;
    Test to ensure key absent from redis.
    &quot;&quot;&quot;
    name = &quot;key_in_redis&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;}

    mock = MagicMock(side_effect=[False, True, True])
    mock_t = MagicMock(return_value=False)
    with patch.dict(redismod.__salt__, {&quot;redis.exists&quot;: mock, &quot;redis.delete&quot;: mock_t}):
        comt = &quot;`keys` not formed as a list type&quot;
        ret.update({&quot;comment&quot;: comt, &quot;result&quot;: False})
        assert redismod.absent(name, &quot;key&quot;) == ret

        comt = &quot;Key(s) specified already absent&quot;
        ret.update({&quot;comment&quot;: comt, &quot;result&quot;: True})
        assert redismod.absent(name, [&quot;key&quot;]) == ret

        comt = &quot;Keys deleted&quot;
        ret.update({&quot;comment&quot;: comt, &quot;changes&quot;: {&quot;deleted&quot;: [&quot;key&quot;]}})
        assert redismod.absent(name, [&quot;key&quot;]) == ret

        comt = &quot;Key deleted&quot;
        ret.update({&quot;comment&quot;: comt, &quot;changes&quot;: {&quot;deleted&quot;: [&quot;key_in_redis&quot;]}})
        assert redismod.absent(name) == ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_http_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Rahul Handay &lt;rahulha@saltstack.com&gt;
&quot;&quot;&quot;

import pytest
import salt.states.http as http
from tests.support.mock import MagicMock, patch


@pytest.fixture
def configure_loader_modules():
    return {http: {}}


def test_query():
    &quot;&quot;&quot;
    Test to perform an HTTP query and statefully return the result
    &quot;&quot;&quot;
    ret = [
        {
            &quot;changes&quot;: {},
            &quot;comment&quot;: (
                &quot; Either match text (match) or a status code (status) is required.&quot;
            ),
            &quot;data&quot;: {},
            &quot;name&quot;: &quot;salt&quot;,
            &quot;result&quot;: False,
        },
        {
            &quot;changes&quot;: {},
            &quot;comment&quot;: &quot; (TEST MODE)&quot;,
            &quot;data&quot;: True,
            &quot;name&quot;: &quot;salt&quot;,
            &quot;result&quot;: None,
        },
<A NAME="0"></A>    ]
    assert http.query(&quot;salt&quot;) == ret[0]

    with patch.dict(http.__opts__, {<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match22394-0.html#0',2,'match22394-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;test&quot;: True}):
        mock = MagicMock(return_value=True)
        with patch.dict(http.__salt__, {&quot;http.query&quot;: mock}):
            assert http.query(</B></FONT>&quot;salt&quot;, &quot;Dude&quot;, &quot;stack&quot;) == ret[1]


def test_query_pcre_statustype():
    &quot;&quot;&quot;
    Test to perform an HTTP query with a regex used to match the status code and statefully return the result
    &quot;&quot;&quot;
    testurl = &quot;salturl&quot;
    http_result = {&quot;text&quot;: &quot;This page returned a 201 status code&quot;, &quot;status&quot;: &quot;201&quot;}
    state_return = {
        &quot;changes&quot;: {},
        &quot;comment&quot;: (
            'Match text &quot;This page returned&quot; was found. Status pattern &quot;200|201&quot; was'
            &quot; found.&quot;
        ),
        &quot;data&quot;: {&quot;status&quot;: &quot;201&quot;, &quot;text&quot;: &quot;This page returned a 201 status code&quot;},
        &quot;name&quot;: testurl,
        &quot;result&quot;: True,
    }

    with patch.dict(http.__opts__, {&quot;test&quot;: False}):
        mock = MagicMock(return_value=http_result)
        with patch.dict(http.__salt__, {&quot;http.query&quot;: mock}):
            assert (
                http.query(
                    testurl,
                    match=&quot;This page returned&quot;,
                    status=&quot;200|201&quot;,
                    status_type=&quot;pcre&quot;,
                )
                == state_return
            )


def test_query_stringstatustype():
    &quot;&quot;&quot;
    Test to perform an HTTP query with a string status code and statefully return the result
    &quot;&quot;&quot;
    testurl = &quot;salturl&quot;
    http_result = {&quot;text&quot;: &quot;This page returned a 201 status code&quot;, &quot;status&quot;: &quot;201&quot;}
    state_return = {
        &quot;changes&quot;: {},
        &quot;comment&quot;: 'Match text &quot;This page returned&quot; was found. Status 201 was found.',
        &quot;data&quot;: {&quot;status&quot;: &quot;201&quot;, &quot;text&quot;: &quot;This page returned a 201 status code&quot;},
        &quot;name&quot;: testurl,
        &quot;result&quot;: True,
    }

    with patch.dict(http.__opts__, {&quot;test&quot;: False}):
        mock = MagicMock(return_value=http_result)
        with patch.dict(http.__salt__, {&quot;http.query&quot;: mock}):
            assert (
                http.query(
                    testurl,
                    match=&quot;This page returned&quot;,
                    status=&quot;201&quot;,
                    status_type=&quot;string&quot;,
                )
                == state_return
            )


def test_query_liststatustype():
    &quot;&quot;&quot;
    Test to perform an HTTP query with a list of status codes and statefully return the result
    &quot;&quot;&quot;
    testurl = &quot;salturl&quot;
    http_result = {&quot;text&quot;: &quot;This page returned a 201 status code&quot;, &quot;status&quot;: &quot;201&quot;}
    state_return = {
        &quot;changes&quot;: {},
        &quot;comment&quot;: 'Match text &quot;This page returned&quot; was found. Status 201 was found.',
        &quot;data&quot;: {&quot;status&quot;: &quot;201&quot;, &quot;text&quot;: &quot;This page returned a 201 status code&quot;},
        &quot;name&quot;: testurl,
        &quot;result&quot;: True,
    }

    with patch.dict(http.__opts__, {&quot;test&quot;: False}):
        mock = MagicMock(return_value=http_result)
        with patch.dict(http.__salt__, {&quot;http.query&quot;: mock}):
            assert (
                http.query(
                    testurl,
                    match=&quot;This page returned&quot;,
                    status=[&quot;200&quot;, &quot;201&quot;],
                    status_type=&quot;list&quot;,
                )
                == state_return
            )


def test_wait_for_with_interval():
    &quot;&quot;&quot;
    Test for wait_for_successful_query waits for request_interval
    &quot;&quot;&quot;

    query_mock = MagicMock(side_effect=[{&quot;error&quot;: &quot;error&quot;}, {&quot;result&quot;: True}])

    with patch.object(http, &quot;query&quot;, query_mock):
        with patch(&quot;time.sleep&quot;, MagicMock()) as sleep_mock:
            assert http.wait_for_successful_query(
                &quot;url&quot;, request_interval=1, status=200
            ) == {&quot;result&quot;: True}
            sleep_mock.assert_called_once_with(1)


def test_wait_for_without_interval():
    &quot;&quot;&quot;
    Test for wait_for_successful_query waits for request_interval
    &quot;&quot;&quot;

    query_mock = MagicMock(side_effect=[{&quot;error&quot;: &quot;error&quot;}, {&quot;result&quot;: True}])

    with patch.object(http, &quot;query&quot;, query_mock):
        with patch(&quot;time.sleep&quot;, MagicMock()) as sleep_mock:
            assert http.wait_for_successful_query(&quot;url&quot;, status=200) == {&quot;result&quot;: True}
            sleep_mock.assert_not_called()
</PRE>
</div>
  </div>
</body>
</html>
