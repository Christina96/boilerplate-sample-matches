<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for linux_sysctl.py &amp; zypperpkg.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for linux_sysctl.py &amp; zypperpkg.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>linux_sysctl.py (12.275449%)<th>zypperpkg.py (1.4133058%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(202-214)<td><a href="#" name="0">(668-672)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(188-193)<td><a href="#" name="1">(2040-2042)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(5-18)<td><a href="#" name="2">(31-42)</a><td align="center"><font color="#bf0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>linux_sysctl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
2 import os
3 import re
4 import salt.utils.data
5 import salt.utils.files
6 import salt.utils.stringutils
7 import salt.utils.systemd
8 from salt.exceptions import CommandExecutionError
9 log = logging.getLogger(__name__)
10 __virtualname__ =</b></font> "sysctl"
11 def __virtual__():
12     if __grains__["kernel"] != "Linux":
13         return (
14             False,
15             "The linux_sysctl execution module cannot be loaded: only available on"
16             " Linux systems.",
17         )
18     return __virtualname__
19 def default_config():
20     if (
21         salt.utils.systemd.booted(__context__)
22         and salt.utils.systemd.version(__context__) &gt;= 207
23     ):
24         return "/etc/sysctl.d/99-salt.conf"
25     return "/etc/sysctl.conf"
26 def show(config_file=False):
27     ret = {}
28     if config_file:
29         if not os.path.exists(config_file):
30             return []
31         try:
32             with salt.utils.files.fopen(config_file) as fp_:
33                 for line in fp_:
34                     line = salt.utils.stringutils.to_str(line)
35                     if not line.startswith("#") and "=" in line:
36                         SPLIT = " = "
37                         if SPLIT not in line:
38                             SPLIT = SPLIT.strip()
39                         key, value = line.split(SPLIT, 1)
40                         key = key.strip()
41                         value = value.lstrip()
42                         ret[key] = value
43         except OSError:
44             log.error("Could not open sysctl file")
45             return None
46     else:
47         cmd = "sysctl -a"
48         out = __salt__["cmd.run_stdout"](cmd, output_loglevel="trace")
49         for line in out.splitlines():
50             if not line or " = " not in line:
51                 continue
52             comps = line.split(" = ", 1)
53             ret[comps[0]] = comps[1]
54     return ret
55 def get(name):
56     cmd = "sysctl -n {}".format(name)
57     out = __salt__["cmd.run"](cmd, python_shell=False)
58     return out
59 def assign(name, value):
60     value = str(value)
61     tran_tab = name.translate("".maketrans("./", "/."))
62     sysctl_file = "/proc/sys/{}".format(tran_tab)
63     if not os.path.exists(sysctl_file):
64         raise CommandExecutionError("sysctl {} does not exist".format(name))
65     ret = {}
66     cmd = 'sysctl -w {}="{}"'.format(name, value)
67     data = __salt__["cmd.run_all"](cmd, python_shell=False)
68     out = data["stdout"]
69     err = data["stderr"]
70     regex = re.compile(r"^{}\s+=\s+{}$".format(re.escape(name), re.escape(value)))
71     if not regex.match(out) or "Invalid argument" in str(err):
72         if data["retcode"] != 0 and err:
73             error = err
74         else:
75             error = out
76         raise CommandExecutionError("sysctl -w failed: {}".format(error))
77     new_name, new_value = out.split(" = ", 1)
78     ret[new_name] = new_value
79     return ret
80 def persist(name, value, config=None):
81     if config is None:
82         config = default_config()
83     edited = False
84     if not os.path.isfile(config):
85         sysctl_dir = os.path.dirname(config)
86         if not os.path.exists(sysctl_dir):
87             os.makedirs(sysctl_dir)
88         try:
89             with salt.utils.files.fopen(config, "w+") as _fh:
90                 _fh.write("#\n# Kernel sysctl configuration\n#\n")
91         except OSError:
92             msg = "Could not write to file: {0}"
93             raise CommandExecutionError(msg.format(config))
94     nlines = []
95     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try:
96         with salt.utils.files.fopen(config, "r") as _fh:
97             config_data = salt.utils.data.decode(_fh.readlines(</b></font>))
98     except OSError:
99         msg = "Could not read from file: {0}"
100         raise CommandExecutionError(msg.format(config))
101     for line in config_data:
102             nlines.append(line)
103             continue
104         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if "=" not in line:
105             nlines.append(line)
106             continue
107         comps = [i.strip() for i in line.split("=", 1)]
108         if isinstance(comps[1], str) and " " in comps[1]:
109             comps[</b></font>1] = re.sub(r"\s+", "\t", comps[1])
110         if isinstance(value, str) and " " in value:
111             value = re.sub(r"\s+", "\t", value)
112         if len(comps) &lt; 2:
113             nlines.append(line)
114             continue
115         if name == comps[0]:
116             if str(comps[1]) == str(value):
117                 if str(get(name)) != str(value):
118                     assign(name, value)
119                     return "Updated"
120                 else:
121                     return "Already set"
122             nlines.append("{} = {}\n".format(name, value))
123             edited = True
124             continue
125         else:
126             nlines.append(line)
127     if not edited:
128         nlines.append("{} = {}\n".format(name, value))
129     try:
130         with salt.utils.files.fopen(config, "wb") as _fh:
131             _fh.writelines(salt.utils.data.encode(nlines))
132     except OSError:
133         msg = "Could not write to file: {0}"
134         raise CommandExecutionError(msg.format(config))
135     assign(name, value)
136     return "Updated"
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>zypperpkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import configparser
2 import datetime
3 import fnmatch
4 import logging
5 import os
6 import re
7 import time
8 import urllib.parse
9 from xml.dom import minidom as dom
10 from xml.parsers.expat import ExpatError
11 import salt.utils.data
12 import salt.utils.environment
13 import salt.utils.files
14 import salt.utils.functools
15 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.path
16 import salt.utils.pkg
17 import salt.utils.pkg.rpm
18 import salt.utils.stringutils
19 import salt.utils.systemd
20 import salt.utils.versions
21 from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
22 from salt.utils.versions import LooseVersion
23 log = logging.getLogger(__name__)
24 HAS_ZYPP =</b></font> False
25 ZYPP_HOME = "/etc/zypp"
26 LOCKS = "{}/locks".format(ZYPP_HOME)
27 REPOS = "{}/repos.d".format(ZYPP_HOME)
28 DEFAULT_PRIORITY = 99
29 PKG_ARCH_SEPARATOR = "."
30 __virtualname__ = "pkg"
31 def __virtual__():
32     if __grains__.get("os_family", "") != "Suse":
33         return (
34             False,
35             "Module zypper: non SUSE OS not supported by zypper package manager",
36         )
37     if not salt.utils.path.which("zypper"):
38         return (False, "Module zypper: zypper package manager not found")
39     return __virtualname__
40 class _Zypper:
41     SUCCESS_EXIT_CODES = {
42         0: "Successful run of zypper with no special info.",
43         100: "Patches are available for installation.",
44         101: "Security patches are available for installation.",
45         102: "Installation successful, reboot required.",
46         103: "Installation successful, restart of the package manager itself required.",
47     }
48     WARNING_EXIT_CODES = {
49         6: "No repositories are defined.",
50         7: "The ZYPP library is locked.",
51         106: (
52             "Some repository had to be disabled temporarily because it failed to"
53             " refresh. You should check your repository configuration (e.g. zypper ref"
54             " -f)."
55         ),
56         107: (
57             "Installation basically succeeded, but some of the packages %post install"
58             " scripts returned an error. These packages were successfully unpacked to"
59             " disk and are registered in the rpm database, but due to the failed"
60             " install script they may not work as expected. The failed scripts output"
61             " might reveal what actually went wrong. Any scripts output is also logged"
62             " to /var/log/zypp/history."
63         ),
64     }
65     LOCK_EXIT_CODE = 7
66     XML_DIRECTIVES = ["-x", "--xmlout"]
67     ZYPPER_LOCK = "/var/run/zypp.pid"
68     TAG_RELEASED = "zypper/released"
69     TAG_BLOCKED = "zypper/blocked"
70     def __init__(self):
71         self._reset()
72     def _reset(self):
73         self.__cmd = ["zypper", "--non-interactive"]
74         self.__exit_code = 0
75         self.__call_result = dict()
76         self.__error_msg = ""
77         self.__env = salt.utils.environment.get_module_environment(globals())
78         self.__xml = False
79         self.__no_lock = False
80         self.__no_raise = False
81         self.__refresh = False
82         self.__ignore_repo_failure = False
83         self.__systemd_scope = False
84         self.__root = None
85         self.__called = False
86     def __call__(self, *args, **kwargs):
87         if self.__called:
88             self._reset()
89         if "no_repo_failure" in kwargs:
90             self.__ignore_repo_failure = kwargs["no_repo_failure"]
91         if "systemd_scope" in kwargs:
92             self.__systemd_scope = kwargs["systemd_scope"]
93         if "root" in kwargs:
94             self.__root = kwargs["root"]
95         return self
96     def __getattr__(self, item):
97         if self.__called:
98             self._reset()
99         if item == "xml":
100             self.__xml = True
101         elif item == "nolock":
102             self.__no_lock = True
103         elif item == "noraise":
104             self.__no_raise = True
105         elif item == "refreshable":
106             self.__refresh = True
107         elif item == "call":
108             return self.__call
109         else:
110             return self.__dict__[item]
111         if self.__no_lock:
112             self.__no_lock = not self.__refresh
113         return self
114     @property
115     def exit_code(self):
116         return self.__exit_code
117     @exit_code.setter
118     def exit_code(self, exit_code):
119         self.__exit_code = int(exit_code or "0")
120     @property
121     def error_msg(self):
122         return self.__error_msg
123     @error_msg.setter
124     def error_msg(self, msg):
125         if self._is_error():
126             self.__error_msg = msg and os.linesep.join(msg) or "Check Zypper's logs."
127     @property
128     def stdout(self):
129         return self.__call_result.get("stdout", "")
130     @property
131     def stderr(self):
132         return self.__call_result.get("stderr", "")
133     @property
134     def pid(self):
135         return self.__call_result.get("pid", "")
136     def _is_error(self):
137         if self.exit_code:
138             msg = self.SUCCESS_EXIT_CODES.get(self.exit_code)
139             if msg:
140                 log.info(msg)
141             msg = self.WARNING_EXIT_CODES.get(self.exit_code)
142             if msg:
143                 log.warning(msg)
144         return (
145             self.exit_code not in self.SUCCESS_EXIT_CODES
146             and self.exit_code not in self.WARNING_EXIT_CODES
147         )
148     def _is_lock(self):
149         return self.exit_code == self.LOCK_EXIT_CODE
150     def _is_xml_mode(self):
151         return (
152             [itm for itm in self.XML_DIRECTIVES if itm in self.__cmd] and True or False
153         )
154     def _check_result(self):
155         if not self.__call_result:
156             raise CommandExecutionError("No output result from Zypper?")
157         self.exit_code = self.__call_result["retcode"]
158         if self._is_lock():
159             return False
160         if self._is_error():
161             _error_msg = list()
162             if not self._is_xml_mode():
163                 msg = (
164                     self.__call_result["stderr"]
165                     and self.__call_result["stderr"].strip()
166                     or ""
167                 )
168                 if msg:
169                     _error_msg.append(msg)
170             else:
171                 try:
172                     doc = dom.parseString(self.__call_result["stdout"])
173                 except ExpatError as err:
174                     log.error(err)
175                     doc = None
176                 if doc:
177                     msg_nodes = doc.getElementsByTagName("message")
178                     for node in msg_nodes:
179                         if node.getAttribute("type") == "error":
180                             _error_msg.append(node.childNodes[0].nodeValue)
181                 elif self.__call_result["stderr"].strip():
182                     _error_msg.append(self.__call_result["stderr"].strip())
183             self.error_msg = _error_msg
184         return True
185     def __call(self, *args, **kwargs):
186         self.__called = True
187         if self.__xml:
188             self.__cmd.append("--xmlout")
189         if not self.__refresh and "--no-refresh" not in args:
190             self.__cmd.append("--no-refresh")
191         if self.__root:
192             self.__cmd.extend(["--root", self.__root])
193         self.__cmd.extend(args)
194         kwargs["output_loglevel"] = "trace"
195         kwargs["python_shell"] = False
196         kwargs["env"] = self.__env.copy()
197         if self.__no_lock:
198             kwargs["env"][
199                 "ZYPP_READONLY_HACK"
200             ] = (  # Disables locking for read-only operations. Do not try that at home!
201                 "1"
202             )
203         was_blocked = False
204         while True:
205             cmd = []
206             if self.__systemd_scope:
207                 cmd.extend(["systemd-run", "--scope"])
208             cmd.extend(self.__cmd)
209             log.debug("Calling Zypper: %s", " ".join(cmd))
210             self.__call_result = __salt__["cmd.run_all"](cmd, **kwargs)
211             if self._check_result():
212                 break
213             if os.path.exists(self.ZYPPER_LOCK):
214                 try:
215                     with salt.utils.files.fopen(self.ZYPPER_LOCK) as rfh:
216                         data = __salt__["ps.proc_info"](
217                             int(rfh.readline()),
218                             attrs=["pid", "name", "cmdline", "create_time"],
219                         )
220                         data["cmdline"] = " ".join(data["cmdline"])
221                         data["info"] = "Blocking process created at {}.".format(
222                             datetime.datetime.utcfromtimestamp(
223                                 data["create_time"]
224                             ).isoformat()
225                         )
226                         data["success"] = True
227                 except Exception as err:  # pylint: disable=broad-except
228                     data = {
229                         "info": (
230                             "Unable to retrieve information about blocking process: {}".format(
231                                 err.message
232                             )
233                         ),
234                         "success": False,
235                     }
236             else:
237                 data = {
238                     "info": "Zypper is locked, but no Zypper lock has been found.",
239                     "success": False,
240                 }
241             if not data["success"]:
242                 log.debug("Unable to collect data about blocking process.")
243             else:
244                 log.debug("Collected data about blocking process.")
245             __salt__["event.fire_master"](data, self.TAG_BLOCKED)
246             log.debug(
247                 "Fired a Zypper blocked event to the master with the data: %s", data
248             )
249             log.debug("Waiting 5 seconds for Zypper gets released...")
250             time.sleep(5)
251             if not was_blocked:
252                 was_blocked = True
253         if was_blocked:
254             __salt__["event.fire_master"](
255                 {
256                     "success": not self.error_msg,
257                     "info": self.error_msg or "Zypper has been released",
258                 },
259                 self.TAG_RELEASED,
260             )
261         if self.error_msg and not self.__no_raise and not self.__ignore_repo_failure:
262             raise CommandExecutionError(
263                 "Zypper command failure: {}".format(self.error_msg)
264             )
265         return (
266             self._is_xml_mode()
267             and dom.parseString(
268                 salt.utils.stringutils.to_str(self.__call_result["stdout"])
269             )
270             or self.__call_result["stdout"]
271         )
272 __zypper__ = _Zypper()
273 class Wildcard:
274     Z_OP = ["&lt;", "&lt;=", "=", "&gt;=", "&gt;"]
275     def __init__(self, zypper):
276         self.name = None
277         self.version = None
278         self.zypper = zypper
279         self._attr_solvable_version = "edition"
280         self._op = None
281     def __call__(self, pkg_name, pkg_version):
282         if pkg_version:
283             self.name = pkg_name
284             self._set_version(pkg_version)  # Dissects possible operator
285             versions = sorted(
286                 LooseVersion(vrs)
287                 for vrs in self._get_scope_versions(self._get_available_versions())
288             )
289             return versions and "{}{}".format(self._op or "", versions[-1]) or None
290     def _get_available_versions(self):
291         solvables = self.zypper.nolock.xml.call(
292             "se", "-xv", self.name
293         ).getElementsByTagName("solvable")
294         if not solvables:
295             raise CommandExecutionError(
296                 "No packages found matching '{}'".format(self.name)
297             )
298         return sorted(
299             {
300                 slv.getAttribute(self._attr_solvable_version)
301                 for slv in solvables
302                 if slv.getAttribute(self._attr_solvable_version)
303             }
304         )
305     def _get_scope_versions(self, pkg_versions):
306         get_in_versions = []
307         for p_version in pkg_versions:
308             if fnmatch.fnmatch(p_version, self.version):
309                 get_in_versions.append(p_version)
310         return get_in_versions
311     def _set_version(self, version):
312         if not version:
313             return
314         exact_version = re.sub(r"[&lt;&gt;=+]*", "", version)
315         self._op = version.replace(exact_version, "") or None
316         if self._op and self._op not in self.Z_OP:
317             raise CommandExecutionError(
318                 'Zypper do not supports operator "{}".'.format(self._op)
319             )
320         self.version = exact_version
321 def _systemd_scope():
322     return salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
323         "systemd.scope", True
324     )
325 def _clean_cache():
326     keys = []
327     for cache_name in ["pkg.list_pkgs", "pkg.list_provides"]:
328         for contextkey in __context__:
329             if contextkey.startswith(cache_name):
330                 keys.append(contextkey)
331     for key in keys:
332         __context__.pop(key, None)
333 def list_upgrades(refresh=True, root=None, **kwargs):
334     if refresh:
335         refresh_db(root)
336     ret = dict()
337     cmd = ["list-updates"]
338     if "fromrepo" in kwargs:
339         repos = kwargs["fromrepo"]
340         if isinstance(repos, str):
341             repos = [repos]
342         for repo in repos:
343             cmd.extend(["--repo", repo if isinstance(repo, str) else str(repo)])
344         log.debug("Targeting repos: %s", repos)
345     for update_node in (
346         __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("update")
347     ):
348         if update_node.getAttribute("kind") == "package":
349             ret[update_node.getAttribute("name")] = update_node.getAttribute("edition")
350     return ret
351 list_updates = salt.utils.functools.alias_function(list_upgrades, "list_updates")
352 def info_installed(*names, **kwargs):
353     all_versions = kwargs.get("all_versions", False)
354     ret = dict()
355     for pkg_name, pkgs_nfo in __salt__["lowpkg.info"](*names, **kwargs).items():
356         pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]
357         for _nfo in pkg_nfo:
358             t_nfo = dict()
359             for key, value in _nfo.items():
360                 if key == "source_rpm":
361                     t_nfo["source"] = value
362                 else:
363                     t_nfo[key] = value
364             if not all_versions:
365                 ret[pkg_name] = t_nfo
366             else:
367                 ret.setdefault(pkg_name, []).append(t_nfo)
368     return ret
369 def info_available(*names, **kwargs):
370     ret = {}
371     if not names:
372         return ret
373     else:
374         names = sorted(list(set(names)))
375     root = kwargs.get("root", None)
376     if kwargs.get("refresh", True):
377         refresh_db(root)
378     pkg_info = []
379     batch = names[:]
380     batch_size = 200
381     while batch:
382         pkg_info.extend(
383             re.split(
384                 r"Information for package*",
385                 __zypper__(root=root).nolock.call(
386                     "info", "-t", "package", *batch[:batch_size]
387                 ),
388             )
389         )
390         batch = batch[batch_size:]
391         nfo = {}
392         for line in [data for data in pkg_data.split("\n") if ":" in data]:
393             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if line.startswith("-----"):
394                 continue
395             kw = [data.strip() for data in line.split(":", 1)]
396             if len(kw) == 2 and kw[1]:
397                 nfo[kw[</b></font>0].lower()] = kw[1]
398         if nfo.get("name"):
399             name = nfo.pop("name")
400             ret[name] = nfo
401         if nfo.get("status"):
402             nfo["status"] = nfo.get("status")
403         if nfo.get("installed"):
404             nfo["installed"] = nfo.get("installed").lower().startswith("yes")
405     return ret
406 def parse_arch(name):
407     _name, _arch = None, None
408     try:
409         _name, _arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)
410     except ValueError:
411         pass
412     if _arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
413         _name = name
414         _arch = None
415     return {"name": _name, "arch": _arch}
416 def latest_version(*names, **kwargs):
417     ret = dict()
418     if not names:
419         return ret
420     names = sorted(list(set(names)))
421     package_info = info_available(*names, **kwargs)
422     for name in names:
423         pkg_info = package_info.get(name, {})
424         status = pkg_info.get("status", "").lower()
425         if status.find("not installed") &gt; -1 or status.find("out-of-date") &gt; -1:
426             ret[name] = pkg_info.get("version")
427         else:
428             ret[name] = ""
429     if len(names) == 1 and ret:
430         return ret[names[0]]
431     return ret
432 available_version = salt.utils.functools.alias_function(
433     latest_version, "available_version"
434 )
435 def upgrade_available(name, **kwargs):
436     return not not latest_version(name, **kwargs)  # pylint: disable=C0113
437 def version(*names, **kwargs):
438     return __salt__["pkg_resource.version"](*names, **kwargs) or {}
439 def version_cmp(ver1, ver2, ignore_epoch=False, **kwargs):
440     return __salt__["lowpkg.version_cmp"](ver1, ver2, ignore_epoch=ignore_epoch)
441 def _list_pkgs_from_context(versions_as_list, contextkey, attr):
442     return __salt__["pkg_resource.format_pkg_list"](
443         __context__[contextkey], versions_as_list, attr
444     )
445 def list_pkgs(versions_as_list=False, root=None, includes=None, **kwargs):
446     versions_as_list = salt.utils.data.is_true(versions_as_list)
447     if any(
448         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
449     ):
450         return {}
451     attr = kwargs.get("attr")
452     if attr is not None:
453         attr = salt.utils.args.split_input(attr)
454     includes = includes if includes else []
455     contextkey = "pkg.list_pkgs_{}_{}".format(root, includes)
456     if contextkey in __context__ and kwargs.get("use_context", True):
457         return _list_pkgs_from_context(versions_as_list, contextkey, attr)
458     ret = {}
459     cmd = ["rpm"]
460     if root:
461         cmd.extend(["--root", root])
462     cmd.extend(
463         [
464             "-qa",
465             "--queryformat",
466             salt.utils.pkg.rpm.QUERYFORMAT.replace("%{REPOID}", "(none)") + "\n",
467         ]
468     )
469     output = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="trace")
470     for line in output.splitlines():
471         pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__["osarch"])
472         if pkginfo:
473             pkgver = pkginfo.version
474             epoch = None
475             release = None
476             if ":" in pkgver:
477                 epoch, pkgver = pkgver.split(":", 1)
478             if "-" in pkgver:
479                 pkgver, release = pkgver.split("-", 1)
480             all_attr = {
481                 "epoch": epoch,
482                 "version": pkgver,
483                 "release": release,
484                 "arch": pkginfo.arch,
485                 "install_date": pkginfo.install_date,
486                 "install_date_time_t": pkginfo.install_date_time_t,
487             }
488             __salt__["pkg_resource.add_pkg"](ret, pkginfo.name, all_attr)
489     _ret = {}
490     for pkgname in ret:
491         if pkgname.startswith("gpg-pubkey"):
492             continue
493         _ret[pkgname] = sorted(ret[pkgname], key=lambda d: d["version"])
494     for include in includes:
495         if include == "product":
496             products = list_products(all=False, root=root)
497             for product in products:
498                 extended_name = "{}:{}".format(include, product["name"])
499                 _ret[extended_name] = [
500                     {
501                         "epoch": product["epoch"],
502                         "version": product["version"],
503                         "release": product["release"],
504                         "arch": product["arch"],
505                         "install_date": None,
506                         "install_date_time_t": None,
507                     }
508                 ]
509         if include in ("pattern", "patch"):
510             if include == "pattern":
511                 elements = list_installed_patterns(root=root)
512             elif include == "patch":
513                 elements = list_installed_patches(root=root)
514             else:
515                 elements = []
516             for element in elements:
517                 extended_name = "{}:{}".format(include, element)
518                 info = info_available(extended_name, refresh=False, root=root)
519                 _ret[extended_name] = [
520                     {
521                         "epoch": None,
522                         "version": info[element]["version"],
523                         "release": None,
524                         "arch": info[element]["arch"],
525                         "install_date": None,
526                         "install_date_time_t": None,
527                     }
528                 ]
529     __context__[contextkey] = _ret
530     return __salt__["pkg_resource.format_pkg_list"](
531         __context__[contextkey], versions_as_list, attr
532     )
533 def list_repo_pkgs(*args, **kwargs):
534     byrepo = kwargs.pop("byrepo", False)
535     fromrepo = kwargs.pop("fromrepo", "") or ""
536     ret = {}
537     targets = [arg if isinstance(arg, str) else str(arg) for arg in args]
538     def _is_match(pkgname):
539         if not args:
540             return True
541         for target in targets:
542             if fnmatch.fnmatch(pkgname, target):
543                 return True
544         return False
545     root = kwargs.get("root") or None
546     for node in (
547         __zypper__(root=root)
548         .xml.call("se", "-s", *targets)
549         .getElementsByTagName("solvable")
550     ):
551         pkginfo = dict(node.attributes.items())
552         try:
553             if pkginfo["kind"] != "package":
554                 continue
555             reponame = pkginfo["repository"]
556             if fromrepo and reponame != fromrepo:
557                 continue
558             pkgname = pkginfo["name"]
559             pkgversion = pkginfo["edition"]
560         except KeyError:
561             continue
562         else:
563             if _is_match(pkgname):
564                 repo_dict = ret.setdefault(reponame, {})
565                 version_list = repo_dict.setdefault(pkgname, set())
566                 version_list.add(pkgversion)
567     if byrepo:
568         for reponame in ret:
569             for pkgname in ret[reponame]:
570                 sorted_versions = sorted(
571                     (LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True
572                 )
573                 ret[reponame][pkgname] = [x.vstring for x in sorted_versions]
574         return ret
575     else:
576         byrepo_ret = {}
577         for reponame in ret:
578             for pkgname in ret[reponame]:
579                 byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])
580         for pkgname in byrepo_ret:
581             sorted_versions = sorted(
582                 (LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True
583             )
584             byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]
585         return byrepo_ret
586 def _get_configured_repos(root=None):
587     repos = os.path.join(root, os.path.relpath(REPOS, os.path.sep)) if root else REPOS
588     repos_cfg = configparser.ConfigParser()
589     if os.path.exists(repos):
590         repos_cfg.read(
591             [
592                 repos + "/" + fname
593                 for fname in os.listdir(repos)
594                 if fname.endswith(".repo")
595             ]
596         )
597     else:
598         log.warning("Repositories not found in %s", repos)
599     return repos_cfg
600 def _get_repo_info(alias, repos_cfg=None, root=None):
601     try:
602         meta = dict((repos_cfg or _get_configured_repos(root=root)).items(alias))
603         meta["alias"] = alias
604         for key, val in meta.items():
605             if val in ["0", "1"]:
606                 meta[key] = int(meta[key]) == 1
607             elif val == "NONE":
608                 meta[key] = None
609         return meta
610     except (ValueError, configparser.NoSectionError):
611         return {}
612 def get_repo(repo, root=None, **kwargs):  # pylint: disable=unused-argument
613     return _get_repo_info(repo, root=root)
614 def list_repos(root=None, **kwargs):
615     repos_cfg = _get_configured_repos(root=root)
616     all_repos = {}
617     for alias in repos_cfg.sections():
618         all_repos[alias] = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
619     return all_repos
620 def del_repo(repo, root=None):
621     repos_cfg = _get_configured_repos(root=root)
622     for alias in repos_cfg.sections():
623         if alias == repo:
624             doc = __zypper__(root=root).xml.call(
625                 "rr", "--loose-auth", "--loose-query", alias
626             )
627             msg = doc.getElementsByTagName("message")
628             if doc.getElementsByTagName("progress") and msg:
629                 return {
630                     repo: True,
631                     "message": msg[0].childNodes[0].nodeValue,
632                 }
633     raise CommandExecutionError("Repository '{}' not found.".format(repo))
634 def mod_repo(repo, **kwargs):
635     root = kwargs.get("root") or None
636     repos_cfg = _get_configured_repos(root=root)
637     added = False
638     if repo not in repos_cfg.sections():
639         url = kwargs.get("url", kwargs.get("mirrorlist", kwargs.get("baseurl")))
640         if not url:
641             raise CommandExecutionError(
642                 "Repository '{}' not found, and neither 'baseurl' nor "
643                 "'mirrorlist' was specified".format(repo)
644             )
645         if not urllib.parse.urlparse(url).scheme:
646             raise CommandExecutionError(
647                 "Repository '{}' not found and URL for baseurl/mirrorlist "
648                 "is malformed".format(repo)
649             )
650         for alias in repos_cfg.sections():
651             repo_meta = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
652             new_url = urllib.parse.urlparse(url)
653             if not new_url.path:
654                 new_url = urllib.parse.urlparse.ParseResult(
655                     scheme=new_url.scheme,  # pylint: disable=E1123
656                     netloc=new_url.netloc,
657                     path="/",
658                     params=new_url.params,
659                     query=new_url.query,
660                     fragment=new_url.fragment,
661                 )
662             base_url = urllib.parse.urlparse(repo_meta["baseurl"])
663             if new_url == base_url:
664                 raise CommandExecutionError(
665                     "Repository '{}' already exists as '{}'.".format(repo, alias)
666                 )
667         __zypper__(root=root).xml.call("ar", url, repo)
668         repos_cfg = _get_configured_repos(root=root)
669         if repo not in repos_cfg.sections():
670             raise CommandExecutionError(
671                 "Failed add new repository '{}' for unspecified reason. "
672                 "Please check zypper logs.".format(repo)
673             )
674         added = True
675     repo_info = _get_repo_info(repo, root=root)
676     if (
677         not added
678         and "baseurl" in kwargs
679         and not (kwargs["baseurl"] == repo_info["baseurl"])
680     ):
681         repo_info.update(kwargs)
682         repo_info.setdefault("cache", False)
683         del_repo(repo, root=root)
684         return mod_repo(repo, root=root, **repo_info)
685     cmd_opt = []
686     global_cmd_opt = []
687     call_refresh = False
688     if "enabled" in kwargs:
689         cmd_opt.append(kwargs["enabled"] and "--enable" or "--disable")
690     if "refresh" in kwargs:
691         cmd_opt.append(kwargs["refresh"] and "--refresh" or "--no-refresh")
692     if "cache" in kwargs:
693         cmd_opt.append(kwargs["cache"] and "--keep-packages" or "--no-keep-packages")
694     if "gpgcheck" in kwargs:
695         cmd_opt.append(kwargs["gpgcheck"] and "--gpgcheck" or "--no-gpgcheck")
696     if "priority" in kwargs:
697         cmd_opt.append("--priority={}".format(kwargs.get("priority", DEFAULT_PRIORITY)))
698     if "humanname" in kwargs:
699         cmd_opt.append("--name='{}'".format(kwargs.get("humanname")))
700     if kwargs.get("gpgautoimport") is True:
701         global_cmd_opt.append("--gpg-auto-import-keys")
702         call_refresh = True
703     if cmd_opt:
704         cmd_opt = global_cmd_opt + ["mr"] + cmd_opt + [repo]
705         __zypper__(root=root).refreshable.xml.call(*cmd_opt)
706     comment = None
707     if call_refresh:
708         refresh_opts = global_cmd_opt + ["refresh"] + [repo]
709         __zypper__(root=root).xml.call(*refresh_opts)
710     elif not added and not cmd_opt:
711         comment = "Specified arguments did not result in modification of repo"
712     repo = get_repo(repo, root=root)
713     if comment:
714         repo["comment"] = comment
715     return repo
716 def refresh_db(force=None, root=None):
717     salt.utils.pkg.clear_rtag(__opts__)
718     ret = {}
719     refresh_opts = ["refresh"]
720     if force is None:
721         force = __pillar__.get("zypper", {}).get("refreshdb_force", True)
722     if force:
723         refresh_opts.append("--force")
724     out = __zypper__(root=root).refreshable.call(*refresh_opts)
725     for line in out.splitlines():
726         if not line:
727             continue
728         if line.strip().startswith("Repository") and "'" in line:
729             try:
730                 key = line.split("'")[1].strip()
731                 if "is up to date" in line:
732                     ret[key] = False
733             except IndexError:
734                 continue
735         elif line.strip().startswith("Building") and "'" in line:
736             key = line.split("'")[1].strip()
737             if "done" in line:
738                 ret[key] = True
739     return ret
740 def _find_types(pkgs):
741     return sorted({pkg.split(":", 1)[0] for pkg in pkgs if len(pkg.split(":", 1)) == 2})
742 def install(
743     name=None,
744     refresh=False,
745     fromrepo=None,
746     pkgs=None,
747     sources=None,
748     downloadonly=None,
749     skip_verify=False,
750     version=None,
751     ignore_repo_failure=False,
752     no_recommends=False,
753     root=None,
754     **kwargs
755 ):
756     if refresh:
757         refresh_db(root)
758     try:
759         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
760             name, pkgs, sources, **kwargs
761         )
762     except MinionError as exc:
763         raise CommandExecutionError(exc)
764     if pkg_params is None or len(pkg_params) == 0:
765         return {}
766     version_num = Wildcard(__zypper__(root=root))(name, version)
767     if version_num:
768         if pkgs is None and sources is None:
769             pkg_params = {name: version_num}
770         else:
771             log.warning(
772                 '"version" parameter will be ignored for multiple package targets'
773             )
774     if pkg_type == "repository":
775         targets = []
776         for param, version_num in pkg_params.items():
777             if version_num is None:
778                 log.debug("targeting package: %s", param)
779                 targets.append(param)
780             else:
781                 prefix, verstr = salt.utils.pkg.split_comparison(version_num)
782                 if not prefix:
783                     prefix = "="
784                 target = "{}{}{}".format(param, prefix, verstr)
785                 log.debug("targeting package: %s", target)
786                 targets.append(target)
787     elif pkg_type == "advisory":
788         targets = []
789         cur_patches = list_patches(root=root)
790         for advisory_id in pkg_params:
791             if advisory_id not in cur_patches:
792                 raise CommandExecutionError(
793                     'Advisory id "{}" not found'.format(advisory_id)
794                 )
795             else:
796                 targets.append(advisory_id)
797     else:
798         targets = pkg_params
799     diff_attr = kwargs.get("diff_attr")
800     includes = _find_types(targets)
801     old = (
802         list_pkgs(attr=diff_attr, root=root, includes=includes)
803         if not downloadonly
804         else list_downloaded(root)
805     )
806     downgrades = []
807     if fromrepo:
808         fromrepoopt = ["--force", "--force-resolution", "--from", fromrepo]
809         log.info("Targeting repo '%s'", fromrepo)
810     else:
811         fromrepoopt = ""
812     cmd_install = ["install", "--auto-agree-with-licenses"]
813     cmd_install.append(
814         kwargs.get("resolve_capabilities") and "--capability" or "--name"
815     )
816     if not refresh:
817         cmd_install.insert(0, "--no-refresh")
818     if skip_verify:
819         cmd_install.insert(0, "--no-gpg-checks")
820     if downloadonly:
821         cmd_install.append("--download-only")
822     if fromrepo:
823         cmd_install.extend(fromrepoopt)
824     if no_recommends:
825         cmd_install.append("--no-recommends")
826     errors = []
827     if pkg_type == "advisory":
828         targets = ["patch:{}".format(t) for t in targets]
829     systemd_scope = _systemd_scope()
830     while targets:
831         cmd = cmd_install + targets[:500]
832         targets = targets[500:]
833         for line in (
834             __zypper__(
835                 no_repo_failure=ignore_repo_failure,
836                 systemd_scope=systemd_scope,
837                 root=root,
838             )
839             .call(*cmd)
840             .splitlines()
841         ):
842             match = re.match(
843                 r"^The selected package '([^']+)'.+has lower version", line
844             )
845             if match:
846                 downgrades.append(match.group(1))
847     while downgrades:
848         cmd = cmd_install + ["--force"] + downgrades[:500]
849         downgrades = downgrades[500:]
850         __zypper__(no_repo_failure=ignore_repo_failure, root=root).call(*cmd)
851     _clean_cache()
852     new = (
853         list_pkgs(attr=diff_attr, root=root, includes=includes)
854         if not downloadonly
855         else list_downloaded(root)
856     )
857     ret = salt.utils.data.compare_dicts(old, new)
858     if includes:
859         _clean_cache()
860     if errors:
861         raise CommandExecutionError(
862             "Problem encountered {} package(s)".format(
863                 "downloading" if downloadonly else "installing"
864             ),
865             info={"errors": errors, "changes": ret},
866         )
867     return ret
868 def upgrade(
869     refresh=True,
870     dryrun=False,
871     dist_upgrade=False,
872     fromrepo=None,
873     novendorchange=False,
874     skip_verify=False,
875     no_recommends=False,
876     root=None,
877     **kwargs
878 ):  # pylint: disable=unused-argument
879     cmd_update = (["dist-upgrade"] if dist_upgrade else ["update"]) + [
880         "--auto-agree-with-licenses"
881     ]
882     if skip_verify:
883         cmd_update.insert(0, "--no-gpg-checks")
884     if refresh:
885         refresh_db(root)
886     if dryrun:
887         cmd_update.append("--dry-run")
888     if fromrepo:
889         if isinstance(fromrepo, str):
890             fromrepo = [fromrepo]
891         for repo in fromrepo:
892             cmd_update.extend(["--from" if dist_upgrade else "--repo", repo])
893         log.info("Targeting repos: %s", fromrepo)
894     if dist_upgrade:
895         if novendorchange:
896             if __grains__["osrelease_info"][0] &gt; 11:
897                 cmd_update.append("--no-allow-vendor-change")
898                 log.info("Disabling vendor changes")
899             else:
900                 log.warning(
901                     "Disabling vendor changes is not supported on this Zypper version"
902                 )
903         if no_recommends:
904             cmd_update.append("--no-recommends")
905             log.info("Disabling recommendations")
906         if dryrun:
907             log.info("Executing debugsolver and performing a dry-run dist-upgrade")
908             __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(
909                 *cmd_update + ["--debug-solver"]
910             )
911     old = list_pkgs(root=root)
912     __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(*cmd_update)
913     _clean_cache()
914     new = list_pkgs(root=root)
915     ret = salt.utils.data.compare_dicts(old, new)
916     if __zypper__.exit_code not in __zypper__.SUCCESS_EXIT_CODES:
917         result = {
918             "retcode": __zypper__.exit_code,
919             "stdout": __zypper__.stdout,
920             "stderr": __zypper__.stderr,
921             "pid": __zypper__.pid,
922         }
923         raise CommandExecutionError(
924             "Problem encountered upgrading packages",
925             info={"changes": ret, "result": result},
926         )
927     if dryrun:
928         ret = (__zypper__.stdout + os.linesep + __zypper__.stderr).strip()
929     return ret
930 def _uninstall(name=None, pkgs=None, root=None):
931     try:
932         pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
933     except MinionError as exc:
934         raise CommandExecutionError(exc)
935     includes = _find_types(pkg_params.keys())
936     old = list_pkgs(root=root, includes=includes)
937     targets = []
938     for target in pkg_params:
939         if target in old and pkg_params[target] in old[target].split(","):
940             targets.append(target + "-" + pkg_params[target])
941         elif target in old and not pkg_params[target]:
942             targets.append(target)
943     if not targets:
944         return {}
945     systemd_scope = _systemd_scope()
946     errors = []
947     while targets:
948         __zypper__(systemd_scope=systemd_scope, root=root).call(
949             "remove", *targets[:500]
950         )
951         targets = targets[500:]
952     _clean_cache()
953     new = list_pkgs(root=root, includes=includes)
954     ret = salt.utils.data.compare_dicts(old, new)
955     if errors:
956         raise CommandExecutionError(
957             "Problem encountered removing package(s)",
958             info={"errors": errors, "changes": ret},
959         )
960     return ret
961 def normalize_name(name):
962     try:
963         arch = name.rsplit(".", 1)[-1]
964         if arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
965             return name
966     except ValueError:
967         return name
968     if arch in (__grains__["osarch"], "noarch") or salt.utils.pkg.rpm.check_32(
969         arch, osarch=__grains__["osarch"]
970     ):
971         return name[: -(len(arch) + 1)]
972     return name
973 def remove(
974     name=None, pkgs=None, root=None, **kwargs
975 ):  # pylint: disable=unused-argument
976     return _uninstall(name=name, pkgs=pkgs, root=root)
977 def purge(name=None, pkgs=None, root=None, **kwargs):  # pylint: disable=unused-argument
978     return _uninstall(name=name, pkgs=pkgs, root=root)
979 def list_locks(root=None):
980     """
981     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try:
982         with salt.utils.files.fopen(_locks) as fhr:
983             items = salt.utils.stringutils.to_unicode(fhr.read(</b></font>)).split("\n\n")
984             for meta in [item.split("\n") for item in items]:
985                 lock = {}
986                 for element in [el for el in meta if el]:
987                     if ":" in element:
988                         lock.update(
989                             dict([tuple(i.strip() for i in element.split(":", 1))])
990                         )
991                 if lock.get("solvable_name"):
992                     locks[lock.pop("solvable_name")] = lock
993     except OSError:
994         pass
995     except Exception:  # pylint: disable=broad-except
996         log.warning("Detected a problem when accessing %s", _locks)
997     return locks
998 def clean_locks(root=None):
999     """
1000     Remove unused locks that do not currently (with regard to repositories
1001     used) lock any package.
1002     root
1003         Operate on a different root directory.
1004     CLI Example:
1005     .. code-block:: bash
1006         salt '*' pkg.clean_locks
1007     """
1008     LCK = "removed"
1009     out = {LCK: 0}
1010     locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
1011     if not os.path.exists(locks):
1012         return out
1013     for node in __zypper__(root=root).xml.call("cl").getElementsByTagName("message"):
1014         text = node.childNodes[0].nodeValue.lower()
1015         if text.startswith(LCK):
1016             out[LCK] = text.split(" ")[1]
1017             break
1018     return out
1019 def unhold(name=None, pkgs=None, **kwargs):
1020     """
1021     .. versionadded:: 3003
1022     Remove a package hold.
1023     name
1024         A package name to unhold, or a comma-separated list of package names to
1025         unhold.
1026     pkgs
1027         A list of packages to unhold.  The ``name`` parameter will be ignored if
1028         this option is passed.
1029     CLI Example:
1030     .. code-block:: bash
1031         salt '*' pkg.unhold &lt;package name&gt;
1032         salt '*' pkg.unhold &lt;package1&gt;,&lt;package2&gt;,&lt;package3&gt;
1033         salt '*' pkg.unhold pkgs='["foo", "bar"]'
1034     """
1035     ret = {}
1036     if not name and not pkgs:
1037         raise CommandExecutionError("Name or packages must be specified.")
1038     targets = []
1039     if pkgs:
1040         for pkg in salt.utils.data.repack_dictlist(pkgs):
1041             targets.append(pkg)
1042     else:
1043         targets.append(name)
1044     locks = list_locks()
1045     removed = []
1046     missing = []
1047     for target in targets:
1048         ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
1049         if locks.get(target):
1050             removed.append(target)
1051             ret[target]["changes"]["new"] = ""
1052             ret[target]["changes"]["old"] = "hold"
1053             ret[target]["comment"] = "Package {} is no longer held.".format(target)
1054         else:
1055             missing.append(target)
1056             ret[target]["comment"] = "Package {} was already unheld.".format(target)
1057     if removed:
1058         __zypper__.call("rl", *removed)
1059     return ret
1060 def hold(name=None, pkgs=None, **kwargs):
1061     """
1062     .. versionadded:: 3003
1063     Add a package hold.  Specify one of ``name`` and ``pkgs``.
1064     name
1065         A package name to hold, or a comma-separated list of package names to
1066         hold.
1067     pkgs
1068         A list of packages to hold.  The ``name`` parameter will be ignored if
1069         this option is passed.
1070     CLI Example:
1071     .. code-block:: bash
1072         salt '*' pkg.hold &lt;package name&gt;
1073         salt '*' pkg.hold &lt;package1&gt;,&lt;package2&gt;,&lt;package3&gt;
1074         salt '*' pkg.hold pkgs='["foo", "bar"]'
1075     """
1076     ret = {}
1077     if not name and not pkgs:
1078         raise CommandExecutionError("Name or packages must be specified.")
1079     targets = []
1080     if pkgs:
1081         for pkg in salt.utils.data.repack_dictlist(pkgs):
1082             targets.append(pkg)
1083     else:
1084         targets.append(name)
1085     locks = list_locks()
1086     added = []
1087     for target in targets:
1088         ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
1089         if not locks.get(target):
1090             added.append(target)
1091             ret[target]["changes"]["new"] = "hold"
1092             ret[target]["changes"]["old"] = ""
1093             ret[target]["comment"] = "Package {} is now being held.".format(target)
1094         else:
1095             ret[target]["comment"] = "Package {} is already set to be held.".format(
1096                 target
1097             )
1098     if added:
1099         __zypper__.call("al", *added)
1100     return ret
1101 def verify(*names, **kwargs):
1102     """
1103     Runs an rpm -Va on a system, and returns the results in a dict
1104     Files with an attribute of config, doc, ghost, license or readme in the
1105     package header can be ignored using the ``ignore_types`` keyword argument.
1106     The root parameter can also be passed via the keyword argument.
1107     CLI Example:
1108     .. code-block:: bash
1109         salt '*' pkg.verify
1110         salt '*' pkg.verify httpd
1111         salt '*' pkg.verify 'httpd postfix'
1112         salt '*' pkg.verify 'httpd postfix' ignore_types=['config','doc']
1113     """
1114     return __salt__["lowpkg.verify"](*names, **kwargs)
1115 def file_list(*packages, **kwargs):
1116     """
1117     List the files that belong to a package. Not specifying any packages will
1118     return a list of *every* file on the system's rpm database (not generally
1119     recommended).
1120     The root parameter can also be passed via the keyword argument.
1121     CLI Examples:
1122     .. code-block:: bash
1123         salt '*' pkg.file_list httpd
1124         salt '*' pkg.file_list httpd postfix
1125         salt '*' pkg.file_list
1126     """
1127     return __salt__["lowpkg.file_list"](*packages, **kwargs)
1128 def file_dict(*packages, **kwargs):
1129     """
1130     List the files that belong to a package, grouped by package. Not
1131     specifying any packages will return a list of *every* file on the system's
1132     rpm database (not generally recommended).
1133     The root parameter can also be passed via the keyword argument.
1134     CLI Examples:
1135     .. code-block:: bash
1136         salt '*' pkg.file_list httpd
1137         salt '*' pkg.file_list httpd postfix
1138         salt '*' pkg.file_list
1139     """
1140     return __salt__["lowpkg.file_dict"](*packages, **kwargs)
1141 def modified(*packages, **flags):
1142     """
1143     List the modified files that belong to a package. Not specifying any packages
1144     will return a list of _all_ modified files on the system's RPM database.
1145     .. versionadded:: 2015.5.0
1146     Filtering by flags (True or False):
1147     size
1148         Include only files where size changed.
1149     mode
1150         Include only files which file's mode has been changed.
1151     checksum
1152         Include only files which MD5 checksum has been changed.
1153     device
1154         Include only files which major and minor numbers has been changed.
1155     symlink
1156         Include only files which are symbolic link contents.
1157     owner
1158         Include only files where owner has been changed.
1159     group
1160         Include only files where group has been changed.
1161     time
1162         Include only files where modification time of the file has been changed.
1163     capabilities
1164         Include only files where capabilities differ or not. Note: supported only on newer RPM versions.
1165     root
1166         operate on a different root directory.
1167     CLI Examples:
1168     .. code-block:: bash
1169         salt '*' pkg.modified
1170         salt '*' pkg.modified httpd
1171         salt '*' pkg.modified httpd postfix
1172         salt '*' pkg.modified httpd owner=True group=False
1173     """
1174     return __salt__["lowpkg.modified"](*packages, **flags)
1175 def owner(*paths, **kwargs):
1176     """
1177     Return the name of the package that owns the file. Multiple file paths can
1178     be passed. If a single path is passed, a string will be returned,
1179     and if multiple paths are passed, a dictionary of file/package name
1180     pairs will be returned.
1181     If the file is not owned by a package, or is not present on the minion,
1182     then an empty string will be returned for that path.
1183     The root parameter can also be passed via the keyword argument.
1184     CLI Examples:
1185     .. code-block:: bash
1186         salt '*' pkg.owner /usr/bin/apachectl
1187         salt '*' pkg.owner /usr/bin/apachectl /etc/httpd/conf/httpd.conf
1188     """
1189     return __salt__["lowpkg.owner"](*paths, **kwargs)
1190 def _get_visible_patterns(root=None):
1191     patterns = {}
1192     search_patterns = __zypper__(root=root).nolock.xml.call("se", "-t", "pattern")
1193     for element in search_patterns.getElementsByTagName("solvable"):
1194         installed = element.getAttribute("status") == "installed"
1195         patterns[element.getAttribute("name")] = {
1196             "installed": installed,
1197             "summary": element.getAttribute("summary"),
1198         }
1199     return patterns
1200 def _get_installed_patterns(root=None):
1201     """
1202     List all installed patterns.
1203     """
1204     def _pattern_name(capability):
1205         return capability.split("=")[-1].strip()
1206     cmd = ["rpm"]
1207     if root:
1208         cmd.extend(["--root", root])
1209     cmd.extend(["-q", "--provides", "--whatprovides", "pattern()"])
1210     output = __salt__["cmd.run"](cmd, ignore_retcode=True)
1211     installed_patterns = {
1212         _pattern_name(line)
1213         for line in output.splitlines()
1214         if line.startswith("pattern() = ") and not _pattern_name(line).startswith(".")
1215     }
1216     patterns = {
1217         k: v for k, v in _get_visible_patterns(root=root).items() if v["installed"]
1218     }
1219     for pattern in installed_patterns:
1220         if pattern not in patterns:
1221             patterns[pattern] = {
1222                 "installed": True,
1223                 "summary": "Non-visible pattern",
1224             }
1225     return patterns
1226 def list_patterns(refresh=False, root=None):
1227     """
1228     List all known patterns from available repos.
1229     refresh
1230         force a refresh if set to True.
1231         If set to False (default) it depends on zypper if a refresh is
1232         executed.
1233     root
1234         operate on a different root directory.
1235     CLI Examples:
1236     .. code-block:: bash
1237         salt '*' pkg.list_patterns
1238     """
1239     if refresh:
1240         refresh_db(root)
1241     return _get_visible_patterns(root=root)
1242 def list_installed_patterns(root=None):
1243     """
1244     List installed patterns on the system.
1245     root
1246         operate on a different root directory.
1247     CLI Examples:
1248     .. code-block:: bash
1249         salt '*' pkg.list_installed_patterns
1250     """
1251     return _get_installed_patterns(root=root)
1252 def search(criteria, refresh=False, **kwargs):
1253     """
1254     List known packages, available to the system.
1255     refresh
1256         force a refresh if set to True.
1257         If set to False (default) it depends on zypper if a refresh is
1258         executed.
1259     match (str)
1260         One of `exact`, `words`, `substrings`. Search for an `exact` match
1261         or for the whole `words` only. Default to `substrings` to patch
1262         partial words.
1263     provides (bool)
1264         Search for packages which provide the search strings.
1265     recommends (bool)
1266         Search for packages which recommend the search strings.
1267     requires (bool)
1268         Search for packages which require the search strings.
1269     suggests (bool)
1270         Search for packages which suggest the search strings.
1271     conflicts (bool)
1272         Search packages conflicting with search strings.
1273     obsoletes (bool)
1274         Search for packages which obsolete the search strings.
1275     file_list (bool)
1276         Search for a match in the file list of packages.
1277     search_descriptions (bool)
1278         Search also in package summaries and descriptions.
1279     case_sensitive (bool)
1280         Perform case-sensitive search.
1281     installed_only (bool)
1282         Show only installed packages.
1283     not_installed_only (bool)
1284         Show only packages which are not installed.
1285     details (bool)
1286         Show version and repository
1287     root
1288         operate on a different root directory.
1289     CLI Examples:
1290     .. code-block:: bash
1291         salt '*' pkg.search &lt;criteria&gt;
1292     """
1293     ALLOWED_SEARCH_OPTIONS = {
1294         "provides": "--provides",
1295         "recommends": "--recommends",
1296         "requires": "--requires",
1297         "suggests": "--suggests",
1298         "conflicts": "--conflicts",
1299         "obsoletes": "--obsoletes",
1300         "file_list": "--file-list",
1301         "search_descriptions": "--search-descriptions",
1302         "case_sensitive": "--case-sensitive",
1303         "installed_only": "--installed-only",
1304         "not_installed_only": "-u",
1305         "details": "--details",
1306     }
1307     root = kwargs.get("root", None)
1308     if refresh:
1309         refresh_db(root)
1310     cmd = ["search"]
1311     if kwargs.get("match") == "exact":
1312         cmd.append("--match-exact")
1313     elif kwargs.get("match") == "words":
1314         cmd.append("--match-words")
1315     elif kwargs.get("match") == "substrings":
1316         cmd.append("--match-substrings")
1317     for opt in kwargs:
1318         if opt in ALLOWED_SEARCH_OPTIONS:
1319             cmd.append(ALLOWED_SEARCH_OPTIONS.get(opt))
1320     cmd.append(criteria)
1321     solvables = (
1322         __zypper__(root=root)
1323         .nolock.noraise.xml.call(*cmd)
1324         .getElementsByTagName("solvable")
1325     )
1326     if not solvables:
1327         raise CommandExecutionError("No packages found matching '{}'".format(criteria))
1328     out = {}
1329     for solvable in solvables:
1330         out[solvable.getAttribute("name")] = dict()
1331         for k, v in solvable.attributes.items():
1332             out[solvable.getAttribute("name")][k] = v
1333     return out
1334 def _get_first_aggregate_text(node_list):
1335     """
1336     Extract text from the first occurred DOM aggregate.
1337     """
1338     if not node_list:
1339         return ""
1340     out = []
1341     for node in node_list[0].childNodes:
1342         if node.nodeType == dom.Document.TEXT_NODE:
1343             out.append(node.nodeValue)
1344     return "\n".join(out)
1345 def list_products(all=False, refresh=False, root=None):
1346     """
1347     List all available or installed SUSE products.
1348     all
1349         List all products available or only installed. Default is False.
1350     refresh
1351         force a refresh if set to True.
1352         If set to False (default) it depends on zypper if a refresh is
1353         executed.
1354     root
1355         operate on a different root directory.
1356     Includes handling for OEM products, which read the OEM productline file
1357     and overwrite the release value.
1358     CLI Examples:
1359     .. code-block:: bash
1360         salt '*' pkg.list_products
1361         salt '*' pkg.list_products all=True
1362     """
1363     if refresh:
1364         refresh_db(root)
1365     ret = list()
1366     OEM_PATH = "/var/lib/suseRegister/OEM"
1367     if root:
1368         OEM_PATH = os.path.join(root, os.path.relpath(OEM_PATH, os.path.sep))
1369     cmd = list()
1370     if not all:
1371         cmd.append("--disable-repositories")
1372     cmd.append("products")
1373     if not all:
1374         cmd.append("-i")
1375     product_list = (
1376         __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("product-list")
1377     )
1378     if not product_list:
1379         return ret  # No products found
1380     for prd in product_list[0].getElementsByTagName("product"):
1381         p_nfo = dict()
1382         for k_p_nfo, v_p_nfo in prd.attributes.items():
1383             if k_p_nfo in ["isbase", "installed"]:
1384                 p_nfo[k_p_nfo] = bool(v_p_nfo in ["true", "1"])
1385             elif v_p_nfo:
1386                 p_nfo[k_p_nfo] = v_p_nfo
1387         eol = prd.getElementsByTagName("endoflife")
1388         if eol:
1389             p_nfo["eol"] = eol[0].getAttribute("text")
1390             p_nfo["eol_t"] = int(eol[0].getAttribute("time_t") or 0)
1391         p_nfo["description"] = " ".join(
1392             [
1393                 line.strip()
1394                 for line in _get_first_aggregate_text(
1395                     prd.getElementsByTagName("description")
1396                 ).split(os.linesep)
1397             ]
1398         )
1399         if "productline" in p_nfo and p_nfo["productline"]:
1400             oem_file = os.path.join(OEM_PATH, p_nfo["productline"])
1401             if os.path.isfile(oem_file):
1402                 with salt.utils.files.fopen(oem_file, "r") as rfile:
1403                     oem_release = salt.utils.stringutils.to_unicode(
1404                         rfile.readline()
1405                     ).strip()
1406                     if oem_release:
1407                         p_nfo["release"] = oem_release
1408         ret.append(p_nfo)
1409     return ret
1410 def download(*packages, **kwargs):
1411     """
1412     Download packages to the local disk.
1413     refresh
1414         force a refresh if set to True.
1415         If set to False (default) it depends on zypper if a refresh is
1416         executed.
1417     root
1418         operate on a different root directory.
1419     CLI Example:
1420     .. code-block:: bash
1421         salt '*' pkg.download httpd
1422         salt '*' pkg.download httpd postfix
1423     """
1424     if not packages:
1425         raise SaltInvocationError("No packages specified")
1426     root = kwargs.get("root", None)
1427     refresh = kwargs.get("refresh", False)
1428     if refresh:
1429         refresh_db(root)
1430     pkg_ret = {}
1431     for dld_result in (
1432         __zypper__(root=root)
1433         .xml.call("download", *packages)
1434         .getElementsByTagName("download-result")
1435     ):
1436         repo = dld_result.getElementsByTagName("repository")[0]
1437         path = dld_result.getElementsByTagName("localfile")[0].getAttribute("path")
1438         pkg_info = {
1439             "repository-name": repo.getAttribute("name"),
1440             "repository-alias": repo.getAttribute("alias"),
1441             "path": path,
1442         }
1443         key = _get_first_aggregate_text(dld_result.getElementsByTagName("name"))
1444         if __salt__["lowpkg.checksum"](pkg_info["path"], root=root):
1445             pkg_ret[key] = pkg_info
1446     if pkg_ret:
1447         failed = [pkg for pkg in packages if pkg not in pkg_ret]
1448         if failed:
1449             pkg_ret[
1450                 "_error"
1451             ] = "The following package(s) failed to download: {}".format(
1452                 ", ".join(failed)
1453             )
1454         return pkg_ret
1455     raise CommandExecutionError(
1456         "Unable to download packages: {}".format(", ".join(packages))
1457     )
1458 def list_downloaded(root=None, **kwargs):
1459     """
1460     .. versionadded:: 2017.7.0
1461     List prefetched packages downloaded by Zypper in the local disk.
1462     root
1463         operate on a different root directory.
1464     CLI Example:
1465     .. code-block:: bash
1466         salt '*' pkg.list_downloaded
1467     """
1468     CACHE_DIR = "/var/cache/zypp/packages/"
1469     if root:
1470         CACHE_DIR = os.path.join(root, os.path.relpath(CACHE_DIR, os.path.sep))
1471     ret = {}
1472     for root, dirnames, filenames in salt.utils.path.os_walk(CACHE_DIR):
1473         for filename in fnmatch.filter(filenames, "*.rpm"):
1474             package_path = os.path.join(root, filename)
1475             pkg_info = __salt__["lowpkg.bin_pkg_info"](package_path)
1476             pkg_timestamp = int(os.path.getctime(package_path))
1477             ret.setdefault(pkg_info["name"], {})[pkg_info["version"]] = {
1478                 "path": package_path,
1479                 "size": os.path.getsize(package_path),
1480                 "creation_date_time_t": pkg_timestamp,
1481                 "creation_date_time": datetime.datetime.utcfromtimestamp(
1482                     pkg_timestamp
1483                 ).isoformat(),
1484             }
1485     return ret
1486 def diff(*paths, **kwargs):
1487     """
1488     Return a formatted diff between current files and original in a package.
1489     NOTE: this function includes all files (configuration and not), but does
1490     not work on binary content.
1491     The root parameter can also be passed via the keyword argument.
1492     :param path: Full path to the installed file
1493     :return: Difference string or raises and exception if examined file is binary.
1494     CLI Example:
1495     .. code-block:: bash
1496         salt '*' pkg.diff /etc/apache2/httpd.conf /etc/sudoers
1497     """
1498     ret = {}
1499     pkg_to_paths = {}
1500     for pth in paths:
1501         pth_pkg = __salt__["lowpkg.owner"](pth, **kwargs)
1502         if not pth_pkg:
1503             ret[pth] = os.path.exists(pth) and "Not managed" or "N/A"
1504         else:
1505             if pkg_to_paths.get(pth_pkg) is None:
1506                 pkg_to_paths[pth_pkg] = []
1507             pkg_to_paths[pth_pkg].append(pth)
1508     if pkg_to_paths:
1509         local_pkgs = __salt__["pkg.download"](*pkg_to_paths.keys(), **kwargs)
1510         for pkg, files in pkg_to_paths.items():
1511             for path in files:
1512                 ret[path] = (
1513                     __salt__["lowpkg.diff"](local_pkgs[pkg]["path"], path)
1514                     or "Unchanged"
1515                 )
1516     return ret
1517 def _get_patches(installed_only=False, root=None):
1518     """
1519     List all known patches in repos.
1520     """
1521     patches = {}
1522     for element in (
1523         __zypper__(root=root)
1524         .nolock.xml.call("se", "-t", "patch")
1525         .getElementsByTagName("solvable")
1526     ):
1527         installed = element.getAttribute("status") == "installed"
1528         if (installed_only and installed) or not installed_only:
1529             patches[element.getAttribute("name")] = {
1530                 "installed": installed,
1531                 "summary": element.getAttribute("summary"),
1532             }
1533     return patches
1534 def list_patches(refresh=False, root=None, **kwargs):
1535     """
1536     .. versionadded:: 2017.7.0
1537     List all known advisory patches from available repos.
1538     refresh
1539         force a refresh if set to True.
1540         If set to False (default) it depends on zypper if a refresh is
1541         executed.
1542     root
1543         operate on a different root directory.
1544     CLI Examples:
1545     .. code-block:: bash
1546         salt '*' pkg.list_patches
1547     """
1548     if refresh:
1549         refresh_db(root)
1550     return _get_patches(root=root)
1551 def list_installed_patches(root=None, **kwargs):
1552     """
1553     .. versionadded:: 2017.7.0
1554     List installed advisory patches on the system.
1555     root
1556         operate on a different root directory.
1557     CLI Examples:
1558     .. code-block:: bash
1559         salt '*' pkg.list_installed_patches
1560     """
1561     return _get_patches(installed_only=True, root=root)
1562 def list_provides(root=None, **kwargs):
1563     """
1564     .. versionadded:: 2018.3.0
1565     List package provides of installed packages as a dict.
1566     {'&lt;provided_name&gt;': ['&lt;package_name&gt;', '&lt;package_name&gt;', ...]}
1567     root
1568         operate on a different root directory.
1569     CLI Examples:
1570     .. code-block:: bash
1571         salt '*' pkg.list_provides
1572     """
1573     ret = __context__.get("pkg.list_provides")
1574     if not ret:
1575         cmd = ["rpm"]
1576         if root:
1577             cmd.extend(["--root", root])
1578         cmd.extend(["-qa", "--queryformat", "%{PROVIDES}_|-%{NAME}\n"])
1579         ret = dict()
1580         for line in __salt__["cmd.run"](
1581             cmd, output_loglevel="trace", python_shell=False
1582         ).splitlines():
1583             provide, realname = line.split("_|-")
1584             if provide == realname:
1585                 continue
1586             if provide not in ret:
1587                 ret[provide] = list()
1588             ret[provide].append(realname)
1589         __context__["pkg.list_provides"] = ret
1590     return ret
1591 def resolve_capabilities(pkgs, refresh=False, root=None, **kwargs):
1592     """
1593     .. versionadded:: 2018.3.0
1594     Convert name provides in ``pkgs`` into real package names if
1595     ``resolve_capabilities`` parameter is set to True. In case of
1596     ``resolve_capabilities`` is set to False the package list
1597     is returned unchanged.
1598     refresh
1599         force a refresh if set to True.
1600         If set to False (default) it depends on zypper if a refresh is
1601         executed.
1602     root
1603         operate on a different root directory.
1604     resolve_capabilities
1605         If this option is set to True the input will be checked if
1606         a package with this name exists. If not, this function will
1607         search for a package which provides this name. If one is found
1608         the output is exchanged with the real package name.
1609         In case this option is set to False (Default) the input will
1610         be returned unchanged.
1611     CLI Examples:
1612     .. code-block:: bash
1613         salt '*' pkg.resolve_capabilities resolve_capabilities=True w3m_ssl
1614     """
1615     if refresh:
1616         refresh_db(root)
1617     ret = list()
1618     for pkg in pkgs:
1619         if isinstance(pkg, dict):
1620             name = next(iter(pkg))
1621             version = pkg[name]
1622         else:
1623             name = pkg
1624             version = None
1625         if kwargs.get("resolve_capabilities", False):
1626             try:
1627                 search(name, root=root, match="exact")
1628             except CommandExecutionError:
1629                 try:
1630                     result = search(name, root=root, provides=True, match="exact")
1631                     if len(result) == 1:
1632                         name = next(iter(result.keys()))
1633                     elif len(result) &gt; 1:
1634                         log.warning("Found ambiguous match for capability '%s'.", pkg)
1635                 except CommandExecutionError as exc:
1636                     log.debug("Search failed with: %s", exc)
1637         if version:
1638             ret.append({name: version})
1639         else:
1640             ret.append(name)
1641     return ret
1642 def services_need_restart(root=None, **kwargs):
1643     """
1644     .. versionadded:: 3003
1645     List services that use files which have been changed by the
1646     package manager. It might be needed to restart them.
1647     root
1648         operate on a different root directory.
1649     CLI Examples:
1650     .. code-block:: bash
1651         salt '*' pkg.services_need_restart
1652     """
1653     cmd = ["ps", "-sss"]
1654     zypper_output = __zypper__(root=root).nolock.call(*cmd)
1655     services = zypper_output.split()
1656     return services
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
