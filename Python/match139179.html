<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for linux_sysctl.py &amp; zypperpkg.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for linux_sysctl.py &amp; zypperpkg.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>linux_sysctl.py (12.275449%)<th>zypperpkg.py (1.4133058%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(202-214)<td><a href="#" name="0">(668-672)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(188-193)<td><a href="#" name="1">(2040-2042)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(5-18)<td><a href="#" name="2">(31-42)</a><td align="center"><font color="#bf0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>linux_sysctl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
2 import os
3 import re
4 import salt.utils.data
5 import salt.utils.files
6 import salt.utils.stringutils
7 import salt.utils.systemd
8 from salt.exceptions import CommandExecutionError
9 log = logging.getLogger(__name__)
10 __virtualname__ =</b></font> "sysctl"
11 def __virtual__():
12     if __grains__["kernel"] != "Linux":
13         return (
14             False,
15             "The linux_sysctl execution module cannot be loaded: only available on"
16             " Linux systems.",
17         )
18     return __virtualname__
19 def default_config():
20     if (
21         salt.utils.systemd.booted(__context__)
22         and salt.utils.systemd.version(__context__) &gt;= 207
23     ):
24         return "/etc/sysctl.d/99-salt.conf"
25     return "/etc/sysctl.conf"
26 def show(config_file=False):
27     ret = {}
28     if config_file:
29         if not os.path.exists(config_file):
30             return []
31         try:
32             with salt.utils.files.fopen(config_file) as fp_:
33                 for line in fp_:
34                     line = salt.utils.stringutils.to_str(line)
35                     if not line.startswith("#") and "=" in line:
36                         SPLIT = " = "
37                         if SPLIT not in line:
38                             SPLIT = SPLIT.strip()
39                         key, value = line.split(SPLIT, 1)
40                         key = key.strip()
41                         value = value.lstrip()
42                         ret[key] = value
43         except OSError:
44             log.error("Could not open sysctl file")
45             return None
46     else:
47         cmd = "sysctl -a"
48         out = __salt__["cmd.run_stdout"](cmd, output_loglevel="trace")
49         for line in out.splitlines():
50             if not line or " = " not in line:
51                 continue
52             comps = line.split(" = ", 1)
53             ret[comps[0]] = comps[1]
54     return ret
55 def get(name):
56     cmd = "sysctl -n {}".format(name)
57     out = __salt__["cmd.run"](cmd, python_shell=False)
58     return out
59 def assign(name, value):
60     value = str(value)
61     tran_tab = name.translate("".maketrans("./", "/."))
62     sysctl_file = "/proc/sys/{}".format(tran_tab)
63     if not os.path.exists(sysctl_file):
64         raise CommandExecutionError("sysctl {} does not exist".format(name))
65     ret = {}
66     cmd = 'sysctl -w {}="{}"'.format(name, value)
67     data = __salt__["cmd.run_all"](cmd, python_shell=False)
68     out = data["stdout"]
69     err = data["stderr"]
70     regex = re.compile(r"^{}\s+=\s+{}$".format(re.escape(name), re.escape(value)))
71     if not regex.match(out) or "Invalid argument" in str(err):
72         if data["retcode"] != 0 and err:
73             error = err
74         else:
75             error = out
76         raise CommandExecutionError("sysctl -w failed: {}".format(error))
77     new_name, new_value = out.split(" = ", 1)
78     ret[new_name] = new_value
79     return ret
80 def persist(name, value, config=None):
81     if config is None:
82         config = default_config()
83     edited = False
84     if not os.path.isfile(config):
85         sysctl_dir = os.path.dirname(config)
86         if not os.path.exists(sysctl_dir):
87             os.makedirs(sysctl_dir)
88         try:
89             with salt.utils.files.fopen(config, "w+") as _fh:
90                 _fh.write("#\n# Kernel sysctl configuration\n#\n")
91         except OSError:
92             msg = "Could not write to file: {0}"
93             raise CommandExecutionError(msg.format(config))
94 <a name="1"></a>
95     nlines = []
96     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try:
97         with salt.utils.files.fopen(config, "r") as _fh:
98             config_data = salt.utils.data.decode(_fh.readlines(</b></font>))
99     except OSError:
100         msg = "Could not read from file: {0}"
101         raise CommandExecutionError(msg.format(config))
102     for line in config_data:
103             nlines.append(line)
104             continue
105         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if "=" not in line:
106             nlines.append(line)
107             continue
108         comps = [i.strip() for i in line.split("=", 1)]
109         if isinstance(comps[1], str) and " " in comps[1]:
110             comps[</b></font>1] = re.sub(r"\s+", "\t", comps[1])
111         if isinstance(value, str) and " " in value:
112             value = re.sub(r"\s+", "\t", value)
113         if len(comps) &lt; 2:
114             nlines.append(line)
115             continue
116         if name == comps[0]:
117             if str(comps[1]) == str(value):
118                 if str(get(name)) != str(value):
119                     assign(name, value)
120                     return "Updated"
121                 else:
122                     return "Already set"
123             nlines.append("{} = {}\n".format(name, value))
124             edited = True
125             continue
126         else:
127             nlines.append(line)
128     if not edited:
129         nlines.append("{} = {}\n".format(name, value))
130     try:
131         with salt.utils.files.fopen(config, "wb") as _fh:
132             _fh.writelines(salt.utils.data.encode(nlines))
133     except OSError:
134         msg = "Could not write to file: {0}"
135         raise CommandExecutionError(msg.format(config))
136     assign(name, value)
137     return "Updated"
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>zypperpkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import configparser
2 import datetime
3 import fnmatch
4 import logging
5 import os
6 import re
7 import time
8 import urllib.parse
9 from xml.dom import minidom as dom
10 from xml.parsers.expat import ExpatError
11 import salt.utils.data
12 import salt.utils.environment
13 <a name="2"></a>import salt.utils.event
14 import salt.utils.files
15 import salt.utils.functools
16 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.path
17 import salt.utils.pkg
18 import salt.utils.pkg.rpm
19 import salt.utils.stringutils
20 import salt.utils.systemd
21 import salt.utils.versions
22 from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
23 from salt.utils.versions import LooseVersion
24 log = logging.getLogger(__name__)
25 HAS_ZYPP =</b></font> False
26 ZYPP_HOME = "/etc/zypp"
27 LOCKS = "{}/locks".format(ZYPP_HOME)
28 REPOS = "{}/repos.d".format(ZYPP_HOME)
29 DEFAULT_PRIORITY = 99
30 PKG_ARCH_SEPARATOR = "."
31 __virtualname__ = "pkg"
32 def __virtual__():
33     if __grains__.get("os_family", "") != "Suse":
34         return (
35             False,
36             "Module zypper: non SUSE OS not supported by zypper package manager",
37         )
38     if not salt.utils.path.which("zypper"):
39         return (False, "Module zypper: zypper package manager not found")
40     return __virtualname__
41 class _Zypper:
42     SUCCESS_EXIT_CODES = {
43         0: "Successful run of zypper with no special info.",
44         100: "Patches are available for installation.",
45         101: "Security patches are available for installation.",
46         102: "Installation successful, reboot required.",
47         103: "Installation successful, restart of the package manager itself required.",
48     }
49     WARNING_EXIT_CODES = {
50         6: "No repositories are defined.",
51         7: "The ZYPP library is locked.",
52         106: (
53             "Some repository had to be disabled temporarily because it failed to"
54             " refresh. You should check your repository configuration (e.g. zypper ref"
55             " -f)."
56         ),
57         107: (
58             "Installation basically succeeded, but some of the packages %post install"
59             " scripts returned an error. These packages were successfully unpacked to"
60             " disk and are registered in the rpm database, but due to the failed"
61             " install script they may not work as expected. The failed scripts output"
62             " might reveal what actually went wrong. Any scripts output is also logged"
63             " to /var/log/zypp/history."
64         ),
65     }
66     LOCK_EXIT_CODE = 7
67     XML_DIRECTIVES = ["-x", "--xmlout"]
68     ZYPPER_LOCK = "/var/run/zypp.pid"
69     TAG_RELEASED = "zypper/released"
70     TAG_BLOCKED = "zypper/blocked"
71     def __init__(self):
72         self._reset()
73     def _reset(self):
74         self.__cmd = ["zypper", "--non-interactive"]
75         self.__exit_code = 0
76         self.__call_result = dict()
77         self.__error_msg = ""
78         self.__env = salt.utils.environment.get_module_environment(globals())
79         self.__xml = False
80         self.__no_lock = False
81         self.__no_raise = False
82         self.__refresh = False
83         self.__ignore_repo_failure = False
84         self.__systemd_scope = False
85         self.__root = None
86         self.__called = False
87     def __call__(self, *args, **kwargs):
88         if self.__called:
89             self._reset()
90         if "no_repo_failure" in kwargs:
91             self.__ignore_repo_failure = kwargs["no_repo_failure"]
92         if "systemd_scope" in kwargs:
93             self.__systemd_scope = kwargs["systemd_scope"]
94         if "root" in kwargs:
95             self.__root = kwargs["root"]
96         return self
97     def __getattr__(self, item):
98         if self.__called:
99             self._reset()
100         if item == "xml":
101             self.__xml = True
102         elif item == "nolock":
103             self.__no_lock = True
104         elif item == "noraise":
105             self.__no_raise = True
106         elif item == "refreshable":
107             self.__refresh = True
108         elif item == "call":
109             return self.__call
110         else:
111             return self.__dict__[item]
112         if self.__no_lock:
113             self.__no_lock = not self.__refresh
114         return self
115     @property
116     def exit_code(self):
117         return self.__exit_code
118     @exit_code.setter
119     def exit_code(self, exit_code):
120         self.__exit_code = int(exit_code or "0")
121     @property
122     def error_msg(self):
123         return self.__error_msg
124     @error_msg.setter
125     def error_msg(self, msg):
126         if self._is_error():
127             self.__error_msg = msg and os.linesep.join(msg) or "Check Zypper's logs."
128     @property
129     def stdout(self):
130         return self.__call_result.get("stdout", "")
131     @property
132     def stderr(self):
133         return self.__call_result.get("stderr", "")
134     @property
135     def pid(self):
136         return self.__call_result.get("pid", "")
137     def _is_error(self):
138         if self.exit_code:
139             msg = self.SUCCESS_EXIT_CODES.get(self.exit_code)
140             if msg:
141                 log.info(msg)
142             msg = self.WARNING_EXIT_CODES.get(self.exit_code)
143             if msg:
144                 log.warning(msg)
145         return (
146             self.exit_code not in self.SUCCESS_EXIT_CODES
147             and self.exit_code not in self.WARNING_EXIT_CODES
148         )
149     def _is_lock(self):
150         return self.exit_code == self.LOCK_EXIT_CODE
151     def _is_xml_mode(self):
152         return (
153             [itm for itm in self.XML_DIRECTIVES if itm in self.__cmd] and True or False
154         )
155     def _check_result(self):
156         if not self.__call_result:
157             raise CommandExecutionError("No output result from Zypper?")
158         self.exit_code = self.__call_result["retcode"]
159         if self._is_lock():
160             return False
161         if self._is_error():
162             _error_msg = list()
163             if not self._is_xml_mode():
164                 msg = (
165                     self.__call_result["stderr"]
166                     and self.__call_result["stderr"].strip()
167                     or ""
168                 )
169                 if msg:
170                     _error_msg.append(msg)
171             else:
172                 try:
173                     doc = dom.parseString(self.__call_result["stdout"])
174                 except ExpatError as err:
175                     log.error(err)
176                     doc = None
177                 if doc:
178                     msg_nodes = doc.getElementsByTagName("message")
179                     for node in msg_nodes:
180                         if node.getAttribute("type") == "error":
181                             _error_msg.append(node.childNodes[0].nodeValue)
182                 elif self.__call_result["stderr"].strip():
183                     _error_msg.append(self.__call_result["stderr"].strip())
184             self.error_msg = _error_msg
185         return True
186     def __call(self, *args, **kwargs):
187         self.__called = True
188         if self.__xml:
189             self.__cmd.append("--xmlout")
190         if not self.__refresh and "--no-refresh" not in args:
191             self.__cmd.append("--no-refresh")
192         if self.__root:
193             self.__cmd.extend(["--root", self.__root])
194         self.__cmd.extend(args)
195         kwargs["output_loglevel"] = "trace"
196         kwargs["python_shell"] = False
197         kwargs["env"] = self.__env.copy()
198         if self.__no_lock:
199             kwargs["env"][
200                 "ZYPP_READONLY_HACK"
201             ] = (  # Disables locking for read-only operations. Do not try that at home!
202                 "1"
203             )
204         was_blocked = False
205         while True:
206             cmd = []
207             if self.__systemd_scope:
208                 cmd.extend(["systemd-run", "--scope"])
209             cmd.extend(self.__cmd)
210             log.debug("Calling Zypper: %s", " ".join(cmd))
211             self.__call_result = __salt__["cmd.run_all"](cmd, **kwargs)
212             if self._check_result():
213                 break
214             if os.path.exists(self.ZYPPER_LOCK):
215                 try:
216                     with salt.utils.files.fopen(self.ZYPPER_LOCK) as rfh:
217                         data = __salt__["ps.proc_info"](
218                             int(rfh.readline()),
219                             attrs=["pid", "name", "cmdline", "create_time"],
220                         )
221                         data["cmdline"] = " ".join(data["cmdline"])
222                         data["info"] = "Blocking process created at {}.".format(
223                             datetime.datetime.utcfromtimestamp(
224                                 data["create_time"]
225                             ).isoformat()
226                         )
227                         data["success"] = True
228                 except Exception as err:  # pylint: disable=broad-except
229                     data = {
230                         "info": (
231                             "Unable to retrieve information about blocking process: {}".format(
232                                 err.message
233                             )
234                         ),
235                         "success": False,
236                     }
237             else:
238                 data = {
239                     "info": "Zypper is locked, but no Zypper lock has been found.",
240                     "success": False,
241                 }
242             if not data["success"]:
243                 log.debug("Unable to collect data about blocking process.")
244             else:
245                 log.debug("Collected data about blocking process.")
246             __salt__["event.fire_master"](data, self.TAG_BLOCKED)
247             log.debug(
248                 "Fired a Zypper blocked event to the master with the data: %s", data
249             )
250             log.debug("Waiting 5 seconds for Zypper gets released...")
251             time.sleep(5)
252             if not was_blocked:
253                 was_blocked = True
254         if was_blocked:
255             __salt__["event.fire_master"](
256                 {
257                     "success": not self.error_msg,
258                     "info": self.error_msg or "Zypper has been released",
259                 },
260                 self.TAG_RELEASED,
261             )
262         if self.error_msg and not self.__no_raise and not self.__ignore_repo_failure:
263             raise CommandExecutionError(
264                 "Zypper command failure: {}".format(self.error_msg)
265             )
266         return (
267             self._is_xml_mode()
268             and dom.parseString(
269                 salt.utils.stringutils.to_str(self.__call_result["stdout"])
270             )
271             or self.__call_result["stdout"]
272         )
273 __zypper__ = _Zypper()
274 class Wildcard:
275     Z_OP = ["&lt;", "&lt;=", "=", "&gt;=", "&gt;"]
276     def __init__(self, zypper):
277         self.name = None
278         self.version = None
279         self.zypper = zypper
280         self._attr_solvable_version = "edition"
281         self._op = None
282     def __call__(self, pkg_name, pkg_version):
283         if pkg_version:
284             self.name = pkg_name
285             self._set_version(pkg_version)  # Dissects possible operator
286             versions = sorted(
287                 LooseVersion(vrs)
288                 for vrs in self._get_scope_versions(self._get_available_versions())
289             )
290             return versions and "{}{}".format(self._op or "", versions[-1]) or None
291     def _get_available_versions(self):
292         solvables = self.zypper.nolock.xml.call(
293             "se", "-xv", self.name
294         ).getElementsByTagName("solvable")
295         if not solvables:
296             raise CommandExecutionError(
297                 "No packages found matching '{}'".format(self.name)
298             )
299         return sorted(
300             {
301                 slv.getAttribute(self._attr_solvable_version)
302                 for slv in solvables
303                 if slv.getAttribute(self._attr_solvable_version)
304             }
305         )
306     def _get_scope_versions(self, pkg_versions):
307         get_in_versions = []
308         for p_version in pkg_versions:
309             if fnmatch.fnmatch(p_version, self.version):
310                 get_in_versions.append(p_version)
311         return get_in_versions
312     def _set_version(self, version):
313         if not version:
314             return
315         exact_version = re.sub(r"[&lt;&gt;=+]*", "", version)
316         self._op = version.replace(exact_version, "") or None
317         if self._op and self._op not in self.Z_OP:
318             raise CommandExecutionError(
319                 'Zypper do not supports operator "{}".'.format(self._op)
320             )
321         self.version = exact_version
322 def _systemd_scope():
323     return salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
324         "systemd.scope", True
325     )
326 def _clean_cache():
327     keys = []
328     for cache_name in ["pkg.list_pkgs", "pkg.list_provides"]:
329         for contextkey in __context__:
330             if contextkey.startswith(cache_name):
331                 keys.append(contextkey)
332     for key in keys:
333         __context__.pop(key, None)
334 def list_upgrades(refresh=True, root=None, **kwargs):
335     if refresh:
336         refresh_db(root)
337     ret = dict()
338     cmd = ["list-updates"]
339     if "fromrepo" in kwargs:
340         repos = kwargs["fromrepo"]
341         if isinstance(repos, str):
342             repos = [repos]
343         for repo in repos:
344             cmd.extend(["--repo", repo if isinstance(repo, str) else str(repo)])
345         log.debug("Targeting repos: %s", repos)
346     for update_node in (
347         __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("update")
348     ):
349         if update_node.getAttribute("kind") == "package":
350             ret[update_node.getAttribute("name")] = update_node.getAttribute("edition")
351     return ret
352 list_updates = salt.utils.functools.alias_function(list_upgrades, "list_updates")
353 def info_installed(*names, **kwargs):
354     all_versions = kwargs.get("all_versions", False)
355     ret = dict()
356     for pkg_name, pkgs_nfo in __salt__["lowpkg.info"](*names, **kwargs).items():
357         pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]
358         for _nfo in pkg_nfo:
359             t_nfo = dict()
360             for key, value in _nfo.items():
361                 if key == "source_rpm":
362                     t_nfo["source"] = value
363                 else:
364                     t_nfo[key] = value
365             if not all_versions:
366                 ret[pkg_name] = t_nfo
367             else:
368                 ret.setdefault(pkg_name, []).append(t_nfo)
369     return ret
370 def info_available(*names, **kwargs):
371     ret = {}
372     if not names:
373         return ret
374     else:
375         names = sorted(list(set(names)))
376     root = kwargs.get("root", None)
377     if kwargs.get("refresh", True):
378         refresh_db(root)
379     pkg_info = []
380     batch = names[:]
381     batch_size = 200
382     while batch:
383         pkg_info.extend(
384             re.split(
385                 r"Information for package*",
386                 __zypper__(root=root).nolock.call(
387                     "info", "-t", "package", *batch[:batch_size]
388                 ),
389             )
390         )
391         batch = batch[batch_size:]
392 <a name="0"></a>    for pkg_data in pkg_info:
393         nfo = {}
394         for line in [data for data in pkg_data.split("\n") if ":" in data]:
395             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if line.startswith("-----"):
396                 continue
397             kw = [data.strip() for data in line.split(":", 1)]
398             if len(kw) == 2 and kw[1]:
399                 nfo[kw[</b></font>0].lower()] = kw[1]
400         if nfo.get("name"):
401             name = nfo.pop("name")
402             ret[name] = nfo
403         if nfo.get("status"):
404             nfo["status"] = nfo.get("status")
405         if nfo.get("installed"):
406             nfo["installed"] = nfo.get("installed").lower().startswith("yes")
407     return ret
408 def parse_arch(name):
409     _name, _arch = None, None
410     try:
411         _name, _arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)
412     except ValueError:
413         pass
414     if _arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
415         _name = name
416         _arch = None
417     return {"name": _name, "arch": _arch}
418 def latest_version(*names, **kwargs):
419     ret = dict()
420     if not names:
421         return ret
422     names = sorted(list(set(names)))
423     package_info = info_available(*names, **kwargs)
424     for name in names:
425         pkg_info = package_info.get(name, {})
426         status = pkg_info.get("status", "").lower()
427         if status.find("not installed") &gt; -1 or status.find("out-of-date") &gt; -1:
428             ret[name] = pkg_info.get("version")
429         else:
430             ret[name] = ""
431     if len(names) == 1 and ret:
432         return ret[names[0]]
433     return ret
434 available_version = salt.utils.functools.alias_function(
435     latest_version, "available_version"
436 )
437 def upgrade_available(name, **kwargs):
438     return not not latest_version(name, **kwargs)  # pylint: disable=C0113
439 def version(*names, **kwargs):
440     return __salt__["pkg_resource.version"](*names, **kwargs) or {}
441 def version_cmp(ver1, ver2, ignore_epoch=False, **kwargs):
442     return __salt__["lowpkg.version_cmp"](ver1, ver2, ignore_epoch=ignore_epoch)
443 def _list_pkgs_from_context(versions_as_list, contextkey, attr):
444     return __salt__["pkg_resource.format_pkg_list"](
445         __context__[contextkey], versions_as_list, attr
446     )
447 def list_pkgs(versions_as_list=False, root=None, includes=None, **kwargs):
448     versions_as_list = salt.utils.data.is_true(versions_as_list)
449     if any(
450         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
451     ):
452         return {}
453     attr = kwargs.get("attr")
454     if attr is not None:
455         attr = salt.utils.args.split_input(attr)
456     includes = includes if includes else []
457     contextkey = "pkg.list_pkgs_{}_{}".format(root, includes)
458     if contextkey in __context__ and kwargs.get("use_context", True):
459         return _list_pkgs_from_context(versions_as_list, contextkey, attr)
460     ret = {}
461     cmd = ["rpm"]
462     if root:
463         cmd.extend(["--root", root])
464     cmd.extend(
465         [
466             "-qa",
467             "--queryformat",
468             salt.utils.pkg.rpm.QUERYFORMAT.replace("%{REPOID}", "(none)") + "\n",
469         ]
470     )
471     output = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="trace")
472     for line in output.splitlines():
473         pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__["osarch"])
474         if pkginfo:
475             pkgver = pkginfo.version
476             epoch = None
477             release = None
478             if ":" in pkgver:
479                 epoch, pkgver = pkgver.split(":", 1)
480             if "-" in pkgver:
481                 pkgver, release = pkgver.split("-", 1)
482             all_attr = {
483                 "epoch": epoch,
484                 "version": pkgver,
485                 "release": release,
486                 "arch": pkginfo.arch,
487                 "install_date": pkginfo.install_date,
488                 "install_date_time_t": pkginfo.install_date_time_t,
489             }
490             __salt__["pkg_resource.add_pkg"](ret, pkginfo.name, all_attr)
491     _ret = {}
492     for pkgname in ret:
493         if pkgname.startswith("gpg-pubkey"):
494             continue
495         _ret[pkgname] = sorted(ret[pkgname], key=lambda d: d["version"])
496     for include in includes:
497         if include == "product":
498             products = list_products(all=False, root=root)
499             for product in products:
500                 extended_name = "{}:{}".format(include, product["name"])
501                 _ret[extended_name] = [
502                     {
503                         "epoch": product["epoch"],
504                         "version": product["version"],
505                         "release": product["release"],
506                         "arch": product["arch"],
507                         "install_date": None,
508                         "install_date_time_t": None,
509                     }
510                 ]
511         if include in ("pattern", "patch"):
512             if include == "pattern":
513                 elements = list_installed_patterns(root=root)
514             elif include == "patch":
515                 elements = list_installed_patches(root=root)
516             else:
517                 elements = []
518             for element in elements:
519                 extended_name = "{}:{}".format(include, element)
520                 info = info_available(extended_name, refresh=False, root=root)
521                 _ret[extended_name] = [
522                     {
523                         "epoch": None,
524                         "version": info[element]["version"],
525                         "release": None,
526                         "arch": info[element]["arch"],
527                         "install_date": None,
528                         "install_date_time_t": None,
529                     }
530                 ]
531     __context__[contextkey] = _ret
532     return __salt__["pkg_resource.format_pkg_list"](
533         __context__[contextkey], versions_as_list, attr
534     )
535 def list_repo_pkgs(*args, **kwargs):
536     byrepo = kwargs.pop("byrepo", False)
537     fromrepo = kwargs.pop("fromrepo", "") or ""
538     ret = {}
539     targets = [arg if isinstance(arg, str) else str(arg) for arg in args]
540     def _is_match(pkgname):
541         if not args:
542             return True
543         for target in targets:
544             if fnmatch.fnmatch(pkgname, target):
545                 return True
546         return False
547     root = kwargs.get("root") or None
548     for node in (
549         __zypper__(root=root)
550         .xml.call("se", "-s", *targets)
551         .getElementsByTagName("solvable")
552     ):
553         pkginfo = dict(node.attributes.items())
554         try:
555             if pkginfo["kind"] != "package":
556                 continue
557             reponame = pkginfo["repository"]
558             if fromrepo and reponame != fromrepo:
559                 continue
560             pkgname = pkginfo["name"]
561             pkgversion = pkginfo["edition"]
562         except KeyError:
563             continue
564         else:
565             if _is_match(pkgname):
566                 repo_dict = ret.setdefault(reponame, {})
567                 version_list = repo_dict.setdefault(pkgname, set())
568                 version_list.add(pkgversion)
569     if byrepo:
570         for reponame in ret:
571             for pkgname in ret[reponame]:
572                 sorted_versions = sorted(
573                     (LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True
574                 )
575                 ret[reponame][pkgname] = [x.vstring for x in sorted_versions]
576         return ret
577     else:
578         byrepo_ret = {}
579         for reponame in ret:
580             for pkgname in ret[reponame]:
581                 byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])
582         for pkgname in byrepo_ret:
583             sorted_versions = sorted(
584                 (LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True
585             )
586             byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]
587         return byrepo_ret
588 def _get_configured_repos(root=None):
589     repos = os.path.join(root, os.path.relpath(REPOS, os.path.sep)) if root else REPOS
590     repos_cfg = configparser.ConfigParser()
591     if os.path.exists(repos):
592         repos_cfg.read(
593             [
594                 repos + "/" + fname
595                 for fname in os.listdir(repos)
596                 if fname.endswith(".repo")
597             ]
598         )
599     else:
600         log.warning("Repositories not found in %s", repos)
601     return repos_cfg
602 def _get_repo_info(alias, repos_cfg=None, root=None):
603     try:
604         meta = dict((repos_cfg or _get_configured_repos(root=root)).items(alias))
605         meta["alias"] = alias
606         for key, val in meta.items():
607             if val in ["0", "1"]:
608                 meta[key] = int(meta[key]) == 1
609             elif val == "NONE":
610                 meta[key] = None
611         return meta
612     except (ValueError, configparser.NoSectionError):
613         return {}
614 def get_repo(repo, root=None, **kwargs):  # pylint: disable=unused-argument
615     return _get_repo_info(repo, root=root)
616 def list_repos(root=None, **kwargs):
617     repos_cfg = _get_configured_repos(root=root)
618     all_repos = {}
619     for alias in repos_cfg.sections():
620         all_repos[alias] = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
621     return all_repos
622 def del_repo(repo, root=None):
623     repos_cfg = _get_configured_repos(root=root)
624     for alias in repos_cfg.sections():
625         if alias == repo:
626             doc = __zypper__(root=root).xml.call(
627                 "rr", "--loose-auth", "--loose-query", alias
628             )
629             msg = doc.getElementsByTagName("message")
630             if doc.getElementsByTagName("progress") and msg:
631                 return {
632                     repo: True,
633                     "message": msg[0].childNodes[0].nodeValue,
634                 }
635     raise CommandExecutionError("Repository '{}' not found.".format(repo))
636 def mod_repo(repo, **kwargs):
637     root = kwargs.get("root") or None
638     repos_cfg = _get_configured_repos(root=root)
639     added = False
640     if repo not in repos_cfg.sections():
641         url = kwargs.get("url", kwargs.get("mirrorlist", kwargs.get("baseurl")))
642         if not url:
643             raise CommandExecutionError(
644                 "Repository '{}' not found, and neither 'baseurl' nor "
645                 "'mirrorlist' was specified".format(repo)
646             )
647         if not urllib.parse.urlparse(url).scheme:
648             raise CommandExecutionError(
649                 "Repository '{}' not found and URL for baseurl/mirrorlist "
650                 "is malformed".format(repo)
651             )
652         for alias in repos_cfg.sections():
653             repo_meta = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
654             new_url = urllib.parse.urlparse(url)
655             if not new_url.path:
656                 new_url = urllib.parse.urlparse.ParseResult(
657                     scheme=new_url.scheme,  # pylint: disable=E1123
658                     netloc=new_url.netloc,
659                     path="/",
660                     params=new_url.params,
661                     query=new_url.query,
662                     fragment=new_url.fragment,
663                 )
664             base_url = urllib.parse.urlparse(repo_meta["baseurl"])
665             if new_url == base_url:
666                 raise CommandExecutionError(
667                     "Repository '{}' already exists as '{}'.".format(repo, alias)
668                 )
669         __zypper__(root=root).xml.call("ar", url, repo)
670         repos_cfg = _get_configured_repos(root=root)
671         if repo not in repos_cfg.sections():
672             raise CommandExecutionError(
673                 "Failed add new repository '{}' for unspecified reason. "
674                 "Please check zypper logs.".format(repo)
675             )
676         added = True
677     repo_info = _get_repo_info(repo, root=root)
678     if (
679         not added
680         and "baseurl" in kwargs
681         and not (kwargs["baseurl"] == repo_info["baseurl"])
682     ):
683         repo_info.update(kwargs)
684         repo_info.setdefault("cache", False)
685         del_repo(repo, root=root)
686         return mod_repo(repo, root=root, **repo_info)
687     cmd_opt = []
688     global_cmd_opt = []
689     call_refresh = False
690     if "enabled" in kwargs:
691         cmd_opt.append(kwargs["enabled"] and "--enable" or "--disable")
692     if "refresh" in kwargs:
693         cmd_opt.append(kwargs["refresh"] and "--refresh" or "--no-refresh")
694     if "cache" in kwargs:
695         cmd_opt.append(kwargs["cache"] and "--keep-packages" or "--no-keep-packages")
696     if "gpgcheck" in kwargs:
697         cmd_opt.append(kwargs["gpgcheck"] and "--gpgcheck" or "--no-gpgcheck")
698     if "priority" in kwargs:
699         cmd_opt.append("--priority={}".format(kwargs.get("priority", DEFAULT_PRIORITY)))
700     if "humanname" in kwargs:
701         cmd_opt.append("--name='{}'".format(kwargs.get("humanname")))
702     if kwargs.get("gpgautoimport") is True:
703         global_cmd_opt.append("--gpg-auto-import-keys")
704         call_refresh = True
705     if cmd_opt:
706         cmd_opt = global_cmd_opt + ["mr"] + cmd_opt + [repo]
707         __zypper__(root=root).refreshable.xml.call(*cmd_opt)
708     comment = None
709     if call_refresh:
710         refresh_opts = global_cmd_opt + ["refresh"] + [repo]
711         __zypper__(root=root).xml.call(*refresh_opts)
712     elif not added and not cmd_opt:
713         comment = "Specified arguments did not result in modification of repo"
714     repo = get_repo(repo, root=root)
715     if comment:
716         repo["comment"] = comment
717     return repo
718 def refresh_db(force=None, root=None):
719     salt.utils.pkg.clear_rtag(__opts__)
720     ret = {}
721     refresh_opts = ["refresh"]
722     if force is None:
723         force = __pillar__.get("zypper", {}).get("refreshdb_force", True)
724     if force:
725         refresh_opts.append("--force")
726     out = __zypper__(root=root).refreshable.call(*refresh_opts)
727     for line in out.splitlines():
728         if not line:
729             continue
730         if line.strip().startswith("Repository") and "'" in line:
731             try:
732                 key = line.split("'")[1].strip()
733                 if "is up to date" in line:
734                     ret[key] = False
735             except IndexError:
736                 continue
737         elif line.strip().startswith("Building") and "'" in line:
738             key = line.split("'")[1].strip()
739             if "done" in line:
740                 ret[key] = True
741     return ret
742 def _find_types(pkgs):
743     return sorted({pkg.split(":", 1)[0] for pkg in pkgs if len(pkg.split(":", 1)) == 2})
744 def install(
745     name=None,
746     refresh=False,
747     fromrepo=None,
748     pkgs=None,
749     sources=None,
750     downloadonly=None,
751     skip_verify=False,
752     version=None,
753     ignore_repo_failure=False,
754     no_recommends=False,
755     root=None,
756     **kwargs
757 ):
758     if refresh:
759         refresh_db(root)
760     try:
761         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
762             name, pkgs, sources, **kwargs
763         )
764     except MinionError as exc:
765         raise CommandExecutionError(exc)
766     if pkg_params is None or len(pkg_params) == 0:
767         return {}
768     version_num = Wildcard(__zypper__(root=root))(name, version)
769     if version_num:
770         if pkgs is None and sources is None:
771             pkg_params = {name: version_num}
772         else:
773             log.warning(
774                 '"version" parameter will be ignored for multiple package targets'
775             )
776     if pkg_type == "repository":
777         targets = []
778         for param, version_num in pkg_params.items():
779             if version_num is None:
780                 log.debug("targeting package: %s", param)
781                 targets.append(param)
782             else:
783                 prefix, verstr = salt.utils.pkg.split_comparison(version_num)
784                 if not prefix:
785                     prefix = "="
786                 target = "{}{}{}".format(param, prefix, verstr)
787                 log.debug("targeting package: %s", target)
788                 targets.append(target)
789     elif pkg_type == "advisory":
790         targets = []
791         cur_patches = list_patches(root=root)
792         for advisory_id in pkg_params:
793             if advisory_id not in cur_patches:
794                 raise CommandExecutionError(
795                     'Advisory id "{}" not found'.format(advisory_id)
796                 )
797             else:
798                 targets.append(advisory_id)
799     else:
800         targets = pkg_params
801     diff_attr = kwargs.get("diff_attr")
802     includes = _find_types(targets)
803     old = (
804         list_pkgs(attr=diff_attr, root=root, includes=includes)
805         if not downloadonly
806         else list_downloaded(root)
807     )
808     downgrades = []
809     if fromrepo:
810         fromrepoopt = ["--force", "--force-resolution", "--from", fromrepo]
811         log.info("Targeting repo '%s'", fromrepo)
812     else:
813         fromrepoopt = ""
814     cmd_install = ["install", "--auto-agree-with-licenses"]
815     cmd_install.append(
816         kwargs.get("resolve_capabilities") and "--capability" or "--name"
817     )
818     if not refresh:
819         cmd_install.insert(0, "--no-refresh")
820     if skip_verify:
821         cmd_install.insert(0, "--no-gpg-checks")
822     if downloadonly:
823         cmd_install.append("--download-only")
824     if fromrepo:
825         cmd_install.extend(fromrepoopt)
826     if no_recommends:
827         cmd_install.append("--no-recommends")
828     errors = []
829     if pkg_type == "advisory":
830         targets = ["patch:{}".format(t) for t in targets]
831     systemd_scope = _systemd_scope()
832     while targets:
833         cmd = cmd_install + targets[:500]
834         targets = targets[500:]
835         for line in (
836             __zypper__(
837                 no_repo_failure=ignore_repo_failure,
838                 systemd_scope=systemd_scope,
839                 root=root,
840             )
841             .call(*cmd)
842             .splitlines()
843         ):
844             match = re.match(
845                 r"^The selected package '([^']+)'.+has lower version", line
846             )
847             if match:
848                 downgrades.append(match.group(1))
849     while downgrades:
850         cmd = cmd_install + ["--force"] + downgrades[:500]
851         downgrades = downgrades[500:]
852         __zypper__(no_repo_failure=ignore_repo_failure, root=root).call(*cmd)
853     _clean_cache()
854     new = (
855         list_pkgs(attr=diff_attr, root=root, includes=includes)
856         if not downloadonly
857         else list_downloaded(root)
858     )
859     ret = salt.utils.data.compare_dicts(old, new)
860     if includes:
861         _clean_cache()
862     if errors:
863         raise CommandExecutionError(
864             "Problem encountered {} package(s)".format(
865                 "downloading" if downloadonly else "installing"
866             ),
867             info={"errors": errors, "changes": ret},
868         )
869     return ret
870 def upgrade(
871     refresh=True,
872     dryrun=False,
873     dist_upgrade=False,
874     fromrepo=None,
875     novendorchange=False,
876     skip_verify=False,
877     no_recommends=False,
878     root=None,
879     **kwargs
880 ):  # pylint: disable=unused-argument
881     cmd_update = (["dist-upgrade"] if dist_upgrade else ["update"]) + [
882         "--auto-agree-with-licenses"
883     ]
884     if skip_verify:
885         cmd_update.insert(0, "--no-gpg-checks")
886     if refresh:
887         refresh_db(root)
888     if dryrun:
889         cmd_update.append("--dry-run")
890     if fromrepo:
891         if isinstance(fromrepo, str):
892             fromrepo = [fromrepo]
893         for repo in fromrepo:
894             cmd_update.extend(["--from" if dist_upgrade else "--repo", repo])
895         log.info("Targeting repos: %s", fromrepo)
896     if dist_upgrade:
897         if novendorchange:
898             if __grains__["osrelease_info"][0] &gt; 11:
899                 cmd_update.append("--no-allow-vendor-change")
900                 log.info("Disabling vendor changes")
901             else:
902                 log.warning(
903                     "Disabling vendor changes is not supported on this Zypper version"
904                 )
905         if no_recommends:
906             cmd_update.append("--no-recommends")
907             log.info("Disabling recommendations")
908         if dryrun:
909             log.info("Executing debugsolver and performing a dry-run dist-upgrade")
910             __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(
911                 *cmd_update + ["--debug-solver"]
912             )
913     old = list_pkgs(root=root)
914     __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(*cmd_update)
915     _clean_cache()
916     new = list_pkgs(root=root)
917     ret = salt.utils.data.compare_dicts(old, new)
918     if __zypper__.exit_code not in __zypper__.SUCCESS_EXIT_CODES:
919         result = {
920             "retcode": __zypper__.exit_code,
921             "stdout": __zypper__.stdout,
922             "stderr": __zypper__.stderr,
923             "pid": __zypper__.pid,
924         }
925         raise CommandExecutionError(
926             "Problem encountered upgrading packages",
927             info={"changes": ret, "result": result},
928         )
929     if dryrun:
930         ret = (__zypper__.stdout + os.linesep + __zypper__.stderr).strip()
931     return ret
932 def _uninstall(name=None, pkgs=None, root=None):
933     try:
934         pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
935     except MinionError as exc:
936         raise CommandExecutionError(exc)
937     includes = _find_types(pkg_params.keys())
938     old = list_pkgs(root=root, includes=includes)
939     targets = []
940     for target in pkg_params:
941         if target in old and pkg_params[target] in old[target].split(","):
942             targets.append(target + "-" + pkg_params[target])
943         elif target in old and not pkg_params[target]:
944             targets.append(target)
945     if not targets:
946         return {}
947     systemd_scope = _systemd_scope()
948     errors = []
949     while targets:
950         __zypper__(systemd_scope=systemd_scope, root=root).call(
951             "remove", *targets[:500]
952         )
953         targets = targets[500:]
954     _clean_cache()
955     new = list_pkgs(root=root, includes=includes)
956     ret = salt.utils.data.compare_dicts(old, new)
957     if errors:
958         raise CommandExecutionError(
959             "Problem encountered removing package(s)",
960             info={"errors": errors, "changes": ret},
961         )
962     return ret
963 def normalize_name(name):
964     try:
965         arch = name.rsplit(".", 1)[-1]
966         if arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
967             return name
968     except ValueError:
969         return name
970     if arch in (__grains__["osarch"], "noarch") or salt.utils.pkg.rpm.check_32(
971         arch, osarch=__grains__["osarch"]
972     ):
973         return name[: -(len(arch) + 1)]
974     return name
975 def remove(
976     name=None, pkgs=None, root=None, **kwargs
977 ):  # pylint: disable=unused-argument
978     return _uninstall(name=name, pkgs=pkgs, root=root)
979 def purge(name=None, pkgs=None, root=None, **kwargs):  # pylint: disable=unused-argument
980     return _uninstall(name=name, pkgs=pkgs, root=root)
981 def list_locks(root=None):
982     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try:
983         with salt.utils.files.fopen(_locks) as fhr:
984             items = salt.utils.stringutils.to_unicode(fhr.read(</b></font>)).split("\n\n")
985             for meta in [item.split("\n") for item in items]:
986                 lock = {}
987                 for element in [el for el in meta if el]:
988                     if ":" in element:
989                         lock.update(
990                             dict([tuple(i.strip() for i in element.split(":", 1))])
991                         )
992                 if lock.get("solvable_name"):
993                     locks[lock.pop("solvable_name")] = lock
994     except OSError:
995         pass
996     except Exception:  # pylint: disable=broad-except
997         log.warning("Detected a problem when accessing %s", _locks)
998     return locks
999 def clean_locks(root=None):
1000     LCK = "removed"
1001     out = {LCK: 0}
1002     locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
1003     if not os.path.exists(locks):
1004         return out
1005     for node in __zypper__(root=root).xml.call("cl").getElementsByTagName("message"):
1006         text = node.childNodes[0].nodeValue.lower()
1007         if text.startswith(LCK):
1008             out[LCK] = text.split(" ")[1]
1009             break
1010     return out
1011 def unhold(name=None, pkgs=None, **kwargs):
1012     ret = {}
1013     if not name and not pkgs:
1014         raise CommandExecutionError("Name or packages must be specified.")
1015     targets = []
1016     if pkgs:
1017         for pkg in salt.utils.data.repack_dictlist(pkgs):
1018             targets.append(pkg)
1019     else:
1020         targets.append(name)
1021     locks = list_locks()
1022     removed = []
1023     missing = []
1024     for target in targets:
1025         ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
1026         if locks.get(target):
1027             removed.append(target)
1028             ret[target]["changes"]["new"] = ""
1029             ret[target]["changes"]["old"] = "hold"
1030             ret[target]["comment"] = "Package {} is no longer held.".format(target)
1031         else:
1032             missing.append(target)
1033             ret[target]["comment"] = "Package {} was already unheld.".format(target)
1034     if removed:
1035         __zypper__.call("rl", *removed)
1036     return ret
1037 def hold(name=None, pkgs=None, **kwargs):
1038     ret = {}
1039     if not name and not pkgs:
1040         raise CommandExecutionError("Name or packages must be specified.")
1041     targets = []
1042     if pkgs:
1043         for pkg in salt.utils.data.repack_dictlist(pkgs):
1044             targets.append(pkg)
1045     else:
1046         targets.append(name)
1047     locks = list_locks()
1048     added = []
1049     for target in targets:
1050         ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
1051         if not locks.get(target):
1052             added.append(target)
1053             ret[target]["changes"]["new"] = "hold"
1054             ret[target]["changes"]["old"] = ""
1055             ret[target]["comment"] = "Package {} is now being held.".format(target)
1056         else:
1057             ret[target]["comment"] = "Package {} is already set to be held.".format(
1058                 target
1059             )
1060     if added:
1061         __zypper__.call("al", *added)
1062     return ret
1063 def verify(*names, **kwargs):
1064     return __salt__["lowpkg.verify"](*names, **kwargs)
1065 def file_list(*packages, **kwargs):
1066     return __salt__["lowpkg.file_list"](*packages, **kwargs)
1067 def file_dict(*packages, **kwargs):
1068     return __salt__["lowpkg.file_dict"](*packages, **kwargs)
1069 def modified(*packages, **flags):
1070     return __salt__["lowpkg.modified"](*packages, **flags)
1071 def owner(*paths, **kwargs):
1072     return __salt__["lowpkg.owner"](*paths, **kwargs)
1073 def _get_visible_patterns(root=None):
1074     patterns = {}
1075     search_patterns = __zypper__(root=root).nolock.xml.call("se", "-t", "pattern")
1076     for element in search_patterns.getElementsByTagName("solvable"):
1077         installed = element.getAttribute("status") == "installed"
1078         patterns[element.getAttribute("name")] = {
1079             "installed": installed,
1080             "summary": element.getAttribute("summary"),
1081         }
1082     return patterns
1083 def _get_installed_patterns(root=None):
1084     def _pattern_name(capability):
1085         return capability.split("=")[-1].strip()
1086     cmd = ["rpm"]
1087     if root:
1088         cmd.extend(["--root", root])
1089     cmd.extend(["-q", "--provides", "--whatprovides", "pattern()"])
1090     output = __salt__["cmd.run"](cmd, ignore_retcode=True)
1091     installed_patterns = {
1092         _pattern_name(line)
1093         for line in output.splitlines()
1094         if line.startswith("pattern() = ") and not _pattern_name(line).startswith(".")
1095     }
1096     patterns = {
1097         k: v for k, v in _get_visible_patterns(root=root).items() if v["installed"]
1098     }
1099     for pattern in installed_patterns:
1100         if pattern not in patterns:
1101             patterns[pattern] = {
1102                 "installed": True,
1103                 "summary": "Non-visible pattern",
1104             }
1105     return patterns
1106 def list_patterns(refresh=False, root=None):
1107     if refresh:
1108         refresh_db(root)
1109     return _get_visible_patterns(root=root)
1110 def list_installed_patterns(root=None):
1111     return _get_installed_patterns(root=root)
1112 def search(criteria, refresh=False, **kwargs):
1113     ALLOWED_SEARCH_OPTIONS = {
1114         "provides": "--provides",
1115         "recommends": "--recommends",
1116         "requires": "--requires",
1117         "suggests": "--suggests",
1118         "conflicts": "--conflicts",
1119         "obsoletes": "--obsoletes",
1120         "file_list": "--file-list",
1121         "search_descriptions": "--search-descriptions",
1122         "case_sensitive": "--case-sensitive",
1123         "installed_only": "--installed-only",
1124         "not_installed_only": "-u",
1125         "details": "--details",
1126     }
1127     root = kwargs.get("root", None)
1128     if refresh:
1129         refresh_db(root)
1130     cmd = ["search"]
1131     if kwargs.get("match") == "exact":
1132         cmd.append("--match-exact")
1133     elif kwargs.get("match") == "words":
1134         cmd.append("--match-words")
1135     elif kwargs.get("match") == "substrings":
1136         cmd.append("--match-substrings")
1137     for opt in kwargs:
1138         if opt in ALLOWED_SEARCH_OPTIONS:
1139             cmd.append(ALLOWED_SEARCH_OPTIONS.get(opt))
1140     cmd.append(criteria)
1141     solvables = (
1142         __zypper__(root=root)
1143         .nolock.noraise.xml.call(*cmd)
1144         .getElementsByTagName("solvable")
1145     )
1146     if not solvables:
1147         raise CommandExecutionError("No packages found matching '{}'".format(criteria))
1148     out = {}
1149     for solvable in solvables:
1150         out[solvable.getAttribute("name")] = dict()
1151         for k, v in solvable.attributes.items():
1152             out[solvable.getAttribute("name")][k] = v
1153     return out
1154 def _get_first_aggregate_text(node_list):
1155     if not node_list:
1156         return ""
1157     out = []
1158     for node in node_list[0].childNodes:
1159         if node.nodeType == dom.Document.TEXT_NODE:
1160             out.append(node.nodeValue)
1161     return "\n".join(out)
1162 def list_products(all=False, refresh=False, root=None):
1163     if refresh:
1164         refresh_db(root)
1165     ret = list()
1166     OEM_PATH = "/var/lib/suseRegister/OEM"
1167     if root:
1168         OEM_PATH = os.path.join(root, os.path.relpath(OEM_PATH, os.path.sep))
1169     cmd = list()
1170     if not all:
1171         cmd.append("--disable-repositories")
1172     cmd.append("products")
1173     if not all:
1174         cmd.append("-i")
1175     product_list = (
1176         __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("product-list")
1177     )
1178     if not product_list:
1179         return ret  # No products found
1180     for prd in product_list[0].getElementsByTagName("product"):
1181         p_nfo = dict()
1182         for k_p_nfo, v_p_nfo in prd.attributes.items():
1183             if k_p_nfo in ["isbase", "installed"]:
1184                 p_nfo[k_p_nfo] = bool(v_p_nfo in ["true", "1"])
1185             elif v_p_nfo:
1186                 p_nfo[k_p_nfo] = v_p_nfo
1187         eol = prd.getElementsByTagName("endoflife")
1188         if eol:
1189             p_nfo["eol"] = eol[0].getAttribute("text")
1190             p_nfo["eol_t"] = int(eol[0].getAttribute("time_t") or 0)
1191         p_nfo["description"] = " ".join(
1192             [
1193                 line.strip()
1194                 for line in _get_first_aggregate_text(
1195                     prd.getElementsByTagName("description")
1196                 ).split(os.linesep)
1197             ]
1198         )
1199         if "productline" in p_nfo and p_nfo["productline"]:
1200             oem_file = os.path.join(OEM_PATH, p_nfo["productline"])
1201             if os.path.isfile(oem_file):
1202                 with salt.utils.files.fopen(oem_file, "r") as rfile:
1203                     oem_release = salt.utils.stringutils.to_unicode(
1204                         rfile.readline()
1205                     ).strip()
1206                     if oem_release:
1207                         p_nfo["release"] = oem_release
1208         ret.append(p_nfo)
1209     return ret
1210 def download(*packages, **kwargs):
1211     if not packages:
1212         raise SaltInvocationError("No packages specified")
1213     root = kwargs.get("root", None)
1214     refresh = kwargs.get("refresh", False)
1215     if refresh:
1216         refresh_db(root)
1217     pkg_ret = {}
1218     for dld_result in (
1219         __zypper__(root=root)
1220         .xml.call("download", *packages)
1221         .getElementsByTagName("download-result")
1222     ):
1223         repo = dld_result.getElementsByTagName("repository")[0]
1224         path = dld_result.getElementsByTagName("localfile")[0].getAttribute("path")
1225         pkg_info = {
1226             "repository-name": repo.getAttribute("name"),
1227             "repository-alias": repo.getAttribute("alias"),
1228             "path": path,
1229         }
1230         key = _get_first_aggregate_text(dld_result.getElementsByTagName("name"))
1231         if __salt__["lowpkg.checksum"](pkg_info["path"], root=root):
1232             pkg_ret[key] = pkg_info
1233     if pkg_ret:
1234         failed = [pkg for pkg in packages if pkg not in pkg_ret]
1235         if failed:
1236             pkg_ret[
1237                 "_error"
1238             ] = "The following package(s) failed to download: {}".format(
1239                 ", ".join(failed)
1240             )
1241         return pkg_ret
1242     raise CommandExecutionError(
1243         "Unable to download packages: {}".format(", ".join(packages))
1244     )
1245 def list_downloaded(root=None, **kwargs):
1246     CACHE_DIR = "/var/cache/zypp/packages/"
1247     if root:
1248         CACHE_DIR = os.path.join(root, os.path.relpath(CACHE_DIR, os.path.sep))
1249     ret = {}
1250     for root, dirnames, filenames in salt.utils.path.os_walk(CACHE_DIR):
1251         for filename in fnmatch.filter(filenames, "*.rpm"):
1252             package_path = os.path.join(root, filename)
1253             pkg_info = __salt__["lowpkg.bin_pkg_info"](package_path)
1254             pkg_timestamp = int(os.path.getctime(package_path))
1255             ret.setdefault(pkg_info["name"], {})[pkg_info["version"]] = {
1256                 "path": package_path,
1257                 "size": os.path.getsize(package_path),
1258                 "creation_date_time_t": pkg_timestamp,
1259                 "creation_date_time": datetime.datetime.utcfromtimestamp(
1260                     pkg_timestamp
1261                 ).isoformat(),
1262             }
1263     return ret
1264 def diff(*paths, **kwargs):
1265     ret = {}
1266     pkg_to_paths = {}
1267     for pth in paths:
1268         pth_pkg = __salt__["lowpkg.owner"](pth, **kwargs)
1269         if not pth_pkg:
1270             ret[pth] = os.path.exists(pth) and "Not managed" or "N/A"
1271         else:
1272             if pkg_to_paths.get(pth_pkg) is None:
1273                 pkg_to_paths[pth_pkg] = []
1274             pkg_to_paths[pth_pkg].append(pth)
1275     if pkg_to_paths:
1276         local_pkgs = __salt__["pkg.download"](*pkg_to_paths.keys(), **kwargs)
1277         for pkg, files in pkg_to_paths.items():
1278             for path in files:
1279                 ret[path] = (
1280                     __salt__["lowpkg.diff"](local_pkgs[pkg]["path"], path)
1281                     or "Unchanged"
1282                 )
1283     return ret
1284 def _get_patches(installed_only=False, root=None):
1285     patches = {}
1286     for element in (
1287         __zypper__(root=root)
1288         .nolock.xml.call("se", "-t", "patch")
1289         .getElementsByTagName("solvable")
1290     ):
1291         installed = element.getAttribute("status") == "installed"
1292         if (installed_only and installed) or not installed_only:
1293             patches[element.getAttribute("name")] = {
1294                 "installed": installed,
1295                 "summary": element.getAttribute("summary"),
1296             }
1297     return patches
1298 def list_patches(refresh=False, root=None, **kwargs):
1299     if refresh:
1300         refresh_db(root)
1301     return _get_patches(root=root)
1302 def list_installed_patches(root=None, **kwargs):
1303     return _get_patches(installed_only=True, root=root)
1304 def list_provides(root=None, **kwargs):
1305     ret = __context__.get("pkg.list_provides")
1306     if not ret:
1307         cmd = ["rpm"]
1308         if root:
1309             cmd.extend(["--root", root])
1310         cmd.extend(["-qa", "--queryformat", "%{PROVIDES}_|-%{NAME}\n"])
1311         ret = dict()
1312         for line in __salt__["cmd.run"](
1313             cmd, output_loglevel="trace", python_shell=False
1314         ).splitlines():
1315             provide, realname = line.split("_|-")
1316             if provide == realname:
1317                 continue
1318             if provide not in ret:
1319                 ret[provide] = list()
1320             ret[provide].append(realname)
1321         __context__["pkg.list_provides"] = ret
1322     return ret
1323 def resolve_capabilities(pkgs, refresh=False, root=None, **kwargs):
1324     if refresh:
1325         refresh_db(root)
1326     ret = list()
1327     for pkg in pkgs:
1328         if isinstance(pkg, dict):
1329             name = next(iter(pkg))
1330             version = pkg[name]
1331         else:
1332             name = pkg
1333             version = None
1334         if kwargs.get("resolve_capabilities", False):
1335             try:
1336                 search(name, root=root, match="exact")
1337             except CommandExecutionError:
1338                 try:
1339                     result = search(name, root=root, provides=True, match="exact")
1340                     if len(result) == 1:
1341                         name = next(iter(result.keys()))
1342                     elif len(result) &gt; 1:
1343                         log.warning("Found ambiguous match for capability '%s'.", pkg)
1344                 except CommandExecutionError as exc:
1345                     log.debug("Search failed with: %s", exc)
1346         if version:
1347             ret.append({name: version})
1348         else:
1349             ret.append(name)
1350     return ret
1351 def services_need_restart(root=None, **kwargs):
1352     cmd = ["ps", "-sss"]
1353     zypper_output = __zypper__(root=root).nolock.call(*cmd)
1354     services = zypper_output.split()
1355     return services
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
