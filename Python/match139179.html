<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for linux_sysctl.py &amp; zypperpkg.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for linux_sysctl.py &amp; zypperpkg.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>linux_sysctl.py (12.275449%)<th>zypperpkg.py (1.4133058%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(202-214)<td><a href="#" name="0">(668-672)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(188-193)<td><a href="#" name="1">(2040-2042)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(5-18)<td><a href="#" name="2">(31-42)</a><td align="center"><font color="#bf0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>linux_sysctl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
import os
import re
import salt.utils.data
import salt.utils.files
import salt.utils.stringutils
import salt.utils.systemd
from salt.exceptions import CommandExecutionError
log = logging.getLogger(__name__)
__virtualname__ =</b></font> "sysctl"
def __virtual__():
    if __grains__["kernel"] != "Linux":
        return (
            False,
            "The linux_sysctl execution module cannot be loaded: only available on"
            " Linux systems.",
        )
    return __virtualname__
def default_config():
    if (
        salt.utils.systemd.booted(__context__)
        and salt.utils.systemd.version(__context__) &gt;= 207
    ):
        return "/etc/sysctl.d/99-salt.conf"
    return "/etc/sysctl.conf"
def show(config_file=False):
    ret = {}
    if config_file:
        if not os.path.exists(config_file):
            return []
        try:
            with salt.utils.files.fopen(config_file) as fp_:
                for line in fp_:
                    line = salt.utils.stringutils.to_str(line)
                    if not line.startswith("#") and "=" in line:
                        SPLIT = " = "
                        if SPLIT not in line:
                            SPLIT = SPLIT.strip()
                        key, value = line.split(SPLIT, 1)
                        key = key.strip()
                        value = value.lstrip()
                        ret[key] = value
        except OSError:
            log.error("Could not open sysctl file")
            return None
    else:
        cmd = "sysctl -a"
        out = __salt__["cmd.run_stdout"](cmd, output_loglevel="trace")
        for line in out.splitlines():
            if not line or " = " not in line:
                continue
            comps = line.split(" = ", 1)
            ret[comps[0]] = comps[1]
    return ret
def get(name):
    cmd = "sysctl -n {}".format(name)
    out = __salt__["cmd.run"](cmd, python_shell=False)
    return out
def assign(name, value):
    value = str(value)
    tran_tab = name.translate("".maketrans("./", "/."))
    sysctl_file = "/proc/sys/{}".format(tran_tab)
    if not os.path.exists(sysctl_file):
        raise CommandExecutionError("sysctl {} does not exist".format(name))
    ret = {}
    cmd = 'sysctl -w {}="{}"'.format(name, value)
    data = __salt__["cmd.run_all"](cmd, python_shell=False)
    out = data["stdout"]
    err = data["stderr"]
    regex = re.compile(r"^{}\s+=\s+{}$".format(re.escape(name), re.escape(value)))
    if not regex.match(out) or "Invalid argument" in str(err):
        if data["retcode"] != 0 and err:
            error = err
        else:
            error = out
        raise CommandExecutionError("sysctl -w failed: {}".format(error))
    new_name, new_value = out.split(" = ", 1)
    ret[new_name] = new_value
    return ret
def persist(name, value, config=None):
    if config is None:
        config = default_config()
    edited = False
    if not os.path.isfile(config):
        sysctl_dir = os.path.dirname(config)
        if not os.path.exists(sysctl_dir):
            os.makedirs(sysctl_dir)
        try:
            with salt.utils.files.fopen(config, "w+") as _fh:
                _fh.write("#\n# Kernel sysctl configuration\n#\n")
        except OSError:
            msg = "Could not write to file: {0}"
            raise CommandExecutionError(msg.format(config))
<a name="1"></a>
    nlines = []
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try:
        with salt.utils.files.fopen(config, "r") as _fh:
            config_data = salt.utils.data.decode(_fh.readlines(</b></font>))
    except OSError:
        msg = "Could not read from file: {0}"
        raise CommandExecutionError(msg.format(config))
    for line in config_data:
            nlines.append(line)
            continue
        <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if "=" not in line:
            nlines.append(line)
            continue
        comps = [i.strip() for i in line.split("=", 1)]
        if isinstance(comps[1], str) and " " in comps[1]:
            comps[</b></font>1] = re.sub(r"\s+", "\t", comps[1])
        if isinstance(value, str) and " " in value:
            value = re.sub(r"\s+", "\t", value)
        if len(comps) &lt; 2:
            nlines.append(line)
            continue
        if name == comps[0]:
            if str(comps[1]) == str(value):
                if str(get(name)) != str(value):
                    assign(name, value)
                    return "Updated"
                else:
                    return "Already set"
            nlines.append("{} = {}\n".format(name, value))
            edited = True
            continue
        else:
            nlines.append(line)
    if not edited:
        nlines.append("{} = {}\n".format(name, value))
    try:
        with salt.utils.files.fopen(config, "wb") as _fh:
            _fh.writelines(salt.utils.data.encode(nlines))
    except OSError:
        msg = "Could not write to file: {0}"
        raise CommandExecutionError(msg.format(config))
    assign(name, value)
    return "Updated"
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>zypperpkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import configparser
import datetime
import fnmatch
import logging
import os
import re
import time
import urllib.parse
from xml.dom import minidom as dom
from xml.parsers.expat import ExpatError
import salt.utils.data
import salt.utils.environment
<a name="2"></a>import salt.utils.event
import salt.utils.files
import salt.utils.functools
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.path
import salt.utils.pkg
import salt.utils.pkg.rpm
import salt.utils.stringutils
import salt.utils.systemd
import salt.utils.versions
from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
from salt.utils.versions import LooseVersion
log = logging.getLogger(__name__)
HAS_ZYPP =</b></font> False
ZYPP_HOME = "/etc/zypp"
LOCKS = "{}/locks".format(ZYPP_HOME)
REPOS = "{}/repos.d".format(ZYPP_HOME)
DEFAULT_PRIORITY = 99
PKG_ARCH_SEPARATOR = "."
__virtualname__ = "pkg"
def __virtual__():
    if __grains__.get("os_family", "") != "Suse":
        return (
            False,
            "Module zypper: non SUSE OS not supported by zypper package manager",
        )
    if not salt.utils.path.which("zypper"):
        return (False, "Module zypper: zypper package manager not found")
    return __virtualname__
class _Zypper:
    SUCCESS_EXIT_CODES = {
        0: "Successful run of zypper with no special info.",
        100: "Patches are available for installation.",
        101: "Security patches are available for installation.",
        102: "Installation successful, reboot required.",
        103: "Installation successful, restart of the package manager itself required.",
    }
    WARNING_EXIT_CODES = {
        6: "No repositories are defined.",
        7: "The ZYPP library is locked.",
        106: (
            "Some repository had to be disabled temporarily because it failed to"
            " refresh. You should check your repository configuration (e.g. zypper ref"
            " -f)."
        ),
        107: (
            "Installation basically succeeded, but some of the packages %post install"
            " scripts returned an error. These packages were successfully unpacked to"
            " disk and are registered in the rpm database, but due to the failed"
            " install script they may not work as expected. The failed scripts output"
            " might reveal what actually went wrong. Any scripts output is also logged"
            " to /var/log/zypp/history."
        ),
    }
    LOCK_EXIT_CODE = 7
    XML_DIRECTIVES = ["-x", "--xmlout"]
    ZYPPER_LOCK = "/var/run/zypp.pid"
    TAG_RELEASED = "zypper/released"
    TAG_BLOCKED = "zypper/blocked"
    def __init__(self):
        self._reset()
    def _reset(self):
        self.__cmd = ["zypper", "--non-interactive"]
        self.__exit_code = 0
        self.__call_result = dict()
        self.__error_msg = ""
        self.__env = salt.utils.environment.get_module_environment(globals())
        self.__xml = False
        self.__no_lock = False
        self.__no_raise = False
        self.__refresh = False
        self.__ignore_repo_failure = False
        self.__systemd_scope = False
        self.__root = None
        self.__called = False
    def __call__(self, *args, **kwargs):
        if self.__called:
            self._reset()
        if "no_repo_failure" in kwargs:
            self.__ignore_repo_failure = kwargs["no_repo_failure"]
        if "systemd_scope" in kwargs:
            self.__systemd_scope = kwargs["systemd_scope"]
        if "root" in kwargs:
            self.__root = kwargs["root"]
        return self
    def __getattr__(self, item):
        if self.__called:
            self._reset()
        if item == "xml":
            self.__xml = True
        elif item == "nolock":
            self.__no_lock = True
        elif item == "noraise":
            self.__no_raise = True
        elif item == "refreshable":
            self.__refresh = True
        elif item == "call":
            return self.__call
        else:
            return self.__dict__[item]
        if self.__no_lock:
            self.__no_lock = not self.__refresh
        return self
    @property
    def exit_code(self):
        return self.__exit_code
    @exit_code.setter
    def exit_code(self, exit_code):
        self.__exit_code = int(exit_code or "0")
    @property
    def error_msg(self):
        return self.__error_msg
    @error_msg.setter
    def error_msg(self, msg):
        if self._is_error():
            self.__error_msg = msg and os.linesep.join(msg) or "Check Zypper's logs."
    @property
    def stdout(self):
        return self.__call_result.get("stdout", "")
    @property
    def stderr(self):
        return self.__call_result.get("stderr", "")
    @property
    def pid(self):
        return self.__call_result.get("pid", "")
    def _is_error(self):
        if self.exit_code:
            msg = self.SUCCESS_EXIT_CODES.get(self.exit_code)
            if msg:
                log.info(msg)
            msg = self.WARNING_EXIT_CODES.get(self.exit_code)
            if msg:
                log.warning(msg)
        return (
            self.exit_code not in self.SUCCESS_EXIT_CODES
            and self.exit_code not in self.WARNING_EXIT_CODES
        )
    def _is_lock(self):
        return self.exit_code == self.LOCK_EXIT_CODE
    def _is_xml_mode(self):
        return (
            [itm for itm in self.XML_DIRECTIVES if itm in self.__cmd] and True or False
        )
    def _check_result(self):
        if not self.__call_result:
            raise CommandExecutionError("No output result from Zypper?")
        self.exit_code = self.__call_result["retcode"]
        if self._is_lock():
            return False
        if self._is_error():
            _error_msg = list()
            if not self._is_xml_mode():
                msg = (
                    self.__call_result["stderr"]
                    and self.__call_result["stderr"].strip()
                    or ""
                )
                if msg:
                    _error_msg.append(msg)
            else:
                try:
                    doc = dom.parseString(self.__call_result["stdout"])
                except ExpatError as err:
                    log.error(err)
                    doc = None
                if doc:
                    msg_nodes = doc.getElementsByTagName("message")
                    for node in msg_nodes:
                        if node.getAttribute("type") == "error":
                            _error_msg.append(node.childNodes[0].nodeValue)
                elif self.__call_result["stderr"].strip():
                    _error_msg.append(self.__call_result["stderr"].strip())
            self.error_msg = _error_msg
        return True
    def __call(self, *args, **kwargs):
        self.__called = True
        if self.__xml:
            self.__cmd.append("--xmlout")
        if not self.__refresh and "--no-refresh" not in args:
            self.__cmd.append("--no-refresh")
        if self.__root:
            self.__cmd.extend(["--root", self.__root])
        self.__cmd.extend(args)
        kwargs["output_loglevel"] = "trace"
        kwargs["python_shell"] = False
        kwargs["env"] = self.__env.copy()
        if self.__no_lock:
            kwargs["env"][
                "ZYPP_READONLY_HACK"
            ] = (  # Disables locking for read-only operations. Do not try that at home!
                "1"
            )
        was_blocked = False
        while True:
            cmd = []
            if self.__systemd_scope:
                cmd.extend(["systemd-run", "--scope"])
            cmd.extend(self.__cmd)
            log.debug("Calling Zypper: %s", " ".join(cmd))
            self.__call_result = __salt__["cmd.run_all"](cmd, **kwargs)
            if self._check_result():
                break
            if os.path.exists(self.ZYPPER_LOCK):
                try:
                    with salt.utils.files.fopen(self.ZYPPER_LOCK) as rfh:
                        data = __salt__["ps.proc_info"](
                            int(rfh.readline()),
                            attrs=["pid", "name", "cmdline", "create_time"],
                        )
                        data["cmdline"] = " ".join(data["cmdline"])
                        data["info"] = "Blocking process created at {}.".format(
                            datetime.datetime.utcfromtimestamp(
                                data["create_time"]
                            ).isoformat()
                        )
                        data["success"] = True
                except Exception as err:  # pylint: disable=broad-except
                    data = {
                        "info": (
                            "Unable to retrieve information about blocking process: {}".format(
                                err.message
                            )
                        ),
                        "success": False,
                    }
            else:
                data = {
                    "info": "Zypper is locked, but no Zypper lock has been found.",
                    "success": False,
                }
            if not data["success"]:
                log.debug("Unable to collect data about blocking process.")
            else:
                log.debug("Collected data about blocking process.")
            __salt__["event.fire_master"](data, self.TAG_BLOCKED)
            log.debug(
                "Fired a Zypper blocked event to the master with the data: %s", data
            )
            log.debug("Waiting 5 seconds for Zypper gets released...")
            time.sleep(5)
            if not was_blocked:
                was_blocked = True
        if was_blocked:
            __salt__["event.fire_master"](
                {
                    "success": not self.error_msg,
                    "info": self.error_msg or "Zypper has been released",
                },
                self.TAG_RELEASED,
            )
        if self.error_msg and not self.__no_raise and not self.__ignore_repo_failure:
            raise CommandExecutionError(
                "Zypper command failure: {}".format(self.error_msg)
            )
        return (
            self._is_xml_mode()
            and dom.parseString(
                salt.utils.stringutils.to_str(self.__call_result["stdout"])
            )
            or self.__call_result["stdout"]
        )
__zypper__ = _Zypper()
class Wildcard:
    Z_OP = ["&lt;", "&lt;=", "=", "&gt;=", "&gt;"]
    def __init__(self, zypper):
        self.name = None
        self.version = None
        self.zypper = zypper
        self._attr_solvable_version = "edition"
        self._op = None
    def __call__(self, pkg_name, pkg_version):
        if pkg_version:
            self.name = pkg_name
            self._set_version(pkg_version)  # Dissects possible operator
            versions = sorted(
                LooseVersion(vrs)
                for vrs in self._get_scope_versions(self._get_available_versions())
            )
            return versions and "{}{}".format(self._op or "", versions[-1]) or None
    def _get_available_versions(self):
        solvables = self.zypper.nolock.xml.call(
            "se", "-xv", self.name
        ).getElementsByTagName("solvable")
        if not solvables:
            raise CommandExecutionError(
                "No packages found matching '{}'".format(self.name)
            )
        return sorted(
            {
                slv.getAttribute(self._attr_solvable_version)
                for slv in solvables
                if slv.getAttribute(self._attr_solvable_version)
            }
        )
    def _get_scope_versions(self, pkg_versions):
        get_in_versions = []
        for p_version in pkg_versions:
            if fnmatch.fnmatch(p_version, self.version):
                get_in_versions.append(p_version)
        return get_in_versions
    def _set_version(self, version):
        if not version:
            return
        exact_version = re.sub(r"[&lt;&gt;=+]*", "", version)
        self._op = version.replace(exact_version, "") or None
        if self._op and self._op not in self.Z_OP:
            raise CommandExecutionError(
                'Zypper do not supports operator "{}".'.format(self._op)
            )
        self.version = exact_version
def _systemd_scope():
    return salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
        "systemd.scope", True
    )
def _clean_cache():
    keys = []
    for cache_name in ["pkg.list_pkgs", "pkg.list_provides"]:
        for contextkey in __context__:
            if contextkey.startswith(cache_name):
                keys.append(contextkey)
    for key in keys:
        __context__.pop(key, None)
def list_upgrades(refresh=True, root=None, **kwargs):
    if refresh:
        refresh_db(root)
    ret = dict()
    cmd = ["list-updates"]
    if "fromrepo" in kwargs:
        repos = kwargs["fromrepo"]
        if isinstance(repos, str):
            repos = [repos]
        for repo in repos:
            cmd.extend(["--repo", repo if isinstance(repo, str) else str(repo)])
        log.debug("Targeting repos: %s", repos)
    for update_node in (
        __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("update")
    ):
        if update_node.getAttribute("kind") == "package":
            ret[update_node.getAttribute("name")] = update_node.getAttribute("edition")
    return ret
list_updates = salt.utils.functools.alias_function(list_upgrades, "list_updates")
def info_installed(*names, **kwargs):
    all_versions = kwargs.get("all_versions", False)
    ret = dict()
    for pkg_name, pkgs_nfo in __salt__["lowpkg.info"](*names, **kwargs).items():
        pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]
        for _nfo in pkg_nfo:
            t_nfo = dict()
            for key, value in _nfo.items():
                if key == "source_rpm":
                    t_nfo["source"] = value
                else:
                    t_nfo[key] = value
            if not all_versions:
                ret[pkg_name] = t_nfo
            else:
                ret.setdefault(pkg_name, []).append(t_nfo)
    return ret
def info_available(*names, **kwargs):
    ret = {}
    if not names:
        return ret
    else:
        names = sorted(list(set(names)))
    root = kwargs.get("root", None)
    if kwargs.get("refresh", True):
        refresh_db(root)
    pkg_info = []
    batch = names[:]
    batch_size = 200
    while batch:
        pkg_info.extend(
            re.split(
                r"Information for package*",
                __zypper__(root=root).nolock.call(
                    "info", "-t", "package", *batch[:batch_size]
                ),
            )
        )
        batch = batch[batch_size:]
<a name="0"></a>    for pkg_data in pkg_info:
        nfo = {}
        for line in [data for data in pkg_data.split("\n") if ":" in data]:
            <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if line.startswith("-----"):
                continue
            kw = [data.strip() for data in line.split(":", 1)]
            if len(kw) == 2 and kw[1]:
                nfo[kw[</b></font>0].lower()] = kw[1]
        if nfo.get("name"):
            name = nfo.pop("name")
            ret[name] = nfo
        if nfo.get("status"):
            nfo["status"] = nfo.get("status")
        if nfo.get("installed"):
            nfo["installed"] = nfo.get("installed").lower().startswith("yes")
    return ret
def parse_arch(name):
    _name, _arch = None, None
    try:
        _name, _arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)
    except ValueError:
        pass
    if _arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
        _name = name
        _arch = None
    return {"name": _name, "arch": _arch}
def latest_version(*names, **kwargs):
    ret = dict()
    if not names:
        return ret
    names = sorted(list(set(names)))
    package_info = info_available(*names, **kwargs)
    for name in names:
        pkg_info = package_info.get(name, {})
        status = pkg_info.get("status", "").lower()
        if status.find("not installed") &gt; -1 or status.find("out-of-date") &gt; -1:
            ret[name] = pkg_info.get("version")
        else:
            ret[name] = ""
    if len(names) == 1 and ret:
        return ret[names[0]]
    return ret
available_version = salt.utils.functools.alias_function(
    latest_version, "available_version"
)
def upgrade_available(name, **kwargs):
    return not not latest_version(name, **kwargs)  # pylint: disable=C0113
def version(*names, **kwargs):
    return __salt__["pkg_resource.version"](*names, **kwargs) or {}
def version_cmp(ver1, ver2, ignore_epoch=False, **kwargs):
    return __salt__["lowpkg.version_cmp"](ver1, ver2, ignore_epoch=ignore_epoch)
def _list_pkgs_from_context(versions_as_list, contextkey, attr):
    return __salt__["pkg_resource.format_pkg_list"](
        __context__[contextkey], versions_as_list, attr
    )
def list_pkgs(versions_as_list=False, root=None, includes=None, **kwargs):
    versions_as_list = salt.utils.data.is_true(versions_as_list)
    if any(
        [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
    ):
        return {}
    attr = kwargs.get("attr")
    if attr is not None:
        attr = salt.utils.args.split_input(attr)
    includes = includes if includes else []
    contextkey = "pkg.list_pkgs_{}_{}".format(root, includes)
    if contextkey in __context__ and kwargs.get("use_context", True):
        return _list_pkgs_from_context(versions_as_list, contextkey, attr)
    ret = {}
    cmd = ["rpm"]
    if root:
        cmd.extend(["--root", root])
    cmd.extend(
        [
            "-qa",
            "--queryformat",
            salt.utils.pkg.rpm.QUERYFORMAT.replace("%{REPOID}", "(none)") + "\n",
        ]
    )
    output = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="trace")
    for line in output.splitlines():
        pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__["osarch"])
        if pkginfo:
            pkgver = pkginfo.version
            epoch = None
            release = None
            if ":" in pkgver:
                epoch, pkgver = pkgver.split(":", 1)
            if "-" in pkgver:
                pkgver, release = pkgver.split("-", 1)
            all_attr = {
                "epoch": epoch,
                "version": pkgver,
                "release": release,
                "arch": pkginfo.arch,
                "install_date": pkginfo.install_date,
                "install_date_time_t": pkginfo.install_date_time_t,
            }
            __salt__["pkg_resource.add_pkg"](ret, pkginfo.name, all_attr)
    _ret = {}
    for pkgname in ret:
        if pkgname.startswith("gpg-pubkey"):
            continue
        _ret[pkgname] = sorted(ret[pkgname], key=lambda d: d["version"])
    for include in includes:
        if include == "product":
            products = list_products(all=False, root=root)
            for product in products:
                extended_name = "{}:{}".format(include, product["name"])
                _ret[extended_name] = [
                    {
                        "epoch": product["epoch"],
                        "version": product["version"],
                        "release": product["release"],
                        "arch": product["arch"],
                        "install_date": None,
                        "install_date_time_t": None,
                    }
                ]
        if include in ("pattern", "patch"):
            if include == "pattern":
                elements = list_installed_patterns(root=root)
            elif include == "patch":
                elements = list_installed_patches(root=root)
            else:
                elements = []
            for element in elements:
                extended_name = "{}:{}".format(include, element)
                info = info_available(extended_name, refresh=False, root=root)
                _ret[extended_name] = [
                    {
                        "epoch": None,
                        "version": info[element]["version"],
                        "release": None,
                        "arch": info[element]["arch"],
                        "install_date": None,
                        "install_date_time_t": None,
                    }
                ]
    __context__[contextkey] = _ret
    return __salt__["pkg_resource.format_pkg_list"](
        __context__[contextkey], versions_as_list, attr
    )
def list_repo_pkgs(*args, **kwargs):
    byrepo = kwargs.pop("byrepo", False)
    fromrepo = kwargs.pop("fromrepo", "") or ""
    ret = {}
    targets = [arg if isinstance(arg, str) else str(arg) for arg in args]
    def _is_match(pkgname):
        if not args:
            return True
        for target in targets:
            if fnmatch.fnmatch(pkgname, target):
                return True
        return False
    root = kwargs.get("root") or None
    for node in (
        __zypper__(root=root)
        .xml.call("se", "-s", *targets)
        .getElementsByTagName("solvable")
    ):
        pkginfo = dict(node.attributes.items())
        try:
            if pkginfo["kind"] != "package":
                continue
            reponame = pkginfo["repository"]
            if fromrepo and reponame != fromrepo:
                continue
            pkgname = pkginfo["name"]
            pkgversion = pkginfo["edition"]
        except KeyError:
            continue
        else:
            if _is_match(pkgname):
                repo_dict = ret.setdefault(reponame, {})
                version_list = repo_dict.setdefault(pkgname, set())
                version_list.add(pkgversion)
    if byrepo:
        for reponame in ret:
            for pkgname in ret[reponame]:
                sorted_versions = sorted(
                    (LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True
                )
                ret[reponame][pkgname] = [x.vstring for x in sorted_versions]
        return ret
    else:
        byrepo_ret = {}
        for reponame in ret:
            for pkgname in ret[reponame]:
                byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])
        for pkgname in byrepo_ret:
            sorted_versions = sorted(
                (LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True
            )
            byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]
        return byrepo_ret
def _get_configured_repos(root=None):
    repos = os.path.join(root, os.path.relpath(REPOS, os.path.sep)) if root else REPOS
    repos_cfg = configparser.ConfigParser()
    if os.path.exists(repos):
        repos_cfg.read(
            [
                repos + "/" + fname
                for fname in os.listdir(repos)
                if fname.endswith(".repo")
            ]
        )
    else:
        log.warning("Repositories not found in %s", repos)
    return repos_cfg
def _get_repo_info(alias, repos_cfg=None, root=None):
    try:
        meta = dict((repos_cfg or _get_configured_repos(root=root)).items(alias))
        meta["alias"] = alias
        for key, val in meta.items():
            if val in ["0", "1"]:
                meta[key] = int(meta[key]) == 1
            elif val == "NONE":
                meta[key] = None
        return meta
    except (ValueError, configparser.NoSectionError):
        return {}
def get_repo(repo, root=None, **kwargs):  # pylint: disable=unused-argument
    return _get_repo_info(repo, root=root)
def list_repos(root=None, **kwargs):
    repos_cfg = _get_configured_repos(root=root)
    all_repos = {}
    for alias in repos_cfg.sections():
        all_repos[alias] = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
    return all_repos
def del_repo(repo, root=None):
    repos_cfg = _get_configured_repos(root=root)
    for alias in repos_cfg.sections():
        if alias == repo:
            doc = __zypper__(root=root).xml.call(
                "rr", "--loose-auth", "--loose-query", alias
            )
            msg = doc.getElementsByTagName("message")
            if doc.getElementsByTagName("progress") and msg:
                return {
                    repo: True,
                    "message": msg[0].childNodes[0].nodeValue,
                }
    raise CommandExecutionError("Repository '{}' not found.".format(repo))
def mod_repo(repo, **kwargs):
    root = kwargs.get("root") or None
    repos_cfg = _get_configured_repos(root=root)
    added = False
    if repo not in repos_cfg.sections():
        url = kwargs.get("url", kwargs.get("mirrorlist", kwargs.get("baseurl")))
        if not url:
            raise CommandExecutionError(
                "Repository '{}' not found, and neither 'baseurl' nor "
                "'mirrorlist' was specified".format(repo)
            )
        if not urllib.parse.urlparse(url).scheme:
            raise CommandExecutionError(
                "Repository '{}' not found and URL for baseurl/mirrorlist "
                "is malformed".format(repo)
            )
        for alias in repos_cfg.sections():
            repo_meta = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
            new_url = urllib.parse.urlparse(url)
            if not new_url.path:
                new_url = urllib.parse.urlparse.ParseResult(
                    scheme=new_url.scheme,  # pylint: disable=E1123
                    netloc=new_url.netloc,
                    path="/",
                    params=new_url.params,
                    query=new_url.query,
                    fragment=new_url.fragment,
                )
            base_url = urllib.parse.urlparse(repo_meta["baseurl"])
            if new_url == base_url:
                raise CommandExecutionError(
                    "Repository '{}' already exists as '{}'.".format(repo, alias)
                )
        __zypper__(root=root).xml.call("ar", url, repo)
        repos_cfg = _get_configured_repos(root=root)
        if repo not in repos_cfg.sections():
            raise CommandExecutionError(
                "Failed add new repository '{}' for unspecified reason. "
                "Please check zypper logs.".format(repo)
            )
        added = True
    repo_info = _get_repo_info(repo, root=root)
    if (
        not added
        and "baseurl" in kwargs
        and not (kwargs["baseurl"] == repo_info["baseurl"])
    ):
        repo_info.update(kwargs)
        repo_info.setdefault("cache", False)
        del_repo(repo, root=root)
        return mod_repo(repo, root=root, **repo_info)
    cmd_opt = []
    global_cmd_opt = []
    call_refresh = False
    if "enabled" in kwargs:
        cmd_opt.append(kwargs["enabled"] and "--enable" or "--disable")
    if "refresh" in kwargs:
        cmd_opt.append(kwargs["refresh"] and "--refresh" or "--no-refresh")
    if "cache" in kwargs:
        cmd_opt.append(kwargs["cache"] and "--keep-packages" or "--no-keep-packages")
    if "gpgcheck" in kwargs:
        cmd_opt.append(kwargs["gpgcheck"] and "--gpgcheck" or "--no-gpgcheck")
    if "priority" in kwargs:
        cmd_opt.append("--priority={}".format(kwargs.get("priority", DEFAULT_PRIORITY)))
    if "humanname" in kwargs:
        cmd_opt.append("--name='{}'".format(kwargs.get("humanname")))
    if kwargs.get("gpgautoimport") is True:
        global_cmd_opt.append("--gpg-auto-import-keys")
        call_refresh = True
    if cmd_opt:
        cmd_opt = global_cmd_opt + ["mr"] + cmd_opt + [repo]
        __zypper__(root=root).refreshable.xml.call(*cmd_opt)
    comment = None
    if call_refresh:
        refresh_opts = global_cmd_opt + ["refresh"] + [repo]
        __zypper__(root=root).xml.call(*refresh_opts)
    elif not added and not cmd_opt:
        comment = "Specified arguments did not result in modification of repo"
    repo = get_repo(repo, root=root)
    if comment:
        repo["comment"] = comment
    return repo
def refresh_db(force=None, root=None):
    salt.utils.pkg.clear_rtag(__opts__)
    ret = {}
    refresh_opts = ["refresh"]
    if force is None:
        force = __pillar__.get("zypper", {}).get("refreshdb_force", True)
    if force:
        refresh_opts.append("--force")
    out = __zypper__(root=root).refreshable.call(*refresh_opts)
    for line in out.splitlines():
        if not line:
            continue
        if line.strip().startswith("Repository") and "'" in line:
            try:
                key = line.split("'")[1].strip()
                if "is up to date" in line:
                    ret[key] = False
            except IndexError:
                continue
        elif line.strip().startswith("Building") and "'" in line:
            key = line.split("'")[1].strip()
            if "done" in line:
                ret[key] = True
    return ret
def _find_types(pkgs):
    return sorted({pkg.split(":", 1)[0] for pkg in pkgs if len(pkg.split(":", 1)) == 2})
def install(
    name=None,
    refresh=False,
    fromrepo=None,
    pkgs=None,
    sources=None,
    downloadonly=None,
    skip_verify=False,
    version=None,
    ignore_repo_failure=False,
    no_recommends=False,
    root=None,
    **kwargs
):
    if refresh:
        refresh_db(root)
    try:
        pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
            name, pkgs, sources, **kwargs
        )
    except MinionError as exc:
        raise CommandExecutionError(exc)
    if pkg_params is None or len(pkg_params) == 0:
        return {}
    version_num = Wildcard(__zypper__(root=root))(name, version)
    if version_num:
        if pkgs is None and sources is None:
            pkg_params = {name: version_num}
        else:
            log.warning(
                '"version" parameter will be ignored for multiple package targets'
            )
    if pkg_type == "repository":
        targets = []
        for param, version_num in pkg_params.items():
            if version_num is None:
                log.debug("targeting package: %s", param)
                targets.append(param)
            else:
                prefix, verstr = salt.utils.pkg.split_comparison(version_num)
                if not prefix:
                    prefix = "="
                target = "{}{}{}".format(param, prefix, verstr)
                log.debug("targeting package: %s", target)
                targets.append(target)
    elif pkg_type == "advisory":
        targets = []
        cur_patches = list_patches(root=root)
        for advisory_id in pkg_params:
            if advisory_id not in cur_patches:
                raise CommandExecutionError(
                    'Advisory id "{}" not found'.format(advisory_id)
                )
            else:
                targets.append(advisory_id)
    else:
        targets = pkg_params
    diff_attr = kwargs.get("diff_attr")
    includes = _find_types(targets)
    old = (
        list_pkgs(attr=diff_attr, root=root, includes=includes)
        if not downloadonly
        else list_downloaded(root)
    )
    downgrades = []
    if fromrepo:
        fromrepoopt = ["--force", "--force-resolution", "--from", fromrepo]
        log.info("Targeting repo '%s'", fromrepo)
    else:
        fromrepoopt = ""
    cmd_install = ["install", "--auto-agree-with-licenses"]
    cmd_install.append(
        kwargs.get("resolve_capabilities") and "--capability" or "--name"
    )
    if not refresh:
        cmd_install.insert(0, "--no-refresh")
    if skip_verify:
        cmd_install.insert(0, "--no-gpg-checks")
    if downloadonly:
        cmd_install.append("--download-only")
    if fromrepo:
        cmd_install.extend(fromrepoopt)
    if no_recommends:
        cmd_install.append("--no-recommends")
    errors = []
    if pkg_type == "advisory":
        targets = ["patch:{}".format(t) for t in targets]
    systemd_scope = _systemd_scope()
    while targets:
        cmd = cmd_install + targets[:500]
        targets = targets[500:]
        for line in (
            __zypper__(
                no_repo_failure=ignore_repo_failure,
                systemd_scope=systemd_scope,
                root=root,
            )
            .call(*cmd)
            .splitlines()
        ):
            match = re.match(
                r"^The selected package '([^']+)'.+has lower version", line
            )
            if match:
                downgrades.append(match.group(1))
    while downgrades:
        cmd = cmd_install + ["--force"] + downgrades[:500]
        downgrades = downgrades[500:]
        __zypper__(no_repo_failure=ignore_repo_failure, root=root).call(*cmd)
    _clean_cache()
    new = (
        list_pkgs(attr=diff_attr, root=root, includes=includes)
        if not downloadonly
        else list_downloaded(root)
    )
    ret = salt.utils.data.compare_dicts(old, new)
    if includes:
        _clean_cache()
    if errors:
        raise CommandExecutionError(
            "Problem encountered {} package(s)".format(
                "downloading" if downloadonly else "installing"
            ),
            info={"errors": errors, "changes": ret},
        )
    return ret
def upgrade(
    refresh=True,
    dryrun=False,
    dist_upgrade=False,
    fromrepo=None,
    novendorchange=False,
    skip_verify=False,
    no_recommends=False,
    root=None,
    **kwargs
):  # pylint: disable=unused-argument
    cmd_update = (["dist-upgrade"] if dist_upgrade else ["update"]) + [
        "--auto-agree-with-licenses"
    ]
    if skip_verify:
        cmd_update.insert(0, "--no-gpg-checks")
    if refresh:
        refresh_db(root)
    if dryrun:
        cmd_update.append("--dry-run")
    if fromrepo:
        if isinstance(fromrepo, str):
            fromrepo = [fromrepo]
        for repo in fromrepo:
            cmd_update.extend(["--from" if dist_upgrade else "--repo", repo])
        log.info("Targeting repos: %s", fromrepo)
    if dist_upgrade:
        if novendorchange:
            if __grains__["osrelease_info"][0] &gt; 11:
                cmd_update.append("--no-allow-vendor-change")
                log.info("Disabling vendor changes")
            else:
                log.warning(
                    "Disabling vendor changes is not supported on this Zypper version"
                )
        if no_recommends:
            cmd_update.append("--no-recommends")
            log.info("Disabling recommendations")
        if dryrun:
            log.info("Executing debugsolver and performing a dry-run dist-upgrade")
            __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(
                *cmd_update + ["--debug-solver"]
            )
    old = list_pkgs(root=root)
    __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(*cmd_update)
    _clean_cache()
    new = list_pkgs(root=root)
    ret = salt.utils.data.compare_dicts(old, new)
    if __zypper__.exit_code not in __zypper__.SUCCESS_EXIT_CODES:
        result = {
            "retcode": __zypper__.exit_code,
            "stdout": __zypper__.stdout,
            "stderr": __zypper__.stderr,
            "pid": __zypper__.pid,
        }
        raise CommandExecutionError(
            "Problem encountered upgrading packages",
            info={"changes": ret, "result": result},
        )
    if dryrun:
        ret = (__zypper__.stdout + os.linesep + __zypper__.stderr).strip()
    return ret
def _uninstall(name=None, pkgs=None, root=None):
    try:
        pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
    except MinionError as exc:
        raise CommandExecutionError(exc)
    includes = _find_types(pkg_params.keys())
    old = list_pkgs(root=root, includes=includes)
    targets = []
    for target in pkg_params:
        if target in old and pkg_params[target] in old[target].split(","):
            targets.append(target + "-" + pkg_params[target])
        elif target in old and not pkg_params[target]:
            targets.append(target)
    if not targets:
        return {}
    systemd_scope = _systemd_scope()
    errors = []
    while targets:
        __zypper__(systemd_scope=systemd_scope, root=root).call(
            "remove", *targets[:500]
        )
        targets = targets[500:]
    _clean_cache()
    new = list_pkgs(root=root, includes=includes)
    ret = salt.utils.data.compare_dicts(old, new)
    if errors:
        raise CommandExecutionError(
            "Problem encountered removing package(s)",
            info={"errors": errors, "changes": ret},
        )
    return ret
def normalize_name(name):
    try:
        arch = name.rsplit(".", 1)[-1]
        if arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
            return name
    except ValueError:
        return name
    if arch in (__grains__["osarch"], "noarch") or salt.utils.pkg.rpm.check_32(
        arch, osarch=__grains__["osarch"]
    ):
        return name[: -(len(arch) + 1)]
    return name
def remove(
    name=None, pkgs=None, root=None, **kwargs
):  # pylint: disable=unused-argument
    return _uninstall(name=name, pkgs=pkgs, root=root)
def purge(name=None, pkgs=None, root=None, **kwargs):  # pylint: disable=unused-argument
    return _uninstall(name=name, pkgs=pkgs, root=root)
def list_locks(root=None):
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try:
        with salt.utils.files.fopen(_locks) as fhr:
            items = salt.utils.stringutils.to_unicode(fhr.read(</b></font>)).split("\n\n")
            for meta in [item.split("\n") for item in items]:
                lock = {}
                for element in [el for el in meta if el]:
                    if ":" in element:
                        lock.update(
                            dict([tuple(i.strip() for i in element.split(":", 1))])
                        )
                if lock.get("solvable_name"):
                    locks[lock.pop("solvable_name")] = lock
    except OSError:
        pass
    except Exception:  # pylint: disable=broad-except
        log.warning("Detected a problem when accessing %s", _locks)
    return locks
def clean_locks(root=None):
    LCK = "removed"
    out = {LCK: 0}
    locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
    if not os.path.exists(locks):
        return out
    for node in __zypper__(root=root).xml.call("cl").getElementsByTagName("message"):
        text = node.childNodes[0].nodeValue.lower()
        if text.startswith(LCK):
            out[LCK] = text.split(" ")[1]
            break
    return out
def unhold(name=None, pkgs=None, **kwargs):
    ret = {}
    if not name and not pkgs:
        raise CommandExecutionError("Name or packages must be specified.")
    targets = []
    if pkgs:
        for pkg in salt.utils.data.repack_dictlist(pkgs):
            targets.append(pkg)
    else:
        targets.append(name)
    locks = list_locks()
    removed = []
    missing = []
    for target in targets:
        ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
        if locks.get(target):
            removed.append(target)
            ret[target]["changes"]["new"] = ""
            ret[target]["changes"]["old"] = "hold"
            ret[target]["comment"] = "Package {} is no longer held.".format(target)
        else:
            missing.append(target)
            ret[target]["comment"] = "Package {} was already unheld.".format(target)
    if removed:
        __zypper__.call("rl", *removed)
    return ret
def hold(name=None, pkgs=None, **kwargs):
    ret = {}
    if not name and not pkgs:
        raise CommandExecutionError("Name or packages must be specified.")
    targets = []
    if pkgs:
        for pkg in salt.utils.data.repack_dictlist(pkgs):
            targets.append(pkg)
    else:
        targets.append(name)
    locks = list_locks()
    added = []
    for target in targets:
        ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
        if not locks.get(target):
            added.append(target)
            ret[target]["changes"]["new"] = "hold"
            ret[target]["changes"]["old"] = ""
            ret[target]["comment"] = "Package {} is now being held.".format(target)
        else:
            ret[target]["comment"] = "Package {} is already set to be held.".format(
                target
            )
    if added:
        __zypper__.call("al", *added)
    return ret
def verify(*names, **kwargs):
    return __salt__["lowpkg.verify"](*names, **kwargs)
def file_list(*packages, **kwargs):
    return __salt__["lowpkg.file_list"](*packages, **kwargs)
def file_dict(*packages, **kwargs):
    return __salt__["lowpkg.file_dict"](*packages, **kwargs)
def modified(*packages, **flags):
    return __salt__["lowpkg.modified"](*packages, **flags)
def owner(*paths, **kwargs):
    return __salt__["lowpkg.owner"](*paths, **kwargs)
def _get_visible_patterns(root=None):
    patterns = {}
    search_patterns = __zypper__(root=root).nolock.xml.call("se", "-t", "pattern")
    for element in search_patterns.getElementsByTagName("solvable"):
        installed = element.getAttribute("status") == "installed"
        patterns[element.getAttribute("name")] = {
            "installed": installed,
            "summary": element.getAttribute("summary"),
        }
    return patterns
def _get_installed_patterns(root=None):
    def _pattern_name(capability):
        return capability.split("=")[-1].strip()
    cmd = ["rpm"]
    if root:
        cmd.extend(["--root", root])
    cmd.extend(["-q", "--provides", "--whatprovides", "pattern()"])
    output = __salt__["cmd.run"](cmd, ignore_retcode=True)
    installed_patterns = {
        _pattern_name(line)
        for line in output.splitlines()
        if line.startswith("pattern() = ") and not _pattern_name(line).startswith(".")
    }
    patterns = {
        k: v for k, v in _get_visible_patterns(root=root).items() if v["installed"]
    }
    for pattern in installed_patterns:
        if pattern not in patterns:
            patterns[pattern] = {
                "installed": True,
                "summary": "Non-visible pattern",
            }
    return patterns
def list_patterns(refresh=False, root=None):
    if refresh:
        refresh_db(root)
    return _get_visible_patterns(root=root)
def list_installed_patterns(root=None):
    return _get_installed_patterns(root=root)
def search(criteria, refresh=False, **kwargs):
    ALLOWED_SEARCH_OPTIONS = {
        "provides": "--provides",
        "recommends": "--recommends",
        "requires": "--requires",
        "suggests": "--suggests",
        "conflicts": "--conflicts",
        "obsoletes": "--obsoletes",
        "file_list": "--file-list",
        "search_descriptions": "--search-descriptions",
        "case_sensitive": "--case-sensitive",
        "installed_only": "--installed-only",
        "not_installed_only": "-u",
        "details": "--details",
    }
    root = kwargs.get("root", None)
    if refresh:
        refresh_db(root)
    cmd = ["search"]
    if kwargs.get("match") == "exact":
        cmd.append("--match-exact")
    elif kwargs.get("match") == "words":
        cmd.append("--match-words")
    elif kwargs.get("match") == "substrings":
        cmd.append("--match-substrings")
    for opt in kwargs:
        if opt in ALLOWED_SEARCH_OPTIONS:
            cmd.append(ALLOWED_SEARCH_OPTIONS.get(opt))
    cmd.append(criteria)
    solvables = (
        __zypper__(root=root)
        .nolock.noraise.xml.call(*cmd)
        .getElementsByTagName("solvable")
    )
    if not solvables:
        raise CommandExecutionError("No packages found matching '{}'".format(criteria))
    out = {}
    for solvable in solvables:
        out[solvable.getAttribute("name")] = dict()
        for k, v in solvable.attributes.items():
            out[solvable.getAttribute("name")][k] = v
    return out
def _get_first_aggregate_text(node_list):
    if not node_list:
        return ""
    out = []
    for node in node_list[0].childNodes:
        if node.nodeType == dom.Document.TEXT_NODE:
            out.append(node.nodeValue)
    return "\n".join(out)
def list_products(all=False, refresh=False, root=None):
    if refresh:
        refresh_db(root)
    ret = list()
    OEM_PATH = "/var/lib/suseRegister/OEM"
    if root:
        OEM_PATH = os.path.join(root, os.path.relpath(OEM_PATH, os.path.sep))
    cmd = list()
    if not all:
        cmd.append("--disable-repositories")
    cmd.append("products")
    if not all:
        cmd.append("-i")
    product_list = (
        __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("product-list")
    )
    if not product_list:
        return ret  # No products found
    for prd in product_list[0].getElementsByTagName("product"):
        p_nfo = dict()
        for k_p_nfo, v_p_nfo in prd.attributes.items():
            if k_p_nfo in ["isbase", "installed"]:
                p_nfo[k_p_nfo] = bool(v_p_nfo in ["true", "1"])
            elif v_p_nfo:
                p_nfo[k_p_nfo] = v_p_nfo
        eol = prd.getElementsByTagName("endoflife")
        if eol:
            p_nfo["eol"] = eol[0].getAttribute("text")
            p_nfo["eol_t"] = int(eol[0].getAttribute("time_t") or 0)
        p_nfo["description"] = " ".join(
            [
                line.strip()
                for line in _get_first_aggregate_text(
                    prd.getElementsByTagName("description")
                ).split(os.linesep)
            ]
        )
        if "productline" in p_nfo and p_nfo["productline"]:
            oem_file = os.path.join(OEM_PATH, p_nfo["productline"])
            if os.path.isfile(oem_file):
                with salt.utils.files.fopen(oem_file, "r") as rfile:
                    oem_release = salt.utils.stringutils.to_unicode(
                        rfile.readline()
                    ).strip()
                    if oem_release:
                        p_nfo["release"] = oem_release
        ret.append(p_nfo)
    return ret
def download(*packages, **kwargs):
    if not packages:
        raise SaltInvocationError("No packages specified")
    root = kwargs.get("root", None)
    refresh = kwargs.get("refresh", False)
    if refresh:
        refresh_db(root)
    pkg_ret = {}
    for dld_result in (
        __zypper__(root=root)
        .xml.call("download", *packages)
        .getElementsByTagName("download-result")
    ):
        repo = dld_result.getElementsByTagName("repository")[0]
        path = dld_result.getElementsByTagName("localfile")[0].getAttribute("path")
        pkg_info = {
            "repository-name": repo.getAttribute("name"),
            "repository-alias": repo.getAttribute("alias"),
            "path": path,
        }
        key = _get_first_aggregate_text(dld_result.getElementsByTagName("name"))
        if __salt__["lowpkg.checksum"](pkg_info["path"], root=root):
            pkg_ret[key] = pkg_info
    if pkg_ret:
        failed = [pkg for pkg in packages if pkg not in pkg_ret]
        if failed:
            pkg_ret[
                "_error"
            ] = "The following package(s) failed to download: {}".format(
                ", ".join(failed)
            )
        return pkg_ret
    raise CommandExecutionError(
        "Unable to download packages: {}".format(", ".join(packages))
    )
def list_downloaded(root=None, **kwargs):
    CACHE_DIR = "/var/cache/zypp/packages/"
    if root:
        CACHE_DIR = os.path.join(root, os.path.relpath(CACHE_DIR, os.path.sep))
    ret = {}
    for root, dirnames, filenames in salt.utils.path.os_walk(CACHE_DIR):
        for filename in fnmatch.filter(filenames, "*.rpm"):
            package_path = os.path.join(root, filename)
            pkg_info = __salt__["lowpkg.bin_pkg_info"](package_path)
            pkg_timestamp = int(os.path.getctime(package_path))
            ret.setdefault(pkg_info["name"], {})[pkg_info["version"]] = {
                "path": package_path,
                "size": os.path.getsize(package_path),
                "creation_date_time_t": pkg_timestamp,
                "creation_date_time": datetime.datetime.utcfromtimestamp(
                    pkg_timestamp
                ).isoformat(),
            }
    return ret
def diff(*paths, **kwargs):
    ret = {}
    pkg_to_paths = {}
    for pth in paths:
        pth_pkg = __salt__["lowpkg.owner"](pth, **kwargs)
        if not pth_pkg:
            ret[pth] = os.path.exists(pth) and "Not managed" or "N/A"
        else:
            if pkg_to_paths.get(pth_pkg) is None:
                pkg_to_paths[pth_pkg] = []
            pkg_to_paths[pth_pkg].append(pth)
    if pkg_to_paths:
        local_pkgs = __salt__["pkg.download"](*pkg_to_paths.keys(), **kwargs)
        for pkg, files in pkg_to_paths.items():
            for path in files:
                ret[path] = (
                    __salt__["lowpkg.diff"](local_pkgs[pkg]["path"], path)
                    or "Unchanged"
                )
    return ret
def _get_patches(installed_only=False, root=None):
    patches = {}
    for element in (
        __zypper__(root=root)
        .nolock.xml.call("se", "-t", "patch")
        .getElementsByTagName("solvable")
    ):
        installed = element.getAttribute("status") == "installed"
        if (installed_only and installed) or not installed_only:
            patches[element.getAttribute("name")] = {
                "installed": installed,
                "summary": element.getAttribute("summary"),
            }
    return patches
def list_patches(refresh=False, root=None, **kwargs):
    if refresh:
        refresh_db(root)
    return _get_patches(root=root)
def list_installed_patches(root=None, **kwargs):
    return _get_patches(installed_only=True, root=root)
def list_provides(root=None, **kwargs):
    ret = __context__.get("pkg.list_provides")
    if not ret:
        cmd = ["rpm"]
        if root:
            cmd.extend(["--root", root])
        cmd.extend(["-qa", "--queryformat", "%{PROVIDES}_|-%{NAME}\n"])
        ret = dict()
        for line in __salt__["cmd.run"](
            cmd, output_loglevel="trace", python_shell=False
        ).splitlines():
            provide, realname = line.split("_|-")
            if provide == realname:
                continue
            if provide not in ret:
                ret[provide] = list()
            ret[provide].append(realname)
        __context__["pkg.list_provides"] = ret
    return ret
def resolve_capabilities(pkgs, refresh=False, root=None, **kwargs):
    if refresh:
        refresh_db(root)
    ret = list()
    for pkg in pkgs:
        if isinstance(pkg, dict):
            name = next(iter(pkg))
            version = pkg[name]
        else:
            name = pkg
            version = None
        if kwargs.get("resolve_capabilities", False):
            try:
                search(name, root=root, match="exact")
            except CommandExecutionError:
                try:
                    result = search(name, root=root, provides=True, match="exact")
                    if len(result) == 1:
                        name = next(iter(result.keys()))
                    elif len(result) &gt; 1:
                        log.warning("Found ambiguous match for capability '%s'.", pkg)
                except CommandExecutionError as exc:
                    log.debug("Search failed with: %s", exc)
        if version:
            ret.append({name: version})
        else:
            ret.append(name)
    return ret
def services_need_restart(root=None, **kwargs):
    cmd = ["ps", "-sss"]
    zypper_output = __zypper__(root=root).nolock.call(*cmd)
    services = zypper_output.split()
    return services
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
