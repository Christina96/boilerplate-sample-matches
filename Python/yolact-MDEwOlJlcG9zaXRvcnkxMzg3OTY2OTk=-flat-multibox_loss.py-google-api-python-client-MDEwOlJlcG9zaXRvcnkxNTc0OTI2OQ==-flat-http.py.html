
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.849604221635883%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-multibox_loss.py</h3>
            <pre><code>1  import torch
2  import torch.nn as nn
3  import torch.nn.functional as F
4  from torch.autograd import Variable
5  from ..box_utils import match, log_sum_exp, decode, center_size, crop, elemwise_mask_iou, elemwise_box_iou
6  from data import cfg, mask_type, activation_func
7  class MultiBoxLoss(nn.Module):
8      def __init__(self, num_classes, pos_threshold, neg_threshold, negpos_ratio):
9          super(MultiBoxLoss, self).__init__()
10          self.num_classes = num_classes
11          self.pos_threshold = pos_threshold
12          self.neg_threshold = neg_threshold
13          self.negpos_ratio = negpos_ratio
14          self.l1_expected_area = 20*20/70/70
15          self.l1_alpha = 0.1
16          if cfg.use_class_balanced_conf:
17              self.class_instances = None
18              self.total_instances = 0
19      def forward(self, net, predictions, targets, masks, num_crowds):
20          loc_data  = predictions['loc']
21          conf_data = predictions['conf']
22          mask_data = predictions['mask']
23          priors    = predictions['priors']
24          if cfg.mask_type == mask_type.lincomb:
25              proto_data = predictions['proto']
26          score_data = predictions['score'] if cfg.use_mask_scoring   else None   
27          inst_data  = predictions['inst']  if cfg.use_instance_coeff else None
28          labels = [None] * len(targets) # Used in sem segm loss
29          batch_size = loc_data.size(0)
30          num_priors = priors.size(0)
31          num_classes = self.num_classes
32          loc_t = loc_data.new(batch_size, num_priors, 4)
33          gt_box_t = loc_data.new(batch_size, num_priors, 4)
34          conf_t = loc_data.new(batch_size, num_priors).long()
35          idx_t = loc_data.new(batch_size, num_priors).long()
36          if cfg.use_class_existence_loss:
37              class_existence_t = loc_data.new(batch_size, num_classes-1)
38          for idx in range(batch_size):
39              truths      = targets[idx][:, :-1].data
40              labels[idx] = targets[idx][:, -1].data.long()
41              if cfg.use_class_existence_loss:
42                  class_existence_t[idx, :] = torch.eye(num_classes-1, device=conf_t.get_device())[labels[idx]].max(dim=0)[0]
43              cur_crowds = num_crowds[idx]
44              if cur_crowds > 0:
45                  split = lambda x: (x[-cur_crowds:], x[:-cur_crowds])
46                  crowd_boxes, truths = split(truths)
47                  _, labels[idx] = split(labels[idx])
48                  _, masks[idx]  = split(masks[idx])
49              else:
50                  crowd_boxes = None
51              match(self.pos_threshold, self.neg_threshold,
52                    truths, priors.data, labels[idx], crowd_boxes,
53                    loc_t, conf_t, idx_t, idx, loc_data[idx])
54              gt_box_t[idx, :, :] = truths[idx_t[idx]]
55          loc_t = Variable(loc_t, requires_grad=False)
56          conf_t = Variable(conf_t, requires_grad=False)
57          idx_t = Variable(idx_t, requires_grad=False)
58          pos = conf_t > 0
59          num_pos = pos.sum(dim=1, keepdim=True)
60          pos_idx = pos.unsqueeze(pos.dim()).expand_as(loc_data)
61          losses = {}
62          if cfg.train_boxes:
63              loc_p = loc_data[pos_idx].view(-1, 4)
64              loc_t = loc_t[pos_idx].view(-1, 4)
65              losses['B'] = F.smooth_l1_loss(loc_p, loc_t, reduction='sum') * cfg.bbox_alpha
66          if cfg.train_masks:
67              if cfg.mask_type == mask_type.direct:
68                  if cfg.use_gt_bboxes:
69                      pos_masks = []
70                      for idx in range(batch_size):
71                          pos_masks.append(masks[idx][idx_t[idx, pos[idx]]])
72                      masks_t = torch.cat(pos_masks, 0)
73                      masks_p = mask_data[pos, :].view(-1, cfg.mask_dim)
74                      losses['M'] = F.binary_cross_entropy(torch.clamp(masks_p, 0, 1), masks_t, reduction='sum') * cfg.mask_alpha
75                  else:
76                      losses['M'] = self.direct_mask_loss(pos_idx, idx_t, loc_data, mask_data, priors, masks)
77              elif cfg.mask_type == mask_type.lincomb:
78                  ret = self.lincomb_mask_loss(pos, idx_t, loc_data, mask_data, priors, proto_data, masks, gt_box_t, score_data, inst_data, labels)
79                  if cfg.use_maskiou:
80                      loss, maskiou_targets = ret
81                  else:
82                      loss = ret
83                  losses.update(loss)
84                  if cfg.mask_proto_loss is not None:
85                      if cfg.mask_proto_loss == 'l1':
86                          losses['P'] = torch.mean(torch.abs(proto_data)) / self.l1_expected_area * self.l1_alpha
87                      elif cfg.mask_proto_loss == 'disj':
88                          losses['P'] = -torch.mean(torch.max(F.log_softmax(proto_data, dim=-1), dim=-1)[0])
89          if cfg.use_focal_loss:
90              if cfg.use_sigmoid_focal_loss:
91                  losses['C'] = self.focal_conf_sigmoid_loss(conf_data, conf_t)
92              elif cfg.use_objectness_score:
93                  losses['C'] = self.focal_conf_objectness_loss(conf_data, conf_t)
94              else:
95                  losses['C'] = self.focal_conf_loss(conf_data, conf_t)
96          else:
97              if cfg.use_objectness_score:
98                  losses['C'] = self.conf_objectness_loss(conf_data, conf_t, batch_size, loc_p, loc_t, priors)
99              else:
100                  losses['C'] = self.ohem_conf_loss(conf_data, conf_t, pos, batch_size)
101          if cfg.use_maskiou and maskiou_targets is not None:
102              losses['I'] = self.mask_iou_loss(net, maskiou_targets)
103          if cfg.use_class_existence_loss:
104              losses['E'] = self.class_existence_loss(predictions['classes'], class_existence_t)
105          if cfg.use_semantic_segmentation_loss:
106              losses['S'] = self.semantic_segmentation_loss(predictions['segm'], masks, labels)
107          total_num_pos = num_pos.data.sum().float()
108          for k in losses:
109              if k not in ('P', 'E', 'S'):
110                  losses[k] /= total_num_pos
111              else:
112                  losses[k] /= batch_size
113          return losses
114      def class_existence_loss(self, class_data, class_existence_t):
115          return cfg.class_existence_alpha * F.binary_cross_entropy_with_logits(class_data, class_existence_t, reduction='sum')
116      def semantic_segmentation_loss(self, segment_data, mask_t, class_t, interpolation_mode='bilinear'):
117          batch_size, num_classes, mask_h, mask_w = segment_data.size()
118          loss_s = 0
119          for idx in range(batch_size):
120              cur_segment = segment_data[idx]
121              cur_class_t = class_t[idx]
122              with torch.no_grad():
123                  downsampled_masks = F.interpolate(mask_t[idx].unsqueeze(0), (mask_h, mask_w),
124                                                    mode=interpolation_mode, align_corners=False).squeeze(0)
125                  downsampled_masks = downsampled_masks.gt(0.5).float()
126                  segment_t = torch.zeros_like(cur_segment, requires_grad=False)
127                  for obj_idx in range(downsampled_masks.size(0)):
128                      segment_t[cur_class_t[obj_idx]] = torch.max(segment_t[cur_class_t[obj_idx]], downsampled_masks[obj_idx])
129              loss_s += F.binary_cross_entropy_with_logits(cur_segment, segment_t, reduction='sum')
130          return loss_s / mask_h / mask_w * cfg.semantic_segmentation_alpha
131      def ohem_conf_loss(self, conf_data, conf_t, pos, num):
132          batch_conf = conf_data.view(-1, self.num_classes)
133          if cfg.ohem_use_most_confident:
134              batch_conf = F.softmax(batch_conf, dim=1)
135              loss_c, _ = batch_conf[:, 1:].max(dim=1)
136          else:
137              loss_c = log_sum_exp(batch_conf) - batch_conf[:, 0]
138          loss_c = loss_c.view(num, -1)
139          loss_c[pos]        = 0 # filter out pos boxes
140          loss_c[conf_t < 0] = 0 # filter out neutrals (conf_t = -1)
141          _, loss_idx = loss_c.sort(1, descending=True)
142          _, idx_rank = loss_idx.sort(1)
143          num_pos = pos.long().sum(1, keepdim=True)
144          num_neg = torch.clamp(self.negpos_ratio*num_pos, max=pos.size(1)-1)
145          neg = idx_rank < num_neg.expand_as(idx_rank)
146          neg[pos]        = 0
147          neg[conf_t < 0] = 0 # Filter out neutrals
148          pos_idx = pos.unsqueeze(2).expand_as(conf_data)
149          neg_idx = neg.unsqueeze(2).expand_as(conf_data)
150          conf_p = conf_data[(pos_idx+neg_idx).gt(0)].view(-1, self.num_classes)
151          targets_weighted = conf_t[(pos+neg).gt(0)]
152          loss_c = F.cross_entropy(conf_p, targets_weighted, reduction='none')
153          if cfg.use_class_balanced_conf:
154              if self.class_instances is None:
155                  self.class_instances = torch.zeros(self.num_classes, device=targets_weighted.device)
156              classes, counts = targets_weighted.unique(return_counts=True)
157              for _cls, _cnt in zip(classes.cpu().numpy(), counts.cpu().numpy()):
158                  self.class_instances[_cls] += _cnt
159              self.total_instances += targets_weighted.size(0)
160              weighting = 1 - (self.class_instances[targets_weighted] / self.total_instances)
161              weighting = torch.clamp(weighting, min=1/self.num_classes)
162              avg_weight = (self.num_classes - 1) / self.num_classes
163              loss_c = (loss_c * weighting).sum() / avg_weight
164          else:
165              loss_c = loss_c.sum()
166          return cfg.conf_alpha * loss_c
167      def focal_conf_loss(self, conf_data, conf_t):
168          conf_t = conf_t.view(-1) # [batch_size*num_priors]
169          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
170          keep = (conf_t >= 0).float()
171          conf_t[conf_t < 0] = 0 # so that gather doesn't drum up a fuss
172          logpt = F.log_softmax(conf_data, dim=-1)
173          logpt = logpt.gather(1, conf_t.unsqueeze(-1))
174          logpt = logpt.view(-1)
175          pt    = logpt.exp()
176          background = (conf_t == 0).float()
177          at = (1 - cfg.focal_loss_alpha) * background + cfg.focal_loss_alpha * (1 - background)
178          loss = -at * (1 - pt) ** cfg.focal_loss_gamma * logpt
179          return cfg.conf_alpha * (loss * keep).sum()
180      def focal_conf_sigmoid_loss(self, conf_data, conf_t):
181          num_classes = conf_data.size(-1)
182          conf_t = conf_t.view(-1) # [batch_size*num_priors]
183          conf_data = conf_data.view(-1, num_classes) # [batch_size*num_priors, num_classes]
184          keep = (conf_t >= 0).float()
185          conf_t[conf_t < 0] = 0 # can't mask with -1, so filter that out
186          conf_one_t = torch.eye(num_classes, device=conf_t.get_device())[conf_t]
187          conf_pm_t  = conf_one_t * 2 - 1 # -1 if background, +1 if forground for specific class
188          logpt = F.logsigmoid(conf_data * conf_pm_t) # note: 1 - sigmoid(x) = sigmoid(-x)
189          pt    = logpt.exp()
190          at = cfg.focal_loss_alpha * conf_one_t + (1 - cfg.focal_loss_alpha) * (1 - conf_one_t)
191          at[..., 0] = 0 # Set alpha for the background class to 0 because sigmoid focal loss doesn't use it
192          loss = -at * (1 - pt) ** cfg.focal_loss_gamma * logpt
193          loss = keep * loss.sum(dim=-1)
194          return cfg.conf_alpha * loss.sum()
195      def focal_conf_objectness_loss(self, conf_data, conf_t):
196          conf_t = conf_t.view(-1) # [batch_size*num_priors]
197          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
198          keep = (conf_t >= 0).float()
199          conf_t[conf_t < 0] = 0 # so that gather doesn't drum up a fuss
200          background = (conf_t == 0).float()
201          at = (1 - cfg.focal_loss_alpha) * background + cfg.focal_loss_alpha * (1 - background)
202          logpt = F.logsigmoid(conf_data[:, 0]) * (1 - background) + F.logsigmoid(-conf_data[:, 0]) * background
203          pt    = logpt.exp()
204          obj_loss = -at * (1 - pt) ** cfg.focal_loss_gamma * logpt
205          pos_mask = conf_t > 0
206          conf_data_pos = (conf_data[:, 1:])[pos_mask] # Now this has just 80 classes
207          conf_t_pos    = conf_t[pos_mask] - 1         # So subtract 1 here
208          class_loss = F.cross_entropy(conf_data_pos, conf_t_pos, reduction='sum')
209          return cfg.conf_alpha * (class_loss + (obj_loss * keep).sum())
210      def conf_objectness_loss(self, conf_data, conf_t, batch_size, loc_p, loc_t, priors):
211          conf_t = conf_t.view(-1) # [batch_size*num_priors]
212          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
<span onclick='openModal()' class='match'>213          pos_mask = (conf_t > 0)
214          neg_mask = (conf_t == 0)
215          obj_data = conf_data[:, 0]
216          obj_data_pos = obj_data[pos_mask]
217          obj_data_neg = obj_data[neg_mask]
218          obj_neg_loss = - F.logsigmoid(-obj_data_neg).sum()
</span>219          with torch.no_grad():
220              pos_priors = priors.unsqueeze(0).expand(batch_size, -1, -1).reshape(-1, 4)[pos_mask, :]
221              boxes_pred = decode(loc_p, pos_priors, cfg.use_yolo_regressors)
222              boxes_targ = decode(loc_t, pos_priors, cfg.use_yolo_regressors)
223              iou_targets = elemwise_box_iou(boxes_pred, boxes_targ)
224          obj_pos_loss = - iou_targets * F.logsigmoid(obj_data_pos) - (1 - iou_targets) * F.logsigmoid(-obj_data_pos)
225          obj_pos_loss = obj_pos_loss.sum()
226          conf_data_pos = (conf_data[:, 1:])[pos_mask] # Now this has just 80 classes
227          conf_t_pos    = conf_t[pos_mask] - 1         # So subtract 1 here
228          class_loss = F.cross_entropy(conf_data_pos, conf_t_pos, reduction='sum')
229          return cfg.conf_alpha * (class_loss + obj_pos_loss + obj_neg_loss)
230      def direct_mask_loss(self, pos_idx, idx_t, loc_data, mask_data, priors, masks):
231          loss_m = 0
232          for idx in range(mask_data.size(0)):
233              with torch.no_grad():
234                  cur_pos_idx = pos_idx[idx, :, :]
235                  cur_pos_idx_squeezed = cur_pos_idx[:, 1]
236                  pos_bboxes = decode(loc_data[idx, :, :], priors.data, cfg.use_yolo_regressors)
237                  pos_bboxes = pos_bboxes[cur_pos_idx].view(-1, 4).clamp(0, 1)
238                  pos_lookup = idx_t[idx, cur_pos_idx_squeezed]
239                  cur_masks = masks[idx]
240                  pos_masks = cur_masks[pos_lookup, :, :]
241                  num_pos, img_height, img_width = pos_masks.size()
242                  x1, x2 = sanitize_coordinates(pos_bboxes[:, 0], pos_bboxes[:, 2], img_width)
243                  y1, y2 = sanitize_coordinates(pos_bboxes[:, 1], pos_bboxes[:, 3], img_height)
244                  scaled_masks = []
245                  for jdx in range(num_pos):
246                      tmp_mask = pos_masks[jdx, y1[jdx]:y2[jdx], x1[jdx]:x2[jdx]]
247                      while tmp_mask.dim() < 2:
248                          tmp_mask = tmp_mask.unsqueeze(0)
249                      new_mask = F.adaptive_avg_pool2d(tmp_mask.unsqueeze(0), cfg.mask_size)
250                      scaled_masks.append(new_mask.view(1, -1))
251                  mask_t = torch.cat(scaled_masks, 0).gt(0.5).float() # Threshold downsampled mask
252              pos_mask_data = mask_data[idx, cur_pos_idx_squeezed, :]
253              loss_m += F.binary_cross_entropy(torch.clamp(pos_mask_data, 0, 1), mask_t, reduction='sum') * cfg.mask_alpha
254          return loss_m
255      def coeff_diversity_loss(self, coeffs, instance_t):
256          num_pos = coeffs.size(0)
257          instance_t = instance_t.view(-1) # juuuust to make sure
258          coeffs_norm = F.normalize(coeffs, dim=1)
259          cos_sim = coeffs_norm @ coeffs_norm.t()
260          inst_eq = (instance_t[:, None].expand_as(cos_sim) == instance_t[None, :].expand_as(cos_sim)).float()
261          cos_sim = (cos_sim + 1) / 2
262          loss = (1 - cos_sim) * inst_eq + cos_sim * (1 - inst_eq)
263          return cfg.mask_proto_coeff_diversity_alpha * loss.sum() / num_pos
264      def lincomb_mask_loss(self, pos, idx_t, loc_data, mask_data, priors, proto_data, masks, gt_box_t, score_data, inst_data, labels, interpolation_mode='bilinear'):
265          mask_h = proto_data.size(1)
266          mask_w = proto_data.size(2)
267          process_gt_bboxes = cfg.mask_proto_normalize_emulate_roi_pooling or cfg.mask_proto_crop
268          if cfg.mask_proto_remove_empty_masks:
269              pos = pos.clone()
270          loss_m = 0
271          loss_d = 0 # Coefficient diversity loss
272          maskiou_t_list = []
273          maskiou_net_input_list = []
274          label_t_list = []
275          for idx in range(mask_data.size(0)):
276              with torch.no_grad():
277                  downsampled_masks = F.interpolate(masks[idx].unsqueeze(0), (mask_h, mask_w),
278                                                    mode=interpolation_mode, align_corners=False).squeeze(0)
279                  downsampled_masks = downsampled_masks.permute(1, 2, 0).contiguous()
280                  if cfg.mask_proto_binarize_downsampled_gt:
281                      downsampled_masks = downsampled_masks.gt(0.5).float()
282                  if cfg.mask_proto_remove_empty_masks:
283                      very_small_masks = (downsampled_masks.sum(dim=(0,1)) <= 0.0001)
284                      for i in range(very_small_masks.size(0)):
285                          if very_small_masks[i]:
286                              pos[idx, idx_t[idx] == i] = 0
287                  if cfg.mask_proto_reweight_mask_loss:
288                      if not cfg.mask_proto_binarize_downsampled_gt:
289                          bin_gt = downsampled_masks.gt(0.5).float()
290                      else:
291                          bin_gt = downsampled_masks
292                      gt_foreground_norm = bin_gt     / (torch.sum(bin_gt,   dim=(0,1), keepdim=True) + 0.0001)
293                      gt_background_norm = (1-bin_gt) / (torch.sum(1-bin_gt, dim=(0,1), keepdim=True) + 0.0001)
294                      mask_reweighting   = gt_foreground_norm * cfg.mask_proto_reweight_coeff + gt_background_norm
295                      mask_reweighting  *= mask_h * mask_w
296              cur_pos = pos[idx]
297              pos_idx_t = idx_t[idx, cur_pos]
298              if process_gt_bboxes:
299                  if cfg.mask_proto_crop_with_pred_box:
300                      pos_gt_box_t = decode(loc_data[idx, :, :], priors.data, cfg.use_yolo_regressors)[cur_pos]
301                  else:
302                      pos_gt_box_t = gt_box_t[idx, cur_pos]
303              if pos_idx_t.size(0) == 0:
304                  continue
305              proto_masks = proto_data[idx]
306              proto_coef  = mask_data[idx, cur_pos, :]
307              if cfg.use_mask_scoring:
308                  mask_scores = score_data[idx, cur_pos, :]
309              if cfg.mask_proto_coeff_diversity_loss:
310                  if inst_data is not None:
311                      div_coeffs = inst_data[idx, cur_pos, :]
312                  else:
313                      div_coeffs = proto_coef
314                  loss_d += self.coeff_diversity_loss(div_coeffs, pos_idx_t)
315              old_num_pos = proto_coef.size(0)
316              if old_num_pos > cfg.masks_to_train:
317                  perm = torch.randperm(proto_coef.size(0))
318                  select = perm[:cfg.masks_to_train]
319                  proto_coef = proto_coef[select, :]
320                  pos_idx_t  = pos_idx_t[select]
321                  if process_gt_bboxes:
322                      pos_gt_box_t = pos_gt_box_t[select, :]
323                  if cfg.use_mask_scoring:
324                      mask_scores = mask_scores[select, :]
325              num_pos = proto_coef.size(0)
326              mask_t = downsampled_masks[:, :, pos_idx_t]     
327              label_t = labels[idx][pos_idx_t]     
328              pred_masks = proto_masks @ proto_coef.t()
329              pred_masks = cfg.mask_proto_mask_activation(pred_masks)
330              if cfg.mask_proto_double_loss:
331                  if cfg.mask_proto_mask_activation == activation_func.sigmoid:
332                      pre_loss = F.binary_cross_entropy(torch.clamp(pred_masks, 0, 1), mask_t, reduction='sum')
333                  else:
334                      pre_loss = F.smooth_l1_loss(pred_masks, mask_t, reduction='sum')
335                  loss_m += cfg.mask_proto_double_loss_alpha * pre_loss
336              if cfg.mask_proto_crop:
337                  pred_masks = crop(pred_masks, pos_gt_box_t)
338              if cfg.mask_proto_mask_activation == activation_func.sigmoid:
339                  pre_loss = F.binary_cross_entropy(torch.clamp(pred_masks, 0, 1), mask_t, reduction='none')
340              else:
341                  pre_loss = F.smooth_l1_loss(pred_masks, mask_t, reduction='none')
342              if cfg.mask_proto_normalize_mask_loss_by_sqrt_area:
343                  gt_area  = torch.sum(mask_t, dim=(0, 1), keepdim=True)
344                  pre_loss = pre_loss / (torch.sqrt(gt_area) + 0.0001)
345              if cfg.mask_proto_reweight_mask_loss:
346                  pre_loss = pre_loss * mask_reweighting[:, :, pos_idx_t]
347              if cfg.mask_proto_normalize_emulate_roi_pooling:
348                  weight = mask_h * mask_w if cfg.mask_proto_crop else 1
349                  pos_gt_csize = center_size(pos_gt_box_t)
350                  gt_box_width  = pos_gt_csize[:, 2] * mask_w
351                  gt_box_height = pos_gt_csize[:, 3] * mask_h
352                  pre_loss = pre_loss.sum(dim=(0, 1)) / gt_box_width / gt_box_height * weight
353              if old_num_pos > num_pos:
354                  pre_loss *= old_num_pos / num_pos
355              loss_m += torch.sum(pre_loss)
356              if cfg.use_maskiou:
357                  if cfg.discard_mask_area > 0:
358                      gt_mask_area = torch.sum(mask_t, dim=(0, 1))
359                      select = gt_mask_area > cfg.discard_mask_area
360                      if torch.sum(select) < 1:
361                          continue
362                      pos_gt_box_t = pos_gt_box_t[select, :]
363                      pred_masks = pred_masks[:, :, select]
364                      mask_t = mask_t[:, :, select]
365                      label_t = label_t[select]
366                  maskiou_net_input = pred_masks.permute(2, 0, 1).contiguous().unsqueeze(1)
367                  pred_masks = pred_masks.gt(0.5).float()                
368                  maskiou_t = self._mask_iou(pred_masks, mask_t)
369                  maskiou_net_input_list.append(maskiou_net_input)
370                  maskiou_t_list.append(maskiou_t)
371                  label_t_list.append(label_t)
372          losses = {'M': loss_m * cfg.mask_alpha / mask_h / mask_w}
373          if cfg.mask_proto_coeff_diversity_loss:
374              losses['D'] = loss_d
375          if cfg.use_maskiou:
376              if len(maskiou_t_list) == 0:
377                  return losses, None
378              maskiou_t = torch.cat(maskiou_t_list)
379              label_t = torch.cat(label_t_list)
380              maskiou_net_input = torch.cat(maskiou_net_input_list)
381              num_samples = maskiou_t.size(0)
382              if cfg.maskious_to_train > 0 and num_samples > cfg.maskious_to_train:
383                  perm = torch.randperm(num_samples)
384                  select = perm[:cfg.masks_to_train]
385                  maskiou_t = maskiou_t[select]
386                  label_t = label_t[select]
387                  maskiou_net_input = maskiou_net_input[select]
388              return losses, [maskiou_net_input, maskiou_t, label_t]
389          return losses
390      def _mask_iou(self, mask1, mask2):
391          intersection = torch.sum(mask1*mask2, dim=(0, 1))
392          area1 = torch.sum(mask1, dim=(0, 1))
393          area2 = torch.sum(mask2, dim=(0, 1))
394          union = (area1 + area2) - intersection
395          ret = intersection / union
396          return ret
397      def mask_iou_loss(self, net, maskiou_targets):
398          maskiou_net_input, maskiou_t, label_t = maskiou_targets
399          maskiou_p = net.maskiou_net(maskiou_net_input)
400          label_t = label_t[:, None]
401          maskiou_p = torch.gather(maskiou_p, dim=1, index=label_t).view(-1)
402          loss_i = F.smooth_l1_loss(maskiou_p, maskiou_t, reduction='sum')
403          return loss_i * cfg.maskiou_alpha
</code></pre>
        </div>
        <div class="column">
            <h3>google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-http.py</h3>
            <pre><code>1  from __future__ import absolute_import
2  __author__ = "jcgregorio@google.com (Joe Gregorio)"
3  import copy
4  import http.client as http_client
5  import io
6  import json
7  import logging
8  import mimetypes
9  import os
10  import random
11  import socket
12  import time
13  import urllib
14  import uuid
15  import httplib2
16  try:
17      import ssl
18  except ImportError:
19      _ssl_SSLError = object()
20  else:
21      _ssl_SSLError = ssl.SSLError
22  from email.generator import Generator
23  from email.mime.multipart import MIMEMultipart
24  from email.mime.nonmultipart import MIMENonMultipart
25  from email.parser import FeedParser
26  from googleapiclient import _auth
27  from googleapiclient import _helpers as util
28  from googleapiclient.errors import (
29      BatchError,
30      HttpError,
31      InvalidChunkSizeError,
32      ResumableUploadError,
33      UnexpectedBodyError,
34      UnexpectedMethodError,
35  )
36  from googleapiclient.model import JsonModel
37  LOGGER = logging.getLogger(__name__)
38  DEFAULT_CHUNK_SIZE = 100 * 1024 * 1024
39  MAX_URI_LENGTH = 2048
40  MAX_BATCH_LIMIT = 1000
41  _TOO_MANY_REQUESTS = 429
42  DEFAULT_HTTP_TIMEOUT_SEC = 60
43  _LEGACY_BATCH_URI = "https://www.googleapis.com/batch"
44  def _should_retry_response(resp_status, content):
45      reason = None
46      if resp_status >= 500:
47          return True
48      if resp_status == _TOO_MANY_REQUESTS:
49          return True
50      if resp_status == http_client.FORBIDDEN:
51          if not content:
52              return False
53          try:
54              data = json.loads(content.decode("utf-8"))
55              if isinstance(data, dict):
56                  error_detail_keyword = next(
57                      (
58                          kw
59                          for kw in ["errors", "status", "message"]
60                          if kw in data["error"]
61                      ),
62                      "",
63                  )
64                  if error_detail_keyword:
65                      reason = data["error"][error_detail_keyword]
66                      if isinstance(reason, list) and len(reason) > 0:
67                          reason = reason[0]
68                          if "reason" in reason:
69                              reason = reason["reason"]
70              else:
71                  reason = data[0]["error"]["errors"]["reason"]
72          except (UnicodeDecodeError, ValueError, KeyError):
73              LOGGER.warning("Invalid JSON content from response: %s", content)
74              return False
75          LOGGER.warning('Encountered 403 Forbidden with reason "%s"', reason)
76          if reason in ("userRateLimitExceeded", "rateLimitExceeded"):
77              return True
78      return False
79  def _retry_request(
80      http, num_retries, req_type, sleep, rand, uri, method, *args, **kwargs
81  ):
82      resp = None
83      content = None
84      exception = None
85      for retry_num in range(num_retries + 1):
86          if retry_num > 0:
87              sleep_time = rand() * 2**retry_num
88              LOGGER.warning(
89                  "Sleeping %.2f seconds before retry %d of %d for %s: %s %s, after %s",
90                  sleep_time,
91                  retry_num,
92                  num_retries,
93                  req_type,
94                  method,
95                  uri,
96                  resp.status if resp else exception,
97              )
98              sleep(sleep_time)
99          try:
100              exception = None
101              resp, content = http.request(uri, method, *args, **kwargs)
102          except _ssl_SSLError as ssl_error:
103              exception = ssl_error
104          except socket.timeout as socket_timeout:
105              exception = socket_timeout
106          except ConnectionError as connection_error:
107              exception = connection_error
108          except OSError as socket_error:
109              if socket.errno.errorcode.get(socket_error.errno) not in {
110                  "WSAETIMEDOUT",
111                  "ETIMEDOUT",
112                  "EPIPE",
113                  "ECONNABORTED",
114                  "ECONNREFUSED",
115                  "ECONNRESET",
116              }:
117                  raise
118              exception = socket_error
119          except httplib2.ServerNotFoundError as server_not_found_error:
120              exception = server_not_found_error
121          if exception:
122              if retry_num == num_retries:
123                  raise exception
124              else:
125                  continue
126          if not _should_retry_response(resp.status, content):
127              break
128      return resp, content
129  class MediaUploadProgress(object):
130      def __init__(self, resumable_progress, total_size):
131          self.resumable_progress = resumable_progress
132          self.total_size = total_size
133      def progress(self):
134          if self.total_size is not None and self.total_size != 0:
135              return float(self.resumable_progress) / float(self.total_size)
136          else:
137              return 0.0
138  class MediaDownloadProgress(object):
139      def __init__(self, resumable_progress, total_size):
140          self.resumable_progress = resumable_progress
141          self.total_size = total_size
142      def progress(self):
143          if self.total_size is not None and self.total_size != 0:
144              return float(self.resumable_progress) / float(self.total_size)
145          else:
146              return 0.0
147  class MediaUpload(object):
148      def chunksize(self):
149          raise NotImplementedError()
150      def mimetype(self):
151          return "application/octet-stream"
152      def size(self):
153          return None
154      def resumable(self):
155          return False
156      def getbytes(self, begin, end):
157          raise NotImplementedError()
158      def has_stream(self):
159          return False
160      def stream(self):
161          raise NotImplementedError()
162      @util.positional(1)
163      def _to_json(self, strip=None):
164          t = type(self)
165          d = copy.copy(self.__dict__)
166          if strip is not None:
167              for member in strip:
168                  del d[member]
169          d["_class"] = t.__name__
170          d["_module"] = t.__module__
171          return json.dumps(d)
172      def to_json(self):
173          return self._to_json()
174      @classmethod
175      def new_from_json(cls, s):
176          data = json.loads(s)
177          module = data["_module"]
178          m = __import__(module, fromlist=module.split(".")[:-1])
179          kls = getattr(m, data["_class"])
180          from_json = getattr(kls, "from_json")
181          return from_json(s)
182  class MediaIoBaseUpload(MediaUpload):
183      @util.positional(3)
184      def __init__(self, fd, mimetype, chunksize=DEFAULT_CHUNK_SIZE, resumable=False):
185          super(MediaIoBaseUpload, self).__init__()
186          self._fd = fd
187          self._mimetype = mimetype
188          if not (chunksize == -1 or chunksize > 0):
189              raise InvalidChunkSizeError()
190          self._chunksize = chunksize
191          self._resumable = resumable
192          self._fd.seek(0, os.SEEK_END)
193          self._size = self._fd.tell()
194      def chunksize(self):
195          return self._chunksize
196      def mimetype(self):
197          return self._mimetype
198      def size(self):
199          return self._size
200      def resumable(self):
201          return self._resumable
202      def getbytes(self, begin, length):
203          self._fd.seek(begin)
204          return self._fd.read(length)
205      def has_stream(self):
206          return True
207      def stream(self):
208          return self._fd
209      def to_json(self):
210          raise NotImplementedError("MediaIoBaseUpload is not serializable.")
211  class MediaFileUpload(MediaIoBaseUpload):
212      @util.positional(2)
213      def __init__(
214          self, filename, mimetype=None, chunksize=DEFAULT_CHUNK_SIZE, resumable=False
215      ):
216          self._fd = None
217          self._filename = filename
218          self._fd = open(self._filename, "rb")
219          if mimetype is None:
220              mimetype, _ = mimetypes.guess_type(filename)
221              if mimetype is None:
222                  mimetype = "application/octet-stream"
223          super(MediaFileUpload, self).__init__(
224              self._fd, mimetype, chunksize=chunksize, resumable=resumable
225          )
226      def __del__(self):
227          if self._fd:
228              self._fd.close()
229      def to_json(self):
230          return self._to_json(strip=["_fd"])
231      @staticmethod
232      def from_json(s):
233          d = json.loads(s)
234          return MediaFileUpload(
235              d["_filename"],
236              mimetype=d["_mimetype"],
237              chunksize=d["_chunksize"],
238              resumable=d["_resumable"],
239          )
240  class MediaInMemoryUpload(MediaIoBaseUpload):
241      @util.positional(2)
242      def __init__(
243          self,
244          body,
245          mimetype="application/octet-stream",
246          chunksize=DEFAULT_CHUNK_SIZE,
247          resumable=False,
248      ):
249          fd = io.BytesIO(body)
250          super(MediaInMemoryUpload, self).__init__(
251              fd, mimetype, chunksize=chunksize, resumable=resumable
252          )
253  class MediaIoBaseDownload(object):
254      @util.positional(3)
255      def __init__(self, fd, request, chunksize=DEFAULT_CHUNK_SIZE):
256          self._fd = fd
257          self._request = request
258          self._uri = request.uri
259          self._chunksize = chunksize
260          self._progress = 0
261          self._total_size = None
262          self._done = False
263          self._sleep = time.sleep
264          self._rand = random.random
265          self._headers = {}
266          for k, v in request.headers.items():
267              if not k.lower() in ("accept", "accept-encoding", "user-agent"):
268                  self._headers[k] = v
269      @util.positional(1)
270      def next_chunk(self, num_retries=0):
271          headers = self._headers.copy()
272          headers["range"] = "bytes=%d-%d" % (
273              self._progress,
274              self._progress + self._chunksize - 1,
275          )
276          http = self._request.http
277          resp, content = _retry_request(
278              http,
279              num_retries,
280              "media download",
281              self._sleep,
282              self._rand,
283              self._uri,
284              "GET",
285              headers=headers,
286          )
287          if resp.status in [200, 206]:
288              if "content-location" in resp and resp["content-location"] != self._uri:
289                  self._uri = resp["content-location"]
290              self._progress += len(content)
291              self._fd.write(content)
292              if "content-range" in resp:
293                  content_range = resp["content-range"]
294                  length = content_range.rsplit("/", 1)[1]
295                  self._total_size = int(length)
296              elif "content-length" in resp:
297                  self._total_size = int(resp["content-length"])
298              if self._total_size is None or self._progress == self._total_size:
299                  self._done = True
300              return MediaDownloadProgress(self._progress, self._total_size), self._done
301          elif resp.status == 416:
302              content_range = resp["content-range"]
303              length = content_range.rsplit("/", 1)[1]
304              self._total_size = int(length)
305              if self._total_size == 0:
306                  self._done = True
307                  return (
308                      MediaDownloadProgress(self._progress, self._total_size),
309                      self._done,
310                  )
311          raise HttpError(resp, content, uri=self._uri)
312  class _StreamSlice(object):
313      def __init__(self, stream, begin, chunksize):
314          self._stream = stream
315          self._begin = begin
316          self._chunksize = chunksize
317          self._stream.seek(begin)
318      def read(self, n=-1):
319          cur = self._stream.tell()
320          end = self._begin + self._chunksize
321          if n == -1 or cur + n > end:
322              n = end - cur
323          return self._stream.read(n)
324  class HttpRequest(object):
325      @util.positional(4)
326      def __init__(
327          self,
328          http,
329          postproc,
330          uri,
331          method="GET",
332          body=None,
333          headers=None,
334          methodId=None,
335          resumable=None,
336      ):
337          self.uri = uri
338          self.method = method
339          self.body = body
340          self.headers = headers or {}
341          self.methodId = methodId
342          self.http = http
343          self.postproc = postproc
344          self.resumable = resumable
345          self.response_callbacks = []
346          self._in_error_state = False
347          self.body_size = len(self.body or "")
348          self.resumable_uri = None
349          self.resumable_progress = 0
350          self._rand = random.random
351          self._sleep = time.sleep
352      @util.positional(1)
353      def execute(self, http=None, num_retries=0):
354          if http is None:
355              http = self.http
356          if self.resumable:
357              body = None
358              while body is None:
359                  _, body = self.next_chunk(http=http, num_retries=num_retries)
360              return body
361          if "content-length" not in self.headers:
362              self.headers["content-length"] = str(self.body_size)
363          if len(self.uri) > MAX_URI_LENGTH and self.method == "GET":
364              self.method = "POST"
365              self.headers["x-http-method-override"] = "GET"
366              self.headers["content-type"] = "application/x-www-form-urlencoded"
367              parsed = urllib.parse.urlparse(self.uri)
368              self.uri = urllib.parse.urlunparse(
369                  (parsed.scheme, parsed.netloc, parsed.path, parsed.params, None, None)
370              )
371              self.body = parsed.query
372              self.headers["content-length"] = str(len(self.body))
373          resp, content = _retry_request(
374              http,
375              num_retries,
376              "request",
377              self._sleep,
378              self._rand,
379              str(self.uri),
380              method=str(self.method),
381              body=self.body,
382              headers=self.headers,
383          )
384          for callback in self.response_callbacks:
385              callback(resp)
386          if resp.status >= 300:
387              raise HttpError(resp, content, uri=self.uri)
388          return self.postproc(resp, content)
389      @util.positional(2)
390      def add_response_callback(self, cb):
391          self.response_callbacks.append(cb)
392      @util.positional(1)
393      def next_chunk(self, http=None, num_retries=0):
394          if http is None:
395              http = self.http
396          if self.resumable.size() is None:
397              size = "*"
398          else:
399              size = str(self.resumable.size())
400          if self.resumable_uri is None:
401              start_headers = copy.copy(self.headers)
402              start_headers["X-Upload-Content-Type"] = self.resumable.mimetype()
403              if size != "*":
404                  start_headers["X-Upload-Content-Length"] = size
405              start_headers["content-length"] = str(self.body_size)
406              resp, content = _retry_request(
407                  http,
408                  num_retries,
409                  "resumable URI request",
410                  self._sleep,
411                  self._rand,
412                  self.uri,
413                  method=self.method,
414                  body=self.body,
415                  headers=start_headers,
416              )
417              if resp.status == 200 and "location" in resp:
418                  self.resumable_uri = resp["location"]
419              else:
420                  raise ResumableUploadError(resp, content)
421          elif self._in_error_state:
422              resp, content = http.request(self.resumable_uri, "PUT", headers=headers)
423              status, body = self._process_response(resp, content)
424              if body:
425                  return (status, body)
426          if self.resumable.has_stream():
427              data = self.resumable.stream()
428              if self.resumable.chunksize() == -1:
429                  data.seek(self.resumable_progress)
430                  chunk_end = self.resumable.size() - self.resumable_progress - 1
431              else:
432                  data = _StreamSlice(
433                      data, self.resumable_progress, self.resumable.chunksize()
434                  )
435                  chunk_end = min(
436                      self.resumable_progress + self.resumable.chunksize() - 1,
437                      self.resumable.size() - 1,
438                  )
439          else:
440              data = self.resumable.getbytes(
441                  self.resumable_progress, self.resumable.chunksize()
442              )
443              if len(data) < self.resumable.chunksize():
444                  size = str(self.resumable_progress + len(data))
445              chunk_end = self.resumable_progress + len(data) - 1
446          headers = {
447              "Content-Length": str(chunk_end - self.resumable_progress + 1),
448          }
449          if chunk_end != -1:
450              headers["Content-Range"] = "bytes %d-%d/%s" % (
451                  self.resumable_progress,
452                  chunk_end,
453                  size,
454              )
455          for retry_num in range(num_retries + 1):
456              if retry_num > 0:
457                  self._sleep(self._rand() * 2**retry_num)
458                  LOGGER.warning(
459                      "Retry #%d for media upload: %s %s, following status: %d"
460                      % (retry_num, self.method, self.uri, resp.status)
461                  )
462              try:
463                  resp, content = http.request(
464                      self.resumable_uri, method="PUT", body=data, headers=headers
465                  )
466              except:
467                  self._in_error_state = True
468                  raise
469              if not _should_retry_response(resp.status, content):
470                  break
471          return self._process_response(resp, content)
472      def _process_response(self, resp, content):
473          if resp.status in [200, 201]:
474              self._in_error_state = False
475              return None, self.postproc(resp, content)
476          elif resp.status == 308:
477              self._in_error_state = False
478              try:
479                  self.resumable_progress = int(resp["range"].split("-")[1]) + 1
480              except KeyError:
481                  self.resumable_progress = 0
482              if "location" in resp:
483                  self.resumable_uri = resp["location"]
484          else:
485              self._in_error_state = True
486              raise HttpError(resp, content, uri=self.uri)
487          return (
488              MediaUploadProgress(self.resumable_progress, self.resumable.size()),
489              None,
490          )
491      def to_json(self):
492          d = copy.copy(self.__dict__)
493          if d["resumable"] is not None:
494              d["resumable"] = self.resumable.to_json()
495          del d["http"]
496          del d["postproc"]
497          del d["_sleep"]
498          del d["_rand"]
499          return json.dumps(d)
500      @staticmethod
501      def from_json(s, http, postproc):
502          d = json.loads(s)
503          if d["resumable"] is not None:
504              d["resumable"] = MediaUpload.new_from_json(d["resumable"])
505          return HttpRequest(
506              http,
507              postproc,
508              uri=d["uri"],
509              method=d["method"],
510              body=d["body"],
511              headers=d["headers"],
512              methodId=d["methodId"],
513              resumable=d["resumable"],
514          )
515      @staticmethod
516      def null_postproc(resp, contents):
517          return resp, contents
518  class BatchHttpRequest(object):
519      @util.positional(1)
520      def __init__(self, callback=None, batch_uri=None):
521          if batch_uri is None:
522              batch_uri = _LEGACY_BATCH_URI
523          if batch_uri == _LEGACY_BATCH_URI:
524              LOGGER.warning(
525                  "You have constructed a BatchHttpRequest using the legacy batch "
526                  "endpoint %s. This endpoint will be turned down on August 12, 2020. "
527                  "Please provide the API-specific endpoint or use "
528                  "service.new_batch_http_request(). For more details see "
529                  "https://developers.googleblog.com/2018/03/discontinuing-support-for-json-rpc-and.html"
530                  "and https://developers.google.com/api-client-library/python/guide/batch.",
531                  _LEGACY_BATCH_URI,
532              )
533          self._batch_uri = batch_uri
534          self._callback = callback
535          self._requests = {}
536          self._callbacks = {}
537          self._order = []
538          self._last_auto_id = 0
539          self._base_id = None
540          self._responses = {}
541          self._refreshed_credentials = {}
542      def _refresh_and_apply_credentials(self, request, http):
543          creds = None
544          request_credentials = False
545          if request.http is not None:
546              creds = _auth.get_credentials_from_http(request.http)
547              request_credentials = True
548          if creds is None and http is not None:
549              creds = _auth.get_credentials_from_http(http)
550          if creds is not None:
551              if id(creds) not in self._refreshed_credentials:
552                  _auth.refresh_credentials(creds)
553                  self._refreshed_credentials[id(creds)] = 1
554          if request.http is None or not request_credentials:
555              _auth.apply_credentials(creds, request.headers)
556      def _id_to_header(self, id_):
557          if self._base_id is None:
558              self._base_id = uuid.uuid4()
559          return "<%s + %s>" % (self._base_id, urllib.parse.quote(id_))
560      def _header_to_id(self, header):
561          if header[0] != "<" or header[-1] != ">":
562              raise BatchError("Invalid value for Content-ID: %s" % header)
563          if "+" not in header:
564              raise BatchError("Invalid value for Content-ID: %s" % header)
565          base, id_ = header[1:-1].split(" + ", 1)
566          return urllib.parse.unquote(id_)
567      def _serialize_request(self, request):
568          parsed = urllib.parse.urlparse(request.uri)
569          request_line = urllib.parse.urlunparse(
570              ("", "", parsed.path, parsed.params, parsed.query, "")
571          )
572          status_line = request.method + " " + request_line + " HTTP/1.1\n"
573          major, minor = request.headers.get("content-type", "application/json").split(
574              "/"
575          )
576          msg = MIMENonMultipart(major, minor)
577          headers = request.headers.copy()
578          if request.http is not None:
579              credentials = _auth.get_credentials_from_http(request.http)
580              if credentials is not None:
581                  _auth.apply_credentials(credentials, headers)
582          if "content-type" in headers:
583              del headers["content-type"]
584          for key, value in headers.items():
585              msg[key] = value
586          msg["Host"] = parsed.netloc
587          msg.set_unixfrom(None)
588          if request.body is not None:
589              msg.set_payload(request.body)
590              msg["content-length"] = str(len(request.body))
591          fp = io.StringIO()
592          g = Generator(fp, maxheaderlen=0)
593          g.flatten(msg, unixfrom=False)
594          body = fp.getvalue()
595          return status_line + body
596      def _deserialize_response(self, payload):
597          status_line, payload = payload.split("\n", 1)
598          protocol, status, reason = status_line.split(" ", 2)
599          parser = FeedParser()
600          parser.feed(payload)
601          msg = parser.close()
602          msg["status"] = status
603          resp = httplib2.Response(msg)
604          resp.reason = reason
605          resp.version = int(protocol.split("/", 1)[1].replace(".", ""))
606          content = payload.split("\r\n\r\n", 1)[1]
607          return resp, content
608      def _new_id(self):
609          self._last_auto_id += 1
610          while str(self._last_auto_id) in self._requests:
611              self._last_auto_id += 1
612          return str(self._last_auto_id)
613      @util.positional(2)
614      def add(self, request, callback=None, request_id=None):
615          if len(self._order) >= MAX_BATCH_LIMIT:
616              raise BatchError(
617                  "Exceeded the maximum calls(%d) in a single batch request."
618                  % MAX_BATCH_LIMIT
619              )
620          if request_id is None:
621              request_id = self._new_id()
622          if request.resumable is not None:
623              raise BatchError("Media requests cannot be used in a batch request.")
624          if request_id in self._requests:
625              raise KeyError("A request with this ID already exists: %s" % request_id)
626          self._requests[request_id] = request
627          self._callbacks[request_id] = callback
628          self._order.append(request_id)
629      def _execute(self, http, order, requests):
630          message = MIMEMultipart("mixed")
631          setattr(message, "_write_headers", lambda self: None)
632          for request_id in order:
633              request = requests[request_id]
634              msg = MIMENonMultipart("application", "http")
635              msg["Content-Transfer-Encoding"] = "binary"
636              msg["Content-ID"] = self._id_to_header(request_id)
637              body = self._serialize_request(request)
638              msg.set_payload(body)
639              message.attach(msg)
640          fp = io.StringIO()
641          g = Generator(fp, mangle_from_=False)
642          g.flatten(message, unixfrom=False)
643          body = fp.getvalue()
644          headers = {}
645          headers["content-type"] = (
646              "multipart/mixed; " 'boundary="%s"'
647          ) % message.get_boundary()
648          resp, content = http.request(
649              self._batch_uri, method="POST", body=body, headers=headers
650          )
651          if resp.status >= 300:
652              raise HttpError(resp, content, uri=self._batch_uri)
653          header = "content-type: %s\r\n\r\n" % resp["content-type"]
654          content = content.decode("utf-8")
655          for_parser = header + content
656          parser = FeedParser()
657          parser.feed(for_parser)
658          mime_response = parser.close()
659          if not mime_response.is_multipart():
660              raise BatchError(
661                  "Response not in multipart/mixed format.", resp=resp, content=content
662              )
663          for part in mime_response.get_payload():
664              request_id = self._header_to_id(part["Content-ID"])
665              response, content = self._deserialize_response(part.get_payload())
666              if isinstance(content, str):
667                  content = content.encode("utf-8")
668              self._responses[request_id] = (response, content)
669      @util.positional(1)
670      def execute(self, http=None):
671          if len(self._order) == 0:
672              return None
673          if http is None:
674              for request_id in self._order:
675                  request = self._requests[request_id]
676                  if request is not None:
677                      http = request.http
678                      break
679          if http is None:
680              raise ValueError("Missing a valid http object.")
681          creds = _auth.get_credentials_from_http(http)
682          if creds is not None:
683              if not _auth.is_valid(creds):
684                  LOGGER.info("Attempting refresh to obtain initial access_token")
685                  _auth.refresh_credentials(creds)
686          self._execute(http, self._order, self._requests)
687          redo_requests = {}
688          redo_order = []
689          for request_id in self._order:
690              resp, content = self._responses[request_id]
691              if resp["status"] == "401":
692                  redo_order.append(request_id)
693                  request = self._requests[request_id]
694                  self._refresh_and_apply_credentials(request, http)
695                  redo_requests[request_id] = request
696          if redo_requests:
697              self._execute(http, redo_order, redo_requests)
698          for request_id in self._order:
699              resp, content = self._responses[request_id]
700              request = self._requests[request_id]
701              callback = self._callbacks[request_id]
702              response = None
703              exception = None
704              try:
705                  if resp.status >= 300:
706                      raise HttpError(resp, content, uri=request.uri)
707                  response = request.postproc(resp, content)
708              except HttpError as e:
709                  exception = e
710              if callback is not None:
711                  callback(request_id, response, exception)
712              if self._callback is not None:
713                  self._callback(request_id, response, exception)
714  class HttpRequestMock(object):
715      def __init__(self, resp, content, postproc):
716          self.resp = resp
717          self.content = content
718          self.postproc = postproc
719          if resp is None:
720              self.resp = httplib2.Response({"status": 200, "reason": "OK"})
721          if "reason" in self.resp:
722              self.resp.reason = self.resp["reason"]
723      def execute(self, http=None):
724          return self.postproc(self.resp, self.content)
725  class RequestMockBuilder(object):
726      def __init__(self, responses, check_unexpected=False):
727          self.responses = responses
728          self.check_unexpected = check_unexpected
729      def __call__(
730          self,
731          http,
732          postproc,
733          uri,
734          method="GET",
735          body=None,
736          headers=None,
737          methodId=None,
738          resumable=None,
739      ):
740          if methodId in self.responses:
741              response = self.responses[methodId]
742              resp, content = response[:2]
743              if len(response) > 2:
744                  expected_body = response[2]
745                  if bool(expected_body) != bool(body):
746                      raise UnexpectedBodyError(expected_body, body)
747                  if isinstance(expected_body, str):
748                      expected_body = json.loads(expected_body)
749                  body = json.loads(body)
750                  if body != expected_body:
751                      raise UnexpectedBodyError(expected_body, body)
752              return HttpRequestMock(resp, content, postproc)
753          elif self.check_unexpected:
754              raise UnexpectedMethodError(methodId=methodId)
755          else:
756              model = JsonModel(False)
757              return HttpRequestMock(None, "{}", model.response)
758  class HttpMock(object):
759      def __init__(self, filename=None, headers=None):
760          if headers is None:
761              headers = {"status": "200"}
762          if filename:
763              with open(filename, "rb") as f:
764                  self.data = f.read()
765          else:
766              self.data = None
767          self.response_headers = headers
768          self.headers = None
769          self.uri = None
770          self.method = None
771          self.body = None
772          self.headers = None
773      def request(
774          self,
775          uri,
776          method="GET",
777          body=None,
<span onclick='openModal()' class='match'>778          headers=None,
779          redirections=1,
780          connection_type=None,
781      ):
782          self.uri = uri
783          self.method = method
784          self.body = body
785          self.headers = headers
</span>786          return httplib2.Response(self.response_headers), self.data
787      def close(self):
788          return None
789  class HttpMockSequence(object):
790      def __init__(self, iterable):
791          self._iterable = iterable
792          self.follow_redirects = True
793          self.request_sequence = list()
794      def request(
795          self,
796          uri,
797          method="GET",
798          body=None,
799          headers=None,
800          redirections=1,
801          connection_type=None,
802      ):
803          self.request_sequence.append((uri, method, body, headers))
804          resp, content = self._iterable.pop(0)
805          if isinstance(content, str):
806              content = content.encode("utf-8")
807          if content == b"echo_request_headers":
808              content = headers
809          elif content == b"echo_request_headers_as_json":
810              content = json.dumps(headers)
811          elif content == b"echo_request_body":
812              if hasattr(body, "read"):
813                  content = body.read()
814              else:
815                  content = body
816          elif content == b"echo_request_uri":
817              content = uri
818          if isinstance(content, str):
819              content = content.encode("utf-8")
820          return httplib2.Response(resp), content
821  def set_user_agent(http, user_agent):
822      request_orig = http.request
823      def new_request(
824          uri,
825          method="GET",
826          body=None,
827          headers=None,
828          redirections=httplib2.DEFAULT_MAX_REDIRECTS,
829          connection_type=None,
830      ):
831          if headers is None:
832              headers = {}
833          if "user-agent" in headers:
834              headers["user-agent"] = user_agent + " " + headers["user-agent"]
835          else:
836              headers["user-agent"] = user_agent
837          resp, content = request_orig(
838              uri,
839              method=method,
840              body=body,
841              headers=headers,
842              redirections=redirections,
843              connection_type=connection_type,
844          )
845          return resp, content
846      http.request = new_request
847      return http
848  def tunnel_patch(http):
849      request_orig = http.request
850      def new_request(
851          uri,
852          method="GET",
853          body=None,
854          headers=None,
855          redirections=httplib2.DEFAULT_MAX_REDIRECTS,
856          connection_type=None,
857      ):
858          if headers is None:
859              headers = {}
860          if method == "PATCH":
861              if "oauth_token" in headers.get("authorization", ""):
862                  LOGGER.warning(
863                      "OAuth 1.0 request made with Credentials after tunnel_patch."
864                  )
865              headers["x-http-method-override"] = "PATCH"
866              method = "POST"
867          resp, content = request_orig(
868              uri,
869              method=method,
870              body=body,
871              headers=headers,
872              redirections=redirections,
873              connection_type=connection_type,
874          )
875          return resp, content
876      http.request = new_request
877      return http
878  def build_http():
879      if socket.getdefaulttimeout() is not None:
880          http_timeout = socket.getdefaulttimeout()
881      else:
882          http_timeout = DEFAULT_HTTP_TIMEOUT_SEC
883      http = httplib2.Http(timeout=http_timeout)
884      try:
885          http.redirect_codes = http.redirect_codes - {308}
886      except AttributeError:
887          pass
888      return http
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-multibox_loss.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-http.py</div>
                </div>
                <div class="column column_space"><pre><code>213          pos_mask = (conf_t > 0)
214          neg_mask = (conf_t == 0)
215          obj_data = conf_data[:, 0]
216          obj_data_pos = obj_data[pos_mask]
217          obj_data_neg = obj_data[neg_mask]
218          obj_neg_loss = - F.logsigmoid(-obj_data_neg).sum()
</pre></code></div>
                <div class="column column_space"><pre><code>778          headers=None,
779          redirections=1,
780          connection_type=None,
781      ):
782          self.uri = uri
783          self.method = method
784          self.body = body
785          self.headers = headers
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    