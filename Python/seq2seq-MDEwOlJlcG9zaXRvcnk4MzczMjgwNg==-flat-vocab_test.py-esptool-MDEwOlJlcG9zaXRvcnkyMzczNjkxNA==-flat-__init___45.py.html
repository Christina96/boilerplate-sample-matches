
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.02808112324493%, Tokens: 13</h2>
        <div class="column">
            <h3>seq2seq-MDEwOlJlcG9zaXRvcnk4MzczMjgwNg==-flat-vocab_test.py</h3>
            <pre><code>1  from __future__ import absolute_import
2  from __future__ import division
3  from __future__ import print_function
4  from __future__ import unicode_literals
5  import tensorflow as tf
6  import numpy as np
7  from seq2seq.data import vocab
8  from seq2seq.test import utils as test_utils
9  class VocabInfoTest(tf.test.TestCase):
10    def setUp(self):
11      super(VocabInfoTest, self).setUp()
12      tf.logging.set_verbosity(tf.logging.INFO)
13      self.vocab_list = ["Hello", ".", "Bye"]
14      self.vocab_file = test_utils.create_temporary_vocab_file(self.vocab_list)
15    def tearDown(self):
16      super(VocabInfoTest, self).tearDown()
17      self.vocab_file.close()
18    def test_vocab_info(self):
19      vocab_info = vocab.get_vocab_info(self.vocab_file.name)
20      self.assertEqual(vocab_info.vocab_size, 3)
21      self.assertEqual(vocab_info.path, self.vocab_file.name)
22      self.assertEqual(vocab_info.special_vocab.UNK, 3)
23      self.assertEqual(vocab_info.special_vocab.SEQUENCE_START, 4)
24      self.assertEqual(vocab_info.special_vocab.SEQUENCE_END, 5)
25      self.assertEqual(vocab_info.total_size, 6)
26  class CreateVocabularyLookupTableTest(tf.test.TestCase):
27    def test_without_counts(self):
28      vocab_list = ["Hello", ".", "笑"]
29      vocab_file = test_utils.create_temporary_vocab_file(vocab_list)
30      vocab_to_id_table, id_to_vocab_table, _, vocab_size = \
31        vocab.create_vocabulary_lookup_table(vocab_file.name)
32      self.assertEqual(vocab_size, 6)
<span onclick='openModal()' class='match'>33      with self.test_session() as sess:
34        sess.run(tf.global_variables_initializer())
35        sess.run(tf.local_variables_initializer())
36        sess.run(tf.tables_initializer())
</span>37        ids = vocab_to_id_table.lookup(
38            tf.convert_to_tensor(["Hello", ".", "笑", "??", "xxx"]))
39        ids = sess.run(ids)
40        np.testing.assert_array_equal(ids, [0, 1, 2, 3, 3])
41        words = id_to_vocab_table.lookup(
42            tf.convert_to_tensor(
43                [0, 1, 2, 3], dtype=tf.int64))
44        words = sess.run(words)
45        np.testing.assert_array_equal(
46            np.char.decode(words.astype("S"), "utf-8"),
47            ["Hello", ".", "笑", "UNK"])
48    def test_with_counts(self):
49      vocab_list = ["Hello", ".", "笑"]
50      vocab_counts = [100, 200, 300]
51      vocab_file = test_utils.create_temporary_vocab_file(vocab_list,
52                                                          vocab_counts)
53      vocab_to_id_table, id_to_vocab_table, word_to_count_table, vocab_size = \
54        vocab.create_vocabulary_lookup_table(vocab_file.name)
55      self.assertEqual(vocab_size, 6)
56      with self.test_session() as sess:
57        sess.run(tf.global_variables_initializer())
58        sess.run(tf.local_variables_initializer())
59        sess.run(tf.tables_initializer())
60        ids = vocab_to_id_table.lookup(
61            tf.convert_to_tensor(["Hello", ".", "笑", "??", "xxx"]))
62        ids = sess.run(ids)
63        np.testing.assert_array_equal(ids, [0, 1, 2, 3, 3])
64        words = id_to_vocab_table.lookup(
65            tf.convert_to_tensor(
66                [0, 1, 2, 3], dtype=tf.int64))
67        words = sess.run(words)
68        np.testing.assert_array_equal(
69            np.char.decode(words.astype("S"), "utf-8"),
70            ["Hello", ".", "笑", "UNK"])
71        counts = word_to_count_table.lookup(
72            tf.convert_to_tensor(["Hello", ".", "笑", "??", "xxx"]))
73        counts = sess.run(counts)
74        np.testing.assert_array_equal(counts, [100, 200, 300, -1, -1])
75  if __name__ == "__main__":
76    tf.test.main()
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___45.py</h3>
            <pre><code>1  __all__ = [
2      "chip_id",
3      "detect_chip",
4      "dump_mem",
5      "elf2image",
6      "erase_flash",
7      "erase_region",
8      "flash_id",
9      "get_security_info",
10      "image_info",
11      "load_ram",
12      "make_image",
13      "merge_bin",
14      "read_flash",
15      "read_flash_status",
16      "read_mac",
17      "read_mem",
18      "run",
19      "verify_flash",
20      "version",
21      "write_flash",
22      "write_flash_status",
23      "write_mem",
24  ]
25  __version__ = "4.7-dev"
26  import argparse
27  import inspect
28  import os
29  import shlex
30  import sys
31  import time
32  import traceback
33  from esptool.cmds import (
34      DETECTED_FLASH_SIZES,
35      chip_id,
36      detect_chip,
37      detect_flash_size,
38      dump_mem,
39      elf2image,
40      erase_flash,
41      erase_region,
42      flash_id,
43      get_security_info,
44      image_info,
45      load_ram,
46      make_image,
47      merge_bin,
48      read_flash,
49      read_flash_status,
50      read_mac,
51      read_mem,
52      run,
53      verify_flash,
54      version,
55      write_flash,
56      write_flash_status,
57      write_mem,
58  )
59  from esptool.config import load_config_file
60  from esptool.loader import DEFAULT_CONNECT_ATTEMPTS, ESPLoader, list_ports
61  from esptool.targets import CHIP_DEFS, CHIP_LIST, ESP32ROM
62  from esptool.util import (
63      FatalError,
64      NotImplementedInROMError,
65      flash_size_bytes,
66      strip_chip_name,
67  )
68  import serial
69  def main(argv=None, esp=None):
70      external_esp = esp is not None
71      parser = argparse.ArgumentParser(
72          description="esptool.py v%s - Espressif chips ROM Bootloader Utility"
73          % __version__,
74          prog="esptool",
75      )
76      parser.add_argument(
77          "--chip",
78          "-c",
79          help="Target chip type",
80          type=strip_chip_name,
81          choices=["auto"] + CHIP_LIST,
82          default=os.environ.get("ESPTOOL_CHIP", "auto"),
83      )
84      parser.add_argument(
85          "--port",
86          "-p",
87          help="Serial port device",
88          default=os.environ.get("ESPTOOL_PORT", None),
89      )
90      parser.add_argument(
91          "--baud",
92          "-b",
93          help="Serial port baud rate used when flashing/reading",
94          type=arg_auto_int,
95          default=os.environ.get("ESPTOOL_BAUD", ESPLoader.ESP_ROM_BAUD),
96      )
97      parser.add_argument(
98          "--before",
99          help="What to do before connecting to the chip",
100          choices=["default_reset", "usb_reset", "no_reset", "no_reset_no_sync"],
101          default=os.environ.get("ESPTOOL_BEFORE", "default_reset"),
102      )
103      parser.add_argument(
104          "--after",
105          "-a",
106          help="What to do after esptool.py is finished",
107          choices=["hard_reset", "soft_reset", "no_reset", "no_reset_stub"],
108          default=os.environ.get("ESPTOOL_AFTER", "hard_reset"),
109      )
110      parser.add_argument(
111          "--no-stub",
112          help="Disable launching the flasher stub, only talk to ROM bootloader. "
113          "Some features will not be available.",
114          action="store_true",
115      )
116      parser.add_argument(
117          "--trace",
118          "-t",
119          help="Enable trace-level output of esptool.py interactions.",
120          action="store_true",
121      )
122      parser.add_argument(
123          "--override-vddsdio",
124          help="Override ESP32 VDDSDIO internal voltage regulator (use with care)",
125          choices=ESP32ROM.OVERRIDE_VDDSDIO_CHOICES,
126          nargs="?",
127      )
128      parser.add_argument(
129          "--connect-attempts",
130          help=(
131              "Number of attempts to connect, negative or 0 for infinite. "
132              "Default: %d." % DEFAULT_CONNECT_ATTEMPTS
133          ),
134          type=int,
135          default=os.environ.get("ESPTOOL_CONNECT_ATTEMPTS", DEFAULT_CONNECT_ATTEMPTS),
136      )
137      subparsers = parser.add_subparsers(
138          dest="operation", help="Run esptool.py {command} -h for additional help"
139      )
140      def add_spi_connection_arg(parent):
141          parent.add_argument(
142              "--spi-connection",
143              "-sc",
144              help="ESP32-only argument. Override default SPI Flash connection. "
145              "Value can be SPI, HSPI or a comma-separated list of 5 I/O numbers "
146              "to use for SPI flash (CLK,Q,D,HD,CS).",
147              action=SpiConnectionAction,
148          )
149      parser_load_ram = subparsers.add_parser(
150          "load_ram", help="Download an image to RAM and execute"
151      )
152      parser_load_ram.add_argument("filename", help="Firmware image")
153      parser_dump_mem = subparsers.add_parser(
154          "dump_mem", help="Dump arbitrary memory to disk"
155      )
156      parser_dump_mem.add_argument("address", help="Base address", type=arg_auto_int)
157      parser_dump_mem.add_argument(
158          "size", help="Size of region to dump", type=arg_auto_int
159      )
160      parser_dump_mem.add_argument("filename", help="Name of binary dump")
161      parser_read_mem = subparsers.add_parser(
162          "read_mem", help="Read arbitrary memory location"
163      )
164      parser_read_mem.add_argument("address", help="Address to read", type=arg_auto_int)
165      parser_write_mem = subparsers.add_parser(
166          "write_mem", help="Read-modify-write to arbitrary memory location"
167      )
168      parser_write_mem.add_argument("address", help="Address to write", type=arg_auto_int)
169      parser_write_mem.add_argument("value", help="Value", type=arg_auto_int)
170      parser_write_mem.add_argument(
171          "mask",
172          help="Mask of bits to write",
173          type=arg_auto_int,
174          nargs="?",
175          default="0xFFFFFFFF",
176      )
177      def add_spi_flash_subparsers(parent, allow_keep, auto_detect):
178          extra_keep_args = ["keep"] if allow_keep else []
179          if auto_detect and allow_keep:
180              extra_fs_message = ", detect, or keep"
181              flash_sizes = ["detect", "keep"]
182          elif auto_detect:
183              extra_fs_message = ", or detect"
184              flash_sizes = ["detect"]
185          elif allow_keep:
186              extra_fs_message = ", or keep"
187              flash_sizes = ["keep"]
188          else:
189              extra_fs_message = ""
190              flash_sizes = []
191          parent.add_argument(
192              "--flash_freq",
193              "-ff",
194              help="SPI Flash frequency",
195              choices=extra_keep_args
196              + [
197                  "80m",
198                  "60m",
199                  "48m",
200                  "40m",
201                  "30m",
202                  "26m",
203                  "24m",
204                  "20m",
205                  "16m",
206                  "15m",
207                  "12m",
208              ],
209              default=os.environ.get("ESPTOOL_FF", "keep" if allow_keep else None),
210          )
211          parent.add_argument(
212              "--flash_mode",
213              "-fm",
214              help="SPI Flash mode",
215              choices=extra_keep_args + ["qio", "qout", "dio", "dout"],
216              default=os.environ.get("ESPTOOL_FM", "keep" if allow_keep else "qio"),
217          )
218          parent.add_argument(
219              "--flash_size",
220              "-fs",
221              help="SPI Flash size in MegaBytes "
222              "(1MB, 2MB, 4MB, 8MB, 16MB, 32MB, 64MB, 128MB) "
223              "plus ESP8266-only (256KB, 512KB, 2MB-c1, 4MB-c1)" + extra_fs_message,
224              choices=flash_sizes
225              + [
226                  "256KB",
227                  "512KB",
228                  "1MB",
229                  "2MB",
230                  "2MB-c1",
231                  "4MB",
232                  "4MB-c1",
233                  "8MB",
234                  "16MB",
235                  "32MB",
236                  "64MB",
237                  "128MB",
238              ],
239              default=os.environ.get("ESPTOOL_FS", "keep" if allow_keep else "1MB"),
240          )
241          add_spi_connection_arg(parent)
242      parser_write_flash = subparsers.add_parser(
243          "write_flash", help="Write a binary blob to flash"
244      )
245      parser_write_flash.add_argument(
246          "addr_filename",
247          metavar="<address> <filename>",
248          help="Address followed by binary filename, separated by space",
249          action=AddrFilenamePairAction,
250      )
251      parser_write_flash.add_argument(
252          "--erase-all",
253          "-e",
254          help="Erase all regions of flash (not just write areas) before programming",
255          action="store_true",
256      )
257      add_spi_flash_subparsers(parser_write_flash, allow_keep=True, auto_detect=True)
258      parser_write_flash.add_argument(
259          "--no-progress", "-p", help="Suppress progress output", action="store_true"
260      )
261      parser_write_flash.add_argument(
262          "--verify",
263          help="Verify just-written data on flash "
264          "(mostly superfluous, data is read back during flashing)",
265          action="store_true",
266      )
267      parser_write_flash.add_argument(
268          "--encrypt",
269          help="Apply flash encryption when writing data "
270          "(required correct efuse settings)",
271          action="store_true",
272      )
273      parser_write_flash.add_argument(
274          "--encrypt-files",
275          metavar="<address> <filename>",
276          help="Files to be encrypted on the flash. "
277          "Address followed by binary filename, separated by space.",
278          action=AddrFilenamePairAction,
279      )
280      parser_write_flash.add_argument(
281          "--ignore-flash-encryption-efuse-setting",
282          help="Ignore flash encryption efuse settings ",
283          action="store_true",
284      )
285      parser_write_flash.add_argument(
286          "--force",
287          help="Force write, skip security and compatibility checks. Use with caution!",
288          action="store_true",
289      )
290      compress_args = parser_write_flash.add_mutually_exclusive_group(required=False)
291      compress_args.add_argument(
292          "--compress",
293          "-z",
294          help="Compress data in transfer (default unless --no-stub is specified)",
295          action="store_true",
296          default=None,
297      )
298      compress_args.add_argument(
299          "--no-compress",
300          "-u",
301          help="Disable data compression during transfer "
302          "(default if --no-stub is specified)",
303          action="store_true",
304      )
305      subparsers.add_parser("run", help="Run application code in flash")
306      parser_image_info = subparsers.add_parser(
307          "image_info", help="Dump headers from a binary file (bootloader or application)"
308      )
309      parser_image_info.add_argument("filename", help="Image file to parse")
310      parser_image_info.add_argument(
311          "--version",
312          "-v",
313          help="Output format version (1 - legacy, 2 - extended)",
314          choices=["1", "2"],
315          default="1",
316      )
317      parser_make_image = subparsers.add_parser(
318          "make_image", help="Create an application image from binary files"
319      )
320      parser_make_image.add_argument("output", help="Output image file")
321      parser_make_image.add_argument(
322          "--segfile", "-f", action="append", help="Segment input file"
323      )
324      parser_make_image.add_argument(
325          "--segaddr",
326          "-a",
327          action="append",
328          help="Segment base address",
329          type=arg_auto_int,
330      )
331      parser_make_image.add_argument(
332          "--entrypoint",
333          "-e",
334          help="Address of entry point",
335          type=arg_auto_int,
336          default=0,
337      )
338      parser_elf2image = subparsers.add_parser(
339          "elf2image", help="Create an application image from ELF file"
340      )
341      parser_elf2image.add_argument("input", help="Input ELF file")
342      parser_elf2image.add_argument(
343          "--output",
344          "-o",
345          help="Output filename prefix (for version 1 image), "
346          "or filename (for version 2 single image)",
347          type=str,
348      )
349      parser_elf2image.add_argument(
350          "--version",
351          "-e",
352          help="Output image version",
353          choices=["1", "2", "3"],
354          default="1",
355      )
356      parser_elf2image.add_argument(
357          "--min-rev",
358          "-r",
359          help=argparse.SUPPRESS,
360          type=int,
361          choices=range(256),
362          metavar="{0, ... 255}",
363          default=0,
364      )
365      parser_elf2image.add_argument(
366          "--min-rev-full",
367          help="Minimal chip revision (in format: major * 100 + minor)",
368          type=int,
369          choices=range(65536),
370          metavar="{0, ... 65535}",
371          default=0,
372      )
373      parser_elf2image.add_argument(
374          "--max-rev-full",
375          help="Maximal chip revision (in format: major * 100 + minor)",
376          type=int,
377          choices=range(65536),
378          metavar="{0, ... 65535}",
379          default=65535,
380      )
381      parser_elf2image.add_argument(
382          "--secure-pad",
383          action="store_true",
384          help="Pad image so once signed it will end on a 64KB boundary. "
385          "For Secure Boot v1 images only.",
386      )
387      parser_elf2image.add_argument(
388          "--secure-pad-v2",
389          action="store_true",
390          help="Pad image to 64KB, so once signed its signature sector will"
391          "start at the next 64K block. For Secure Boot v2 images only.",
392      )
393      parser_elf2image.add_argument(
394          "--elf-sha256-offset",
395          help="If set, insert SHA256 hash (32 bytes) of the input ELF file "
396          "at specified offset in the binary.",
397          type=arg_auto_int,
398          default=None,
399      )
400      parser_elf2image.add_argument(
401          "--dont-append-digest",
402          dest="append_digest",
403          help="Don't append a SHA256 digest of the entire image after the checksum. "
404          "This argument is not supported and ignored for ESP8266.",
405          action="store_false",
406          default=True,
407      )
408      parser_elf2image.add_argument(
409          "--use_segments",
410          help="If set, ELF segments will be used instead of ELF sections "
411          "to genereate the image.",
412          action="store_true",
413      )
414      parser_elf2image.add_argument(
415          "--flash-mmu-page-size",
416          help="Change flash MMU page size.",
417          choices=["64KB", "32KB", "16KB", "8KB"],
418      )
419      parser_elf2image.add_argument(
420          "--pad-to-size",
421          help="The block size with which the final binary image after padding "
422          "must be aligned to. Value 0xFF is used for padding, similar to erase_flash",
423          default=None,
424      )
425      add_spi_flash_subparsers(parser_elf2image, allow_keep=False, auto_detect=False)
426      subparsers.add_parser("read_mac", help="Read MAC address from OTP ROM")
427      subparsers.add_parser("chip_id", help="Read Chip ID from OTP ROM")
428      parser_flash_id = subparsers.add_parser(
429          "flash_id", help="Read SPI flash manufacturer and device ID"
430      )
431      add_spi_connection_arg(parser_flash_id)
432      parser_read_status = subparsers.add_parser(
433          "read_flash_status", help="Read SPI flash status register"
434      )
435      add_spi_connection_arg(parser_read_status)
436      parser_read_status.add_argument(
437          "--bytes",
438          help="Number of bytes to read (1-3)",
439          type=int,
440          choices=[1, 2, 3],
441          default=2,
442      )
443      parser_write_status = subparsers.add_parser(
444          "write_flash_status", help="Write SPI flash status register"
445      )
446      add_spi_connection_arg(parser_write_status)
447      parser_write_status.add_argument(
448          "--non-volatile",
449          help="Write non-volatile bits (use with caution)",
450          action="store_true",
451      )
452      parser_write_status.add_argument(
453          "--bytes",
454          help="Number of status bytes to write (1-3)",
455          type=int,
456          choices=[1, 2, 3],
457          default=2,
458      )
459      parser_write_status.add_argument("value", help="New value", type=arg_auto_int)
460      parser_read_flash = subparsers.add_parser(
461          "read_flash", help="Read SPI flash content"
462      )
463      add_spi_connection_arg(parser_read_flash)
464      parser_read_flash.add_argument("address", help="Start address", type=arg_auto_int)
465      parser_read_flash.add_argument(
466          "size",
467          help="Size of region to dump. Use `ALL` to read to the end of flash.",
468          type=arg_auto_size,
469      )
470      parser_read_flash.add_argument("filename", help="Name of binary dump")
471      parser_read_flash.add_argument(
472          "--no-progress", "-p", help="Suppress progress output", action="store_true"
473      )
474      parser_verify_flash = subparsers.add_parser(
475          "verify_flash", help="Verify a binary blob against flash"
476      )
477      parser_verify_flash.add_argument(
478          "addr_filename",
479          help="Address and binary file to verify there, separated by space",
480          action=AddrFilenamePairAction,
481      )
482      parser_verify_flash.add_argument(
483          "--diff", "-d", help="Show differences", choices=["no", "yes"], default="no"
484      )
485      add_spi_flash_subparsers(parser_verify_flash, allow_keep=True, auto_detect=True)
486      parser_erase_flash = subparsers.add_parser(
487          "erase_flash", help="Perform Chip Erase on SPI flash"
488      )
489      parser_erase_flash.add_argument(
490          "--force",
491          help="Erase flash even if security features are enabled. Use with caution!",
492          action="store_true",
493      )
494      add_spi_connection_arg(parser_erase_flash)
495      parser_erase_region = subparsers.add_parser(
496          "erase_region", help="Erase a region of the flash"
497      )
498      parser_erase_region.add_argument(
499          "--force",
500          help="Erase region even if security features are enabled. Use with caution!",
501          action="store_true",
502      )
503      add_spi_connection_arg(parser_erase_region)
504      parser_erase_region.add_argument(
505          "address", help="Start address (must be multiple of 4096)", type=arg_auto_int
506      )
507      parser_erase_region.add_argument(
508          "size",
509          help="Size of region to erase (must be multiple of 4096). "
510          "Use `ALL` to erase to the end of flash.",
511          type=arg_auto_size,
512      )
513      parser_merge_bin = subparsers.add_parser(
514          "merge_bin",
515          help="Merge multiple raw binary files into a single file for later flashing",
516      )
517      parser_merge_bin.add_argument(
518          "--output", "-o", help="Output filename", type=str, required=True
519      )
520      parser_merge_bin.add_argument(
521          "--format", "-f", help="Format of the output file", choices="raw", default="raw"
522      )  # for future expansion
523      add_spi_flash_subparsers(parser_merge_bin, allow_keep=True, auto_detect=False)
524      parser_merge_bin.add_argument(
525          "--target-offset",
526          "-t",
527          help="Target offset where the output file will be flashed",
528          type=arg_auto_int,
529          default=0,
530      )
531      parser_merge_bin.add_argument(
532          "--fill-flash-size",
533          help="If set, the final binary file will be padded with FF "
534          "bytes up to this flash size.",
535          choices=[
536              "256KB",
537              "512KB",
538              "1MB",
539              "2MB",
540              "4MB",
541              "8MB",
542              "16MB",
543              "32MB",
544              "64MB",
545              "128MB",
546          ],
547      )
548      parser_merge_bin.add_argument(
549          "addr_filename",
550          metavar="<address> <filename>",
551          help="Address followed by binary filename, separated by space",
552          action=AddrFilenamePairAction,
553      )
554      subparsers.add_parser("get_security_info", help="Get some security-related data")
555      subparsers.add_parser("version", help="Print esptool version")
556      for operation in subparsers.choices.keys():
557          assert operation in globals(), "%s should be a module function" % operation
558      argv = expand_file_arguments(argv or sys.argv[1:])
559      args = parser.parse_args(argv)
560      print("esptool.py v%s" % __version__)
561      load_config_file(verbose=True)
562      if args.operation is None:
563          parser.print_help()
564          sys.exit(1)
565      if (
566          args.operation == "write_flash"
567          and args.encrypt
568          and args.encrypt_files is not None
569      ):
570          raise FatalError(
571              "Options --encrypt and --encrypt-files "
572              "must not be specified at the same time."
573          )
574      operation_func = globals()[args.operation]
575      operation_args = inspect.getfullargspec(operation_func).args
576      if (
577          operation_args[0] == "esp"
578      ):  # operation function takes an ESPLoader connection object
579          if args.before != "no_reset_no_sync":
580              initial_baud = min(
581                  ESPLoader.ESP_ROM_BAUD, args.baud
582              )  # don't sync faster than the default baud rate
583          else:
584              initial_baud = args.baud
585          if args.port is None:
586              ser_list = get_port_list()
587              print("Found %d serial ports" % len(ser_list))
588          else:
589              ser_list = [args.port]
590          esp = esp or get_default_connected_device(
591              ser_list,
592              port=args.port,
593              connect_attempts=args.connect_attempts,
594              initial_baud=initial_baud,
595              chip=args.chip,
596              trace=args.trace,
597              before=args.before,
598          )
599          if esp is None:
600              raise FatalError(
601                  "Could not connect to an Espressif device "
602                  "on any of the %d available serial ports." % len(ser_list)
603              )
604          if esp.secure_download_mode:
605              print("Chip is %s in Secure Download Mode" % esp.CHIP_NAME)
606          else:
607              print("Chip is %s" % (esp.get_chip_description()))
608              print("Features: %s" % ", ".join(esp.get_chip_features()))
609              print("Crystal is %dMHz" % esp.get_crystal_freq())
610              read_mac(esp, args)
611          if not args.no_stub:
612              if esp.secure_download_mode:
613                  print(
614                      "WARNING: Stub loader is not supported in Secure Download Mode, "
615                      "setting --no-stub"
616                  )
617                  args.no_stub = True
618              elif not esp.IS_STUB and esp.stub_is_disabled:
619                  print(
620                      "WARNING: Stub loader has been disabled for compatibility, "
621                      "setting --no-stub"
622                  )
623                  args.no_stub = True
624              else:
625                  esp = esp.run_stub()
626          if args.override_vddsdio:
627              esp.override_vddsdio(args.override_vddsdio)
628          if args.baud > initial_baud:
629              try:
630                  esp.change_baud(args.baud)
631              except NotImplementedInROMError:
632                  print(
633                      "WARNING: ROM doesn't support changing baud rate. "
634                      "Keeping initial baud rate %d" % initial_baud
635                  )
636          if hasattr(args, "spi_connection") and args.spi_connection is not None:
637              if esp.CHIP_NAME != "ESP32":
638                  raise FatalError(
639                      "Chip %s does not support --spi-connection option." % esp.CHIP_NAME
640                  )
641              print("Configuring SPI flash mode...")
642              esp.flash_spi_attach(args.spi_connection)
643          elif args.no_stub:
644              print("Enabling default SPI flash mode...")
645              esp.flash_spi_attach(0)
646          XMC_VENDOR_ID = 0x20
647          def is_xmc_chip_strict():
648              id = esp.flash_id()
649              rdid = ((id & 0xFF) << 16) | ((id >> 16) & 0xFF) | (id & 0xFF00)
650              vendor_id = (rdid >> 16) & 0xFF
651              mfid = (rdid >> 8) & 0xFF
652              cpid = rdid & 0xFF
653              if vendor_id != XMC_VENDOR_ID:
654                  return False
655              matched = False
656              if mfid == 0x40:
657                  if cpid >= 0x13 and cpid <= 0x20:
658                      matched = True
659              elif mfid == 0x41:
660                  if cpid >= 0x17 and cpid <= 0x20:
661                      matched = True
662              elif mfid == 0x50:
663                  if cpid >= 0x15 and cpid <= 0x16:
664                      matched = True
665              return matched
666          def flash_xmc_startup():
667              fast_check = True
668              if fast_check and is_xmc_chip_strict():
669                  return  # Successful XMC flash chip boot-up detected by RDID, skipping.
670              sfdp_mfid_addr = 0x10
671              mf_id = esp.read_spiflash_sfdp(sfdp_mfid_addr, 8)
672              if mf_id != XMC_VENDOR_ID:  # Non-XMC chip detected by SFDP Read, skipping.
673                  return
<span onclick='openModal()' class='match'>674              print(
675                  "WARNING: XMC flash chip boot-up failure detected! "
676                  "Running XMC25QHxxC startup flow"
677              )
678              esp.run_spiflash_command(0xB9)  # Enter DPD
679              esp.run_spiflash_command(0x79)  # Enter UDPD
680              esp.run_spiflash_command(0xFF)  # Exit UDPD
681              time.sleep(0.002)  # Delay tXUDPD
682              esp.run_spiflash_command(0xAB)  # Release Power-Down
683              time.sleep(0.00002)
</span>684              if not is_xmc_chip_strict():
685                  print("WARNING: XMC flash boot-up fix failed.")
686              print("XMC flash chip boot-up fix successful!")
687          if not esp.secure_download_mode:
688              try:
689                  flash_id = esp.flash_id()
690                  if flash_id in (0xFFFFFF, 0x000000):
691                      print(
692                          "WARNING: Failed to communicate with the flash chip, "
693                          "read/write operations will fail. "
694                          "Try checking the chip connections or removing "
695                          "any other hardware connected to IOs."
696                      )
697              except FatalError as e:
698                  raise FatalError(f"Unable to verify flash chip connection ({e}).")
699          if not esp.secure_download_mode:
700              try:
701                  flash_xmc_startup()
702              except FatalError as e:
703                  esp.trace(f"Unable to perform XMC flash chip startup sequence ({e}).")
704          if hasattr(args, "flash_size"):
705              print("Configuring flash size...")
706              if args.flash_size == "detect":
707                  flash_size = detect_flash_size(esp, args)
708              elif args.flash_size == "keep":
709                  flash_size = detect_flash_size(esp, args=None)
710              else:
711                  flash_size = args.flash_size
712              if flash_size is not None:  # Secure download mode
713                  esp.flash_set_parameters(flash_size_bytes(flash_size))
714                  if esp.IS_STUB and flash_size in ("32MB", "64MB", "128MB"):
715                      print(
716                          "WARNING: Flasher stub doesn't fully support flash size larger "
717                          "than 16MB, in case of failure use --no-stub."
718                      )
719          if getattr(args, "size", "") == "all":
720              if esp.secure_download_mode:
721                  raise FatalError(
722                      "Detecting flash size is not supported in secure download mode. "
723                      "Set an exact size value."
724                  )
725              flash_id = esp.flash_id()
726              size_id = flash_id >> 16
727              size_str = DETECTED_FLASH_SIZES.get(size_id)
728              if size_str is None:
729                  raise FatalError(
730                      "Detecting flash size failed. Set an exact size value."
731                  )
732              print(f"Detected flash size: {size_str}")
733              args.size = flash_size_bytes(size_str)
734          if esp.IS_STUB and hasattr(args, "address") and hasattr(args, "size"):
735              if args.address + args.size > 0x1000000:
736                  print(
737                      "WARNING: Flasher stub doesn't fully support flash size larger "
738                      "than 16MB, in case of failure use --no-stub."
739                  )
740          try:
741              operation_func(esp, args)
742          finally:
743              try:  # Clean up AddrFilenamePairAction files
744                  for address, argfile in args.addr_filename:
745                      argfile.close()
746              except AttributeError:
747                  pass
748          if operation_func == load_ram:
749              print("Exiting immediately.")
750          elif args.after == "hard_reset":
751              esp.hard_reset()
752          elif args.after == "soft_reset":
753              print("Soft resetting...")
754              esp.soft_reset(False)
755          elif args.after == "no_reset_stub":
756              print("Staying in flasher stub.")
757          else:  # args.after == 'no_reset'
758              print("Staying in bootloader.")
759              if esp.IS_STUB:
760                  esp.soft_reset(True)  # exit stub back to ROM loader
761          if not external_esp:
762              esp._port.close()
763      else:
764          operation_func(args)
765  def arg_auto_int(x):
766      return int(x, 0)
767  def arg_auto_size(x):
768      x = x.lower()
769      return x if x == "all" else arg_auto_int(x)
770  def get_port_list():
771      if list_ports is None:
772          raise FatalError(
773              "Listing all serial ports is currently not available. "
774              "Please try to specify the port when running esptool.py or update "
775              "the pyserial package to the latest version"
776          )
777      return sorted(ports.device for ports in list_ports.comports())
778  def expand_file_arguments(argv):
779      new_args = []
780      expanded = False
781      for arg in argv:
782          if arg.startswith("@"):
783              expanded = True
784              with open(arg[1:], "r") as f:
785                  for line in f.readlines():
786                      new_args += shlex.split(line)
787          else:
788              new_args.append(arg)
789      if expanded:
790          print("esptool %s" % (" ".join(new_args[1:])))
791          return new_args
792      return argv
793  def get_default_connected_device(
794      serial_list,
795      port,
796      connect_attempts,
797      initial_baud,
798      chip="auto",
799      trace=False,
800      before="default_reset",
801  ):
802      _esp = None
803      for each_port in reversed(serial_list):
804          print("Serial port %s" % each_port)
805          try:
806              if chip == "auto":
807                  _esp = detect_chip(
808                      each_port, initial_baud, before, trace, connect_attempts
809                  )
810              else:
811                  chip_class = CHIP_DEFS[chip]
812                  _esp = chip_class(each_port, initial_baud, trace)
813                  _esp.connect(before, connect_attempts)
814              break
815          except (FatalError, OSError) as err:
816              if port is not None:
817                  raise
818              print("%s failed to connect: %s" % (each_port, err))
819              if _esp and _esp._port:
820                  _esp._port.close()
821              _esp = None
822      return _esp
823  class SpiConnectionAction(argparse.Action):
824      def __call__(self, parser, namespace, value, option_string=None):
825          if value.upper() == "SPI":
826              value = 0
827          elif value.upper() == "HSPI":
828              value = 1
829          elif "," in value:
830              values = value.split(",")
831              if len(values) != 5:
832                  raise argparse.ArgumentError(
833                      self,
834                      "%s is not a valid list of comma-separate pin numbers. "
835                      "Must be 5 numbers - CLK,Q,D,HD,CS." % value,
836                  )
837              try:
838                  values = tuple(int(v, 0) for v in values)
839              except ValueError:
840                  raise argparse.ArgumentError(
841                      self,
842                      "%s is not a valid argument. All pins must be numeric values"
843                      % values,
844                  )
845              if any([v for v in values if v > 33 or v < 0]):
846                  raise argparse.ArgumentError(
847                      self, "Pin numbers must be in the range 0-33."
848                  )
849              clk, q, d, hd, cs = values
850              value = (hd << 24) | (cs << 18) | (d << 12) | (q << 6) | clk
851          else:
852              raise argparse.ArgumentError(
853                  self,
854                  "%s is not a valid spi-connection value. "
855                  "Values are SPI, HSPI, or a sequence of 5 pin numbers CLK,Q,D,HD,CS)."
856                  % value,
857              )
858          setattr(namespace, self.dest, value)
859  class AddrFilenamePairAction(argparse.Action):
860      def __init__(self, option_strings, dest, nargs="+", **kwargs):
861          super(AddrFilenamePairAction, self).__init__(
862              option_strings, dest, nargs, **kwargs
863          )
864      def __call__(self, parser, namespace, values, option_string=None):
865          pairs = []
866          for i in range(0, len(values), 2):
867              try:
868                  address = int(values[i], 0)
869              except ValueError:
870                  raise argparse.ArgumentError(
871                      self, 'Address "%s" must be a number' % values[i]
872                  )
873              try:
874                  argfile = open(values[i + 1], "rb")
875              except IOError as e:
876                  raise argparse.ArgumentError(self, e)
877              except IndexError:
878                  raise argparse.ArgumentError(
879                      self,
880                      "Must be pairs of an address "
881                      "and the binary filename to write there",
882                  )
883              pairs.append((address, argfile))
884          end = 0
885          for address, argfile in sorted(pairs, key=lambda x: x[0]):
886              argfile.seek(0, 2)  # seek to end
887              size = argfile.tell()
888              argfile.seek(0)
889              sector_start = address & ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
890              sector_end = (
891                  (address + size + ESPLoader.FLASH_SECTOR_SIZE - 1)
892                  & ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
893              ) - 1
894              if sector_start < end:
895                  message = "Detected overlap at address: 0x%x for file: %s" % (
896                      address,
897                      argfile.name,
898                  )
899                  raise argparse.ArgumentError(self, message)
900              end = sector_end
901          setattr(namespace, self.dest, pairs)
902  def _main():
903      try:
904          main()
905      except FatalError as e:
906          print(f"\nA fatal error occurred: {e}")
907          sys.exit(2)
908      except serial.serialutil.SerialException as e:
909          print(f"\nA serial exception error occurred: {e}")
910          print(
911              "Note: This error originates from pySerial. "
912              "It is likely not a problem with esptool, "
913              "but with the hardware connection or drivers."
914          )
915          print(
916              "For troubleshooting steps visit: "
917              "https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html"
918          )
919          sys.exit(1)
920      except StopIteration:
921          print(traceback.format_exc())
922          print("A fatal error occurred: The chip stopped responding.")
923          sys.exit(2)
924  if __name__ == "__main__":
925      _main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from seq2seq-MDEwOlJlcG9zaXRvcnk4MzczMjgwNg==-flat-vocab_test.py</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___45.py</div>
                <div class="column column_space"><pre><code>33      with self.test_session() as sess:
34        sess.run(tf.global_variables_initializer())
35        sess.run(tf.local_variables_initializer())
36        sess.run(tf.tables_initializer())
</pre></code></div>
                <div class="column column_space"><pre><code>674              print(
675                  "WARNING: XMC flash chip boot-up failure detected! "
676                  "Running XMC25QHxxC startup flow"
677              )
678              esp.run_spiflash_command(0xB9)  # Enter DPD
679              esp.run_spiflash_command(0x79)  # Enter UDPD
680              esp.run_spiflash_command(0xFF)  # Exit UDPD
681              time.sleep(0.002)  # Delay tXUDPD
682              esp.run_spiflash_command(0xAB)  # Release Power-Down
683              time.sleep(0.00002)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    