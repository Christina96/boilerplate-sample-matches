<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_conv3d2d.py &amp; pkl_utils.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_conv3d2d.py &amp; pkl_utils.py
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_conv3d2d.py (3.8961039%)<th>pkl_utils.py (3.3333333%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-16)<td><a href="#" name="0">(14-28)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_conv3d2d.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import time
2 from nose.plugins.skip import SkipTest
3 from parameterized import parameterized
4 import numpy as np
5 try:
6     from scipy import ndimage
7 except ImportError:
8     ndimage = None
9 from six.moves import xrange
10 import theano
11 from theano.gof.opt import check_stack_trace
12 from theano.tensor.nnet.conv3d2d import conv3d, get_diagonal_subtensor_view, DiagonalSubtensor, IncDiagonalSubtensor
13 import</b></font> theano.tests.unittest_tools as utt
14 def test_get_diagonal_subtensor_view(wrap=lambda a: a):
15     x = np.arange(20).reshape(5, 4).astype('float32')
16     x = wrap(x)
17     xv01 = get_diagonal_subtensor_view(x, 0, 1)
18     assert np.all(np.asarray(xv01) == [[12, 9, 6, 3], [16, 13, 10, 7]])
19     x = np.arange(24).reshape(4, 3, 2)
20     xv01 = get_diagonal_subtensor_view(x, 0, 1)
21     xv02 = get_diagonal_subtensor_view(x, 0, 2)
22     xv12 = get_diagonal_subtensor_view(x, 1, 2)
23     assert np.all(np.asarray(xv01) == [
24         [[12, 13], [8, 9], [4, 5]],
25         [[18, 19], [14, 15], [10, 11]]])
26     assert np.all(np.asarray(xv02) == [
27         [[6, 1], [8, 3], [10, 5]],
28         [[12, 7], [14, 9], [16, 11]],
29         [[18, 13], [20, 15], [22, 17]],
30         ])
31     for xi, xvi in zip(x, xv12):
32         assert np.all(xvi == get_diagonal_subtensor_view(xi, 0, 1))
33 def pyconv3d(signals, filters, border_mode='valid'):
34     Ns, Ts, C, Hs, Ws = signals.shape
35     Nf, Tf, C, Hf, Wf = filters.shape
36     if border_mode == 'full':
37         Tpad = Tf - 1
38         Hpad = Hf - 1
39         Wpad = Wf - 1
40     elif border_mode == 'half':
41         Tpad = Tf // 2
42         Hpad = Hf // 2
43         Wpad = Wf // 2
44     else:
45         Tpad = 0
46         Hpad = 0
47         Wpad = 0
48     if Tpad &gt; 0 or Hpad &gt; 0 or Wpad &gt; 0:
49         signals_padded = np.zeros((Ns, Ts + 2 * Tpad, C,
50                                    Hs + 2 * Hpad, Ws + 2 * Wpad), 'float32')
51         signals_padded[:, Tpad:(Ts + Tpad), :, Hpad:(Hs + Hpad),
52                        Wpad:(Ws + Wpad)] = signals
53         Ns, Ts, C, Hs, Ws = signals_padded.shape
54         signals = signals_padded
55     Tf2 = Tf // 2
56     Hf2 = Hf // 2
57     Wf2 = Wf // 2
58     rval = np.zeros((Ns, Ts - Tf + 1, Nf, Hs - Hf + 1, Ws - Wf + 1))
59     for ns in xrange(Ns):
60         for nf in xrange(Nf):
61             for c in xrange(C):
62                 s_i = signals[ns, :, c, :, :]
63                 f_i = filters[nf, :, c, :, :]
64                 r_i = rval[ns, :, nf, :, :]
65                 o_i = ndimage.convolve(s_i, f_i, mode='constant', cval=1)
66                 o_i_sh0 = o_i.shape[0]
67                 r_i += o_i[Tf2:o_i_sh0 - Tf2, Hf2:-Hf2, Wf2:-Wf2]
68     return rval
69 def check_diagonal_subtensor_view_traces(fn):
70     assert check_stack_trace(
71         fn, ops_to_check=(DiagonalSubtensor, IncDiagonalSubtensor))
72 @parameterized.expand(('valid', 'full', 'half'), utt.custom_name_func)
73 def test_conv3d(border_mode):
74     if ndimage is None or not theano.config.cxx:
75         raise SkipTest("conv3d2d tests need SciPy and a c++ compiler")
76     if theano.config.mode == 'FAST_COMPILE':
77         mode = theano.compile.mode.get_mode('FAST_RUN')
78     else:
79         mode = theano.compile.mode.get_default_mode()
80     shared = theano.tensor._shared
81     Ns, Ts, C, Hs, Ws = 3, 10, 3, 32, 32
82     Nf, Tf, C, Hf, Wf = 32, 5, 3, 5, 5
83     signals = np.arange(Ns * Ts * C * Hs * Ws).reshape(Ns, Ts, C, Hs, Ws).astype('float32')
84     filters = np.arange(Nf * Tf * C * Hf * Wf).reshape(Nf, Tf, C, Hf, Wf).astype('float32')
85     t0 = time.time()
86     pyres = pyconv3d(signals, filters, border_mode)
87     print(time.time() - t0)
88     s_signals = shared(signals)
89     s_filters = shared(filters)
90     s_output = shared(signals * 0)
91     out = conv3d(s_signals, s_filters,
92                  signals_shape=signals.shape,
93                  filters_shape=filters.shape,
94                  border_mode=border_mode)
95     newconv3d = theano.function([], [],
96                                 updates={s_output: out},
97                                 mode=mode)
98     check_diagonal_subtensor_view_traces(newconv3d)
99     t0 = time.time()
100     newconv3d()
101     print(time.time() - t0)
102     utt.assert_allclose(pyres, s_output.get_value(borrow=True))
103     gsignals, gfilters = theano.grad(out.sum(), [s_signals, s_filters])
104     gnewconv3d = theano.function([], [],
105                                  updates=[(s_filters, gfilters),
106                                           (s_signals, gsignals)],
107                                  mode=mode,
108                                  name='grad')
109     check_diagonal_subtensor_view_traces(gnewconv3d)
110     t0 = time.time()
111     gnewconv3d()
112     print('grad', time.time() - t0)
113     Ns, Ts, C, Hs, Ws = 3, 3, 3, 5, 5
114     Nf, Tf, C, Hf, Wf = 4, 2, 3, 2, 2
115     signals = np.random.rand(Ns, Ts, C, Hs, Ws).astype('float32')
116     filters = np.random.rand(Nf, Tf, C, Hf, Wf).astype('float32')
117     utt.verify_grad(lambda s, f: conv3d(s, f, border_mode=border_mode),
118                     [signals, filters], eps=1e-1, mode=mode)
119     Ns, Ts, C, Hs, Ws = 3, 10, 3, 32, 32
120     Nf, Tf, C, Hf, Wf = 32, 1, 3, 5, 5
121     signals = np.arange(Ns * Ts * C * Hs * Ws).reshape(Ns, Ts, C, Hs, Ws).astype('float32')
122     filters = np.arange(Nf * Tf * C * Hf * Wf).reshape(Nf, Tf, C, Hf, Wf).astype('float32')
123     t0 = time.time()
124     pyres = pyconv3d(signals, filters, border_mode)
125     print(time.time() - t0)
126     s_signals = shared(signals)
127     s_filters = shared(filters)
128     s_output = shared(signals * 0)
129     out = conv3d(s_signals, s_filters,
130                  signals_shape=signals.shape,
131                  filters_shape=filters.shape,
132                  border_mode=border_mode)
133     newconv3d = theano.function([], [],
134                                 updates={s_output: out},
135                                 mode=mode)
136     t0 = time.time()
137     newconv3d()
138     print(time.time() - t0)
139     utt.assert_allclose(pyres, s_output.get_value(borrow=True))
140     gsignals, gfilters = theano.grad(out.sum(), [s_signals, s_filters])
141     gnewconv3d = theano.function([], [],
142                                  updates=[(s_filters, gfilters),
143                                           (s_signals, gsignals)],
144                                  mode=mode,
145                                  name='grad')
146     t0 = time.time()
147     gnewconv3d()
148     print('grad', time.time() - t0)
149     Ns, Ts, C, Hs, Ws = 3, 3, 3, 5, 5
150     Nf, Tf, C, Hf, Wf = 4, 1, 3, 2, 2
151     signals = np.random.rand(Ns, Ts, C, Hs, Ws).astype('float32')
152     filters = np.random.rand(Nf, Tf, C, Hf, Wf).astype('float32')
153     utt.verify_grad(lambda s, f: conv3d(s, f, border_mode=border_mode),
154                     [signals, filters], eps=1e-1, mode=mode)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pkl_utils.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, print_function, division
2 import numpy as np
3 import os
4 import pickle
5 import tempfile
6 import zipfile
7 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import warnings
8 from collections import defaultdict
9 from contextlib import closing
10 from pickle import HIGHEST_PROTOCOL
11 from six import BytesIO
12 try:
13     from pickle import DEFAULT_PROTOCOL
14 except ImportError:
15     DEFAULT_PROTOCOL = HIGHEST_PROTOCOL
16 import theano
17 from theano import config
18 from theano.compat import PY3
19 from six import string_types
20 from</b></font> theano.compile.sharedvalue import SharedVariable
21 __docformat__ = "restructuredtext en"
22 __authors__ = "Pascal Lamblin"
23 __copyright__ = "Copyright 2013, Universite de Montreal"
24 __license__ = "3-clause BSD"
25 min_recursion = 3000
26 if sys.getrecursionlimit() &lt; min_recursion:
27     sys.setrecursionlimit(min_recursion)
28 Pickler = pickle.Pickler
29 class StripPickler(Pickler):
30     def __init__(self, file, protocol=0, extra_tag_to_remove=None):
31         Pickler.__init__(self, file, protocol)
32         self.tag_to_remove = ['trace', 'test_value']
33         if extra_tag_to_remove:
34             self.tag_to_remove.extend(extra_tag_to_remove)
35     def save(self, obj):
36         if isinstance(obj, theano.gof.utils.scratchpad):
37             for tag in self.tag_to_remove:
38                 if hasattr(obj, tag):
39                     del obj.__dict__[tag]
40         elif (isinstance(obj, theano.tensor.Elemwise)):
41             if '__doc__' in obj.__dict__:
42                 del obj.__dict__['__doc__']
43         return Pickler.save(self, obj)
44 def load_reduce(self):
45     stack = self.stack
46     args = stack.pop()
47     func = stack[-1]
48     try:
49         value = func(*args)
50     except Exception:
51         if self.encoding is not None:
52             new_args = []
53             for arg in args:
54                 if isinstance(arg, string_types):
55                     new_args.append(arg.encode(self.encoding))
56                 else:
57                     new_args.append(arg)
58             args = tuple(new_args)
59             try:
60                 stack[-1] = func(*args)
61                 return
62             except Exception:
63                 pass
64         raise
65     stack[-1] = value
66 if PY3:
67     class CompatUnpickler(pickle._Unpickler):
68         pass
69     CompatUnpickler.dispatch[pickle.REDUCE[0]] = load_reduce
70 else:
71     class CompatUnpickler(pickle.Unpickler):
72         pass
73 class PersistentNdarrayID(object):
74     def __init__(self, zip_file):
75         self.zip_file = zip_file
76         self.count = 0
77         self.seen = {}
78     def _resolve_name(self, obj):
79         name = 'array_{0}'.format(self.count)
80         self.count += 1
81         return name
82     def __call__(self, obj):
83         if type(obj) is np.ndarray:
84             if id(obj) not in self.seen:
85                 def write_array(f):
86                     np.lib.format.write_array(f, obj)
87                 name = self._resolve_name(obj)
88                 zipadd(write_array, self.zip_file, name)
89                 self.seen[id(obj)] = 'ndarray.{0}'.format(name)
90             return self.seen[id(obj)]
91 class PersistentGpuArrayID(PersistentNdarrayID):
92     def __call__(self, obj):
93         from theano.gpuarray.type import _name_for_ctx
94         try:
95             import pygpu
96         except ImportError:
97             pygpu = None
98         if (pygpu and
99                 isinstance(obj, pygpu.gpuarray.GpuArray)):
100             if id(obj) not in self.seen:
101                 def write_array(f):
102                     pickle.dump(_name_for_ctx(obj.context), f, 2)
103                     np.lib.format.write_array(f, np.asarray(obj))
104                 name = self._resolve_name(obj)
105                 zipadd(write_array, self.zip_file, name)
106                 self.seen[id(obj)] = 'gpuarray.{0}'.format(name)
107             return self.seen[id(obj)]
108         return super(PersistentGpuArrayID, self).__call__(obj)
109 class PersistentSharedVariableID(PersistentGpuArrayID):
110     def __init__(self, zip_file, allow_unnamed=True, allow_duplicates=True):
111         super(PersistentSharedVariableID, self).__init__(zip_file)
112         self.name_counter = defaultdict(int)
113         self.ndarray_names = {}
114         self.allow_unnamed = allow_unnamed
115         self.allow_duplicates = allow_duplicates
116     def _resolve_name(self, obj):
117         if id(obj) in self.ndarray_names:
118             name = self.ndarray_names[id(obj)]
119             count = self.name_counter[name]
120             self.name_counter[name] += 1
121             if count:
122                 if not self.allow_duplicates:
123                     raise ValueError("multiple shared variables with the name "
124                                      "`{0}` found".format(name))
125                 name = '{0}_{1}'.format(name, count + 1)
126             return name
127         return super(PersistentSharedVariableID, self)._resolve_name(obj)
128     def __call__(self, obj):
129         if isinstance(obj, SharedVariable):
130             if obj.name:
131                 if obj.name == 'pkl':
132                     ValueError("can't pickle shared variable with name `pkl`")
133                 self.ndarray_names[id(obj.container.storage[0])] = obj.name
134             elif not self.allow_unnamed:
135                 raise ValueError("unnamed shared variable, {0}".format(obj))
136         return super(PersistentSharedVariableID, self).__call__(obj)
137 class PersistentNdarrayLoad(object):
138     def __init__(self, zip_file):
139         self.zip_file = zip_file
140         self.cache = {}
141     def __call__(self, persid):
142         from theano.gpuarray.type import get_context
143         from theano.gpuarray import pygpu
144         array_type, name = persid.split('.')
145         if name in self.cache:
146             return self.cache[name]
147         ret = None
148         if array_type == 'gpuarray':
149             with self.zip_file.open(name) as f:
150                 ctx_name = pickle.load(f)
151                 array = np.lib.format.read_array(f)
152             if config.experimental.unpickle_gpu_on_cpu:
153                 warnings.warn("config.experimental.unpickle_gpu_on_cpu is set "
154                               "to True. Unpickling GpuArray as numpy.ndarray")
155                 ret = array
156             elif pygpu:
157                 ret = pygpu.array(array, context=get_context(ctx_name))
158             else:
159                 raise ImportError("pygpu not found. Cannot unpickle GpuArray")
160         else:
161             with self.zip_file.open(name) as f:
162                 ret = np.lib.format.read_array(f)
163         self.cache[name] = ret
164         return ret
165 def dump(obj, file_handler, protocol=DEFAULT_PROTOCOL,
166          persistent_id=PersistentSharedVariableID):
167     with closing(zipfile.ZipFile(file_handler, 'w', zipfile.ZIP_DEFLATED,
168                                  allowZip64=True)) as zip_file:
169         def func(f):
170             p = pickle.Pickler(f, protocol=protocol)
171             p.persistent_id = persistent_id(zip_file)
172             p.dump(obj)
173         zipadd(func, zip_file, 'pkl')
174 def load(f, persistent_load=PersistentNdarrayLoad):
175     with closing(zipfile.ZipFile(f, 'r')) as zip_file:
176         p = pickle.Unpickler(BytesIO(zip_file.open('pkl').read()))
177         p.persistent_load = persistent_load(zip_file)
178         return p.load()
179 def zipadd(func, zip_file, name):
180     with tempfile.NamedTemporaryFile('wb', delete=False) as temp_file:
181         func(temp_file)
182         temp_file.close()
183         zip_file.write(temp_file.name, arcname=name)
184     if os.path.isfile(temp_file.name):
185         os.remove(temp_file.name)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
