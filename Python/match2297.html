<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_conv3d2d.py &amp; pkl_utils.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_conv3d2d.py &amp; pkl_utils.py
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_conv3d2d.py (3.8961039%)<th>pkl_utils.py (3.3333333%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-16)<td><a href="#" name="0">(14-28)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_conv3d2d.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, print_function, division
2 import time
3 from nose.plugins.skip import SkipTest
4 from parameterized import parameterized
5 import numpy as np
6 try:
7     from scipy import ndimage
8 except ImportError:
9     ndimage = None
10 from six.moves import xrange
11 import theano
12 from theano.gof.opt import check_stack_trace
13 from theano.tensor.nnet.conv3d2d import conv3d, get_diagonal_subtensor_view, DiagonalSubtensor, IncDiagonalSubtensor
14 import</b></font> theano.tests.unittest_tools as utt
15 def test_get_diagonal_subtensor_view(wrap=lambda a: a):
16     x = np.arange(20).reshape(5, 4).astype('float32')
17     x = wrap(x)
18     xv01 = get_diagonal_subtensor_view(x, 0, 1)
19     assert np.all(np.asarray(xv01) == [[12, 9, 6, 3], [16, 13, 10, 7]])
20     x = np.arange(24).reshape(4, 3, 2)
21     xv01 = get_diagonal_subtensor_view(x, 0, 1)
22     xv02 = get_diagonal_subtensor_view(x, 0, 2)
23     xv12 = get_diagonal_subtensor_view(x, 1, 2)
24     assert np.all(np.asarray(xv01) == [
25         [[12, 13], [8, 9], [4, 5]],
26         [[18, 19], [14, 15], [10, 11]]])
27     assert np.all(np.asarray(xv02) == [
28         [[6, 1], [8, 3], [10, 5]],
29         [[12, 7], [14, 9], [16, 11]],
30         [[18, 13], [20, 15], [22, 17]],
31         ])
32     for xi, xvi in zip(x, xv12):
33         assert np.all(xvi == get_diagonal_subtensor_view(xi, 0, 1))
34 def pyconv3d(signals, filters, border_mode='valid'):
35     Ns, Ts, C, Hs, Ws = signals.shape
36     Nf, Tf, C, Hf, Wf = filters.shape
37     if border_mode == 'full':
38         Tpad = Tf - 1
39         Hpad = Hf - 1
40         Wpad = Wf - 1
41     elif border_mode == 'half':
42         Tpad = Tf // 2
43         Hpad = Hf // 2
44         Wpad = Wf // 2
45     else:
46         Tpad = 0
47         Hpad = 0
48         Wpad = 0
49     if Tpad &gt; 0 or Hpad &gt; 0 or Wpad &gt; 0:
50         signals_padded = np.zeros((Ns, Ts + 2 * Tpad, C,
51                                    Hs + 2 * Hpad, Ws + 2 * Wpad), 'float32')
52         signals_padded[:, Tpad:(Ts + Tpad), :, Hpad:(Hs + Hpad),
53                        Wpad:(Ws + Wpad)] = signals
54         Ns, Ts, C, Hs, Ws = signals_padded.shape
55         signals = signals_padded
56     Tf2 = Tf // 2
57     Hf2 = Hf // 2
58     Wf2 = Wf // 2
59     rval = np.zeros((Ns, Ts - Tf + 1, Nf, Hs - Hf + 1, Ws - Wf + 1))
60     for ns in xrange(Ns):
61         for nf in xrange(Nf):
62             for c in xrange(C):
63                 s_i = signals[ns, :, c, :, :]
64                 f_i = filters[nf, :, c, :, :]
65                 r_i = rval[ns, :, nf, :, :]
66                 o_i = ndimage.convolve(s_i, f_i, mode='constant', cval=1)
67                 o_i_sh0 = o_i.shape[0]
68                 r_i += o_i[Tf2:o_i_sh0 - Tf2, Hf2:-Hf2, Wf2:-Wf2]
69     return rval
70 def check_diagonal_subtensor_view_traces(fn):
71     assert check_stack_trace(
72         fn, ops_to_check=(DiagonalSubtensor, IncDiagonalSubtensor))
73 @parameterized.expand(('valid', 'full', 'half'), utt.custom_name_func)
74 def test_conv3d(border_mode):
75     if ndimage is None or not theano.config.cxx:
76         raise SkipTest("conv3d2d tests need SciPy and a c++ compiler")
77     if theano.config.mode == 'FAST_COMPILE':
78         mode = theano.compile.mode.get_mode('FAST_RUN')
79     else:
80         mode = theano.compile.mode.get_default_mode()
81     shared = theano.tensor._shared
82     Ns, Ts, C, Hs, Ws = 3, 10, 3, 32, 32
83     Nf, Tf, C, Hf, Wf = 32, 5, 3, 5, 5
84     signals = np.arange(Ns * Ts * C * Hs * Ws).reshape(Ns, Ts, C, Hs, Ws).astype('float32')
85     filters = np.arange(Nf * Tf * C * Hf * Wf).reshape(Nf, Tf, C, Hf, Wf).astype('float32')
86     t0 = time.time()
87     pyres = pyconv3d(signals, filters, border_mode)
88     print(time.time() - t0)
89     s_signals = shared(signals)
90     s_filters = shared(filters)
91     s_output = shared(signals * 0)
92     out = conv3d(s_signals, s_filters,
93                  signals_shape=signals.shape,
94                  filters_shape=filters.shape,
95                  border_mode=border_mode)
96     newconv3d = theano.function([], [],
97                                 updates={s_output: out},
98                                 mode=mode)
99     check_diagonal_subtensor_view_traces(newconv3d)
100     t0 = time.time()
101     newconv3d()
102     print(time.time() - t0)
103     utt.assert_allclose(pyres, s_output.get_value(borrow=True))
104     gsignals, gfilters = theano.grad(out.sum(), [s_signals, s_filters])
105     gnewconv3d = theano.function([], [],
106                                  updates=[(s_filters, gfilters),
107                                           (s_signals, gsignals)],
108                                  mode=mode,
109                                  name='grad')
110     check_diagonal_subtensor_view_traces(gnewconv3d)
111     t0 = time.time()
112     gnewconv3d()
113     print('grad', time.time() - t0)
114     Ns, Ts, C, Hs, Ws = 3, 3, 3, 5, 5
115     Nf, Tf, C, Hf, Wf = 4, 2, 3, 2, 2
116     signals = np.random.rand(Ns, Ts, C, Hs, Ws).astype('float32')
117     filters = np.random.rand(Nf, Tf, C, Hf, Wf).astype('float32')
118     utt.verify_grad(lambda s, f: conv3d(s, f, border_mode=border_mode),
119                     [signals, filters], eps=1e-1, mode=mode)
120     Ns, Ts, C, Hs, Ws = 3, 10, 3, 32, 32
121     Nf, Tf, C, Hf, Wf = 32, 1, 3, 5, 5
122     signals = np.arange(Ns * Ts * C * Hs * Ws).reshape(Ns, Ts, C, Hs, Ws).astype('float32')
123     filters = np.arange(Nf * Tf * C * Hf * Wf).reshape(Nf, Tf, C, Hf, Wf).astype('float32')
124     t0 = time.time()
125     pyres = pyconv3d(signals, filters, border_mode)
126     print(time.time() - t0)
127     s_signals = shared(signals)
128     s_filters = shared(filters)
129     s_output = shared(signals * 0)
130     out = conv3d(s_signals, s_filters,
131                  signals_shape=signals.shape,
132                  filters_shape=filters.shape,
133                  border_mode=border_mode)
134     newconv3d = theano.function([], [],
135                                 updates={s_output: out},
136                                 mode=mode)
137     t0 = time.time()
138     newconv3d()
139     print(time.time() - t0)
140     utt.assert_allclose(pyres, s_output.get_value(borrow=True))
141     gsignals, gfilters = theano.grad(out.sum(), [s_signals, s_filters])
142     gnewconv3d = theano.function([], [],
143                                  updates=[(s_filters, gfilters),
144                                           (s_signals, gsignals)],
145                                  mode=mode,
146                                  name='grad')
147     t0 = time.time()
148     gnewconv3d()
149     print('grad', time.time() - t0)
150     Ns, Ts, C, Hs, Ws = 3, 3, 3, 5, 5
151     Nf, Tf, C, Hf, Wf = 4, 1, 3, 2, 2
152     signals = np.random.rand(Ns, Ts, C, Hs, Ws).astype('float32')
153     filters = np.random.rand(Nf, Tf, C, Hf, Wf).astype('float32')
154     utt.verify_grad(lambda s, f: conv3d(s, f, border_mode=border_mode),
155                     [signals, filters], eps=1e-1, mode=mode)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pkl_utils.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, print_function, division
2 import numpy as np
3 import os
4 import pickle
5 <a name="0"></a>import sys
6 import tempfile
7 import zipfile
8 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import warnings
9 from collections import defaultdict
10 from contextlib import closing
11 from pickle import HIGHEST_PROTOCOL
12 from six import BytesIO
13 try:
14     from pickle import DEFAULT_PROTOCOL
15 except ImportError:
16     DEFAULT_PROTOCOL = HIGHEST_PROTOCOL
17 import theano
18 from theano import config
19 from theano.compat import PY3
20 from six import string_types
21 from</b></font> theano.compile.sharedvalue import SharedVariable
22 __docformat__ = "restructuredtext en"
23 __authors__ = "Pascal Lamblin"
24 __copyright__ = "Copyright 2013, Universite de Montreal"
25 __license__ = "3-clause BSD"
26 min_recursion = 3000
27 if sys.getrecursionlimit() &lt; min_recursion:
28     sys.setrecursionlimit(min_recursion)
29 Pickler = pickle.Pickler
30 class StripPickler(Pickler):
31     def __init__(self, file, protocol=0, extra_tag_to_remove=None):
32         Pickler.__init__(self, file, protocol)
33         self.tag_to_remove = ['trace', 'test_value']
34         if extra_tag_to_remove:
35             self.tag_to_remove.extend(extra_tag_to_remove)
36     def save(self, obj):
37         if isinstance(obj, theano.gof.utils.scratchpad):
38             for tag in self.tag_to_remove:
39                 if hasattr(obj, tag):
40                     del obj.__dict__[tag]
41         elif (isinstance(obj, theano.tensor.Elemwise)):
42             if '__doc__' in obj.__dict__:
43                 del obj.__dict__['__doc__']
44         return Pickler.save(self, obj)
45 def load_reduce(self):
46     stack = self.stack
47     args = stack.pop()
48     func = stack[-1]
49     try:
50         value = func(*args)
51     except Exception:
52         if self.encoding is not None:
53             new_args = []
54             for arg in args:
55                 if isinstance(arg, string_types):
56                     new_args.append(arg.encode(self.encoding))
57                 else:
58                     new_args.append(arg)
59             args = tuple(new_args)
60             try:
61                 stack[-1] = func(*args)
62                 return
63             except Exception:
64                 pass
65         raise
66     stack[-1] = value
67 if PY3:
68     class CompatUnpickler(pickle._Unpickler):
69         pass
70     CompatUnpickler.dispatch[pickle.REDUCE[0]] = load_reduce
71 else:
72     class CompatUnpickler(pickle.Unpickler):
73         pass
74 class PersistentNdarrayID(object):
75     def __init__(self, zip_file):
76         self.zip_file = zip_file
77         self.count = 0
78         self.seen = {}
79     def _resolve_name(self, obj):
80         name = 'array_{0}'.format(self.count)
81         self.count += 1
82         return name
83     def __call__(self, obj):
84         if type(obj) is np.ndarray:
85             if id(obj) not in self.seen:
86                 def write_array(f):
87                     np.lib.format.write_array(f, obj)
88                 name = self._resolve_name(obj)
89                 zipadd(write_array, self.zip_file, name)
90                 self.seen[id(obj)] = 'ndarray.{0}'.format(name)
91             return self.seen[id(obj)]
92 class PersistentGpuArrayID(PersistentNdarrayID):
93     def __call__(self, obj):
94         from theano.gpuarray.type import _name_for_ctx
95         try:
96             import pygpu
97         except ImportError:
98             pygpu = None
99         if (pygpu and
100                 isinstance(obj, pygpu.gpuarray.GpuArray)):
101             if id(obj) not in self.seen:
102                 def write_array(f):
103                     pickle.dump(_name_for_ctx(obj.context), f, 2)
104                     np.lib.format.write_array(f, np.asarray(obj))
105                 name = self._resolve_name(obj)
106                 zipadd(write_array, self.zip_file, name)
107                 self.seen[id(obj)] = 'gpuarray.{0}'.format(name)
108             return self.seen[id(obj)]
109         return super(PersistentGpuArrayID, self).__call__(obj)
110 class PersistentSharedVariableID(PersistentGpuArrayID):
111     def __init__(self, zip_file, allow_unnamed=True, allow_duplicates=True):
112         super(PersistentSharedVariableID, self).__init__(zip_file)
113         self.name_counter = defaultdict(int)
114         self.ndarray_names = {}
115         self.allow_unnamed = allow_unnamed
116         self.allow_duplicates = allow_duplicates
117     def _resolve_name(self, obj):
118         if id(obj) in self.ndarray_names:
119             name = self.ndarray_names[id(obj)]
120             count = self.name_counter[name]
121             self.name_counter[name] += 1
122             if count:
123                 if not self.allow_duplicates:
124                     raise ValueError("multiple shared variables with the name "
125                                      "`{0}` found".format(name))
126                 name = '{0}_{1}'.format(name, count + 1)
127             return name
128         return super(PersistentSharedVariableID, self)._resolve_name(obj)
129     def __call__(self, obj):
130         if isinstance(obj, SharedVariable):
131             if obj.name:
132                 if obj.name == 'pkl':
133                     ValueError("can't pickle shared variable with name `pkl`")
134                 self.ndarray_names[id(obj.container.storage[0])] = obj.name
135             elif not self.allow_unnamed:
136                 raise ValueError("unnamed shared variable, {0}".format(obj))
137         return super(PersistentSharedVariableID, self).__call__(obj)
138 class PersistentNdarrayLoad(object):
139     def __init__(self, zip_file):
140         self.zip_file = zip_file
141         self.cache = {}
142     def __call__(self, persid):
143         from theano.gpuarray.type import get_context
144         from theano.gpuarray import pygpu
145         array_type, name = persid.split('.')
146         if name in self.cache:
147             return self.cache[name]
148         ret = None
149         if array_type == 'gpuarray':
150             with self.zip_file.open(name) as f:
151                 ctx_name = pickle.load(f)
152                 array = np.lib.format.read_array(f)
153             if config.experimental.unpickle_gpu_on_cpu:
154                 warnings.warn("config.experimental.unpickle_gpu_on_cpu is set "
155                               "to True. Unpickling GpuArray as numpy.ndarray")
156                 ret = array
157             elif pygpu:
158                 ret = pygpu.array(array, context=get_context(ctx_name))
159             else:
160                 raise ImportError("pygpu not found. Cannot unpickle GpuArray")
161         else:
162             with self.zip_file.open(name) as f:
163                 ret = np.lib.format.read_array(f)
164         self.cache[name] = ret
165         return ret
166 def dump(obj, file_handler, protocol=DEFAULT_PROTOCOL,
167          persistent_id=PersistentSharedVariableID):
168     with closing(zipfile.ZipFile(file_handler, 'w', zipfile.ZIP_DEFLATED,
169                                  allowZip64=True)) as zip_file:
170         def func(f):
171             p = pickle.Pickler(f, protocol=protocol)
172             p.persistent_id = persistent_id(zip_file)
173             p.dump(obj)
174         zipadd(func, zip_file, 'pkl')
175 def load(f, persistent_load=PersistentNdarrayLoad):
176     with closing(zipfile.ZipFile(f, 'r')) as zip_file:
177         p = pickle.Unpickler(BytesIO(zip_file.open('pkl').read()))
178         p.persistent_load = persistent_load(zip_file)
179         return p.load()
180 def zipadd(func, zip_file, name):
181     with tempfile.NamedTemporaryFile('wb', delete=False) as temp_file:
182         func(temp_file)
183         temp_file.close()
184         zip_file.write(temp_file.name, arcname=name)
185     if os.path.isfile(temp_file.name):
186         os.remove(temp_file.name)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
