<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for cmdmod.py &amp; network_4.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for cmdmod.py &amp; network_4.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>cmdmod.py (2.0475562%)<th>network_4.py (1.9564531%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-49)<td><a href="#" name="0">(7-32)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(4391-4395)<td><a href="#" name="1">(819-823)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(4039-4043)<td><a href="#" name="2">(799-804)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(2838-2841)<td><a href="#" name="3">(974-977)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cmdmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import fnmatch
3 import functools
4 import glob
5 import logging
6 import os
7 import re
8 import shutil
9 <a name="0"></a>import subprocess
10 import sys
11 import tempfile
12 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import time
13 import traceback
14 import salt.grains.extra
15 import salt.utils.args
16 import salt.utils.data
17 import salt.utils.files
18 import salt.utils.json
19 import salt.utils.path
20 import salt.utils.platform
21 import salt.utils.powershell
22 import salt.utils.stringutils
23 import salt.utils.templates
24 import salt.utils.timed_subprocess
25 import salt.utils.url
26 import salt.utils.user
27 import salt.utils.versions
28 import salt.utils.vt
29 import salt.utils.win_chcp
30 import salt.utils.win_dacl
31 import salt.utils.win_reg
32 from salt.exceptions import (
33     CommandExecutionError,
34     SaltInvocationError,
35     TimedProcTimeoutError,
36 )
37 from salt.log import LOG_LEVELS
38 try:
39     import</b></font> grp
40     import pwd
41 except ImportError:
42     pass
43 if salt.utils.platform.is_windows():
44     from salt.utils.win_functions import escape_argument as _cmd_quote
45     from salt.utils.win_runas import runas as win_runas
46     HAS_WIN_RUNAS = True
47 else:
48     import shlex
49     _cmd_quote = shlex.quote
50     HAS_WIN_RUNAS = False
51 __proxyenabled__ = ["*"]
52 __virtualname__ = "cmd"
53 log = logging.getLogger(__name__)
54 DEFAULT_SHELL = salt.grains.extra.shell()["shell"]
55 def __virtual__():
56     return __virtualname__
57 def _log_cmd(cmd):
58     if isinstance(cmd, (tuple, list)):
59         return cmd[0].strip()
60     else:
61         return str(cmd).split()[0].strip()
62 def _check_cb(cb_):
63     if cb_ is not None:
64         if hasattr(cb_, "__call__"):
65             return cb_
66         else:
67             log.error("log_callback is not callable, ignoring")
68     return lambda x: x
69 def _python_shell_default(python_shell, __pub_jid):
70     try:
71         if __pub_jid and python_shell is None:
72             return True
73         elif __opts__.get("cmd_safe", True) is False and python_shell is None:
74             return True
75     except NameError:
76         pass
77     return python_shell
78 def _chroot_pids(chroot):
79     pids = []
80     for root in glob.glob("/proc/[0-9]*/root"):
81         try:
82             link = os.path.realpath(root)
83             if link.startswith(chroot):
84                 pids.append(int(os.path.basename(os.path.dirname(root))))
85         except OSError:
86             pass
87     return pids
88 def _render_cmd(cmd, cwd, template, saltenv=None, pillarenv=None, pillar_override=None):
89     if saltenv is None:
90         try:
91             saltenv = __opts__.get("saltenv", "base")
92         except NameError:
93             saltenv = "base"
94     if not template:
95         return (cmd, cwd)
96     if template not in salt.utils.templates.TEMPLATE_REGISTRY:
97         raise CommandExecutionError(
98             "Attempted to render file paths with unavailable engine {}".format(template)
99         )
100     kwargs = {}
101     kwargs["salt"] = __salt__
102     if pillarenv is not None or pillar_override is not None:
103         pillarenv = pillarenv or __opts__["pillarenv"]
104         kwargs["pillar"] = _gather_pillar(pillarenv, pillar_override)
105     else:
106         kwargs["pillar"] = __pillar__
107     kwargs["grains"] = __grains__
108     kwargs["opts"] = __opts__
109     kwargs["saltenv"] = saltenv
110     def _render(contents):
111         tmp_path_fn = salt.utils.files.mkstemp()
112         with salt.utils.files.fopen(tmp_path_fn, "w+") as fp_:
113             fp_.write(salt.utils.stringutils.to_str(contents))
114         data = salt.utils.templates.TEMPLATE_REGISTRY[template](
115             tmp_path_fn, to_str=True, **kwargs
116         )
117         salt.utils.files.safe_rm(tmp_path_fn)
118         if not data["result"]:
119             raise CommandExecutionError(
120                 "Failed to execute cmd with error: {}".format(data["data"])
121             )
122         else:
123             return data["data"]
124     cmd = _render(cmd)
125     cwd = _render(cwd)
126     return (cmd, cwd)
127 def _check_loglevel(level="info"):
128     try:
129         level = level.lower()
130         if level == "quiet":
131             return None
132         else:
133             return LOG_LEVELS[level]
134     except (AttributeError, KeyError):
135         log.error(
136             "Invalid output_loglevel '%s'. Valid levels are: %s. Falling "
137             "back to 'info'.",
138             level,
139             ", ".join(sorted(LOG_LEVELS, reverse=True)),
140         )
141         return LOG_LEVELS["info"]
142 def _parse_env(env):
143     if not env:
144         env = {}
145     if isinstance(env, list):
146         env = salt.utils.data.repack_dictlist(env)
147     if not isinstance(env, dict):
148         env = {}
149     return env
150 def _gather_pillar(pillarenv, pillar_override):
151     pillar = salt.pillar.get_pillar(
152         __opts__,
153         __grains__,
154         __opts__["id"],
155         __opts__["saltenv"],
156         pillar_override=pillar_override,
157         pillarenv=pillarenv,
158     )
159     ret = pillar.compile_pillar()
160     if pillar_override and isinstance(pillar_override, dict):
161         ret.update(pillar_override)
162     return ret
163 def _check_avail(cmd):
164     if isinstance(cmd, list):
165         cmd = " ".join([str(x) if not isinstance(x, str) else x for x in cmd])
166     bret = True
167     wret = False
168     if __salt__["config.get"]("cmd_blacklist_glob"):
169         blist = __salt__["config.get"]("cmd_blacklist_glob", [])
170         for comp in blist:
171             if fnmatch.fnmatch(cmd, comp):
172                 bret = False
173     if __salt__["config.get"]("cmd_whitelist_glob", []):
174         blist = __salt__["config.get"]("cmd_whitelist_glob", [])
175         for comp in blist:
176             if fnmatch.fnmatch(cmd, comp):
177                 wret = True
178                 break
179     else:
180         wret = True
181     return bret and wret
182 def _run(
183     cmd,
184     cwd=None,
185     stdin=None,
186     stdout=subprocess.PIPE,
187     stderr=subprocess.PIPE,
188     output_encoding=None,
189     output_loglevel="debug",
190     log_callback=None,
191     runas=None,
192     group=None,
193     shell=DEFAULT_SHELL,
194     python_shell=False,
195     env=None,
196     clean_env=False,
197     prepend_path=None,
198     rstrip=True,
199     template=None,
200     umask=None,
201     timeout=None,
202     with_communicate=True,
203     reset_system_locale=True,
204     ignore_retcode=False,
205     saltenv=None,
206     pillarenv=None,
207     pillar_override=None,
208     use_vt=False,
209     password=None,
210     bg=False,
211     encoded_cmd=False,
212     success_retcodes=None,
213     success_stdout=None,
214     success_stderr=None,
215     windows_codepage=65001,
216     **kwargs
217 ):
218     if "pillar" in kwargs and not pillar_override:
219         pillar_override = kwargs["pillar"]
220     if output_loglevel != "quiet" and _is_valid_shell(shell) is False:
221         log.warning(
222             "Attempt to run a shell command with what may be an invalid shell! "
223             "Check to ensure that the shell &lt;%s&gt; is valid for this user.",
224             shell,
225         )
226     output_loglevel = _check_loglevel(output_loglevel)
227     log_callback = _check_cb(log_callback)
228     use_sudo = False
229     if runas is None and "__context__" in globals():
230         runas = __context__.get("runas")
231     if password is None and "__context__" in globals():
232         password = __context__.get("runas_password")
233     if not cwd:
234         cwd = os.path.expanduser("~{}".format("" if not runas else runas))
235         if not os.access(cwd, os.R_OK):
236             cwd = "/"
237             if salt.utils.platform.is_windows():
238                 cwd = os.path.abspath(os.sep)
239     else:
240         cwd = str(cwd)
241     if bg:
242         ignore_retcode = True
243         use_vt = False
244     change_windows_codepage = False
245     if not salt.utils.platform.is_windows():
246         if not os.path.isfile(shell) or not os.access(shell, os.X_OK):
247             msg = "The shell {} is not available".format(shell)
248             raise CommandExecutionError(msg)
249     elif use_vt:  # Memozation so not much overhead
250         raise CommandExecutionError("VT not available on windows")
251     else:
252         if windows_codepage:
253             if not isinstance(windows_codepage, int):
254                 windows_codepage = int(windows_codepage)
255             previous_windows_codepage = salt.utils.win_chcp.get_codepage_id()
256             if windows_codepage != previous_windows_codepage:
257                 change_windows_codepage = True
258     if any(word in shell.lower().strip() for word in ["powershell", "pwsh"]):
259         if isinstance(cmd, str):
260             cmd = cmd.strip()
261         elif isinstance(cmd, list):
262             cmd = " ".join(cmd).strip()
263         cmd = cmd.replace('"', '\\"')
264         stack = traceback.extract_stack(limit=2)
265         if stack[-2][2] == "script":
266             cmd = '"{}" -NonInteractive -NoProfile -ExecutionPolicy Bypass -Command {}'.format(
267                 shell, cmd
268             )
269         elif encoded_cmd:
270             cmd = '"{}" -NonInteractive -NoProfile -EncodedCommand {}'.format(
271                 shell, cmd
272             )
273         else:
274             cmd = '"{}" -NonInteractive -NoProfile -Command "{}"'.format(shell, cmd)
275     (cmd, cwd) = _render_cmd(cmd, cwd, template, saltenv, pillarenv, pillar_override)
276     ret = {}
277     if "__pub_jid" in kwargs:
278         if not _check_avail(cmd):
279             raise CommandExecutionError(
280                 'The shell command "{}" is not permitted'.format(cmd)
281             )
282     env = _parse_env(env)
283     for bad_env_key in (x for x, y in env.items() if y is None):
284         log.error(
285             "Environment variable '%s' passed without a value. "
286             "Setting value to an empty string",
287             bad_env_key,
288         )
289         env[bad_env_key] = ""
290     if output_loglevel is not None:
291         msg = "Executing command {}{}{} {}{}in directory '{}'{}".format(
292             "'" if not isinstance(cmd, list) else "",
293             _log_cmd(cmd),
294             "'" if not isinstance(cmd, list) else "",
295             "as user '{}' ".format(runas) if runas else "",
296             "in group '{}' ".format(group) if group else "",
297             cwd,
298             ". Executing command in the background, no output will be logged."
299             if bg
300             else "",
301         )
302         log.info(log_callback(msg))
303     if runas and salt.utils.platform.is_windows():
304         if not HAS_WIN_RUNAS:
305             msg = "missing salt/utils/win_runas.py"
306             raise CommandExecutionError(msg)
307         if isinstance(cmd, (list, tuple)):
308             cmd = " ".join(cmd)
309         return win_runas(cmd, runas, password, cwd)
310     if runas and salt.utils.platform.is_darwin():
311         if isinstance(cmd, (list, tuple)):
312             cmd = " ".join(map(_cmd_quote, cmd))
313         cmd = "cd -- {dir} &amp;&amp; {{ {cmd}\n }}".format(dir=_cmd_quote(cwd), cmd=cmd)
314         try:
315             user_shell = __salt__["user.info"](runas)["shell"]
316             if re.search("bash$", user_shell):
317                 cmd = "{shell} -l -c {cmd}".format(
318                     shell=user_shell, cmd=_cmd_quote(cmd)
319                 )
320         except KeyError:
321             pass
322         cmd = "su -l {} -c {}".format(_cmd_quote(runas), _cmd_quote(cmd))
323         runas = None
324     if runas:
325         try:
326             pwd.getpwnam(runas)
327         except KeyError:
328             raise CommandExecutionError("User '{}' is not available".format(runas))
329     if group:
330         if salt.utils.platform.is_windows():
331             msg = "group is not currently available on Windows"
332             raise SaltInvocationError(msg)
333         if not which_bin(["sudo"]):
334             msg = "group argument requires sudo but not found"
335             raise CommandExecutionError(msg)
336         try:
337             grp.getgrnam(group)
338         except KeyError:
339             raise CommandExecutionError("Group '{}' is not available".format(runas))
340         else:
341             use_sudo = True
342     if runas or group:
343         try:
344             import uuid
345             marker = "&lt;&lt;&lt;" + str(uuid.uuid4()) + "&gt;&gt;&gt;"
346             marker_b = marker.encode(__salt_system_encoding__)
347             py_code = (
348                 "import sys, os, itertools; sys.stdout.write('{0}'); "
349                 "sys.stdout.write('\\0'.join(itertools.chain(*os.environ.items()))); "
350                 "sys.stdout.write('{0}');".format(marker)
351             )
352             if use_sudo:
353                 env_cmd = ["sudo"]
354                 if runas:
355                     env_cmd.extend(["-u", runas])
356                 if group:
357                     env_cmd.extend(["-g", group])
358                 if shell != DEFAULT_SHELL:
359                     env_cmd.extend(["-s", "--", shell, "-c"])
360                 else:
361                     env_cmd.extend(["-i", "--"])
362                 env_cmd.extend([sys.executable])
363             elif __grains__["os"] in ["FreeBSD"]:
364                 env_cmd = (
365                     "su",
366                     "-",
367                     runas,
368                     "-c",
369                     "{} -c {}".format(shell, sys.executable),
370                 )
371             elif __grains__["os_family"] in ["Solaris"]:
372                 env_cmd = ("su", "-", runas, "-c", sys.executable)
373             elif __grains__["os_family"] in ["AIX"]:
374                 env_cmd = ("su", "-", runas, "-c", sys.executable)
375             else:
376                 env_cmd = ("su", "-s", shell, "-", runas, "-c", sys.executable)
377             msg = "env command: {}".format(env_cmd)
378             log.debug(log_callback(msg))
379             env_bytes, env_encoded_err = subprocess.Popen(
380                 env_cmd,
381                 stderr=subprocess.PIPE,
382                 stdout=subprocess.PIPE,
383                 stdin=subprocess.PIPE,
384             ).communicate(salt.utils.stringutils.to_bytes(py_code))
385             marker_count = env_bytes.count(marker_b)
386             if marker_count == 0:
387                 log.error(
388                     "Environment could not be retrieved for user '%s': "
389                     "stderr=%r stdout=%r",
390                     runas,
391                     env_encoded_err,
392                     env_bytes,
393                 )
394                 env_bytes = b""
395             elif marker_count != 2:
396                 raise CommandExecutionError(
397                     "Environment could not be retrieved for user '{}'",
398                     info={"stderr": repr(env_encoded_err), "stdout": repr(env_bytes)},
399                 )
400             else:
401                 env_bytes = env_bytes.split(marker_b)[1]
402             env_runas = dict(list(zip(*[iter(env_bytes.split(b"\0"))] * 2)))
403             env_runas = {
404                 salt.utils.stringutils.to_str(k): salt.utils.stringutils.to_str(v)
405                 for k, v in env_runas.items()
406             }
407             env_runas.update(env)
408             if env_runas.get("USER") != runas:
409                 env_runas["USER"] = runas
410             runas_home = os.path.expanduser("~{}".format(runas))
411             if env_runas.get("HOME") != runas_home:
412                 env_runas["HOME"] = runas_home
413             env = env_runas
414         except ValueError as exc:
415             log.exception("Error raised retrieving environment for user %s", runas)
416             raise CommandExecutionError(
417                 "Environment could not be retrieved for user '{}': {}".format(
418                     runas, exc
419                 )
420             )
421     if reset_system_locale is True:
422         if not salt.utils.platform.is_windows():
423             env.setdefault("LC_CTYPE", "C")
424             env.setdefault("LC_NUMERIC", "C")
425             env.setdefault("LC_TIME", "C")
426             env.setdefault("LC_COLLATE", "C")
427             env.setdefault("LC_MONETARY", "C")
428             env.setdefault("LC_MESSAGES", "C")
429             env.setdefault("LC_PAPER", "C")
430             env.setdefault("LC_NAME", "C")
431             env.setdefault("LC_ADDRESS", "C")
432             env.setdefault("LC_TELEPHONE", "C")
433             env.setdefault("LC_MEASUREMENT", "C")
434             env.setdefault("LC_IDENTIFICATION", "C")
435             env.setdefault("LANGUAGE", "C")
436     if clean_env:
437         run_env = env
438     else:
439         if salt.utils.platform.is_windows():
440             import nt
441             run_env = nt.environ.copy()
442         else:
443             run_env = os.environ.copy()
444         run_env.update(env)
445     if prepend_path:
446         run_env["PATH"] = ":".join((prepend_path, run_env["PATH"]))
447     if "NOTIFY_SOCKET" not in env:
448         run_env.pop("NOTIFY_SOCKET", None)
449     if python_shell is None:
450         python_shell = False
451     new_kwargs = {
452         "cwd": cwd,
453         "shell": python_shell,
454         "env": run_env,
455         "stdin": str(stdin) if stdin is not None else stdin,
456         "stdout": stdout,
457         "stderr": stderr,
458         "with_communicate": with_communicate,
459         "timeout": timeout,
460         "bg": bg,
461     }
462     if "stdin_raw_newlines" in kwargs:
463         new_kwargs["stdin_raw_newlines"] = kwargs["stdin_raw_newlines"]
464     if umask is not None:
465         _umask = str(umask).lstrip("0")
466         if _umask == "":
467             msg = "Zero umask is not allowed."
468             raise CommandExecutionError(msg)
469         try:
470             _umask = int(_umask, 8)
471         except ValueError:
472             raise CommandExecutionError("Invalid umask: '{}'".format(umask))
473     else:
474         _umask = None
475     if runas or group or umask:
476         new_kwargs["preexec_fn"] = functools.partial(
477             salt.utils.user.chugid_and_umask, runas, _umask, group
478         )
479     if not salt.utils.platform.is_windows():
480         if new_kwargs["shell"] is True:
481             new_kwargs["executable"] = shell
482         if salt.utils.platform.is_freebsd() and sys.version_info &lt; (3, 9):
483             new_kwargs["close_fds"] = False
484         else:
485             new_kwargs["close_fds"] = True
486     if not os.path.isabs(cwd) or not os.path.isdir(cwd):
487         raise CommandExecutionError(
488             "Specified cwd '{}' either not absolute or does not exist".format(cwd)
489         )
490     if (
491         python_shell is not True
492         and not salt.utils.platform.is_windows()
493         and not isinstance(cmd, list)
494     ):
495         cmd = salt.utils.args.shlex_split(cmd)
496     if success_retcodes is None:
497         success_retcodes = [0]
498     else:
499         try:
500             success_retcodes = [
501                 int(i) for i in salt.utils.args.split_input(success_retcodes)
502             ]
503         except ValueError:
504             raise SaltInvocationError("success_retcodes must be a list of integers")
505     if success_stdout is None:
506         success_stdout = []
507     else:
508         success_stdout = salt.utils.args.split_input(success_stdout)
509     if success_stderr is None:
510         success_stderr = []
511     else:
512         success_stderr = salt.utils.args.split_input(success_stderr)
513     if not use_vt:
514         try:
515             if change_windows_codepage:
516                 salt.utils.win_chcp.set_codepage_id(windows_codepage)
517             try:
518                 proc = salt.utils.timed_subprocess.TimedProc(cmd, **new_kwargs)
519             except OSError as exc:
520                 msg = "Unable to run command '{}' with the context '{}', reason: {}".format(
521                     cmd if output_loglevel is not None else "REDACTED",
522                     new_kwargs,
523                     exc,
524                 )
525                 raise CommandExecutionError(msg)
526             try:
527                 proc.run()
528             except TimedProcTimeoutError as exc:
529                 ret["stdout"] = str(exc)
530                 ret["stderr"] = ""
531                 ret["retcode"] = None
532                 ret["pid"] = proc.process.pid
533                 ret["retcode"] = 1
534                 return ret
535         finally:
536             if change_windows_codepage:
537                 salt.utils.win_chcp.set_codepage_id(previous_windows_codepage)
538         if output_loglevel != "quiet" and output_encoding is not None:
539             log.debug(
540                 "Decoding output from command %s using %s encoding",
541                 cmd,
542                 output_encoding,
543             )
544         try:
545             out = salt.utils.stringutils.to_unicode(
546                 proc.stdout, encoding=output_encoding
547             )
548         except TypeError:
549             out = ""
550         except UnicodeDecodeError:
551             out = salt.utils.stringutils.to_unicode(
552                 proc.stdout, encoding=output_encoding, errors="replace"
553             )
554             if output_loglevel != "quiet":
555                 log.error(
556                     "Failed to decode stdout from command %s, non-decodable "
557                     "characters have been replaced",
558                     _log_cmd(cmd),
559                 )
560         try:
561             err = salt.utils.stringutils.to_unicode(
562                 proc.stderr, encoding=output_encoding
563             )
564         except TypeError:
565             err = ""
566         except UnicodeDecodeError:
567             err = salt.utils.stringutils.to_unicode(
568                 proc.stderr, encoding=output_encoding, errors="replace"
569             )
570             if output_loglevel != "quiet":
571                 log.error(
572                     "Failed to decode stderr from command %s, non-decodable "
573                     "characters have been replaced",
574                     _log_cmd(cmd),
575                 )
576         if rstrip:
577             if out is not None:
578                 out = out.rstrip()
579             if err is not None:
580                 err = err.rstrip()
581         ret["pid"] = proc.process.pid
582         ret["retcode"] = proc.process.returncode
583         if ret["retcode"] in success_retcodes:
584             ret["retcode"] = 0
585         ret["stdout"] = out
586         ret["stderr"] = err
587         if any(
588             [stdo in ret["stdout"] for stdo in success_stdout]
589             + [stde in ret["stderr"] for stde in success_stderr]
590         ):
591             ret["retcode"] = 0
592     else:
593         formatted_timeout = ""
594         if timeout:
595             formatted_timeout = " (timeout: {}s)".format(timeout)
596         if output_loglevel is not None:
597             msg = "Running {} in VT{}".format(cmd, formatted_timeout)
598             log.debug(log_callback(msg))
599         stdout, stderr = "", ""
600         now = time.time()
601         if timeout:
602             will_timeout = now + timeout
603         else:
604             will_timeout = -1
605         try:
606             proc = salt.utils.vt.Terminal(
607                 cmd,
608                 shell=True,
609                 log_stdout=True,
610                 log_stderr=True,
611                 cwd=cwd,
612                 preexec_fn=new_kwargs.get("preexec_fn", None),
613                 env=run_env,
614                 log_stdin_level=output_loglevel,
615                 log_stdout_level=output_loglevel,
616                 log_stderr_level=output_loglevel,
617                 stream_stdout=True,
618                 stream_stderr=True,
619             )
620             ret["pid"] = proc.pid
621             while proc.has_unread_data:
622                 try:
623                     try:
624                         time.sleep(0.5)
625                         try:
626                             cstdout, cstderr = proc.recv()
627                         except OSError:
628                             cstdout, cstderr = "", ""
629                         if cstdout:
630                             stdout += cstdout
631                         else:
632                             stdout = ""
633                         if cstderr:
634                             stderr += cstderr
635                         else:
636                             stderr = ""
637                         if timeout and (time.time() &gt; will_timeout):
638                             ret["stderr"] = "SALT: Timeout after {}s\n{}".format(
639                                 timeout, stderr
640                             )
641                             ret["retcode"] = None
642                             break
643                     except KeyboardInterrupt:
644                         ret["stderr"] = "SALT: User break\n{}".format(stderr)
645                         ret["retcode"] = 1
646                         break
647                 except salt.utils.vt.TerminalException as exc:
648                     log.error("VT: %s", exc, exc_info_on_loglevel=logging.DEBUG)
649                     ret = {"retcode": 1, "pid": "2"}
650                     break
651                 ret["stdout"] = stdout
652                 if not proc.isalive():
653                     ret["stderr"] = stderr
654                     ret["retcode"] = proc.exitstatus
655                     if ret["retcode"] in success_retcodes:
656                         ret["retcode"] = 0
657                     if any(
658                         [stdo in ret["stdout"] for stdo in success_stdout]
659                         + [stde in ret["stderr"] for stde in success_stderr]
660                     ):
661                         ret["retcode"] = 0
662                 ret["pid"] = proc.pid
663         finally:
664             proc.close(terminate=True, kill=True)
665     try:
666         if ignore_retcode:
667             __context__["retcode"] = 0
668         else:
669             __context__["retcode"] = ret["retcode"]
670     except NameError:
671         pass
672     if output_loglevel is not None:
673         if not ignore_retcode and ret["retcode"] != 0:
674             if output_loglevel &lt; LOG_LEVELS["error"]:
675                 output_loglevel = LOG_LEVELS["error"]
676             msg = "Command '{}' failed with return code: {}".format(
677                 _log_cmd(cmd), ret["retcode"]
678             )
679             log.error(log_callback(msg))
680         if ret["stdout"]:
681             log.log(output_loglevel, "stdout: %s", log_callback(ret["stdout"]))
682         if ret["stderr"]:
683             log.log(output_loglevel, "stderr: %s", log_callback(ret["stderr"]))
684         if ret["retcode"]:
685             log.log(output_loglevel, "retcode: %s", ret["retcode"])
686     return ret
687 def _run_quiet(
688     cmd,
689     cwd=None,
690     stdin=None,
691     output_encoding=None,
692     runas=None,
693     shell=DEFAULT_SHELL,
694     python_shell=False,
695     env=None,
696     template=None,
697     umask=None,
698     timeout=None,
699     reset_system_locale=True,
700     saltenv=None,
701     pillarenv=None,
702     pillar_override=None,
703     success_retcodes=None,
704     success_stdout=None,
705     success_stderr=None,
706 ):
707     return _run(
708         cmd,
709         runas=runas,
710         cwd=cwd,
711         stdin=stdin,
712         stderr=subprocess.STDOUT,
713         output_encoding=output_encoding,
714         output_loglevel="quiet",
715         log_callback=None,
716         shell=shell,
717         python_shell=python_shell,
718         env=env,
719         template=template,
720         umask=umask,
721         timeout=timeout,
722         reset_system_locale=reset_system_locale,
723         saltenv=saltenv,
724         pillarenv=pillarenv,
725         pillar_override=pillar_override,
726         success_retcodes=success_retcodes,
727         success_stdout=success_stdout,
728         success_stderr=success_stderr,
729     )["stdout"]
730 def _run_all_quiet(
731     cmd,
732     cwd=None,
733     stdin=None,
734     runas=None,
735     shell=DEFAULT_SHELL,
736     python_shell=False,
737     env=None,
738     template=None,
739     umask=None,
740     timeout=None,
741     reset_system_locale=True,
742     saltenv=None,
743     pillarenv=None,
744     pillar_override=None,
745     output_encoding=None,
746     success_retcodes=None,
747     success_stdout=None,
748     success_stderr=None,
749 ):
750     return _run(
751         cmd,
752         runas=runas,
753         cwd=cwd,
754         stdin=stdin,
755         shell=shell,
756         python_shell=python_shell,
757         env=env,
758         output_encoding=output_encoding,
759         output_loglevel="quiet",
760         log_callback=None,
761         template=template,
762         umask=umask,
763         timeout=timeout,
764         reset_system_locale=reset_system_locale,
765         saltenv=saltenv,
766         pillarenv=pillarenv,
767         pillar_override=pillar_override,
768         success_retcodes=success_retcodes,
769         success_stdout=success_stdout,
770         success_stderr=success_stderr,
771     )
772 def run(
773     cmd,
774     cwd=None,
775     stdin=None,
776     runas=None,
777     group=None,
778     shell=DEFAULT_SHELL,
779     python_shell=None,
780     env=None,
781     clean_env=False,
782     template=None,
783     rstrip=True,
784     umask=None,
785     output_encoding=None,
786     output_loglevel="debug",
787     log_callback=None,
788     hide_output=False,
789     timeout=None,
790     reset_system_locale=True,
791     ignore_retcode=False,
792     saltenv=None,
793     use_vt=False,
794     bg=False,
795     password=None,
796     encoded_cmd=False,
797     raise_err=False,
798     prepend_path=None,
799     success_retcodes=None,
800     success_stdout=None,
801     success_stderr=None,
802     **kwargs
803 ):
804     r"""
805     Execute the passed command and return the output as a string
806     :param str cmd: The command to run. ex: ``ls -lart /home``
807     :param str cwd: The directory from which to execute the command. Defaults
808         to the home directory of the user specified by ``runas`` (or the user
809         under which Salt is running if ``runas`` is not specified).
810     :param str stdin: A string of standard input can be specified for the
811         command to be run using the ``stdin`` parameter. This can be useful in
812         cases where sensitive information must be read from standard input.
813     :param str runas: Specify an alternate user to run the command. The default
814         behavior is to run as the user under which Salt is running.
815         .. warning::
816             For versions 2018.3.3 and above on macosx while using runas,
817             on linux while using run, to pass special characters to the
818             command you need to escape the characters on the shell.
819             Example:
820             .. code-block:: bash
821                 cmd.run 'echo '\''h=\"baz\"'\''' runas=macuser
822     :param str group: Group to run command as. Not currently supported
823         on Windows.
824     :param str password: Windows only. Required when specifying ``runas``. This
825         parameter will be ignored on non-Windows platforms.
826         .. versionadded:: 2016.3.0
827     :param str shell: Specify an alternate shell. Defaults to the system's
828         default shell.
829     :param bool python_shell: If ``False``, let python handle the positional
830         arguments. Set to ``True`` to use shell features, such as pipes or
831         redirection.
832     :param bool bg: If ``True``, run command in background and do not await or
833         deliver its results
834         .. versionadded:: 2016.3.0
835     :param dict env: Environment variables to be set prior to execution.
836         .. note::
837             When passing environment variables on the CLI, they should be
838             passed as the string representation of a dictionary.
839             .. code-block:: bash
840                 salt myminion cmd.run 'some command' env='{"FOO": "bar"}'
841         .. note::
842             When using environment variables on Window's, case-sensitivity
843             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
844             systems.
845     :param bool clean_env: Attempt to clean out all other shell environment
846         variables and set only those provided in the 'env' argument to this
847         function.
848     :param str prepend_path: $PATH segment to prepend (trailing ':' not
849         necessary) to $PATH
850         .. versionadded:: 2018.3.0
851     :param str template: If this setting is applied then the named templating
852         engine will be used to render the downloaded file. Currently jinja,
853         mako, and wempy are supported.
854     :param bool rstrip: Strip all whitespace off the end of output before it is
855         returned.
856     :param str umask: The umask (in octal) to use when running the command.
857     :param str output_encoding: Control the encoding used to decode the
858         command's output.
859         .. note::
860             This should not need to be used in most cases. By default, Salt
861             will try to use the encoding detected from the system locale, and
862             will fall back to UTF-8 if this fails. This should only need to be
863             used in cases where the output of the command is encoded in
864             something other than the system locale or UTF-8.
865             To see the encoding Salt has detected from the system locale, check
866             the `locale` line in the output of :py:func:`test.versions_report
867             &lt;salt.modules.test.versions_report&gt;`.
868         .. versionadded:: 2018.3.0
869     :param str output_loglevel: Control the loglevel at which the output from
870         the command is logged to the minion log.
871         .. note::
872             The command being run will still be logged at the ``debug``
873             loglevel regardless, unless ``quiet`` is used for this value.
874     :param bool ignore_retcode: If the exit code of the command is nonzero,
875         this is treated as an error condition, and the output from the command
876         will be logged to the minion log. However, there are some cases where
877         programs use the return code for signaling and a nonzero exit code
878         doesn't necessarily mean failure. Pass this argument as ``True`` to
879         skip logging the output if the command has a nonzero exit code.
880     :param bool hide_output: If ``True``, suppress stdout and stderr in the
881         return data.
882         .. note::
883             This is separate from ``output_loglevel``, which only handles how
884             Salt logs to the minion log.
885         .. versionadded:: 2018.3.0
886     :param int timeout: A timeout in seconds for the executed process to return.
887     :param bool use_vt: Use VT utils (saltstack) to stream the command output
888         more interactively to the console and the logs. This is experimental.
889     :param bool encoded_cmd: Specify if the supplied command is encoded.
890         Only applies to shell 'powershell' and 'pwsh'.
891         .. versionadded:: 2018.3.0
892         Older versions of powershell seem to return raw xml data in the return.
893         To avoid raw xml data in the return, prepend your command with the
894         following before encoding:
895         `$ProgressPreference='SilentlyContinue'; &lt;your command&gt;`
896         The following powershell code block will encode the `Write-Output`
897         command so that it will not have the raw xml data in the return:
898         .. code-block:: powershell
899             $Command = '$ProgressPreference="SilentlyContinue"; Write-Output "hello"'
900             $Encoded = [convert]::ToBase64String([System.Text.encoding]::Unicode.GetBytes($command))
901             Write-Output $Encoded
902     :param bool raise_err: If ``True`` and the command has a nonzero exit code,
903         a CommandExecutionError exception will be raised.
904     .. warning::
905         This function does not process commands through a shell
906         unless the python_shell flag is set to True. This means that any
907         shell-specific functionality such as 'echo' or the use of pipes,
908         redirection or &amp;&amp;, should either be migrated to cmd.shell or
909         have the python_shell=True flag set here.
910         The use of python_shell=True means that the shell will accept _any_ input
911         including potentially malicious commands such as 'good_command;rm -rf /'.
912         Be absolutely certain that you have sanitized your input prior to using
913         python_shell=True
914     :param list success_retcodes: This parameter will allow a list of
915         non-zero return codes that should be considered a success.  If the
916         return code returned from the run matches any in the provided list,
917         the return code will be overridden with zero.
918       .. versionadded:: 2019.2.0
919     :param list success_stdout: This parameter will allow a list of
920         strings that when found in standard out should be considered a success.
921         If stdout returned from the run matches any in the provided list,
922         the return code will be overridden with zero.
923       .. versionadded:: 3004
924     :param list success_stderr: This parameter will allow a list of
925         strings that when found in standard error should be considered a success.
926         If stderr returned from the run matches any in the provided list,
927         the return code will be overridden with zero.
928       .. versionadded:: 3004
929     :param bool stdin_raw_newlines: False
930         If ``True``, Salt will not automatically convert the characters ``\\n``
931         present in the ``stdin`` value to newlines.
932       .. versionadded:: 2019.2.0
933     :param int windows_codepage: 65001
934         Only applies to Windows: the minion uses `C:\Windows\System32\chcp.com` to
935         verify or set the code page before the command `cmd` is executed.
936         Code page 65001 corresponds with UTF-8 and allows international localization of Windows.
937       .. versionadded:: 3002
938     CLI Example:
939     .. code-block:: bash
940         salt '*' cmd.run "ls -l | awk '/foo/{print \\$2}'"
941     The template arg can be set to 'jinja' or another supported template
942     engine to render the command arguments before execution.
943     For example:
944     .. code-block:: bash
945         salt '*' cmd.run template=jinja "ls -l /tmp/{{grains.id}} | awk '/foo/{print \\$2}'"
946     Specify an alternate shell with the shell parameter:
947     .. code-block:: bash
948         salt '*' cmd.run "Get-ChildItem C:\\ " shell='powershell'
949     A string of standard input can be specified for the command to be run using
950     the ``stdin`` parameter. This can be useful in cases where sensitive
951     information must be read from standard input.
952     .. code-block:: bash
953         salt '*' cmd.run "grep f" stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'
954     If an equal sign (``=``) appears in an argument to a Salt command it is
955     interpreted as a keyword argument in the format ``key=val``. That
956     processing can be bypassed in order to pass an equal sign through to the
957     remote shell command by manually specifying the kwarg:
958     .. code-block:: bash
959         salt '*' cmd.run cmd='sed -e s/=/:/g'
960     Execute the passed command and return the output as a string.
961     .. versionadded:: 2015.5.0
962     :param str cmd: The command to run. ex: ``ls -lart /home``
963     :param str cwd: The directory from which to execute the command. Defaults
964         to the home directory of the user specified by ``runas`` (or the user
965         under which Salt is running if ``runas`` is not specified).
966     :param str stdin: A string of standard input can be specified for the
967         command to be run using the ``stdin`` parameter. This can be useful in
968         cases where sensitive information must be read from standard input.
969     :param str runas: Specify an alternate user to run the command. The default
970         behavior is to run as the user under which Salt is running. If running
971         on a Windows minion you must also use the ``password`` argument, and
972         the target user account must be in the Administrators group.
973         .. warning::
974             For versions 2018.3.3 and above on macosx while using runas,
975             to pass special characters to the command you need to escape
976             the characters on the shell.
977             Example:
978             .. code-block:: bash
979                 cmd.shell 'echo '\\''h=\\"baz\\"'\\''' runas=macuser
980     :param str group: Group to run command as. Not currently supported
981       on Windows.
982     :param str password: Windows only. Required when specifying ``runas``. This
983         parameter will be ignored on non-Windows platforms.
984         .. versionadded:: 2016.3.0
985     :param int shell: Shell to execute under. Defaults to the system default
986         shell.
987     :param bool bg: If True, run command in background and do not await or
988         deliver its results
989     :param dict env: Environment variables to be set prior to execution.
990         .. note::
991             When passing environment variables on the CLI, they should be
992             passed as the string representation of a dictionary.
993             .. code-block:: bash
994                 salt myminion cmd.shell 'some command' env='{"FOO": "bar"}'
995         .. note::
996             When using environment variables on Window's, case-sensitivity
997             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
998             systems.
999     :param bool clean_env: Attempt to clean out all other shell environment
1000         variables and set only those provided in the 'env' argument to this
1001         function.
1002     :param str prepend_path: $PATH segment to prepend (trailing ':' not necessary)
1003         to $PATH
1004         .. versionadded:: 2018.3.0
1005     :param str template: If this setting is applied then the named templating
1006         engine will be used to render the downloaded file. Currently jinja,
1007         mako, and wempy are supported.
1008     :param bool rstrip: Strip all whitespace off the end of output before it is
1009         returned.
1010     :param str umask: The umask (in octal) to use when running the command.
1011     :param str output_encoding: Control the encoding used to decode the
1012         command's output.
1013         .. note::
1014             This should not need to be used in most cases. By default, Salt
1015             will try to use the encoding detected from the system locale, and
1016             will fall back to UTF-8 if this fails. This should only need to be
1017             used in cases where the output of the command is encoded in
1018             something other than the system locale or UTF-8.
1019             To see the encoding Salt has detected from the system locale, check
1020             the `locale` line in the output of :py:func:`test.versions_report
1021             &lt;salt.modules.test.versions_report&gt;`.
1022         .. versionadded:: 2018.3.0
1023     :param str output_loglevel: Control the loglevel at which the output from
1024         the command is logged to the minion log.
1025         .. note::
1026             The command being run will still be logged at the ``debug``
1027             loglevel regardless, unless ``quiet`` is used for this value.
1028     :param bool ignore_retcode: If the exit code of the command is nonzero,
1029         this is treated as an error condition, and the output from the command
1030         will be logged to the minion log. However, there are some cases where
1031         programs use the return code for signaling and a nonzero exit code
1032         doesn't necessarily mean failure. Pass this argument as ``True`` to
1033         skip logging the output if the command has a nonzero exit code.
1034     :param bool hide_output: If ``True``, suppress stdout and stderr in the
1035         return data.
1036         .. note::
1037             This is separate from ``output_loglevel``, which only handles how
1038             Salt logs to the minion log.
1039         .. versionadded:: 2018.3.0
1040     :param int timeout: A timeout in seconds for the executed process to
1041         return.
1042     :param bool use_vt: Use VT utils (saltstack) to stream the command output
1043         more interactively to the console and the logs. This is experimental.
1044     .. warning::
1045         This passes the cmd argument directly to the shell without any further
1046         processing! Be absolutely sure that you have properly sanitized the
1047         command passed to this function and do not use untrusted inputs.
1048     :param list success_retcodes: This parameter will allow a list of
1049         non-zero return codes that should be considered a success.  If the
1050         return code returned from the run matches any in the provided list,
1051         the return code will be overridden with zero.
1052       .. versionadded:: 2019.2.0
1053     :param list success_stdout: This parameter will allow a list of
1054         strings that when found in standard out should be considered a success.
1055         If stdout returned from the run matches any in the provided list,
1056         the return code will be overridden with zero.
1057       .. versionadded:: 3004
1058     :param list success_stderr: This parameter will allow a list of
1059         strings that when found in standard error should be considered a success.
1060         If stderr returned from the run matches any in the provided list,
1061         the return code will be overridden with zero.
1062       .. versionadded:: 3004
1063     :param bool stdin_raw_newlines: False
1064         If ``True``, Salt will not automatically convert the characters ``\\n``
1065         present in the ``stdin`` value to newlines.
1066       .. versionadded:: 2019.2.0
1067     CLI Example:
1068     .. code-block:: bash
1069         salt '*' cmd.shell "ls -l | awk '/foo/{print \\$2}'"
1070     The template arg can be set to 'jinja' or another supported template
1071     engine to render the command arguments before execution.
1072     For example:
1073     .. code-block:: bash
1074         salt '*' cmd.shell template=jinja "ls -l /tmp/{{grains.id}} | awk '/foo/{print \\$2}'"
1075     Specify an alternate shell with the shell parameter:
1076     .. code-block:: bash
1077         salt '*' cmd.shell "Get-ChildItem C:\\ " shell='powershell'
1078     A string of standard input can be specified for the command to be run using
1079     the ``stdin`` parameter. This can be useful in cases where sensitive
1080     information must be read from standard input.
1081     .. code-block:: bash
1082         salt '*' cmd.shell "grep f" stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'
1083     If an equal sign (``=``) appears in an argument to a Salt command it is
1084     interpreted as a keyword argument in the format ``key=val``. That
1085     processing can be bypassed in order to pass an equal sign through to the
1086     remote shell command by manually specifying the kwarg:
1087     .. code-block:: bash
1088         salt '*' cmd.shell cmd='sed -e s/=/:/g'
1089     Execute a command, and only return the standard out
1090     :param str cmd: The command to run. ex: ``ls -lart /home``
1091     :param str cwd: The directory from which to execute the command. Defaults
1092         to the home directory of the user specified by ``runas`` (or the user
1093         under which Salt is running if ``runas`` is not specified).
1094     :param str stdin: A string of standard input can be specified for the
1095         command to be run using the ``stdin`` parameter. This can be useful in
1096         cases where sensitive information must be read from standard input.
1097     :param str runas: Specify an alternate user to run the command. The default
1098         behavior is to run as the user under which Salt is running. If running
1099         on a Windows minion you must also use the ``password`` argument, and
1100         the target user account must be in the Administrators group.
1101         .. warning::
1102             For versions 2018.3.3 and above on macosx while using runas,
1103             to pass special characters to the command you need to escape
1104             the characters on the shell.
1105             Example:
1106             .. code-block:: bash
1107                 cmd.run_stdout 'echo '\\''h=\\"baz\\"'\\''' runas=macuser
1108     :param str password: Windows only. Required when specifying ``runas``. This
1109         parameter will be ignored on non-Windows platforms.
1110         .. versionadded:: 2016.3.0
1111     :param str group: Group to run command as. Not currently supported
1112       on Windows.
1113     :param str shell: Specify an alternate shell. Defaults to the system's
1114         default shell.
1115     :param bool python_shell: If False, let python handle the positional
1116         arguments. Set to True to use shell features, such as pipes or
1117         redirection.
1118     :param dict env: Environment variables to be set prior to execution.
1119         .. note::
1120             When passing environment variables on the CLI, they should be
1121             passed as the string representation of a dictionary.
1122             .. code-block:: bash
1123                 salt myminion cmd.run_stdout 'some command' env='{"FOO": "bar"}'
1124         .. note::
1125             When using environment variables on Window's, case-sensitivity
1126             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
1127             systems.
1128     :param bool clean_env: Attempt to clean out all other shell environment
1129         variables and set only those provided in the 'env' argument to this
1130         function.
1131     :param str prepend_path: $PATH segment to prepend (trailing ':' not necessary)
1132         to $PATH
1133         .. versionadded:: 2018.3.0
1134     :param str template: If this setting is applied then the named templating
1135         engine will be used to render the downloaded file. Currently jinja,
1136         mako, and wempy are supported.
1137     :param bool rstrip: Strip all whitespace off the end of output before it is
1138         returned.
1139     :param str umask: The umask (in octal) to use when running the command.
1140     :param str output_encoding: Control the encoding used to decode the
1141         command's output.
1142         .. note::
1143             This should not need to be used in most cases. By default, Salt
1144             will try to use the encoding detected from the system locale, and
1145             will fall back to UTF-8 if this fails. This should only need to be
1146             used in cases where the output of the command is encoded in
1147             something other than the system locale or UTF-8.
1148             To see the encoding Salt has detected from the system locale, check
1149             the `locale` line in the output of :py:func:`test.versions_report
1150             &lt;salt.modules.test.versions_report&gt;`.
1151         .. versionadded:: 2018.3.0
1152     :param str output_loglevel: Control the loglevel at which the output from
1153         the command is logged to the minion log.
1154         .. note::
1155             The command being run will still be logged at the ``debug``
1156             loglevel regardless, unless ``quiet`` is used for this value.
1157     :param bool ignore_retcode: If the exit code of the command is nonzero,
1158         this is treated as an error condition, and the output from the command
1159         will be logged to the minion log. However, there are some cases where
1160         programs use the return code for signaling and a nonzero exit code
1161         doesn't necessarily mean failure. Pass this argument as ``True`` to
1162         skip logging the output if the command has a nonzero exit code.
1163     :param bool hide_output: If ``True``, suppress stdout and stderr in the
1164         return data.
1165         .. note::
1166             This is separate from ``output_loglevel``, which only handles how
1167             Salt logs to the minion log.
1168         .. versionadded:: 2018.3.0
1169     :param int timeout: A timeout in seconds for the executed process to
1170         return.
1171     :param bool use_vt: Use VT utils (saltstack) to stream the command output
1172         more interactively to the console and the logs. This is experimental.
1173     :param list success_retcodes: This parameter will allow a list of
1174         non-zero return codes that should be considered a success.  If the
1175         return code returned from the run matches any in the provided list,
1176         the return code will be overridden with zero.
1177       .. versionadded:: 2019.2.0
1178     :param list success_stdout: This parameter will allow a list of
1179         strings that when found in standard out should be considered a success.
1180         If stdout returned from the run matches any in the provided list,
1181         the return code will be overridden with zero.
1182       .. versionadded:: 3004
1183     :param list success_stderr: This parameter will allow a list of
1184         strings that when found in standard error should be considered a success.
1185         If stderr returned from the run matches any in the provided list,
1186         the return code will be overridden with zero.
1187       .. versionadded:: 3004
1188     :param bool stdin_raw_newlines: False
1189         If ``True``, Salt will not automatically convert the characters ``\\n``
1190         present in the ``stdin`` value to newlines.
1191       .. versionadded:: 2019.2.0
1192     CLI Example:
1193     .. code-block:: bash
1194         salt '*' cmd.run_stdout "ls -l | awk '/foo/{print \\$2}'"
1195     The template arg can be set to 'jinja' or another supported template
1196     engine to render the command arguments before execution.
1197     For example:
1198     .. code-block:: bash
1199         salt '*' cmd.run_stdout template=jinja "ls -l /tmp/{{grains.id}} | awk '/foo/{print \\$2}'"
1200     A string of standard input can be specified for the command to be run using
1201     the ``stdin`` parameter. This can be useful in cases where sensitive
1202     information must be read from standard input.
1203     .. code-block:: bash
1204         salt '*' cmd.run_stdout "grep f" stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'
1205     Execute a command and only return the standard error
1206     :param str cmd: The command to run. ex: ``ls -lart /home``
1207     :param str cwd: The directory from which to execute the command. Defaults
1208         to the home directory of the user specified by ``runas`` (or the user
1209         under which Salt is running if ``runas`` is not specified).
1210     :param str stdin: A string of standard input can be specified for the
1211         command to be run using the ``stdin`` parameter. This can be useful in
1212         cases where sensitive information must be read from standard input.
1213     :param str runas: Specify an alternate user to run the command. The default
1214         behavior is to run as the user under which Salt is running. If running
1215         on a Windows minion you must also use the ``password`` argument, and
1216         the target user account must be in the Administrators group.
1217         .. warning::
1218             For versions 2018.3.3 and above on macosx while using runas,
1219             to pass special characters to the command you need to escape
1220             the characters on the shell.
1221             Example:
1222             .. code-block:: bash
1223                 cmd.run_stderr 'echo '\\''h=\\"baz\\"'\\''' runas=macuser
1224     :param str password: Windows only. Required when specifying ``runas``. This
1225         parameter will be ignored on non-Windows platforms.
1226         .. versionadded:: 2016.3.0
1227     :param str group: Group to run command as. Not currently supported
1228       on Windows.
1229     :param str shell: Specify an alternate shell. Defaults to the system's
1230         default shell.
1231     :param bool python_shell: If False, let python handle the positional
1232         arguments. Set to True to use shell features, such as pipes or
1233         redirection.
1234     :param dict env: Environment variables to be set prior to execution.
1235         .. note::
1236             When passing environment variables on the CLI, they should be
1237             passed as the string representation of a dictionary.
1238             .. code-block:: bash
1239                 salt myminion cmd.run_stderr 'some command' env='{"FOO": "bar"}'
1240         .. note::
1241             When using environment variables on Window's, case-sensitivity
1242             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
1243             systems.
1244     :param bool clean_env: Attempt to clean out all other shell environment
1245         variables and set only those provided in the 'env' argument to this
1246         function.
1247     :param str prepend_path: $PATH segment to prepend (trailing ':' not
1248         necessary) to $PATH
1249         .. versionadded:: 2018.3.0
1250     :param str template: If this setting is applied then the named templating
1251         engine will be used to render the downloaded file. Currently jinja,
1252         mako, and wempy are supported.
1253     :param bool rstrip: Strip all whitespace off the end of output before it is
1254         returned.
1255     :param str umask: The umask (in octal) to use when running the command.
1256     :param str output_encoding: Control the encoding used to decode the
1257         command's output.
1258         .. note::
1259             This should not need to be used in most cases. By default, Salt
1260             will try to use the encoding detected from the system locale, and
1261             will fall back to UTF-8 if this fails. This should only need to be
1262             used in cases where the output of the command is encoded in
1263             something other than the system locale or UTF-8.
1264             To see the encoding Salt has detected from the system locale, check
1265             the `locale` line in the output of :py:func:`test.versions_report
1266             &lt;salt.modules.test.versions_report&gt;`.
1267         .. versionadded:: 2018.3.0
1268     :param str output_loglevel: Control the loglevel at which the output from
1269         the command is logged to the minion log.
1270         .. note::
1271             The command being run will still be logged at the ``debug``
1272             loglevel regardless, unless ``quiet`` is used for this value.
1273     :param bool ignore_retcode: If the exit code of the command is nonzero,
1274         this is treated as an error condition, and the output from the command
1275         will be logged to the minion log. However, there are some cases where
1276         programs use the return code for signaling and a nonzero exit code
1277         doesn't necessarily mean failure. Pass this argument as ``True`` to
1278         skip logging the output if the command has a nonzero exit code.
1279     :param bool hide_output: If ``True``, suppress stdout and stderr in the
1280         return data.
1281         .. note::
1282             This is separate from ``output_loglevel``, which only handles how
1283             Salt logs to the minion log.
1284         .. versionadded:: 2018.3.0
1285     :param int timeout: A timeout in seconds for the executed process to
1286         return.
1287     :param bool use_vt: Use VT utils (saltstack) to stream the command output
1288         more interactively to the console and the logs. This is experimental.
1289     :param list success_retcodes: This parameter will allow a list of
1290         non-zero return codes that should be considered a success.  If the
1291         return code returned from the run matches any in the provided list,
1292         the return code will be overridden with zero.
1293       .. versionadded:: 2019.2.0
1294     :param list success_stdout: This parameter will allow a list of
1295         strings that when found in standard out should be considered a success.
1296         If stdout returned from the run matches any in the provided list,
1297         the return code will be overridden with zero.
1298       .. versionadded:: 3004
1299     :param list success_stderr: This parameter will allow a list of
1300         strings that when found in standard error should be considered a success.
1301         If stderr returned from the run matches any in the provided list,
1302         the return code will be overridden with zero.
1303       .. versionadded:: 3004
1304     :param bool stdin_raw_newlines: False
1305         If ``True``, Salt will not automatically convert the characters ``\\n``
1306         present in the ``stdin`` value to newlines.
1307       .. versionadded:: 2019.2.0
1308     CLI Example:
1309     .. code-block:: bash
1310         salt '*' cmd.run_stderr "ls -l | awk '/foo/{print \\$2}'"
1311     The template arg can be set to 'jinja' or another supported template
1312     engine to render the command arguments before execution.
1313     For example:
1314     .. code-block:: bash
1315         salt '*' cmd.run_stderr template=jinja "ls -l /tmp/{{grains.id}} | awk '/foo/{print \\$2}'"
1316     A string of standard input can be specified for the command to be run using
1317     the ``stdin`` parameter. This can be useful in cases where sensitive
1318     information must be read from standard input.
1319     .. code-block:: bash
1320         salt '*' cmd.run_stderr "grep f" stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'
1321     Execute the passed command and return a dict of return data
1322     :param str cmd: The command to run. ex: ``ls -lart /home``
1323     :param str cwd: The directory from which to execute the command. Defaults
1324         to the home directory of the user specified by ``runas`` (or the user
1325         under which Salt is running if ``runas`` is not specified).
1326     :param str stdin: A string of standard input can be specified for the
1327         command to be run using the ``stdin`` parameter. This can be useful in
1328         cases where sensitive information must be read from standard input.
1329     :param str runas: Specify an alternate user to run the command. The default
1330         behavior is to run as the user under which Salt is running. If running
1331         on a Windows minion you must also use the ``password`` argument, and
1332         the target user account must be in the Administrators group.
1333         .. warning::
1334             For versions 2018.3.3 and above on macosx while using runas,
1335             to pass special characters to the command you need to escape
1336             the characters on the shell.
1337             Example:
1338             .. code-block:: bash
1339                 cmd.run_all 'echo '\\''h=\\"baz\\"'\\''' runas=macuser
1340     :param str password: Windows only. Required when specifying ``runas``. This
1341         parameter will be ignored on non-Windows platforms.
1342         .. versionadded:: 2016.3.0
1343     :param str group: Group to run command as. Not currently supported
1344       on Windows.
1345     :param str shell: Specify an alternate shell. Defaults to the system's
1346         default shell.
1347     :param bool python_shell: If False, let python handle the positional
1348         arguments. Set to True to use shell features, such as pipes or
1349         redirection.
1350     :param dict env: Environment variables to be set prior to execution.
1351         .. note::
1352             When passing environment variables on the CLI, they should be
1353             passed as the string representation of a dictionary.
1354             .. code-block:: bash
1355                 salt myminion cmd.run_all 'some command' env='{"FOO": "bar"}'
1356         .. note::
1357             When using environment variables on Window's, case-sensitivity
1358             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
1359             systems.
1360     :param bool clean_env: Attempt to clean out all other shell environment
1361         variables and set only those provided in the 'env' argument to this
1362         function.
1363     :param str prepend_path: $PATH segment to prepend (trailing ':' not
1364         necessary) to $PATH
1365         .. versionadded:: 2018.3.0
1366     :param str template: If this setting is applied then the named templating
1367         engine will be used to render the downloaded file. Currently jinja,
1368         mako, and wempy are supported.
1369     :param bool rstrip: Strip all whitespace off the end of output before it is
1370         returned.
1371     :param str umask: The umask (in octal) to use when running the command.
1372     :param str output_encoding: Control the encoding used to decode the
1373         command's output.
1374         .. note::
1375             This should not need to be used in most cases. By default, Salt
1376             will try to use the encoding detected from the system locale, and
1377             will fall back to UTF-8 if this fails. This should only need to be
1378             used in cases where the output of the command is encoded in
1379             something other than the system locale or UTF-8.
1380             To see the encoding Salt has detected from the system locale, check
1381             the `locale` line in the output of :py:func:`test.versions_report
1382             &lt;salt.modules.test.versions_report&gt;`.
1383         .. versionadded:: 2018.3.0
1384     :param str output_loglevel: Control the loglevel at which the output from
1385         the command is logged to the minion log.
1386         .. note::
1387             The command being run will still be logged at the ``debug``
1388             loglevel regardless, unless ``quiet`` is used for this value.
1389     :param bool ignore_retcode: If the exit code of the command is nonzero,
1390         this is treated as an error condition, and the output from the command
1391         will be logged to the minion log. However, there are some cases where
1392         programs use the return code for signaling and a nonzero exit code
1393         doesn't necessarily mean failure. Pass this argument as ``True`` to
1394         skip logging the output if the command has a nonzero exit code.
1395     :param bool hide_output: If ``True``, suppress stdout and stderr in the
1396         return data.
1397         .. note::
1398             This is separate from ``output_loglevel``, which only handles how
1399             Salt logs to the minion log.
1400         .. versionadded:: 2018.3.0
1401     :param int timeout: A timeout in seconds for the executed process to
1402         return.
1403     :param bool use_vt: Use VT utils (saltstack) to stream the command output
1404         more interactively to the console and the logs. This is experimental.
1405     :param bool encoded_cmd: Specify if the supplied command is encoded.
1406         Only applies to shell 'powershell' and 'pwsh'.
1407         .. versionadded:: 2018.3.0
1408         Older versions of powershell seem to return raw xml data in the return.
1409         To avoid raw xml data in the return, prepend your command with the
1410         following before encoding:
1411         `$ProgressPreference='SilentlyContinue'; &lt;your command&gt;`
1412         The following powershell code block will encode the `Write-Output`
1413         command so that it will not have the raw xml data in the return:
1414         .. code-block:: powershell
1415             $Command = '$ProgressPreference="SilentlyContinue"; Write-Output "hello"'
1416             $Encoded = [convert]::ToBase64String([System.Text.encoding]::Unicode.GetBytes($command))
1417             Write-Output $Encoded
1418     :param bool redirect_stderr: If set to ``True``, then stderr will be
1419         redirected to stdout. This is helpful for cases where obtaining both
1420         the retcode and output is desired, but it is not desired to have the
1421         output separated into both stdout and stderr.
1422         .. versionadded:: 2015.8.2
1423     :param str password: Windows only. Required when specifying ``runas``. This
1424         parameter will be ignored on non-Windows platforms.
1425           .. versionadded:: 2016.3.0
1426     :param bool bg: If ``True``, run command in background and do not await or
1427         deliver its results
1428         .. versionadded:: 2016.3.6
1429     :param list success_retcodes: This parameter will allow a list of
1430         non-zero return codes that should be considered a success.  If the
1431         return code returned from the run matches any in the provided list,
1432         the return code will be overridden with zero.
1433       .. versionadded:: 2019.2.0
1434     :param list success_stdout: This parameter will allow a list of
1435         strings that when found in standard out should be considered a success.
1436         If stdout returned from the run matches any in the provided list,
1437         the return code will be overridden with zero.
1438       .. versionadded:: 3004
1439     :param list success_stderr: This parameter will allow a list of
1440         strings that when found in standard error should be considered a success.
1441         If stderr returned from the run matches any in the provided list,
1442         the return code will be overridden with zero.
1443       .. versionadded:: 3004
1444     :param bool stdin_raw_newlines: False
1445         If ``True``, Salt will not automatically convert the characters ``\\n``
1446         present in the ``stdin`` value to newlines.
1447       .. versionadded:: 2019.2.0
1448     CLI Example:
1449     .. code-block:: bash
1450         salt '*' cmd.run_all "ls -l | awk '/foo/{print \\$2}'"
1451     The template arg can be set to 'jinja' or another supported template
1452     engine to render the command arguments before execution.
1453     For example:
1454     .. code-block:: bash
1455         salt '*' cmd.run_all template=jinja "ls -l /tmp/{{grains.id}} | awk '/foo/{print \\$2}'"
1456     A string of standard input can be specified for the command to be run using
1457     the ``stdin`` parameter. This can be useful in cases where sensitive
1458     information must be read from standard input.
1459     .. code-block:: bash
1460         salt '*' cmd.run_all "grep f" stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'
1461     Execute a shell command and return the command's return code.
1462     :param str cmd: The command to run. ex: ``ls -lart /home``
1463     :param str cwd: The directory from which to execute the command. Defaults
1464         to the home directory of the user specified by ``runas`` (or the user
1465         under which Salt is running if ``runas`` is not specified).
1466     :param str stdin: A string of standard input can be specified for the
1467         command to be run using the ``stdin`` parameter. This can be useful in
1468         cases where sensitive information must be read from standard input.
1469     :param str runas: Specify an alternate user to run the command. The default
1470         behavior is to run as the user under which Salt is running. If running
1471         on a Windows minion you must also use the ``password`` argument, and
1472         the target user account must be in the Administrators group.
1473         .. warning::
1474             For versions 2018.3.3 and above on macosx while using runas,
1475             to pass special characters to the command you need to escape
1476             the characters on the shell.
1477             Example:
1478             .. code-block:: bash
1479                 cmd.retcode 'echo '\\''h=\\"baz\\"'\\''' runas=macuser
1480     :param str password: Windows only. Required when specifying ``runas``. This
1481         parameter will be ignored on non-Windows platforms.
1482         .. versionadded:: 2016.3.0
1483     :param str group: Group to run command as. Not currently supported
1484       on Windows.
1485     :param str shell: Specify an alternate shell. Defaults to the system's
1486         default shell.
1487     :param bool python_shell: If False, let python handle the positional
1488         arguments. Set to True to use shell features, such as pipes or
1489         redirection.
1490     :param dict env: Environment variables to be set prior to execution.
1491         .. note::
1492             When passing environment variables on the CLI, they should be
1493             passed as the string representation of a dictionary.
1494             .. code-block:: bash
1495                 salt myminion cmd.retcode 'some command' env='{"FOO": "bar"}'
1496         .. note::
1497             When using environment variables on Window's, case-sensitivity
1498             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
1499             systems.
1500     :param bool clean_env: Attempt to clean out all other shell environment
1501         variables and set only those provided in the 'env' argument to this
1502         function.
1503     :param str template: If this setting is applied then the named templating
1504         engine will be used to render the downloaded file. Currently jinja,
1505         mako, and wempy are supported.
1506     :param bool rstrip: Strip all whitespace off the end of output before it is
1507         returned.
1508     :param str umask: The umask (in octal) to use when running the command.
1509     :param str output_encoding: Control the encoding used to decode the
1510         command's output.
1511         .. note::
1512             This should not need to be used in most cases. By default, Salt
1513             will try to use the encoding detected from the system locale, and
1514             will fall back to UTF-8 if this fails. This should only need to be
1515             used in cases where the output of the command is encoded in
1516             something other than the system locale or UTF-8.
1517             To see the encoding Salt has detected from the system locale, check
1518             the `locale` line in the output of :py:func:`test.versions_report
1519             &lt;salt.modules.test.versions_report&gt;`.
1520         .. versionadded:: 2018.3.0
1521     :param str output_loglevel: Control the loglevel at which the output from
1522         the command is logged to the minion log.
1523         .. note::
1524             The command being run will still be logged at the ``debug``
1525             loglevel regardless, unless ``quiet`` is used for this value.
1526     :param bool ignore_retcode: If the exit code of the command is nonzero,
1527         this is treated as an error condition, and the output from the command
1528         will be logged to the minion log. However, there are some cases where
1529         programs use the return code for signaling and a nonzero exit code
1530         doesn't necessarily mean failure. Pass this argument as ``True`` to
1531         skip logging the output if the command has a nonzero exit code.
1532     :param int timeout: A timeout in seconds for the executed process to return.
1533     :param bool use_vt: Use VT utils (saltstack) to stream the command output
1534       more interactively to the console and the logs. This is experimental.
1535     :rtype: int
1536     :rtype: None
1537     :returns: Return Code as an int or None if there was an exception.
1538     :param list success_retcodes: This parameter will allow a list of
1539         non-zero return codes that should be considered a success.  If the
1540         return code returned from the run matches any in the provided list,
1541         the return code will be overridden with zero.
1542       .. versionadded:: 2019.2.0
1543     :param list success_stdout: This parameter will allow a list of
1544         strings that when found in standard out should be considered a success.
1545         If stdout returned from the run matches any in the provided list,
1546         the return code will be overridden with zero.
1547       .. versionadded:: 3004
1548     :param list success_stderr: This parameter will allow a list of
1549         strings that when found in standard error should be considered a success.
1550         If stderr returned from the run matches any in the provided list,
1551         the return code will be overridden with zero.
1552       .. versionadded:: 3004
1553     :param bool stdin_raw_newlines: False
1554         If ``True``, Salt will not automatically convert the characters ``\\n``
1555         present in the ``stdin`` value to newlines.
1556       .. versionadded:: 2019.2.0
1557     CLI Example:
1558     .. code-block:: bash
1559         salt '*' cmd.retcode "file /bin/bash"
1560     The template arg can be set to 'jinja' or another supported template
1561     engine to render the command arguments before execution.
1562     For example:
1563     .. code-block:: bash
1564         salt '*' cmd.retcode template=jinja "file {{grains.pythonpath[0]}}/python"
1565     A string of standard input can be specified for the command to be run using
1566     the ``stdin`` parameter. This can be useful in cases where sensitive
1567     information must be read from standard input.
1568     .. code-block:: bash
1569         salt '*' cmd.retcode "grep f" stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'
1570     Helper for running commands quietly for minion startup. Returns same as
1571     the retcode() function.
1572     Download a script from a remote location and execute the script locally.
1573     The script can be located on the salt master file server or on an HTTP/FTP
1574     server.
1575     The script will be executed directly, so it can be written in any available
1576     programming language.
1577     :param str source: The location of the script to download. If the file is
1578         located on the master in the directory named spam, and is called eggs,
1579         the source string is salt://spam/eggs
1580     :param str args: String of command line args to pass to the script. Only
1581         used if no args are specified as part of the `name` argument. To pass a
1582         string containing spaces in YAML, you will need to doubly-quote it:
1583         .. code-block:: bash
1584             salt myminion cmd.script salt://foo.sh "arg1 'arg two' arg3"
1585     :param str cwd: The directory from which to execute the command. Defaults
1586         to the directory returned from Python's tempfile.mkstemp.
1587     :param str stdin: A string of standard input can be specified for the
1588         command to be run using the ``stdin`` parameter. This can be useful in
1589         cases where sensitive information must be read from standard input.
1590     :param str runas: Specify an alternate user to run the command. The default
1591         behavior is to run as the user under which Salt is running. If running
1592         on a Windows minion you must also use the ``password`` argument, and
1593         the target user account must be in the Administrators group.
1594         .. note::
1595             For Window's users, specifically Server users, it may be necessary
1596             to specify your runas user using the User Logon Name instead of the
1597             legacy logon name. Traditionally, logons would be in the following
1598             format.
1599                 ``Domain/user``
1600             In the event this causes issues when executing scripts, use the UPN
1601             format which looks like the following.
1602                 ``user@domain.local``
1603             More information &lt;https://github.com/saltstack/salt/issues/55080&gt;
1604     :param str password: Windows only. Required when specifying ``runas``. This
1605         parameter will be ignored on non-Windows platforms.
1606         .. versionadded:: 2016.3.0
1607     :param str group: Group to run script as. Not currently supported
1608       on Windows.
1609     :param str shell: Specify an alternate shell. Defaults to the system's
1610         default shell.
1611     :param bool python_shell: If False, let python handle the positional
1612         arguments. Set to True to use shell features, such as pipes or
1613         redirection.
1614     :param bool bg: If True, run script in background and do not await or
1615         deliver its results
1616     :param dict env: Environment variables to be set prior to execution.
1617         .. note::
1618             When passing environment variables on the CLI, they should be
1619             passed as the string representation of a dictionary.
1620             .. code-block:: bash
1621                 salt myminion cmd.script 'some command' env='{"FOO": "bar"}'
1622         .. note::
1623             When using environment variables on Window's, case-sensitivity
1624             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
1625             systems.
1626     :param str template: If this setting is applied then the named templating
1627         engine will be used to render the downloaded file. Currently jinja,
1628         mako, and wempy are supported.
1629     :param str umask: The umask (in octal) to use when running the command.
1630     :param str output_encoding: Control the encoding used to decode the
1631         command's output.
1632         .. note::
1633             This should not need to be used in most cases. By default, Salt
1634             will try to use the encoding detected from the system locale, and
1635             will fall back to UTF-8 if this fails. This should only need to be
1636             used in cases where the output of the command is encoded in
1637             something other than the system locale or UTF-8.
1638             To see the encoding Salt has detected from the system locale, check
1639             the `locale` line in the output of :py:func:`test.versions_report
1640             &lt;salt.modules.test.versions_report&gt;`.
1641         .. versionadded:: 2018.3.0
1642     :param str output_loglevel: Control the loglevel at which the output from
1643         the command is logged to the minion log.
1644         .. note::
1645             The command being run will still be logged at the ``debug``
1646             loglevel regardless, unless ``quiet`` is used for this value.
1647     :param bool ignore_retcode: If the exit code of the command is nonzero,
1648         this is treated as an error condition, and the output from the command
1649         will be logged to the minion log. However, there are some cases where
1650         programs use the return code for signaling and a nonzero exit code
1651         doesn't necessarily mean failure. Pass this argument as ``True`` to
1652         skip logging the output if the command has a nonzero exit code.
1653     :param bool hide_output: If ``True``, suppress stdout and stderr in the
1654         return data.
1655         .. note::
1656             This is separate from ``output_loglevel``, which only handles how
1657             Salt logs to the minion log.
1658         .. versionadded:: 2018.3.0
1659     :param int timeout: If the command has not terminated after timeout
1660         seconds, send the subprocess sigterm, and if sigterm is ignored, follow
1661         up with sigkill
1662     :param bool use_vt: Use VT utils (saltstack) to stream the command output
1663         more interactively to the console and the logs. This is experimental.
1664     :param list success_retcodes: This parameter will allow a list of
1665         non-zero return codes that should be considered a success.  If the
1666         return code returned from the run matches any in the provided list,
1667         the return code will be overridden with zero.
1668       .. versionadded:: 2019.2.0
1669     :param list success_stdout: This parameter will allow a list of
1670         strings that when found in standard out should be considered a success.
1671         If stdout returned from the run matches any in the provided list,
1672         the return code will be overridden with zero.
1673       .. versionadded:: 3004
1674     :param list success_stderr: This parameter will allow a list of
1675         strings that when found in standard error should be considered a success.
1676         If stderr returned from the run matches any in the provided list,
1677         the return code will be overridden with zero.
1678       .. versionadded:: 3004
1679     :param bool stdin_raw_newlines: False
1680         If ``True``, Salt will not automatically convert the characters ``\\n``
1681         present in the ``stdin`` value to newlines.
1682       .. versionadded:: 2019.2.0
1683     CLI Example:
1684     .. code-block:: bash
1685         salt '*' cmd.script salt://scripts/runme.sh
1686         salt '*' cmd.script salt://scripts/runme.sh 'arg1 arg2 "arg 3"'
1687         salt '*' cmd.script salt://scripts/windows_task.ps1 args=' -Input c:\\tmp\\infile.txt' shell='powershell'
1688     .. code-block:: bash
1689         salt '*' cmd.script salt://scripts/runme.sh stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'
1690             pillarenv = kwargs.get("pillarenv", __opts__<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get("pillarenv"))
1691             kwargs["pillar"] = _gather_pillar(pillarenv, kwargs.get("pillar"))
1692         fn_ = __salt__["cp.get_template"](source, path, template, saltenv, **kwargs)
1693         if</b></font> not fn_:
1694             _cleanup_tempfile(path)
1695             if win_cwd:
1696                 _cleanup_tempfile(cwd)
1697             return {
1698                 "pid": 0,
1699                 "retcode": 1,
1700                 "stdout": "",
1701                 "stderr": "",
1702                 "cache_error": True,
1703             }
1704     else:
1705         fn_ = __salt__["cp.cache_file"](source, saltenv)
1706         if not fn_:
1707             _cleanup_tempfile(path)
1708             if win_cwd:
1709                 _cleanup_tempfile(cwd)
1710             return {
1711                 "pid": 0,
1712                 "retcode": 1,
1713                 "stdout": "",
1714                 "stderr": "",
1715                 "cache_error": True,
1716             }
1717         shutil.copyfile(fn_, path)
1718     if not salt.utils.platform.is_windows():
1719         os.chmod(path, 320)
1720         os.chown(path, __salt__["file.user_to_uid"](runas), -1)
1721     if salt.utils.platform.is_windows() and shell.lower() != "powershell":
1722         cmd_path = _cmd_quote(path, escape=False)
1723     else:
1724         cmd_path = _cmd_quote(path)
1725     ret = _run(
1726         cmd_path + " " + str(args) if args else cmd_path,
1727         cwd=cwd,
1728         stdin=stdin,
1729         output_encoding=output_encoding,
1730         output_loglevel=output_loglevel,
1731         log_callback=log_callback,
1732         runas=runas,
1733         group=group,
1734         shell=shell,
1735         python_shell=python_shell,
1736         env=env,
1737         umask=umask,
1738         timeout=timeout,
1739         reset_system_locale=reset_system_locale,
1740         saltenv=saltenv,
1741         use_vt=use_vt,
1742         bg=bg,
1743         password=password,
1744         success_retcodes=success_retcodes,
1745         success_stdout=success_stdout,
1746         success_stderr=success_stderr,
1747         **kwargs
1748     )
1749     _cleanup_tempfile(path)
1750     if win_cwd:
1751         _cleanup_tempfile(cwd)
1752     if hide_output:
1753         ret["stdout"] = ret["stderr"] = ""
1754     return ret
1755 def script_retcode(
1756     source,
1757     args=None,
1758     cwd=None,
1759     stdin=None,
1760     runas=None,
1761     group=None,
1762     shell=DEFAULT_SHELL,
1763     python_shell=None,
1764     env=None,
1765     template="jinja",
1766     umask=None,
1767     timeout=None,
1768     reset_system_locale=True,
1769     saltenv=None,
1770     output_encoding=None,
1771     output_loglevel="debug",
1772     log_callback=None,
1773     use_vt=False,
1774     password=None,
1775     success_retcodes=None,
1776     success_stdout=None,
1777     success_stderr=None,
1778     **kwargs
1779 ):
1780     if "__env__" in kwargs:
1781         kwargs.pop("__env__")
1782     return script(
1783         source=source,
1784         args=args,
1785         cwd=cwd,
1786         stdin=stdin,
1787         runas=runas,
1788         group=group,
1789         shell=shell,
1790         python_shell=python_shell,
1791         env=env,
1792         template=template,
1793         umask=umask,
1794         timeout=timeout,
1795         reset_system_locale=reset_system_locale,
1796         saltenv=saltenv,
1797         output_encoding=output_encoding,
1798         output_loglevel=output_loglevel,
1799         log_callback=log_callback,
1800         use_vt=use_vt,
1801         password=password,
1802         success_retcodes=success_retcodes,
1803         success_stdout=success_stdout,
1804         success_stderr=success_stderr,
1805         **kwargs
1806     )["retcode"]
1807 def which(cmd):
1808     return salt.utils.path.which(cmd)
1809 def which_bin(cmds):
1810     return salt.utils.path.which_bin(cmds)
1811 def has_exec(cmd):
1812     return which(cmd) is not None
1813 def exec_code(lang, code, cwd=None, args=None, **kwargs):
1814     return exec_code_all(lang, code, cwd, args, **kwargs)["stdout"]
1815 def exec_code_all(lang, code, cwd=None, args=None, **kwargs):
1816     powershell = lang.lower().startswith("powershell")
1817     if powershell:
1818         codefile = salt.utils.files.mkstemp(suffix=".ps1")
1819     else:
1820         codefile = salt.utils.files.mkstemp()
1821     with salt.utils.files.fopen(codefile, "w+t", binary=False) as fp_:
1822         fp_.write(salt.utils.stringutils.to_str(code))
1823     if powershell:
1824         cmd = [lang, "-File", codefile]
1825     else:
1826         cmd = [lang, codefile]
1827     if isinstance(args, str):
1828         cmd.append(args)
1829     elif isinstance(args, list):
1830         cmd += args
1831     def _cleanup_tempfile(path):
1832         try:
1833             __salt__["file.remove"](path)
1834         except (SaltInvocationError, CommandExecutionError) as exc:
1835             log.error(
1836                 "cmd.exec_code_all: Unable to clean tempfile '%s': %s",
1837                 path,
1838                 exc,
1839                 exc_info_on_loglevel=logging.DEBUG,
1840             )
1841     runas = kwargs.get("runas")
1842     if runas is not None:
1843         if not salt.utils.platform.is_windows():
1844             os.chown(codefile, __salt__["file.user_to_uid"](runas), -1)
1845     ret = run_all(cmd, cwd=cwd, python_shell=False, **kwargs)
1846     _cleanup_tempfile(codefile)
1847     return ret
1848 def tty(device, echo=""):
1849     if device.startswith("tty"):
1850         teletype = "/dev/{}".format(device)
1851     elif device.startswith("pts"):
1852         teletype = "/dev/{}".format(device.replace("pts", "pts/"))
1853     else:
1854         return {"Error": "The specified device is not a valid TTY"}
1855     try:
1856         with salt.utils.files.fopen(teletype, "wb") as tty_device:
1857             tty_device.write(salt.utils.stringutils.to_bytes(echo))
1858         return {"Success": "Message was successfully echoed to {}".format(teletype)}
1859     except OSError:
1860         return {"Error": "Echoing to {} returned error".format(teletype)}
1861 def run_chroot(
1862     root,
1863     cmd,
1864     cwd=None,
1865     stdin=None,
1866     runas=None,
1867     group=None,
1868     shell=DEFAULT_SHELL,
1869     python_shell=True,
1870     binds=None,
1871     env=None,
1872     clean_env=False,
1873     template=None,
1874     rstrip=True,
1875     umask=None,
1876     output_encoding=None,
1877     output_loglevel="quiet",
1878     log_callback=None,
1879     hide_output=False,
1880     timeout=None,
1881     reset_system_locale=True,
1882     ignore_retcode=False,
1883     saltenv=None,
1884     use_vt=False,
1885     bg=False,
1886     success_retcodes=None,
1887     success_stdout=None,
1888     success_stderr=None,
1889     **kwargs
1890 ):
1891     __salt__["mount.mount"](os.path.join(root, "dev"), "devtmpfs", fstype="devtmpfs")
1892     __salt__["mount.mount"](os.path.join(root, "proc"), "proc", fstype="proc")
1893     __salt__["mount.mount"](os.path.join(root, "sys"), "sysfs", fstype="sysfs")
1894     binds = binds if binds else []
1895     for bind_exported in binds:
1896         bind_exported_to = os.path.relpath(bind_exported, os.path.sep)
1897         bind_exported_to = os.path.join(root, bind_exported_to)
1898         __salt__["mount.mount"](bind_exported_to, bind_exported, opts="default,bind")
1899     sh_ = "/bin/sh"
1900     if os.path.isfile(os.path.join(root, "bin/bash")):
1901         sh_ = "/bin/bash"
1902     if isinstance(cmd, (list, tuple)):
1903         cmd = " ".join([str(i) for i in cmd])
1904     if runas:
1905         userspec = "--userspec {}:{}".format(runas, group if group else "")
1906     else:
1907         userspec = ""
1908     cmd = "chroot {} {} {} -c {}".format(userspec, root, sh_, _cmd_quote(cmd))
1909     run_func = __context__.pop("cmd.run_chroot.func", run_all)
1910     ret = run_func(
1911         cmd,
1912         cwd=cwd,
1913         stdin=stdin,
1914         shell=shell,
1915         python_shell=python_shell,
1916         env=env,
1917         clean_env=clean_env,
1918         template=template,
1919         rstrip=rstrip,
1920         umask=umask,
1921         output_encoding=output_encoding,
1922         output_loglevel=output_loglevel,
1923         log_callback=log_callback,
1924         timeout=timeout,
1925         reset_system_locale=reset_system_locale,
1926         ignore_retcode=ignore_retcode,
1927         saltenv=saltenv,
1928         pillarenv=kwargs.get("pillarenv"),
1929         pillar=kwargs.get("pillar"),
1930         use_vt=use_vt,
1931         success_retcodes=success_retcodes,
1932         success_stdout=success_stdout,
1933         success_stderr=success_stderr,
1934         bg=bg,
1935     )
1936     for i in range(6):
1937         pids = _chroot_pids(root)
1938         if not pids:
1939             break
1940         for pid in pids:
1941             sig = 15 if i &lt; 3 else 9
1942             os.kill(pid, sig)
1943     if _chroot_pids(root):
1944         log.error(
1945             "Processes running in chroot could not be killed, "
1946             "filesystem will remain mounted"
1947         )
1948     for bind_exported in binds:
1949         bind_exported_to = os.path.relpath(bind_exported, os.path.sep)
1950         bind_exported_to = os.path.join(root, bind_exported_to)
1951         __salt__["mount.umount"](bind_exported_to)
1952     __salt__["mount.umount"](os.path.join(root, "sys"))
1953     __salt__["mount.umount"](os.path.join(root, "proc"))
1954     __salt__["mount.umount"](os.path.join(root, "dev"))
1955     if hide_output:
1956         ret["stdout"] = ret["stderr"] = ""
1957     return ret
1958 def _is_valid_shell(shell):
1959     if salt.utils.platform.is_windows():
1960         return True  # Don't even try this for Windows
1961     shells = "/etc/shells"
1962     available_shells = []
1963     if os.path.exists(shells):
1964         try:
1965             with salt.utils.files.fopen(shells, "r") as shell_fp:
1966                 lines = [
1967                     salt.utils.stringutils.to_unicode(x)
1968                     for x in shell_fp.read().splitlines()
1969                 ]
1970             for line in lines:
1971                 if line.startswith("#"):
1972                     continue
1973                 else:
1974                     available_shells.append(line)
1975         except OSError:
1976             return True
1977     else:
1978         return None
1979     if shell in available_shells:
1980         return True
1981     else:
1982         return False
1983 def shells():
1984     shells_fn = "/etc/shells"
1985     ret = []
1986     if os.path.exists(shells_fn):
1987         try:
1988             with salt.utils.files.fopen(shells_fn, "r") as shell_fp:
1989                 lines = [
1990                     salt.utils.stringutils.to_unicode(x)
1991                     for x in shell_fp.read().splitlines()
1992                 ]
1993             for line in lines:
1994                 line = line.strip()
1995                 if line.startswith("#"):
1996                     continue
1997                 elif not line:
1998                     continue
1999                 else:
2000                     ret.append(line)
2001         except OSError:
2002             log.error("File '%s' was not found", shells_fn)
2003     return ret
2004 def shell_info(shell, list_modules=False):
2005     regex_shells = {
2006         "bash": [r"version (\d\S*)", "bash", "--version"],
2007         "bash-test-error": [
2008             r"versioZ ([-\w.]+)",
2009             "bash",
2010             "--version",
2011         ],  # used to test an error result
2012         "bash-test-env": [
2013             r"(HOME=.*)",
2014             "bash",
2015             "-c",
2016             "declare",
2017         ],  # used to test an error result
2018         "zsh": [r"^zsh (\d\S*)", "zsh", "--version"],
2019         "tcsh": [r"^tcsh (\d\S*)", "tcsh", "--version"],
2020         "cmd": [r"Version ([\d.]+)", "cmd.exe", "/C", "ver"],
2021         "powershell": [
2022             r"PSVersion\s+(\d\S*)",
2023             "powershell",
2024             "-NonInteractive",
2025             "$PSVersionTable",
2026         ],
2027         "perl": [r"^(\d\S*)", "perl", "-e", 'printf "%vd\n", $^V;'],
2028         "python": [r"^Python (\d\S*)", "python", "-V"],
2029         "ruby": [r"^ruby (\d\S*)", "ruby", "-v"],
2030         "php": [r"^PHP (\d\S*)", "php", "-v"],
2031     }
2032     ret = {"installed": False}
2033     if salt.utils.platform.is_windows() and shell == "powershell":
2034         pw_keys = salt.utils.win_reg.list_keys(
2035             hive="HKEY_LOCAL_MACHINE", key="Software\\Microsoft\\PowerShell"
2036         )
2037         pw_keys.sort(key=int)
2038         if not pw_keys:
2039             return {
2040                 "error": (
2041                     "Unable to locate 'powershell' Reason: Cannot be found in registry."
2042                 ),
2043                 "installed": False,
2044             }
2045         for reg_ver in pw_keys:
2046             install_data = salt.utils.win_reg.read_value(
2047                 hive="HKEY_LOCAL_MACHINE",
2048                 key="Software\\Microsoft\\PowerShell\\{}".format(reg_ver),
2049                 vname="Install",
2050             )
2051             if (
2052                 install_data.get("vtype") == "REG_DWORD"
2053                 and install_data.get("vdata") == 1
2054             ):
2055                 details = salt.utils.win_reg.list_values(
2056                     hive="HKEY_LOCAL_MACHINE",
2057                     key="Software\\Microsoft\\PowerShell\\{}\\PowerShellEngine".format(
2058                         reg_ver
2059                     ),
2060                 )
2061                 ret = {}
2062                 ret["installed"] = None
2063                 ret["path"] = which("powershell.exe")
2064                 for attribute in details:
2065                     if attribute["vname"].lower() == "(default)":
2066                         continue
2067                     elif attribute["vname"].lower() == "powershellversion":
2068                         ret["psversion"] = attribute["vdata"]
2069                         ret["version_raw"] = attribute["vdata"]
2070                     elif attribute["vname"].lower() == "runtimeversion":
2071                         ret["crlversion"] = attribute["vdata"]
2072                         if ret["crlversion"][0].lower() == "v":
2073                             ret["crlversion"] = ret["crlversion"][1::]
2074                     elif attribute["vname"].lower() == "pscompatibleversion":
2075                         ret["pscompatibleversions"] = (
2076                             attribute["vdata"].replace(" ", "").split(",")
2077                         )
2078                     else:
2079                         ret[attribute["vname"].lower()] = attribute["vdata"]
2080     else:
2081         if shell not in regex_shells:
2082             return {
2083                 "error": (
2084                     "Salt does not know how to get the version number for {}".format(
2085                         shell
2086                     )
2087                 ),
2088                 "installed": None,
2089             }
2090         shell_data = regex_shells[shell]
2091         pattern = shell_data.pop(0)
2092         if salt.utils.platform.is_windows():
2093             import nt
2094             newenv = nt.environ
2095         else:
2096             newenv = os.environ
2097         if ("HOME" not in newenv) and (not salt.utils.platform.is_windows()):
2098             newenv["HOME"] = os.path.expanduser("~")
2099             log.debug("HOME environment set to %s", newenv["HOME"])
2100         try:
2101             proc = salt.utils.timed_subprocess.TimedProc(
2102                 shell_data,
2103                 stdin=None,
2104                 stdout=subprocess.PIPE,
2105                 stderr=subprocess.STDOUT,
2106                 timeout=10,
2107                 env=newenv,
2108             )
2109         except OSError as exc:
2110             return {
2111                 "error": "Unable to run command '{}' Reason: {}".format(
2112                     " ".join(shell_data), exc
2113                 ),
2114                 "installed": False,
2115             }
2116         try:
2117             proc.run()
2118         except TimedProcTimeoutError as exc:
2119             return {
2120                 "error": "Unable to run command '{}' Reason: Timed out.".format(
2121                     " ".join(shell_data)
2122                 ),
2123                 "installed": False,
2124             }
2125         ret["path"] = which(shell_data[0])
2126         pattern_result = re.search(pattern, proc.stdout, flags=re.IGNORECASE)
2127         if pattern_result:
2128             ret["version_raw"] = pattern_result.group(1)
2129     if "version_raw" in ret:
2130         version_results = re.match(r"(\d[\d.]*)", ret["version_raw"])
2131         if version_results:
2132             ret["installed"] = True
2133             ver_list = version_results.group(1).split(".")[:3]
2134             if len(ver_list) == 1:
2135                 ver_list.append("0")
2136             ret["version"] = ".".join(ver_list[:3])
2137     else:
2138         ret["installed"] = None  # Have an unexpected result
2139     if shell == "powershell" and ret["installed"] and list_modules:
2140         ret["modules"] = salt.utils.powershell.get_modules()
2141     if "version" not in ret:
2142         ret["error"] = (
2143             "The version regex pattern for shell {}, could not "
2144             "find the version string".format(shell)
2145         )
2146         ret["stdout"] = proc.stdout  # include stdout so they can see the issue
2147         log.error(ret["error"])
2148     return ret
2149 def powershell(
2150     cmd,
2151     cwd=None,
2152     stdin=None,
2153     runas=None,
2154     shell="powershell",
2155     env=None,
2156     clean_env=False,
2157     template=None,
2158     rstrip=True,
2159     umask=None,
2160     output_encoding=None,
2161     output_loglevel="debug",
2162     hide_output=False,
2163     timeout=None,
2164     reset_system_locale=True,
2165     ignore_retcode=False,
2166     saltenv=None,
2167     use_vt=False,
2168     password=None,
2169     depth=None,
2170     encode_cmd=False,
2171     success_retcodes=None,
2172     success_stdout=None,
2173     success_stderr=None,
2174     **kwargs
2175 ):
2176     if shell not in ["powershell", "pwsh"]:
2177         raise CommandExecutionError(
2178             "Must specify a valid powershell binary. Must be 'powershell' or 'pwsh'"
2179         )
2180     if "python_shell" in kwargs:
2181         python_shell = kwargs.pop("python_shell")
2182     else:
2183         python_shell = True
2184     psversion = shell_info("powershell")["psversion"]
2185     if salt.utils.versions.version_cmp(psversion, "2.0") == 1:
2186         cmd += " | ConvertTo-JSON"
2187         if depth is not None:
2188             cmd += " -Depth {}".format(depth)
2189     cmd = "try {" + cmd + '} catch { "{}" }'
2190 <a name="2"></a>    if encode_cmd:
2191         log<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.debug("Encoding PowerShell command '%s'", cmd)
2192         cmd = "$ProgressPreference='SilentlyContinue'; {}".format(cmd)
2193         cmd_utf16 = cmd.encode("utf-16-le")
2194         cmd = base64.standard_b64encode(cmd_utf16)
2195         cmd = salt.</b></font>utils.stringutils.to_str(cmd)
2196         encoded_cmd = True
2197     else:
2198         encoded_cmd = False
2199     response = run(
2200         cmd,
2201         cwd=cwd,
2202         stdin=stdin,
2203         runas=runas,
2204         shell=shell,
2205         env=env,
2206         clean_env=clean_env,
2207         template=template,
2208         rstrip=rstrip,
2209         umask=umask,
2210         output_encoding=output_encoding,
2211         output_loglevel=output_loglevel,
2212         hide_output=hide_output,
2213         timeout=timeout,
2214         reset_system_locale=reset_system_locale,
2215         ignore_retcode=ignore_retcode,
2216         saltenv=saltenv,
2217         use_vt=use_vt,
2218         python_shell=python_shell,
2219         password=password,
2220         encoded_cmd=encoded_cmd,
2221         success_retcodes=success_retcodes,
2222         success_stdout=success_stdout,
2223         success_stderr=success_stderr,
2224         **kwargs
2225     )
2226     if response == "":
2227         response = "{}"
2228     try:
2229         return salt.utils.json.loads(response)
2230     except Exception:  # pylint: disable=broad-except
2231         log.error("Error converting PowerShell JSON return", exc_info=True)
2232         return {}
2233 def powershell_all(
2234     cmd,
2235     cwd=None,
2236     stdin=None,
2237     runas=None,
2238     shell="powershell",
2239     env=None,
2240     clean_env=False,
2241     template=None,
2242     rstrip=True,
2243     umask=None,
2244     output_encoding=None,
2245     output_loglevel="debug",
2246     quiet=False,
2247     timeout=None,
2248     reset_system_locale=True,
2249     ignore_retcode=False,
2250     saltenv=None,
2251     use_vt=False,
2252     password=None,
2253     depth=None,
2254     encode_cmd=False,
2255     force_list=False,
2256     success_retcodes=None,
2257     success_stdout=None,
2258     success_stderr=None,
2259     **kwargs
2260 ):
2261     if shell not in ["powershell", "pwsh"]:
2262         raise CommandExecutionError(
2263             "Must specify a valid powershell binary. Must be 'powershell' or 'pwsh'"
2264         )
2265     if "python_shell" in kwargs:
2266         python_shell = kwargs.pop("python_shell")
2267     else:
2268         python_shell = True
2269     cmd += " | ConvertTo-JSON"
2270     if depth is not None:
2271         cmd += " -Depth {}".format(depth)
2272 <a name="1"></a>    if encode_cmd:
2273         log<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.debug("Encoding PowerShell command '%s'", cmd)
2274         cmd = "$ProgressPreference='SilentlyContinue'; {}".format(cmd)
2275         cmd_utf16 = cmd.encode("utf-16-le")
2276         cmd = base64.standard_b64encode(cmd_utf16)
2277         cmd = salt.</b></font>utils.stringutils.to_str(cmd)
2278         encoded_cmd = True
2279     else:
2280         encoded_cmd = False
2281     response = run_all(
2282         cmd,
2283         cwd=cwd,
2284         stdin=stdin,
2285         runas=runas,
2286         shell=shell,
2287         env=env,
2288         clean_env=clean_env,
2289         template=template,
2290         rstrip=rstrip,
2291         umask=umask,
2292         output_encoding=output_encoding,
2293         output_loglevel=output_loglevel,
2294         quiet=quiet,
2295         timeout=timeout,
2296         reset_system_locale=reset_system_locale,
2297         ignore_retcode=ignore_retcode,
2298         saltenv=saltenv,
2299         use_vt=use_vt,
2300         python_shell=python_shell,
2301         password=password,
2302         encoded_cmd=encoded_cmd,
2303         success_retcodes=success_retcodes,
2304         success_stdout=success_stdout,
2305         success_stderr=success_stderr,
2306         **kwargs
2307     )
2308     stdoutput = response["stdout"]
2309     if not stdoutput:
2310         response.pop("stdout")
2311         if force_list:
2312             response["result"] = []
2313         return response
2314     try:
2315         result = salt.utils.json.loads(stdoutput)
2316     except Exception:  # pylint: disable=broad-except
2317         err_msg = "cmd.powershell_all " + "cannot parse the Powershell output."
2318         response["cmd"] = cmd
2319         raise CommandExecutionError(message=err_msg, info=response)
2320     response.pop("stdout")
2321     if type(result) is not list:
2322         if force_list:
2323             response["result"] = [result]
2324         else:
2325             response["result"] = result
2326     else:
2327         response["result"] = result
2328     return response
2329 def run_bg(
2330     cmd,
2331     cwd=None,
2332     runas=None,
2333     group=None,
2334     shell=DEFAULT_SHELL,
2335     python_shell=None,
2336     env=None,
2337     clean_env=False,
2338     template=None,
2339     umask=None,
2340     timeout=None,
2341     output_encoding=None,
2342     output_loglevel="debug",
2343     log_callback=None,
2344     reset_system_locale=True,
2345     ignore_retcode=False,
2346     saltenv=None,
2347     password=None,
2348     prepend_path=None,
2349     success_retcodes=None,
2350     success_stdout=None,
2351     success_stderr=None,
2352     **kwargs
2353 ):
2354     r"""
2355     .. versionadded:: 2016.3.0
2356     Execute the passed command in the background and return its PID
2357     .. note::
2358         If the init system is systemd and the backgrounded task should run even
2359         if the salt-minion process is restarted, prepend ``systemd-run
2360         --scope`` to the command. This will reparent the process in its own
2361         scope separate from salt-minion, and will not be affected by restarting
2362         the minion service.
2363     :param str cmd: The command to run. ex: ``ls -lart /home``
2364     :param str cwd: The directory from which to execute the command. Defaults
2365         to the home directory of the user specified by ``runas`` (or the user
2366         under which Salt is running if ``runas`` is not specified).
2367     :param str group: Group to run command as. Not currently supported
2368       on Windows.
2369     :param str shell: Shell to execute under. Defaults to the system default
2370       shell.
2371     :param str output_encoding: Control the encoding used to decode the
2372         command's output.
2373         .. note::
2374             This should not need to be used in most cases. By default, Salt
2375             will try to use the encoding detected from the system locale, and
2376             will fall back to UTF-8 if this fails. This should only need to be
2377             used in cases where the output of the command is encoded in
2378             something other than the system locale or UTF-8.
2379             To see the encoding Salt has detected from the system locale, check
2380             the `locale` line in the output of :py:func:`test.versions_report
2381             &lt;salt.modules.test.versions_report&gt;`.
2382         .. versionadded:: 2018.3.0
2383     :param str output_loglevel: Control the loglevel at which the output from
2384         the command is logged to the minion log.
2385         .. note::
2386             The command being run will still be logged at the ``debug``
2387             loglevel regardless, unless ``quiet`` is used for this value.
2388     :param bool ignore_retcode: If the exit code of the command is nonzero,
2389         this is treated as an error condition, and the output from the command
2390         will be logged to the minion log. However, there are some cases where
2391         programs use the return code for signaling and a nonzero exit code
2392         doesn't necessarily mean failure. Pass this argument as ``True`` to
2393         skip logging the output if the command has a nonzero exit code.
2394     :param str runas: Specify an alternate user to run the command. The default
2395         behavior is to run as the user under which Salt is running. If running
2396         on a Windows minion you must also use the ``password`` argument, and
2397         the target user account must be in the Administrators group.
2398         .. warning::
2399             For versions 2018.3.3 and above on macosx while using runas,
2400             to pass special characters to the command you need to escape
2401             the characters on the shell.
2402             Example:
2403             .. code-block:: bash
2404                 cmd.run_bg 'echo '\''h=\"baz\"'\''' runas=macuser
2405     :param str password: Windows only. Required when specifying ``runas``. This
2406         parameter will be ignored on non-Windows platforms.
2407         .. versionadded:: 2016.3.0
2408     :param str shell: Specify an alternate shell. Defaults to the system's
2409         default shell.
2410     :param bool python_shell: If False, let python handle the positional
2411         arguments. Set to True to use shell features, such as pipes or
2412         redirection.
2413     :param dict env: Environment variables to be set prior to execution.
2414         .. note::
2415             When passing environment variables on the CLI, they should be
2416             passed as the string representation of a dictionary.
2417             .. code-block:: bash
2418                 salt myminion cmd.run_bg 'some command' env='{"FOO": "bar"}'
2419         .. note::
2420             When using environment variables on Window's, case-sensitivity
2421             matters, i.e. Window's uses `Path` as opposed to `PATH` for other
2422             systems.
2423     :param bool clean_env: Attempt to clean out all other shell environment
2424         variables and set only those provided in the 'env' argument to this
2425         function.
2426     :param str prepend_path: $PATH segment to prepend (trailing ':' not
2427         necessary) to $PATH
2428         .. versionadded:: 2018.3.0
2429     :param str template: If this setting is applied then the named templating
2430         engine will be used to render the downloaded file. Currently jinja,
2431         mako, and wempy are supported.
2432     :param str umask: The umask (in octal) to use when running the command.
2433     :param int timeout: A timeout in seconds for the executed process to return.
2434     .. warning::
2435         This function does not process commands through a shell unless the
2436         ``python_shell`` argument is set to ``True``. This means that any
2437         shell-specific functionality such as 'echo' or the use of pipes,
2438         redirection or &amp;&amp;, should either be migrated to cmd.shell or have the
2439         python_shell=True flag set here.
2440         The use of ``python_shell=True`` means that the shell will accept _any_
2441         input including potentially malicious commands such as 'good_command;rm
2442         -rf /'.  Be absolutely certain that you have sanitized your input prior
2443         to using ``python_shell=True``.
2444     :param list success_retcodes: This parameter will allow a list of
2445         non-zero return codes that should be considered a success.  If the
2446         return code returned from the run matches any in the provided list,
2447         the return code will be overridden with zero.
2448       .. versionadded:: 2019.2.0
2449     :param list success_stdout: This parameter will allow a list of
2450         strings that when found in standard out should be considered a success.
2451         If stdout returned from the run matches any in the provided list,
2452         the return code will be overridden with zero.
2453       .. versionadded:: 3004
2454     :param list success_stderr: This parameter will allow a list of
2455         strings that when found in standard error should be considered a success.
2456         If stderr returned from the run matches any in the provided list,
2457         the return code will be overridden with zero.
2458       .. versionadded:: 3004
2459     :param bool stdin_raw_newlines: False
2460         If ``True``, Salt will not automatically convert the characters ``\\n``
2461         present in the ``stdin`` value to newlines.
2462       .. versionadded:: 2019.2.0
2463     CLI Example:
2464     .. code-block:: bash
2465         salt '*' cmd.run_bg "fstrim-all"
2466     The template arg can be set to 'jinja' or another supported template
2467     engine to render the command arguments before execution.
2468     For example:
2469     .. code-block:: bash
2470         salt '*' cmd.run_bg template=jinja "ls -l /tmp/{{grains.id}} | awk '/foo/{print \\$2}'"
2471     Specify an alternate shell with the shell parameter:
2472     .. code-block:: bash
2473         salt '*' cmd.run_bg "Get-ChildItem C:\\ " shell='powershell'
2474     If an equal sign (``=``) appears in an argument to a Salt command it is
2475     interpreted as a keyword argument in the format ``key=val``. That
2476     processing can be bypassed in order to pass an equal sign through to the
2477     remote shell command by manually specifying the kwarg:
2478     .. code-block:: bash
2479         salt '*' cmd.run_bg cmd='ls -lR / | sed -e s/=/:/g &gt; /tmp/dontwait'
2480     """
2481     python_shell = _python_shell_default(python_shell, kwargs.get("__pub_jid", ""))
2482     res = _run(
2483         cmd,
2484         stdin=None,
2485         stderr=None,
2486         stdout=None,
2487         output_encoding=output_encoding,
2488         output_loglevel=output_loglevel,
2489         use_vt=None,
2490         bg=True,
2491         with_communicate=False,
2492         rstrip=False,
2493         runas=runas,
2494         group=group,
2495         shell=shell,
2496         python_shell=python_shell,
2497         cwd=cwd,
2498         env=env,
2499         clean_env=clean_env,
2500         prepend_path=prepend_path,
2501         template=template,
2502         umask=umask,
2503         log_callback=log_callback,
2504         timeout=timeout,
2505         reset_system_locale=reset_system_locale,
2506         saltenv=saltenv,
2507         password=password,
2508         success_retcodes=success_retcodes,
2509         success_stdout=success_stdout,
2510         success_stderr=success_stderr,
2511         **kwargs
2512     )
2513     return {"pid": res["pid"]}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>network_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import fnmatch
2 import itertools
3 import logging
4 import os
5 import platform
6 import random
7 import re
8 import socket
9 import subprocess
10 import types
11 from collections.abc import Mapping, Sequence
12 from string import ascii_letters, digits
13 import salt.utils.args
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import salt.utils.stringutils
18 import salt.utils.zeromq
19 from salt._compat import ipaddress
20 from salt.exceptions import SaltClientError, SaltSystemExit
21 from salt.utils.decorators.jinja import jinja_filter
22 from salt.utils.versions import LooseVersion
23 try:
24     import</b></font> salt.utils.win_network
25     WIN_NETWORK_LOADED = True
26 except ImportError:
27     WIN_NETWORK_LOADED = False
28 log = logging.getLogger(__name__)
29 try:
30     import ctypes
31     import ctypes.util
32     LIBC = ctypes.cdll.LoadLibrary(ctypes.util.find_library("c"))
33     RES_INIT = LIBC.__res_init
34 except (ImportError, OSError, AttributeError, TypeError):
35     pass
36 class Interfaces:
37     __slots__ = ("interfaces",)
38     def __init__(self, interfaces=None):
39         if interfaces is None:
40             interfaces = {}
41         self.interfaces = interfaces
42     def __call__(self, *args, **kwargs):
43         if not self.interfaces:
44             self.interfaces = interfaces()
45         return self.interfaces
46     def clear(self):
47         self.interfaces = {}
48 _get_interfaces = Interfaces()
49 _clear_interfaces = _get_interfaces.clear
50 def sanitize_host(host):
51     RFC952_characters = ascii_letters + digits + ".-_"
52     return "".join([c for c in host[0:255] if c in RFC952_characters])
53 def isportopen(host, port):
54     if not 1 &lt;= int(port) &lt;= 65535:
55         return False
56     sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
57     out = sock.connect_ex((sanitize_host(host), int(port)))
58     return out
59 def host_to_ips(host):
60     ips = []
61     try:
62         for family, socktype, proto, canonname, sockaddr in socket.getaddrinfo(
63             host, 0, socket.AF_UNSPEC, socket.SOCK_STREAM
64         ):
65             if family == socket.AF_INET:
66                 ip, port = sockaddr
67             elif family == socket.AF_INET6:
68                 ip, port, flow_info, scope_id = sockaddr
69             ips.append(ip)
70         if not ips:
71             ips = None
72     except Exception:  # pylint: disable=broad-except
73         ips = None
74     return ips
75 def _generate_minion_id():
76     class DistinctList(list):
77         localhost_matchers = [
78             r"localhost.*",
79             r"ip6-.*",
80             r"127[.]\d",
81             r"0\.0\.0\.0",
82             r"::1.*",
83             r"ipv6-.*",
84             r"fe00::.*",
85             r"fe02::.*",
86             r"1.0.0.*.ip6.arpa",
87         ]
88         def append(self, p_object):
89             if p_object and p_object not in self and not self.filter(p_object):
90                 super().append(p_object)
91             return self
92         def extend(self, iterable):
93             for obj in iterable:
94                 self.append(obj)
95             return self
96         def filter(self, element):
97             "Returns True if element needs to be filtered"
98             for rgx in self.localhost_matchers:
99                 if re.match(rgx, element):
100                     return True
101         def first(self):
102             return self and self[0] or None
103     hostname = socket.gethostname()
104     hosts = (
105         DistinctList()
106         .append(
107             salt.utils.stringutils.to_unicode(
108                 socket.getfqdn(salt.utils.stringutils.to_bytes(hostname))
109             )
110         )
111         .append(platform.node())
112         .append(hostname)
113     )
114     if not hosts:
115         try:
116             for a_nfo in socket.getaddrinfo(
117                 hosts.first() or "localhost",
118                 None,
119                 socket.AF_INET,
120                 socket.SOCK_RAW,
121                 socket.IPPROTO_IP,
122                 socket.AI_CANONNAME,
123             ):
124                 if len(a_nfo) &gt; 3:
125                     hosts.append(a_nfo[3])
126         except socket.gaierror:
127             log.warning(
128                 "Cannot resolve address %s info via socket: %s",
129                 hosts.first() or "localhost (N/A)",
130                 socket.gaierror,
131             )
132     for f_name in (
133         "/etc/hostname",
134         "/etc/nodename",
135         "/etc/hosts",
136         r"{win}\system32\drivers\etc\hosts".format(win=os.getenv("WINDIR")),
137     ):
138         try:
139             with salt.utils.files.fopen(f_name) as f_hdl:
140                 for line in f_hdl:
141                     line = salt.utils.stringutils.to_unicode(line)
142                     hst = line.strip().split("#")[0].strip().split()
143                     if hst:
144                         if hst[0][:4] in ("127.", "::1") or len(hst) == 1:
145                             hosts.extend(hst)
146         except OSError:
147             pass
148     return hosts.extend(
149         [addr for addr in ip_addrs() if not ipaddress.ip_address(addr).is_loopback]
150     )
151 def generate_minion_id():
152     try:
153         ret = salt.utils.stringutils.to_unicode(_generate_minion_id().first())
154     except TypeError:
155         ret = None
156     return ret or "localhost"
157 def get_socket(addr, type=socket.SOCK_STREAM, proto=0):
158     version = ipaddress.ip_address(addr).version
159     if version == 4:
160         family = socket.AF_INET
161     elif version == 6:
162         family = socket.AF_INET6
163     return socket.socket(family, type, proto)
164 def get_fqhostname():
165     l = [socket.getfqdn()]
166     try:
167         addrinfo = socket.getaddrinfo(
168             socket.gethostname(),
169             0,
170             socket.AF_UNSPEC,
171             socket.SOCK_STREAM,
172             socket.SOL_TCP,
173             socket.AI_CANONNAME,
174         )
175         for info in addrinfo:
176             if len(info) &gt;= 4 and info[3]:
177                 l = [info[3]]
178     except socket.gaierror:
179         pass
180     return l and l[0] or None
181 def ip_to_host(ip):
182     try:
183         hostname, aliaslist, ipaddrlist = socket.gethostbyaddr(ip)
184     except Exception as exc:  # pylint: disable=broad-except
185         log.debug("salt.utils.network.ip_to_host(%r) failed: %s", ip, exc)
186         hostname = None
187     return hostname
188 def is_reachable_host(entity_name):
189     try:
190         assert type(socket.getaddrinfo(entity_name, 0, 0, 0, 0)) == list
191         ret = True
192     except socket.gaierror:
193         ret = False
194     return ret
195 def is_ip(ip_addr):
196     return is_ipv4(ip_addr) or is_ipv6(ip_addr)
197 def is_ipv4(ip_addr):
198     try:
199         return ipaddress.ip_address(ip_addr).version == 4
200     except ValueError:
201         return False
202 def is_ipv6(ip_addr):
203     try:
204         return ipaddress.ip_address(ip_addr).version == 6
205     except ValueError:
206         return False
207 def is_subnet(cidr):
208     return is_ipv4_subnet(cidr) or is_ipv6_subnet(cidr)
209 def is_ipv4_subnet(cidr):
210     try:
211         return "/" in cidr and bool(ipaddress.IPv4Network(cidr))
212     except Exception:  # pylint: disable=broad-except
213         return False
214 def is_ipv6_subnet(cidr):
215     try:
216         return "/" in cidr and bool(ipaddress.IPv6Network(cidr))
217     except Exception:  # pylint: disable=broad-except
218         return False
219 @jinja_filter("is_ip")
220 def is_ip_filter(ip_addr, options=None):
221     return is_ipv4_filter(ip_addr, options=options) or is_ipv6_filter(
222         ip_addr, options=options
223     )
224 def _ip_options_global(ip_obj, version):
225     return not ip_obj.is_private
226 def _ip_options_multicast(ip_obj, version):
227     return ip_obj.is_multicast
228 def _ip_options_loopback(ip_obj, version):
229     return ip_obj.is_loopback
230 def _ip_options_link_local(ip_obj, version):
231     return ip_obj.is_link_local
232 def _ip_options_private(ip_obj, version):
233     return ip_obj.is_private
234 def _ip_options_reserved(ip_obj, version):
235     return ip_obj.is_reserved
236 def _ip_options_site_local(ip_obj, version):
237     if version == 6:
238         return ip_obj.is_site_local
239     return False
240 def _ip_options_unspecified(ip_obj, version):
241     return ip_obj.is_unspecified
242 def _ip_options(ip_obj, version, options=None):
243     options_fun_map = {
244         "global": _ip_options_global,
245         "link-local": _ip_options_link_local,
246         "linklocal": _ip_options_link_local,
247         "ll": _ip_options_link_local,
248         "link_local": _ip_options_link_local,
249         "loopback": _ip_options_loopback,
250         "lo": _ip_options_loopback,
251         "multicast": _ip_options_multicast,
252         "private": _ip_options_private,
253         "public": _ip_options_global,
254         "reserved": _ip_options_reserved,
255         "site-local": _ip_options_site_local,
256         "sl": _ip_options_site_local,
257         "site_local": _ip_options_site_local,
258         "unspecified": _ip_options_unspecified,
259     }
260     if not options:
261         return str(ip_obj)  # IP version already checked
262     options_list = [option.strip() for option in options.split(",")]
263     for option, fun in options_fun_map.items():
264         if option in options_list:
265             fun_res = fun(ip_obj, version)
266             if not fun_res:
267                 return None
268     return str(ip_obj)
269 def _is_ipv(ip_addr, version, options=None):
270     if not version:
271         version = 4
272     if version not in (4, 6):
273         return None
274     try:
275         ip_obj = ipaddress.ip_address(ip_addr)
276     except ValueError:
277         try:
278             ip_obj = ipaddress.ip_interface(ip_addr)
279         except ValueError:
280             return None
281     if not ip_obj.version == version:
282         return None
283     return _ip_options(ip_obj, version, options=options)
284 @jinja_filter("is_ipv4")
285 def is_ipv4_filter(ip_addr, options=None):
286     _is_ipv4 = _is_ipv(ip_addr, 4, options=options)
287     return isinstance(_is_ipv4, str)
288 @jinja_filter("is_ipv6")
289 def is_ipv6_filter(ip_addr, options=None):
290     _is_ipv6 = _is_ipv(ip_addr, 6, options=options)
291     return isinstance(_is_ipv6, str)
292 def _ipv_filter(value, version, options=None):
293     if version not in (4, 6):
294         return
295     if isinstance(value, (str, bytes)):
296         return _is_ipv(
297             value, version, options=options
298         )  # calls is_ipv4 or is_ipv6 for `value`
299     elif isinstance(value, (list, tuple, types.GeneratorType)):
300         return [
301             _is_ipv(addr, version, options=options)
302             for addr in value
303             if _is_ipv(addr, version, options=options) is not None
304         ]
305     return None
306 @jinja_filter("ipv4")
307 def ipv4(value, options=None):
308     return _ipv_filter(value, 4, options=options)
309 @jinja_filter("ipv6")
310 def ipv6(value, options=None):
311     return _ipv_filter(value, 6, options=options)
312 @jinja_filter("ipaddr")
313 def ipaddr(value, options=None):
314     ipv4_obj = ipv4(value, options=options)
315     ipv6_obj = ipv6(value, options=options)
316     if ipv4_obj is None or ipv6_obj is None:
317         return ipv4_obj or ipv6_obj  # one of them
318     else:
319         return ipv4_obj + ipv6_obj  # extend lists
320 def _filter_ipaddr(value, options, version=None):
321     ipaddr_filter_out = None
322     if version:
323         if version == 4:
324             ipaddr_filter_out = ipv4(value, options)
325         elif version == 6:
326             ipaddr_filter_out = ipv6(value, options)
327     else:
328         ipaddr_filter_out = ipaddr(value, options)
329     if not ipaddr_filter_out:
330         return
331     if not isinstance(ipaddr_filter_out, (list, tuple, types.GeneratorType)):
332         ipaddr_filter_out = [ipaddr_filter_out]
333     return ipaddr_filter_out
334 @jinja_filter("ip_host")
335 def ip_host(value, options=None, version=None):
336     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
337     if not ipaddr_filter_out:
338         return
339     if not isinstance(value, (list, tuple, types.GeneratorType)):
340         return str(ipaddress.ip_interface(ipaddr_filter_out[0]))
341     return [str(ipaddress.ip_interface(ip_a)) for ip_a in ipaddr_filter_out]
342 def _network_hosts(ip_addr_entry):
343     return [
344         str(host) for host in ipaddress.ip_network(ip_addr_entry, strict=False).hosts()
345     ]
346 @jinja_filter("network_hosts")
347 def network_hosts(value, options=None, version=None):
348     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
349     if not ipaddr_filter_out:
350         return
351     if not isinstance(value, (list, tuple, types.GeneratorType)):
352         return _network_hosts(ipaddr_filter_out[0])
353     return [_network_hosts(ip_a) for ip_a in ipaddr_filter_out]
354 def _network_size(ip_addr_entry):
355     return ipaddress.ip_network(ip_addr_entry, strict=False).num_addresses
356 @jinja_filter("network_size")
357 def network_size(value, options=None, version=None):
358     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
359     if not ipaddr_filter_out:
360         return
361     if not isinstance(value, (list, tuple, types.GeneratorType)):
362         return _network_size(ipaddr_filter_out[0])
363     return [_network_size(ip_a) for ip_a in ipaddr_filter_out]
364 def natural_ipv4_netmask(ip_addr, fmt="prefixlen"):
365     bits = _ipv4_to_bits(ip_addr)
366     if bits.startswith("11"):
367         mask = "24"
368     elif bits.startswith("1"):
369         mask = "16"
370     else:
371         mask = "8"
372     if fmt == "netmask":
373         return cidr_to_ipv4_netmask(mask)
374     else:
375         return "/" + mask
376 def rpad_ipv4_network(ip_addr):
377     return ".".join(itertools.islice(itertools.chain(ip_addr.split("."), "0000"), 0, 4))
378 def cidr_to_ipv4_netmask(cidr_bits):
379     try:
380         cidr_bits = int(cidr_bits)
381         if not 1 &lt;= cidr_bits &lt;= 32:
382             return ""
383     except ValueError:
384         return ""
385     netmask = ""
386     for idx in range(4):
387         if idx:
388             netmask += "."
389         if cidr_bits &gt;= 8:
390             netmask += "255"
391             cidr_bits -= 8
392         else:
393             netmask += "{:d}".format(256 - (2 ** (8 - cidr_bits)))
394             cidr_bits = 0
395     return netmask
396 def _number_of_set_bits_to_ipv4_netmask(set_bits):
397     return cidr_to_ipv4_netmask(_number_of_set_bits(set_bits))
398 def _number_of_set_bits(x):
399     x -= (x &gt;&gt; 1) &amp; 0x55555555
400     x = ((x &gt;&gt; 2) &amp; 0x33333333) + (x &amp; 0x33333333)
401     x = ((x &gt;&gt; 4) + x) &amp; 0x0F0F0F0F
402     x += x &gt;&gt; 8
403     x += x &gt;&gt; 16
404     return x &amp; 0x0000003F
405 def _interfaces_ip(out):
406     ret = dict()
407     def parse_network(value, cols):
408         brd = None
409         scope = None
410         if "/" in value:  # we have a CIDR in this address
411             ip, cidr = value.split("/")
412         else:
413             ip = value
414             cidr = 32
415         if type_ == "inet":
416             mask = cidr_to_ipv4_netmask(int(cidr))
417             if "brd" in cols:
418                 brd = cols[cols.index("brd") + 1]
419         elif type_ == "inet6":
420             mask = cidr
421             if "scope" in cols:
422                 scope = cols[cols.index("scope") + 1]
423         return (ip, mask, brd, scope)
424     groups = re.compile("\r?\n\\d").split(out)
425     for group in groups:
426         iface = None
427         data = dict()
428         for line in group.splitlines():
429             if " " not in line:
430                 continue
431             match = re.match(r"^\d*:\s+([\w.\-]+)(?:@)?([\w.\-]+)?:\s+&lt;(.+)&gt;", line)
432             if match:
433                 iface, parent, attrs = match.groups()
434                 if "UP" in attrs.split(","):
435                     data["up"] = True
436                 else:
437                     data["up"] = False
438                 if parent:
439                     data["parent"] = parent
440                 continue
441             cols = line.split()
442             if len(cols) &gt;= 2:
443                 type_, value = tuple(cols[0:2])
444                 iflabel = cols[-1:][0]
445                 if type_ in ("inet", "inet6"):
446                     ipaddr, netmask, broadcast, scope = parse_network(value, cols)
447                     addr_obj = dict()
448                     if "secondary" not in cols:
449                         if type_ == "inet":
450                             if "inet" not in data:
451                                 data["inet"] = list()
452                             addr_obj["address"] = ipaddr
453                             addr_obj["netmask"] = netmask
454                             addr_obj["broadcast"] = broadcast
455                             addr_obj["label"] = iflabel
456                             data["inet"].append(addr_obj)
457                         elif type_ == "inet6":
458                             if "inet6" not in data:
459                                 data["inet6"] = list()
460                             addr_obj["address"] = ipaddr
461                             addr_obj["prefixlen"] = netmask
462                             addr_obj["scope"] = scope
463                             data["inet6"].append(addr_obj)
464                     else:
465                         if type_ == "inet":
466                             if "secondary" not in data:
467                                 data["secondary"] = list()
468                             addr_obj["type"] = type_
469                             addr_obj["address"] = ipaddr
470                             addr_obj["netmask"] = netmask
471                             addr_obj["broadcast"] = broadcast
472                             addr_obj["label"] = iflabel
473                             data["secondary"].append(addr_obj)
474                         elif type_ == "inet6":
475                             if "secondary" not in data:
476                                 data["secondary"] = list()
477                             addr_obj["type"] = type_
478                             addr_obj["address"] = ipaddr
479                             addr_obj["prefixlen"] = netmask
480                             addr_obj["scope"] = scope
481                             data["secondary"].append(addr_obj)
482                 elif type_.startswith("link"):
483                     data["hwaddr"] = value
484         if iface:
485             ret[iface] = data
486             del iface, data
487     return ret
488 def _interfaces_ifconfig(out):
489     ret = dict()
490 <a name="2"></a>
491     piface = re.compile(r"^([^\s:]+)")
492     pmac = re.compile(".*?(?:HWaddr|ether|address:|lladdr) ([0-9a-fA-F:]+)")
493     if salt.utils.platform<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.is_sunos():
494         pip = re.compile(r".*?(?:inet\s+)([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(.*)")
495         pip6 = re.compile(".*?(?:inet6 )([0-9a-fA-F:]+)")
496         pmask6 = re.compile(r".*?(?:inet6 [0-9a-fA-F:]+/(\d+)).*")
497     else:
498         pip = re.</b></font>compile(r".*?(?:inet addr:|inet [^\d]*)(.*?)\s")
499         pip6 = re.compile(".*?(?:inet6 addr: (.*?)/|inet6 )([0-9a-fA-F:]+)")
500         pmask6 = re.compile(
501             r".*?(?:inet6 addr: [0-9a-fA-F:]+/(\d+)|prefixlen (\d+))(?:"
502             r" Scope:([a-zA-Z]+)| scopeid (0x[0-9a-fA-F]))?"
503         )
504     pmask = re.compile(r".*?(?:Mask:|netmask )(?:((?:0x)?[0-9a-fA-F]{8})|([\d\.]+))")
505     pupdown = re.compile("UP")
506     pbcast = re.compile(r".*?(?:Bcast:|broadcast )([\d\.]+)")
507     groups = re.compile("\r?\n(?=\\S)").split(out)
508     for group in groups:
509 <a name="1"></a>        data = dict()
510         iface = ""
511         updown = False
512         for line in group<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.splitlines():
513             miface = piface.match(line)
514             mmac = pmac.match(line)
515             mip = pip.match(line)
516             mip6 = pip6.</b></font>match(line)
517             mupdown = pupdown.search(line)
518             if miface:
519                 iface = miface.group(1)
520             if mmac:
521                 data["hwaddr"] = mmac.group(1)
522                 if salt.utils.platform.is_sunos():
523                     expand_mac = []
524                     for chunk in data["hwaddr"].split(":"):
525                         expand_mac.append(
526                             "0{}".format(chunk)
527                             if len(chunk) &lt; 2
528                             else "{}".format(chunk)
529                         )
530                     data["hwaddr"] = ":".join(expand_mac)
531             if mip:
532                 if "inet" not in data:
533                     data["inet"] = list()
534                 addr_obj = dict()
535                 addr_obj["address"] = mip.group(1)
536                 mmask = pmask.match(line)
537                 if mmask:
538                     if mmask.group(1):
539                         mmask = _number_of_set_bits_to_ipv4_netmask(
540                             int(mmask.group(1), 16)
541                         )
542                     else:
543                         mmask = mmask.group(2)
544                     addr_obj["netmask"] = mmask
545                 mbcast = pbcast.match(line)
546                 if mbcast:
547                     addr_obj["broadcast"] = mbcast.group(1)
548                 data["inet"].append(addr_obj)
549             if mupdown:
550                 updown = True
551             if mip6:
552                 if "inet6" not in data:
553                     data["inet6"] = list()
554                 addr_obj = dict()
555                 addr_obj["address"] = mip6.group(1) or mip6.group(2)
556                 mmask6 = pmask6.match(line)
557                 if mmask6:
558                     addr_obj["prefixlen"] = mmask6.group(1) or mmask6.group(2)
559                     if not salt.utils.platform.is_sunos():
560                         ipv6scope = mmask6.group(3) or mmask6.group(4)
561                         addr_obj["scope"] = (
562                             ipv6scope.lower() if ipv6scope is not None else ipv6scope
563                         )
564                 if (
565                     not salt.utils.platform.is_sunos()
566                     or addr_obj["address"] != "::"
567                     and addr_obj["prefixlen"] != 0
568                 ):
569                     data["inet6"].append(addr_obj)
570         data["up"] = updown
571         if iface in ret:
572             ret[iface] = dict(list(data.items()) + list(ret[iface].items()))
573             if "inet" in data:
574                 ret[iface]["inet"].extend(
575                     x for x in data["inet"] if x not in ret[iface]["inet"]
576                 )
577             if "inet6" in data:
578                 ret[iface]["inet6"].extend(
579                     x for x in data["inet6"] if x not in ret[iface]["inet6"]
580                 )
581         else:
582             ret[iface] = data
583         del data
584     return ret
585 def linux_interfaces():
586     ifaces = dict()
587     ip_path = salt.utils.path.which("ip")
588     ifconfig_path = None if ip_path else salt.utils.path.which("ifconfig")
589     if ip_path:
590         cmd1 = subprocess.Popen(
591             [ip_path, "link", "show"],
592             close_fds=True,
593             stdout=subprocess.PIPE,
594             stderr=subprocess.STDOUT,
595         ).communicate()[0]
596         cmd2 = subprocess.Popen(
597             [ip_path, "addr", "show"],
598             close_fds=True,
599             stdout=subprocess.PIPE,
600             stderr=subprocess.STDOUT,
601         ).communicate()[0]
602         ifaces = _interfaces_ip(
603             "{}\n{}".format(
604                 salt.utils.stringutils.to_str(cmd1), salt.utils.stringutils.to_str(cmd2)
605             )
606         )
607     elif ifconfig_path:
608         cmd = subprocess.Popen(
609             [ifconfig_path, "-a"],
610             stdout=subprocess.PIPE,
611             stderr=subprocess.STDOUT,
612         ).communicate()[0]
613         ifaces = _interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
614     return ifaces
615 def _netbsd_interfaces_ifconfig(out):
616     ret = dict()
617     piface = re.compile(r"^([^\s:]+)")
618     pmac = re.compile(".*?address: ([0-9a-f:]+)")
619     pip = re.compile(r".*?inet [^\d]*(.*?)/([\d]*)\s")
620     pip6 = re.compile(r".*?inet6 ([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s")
621     pupdown = re.compile("UP")
622     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
623     groups = re.compile("\r?\n(?=\\S)").split(out)
624     for group in groups:
625         data = dict()
626         iface = ""
627         updown = False
628         for line in group.splitlines():
629             miface = piface.match(line)
630             mmac = pmac.match(line)
631             mip = pip.match(line)
632             mip6 = pip6.match(line)
633             mupdown = pupdown.search(line)
634             if miface:
635                 iface = miface.group(1)
636             if mmac:
637                 data["hwaddr"] = mmac.group(1)
638             if mip:
639                 if "inet" not in data:
640                     data["inet"] = list()
641 <a name="3"></a>                addr_obj = dict()
642                 addr_obj["address"] = mip.group(1)
643                 mmask = mip.group(2)
644                 if mip<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.group(2):
645                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(2))
646                 mbcast = pbcast.match(line)
647                 if</b></font> mbcast:
648                     addr_obj["broadcast"] = mbcast.group(1)
649                 data["inet"].append(addr_obj)
650             if mupdown:
651                 updown = True
652             if mip6:
653                 if "inet6" not in data:
654                     data["inet6"] = list()
655                 addr_obj = dict()
656                 addr_obj["address"] = mip6.group(1)
657                 mmask6 = mip6.group(3)
658                 addr_obj["scope"] = mip6.group(2)
659                 addr_obj["prefixlen"] = mip6.group(3)
660                 data["inet6"].append(addr_obj)
661         data["up"] = updown
662         ret[iface] = data
663         del data
664     return ret
665 def _junos_interfaces_ifconfig(out):
666     ret = dict()
667     piface = re.compile(r"^([^\s:]+)")
668     pmac = re.compile("curr media .*? ([0-9a-f:]+)")
669     pip = re.compile(
670         r".*?inet\s*(primary)*\s+mtu"
671         r" (\d+)\s+local=[^\d]*(.*?)\s+dest=[^\d]*(.*?)\/([\d]*)\s+bcast=((?:[0-9]{1,3}\.){3}[0-9]{1,3})"
672     )
673     pip6 = re.compile(
674         r".*?inet6 mtu [^\d]+\s+local=([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s"
675     )
676     pupdown = re.compile("UP")
677     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
678     groups = re.compile("\r?\n(?=\\S)").split(out)
679     for group in groups:
680         data = dict()
681         iface = ""
682         updown = False
683         primary = False
684         for line in group.splitlines():
685             miface = piface.match(line)
686             mmac = pmac.match(line)
687             mip = pip.match(line)
688             mip6 = pip6.match(line)
689             mupdown = pupdown.search(line)
690             if miface:
691                 iface = miface.group(1)
692             if mmac:
693                 data["hwaddr"] = mmac.group(1)
694             if mip:
695                 if "primary" in data:
696                     primary = True
697                 if "inet" not in data:
698                     data["inet"] = list()
699                 if mip.group(2):
700                     data["mtu"] = int(mip.group(2))
701                 addr_obj = dict()
702                 addr_obj["address"] = mip.group(3)
703                 mmask = mip.group(5)
704                 if mip.group(5):
705                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(5))
706                 mbcast = pbcast.match(line)
707                 if mbcast:
708                     addr_obj["broadcast"] = mbcast.group(1)
709                 data["inet"].append(addr_obj)
710             if mupdown:
711                 updown = True
712             if mip6:
713                 if "inet6" not in data:
714                     data["inet6"] = list()
715                 addr_obj = dict()
716                 addr_obj["address"] = mip6.group(1)
717                 mmask6 = mip6.group(3)
718                 addr_obj["scope"] = mip6.group(2)
719                 addr_obj["prefixlen"] = mip6.group(3)
720                 data["inet6"].append(addr_obj)
721         data["up"] = updown
722         ret[iface] = data
723         del data
724     return ret
725 def junos_interfaces():
726     ifconfig_path = salt.utils.path.which("ifconfig")
727     cmd = subprocess.Popen(
728         [ifconfig_path, "-a"],
729         stdout=subprocess.PIPE,
730         stderr=subprocess.STDOUT,
731     ).communicate()[0]
732     return _junos_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
733 def netbsd_interfaces():
734     if LooseVersion(os.uname()[2]) &lt; LooseVersion("8.0"):
735         return linux_interfaces()
736     ifconfig_path = salt.utils.path.which("ifconfig")
737     cmd = subprocess.Popen(
738         [ifconfig_path, "-a"],
739         stdout=subprocess.PIPE,
740         stderr=subprocess.STDOUT,
741     ).communicate()[0]
742     return _netbsd_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
743 def _interfaces_ipconfig(out):
744     ifaces = dict()
745     iface = None
746     addr = None
747     adapter_iface_regex = re.compile(r"adapter (\S.+):$")
748     for line in out.splitlines():
749         if not line:
750             continue
751         if line.startswith("Ethernet"):
752             iface = ifaces[adapter_iface_regex.search(line).group(1)]
753             iface["up"] = True
754             addr = {}
755             continue
756         if iface:
757             key, val = line.split(",", 1)
758             key = key.strip(" .")
759             val = val.strip()
760             if addr and key == "Subnet Mask":
761                 addr["netmask"] = val
762             elif key in ("IP Address", "IPv4 Address"):
763                 if "inet" not in iface:
764                     iface["inet"] = list()
765                 addr = {
766                     "address": val.rstrip("(Preferred)"),
767                     "netmask": None,
768                     "broadcast": None,
769                 }  # TODO find the broadcast
770                 iface["inet"].append(addr)
771             elif "IPv6 Address" in key:
772                 if "inet6" not in iface:
773                     iface["inet"] = list()
774                 addr = {"address": val.rstrip("(Preferred)"), "prefixlen": None}
775                 iface["inet6"].append(addr)
776             elif key == "Physical Address":
777                 iface["hwaddr"] = val
778             elif key == "Media State":
779                 iface["up"] = val != "Media disconnected"
780 def win_interfaces():
781     if WIN_NETWORK_LOADED is False:
782         import salt.utils.win_network as _
783     return salt.utils.win_network.get_interface_info()
784 def interfaces():
785     if salt.utils.platform.is_windows():
786         return win_interfaces()
787     elif salt.utils.platform.is_junos():
788         return junos_interfaces()
789     elif salt.utils.platform.is_netbsd():
790         return netbsd_interfaces()
791     else:
792         return linux_interfaces()
793 def get_net_start(ipaddr, netmask):
794     net = ipaddress.ip_network("{}/{}".format(ipaddr, netmask), strict=False)
795     return str(net.network_address)
796 def get_net_size(mask):
797     binary_str = ""
798     for octet in mask.split("."):
799         binary_str += bin(int(octet))[2:].zfill(8)
800     return len(binary_str.rstrip("0"))
801 def calc_net(ipaddr, netmask=None):
802     if netmask is not None:
803         ipaddr = "{}/{}".format(ipaddr, netmask)
804     return str(ipaddress.ip_network(ipaddr, strict=False))
805 def _ipv4_to_bits(ipaddr):
806     return "".join([bin(int(x))[2:].rjust(8, "0") for x in ipaddr.split(".")])
807 def _get_iface_info(iface):
808     iface_info = interfaces()
809     if iface in iface_info.keys():
810         return iface_info, False
811     else:
812         error_msg = 'Interface "{}" not in available interfaces: "{}"'.format(
813             iface, '", "'.join(iface_info.keys())
814         )
815         log.error(error_msg)
816         return None, error_msg
817 def _hw_addr_aix(iface):
818     cmd = subprocess.Popen(
819         ["grep", "Hardware Address"],
820         stdin=subprocess.Popen(
821             ["entstat", "-d", iface],
822             stdout=subprocess.PIPE,
823             stderr=subprocess.STDOUT,
824         ).stdout,
825         stdout=subprocess.PIPE,
826         stderr=subprocess.STDOUT,
827     ).communicate()[0]
828     if cmd:
829         comps = cmd.split(" ")
830         if len(comps) == 3:
831             mac_addr = comps[2].strip("'").strip()
832             return mac_addr
833     error_msg = 'Interface "{}" either not available or does not contain a hardware address'.format(
834         iface
835     )
836     log.error(error_msg)
837     return error_msg
838 def hw_addr(iface):
839     if salt.utils.platform.is_aix():
840         return _hw_addr_aix
841     iface_info, error = _get_iface_info(iface)
842     if error is False:
843         return iface_info.get(iface, {}).get("hwaddr", "")
844     else:
845         return error
846 def interface(iface):
847     iface_info, error = _get_iface_info(iface)
848     if error is False:
849         return iface_info.get(iface, {}).get("inet", "")
850     else:
851         return error
852 def interface_ip(iface):
853     iface_info, error = _get_iface_info(iface)
854     if error is False:
855         inet = iface_info.get(iface, {}).get("inet", None)
856         return inet[0].get("address", "") if inet else ""
857     else:
858         return error
859 def _subnets(proto="inet", interfaces_=None):
860     if interfaces_ is None:
861         ifaces = interfaces()
862     elif isinstance(interfaces_, list):
863         ifaces = {}
864         for key, value in interfaces().items():
865             if key in interfaces_:
866                 ifaces[key] = value
867     else:
868         ifaces = {interfaces_: interfaces().get(interfaces_, {})}
869     ret = set()
870     if proto == "inet":
871         subnet = "netmask"
872         dflt_cidr = 32
873     elif proto == "inet6":
874         subnet = "prefixlen"
875         dflt_cidr = 128
876     else:
877         log.error("Invalid proto %s calling subnets()", proto)
878         return
879     for ip_info in ifaces.values():
880         addrs = ip_info.get(proto, [])
881         addrs.extend(
882             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
883         )
884         for intf in addrs:
885             if subnet in intf:
886                 intf = ipaddress.ip_interface(
887                     "{}/{}".format(intf["address"], intf[subnet])
888                 )
889             else:
890                 intf = ipaddress.ip_interface(
891                     "{}/{}".format(intf["address"], dflt_cidr)
892                 )
893             if not intf.is_loopback:
894                 ret.add(intf.network)
895     return [str(net) for net in sorted(ret)]
896 def subnets(interfaces=None):
897     return _subnets("inet", interfaces_=interfaces)
898 def subnets6():
899     return _subnets("inet6")
900 def in_subnet(cidr, addr=None):
901     try:
902         cidr = ipaddress.ip_network(cidr)
903     except ValueError:
904         log.error("Invalid CIDR '%s'", cidr)
905         return False
906     if addr is None:
907         addr = ip_addrs()
908         addr.extend(ip_addrs6())
909     elif not isinstance(addr, (list, tuple)):
910         addr = (addr,)
911     return any(ipaddress.ip_address(item) in cidr for item in addr)
912 def _get_ips(ifaces, proto="inet"):
913     ret = []
914     for ip_info in ifaces.values():
915         ret.extend(ip_info.get(proto, []))
916         ret.extend(
917             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
918         )
919     return ret
920 def _filter_interfaces(interface=None, interface_data=None):
921     ifaces = interface_data if isinstance(interface_data, dict) else interfaces()
922     if interface is None:
923         ret = ifaces
924     else:
925         interface = salt.utils.args.split_input(interface)
926         ret = {
927             k: v
928             for k, v in ifaces.items()
929             if any(fnmatch.fnmatch(k, pat) for pat in interface)
930         }
931     return ret
932 def _ip_addrs(
933     interface=None, include_loopback=False, interface_data=None, proto="inet"
934 ):
935     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
936     ret = set()
937     for addr in addrs:
938         addr = ipaddress.ip_address(addr.get("address"))
939         if not addr.is_loopback or include_loopback:
940             ret.add(addr)
941     return [str(addr) for addr in sorted(ret)]
942 def ip_addrs(interface=None, include_loopback=False, interface_data=None):
943     return _ip_addrs(interface, include_loopback, interface_data, "inet")
944 def ip_addrs6(interface=None, include_loopback=False, interface_data=None):
945     return _ip_addrs(interface, include_loopback, interface_data, "inet6")
946 def _ip_networks(
947     interface=None,
948     include_loopback=False,
949     verbose=False,
950     interface_data=None,
951     proto="inet",
952 ):
953     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
954     ret = set()
955     for addr in addrs:
956         _ip = addr.get("address")
957         _net = addr.get("netmask" if proto == "inet" else "prefixlen")
958         if _ip and _net:
959             try:
960                 ip_net = ipaddress.ip_network("{}/{}".format(_ip, _net), strict=False)
961             except Exception:  # pylint: disable=broad-except
962                 continue
963             if not ip_net.is_loopback or include_loopback:
964                 ret.add(ip_net)
965     if not verbose:
966         return [str(addr) for addr in sorted(ret)]
967     verbose_ret = {
968         str(x): {
969             "address": str(x.network_address),
970             "netmask": str(x.netmask),
971             "num_addresses": x.num_addresses,
972             "prefixlen": x.prefixlen,
973         }
974         for x in ret
975     }
976     return verbose_ret
977 def ip_networks(
978     interface=None, include_loopback=False, verbose=False, interface_data=None
979 ):
980     return _ip_networks(
981         interface=interface,
982         include_loopback=include_loopback,
983         verbose=verbose,
984         interface_data=interface_data,
985         proto="inet",
986     )
987 def ip_networks6(
988     interface=None, include_loopback=False, verbose=False, interface_data=None
989 ):
990     return _ip_networks(
991         interface=interface,
992         include_loopback=include_loopback,
993         verbose=verbose,
994         interface_data=interface_data,
995         proto="inet6",
996     )
997 def hex2ip(hex_ip, invert=False):
998     if len(hex_ip) == 32:  # ipv6
999         ip_addr = []
1000         for i in range(0, 32, 8):
1001             ip_part = hex_ip[i : i + 8]
1002             ip_part = [ip_part[x : x + 2] for x in range(0, 8, 2)]
1003             if invert:
1004                 ip_addr.append("{0[3]}{0[2]}:{0[1]}{0[0]}".format(ip_part))
1005             else:
1006                 ip_addr.append("{0[0]}{0[1]}:{0[2]}{0[3]}".format(ip_part))
1007         try:
1008             address = ipaddress.IPv6Address(":".join(ip_addr))
1009             if address.ipv4_mapped:
1010                 return str(address.ipv4_mapped)
1011             else:
1012                 return address.compressed
1013         except ipaddress.AddressValueError as ex:
1014             log.error("hex2ip - ipv6 address error: %s", ex)
1015             return hex_ip
1016     try:
1017         hip = int(hex_ip, 16)
1018     except ValueError:
1019         return hex_ip
1020     if invert:
1021         return "{3}.{2}.{1}.{0}".format(
1022             hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1023         )
1024     return "{}.{}.{}.{}".format(
1025         hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1026     )
1027 def mac2eui64(mac, prefix=None):
1028     eui64 = re.sub(r"[.:-]", "", mac).lower()
1029     eui64 = eui64[0:6] + "fffe" + eui64[6:]
1030     eui64 = hex(int(eui64[0:2], 16) | 2)[2:].zfill(2) + eui64[2:]
1031     if prefix is None:
1032         return ":".join(re.findall(r".{4}", eui64))
1033     else:
1034         try:
1035             net = ipaddress.ip_network(prefix, strict=False)
1036             euil = int("0x{}".format(eui64), 16)
1037             return "{}/{}".format(net[euil], net.prefixlen)
1038         except Exception:  # pylint: disable=broad-except
1039             return
1040 def active_tcp():
1041     ret = {}
1042     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1043         if not os.path.isfile(statf):
1044             continue
1045         with salt.utils.files.fopen(statf, "rb") as fp_:
1046             for line in fp_:
1047                 line = salt.utils.stringutils.to_unicode(line)
1048                 if line.strip().startswith("sl"):
1049                     continue
1050                 iret = _parse_tcp_line(line)
1051                 slot = next(iter(iret))
1052                 if iret[slot]["state"] == 1:  # 1 is ESTABLISHED
1053                     del iret[slot]["state"]
1054                     ret[len(ret)] = iret[slot]
1055     return ret
1056 def local_port_tcp(port):
1057     ret = _remotes_on(port, "local_port")
1058     return ret
1059 def remote_port_tcp(port):
1060     ret = _remotes_on(port, "remote_port")
1061     return ret
1062 def _remotes_on(port, which_end):
1063     port = int(port)
1064     ret = _netlink_tool_remote_on(port, which_end)
1065     if ret is not None:
1066         return ret
1067     ret = set()
1068     proc_available = False
1069     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1070         if not os.path.isfile(statf):
1071             continue
1072         proc_available = True
1073         with salt.utils.files.fopen(statf, "r") as fp_:
1074             for line in fp_:
1075                 line = salt.utils.stringutils.to_unicode(line)
1076                 if line.strip().startswith("sl"):
1077                     continue
1078                 iret = _parse_tcp_line(line)
1079                 slot = next(iter(iret))
1080                 if (
1081                     iret[slot][which_end] == port and iret[slot]["state"] == 1
1082                 ):  # 1 is ESTABLISHED
1083                     ret.add(iret[slot]["remote_addr"])
1084     if not proc_available:  # Fallback to use OS specific tools
1085         if salt.utils.platform.is_sunos():
1086             return _sunos_remotes_on(port, which_end)
1087         if salt.utils.platform.is_freebsd():
1088             return _freebsd_remotes_on(port, which_end)
1089         if salt.utils.platform.is_netbsd():
1090             return _netbsd_remotes_on(port, which_end)
1091         if salt.utils.platform.is_openbsd():
1092             return _openbsd_remotes_on(port, which_end)
1093         if salt.utils.platform.is_windows():
1094             return _windows_remotes_on(port, which_end)
1095         if salt.utils.platform.is_aix():
1096             return _aix_remotes_on(port, which_end)
1097         return _linux_remotes_on(port, which_end)
1098     return ret
1099 def _parse_tcp_line(line):
1100     ret = {}
1101     comps = line.strip().split()
1102     slot = comps[0].rstrip(":")
1103     ret[slot] = {}
1104     l_addr, l_port = comps[1].split(":")
1105     r_addr, r_port = comps[2].split(":")
1106     ret[slot]["local_addr"] = hex2ip(l_addr, True)
1107     ret[slot]["local_port"] = int(l_port, 16)
1108     ret[slot]["remote_addr"] = hex2ip(r_addr, True)
1109     ret[slot]["remote_port"] = int(r_port, 16)
1110     ret[slot]["state"] = int(comps[3], 16)
1111     return ret
1112 def _netlink_tool_remote_on(port, which_end):
1113     remotes = set()
1114     valid = False
1115     tcp_end = "dst" if which_end == "remote_port" else "src"
1116     try:
1117         data = subprocess.check_output(
1118             ["ss", "-ant", tcp_end, ":{}".format(port)]
1119         )  # pylint: disable=minimum-python-version
1120     except subprocess.CalledProcessError:
1121         log.error("Failed ss")
1122         raise
1123     except OSError:  # not command "No such file or directory"
1124         return None
1125     lines = salt.utils.stringutils.to_str(data).split("\n")
1126     for line in lines:
1127         if "Address:Port" in line:  # ss tools may not be valid
1128             valid = True
1129             continue
1130         elif "ESTAB" not in line:
1131             continue
1132         chunks = line.split()
1133         remote_host, remote_port = chunks[4].rsplit(":", 1)
1134         remotes.add(remote_host.strip("[]"))
1135     if valid is False:
1136         remotes = None
1137     return remotes
1138 def _sunos_remotes_on(port, which_end):
1139     remotes = set()
1140     try:
1141         data = subprocess.check_output(
1142             ["netstat", "-f", "inet", "-n"]
1143         )  # pylint: disable=minimum-python-version
1144     except subprocess.CalledProcessError:
1145         log.error("Failed netstat")
1146         raise
1147     lines = salt.utils.stringutils.to_str(data).split("\n")
1148     for line in lines:
1149         if "ESTABLISHED" not in line:
1150             continue
1151         chunks = line.split()
1152         local_host, local_port = chunks[0].rsplit(".", 1)
1153         remote_host, remote_port = chunks[1].rsplit(".", 1)
1154         if which_end == "remote_port" and int(remote_port) != port:
1155             continue
1156         if which_end == "local_port" and int(local_port) != port:
1157             continue
1158         remotes.add(remote_host)
1159     return remotes
1160 def _freebsd_remotes_on(port, which_end):
1161     port = int(port)
1162     remotes = set()
1163     try:
1164         cmd = salt.utils.args.shlex_split("sockstat -4 -c -p {}".format(port))
1165         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1166     except subprocess.CalledProcessError as ex:
1167         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1168         raise
1169     lines = salt.utils.stringutils.to_str(data).split("\n")
1170     for line in lines:
1171         chunks = line.split()
1172         if not chunks:
1173             continue
1174         if "COMMAND" in chunks[1]:
1175             continue  # ignore header
1176         if len(chunks) &lt; 2:
1177             continue
1178         local = chunks[-2]
1179         remote = chunks[-1]
1180         lhost, lport = local.split(":")
1181         rhost, rport = remote.split(":")
1182         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1183             continue
1184         if (
1185             which_end == "remote" and int(rport) != port
1186         ):  # ignore if remote port not port
1187             continue
1188         remotes.add(rhost)
1189     return remotes
1190 def _netbsd_remotes_on(port, which_end):
1191     port = int(port)
1192     remotes = set()
1193     try:
1194         cmd = salt.utils.args.shlex_split("sockstat -4 -c -n -p {}".format(port))
1195         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1196     except subprocess.CalledProcessError as ex:
1197         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1198         raise
1199     lines = salt.utils.stringutils.to_str(data).split("\n")
1200     for line in lines:
1201         chunks = line.split()
1202         if not chunks:
1203             continue
1204         if "COMMAND" in chunks[1]:
1205             continue  # ignore header
1206         if len(chunks) &lt; 2:
1207             continue
1208         local = chunks[5].split(".")
1209         lport = local.pop()
1210         lhost = ".".join(local)
1211         remote = chunks[6].split(".")
1212         rport = remote.pop()
1213         rhost = ".".join(remote)
1214         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1215             continue
1216         if (
1217             which_end == "remote" and int(rport) != port
1218         ):  # ignore if remote port not port
1219             continue
1220         remotes.add(rhost)
1221     return remotes
1222 def _openbsd_remotes_on(port, which_end):
1223     remotes = set()
1224     try:
1225         data = subprocess.check_output(
1226             ["netstat", "-nf", "inet"]
1227         )  # pylint: disable=minimum-python-version
1228     except subprocess.CalledProcessError:
1229         log.error("Failed netstat")
1230         raise
1231     lines = data.split("\n")
1232     for line in lines:
1233         if "ESTABLISHED" not in line:
1234             continue
1235         chunks = line.split()
1236         local_host, local_port = chunks[3].rsplit(".", 1)
1237         remote_host, remote_port = chunks[4].rsplit(".", 1)
1238         if which_end == "remote_port" and int(remote_port) != port:
1239             continue
1240         if which_end == "local_port" and int(local_port) != port:
1241             continue
1242         remotes.add(remote_host)
1243     return remotes
1244 def _windows_remotes_on(port, which_end):
1245     r"""
1246     Windows specific helper function.
1247     Returns set of ipv4 host addresses of remote established connections
1248     on local or remote tcp port.
1249     Parses output of shell 'netstat' to get connections
1250     C:\&gt;netstat -n
1251     Active Connections
1252        Proto  Local Address          Foreign Address        State
1253        TCP    10.2.33.17:3007        130.164.12.233:10123   ESTABLISHED
1254        TCP    10.2.33.17:3389        130.164.30.5:10378     ESTABLISHED
1255     Linux specific helper function.
1256     Returns set of ip host addresses of remote established connections
1257     on local tcp port port.
1258     Parses output of shell 'lsof'
1259     to get connections
1260     $ sudo lsof -iTCP:4505 -n
1261     COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
1262     Python   9971 root   35u  IPv4 0x18a8464a29ca329d      0t0  TCP *:4505 (LISTEN)
1263     Python   9971 root   37u  IPv4 0x18a8464a29b2b29d      0t0  TCP 127.0.0.1:4505-&gt;127.0.0.1:55703 (ESTABLISHED)
1264     Python  10152 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP 127.0.0.1:55703-&gt;127.0.0.1:4505 (ESTABLISHED)
1265     Python  10153 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP [fe80::249a]:4505-&gt;[fe80::150]:59367 (ESTABLISHED)
1266     """
1267     remotes = set()
1268     try:
1269         data = subprocess.check_output(
1270             [
1271                 "lsof",
1272                 "-iTCP:{:d}".format(port),
1273                 "-n",
1274                 "-P",
1275             ]  # pylint: disable=minimum-python-version
1276         )
1277     except subprocess.CalledProcessError as ex:
1278         if ex.returncode == 1:
1279             log.warning('"lsof" returncode = 1, likely no active TCP sessions.')
1280             return remotes
1281         log.error('Failed "lsof" with returncode = %s', ex.returncode)
1282         raise
1283     lines = salt.utils.stringutils.to_str(data).split("\n")
1284     for line in lines:
1285         chunks = line.split()
1286         if not chunks:
1287             continue
1288         if "COMMAND" in chunks[0]:
1289             continue  # ignore header
1290         if "ESTABLISHED" not in chunks[-1]:
1291             continue  # ignore if not ESTABLISHED
1292         local, remote = chunks[8].split("-&gt;")
1293         _, lport = local.rsplit(":", 1)
1294         rhost, rport = remote.rsplit(":", 1)
1295         if which_end == "remote_port" and int(rport) != port:
1296             continue
1297         if which_end == "local_port" and int(lport) != port:
1298             continue
1299         remotes.add(rhost.strip("[]"))
1300     return remotes
1301 def _aix_remotes_on(port, which_end):
1302     remotes = set()
1303     try:
1304         data = subprocess.check_output(
1305             ["netstat", "-f", "inet", "-n"]
1306         )  # pylint: disable=minimum-python-version
1307     except subprocess.CalledProcessError:
1308         log.error("Failed netstat")
1309         raise
1310     lines = salt.utils.stringutils.to_str(data).split("\n")
1311     for line in lines:
1312         if "ESTABLISHED" not in line:
1313             continue
1314         chunks = line.split()
1315         local_host, local_port = chunks[3].rsplit(".", 1)
1316         remote_host, remote_port = chunks[4].rsplit(".", 1)
1317         if which_end == "remote_port" and int(remote_port) != port:
1318             continue
1319         if which_end == "local_port" and int(local_port) != port:
1320             continue
1321         remotes.add(remote_host)
1322     return remotes
1323 @jinja_filter("gen_mac")
1324 def gen_mac(prefix="AC:DE:48"):
1325     return "{}:{:02X}:{:02X}:{:02X}".format(
1326         prefix,
1327         random.randint(0, 0xFF),
1328         random.randint(0, 0xFF),
1329         random.randint(0, 0xFF),
1330     )
1331 @jinja_filter("mac_str_to_bytes")
1332 def mac_str_to_bytes(mac_str):
1333     if len(mac_str) == 12:
1334         pass
1335     elif len(mac_str) == 17:
1336         sep = mac_str[2]
1337         mac_str = mac_str.replace(sep, "")
1338     else:
1339         raise ValueError("Invalid MAC address")
1340     chars = (int(mac_str[s : s + 2], 16) for s in range(0, 12, 2))
1341     return bytes(chars)
1342 def refresh_dns():
1343     try:
1344         RES_INIT()
1345     except NameError:
1346         pass
1347 @jinja_filter("dns_check")
1348 def dns_check(addr, port, safe=False, ipv6=None):
1349     ip_addrs = []
1350     family = (
1351         socket.AF_INET6
1352         if ipv6
1353         else socket.AF_INET
1354         if ipv6 is False
1355         else socket.AF_UNSPEC
1356     )
1357     socket_error = False
1358     try:
1359         refresh_dns()
1360         addrinfo = socket.getaddrinfo(addr, port, family, socket.SOCK_STREAM)
1361         ip_addrs = _test_addrs(addrinfo, port)
1362     except TypeError:
1363         raise SaltSystemExit(
1364             code=42,
1365             msg=(
1366                 "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1367                 " address".format(addr)
1368             ),
1369         )
1370     except OSError:
1371         socket_error = True
1372     if socket_error and ipv6:
1373         try:
1374             refresh_dns()
1375             addrinfo = socket.getaddrinfo(
1376                 addr, port, socket.AF_INET, socket.SOCK_STREAM
1377             )
1378             ip_addrs = _test_addrs(addrinfo, port)
1379         except TypeError:
1380             raise SaltSystemExit(
1381                 code=42,
1382                 msg=(
1383                     "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1384                     " address".format(addr)
1385                 ),
1386             )
1387         except OSError:
1388             error = True
1389     if not ip_addrs:
1390         err = "DNS lookup or connection check of '{}' failed.".format(addr)
1391         if safe:
1392             if salt.log.is_console_configured():
1393                 log.error(err)
1394             raise SaltClientError()
1395         raise SaltSystemExit(code=42, msg=err)
1396     return salt.utils.zeromq.ip_bracket(ip_addrs[0])
1397 def _test_addrs(addrinfo, port):
1398     ip_addrs = []
1399     for a in addrinfo:
1400         ip_family = a[0]
1401         ip_addr = a[4][0]
1402         if ip_addr in ip_addrs:
1403             continue
1404         ip_addrs.append(ip_addr)
1405         try:
1406             s = socket.socket(ip_family, socket.SOCK_STREAM)
1407             s.settimeout(2)
1408             s.connect((ip_addr, port))
1409             s.close()
1410             ip_addrs = [ip_addr]
1411             break
1412         except OSError:
1413             pass
1414     return ip_addrs
1415 def parse_host_port(host_port):
1416     host, port = None, None  # default
1417     _s_ = host_port[:]
1418     if _s_[0] == "[":
1419         if "]" in host_port:
1420             host, _s_ = _s_.lstrip("[").rsplit("]", 1)
1421             host = ipaddress.IPv6Address(host).compressed
1422             if _s_[0] == ":":
1423                 port = int(_s_.lstrip(":"))
1424             else:
1425                 if len(_s_) &gt; 1:
1426                     raise ValueError(
1427                         'found ambiguous "{}" port in "{}"'.format(_s_, host_port)
1428                     )
1429     else:
1430         if _s_.count(":") == 1:
1431             host, _hostport_separator_, port = _s_.partition(":")
1432             try:
1433                 port = int(port)
1434             except ValueError as _e_:
1435                 errmsg = 'host_port "{}" port value "{}" is not an integer.'.format(
1436                     host_port, port
1437                 )
1438                 log.error(errmsg)
1439                 raise ValueError(errmsg)
1440         else:
1441             host = _s_
1442     try:
1443         if not isinstance(host, ipaddress._BaseAddress):
1444             host_ip = ipaddress.ip_address(host).compressed
1445             host = host_ip
1446     except ValueError:
1447         log.debug('"%s" Not an IP address? Assuming it is a hostname.', host)
1448         if host != sanitize_host(host):
1449             log.error('bad hostname: "%s"', host)
1450             raise ValueError('bad hostname: "{}"'.format(host))
1451     return host, port
1452 @jinja_filter("filter_by_networks")
1453 def filter_by_networks(values, networks):
1454     _filter = lambda ips, networks: [
1455         ip for ip in ips for net in networks if ipaddress.ip_address(ip) in net
1456     ]
1457     if networks is not None:
1458         networks = [ipaddress.ip_network(network) for network in networks]
1459         if isinstance(values, Mapping):
1460             return {
1461                 interface: _filter(values[interface], networks) for interface in values
1462             }
1463         elif isinstance(values, Sequence):
1464             return _filter(values, networks)
1465         else:
1466             raise ValueError("Do not know how to filter a {}".format(type(values)))
1467     else:
1468         return values
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
