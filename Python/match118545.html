<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for httpserver_test.py &amp; win_lgpo_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for httpserver_test.py &amp; win_lgpo_1.py
      </h3>
<h1 align="center">
        2.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>httpserver_test.py (7.725322%)<th>win_lgpo_1.py (1.8210431%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-24)<td><a href="#" name="0">(39-59)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(196-199)<td><a href="#" name="1">(1798-1822)</a><td align="center"><font color="#d80000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(271-275)<td><a href="#" name="2">(9617-9626)</a><td align="center"><font color="#b20000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(709-714)<td><a href="#" name="3">(5110-5112)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(261-267)<td><a href="#" name="4">(8922-8926)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(243-247)<td><a href="#" name="5">(8144-8155)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(865-869)<td><a href="#" name="6">(6241-6247)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(742-745)<td><a href="#" name="7">(7542-7548)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(727-731)<td><a href="#" name="8">(7632-7638)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(608-611)<td><a href="#" name="9">(6039-6043)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(276-278)<td><a href="#" name="10">(7462-7467)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(173-175)<td><a href="#" name="11">(5392-5394)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>httpserver_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado import netutil
3 from salt.ext.tornado.escape import json_decode, json_encode, utf8, _unicode, recursive_unicode, native_str
4 from salt.ext.tornado import gen
5 from salt.ext.tornado.http1connection import HTTP1Connection
6 from salt.ext.tornado.httpserver import HTTPServer
7 from salt.ext.tornado.httputil import HTTPHeaders, HTTPMessageDelegate, HTTPServerConnectionDelegate, ResponseStartLine
8 from salt.ext.tornado.iostream import IOStream
9 from salt.ext.tornado.log import gen_log
10 from salt.ext.tornado.netutil import ssl_options_to_context
11 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
12 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog, gen_test
13 from salt.ext.tornado.test.util import unittest, skipOnTravis
14 from salt.ext.tornado.web import Application, RequestHandler, asynchronous, stream_request_body
15 from contextlib import closing
16 import datetime
17 import gzip
18 import os
19 import shutil
20 import</b></font> socket
21 import ssl
22 import sys
23 import tempfile
24 from io import BytesIO
25 def read_stream_body(stream, callback):
26     """Reads an HTTP response from `stream` and runs callback with its
27         module_dir <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= os.path.dirname(__file__)
28         existing_certificate = os.path.join(module_dir, 'test.crt')
29         existing_key = os.path.join(</b></font>module_dir, 'test.key')
30         self.assertRaises((ValueError, IOError),
31                           HTTPServer, application, ssl_options={
32                               "certfile": "/__mising__.crt",
33         })
34         self.assertRaises((ValueError, IOError),
35                           HTTPServer, application, ssl_options={
36                               "certfile": existing_certificate,
37                               "keyfile": "/__missing__.key"
38         })
39         HTTPServer(application, ssl_options={
40                    "certfile": existing_certificate,
41                    "keyfile": existing_key,
42                    })
43 class MultipartTestHandler(RequestHandler):
44     def post(self):
45         self.finish({<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"header": self.request.headers["X-Header-Encoding-Test"],
46                      "argument": self.get_argument("argument"),
47                      "filename": self.request.files["files"][0].filename,
48                      "filebody": _unicode(self.request.files["files"][0][</b></font>"body"]),
49                      })
50 class HTTPConnectionTest(AsyncHTTPTestCase):
51     def get_handlers(self):
52         return [("/multipart", MultipartTestHandler),
53                 ("/hello", HelloWorldRequestHandler)]
54     def get_app(self):
55         return Application(self.get_handlers())
56     def raw_fetch(self, headers, body, newline=b"\r\n"):
57         with closing(IOStream(socket.socket())) as stream:
58             stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
59             self.wait()
60             stream.write(
61                 newline.join(headers +
62                              [utf8("Content-Length: %d" % len(body))]) +
63                 newline + newline + body)
64             read_stream_body(stream, self.stop)
65             headers, body = self.wait()
66             return body
67     def test_multipart_form(self):
68         response = self.raw_fetch([
69             b"POST /multipart HTTP/1.0",
70             b"Content-Type: multipart/form-data; boundary=1234567890",
71             b"X-Header-encoding-test: \xe9",
72         ],
73             b"\r\n".join([
74                 b"Content-Disposition: form-data; name=argument",
75                 b"",
76                 u"\u00e1".encode("utf-8"),
77                 b"--1234567890",
78                 u'Content-Disposition: form-data; name="files"; filename="\u00f3"'.encode("utf8"),
79                 b"",
80                 u"\u00fa".encode("utf-8"),
81                 b"",
82             ]))
83         data = json_decode<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(response)
84         self.assertEqual(u"\u00e9", data["header"])
85         self.assertEqual(u"\u00e1", data["argument"])
86         self.assertEqual(u"\u00f3", data["filename"])
87         self.assertEqual(u"\u00fa", data[</b></font>"filebody"])
88     def test_newlines(self):
89         for newline in (b"\r\n", b"\n"):
90             response = self.raw_fetch([b"GET /hello HTTP/1.0"], b"",
91                                       newline=newline)
92             self.assertEqual(response, b'Hello world')
93     def test_100_continue(self):
94         stream = IOStream(socket.socket(), io_loop=self.io_loop)
95         stream.connect(("127.0.0.1", self<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get_http_port()), callback=self.stop)
96         self.wait()
97         stream.write(b"\r\n".join([b"POST /hello HTTP/1.1",
98                                    b"Content-Length: 1024",
99                                    b"Expect: 100-continue",
100                                    b"Connection: close",
101                                    b"\r\n"]), callback=self.</b></font>stop)
102         stream.read_until(b"\r\n\r\n", self.stop)
103         data = self.wait()
104         self.assertTrue<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(data.startswith(b"HTTP/1.1 100 "), data)
105         stream.write(b"a" * 1024)
106         first_line = self.wait()
107         self.assertTrue(first_line.</b></font>startswith(b"HTTP/1.1 200"), first_line)
108         stream<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.read_until(b"\r\n\r\n", self.stop)
109         header_data = self.wait()
110         headers = HTTPHeaders.parse(native_str(header_data.decode(</b></font>'latin1')))
111         stream.read_bytes(int(headers["Content-Length"]), self.stop)
112         body = self.wait()
113         self.assertEqual(body, b"Got 1024 bytes in POST")
114         stream.close()
115 class EchoHandler(RequestHandler):
116     def get(self):
117         self.write(recursive_unicode(self.request.arguments))
118     def post(self):
119         self.write(recursive_unicode(self.request.arguments))
120 class TypeCheckHandler(RequestHandler):
121     def prepare(self):
122         self.errors = {}
123         fields = [
124             ('method', str),
125             ('uri', str),
126             ('version', str),
127             ('remote_ip', str),
128             ('protocol', str),
129             ('host', str),
130             ('path', str),
131             ('query', str),
132         ]
133         for field, expected_type in fields:
134             self.check_type(field, getattr(self.request, field), expected_type)
135         self.check_type('header_key', list(self.request.headers.keys())[0], str)
136         self.check_type('header_value', list(self.request.headers.values())[0], str)
137         self.check_type('cookie_key', list(self.request.cookies.keys())[0], str)
138         self.check_type('cookie_value', list(self.request.cookies.values())[0].value, str)
139         self.check_type('arg_key', list(self.request.arguments.keys())[0], str)
140         self.check_type('arg_value', list(self.request.arguments.values())[0][0], bytes)
141     def post(self):
142         self.check_type('body', self.request.body, bytes)
143         self.write(self.errors)
144     def get(self):
145         self.write(self.errors)
146     def check_type(self, name, obj, expected_type):
147         actual_type = type(obj)
148         if expected_type != actual_type:
149             self.errors[name] = "expected %s, got %s" % (expected_type,
150                                                          actual_type)
151 class HTTPServerTest(AsyncHTTPTestCase):
152     def get_app(self):
153         return Application([("/echo", EchoHandler),
154                             ("/typecheck", TypeCheckHandler),
155                             ("//doubleslash", EchoHandler),
156                             ])
157     def test_query_string_encoding(self):
158         response = self.fetch("/echo?foo=%C3%A9")
159         data = json_decode(response.body)
160         self.assertEqual(data, {u"foo": [u"\u00e9"]})
161     def test_empty_query_string(self):
162         response = self.fetch("/echo?foo=&amp;foo=")
163         data = json_decode(response.body)
164         self.assertEqual(data, {u"foo": [u"", u""]})
165     def test_empty_post_parameters(self):
166         response = self.fetch("/echo", method="POST", body="foo=&amp;bar=")
167         data = json_decode(response.body)
168         self.assertEqual(data, {u"foo": [u""], u"bar": [u""]})
169     def test_types(self):
170         headers = {"Cookie": "foo=bar"}
171         response = self.fetch("/typecheck?foo=bar", headers=headers)
172         data = json_decode(response.body)
173         self.assertEqual(data, {})
174         response = self.fetch("/typecheck", method="POST", body="foo=bar", headers=headers)
175         data = json_decode(response.body)
176         self.assertEqual(data, {})
177     def test_double_slash(self):
178         response = self.fetch("//doubleslash")
179         self.assertEqual(200, response.code)
180         self.assertEqual(json_decode(response.body), {})
181     def test_malformed_body(self):
182         if str is bytes:
183             return
184         with ExpectLog(gen_log, 'Invalid x-www-form-urlencoded body'):
185             response = self.fetch(
186                 '/echo', method="POST",
187                 headers={'Content-Type': 'application/x-www-form-urlencoded'},
188                 body=b'\xe9')
189         self.assertEqual(200, response.code)
190         self.assertEqual(b'{}', response.body)
191 class HTTPServerRawTest(AsyncHTTPTestCase):
192     def get_app(self):
193         return Application([
194             ('/echo', EchoHandler),
195         ])
196     def setUp(self):
197         super(HTTPServerRawTest, self).setUp()
198         self.stream = IOStream(socket.socket())
199         self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
200         self.wait()
201     def tearDown(self):
202         self.stream.close()
203         super(HTTPServerRawTest, self).tearDown()
204     def test_empty_request(self):
205         self.stream.close()
206         self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
207         self.wait()
208     def test_malformed_first_line(self):
209         with ExpectLog(gen_log, '.*Malformed HTTP request line'):
210             self.stream.write(b'asdf\r\n\r\n')
211             self.io_loop.add_timeout(datetime.timedelta(seconds=0.05),
212                                      self.stop)
213             self.wait()
214     def test_malformed_headers(self):
215         with ExpectLog(gen_log, '.*Malformed HTTP headers'):
216             self.stream.write(b'GET / HTTP/1.0\r\nasdf\r\n\r\n')
217             self.io_loop.add_timeout(datetime.timedelta(seconds=0.05),
218                                      self.stop)
219             self.wait()
220     def test_chunked_request_body(self):
221         self.stream.write(b"""\
222 POST /echo HTTP/1.1
223 Transfer-Encoding: chunked
224 Content-Type: application/x-www-form-urlencoded
225 4
226 foo=
227 3
228 bar
229 0
230 """.replace(b"\n", b"\r\n"))
231         read_stream_body(self.stream, self.stop)
232         headers, response = self.wait()
233         self.assertEqual(json_decode(response), {u'foo': [u'bar']})
234     def test_chunked_request_uppercase(self):
235         self.stream.write(b"""\
236 POST /echo HTTP/1.1
237 Transfer-Encoding: Chunked
238 Content-Type: application/x-www-form-urlencoded
239 4
240 foo=
241 3
242 bar
243 0
244 """.replace(b"\n", b"\r\n"))
245         read_stream_body(self.stream, self.stop)
246         headers, response = self.wait()
247         self.assertEqual(json_decode(response), {u'foo': [u'bar']})
248     def test_invalid_content_length(self):
249         with ExpectLog(gen_log, '.*Only integer Content-Length is allowed'):
250             self.stream.write(b"""\
251 POST /echo HTTP/1.1
252 Content-Length: foo
253 bar
254 """.replace(b"\n", b"\r\n"))
255             self.stream.read_until_close(self.stop)
256             self.wait()
257 class XHeaderTest(HandlerBaseTestCase):
258     class Handler(RequestHandler):
259         def get(self):
260             self.write(dict(remote_ip=self.request.remote_ip,
261                             remote_protocol=self.request.protocol))
262     def get_httpserver_options(self):
263         return dict(xheaders=True, trusted_downstream=['5.5.5.5'])
264     def test_ip_headers(self):
265         self.assertEqual(self.fetch_json("/")["remote_ip"], "127.0.0.1")
266         valid_ipv4 = {"X-Real-IP": "4.4.4.4"}
267         self.assertEqual(
268             self.fetch_json("/", headers=valid_ipv4)["remote_ip"],
269             "4.4.4.4")
270         valid_ipv4_list = {"X-Forwarded-For": "127.0.0.1, 4.4.4.4"}
271         self.assertEqual(
272             self.fetch_json("/", headers=valid_ipv4_list)["remote_ip"],
273             "4.4.4.4")
274         valid_ipv6 = {"X-Real-IP": "2620:0:1cfe:face:b00c::3"}
275         self.assertEqual(
276             self.fetch_json("/", headers=valid_ipv6)["remote_ip"],
277             "2620:0:1cfe:face:b00c::3")
278         valid_ipv6_list = {"X-Forwarded-For": "::1, 2620:0:1cfe:face:b00c::3"}
279         self.assertEqual(
280             self.fetch_json("/", headers=valid_ipv6_list)["remote_ip"],
281             "2620:0:1cfe:face:b00c::3")
282         invalid_chars = {"X-Real-IP": "4.4.4.4&lt;script&gt;"}
283         self.assertEqual(
284             self.fetch_json("/", headers=invalid_chars)["remote_ip"],
285             "127.0.0.1")
286         invalid_chars_list = {"X-Forwarded-For": "4.4.4.4, 5.5.5.5&lt;script&gt;"}
287         self.assertEqual(
288             self.fetch_json("/", headers=invalid_chars_list)["remote_ip"],
289             "127.0.0.1")
290         invalid_host = {"X-Real-IP": "www.google.com"}
291         self.assertEqual(
292             self.fetch_json("/", headers=invalid_host)["remote_ip"],
293             "127.0.0.1")
294     def test_trusted_downstream(self):
295         valid_ipv4_list = {"X-Forwarded-For": "127.0.0.1, 4.4.4.4, 5.5.5.5"}
296         self.assertEqual(
297             self.fetch_json("/", headers=valid_ipv4_list)["remote_ip"],
298             "4.4.4.4")
299     def test_scheme_headers(self):
300         self.assertEqual(self.fetch_json("/")["remote_protocol"], "http")
301         https_scheme = {"X-Scheme": "https"}
302         self.assertEqual(
303             self.fetch_json("/", headers=https_scheme)["remote_protocol"],
304             "https")
305         https_forwarded = {"X-Forwarded-Proto": "https"}
306         self.assertEqual(
307             self.fetch_json("/", headers=https_forwarded)["remote_protocol"],
308             "https")
309         bad_forwarded = {"X-Forwarded-Proto": "unknown"}
310         self.assertEqual(
311             self.fetch_json("/", headers=bad_forwarded)["remote_protocol"],
312             "http")
313 class SSLXHeaderTest(AsyncHTTPSTestCase, HandlerBaseTestCase):
314     def get_app(self):
315         return Application([('/', XHeaderTest.Handler)])
316     def get_httpserver_options(self):
317         output = super(SSLXHeaderTest, self).get_httpserver_options()
318         output['xheaders'] = True
319         return output
320     def test_request_without_xprotocol(self):
321         self.assertEqual(self.fetch_json("/")["remote_protocol"], "https")
322         http_scheme = {"X-Scheme": "http"}
323         self.assertEqual(
324             self.fetch_json("/", headers=http_scheme)["remote_protocol"], "http")
325         bad_scheme = {"X-Scheme": "unknown"}
326         self.assertEqual(
327             self.fetch_json("/", headers=bad_scheme)["remote_protocol"], "https")
328 class ManualProtocolTest(HandlerBaseTestCase):
329     class Handler(RequestHandler):
330         def get(self):
331             self.write(dict(protocol=self.request.protocol))
332     def get_httpserver_options(self):
333         return dict(protocol='https')
334     def test_manual_protocol(self):
335         self.assertEqual(self.fetch_json('/')['protocol'], 'https')
336 @unittest.skipIf(not hasattr(socket, 'AF_UNIX') or sys.platform == 'cygwin',
337                  "unix sockets not supported on this platform")
338 class UnixSocketTest(AsyncTestCase):
339     """HTTPServers can listen on Unix sockets too.
340     Why would you want to do this?  Nginx can proxy to backends listening
341     on unix sockets, for one thing (and managing a namespace for unix
342     sockets can be easier than managing a bunch of TCP port numbers).
343     Unfortunately, there's no way to specify a unix socket in a url for
344     an HTTP client, so we have to test this by hand.
345     """
346     def setUp(self):
347         super(UnixSocketTest, self).setUp()
348         self.tmpdir = tempfile.mkdtemp()
349         self.sockfile = os.path.join(self.tmpdir, "test.sock")
350         sock = netutil.bind_unix_socket(self.sockfile)
351         app = Application([("/hello", HelloWorldRequestHandler)])
352         self.server = HTTPServer(app, io_loop=self.io_loop)
353         self.server.add_socket(sock)
354         self.stream = IOStream(socket.socket(socket.AF_UNIX), io_loop=self.io_loop)
355         self.stream.connect(self.sockfile, self.stop)
356     def tearDown(self):
357         self<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.stream.close()
358         self.server.stop()
359         shutil.rmtree(self.tmpdir)
360         super(UnixSocketTest, self).tearDown(</b></font>)
361     def test_unix_socket(self):
362         self.stream.write(b"GET /hello HTTP/1.0\r\n\r\n")
363         self.stream.read_until(b"\r\n", self.stop)
364         response = self.wait()
365         self.assertEqual(response, b"HTTP/1.1 200 OK\r\n")
366         self.stream.read_until(b"\r\n\r\n", self.stop)
367         headers = HTTPHeaders.parse(self.wait().decode('latin1'))
368         self.stream.read_bytes(int(headers["Content-Length"]), self.stop)
369         body = self.wait()
370         self.assertEqual(body, b"Hello world")
371     def test_unix_socket_bad_request(self):
372         with ExpectLog(gen_log, "Malformed HTTP message from"):
373             self.stream.write(b"garbage\r\n\r\n")
374             self.stream.read_until_close(self.stop)
375             response = self.wait()
376         self.assertEqual(response, b"")
377 class KeepAliveTest(AsyncHTTPTestCase):
378     """Tests various scenarios for HTTP 1.1 keep-alive support.
379     These tests don't use AsyncHTTPClient because we want to control
380     connection reuse and closing.
381     """
382     def get_app(self):
383         class HelloHandler(RequestHandler):
384             def get(self):
385                 self.finish('Hello world')
386             def post(self):
387                 self.finish('Hello world')
388         class LargeHandler(RequestHandler):
389             def get(self):
390                 self.write(''.join(chr(i % 256) * 1024 for i in range(512)))
391         class FinishOnCloseHandler(RequestHandler):
392             @asynchronous
393             def get(self):
394                 self.flush()
395             def on_connection_close(self):
396                 self.finish('closed')
397         return Application([('/', HelloHandler),
398                             ('/large', LargeHandler),
399                             ('/finish_on_close', FinishOnCloseHandler)])
400     def setUp(self):
401         super(KeepAliveTest, self).setUp()
402         self.http_version = b'HTTP/1.1'
403     def tearDown(self):
404         self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
405         self.wait()
406         if hasattr(self, 'stream'):
407             self.stream.close()
408         super(KeepAliveTest, self).tearDown()
409     def connect(self):
410         self.stream = IOStream(socket.socket(), io_loop=self.io_loop)
411         self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
412         self.wait()
413     def read_headers(self):
414         self.stream.read_until(b'\r\n', self.stop)
415         first_line = self.wait()
416         self.assertTrue(first_line.startswith(b'HTTP/1.1 200'), first_line)
417         self.stream.read_until(b'\r\n\r\n', self.stop)
418         header_bytes = self.wait()
419         headers = HTTPHeaders.parse(header_bytes.decode('latin1'))
420         return headers
421     def read_response(self):
422         self.headers = self.read_headers()
423         self.stream.read_bytes(int(self.headers['Content-Length']), self.stop)
424         body = self.wait()
425         self.assertEqual(b'Hello world', body)
426     def close(self):
427         self.stream.close()
428     def test_two_requests(self):
429         self<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.connect()
430         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
431         self.read_response()
432         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
433         self.read_response()
434         self.</b></font>close()
435     def test_request_close(self):
436         self.connect()
437         self.stream.write(b'GET / HTTP/1.1\r\nConnection: close\r\n\r\n')
438         self.read_response()
439         self.stream.read_until_close(callback=self.stop)
440         data = self.wait()
441         self.assertTrue(not data)
442         self.close()
443     def test_http10(self):
444         self<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.http_version = b'HTTP/1.0'
445         self.connect()
446         self.stream.write(b'GET / HTTP/1.0\r\n\r\n')
447         self.read_response()
448         self.stream.read_until_close(</b></font>callback=self.stop)
449         data = self.wait()
450         self.assertTrue(not data)
451         self.assertTrue('Connection' not in self.headers)
452         self.close()
453     def test_http10_keepalive(self):
454         self.http_version = b'HTTP/1.0'
455         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
456         self.read_response()
457         self<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(self.headers['Connection'], 'Keep-Alive')
458         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
459         self.read_response()
460         self.assertEqual(self.</b></font>headers['Connection'], 'Keep-Alive')
461         self.close()
462     def test_http10_keepalive_extra_crlf(self):
463         self.http_version = b'HTTP/1.0'
464         self.connect()
465         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n\r\n')
466         self.read_response()
467         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
468         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
469         self.read_response()
470         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
471         self.close()
472     def test_pipelined_requests(self):
473         self.connect()
474         self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
475         self.read_response()
476         self.read_response()
477         self.close()
478     def test_pipelined_cancel(self):
479         self.connect()
480         self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
481         self.read_response()
482         self.close()
483     def test_cancel_during_download(self):
484         self.connect()
485         self.stream.write(b'GET /large HTTP/1.1\r\n\r\n')
486         self.read_headers()
487         self.stream.read_bytes(1024, self.stop)
488         self.wait()
489         self.close()
490     def test_finish_while_closed(self):
491         self.connect()
492         self.stream.write(b'GET /finish_on_close HTTP/1.1\r\n\r\n')
493         self.read_headers()
494         self.close()
495     def test_keepalive_chunked(self):
496         self.http_version = b'HTTP/1.0'
497         self.connect()
498         self.stream.write(b'POST / HTTP/1.0\r\n'
499                           b'Connection: keep-alive\r\n'
500                           b'Transfer-Encoding: chunked\r\n'
501                           b'\r\n'
502                           b'0\r\n'
503                           b'\r\n')
504         self.read_response()
505         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
506         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
507         self.read_response()
508         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
509         self.close()
510 class GzipBaseTest(object):
511     def get_app(self):
512         return Application([('/', EchoHandler)])
513     def post_gzip(self, body):
514         bytesio = BytesIO()
515         gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
516         gzip_file.write(utf8(body))
517         gzip_file.close()
518         compressed_body = bytesio.getvalue()
519         return self.fetch('/', method='POST', body=compressed_body,
520                           headers={'Content-Encoding': 'gzip'})
521     def test_uncompressed(self):
522         response = self.fetch('/', method='POST', body='foo=bar')
523         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
524 class GzipTest(GzipBaseTest, AsyncHTTPTestCase):
525     def get_httpserver_options(self):
526         return dict(decompress_request=True)
527     def test_gzip(self):
528         response = self.post_gzip('foo=bar')
529         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
530 class GzipUnsupportedTest(GzipBaseTest, AsyncHTTPTestCase):
531     def test_gzip_unsupported(self):
532         with ExpectLog(gen_log, "Unsupported Content-Encoding"):
533             response = self.post_gzip('foo=bar')
534         self.assertEquals(json_decode(response.body), {})
535 class StreamingChunkSizeTest(AsyncHTTPTestCase):
536     BODY = b'01234567890123456789012345678901234567890123456789'
537     CHUNK_SIZE = 16
538     def get_http_client(self):
539         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
540     def get_httpserver_options(self):
541         return dict(chunk_size=self.CHUNK_SIZE, decompress_request=True)
542     class MessageDelegate(HTTPMessageDelegate):
543         def __init__(self, connection):
544             self.connection = connection
545         def headers_received(self, start_line, headers):
546             self.chunk_lengths = []
547         def data_received(self, chunk):
548         def finish(self):
549             response_body = utf8<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(json_encode(self.chunk_lengths))
550             self.connection.write_headers(
551                 ResponseStartLine('HTTP/1.1', 200, 'OK'),
552                 HTTPHeaders({'Content-Length': str(len(response_body))}))
553             self.</b></font>connection.write(response_body)
554             self.connection.finish()
555     def get_app(self):
556         class App(HTTPServerConnectionDelegate):
557             def start_request(self, server_conn, request_conn):
558                 return StreamingChunkSizeTest.MessageDelegate(request_conn)
559         return App()
560     def fetch_chunk_sizes(self, **kwargs):
561         response = self.fetch('/', method='POST', **kwargs)
562         response.rethrow()
563         chunks = json_decode(response.body)
564         self.assertEqual(len(self.BODY), sum(chunks))
565         for chunk_size in chunks:
566             self.assertLessEqual(chunk_size, self.CHUNK_SIZE,
567                                  'oversized chunk: ' + str(chunks))
568             self.assertGreater(chunk_size, 0,
569                                'empty chunk: ' + str(chunks))
570         return chunks
571     def compress(self, body):
572         bytesio = BytesIO()
573         gzfile = gzip.GzipFile(mode='w', fileobj=bytesio)
574         gzfile.write(body)
575         gzfile.close()
576         compressed = bytesio.getvalue()
577         if len(compressed) &gt;= len(body):
578             raise Exception("body did not shrink when compressed")
579         return compressed
580     def test_regular_body(self):
581         chunks = self.fetch_chunk_sizes(body=self.BODY)
582         self.assertEqual([16, 16, 16, 2], chunks)
583     def test_compressed_body(self):
584         self.fetch_chunk_sizes(body=self.compress(self.BODY),
585                                headers={'Content-Encoding': 'gzip'})
586     def test_chunked_body(self):
587         def body_producer(write):
588             write(self.BODY[:20])
589             write(self.BODY[20:])
590         chunks = self.fetch_chunk_sizes(body_producer=body_producer)
591         self.assertEqual([16, 4, 16, 14], chunks)
592     def test_chunked_compressed(self):
593         compressed = self.compress(self.BODY)
594         self.assertGreater(len(compressed), 20)
595         def body_producer(write):
596             write(compressed[:20])
597             write(compressed[20:])
598         self.fetch_chunk_sizes(body_producer=body_producer,
599                                headers={'Content-Encoding': 'gzip'})
600 class MaxHeaderSizeTest(AsyncHTTPTestCase):
601     def get_app(self):
602         return Application([('/', HelloWorldRequestHandler)])
603     def get_httpserver_options(self):
604         return dict(max_header_size=1024)
605     def test_small_headers(self):
606         response = self.fetch("/", headers={'X-Filler': 'a' * 100})
607         response.rethrow()
608         self.assertEqual(response.body, b"Hello world")
609     def test_large_headers(self):
610         with ExpectLog(gen_log, "Unsatisfiable read", required=False):
611             response = self.fetch("/", headers={'X-Filler': 'a' * 1000})
612         self.assertIn(response.code, (431, 599))
613 @skipOnTravis
614 class IdleTimeoutTest(AsyncHTTPTestCase):
615     def get_app(self):
616         return Application([('/', HelloWorldRequestHandler)])
617     def get_httpserver_options(self):
618         return dict(idle_connection_timeout=0.1)
619     def setUp(self):
620         super(IdleTimeoutTest, self).setUp()
621         self.streams = []
622     def tearDown(self):
623         super(IdleTimeoutTest, self).tearDown()
624         for stream in self.streams:
625             stream.close()
626     def connect(self):
627         stream = IOStream(socket.socket())
628         stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
629         self.wait()
630         self.streams.append(stream)
631         return stream
632     def test_unused_connection(self):
633         stream = self.connect()
634         stream.set_close_callback(self.stop)
635         self.wait()
636     def test_idle_after_use(self):
637         stream = self.connect()
638         stream.set_close_callback(lambda: self.stop("closed"))
639         for i in range(2):
640             stream.write(b"GET / HTTP/1.1\r\n\r\n")
641             stream.read_until(b"\r\n\r\n", self.stop)
642             self.wait()
643             stream.read_bytes(11, self.stop)
644             data = self.wait()
645             self.assertEqual(data, b"Hello world")
646         data = self.wait()
647         self.assertEqual(data, "closed")
648 class BodyLimitsTest(AsyncHTTPTestCase):
649     def get_app(self):
650         class BufferedHandler(RequestHandler):
651             def put(self):
652                 self.write(str(len(self.request.body)))
653         @stream_request_body
654         class StreamingHandler(RequestHandler):
655             def initialize(self):
656                 self.bytes_read = 0
657             def prepare(self):
658                 if 'expected_size' in self.request.arguments:
659                     self.request.connection.set_max_body_size(
660                         int(self.get_argument('expected_size')))
661                 if 'body_timeout' in self.request.arguments:
662                     self.request.connection.set_body_timeout(
663                         float(self.get_argument('body_timeout')))
664             def data_received(self, data):
665                 self.bytes_read += len(data)
666             def put(self):
667                 self.write(str(self.bytes_read))
668         return Application([('/buffered', BufferedHandler),
669                             ('/streaming', StreamingHandler)])
670     def get_httpserver_options(self):
671         return dict(body_timeout=3600, max_body_size=4096)
672     def get_http_client(self):
673         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
674     def test_small_body(self):
675         response = self.fetch('/buffered', method='PUT', body=b'a' * 4096)
676         self.assertEqual(response.body, b'4096')
677         response = self.fetch('/streaming', method='PUT', body=b'a' * 4096)
678         self.assertEqual(response.body, b'4096')
679     def test_large_body_buffered(self):
680         with ExpectLog(gen_log, '.*Content-Length too long'):
681             response = self.fetch('/buffered', method='PUT', body=b'a' * 10240)
682         self.assertEqual(response.code, 599)
683     def test_large_body_buffered_chunked(self):
684         with ExpectLog(gen_log, '.*chunked body too large'):
685             response = self.fetch('/buffered', method='PUT',
686                                   body_producer=lambda write: write(b'a' * 10240))
687         self.assertEqual(response.code, 599)
688     def test_large_body_streaming(self):
689         with ExpectLog(gen_log, '.*Content-Length too long'):
690             response = self.fetch('/streaming', method='PUT', body=b'a' * 10240)
691         self.assertEqual(response.code, 599)
692     def test_large_body_streaming_chunked(self):
693         with ExpectLog(gen_log, '.*chunked body too large'):
694             response = self.fetch('/streaming', method='PUT',
695                                   body_producer=lambda write: write(b'a' * 10240))
696         self.assertEqual(response.code, 599)
697     def test_large_body_streaming_override(self):
698         response = self.fetch('/streaming?expected_size=10240', method='PUT',
699                               body=b'a' * 10240)
700         self.assertEqual(response.body, b'10240')
701     def test_large_body_streaming_chunked_override(self):
702         response = self.fetch('/streaming?expected_size=10240', method='PUT',
703                               body_producer=lambda write: write(b'a' * 10240))
704         self.assertEqual(response.body, b'10240')
705     @gen_test
706     def test_timeout(self):
707         stream = IOStream(socket.socket())
708         try:
709             yield stream.connect(('127.0.0.1', self.get_http_port()))
710             stream.write(b'PUT /streaming?body_timeout=0.1 HTTP/1.0\r\n'
711                          b'Content-Length: 42\r\n\r\n')
712             with ExpectLog(gen_log, 'Timeout reading body'):
713                 response = yield stream.read_until_close()
714             self.assertEqual(response, b'')
715         finally:
716             stream.close()
717     @gen_test
718     def test_body_size_override_reset(self):
719         stream = IOStream(socket.socket())
720         try:
721             yield stream.connect(('127.0.0.1', self.get_http_port()))
722             stream.write(b'PUT /streaming?expected_size=10240 HTTP/1.1\r\n'
723                          b'Content-Length: 10240\r\n\r\n')
724             stream.write(b'a' * 10240)
725             headers, response = yield gen.Task(read_stream_body, stream)
726             self.assertEqual(response, b'10240')
727             stream.write(b'PUT /streaming HTTP/1.1\r\n'
728                          b'Content-Length: 10240\r\n\r\n')
729             with ExpectLog(gen_log, '.*Content-Length too long'):
730                 data = yield stream.read_until_close()
731             self.assertEqual(data, b'')
732         finally:
733             stream.close()
734 class LegacyInterfaceTest(AsyncHTTPTestCase):
735     def get_app(self):
736         def handle_request(request):
737             self.http1 = request.version.startswith("HTTP/1.")
738             if not self.http1:
739                 request.connection.write_headers(
740                     ResponseStartLine('', 200, 'OK'),
741                     HTTPHeaders())
742                 request.connection.finish()
743                 return
744             message = b"Hello world"
745             request.write(utf8("HTTP/1.1 200 OK\r\n"
746                                "Content-Length: %d\r\n\r\n" % len(message)))
747             request.write(message)
748             request.finish()
749         return handle_request
750     def test_legacy_interface(self):
751         response = self.fetch('/')
752         if not self.http1:
753             self.skipTest("requires HTTP/1.x")
754         self.assertEqual(response.body, b"Hello world")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_lgpo_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Manage Local Policy on Windows
3 This module allows configuring local group policy (i.e. ``gpedit.msc``) on a
4 Windows server.
5 .. versionadded:: 2016.11.0
6 Administrative Templates
7 ========================
8 Administrative template policies are dynamically read from ADMX/ADML files on
9 the server.
10 Windows Settings
11 ================
12 Policies contained in the "Windows Settings" section of the ``gpedit.msc`` GUI
13 are statically defined in this module. Each policy is configured for the section
14 (Machine/User) in the module's _policy_info class. The ``_policy_info`` class
15 contains a "policies" dict on how the module will configure the policy, where
16 the policy resides in the GUI (for display purposes), data validation data, data
17 transformation data, etc.
18 Current known limitations
19 =========================
20 - At this time, start/shutdown scripts policies are displayed, but are not
21   configurable.
22 - Not all "Security Settings" policies exist in the _policy_info class
23 :depends:
24   - pywin32 Python module
25   - lxml
26   - uuid
27   - salt.utils.win_reg
28 """
29 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import csv
30 import ctypes
31 import glob
32 import io
33 import locale
34 import logging
35 import os
36 import re
37 import tempfile
38 import time
39 import uuid
40 import zlib
41 import salt.utils.dictupdate as dictupdate
42 import salt.utils.files
43 import salt.utils.path
44 import salt.utils.platform
45 import salt.utils.stringutils
46 import salt.utils.win_lgpo_netsh
47 from salt.exceptions import CommandExecutionError, SaltInvocationError
48 from</b></font> salt.serializers.configparser import deserialize
49 log = logging.getLogger(__name__)
50 __virtualname__ = "lgpo"
51 __func_alias__ = {"set_": "set"}
52 UUID = uuid.uuid4().hex
53 adm_policy_name_map = {True: {}, False: {}}
54 HAS_WINDOWS_MODULES = False
55 TRUE_VALUE_XPATH = None
56 FALSE_VALUE_XPATH = None
57 ELEMENTS_XPATH = None
58 ENABLED_VALUE_XPATH = None
59 DISABLED_VALUE_XPATH = None
60 ENABLED_LIST_XPATH = None
61 DISABLED_LIST_XPATH = None
62 VALUE_XPATH = None
63 TRUE_LIST_XPATH = None
64 FALSE_LIST_XPATH = None
65 REGKEY_XPATH = None
66 POLICY_ANCESTOR_XPATH = None
67 ALL_CLASS_POLICY_XPATH = None
68 ADML_DISPLAY_NAME_XPATH = None
69 VALUE_LIST_XPATH = None
70 ENUM_ITEM_DISPLAY_NAME_XPATH = None
71 ADMX_SEARCH_XPATH = None
72 ADML_SEARCH_XPATH = None
73 ADMX_DISPLAYNAME_SEARCH_XPATH = None
74 PRESENTATION_ANCESTOR_XPATH = None
75 TEXT_ELEMENT_XPATH = None
76 try:
77     import struct
78     import lxml
79     import win32net
80     import win32security
81     from lxml import etree
82     from salt.utils.win_reg import Registry
83     HAS_WINDOWS_MODULES = True
84     TRUE_VALUE_XPATH = etree.XPath('.//*[local-name() = "trueValue"]')
85     FALSE_VALUE_XPATH = etree.XPath('.//*[local-name() = "falseValue"]')
86     ELEMENTS_XPATH = etree.XPath('.//*[local-name() = "elements"]')
87     ENABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "enabledValue"]')
88     DISABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "disabledValue"]')
89     ENABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "enabledList"]')
90     DISABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "disabledList"]')
91     VALUE_XPATH = etree.XPath('.//*[local-name() = "value"]')
92     TRUE_LIST_XPATH = etree.XPath('.//*[local-name() = "trueList"]')
93     FALSE_LIST_XPATH = etree.XPath('.//*[local-name() = "falseList"]')
94     REGKEY_XPATH = etree.XPath("//*[@key = $keyvalue]")
95     POLICY_ANCESTOR_XPATH = etree.XPath('ancestor::*[local-name() = "policy"]')
96     ALL_CLASS_POLICY_XPATH = etree.XPath(
97         '//*[local-name() = "policy" and (@*[local-name() = "class"] = "Both" or'
98         ' @*[local-name() = "class"] = $registry_class)]'
99     )
100     ADML_DISPLAY_NAME_XPATH = etree.XPath(
101         '//*[local-name() = $displayNameType and @*[local-name() = "id"] ='
102         " $displayNameId]"
103     )
104     VALUE_LIST_XPATH = etree.XPath('.//*[local-name() = "valueList"]')
105     ENUM_ITEM_DISPLAY_NAME_XPATH = etree.XPath(
106         './/*[local-name() = "item" and @*[local-name() = "displayName" ='
107         " $display_name]]"
108     )
109     ADMX_SEARCH_XPATH = etree.XPath(
110         '//*[local-name() = "policy" and @*[local-name() = "name"] = $policy_name and'
111         ' (@*[local-name() = "class"] = "Both" or @*[local-name() = "class"] ='
112         " $registry_class)]"
113     )
114     ADML_SEARCH_XPATH = etree.XPath(
115         '//*[starts-with(text(), $policy_name) and @*[local-name() = "id"]]'
116     )
117     ADMX_DISPLAYNAME_SEARCH_XPATH = etree.XPath(
118         '//*[local-name() = "policy" and @*[local-name() = "displayName"] ='
119         ' $display_name and (@*[local-name() = "class"] = "Both" or @*[local-name() ='
120         ' "class"] = $registry_class) ]'
121     )
122     PRESENTATION_ANCESTOR_XPATH = etree.XPath(
123         'ancestor::*[local-name() = "presentation"]'
124     )
125     TEXT_ELEMENT_XPATH = etree.XPath('.//*[local-name() = "text"]')
126     windll = ctypes.windll.kernel32
127     INSTALL_LANGUAGE = locale.windows_locale.get(
128         windll.GetSystemDefaultUILanguage(), "en_US"
129     ).replace("_", "-")
130 except ImportError:
131     HAS_WINDOWS_MODULES = False
132 class _policy_info:
133     r"""
134     Policy Helper Class
135     ===================
136     The format of the policy dict is as follows:
137     The top most two key/value pairs in the dict divide the policies object into
138     the two sections of local group policy, using the keys "Machine" and "User".
139     The value make-up of these dicts are described below in "Policy Section
140     Definition"
141     Policy Section Definition
142     -------------------------
143     A policy section dict has two required key/value pairs:
144     ============  ==============================================================
145     Key
146     ============  ==============================================================
147     lgpo_section  String matching how the policy section is displayed in the mmc
148                   snap-in ("Computer Configuration" for "Machine" and "User
149                   Configuration" for "User")
150     policies      a dict containing the non-Administrative template policy
151                   definitions, the key for each item is a short/unique
152                   identifier for the policy, the value is described below in
153                   "Policies Definition"
154     ============  ==============================================================
155     Policies Definition
156     -------------------
157     A policies definition item describes the particular policy. There are three
158     child key/value pairs shared with all policy types:
159     ============  ==============================================================
160     Key           Value
161     ============  ==============================================================
162     lgpo_section  A list containing the hierarchical path to the policy in the
163                   gpedit mmc snap-in.
164     Policy        A string containing the name of the policy in the gpedit mmc
165                   snap-in
166     Settings      An object which describes valid settings for the policy. This
167                   can be None for no validation, a list of possible settings, or
168                   a dict with the following key/value pairs:
169                   - **Function:** The class function to use to validate the
170                     setting
171                   - **Args:** A dict of kwargs to pass to the class function
172     ============  ==============================================================
173     Additionally, each policies definition will contain a key/value pair that
174     defines the mechanism that will be used to configure the policy. The
175     available mechanisms are:  NetUserModal, Registry, Secedit, and LsaRights
176     Registry Mechanism
177     ------------------
178     Some policies simply set values in the Windows registry. The value of this
179     key is a dict with the following make-up:
180     =====  =====================================================================
181     Key    Value
182     =====  =====================================================================
183     Hive   A string containing the Registry hive, such as ``HKEY_LOCAL_MACHINE``
184     Path   A string containing the registry key path, such as
185            ``SYSTEM\\CurrentControlSet\\Control\\Lsa``
186     Value  A string containing the name of the registry value, such as
187            **restrictanonymous**
188     Type   A string containing the registry type of the value, such as
189            ``REG_DWORD``
190     =====  =====================================================================
191     Secedit Mechanism
192     -----------------
193     Some policies are configurable via the "secedit.exe" executable. The value
194     of this key is a dict with the following make-up:
195     =======  ===================================================================
196     Key      Value
197     =======  ===================================================================
198     Option   A string containing the name of the policy as it appears in an
199              export from secedit, such as **PasswordComplexity**
200     Section  A string containing the name of the section in which the "Option"
201              value appears in an export from ``secedit``, such as "System
202              Access"
203     =======  ===================================================================
204     LsaRights Mechanism
205     -------------------
206     LSA Rights policies are configured via the LsaRights mechanism. The value of
207     this key is a dict with the following make-up:
208     ======  ====================================================================
209     Key     Value
210     ======  ====================================================================
211     Option  A string containing the programmatic name of the Lsa Right, such as
212             **SeNetworkLogonRight**
213     ======  ====================================================================
214     NetUserModal Mechanism
215     ----------------------
216     Some policies are configurable by the **NetUserModalGet** and
217     **NetUserModalSet** function from pywin32.  The value of this key is a dict
218     with the following make-up:
219     ======  ====================================================================
220     Key     Value
221     ======  ====================================================================
222     Modal   The modal "level" that the particular option is specified in (0-3),
223             see `here &lt;https://msdn.microsoft.com/en-us/library/windows/desktop/
224             aa370656(v=vs.85).aspx&gt;`_
225     Option  The name of the structure member which contains the data for the
226             policy, for example **max_passwd_age**
227     ======  ====================================================================
228     NetSH Mechanism
229     ---------------
230     The firewall policies are configured by the ``netsh.exe`` executable. The
231     value of this key is a dict with the following make-up:
232     =======  ===================================================================
233     Key      Value
234     =======  ===================================================================
235     Profile  The firewall profile to modify. Can be one of Domain, Private, or
236              Public
237     Section  The section of the firewall to modify. Can be one of state,
238              firewallpolicy, settings, or logging.
239     Option   The setting within that section
240     Value    The value of the setting
241     =======  ===================================================================
242     More information can be found in the advfirewall context in netsh. This can
243     be access by opening a netsh prompt. At a command prompt type the following:
244     c:\&gt;netsh
245     netsh&gt;advfirewall
246     netsh advfirewall&gt;set help
247     netsh advfirewall&gt;set domain help
248     AdvAudit Mechanism
249     ------------------
250     The Advanced Audit Policies are configured using a combination of the
251     auditpol command-line utility and modifying the audit.csv file in two
252     locations. The value of this key is a dict with the following make-up:
253     ======  ===================================
254     Key     Value
255     ======  ===================================
256     Option  The Advanced Audit Policy to modify
257     ======  ===================================
258     Transforms
259     ----------
260     Optionally, each policy definition can contain a "Transform" key. The
261     Transform key is used to handle data that is stored and viewed differently.
262     This key's value is a dict with the following key/value pairs:
263     ===  =======================================================================
264     Key  Value
265     ===  =======================================================================
266     Get  The name of the class function to use to transform the data from the
267          stored value to how the value is displayed in the GUI
268     Put The name of the class function to use to transform the data supplied by
269         the user to the correct value that the policy is stored in
270     ===  =======================================================================
271     For example, "Minimum password age" is stored in seconds, but is displayed
272     in days.  Thus the "Get" and "Put" functions for this policy do these
273     conversions so the user is able to set and view the policy using the same
274     data that is shown in the GUI.
275     """
276     def __init__(self):
277         self.audit_lookup = {
278             0: "No auditing",
279             1: "Success",
280             2: "Failure",
281             3: "Success, Failure",
282             "Not Defined": "Not Defined",
283             None: "Not Defined",
284         }
285         self.advanced_audit_lookup = {
286             0: "No Auditing",
287             1: "Success",
288             2: "Failure",
289             3: "Success and Failure",
290             None: "Not Configured",
291         }
292         self.sc_removal_lookup = {
293             "0": "No Action",
294             "1": "Lock Workstation",
295             "2": "Force Logoff",
296             "3": "Disconnect if a Remote Desktop Services session",
297             None: "Not Defined",
298             "(value not set)": "Not Defined",
299         }
300         self.uac_admin_prompt_lookup = {
301             0: "Elevate without prompting",
302             1: "Prompt for credentials on the secure desktop",
303             2: "Prompt for consent on the secure desktop",
304             3: "Prompt for credentials",
305             4: "Prompt for consent",
306             5: "Prompt for consent for non-Windows binaries",
307             None: "Not Defined",
308             "(value not set)": "Not Defined",
309         }
310         self.uac_user_prompt_lookup = {
311             0: "Automatically deny elevation requests",
312             1: "Prompt for credentials on the secure desktop",
313             3: "Prompt for credentials",
314             None: "Not Defined",
315             "(value not set)": "Not Defined",
316         }
317         self.enabled_one_disabled_zero = {
318             0: "Disabled",
319             1: "Enabled",
320             None: "Not Defined",
321             "(value not set)": "Not Defined",
322         }
323         self.enabled_one_disabled_zero_transform = {
324             "Get": "_dict_lookup",
325             "Put": "_dict_lookup",
326             "GetArgs": {
327                 "lookup": self.enabled_one_disabled_zero,
328                 "value_lookup": False,
329             },
330             "PutArgs": {
331                 "lookup": self.enabled_one_disabled_zero,
332                 "value_lookup": True,
333             },
334         }
335         self.s4u2self_options = {
336             0: "Default",
337             1: "Enabled",
338             2: "Disabled",
339             None: "Not Defined",
340             "(value not set)": "Not Defined",
341         }
342         self.audit_transform = {
343             "Get": "_dict_lookup",
344             "Put": "_dict_lookup",
345             "GetArgs": {"lookup": self.audit_lookup, "value_lookup": False},
346             "PutArgs": {"lookup": self.audit_lookup, "value_lookup": True},
347         }
348         self.advanced_audit_transform = {
349             "Get": "_dict_lookup",
350             "Put": "_dict_lookup",
351             "GetArgs": {"lookup": self.advanced_audit_lookup, "value_lookup": False},
352             "PutArgs": {"lookup": self.advanced_audit_lookup, "value_lookup": True},
353         }
354         self.enabled_one_disabled_zero_strings = {
355             "0": "Disabled",
356             "1": "Enabled",
357             None: "Not Defined",
358             "(value not set)": "Not Defined",
359         }
360         self.enabled_one_disabled_zero_strings_transform = {
361             "Get": "_dict_lookup",
362             "Put": "_dict_lookup",
363             "GetArgs": {
364                 "lookup": self.enabled_one_disabled_zero_strings,
365                 "value_lookup": False,
366             },
367             "PutArgs": {
368                 "lookup": self.enabled_one_disabled_zero_strings,
369                 "value_lookup": True,
370             },
371         }
372         self.security_options_gpedit_path = [
373             "Computer Configuration",
374             "Windows Settings",
375             "Security Settings",
376             "Local Policies",
377             "Security Options",
378         ]
379         self.windows_firewall_gpedit_path = [
380             "Computer Configuration",
381             "Windows Settings",
382             "Security Settings",
383             "Windows Firewall with Advanced Security",
384             "Windows Firewall with Advanced Security - Local Group Policy Object",
385         ]
386         self.password_policy_gpedit_path = [
387             "Computer Configuration",
388             "Windows Settings",
389             "Security Settings",
390             "Account Policies",
391             "Password Policy",
392         ]
393         self.audit_policy_gpedit_path = [
394             "Computer Configuration",
395             "Windows Settings",
396             "Security Settings",
397             "Local Policies",
398             "Audit Policy",
399         ]
400         self.advanced_audit_policy_gpedit_path = [
401             "Computer Configuration",
402             "Windows Settings",
403             "Security Settings",
404             "Advanced Audit Policy Configuration",
405             "System Audit Policies - Local Group Policy Object",
406         ]
407         self.account_lockout_policy_gpedit_path = [
408             "Computer Configuration",
409             "Windows Settings",
410             "Security Settings",
411             "Account Policies",
412             "Account Lockout Policy",
413         ]
414         self.user_rights_assignment_gpedit_path = [
415             "Computer Configuration",
416             "Windows Settings",
417             "Security Settings",
418             "Local Policies",
419             "User Rights Assignment",
420         ]
421         self.block_ms_accounts = {
422             0: "This policy is disabled",
423             1: "Users can't add Microsoft accounts",
424             3: "Users can't add or log on with Microsoft accounts",
425             None: "Not Defined",
426             "(value not set)": "Not Defined",
427         }
428         self.ldap_server_signing_requirements = {
429             1: "None",
430             2: "Require signing",
431             None: "Not Defined",
432             "(value not set)": "Not Defined",
433         }
434         self.smb_server_name_hardening_levels = {
435             0: "Off",
436             1: "Accept if provided by client",
437             2: "Required from client",
438             None: "Not Defined",
439             "(value not set)": "Not Defined",
440         }
441         self.locked_session_user_info = {
442             1: "User display name, domain and user names",
443             2: "User display name only",
444             3: "Do not display user information",
445             None: "Not Defined",
446             "(value not set)": "Not Defined",
447         }
448         self.force_guest = {
449             0: "Classic - local users authenticate as themselves",
450             1: "Guest only - local users authenticate as Guest",
451             None: "Not Defined",
452             "(value not set)": "Not Defined",
453         }
454         self.force_key_protection = {
455             0: "User input is not required when new keys are stored and used",
456             1: "User is prompted when the key is first used",
457             2: "User must enter a password each time they use a key",
458             None: "Not Defined",
459             "(value not set)": "Not Defined",
460         }
461         self.firewall_inbound_connections = {
462             "blockinbound": "Block (default)",
463             "blockinboundalways": "Block all connections",
464             "allowinbound": "Allow",
465             "notconfigured": "Not configured",
466         }
467         self.firewall_outbound_connections = {
468             "blockoutbound": "Block",
469             "allowoutbound": "Allow (default)",
470             "notconfigured": "Not configured",
471         }
472         self.firewall_rule_merging = {
473             "enable": "Yes (default)",
474             "disable": "No",
475             "notconfigured": "Not configured",
476         }
477         self.firewall_log_packets_connections = {
478             "enable": "Yes",
479             "disable": "No (default)",
480             "notconfigured": "Not configured",
481         }
482         self.firewall_notification = {
483             "enable": "Yes",
484             "disable": "No",
485             "notconfigured": "Not configured",
486         }
487         self.firewall_state = {
488             "on": "On (recommended)",
489             "off": "Off",
490             "notconfigured": "Not configured",
491         }
492         self.krb_encryption_types = {
493             0: "No minimum",
494             1: "DES_CBC_CRC",
495             2: "DES_CBD_MD5",
496             4: "RC4_HMAC_MD5",
497             8: "AES128_HMAC_SHA1",
498             16: "AES256_HMAC_SHA1",
499             2147483616: "Future Encryption Types",
500             None: "Not Defined",
501             "(value not set)": "Not Defined",
502         }
503         self.lm_compat_levels = {
504             0: "Send LM &amp; NTLM response",
505             1: "Send LM &amp; NTLM - use NTLMv2 session security if negotiated",
506             2: "Send NTLM response only",
507             3: "Send NTLMv2 response only",
508             4: "Send NTLMv2 response only. Refuse LM",
509             5: "Send NTLMv2 response only. Refuse LM &amp; NTLM",
510             None: "Not Defined",
511             "(value not set)": "Not Defined",
512         }
513         self.ldap_signing_reqs = {
514             0: "None",
515             1: "Negotiate signing",
516             2: "Require signing",
517             None: "Not Defined",
518             "(value not set)": "Not Defined",
519         }
520         self.ntlm_session_security_levels = {
521             0: "No minimum",
522             524288: "Require NTLMv2 session security",
523             536870912: "Require 128-bit encryption",
524             None: "Not Defined",
525             "(value not set)": "Not Defined",
526         }
527         self.ntlm_audit_settings = {
528             0: "Disable",
529             1: "Enable auditing for domain accounts",
530             2: "Enable auditing for all accounts",
531             None: "Not Defined",
532             "(value not set)": "Not Defined",
533         }
534         self.ntlm_domain_audit_settings = {
535             0: "Disable",
536             1: "Enable for domain accounts to domain servers",
537             3: "Enable for domain accounts",
538             5: "Enable for domain servers",
539             7: "Enable all",
540             None: "Not Defined",
541             "(value not set)": "Not Defined",
542         }
543         self.incoming_ntlm_settings = {
544             0: "Allow all",
545             1: "Deny all domain accounts",
546             2: "Deny all accounts",
547             None: "Not Defined",
548             "(value not set)": "Not Defined",
549         }
550         self.ntlm_domain_auth_settings = {
551             0: "Disable",
552             1: "Deny for domain accounts to domain servers",
553             3: "Deny for domain accounts",
554             5: "Deny for domain servers",
555             7: "Deny all",
556             None: "Not Defined",
557             "(value not set)": "Not Defined",
558         }
559         self.outgoing_ntlm_settings = {
560             0: "Allow all",
561             1: "Audit all",
562             2: "Deny all",
563             None: "Not Defined",
564             "(value not set)": "Not Defined",
565         }
566         self.enabled_one_disabled_zero_no_not_defined = {
567             0: "Disabled",
568             1: "Enabled",
569         }
570         self.enabled_one_disabled_zero_no_not_defined_transform = {
571             "Get": "_dict_lookup",
572             "Put": "_dict_lookup",
573             "GetArgs": {
574                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
575                 "value_lookup": False,
576             },
577             "PutArgs": {
578                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
579                 "value_lookup": True,
580             },
581         }
582         self.policies = {
583             "Machine": {
584                 "lgpo_section": "Computer Configuration",
585                 "policies": {
586                     "StartupScripts": {
587                         "Policy": "Startup Scripts",
588                         "lgpo_section": [
589                             "Computer Configuration",
590                             "Windows Settings",
591                             "Scripts (Startup/Shutdown)",
592                             "Startup",
593                         ],
594                         "ScriptIni": {
595                             "Section": "Startup",
596                             "IniPath": os.path.join(
597                                 os.getenv("WINDIR"),
598                                 "System32",
599                                 "GroupPolicy",
600                                 "Machine",
601                                 "Scripts",
602                                 "scripts.ini",
603                             ),
604                         },
605                     },
606                     "StartupPowershellScripts": {
607                         "Policy": "Startup Powershell Scripts",
608                         "lgpo_section": [
609                             "Computer Configuration",
610                             "Windows Settings",
611                             "Scripts (Startup/Shutdown)",
612                             "Startup",
613                         ],
614                         "ScriptIni": {
615                             "Section": "Startup",
616                             "IniPath": os.path.join(
617                                 os.getenv("WINDIR"),
618                                 "System32",
619                                 "GroupPolicy",
620                                 "Machine",
621                                 "Scripts",
622                                 "psscripts.ini",
623                             ),
624                         },
625                     },
626                     "StartupPowershellScriptOrder": {
627                         "Policy": (
628                             "Startup - For this GPO, run scripts in the following order"
629                         ),
630                         "lgpo_section": [
631                             "Computer Configuration",
632                             "Windows Settings",
633                             "Scripts (Startup/Shutdown)",
634                             "Startup",
635                         ],
636                         "ScriptIni": {
637                             "IniPath": os.path.join(
638                                 os.getenv("WINDIR"),
639                                 "System32",
640                                 "GroupPolicy",
641                                 "Machine",
642                                 "Scripts",
643                                 "psscripts.ini",
644                             ),
645                             "Section": "ScriptsConfig",
646                             "SettingName": "StartExecutePSFirst",
647                             "Settings": ["true", "false", None],
648                         },
649                         "Transform": {
650                             "Get": "_powershell_script_order_conversion",
651                             "Put": "_powershell_script_order_reverse_conversion",
652                         },
653                     },
654                     "ShutdownScripts": {
655                         "Policy": "Shutdown Scripts",
656                         "lgpo_section": [
657                             "Computer Configuration",
658                             "Windows Settings",
659                             "Scripts (Startup/Shutdown)",
660                             "Shutdown",
661                         ],
662                         "ScriptIni": {
663                             "Section": "Shutdown",
664                             "IniPath": os.path.join(
665                                 os.getenv("WINDIR"),
666                                 "System32",
667                                 "GroupPolicy",
668                                 "Machine",
669                                 "Scripts",
670                                 "scripts.ini",
671                             ),
672                         },
673                     },
674                     "ShutdownPowershellScripts": {
675                         "Policy": "Shutdown Powershell Scripts",
676                         "lgpo_section": [
677                             "Computer Configuration",
678                             "Windows Settings",
679                             "Scripts (Startup/Shutdown)",
680                             "Shutdown",
681                         ],
682                         "ScriptIni": {
683                             "Section": "Shutdown",
684                             "IniPath": os.path.join(
685                                 os.getenv("WINDIR"),
686                                 "System32",
687                                 "GroupPolicy",
688                                 "Machine",
689                                 "Scripts",
690                                 "psscripts.ini",
691                             ),
692                         },
693                     },
694                     "ShutdownPowershellScriptOrder": {
695                         "Policy": (
696                             "Shutdown - For this GPO, run scripts in the "
697                             "following order"
698                         ),
699                         "lgpo_section": [
700                             "Computer Configuration",
701                             "Windows Settings",
702                             "Scripts (Startup/Shutdown)",
703                             "Shutdown",
704                         ],
705                         "ScriptIni": {
706                             "IniPath": os.path.join(
707                                 os.getenv("WINDIR"),
708                                 "System32",
709                                 "GroupPolicy",
710                                 "Machine",
711                                 "Scripts",
712                                 "psscripts.ini",
713                             ),
714                             "Section": "ScriptsConfig",
715                             "SettingName": "EndExecutePSFirst",
716                             "Settings": ["true", "false", None],
717                         },
718                         "Transform": {
719                             "Get": "_powershell_script_order_conversion",
720                             "Put": "_powershell_script_order_reverse_conversion",
721                         },
722                     },
723                     "LSAAnonymousNameLookup": {
724                         "Policy": (
725                             "Network access: Allow anonymous SID/Name translation"
726                         ),
727                         "lgpo_section": self.password_policy_gpedit_path,
728                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
729                         "Secedit": {
730                             "Option": "LSAAnonymousNameLookup",
731                             "Section": "System Access",
732                         },
733                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
734                     },
735                     "RestrictAnonymousSam": {
736                         "Policy": (
737                             "Network access: Do not allow anonymous "
738                             "enumeration of SAM accounts"
739                         ),
740                         "lgpo_section": self.security_options_gpedit_path,
741                         "Settings": self.enabled_one_disabled_zero.keys(),
742                         "Registry": {
743                             "Hive": "HKEY_LOCAL_MACHINE",
744                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
745                             "Value": "RestrictAnonymousSam",
746                             "Type": "REG_DWORD",
747                         },
748                         "Transform": self.enabled_one_disabled_zero_transform,
749                     },
750                     "RestrictRemoteSAM": {
751                         "Policy": (
752                             "Network access: Restrict clients allowed to "
753                             "make remote calls to SAM"
754                         ),
755                         "lgpo_section": self.security_options_gpedit_path,
756                         "Registry": {
757                             "Hive": "HKEY_LOCAL_MACHINE",
758                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
759                             "Value": "RestrictRemoteSAM",
760                             "Type": "REG_SZ",
761                         },
762                         "Transform": {"Put": "_string_put_transform"},
763                     },
764                     "RestrictAnonymous": {
765                         "Policy": (
766                             "Network access: Do not allow anonymous "
767                             "enumeration of SAM accounts and shares"
768                         ),
769                         "lgpo_section": self.security_options_gpedit_path,
770                         "Settings": self.enabled_one_disabled_zero.keys(),
771                         "Registry": {
772                             "Hive": "HKEY_LOCAL_MACHINE",
773                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
774                             "Value": "RestrictAnonymous",
775                             "Type": "REG_DWORD",
776                         },
777                         "Transform": self.enabled_one_disabled_zero_transform,
778                     },
779                     "DisableDomainCreds": {
780                         "Policy": (
781                             "Network access: Do not allow storage of "
782                             "passwords and credentials for network "
783                             "authentication"
784                         ),
785                         "lgpo_section": self.security_options_gpedit_path,
786                         "Settings": self.enabled_one_disabled_zero.keys(),
787                         "Registry": {
788                             "Hive": "HKEY_LOCAL_MACHINE",
789                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
790                             "Value": "DisableDomainCreds",
791                             "Type": "REG_DWORD",
792                         },
793                         "Transform": self.enabled_one_disabled_zero_transform,
794                     },
795                     "EveryoneIncludesAnonymous": {
796                         "Policy": (
797                             "Network access: Let Everyone permissions "
798                             "apply to anonymous users"
799                         ),
800                         "lgpo_section": self.security_options_gpedit_path,
801                         "Settings": self.enabled_one_disabled_zero.keys(),
802                         "Registry": {
803                             "Hive": "HKEY_LOCAL_MACHINE",
804                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
805                             "Value": "everyoneincludesanonymous",
806                             "Type": "REG_DWORD",
807                         },
808                         "Transform": self.enabled_one_disabled_zero_transform,
809                     },
810                     "NullSessionPipes": {
811                         "Policy": (
812                             "Network access: Named Pipes that can be "
813                             "accessed anonymously"
814                         ),
815                         "lgpo_section": self.security_options_gpedit_path,
816                         "Registry": {
817                             "Hive": "HKEY_LOCAL_MACHINE",
818                             "Path": (
819                                 "SYSTEM\\CurrentControlSet\\Services\\"
820                                 "LanmanServer\\Parameters"
821                             ),
822                             "Value": "NullSessionPipes",
823                             "Type": "REG_MULTI_SZ",
824                         },
825                         "Transform": {
826                             "Put": "_multi_string_put_transform",
827                             "Get": "_multi_string_get_transform",
828                         },
829                     },
830                     "RemoteRegistryExactPaths": {
831                         "Policy": "Network access: Remotely accessible registry paths",
832                         "lgpo_section": self.security_options_gpedit_path,
833                         "Registry": {
834                             "Hive": "HKEY_LOCAL_MACHINE",
835                             "Path": (
836                                 "SYSTEM\\CurrentControlSet\\Control\\"
837                                 "SecurePipeServers\\winreg\\"
838                                 "AllowedExactPaths"
839                             ),
840                             "Value": "Machine",
841                             "Type": "REG_MULTI_SZ",
842                         },
843                         "Transform": {
844                             "Put": "_multi_string_put_transform",
845                             "Get": "_multi_string_get_transform",
846                         },
847                     },
848                     "RemoteRegistryPaths": {
849                         "Policy": (
850                             "Network access: Remotely accessible "
851                             "registry paths and sub-paths"
852                         ),
853                         "lgpo_section": self.security_options_gpedit_path,
854                         "Registry": {
855                             "Hive": "HKEY_LOCAL_MACHINE",
856                             "Path": (
857                                 "SYSTEM\\CurrentControlSet\\Control\\"
858                                 "SecurePipeServers\\winreg\\AllowedPaths"
859                             ),
860                             "Value": "Machine",
861                             "Type": "REG_MULTI_SZ",
862                         },
863                         "Transform": {
864                             "Put": "_multi_string_put_transform",
865                             "Get": "_multi_string_get_transform",
866                         },
867                     },
868                     "RestrictNullSessAccess": {
869                         "Policy": (
870                             "Network access: Restrict anonymous access "
871                             "to Named Pipes and Shares"
872                         ),
873                         "lgpo_section": self.security_options_gpedit_path,
874                         "Settings": self.enabled_one_disabled_zero.keys(),
875                         "Registry": {
876                             "Hive": "HKEY_LOCAL_MACHINE",
877                             "Path": (
878                                 "System\\CurrentControlSet\\Services\\"
879                                 "LanmanServer\\Parameters"
880                             ),
881                             "Value": "RestrictNullSessAccess",
882                             "Type": "REG_DWORD",
883                         },
884                         "Transform": self.enabled_one_disabled_zero_transform,
885                     },
886                     "NullSessionShares": {
887                         "Policy": (
888                             "Network access: Shares that can be accessed anonymously"
889                         ),
890                         "lgpo_section": self.security_options_gpedit_path,
891                         "Registry": {
892                             "Hive": "HKEY_LOCAL_MACHINE",
893                             "Path": (
894                                 "SYSTEM\\CurrentControlSet\\Services\\"
895                                 "LanmanServer\\Parameters"
896                             ),
897                             "Value": "NullSessionShares",
898                             "Type": "REG_MULTI_SZ",
899                         },
900                         "Transform": {
901                             "Put": "_multi_string_put_transform",
902                             "Get": "_multi_string_get_transform",
903                         },
904                     },
905                     "ForceGuest": {
906                         "Policy": (
907                             "Network access: Sharing and security model "
908                             "for local accounts"
909                         ),
910                         "lgpo_section": self.security_options_gpedit_path,
911                         "Settings": self.force_guest.keys(),
912                         "Registry": {
913                             "Hive": "HKEY_LOCAL_MACHINE",
914                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
915                             "Value": "ForceGuest",
916                             "Type": "REG_DWORD",
917                         },
918                         "Transform": {
919                             "Get": "_dict_lookup",
920                             "Put": "_dict_lookup",
921                             "GetArgs": {
922                                 "lookup": self.force_guest,
923                                 "value_lookup": False,
924                             },
925                             "PutArgs": {
926                                 "lookup": self.force_guest,
927                                 "value_lookup": True,
928                             },
929                         },
930                     },
931                     "WfwDomainState": {
932                         "Policy": "Network firewall: Domain: State",
933                         "lgpo_section": self.windows_firewall_gpedit_path,
934                         "Settings": self.firewall_state.keys(),
935                         "NetSH": {
936                             "Profile": "domain",
937                             "Section": "state",
938                             "Option": "State",  # Unused, but needed
939                         },
940                         "Transform": {
941                             "Get": "_dict_lookup",
942                             "Put": "_dict_lookup",
943                             "GetArgs": {
944                                 "lookup": self.firewall_state,
945                                 "value_lookup": False,
946                             },
947                             "PutArgs": {
948                                 "lookup": self.firewall_state,
949                                 "value_lookup": True,
950                             },
951                         },
952                     },
953                     "WfwPrivateState": {
954                         "Policy": "Network firewall: Private: State",
955                         "lgpo_section": self.windows_firewall_gpedit_path,
956                         "Settings": self.firewall_state.keys(),
957                         "NetSH": {
958                             "Profile": "private",
959                             "Section": "state",
960                             "Option": "State",  # Unused, but needed
961                         },
962                         "Transform": {
963                             "Get": "_dict_lookup",
964                             "Put": "_dict_lookup",
965                             "GetArgs": {
966                                 "lookup": self.firewall_state,
967                                 "value_lookup": False,
968                             },
969                             "PutArgs": {
970                                 "lookup": self.firewall_state,
971                                 "value_lookup": True,
972                             },
973                         },
974                     },
975                     "WfwPublicState": {
976                         "Policy": "Network firewall: Public: State",
977                         "lgpo_section": self.windows_firewall_gpedit_path,
978                         "Settings": self.firewall_state.keys(),
979                         "NetSH": {
980                             "Profile": "public",
981                             "Section": "state",
982                             "Option": "State",  # Unused, but needed
983                         },
984                         "Transform": {
985                             "Get": "_dict_lookup",
986                             "Put": "_dict_lookup",
987                             "GetArgs": {
988                                 "lookup": self.firewall_state,
989                                 "value_lookup": False,
990                             },
991                             "PutArgs": {
992                                 "lookup": self.firewall_state,
993                                 "value_lookup": True,
994                             },
995                         },
996                     },
997                     "WfwDomainInboundConnections": {
998                         "Policy": "Network firewall: Domain: Inbound connections",
999                         "lgpo_section": self.windows_firewall_gpedit_path,
1000                         "Settings": self.firewall_inbound_connections.keys(),
1001                         "NetSH": {
1002                             "Profile": "domain",
1003                             "Section": "firewallpolicy",
1004                             "Option": "Inbound",
1005                         },
1006                         "Transform": {
1007                             "Get": "_dict_lookup",
1008                             "Put": "_dict_lookup",
1009                             "GetArgs": {
1010                                 "lookup": self.firewall_inbound_connections,
1011                                 "value_lookup": False,
1012                             },
1013                             "PutArgs": {
1014                                 "lookup": self.firewall_inbound_connections,
1015                                 "value_lookup": True,
1016                             },
1017                         },
1018                     },
1019                     "WfwPrivateInboundConnections": {
1020                         "Policy": "Network firewall: Private: Inbound connections",
1021                         "lgpo_section": self.windows_firewall_gpedit_path,
1022                         "Settings": self.firewall_inbound_connections.keys(),
1023                         "NetSH": {
1024                             "Profile": "private",
1025                             "Section": "firewallpolicy",
1026                             "Option": "Inbound",
1027                         },
1028                         "Transform": {
1029                             "Get": "_dict_lookup",
1030                             "Put": "_dict_lookup",
1031                             "GetArgs": {
1032                                 "lookup": self.firewall_inbound_connections,
1033                                 "value_lookup": False,
1034                             },
1035                             "PutArgs": {
1036                                 "lookup": self.firewall_inbound_connections,
1037                                 "value_lookup": True,
1038                             },
1039                         },
1040                     },
1041                     "WfwPublicInboundConnections": {
1042                         "Policy": "Network firewall: Public: Inbound connections",
1043                         "lgpo_section": self.windows_firewall_gpedit_path,
1044                         "Settings": self.firewall_inbound_connections.keys(),
1045                         "NetSH": {
1046                             "Profile": "public",
1047                             "Section": "firewallpolicy",
1048                             "Option": "Inbound",
1049                         },
1050                         "Transform": {
1051                             "Get": "_dict_lookup",
1052                             "Put": "_dict_lookup",
1053                             "GetArgs": {
1054                                 "lookup": self.firewall_inbound_connections,
1055                                 "value_lookup": False,
1056                             },
1057                             "PutArgs": {
1058                                 "lookup": self.firewall_inbound_connections,
1059                                 "value_lookup": True,
1060                             },
1061                         },
1062                     },
1063                     "WfwDomainOutboundConnections": {
1064                         "Policy": "Network firewall: Domain: Outbound connections",
1065                         "lgpo_section": self.windows_firewall_gpedit_path,
1066                         "Settings": self.firewall_outbound_connections.keys(),
1067                         "NetSH": {
1068                             "Profile": "domain",
1069                             "Section": "firewallpolicy",
1070                             "Option": "Outbound",
1071                         },
1072                         "Transform": {
1073                             "Get": "_dict_lookup",
1074                             "Put": "_dict_lookup",
1075                             "GetArgs": {
1076                                 "lookup": self.firewall_outbound_connections,
1077                                 "value_lookup": False,
1078                             },
1079                             "PutArgs": {
1080                                 "lookup": self.firewall_outbound_connections,
1081                                 "value_lookup": True,
1082                             },
1083                         },
1084                     },
1085                     "WfwPrivateOutboundConnections": {
1086                         "Policy": "Network firewall: Private: Outbound connections",
1087                         "lgpo_section": self.windows_firewall_gpedit_path,
1088                         "Settings": self.firewall_outbound_connections.keys(),
1089                         "NetSH": {
1090                             "Profile": "private",
1091                             "Section": "firewallpolicy",
1092                             "Option": "Outbound",
1093                         },
1094                         "Transform": {
1095                             "Get": "_dict_lookup",
1096                             "Put": "_dict_lookup",
1097                             "GetArgs": {
1098                                 "lookup": self.firewall_outbound_connections,
1099                                 "value_lookup": False,
1100                             },
1101                             "PutArgs": {
1102                                 "lookup": self.firewall_outbound_connections,
1103                                 "value_lookup": True,
1104                             },
1105                         },
1106                     },
1107                     "WfwPublicOutboundConnections": {
1108                         "Policy": "Network firewall: Public: Outbound connections",
1109                         "lgpo_section": self.windows_firewall_gpedit_path,
1110                         "Settings": self.firewall_outbound_connections.keys(),
1111                         "NetSH": {
1112                             "Profile": "public",
1113                             "Section": "firewallpolicy",
1114                             "Option": "Outbound",
1115                         },
1116                         "Transform": {
1117                             "Get": "_dict_lookup",
1118                             "Put": "_dict_lookup",
1119                             "GetArgs": {
1120                                 "lookup": self.firewall_outbound_connections,
1121                                 "value_lookup": False,
1122                             },
1123                             "PutArgs": {
1124                                 "lookup": self.firewall_outbound_connections,
1125                                 "value_lookup": True,
1126                             },
1127                         },
1128                     },
1129                     "WfwDomainSettingsNotification": {
1130                         "Policy": (
1131                             "Network firewall: Domain: Settings: Display a notification"
1132                         ),
1133                         "lgpo_section": self.windows_firewall_gpedit_path,
1134                         "Settings": self.firewall_notification.keys(),
1135                         "NetSH": {
1136                             "Profile": "domain",
1137                             "Section": "settings",
1138                             "Option": "InboundUserNotification",
1139                         },
1140                         "Transform": {
1141                             "Get": "_dict_lookup",
1142                             "Put": "_dict_lookup",
1143                             "GetArgs": {
1144                                 "lookup": self.firewall_notification,
1145                                 "value_lookup": False,
1146                             },
1147                             "PutArgs": {
1148                                 "lookup": self.firewall_notification,
1149                                 "value_lookup": True,
1150                             },
1151                         },
1152                     },
1153                     "WfwPrivateSettingsNotification": {
1154                         "Policy": (
1155                             "Network firewall: Private: Settings: Display a"
1156                             " notification"
1157                         ),
1158                         "lgpo_section": self.windows_firewall_gpedit_path,
1159                         "Settings": self.firewall_notification.keys(),
1160                         "NetSH": {
1161                             "Profile": "private",
1162                             "Section": "settings",
1163                             "Option": "InboundUserNotification",
1164                         },
1165                         "Transform": {
1166                             "Get": "_dict_lookup",
1167                             "Put": "_dict_lookup",
1168                             "GetArgs": {
1169                                 "lookup": self.firewall_notification,
1170                                 "value_lookup": False,
1171                             },
1172                             "PutArgs": {
1173                                 "lookup": self.firewall_notification,
1174                                 "value_lookup": True,
1175                             },
1176                         },
1177                     },
1178                     "WfwPublicSettingsNotification": {
1179                         "Policy": (
1180                             "Network firewall: Public: Settings: Display a notification"
1181                         ),
1182                         "lgpo_section": self.windows_firewall_gpedit_path,
1183                         "Settings": self.firewall_notification.keys(),
1184                         "NetSH": {
1185                             "Profile": "public",
1186                             "Section": "settings",
1187                             "Option": "InboundUserNotification",
1188                         },
1189                         "Transform": {
1190                             "Get": "_dict_lookup",
1191                             "Put": "_dict_lookup",
1192                             "GetArgs": {
1193                                 "lookup": self.firewall_notification,
1194                                 "value_lookup": False,
1195                             },
1196                             "PutArgs": {
1197                                 "lookup": self.firewall_notification,
1198                                 "value_lookup": True,
1199                             },
1200                         },
1201                     },
1202                     "WfwDomainSettingsLocalFirewallRules": {
1203                         "Policy": (
1204                             "Network firewall: Domain: Settings: Apply "
1205                             "local firewall rules"
1206                         ),
1207                         "lgpo_section": self.windows_firewall_gpedit_path,
1208                         "Settings": self.firewall_rule_merging.keys(),
1209                         "NetSH": {
1210                             "Profile": "domain",
1211                             "Section": "settings",
1212                             "Option": "LocalFirewallRules",
1213                         },
1214                         "Transform": {
1215                             "Get": "_dict_lookup",
1216                             "Put": "_dict_lookup",
1217                             "GetArgs": {
1218                                 "lookup": self.firewall_rule_merging,
1219                                 "value_lookup": False,
1220                             },
1221                             "PutArgs": {
1222                                 "lookup": self.firewall_rule_merging,
1223                                 "value_lookup": True,
1224                             },
1225                         },
1226                     },
1227                     "WfwPrivateSettingsLocalFirewallRules": {
1228                         "Policy": (
1229                             "Network firewall: Private: Settings: Apply "
1230                             "local firewall rules"
1231                         ),
1232                         "lgpo_section": self.windows_firewall_gpedit_path,
1233                         "Settings": self.firewall_rule_merging.keys(),
1234                         "NetSH": {
1235                             "Profile": "private",
1236                             "Section": "settings",
1237                             "Option": "LocalFirewallRules",
1238                         },
1239                         "Transform": {
1240                             "Get": "_dict_lookup",
1241                             "Put": "_dict_lookup",
1242                             "GetArgs": {
1243                                 "lookup": self.firewall_rule_merging,
1244                                 "value_lookup": False,
1245                             },
1246                             "PutArgs": {
1247                                 "lookup": self.firewall_rule_merging,
1248                                 "value_lookup": True,
1249                             },
1250                         },
1251                     },
1252                     "WfwPublicSettingsLocalFirewallRules": {
1253                         "Policy": (
1254                             "Network firewall: Public: Settings: Apply "
1255                             "local firewall rules"
1256                         ),
1257                         "lgpo_section": self.windows_firewall_gpedit_path,
1258                         "Settings": self.firewall_rule_merging.keys(),
1259                         "NetSH": {
1260                             "Profile": "public",
1261                             "Section": "settings",
1262                             "Option": "LocalFirewallRules",
1263                         },
1264                         "Transform": {
1265                             "Get": "_dict_lookup",
1266                             "Put": "_dict_lookup",
1267                             "GetArgs": {
1268                                 "lookup": self.firewall_rule_merging,
1269                                 "value_lookup": False,
1270                             },
1271                             "PutArgs": {
1272                                 "lookup": self.firewall_rule_merging,
1273                                 "value_lookup": True,
1274                             },
1275                         },
1276                     },
1277                     "WfwDomainSettingsLocalConnectionRules": {
1278                         "Policy": (
1279                             "Network firewall: Domain: Settings: Apply "
1280                             "local connection security rules"
1281                         ),
1282                         "lgpo_section": self.windows_firewall_gpedit_path,
1283                         "Settings": self.firewall_rule_merging.keys(),
1284                         "NetSH": {
1285                             "Profile": "domain",
1286                             "Section": "settings",
1287                             "Option": "LocalConSecRules",
1288                         },
1289                         "Transform": {
1290                             "Get": "_dict_lookup",
1291                             "Put": "_dict_lookup",
1292                             "GetArgs": {
1293                                 "lookup": self.firewall_rule_merging,
1294                                 "value_lookup": False,
1295                             },
1296                             "PutArgs": {
1297                                 "lookup": self.firewall_rule_merging,
1298                                 "value_lookup": True,
1299                             },
1300                         },
1301                     },
1302                     "WfwPrivateSettingsLocalConnectionRules": {
1303                         "Policy": (
1304                             "Network firewall: Private: Settings: Apply "
1305                             "local connection security rules"
1306                         ),
1307                         "lgpo_section": self.windows_firewall_gpedit_path,
1308                         "Settings": self.firewall_rule_merging.keys(),
1309                         "NetSH": {
1310                             "Profile": "private",
1311                             "Section": "settings",
1312                             "Option": "LocalConSecRules",
1313                         },
1314                         "Transform": {
1315                             "Get": "_dict_lookup",
1316                             "Put": "_dict_lookup",
1317                             "GetArgs": {
1318                                 "lookup": self.firewall_rule_merging,
1319                                 "value_lookup": False,
1320                             },
1321                             "PutArgs": {
1322                                 "lookup": self.firewall_rule_merging,
1323                                 "value_lookup": True,
1324                             },
1325                         },
1326                     },
1327                     "WfwPublicSettingsLocalConnectionRules": {
1328                         "Policy": (
1329                             "Network firewall: Public: Settings: Apply "
1330                             "local connection security rules"
1331                         ),
1332                         "lgpo_section": self.windows_firewall_gpedit_path,
1333                         "Settings": self.firewall_rule_merging.keys(),
1334                         "NetSH": {
1335                             "Profile": "public",
1336                             "Section": "settings",
1337                             "Option": "LocalConSecRules",
1338                         },
1339                         "Transform": {
1340                             "Get": "_dict_lookup",
1341                             "Put": "_dict_lookup",
1342                             "GetArgs": {
1343                                 "lookup": self.firewall_rule_merging,
1344                                 "value_lookup": False,
1345                             },
1346                             "PutArgs": {
1347                                 "lookup": self.firewall_rule_merging,
1348                                 "value_lookup": True,
1349                             },
1350                         },
1351                     },
1352                     "WfwDomainLoggingName": {
1353                         "Policy": "Network firewall: Domain: Logging: Name",
1354                         "lgpo_section": self.windows_firewall_gpedit_path,
1355                         "Settings": None,
1356                         "NetSH": {
1357                             "Profile": "domain",
1358                             "Section": "logging",
1359                             "Option": "FileName",
1360                         },
1361                     },
1362                     "WfwPrivateLoggingName": {
1363                         "Policy": "Network firewall: Private: Logging: Name",
1364                         "lgpo_section": self.windows_firewall_gpedit_path,
1365                         "Settings": None,
1366                         "NetSH": {
1367                             "Profile": "private",
1368                             "Section": "logging",
1369                             "Option": "FileName",
1370                         },
1371                     },
1372                     "WfwPublicLoggingName": {
1373                         "Policy": "Network firewall: Public: Logging: Name",
1374                         "lgpo_section": self.windows_firewall_gpedit_path,
1375                         "Settings": None,
1376                         "NetSH": {
1377                             "Profile": "public",
1378                             "Section": "logging",
1379                             "Option": "FileName",
1380                         },
1381                     },
1382                     "WfwDomainLoggingMaxFileSize": {
1383                         "Policy": "Network firewall: Domain: Logging: Size limit (KB)",
1384                         "lgpo_section": self.windows_firewall_gpedit_path,
1385                         "Settings": None,
1386                         "NetSH": {
1387                             "Profile": "domain",
1388                             "Section": "logging",
1389                             "Option": "MaxFileSize",
1390                         },
1391                     },
1392                     "WfwPrivateLoggingMaxFileSize": {
1393                         "Policy": "Network firewall: Private: Logging: Size limit (KB)",
1394                         "lgpo_section": self.windows_firewall_gpedit_path,
1395                         "Settings": None,
1396                         "NetSH": {
1397                             "Profile": "private",
1398                             "Section": "logging",
1399                             "Option": "MaxFileSize",
1400                         },
1401                     },
1402                     "WfwPublicLoggingMaxFileSize": {
1403                         "Policy": "Network firewall: Public: Logging: Size limit (KB)",
1404                         "lgpo_section": self.windows_firewall_gpedit_path,
1405                         "Settings": None,
1406                         "NetSH": {
1407                             "Profile": "public",
1408                             "Section": "logging",
1409                             "Option": "MaxFileSize",
1410                         },
1411                     },
1412                     "WfwDomainLoggingAllowedConnections": {
1413                         "Policy": (
1414                             "Network firewall: Domain: Logging: Log successful"
1415                             " connections"
1416                         ),
1417                         "lgpo_section": self.windows_firewall_gpedit_path,
1418                         "Settings": self.firewall_log_packets_connections.keys(),
1419                         "NetSH": {
1420                             "Profile": "domain",
1421                             "Section": "logging",
1422                             "Option": "LogAllowedConnections",
1423                         },
1424                         "Transform": {
1425                             "Get": "_dict_lookup",
1426                             "Put": "_dict_lookup",
1427                             "GetArgs": {
1428                                 "lookup": self.firewall_log_packets_connections,
1429                                 "value_lookup": False,
1430                             },
1431                             "PutArgs": {
1432                                 "lookup": self.firewall_log_packets_connections,
1433                                 "value_lookup": True,
1434                             },
1435                         },
1436                     },
1437                     "WfwPrivateLoggingAllowedConnections": {
1438                         "Policy": (
1439                             "Network firewall: Private: Logging: Log successful"
1440                             " connections"
1441                         ),
1442                         "lgpo_section": self.windows_firewall_gpedit_path,
1443                         "Settings": self.firewall_log_packets_connections.keys(),
1444                         "NetSH": {
1445                             "Profile": "private",
1446                             "Section": "logging",
1447                             "Option": "LogAllowedConnections",
1448                         },
1449                         "Transform": {
1450                             "Get": "_dict_lookup",
1451                             "Put": "_dict_lookup",
1452                             "GetArgs": {
1453                                 "lookup": self.firewall_log_packets_connections,
1454                                 "value_lookup": False,
1455                             },
1456                             "PutArgs": {
1457                                 "lookup": self.firewall_log_packets_connections,
1458                                 "value_lookup": True,
1459                             },
1460                         },
1461                     },
1462                     "WfwPublicLoggingAllowedConnections": {
1463                         "Policy": (
1464                             "Network firewall: Public: Logging: Log successful"
1465                             " connections"
1466                         ),
1467                         "lgpo_section": self.windows_firewall_gpedit_path,
1468                         "Settings": self.firewall_log_packets_connections.keys(),
1469                         "NetSH": {
1470                             "Profile": "public",
1471                             "Section": "logging",
1472                             "Option": "LogAllowedConnections",
1473                         },
1474                         "Transform": {
1475                             "Get": "_dict_lookup",
1476                             "Put": "_dict_lookup",
1477                             "GetArgs": {
1478                                 "lookup": self.firewall_log_packets_connections,
1479                                 "value_lookup": False,
1480                             },
1481                             "PutArgs": {
1482                                 "lookup": self.firewall_log_packets_connections,
1483                                 "value_lookup": True,
1484                             },
1485                         },
1486                     },
1487                     "WfwDomainLoggingDroppedConnections": {
1488                         "Policy": (
1489                             "Network firewall: Domain: Logging: Log dropped packets"
1490                         ),
1491                         "lgpo_section": self.windows_firewall_gpedit_path,
1492                         "Settings": self.firewall_log_packets_connections.keys(),
1493                         "NetSH": {
1494                             "Profile": "domain",
1495                             "Section": "logging",
1496                             "Option": "LogDroppedConnections",
1497                         },
1498                         "Transform": {
1499                             "Get": "_dict_lookup",
1500                             "Put": "_dict_lookup",
1501                             "GetArgs": {
1502                                 "lookup": self.firewall_log_packets_connections,
1503                                 "value_lookup": False,
1504                             },
1505                             "PutArgs": {
1506                                 "lookup": self.firewall_log_packets_connections,
1507                                 "value_lookup": True,
1508                             },
1509                         },
1510                     },
1511                     "WfwPrivateLoggingDroppedConnections": {
1512                         "Policy": (
1513                             "Network firewall: Private: Logging: Log dropped packets"
1514                         ),
1515                         "lgpo_section": self.windows_firewall_gpedit_path,
1516                         "Settings": self.firewall_log_packets_connections.keys(),
1517                         "NetSH": {
1518                             "Profile": "private",
1519                             "Section": "logging",
1520                             "Option": "LogDroppedConnections",
1521                         },
1522                         "Transform": {
1523                             "Get": "_dict_lookup",
1524                             "Put": "_dict_lookup",
1525                             "GetArgs": {
1526                                 "lookup": self.firewall_log_packets_connections,
1527                                 "value_lookup": False,
1528                             },
1529                             "PutArgs": {
1530                                 "lookup": self.firewall_log_packets_connections,
1531                                 "value_lookup": True,
1532                             },
1533                         },
1534                     },
1535                     "WfwPublicLoggingDroppedConnections": {
1536                         "Policy": (
1537                             "Network firewall: Public: Logging: Log dropped packets"
1538                         ),
1539                         "lgpo_section": self.windows_firewall_gpedit_path,
1540                         "Settings": self.firewall_log_packets_connections.keys(),
1541                         "NetSH": {
1542                             "Profile": "public",
1543                             "Section": "logging",
1544                             "Option": "LogDroppedConnections",
1545                         },
1546                         "Transform": {
1547                             "Get": "_dict_lookup",
1548                             "Put": "_dict_lookup",
1549                             "GetArgs": {
1550                                 "lookup": self.firewall_log_packets_connections,
1551                                 "value_lookup": False,
1552                             },
1553                             "PutArgs": {
1554                                 "lookup": self.firewall_log_packets_connections,
1555                                 "value_lookup": True,
1556                             },
1557                         },
1558                     },
1559                     "PasswordHistory": {
1560                         "Policy": "Enforce password history",
1561                         "lgpo_section": self.password_policy_gpedit_path,
1562                         "Settings": {
1563                             "Function": "_in_range_inclusive",
1564                             "Args": {"min": 0, "max": 24},
1565                         },
1566                         "NetUserModal": {"Modal": 0, "Option": "password_hist_len"},
1567                     },
1568                     "MaxPasswordAge": {
1569                         "Policy": "Maximum password age",
1570                         "lgpo_section": self.password_policy_gpedit_path,
1571                         "Settings": {
1572                             "Function": "_in_range_inclusive",
1573                             "Args": {
1574                                 "min": 1,
1575                                 "max": 86313600,
1576                                 "zero_value": 0xFFFFFFFF,
1577                             },
1578                         },
1579                         "NetUserModal": {"Modal": 0, "Option": "max_passwd_age"},
1580                         "Transform": {
1581                             "Get": "_seconds_to_days",
1582                             "Put": "_days_to_seconds",
1583                             "GetArgs": {"zero_value": 0xFFFFFFFF},
1584                             "PutArgs": {"zero_value": 0xFFFFFFFF},
1585                         },
1586                     },
1587                     "MinPasswordAge": {
1588                         "Policy": "Minimum password age",
1589                         "lgpo_section": self.password_policy_gpedit_path,
1590                         "Settings": {
1591                             "Function": "_in_range_inclusive",
1592                             "Args": {"min": 0, "max": 86313600},
1593                         },
1594                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_age"},
1595                         "Transform": {
1596                             "Get": "_seconds_to_days",
1597                             "Put": "_days_to_seconds",
1598                         },
1599                     },
1600                     "MinPasswordLen": {
1601                         "Policy": "Minimum password length",
1602                         "lgpo_section": self.password_policy_gpedit_path,
1603                         "Settings": {
1604                             "Function": "_in_range_inclusive",
1605                             "Args": {"min": 0, "max": 14},
1606                         },
1607                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_len"},
1608                     },
1609                     "PasswordComplexity": {
1610                         "Policy": "Password must meet complexity requirements",
1611                         "lgpo_section": self.password_policy_gpedit_path,
1612                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1613                         "Secedit": {
1614                             "Section": "System Access",
1615                         },
1616                         "Transform": self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.enabled_one_disabled_zero_no_not_defined_transform,
1617                     },
1618                     "ClearTextPasswords": {
1619                         "Policy": "Store passwords using reversible encryption",
1620                         "lgpo_section": self.password_policy_gpedit_path,
1621                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1622                         "Secedit": {
1623                             "Option": "ClearTextPassword",
1624                             "Section": "System Access",
1625                         },
1626                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1627                     },
1628                     "AdminAccountStatus": {
1629                         "Policy": "Accounts: Administrator account status",
1630                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1631                         "lgpo_section": self.security_options_gpedit_path,
1632                         "Secedit": {
1633                             "Option": "EnableAdminAccount",
1634                             "Section": "System Access",
1635                         },
1636                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1637                     },
1638                     "NoConnectedUser": {
1639                         "Policy": "Accounts: Block Microsoft accounts",
1640                         "Settings": self.</b></font>block_ms_accounts.keys(),
1641                         "lgpo_section": self.security_options_gpedit_path,
1642                         "Registry": {
1643                             "Hive": "HKEY_LOCAL_MACHINE",
1644                             "Path": (
1645                                 "SOFTWARE\\Microsoft\\Windows\\"
1646                                 "CurrentVersion\\policies\\system"
1647                             ),
1648                             "Value": "NoConnectedUser",
1649                             "Type": "REG_DWORD",
1650                         },
1651                         "Transform": {
1652                             "Get": "_dict_lookup",
1653                             "Put": "_dict_lookup",
1654                             "GetArgs": {
1655                                 "lookup": self.block_ms_accounts,
1656                                 "value_lookup": False,
1657                             },
1658                             "PutArgs": {
1659                                 "lookup": self.block_ms_accounts,
1660                                 "value_lookup": True,
1661                             },
1662                         },
1663                     },
1664                     "GuestAccountStatus": {
1665                         "Policy": "Accounts: Guest account status",
1666                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1667                         "lgpo_section": self.security_options_gpedit_path,
1668                         "Secedit": {
1669                             "Option": "EnableGuestAccount",
1670                             "Section": "System Access",
1671                         },
1672                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1673                     },
1674                     "LimitBlankPasswordUse": {
1675                         "Policy": (
1676                             "Accounts: Limit local account use of blank "
1677                             "passwords to console logon only"
1678                         ),
1679                         "lgpo_section": self.security_options_gpedit_path,
1680                         "Settings": self.enabled_one_disabled_zero.keys(),
1681                         "Registry": {
1682                             "Hive": "HKEY_LOCAL_MACHINE",
1683                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1684                             "Value": "limitblankpassworduse",
1685                             "Type": "REG_DWORD",
1686                         },
1687                         "Transform": self.enabled_one_disabled_zero_transform,
1688                     },
1689                     "RenameAdministratorAccount": {
1690                         "Policy": "Accounts: Rename administrator account",
1691                         "Settings": None,
1692                         "lgpo_section": self.security_options_gpedit_path,
1693                         "Secedit": {
1694                             "Option": "NewAdministratorName",
1695                             "Section": "System Access",
1696                         },
1697                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1698                     },
1699                     "RenameGuestAccount": {
1700                         "Policy": "Accounts: Rename guest account",
1701                         "Settings": None,
1702                         "lgpo_section": self.security_options_gpedit_path,
1703                         "Secedit": {
1704                             "Option": "NewGuestName",
1705                             "Section": "System Access",
1706                         },
1707                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1708                     },
1709                     "AuditBaseObjects": {
1710                         "Policy": "Audit: Audit the access of global system objects",
1711                         "Settings": self.enabled_one_disabled_zero.keys(),
1712                         "lgpo_section": self.security_options_gpedit_path,
1713                         "Registry": {
1714                             "Hive": "HKEY_LOCAL_MACHINE",
1715                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1716                             "Value": "AuditBaseObjects",
1717                             "Type": "REG_DWORD",
1718                         },
1719                         "Transform": self.enabled_one_disabled_zero_transform,
1720                     },
1721                     "SceNoApplyLegacyAuditPolicy": {
1722                         "Policy": (
1723                             "Audit: Force audit policy subcategory "
1724                             "settings (Windows Vista or later) to "
1725                             "override audit policy category settings"
1726                         ),
1727                         "Settings": self.enabled_one_disabled_zero.keys(),
1728                         "lgpo_section": self.security_options_gpedit_path,
1729                         "Registry": {
1730                             "Hive": "HKEY_LOCAL_MACHINE",
1731                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1732                             "Value": "SCENoApplyLegacyAuditPolicy",
1733                             "Type": "REG_DWORD",
1734                         },
1735                         "Transform": self.enabled_one_disabled_zero_transform,
1736                     },
1737                     "DontDisplayLastUserName": {
1738                         "Policy": "Interactive logon: Do not display last user name",
1739                         "Settings": self.enabled_one_disabled_zero.keys(),
1740                         "lgpo_section": self.security_options_gpedit_path,
1741                         "Registry": {
1742                             "Hive": "HKEY_LOCAL_MACHINE",
1743                             "Path": (
1744                                 "Software\\Microsoft\\Windows\\"
1745                                 "CurrentVersion\\Policies\\System"
1746                             ),
1747                             "Value": "DontDisplayLastUserName",
1748                             "Type": "REG_DWORD",
1749                         },
1750                         "Transform": self.enabled_one_disabled_zero_transform,
1751                     },
1752                     "CachedLogonsCount": {
1753                         "Policy": (
1754                             "Interactive logon: Number of previous "
1755                             "logons to cache (in case domain controller "
1756                             "is not available)"
1757                         ),
1758                         "Settings": {
1759                             "Function": "_in_range_inclusive",
1760                             "Args": {"min": 0, "max": 50},
1761                         },
1762                         "lgpo_section": self.security_options_gpedit_path,
1763                         "Registry": {
1764                             "Hive": "HKEY_LOCAL_MACHINE",
1765                             "Path": (
1766                                 "Software\\Microsoft\\Windows NT\\"
1767                                 "CurrentVersion\\Winlogon"
1768                             ),
1769                             "Value": "CachedLogonsCount",
1770                             "Type": "REG_SZ",
1771                         },
1772                     },
1773                     "ForceUnlockLogon": {
1774                         "Policy": (
1775                             "Interactive logon: Require Domain "
1776                             "Controller authentication to unlock "
1777                             "workstation"
1778                         ),
1779                         "Settings": self.enabled_one_disabled_zero.keys(),
1780                         "lgpo_section": self.security_options_gpedit_path,
1781                         "Registry": {
1782                             "Hive": "HKEY_LOCAL_MACHINE",
1783                             "Path": (
1784                                 "Software\\Microsoft\\Windows NT\\"
1785                                 "CurrentVersion\\Winlogon"
1786                             ),
1787                             "Value": "ForceUnlockLogon",
1788                             "Type": "REG_DWORD",
1789                         },
1790                         "Transform": self.enabled_one_disabled_zero_transform,
1791                     },
1792                     "ScRemoveOption": {
1793                         "Policy": "Interactive logon: Smart card removal behavior",
1794                         "Settings": self.sc_removal_lookup.keys(),
1795                         "lgpo_section": self.security_options_gpedit_path,
1796                         "Registry": {
1797                             "Hive": "HKEY_LOCAL_MACHINE",
1798                             "Path": (
1799                                 "Software\\Microsoft\\Windows NT\\"
1800                                 "CurrentVersion\\Winlogon"
1801                             ),
1802                             "Value": "ScRemoveOption",
1803                             "Type": "REG_SZ",
1804                         },
1805                         "Transform": {
1806                             "Get": "_dict_lookup",
1807                             "Put": "_dict_lookup",
1808                             "GetArgs": {
1809                                 "lookup": self.sc_removal_lookup,
1810                                 "value_lookup": False,
1811                             },
1812                             "PutArgs": {
1813                                 "lookup": self.sc_removal_lookup,
1814                                 "value_lookup": True,
1815                             },
1816                         },
1817                     },
1818                     "DisableCAD": {
1819                         "Policy": "Interactive logon: Do not require CTRL+ALT+DEL",
1820                         "Settings": self.enabled_one_disabled_zero.keys(),
1821                         "lgpo_section": self.security_options_gpedit_path,
1822                         "Registry": {
1823                             "Hive": "HKEY_LOCAL_MACHINE",
1824                             "Path": (
1825                                 "Software\\Microsoft\\Windows\\"
1826                                 "CurrentVersion\\Policies\\System"
1827                             ),
1828                             "Value": "DisableCAD",
1829                             "Type": "REG_DWORD",
1830                         },
1831                         "Transform": self.enabled_one_disabled_zero_transform,
1832                     },
1833                     "FilterAdministratorToken": {
1834                         "Policy": (
1835                             "User Account Control: Admin Approval Mode "
1836                             "for the built-in Administrator account"
1837                         ),
1838                         "Settings": self.enabled_one_disabled_zero.keys(),
1839                         "lgpo_section": self.security_options_gpedit_path,
1840                         "Registry": {
1841                             "Hive": "HKEY_LOCAL_MACHINE",
1842                             "Path": (
1843                                 "Software\\Microsoft\\Windows\\"
1844                                 "CurrentVersion\\Policies\\System"
1845                             ),
1846                             "Value": "FilterAdministratorToken",
1847                             "Type": "REG_DWORD",
1848                         },
1849                         "Transform": self.enabled_one_disabled_zero_transform,
1850                     },
1851                     "EnableUIADesktopToggle": {
1852                         "Policy": (
1853                             "User Account Control: Allow UIAccess "
1854                             "applications to prompt for elevation "
1855                             "without using the secure desktop"
1856                         ),
1857                         "Settings": self.enabled_one_disabled_zero.keys(),
1858                         "lgpo_section": self.security_options_gpedit_path,
1859                         "Registry": {
1860                             "Hive": "HKEY_LOCAL_MACHINE",
1861                             "Path": (
1862                                 "Software\\Microsoft\\Windows\\"
1863                                 "CurrentVersion\\Policies\\System"
1864                             ),
1865                             "Value": "EnableUIADesktopToggle",
1866                             "Type": "REG_DWORD",
1867                         },
1868                         "Transform": self.enabled_one_disabled_zero_transform,
1869                     },
1870                     "ConsentPromptBehaviorAdmin": {
1871                         "Policy": (
1872                             "User Account Control: Behavior of the "
1873                             "elevation prompt for administrators in "
1874                             "Admin Approval Mode"
1875                         ),
1876                         "Settings": self.uac_admin_prompt_lookup.keys(),
1877                         "lgpo_section": self.security_options_gpedit_path,
1878                         "Registry": {
1879                             "Hive": "HKEY_LOCAL_MACHINE",
1880                             "Path": (
1881                                 "Software\\Microsoft\\Windows\\"
1882                                 "CurrentVersion\\Policies\\System"
1883                             ),
1884                             "Value": "ConsentPromptBehaviorAdmin",
1885                             "Type": "REG_DWORD",
1886                         },
1887                         "Transform": {
1888                             "Get": "_dict_lookup",
1889                             "Put": "_dict_lookup",
1890                             "GetArgs": {
1891                                 "lookup": self.uac_admin_prompt_lookup,
1892                                 "value_lookup": False,
1893                             },
1894                             "PutArgs": {
1895                                 "lookup": self.uac_admin_prompt_lookup,
1896                                 "value_lookup": True,
1897                             },
1898                         },
1899                     },
1900                     "ConsentPromptBehaviorUser": {
1901                         "Policy": (
1902                             "User Account Control: Behavior of the "
1903                             "elevation prompt for standard users"
1904                         ),
1905                         "Settings": self.uac_user_prompt_lookup.keys(),
1906                         "lgpo_section": self.security_options_gpedit_path,
1907                         "Registry": {
1908                             "Hive": "HKEY_LOCAL_MACHINE",
1909                             "Path": (
1910                                 "Software\\Microsoft\\Windows\\"
1911                                 "CurrentVersion\\Policies\\System"
1912                             ),
1913                             "Value": "ConsentPromptBehaviorUser",
1914                             "Type": "REG_DWORD",
1915                         },
1916                         "Transform": {
1917                             "Get": "_dict_lookup",
1918                             "Put": "_dict_lookup",
1919                             "GetArgs": {
1920                                 "lookup": self.uac_user_prompt_lookup,
1921                                 "value_lookup": False,
1922                             },
1923                             "PutArgs": {
1924                                 "lookup": self.uac_user_prompt_lookup,
1925                                 "value_lookup": True,
1926                             },
1927                         },
1928                     },
1929                     "EnableInstallerDetection": {
1930                         "Policy": (
1931                             "User Account Control: Detect application "
1932                             "installations and prompt for elevation"
1933                         ),
1934                         "Settings": self.enabled_one_disabled_zero.keys(),
1935                         "lgpo_section": self.security_options_gpedit_path,
1936                         "Registry": {
1937                             "Hive": "HKEY_LOCAL_MACHINE",
1938                             "Path": (
1939                                 "Software\\Microsoft\\Windows\\"
1940                                 "CurrentVersion\\Policies\\System"
1941                             ),
1942                             "Value": "EnableInstallerDetection",
1943                             "Type": "REG_DWORD",
1944                         },
1945                         "Transform": self.enabled_one_disabled_zero_transform,
1946                     },
1947                     "ValidateAdminCodeSignatures": {
1948                         "Policy": (
1949                             "User Account Control: Only elevate "
1950                             "executables that are signed and validated"
1951                         ),
1952                         "Settings": self.enabled_one_disabled_zero.keys(),
1953                         "lgpo_section": self.security_options_gpedit_path,
1954                         "Registry": {
1955                             "Hive": "HKEY_LOCAL_MACHINE",
1956                             "Path": (
1957                                 "Software\\Microsoft\\Windows\\"
1958                                 "CurrentVersion\\Policies\\System"
1959                             ),
1960                             "Value": "ValidateAdminCodeSignatures",
1961                             "Type": "REG_DWORD",
1962                         },
1963                         "Transform": self.enabled_one_disabled_zero_transform,
1964                     },
1965                     "EnableSecureUIAPaths": {
1966                         "Policy": (
1967                             "User Account Control: Only elevate UIAccess "
1968                             "applications that are installed in secure "
1969                             "locations"
1970                         ),
1971                         "Settings": self.enabled_one_disabled_zero.keys(),
1972                         "lgpo_section": self.security_options_gpedit_path,
1973                         "Registry": {
1974                             "Hive": "HKEY_LOCAL_MACHINE",
1975                             "Path": (
1976                                 "Software\\Microsoft\\Windows\\"
1977                                 "CurrentVersion\\Policies\\System"
1978                             ),
1979                             "Value": "EnableSecureUIAPaths",
1980                             "Type": "REG_DWORD",
1981                         },
1982                         "Transform": self.enabled_one_disabled_zero_transform,
1983                     },
1984                     "EnableLUA": {
1985                         "Policy": (
1986                             "User Account Control: Run all "
1987                             "administrators in Admin Approval Mode"
1988                         ),
1989                         "Settings": self.enabled_one_disabled_zero.keys(),
1990                         "lgpo_section": self.security_options_gpedit_path,
1991                         "Registry": {
1992                             "Hive": "HKEY_LOCAL_MACHINE",
1993                             "Path": (
1994                                 "Software\\Microsoft\\Windows\\"
1995                                 "CurrentVersion\\Policies\\System"
1996                             ),
1997                             "Value": "EnableLUA",
1998                             "Type": "REG_DWORD",
1999                         },
2000                         "Transform": self.enabled_one_disabled_zero_transform,
2001                     },
2002                     "PromptOnSecureDesktop": {
2003                         "Policy": (
2004                             "User Account Control: Switch to the secure "
2005                             "desktop when prompting for elevation"
2006                         ),
2007                         "Settings": self.enabled_one_disabled_zero.keys(),
2008                         "lgpo_section": self.security_options_gpedit_path,
2009                         "Registry": {
2010                             "Hive": "HKEY_LOCAL_MACHINE",
2011                             "Path": (
2012                                 "Software\\Microsoft\\Windows\\"
2013                                 "CurrentVersion\\Policies\\System"
2014                             ),
2015                             "Value": "PromptOnSecureDesktop",
2016                             "Type": "REG_DWORD",
2017                         },
2018                         "Transform": self.enabled_one_disabled_zero_transform,
2019                     },
2020                     "EnableVirtualization": {
2021                         "Policy": (
2022                             "User Account Control: Virtualize file and "
2023                             "registry write failures to per-user "
2024                             "locations"
2025                         ),
2026                         "Settings": self.enabled_one_disabled_zero.keys(),
2027                         "lgpo_section": self.security_options_gpedit_path,
2028                         "Registry": {
2029                             "Hive": "HKEY_LOCAL_MACHINE",
2030                             "Path": (
2031                                 "Software\\Microsoft\\Windows\\"
2032                                 "CurrentVersion\\Policies\\System"
2033                             ),
2034                             "Value": "EnableVirtualization",
2035                             "Type": "REG_DWORD",
2036                         },
2037                         "Transform": self.enabled_one_disabled_zero_transform,
2038                     },
2039                     "PasswordExpiryWarning": {
2040                         "Policy": (
2041                             "Interactive logon: Prompt user to change "
2042                             "password before expiration"
2043                         ),
2044                         "Settings": {
2045                             "Function": "_in_range_inclusive",
2046                             "Args": {"min": 0, "max": 999},
2047                         },
2048                         "lgpo_section": self.security_options_gpedit_path,
2049                         "Registry": {
2050                             "Hive": "HKEY_LOCAL_MACHINE",
2051                             "Path": (
2052                                 "Software\\Microsoft\\Windows NT\\"
2053                                 "CurrentVersion\\Winlogon"
2054                             ),
2055                             "Value": "PasswordExpiryWarning",
2056                             "Type": "REG_DWORD",
2057                         },
2058                     },
2059                     "MaxDevicePasswordFailedAttempts": {
2060                         "Policy": (
2061                             "Interactive logon: Machine account lockout threshold"
2062                         ),
2063                         "Settings": {
2064                             "Function": "_in_range_inclusive",
2065                             "Args": {"min": 0, "max": 999},
2066                         },
2067                         "lgpo_section": self.security_options_gpedit_path,
2068                         "Registry": {
2069                             "Hive": "HKEY_LOCAL_MACHINE",
2070                             "Path": (
2071                                 "SOFTWARE\\Microsoft\\Windows\\"
2072                                 "CurrentVersion\\policies\\system"
2073                             ),
2074                             "Value": "MaxDevicePasswordFailedAttempts",
2075                             "Type": "REG_DWORD",
2076                         },
2077                     },
2078                     "InactivityTimeoutSecs": {
2079                         "Policy": "Interactive logon: Machine inactivity limit",
2080                         "Settings": {
2081                             "Function": "_in_range_inclusive",
2082                             "Args": {"min": 0, "max": 599940},
2083                         },
2084                         "lgpo_section": self.security_options_gpedit_path,
2085                         "Registry": {
2086                             "Hive": "HKEY_LOCAL_MACHINE",
2087                             "Path": (
2088                                 "SOFTWARE\\Microsoft\\Windows\\"
2089                                 "CurrentVersion\\policies\\system"
2090                             ),
2091                             "Value": "InactivityTimeoutSecs",
2092                             "Type": "REG_DWORD",
2093                         },
2094                     },
2095                     "legalnoticetext": {
2096                         "Policy": (
2097                             "Interactive logon: Message text for users "
2098                             "attempting to log on"
2099                         ),
2100                         "lgpo_section": self.security_options_gpedit_path,
2101                         "Registry": {
2102                             "Hive": "HKEY_LOCAL_MACHINE",
2103                             "Path": (
2104                                 "SOFTWARE\\Microsoft\\Windows\\"
2105                                 "CurrentVersion\\policies\\system"
2106                             ),
2107                             "Value": "legalnoticetext",
2108                             "Type": "REG_SZ",
2109                         },
2110                         "Transform": {"Put": "_string_put_transform"},
2111                     },
2112                     "legalnoticecaption": {
2113                         "Policy": (
2114                             "Interactive logon: Message title for users "
2115                             "attempting to log on"
2116                         ),
2117                         "lgpo_section": self.security_options_gpedit_path,
2118                         "Registry": {
2119                             "Hive": "HKEY_LOCAL_MACHINE",
2120                             "Path": (
2121                                 "SOFTWARE\\Microsoft\\Windows\\"
2122                                 "CurrentVersion\\policies\\system"
2123                             ),
2124                             "Value": "legalnoticecaption",
2125                             "Type": "REG_SZ",
2126                         },
2127                         "Transform": {"Put": "_string_put_transform"},
2128                     },
2129                     "DontDisplayLockedUserId": {
2130                         "Policy": (
2131                             "Interactive logon: Display user information "
2132                             "when the session is locked"
2133                         ),
2134                         "Settings": self.locked_session_user_info.keys(),
2135                         "lgpo_section": self.security_options_gpedit_path,
2136                         "Registry": {
2137                             "Hive": "HKEY_LOCAL_MACHINE",
2138                             "Path": (
2139                                 "SOFTWARE\\Microsoft\\Windows\\"
2140                                 "CurrentVersion\\policies\\system"
2141                             ),
2142                             "Value": "DontDisplayLockedUserId",
2143                             "Type": "REG_DWORD",
2144                         },
2145                         "Transform": {
2146                             "Get": "_dict_lookup",
2147                             "Put": "_dict_lookup",
2148                             "GetArgs": {
2149                                 "lookup": self.locked_session_user_info,
2150                                 "value_lookup": False,
2151                             },
2152                             "PutArgs": {
2153                                 "lookup": self.locked_session_user_info,
2154                                 "value_lookup": True,
2155                             },
2156                         },
2157                     },
2158                     "ScForceOption": {
2159                         "Policy": "Interactive logon: Require smart card",
2160                         "Settings": self.enabled_one_disabled_zero.keys(),
2161                         "lgpo_section": self.security_options_gpedit_path,
2162                         "Registry": {
2163                             "Hive": "HKEY_LOCAL_MACHINE",
2164                             "Path": (
2165                                 "Software\\Microsoft\\Windows\\"
2166                                 "CurrentVersion\\Policies\\System"
2167                             ),
2168                             "Value": "ScForceOption",
2169                             "Type": "REG_DWORD",
2170                         },
2171                         "Transform": self.enabled_one_disabled_zero_transform,
2172                     },
2173                     "Client_RequireSecuritySignature": {
2174                         "Policy": (
2175                             "Microsoft network client: Digitally sign "
2176                             "communications (always)"
2177                         ),
2178                         "Settings": self.enabled_one_disabled_zero.keys(),
2179                         "lgpo_section": self.security_options_gpedit_path,
2180                         "Registry": {
2181                             "Hive": "HKEY_LOCAL_MACHINE",
2182                             "Path": (
2183                                 "SYSTEM\\CurrentControlSet\\Services\\"
2184                                 "LanmanWorkstation\\Parameters"
2185                             ),
2186                             "Value": "RequireSecuritySignature",
2187                             "Type": "REG_DWORD",
2188                         },
2189                         "Transform": self.enabled_one_disabled_zero_transform,
2190                     },
2191                     "Client_EnableSecuritySignature": {
2192                         "Policy": (
2193                             "Microsoft network client: Digitally sign "
2194                             "communications (if server agrees)"
2195                         ),
2196                         "Settings": self.enabled_one_disabled_zero.keys(),
2197                         "lgpo_section": self.security_options_gpedit_path,
2198                         "Registry": {
2199                             "Hive": "HKEY_LOCAL_MACHINE",
2200                             "Path": (
2201                                 "SYSTEM\\CurrentControlSet\\Services\\"
2202                                 "LanmanWorkstation\\Parameters"
2203                             ),
2204                             "Value": "EnableSecuritySignature",
2205                             "Type": "REG_DWORD",
2206                         },
2207                         "Transform": self.enabled_one_disabled_zero_transform,
2208                     },
2209                     "EnablePlainTextPassword": {
2210                         "Policy": (
2211                             "Microsoft network client: Send unencrypted "
2212                             "password to third-party SMB servers"
2213                         ),
2214                         "Settings": self.enabled_one_disabled_zero.keys(),
2215                         "lgpo_section": self.security_options_gpedit_path,
2216                         "Registry": {
2217                             "Hive": "HKEY_LOCAL_MACHINE",
2218                             "Path": (
2219                                 "SYSTEM\\CurrentControlSet\\Services\\"
2220                                 "LanmanWorkstation\\Parameters"
2221                             ),
2222                             "Value": "EnablePlainTextPassword",
2223                             "Type": "REG_DWORD",
2224                         },
2225                         "Transform": self.enabled_one_disabled_zero_transform,
2226                     },
2227                     "AutoDisconnect": {
2228                         "Policy": (
2229                             "Microsoft network server: Amount of idle "
2230                             "time required before suspending session"
2231                         ),
2232                         "Settings": {
2233                             "Function": "_in_range_inclusive",
2234                             "Args": {"min": 0, "max": 99999},
2235                         },
2236                         "lgpo_section": self.security_options_gpedit_path,
2237                         "Registry": {
2238                             "Hive": "HKEY_LOCAL_MACHINE",
2239                             "Path": (
2240                                 "System\\CurrentControlSet\\Services\\"
2241                                 "LanmanServer\\Parameters"
2242                             ),
2243                             "Value": "AutoDisconnect",
2244                             "Type": "REG_DWORD",
2245                         },
2246                     },
2247                     "EnableS4U2SelfForClaims": {
2248                         "Policy": (
2249                             "Microsoft network server: Attempt S4U2Self "
2250                             "to obtain claim information"
2251                         ),
2252                         "Settings": self.s4u2self_options.keys(),
2253                         "lgpo_section": self.security_options_gpedit_path,
2254                         "Registry": {
2255                             "Hive": "HKEY_LOCAL_MACHINE",
2256                             "Path": (
2257                                 "System\\CurrentControlSet\\Services\\"
2258                                 "LanmanServer\\Parameters"
2259                             ),
2260                             "Value": "EnableS4U2SelfForClaims",
2261                             "Type": "REG_DWORD",
2262                         },
2263                         "Transform": {
2264                             "Get": "_dict_lookup",
2265                             "Put": "_dict_lookup",
2266                             "GetArgs": {
2267                                 "lookup": self.s4u2self_options,
2268                                 "value_lookup": False,
2269                             },
2270                             "PutArgs": {
2271                                 "lookup": self.s4u2self_options,
2272                                 "value_lookup": True,
2273                             },
2274                         },
2275                     },
2276                     "Server_RequireSecuritySignature": {
2277                         "Policy": (
2278                             "Microsoft network server: Digitally sign "
2279                             "communications (always)"
2280                         ),
2281                         "Settings": self.enabled_one_disabled_zero.keys(),
2282                         "lgpo_section": self.security_options_gpedit_path,
2283                         "Registry": {
2284                             "Hive": "HKEY_LOCAL_MACHINE",
2285                             "Path": (
2286                                 "SYSTEM\\CurrentControlSet\\Services\\"
2287                                 "LanmanServer\\Parameters"
2288                             ),
2289                             "Value": "RequireSecuritySignature",
2290                             "Type": "REG_DWORD",
2291                         },
2292                         "Transform": self.enabled_one_disabled_zero_transform,
2293                     },
2294                     "Server_EnableSecuritySignature": {
2295                         "Policy": (
2296                             "Microsoft network server: Digitally sign "
2297                             "communications (if client agrees)"
2298                         ),
2299                         "Settings": self.enabled_one_disabled_zero.keys(),
2300                         "lgpo_section": self.security_options_gpedit_path,
2301                         "Registry": {
2302                             "Hive": "HKEY_LOCAL_MACHINE",
2303                             "Path": (
2304                                 "SYSTEM\\CurrentControlSet\\Services\\"
2305                                 "LanmanServer\\Parameters"
2306                             ),
2307                             "Value": "EnableSecuritySignature",
2308                             "Type": "REG_DWORD",
2309                         },
2310                         "Transform": self.enabled_one_disabled_zero_transform,
2311                     },
2312                     "EnableForcedLogoff": {
2313                         "Policy": (
2314                             "Microsoft network server: Disconnect "
2315                             "clients when logon hours expire"
2316                         ),
2317                         "Settings": self.enabled_one_disabled_zero.keys(),
2318                         "lgpo_section": self.security_options_gpedit_path,
2319                         "Registry": {
2320                             "Hive": "HKEY_LOCAL_MACHINE",
2321                             "Path": (
2322                                 "SYSTEM\\CurrentControlSet\\Services\\"
2323                                 "LanmanServer\\Parameters"
2324                             ),
2325                             "Value": "EnableForcedLogoff",
2326                             "Type": "REG_DWORD",
2327                         },
2328                         "Transform": self.enabled_one_disabled_zero_transform,
2329                     },
2330                     "SmbServerNameHardeningLevel": {
2331                         "Policy": (
2332                             "Microsoft network server: Server SPN target "
2333                             "name validation level"
2334                         ),
2335                         "Settings": self.smb_server_name_hardening_levels.keys(),
2336                         "lgpo_section": self.security_options_gpedit_path,
2337                         "Registry": {
2338                             "Hive": "HKEY_LOCAL_MACHINE",
2339                             "Path": (
2340                                 "System\\CurrentControlSet\\Services\\"
2341                                 "LanmanServer\\Parameters"
2342                             ),
2343                             "Value": "SmbServerNameHardeningLevel",
2344                             "Type": "REG_DWORD",
2345                         },
2346                         "Transform": {
2347                             "Get": "_dict_lookup",
2348                             "Put": "_dict_lookup",
2349                             "GetArgs": {
2350                                 "lookup": self.smb_server_name_hardening_levels,
2351                                 "value_lookup": False,
2352                             },
2353                             "PutArgs": {
2354                                 "lookup": self.smb_server_name_hardening_levels,
2355                                 "value_lookup": True,
2356                             },
2357                         },
2358                     },
2359                     "FullPrivilegeAuditing": {
2360                         "Policy": (
2361                             "Audit: Audit the use of Backup and Restore privilege"
2362                         ),
2363                         "Settings": [chr(0), chr(1)],
2364                         "lgpo_section": self.security_options_gpedit_path,
2365                         "Registry": {
2366                             "Hive": "HKEY_LOCAL_MACHINE",
2367                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2368                             "Value": "FullPrivilegeAuditing",
2369                             "Type": "REG_BINARY",
2370                         },
2371                         "Transform": {
2372                             "Get": "_binary_enable_zero_disable_one_conversion",
2373                             "Put": "_binary_enable_zero_disable_one_reverse_conversion",
2374                         },
2375                     },
2376                     "CrashOnAuditFail": {
2377                         "Policy": (
2378                             "Audit: Shut down system immediately if "
2379                             "unable to log security audits"
2380                         ),
2381                         "Settings": self.enabled_one_disabled_zero.keys(),
2382                         "lgpo_section": self.security_options_gpedit_path,
2383                         "Registry": {
2384                             "Hive": "HKEY_LOCAL_MACHINE",
2385                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
2386                             "Value": "CrashOnAuditFail",
2387                             "Type": "REG_DWORD",
2388                         },
2389                         "Transform": self.enabled_one_disabled_zero_transform,
2390                     },
2391                     "UndockWithoutLogon": {
2392                         "Policy": "Devices: Allow undock without having to log on",
2393                         "Settings": self.enabled_one_disabled_zero.keys(),
2394                         "lgpo_section": self.security_options_gpedit_path,
2395                         "Registry": {
2396                             "Hive": "HKEY_LOCAL_MACHINE",
2397                             "Path": (
2398                                 "Software\\Microsoft\\Windows\\"
2399                                 "CurrentVersion\\Policies\\System"
2400                             ),
2401                             "Value": "UndockWithoutLogon",
2402                             "Type": "REG_DWORD",
2403                         },
2404                         "Transform": self.enabled_one_disabled_zero_transform,
2405                     },
2406                     "AddPrinterDrivers": {
2407                         "Policy": (
2408                             "Devices: Prevent users from installing printer drivers"
2409                         ),
2410                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2411                         "lgpo_section": self.security_options_gpedit_path,
2412                         "Registry": {
2413                             "Hive": "HKEY_LOCAL_MACHINE",
2414                             "Path": (
2415                                 "System\\CurrentControlSet\\Control\\"
2416                                 "Print\\Providers\\LanMan Print Services\\"
2417                                 "Servers"
2418                             ),
2419                             "Value": "AddPrinterDrivers",
2420                             "Type": "REG_DWORD",
2421                         },
2422                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2423                     },
2424                     "AllocateDASD": {
2425                         "Policy": (
2426                             "Devices: Allowed to format and eject removable media"
2427                         ),
2428                         "Settings": ["9999", "0", "1", "2"],
2429                         "lgpo_section": self.security_options_gpedit_path,
2430                         "Registry": {
2431                             "Hive": "HKEY_LOCAL_MACHINE",
2432                             "Path": (
2433                                 "Software\\Microsoft\\Windows NT\\"
2434                                 "CurrentVersion\\Winlogon"
2435                             ),
2436                             "Value": "AllocateDASD",
2437                             "Type": "REG_SZ",
2438                         },
2439                         "Transform": {
2440                             "Get": "_dasd_conversion",
2441                             "Put": "_dasd_reverse_conversion",
2442                         },
2443                     },
2444                     "AllocateCDRoms": {
2445                         "Policy": (
2446                             "Devices: Restrict CD-ROM access to locally "
2447                             "logged-on user only"
2448                         ),
2449                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2450                         "lgpo_section": self.security_options_gpedit_path,
2451                         "Registry": {
2452                             "Hive": "HKEY_LOCAL_MACHINE",
2453                             "Path": (
2454                                 "Software\\Microsoft\\Windows NT\\"
2455                                 "CurrentVersion\\Winlogon"
2456                             ),
2457                             "Value": "AllocateCDRoms",
2458                             "Type": "REG_SZ",
2459                         },
2460                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2461                     },
2462                     "AllocateFloppies": {
2463                         "Policy": (
2464                             "Devices: Restrict floppy access to locally "
2465                             "logged-on user only"
2466                         ),
2467                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2468                         "lgpo_section": self.security_options_gpedit_path,
2469                         "Registry": {
2470                             "Hive": "HKEY_LOCAL_MACHINE",
2471                             "Path": (
2472                                 "Software\\Microsoft\\Windows NT\\"
2473                                 "CurrentVersion\\Winlogon"
2474                             ),
2475                             "Value": "AllocateFloppies",
2476                             "Type": "REG_SZ",
2477                         },
2478                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2479                     },
2480                     "DriverSigningPolicy": {
2481                         "Policy": "Devices: Unsigned driver installation behavior",
2482                         "Settings": ["3,0", "3," + chr(1), "3," + chr(2)],
2483                         "lgpo_section": self.security_options_gpedit_path,
2484                         "Secedit": {
2485                             "Option": (
2486                                 "MACHINE\\Software\\Microsoft\\Driver Signing\\Policy"
2487                             ),
2488                             "Section": "Registry Values",
2489                         },
2490                         "Transform": {
2491                             "Get": "_driver_signing_reg_conversion",
2492                             "Put": "_driver_signing_reg_reverse_conversion",
2493                         },
2494                     },
2495                     "SubmitControl": {
2496                         "Policy": (
2497                             "Domain controller: Allow server operators "
2498                             "to schedule tasks"
2499                         ),
2500                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2501                         "lgpo_section": self.security_options_gpedit_path,
2502                         "Registry": {
2503                             "Hive": "HKEY_LOCAL_MACHINE",
2504                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2505                             "Value": "SubmitControl",
2506                             "Type": "REG_DWORD",
2507                         },
2508                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2509                     },
2510                     "LDAPServerIntegrity": {
2511                         "Policy": "Domain controller: LDAP server signing requirements",
2512                         "Settings": self.ldap_server_signing_requirements.keys(),
2513                         "lgpo_section": self.security_options_gpedit_path,
2514                         "Registry": {
2515                             "Hive": "HKEY_LOCAL_MACHINE",
2516                             "Path": (
2517                                 "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
2518                             ),
2519                             "Value": "LDAPServerIntegrity",
2520                             "Type": "REG_DWORD",
2521                         },
2522                         "Transform": {
2523                             "Get": "_dict_lookup",
2524                             "Put": "_dict_lookup",
2525                             "GetArgs": {
2526                                 "lookup": self.ldap_server_signing_requirements,
2527                                 "value_lookup": False,
2528                             },
2529                             "PutArgs": {
2530                                 "lookup": self.ldap_server_signing_requirements,
2531                                 "value_lookup": True,
2532                             },
2533                         },
2534                     },
2535                     "RefusePasswordChange": {
2536                         "Policy": (
2537                             "Domain controller: Refuse machine account password changes"
2538                         ),
2539                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2540                         "lgpo_section": self.security_options_gpedit_path,
2541                         "Registry": {
2542                             "Hive": "HKEY_LOCAL_MACHINE",
2543                             "Path": (
2544                                 "SYSTEM\\CurrentControlSet\\Services\\"
2545                                 "Netlogon\\Parameters"
2546                             ),
2547                             "Value": "RefusePasswordChange",
2548                             "Type": "REG_DWORD",
2549                         },
2550                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2551                     },
2552                     "RequireSignOrSeal": {
2553                         "Policy": (
2554                             "Domain member: Digitally encrypt or sign "
2555                             "secure channel data (always)"
2556                         ),
2557                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2558                         "lgpo_section": self.security_options_gpedit_path,
2559                         "Registry": {
2560                             "Hive": "HKEY_LOCAL_MACHINE",
2561                             "Path": (
2562                                 "System\\CurrentControlSet\\Services\\"
2563                                 "Netlogon\\Parameters"
2564                             ),
2565                             "Value": "RequireSignOrSeal",
2566                             "Type": "REG_DWORD",
2567                         },
2568                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2569                     },
2570                     "SealSecureChannel": {
2571                         "Policy": (
2572                             "Domain member: Digitally encrypt secure "
2573                             "channel data (when possible)"
2574                         ),
2575                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2576                         "lgpo_section": self.security_options_gpedit_path,
2577                         "Registry": {
2578                             "Hive": "HKEY_LOCAL_MACHINE",
2579                             "Path": (
2580                                 "System\\CurrentControlSet\\Services\\"
2581                                 "Netlogon\\Parameters"
2582                             ),
2583                             "Value": "SealSecureChannel",
2584                             "Type": "REG_DWORD",
2585                         },
2586                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2587                     },
2588                     "SignSecureChannel": {
2589                         "Policy": (
2590                             "Domain member: Digitally sign secure "
2591                             "channel data (when possible)"
2592                         ),
2593                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2594                         "lgpo_section": self.security_options_gpedit_path,
2595                         "Registry": {
2596                             "Hive": "HKEY_LOCAL_MACHINE",
2597                             "Path": (
2598                                 "System\\CurrentControlSet\\Services\\"
2599                                 "Netlogon\\Parameters"
2600                             ),
2601                             "Value": "SignSecureChannel",
2602                             "Type": "REG_DWORD",
2603                         },
2604                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2605                     },
2606                     "DisablePasswordChange": {
2607                         "Policy": (
2608                             "Domain member: Disable machine account password changes"
2609                         ),
2610                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2611                         "lgpo_section": self.security_options_gpedit_path,
2612                         "Registry": {
2613                             "Hive": "HKEY_LOCAL_MACHINE",
2614                             "Path": (
2615                                 "System\\CurrentControlSet\\Services\\"
2616                                 "Netlogon\\Parameters"
2617                             ),
2618                             "Value": "DisablePasswordChange",
2619                             "Type": "REG_DWORD",
2620                         },
2621                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2622                     },
2623                     "MaximumPasswordAge": {
2624                         "Policy": "Domain member: Maximum machine account password age",
2625                         "Settings": {
2626                             "Function": "_in_range_inclusive",
2627                             "Args": {"min": 0, "max": 999},
2628                         },
2629                         "lgpo_section": self.security_options_gpedit_path,
2630                         "Registry": {
2631                             "Hive": "HKEY_LOCAL_MACHINE",
2632                             "Path": (
2633                                 "System\\CurrentControlSet\\Services\\"
2634                                 "Netlogon\\Parameters"
2635                             ),
2636                             "Value": "MaximumPasswordAge",
2637                             "Type": "REG_DWORD",
2638                         },
2639                     },
2640                     "RequireStrongKey": {
2641                         "Policy": (
2642                             "Domain member: Require strong (Windows 2000 "
2643                             "or later) session key"
2644                         ),
2645                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2646                         "lgpo_section": self.security_options_gpedit_path,
2647                         "Registry": {
2648                             "Hive": "HKEY_LOCAL_MACHINE",
2649                             "Path": (
2650                                 "System\\CurrentControlSet\\Services\\"
2651                                 "Netlogon\\Parameters"
2652                             ),
2653                             "Value": "RequireStrongKey",
2654                             "Type": "REG_DWORD",
2655                         },
2656                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2657                     },
2658                     "LockoutDuration": {
2659                         "Policy": "Account lockout duration",
2660                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2661                         "Settings": {
2662                             "Function": "_in_range_inclusive",
2663                             "Args": {
2664                                 "min": 0,
2665                                 "max": 6000000,
2666                                 "zero_value": 0xFFFFFFFF,
2667                             },
2668                         },
2669                         "NetUserModal": {"Modal": 3, "Option": "lockout_duration"},
2670                         "Transform": {
2671                             "Get": "_seconds_to_minutes",
2672                             "Put": "_minutes_to_seconds",
2673                             "GetArgs": {"zero_value": 0xFFFFFFFF},
2674                             "PutArgs": {"zero_value": 0xFFFFFFFF},
2675                         },
2676                     },
2677                     "LockoutThreshold": {
2678                         "Policy": "Account lockout threshold",
2679                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2680                         "Settings": {
2681                             "Function": "_in_range_inclusive",
2682                             "Args": {"min": 0, "max": 1000},
2683                         },
2684                         "NetUserModal": {"Modal": 3, "Option": "lockout_threshold"},
2685                     },
2686                     "LockoutWindow": {
2687                         "Policy": "Reset account lockout counter after",
2688                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2689                         "Settings": {
2690                             "Function": "_in_range_inclusive",
2691                             "Args": {"min": 0, "max": 6000000},
2692                         },
2693                         "NetUserModal": {
2694                             "Modal": 3,
2695                             "Option": "lockout_observation_window",
2696                         },
2697                         "Transform": {
2698                             "Get": "_seconds_to_minutes",
2699                             "Put": "_minutes_to_seconds",
2700                         },
2701                     },
2702                     "AuditAccountLogon": {
2703                         "Policy": "Audit account logon events",
2704                         "lgpo_section": self.audit_policy_gpedit_path,
2705                         "Settings": self.audit_lookup.keys(),
2706                         "Secedit": {
2707                             "Option": "AuditAccountLogon",
2708                             "Section": "Event Audit",
2709                         },
2710                         "Transform": self.audit_transform,
2711                     },
2712                     "AuditAccountManage": {
2713                         "Policy": "Audit account management",
2714                         "lgpo_section": self.audit_policy_gpedit_path,
2715                         "Settings": self.audit_lookup.keys(),
2716                         "Secedit": {
2717                             "Option": "AuditAccountManage",
2718                             "Section": "Event Audit",
2719                         },
2720                         "Transform": self.audit_transform,
2721                     },
2722                     "AuditDSAccess": {
2723                         "Policy": "Audit directory service access",
2724                         "lgpo_section": self.audit_policy_gpedit_path,
2725                         "Settings": self.audit_lookup.keys(),
2726                         "Secedit": {
2727                             "Option": "AuditDSAccess",
2728                             "Section": "Event Audit",
2729                         },
2730                         "Transform": self.audit_transform,
2731                     },
2732                     "AuditLogonEvents": {
2733                         "Policy": "Audit logon events",
2734                         "lgpo_section": self.audit_policy_gpedit_path,
2735                         "Settings": self.audit_lookup.keys(),
2736                         "Secedit": {
2737                             "Option": "AuditLogonEvents",
2738                             "Section": "Event Audit",
2739                         },
2740                         "Transform": self.audit_transform,
2741                     },
2742                     "AuditObjectAccess": {
2743                         "Policy": "Audit object access",
2744                         "lgpo_section": self.audit_policy_gpedit_path,
2745                         "Settings": self.audit_lookup.keys(),
2746                         "Secedit": {
2747                             "Option": "AuditObjectAccess",
2748                             "Section": "Event Audit",
2749                         },
2750                         "Transform": self.audit_transform,
2751                     },
2752                     "AuditPolicyChange": {
2753                         "Policy": "Audit policy change",
2754                         "lgpo_section": self.audit_policy_gpedit_path,
2755                         "Settings": self.audit_lookup.keys(),
2756                         "Secedit": {
2757                             "Option": "AuditPolicyChange",
2758                             "Section": "Event Audit",
2759                         },
2760                         "Transform": self.audit_transform,
2761                     },
2762                     "AuditPrivilegeUse": {
2763                         "Policy": "Audit privilege use",
2764                         "lgpo_section": self.audit_policy_gpedit_path,
2765                         "Settings": self.audit_lookup.keys(),
2766                         "Secedit": {
2767                             "Option": "AuditPrivilegeUse",
2768                             "Section": "Event Audit",
2769                         },
2770                         "Transform": self.audit_transform,
2771                     },
2772                     "AuditProcessTracking": {
2773                         "Policy": "Audit process tracking",
2774                         "lgpo_section": self.audit_policy_gpedit_path,
2775                         "Settings": self.audit_lookup.keys(),
2776                         "Secedit": {
2777                             "Option": "AuditProcessTracking",
2778                             "Section": "Event Audit",
2779                         },
2780                         "Transform": self.audit_transform,
2781                     },
2782                     "AuditSystemEvents": {
2783                         "Policy": "Audit system events",
2784                         "lgpo_section": self.audit_policy_gpedit_path,
2785                         "Settings": self.audit_lookup.keys(),
2786                         "Secedit": {
2787                             "Option": "AuditSystemEvents",
2788                             "Section": "Event Audit",
2789                         },
2790                         "Transform": self.audit_transform,
2791                     },
2792                     "AuditCredentialValidation": {
2793                         "Policy": "Audit Credential Validation",
2794                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2795                         "Settings": self.advanced_audit_lookup.keys(),
2796                         "AdvAudit": {"Option": "Audit Credential Validation"},
2797                         "Transform": self.advanced_audit_transform,
2798                     },
2799                     "AuditKerberosAuthenticationService": {
2800                         "Policy": "Audit Kerberos Authentication Service",
2801                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2802                         "Settings": self.advanced_audit_lookup.keys(),
2803                         "AdvAudit": {
2804                             "Option": "Audit Kerberos Authentication Service",
2805                         },
2806                         "Transform": self.advanced_audit_transform,
2807                     },
2808                     "AuditKerberosServiceTicketOperations": {
2809                         "Policy": "Audit Kerberos Service Ticket Operations",
2810                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2811                         "Settings": self.advanced_audit_lookup.keys(),
2812                         "AdvAudit": {
2813                             "Option": "Audit Kerberos Service Ticket Operations",
2814                         },
2815                         "Transform": self.advanced_audit_transform,
2816                     },
2817                     "AuditOtherAccountLogonEvents": {
2818                         "Policy": "Audit Other Account Logon Events",
2819                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2820                         "Settings": self.advanced_audit_lookup.keys(),
2821                         "AdvAudit": {"Option": "Audit Other Account Logon Events"},
2822                         "Transform": self.advanced_audit_transform,
2823                     },
2824                     "AuditApplicationGroupManagement": {
2825                         "Policy": "Audit Application Group Management",
2826                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2827                         "Settings": self.advanced_audit_lookup.keys(),
2828                         "AdvAudit": {"Option": "Audit Application Group Management"},
2829                         "Transform": self.advanced_audit_transform,
2830                     },
2831                     "AuditComputerAccountManagement": {
2832                         "Policy": "Audit Computer Account Management",
2833                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2834                         "Settings": self.advanced_audit_lookup.keys(),
2835                         "AdvAudit": {"Option": "Audit Computer Account Management"},
2836                         "Transform": self.advanced_audit_transform,
2837                     },
2838                     "AuditDistributionGroupManagement": {
2839                         "Policy": "Audit Distribution Group Management",
2840                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2841                         "Settings": self.advanced_audit_lookup.keys(),
2842                         "AdvAudit": {"Option": "Audit Distribution Group Management"},
2843                         "Transform": self.advanced_audit_transform,
2844                     },
2845                     "AuditOtherAccountManagementEvents": {
2846                         "Policy": "Audit Other Account Management Events",
2847                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2848                         "Settings": self.advanced_audit_lookup.keys(),
2849                         "AdvAudit": {
2850                             "Option": "Audit Other Account Management Events",
2851                         },
2852                         "Transform": self.advanced_audit_transform,
2853                     },
2854                     "AuditSecurityGroupManagement": {
2855                         "Policy": "Audit Security Group Management",
2856                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2857                         "Settings": self.advanced_audit_lookup.keys(),
2858                         "AdvAudit": {"Option": "Audit Security Group Management"},
2859                         "Transform": self.advanced_audit_transform,
2860                     },
2861                     "AuditUserAccountManagement": {
2862                         "Policy": "Audit User Account Management",
2863                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2864                         "Settings": self.advanced_audit_lookup.keys(),
2865                         "AdvAudit": {"Option": "Audit User Account Management"},
2866                         "Transform": self.advanced_audit_transform,
2867                     },
2868                     "AuditDPAPIActivity": {
2869                         "Policy": "Audit DPAPI Activity",
2870                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2871                         "Settings": self.advanced_audit_lookup.keys(),
2872                         "AdvAudit": {"Option": "Audit DPAPI Activity"},
2873                         "Transform": self.advanced_audit_transform,
2874                     },
2875                     "AuditPNPActivity": {
2876                         "Policy": "Audit PNP Activity",
2877                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2878                         "Settings": self.advanced_audit_lookup.keys(),
2879                         "AdvAudit": {"Option": "Audit PNP Activity"},
2880                         "Transform": self.advanced_audit_transform,
2881                     },
2882                     "AuditProcessCreation": {
2883                         "Policy": "Audit Process Creation",
2884                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2885                         "Settings": self.advanced_audit_lookup.keys(),
2886                         "AdvAudit": {"Option": "Audit Process Creation"},
2887                         "Transform": self.advanced_audit_transform,
2888                     },
2889                     "AuditProcessTermination": {
2890                         "Policy": "Audit Process Termination",
2891                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2892                         "Settings": self.advanced_audit_lookup.keys(),
2893                         "AdvAudit": {"Option": "Audit Process Termination"},
2894                         "Transform": self.advanced_audit_transform,
2895                     },
2896                     "AuditRPCEvents": {
2897                         "Policy": "Audit RPC Events",
2898                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2899                         "Settings": self.advanced_audit_lookup.keys(),
2900                         "AdvAudit": {"Option": "Audit RPC Events"},
2901                         "Transform": self.advanced_audit_transform,
2902                     },
2903                     "AuditTokenRightAdjusted": {
2904                         "Policy": "Audit Token Right Adjusted",
2905                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2906                         "Settings": self.advanced_audit_lookup.keys(),
2907                         "AdvAudit": {"Option": "Audit Token Right Adjusted"},
2908                         "Transform": self.advanced_audit_transform,
2909                     },
2910                     "AuditDetailedDirectoryServiceReplication": {
2911                         "Policy": "Audit Detailed Directory Service Replication",
2912                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2913                         "Settings": self.advanced_audit_lookup.keys(),
2914                         "AdvAudit": {
2915                             "Option": "Audit Detailed Directory Service Replication",
2916                         },
2917                         "Transform": self.advanced_audit_transform,
2918                     },
2919                     "AuditDirectoryServiceAccess": {
2920                         "Policy": "Audit Directory Service Access",
2921                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2922                         "Settings": self.advanced_audit_lookup.keys(),
2923                         "AdvAudit": {"Option": "Audit Directory Service Access"},
2924                         "Transform": self.advanced_audit_transform,
2925                     },
2926                     "AuditDirectoryServiceChanges": {
2927                         "Policy": "Audit Directory Service Changes",
2928                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2929                         "Settings": self.advanced_audit_lookup.keys(),
2930                         "AdvAudit": {"Option": "Audit Directory Service Changes"},
2931                         "Transform": self.advanced_audit_transform,
2932                     },
2933                     "AuditDirectoryServiceReplication": {
2934                         "Policy": "Audit Directory Service Replication",
2935                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2936                         "Settings": self.advanced_audit_lookup.keys(),
2937                         "AdvAudit": {"Option": "Audit Directory Service Replication"},
2938                         "Transform": self.advanced_audit_transform,
2939                     },
2940                     "AuditAccountLockout": {
2941                         "Policy": "Audit Account Lockout",
2942                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2943                         "Settings": self.advanced_audit_lookup.keys(),
2944                         "AdvAudit": {"Option": "Audit Account Lockout"},
2945                         "Transform": self.advanced_audit_transform,
2946                     },
2947                     "AuditUserDeviceClaims": {
2948                         "Policy": "Audit User / Device Claims",
2949                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2950                         "Settings": self.advanced_audit_lookup.keys(),
2951                         "AdvAudit": {"Option": "Audit User / Device Claims"},
2952                         "Transform": self.advanced_audit_transform,
2953                     },
2954                     "AuditGroupMembership": {
2955                         "Policy": "Audit Group Membership",
2956                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2957                         "Settings": self.advanced_audit_lookup.keys(),
2958                         "AdvAudit": {"Option": "Audit Group Membership"},
2959                         "Transform": self.advanced_audit_transform,
2960                     },
2961                     "AuditIPsecExtendedMode": {
2962                         "Policy": "Audit IPsec Extended Mode",
2963                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2964                         "Settings": self.advanced_audit_lookup.keys(),
2965                         "AdvAudit": {"Option": "Audit IPsec Extended Mode"},
2966                         "Transform": self.advanced_audit_transform,
2967                     },
2968                     "AuditIPsecMainMode": {
2969                         "Policy": "Audit IPsec Main Mode",
2970                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2971                         "Settings": self.advanced_audit_lookup.keys(),
2972                         "AdvAudit": {"Option": "Audit IPsec Main Mode"},
2973                         "Transform": self.advanced_audit_transform,
2974                     },
2975                     "AuditIPsecQuickMode": {
2976                         "Policy": "Audit IPsec Quick Mode",
2977                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2978                         "Settings": self.advanced_audit_lookup.keys(),
2979                         "AdvAudit": {"Option": "Audit IPsec Quick Mode"},
2980                         "Transform": self.advanced_audit_transform,
2981                     },
2982                     "AuditLogoff": {
2983                         "Policy": "Audit Logoff",
2984                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2985                         "Settings": self.advanced_audit_lookup.keys(),
2986                         "AdvAudit": {"Option": "Audit Logoff"},
2987                         "Transform": self.advanced_audit_transform,
2988                     },
2989                     "AuditLogon": {
2990                         "Policy": "Audit Logon",
2991                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2992                         "Settings": self.advanced_audit_lookup.keys(),
2993                         "AdvAudit": {"Option": "Audit Logon"},
2994                         "Transform": self.advanced_audit_transform,
2995                     },
2996                     "AuditNetworkPolicyServer": {
2997                         "Policy": "Audit Network Policy Server",
2998                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2999                         "Settings": self.advanced_audit_lookup.keys(),
3000                         "AdvAudit": {"Option": "Audit Network Policy Server"},
3001                         "Transform": self.advanced_audit_transform,
3002                     },
3003                     "AuditOtherLogonLogoffEvents": {
3004                         "Policy": "Audit Other Logon/Logoff Events",
3005                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3006                         "Settings": self.advanced_audit_lookup.keys(),
3007                         "AdvAudit": {"Option": "Audit Other Logon/Logoff Events"},
3008                         "Transform": self.advanced_audit_transform,
3009                     },
3010                     "AuditSpecialLogon": {
3011                         "Policy": "Audit Special Logon",
3012                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3013                         "Settings": self.advanced_audit_lookup.keys(),
3014                         "AdvAudit": {"Option": "Audit Special Logon"},
3015                         "Transform": self.advanced_audit_transform,
3016                     },
3017                     "AuditApplicationGenerated": {
3018                         "Policy": "Audit Application Generated",
3019                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3020                         "Settings": self.advanced_audit_lookup.keys(),
3021                         "AdvAudit": {"Option": "Audit Application Generated"},
3022                         "Transform": self.advanced_audit_transform,
3023                     },
3024                     "AuditCertificationServices": {
3025                         "Policy": "Audit Certification Services",
3026                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3027                         "Settings": self.advanced_audit_lookup.keys(),
3028                         "AdvAudit": {"Option": "Audit Certification Services"},
3029                         "Transform": self.advanced_audit_transform,
3030                     },
3031                     "AuditDetailedFileShare": {
3032                         "Policy": "Audit Detailed File Share",
3033                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3034                         "Settings": self.advanced_audit_lookup.keys(),
3035                         "AdvAudit": {"Option": "Audit Detailed File Share"},
3036                         "Transform": self.advanced_audit_transform,
3037                     },
3038                     "AuditFileShare": {
3039                         "Policy": "Audit File Share",
3040                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3041                         "Settings": self.advanced_audit_lookup.keys(),
3042                         "AdvAudit": {"Option": "Audit File Share"},
3043                         "Transform": self.advanced_audit_transform,
3044                     },
3045                     "AuditFileSystem": {
3046                         "Policy": "Audit File System",
3047                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3048                         "Settings": self.advanced_audit_lookup.keys(),
3049                         "AdvAudit": {"Option": "Audit File System"},
3050                         "Transform": self.advanced_audit_transform,
3051                     },
3052                     "AuditFilteringPlatformConnection": {
3053                         "Policy": "Audit Filtering Platform Connection",
3054                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3055                         "Settings": self.advanced_audit_lookup.keys(),
3056                         "AdvAudit": {"Option": "Audit Filtering Platform Connection"},
3057                         "Transform": self.advanced_audit_transform,
3058                     },
3059                     "AuditFilteringPlatformPacketDrop": {
3060                         "Policy": "Audit Filtering Platform Packet Drop",
3061                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3062                         "Settings": self.advanced_audit_lookup.keys(),
3063                         "AdvAudit": {"Option": "Audit Filtering Platform Packet Drop"},
3064                         "Transform": self.advanced_audit_transform,
3065                     },
3066                     "AuditHandleManipulation": {
3067                         "Policy": "Audit Handle Manipulation",
3068                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3069                         "Settings": self.advanced_audit_lookup.keys(),
3070                         "AdvAudit": {"Option": "Audit Handle Manipulation"},
3071                         "Transform": self.advanced_audit_transform,
3072                     },
3073                     "AuditKernelObject": {
3074                         "Policy": "Audit Kernel Object",
3075                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3076                         "Settings": self.advanced_audit_lookup.keys(),
3077                         "AdvAudit": {"Option": "Audit Kernel Object"},
3078                         "Transform": self.advanced_audit_transform,
3079                     },
3080                     "AuditOtherObjectAccessEvents": {
3081                         "Policy": "Audit Other Object Access Events",
3082                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3083                         "Settings": self.advanced_audit_lookup.keys(),
3084                         "AdvAudit": {"Option": "Audit Other Object Access Events"},
3085                         "Transform": self.advanced_audit_transform,
3086                     },
3087                     "AuditRegistry": {
3088                         "Policy": "Audit Registry",
3089                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3090                         "Settings": self.advanced_audit_lookup.keys(),
3091                         "AdvAudit": {"Option": "Audit Registry"},
3092                         "Transform": self.advanced_audit_transform,
3093                     },
3094                     "AuditRemovableStorage": {
3095                         "Policy": "Audit Removable Storage",
3096                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3097                         "Settings": self.advanced_audit_lookup.keys(),
3098                         "AdvAudit": {"Option": "Audit Removable Storage"},
3099                         "Transform": self.advanced_audit_transform,
3100                     },
3101                     "AuditSAM": {
3102                         "Policy": "Audit SAM",
3103                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3104                         "Settings": self.advanced_audit_lookup.keys(),
3105                         "AdvAudit": {"Option": "Audit SAM"},
3106                         "Transform": self.advanced_audit_transform,
3107                     },
3108                     "AuditCentralAccessPolicyStaging": {
3109                         "Policy": "Audit Central Access Policy Staging",
3110                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3111                         "Settings": self.advanced_audit_lookup.keys(),
3112                         "AdvAudit": {"Option": "Audit Central Access Policy Staging"},
3113                         "Transform": self.advanced_audit_transform,
3114                     },
3115                     "AuditAuditPolicyChange": {
3116                         "Policy": "Audit Audit Policy Change",
3117                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3118                         "Settings": self.advanced_audit_lookup.keys(),
3119                         "AdvAudit": {"Option": "Audit Audit Policy Change"},
3120                         "Transform": self.advanced_audit_transform,
3121                     },
3122                     "AuditAuthenticationPolicyChange": {
3123                         "Policy": "Audit Authentication Policy Change",
3124                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3125                         "Settings": self.advanced_audit_lookup.keys(),
3126                         "AdvAudit": {"Option": "Audit Authentication Policy Change"},
3127                         "Transform": self.advanced_audit_transform,
3128                     },
3129                     "AuditAuthorizationPolicyChange": {
3130                         "Policy": "Audit Authorization Policy Change",
3131                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3132                         "Settings": self.advanced_audit_lookup.keys(),
3133                         "AdvAudit": {"Option": "Audit Authorization Policy Change"},
3134                         "Transform": self.advanced_audit_transform,
3135                     },
3136                     "AuditFilteringPlatformPolicyChange": {
3137                         "Policy": "Audit Filtering Platform Policy Change",
3138                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3139                         "Settings": self.advanced_audit_lookup.keys(),
3140                         "AdvAudit": {
3141                             "Option": "Audit Filtering Platform Policy Change",
3142                         },
3143                         "Transform": self.advanced_audit_transform,
3144                     },
3145                     "AuditMPSSVCRuleLevelPolicyChange": {
3146                         "Policy": "Audit MPSSVC Rule-Level Policy Change",
3147                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3148                         "Settings": self.advanced_audit_lookup.keys(),
3149                         "AdvAudit": {
3150                             "Option": "Audit MPSSVC Rule-Level Policy Change",
3151                         },
3152                         "Transform": self.advanced_audit_transform,
3153                     },
3154                     "AuditOtherPolicyChangeEvents": {
3155                         "Policy": "Audit Other Policy Change Events",
3156                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3157                         "Settings": self.advanced_audit_lookup.keys(),
3158                         "AdvAudit": {"Option": "Audit Other Policy Change Events"},
3159                         "Transform": self.advanced_audit_transform,
3160                     },
3161                     "AuditNonSensitivePrivilegeUse": {
3162                         "Policy": "Audit Non Sensitive Privilege Use",
3163                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3164                         "Settings": self.advanced_audit_lookup.keys(),
3165                         "AdvAudit": {"Option": "Audit Non Sensitive Privilege Use"},
3166                         "Transform": self.advanced_audit_transform,
3167                     },
3168                     "AuditOtherPrivilegeUseEvents": {
3169                         "Policy": "Audit Other Privilege Use Events",
3170                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3171                         "Settings": self.advanced_audit_lookup.keys(),
3172                         "AdvAudit": {"Option": "Audit Other Privilege Use Events"},
3173                         "Transform": self.advanced_audit_transform,
3174                     },
3175                     "AuditSensitivePrivilegeUse": {
3176                         "Policy": "Audit Sensitive Privilege Use",
3177                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3178                         "Settings": self.advanced_audit_lookup.keys(),
3179                         "AdvAudit": {"Option": "Audit Sensitive Privilege Use"},
3180                         "Transform": self.advanced_audit_transform,
3181                     },
3182                     "AuditIPsecDriver": {
3183                         "Policy": "Audit IPsec Driver",
3184                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3185                         "Settings": self.advanced_audit_lookup.keys(),
3186                         "AdvAudit": {"Option": "Audit IPsec Driver"},
3187                         "Transform": self.advanced_audit_transform,
3188                     },
3189                     "AuditOtherSystemEvents": {
3190                         "Policy": "Audit Other System Events",
3191                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3192                         "Settings": self.advanced_audit_lookup.keys(),
3193                         "AdvAudit": {"Option": "Audit Other System Events"},
3194                         "Transform": self.advanced_audit_transform,
3195                     },
3196                     "AuditSecurityStateChange": {
3197                         "Policy": "Audit Security State Change",
3198                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3199                         "Settings": self.advanced_audit_lookup.keys(),
3200                         "AdvAudit": {"Option": "Audit Security State Change"},
3201                         "Transform": self.advanced_audit_transform,
3202                     },
3203                     "AuditSecuritySystemExtension": {
3204                         "Policy": "Audit Security System Extension",
3205                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3206                         "Settings": self.advanced_audit_lookup.keys(),
3207                         "AdvAudit": {"Option": "Audit Security System Extension"},
3208                         "Transform": self.advanced_audit_transform,
3209                     },
3210                     "AuditSystemIntegrity": {
3211                         "Policy": "Audit System Integrity",
3212                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3213                         "Settings": self.advanced_audit_lookup.keys(),
3214                         "AdvAudit": {"Option": "Audit System Integrity"},
3215                         "Transform": self.advanced_audit_transform,
3216                     },
3217                     "SeTrustedCredManAccessPrivilege": {
3218                         "Policy": "Access Credential Manager as a trusted caller",
3219                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3220                         "rights_assignment": True,
3221                         "Settings": None,
3222                         "LsaRights": {"Option": "SeTrustedCredManAccessPrivilege"},
3223                         "Transform": {
3224                             "Get": "_sidConversion",
3225                             "Put": "_usernamesToSidObjects",
3226                         },
3227                     },
3228                     "SeNetworkLogonRight": {
3229                         "Policy": "Access this computer from the network",
3230                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3231                         "rights_assignment": True,
3232                         "Settings": None,
3233                         "LsaRights": {"Option": "SeNetworkLogonRight"},
3234                         "Transform": {
3235                             "Get": "_sidConversion",
3236                             "Put": "_usernamesToSidObjects",
3237                         },
3238                     },
3239                     "SeTcbPrivilege": {
3240                         "Policy": "Act as part of the operating system",
3241                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3242                         "rights_assignment": True,
3243                         "Settings": None,
3244                         "LsaRights": {"Option": "SeTcbPrivilege"},
3245                         "Transform": {
3246                             "Get": "_sidConversion",
3247                             "Put": "_usernamesToSidObjects",
3248                         },
3249                     },
3250                     "SeMachineAccountPrivilege": {
3251                         "Policy": "Add workstations to domain",
3252                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3253                         "rights_assignment": True,
3254                         "Settings": None,
3255                         "LsaRights": {"Option": "SeMachineAccountPrivilege"},
3256                         "Transform": {
3257                             "Get": "_sidConversion",
3258                             "Put": "_usernamesToSidObjects",
3259                         },
3260                     },
3261                     "SeIncreaseQuotaPrivilege": {
3262                         "Policy": "Adjust memory quotas for a process",
3263                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3264                         "rights_assignment": True,
3265                         "Settings": None,
3266                         "LsaRights": {"Option": "SeIncreaseQuotaPrivilege"},
3267                         "Transform": {
3268                             "Get": "_sidConversion",
3269                             "Put": "_usernamesToSidObjects",
3270                         },
3271                     },
3272                     "SeInteractiveLogonRight": {
3273                         "Policy": "Allow log on locally",
3274                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3275                         "rights_assignment": True,
3276                         "Settings": None,
3277                         "LsaRights": {"Option": "SeInteractiveLogonRight"},
3278                         "Transform": {
3279                             "Get": "_sidConversion",
3280                             "Put": "_usernamesToSidObjects",
3281                         },
3282                     },
3283                     "SeRemoteInteractiveLogonRight": {
3284                         "Policy": "Allow log on through Remote Desktop Services",
3285                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3286                         "rights_assignment": True,
3287                         "Settings": None,
3288                         "LsaRights": {"Option": "SeRemoteInteractiveLogonRight"},
3289                         "Transform": {
3290                             "Get": "_sidConversion",
3291                             "Put": "_usernamesToSidObjects",
3292                         },
3293                     },
3294                     "SeBackupPrivilege": {
3295                         "Policy": "Backup files and directories",
3296                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3297                         "rights_assignment": True,
3298                         "Settings": None,
3299                         "LsaRights": {"Option": "SeBackupPrivilege"},
3300                         "Transform": {
3301                             "Get": "_sidConversion",
3302                             "Put": "_usernamesToSidObjects",
3303                         },
3304                     },
3305                     "SeChangeNotifyPrivilege": {
3306                         "Policy": "Bypass traverse checking",
3307                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3308                         "rights_assignment": True,
3309                         "Settings": None,
3310                         "LsaRights": {"Option": "SeChangeNotifyPrivilege"},
3311                         "Transform": {
3312                             "Get": "_sidConversion",
3313                             "Put": "_usernamesToSidObjects",
3314                         },
3315                     },
3316                     "SeSystemtimePrivilege": {
3317                         "Policy": "Change the system time",
3318                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3319                         "rights_assignment": True,
3320                         "Settings": None,
3321                         "LsaRights": {"Option": "SeSystemtimePrivilege"},
3322                         "Transform": {
3323                             "Get": "_sidConversion",
3324                             "Put": "_usernamesToSidObjects",
3325                         },
3326                     },
3327                     "SeTimeZonePrivilege": {
3328                         "Policy": "Change the time zone",
3329                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3330                         "rights_assignment": True,
3331                         "Settings": None,
3332                         "LsaRights": {"Option": "SeTimeZonePrivilege"},
3333                         "Transform": {
3334                             "Get": "_sidConversion",
3335                             "Put": "_usernamesToSidObjects",
3336                         },
3337                     },
3338                     "SeCreatePagefilePrivilege": {
3339                         "Policy": "Create a pagefile",
3340                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3341                         "rights_assignment": True,
3342                         "Settings": None,
3343                         "LsaRights": {"Option": "SeCreatePagefilePrivilege"},
3344                         "Transform": {
3345                             "Get": "_sidConversion",
3346                             "Put": "_usernamesToSidObjects",
3347                         },
3348                     },
3349                     "SeCreateTokenPrivilege": {
3350                         "Policy": "Create a token object",
3351                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3352                         "rights_assignment": True,
3353                         "Settings": None,
3354                         "LsaRights": {"Option": "SeCreateTokenPrivilege"},
3355                         "Transform": {
3356                             "Get": "_sidConversion",
3357                             "Put": "_usernamesToSidObjects",
3358                         },
3359                     },
3360                     "SeCreateGlobalPrivilege": {
3361                         "Policy": "Create global objects",
3362                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3363                         "rights_assignment": True,
3364                         "Settings": None,
3365                         "LsaRights": {"Option": "SeCreateGlobalPrivilege"},
3366                         "Transform": {
3367                             "Get": "_sidConversion",
3368                             "Put": "_usernamesToSidObjects",
3369                         },
3370                     },
3371                     "SeCreatePermanentPrivilege": {
3372                         "Policy": "Create permanent shared objects",
3373                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3374                         "rights_assignment": True,
3375                         "Settings": None,
3376                         "LsaRights": {"Option": "SeCreatePermanentPrivilege"},
3377                         "Transform": {
3378                             "Get": "_sidConversion",
3379                             "Put": "_usernamesToSidObjects",
3380                         },
3381                     },
3382                     "SeCreateSymbolicLinkPrivilege": {
3383                         "Policy": "Create symbolic links",
3384                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3385                         "rights_assignment": True,
3386                         "Settings": None,
3387                         "LsaRights": {"Option": "SeCreateSymbolicLinkPrivilege"},
3388                         "Transform": {
3389                             "Get": "_sidConversion",
3390                             "Put": "_usernamesToSidObjects",
3391                         },
3392                     },
3393                     "SeDebugPrivilege": {
3394                         "Policy": "Debug programs",
3395                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3396                         "rights_assignment": True,
3397                         "Settings": None,
3398                         "LsaRights": {"Option": "SeDebugPrivilege"},
3399                         "Transform": {
3400                             "Get": "_sidConversion",
3401                             "Put": "_usernamesToSidObjects",
3402                         },
3403                     },
3404                     "SeDenyNetworkLogonRight": {
3405                         "Policy": "Deny access to this computer from the network",
3406                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3407                         "rights_assignment": True,
3408                         "Settings": None,
3409                         "LsaRights": {"Option": "SeDenyNetworkLogonRight"},
3410                         "Transform": {
3411                             "Get": "_sidConversion",
3412                             "Put": "_usernamesToSidObjects",
3413                         },
3414                     },
3415                     "SeDenyBatchLogonRight": {
3416                         "Policy": "Deny log on as a batch job",
3417                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3418                         "rights_assignment": True,
3419                         "Settings": None,
3420                         "LsaRights": {"Option": "SeDenyBatchLogonRight"},
3421                         "Transform": {
3422                             "Get": "_sidConversion",
3423                             "Put": "_usernamesToSidObjects",
3424                         },
3425                     },
3426                     "SeDenyServiceLogonRight": {
3427                         "Policy": "Deny log on as a service",
3428                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3429                         "rights_assignment": True,
3430                         "Settings": None,
3431                         "LsaRights": {"Option": "SeDenyServiceLogonRight"},
3432                         "Transform": {
3433                             "Get": "_sidConversion",
3434                             "Put": "_usernamesToSidObjects",
3435                         },
3436                     },
3437                     "SeDenyInteractiveLogonRight": {
3438                         "Policy": "Deny log on locally",
3439                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3440                         "rights_assignment": True,
3441                         "Settings": None,
3442                         "LsaRights": {"Option": "SeDenyInteractiveLogonRight"},
3443                         "Transform": {
3444                             "Get": "_sidConversion",
3445                             "Put": "_usernamesToSidObjects",
3446                         },
3447                     },
3448                     "SeDenyRemoteInteractiveLogonRight": {
3449                         "Policy": "Deny log on through Remote Desktop Services",
3450                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3451                         "rights_assignment": True,
3452                         "Settings": None,
3453                         "LsaRights": {"Option": "SeDenyRemoteInteractiveLogonRight"},
3454                         "Transform": {
3455                             "Get": "_sidConversion",
3456                             "Put": "_usernamesToSidObjects",
3457                         },
3458                     },
3459                     "SeEnableDelegationPrivilege": {
3460                         "Policy": (
3461                             "Enable computer and user accounts to be "
3462                             "trusted for delegation"
3463                         ),
3464                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3465                         "rights_assignment": True,
3466                         "Settings": None,
3467                         "LsaRights": {"Option": "SeEnableDelegationPrivilege"},
3468                         "Transform": {
3469                             "Get": "_sidConversion",
3470                             "Put": "_usernamesToSidObjects",
3471                         },
3472                     },
3473                     "SeRemoteShutdownPrivilege": {
3474                         "Policy": "Force shutdown from a remote system",
3475                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3476                         "rights_assignment": True,
3477                         "Settings": None,
3478                         "LsaRights": {"Option": "SeRemoteShutdownPrivilege"},
3479                         "Transform": {
3480                             "Get": "_sidConversion",
3481                             "Put": "_usernamesToSidObjects",
3482                         },
3483                     },
3484                     "SeAuditPrivilege": {
3485                         "Policy": "Generate security audits",
3486                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3487                         "rights_assignment": True,
3488                         "Settings": None,
3489                         "LsaRights": {"Option": "SeAuditPrivilege"},
3490                         "Transform": {
3491                             "Get": "_sidConversion",
3492                             "Put": "_usernamesToSidObjects",
3493                         },
3494                     },
3495                     "SeImpersonatePrivilege": {
3496                         "Policy": "Impersonate a client after authentication",
3497                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3498                         "rights_assignment": True,
3499                         "Settings": None,
3500                         "LsaRights": {"Option": "SeImpersonatePrivilege"},
3501                         "Transform": {
3502                             "Get": "_sidConversion",
3503                             "Put": "_usernamesToSidObjects",
3504                         },
3505                     },
3506                     "SeIncreaseWorkingSetPrivilege": {
3507                         "Policy": "Increase a process working set",
3508                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3509                         "rights_assignment": True,
3510                         "Settings": None,
3511                         "LsaRights": {"Option": "SeIncreaseWorkingSetPrivilege"},
3512                         "Transform": {
3513                             "Get": "_sidConversion",
3514                             "Put": "_usernamesToSidObjects",
3515                         },
3516                     },
3517                     "SeIncreaseBasePriorityPrivilege": {
3518                         "Policy": "Increase scheduling priority",
3519                         "rights_assignment": True,
3520                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3521                         "Settings": None,
3522                         "LsaRights": {"Option": "SeIncreaseBasePriorityPrivilege"},
3523                         "Transform": {
3524                             "Get": "_sidConversion",
3525                             "Put": "_usernamesToSidObjects",
3526                         },
3527                     },
3528                     "SeLoadDriverPrivilege": {
3529                         "Policy": "Load and unload device drivers",
3530                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3531                         "rights_assignment": True,
3532                         "Settings": None,
3533                         "LsaRights": {"Option": "SeLoadDriverPrivilege"},
3534                         "Transform": {
3535                             "Get": "_sidConversion",
3536                             "Put": "_usernamesToSidObjects",
3537                         },
3538                     },
3539                     "SeLockMemoryPrivilege": {
3540                         "Policy": "Lock pages in memory",
3541                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3542                         "rights_assignment": True,
3543                         "Settings": None,
3544                         "LsaRights": {"Option": "SeLockMemoryPrivilege"},
3545                         "Transform": {
3546                             "Get": "_sidConversion",
3547                             "Put": "_usernamesToSidObjects",
3548                         },
3549                     },
3550                     "SeBatchLogonRight": {
3551                         "Policy": "Log on as a batch job",
3552                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3553                         "rights_assignment": True,
3554                         "Settings": None,
3555                         "LsaRights": {"Option": "SeBatchLogonRight"},
3556                         "Transform": {
3557                             "Get": "_sidConversion",
3558                             "Put": "_usernamesToSidObjects",
3559                         },
3560                     },
3561                     "SeServiceLogonRight": {
3562                         "Policy": "Log on as a service",
3563                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3564                         "rights_assignment": True,
3565                         "Settings": None,
3566                         "LsaRights": {"Option": "SeServiceLogonRight"},
3567                         "Transform": {
3568                             "Get": "_sidConversion",
3569                             "Put": "_usernamesToSidObjects",
3570                         },
3571                     },
3572                     "SeSecurityPrivilege": {
3573                         "Policy": "Manage auditing and security log",
3574                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3575                         "rights_assignment": True,
3576                         "Settings": None,
3577                         "LsaRights": {"Option": "SeSecurityPrivilege"},
3578                         "Transform": {
3579                             "Get": "_sidConversion",
3580                             "Put": "_usernamesToSidObjects",
3581                         },
3582                     },
3583                     "SeRelabelPrivilege": {
3584                         "Policy": "Modify an object label",
3585                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3586                         "rights_assignment": True,
3587                         "Settings": None,
3588                         "LsaRights": {"Option": "SeRelabelPrivilege"},
3589                         "Transform": {
3590                             "Get": "_sidConversion",
3591                             "Put": "_usernamesToSidObjects",
3592                         },
3593                     },
3594                     "SeSystemEnvironmentPrivilege": {
3595                         "Policy": "Modify firmware environment values",
3596                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3597                         "rights_assignment": True,
3598                         "Settings": None,
3599                         "LsaRights": {"Option": "SeSystemEnvironmentPrivilege"},
3600                         "Transform": {
3601                             "Get": "_sidConversion",
3602                             "Put": "_usernamesToSidObjects",
3603                         },
3604                     },
3605                     "SeManageVolumePrivilege": {
3606                         "Policy": "Perform volume maintenance tasks",
3607                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3608                         "rights_assignment": True,
3609                         "Settings": None,
3610                         "LsaRights": {"Option": "SeManageVolumePrivilege"},
3611                         "Transform": {
3612                             "Get": "_sidConversion",
3613                             "Put": "_usernamesToSidObjects",
3614                         },
3615                     },
3616                     "SeProfileSingleProcessPrivilege": {
3617                         "Policy": "Profile single process",
3618                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3619                         "rights_assignment": True,
3620                         "Settings": None,
3621                         "LsaRights": {"Option": "SeProfileSingleProcessPrivilege"},
3622                         "Transform": {
3623                             "Get": "_sidConversion",
3624                             "Put": "_usernamesToSidObjects",
3625                         },
3626                     },
3627                     "SeSystemProfilePrivilege": {
3628                         "Policy": "Profile system performance",
3629                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3630                         "rights_assignment": True,
3631                         "Settings": None,
3632                         "LsaRights": {"Option": "SeSystemProfilePrivilege"},
3633                         "Transform": {
3634                             "Get": "_sidConversion",
3635                             "Put": "_usernamesToSidObjects",
3636                         },
3637                     },
3638                     "SeUndockPrivilege": {
3639                         "Policy": "Remove computer from docking station",
3640                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3641                         "rights_assignment": True,
3642                         "Settings": None,
3643                         "LsaRights": {"Option": "SeUndockPrivilege"},
3644                         "Transform": {
3645                             "Get": "_sidConversion",
3646                             "Put": "_usernamesToSidObjects",
3647                         },
3648                     },
3649                     "SeAssignPrimaryTokenPrivilege": {
3650                         "Policy": "Replace a process level token",
3651                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3652                         "rights_assignment": True,
3653                         "Settings": None,
3654                         "LsaRights": {"Option": "SeAssignPrimaryTokenPrivilege"},
3655                         "Transform": {
3656                             "Get": "_sidConversion",
3657                             "Put": "_usernamesToSidObjects",
3658                         },
3659                     },
3660                     "SeRestorePrivilege": {
3661                         "Policy": "Restore files and directories",
3662                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3663                         "rights_assignment": True,
3664                         "Settings": None,
3665                         "LsaRights": {"Option": "SeRestorePrivilege"},
3666                         "Transform": {
3667                             "Get": "_sidConversion",
3668                             "Put": "_usernamesToSidObjects",
3669                         },
3670                     },
3671                     "SeShutdownPrivilege": {
3672                         "Policy": "Shut down the system",
3673                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3674                         "rights_assignment": True,
3675                         "Settings": None,
3676                         "LsaRights": {"Option": "SeShutdownPrivilege"},
3677                         "Transform": {
3678                             "Get": "_sidConversion",
3679                             "Put": "_usernamesToSidObjects",
3680                         },
3681                     },
3682                     "SeSyncAgentPrivilege": {
3683                         "Policy": "Synchronize directory service data",
3684                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3685                         "rights_assignment": True,
3686                         "Settings": None,
3687                         "LsaRights": {"Option": "SeSyncAgentPrivilege"},
3688                         "Transform": {
3689                             "Get": "_sidConversion",
3690                             "Put": "_usernamesToSidObjects",
3691                         },
3692                     },
3693                     "SeTakeOwnershipPrivilege": {
3694                         "Policy": "Take ownership of files or other objects",
3695                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3696                         "rights_assignment": True,
3697                         "Settings": None,
3698                         "LsaRights": {"Option": "SeTakeOwnershipPrivilege"},
3699                         "Transform": {
3700                             "Get": "_sidConversion",
3701                             "Put": "_usernamesToSidObjects",
3702                         },
3703                     },
3704                     "RecoveryConsoleSecurityLevel": {
3705                         "Policy": (
3706                             "Recovery console: Allow automatic administrative logon"
3707                         ),
3708                         "Settings": self.enabled_one_disabled_zero.keys(),
3709                         "lgpo_section": self.security_options_gpedit_path,
3710                         "Registry": {
3711                             "Hive": "HKEY_LOCAL_MACHINE",
3712                             "Path": (
3713                                 "Software\\Microsoft\\Windows NT\\"
3714                                 "CurrentVersion\\Setup\\RecoveryConsole"
3715                             ),
3716                             "Value": "SecurityLevel",
3717                             "Type": "REG_DWORD",
3718                         },
3719                         "Transform": self.enabled_one_disabled_zero_transform,
3720                     },
3721                     "RecoveryConsoleSetCommand": {
3722                         "Policy": (
3723                             "Recovery console: Allow floppy copy and "
3724                             "access to all drives and all folders"
3725                         ),
3726                         "Settings": self.enabled_one_disabled_zero.keys(),
3727                         "lgpo_section": self.security_options_gpedit_path,
3728                         "Registry": {
3729                             "Hive": "HKEY_LOCAL_MACHINE",
3730                             "Path": (
3731                                 "Software\\Microsoft\\Windows NT\\"
3732                                 "CurrentVersion\\Setup\\RecoveryConsole"
3733                             ),
3734                             "Value": "SetCommand",
3735                             "Type": "REG_DWORD",
3736                         },
3737                         "Transform": self.enabled_one_disabled_zero_transform,
3738                     },
3739                     "ForceKeyProtection": {
3740                         "Policy": (
3741                             "System Cryptography: Force strong key protection for "
3742                             "user keys stored on the computer"
3743                         ),
3744                         "Settings": self.force_key_protection.keys(),
3745                         "lgpo_section": self.security_options_gpedit_path,
3746                         "Registry": {
3747                             "Hive": "HKEY_LOCAL_MACHINE",
3748                             "Path": "Software\\Policies\\Microsoft\\Cryptography",
3749                             "Value": "ForceKeyProtection",
3750                             "Type": "REG_DWORD",
3751                         },
3752                         "Transform": {
3753                             "Get": "_dict_lookup",
3754                             "Put": "_dict_lookup",
3755                             "GetArgs": {
3756                                 "lookup": self.force_key_protection,
3757                                 "value_lookup": False,
3758                             },
3759                             "PutArgs": {
3760                                 "lookup": self.force_key_protection,
3761                                 "value_lookup": True,
3762                             },
3763                         },
3764                     },
3765                     "FIPSAlgorithmPolicy": {
3766                         "Policy": (
3767                             "System Cryptography: Use FIPS compliant algorithms "
3768                             "for encryption, hashing, and signing"
3769                         ),
3770                         "Settings": self.enabled_one_disabled_zero.keys(),
3771                         "lgpo_section": self.security_options_gpedit_path,
3772                         "Registry": {
3773                             "Hive": "HKEY_LOCAL_MACHINE",
3774                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\FIPSAlgorithmPolicy",
3775                             "Value": "Enabled",
3776                             "Type": "REG_DWORD",
3777                         },
3778                         "Transform": self.enabled_one_disabled_zero_transform,
3779                     },
3780                     "MachineAccessRestriction": {
3781                         "Policy": (
3782                             "DCOM: Machine Access Restrictions in Security Descriptor "
3783                             "Definition Language (SDDL) syntax"
3784                         ),
3785                         "Settings": None,
3786                         "lgpo_section": self.security_options_gpedit_path,
3787                         "Registry": {
3788                             "Hive": "HKEY_LOCAL_MACHINE",
3789                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3790                             "Value": "MachineAccessRestriction",
3791                             "Type": "REG_SZ",
3792                         },
3793                         "Transform": {"Put": "_string_put_transform"},
3794                     },
3795                     "MachineLaunchRestriction": {
3796                         "Policy": (
3797                             "DCOM: Machine Launch Restrictions in Security Descriptor "
3798                             "Definition Language (SDDL) syntax"
3799                         ),
3800                         "Settings": None,
3801                         "lgpo_section": self.security_options_gpedit_path,
3802                         "Registry": {
3803                             "Hive": "HKEY_LOCAL_MACHINE",
3804                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3805                             "Value": "MachineLaunchRestriction",
3806                             "Type": "REG_SZ",
3807                         },
3808                         "Transform": {"Put": "_string_put_transform"},
3809                     },
3810                     "UseMachineId": {
3811                         "Policy": (
3812                             "Network security: Allow Local System to use computer "
3813                             "identity for NTLM"
3814                         ),
3815                         "Settings": self.enabled_one_disabled_zero.keys(),
3816                         "lgpo_section": self.security_options_gpedit_path,
3817                         "Registry": {
3818                             "Hive": "HKEY_LOCAL_MACHINE",
3819                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3820                             "Value": "UseMachineId",
3821                             "Type": "REG_DWORD",
3822                         },
3823                         "Transform": self.enabled_one_disabled_zero_transform,
3824                     },
3825                     "allownullsessionfallback": {
3826                         "Policy": (
3827                             "Network security: Allow LocalSystem NULL session fallback"
3828                         ),
3829                         "Settings": self.enabled_one_disabled_zero.keys(),
3830                         "lgpo_section": self.security_options_gpedit_path,
3831                         "Registry": {
3832                             "Hive": "HKEY_LOCAL_MACHINE",
3833                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3834                             "Value": "allownullsessionfallback",
3835                             "Type": "REG_DWORD",
3836                         },
3837                         "Transform": self.enabled_one_disabled_zero_transform,
3838                     },
3839                     "AllowOnlineID": {
3840                         "Policy": (
3841                             "Network security: Allow PKU2U authentication requests "
3842                             "to this computer to use online identities."
3843                         ),
3844                         "Settings": self.enabled_one_disabled_zero.keys(),
3845                         "lgpo_section": self.security_options_gpedit_path,
3846                         "Registry": {
3847                             "Hive": "HKEY_LOCAL_MACHINE",
3848                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\pku2u",
3849                             "Value": "AllowOnlineID",
3850                             "Type": "REG_DWORD",
3851                         },
3852                         "Transform": self.enabled_one_disabled_zero_transform,
3853                     },
3854                     "KrbSupportedEncryptionTypes": {
3855                         "Policy": (
3856                             "Network security: Configure encryption types allowed "
3857                             "for Kerberos"
3858                         ),
3859                         "Settings": None,
3860                         "lgpo_section": self.security_options_gpedit_path,
3861                         "Registry": {
3862                             "Hive": "HKEY_LOCAL_MACHINE",
3863                             "Path": (
3864                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies"
3865                                 "\\system\\Kerberos\\Parameters"
3866                             ),
3867                             "Value": "SupportedEncryptionTypes",
3868                             "Type": "REG_DWORD",
3869                         },
3870                         "Transform": {
3871                             "Get": "_dict_lookup_bitwise_add",
3872                             "Put": "_dict_lookup_bitwise_add",
3873                             "GetArgs": {
3874                                 "lookup": self.krb_encryption_types,
3875                                 "value_lookup": False,
3876                             },
3877                             "PutArgs": {
3878                                 "lookup": self.krb_encryption_types,
3879                                 "value_lookup": True,
3880                             },
3881                         },
3882                     },
3883                     "NoLMHash": {
3884                         "Policy": (
3885                             "Network security: Do not store LAN Manager hash value "
3886                             "on next password change"
3887                         ),
3888                         "Settings": self.enabled_one_disabled_zero.keys(),
3889                         "lgpo_section": self.security_options_gpedit_path,
3890                         "Registry": {
3891                             "Hive": "HKEY_LOCAL_MACHINE",
3892                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3893                             "Value": "NoLMHash",
3894                             "Type": "REG_DWORD",
3895                         },
3896                         "Transform": self.enabled_one_disabled_zero_transform,
3897                     },
3898                     "ForceLogoffWhenHourExpire": {
3899                         "Policy": (
3900                             "Network security: Force logoff when logon hours expire"
3901                         ),
3902                         "lgpo_section": self.security_options_gpedit_path,
3903                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
3904                         "Secedit": {
3905                             "Option": "ForceLogoffWhenHourExpire",
3906                             "Section": "System Access",
3907                         },
3908                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
3909                     },
3910                     "LmCompatibilityLevel": {
3911                         "Policy": "Network security: LAN Manager authentication level",
3912                         "Settings": self.lm_compat_levels.keys(),
3913                         "lgpo_section": self.security_options_gpedit_path,
3914                         "Registry": {
3915                             "Hive": "HKEY_LOCAL_MACHINE",
3916                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3917                             "Value": "LmCompatibilityLevel",
3918                             "Type": "REG_DWORD",
3919                         },
3920                         "Transform": {
3921                             "Get": "_dict_lookup",
3922                             "Put": "_dict_lookup",
3923                             "GetArgs": {
3924                                 "lookup": self.lm_compat_levels,
3925                                 "value_lookup": False,
3926                             },
3927                             "PutArgs": {
3928                                 "lookup": self.lm_compat_levels,
3929                                 "value_lookup": True,
3930                             },
3931                         },
3932                     },
3933                     "LDAPClientIntegrity": {
3934                         "Policy": "Network security: LDAP client signing requirements",
3935                         "Settings": self.ldap_signing_reqs.keys(),
3936                         "lgpo_section": self.security_options_gpedit_path,
3937                         "Registry": {
3938                             "Hive": "HKEY_LOCAL_MACHINE",
3939                             "Path": "SYSTEM\\CurrentControlSet\\Services\\ldap",
3940                             "Value": "LDAPClientIntegrity",
3941                             "Type": "REG_DWORD",
3942                         },
3943                         "Transform": {
3944                             "Get": "_dict_lookup",
3945                             "Put": "_dict_lookup",
3946                             "GetArgs": {
3947                                 "lookup": self.ldap_signing_reqs,
3948                                 "value_lookup": False,
3949                             },
3950                             "PutArgs": {
3951                                 "lookup": self.ldap_signing_reqs,
3952                                 "value_lookup": True,
3953                             },
3954                         },
3955                     },
3956                     "NTLMMinClientSec": {
3957                         "Policy": (
3958                             "Network security: Minimum session security for NTLM SSP"
3959                             " based (including secure RPC) clients"
3960                         ),
3961                         "Settings": None,
3962                         "lgpo_section": self.security_options_gpedit_path,
3963                         "Registry": {
3964                             "Hive": "HKEY_LOCAL_MACHINE",
3965                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3966                             "Value": "NTLMMinClientSec",
3967                             "Type": "REG_DWORD",
3968                         },
3969                         "Transform": {
3970                             "Get": "_dict_lookup_bitwise_add",
3971                             "Put": "_dict_lookup_bitwise_add",
3972                             "GetArgs": {
3973                                 "lookup": self.ntlm_session_security_levels,
3974                                 "value_lookup": False,
3975                             },
3976                             "PutArgs": {
3977                                 "lookup": self.ntlm_session_security_levels,
3978                                 "value_lookup": True,
3979                             },
3980                         },
3981                     },
3982                     "NTLMMinServerSec": {
3983                         "Policy": (
3984                             "Network security: Minimum session security for NTLM SSP"
3985                             " based (including secure RPC) servers"
3986                         ),
3987                         "Settings": None,
3988                         "lgpo_section": self.security_options_gpedit_path,
3989                         "Registry": {
3990                             "Hive": "HKEY_LOCAL_MACHINE",
3991                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3992                             "Value": "NTLMMinServerSec",
3993                             "Type": "REG_DWORD",
3994                         },
3995                         "Transform": {
3996                             "Get": "_dict_lookup_bitwise_add",
3997                             "Put": "_dict_lookup_bitwise_add",
3998                             "GetArgs": {
3999                                 "lookup": self.ntlm_session_security_levels,
4000                                 "value_lookup": False,
4001                             },
4002                             "PutArgs": {
4003                                 "lookup": self.ntlm_session_security_levels,
4004                                 "value_lookup": True,
4005                             },
4006                         },
4007                     },
4008                     "ClientAllowedNTLMServers": {
4009                         "Policy": (
4010                             "Network security: Restrict NTLM: Add remote server"
4011                             " exceptions for NTLM authentication"
4012                         ),
4013                         "lgpo_section": self.security_options_gpedit_path,
4014                         "Registry": {
4015                             "Hive": "HKEY_LOCAL_MACHINE",
4016                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
4017                             "Value": "ClientAllowedNTLMServers",
4018                             "Type": "REG_MULTI_SZ",
4019                         },
4020                         "Transform": {
4021                             "Put": "_multi_string_put_transform",
4022                             "Get": "_multi_string_get_transform",
4023                         },
4024                     },
4025                     "DCAllowedNTLMServers": {
4026                         "Policy": (
4027                             "Network security: Restrict NTLM: Add server exceptions"
4028                             " in this domain"
4029                         ),
4030                         "lgpo_section": self.security_options_gpedit_path,
4031                         "Registry": {
4032                             "Hive": "HKEY_LOCAL_MACHINE",
4033                             "Path": "System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4034                             "Value": "DCAllowedNTLMServers",
4035                             "Type": "REG_MULTI_SZ",
4036                         },
4037                         "Transform": {
4038                             "Put": "_multi_string_put_transform",
4039                             "Get": "_multi_string_get_transform",
4040                         },
4041                     },
4042                     "AuditReceivingNTLMTraffic": {
4043                         "Policy": (
4044                             "Network security: Restrict NTLM: Audit Incoming NTLM"
4045                             " Traffic"
4046                         ),
4047                         "Settings": self.ntlm_audit_settings.keys(),
4048                         "lgpo_section": self.security_options_gpedit_path,
4049                         "Registry": {
4050                             "Hive": "HKEY_LOCAL_MACHINE",
4051                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
4052                             "Value": "AuditReceivingNTLMTraffic",
4053                             "Type": "REG_DWORD",
4054                         },
4055                         "Transform": {
4056                             "Get": "_dict_lookup",
4057                             "Put": "_dict_lookup",
4058                             "GetArgs": {
4059                                 "lookup": self.ntlm_audit_settings,
4060                                 "value_lookup": False,
4061                             },
4062                             "PutArgs": {
4063                                 "lookup": self.ntlm_audit_settings,
4064                                 "value_lookup": True,
4065                             },
4066                         },
4067                     },
4068                     "AuditNTLMInDomain": {
4069                         "Policy": (
4070                             "Network security: Restrict NTLM: Audit NTLM "
4071                             "authentication in this domain"
4072                         ),
4073                         "Settings": self.ntlm_domain_audit_settings.keys(),
4074                         "lgpo_section": self.security_options_gpedit_path,
4075                         "Registry": {
4076                             "Hive": "HKEY_LOCAL_MACHINE",
4077                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4078                             "Value": "AuditNTLMInDomain",
4079                             "Type": "REG_DWORD",
4080                         },
4081                         "Transform": {
4082                             "Get": "_dict_lookup",
4083                             "Put": "_dict_lookup",
4084                             "GetArgs": {
4085                                 "lookup": self.ntlm_domain_audit_settings,
4086                                 "value_lookup": False,
4087                             },
4088                             "PutArgs": {
4089                                 "lookup": self.ntlm_domain_audit_settings,
4090                                 "value_lookup": True,
4091                             },
4092                         },
4093                     },
4094                     "RestrictReceivingNTLMTraffic": {
4095                         "Policy": (
4096                             "Network security: Restrict NTLM: Incoming NTLM traffic"
4097                         ),
4098                         "Settings": self.incoming_ntlm_settings.keys(),
4099                         "lgpo_section": self.security_options_gpedit_path,
4100                         "Registry": {
4101                             "Hive": "HKEY_LOCAL_MACHINE",
4102                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
4103                             "Value": "RestrictReceivingNTLMTraffic",
4104                             "Type": "REG_DWORD",
4105                         },
4106                         "Transform": {
4107                             "Get": "_dict_lookup",
4108                             "Put": "_dict_lookup",
4109                             "GetArgs": {
4110                                 "lookup": self.incoming_ntlm_settings,
4111                                 "value_lookup": False,
4112                             },
4113                             "PutArgs": {
4114                                 "lookup": self.incoming_ntlm_settings,
4115                                 "value_lookup": True,
4116                             },
4117                         },
4118                     },
4119                     "RestrictNTLMInDomain": {
4120                         "Policy": (
4121                             "Network security: Restrict NTLM: NTLM "
4122                             "authentication in this domain"
4123                         ),
4124                         "Settings": self.ntlm_domain_auth_settings.keys(),
4125                         "lgpo_section": self.security_options_gpedit_path,
4126                         "Registry": {
4127                             "Hive": "HKEY_LOCAL_MACHINE",
4128                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4129                             "Value": "RestrictNTLMInDomain",
4130                             "Type": "REG_DWORD",
4131                         },
4132                         "Transform": {
4133                             "Get": "_dict_lookup",
4134                             "Put": "_dict_lookup",
4135                             "GetArgs": {
4136                                 "lookup": self.ntlm_domain_auth_settings,
4137                                 "value_lookup": False,
4138                             },
4139                             "PutArgs": {
4140                                 "lookup": self.ntlm_domain_auth_settings,
4141                                 "value_lookup": True,
4142                             },
4143                         },
4144                     },
4145                     "RestrictSendingNTLMTraffic": {
4146                         "Policy": (
4147                             "Network security: Restrict NTLM: Outgoing NTLM"
4148                             " traffic to remote servers"
4149                         ),
4150                         "Settings": self.outgoing_ntlm_settings.keys(),
4151                         "lgpo_section": self.security_options_gpedit_path,
4152                         "Registry": {
4153                             "Hive": "HKEY_LOCAL_MACHINE",
4154                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
4155                             "Value": "RestrictSendingNTLMTraffic",
4156                             "Type": "REG_DWORD",
4157                         },
4158                         "Transform": {
4159                             "Get": "_dict_lookup",
4160                             "Put": "_dict_lookup",
4161                             "GetArgs": {
4162                                 "lookup": self.outgoing_ntlm_settings,
4163                                 "value_lookup": False,
4164                             },
4165                             "PutArgs": {
4166                                 "lookup": self.outgoing_ntlm_settings,
4167                                 "value_lookup": True,
4168                             },
4169                         },
4170                     },
4171                     "ShutdownWithoutLogon": {
4172                         "Policy": (
4173                             "Shutdown: Allow system to be shut down "
4174                             "without having to log on"
4175                         ),
4176                         "Settings": self.enabled_one_disabled_zero.keys(),
4177                         "lgpo_section": self.security_options_gpedit_path,
4178                         "Registry": {
4179                             "Hive": "HKEY_LOCAL_MACHINE",
4180                             "Path": "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
4181                             "Value": "ShutdownWithoutLogon",
4182                             "Type": "REG_DWORD",
4183                         },
4184                         "Transform": self.enabled_one_disabled_zero_transform,
4185                     },
4186                     "ClearPageFileAtShutdown": {
4187                         "Policy": "Shutdown: Clear virtual memory pagefile",
4188                         "Settings": self.enabled_one_disabled_zero.keys(),
4189                         "lgpo_section": self.security_options_gpedit_path,
4190                         "Registry": {
4191                             "Hive": "HKEY_LOCAL_MACHINE",
4192                             "Path": (
4193                                 "System\\CurrentControlSet\\Control\\"
4194                                 "SESSION MANAGER\\MEMORY MANAGEMENT"
4195                             ),
4196                             "Value": "ClearPageFileAtShutdown",
4197                             "Type": "REG_DWORD",
4198                         },
4199                         "Transform": self.enabled_one_disabled_zero_transform,
4200                     },
4201                     "ObCaseInsensitive": {
4202                         "Policy": (
4203                             "System objects: Require case insensitivity for "
4204                             "non-Windows subsystems"
4205                         ),
4206                         "Settings": self.enabled_one_disabled_zero.keys(),
4207                         "lgpo_section": self.security_options_gpedit_path,
4208                         "Registry": {
4209                             "Hive": "HKEY_LOCAL_MACHINE",
4210                             "Path": (
4211                                 "System\\CurrentControlSet\\Control\\"
4212                                 "SESSION MANAGER\\Kernel"
4213                             ),
4214                             "Value": "ObCaseInsensitive",
4215                             "Type": "REG_DWORD",
4216                         },
4217                         "Transform": self.enabled_one_disabled_zero_transform,
4218                     },
4219                     "ProtectionMode": {
4220                         "Policy": (
4221                             "System objects: Strengthen default permissions of "
4222                             "internal system objects (e.g. Symbolic Links)"
4223                         ),
4224                         "Settings": self.enabled_one_disabled_zero.keys(),
4225                         "lgpo_section": self.security_options_gpedit_path,
4226                         "Registry": {
4227                             "Hive": "HKEY_LOCAL_MACHINE",
4228                             "Path": (
4229                                 "System\\CurrentControlSet\\Control\\SESSION MANAGER"
4230                             ),
4231                             "Value": "ProtectionMode",
4232                             "Type": "REG_DWORD",
4233                         },
4234                         "Transform": self.enabled_one_disabled_zero_transform,
4235                     },
4236                     "OptionalSubsystems": {
4237                         "Policy": "System settings: Optional subsystems",
4238                         "lgpo_section": self.security_options_gpedit_path,
4239                         "Registry": {
4240                             "Hive": "HKEY_LOCAL_MACHINE",
4241                             "Path": (
4242                                 "System\\CurrentControlSet\\Control\\"
4243                                 "SESSION MANAGER\\SubSystems"
4244                             ),
4245                             "Value": "optional",
4246                             "Type": "REG_MULTI_SZ",
4247                         },
4248                         "Transform": {
4249                             "Put": "_multi_string_put_transform",
4250                             "Get": "_multi_string_get_transform",
4251                         },
4252                     },
4253                     "AuthenticodeEnabled": {
4254                         "Policy": (
4255                             "System settings: Use Certificate Rules on Windows"
4256                             " Executables for Software Restriction Policies"
4257                         ),
4258                         "Settings": self.enabled_one_disabled_zero.keys(),
4259                         "lgpo_section": self.security_options_gpedit_path,
4260                         "Registry": {
4261                             "Hive": "HKEY_LOCAL_MACHINE",
4262                             "Path": "SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers",
4263                             "Value": "AuthenticodeEnabled",
4264                             "Type": "REG_DWORD",
4265                         },
4266                         "Transform": self.enabled_one_disabled_zero_transform,
4267                     },
4268                 },
4269             },
4270             "User": {"lgpo_section": "User Configuration", "policies": {}},
4271         }
4272         self.admx_registry_classes = {
4273             "User": {
4274                 "policy_path": os.path.join(
4275                     os.getenv("WINDIR"),
4276                     "System32",
4277                     "GroupPolicy",
4278                     "User",
4279                     "Registry.pol",
4280                 ),
4281                 "hive": "HKEY_USERS",
4282                 "lgpo_section": "User Configuration",
4283                 "gpt_extension_location": "gPCUserExtensionNames",
4284                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F73-3407-48AE-BA88-E8213C6761F1}]",
4285             },
4286             "Machine": {
4287                 "policy_path": os.path.join(
4288                     os.getenv("WINDIR"),
4289                     "System32",
4290                     "GroupPolicy",
4291                     "Machine",
4292                     "Registry.pol",
4293                 ),
4294                 "hive": "HKEY_LOCAL_MACHINE",
4295                 "lgpo_section": "Computer Configuration",
4296                 "gpt_extension_location": "gPCMachineExtensionNames",
4297                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F72-3407-48AE-BA88-E8213C6761F1}]",
4298             },
4299         }
4300         self.reg_pol_header = "\u5250\u6765\x01\x00"
4301         self.gpt_ini_path = os.path.join(
4302             os.getenv("WINDIR"), "System32", "GroupPolicy", "gpt.ini"
4303         )
4304     @classmethod
4305     def _notEmpty(cls, val, **kwargs):
4306         """
4307         ensures a value is not empty
4308         """
4309         if val:
4310             return True
4311         else:
4312             return False
4313     @classmethod
4314     def _seconds_to_days(cls, val, **kwargs):
4315         """
4316         converts a number of seconds to days
4317         """
4318         zero_value = kwargs.get("zero_value", 0)
4319         if val is not None:
4320             if val == zero_value:
4321                 return 0
4322             return val / 86400
4323         else:
4324             return "Not Defined"
4325     @classmethod
4326     def _days_to_seconds(cls, val, **kwargs):
4327         """
4328         converts a number of days to seconds
4329         """
4330         zero_value = kwargs.get("zero_value", 0)
4331         if val is not None:
4332             if val == 0:
4333                 return zero_value
4334             return val * 86400
4335         else:
4336             return "Not Defined"
4337     @classmethod
4338     def _seconds_to_minutes(cls, val, **kwargs):
4339         """
4340         converts a number of seconds to minutes
4341         """
4342         zero_value = kwargs.get("zero_value", 0)
4343         if val is not None:
4344             if val == zero_value:
4345                 return 0
4346             return val / 60
4347         else:
4348             return "Not Defined"
4349     @classmethod
4350     def _minutes_to_seconds(cls, val, **kwargs):
4351         """
4352         converts number of minutes to seconds
4353         """
4354         zero_value = kwargs.get("zero_value", 0)
4355         if val is not None:
4356             if val == 0:
4357                 return zero_value
4358             return val * 60
4359         else:
4360             return "Not Defined"
4361     @classmethod
4362     def _strip_quotes(cls, val, **kwargs):
4363         """
4364         strips quotes from a string
4365         """
4366         return val.replace('"', "")
4367     @classmethod
4368     def _add_quotes(cls, val, **kwargs):
4369         """
4370         add quotes around the string
4371         """
4372         return '"{}"'.format(val)
4373     @classmethod
4374     def _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):
4375         """
4376         converts a binary 0/1 to Disabled/Enabled
4377         """
4378         try:
4379             if val is not None:
4380                 if ord(val) == 0:
4381                     return "Disabled"
4382                 elif ord(val) == 1:
4383                     return "Enabled"
4384                 else:
4385                     return "Invalid Value: {!r}".format(val)
4386             else:
4387                 return "Not Defined"
4388         except TypeError:
4389             return "Invalid Value"
4390     @classmethod
4391     def _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):
4392         """
4393         converts Enabled/Disabled to unicode char to write to a REG_BINARY value
4394         """
4395         if val is not None:
4396             if val.upper() == "DISABLED":
4397                 return chr(0)
4398             elif val.upper() == "ENABLED":
4399                 return chr(1)
4400             else:
4401                 return None
4402         else:
4403             return None
4404     @classmethod
4405     def _dasd_conversion(cls, val, **kwargs):
4406         """
4407         converts 0/1/2 for dasd reg key
4408         """
4409         if val is not None:
4410             if val == "0" or val == 0 or val == "":
4411                 return "Administrators"
4412             elif val == "1" or val == 1:
4413                 return "Administrators and Power Users"
4414             elif val == "2" or val == 2:
4415                 return "Administrators and Interactive Users"
4416             else:
4417                 return "Not Defined"
4418         else:
4419             return "Not Defined"
4420     @classmethod
4421     def _dasd_reverse_conversion(cls, val, **kwargs):
4422         """
4423         converts DASD String values to the reg_sz value
4424         """
4425         if val is not None:
4426             if val.upper() == "ADMINISTRATORS":
4427                 return "0"
4428             elif val.upper() == "ADMINISTRATORS AND POWER USERS":
4429                 return "1"
4430             elif val.upper() == "ADMINISTRATORS AND INTERACTIVE USERS":
4431                 return "2"
4432             elif val.upper() == "NOT DEFINED":
4433                 return "9999"
4434             else:
4435                 return "Invalid Value"
4436         else:
4437             return "Not Defined"
4438     @classmethod
4439     def _in_range_inclusive(cls, val, **kwargs):
4440         """
4441         checks that a value is in an inclusive range
4442         The value for 0 used by Max Password Age is actually 0xffffffff
4443         """
4444         minimum = kwargs.get("min", 0)
4445         maximum = kwargs.get("max", 1)
4446         zero_value = kwargs.get("zero_value", 0)
4447         if isinstance(val, str):
4448             if val.lower() == "not defined":
4449                 return True
4450             else:
4451                 try:
4452                     val = int(val)
4453                 except ValueError:
4454                     return False
4455         if val is not None:
4456             if minimum &lt;= val &lt;= maximum or val == zero_value:
4457                 return True
4458             else:
4459                 return False
4460         else:
4461             return False
4462     @classmethod
4463     def _driver_signing_reg_conversion(cls, val, **kwargs):
4464         """
4465         converts the binary value in the registry for driver signing into the
4466         correct string representation
4467         """
4468         log.trace("we have %s for the driver signing value", val)
4469         if val is not None:
4470             _val = val.split(",")
4471             if len(_val) == 2:
4472                 if _val[1] == "0":
4473                     return "Silently Succeed"
4474                 elif _val[1] == "1":
4475                     return "Warn but allow installation"
4476                 elif _val[1] == "2":
4477                     return "Do not allow installation"
4478                 elif _val[1] == "Not Defined":
4479                     return "Not Defined"
4480                 else:
4481                     return "Invalid Value"
4482             else:
4483                 return "Not Defined"
4484         else:
4485             return "Not Defined"
4486     @classmethod
4487     def _driver_signing_reg_reverse_conversion(cls, val, **kwargs):
4488         """
4489         converts the string value seen in the GUI to the correct registry value
4490         for secedit
4491         """
4492         if val is not None:
4493             if val.upper() == "SILENTLY SUCCEED":
4494                 return ",".join(["3", "0"])
4495             elif val.upper() == "WARN BUT ALLOW INSTALLATION":
4496                 return ",".join(["3", chr(1)])
4497             elif val.upper() == "DO NOT ALLOW INSTALLATION":
4498                 return ",".join(["3", chr(2)])
4499             else:
4500                 return "Invalid Value"
4501         else:
4502             return "Not Defined"
4503     @classmethod
4504     def _sidConversion(cls, val, **kwargs):
4505         """
4506         converts a list of pysid objects to string representations
4507         """
4508         if isinstance(val, str):
4509             val = val.split(",")
4510         usernames = []
4511         for _sid in val:
4512             try:
4513                 userSid = win32security.LookupAccountSid("", _sid)
4514                 if userSid[1]:
4515                     userSid = "{1}\\{0}".format(userSid[0], userSid[1])
4516                 else:
4517                     userSid = "{}".format(userSid[0])
4518             except Exception:  # pylint: disable=broad-except
4519                 userSid = win32security.ConvertSidToStringSid(_sid)
4520                 log.warning(
4521                     "Unable to convert SID '%s' to a friendly name. "
4522                     "The SID will be displayed instead of a user/group name.",
4523                     userSid,
4524                 )
4525             usernames.append(userSid)
4526         return usernames
4527     @classmethod
4528     def _usernamesToSidObjects(cls, val, **kwargs):
4529         """
4530         converts a list of usernames to sid objects
4531         """
4532         if not val:
4533             return val
4534         if isinstance(val, str):
4535             val = val.split(",")
4536         sids = []
4537         for _user in val:
4538             try:
4539                 sid = win32security.LookupAccountName("", _user)[0]
4540                 sids.append(sid)
4541             except Exception as e:  # pylint: disable=broad-except
4542                 log.exception("Handle this explicitly")
4543                 raise CommandExecutionError(
4544                     'There was an error obtaining the SID of user "{}". Error '
4545                     "returned: {}".format(_user, e)
4546                 )
4547         return sids
4548     @classmethod
4549     def _powershell_script_order_conversion(cls, val, **kwargs):
4550         """
4551         converts true/false/None to the GUI representation of the powershell
4552         startup/shutdown script order
4553         """
4554         log.trace("script order value = %s", val)
4555         if val is None or val == "None":
4556             return "Not Configured"
4557         elif val == "true":
4558             return "Run Windows PowerShell scripts first"
4559         elif val == "false":
4560             return "Run Windows PowerShell scripts last"
4561         else:
4562             return "Invalid Value"
4563     @classmethod
4564     def _powershell_script_order_reverse_conversion(cls, val, **kwargs):
4565         """
4566         converts powershell script GUI strings representations to
4567         True/False/None
4568         """
4569         if val.upper() == "Run Windows PowerShell scripts first".upper():
4570             return "true"
4571         elif val.upper() == "Run Windows PowerShell scripts last".upper():
4572             return "false"
4573         elif val == "Not Configured":
4574             return None
4575         else:
4576             return "Invalid Value"
4577     @classmethod
4578     def _dict_lookup(cls, item, **kwargs):
4579         """
4580         Retrieves the key or value from a dict based on the item
4581         kwarg lookup dict to search for item
4582         kwarg value_lookup bool to determine if item should be compared to keys
4583         or values
4584         """
4585         log.trace("item == %s", item)
4586         value_lookup = kwargs.get("value_lookup", False)
4587         if "lookup" in kwargs:
4588             for k, v in kwargs["lookup"].items():
4589                 if value_lookup:
4590                     if str(v).lower() == str(item).lower():
4591                         log.trace("returning key %s", k)
4592                         return k
4593                 else:
4594                     if str(k).lower() == str(item).lower():
4595                         log.trace("returning value %s", v)
4596                         return v
4597         return "Invalid Value"
4598     @classmethod
4599     def _dict_lookup_bitwise_add(cls, item, **kwargs):
4600         """
4601         kwarg value_lookup bool to determine if item_list should be compared to keys
4602         or values
4603         kwarg test_zero is used to determine if 0 should be tested when value_lookup is false
4604         lookup should be a dict with integers for keys
4605         if value_lookup is True, item is expected to be a list
4606             the function will return the sum of the keys whose values are in the item list
4607         if value_lookup is False, item is expected to be an integer
4608             the function will return the values for the keys
4609             which successfully "bitwise and" with item
4610         """
4611         value_lookup = kwargs.get("value_lookup", False)
4612         test_zero = kwargs.get("test_zero", False)
4613         ret_val = None
4614         if str(item).lower() == "not defined":
4615             return None
4616         if value_lookup:
4617             if not isinstance(item, list):
4618                 return "Invalid Value"
4619             ret_val = 0
4620         else:
4621             if not isinstance(item, int):
4622                 return "Invalid Value"
4623             ret_val = []
4624         if "lookup" in kwargs:
4625             for k, v in kwargs["lookup"].items():
4626                 if value_lookup:
4627                     if str(v).lower() in [z.lower() for z in item]:
4628                         ret_val = ret_val + k
4629                 else:
4630                     do_test = True
4631                     if not test_zero:
4632                         if k == 0:
4633                             do_test = False
4634                     if do_test and isinstance(k, int) and item &amp; k == k:
4635                         ret_val.append(v)
4636         else:
4637             return "Invalid Value"
4638         return ret_val
4639     @classmethod
4640     def _multi_string_put_transform(cls, item, **kwargs):
4641         """
4642         transform for setting REG_MULTI_SZ to properly handle "Not Defined"
4643         """
4644         if isinstance(item, list):
4645             return item
4646         elif isinstance(item, str):
4647             if item.lower() == "not defined":
4648                 return None
4649             else:
4650                 return item.split(",")
4651         else:
4652             return "Invalid Value"
4653     @classmethod
4654     def _multi_string_get_transform(cls, item, **kwargs):
4655         """
4656         transform for getting REG_MULTI_SZ to properly handle `None`
4657         """
4658         if isinstance(item, list):
4659             return item
4660         elif item is None:
4661             return "Not Defined"
4662         else:
4663             return "Invalid Value"
4664     @classmethod
4665     def _string_put_transform(cls, item, **kwargs):
4666         """
4667         transform for a REG_SZ to properly handle "Not Defined"
4668         """
4669         if isinstance(item, str):
4670             if item.lower() == "not defined":
4671                 return None
4672             else:
4673                 return item
4674 def __virtual__():
4675     """
4676     Only works on Windows systems
4677     """
4678     if not salt.utils.platform.is_windows():
4679         return False, "win_lgpo: Not a Windows System"
4680     if not HAS_WINDOWS_MODULES:
4681         return False, "win_lgpo: Required modules failed to load"
4682     return __virtualname__
4683 def _updateNamespace(item, new_namespace):
4684     """
4685     helper function to recursively update the namespaces of an item
4686     """
4687     temp_item = ""
4688     i = item.tag.find("}")
4689     if i &gt;= 0:
4690         temp_item = item.tag[i + 1 :]
4691     else:
4692         temp_item = item.tag
4693     item.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4694     for child in item.getiterator():
4695         if isinstance(child.tag, str):
4696             temp_item = ""
4697             i = child.tag.find("}")
4698             if i &gt;= 0:
4699                 temp_item = child.tag[i + 1 :]
4700             else:
4701                 temp_item = child.tag
4702             child.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4703     return item
4704 def _updatePolicyElements(policy_item, regkey):
4705     """
4706     helper function to add the reg key to each policies element definitions if
4707     the key attribute is not defined to make xpath searching easier for each
4708     child in the policy &lt;elements&gt; item
4709     """
4710     for child in policy_item.getiterator():
4711         if "valueName" in child.attrib:
4712             if "key" not in child.attrib:
4713                 child.attrib["key"] = regkey
4714     return policy_item
4715 def _remove_unicode_encoding(xml_file):
4716     """
4717     attempts to remove the "encoding='unicode'" from an xml file
4718     as lxml does not support that on a windows node currently
4719     see issue #38100 (Search.adml)
4720     For some reason this file is encoded 'utf-16'
4721     """
4722     with salt.utils.files.fopen(xml_file, "rb") as f:
4723         xml_content = f.read()
4724     modified_xml = re.sub(
4725         r' encoding=[\'"]+unicode[\'"]+', "", xml_content.decode("utf-16"), count=1
4726     )
4727     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4728     return xml_tree
4729 def _remove_invalid_xmlns(xml_file):
4730     """
4731     Attempts to remove an invalid xmlns entry in newer versions of
4732     WindowsDefender.adml
4733     xmlns="http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions"
4734     For some reason this file is encoded 'utf-8'
4735     """
4736     with salt.utils.files.fopen(xml_file, "rb") as f:
4737         xml_content = f.read()
4738     modified_xml = re.sub(
4739         r' xmlns=[\'"]+.*[\'"]+', "", xml_content.decode("utf-8"), count=1
4740     )
4741     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4742     return xml_tree
4743 def _parse_xml(adm_file):
4744     """
4745     Parse the admx/adml file. There are 3 scenarios (so far) that we'll likely
4746     encounter:
4747     1. Valid File
4748     2. invalid encoding (encoding="unicode") which the lxml library doesn't
4749        recognize
4750     3. invalid xmlns entry in the xml header, which the lxml library doesn't
4751        recognize
4752     """
4753     parser = lxml.etree.XMLParser(remove_comments=True)
4754     modified_xml = ""
4755     with salt.utils.files.fopen(adm_file, "rb") as rfh:
4756         file_hash = "{:X}".format(zlib.crc32(rfh.read()) &amp; 0xFFFFFFFF)
4757     name, ext = os.path.splitext(os.path.basename(adm_file))
4758     hashed_filename = "{}-{}{}".format(name, file_hash, ext)
4759     cache_dir = os.path.join(__opts__["cachedir"], "lgpo", "policy_defs")
4760     if not os.path.exists(cache_dir):
4761         os.makedirs(cache_dir)
4762     out_file = os.path.join(cache_dir, hashed_filename)
4763     if not os.path.isfile(out_file):
4764         log.debug("LGPO: Generating policy template cache for %s%s", name, ext)
4765         file_list = glob.glob(os.path.join(cache_dir, "{}*{}".format(name, ext)))
4766         for file_path in file_list:
4767             os.remove(file_path)
4768         with salt.utils.files.fopen(adm_file, "rb") as rfh:
4769             encoding = "utf-8"
4770             raw = rfh.read()
4771             try:
4772                 raw = raw.decode(encoding)
4773             except UnicodeDecodeError:
4774                 log.trace("LGPO: Detecting encoding")
4775                 encoding = "utf-16"
4776                 raw = raw.decode(encoding)
4777             for line in raw.split("\r\n"):
4778                 if 'key="' in line:
4779                     start = line.index('key="')
4780                     q1 = line[start:].index('"') + start
4781                     q2 = line[q1 + 1 :].index('"') + q1 + 1
4782                     line = line.replace(line[start:q2], line[start:q2].lower())
4783                     found_key = True
4784                 modified_xml += line + "\r\n"
4785         modified_xml = modified_xml.replace("\u201c", '"').replace("\u201d", '"')
4786         modified_xml = modified_xml.replace("\u2018", "'").replace("\u2019", "'")
4787         modified_xml = modified_xml.replace("\u2013", "-").replace("\u2014", "-")
4788         with salt.utils.files.fopen(out_file, "wb") as wfh:
4789             wfh.write(modified_xml.encode(encoding))
4790     try:
4791         xml_tree = lxml.etree.parse(out_file, parser=parser)
4792     except lxml.etree.XMLSyntaxError:
4793         try:
4794             xml_tree = _remove_unicode_encoding(out_file)
4795         except lxml.etree.XMLSyntaxError:
4796             xml_tree = _remove_invalid_xmlns(out_file)
4797     return xml_tree
4798 def _load_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4799     """
4800     helper function to process all ADMX files in the specified policy_def_path
4801     and build a single XML doc that we can search/use for ADMX policy processing
4802     """
4803     display_language_fallback = INSTALL_LANGUAGE
4804     t_policy_definitions = lxml.etree.Element("policyDefinitions")
4805     t_policy_definitions<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(lxml.etree.Element("categories"))
4806     t_policy_definitions.append(lxml.etree.Element("policies"))
4807     t_policy_definitions.append(lxml.</b></font>etree.Element("policyNamespaces"))
4808     t_policy_definition_resources = lxml.etree.Element("policyDefinitionResources")
4809     policydefs_policies_xpath = etree.XPath("/policyDefinitions/policies")
4810     policydefs_categories_xpath = etree.XPath("/policyDefinitions/categories")
4811     policydefs_policyns_xpath = etree.XPath("/policyDefinitions/policyNamespaces")
4812     policydefs_resources_localname_xpath = etree.XPath(
4813         '//*[local-name() = "policyDefinitionResources"]/*'
4814     )
4815     policydef_resources_xpath = etree.XPath("/policyDefinitionResources")
4816     for root, dirs, files in salt.utils.path.os_walk(path):
4817         if root == path:
4818             for t_admx_file in files:
4819                 admx_file_name, admx_file_ext = os.path.splitext(t_admx_file)
4820                 if not admx_file_ext == ".admx":
4821                     log.debug("%s is not an ADMX file", t_admx_file)
4822                     continue
4823                 admx_file = os.path.join(root, t_admx_file)
4824                 try:
4825                     xml_tree = _parse_xml(admx_file)
4826                 except lxml.etree.XMLSyntaxError:
4827                     log.error(
4828                         "An error was found while processing admx "
4829                         "file %s, all policies from this file will "
4830                         "be unavailable via this module",
4831                         admx_file,
4832                     )
4833                     continue
4834                 namespaces = xml_tree.getroot().nsmap
4835                 namespace_string = ""
4836                 if None in namespaces:
4837                     namespaces["None"] = namespaces[None]
4838                     namespaces.pop(None)
4839                     namespace_string = "None:"
4840                 this_namespace = xml_tree.xpath(
4841                     "/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace".format(
4842                         namespace_string
4843                     ),
4844                     namespaces=namespaces,
4845                 )[0]
4846                 categories = xml_tree.xpath(
4847                     "/{0}policyDefinitions/{0}categories/{0}category".format(
4848                         namespace_string
4849                     ),
4850                     namespaces=namespaces,
4851                 )
4852                 for category in categories:
4853                     temp_cat = category
4854                     temp_cat = _updateNamespace(temp_cat, this_namespace)
4855                     policydefs_categories_xpath(t_policy_definitions)[0].append(
4856                         temp_cat
4857                     )
4858                 policies = xml_tree.xpath(
4859                     "/{0}policyDefinitions/{0}policies/{0}policy".format(
4860                         namespace_string
4861                     ),
4862                     namespaces=namespaces,
4863                 )
4864                 for policy in policies:
4865                     temp_pol = policy
4866                     temp_pol = _updateNamespace(temp_pol, this_namespace)
4867                     if "key" in temp_pol.attrib:
4868                         temp_pol = _updatePolicyElements(
4869                             temp_pol, temp_pol.attrib["key"]
4870                         )
4871                     policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)
4872                 policy_namespaces = xml_tree.xpath(
4873                     "/{0}policyDefinitions/{0}policyNamespaces/{0}*".format(
4874                         namespace_string
4875                     ),
4876                     namespaces=namespaces,
4877                 )
4878                 for policy_ns in policy_namespaces:
4879                     temp_ns = policy_ns
4880                     temp_ns = _updateNamespace(temp_ns, this_namespace)
4881                     policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)
4882                 adml_file = os.path.join(root, language, admx_file_name + ".adml")
4883                 if not __salt__["file.file_exists"](adml_file):
4884                     log.info(
4885                         "An ADML file in the specified ADML language "
4886                         '"%s" does not exist for the ADMX "%s", the '
4887                         "the abbreviated language code will be tried.",
4888                         language,
4889                         t_admx_file,
4890                     )
4891                     adml_file = os.path.join(
4892                         root, language.split("-")[0], admx_file_name + ".adml"
4893                     )
4894                     if not __salt__["file.file_exists"](adml_file):
4895                         log.info(
4896                             "An ADML file in the specified ADML language "
4897                             'code %s does not exist for the ADMX "%s", '
4898                             "the fallback language will be tried.",
4899                             language[:2],
4900                             t_admx_file,
4901                         )
4902                         adml_file = os.path.join(
4903                             root, display_language_fallback, admx_file_name + ".adml"
4904                         )
4905                         if not __salt__["file.file_exists"](adml_file):
4906                             log.info(
4907                                 "An ADML file in the specified ADML "
4908                                 'fallback language "%s" '
4909                                 'does not exist for the ADMX "%s" '
4910                                 "the abbreviated fallback language code "
4911                                 "will be tried.",
4912                                 display_language_fallback,
4913                                 t_admx_file,
4914                             )
4915                             adml_file = os.path.join(
4916                                 root,
4917                                 display_language_fallback.split("-")[0],
4918                                 admx_file_name + ".adml",
4919                             )
4920                             if not __salt__["file.file_exists"](adml_file):
4921                                 raise SaltInvocationError(
4922                                     "An ADML file in the specified ADML language "
4923                                     '"{}" and the fallback language "{}" do not '
4924                                     'exist for the ADMX "{}".'.format(
4925                                         language, display_language_fallback, t_admx_file
4926                                     )
4927                                 )
4928                 try:
4929                     xml_tree = _parse_xml(adml_file)
4930                 except lxml.etree.XMLSyntaxError:
4931                     log.error(
4932                         "An error was found while processing adml "
4933                         "file %s, all policies from this file will "
4934                         "be unavailable via this module",
4935                         adml_file,
4936                     )
4937                     continue
4938                 if None in namespaces:
4939                     namespaces["None"] = namespaces[None]
4940                     namespaces.pop(None)
4941                 policydefs_resources = policydefs_resources_localname_xpath(xml_tree)
4942                 for policydefs_resource in policydefs_resources:
4943                     t_poldef = policydefs_resource
4944                     t_poldef = _updateNamespace(t_poldef, this_namespace)
4945                     policydef_resources_xpath(t_policy_definition_resources)[0].append(
4946                         t_poldef
4947                     )
4948     __context__["lgpo.policy_definitions"] = t_policy_definitions
4949     __context__["lgpo.policy_resources"] = t_policy_definition_resources
4950 def _get_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4951     if "lgpo.policy_definitions" not in __context__:
4952         log.debug("LGPO: Loading policy definitions")
4953         _load_policy_definitions(path=path, language=language)
4954     return __context__["lgpo.policy_definitions"]
4955 def _get_policy_resources(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4956     if "lgpo.policy_resources" not in __context__:
4957         log.debug("LGPO: Loading policy resources")
4958         _load_policy_definitions(path=path, language=language)
4959     return __context__["lgpo.policy_resources"]
4960 def _buildElementNsmap(using_elements):
4961     """
4962     build a namespace map for an ADMX element
4963     """
4964     thisMap = {}
4965     for e in using_elements:
4966         thisMap[e.attrib["prefix"]] = e.attrib["namespace"]
4967     return thisMap
4968 def _get_advaudit_defaults(option=None):
4969     """
4970     Loads audit.csv defaults into a dict in __context__ called
4971     'lgpo.audit_defaults'. The dictionary includes fieldnames and all
4972     configurable policies as keys. The values are used to create/modify the
4973     ``audit.csv`` file. The first entry is `fieldnames` used to create the
4974     header for the csv file. The rest of the entries are the audit policy names.
4975     Sample data follows:
4976     {
4977         'fieldnames': ['Machine Name',
4978                        'Policy Target',
4979                        'Subcategory',
4980                        'Subcategory GUID',
4981                        'Inclusion Setting',
4982                        'Exclusion Setting',
4983                        'Setting Value'],
4984         'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',
4985                                           'Exclusion Setting': '',
4986                                           'Inclusion Setting': 'No Auditing',
4987                                           'Machine Name': 'WIN-8FGT3E045SE',
4988                                           'Policy Target': 'System',
4989                                           'Setting Value': '0',
4990                                           'Subcategory': u'Audit Sensitive Privilege Use',
4991                                           'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},
4992         'Audit Special Logon': {'Auditpol Name': 'Special Logon',
4993                                 'Exclusion Setting': '',
4994                                 'Inclusion Setting': 'No Auditing',
4995                                 'Machine Name': 'WIN-8FGT3E045SE',
4996                                 'Policy Target': 'System',
4997                                 'Setting Value': '0',
4998                                 'Subcategory': u'Audit Special Logon',
4999                                 'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},
5000         'Audit System Integrity': {'Auditpol Name': 'System Integrity',
5001                                    'Exclusion Setting': '',
5002                                    'Inclusion Setting': 'No Auditing',
5003                                    'Machine Name': 'WIN-8FGT3E045SE',
5004                                    'Policy Target': 'System',
5005                                    'Setting Value': '0',
5006                                    'Subcategory': u'Audit System Integrity',
5007                                    'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},
5008         ...
5009     }
5010     .. note::
5011         `Auditpol Name` designates the value to use when setting the value with
5012         the auditpol command
5013     Args:
5014         option (str): The item from the dictionary to return. If ``None`` the
5015             entire dictionary is returned. Default is ``None``
5016     Returns:
5017         dict: If ``None`` or one of the audit settings is passed
5018         list: If ``fieldnames`` is passed
5019     """
5020     if "lgpo.audit_defaults" not in __context__:
5021         log.debug("Loading auditpol defaults into __context__")
5022         dump = __utils__["auditpol.get_auditpol_dump"]()
5023         reader = csv.DictReader(dump)
5024         audit_defaults = {"fieldnames": reader.fieldnames}
5025         for row in reader:
5026             row["Machine Name"] = ""
5027             row["Auditpol Name"] = row["Subcategory"]
5028             if row["Subcategory"] == "Central Policy Staging":
5029                 row["Subcategory"] = "Audit Central Access Policy Staging"
5030             elif row["Subcategory"] == "Plug and Play Events":
5031                 row["Subcategory"] = "Audit PNP Activity"
5032             elif row["Subcategory"] == "Token Right Adjusted Events":
5033                 row["Subcategory"] = "Audit Token Right Adjusted"
5034             else:
5035                 row["Subcategory"] = "Audit {}".format(row["Subcategory"])
5036             audit_defaults[row["Subcategory"]] = row
5037         __context__["lgpo.audit_defaults"] = audit_defaults
5038     if option:
5039         return __context__["lgpo.audit_defaults"][option]
5040     else:
5041         return __context__["lgpo.audit_defaults"]
5042 def _advaudit_check_csv():
5043     """
5044     This function checks for the existence of the `audit.csv` file here:
5045     `C:\\Windows\\security\\audit`
5046     If the file does not exist, then it copies the `audit.csv` file from the
5047     Group Policy location:
5048     `C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit`
5049     file is created.
5050     """
5051     system_root <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= os.environ.get("SystemRoot", "C:\\Windows")
5052     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
5053     f_audit_gpo = os.path.join(</b></font>
5054         system_root,
5055         "System32",
5056         "GroupPolicy",
5057         "Machine",
5058         "Microsoft",
5059         "Windows NT",
5060         "Audit",
5061         "audit.csv",
5062     )
5063     if not __salt__["file.file_exists"](f_audit):
5064         if __salt__["file.file_exists"](f_audit_gpo):
5065             __salt__["file.copy"](f_audit_gpo, f_audit)
5066         else:
5067             field_names = _get_advaudit_defaults("fieldnames")
5068             __salt__["file.makedirs"](f_audit)
5069             __salt__["file.write"](f_audit, ",".join(field_names))
5070 def _get_advaudit_value(option, refresh=False):
5071     """
5072     Get the Advanced Auditing policy as configured in
5073     ``C:\\Windows\\Security\\Audit\\audit.csv``
5074     Args:
5075         option (str):
5076             The name of the setting as it appears in audit.csv
5077         refresh (bool):
5078             Refresh secedit data stored in __context__. This is needed for
5079             testing where the state is setting the value, but the module that
5080             is checking the value has its own __context__.
5081     Returns:
5082         bool: ``True`` if successful, otherwise ``False``
5083     """
5084     if "lgpo.adv_audit_data" not in __context__ or refresh is True:
5085         system_root = os.environ.get("SystemRoot", "C:\\Windows")
5086         f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
5087         _advaudit_check_csv()
5088         audit_settings = {}
5089         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
5090             reader = csv.DictReader(csv_file)
5091             for row in reader:
5092                 audit_settings.update({row["Subcategory"]: row["Setting Value"]})
5093         __context__["lgpo.adv_audit_data"] = audit_settings
5094     return __context__["lgpo.adv_audit_data"].get(option, None)
5095 def _set_advaudit_file_data(option, value):
5096     """
5097     Helper function that sets the Advanced Audit settings in the two .csv files
5098     on Windows. Those files are located at:
5099     C:\\Windows\\Security\\Audit\\audit.csv
5100     C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit\\audit.csv
5101     Args:
5102         option (str): The name of the option to set
5103         value (str): The value to set. ['None', '0', '1', '2', '3']
5104     Returns:
5105         bool: ``True`` if successful, otherwise ``False``
5106     """
5107     system_root = os.environ.get("SystemRoot", "C:\\Windows")
5108     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
5109     f_audit_gpo = os.path.join(
5110         system_root,
5111         "System32",
5112         "GroupPolicy",
5113         "Machine",
5114         "Microsoft",
5115         "Windows NT",
5116         "Audit",
5117         "audit.csv",
5118     )
5119     f_temp = tempfile.NamedTemporaryFile(
5120         mode="w", delete=False, suffix=".csv", prefix="audit"
5121     )
5122     auditpol_values = {
5123         "None": "No Auditing",
5124         "0": "No Auditing",
5125         "1": "Success",
5126         "2": "Failure",
5127         "3": "Success and Failure",
5128     }
5129     _advaudit_check_csv()
5130     try:
5131         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
5132             reader = csv.DictReader(csv_file)
5133             with salt.utils.files.fopen(f_temp.name, mode="w") as tmp_file:
5134                 writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)
5135                 writer.writeheader()
5136                 value_written = False
5137                 for row in reader:
5138                     if row["Subcategory"] == option:
5139                         if not value == "None":
5140                             row["Inclusion Setting"] = auditpol_values[value]
5141                             row["Setting Value"] = value
5142                             log.trace("LGPO: Setting %s to %s", option, value)
5143                             writer.writerow(row)
5144                         else:
5145                             log.trace("LGPO: Removing %s", option)
5146                         value_written = True
5147                     else:
5148                         writer.writerow(row)
5149                 if not value_written:
5150                     if not value == "None":
5151                         log.trace("LGPO: Setting %s to %s", option, value)
5152                         defaults = _get_advaudit_defaults(option)
5153                         writer.writerow(
5154                             {
5155                                 "Machine Name": defaults["Machine Name"],
5156                                 "Policy Target": defaults["Policy Target"],
5157                                 "Subcategory": defaults["Subcategory"],
5158                                 "Subcategory GUID": defaults["Subcategory GUID"],
5159                                 "Inclusion Setting": auditpol_values[value],
5160                                 "Exclusion Setting": defaults["Exclusion Setting"],
5161                                 "Setting Value": value,
5162                             }
5163                         )
5164                     value_written = True
5165         if value_written:
5166             __salt__["file.copy"](f_temp.name, f_audit, remove_existing=True)
5167             __salt__["file.makedirs"](f_audit_gpo)
5168             __salt__["file.copy"](f_temp.name, f_audit_gpo, remove_existing=True)
5169     finally:
5170         f_temp.close()
5171         __salt__["file.remove"](f_temp.name)
5172     return value_written
5173 def _set_advaudit_pol_data(option, value):
5174     """
5175     Helper function that updates the current applied settings to match what has
5176     just been set in the audit.csv files. We're doing it this way instead of
5177     running `gpupdate`
5178     Args:
5179         option (str): The name of the option to set
5180         value (str): The value to set. ['None', '0', '1', '2', '3']
5181     Returns:
5182         bool: ``True`` if successful, otherwise ``False``
5183     """
5184     auditpol_values = {
5185         "None": "No Auditing",
5186         "0": "No Auditing",
5187         "1": "Success",
5188         "2": "Failure",
5189         "3": "Success and Failure",
5190     }
5191     defaults = _get_advaudit_defaults(option)
5192     return __utils__["auditpol.set_setting"](
5193         name=defaults["Auditpol Name"], value=auditpol_values[value]
5194     )
5195 def _set_advaudit_value(option, value):
5196     """
5197     Helper function to update the Advanced Audit policy on the machine. This
5198     function modifies the two ``audit.csv`` files in the following locations:
5199     C:\\Windows\\Security\\Audit\\audit.csv
5200     C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit\\audit.csv
5201     Then it applies those settings using ``auditpol``
5202     After that, it updates ``__context__`` with the new setting
5203     Args:
5204         option (str): The name of the option to set
5205         value (str): The value to set. ['None', '0', '1', '2', '3']
5206     Returns:
5207         bool: ``True`` if successful, otherwise ``False``
5208     """
5209     if not _set_advaudit_file_data(option=option, value=value):
5210         raise CommandExecutionError("Failed to set audit.csv option: {}".format(option))
5211     if not _set_advaudit_pol_data(option=option, value=value):
5212         log.error(
5213             "Failed to apply audit setting: %s\n"
5214             "Policy will take effect on next GPO update",
5215             option,
5216         )
5217     if "lgpo.adv_audit_data" not in __context__:
5218         _get_advaudit_value(option)
5219     if value is None:
5220         log.debug("LGPO: Removing Advanced Audit data: %s", option)
5221         __context__["lgpo.adv_audit_data"].pop(option)
5222     else:
5223         log.debug("LGPO: Updating Advanced Audit data: %s: %s", option, value)
5224         __context__["lgpo.adv_audit_data"][option] = value
5225     return True
5226 def _get_netsh_value(profile, option):
5227     if "lgpo.netsh_data" not in __context__:
5228         __context__["lgpo.netsh_data"] = {}
5229     if profile not in __context__["lgpo.netsh_data"]:
5230         log.debug("LGPO: Loading netsh data for %s profile", profile)
5231         settings = salt.utils.win_lgpo_netsh.get_all_settings(
5232             profile=profile, store="lgpo"
5233         )
5234         __context__["lgpo.netsh_data"].update({profile: settings})
5235     log.trace(
5236         "LGPO: netsh returning value: %s",
5237         __context__["lgpo.netsh_data"][profile][option],
5238     )
5239     return __context__["lgpo.netsh_data"][profile][option]
5240 def _set_netsh_value(profile, section, option, value):
5241     if section not in ("firewallpolicy", "settings", "logging", "state"):
5242         raise ValueError("LGPO: Invalid section: {}".format(section))
5243     log.trace(
5244         "LGPO: Setting the following\nProfile: %s\nSection: %s\nOption: %s\nValue: %s",
5245         profile,
5246         section,
5247         option,
5248         value,
5249     )
5250     if section == "firewallpolicy":
5251         salt.utils.win_lgpo_netsh.set_firewall_settings(
5252             profile=profile,
5253             inbound=value if option == "Inbound" else None,
5254             outbound=value if option == "Outbound" else None,
5255             store="lgpo",
5256         )
5257     if section == "settings":
5258         salt.utils.win_lgpo_netsh.set_settings(
5259             profile=profile, setting=option, value=value, store="lgpo"
5260         )
5261     if section == "state":
5262         salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store="lgpo")
5263     if section == "logging":
5264         if option in ("FileName", "MaxFileSize"):
5265             if value == "Not configured":
5266                 value = "notconfigured"
5267         if option.startswith("Log"):
5268             option = option[3:]
5269         salt.utils.win_lgpo_netsh.set_logging_settings(
5270             profile=profile, setting=option, value=value, store="lgpo"
5271         )
5272     log.trace("LGPO: Clearing netsh data for %s profile", profile)
5273     __context__["lgpo.netsh_data"].pop(profile)
5274     return True
5275 def _load_secedit_data():
5276     """
5277     Helper function that loads secedit data. It runs `secedit /export /cfg
5278     &lt;file_name&gt;` which creates a file that contains the secedit data.
5279     Returns:
5280         str: The contents of the file generated by the secedit command
5281     """
5282     f_exp = os.path.join(__opts__["cachedir"], "secedit-{}.txt".format(UUID))
5283     try:
5284         __salt__["cmd.run"](["secedit", "/export", "/cfg", f_exp])
5285         with salt.utils.files.fopen(f_exp, encoding="utf-16") as fp:
5286             secedit_data = fp.readlines()
5287         return secedit_data
5288     finally:
5289         if __salt__["file.file_exists"](f_exp):
5290             __salt__["file.remove"](f_exp)
5291 def _get_secedit_data(refresh=False):
5292     """
5293     Helper function that returns the secedit data in __context__ if it exists
5294     and puts the secedit data in __context__ if it does not.
5295     Args:
5296         refresh (bool):
5297             Refresh secedit data stored in __context__. This is needed for
5298             testing where the state is setting the value, but the module that
5299             is checking the value has its own __context__.
5300     Returns:
5301         str: secedit data from __context__
5302     """
5303     if "lgpo.secedit_data" not in __context__ or refresh is True:
5304         log.debug("LGPO: Loading secedit data")
5305         __context__["lgpo.secedit_data"] = _load_secedit_data()
5306     return __context__["lgpo.secedit_data"]
5307 def _get_secedit_value(option):
5308     """
5309     Helper function that looks for the passed option in the secedit data
5310     """
5311     secedit_data = _get_secedit_data()
5312     for _line in secedit_data:
5313         if _line.startswith(option):
5314             return _line.split("=")[1].strip()
5315     return "Not Defined"
5316 def _write_secedit_data(inf_data):
5317     """
5318     Helper function to write secedit data to the database
5319     """
5320     f_sdb = os.path.join(os.getenv("WINDIR"), "security", "database", "salt.sdb")
5321     f_inf = os.path.join(__opts__["cachedir"], "secedit-{}.inf".format(UUID))
5322     try:
5323         with salt.utils.files.fopen(f_inf, "w", encoding="utf-16") as fp:
5324             fp.write(inf_data)
5325         cmd = ["secedit", "/import", "/db", f_sdb, "/cfg", f_inf]
5326         retcode = __salt__["cmd.retcode"](cmd)
5327         if not retcode == 0:
5328             log.debug("Secedit failed to import template data")
5329             return False
5330         cmd = ["secedit", "/configure", "/db", f_sdb]
5331         retcode = __salt__["cmd.retcode"](cmd)
5332         if not retcode == 0:
5333             log.debug("Secedit failed to apply security database")
5334             return False
5335         __context__.pop("lgpo.secedit_data", None)
5336         return True
5337     finally:
5338         if __salt__["file.file_exists"](f_inf):
5339             __salt__["file.remove"](f_inf)
5340 def _transform_value(value, policy, transform_type):
5341     """
5342     helper function to transform the policy value into something that more
5343     closely matches how the policy is displayed in the gpedit GUI
5344     """
5345     t_kwargs = {}
5346     if "Transform" in policy:
5347         if transform_type in policy["Transform"]:
5348             _policydata = _policy_info()
5349             if transform_type + "Args" in policy["Transform"]:
5350                 t_kwargs = policy["Transform"][transform_type + "Args"]
5351             return getattr(_policydata, policy["Transform"][transform_type])(
5352                 value, **t_kwargs
5353             )
5354         else:
5355             return value
5356     else:
5357         if "Registry" in policy:
5358             if value == "(value not set)":
5359                 return "Not Defined"
5360         return value
5361 def _validateSetting(value, policy):
5362     """
5363     helper function to validate specified value is appropriate for the policy
5364     if the 'Settings' key is a list, the value will check that it is in the list
5365     if the 'Settings' key is a dict we will try to execute the function name
5366         from the 'Function' key, passing the value and additional arguments from
5367         the 'Args' dict
5368     if the 'Settings' key is None, we won't do any validation and just return
5369         True
5370     if the Policy has 'Children', we'll validate their settings too
5371     """
5372     log.debug("validating %s for policy %s", value, policy)
5373     if "Settings" in policy:
5374         if policy["Settings"]:
5375             if isinstance(policy["Settings"], list):
5376                 if value not in policy["Settings"]:
5377                     return False
5378             elif isinstance(policy["Settings"], dict):
5379                 _policydata = _policy_info()
5380                 if not getattr(_policydata, policy["Settings"]["Function"])(
5381                     value, **policy["Settings"]["Args"]
5382                 ):
5383                     return False
5384     else:
5385         return True
5386     return True
5387 def _addAccountRights(sidObject, user_right):
5388     """
5389     helper function to add an account right to a user
5390     """
5391     try:
5392         if sidObject:
5393             _polHandle = win32security.LsaOpenPolicy(
5394                 None, win32security.POLICY_ALL_ACCESS
5395             )
5396             user_rights_list = [user_right]
5397             _ret = win32security.LsaAddAccountRights(
5398                 _polHandle, sidObject, user_rights_list
5399             )
5400         return True
5401     except Exception as e:  # pylint: disable=broad-except
5402         log.exception("Error attempting to add account right, exception was %s", e)
5403         return False
5404 def _delAccountRights(sidObject, user_right):
5405     """
5406     helper function to remove an account right from a user
5407     """
5408     try:
5409         _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5410         user_rights_list = [user_right]
5411         _ret = win32security.LsaRemoveAccountRights(
5412             _polHandle, sidObject, False, user_rights_list
5413         )
5414         return True
5415     except Exception as e:  # pylint: disable=broad-except
5416         log.exception("Error attempting to delete account right")
5417         return False
5418 def _getRightsAssignments(user_right):
5419     """
5420     helper function to return all the user rights assignments/users
5421     """
5422     sids = []
5423     polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5424     sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)
5425     return sids
5426 def _getAdmlDisplayName(adml_xml_data, display_name):
5427     """
5428     helper function to take the 'displayName' attribute of an element and find
5429     the value from the ADML data
5430     adml_xml_data :: XML data of all ADML files to search
5431     display_name :: the value of the displayName attribute from the ADMX entry
5432                     to search the ADML data for
5433     """
5434     if display_name.startswith("$(") and display_name.endswith(")"):
5435         display_name = re.sub(r"(^\$\(|\)$)", "", display_name)
5436         display_name = display_name.split(".")
5437         displayname_type = display_name[0]
5438         displayname_id = display_name[1]
5439         search_results = ADML_DISPLAY_NAME_XPATH(
5440             adml_xml_data,
5441             displayNameType=displayname_type,
5442             displayNameId=displayname_id,
5443         )
5444         if search_results:
5445             for result in search_results:
5446                 return result.text.strip()
5447     return None
5448 def _getAdmlPresentationRefId(adml_data, ref_id):
5449     """
5450     helper function to check for a presentation label for a policy element
5451     """
5452     search_results = adml_data.xpath(
5453         '//*[@*[local-name() = "refId"] = "{}"]'.format(ref_id)
5454     )
5455     alternate_label = ""
5456     if search_results:
5457         for result in search_results:
5458             the_localname = etree.QName(result.tag).localname
5459             if result.text is None:
5460                 presentation_element = PRESENTATION_ANCESTOR_XPATH(result)
5461                 if presentation_element:
5462                     presentation_element = presentation_element[0]
5463                     if TEXT_ELEMENT_XPATH(presentation_element):
5464                         for p_item in presentation_element:
5465                             if p_item == result:
5466                                 break
5467                             if etree.QName(p_item.tag).localname == "text":
5468                                 if getattr(p_item, "text"):
5469                                     alternate_label = getattr(p_item, "text").rstrip()
5470                         if alternate_label.endswith("."):
5471                             alternate_label = ""
5472             if the_localname in ["textBox", "comboBox"]:
5473                 label_items = result.xpath('.//*[local-name() = "label"]')
5474                 for label_item in label_items:
5475                     if label_item.text:
5476                         return label_item.text.rstrip().rstrip(":")
5477             elif the_localname in [
5478                 "decimalTextBox",
5479                 "longDecimalTextBox",
5480                 "dropdownList",
5481                 "listBox",
5482                 "checkBox",
5483                 "text",
5484                 "multiTextBox",
5485             ]:
5486                 if result.text:
5487                     return result.text.rstrip().rstrip(":")
5488                 else:
5489                     return alternate_label.rstrip(":")
5490     return None
5491 def _getFullPolicyName(
5492     policy_item, policy_name, return_full_policy_names, adml_language
5493 ):
5494     """
5495     helper function to retrieve the full policy name if needed
5496     """
5497     if policy_name in adm_policy_name_map[return_full_policy_names]:
5498         return adm_policy_name_map[return_full_policy_names][policy_name]
5499     adml_data = _get_policy_resources(language=adml_language)
5500     if return_full_policy_names and "displayName" in policy_item.attrib:
5501         fullPolicyName = _getAdmlDisplayName(
5502             adml_data, policy_item.attrib["displayName"]
5503         )
5504         if fullPolicyName:
5505             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5506             policy_name = fullPolicyName
5507     elif return_full_policy_names and "id" in policy_item.attrib:
5508         fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib["id"])
5509         if fullPolicyName:
5510             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5511             policy_name = fullPolicyName
5512     policy_name = policy_name.rstrip(":").rstrip()
5513     return policy_name
5514 def _regexSearchRegPolData(search_string, policy_data):
5515     """
5516     Helper function to do a regex search of a string value in policy_data.
5517     This is used to search the policy data from a registry.pol file or from
5518     gpt.ini
5519     Args:
5520         search_string (str): The string to search for
5521         policy_data (str): The data to be searched
5522     Returns:
5523         bool: ``True`` if the regex search_string is found, otherwise ``False``
5524     """
5525     if policy_data:
5526         if search_string:
5527             match = re.search(search_string, policy_data, re.IGNORECASE)
5528             if match:
5529                 return True
5530     return False
5531 def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):
5532     """
5533     helper function to do a search of Policy data from a registry.pol file
5534     returns the "data" field
5535     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
5536     [key;value;type;size;data]
5537     """
5538     value = None
5539     values = []
5540     encoded_semicolon = ";".encode("utf-16-le")
5541     if return_value_name:
5542         values = {}
5543     if search_string:
5544         registry = Registry()
5545         if len(search_string.split(encoded_semicolon)) &gt;= 3:
5546             vtype = registry.vtype_reverse[
5547                 ord(search_string.split(encoded_semicolon)[2].decode("utf-32-le"))
5548             ]
5549         else:
5550             vtype = None
5551         search_string = re.escape(search_string)
5552         matches = re.finditer(search_string, policy_data, re.IGNORECASE)
5553         if matches:
5554             for match in matches:
5555                 pol_entry = policy_data<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[
5556                     match.start() : (
5557                         policy_data.index("]".encode("utf-16-le"), match.end())
5558                     )
5559                 ].split(</b></font>encoded_semicolon, 4)
5560                 if len(pol_entry) &gt;= 2:
5561                     valueName = pol_entry[1].decode("utf-16-le").rstrip(chr(0))
5562                 if len(pol_entry) &gt;= 5:
5563                     value = encoded_semicolon.join(pol_entry[4:])
5564                     if vtype == "REG_DWORD" or vtype == "REG_QWORD":
5565                         if value:
5566                             if vtype == "REG_DWORD":
5567                                 for v in struct.unpack(b"I", value):
5568                                     value = v
5569                             elif vtype == "REG_QWORD":
5570                                 for v in struct.unpack(b"Q", value):
5571                                     value = v
5572                         else:
5573                             value = 0
5574                     elif vtype == "REG_MULTI_SZ":
5575                         value = value.decode("utf-16-le").rstrip(chr(0)).split(chr(0))
5576                     else:
5577                         value = value.decode("utf-16-le").rstrip(chr(0))
5578                 if return_value_name:
5579                     log.trace("we want value names and the value")
5580                     values[valueName] = value
5581                 elif len(matches) &gt; 1:
5582                     log.trace("we have multiple matches, we will return a list")
5583                     values.append(value)
5584     if values:
5585         value = values
5586     return value
5587 def _checkListItem(
5588     policy_element,
5589     policy_name,
5590     policy_key,
5591     xpath_object,
5592     policy_file_data,
5593     test_items=True,
5594 ):
5595     """
5596     helper function to process an enabled/disabled/true/falseList set
5597     if test_items is True, it will determine if the policy is enabled or
5598     disabled returning True if all items are configured in the registry.pol file
5599     and false if they are not
5600     if test_items is False, the expected strings for the items will be returned
5601     as a list
5602     returns True if the enabled/disabledList is 100% configured in the
5603     registry.pol file, otherwise returns False
5604     """
5605     xpath_string = (
5606         './/*[local-name() = "decimal" or local-name() = "delete"'
5607         ' or local-name() = "longDecimal" or local-name() = "string"]'
5608     )
5609     value_item_child_xpath = etree.XPath(xpath_string)
5610     expected_strings = []
5611     for list_element in xpath_object(policy_element):
5612         configured_items = 0
5613         required_items = 0
5614         for item in list_element:
5615             required_items = required_items + 1
5616             if "key" in item.attrib:
5617                 item_key = item.attrib["key"]
5618             else:
5619                 item_key = policy_key
5620             if "valueName" in item.attrib:
5621                 item_valuename = item.attrib["valueName"]
5622             else:
5623                 log.error(
5624                     "%s item with attributes %s in policy %s does not "
5625                     'have the required "valueName" attribute',
5626                     etree.QName(list_element).localname,
5627                     item.attrib,
5628                     policy_element.attrib,
5629                 )
5630                 break
5631             for value_item in value_item_child_xpath(item):
5632                 search_string = _processValueItem(
5633                     value_item, item_key, item_valuename, policy_element, item
5634                 )
5635                 if test_items:
5636                     if _regexSearchRegPolData(
5637                         re.escape(search_string), policy_file_data
5638                     ):
5639                         configured_items = configured_items + 1
5640                         log.trace(
5641                             "found the search string in the pol file,"
5642                             "%s of %s items for policy %s are "
5643                             "configured in registry.pol",
5644                             configured_items,
5645                             required_items,
5646                             policy_name,
5647                         )
5648                 else:
5649                     expected_strings.append(search_string)
5650         if test_items:
5651             if required_items &gt; 0 and required_items == configured_items:
5652                 log.trace("%s all items are set", policy_name)
5653                 return True
5654     if test_items:
5655         return False
5656     else:
5657         return expected_strings
5658 def _checkValueItemParent(
5659     policy_element,
5660     policy_name,
5661     policy_key,
5662     policy_valueName,
5663     xpath_object,
5664     policy_file_data,
5665     check_deleted=False,
5666     test_item=True,
5667 ):
5668     """
5669     helper function to process the parent of a value item object
5670     if test_item is True, it will determine if the policy is enabled/disabled
5671     returns True if the value is configured in the registry.pol file, otherwise returns False
5672     if test_item is False, the expected search string will be returned
5673     value type parents:
5674         boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx
5675         enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx
5676         disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx
5677     """
5678     for element in xpath_object(policy_element):
5679         for value_item in element:
5680             search_string = _processValueItem(
5681                 value_item,
5682                 policy_key,
5683                 policy_valueName,
5684                 policy_element,
5685                 element,
5686                 check_deleted=check_deleted,
5687             )
5688             if not test_item:
5689                 return search_string
5690             if _regexSearchRegPolData(re.escape(search_string), policy_file_data):
5691                 log.trace(
5692                     "found the search string in the pol file, %s is configured",
5693                     policy_name,
5694                 )
5695                 return True
5696     return False
5697 def _encode_string(value):
5698     encoded_null = chr(0).encode("utf-16-le")
5699     if value is None:
5700         return encoded_null
5701     elif not isinstance(value, str):
5702         raise TypeError(
5703             "Value {} is not a string type\nType: {}".format(repr(value), type(value))
5704         )
5705     return b"".join([value.encode("utf-16-le"), encoded_null])
5706 def _buildKnownDataSearchString(
5707     reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False
5708 ):
5709     """
5710     helper function similar to _processValueItem to build a search string for a
5711     known key/value/type/data
5712     """
5713     registry = Registry()
5714     this_element_value = None
5715     expected_string = b""
5716     encoded_semicolon = ";".encode("utf-16-le")
5717     encoded_null = chr(0).encode("utf-16-le")
5718     if reg_key:
5719         reg_key = reg_key.encode("utf-16-le")
5720     if reg_valueName:
5721         reg_valueName = reg_valueName.encode("utf-16-le")
5722     if reg_data and not check_deleted:
5723         if reg_vtype == "REG_DWORD":
5724             this_element_value = struct.pack(b"I", int(reg_data))
5725         elif reg_vtype == "REG_QWORD":
5726             this_element_value = struct.pack(b"Q", int(reg_data))
5727         elif reg_vtype == "REG_SZ":
5728             this_element_value = _encode_string(reg_data)
5729     if check_deleted:
5730         reg_vtype = "REG_SZ"
5731         expected_string = b"".join(
5732             [
5733                 "[".encode("utf-16-le"),
5734                 encoded_null,
5735                 encoded_semicolon,
5736                 "**del.".encode<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("utf-16-le"),
5737                 reg_valueName,
5738                 encoded_null,
5739                 encoded_semicolon,
5740                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5741                 encoded_semicolon,
5742                 chr(len(" {}".format(chr(0)).</b></font>encode("utf-16-le"))).encode("utf-32-le"),
5743                 encoded_semicolon,
5744                 " ".encode("utf-16-le"),
5745                 encoded_null,
5746                 "]".encode("utf-16-le"),
5747             ]
5748         )
5749     else:
5750         expected_string = b"".join(
5751             [
5752                 "[".encode("utf-16-le"),
5753                 reg_key,
5754                 encoded_null,
5755                 encoded_semicolon,
5756                 reg_valueName,
5757                 encoded_null,
5758                 encoded_semicolon,
5759                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5760                 encoded_semicolon,
5761                 chr(len(this_element_value)).encode("utf-32-le"),
5762                 encoded_semicolon,
5763                 this_element_value,
5764                 "]".encode("utf-16-le"),
5765             ]
5766         )
5767     return expected_string
5768 def _processValueItem(
5769     element,
5770     reg_key,
5771     reg_valuename,
5772     policy,
5773     parent_element,
5774     check_deleted=False,
5775     this_element_value=None,
5776 ):
5777     """
5778     helper function to process a value type item and generate the expected
5779     string in the Registry.pol file
5780     element - the element to process
5781     reg_key - the registry key associated with the element (some inherit from
5782               their parent policy)
5783     reg_valuename - the registry valueName associated with the element (some
5784                     inherit from their parent policy)
5785     policy - the parent policy element
5786     parent_element - the parent element (primarily passed in to differentiate
5787                      children of "elements" objects
5788     check_deleted - if the returned expected string should be for a deleted
5789                     value
5790     this_element_value - a specific value to place into the expected string
5791                          returned for "elements" children whose values are
5792                          specified by the user
5793     """
5794     registry = Registry()
5795     expected_string = None
5796     this_vtype = "REG_SZ"
5797     encoded_semicolon = ";".encode("utf-16-le")
5798     encoded_null = chr(0).encode("utf-16-le")
5799     if reg_key:
5800         reg_key = reg_key.encode("utf-16-le")
5801     if reg_valuename:
5802         reg_valuename = reg_valuename.encode("utf-16-le")
5803     if (
5804         etree.QName(element).localname == "decimal"
5805         and etree.QName(parent_element).localname != "elements"
5806     ):
5807         this_vtype = "REG_DWORD"
5808         if "value" in element.attrib:
5809             this_element_value = struct.pack(b"I", int(element.attrib["value"]))
5810         else:
5811             log.error(
5812                 "The %s child %s element for the policy with "
5813                 'attributes: %s does not have the required "value" '
5814                 "attribute. The element attributes are: %s",
5815                 etree.QName(parent_element).localname,
5816                 etree.QName(element).localname,
5817                 policy.attrib,
5818                 element.attrib,
5819             )
5820             return None
5821     elif (
5822         etree.QName(element).localname == "longDecimal"
5823         and etree.QName(parent_element).localname != "elements"
5824     ):
5825         this_vtype = "REG_QWORD"
5826         if "value" in element.attrib:
5827             this_element_value = struct.pack(b"Q", int(element.attrib["value"]))
5828         else:
5829             log.error(
5830                 "The %s child %s element for the policy with "
5831                 'attributes: %s does not have the required "value" '
5832                 "attribute. The element attributes are: %s",
5833                 etree.QName(parent_element).localname,
5834                 etree.QName(element).localname,
5835                 policy.attrib,
5836                 element.attrib,
5837             )
5838             return None
5839     elif etree.QName(element).localname == "string":
5840         this_vtype = "REG_SZ"
5841         this_element_value = _encode_string(element.text)
5842     elif etree.QName(parent_element).localname == "elements":
5843         standard_element_expected_string = True
5844         if etree.QName(element).localname == "boolean":
5845             if this_element_value is False:
5846                 check_deleted = True
5847             if not check_deleted:
5848                 this_vtype = "REG_DWORD"
5849             this_element_value = struct.pack("I", 1)
5850             standard_element_expected_string = False
5851         elif etree.QName(element).localname == "decimal":
5852             this_vtype = "REG_DWORD"
5853             requested_val = this_element_value
5854             if this_element_value is not None:
5855                 this_element_value = struct.pack(b"I", int(this_element_value))
5856             if "storeAsText" in element.attrib:
5857                 if element.attrib["storeAsText"].lower() == "true":
5858                     this_vtype = "REG_SZ"
5859                     if requested_val is not None:
5860                         this_element_value = str(requested_val).encode("utf-16-le")
5861             if check_deleted:
5862                 this_vtype = "REG_SZ"
5863         elif etree.QName(element).localname == "longDecimal":
5864             this_vtype = "REG_QWORD"
5865             requested_val = this_element_value
5866             if this_element_value is not None:
5867                 this_element_value = struct.pack(b"Q", int(this_element_value))
5868             if "storeAsText" in element.attrib:
5869                 if element.attrib["storeAsText"].lower() == "true":
5870                     this_vtype = "REG_SZ"
5871                     if requested_val is not None:
5872                         this_element_value = str(requested_val).encode("utf-16-le")
5873         elif etree.QName(element).localname == "text":
5874             this_vtype = "REG_SZ"
5875             if "expandable" in element.attrib:
5876                 if element.attrib["expandable"].lower() == "true":
5877                     this_vtype = "REG_EXPAND_SZ"
5878             if this_element_value is not None:
5879                 this_element_value = _encode_string(this_element_value)
5880         elif etree.QName(element).localname == "multiText":
5881             this_vtype = "REG_MULTI_SZ" if not check_deleted else "REG_SZ"
5882             if this_element_value is not None:
5883                 this_element_value = "{0}{1}{1}".format(
5884                     chr(0).join(this_element_value), chr(0)
5885                 )
5886         elif etree.QName(element).localname == "list":
5887             standard_element_expected_string = False
5888             del_keys = b""
5889             element_valuenames = []
5890             element_values = this_element_value
5891             if this_element_value is not None:
5892                 element_valuenames = [
5893                     str(z) for z in range(1, len(this_element_value) + 1)
5894                 ]
5895             if "additive" in element.attrib:
5896                 if element.attrib["additive"].lower() == "false":
5897                     del_keys = b"".join(
5898                         [
5899                             "[".encode("utf-16-le"),
5900                             reg_key,
5901                             encoded_null,
5902                             encoded_semicolon,
5903                             "**delvals.".encode("utf-16-le"),
5904                             encoded_null,
5905                             encoded_semicolon,
5906                             chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5907                             encoded_semicolon,
5908                             chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5909                                 "utf-32-le"
5910                             ),
5911                             encoded_semicolon,
5912                             " ".encode("utf-16-le"),
5913                             encoded_null,
5914                             "]".encode("utf-16-le"),
5915                         ]
5916                     )
5917             if "expandable" in element.attrib:
5918                 this_vtype = "REG_EXPAND_SZ"
5919             if element.attrib.get("explicitValue", "false").lower() == "true":
5920                 if this_element_value is not None:
5921                     element_valuenames = [str(k) for k in this_element_value.keys()]
5922                     element_values = [str(v) for v in this_element_value.values()]
5923             elif "valuePrefix" in element.attrib:
5924                 if element.attrib["valuePrefix"] != "":
5925                     if this_element_value is not None:
5926                         element_valuenames = [
5927                             "{}{}".format(element.attrib["valuePrefix"], k)
5928                             for k in element_valuenames
5929                         ]
5930             else:
5931                 if element_values is not None:
5932                     element_valuenames = [str(z) for z in element_values]
5933             if not check_deleted:
5934                 if this_element_value is not None:
5935                     log.trace(
5936                         "_processValueItem has an explicit element_value of %s",
5937                         this_element_value,
5938                     )
5939                     expected_string = del_keys
5940                     log.trace(
5941                         "element_valuenames == %s and element_values == %s",
5942                         element_valuenames,
5943                         element_values,
5944                     )
5945                     for i, item in enumerate(element_valuenames):
5946                         expected_string = expected_string + b"".join(
5947                             [
5948                                 "[".encode("utf-16-le"),
5949                                 reg_key,
5950                                 encoded_null,
5951                                 encoded_semicolon,
5952                                 element_valuenames[i].encode("utf-16-le"),
5953                                 encoded_null,
5954                                 encoded_semicolon,
5955                                 chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5956                                 encoded_semicolon,
5957                                 chr(
5958                                     len(
5959                                         "{}{}".format(element_values[i], chr(0)).encode(
5960                                             "utf-16-le"
5961                                         )
5962                                     )
5963                                 ).encode("utf-32-le"),
5964                                 encoded_semicolon,
5965                                 _encode_string(element_values[i]),
5966                                 "]".encode("utf-16-le"),
5967                             ]
5968                         )
5969                 else:
5970                     expected_string = del_keys + b"".join(
5971                         [
5972                             "[".encode("utf-16-le"),
5973                             reg_key,
5974                             encoded_null,
5975                             encoded_semicolon,
5976                         ]
5977                     )
5978             else:
5979                 expected_string = b"".join(
5980                     [
5981                         "[".encode("utf-16-le"),
5982                         reg_key,
5983                         encoded_null,
5984                         encoded_semicolon,
5985                         "**delvals.".encode("utf-16-le"),
5986                         encoded_null,
5987                         encoded_semicolon,
5988                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5989                         encoded_semicolon,
5990                         chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5991                             "utf-32-le"
5992                         ),
5993                         encoded_semicolon,
5994                         " ".encode("utf-16-le"),
5995                         encoded_null,
5996                         "]".encode("utf-16-le"),
5997                     ]
5998                 )
5999         elif etree.QName(element).localname == "enum":
6000             if this_element_value is not None:
6001                 pass
6002         if standard_element_expected_string and not check_deleted:
6003             if this_element_value is not None:
6004                 if isinstance(this_element_value, str):
6005                     log.debug("Converting %s to bytes", this_element_value)
6006                     this_element_value = this_element_value.encode("utf-32-le")
6007                 expected_string = b"".join(
6008                     [
6009                         "[".encode("utf-16-le"),
6010                         reg_key,
6011                         encoded_null,
6012                         encoded_semicolon,
6013                         reg_valuename,
6014                         encoded_null,
6015                         encoded_semicolon,
6016                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
6017                         encoded_semicolon,
6018                         chr(len(this_element_value)).encode("utf-32-le"),
6019                         encoded_semicolon,
6020                         this_element_value,
6021                         "]".encode("utf-16-le"),
6022                     ]
6023                 )
6024             else:
6025                 expected_string = b"".join(
6026                     [
6027                         "[".encode("utf-16-le"),
6028                         reg_key,
6029                         encoded_null,
6030                         encoded_semicolon,
6031                         reg_valuename,
6032                         encoded_null,
6033                         encoded_semicolon,
6034                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
6035                         encoded_semicolon,
6036                     ]
6037                 )
6038     if not expected_string:
6039         if etree.QName(element).localname == "delete" or check_deleted:
6040             expected_string = b"".join(
6041                 [
6042                     "[".encode("utf-16-le"),
6043                     reg_key,
6044                     encoded_null,
6045                     encoded_semicolon,
6046                     "**del.".encode("utf-16-le"),
6047                     reg_valuename,
6048                     encoded_null,
6049                     encoded_semicolon,
6050                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
6051                     encoded_semicolon,
6052                     chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
6053                         "utf-32-le"
6054                     ),
6055                     encoded_semicolon,
6056                     " ".encode("utf-16-le"),
6057                     encoded_null,
6058                     "]".encode("utf-16-le"),
6059                 ]
6060             )
6061         else:
6062             expected_string = b"".join(
6063                 [
6064                     "[".encode("utf-16-le"),
6065                     reg_key,
6066                     encoded_null,
6067                     encoded_semicolon,
6068                     reg_valuename,
6069                     encoded_null,
6070                     encoded_semicolon,
6071                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
6072                     encoded_semicolon,
6073                     chr(len(this_element_value)).encode("utf-32-le"),
6074                     encoded_semicolon,
6075                     this_element_value,
6076                     "]".encode("utf-16-le"),
6077                 ]
6078             )
6079     return expected_string
6080 def _checkAllAdmxPolicies(
6081     policy_class,
6082     adml_language="en-US",
6083     return_full_policy_names=False,
6084     hierarchical_return=False,
6085     return_not_configured=False,
6086 ):
6087     """
6088     rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of
6089     looking only at the contents of the file, we're going to loop through every
6090     policy and look in the registry.pol file to determine if it is
6091     enabled/disabled/not configured
6092     """
6093     log.trace("POLICY CLASS == %s", policy_class)
6094     module_policy_data = _policy_info()
6095     policy_file_data = _read_regpol_file(
6096         module_policy_data.admx_registry_classes[policy_class]["policy_path"]
6097     )
6098     admx_policies = []
6099     policy_vals = {}
6100     hierarchy = {}
6101     full_names = {}
6102     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6103     adml_policy_resources = _get_policy_resources(language=adml_language)
6104     if policy_file_data:
6105         log.trace("POLICY CLASS %s has file data", policy_class)
6106         policy_filedata_split = re.sub(
6107             salt.utils.stringutils.to_bytes(r"\]{}$".format(chr(0))),
6108             b"",
6109             re.sub(
6110                 salt.utils.stringutils.to_bytes(r"^\[{}".format(chr(0))),
6111                 b"",
6112                 re.sub(
6113                     re.escape(module_policy_data.reg_pol_header.encode("utf-16-le")),
6114                     b"",
6115                     policy_file_data,
6116                 ),
6117             ),
6118         ).split("][".encode("utf-16-le"))
6119         log.trace("Searching %s policies...", len(policy_filedata_split))
6120         start_time = time.time()
6121         for policy_item in policy_filedata_split:
6122             policy_item_key = (
6123                 policy_item.split("{};".format(chr(0)).encode("utf-16-le"))[0]
6124                 .decode("utf-16-le")
6125                 .lower()
6126             )
6127             if policy_item_key:
6128                 admx_items = REGKEY_XPATH(
6129                     admx_policy_definitions, keyvalue=policy_item_key
6130                 )
6131                 log.trace("Found %s policies for %s", len(admx_items), policy_item_key)
6132                 for admx_item in admx_items:
6133                     if etree.QName(admx_item).localname == "policy":
6134                         if admx_item not in admx_policies:
6135                             admx_policies.append(admx_item)
6136                     else:
6137                         for policy_item in POLICY_ANCESTOR_XPATH(admx_item):
6138                             if policy_item not in admx_policies:
6139                                 admx_policies.append(policy_item)
6140         log.trace("Search complete: %s seconds", time.time() - start_time)
6141         if return_not_configured:
6142             log.trace("Gathering non configured policies")
6143             start_time = time.time()
6144             not_configured_policies = ALL_CLASS_POLICY_XPATH(
6145                 admx_policy_definitions, registry_class=policy_class
6146             )
6147             for policy_item in admx_policies:
6148                 if policy_item in not_configured_policies:
6149                     not_configured_policies.remove(policy_item)
6150             for not_configured_policy in not_configured_policies:
6151                 not_configured_policy_namespace = not_configured_policy.nsmap[
6152                     not_configured_policy.prefix
6153                 ]
6154                 if not_configured_policy_namespace not in policy_vals:
6155                     policy_vals[not_configured_policy_namespace] = {}
6156                 policy_vals[not_configured_policy_namespace][
6157                     not_configured_policy.attrib["name"]
6158                 ] = "Not Configured"
6159                 if return_full_policy_names:
6160                     if not_configured_policy_namespace not in full_names:
6161                         full_names[not_configured_policy_namespace] = {}
6162                     full_names[not_configured_policy_namespace][
6163                         not_configured_policy.attrib["name"]
6164                     ] = _getFullPolicyName(
6165                         policy_item=not_configured_policy,
6166                         policy_name=not_configured_policy.attrib["name"],
6167                         return_full_policy_names=return_full_policy_names,
6168                         adml_language=adml_language,
6169                     )
6170                 log.trace(
6171                     "building hierarchy for non-configured item %s",
6172                     not_configured_policy.attrib["name"],
6173                 )
6174                 if not_configured_policy_namespace not in hierarchy:
6175                     hierarchy[not_configured_policy_namespace] = {}
6176                 hierarchy[not_configured_policy_namespace][
6177                     not_configured_policy.attrib["name"]
6178                 ] = _build_parent_list(
6179                     policy_definition=not_configured_policy,
6180                     return_full_policy_names=return_full_policy_names,
6181                     adml_language=adml_language,
6182                 )
6183             log.trace("Gathering complete: %s seconds", time.time() - start_time)
6184         log.trace("Examining %s policies...", len(admx_policies))
6185         start_time = time.time()
6186         for admx_policy in admx_policies:
6187             this_valuename = None
6188             this_policy_setting = "Not Configured"
6189             element_only_enabled_disabled = True
6190             explicit_enable_disable_value_setting = False
6191             if "key" in admx_policy.attrib:
6192                 this_key = admx_policy.attrib["key"]
6193             else:
6194                 log.error(
6195                     'policy item %s does not have the required "key" attribute',
6196                     admx_policy.attrib,
6197                 )
6198                 break
6199             if "valueName" in admx_policy.attrib:
6200                 this_valuename = admx_policy.attrib["valueName"]
6201             if "name" in admx_policy.attrib:
6202                 this_policyname = admx_policy.attrib["name"]
6203             else:
6204                 log.error(
6205                     'policy item %s does not have the required "name" attribute',
6206                     admx_policy.attrib,
6207                 )
6208                 break
6209             this_policynamespace = admx_policy.nsmap[admx_policy.prefix]
6210             if (
6211                 ENABLED_VALUE_XPATH(admx_policy)
6212                 and this_policy_setting == "Not Configured"
6213             ):
6214                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
6215                     admx_policy
6216                 ):
6217                     element_only_enabled_disabled = False
6218                     explicit_enable_disable_value_setting = True
6219                 if _checkValueItemParent(
6220                     admx_policy,
6221                     this_policyname,
6222                     this_key,
6223                     this_valuename,
6224                     ENABLED_VALUE_XPATH,
6225                     policy_file_data,
6226                 ):
6227                     this_policy_setting = "Enabled"
6228                     log.trace(
6229                         "%s is enabled by detected ENABLED_VALUE_XPATH", this_policyname
6230                     )
6231                     if this_policynamespace not in policy_vals:
6232                         policy_vals[this_policynamespace] = {}
6233                     policy_vals[this_policynamespace][
6234                         this_policyname
6235                     ] = this_policy_setting
6236             if (
6237                 DISABLED_VALUE_XPATH(admx_policy)
6238                 and this_policy_setting == "Not Configured"
6239             ):
6240                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6241                     element_only_enabled_disabled = False
6242                     explicit_enable_disable_value_setting = True
6243                 if _checkValueItemParent(
6244                     admx_policy,
6245                     this_policyname,
6246                     this_key,
6247                     this_valuename,
6248                     DISABLED_VALUE_XPATH,
6249                     policy_file_data,
6250                 ):
6251                     this_policy_setting = "Disabled"
6252                     log.trace(
6253                         "%s is disabled by detected DISABLED_VALUE_XPATH",
6254                         this_policyname,
6255                     )
6256                     if this_policynamespace not in policy_vals:
6257                         policy_vals[this_policynamespace] = {}
6258                     policy_vals[this_policynamespace][
6259                         this_policyname
6260                     ] = this_policy_setting
6261             if (
6262                 ENABLED_LIST_XPATH(admx_policy)
6263                 and this_policy_setting == "Not Configured"
6264             ):
6265                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
6266                     admx_policy
6267                 ):
6268                     element_only_enabled_disabled = False
6269                     explicit_enable_disable_value_setting = True
6270                 if _checkListItem(
6271                     admx_policy,
6272                     this_policyname,
6273                     this_key,
6274                     ENABLED_LIST_XPATH,
6275                     policy_file_data,
6276                 ):
6277                     this_policy_setting = "Enabled"
6278                     log.trace(
6279                         "%s is enabled by detected ENABLED_LIST_XPATH", this_policyname
6280                     )
6281                     if this_policynamespace not in policy_vals:
6282                         policy_vals[this_policynamespace] = {}
6283                     policy_vals[this_policynamespace][
6284                         this_policyname
6285                     ] = this_policy_setting
6286             if (
6287                 DISABLED_LIST_XPATH(admx_policy)
6288                 and this_policy_setting == "Not Configured"
6289             ):
6290                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6291                     element_only_enabled_disabled = False
6292                     explicit_enable_disable_value_setting = True
6293                 if _checkListItem(
6294                     admx_policy,
6295                     this_policyname,
6296                     this_key,
6297                     DISABLED_LIST_XPATH,
6298                     policy_file_data,
6299                 ):
6300                     this_policy_setting = "Disabled"
6301                     log.trace(
6302                         "%s is disabled by detected DISABLED_LIST_XPATH",
6303                         this_policyname,
6304                     )
6305                     if this_policynamespace not in policy_vals:
6306                         policy_vals[this_policynamespace] = {}
6307                     policy_vals[this_policynamespace][
6308                         this_policyname
6309                     ] = this_policy_setting
6310             if not explicit_enable_disable_value_setting and this_valuename:
6311                 if _regexSearchRegPolData(
6312                     re.escape(
6313                         _buildKnownDataSearchString(
6314                             this_key, this_valuename, "REG_DWORD", "1"
6315                         )
6316                     ),
6317                     policy_file_data,
6318                 ):
6319                     this_policy_setting = "Enabled"
6320                     log.trace(
6321                         "%s is enabled by no explicit enable/disable list or value",
6322                         this_policyname,
6323                     )
6324                     if this_policynamespace not in policy_vals:
6325                         policy_vals[this_policynamespace] = {}
6326                     policy_vals[this_policynamespace][
6327                         this_policyname
6328                     ] = this_policy_setting
6329                 elif _regexSearchRegPolData(
6330                     re.escape(
6331                         _buildKnownDataSearchString(
6332                             this_key,
6333                             this_valuename,
6334                             "REG_DWORD",
6335                             None,
6336                             check_deleted=True,
6337                         )
6338                     ),
6339                     policy_file_data,
6340                 ):
6341                     this_policy_setting = "Disabled"
6342                     log.trace(
6343                         "%s is disabled by no explicit enable/disable list or value",
6344                         this_policyname,
6345                     )
6346                     if this_policynamespace not in policy_vals:
6347                         policy_vals[this_policynamespace] = {}
6348                     policy_vals[this_policynamespace][
6349                         this_policyname
6350                     ] = this_policy_setting
6351             if ELEMENTS_XPATH(admx_policy):
6352                 if element_only_enabled_disabled or this_policy_setting == "Enabled":
6353                     required_elements = {}
6354                     configured_elements = {}
6355                     policy_disabled_elements = 0
6356                     for elements_item in ELEMENTS_XPATH(admx_policy):
6357                         for child_item in elements_item:
6358                             this_element_name = _getFullPolicyName(
6359                                 policy_item=child_item,
6360                                 policy_name=child_item.attrib["id"],
6361                                 return_full_policy_names=return_full_policy_names,
6362                                 adml_language=adml_language,
6363                             )
6364                             required_elements[this_element_name] = None
6365                             child_key = child_item.attrib.get("key", this_key)
6366                             child_valuename = child_item.attrib.get(
6367                                 "valueName", this_valuename
6368                             )
6369                             if etree.QName(child_item).localname == "boolean":
6370                                 if child_item is not None:
6371                                     if (
6372                                         TRUE_VALUE_XPATH(child_item)
6373                                         and this_element_name not in configured_elements
6374                                     ):
6375                                         if _checkValueItemParent(
6376                                             child_item,
6377                                             this_policyname,
6378                                             child_key,
6379                                             child_valuename,
6380                                             TRUE_VALUE_XPATH,
6381                                             policy_file_data,
6382                                         ):
6383                                             configured_elements[
6384                                                 this_element_name
6385                                             ] = True
6386                                             log.trace(
6387                                                 "element %s is configured true",
6388                                                 child_item.attrib["id"],
6389                                             )
6390                                     if (
6391                                         FALSE_VALUE_XPATH(child_item)
6392                                         and this_element_name not in configured_elements
6393                                     ):
6394                                         if _checkValueItemParent(
6395                                             child_item,
6396                                             this_policyname,
6397                                             child_key,
6398                                             child_valuename,
6399                                             FALSE_VALUE_XPATH,
6400                                             policy_file_data,
6401                                         ):
6402                                             configured_elements[
6403                                                 this_element_name
6404                                             ] = False
6405                                             policy_disabled_elements = (
6406                                                 policy_disabled_elements + 1
6407                                             )
6408                                             log.trace(
6409                                                 "element %s is configured false",
6410                                                 child_item.attrib["id"],
6411                                             )
6412                                     if (
6413                                         TRUE_LIST_XPATH(child_item)
6414                                         and this_element_name not in configured_elements
6415                                     ):
6416                                         log.trace("checking trueList")
6417                                         if _checkListItem(
6418                                             child_item,
6419                                             this_policyname,
6420                                             this_key,
6421                                             TRUE_LIST_XPATH,
6422                                             policy_file_data,
6423                                         ):
6424                                             configured_elements[
6425                                                 this_element_name
6426                                             ] = True
6427                                             log.trace(
6428                                                 "element %s is configured true",
6429                                                 child_item.attrib["id"],
6430                                             )
6431                                     if (
6432                                         FALSE_LIST_XPATH(child_item)
6433                                         and this_element_name not in configured_elements
6434                                     ):
6435                                         log.trace("checking falseList")
6436                                         if _checkListItem(
6437                                             child_item,
6438                                             this_policyname,
6439                                             this_key,
6440                                             FALSE_LIST_XPATH,
6441                                             policy_file_data,
6442                                         ):
6443                                             configured_elements[
6444                                                 this_element_name
6445                                             ] = False
6446                                             policy_disabled_elements = (
6447                                                 policy_disabled_elements + 1
6448                                             )
6449                                             log.trace(
6450                                                 "element %s is configured false",
6451                                                 child_item.attrib["id"],
6452                                             )
6453                                 else:
6454                                     if _regexSearchRegPolData(
6455                                         re.escape(
6456                                             _processValueItem(
6457                                                 child_item,
6458                                                 child_key,
6459                                                 child_valuename,
6460                                                 admx_policy,
6461                                                 elements_item,
6462                                                 check_deleted=True,
6463                                             )
6464                                         ),
6465                                         policy_file_data,
6466                                     ):
6467                                         configured_elements[this_element_name] = False
6468                                         policy_disabled_elements = (
6469                                             policy_disabled_elements + 1
6470                                         )
6471                                         log.trace(
6472                                             "element %s is configured false",
6473                                             child_item.attrib["id"],
6474                                         )
6475                                     elif _regexSearchRegPolData(
6476                                         re.escape(
6477                                             _processValueItem(
6478                                                 child_item,
6479                                                 child_key,
6480                                                 child_valuename,
6481                                                 admx_policy,
6482                                                 elements_item,
6483                                                 check_deleted=False,
6484                                             )
6485                                         ),
6486                                         policy_file_data,
6487                                     ):
6488                                         configured_elements[this_element_name] = True
6489                                         log.trace(
6490                                             "element %s is configured true",
6491                                             child_item.attrib["id"],
6492                                         )
6493                             elif (
6494                                 etree.QName(child_item).localname == "decimal"
6495                                 or etree.QName(child_item).localname == "text"
6496                                 or etree.QName(child_item).localname == "longDecimal"
6497                                 or etree.QName(child_item).localname == "multiText"
6498                             ):
6499                                 if _regexSearchRegPolData(
6500                                     re.escape(
6501                                         _processValueItem(
6502                                             child_item,
6503                                             child_key,
6504                                             child_valuename,
6505                                             admx_policy,
6506                                             elements_item,
6507                                             check_deleted=True,
6508                                         )
6509                                     ),
6510                                     policy_file_data,
6511                                 ):
6512                                     configured_elements[this_element_name] = "Disabled"
6513                                     policy_disabled_elements = (
6514                                         policy_disabled_elements + 1
6515                                     )
6516                                     log.trace(
6517                                         "element %s is disabled",
6518                                         child_item.attrib["id"],
6519                                     )
6520                                 elif _regexSearchRegPolData(
6521                                     re.escape(
6522                                         _processValueItem(
6523                                             child_item,
6524                                             child_key,
6525                                             child_valuename,
6526                                             admx_policy,
6527                                             elements_item,
6528                                             check_deleted=False,
6529                                         )
6530                                     ),
6531                                     policy_file_data,
6532                                 ):
6533                                     configured_value = _getDataFromRegPolData(
6534                                         _processValueItem(
6535                                             child_item,
6536                                             child_key,
6537                                             child_valuename,
6538                                             admx_policy,
6539                                             elements_item,
6540                                             check_deleted=False,
6541                                         ),
6542                                         policy_file_data,
6543                                     )
6544                                     configured_elements[
6545                                         this_element_name
6546                                     ] = configured_value
6547                                     log.trace(
6548                                         "element %s is enabled, value == %s",
6549                                         child_item.attrib["id"],
6550                                         configured_value,
6551                                     )
6552                             elif etree.QName(child_item).localname == "enum":
6553                                 if _regexSearchRegPolData(
6554                                     re.escape(
6555                                         _processValueItem(
6556                                             child_item,
6557                                             child_key,
6558                                             child_valuename,
6559                                             admx_policy,
6560                                             elements_item,
6561                                             check_deleted=True,
6562                                         )
6563                                     ),
6564                                     policy_file_data,
6565                                 ):
6566                                     log.trace(
6567                                         "enum element %s is disabled",
6568                                         child_item.attrib["id"],
6569                                     )
6570                                     configured_elements[this_element_name] = "Disabled"
6571                                     policy_disabled_elements = (
6572                                         policy_disabled_elements + 1
6573                                     )
6574                                 else:
6575                                     for enum_item in child_item:
6576                                         if _checkValueItemParent(
6577                                             enum_item,
6578                                             child_item.attrib["id"],
6579                                             child_key,
6580                                             child_valuename,
6581                                             VALUE_XPATH,
6582                                             policy_file_data,
6583                                         ):
6584                                             if VALUE_LIST_XPATH(enum_item):
6585                                                 log.trace("enum item has a valueList")
6586                                                 if _checkListItem(
6587                                                     enum_item,
6588                                                     this_policyname,
6589                                                     child_key,
6590                                                     VALUE_LIST_XPATH,
6591                                                     policy_file_data,
6592                                                 ):
6593                                                     log.trace(
6594                                                         "all valueList items exist in"
6595                                                         " file"
6596                                                     )
6597                                                     configured_elements[
6598                                                         this_element_name
6599                                                     ] = _getAdmlDisplayName(
6600                                                         adml_policy_resources,
6601                                                         enum_item.attrib["displayName"],
6602                                                     )
6603                                                     break
6604                                             else:
6605                                                 configured_elements[
6606                                                     this_element_name
6607                                                 ] = _getAdmlDisplayName(
6608                                                     adml_policy_resources,
6609                                                     enum_item.attrib["displayName"],
6610                                                 )
6611                                                 break
6612                             elif etree.QName(child_item).localname == "list":
6613                                 return_value_name = False
6614                                 if (
6615                                     "explicitValue" in child_item.attrib
6616                                     and child_item.attrib["explicitValue"].lower()
6617                                     == "true"
6618                                 ):
6619                                     log.trace(
6620                                         "explicitValue list, we will return value names"
6621                                     )
6622                                     return_value_name = True
6623                                 regex_str = [
6624                                     r"(?!\*",
6625                                     r"\*",
6626                                     "D",
6627                                     "e",
6628                                     "l",
6629                                     "V",
6630                                     "a",
6631                                     "l",
6632                                     "s",
6633                                     r"\.",
6634                                     ")",
6635                                 ]
6636                                 delvals_regex = "\x00".join(regex_str)
6637                                 delvals_regex = salt.utils.stringutils.to_bytes(
6638                                     delvals_regex
6639                                 )
6640                                 if _regexSearchRegPolData(
6641                                     re.escape(
6642                                         _processValueItem(
6643                                             child_item,
6644                                             child_key,
6645                                             child_valuename,
6646                                             admx_policy,
6647                                             elements_item,
6648                                             check_deleted=False,
6649                                         )
6650                                     )
6651                                     + delvals_regex,
6652                                     policy_file_data,
6653                                 ):
6654                                     configured_value = _getDataFromRegPolData(
6655                                         _processValueItem(
6656                                             child_item,
6657                                             child_key,
6658                                             child_valuename,
6659                                             admx_policy,
6660                                             elements_item,
6661                                             check_deleted=False,
6662                                         ),
6663                                         policy_file_data,
6664                                         return_value_name=return_value_name,
6665                                     )
6666                                     configured_elements[
6667                                         this_element_name
6668                                     ] = configured_value
6669                                     log.trace(
6670                                         "element %s is enabled values: %s",
6671                                         child_item.attrib["id"],
6672                                         configured_value,
6673                                     )
6674                                 elif _regexSearchRegPolData(
6675                                     re.escape(
6676                                         _processValueItem(
6677                                             child_item,
6678                                             child_key,
6679                                             child_valuename,
6680                                             admx_policy,
6681                                             elements_item,
6682                                             check_deleted=True,
6683                                         )
6684                                     ),
6685                                     policy_file_data,
6686                                 ):
6687                                     configured_elements[this_element_name] = "Disabled"
6688                                     policy_disabled_elements = (
6689                                         policy_disabled_elements + 1
6690                                     )
6691                                     log.trace(
6692                                         "element %s is disabled",
6693                                         child_item.attrib["id"],
6694                                     )
6695                     if element_only_enabled_disabled:
6696                         if len(required_elements.keys()) &gt; 0 and len(
6697                             configured_elements.keys()
6698                         ) == len(required_elements.keys()):
6699                             if policy_disabled_elements == len(
6700                                 required_elements.keys()
6701                             ):
6702                                 log.trace(
6703                                     "%s is disabled by all enum elements",
6704                                     this_policyname,
6705                                 )
6706                                 if this_policynamespace not in policy_vals:
6707                                     policy_vals[this_policynamespace] = {}
6708                                 policy_vals[this_policynamespace][
6709                                     this_policyname
6710                                 ] = "Disabled"
6711                             else:
6712                                 if this_policynamespace not in policy_vals:
6713                                     policy_vals[this_policynamespace] = {}
6714                                 policy_vals[this_policynamespace][
6715                                     this_policyname
6716                                 ] = configured_elements
6717                                 log.trace(
6718                                     "%s is enabled by enum elements", this_policyname
6719                                 )
6720                     else:
6721                         if this_policy_setting == "Enabled":
6722                             if this_policynamespace not in policy_vals:
6723                                 policy_vals[this_policynamespace] = {}
6724                             policy_vals[this_policynamespace][
6725                                 this_policyname
6726                             ] = configured_elements
6727             if (
6728                 return_full_policy_names
6729                 and this_policynamespace in policy_vals
6730                 and this_policyname in policy_vals[this_policynamespace]
6731             ):
6732                 if this_policynamespace not in full_names:
6733                     full_names[this_policynamespace] = {}
6734                 full_names[this_policynamespace][this_policyname] = _getFullPolicyName(
6735                     policy_item=admx_policy,
6736                     policy_name=admx_policy.attrib["name"],
6737                     return_full_policy_names=return_full_policy_names,
6738                     adml_language=adml_language,
6739                 )
6740                 if (
6741                     this_policyname
6742                     in policy_vals[this_policynamespace][this_policyname]
6743                 ):
6744                     full_name = full_names[this_policynamespace][this_policyname]
6745                     setting = policy_vals[this_policynamespace][this_policyname].pop(
6746                         this_policyname
6747                     )
6748                     policy_vals[this_policynamespace][this_policyname][
6749                         full_name
6750                     ] = setting
6751             if (
6752                 this_policynamespace in policy_vals
6753                 and this_policyname in policy_vals[this_policynamespace]
6754             ):
6755                 if this_policynamespace not in hierarchy:
6756                     hierarchy[this_policynamespace] = {}
6757                 hierarchy[this_policynamespace][this_policyname] = _build_parent_list(
6758                     policy_definition=admx_policy,
6759                     return_full_policy_names=return_full_policy_names,
6760                     adml_language=adml_language,
6761                 )
6762         log.trace("Examination complete: %s seconds", time.time() - start_time)
6763     if policy_vals and return_full_policy_names and not hierarchical_return:
6764         log.debug("Compiling non hierarchical return...")
6765         start_time = time.time()
6766         unpathed_dict = {}
6767         pathed_dict = {}
6768         for policy_namespace in list(policy_vals):
6769             for policy_item in list(policy_vals[policy_namespace]):
6770                 if (
6771                     full_names[policy_namespace][policy_item]
6772                     in policy_vals[policy_namespace]
6773                 ):
6774                     full_path_list = hierarchy[policy_namespace][policy_item]
6775                     full_path_list.reverse()
6776                     full_path_list.append(full_names[policy_namespace][policy_item])
6777                     policy_vals["\\".join(full_path_list)] = policy_vals[
6778                         policy_namespace
6779                     ].pop(policy_item)
6780                     pathed_dict[full_names[policy_namespace][policy_item]] = True
6781                 else:
6782                     policy_vals[policy_namespace][
6783                         full_names[policy_namespace][policy_item]
6784                     ] = policy_vals[policy_namespace].pop(policy_item)
6785                     if policy_namespace not in unpathed_dict:
6786                         unpathed_dict[policy_namespace] = {}
6787                     unpathed_dict[policy_namespace][
6788                         full_names[policy_namespace][policy_item]
6789                     ] = policy_item
6790             if policy_namespace in unpathed_dict:
6791                 for path_needed in unpathed_dict[policy_namespace]:
6792                     full_path_list = hierarchy[policy_namespace][
6793                         unpathed_dict[policy_namespace][path_needed]
6794                     ]
6795                     full_path_list.reverse()
6796                     full_path_list.append(path_needed)
6797                     log.trace("full_path_list == %s", full_path_list)
6798                     policy_vals["\\".join(full_path_list)] = policy_vals[
6799                         policy_namespace
6800                     ].pop(path_needed)
6801         log.trace("Compilation complete: %s seconds", time.time() - start_time)
6802     for policy_namespace in list(policy_vals):
6803         if policy_vals[policy_namespace] == {}:
6804             policy_vals.pop(policy_namespace)
6805     if policy_vals and hierarchical_return:
6806         if hierarchy:
6807             log.debug("Compiling hierarchical return...")
6808             start_time = time.time()
6809             for policy_namespace in hierarchy:
6810                 for hierarchy_item in hierarchy[policy_namespace]:
6811                     if hierarchy_item in policy_vals[policy_namespace]:
6812                         tdict = {}
6813                         first_item = True
6814                         for item in hierarchy[policy_namespace][hierarchy_item]:
6815                             newdict = {}
6816                             if first_item:
6817                                 h_policy_name = hierarchy_item
6818                                 if return_full_policy_names:
6819                                     h_policy_name = full_names[policy_namespace][
6820                                         hierarchy_item
6821                                     ]
6822                                 newdict[item] = {
6823                                     h_policy_name: policy_vals[policy_namespace].pop(
6824                                         hierarchy_item
6825                                     )
6826                                 }
6827                                 first_item = False
6828                             else:
6829                                 newdict[item] = tdict
6830                             tdict = newdict
6831                         if tdict:
6832                             policy_vals = dictupdate.update(policy_vals, tdict)
6833                 if (
6834                     policy_namespace in policy_vals
6835                     and policy_vals[policy_namespace] == {}
6836                 ):
6837                     policy_vals.pop(policy_namespace)
6838             log.trace("Compilation complete: %s seconds", time.time() - start_time)
6839         policy_vals = {
6840             module_policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
6841                 "Administrative Templates": policy_vals
6842             }
6843         }
6844     return policy_vals
6845 def _build_parent_list(policy_definition, return_full_policy_names, adml_language):
6846     """
6847     helper function to build a list containing parent elements of the ADMX
6848     policy
6849     """
6850     parent_list = []
6851     policy_namespace = next(iter(policy_definition.nsmap))
6852     parent_category = policy_definition.xpath(
6853         "{}:parentCategory/@ref".format(policy_namespace),
6854         namespaces=policy_definition.nsmap,
6855     )
6856     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6857     if parent_category:
6858         parent_category = parent_category[0]
6859         nsmap_xpath = "/policyDefinitions/policyNamespaces/{}:*".format(
6860             policy_namespace
6861         )
6862         this_namespace_map = _buildElementNsmap(
6863             admx_policy_definitions.xpath(
6864                 nsmap_xpath, namespaces=policy_definition.nsmap
6865             )
6866         )
6867         this_namespace_map = dictupdate.update(
6868             this_namespace_map, policy_definition.nsmap
6869         )
6870         parent_list = _admx_policy_parent_walk(
6871             path=parent_list,
6872             policy_namespace=policy_namespace,
6873             parent_category=parent_category,
6874             policy_nsmap=this_namespace_map,
6875             return_full_policy_names=return_full_policy_names,
6876             adml_language=adml_language,
6877         )
6878     return parent_list
6879 def _admx_policy_parent_walk(
6880     path,
6881     policy_namespace,
6882     parent_category,
6883     policy_nsmap,
6884     return_full_policy_names,
6885     adml_language,
6886 ):
6887     """
6888     helper function to recursively walk up the ADMX namespaces and build the
6889     hierarchy for the policy
6890     """
6891     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6892     category_xpath_string = '/policyDefinitions/categories/{}:category[@name="{}"]'
6893     using_xpath_string = "/policyDefinitions/policyNamespaces/{}:using"
6894         policy_namespace = parent_category.split(":")[0]
6895         parent_category = parent_category<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.split(":")[1]
6896         using_xpath_string = using_xpath_string.format(policy_namespace)
6897         policy_nsmap = dictupdate.update(
6898             policy_nsmap,
6899             _buildElementNsmap(
6900                 admx_policy_definitions.xpath(</b></font>
6901                     using_xpath_string, namespaces=policy_nsmap
6902                 )
6903             ),
6904         )
6905     category_xpath_string = category_xpath_string.format(
6906         policy_namespace, parent_category
6907     )
6908     if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):
6909         tparent_category = admx_policy_definitions.xpath(
6910             category_xpath_string, namespaces=policy_nsmap
6911         )[0]
6912         this_parent_name = _getFullPolicyName(
6913             policy_item=tparent_category,
6914             policy_name=tparent_category.attrib["name"],
6915             return_full_policy_names=return_full_policy_names,
6916             adml_language=adml_language,
6917         )
6918         path.append(this_parent_name)
6919         if tparent_category.xpath(
6920             "{}:parentCategory/@ref".format(policy_namespace), namespaces=policy_nsmap
6921         ):
6922             path = _admx_policy_parent_walk(
6923                 path=path,
6924                 policy_namespace=policy_namespace,
6925                 parent_category=tparent_category.xpath(
6926                     "{}:parentCategory/@ref".format(policy_namespace),
6927                     namespaces=policy_nsmap,
6928                 )[0],
6929                 policy_nsmap=policy_nsmap,
6930                 return_full_policy_names=return_full_policy_names,
6931                 adml_language=adml_language,
6932             )
6933     return path
6934 def _read_regpol_file(reg_pol_path):
6935     """
6936     helper function to read a reg policy file and return decoded data
6937     """
6938     returndata = None
6939     if os.path.exists(reg_pol_path):
6940         with salt.utils.files.fopen(reg_pol_path, "rb") as pol_file:
6941             returndata = pol_file.read()
6942     return returndata
6943 def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):
6944     """
6945     helper function to do a search of Policy data from a registry.pol file
6946     for a policy_regpath and policy_regkey combo
6947     """
6948     if policy_data:
6949         regex_str = [
6950             r"(\*",
6951             r"\*",
6952             "D",
6953             "e",
6954             "l",
6955             r"\.",
6956             r"|\*",
6957             r"\*",
6958             "D",
6959             "e",
6960             "l",
6961             "V",
6962             "a",
6963             "l",
6964             "s",
6965             r"\.",
6966             "){0,1}",
6967         specialValueRegex = "\x00".join(regex_str)
6968         specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)
6969         _thisSearch = b""<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.join(
6970             [
6971                 salt.utils.stringutils.to_bytes(r"\["),
6972                 re.escape(policy_regpath),
6973                 b"\x00;\x00",
6974                 specialValueRegex,
6975                 re.escape(policy_regkey.</b></font>lstrip(b"\x00")),
6976                 b"\x00;",
6977             ]
6978         )
6979         match = re.search(_thisSearch, policy_data, re.IGNORECASE)
6980         if match:
6981             return policy_data[
6982                 match.start() : (policy_data.index(b"]", match.end())) + 2
6983             ]
6984     return None
6985 def _write_regpol_data(
6986     data_to_write, policy_file_path, gpt_ini_path, gpt_extension, gpt_extension_guid
6987 ):
6988     """
6989     helper function to actually write the data to a Registry.pol file
6990     also updates/edits the gpt.ini file to include the ADM policy extensions
6991     to let the computer know user and/or machine registry policy files need
6992     to be processed
6993     data_to_write: data to write into the user/machine registry.pol file
6994     policy_file_path: path to the registry.pol file
6995     gpt_ini_path: path to gpt.ini file
6996     gpt_extension: gpt extension list name from _policy_info class for this registry class gpt_extension_location
6997     gpt_extension_guid: admx registry extension guid for the class
6998     """
6999     if not os.path.exists(policy_file_path):
7000         __salt__["file.makedirs"](policy_file_path)
7001     try:
7002         with salt.utils.files.fopen(policy_file_path, "wb") as pol_file:
7003             reg_pol_header = "\u5250\u6765\x01\x00".encode("utf-16-le")
7004             if not data_to_write.startswith(reg_pol_header):
7005                 pol_file.write(reg_pol_header)
7006             pol_file.write(data_to_write)
7007     except Exception as e:  # pylint: disable=broad-except
7008         msg = (
7009             "An error occurred attempting to write to {}, the exception was: {}".format(
7010                 policy_file_path, e
7011             )
7012         )
7013         log.exception(msg)
7014         raise CommandExecutionError(msg)
7015     gpt_ini_data = ""
7016     if os.path.exists(gpt_ini_path):
7017         with salt.utils.files.fopen(gpt_ini_path, "r") as gpt_file:
7018             gpt_ini_data = gpt_file.read()
7019         gpt_ini_data = (
7020             gpt_ini_data.replace("\r\n", "_|-")
7021             .replace("\n", "_|-")
7022             .replace("_|-", "\r\n")
7023         )
7024     if not _regexSearchRegPolData(r"\[General\]\r\n", gpt_ini_data):
7025         gpt_ini_data = "[General]\r\n" + gpt_ini_data
7026     if _regexSearchRegPolData(r"{}=".format(re.escape(gpt_extension)), gpt_ini_data):
7027         gpt_ext_loc = re.search(
7028             r"^{}=.*\r\n".format(re.escape(gpt_extension)),
7029             gpt_ini_data,
7030             re.IGNORECASE | re.MULTILINE,
7031         )
7032         gpt_ext_str = gpt_ini_data[gpt_ext_loc.start() : gpt_ext_loc.end()]
7033         if not _regexSearchRegPolData(
7034             r"{}".format(re.escape(gpt_extension_guid)), gpt_ext_str
7035         ):
7036             gpt_ext_str = gpt_ext_str.split("=")
7037             gpt_ext_str[1] = gpt_extension_guid + gpt_ext_str[1]
7038             gpt_ext_str = "=".join(gpt_ext_str)
7039             gpt_ini_data = (
7040                 gpt_ini_data[0 : gpt_ext_loc.start()]
7041                 + gpt_ext_str
7042                 + gpt_ini_data[gpt_ext_loc.end() :]
7043     else:
7044         general_location = re.search(
7045             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.MULTILINE
7046         )
7047         gpt_ini_data = "{}{}={}\r\n{}".format(
7048             gpt_ini_data[general_location.start() : general_location.end()],
7049             gpt_extension,
7050             gpt_extension_guid,
7051             gpt_ini_data[general_location.end(</b></font>) :],
7052         )
7053     if _regexSearchRegPolData(r"Version=", gpt_ini_data):
7054         version_loc = re.search(
7055             r"^Version=.*\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
7056         )
7057         version_str = gpt_ini_data[version_loc.start() : version_loc.end()]
7058         version_str = version_str.split("=")
7059         version_nums = struct.unpack(b"&gt;2H", struct.pack(b"&gt;I", int(version_str[1])))
7060         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
7061             version_nums = (version_nums[0], version_nums[1] + 1)
7062         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
7063             version_nums = (version_nums[0] + 1, version_nums[1])
7064         version_num = struct.unpack(b"&gt;I", struct.pack(b"&gt;2H", *version_nums))[0]
7065         gpt_ini_data = "{}{}={}\r\n{}".format(
7066             gpt_ini_data[0 : version_loc.start()],
7067             "Version",
7068             version_num,
7069             gpt_ini_data[version_loc.end() :],
7070         )
7071     else:
7072         general_location = re.search(
7073             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
7074         )
7075         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
7076             version_nums = (0, 1)
7077         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
7078             version_nums = (1, 0)
7079         gpt_ini_data = "{}{}={}\r\n{}".format(
7080             gpt_ini_data[general_location.start() : general_location.end()],
7081             "Version",
7082             int(
7083                 "{}{}".format(
7084                     str(version_nums[0]).zfill(4),
7085                     str(version_nums[1]).zfill(4),
7086                 ),
7087                 16,
7088             ),
7089             gpt_ini_data[general_location.end() :],
7090         )
7091     if gpt_ini_data:
7092         try:
7093             with salt.utils.files.fopen(gpt_ini_path, "w") as gpt_file:
7094                 gpt_file.write(gpt_ini_data)
7095         except Exception as e:  # pylint: disable=broad-except
7096             msg = (
7097                 "An error occurred attempting to write the gpg.ini file.\n"
7098                 "path: {}\n"
7099                 "exception: {}".format(gpt_ini_path, e)
7100             )
7101             log.exception(msg)
7102             raise CommandExecutionError(msg)
7103 def _policyFileReplaceOrAppendList(string_list, policy_data):
7104     """
7105     helper function to take a list of strings for registry.pol file data and
7106     update existing strings or append the strings
7107     """
7108     if not policy_data:
7109         policy_data = b""
7110     specialValueRegex = salt.utils.stringutils.to_bytes(
7111         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
7112     )
7113     for this_string in string_list:
7114         list_item_key = this_string.split(b"\00;")[0].lstrip(b"[")
7115         list_item_value_name = re.sub(
7116             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
7117         )
7118         log.trace("item value name is %s", list_item_value_name)
7119         data_to_replace = _regexSearchKeyValueCombo(
7120             policy_data, list_item_key, list_item_value_name
7121         )
7122         if data_to_replace:
7123             log.trace("replacing %s with %s", data_to_replace, this_string)
7124             policy_data = policy_data.replace(data_to_replace, this_string)
7125         else:
7126             log.trace("appending %s", this_string)
7127             policy_data = b"".join([policy_data, this_string])
7128     return policy_data
7129 def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):
7130     """
7131     helper function to take a ADMX policy string for registry.pol file data and
7132     update existing string or append the string to the data
7133     """
7134     if not policy_data:
7135         policy_data = b""
7136     specialValueRegex = salt.utils.stringutils.to_bytes(
7137         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
7138     )
7139     item_key = None
7140     item_value_name = None
7141     data_to_replace = None
7142     if not append_only:
7143         item_key = this_string.split(b"\00;")[0].lstrip(b"[")
7144         item_value_name = re.sub(
7145             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
7146         )
7147         log.trace("item value name is %s", item_value_name)
7148         data_to_replace = _regexSearchKeyValueCombo(
7149             policy_data, item_key, item_value_name
7150         )
7151     if data_to_replace:
7152         log.trace("replacing %s with %s", data_to_replace, this_string)
7153         policy_data = policy_data.replace(data_to_replace, this_string)
7154     else:
7155         log.trace("appending %s", this_string)
7156         policy_data = b"".join([policy_data, this_string])
7157     return policy_data
7158 def _writeAdminTemplateRegPolFile(
7159     admtemplate_data, adml_language="en-US", registry_class="Machine"
7160 ):
7161     r"""
7162     helper function to prep/write adm template data to the Registry.pol file
7163     each file begins with REGFILE_SIGNATURE (u'\u5250\u6765') and
7164     REGISTRY_FILE_VERSION (u'\x01\00')
7165     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
7166     +    https://msdn.microsoft.com/en-us/library/cc232696.aspx
7167     [Registry Path&lt;NULL&gt;;Reg Value&lt;NULL&gt;;Reg Type;SizeInBytes;Data&lt;NULL&gt;]
7168     """
7169     existing_data = b""
7170     policy_data = _policy_info()
7171     policySearchXpath = '//ns1:*[@id = "{0}" or @name = "{0}"]'
7172     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7173     adml_policy_resources = _get_policy_resources(language=adml_language)
7174     base_policy_settings = _checkAllAdmxPolicies(
7175         policy_class=registry_class,
7176         adml_language=adml_language,
7177         return_full_policy_names=False,
7178         hierarchical_return=False,
7179         return_not_configured=False,
7180     )
7181     for adm_namespace in admtemplate_data:
7182         for adm_policy in admtemplate_data[adm_namespace]:
7183             if (
7184                 str(admtemplate_data[adm_namespace][adm_policy]).lower()
7185                 == "not configured"
7186             ):
7187                 if (
7188                     base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None)
7189                     is not None
7190                 ):
7191                     log.trace('Policy "%s" removed', adm_policy)
7192             else:
7193                 log.trace("adding %s to base_policy_settings", adm_policy)
7194                 if adm_namespace not in base_policy_settings:
7195                     base_policy_settings[adm_namespace] = {}
7196                 base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[
7197                     adm_namespace
7198                 ][adm_policy]
7199     for adm_namespace in base_policy_settings:
7200         for admPolicy in base_policy_settings[adm_namespace]:
7201             log.trace("working on admPolicy %s", admPolicy)
7202             explicit_enable_disable_value_setting = False
7203             this_key = None
7204             this_valuename = None
7205             if (
7206                 str(base_policy_settings[adm_namespace][admPolicy]).lower()
7207                 == "disabled"
7208             ):
7209                 log.trace("time to disable %s", admPolicy)
7210                 this_policy = admx_policy_definitions.xpath(
7211                     policySearchXpath.format(admPolicy),
7212                     namespaces={"ns1": adm_namespace},
7213                 )
7214                 if this_policy:
7215                     this_policy = this_policy[0]
7216                     if "class" in this_policy.attrib:
7217                         if (
7218                             this_policy.attrib["class"] == registry_class
7219                             or this_policy.attrib["class"] == "Both"
7220                         ):
7221                             if "key" in this_policy.attrib:
7222                                 this_key = this_policy.attrib["key"]
7223                             else:
7224                                 log.error(
7225                                     "policy item %s does not have "
7226                                     'the required "key" attribute',
7227                                     this_policy.attrib,
7228                                 )
7229                                 break
7230                             if "valueName" in this_policy.attrib:
7231                                 this_valuename = this_policy.attrib["valueName"]
7232                             if DISABLED_VALUE_XPATH(this_policy):
7233                                 explicit_enable_disable_value_setting = True
7234                                 disabled_value_string = _checkValueItemParent(
7235                                     this_policy,
7236                                     admPolicy,
7237                                     this_key,
7238                                     this_valuename,
7239                                     DISABLED_VALUE_XPATH,
7240                                     None,
7241                                     check_deleted=False,
7242                                     test_item=False,
7243                                 )
7244                                 existing_data = _policyFileReplaceOrAppend(
7245                                     disabled_value_string, existing_data
7246                                 )
7247                             if DISABLED_LIST_XPATH(this_policy):
7248                                 explicit_enable_disable_value_setting = True
7249                                 disabled_list_strings = _checkListItem(
7250                                     this_policy,
7251                                     admPolicy,
7252                                     this_key,
7253                                     DISABLED_LIST_XPATH,
7254                                     None,
7255                                     test_items=False,
7256                                 )
7257                                 log.trace(
7258                                     "working with disabledList portion of %s",
7259                                     admPolicy,
7260                                 )
7261                                 existing_data = _policyFileReplaceOrAppendList(
7262                                     disabled_list_strings, existing_data
7263                                 )
7264                             if (
7265                                 not explicit_enable_disable_value_setting
7266                                 and this_valuename
7267                             ):
7268                                 disabled_value_string = _buildKnownDataSearchString(
7269                                     this_key,
7270                                     this_valuename,
7271                                     "REG_DWORD",
7272                                     None,
7273                                     check_deleted=True,
7274                                 )
7275                                 existing_data = _policyFileReplaceOrAppend(
7276                                     disabled_value_string, existing_data
7277                                 )
7278                             if ELEMENTS_XPATH(this_policy):
7279                                 log.trace("checking elements of %s", admPolicy)
7280                                 for elements_item in ELEMENTS_XPATH(this_policy):
7281                                     for child_item in elements_item:
7282                                         child_key = this_key
7283                                         child_valuename = this_valuename
7284                                         if "key" in child_item.attrib:
7285                                             child_key = child_item.attrib["key"]
7286                                         if "valueName" in child_item.attrib:
7287                                             child_valuename = child_item.attrib[
7288                                                 "valueName"
7289                                             ]
7290                                         if etree.QName(
7291                                             child_item
7292                                         ).localname == "boolean" and (
7293                                             TRUE_LIST_XPATH(child_item)
7294                                             or FALSE_LIST_XPATH(child_item)
7295                                         ):
7296                                             temp_dict = {
7297                                                 "trueList": TRUE_LIST_XPATH,
7298                                                 "falseList": FALSE_LIST_XPATH,
7299                                             }
7300                                             for this_list in temp_dict:
7301                                                 disabled_list_strings = _checkListItem(
7302                                                     child_item,
7303                                                     admPolicy,
7304                                                     child_key,
7305                                                     temp_dict[this_list],
7306                                                     None,
7307                                                     test_items=False,
7308                                                 )
7309                                                 log.trace(
7310                                                     "working with %s portion of %s",
7311                                                     admPolicy,
7312                                                     this_list,
7313                                                 )
7314                                                 existing_data = (
7315                                                     _policyFileReplaceOrAppendList(
7316                                                         disabled_list_strings,
7317                                                         existing_data,
7318                                                     )
7319                                                 )
7320                                         elif (
7321                                             etree.QName(child_item).localname
7322                                             == "boolean"
7323                                             or etree.QName(child_item).localname
7324                                             == "decimal"
7325                                             or etree.QName(child_item).localname
7326                                             == "text"
7327                                             or etree.QName(child_item).localname
7328                                             == "longDecimal"
7329                                             or etree.QName(child_item).localname
7330                                             == "multiText"
7331                                             or etree.QName(child_item).localname
7332                                             == "enum"
7333                                         ):
7334                                             disabled_value_string = _processValueItem(
7335                                                 child_item,
7336                                                 child_key,
7337                                                 child_valuename,
7338                                                 this_policy,
7339                                                 elements_item,
7340                                                 check_deleted=True,
7341                                             )
7342                                             log.trace(
7343                                                 "I have disabled value string of %s",
7344                                                 disabled_value_string,
7345                                             )
7346                                             existing_data = _policyFileReplaceOrAppend(
7347                                                 disabled_value_string, existing_data
7348                                             )
7349                                         elif (
7350                                             etree.QName(child_item).localname == "list"
7351                                         ):
7352                                             disabled_value_string = _processValueItem(
7353                                                 child_item,
7354                                                 child_key,
7355                                                 child_valuename,
7356                                                 this_policy,
7357                                                 elements_item,
7358                                                 check_deleted=True,
7359                                             )
7360                                             log.trace(
7361                                                 "I have disabled value string of %s",
7362                                                 disabled_value_string,
7363                                             )
7364                                             existing_data = _policyFileReplaceOrAppend(
7365                                                 disabled_value_string, existing_data
7366                                             )
7367                         else:
7368                             log.error(
7369                                 "policy %s was found but it does not appear to be valid"
7370                                 " for the class %s",
7371                                 admPolicy,
7372                                 registry_class,
7373                             )
7374                     else:
7375                         log.error(
7376                             'policy item %s does not have the required "class"'
7377                             " attribute",
7378                             this_policy.attrib,
7379                         )
7380             else:
7381                 log.trace('time to enable and set the policy "%s"', admPolicy)
7382                 this_policy = admx_policy_definitions.xpath(
7383                     policySearchXpath.format(admPolicy),
7384                     namespaces={"ns1": adm_namespace},
7385                 )
7386                 log.trace("found this_policy == %s", this_policy)
7387                 if this_policy:
7388                     this_policy = this_policy[0]
7389                     if "class" in this_policy.attrib:
7390                         if (
7391                             this_policy.attrib["class"] == registry_class
7392                             or this_policy.attrib["class"] == "Both"
7393                         ):
7394                             if "key" in this_policy.attrib:
7395                                 this_key = this_policy.attrib["key"]
7396                             else:
7397                                 log.error(
7398                                     'policy item %s does not have the required "key"'
7399                                     " attribute",
7400                                     this_policy.attrib,
7401                                 )
7402                                 break
7403                             if "valueName" in this_policy.attrib:
7404                                 this_valuename = this_policy.attrib["valueName"]
7405                             if ENABLED_VALUE_XPATH(this_policy):
7406                                 explicit_enable_disable_value_setting = True
7407                                 enabled_value_string = _checkValueItemParent(
7408                                     this_policy,
7409                                     admPolicy,
7410                                     this_key,
7411                                     this_valuename,
7412                                     ENABLED_VALUE_XPATH,
7413                                     None,
7414                                     check_deleted=False,
7415                                     test_item=False,
7416                                 )
7417                                 existing_data = _policyFileReplaceOrAppend(
7418                                     enabled_value_string, existing_data
7419                                 )
7420                             if ENABLED_LIST_XPATH(this_policy):
7421                                 explicit_enable_disable_value_setting = True
7422                                 enabled_list_strings = _checkListItem(
7423                                     this_policy,
7424                                     admPolicy,
7425                                     this_key,
7426                                     ENABLED_LIST_XPATH,
7427                                     None,
7428                                     test_items=False,
7429                                 )
7430                                 log.trace(
7431                                     "working with enabledList portion of %s", admPolicy
7432                                 )
7433                                 existing_data = _policyFileReplaceOrAppendList(
7434                                     enabled_list_strings, existing_data
7435                                 )
7436                             if (
7437                                 not explicit_enable_disable_value_setting
7438                                 and this_valuename
7439                             ):
7440                                 enabled_value_string = _buildKnownDataSearchString(
7441                                     this_key,
7442                                     this_valuename,
7443                                     "REG_DWORD",
7444                                     "1",
7445                                     check_deleted=False,
7446                                 )
7447                                 existing_data = _policyFileReplaceOrAppend(
7448                                     enabled_value_string, existing_data
7449                                 )
7450                             if ELEMENTS_XPATH(this_policy):
7451                                 for elements_item in ELEMENTS_XPATH(this_policy):
7452                                     for child_item in elements_item:
7453                                         child_key = this_key
7454                                         child_valuename = this_valuename
7455                                         if "key" in child_item.attrib:
7456                                             child_key = child_item.attrib["key"]
7457                                         if "valueName" in child_item.attrib:
7458                                             child_valuename = child_item.attrib[
7459                                                 "valueName"
7460                                             ]
7461                                         if (
7462                                             child_item.attrib["id"]
7463                                             in base_policy_settings[adm_namespace][
7464                                                 admPolicy
7465                                             ]
7466                                         ):
7467                                             if etree.QName(
7468                                                 child_item
7469                                             ).localname == "boolean" and (
7470                                                 TRUE_LIST_XPATH(child_item)
7471                                                 or FALSE_LIST_XPATH(child_item)
7472                                             ):
7473                                                 list_strings = []
7474                                                 if base_policy_settings[adm_namespace][
7475                                                     admPolicy
7476                                                 ][child_item.attrib["id"]]:
7477                                                     list_strings = _checkListItem(
7478                                                         child_item,
7479                                                         admPolicy,
7480                                                         child_key,
7481                                                         TRUE_LIST_XPATH,
7482                                                         None,
7483                                                         test_items=False,
7484                                                     )
7485                                                     log.trace(
7486                                                         "working with trueList portion"
7487                                                         " of %s",
7488                                                         admPolicy,
7489                                                     )
7490                                                 else:
7491                                                     list_strings = _checkListItem(
7492                                                         child_item,
7493                                                         admPolicy,
7494                                                         child_key,
7495                                                         FALSE_LIST_XPATH,
7496                                                         None,
7497                                                         test_items=False,
7498                                                     )
7499                                                 existing_data = (
7500                                                     _policyFileReplaceOrAppendList(
7501                                                         list_strings, existing_data
7502                                                     )
7503                                                 )
7504                                             elif etree.QName(
7505                                                 child_item
7506                                             ).localname == "boolean" and (
7507                                                 TRUE_VALUE_XPATH(child_item)
7508                                                 or FALSE_VALUE_XPATH(child_item)
7509                                             ):
7510                                                 value_string = ""
7511                                                 if base_policy_settings[adm_namespace][
7512                                                     admPolicy
7513                                                 ][child_item.attrib["id"]]:
7514                                                     value_string = (
7515                                                         _checkValueItemParent(
7516                                                             child_item,
7517                                                             admPolicy,
7518                                                             child_key,
7519                                                             child_valuename,
7520                                                             TRUE_VALUE_XPATH,
7521                                                             None,
7522                                                             check_deleted=False,
7523                                                             test_item=False,
7524                                                         )
7525                                                     )
7526                                                 else:
7527                                                     value_string = (
7528                                                         _checkValueItemParent(
7529                                                             child_item,
7530                                                             admPolicy,
7531                                                             child_key,
7532                                                             child_valuename,
7533                                                             FALSE_VALUE_XPATH,
7534                                                             None,
7535                                                             check_deleted=False,
7536                                                             test_item=False,
7537                                                     )
7538                                                 existing_data = (
7539                                                     _policyFileReplaceOrAppend<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(
7540                                                         value_string, existing_data
7541                                                     )
7542                                                 )
7543                                             elif (
7544                                                 etree.QName(child_item).localname
7545                                                 == "boolean"
7546                                                 or etree.QName(child_item).localname
7547                                                 == "decimal"
7548                                                 or etree.QName(child_item).localname
7549                                                 == "text"
7550                                                 or etree.QName(child_item).</b></font>localname
7551                                                 == "longDecimal"
7552                                                 or etree.QName(child_item).localname
7553                                                 == "multiText"
7554                                             ):
7555                                                 enabled_value_string = _processValueItem(
7556                                                     child_item,
7557                                                     child_key,
7558                                                     child_valuename,
7559                                                     this_policy,
7560                                                     elements_item,
7561                                                     check_deleted=False,
7562                                                     this_element_value=base_policy_settings[
7563                                                         adm_namespace
7564                                                     ][
7565                                                         admPolicy
7566                                                     ][
7567                                                         child_item.attrib["id"]
7568                                                     ],
7569                                                 )
7570                                                 log.trace(
7571                                                     "I have enabled value string of %s",
7572                                                     enabled_value_string,
7573                                                 )
7574                                                 existing_data = (
7575                                                     _policyFileReplaceOrAppend(
7576                                                         enabled_value_string,
7577                                                         existing_data,
7578                                                     )
7579                                                 )
7580                                             elif (
7581                                                 etree.QName(child_item).localname
7582                                                 == "enum"
7583                                             ):
7584                                                 for enum_item in child_item:
7585                                                     if (
7586                                                         base_policy_settings[
7587                                                             adm_namespace
7588                                                         ][admPolicy][
7589                                                             child_item.attrib["id"]
7590                                                         ]
7591                                                         == _getAdmlDisplayName(
7592                                                             adml_policy_resources,
7593                                                             enum_item.attrib[
7594                                                                 "displayName"
7595                                                             ],
7596                                                         ).strip()
7597                                                     ):
7598                                                         enabled_value_string = (
7599                                                             _checkValueItemParent(
7600                                                                 enum_item,
7601                                                                 child_item.attrib["id"],
7602                                                                 child_key,
7603                                                                 child_valuename,
7604                                                                 VALUE_XPATH,
7605                                                                 None,
7606                                                                 check_deleted=False,
7607                                                                 test_item=False,
7608                                                             )
7609                                                         )
7610                                                         existing_data = (
7611                                                             _policyFileReplaceOrAppend(
7612                                                                 enabled_value_string,
7613                                                                 existing_data,
7614                                                             )
7615                                                         )
7616                                                         if VALUE_LIST_XPATH(enum_item):
7617                                                             enabled_list_strings = (
7618                                                                 _checkListItem(
7619                                                                     enum_item,
7620                                                                     admPolicy,
7621                                                                     child_key,
7622                                                                     VALUE_LIST_XPATH,
7623                                                                     None,
7624                                                                     test_items=False,
7625                                                                 )
7626                                                             )
7627                                                             log.trace(
7628                                                                 "working with valueList"
7629                                                                 " portion of %s",
7630                                                                 child_item.attrib["id"],
7631                                                             )
7632                                                             existing_data = _policyFileReplaceOrAppendList(
7633                                                                 enabled_list_strings,
7634                                                                 existing_data,
7635                                                             )
7636                                                         break
7637                                             elif (
7638                                                 etree.QName(child_item).localname
7639                                                 == "list"
7640                                             ):
7641                                                 enabled_value_string = _processValueItem(
7642                                                     child_item,
7643                                                     child_key,
7644                                                     child_valuename,
7645                                                     this_policy,
7646                                                     elements_item,
7647                                                     check_deleted=False,
7648                                                     this_element_value=base_policy_settings[
7649                                                         adm_namespace
7650                                                     ][
7651                                                         admPolicy
7652                                                     ][
7653                                                         child_item.attrib["id"]
7654                                                     ],
7655                                                 )
7656                                                 log.trace(
7657                                                     "I have enabled value string of %s",
7658                                                     enabled_value_string,
7659                                                 )
7660                                                 existing_data = (
7661                                                     _policyFileReplaceOrAppend(
7662                                                         enabled_value_string,
7663                                                         existing_data,
7664                                                         append_only=True,
7665                                                     )
7666                                                 )
7667     try:
7668         _write_regpol_data(
7669             existing_data,
7670             policy_data.admx_registry_classes[registry_class]["policy_path"],
7671             policy_data.gpt_ini_path,
7672             policy_data.admx_registry_classes[registry_class]["gpt_extension_location"],
7673             policy_data.admx_registry_classes[registry_class]["gpt_extension_guid"],
7674         )
7675     except CommandExecutionError as exc:  # pylint: disable=broad-except
7676         log.exception(
7677             "Unhandled exception occurred while attempting to "
7678             "write Adm Template Policy File.\nException: %s",
7679             exc,
7680         )
7681         return False
7682     return True
7683 def _getScriptSettingsFromIniFile(policy_info):
7684     """
7685     helper function to parse/read a GPO Startup/Shutdown script file
7686     psscript.ini and script.ini file definitions are here
7687         https://msdn.microsoft.com/en-us/library/ff842529.aspx
7688         https://msdn.microsoft.com/en-us/library/dd303238.aspx
7689     """
7690     _existingData = None
7691     if os.path.isfile(policy_info["ScriptIni"]["IniPath"]):
7692         with salt.utils.files.fopen(policy_info["ScriptIni"]["IniPath"], "rb") as fhr:
7693             _existingData = fhr.read()
7694         if _existingData:
7695             try:
7696                 _existingData = deserialize(
7697                     _existingData.decode("utf-16-le").lstrip("\ufeff")
7698                 )
7699                 log.trace("Have deserialized data %s", _existingData)
7700             except Exception as error:  # pylint: disable=broad-except
7701                 log.exception(
7702                     "An error occurred attempting to deserialize data for %s",
7703                     policy_info["Policy"],
7704                 )
7705                 raise CommandExecutionError(error)
7706             if "Section" in policy_info["ScriptIni"] and policy_info["ScriptIni"][
7707                 "Section"
7708             ].lower() in [z.lower() for z in _existingData.keys()]:
7709                 if "SettingName" in policy_info["ScriptIni"]:
7710                     log.trace(
7711                         "Need to look for %s", policy_info["ScriptIni"]["SettingName"]
7712                     )
7713                     if policy_info["ScriptIni"]["SettingName"].lower() in [
7714                         z.lower()
7715                         for z in _existingData[
7716                             policy_info["ScriptIni"]["Section"]
7717                         ].keys()
7718                     ]:
7719                         return _existingData[policy_info["ScriptIni"]["Section"]][
7720                             policy_info["ScriptIni"]["SettingName"].lower()
7721                         ]
7722                     else:
7723                         return None
7724                 else:
7725                     return _existingData[policy_info["ScriptIni"]["Section"]]
7726             else:
7727                 return None
7728     return None
7729 def _writeGpoScript(psscript=False):
7730     """
7731     helper function to write local GPO startup/shutdown script
7732     scripts are stored in scripts.ini and psscripts.ini files in
7733     ``WINDIR\\System32\\GroupPolicy\\Machine|User\\Scripts``
7734     these files have the hidden attribute set
7735     files have following format:
7736         empty line
7737         [Startup]
7738         0CmdLine=&lt;path to script 0&gt;
7739         0Parameters=&lt;script 0 parameters&gt;
7740         [Shutdown]
7741         0CmdLine=&lt;path to shutdown script 0&gt;
7742         0Parameters=&lt;shutdown script 0 parameters&gt;
7743     Number is incremented for each script added
7744     psscript file also has the option of a [ScriptsConfig] section, which has
7745     the following two parameters:
7746         StartExecutePSFirst
7747         EndExecutePSFirst
7748     these can be set to True/False to denote if the powershell startup/shutdown
7749     scripts execute first (True) or last (False), if the value isn't set, then
7750     it is 'Not Configured' in the GUI
7751     """
7752     _machineScriptPolicyPath = os.path.join(
7753         os.getenv("WINDIR"),
7754         "System32",
7755         "GroupPolicy",
7756         "Machine",
7757         "Scripts",
7758         "scripts.ini",
7759     )
7760     _machinePowershellScriptPolicyPath = os.path.join(
7761         os.getenv("WINDIR"),
7762         "System32",
7763         "GroupPolicy",
7764         "Machine",
7765         "Scripts",
7766         "psscripts.ini",
7767     )
7768     _userScriptPolicyPath = os.path.join(
7769         os.getenv("WINDIR"), "System32", "GroupPolicy", "User", "Scripts", "scripts.ini"
7770     )
7771     _userPowershellScriptPolicyPath = os.path.join(
7772         os.getenv("WINDIR"),
7773         "System32",
7774         "GroupPolicy",
7775         "User",
7776         "Scripts",
7777         "psscripts.ini",
7778     )
7779 def _lookup_admin_template(policy_name, policy_class, adml_language="en-US"):
7780     """
7781     (success_flag, policy_xml_item, policy_name_list, message)
7782     """
7783     policy_aliases = []
7784     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7785     adml_policy_resources = _get_policy_resources(language=adml_language)
7786     admx_search_results = ADMX_SEARCH_XPATH(
7787         admx_policy_definitions, policy_name=policy_name, registry_class=policy_class
7788     )
7789     if admx_search_results:
7790         if len(admx_search_results) == 1:
7791             the_policy = admx_search_results[0]
7792             policy_display_name = _getFullPolicyName(
7793                 policy_item=the_policy,
7794                 policy_name=the_policy.attrib["name"],
7795                 return_full_policy_names=True,
7796                 adml_language=adml_language,
7797             )
7798             policy_aliases.append(policy_display_name)
7799             policy_aliases.append(the_policy.attrib["name"])
7800             full_path_list = _build_parent_list(
7801                 policy_definition=the_policy,
7802                 return_full_policy_names=True,
7803                 adml_language=adml_language,
7804             )
7805             full_path_list.reverse()
7806             full_path_list.append(policy_display_name)
7807             policy_aliases.append("\\".join(full_path_list))
7808             return True, the_policy, policy_aliases, None
7809         else:
7810             msg = 'ADMX policy name/id "{}" is used in multiple ADMX files'
7811             return False, None, [], msg
7812     else:
7813         adml_search_results = ADML_SEARCH_XPATH(
7814             adml_policy_resources, policy_name=policy_name
7815         )
7816         hierarchy = []
7817         hierarchy_policy_name = policy_name
7818         if not adml_search_results:
7819             log.warning("Trying another: %s", policy_name)
7820             if "\\" in policy_name:
7821                 hierarchy = policy_name.split("\\")
7822                 policy_name = hierarchy.pop()
7823                 adml_search_results = ADML_SEARCH_XPATH(
7824                     adml_policy_resources, policy_name=policy_name
7825                 )
7826         if adml_search_results:
7827             multiple_adml_entries = False
7828             suggested_policies = ""
7829             adml_to_remove = []
7830             if len(adml_search_results) &gt; 1:
7831                 log.trace(
7832                     "multiple ADML entries found matching the policy name %s",
7833                     policy_name,
7834                 )
7835                 multiple_adml_entries = True
7836                 for adml_search_result in adml_search_results:
7837                     if (
7838                         not getattr(adml_search_result, "text", "").strip()
7839                         == policy_name
7840                     ):
7841                         adml_to_remove.append(adml_search_result)
7842                     else:
7843                         if hierarchy:
7844                             log.trace("we have hierarchy of %s", hierarchy)
7845                             display_name_searchval = "$({}.{})".format(
7846                                 adml_search_result.tag.split("}")[1],
7847                                 adml_search_result.attrib["id"],
7848                             )
7849                             policy_search_string = (
7850                                 '//{}:policy[@displayName = "{}" and (@class = "Both"'
7851                                 ' or @class = "{}") ]'.format(
7852                                     adml_search_result.prefix,
7853                                     display_name_searchval,
7854                                     policy_class,
7855                                 )
7856                             )
7857                             admx_results = []
7858                             these_admx_search_results = admx_policy_definitions.xpath(
7859                                 policy_search_string,
7860                                 namespaces=adml_search_result.nsmap,
7861                             )
7862                             if not these_admx_search_results:
7863                                 log.trace(
7864                                     "No admx was found for the adml entry %s, it will"
7865                                     " be removed",
7866                                     display_name_searchval,
7867                                 )
7868                                 adml_to_remove.append(adml_search_result)
7869                             for search_result in these_admx_search_results:
7870                                 log.trace("policy_name == %s", policy_name)
7871                                 this_hierarchy = _build_parent_list(
7872                                     policy_definition=search_result,
7873                                     return_full_policy_names=True,
7874                                     adml_language=adml_language,
7875                                 )
7876                                 this_hierarchy.reverse()
7877                                 if hierarchy != this_hierarchy:
7878                                     log.trace(
7879                                         "hierarchy %s does not match this item's"
7880                                         " hierarchy of %s",
7881                                         hierarchy,
7882                                         this_hierarchy,
7883                                     )
7884                                     if len(these_admx_search_results) == 1:
7885                                         log.trace(
7886                                             "only 1 admx was found and it does not "
7887                                             "match this adml, it is safe to remove "
7888                                             "from the list"
7889                                         )
7890                                         adml_to_remove.append(adml_search_result)
7891                                 else:
7892                                     log.trace(
7893                                         "hierarchy %s matches item's hierarchy of %s",
7894                                         hierarchy,
7895                                         this_hierarchy,
7896                                     )
7897                                     log.trace(
7898                                         "search_result %s added to results",
7899                                         search_result,
7900                                     )
7901                                     admx_results.append(search_result)
7902                             if len(admx_results) == 1:
7903                                 admx_search_results.append(admx_results[0])
7904                         else:
7905                             display_name_searchval = "$({}.{})".format(
7906                                 adml_search_result.tag.split("}")[1],
7907                                 adml_search_result.attrib["id"],
7908                             )
7909                             these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7910                                 admx_policy_definitions,
7911                                 display_name=display_name_searchval,
7912                                 registry_class=policy_class,
7913                             )
7914                             if not these_admx_search_results:
7915                                 adml_to_remove.append(adml_search_result)
7916             for adml in adml_to_remove:
7917                 if adml in adml_search_results:
7918                     adml_search_results.remove(adml)
7919             if len(adml_search_results) == 1 and multiple_adml_entries:
7920                 multiple_adml_entries = False
7921             for adml_search_result in adml_search_results:
7922                 log.trace(
7923                     "found an ADML entry matching the string! %s -- %s",
7924                     adml_search_result.tag,
7925                     adml_search_result.attrib,
7926                 )
7927                 display_name_searchval = "$({}.{})".format(
7928                     adml_search_result.tag.split("}")[1],
7929                     adml_search_result.attrib["id"],
7930                 )
7931                 log.trace("searching for displayName == %s", display_name_searchval)
7932                 if not admx_search_results:
7933                     log.trace(
7934                         "search for an admx entry matching display_name %s and"
7935                         " registry_class %s",
7936                         display_name_searchval,
7937                         policy_class,
7938                     )
7939                     admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7940                         admx_policy_definitions,
7941                         display_name=display_name_searchval,
7942                         registry_class=policy_class,
7943                     )
7944                 if admx_search_results:
7945                     log.trace(
7946                         "processing admx_search_results of %s", admx_search_results
7947                     )
7948                     log.trace("multiple_adml_entries is %s", multiple_adml_entries)
7949                     if (
7950                         len(admx_search_results) == 1 or hierarchy
7951                     ) and not multiple_adml_entries:
7952                         found = False
7953                         for search_result in admx_search_results:
7954                             found = False
7955                             if hierarchy:
7956                                 this_hierarchy = _build_parent_list(
7957                                     policy_definition=search_result,
7958                                     return_full_policy_names=True,
7959                                     adml_language=adml_language,
7960                                 )
7961                                 this_hierarchy.reverse()
7962                                 log.trace("testing %s == %s", hierarchy, this_hierarchy)
7963                                 if hierarchy == this_hierarchy:
7964                                     found = True
7965                             else:
7966                                 found = True
7967                             if found:
7968                                 log.trace(
7969                                     "found the ADMX policy matching "
7970                                     "the display name %s -- %s",
7971                                     search_result,
7972                                     policy_name,
7973                                 )
7974                                 if "name" in search_result.attrib:
7975                                     policy_display_name = _getFullPolicyName(
7976                                         policy_item=search_result,
7977                                         policy_name=search_result.attrib["name"],
7978                                         return_full_policy_names=True,
7979                                         adml_language=adml_language,
7980                                     )
7981                                     policy_aliases.append(policy_display_name)
7982                                     policy_aliases.append(search_result.attrib["name"])
7983                                     full_path_list = _build_parent_list(
7984                                         policy_definition=search_result,
7985                                         return_full_policy_names=True,
7986                                         adml_language=adml_language,
7987                                     )
7988                                     full_path_list.reverse()
7989                                     full_path_list.append(policy_display_name)
7990                                     policy_aliases.append("\\".join(full_path_list))
7991                                     return True, search_result, policy_aliases, None
7992                                 else:
7993                                     msg = (
7994                                         "ADMX policy with the display name {} does not"
7995                                         "have the required name attribute"
7996                                     )
7997                                     msg = msg.format(policy_name)
7998                                     return False, None, [], msg
7999                         if not found:
8000                             msg = "Unable to correlate {} to any policy".format(
8001                                 hierarchy_policy_name
8002                             )
8003                             return False, None, [], msg
8004                     else:
8005                         for possible_policy in admx_search_results:
8006                             this_parent_list = _build_parent_list(
8007                                 policy_definition=possible_policy,
8008                                 return_full_policy_names=True,
8009                                 adml_language=adml_language,
8010                             )
8011                             this_parent_list.reverse()
8012                             this_parent_list.append(policy_name)
8013                             if suggested_policies:
8014                                 suggested_policies = ", ".join(
8015                                     [suggested_policies, "\\".join(this_parent_list)]
8016                                 )
8017                             else:
8018                                 suggested_policies = "\\".join(this_parent_list)
8019             if suggested_policies:
8020                 msg = (
8021                     'ADML policy name "{}" is used as the display name for '
8022                     "multiple policies. These policies matched: {}. You can "
8023                     "utilize these long names to specify the correct policy"
8024                 )
8025                 return False, None, [], msg.format(policy_name, suggested_policies)
8026     return (
8027         False,
8028         None,
8029         [],
8030         "Unable to find {} policy {}".format(policy_class, policy_name),
8031     )
8032 def get_policy_info(policy_name, policy_class, adml_language="en-US"):
8033     r"""
8034     Returns information about a specified policy
8035     Args:
8036         policy_name (str):
8037             The name of the policy to lookup
8038         policy_class (str):
8039             The class of policy, i.e. machine, user, both
8040         adml_language (str):
8041             The ADML language to use for Administrative Template data lookup
8042     Returns:
8043         dict: Information about the specified policy
8044     CLI Example:
8045     .. code-block:: bash
8046         salt '*' lgpo.get_policy_info 'Maximum password age' machine
8047     You can use ``lgpo.get_policy_info`` to get all the possible names that
8048     could be used in a state file or from the command line (along with elements
8049     that need to be set/etc). The key is to match the text you see in the
8050     ``gpedit.msc`` gui exactly, including quotes around words or phrases. The
8051     "full path" style is really only needed when there are multiple policies
8052     that use the same base name. For example, ``Access data sources across
8053     domains`` exists in ~10 different paths. If you put that through
8054     ``get_policy_info`` you'll get back a message that it is used for multiple
8055     policies and you need to be more specific.
8056     CLI Example:
8057     .. code-block:: bash
8058         salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine
8059         local:
8060             ----------
8061             message:
8062             policy_aliases:
8063                 - Turn off the "Order Prints" picture task
8064                 - ShellRemoveOrderPrints_2
8065                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
8066             policy_class:
8067                 machine
8068             policy_elements:
8069             policy_found:
8070                 True
8071             policy_name:
8072                 ShellRemoveOrderPrints_2
8073             rights_assignment:
8074                 False
8075     Escaping can get tricky in cmd/Powershell. The following is an example of
8076     escaping in Powershell using backquotes:
8077     .. code-block:: bash
8078         PS&gt;salt-call --local lgpo.get_policy_info "Turn off the `\`"Order Prints`\`" picture task" machine
8079         local:
8080             ----------
8081             message:
8082             policy_aliases:
8083                 - Turn off the "Order Prints" picture task
8084                 - ShellRemoveOrderPrints_2
8085                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
8086             policy_class:
8087                 machine
8088             policy_elements:
8089             policy_found:
8090                 True
8091             policy_name:
8092                 Turn off the "Order Prints" picture task
8093             rights_assignment:
8094                 False
8095     This function can then be used to get the options available for specifying
8096     Group Policy Objects to be used in state files. Based on the above any of
8097     these *should* be usable:
8098     .. code-block:: bash
8099         internet_communications_settings:
8100           lgpo.set:
8101             - computer_policy:
8102                 Turn off the "Order Prints" picture task: Enabled
8103     .. code-block:: bash
8104         internet_communications_settings:
8105           lgpo.set:
8106             - computer_policy:
8107                 ShellRemoveOrderPrints_2: Enabled
8108     When using the full path, it might be a good idea to use single quotes
8109     around the path:
8110     .. code-block:: bash
8111         internet_communications_settings:
8112           lgpo.set:
8113             - computer_policy:
8114                 'System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task': 'Enabled'
8115     If you struggle to find the policy from ``get_policy_info`` using the name
8116     as you see in ``gpedit.msc``, the names such as "ShellRemoveOrderPrints_2"
8117     come from the ``.admx`` files. If you know nothing about ``.admx/.adml``
8118     relationships (ADML holds what you see in the GUI, ADMX holds the more
8119     technical details), then this may be a little bit too much info, but here is
8120     an example with the above policy using Powershell:
8121     .. code-block:: bash
8122         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.adml | Select-String "Order Prints"
8123         C:\windows\PolicyDefinitions\en-US\ICM.adml:152:      &lt;string id="ShellRemoveOrderPrints"&gt;Turn off the "Order Prints" picture task&lt;/string&gt;
8124         C:\windows\PolicyDefinitions\en-US\ICM.adml:153:      &lt;string id="ShellRemoveOrderPrints_Help"&gt;This policy setting specifies whether the "Order Prints Online" task is available from Picture Tasks in Windows folders.
8125         C:\windows\PolicyDefinitions\en-US\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.
8126         C:\windows\PolicyDefinitions\en-US\ICM.adml:157:If you enable this policy setting, the task "Order Prints Online" is removed from Picture Tasks in File Explorer folders.
8127     From this grep, we can see id "ShellRemoveOrderPrints" is the ID of the
8128     string used to describe this policy, then we search for it in the ADMX:
8129     .. code-block:: bash
8130         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.admx | Select-String "ShellRemoveOrderPrints"
8131         C:\windows\PolicyDefinitions\ICM.admx:661:    &lt;policy name="ShellRemoveOrderPrints_1" class="User" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
8132         C:\windows\PolicyDefinitions\ICM.admx:671:    &lt;policy name="ShellRemoveOrderPrints_2" class="Machine" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
8133     Now we have two to pick from. And if you notice the ``class="Machine"`` and
8134     ``class="User"`` (which details if it is a computer policy or user policy
8135     respectively) the ``ShellRemoveOrderPrints_2`` is the "short name" we could
8136     use to pass through ``get_policy_info`` to see what the module itself is
8137     expecting.
8138     """
8139     ret = {
8140         "policy_name": policy_name,
8141         "policy_class": policy_class,
8142         "policy_aliases": [],
8143         "policy_found": False,
8144         "rights_assignment": False,
8145         "policy_elements": [],
8146         "message": "policy not found",
8147     }
8148     policy_class = policy_class.title()
8149     policy_data = _policy_info()
8150     if policy_class not in policy_data.policies.keys():
8151         policy_classes = ", ".join(policy_data.policies.keys())
8152         ret["message"] = (
8153             'The requested policy class "{}" is invalid, '
8154             "policy_class should be one of: {}"
8155             "".format(policy_class, policy_classes)
8156         )
8157         return ret
8158     if policy_name in policy_data.policies[policy_class]["policies"]:
8159         ret["policy_aliases"].append(
8160             policy_data.policies[policy_class]["policies"][policy_name]["Policy"]
8161         )
8162         ret["policy_found"] = True
8163         ret["message"] = ""
8164         if "LsaRights" in policy_data.policies[policy_class]["policies"][policy_name]:
8165             ret["rights_assignment"] = True
8166         return ret
8167     else:
8168         for pol in policy_data.policies[policy_class]["policies"]:
8169             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8170             if _p == policy_name:
8171                 ret["policy_aliases"].append(pol)
8172                 ret["policy_found"] = True
8173                 ret["message"] = ""
8174                 if "LsaRights" in policy_data.policies[policy_class]["policies"][pol]:
8175                     ret["rights_assignment"] = True
8176                 return ret
8177         for pol in policy_data.policies[policy_class]["policies"]:
8178             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8179             if _p.lower() == policy_name.lower():
8180                 ret["policy_aliases"].append(pol)
8181                 ret["policy_found"] = True
8182                 ret["message"] = ""
8183                 if "LsaRights" in policy_data.policies[policy_class]["policies"][pol]:
8184                     ret["rights_assignment"] = True
8185                 return ret
8186     success, policy_xml_item, policy_name_list, message = _lookup_admin_template(
8187         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
8188     )
8189     if success:
8190         for elements_item in ELEMENTS_XPATH(policy_xml_item):
8191             for child_item in elements_item:
8192                 this_element_name = _getFullPolicyName(
8193                     policy_item=child_item,
8194                     policy_name=child_item.attrib["id"],
8195                     return_full_policy_names=True,
8196                     adml_language=adml_language,
8197                 )
8198                 ret["policy_elements"].append(
8199                     {
8200                         "element_id": child_item.attrib["id"],
8201                         "element_aliases": [child_item.attrib["id"], this_element_name],
8202                     }
8203                 )
8204         ret["policy_aliases"] = policy_name_list
8205         ret["policy_found"] = True
8206         ret["message"] = ""
8207         return ret
8208     else:
8209         ret["message"] = message
8210     return ret
8211 def get(
8212     policy_class=None,
8213     return_full_policy_names=True,
8214     hierarchical_return=False,
8215     adml_language="en-US",
8216     return_not_configured=False,
8217 ):
8218     """
8219     Get a policy value
8220     Args:
8221         policy_class (str):
8222             Some policies are both user and computer, by default all policies
8223             will be pulled, but this can be used to retrieve only a specific
8224             policy class User/USER/user = retrieve user policies
8225             Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve
8226             machine/computer policies
8227         return_full_policy_names (bool):
8228             True/False to return the policy name as it is seen in the
8229             ``gpedit.msc`` GUI or to only return the policy key/id.
8230         hierarchical_return (bool):
8231             True/False to return the policy data in the hierarchy as seen in the
8232             ``gpedit.msc`` GUI. The default of False will return data split only
8233             into User/Computer configuration sections
8234         adml_language (str):
8235             The ADML language to use for processing display/descriptive names
8236             and enumeration values of ADMX template data, defaults to en-US
8237         return_not_configured (bool):
8238             Include Administrative Template policies that are 'Not Configured'
8239             in the return data
8240     Returns:
8241         dict: A dictionary containing the policy values for the specified class
8242     CLI Example:
8243     .. code-block:: bash
8244         salt '*' lgpo.get machine return_full_policy_names=True
8245     """
8246     _policydata = _policy_info()
8247     if policy_class is None or policy_class<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.lower() == "both":
8248         policy_class = _policydata.policies.keys()
8249     elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:
8250         msg = (
8251             "The policy_class {} is not an available policy class, please "</b></font>
8252             "use one of the following: {}, Both"
8253         )
8254         raise SaltInvocationError(
8255             msg.format(policy_class, ", ".join(_policydata.policies.keys()))
8256         )
8257     else:
8258         policy_class = [policy_class.title()]
8259     for p_class in policy_class:
8260         this_class_policy_names = _policydata.policies[p_class]["policies"]
8261         class_vals = {}
8262         for policy_name in this_class_policy_names:
8263             _pol = None
8264             if policy_name in _policydata.policies[p_class]["policies"]:
8265                 _pol = _policydata.policies[p_class]["policies"][policy_name]
8266             else:
8267                 for policy in _policydata.policies[p_class]["policies"]:
8268                     _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
8269                     if _p == policy_name:
8270                         _pol = _policydata.policies[p_class]["policies"][policy]
8271                         policy_name = policy
8272                 if _pol is None:
8273                     for policy in _policydata.policies[p_class]["policies"]:
8274                         _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
8275                         if _p.lower() == policy_name.lower():
8276                             _pol = _policydata.policies[p_class]["policies"][policy]
8277                             policy_name = policy
8278             if _pol:
8279                 vals_key_name = policy_name
8280                 class_vals[policy_name] = _get_policy_info_setting(_pol)
8281                 if return_full_policy_names:
8282                     class_vals[_pol["Policy"]] = class_vals.pop(policy_name)
8283                     vals_key_name = _pol["Policy"]
8284                 if hierarchical_return:
8285                     if "lgpo_section" in _pol:
8286                         firstItem = True
8287                         tdict = {}
8288                         for level in reversed(_pol["lgpo_section"]):
8289                             newdict = {}
8290                             if firstItem:
8291                                 newdict[level] = {
8292                                     vals_key_name: class_vals.pop(vals_key_name)
8293                                 }
8294                                 firstItem = False
8295                             else:
8296                                 newdict[level] = tdict
8297                             tdict = newdict
8298                         if tdict:
8299                             class_vals = dictupdate.update(class_vals, tdict)
8300             else:
8301                 raise CommandExecutionError(
8302                     "The specified policy {} is not currently available "
8303                     "to be configured via this module".format(policy_name)
8304                 )
8305         class_vals = dictupdate.update(
8306             class_vals,
8307             _checkAllAdmxPolicies(
8308                 policy_class=p_class,
8309                 adml_language=adml_language,
8310                 return_full_policy_names=return_full_policy_names,
8311                 hierarchical_return=hierarchical_return,
8312                 return_not_configured=return_not_configured,
8313             ),
8314         )
8315         if _policydata.policies[p_class]["lgpo_section"] not in class_vals:
8316             temp_dict = {_policydata.policies[p_class]["lgpo_section"]: class_vals}
8317             class_vals = temp_dict
8318         vals = dictupdate.update(vals, class_vals)
8319     return vals
8320 def _get_policy_info_setting(policy_definition):
8321     """
8322     Some policies are defined in this module and others by the ADMX/ADML files
8323     on the machine. This function loads the current values for policies defined
8324     in this module.
8325     Args:
8326         policy_definition (dict):
8327             A sub-dict of Policies property of the _policy_info() class.
8328             Basically a dictionary that defines the policy
8329     Returns:
8330         The transformed value. The transform is defined in the policy
8331         definition. It can be a list, a string, a dictionary, depending on how
8332         it's defined
8333     Usage:
8334         policy_data = _policy_info()
8335         policy_name = 'RemoteRegistryExactPaths'
8336         policy_definition = policy_data.policies['Machine']['policies'][policy_name]
8337         policy_value = _get_policy_info_setting(policy_definition)
8338     """
8339     if "Registry" in policy_definition:
8340         value = __utils__["reg.read_value"](
8341             policy_definition["Registry"]["Hive"],
8342             policy_definition["Registry"]["Path"],
8343             policy_definition["Registry"]["Value"],
8344         )["vdata"]
8345         log.trace(
8346             "Value %r found for Regisry policy %s", value, policy_definition["Policy"]
8347         )
8348     elif "Secedit" in policy_definition:
8349         value = _get_secedit_value(option=policy_definition["Secedit"]["Option"])
8350         log.trace(
8351             "Value %r found for Secedit policy %s", value, policy_definition["Policy"]
8352         )
8353     elif "NetSH" in policy_definition:
8354         value = _get_netsh_value(
8355             profile=policy_definition["NetSH"]["Profile"],
8356             option=policy_definition["NetSH"]["Option"],
8357         )
8358         log.trace(
8359             "Value %r found for NetSH policy %s", value, policy_definition["Policy"]
8360         )
8361     elif "AdvAudit" in policy_definition:
8362         value = _get_advaudit_value(option=policy_definition["AdvAudit"]["Option"])
8363         log.trace(
8364             "Value %r found for AuditPol policy %s", value, policy_definition["Policy"]
8365         )
8366     elif "NetUserModal" in policy_definition:
8367         modal_return = win32net.NetUserModalsGet(
8368             None, policy_definition["NetUserModal"]["Modal"]
8369         )
8370         value = modal_return[policy_definition["NetUserModal"]["Option"]]
8371         log.trace(
8372             "Value %r found for NetUserModal policy %s",
8373             value,
8374             policy_definition["Policy"],
8375         )
8376     elif "LsaRights" in policy_definition:
8377         value = _getRightsAssignments(policy_definition["LsaRights"]["Option"])
8378         log.trace(
8379             "Value %r found for LSARights policy %s", value, policy_definition["Policy"]
8380         )
8381     elif "ScriptIni" in policy_definition:
8382         value = _getScriptSettingsFromIniFile(policy_definition)
8383         log.trace(
8384             "Value %r found for ScriptIni policy %s", value, policy_definition["Policy"]
8385         )
8386     else:
8387         raise CommandExecutionError(
8388             "Unknown or missing mechanism in policy_definition\n{}".format(
8389                 policy_definition
8390             )
8391         )
8392     value = _transform_value(
8393         value=value, policy=policy_definition, transform_type="Get"
8394     )
8395     return value
8396 def _get_policy_adm_setting(
8397     admx_policy,
8398     policy_class,
8399     adml_language="en-US",
8400     return_full_policy_names=False,
8401     hierarchical_return=False,
8402 ):
8403     """
8404     Get the current setting for polices set via the policy templates (ADMX/ADML)
8405     files
8406     Args:
8407         admx_policy (obj):
8408             The XPath object as returned by the ``_lookup_admin_template``
8409             function
8410         policy_class (str):
8411             The policy class. Must be one of ``machine`` or ``user``
8412         adml_language (str):
8413             The language code for the adml file to use for localization. The
8414             default is ``en-US``
8415         return_full_policy_names (bool):
8416             Returns the full policy name regardless of what was passed in
8417             ``policy_name``
8418         hierarchical_return (bool):
8419             Returns a hierarchical view of the policy showing its parents
8420     Returns:
8421         dict: A dictionary containing the policy settings
8422     Usage:
8423         policy_name = 'AutoUpdateCfg'
8424         policy_class = 'machine'
8425         adml_language = 'en-US'
8426         success, policy_obj, _, _ = _lookup_admin_template(
8427             policy_name=policy_name,
8428             policy_class=policy_class,
8429             adml_language=adml_language)
8430         if success:
8431             setting = _get_policy_adm_setting(
8432                 admx_policy=policy_obj,
8433                 policy_class=policy_class,
8434                 adml_language=adml_language,
8435                 return_full_policy_names=return_full_policy_names,
8436                 hierarchical_return=hierarchical_return
8437             )
8438     """
8439     this_key = admx_policy.attrib.get("key", None)
8440     this_policy_name = admx_policy.attrib.get("name", None)
8441     if this_key is None or this_policy_name is None:
8442         raise CommandExecutionError(
8443             'Policy is missing the required "key" or "name" attribute:\n{}'.format(
8444                 admx_policy.attrib
8445             )
8446         )
8447     this_value_name = admx_policy.attrib.get("valueName", None)
8448     this_policy_setting = "Not Configured"
8449     this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]
8450     element_only_enabled_disabled = True
8451     explicit_enable_disable_value_setting = False
8452     policy_data = _policy_info()
8453     policy_file_data = _read_regpol_file(
8454         policy_data.admx_registry_classes[policy_class]["policy_path"]
8455     )
8456     adml_policy_resources = _get_policy_resources(language=adml_language)
8457     policy_vals = {}
8458     if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
8459         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
8460             element_only_enabled_disabled = False
8461             explicit_enable_disable_value_setting = True
8462             if _checkValueItemParent(
8463                 policy_element=admx_policy,
8464                 policy_name=this_policy_name,
8465                 policy_key=this_key,
8466                 policy_valueName=this_value_name,
8467                 xpath_object=ENABLED_VALUE_XPATH,
8468                 policy_file_data=policy_file_data,
8469             ):
8470                 log.trace(
8471                     "%s is enabled by detected ENABLED_VALUE_XPATH", this_policy_name
8472                 )
8473                 this_policy_setting = "Enabled"
8474                 policy_vals.setdefault(this_policy_namespace, {})[
8475                     this_policy_name
8476                 ] = this_policy_setting
8477     if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
8478         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
8479             element_only_enabled_disabled = False
8480             explicit_enable_disable_value_setting = True
8481             if _checkValueItemParent(
8482                 policy_element=admx_policy,
8483                 policy_name=this_policy_name,
8484                 policy_key=this_key,
8485                 policy_valueName=this_value_name,
8486                 xpath_object=DISABLED_VALUE_XPATH,
8487                 policy_file_data=policy_file_data,
8488             ):
8489                 log.trace(
8490                     "%s is disabled by detected DISABLED_VALUE_XPATH", this_policy_name
8491                 )
8492                 this_policy_setting = "Disabled"
8493                 policy_vals.setdefault(this_policy_namespace, {})[
8494                     this_policy_name
8495                 ] = this_policy_setting
8496     if ENABLED_LIST_XPATH(admx_policy):
8497         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
8498             element_only_enabled_disabled = False
8499             explicit_enable_disable_value_setting = True
8500             if _checkListItem(
8501                 policy_element=admx_policy,
8502                 policy_name=this_policy_name,
8503                 policy_key=this_key,
8504                 xpath_object=ENABLED_LIST_XPATH,
8505                 policy_file_data=policy_file_data,
8506             ):
8507                 log.trace(
8508                     "%s is enabled by detected ENABLED_LIST_XPATH", this_policy_name
8509                 )
8510                 this_policy_setting = "Enabled"
8511                 policy_vals.setdefault(this_policy_namespace, {})[
8512                     this_policy_name
8513                 ] = this_policy_setting
8514     if DISABLED_LIST_XPATH(admx_policy):
8515         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
8516             element_only_enabled_disabled = False
8517             explicit_enable_disable_value_setting = True
8518             if _checkListItem(
8519                 policy_element=admx_policy,
8520                 policy_name=this_policy_name,
8521                 policy_key=this_key,
8522                 xpath_object=DISABLED_LIST_XPATH,
8523                 policy_file_data=policy_file_data,
8524             ):
8525                 log.trace(
8526                     "%s is disabled by detected DISABLED_LIST_XPATH", this_policy_name
8527                 )
8528                 this_policy_setting = "Disabled"
8529                 policy_vals.setdefault(this_policy_namespace, {})[
8530                     this_policy_name
8531                 ] = this_policy_setting
8532     if not explicit_enable_disable_value_setting and this_value_name:
8533         if _regexSearchRegPolData(
8534             re.escape(
8535                 _buildKnownDataSearchString(
8536                     reg_key=this_key,
8537                     reg_valueName=this_value_name,
8538                     reg_vtype="REG_DWORD",
8539                     reg_data="1",
8540                 )
8541             ),
8542             policy_file_data,
8543         ):
8544             log.trace(
8545                 "%s is enabled by no explicit enable/disable list or value",
8546                 this_policy_name,
8547             )
8548             this_policy_setting = "Enabled"
8549             policy_vals.setdefault(this_policy_namespace, {})[
8550                 this_policy_name
8551             ] = this_policy_setting
8552         elif _regexSearchRegPolData(
8553             re.escape(
8554                 _buildKnownDataSearchString(
8555                     reg_key=this_key,
8556                     reg_valueName=this_value_name,
8557                     reg_vtype="REG_DWORD",
8558                     reg_data=None,
8559                     check_deleted=True,
8560                 )
8561             ),
8562             policy_file_data,
8563         ):
8564             log.trace(
8565                 "%s is disabled by no explicit enable/disable list or value",
8566                 this_policy_name,
8567             )
8568             this_policy_setting = "Disabled"
8569             policy_vals.setdefault(this_policy_namespace, {})[
8570                 this_policy_name
8571             ] = this_policy_setting
8572     full_names = {}
8573     hierarchy = {}
8574     if ELEMENTS_XPATH(admx_policy):
8575         if element_only_enabled_disabled or this_policy_setting == "Enabled":
8576             required_elements = {}
8577             configured_elements = {}
8578             policy_disabled_elements = 0
8579             for elements_item in ELEMENTS_XPATH(admx_policy):
8580                 for child_item in elements_item:
8581                     this_element_name = _getFullPolicyName(
8582                         policy_item=child_item,
8583                         policy_name=child_item.attrib["id"],
8584                         return_full_policy_names=return_full_policy_names,
8585                         adml_language=adml_language,
8586                     )
8587                     required_elements[this_element_name] = None
8588                     child_key = child_item.attrib.get("key", this_key)
8589                     child_value_name = child_item.attrib.get(
8590                         "valueName", this_value_name
8591                     )
8592                     if etree.QName(child_item).localname == "boolean":
8593                         if child_item is not None:
8594                             if (
8595                                 TRUE_VALUE_XPATH(child_item)
8596                                 and this_element_name not in configured_elements
8597                             ):
8598                                 if _checkValueItemParent(
8599                                     policy_element=child_item,
8600                                     policy_name=this_policy_name,
8601                                     policy_key=child_key,
8602                                     policy_valueName=child_value_name,
8603                                     xpath_object=TRUE_VALUE_XPATH,
8604                                     policy_file_data=policy_file_data,
8605                                 ):
8606                                     configured_elements[this_element_name] = True
8607                                     log.trace(
8608                                         "element %s is configured true",
8609                                         child_item.attrib["id"],
8610                                     )
8611                             if (
8612                                 FALSE_VALUE_XPATH(child_item)
8613                                 and this_element_name not in configured_elements
8614                             ):
8615                                 if _checkValueItemParent(
8616                                     policy_element=child_item,
8617                                     policy_name=this_policy_name,
8618                                     policy_key=child_key,
8619                                     policy_valueName=child_value_name,
8620                                     xpath_object=FALSE_VALUE_XPATH,
8621                                     policy_file_data=policy_file_data,
8622                                 ):
8623                                     configured_elements[this_element_name] = False
8624                                     policy_disabled_elements = (
8625                                         policy_disabled_elements + 1
8626                                     )
8627                                     log.trace(
8628                                         "element %s is configured false",
8629                                         child_item.attrib["id"],
8630                                     )
8631                             if (
8632                                 TRUE_LIST_XPATH(child_item)
8633                                 and this_element_name not in configured_elements
8634                             ):
8635                                 log.trace("checking trueList")
8636                                 if _checkListItem(
8637                                     policy_element=child_item,
8638                                     policy_name=this_policy_name,
8639                                     policy_key=this_key,
8640                                     xpath_object=TRUE_LIST_XPATH,
8641                                     policy_file_data=policy_file_data,
8642                                 ):
8643                                     configured_elements[this_element_name] = True
8644                                     log.trace(
8645                                         "element %s is configured true",
8646                                         child_item.attrib["id"],
8647                                     )
8648                             if (
8649                                 FALSE_LIST_XPATH(child_item)
8650                                 and this_element_name not in configured_elements
8651                             ):
8652                                 log.trace("checking falseList")
8653                                 if _checkListItem(
8654                                     policy_element=child_item,
8655                                     policy_name=this_policy_name,
8656                                     policy_key=this_key,
8657                                     xpath_object=FALSE_LIST_XPATH,
8658                                     policy_file_data=policy_file_data,
8659                                 ):
8660                                     configured_elements[this_element_name] = False
8661                                     policy_disabled_elements = (
8662                                         policy_disabled_elements + 1
8663                                     )
8664                                     log.trace(
8665                                         "element %s is configured false",
8666                                         child_item.attrib["id"],
8667                                     )
8668                         else:
8669                             if _regexSearchRegPolData(
8670                                 re.escape(
8671                                     _processValueItem(
8672                                         element=child_item,
8673                                         reg_key=child_key,
8674                                         reg_valuename=child_value_name,
8675                                         policy=admx_policy,
8676                                         parent_element=elements_item,
8677                                         check_deleted=True,
8678                                     )
8679                                 ),
8680                                 policy_file_data,
8681                             ):
8682                                 configured_elements[this_element_name] = False
8683                                 policy_disabled_elements = policy_disabled_elements + 1
8684                                 log.trace(
8685                                     "element %s is configured false",
8686                                     child_item.attrib["id"],
8687                                 )
8688                             elif _regexSearchRegPolData(
8689                                 re.escape(
8690                                     _processValueItem(
8691                                         element=child_item,
8692                                         reg_key=child_key,
8693                                         reg_valuename=child_value_name,
8694                                         policy=admx_policy,
8695                                         parent_element=elements_item,
8696                                         check_deleted=False,
8697                                     )
8698                                 ),
8699                                 policy_file_data,
8700                             ):
8701                                 configured_elements[this_element_name] = True
8702                                 log.trace(
8703                                     "element %s is configured true",
8704                                     child_item.attrib["id"],
8705                                 )
8706                     elif etree.QName(child_item).localname in [
8707                         "decimal",
8708                         "text",
8709                         "longDecimal",
8710                         "multiText",
8711                     ]:
8712                         if _regexSearchRegPolData(
8713                             re.escape(
8714                                 _processValueItem(
8715                                     element=child_item,
8716                                     reg_key=child_key,
8717                                     reg_valuename=child_value_name,
8718                                     policy=admx_policy,
8719                                     parent_element=elements_item,
8720                                     check_deleted=True,
8721                                 )
8722                             ),
8723                             policy_file_data,
8724                         ):
8725                             configured_elements[this_element_name] = "Disabled"
8726                             policy_disabled_elements = policy_disabled_elements + 1
8727                             log.trace("element %s is disabled", child_item.attrib["id"])
8728                         elif _regexSearchRegPolData(
8729                             re.escape(
8730                                 _processValueItem(
8731                                     element=child_item,
8732                                     reg_key=child_key,
8733                                     reg_valuename=child_value_name,
8734                                     policy=admx_policy,
8735                                     parent_element=elements_item,
8736                                     check_deleted=False,
8737                                 )
8738                             ),
8739                             policy_data=policy_file_data,
8740                         ):
8741                             configured_value = _getDataFromRegPolData(
8742                                 _processValueItem(
8743                                     element=child_item,
8744                                     reg_key=child_key,
8745                                     reg_valuename=child_value_name,
8746                                     policy=admx_policy,
8747                                     parent_element=elements_item,
8748                                     check_deleted=False,
8749                                 ),
8750                                 policy_data=policy_file_data,
8751                             )
8752                             configured_elements[this_element_name] = configured_value
8753                             log.trace(
8754                                 "element %s is enabled, value == %s",
8755                                 child_item.attrib["id"],
8756                                 configured_value,
8757                             )
8758                     elif etree.QName(child_item).localname == "enum":
8759                         if _regexSearchRegPolData(
8760                             re.escape(
8761                                 _processValueItem(
8762                                     element=child_item,
8763                                     reg_key=child_key,
8764                                     reg_valuename=child_value_name,
8765                                     policy=admx_policy,
8766                                     parent_element=elements_item,
8767                                     check_deleted=True,
8768                                 )
8769                             ),
8770                             policy_file_data,
8771                         ):
8772                             log.trace(
8773                                 "enum element %s is disabled", child_item.attrib["id"]
8774                             )
8775                             configured_elements[this_element_name] = "Disabled"
8776                             policy_disabled_elements = policy_disabled_elements + 1
8777                         else:
8778                             for enum_item in child_item:
8779                                 if _checkValueItemParent(
8780                                     policy_element=enum_item,
8781                                     policy_name=child_item.attrib["id"],
8782                                     policy_key=child_key,
8783                                     policy_valueName=child_value_name,
8784                                     xpath_object=VALUE_XPATH,
8785                                     policy_file_data=policy_file_data,
8786                                 ):
8787                                     if VALUE_LIST_XPATH(enum_item):
8788                                         log.trace("enum item has a valueList")
8789                                         if _checkListItem(
8790                                             policy_element=enum_item,
8791                                             policy_name=this_policy_name,
8792                                             policy_key=child_key,
8793                                             xpath_object=VALUE_LIST_XPATH,
8794                                             policy_file_data=policy_file_data,
8795                                         ):
8796                                             log.trace(
8797                                                 "all valueList items exist in file"
8798                                             )
8799                                             configured_elements[
8800                                                 this_element_name
8801                                             ] = _getAdmlDisplayName(
8802                                                 adml_xml_data=adml_policy_resources,
8803                                                 display_name=enum_item.attrib[
8804                                                     "displayName"
8805                                                 ],
8806                                             )
8807                                             break
8808                                     else:
8809                                         configured_elements[
8810                                             this_element_name
8811                                         ] = _getAdmlDisplayName(
8812                                             adml_xml_data=adml_policy_resources,
8813                                             display_name=enum_item.attrib[
8814                                                 "displayName"
8815                                             ],
8816                                         )
8817                                         break
8818                     elif etree.QName(child_item).localname == "list":
8819                         return_value_name = False
8820                         if (
8821                             "explicitValue" in child_item.attrib
8822                             and child_item.attrib["explicitValue"].lower() == "true"
8823                         ):
8824                             log.trace("explicitValue list, we will return value names")
8825                             return_value_name = True
8826                         regex_str = [
8827                             r"(?!\*",
8828                             r"\*",
8829                             "D",
8830                             "e",
8831                             "l",
8832                             "V",
8833                             "a",
8834                             "l",
8835                             "s",
8836                             r"\.",
8837                             ")",
8838                         ]
8839                         delvals_regex = "\x00".join(regex_str)
8840                         delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)
8841                         if _regexSearchRegPolData(
8842                             re.escape(
8843                                 _processValueItem(
8844                                     element=child_item,
8845                                     reg_key=child_key,
8846                                     reg_valuename=child_value_name,
8847                                     policy=admx_policy,
8848                                     parent_element=elements_item,
8849                                     check_deleted=False,
8850                                 )
8851                             )
8852                             + delvals_regex,
8853                             policy_data=policy_file_data,
8854                         ):
8855                             configured_value = _getDataFromRegPolData(
8856                                 _processValueItem(
8857                                     element=child_item,
8858                                     reg_key=child_key,
8859                                     reg_valuename=child_value_name,
8860                                     policy=admx_policy,
8861                                     parent_element=elements_item,
8862                                     check_deleted=False,
8863                                 ),
8864                                 policy_data=policy_file_data,
8865                                 return_value_name=return_value_name,
8866                             )
8867                             configured_elements[this_element_name] = configured_value
8868                             log.trace(
8869                                 "element %s is enabled values: %s",
8870                                 child_item.attrib["id"],
8871                                 configured_value,
8872                             )
8873                         elif _regexSearchRegPolData(
8874                             re.escape(
8875                                 _processValueItem(
8876                                     element=child_item,
8877                                     reg_key=child_key,
8878                                     reg_valuename=child_value_name,
8879                                     policy=admx_policy,
8880                                     parent_element=elements_item,
8881                                     check_deleted=True,
8882                                 )
8883                             ),
8884                             policy_file_data,
8885                         ):
8886                             configured_elements[this_element_name] = "Disabled"
8887                             policy_disabled_elements = policy_disabled_elements + 1
8888             if element_only_enabled_disabled:
8889                 if 0 &lt; len(required_elements.keys()) == len(configured_elements.keys()):
8890                     if policy_disabled_elements == len<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(required_elements.keys()):
8891                         log.trace(
8892                             "%s is disabled by all enum elements", this_policy_name
8893                         )
8894                         policy_vals.setdefault(this_policy_namespace, {})[
8895                             this_policy_name
8896                         ] = "Disabled"
8897                     else:
8898                         log.trace("%s is enabled by enum elements", this_policy_name)
8899                         policy_vals.setdefault(this_policy_namespace, {})[</b></font>
8900                             this_policy_name
8901                         ] = configured_elements
8902                 else:
8903                     policy_vals.setdefault(this_policy_namespace, {})[
8904                         this_policy_name
8905                     ] = this_policy_setting
8906             else:
8907                 if this_policy_setting == "Enabled":
8908                     policy_vals.setdefault(this_policy_namespace, {})[
8909                         this_policy_name
8910                     ] = configured_elements
8911         else:
8912             policy_vals.setdefault(this_policy_namespace, {})[
8913                 this_policy_name
8914             ] = this_policy_setting
8915     else:
8916         policy_vals.setdefault(this_policy_namespace, {})[
8917             this_policy_name
8918         ] = this_policy_setting
8919     if (
8920         return_full_policy_names
8921         and this_policy_namespace in policy_vals
8922         and this_policy_name in policy_vals[this_policy_namespace]
8923     ):
8924         full_names.setdefault(this_policy_namespace, {})
8925         full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(
8926             policy_item=admx_policy,
8927             policy_name=admx_policy.attrib["name"],
8928             return_full_policy_names=return_full_policy_names,
8929             adml_language=adml_language,
8930         )
8931         if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:
8932             full_name = full_names[this_policy_namespace][this_policy_name]
8933             setting = policy_vals[this_policy_namespace][this_policy_name].pop(
8934                 this_policy_name
8935             )
8936             policy_vals[this_policy_namespace][this_policy_name][full_name] = setting
8937     if (
8938         this_policy_namespace in policy_vals
8939         and this_policy_name in policy_vals[this_policy_namespace]
8940     ):
8941         hierarchy.setdefault(this_policy_namespace, {})[
8942             this_policy_name
8943         ] = _build_parent_list(
8944             policy_definition=admx_policy,
8945             return_full_policy_names=return_full_policy_names,
8946             adml_language=adml_language,
8947         )
8948     if policy_vals and return_full_policy_names and not hierarchical_return:
8949         log.debug("Compiling non hierarchical return...")
8950         unpathed_dict = {}
8951         pathed_dict = {}
8952         for policy_namespace in list(policy_vals):
8953             for policy_item in list(policy_vals[policy_namespace]):
8954                 full_name = full_names[policy_namespace][policy_item]
8955                 if full_name in policy_vals[policy_namespace]:
8956                     full_path_list = hierarchy[policy_namespace][policy_item]
8957                     full_path_list.reverse()
8958                     full_path_list.append(full_names[policy_namespace][policy_item])
8959                     policy_vals["\\".join(full_path_list)] = policy_vals[
8960                         policy_namespace
8961                     ].pop(policy_item)
8962                     pathed_dict[full_name] = True
8963                 else:
8964                     policy_vals[policy_namespace][full_name] = policy_vals[
8965                         policy_namespace
8966                     ].pop(policy_item)
8967                     unpathed_dict.setdefault(policy_namespace, {})[
8968                         full_name
8969                     ] = policy_item
8970             for path_needed in unpathed_dict[policy_namespace]:
8971                 full_path_list = hierarchy[policy_namespace][
8972                     unpathed_dict[policy_namespace][path_needed]
8973                 ]
8974                 full_path_list.reverse()
8975                 full_path_list.append(path_needed)
8976                 log.trace("full_path_list == %s", full_path_list)
8977                 policy_vals["\\".join(full_path_list)] = policy_vals[
8978                     policy_namespace
8979                 ].pop(path_needed)
8980     for policy_namespace in list(policy_vals):
8981         if policy_vals[policy_namespace] == {}:
8982             policy_vals.pop(policy_namespace)
8983         elif isinstance(policy_vals[policy_namespace], dict):
8984             if this_policy_namespace == policy_namespace and not hierarchical_return:
8985                 policy_vals.update(policy_vals[policy_namespace])
8986                 policy_vals.pop(policy_namespace)
8987     if policy_vals and hierarchical_return:
8988         if hierarchy:
8989             log.debug("Compiling hierarchical return...")
8990             for policy_namespace in hierarchy:
8991                 for hierarchy_item in hierarchy[policy_namespace]:
8992                     if hierarchy_item in policy_vals[policy_namespace]:
8993                         t_dict = {}
8994                         first_item = True
8995                         for item in hierarchy[policy_namespace][hierarchy_item]:
8996                             new_dict = {}
8997                             if first_item:
8998                                 h_policy_name = hierarchy_item
8999                                 if return_full_policy_names:
9000                                     h_policy_name = full_names[policy_namespace][
9001                                         hierarchy_item
9002                                     ]
9003                                 new_dict[item] = {
9004                                     h_policy_name: policy_vals[policy_namespace].pop(
9005                                         hierarchy_item
9006                                     )
9007                                 }
9008                                 first_item = False
9009                             else:
9010                                 new_dict[item] = t_dict
9011                             t_dict = new_dict
9012                         if t_dict:
9013                             policy_vals = dictupdate.update(policy_vals, t_dict)
9014                 if (
9015                     policy_namespace in policy_vals
9016                     and policy_vals[policy_namespace] == {}
9017                 ):
9018                     policy_vals.pop(policy_namespace)
9019         policy_vals = {
9020             policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
9021                 "Administrative Templates": policy_vals
9022             }
9023         }
9024     return policy_vals
9025 def get_policy(
9026     policy_name,
9027     policy_class,
9028     adml_language="en-US",
9029     return_value_only=True,
9030     return_full_policy_names=True,
9031     hierarchical_return=False,
9032 ):
9033     r"""
9034     Get the current settings for a single policy on the machine
9035     Args:
9036         policy_name (str):
9037             The name of the policy to retrieve. Can be the any of the names
9038             or alieses returned by ``lgpo.get_policy_info``
9039         policy_class (str):
9040             The policy class. Must be one of ``machine`` or ``user``
9041         adml_language (str):
9042             The language code for the adml file to use for localization. The
9043             default is ``en-US``
9044         return_value_only (bool):
9045             ``True`` will return only the value for the policy, without the
9046             name of the policy. ``return_full_policy_names`` and
9047             ``hierarchical_return`` will be ignored. Default is ``True``
9048         return_full_policy_names (bool):
9049             Returns the full policy name regardless of what was passed in
9050             ``policy_name``
9051             .. note::
9052                 This setting applies to sub-elements of the policy if they
9053                 exist. The value passed in ``policy_name`` will always be used
9054                 as the policy name when this setting is ``False``
9055         hierarchical_return (bool):
9056             Returns a hierarchical view of the policy showing its parents
9057     Returns:
9058         dict: A dictionary containing the policy settings
9059     CLI Example:
9060     .. code-block:: bash
9061         salt * lgpo.get_policy LockoutDuration machine
9062         salt * lgpo.get_policy AutoUpdateCfg machine
9063         salt * lgpo.get_policy "Account lockout duration" machine
9064         salt * lgpo.get_policy "Configure Automatic Updates" machine
9065         salt * lgpo.get_policy "Windows Components\Windows Update\Configure Automatic Updates" machine
9066     """
9067     if not policy_name:
9068         raise SaltInvocationError("policy_name must be defined")
9069     if not policy_class:
9070         raise SaltInvocationError("policy_class must be defined")
9071     policy_class = policy_class.title()
9072     policy_data = _policy_info()
9073     if policy_class not in policy_data.policies.keys():
9074         policy_classes = ", ".join(policy_data.policies.keys())
9075         raise CommandExecutionError(
9076             'The requested policy class "{}" is invalid, policy_class should '
9077             "be one of: {}".format(policy_class, policy_classes)
9078         )
9079     policy_definition = None
9080     if policy_name in policy_data.policies[policy_class]["policies"]:
9081         policy_definition = policy_data.policies[policy_class]["policies"][policy_name]
9082     else:
9083         for pol in policy_data.policies[policy_class]["policies"]:
9084             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
9085             if _p == policy_name:
9086                 policy_definition = policy_data.policies[policy_class]["policies"][pol]
9087                 break
9088         if policy_definition is None:
9089             for pol in policy_data.policies[policy_class]["policies"]:
9090                 _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
9091                 if _p.lower() == policy_name.lower():
9092                     policy_definition = policy_data.policies[policy_class]["policies"][
9093                         pol
9094                     ]
9095                     break
9096     if policy_definition:
9097         if return_value_only:
9098             return _get_policy_info_setting(policy_definition)
9099         if return_full_policy_names:
9100             key_name = policy_definition["Policy"]
9101         else:
9102             key_name = policy_name
9103         setting = {key_name: _get_policy_info_setting(policy_definition)}
9104         if hierarchical_return:
9105             if "lgpo_section" in policy_definition:
9106                 first_item = True
9107                 t_dict = {}
9108                 for level in reversed(policy_definition["lgpo_section"]):
9109                     new_dict = {}
9110                     if first_item:
9111                         new_dict[level] = {key_name: setting.pop(key_name)}
9112                         first_item = False
9113                     else:
9114                         new_dict[level] = t_dict
9115                     t_dict = new_dict
9116                 if t_dict:
9117                     setting = t_dict
9118         return setting
9119     success, policy_obj, _, _ = _lookup_admin_template(
9120         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
9121     )
9122     if success:
9123         setting = _get_policy_adm_setting(
9124             admx_policy=policy_obj,
9125             policy_class=policy_class,
9126             adml_language=adml_language,
9127             return_full_policy_names=return_full_policy_names,
9128             hierarchical_return=hierarchical_return,
9129         )
9130         if return_value_only:
9131             for key in setting:
9132                 return setting[key]
9133         return setting
9134 def set_computer_policy(
9135     name, setting, cumulative_rights_assignments=True, adml_language="en-US"
9136 ):
9137     """
9138     Set a single computer policy
9139     Args:
9140         name (str):
9141             The name of the policy to configure
9142         setting (str):
9143             The setting to configure the named policy with
9144         cumulative_rights_assignments (bool): Determine how user rights
9145             assignment policies are configured. If True, user right assignment
9146             specifications are simply added to the existing policy. If False,
9147             only the users specified will get the right (any existing will have
9148             the right revoked)
9149         adml_language (str): The language files to use for looking up
9150             Administrative Template policy data (i.e. how the policy is
9151             displayed in the GUI).  Defaults to 'en-US' (U.S. English).
9152     Returns:
9153         bool: True if successful, otherwise False
9154     CLI Example:
9155     .. code-block:: bash
9156         salt '*' lgpo.set_computer_policy LockoutDuration 1440
9157     """
9158     pol = {}
9159     pol[name] = setting
9160     ret = set_(
9161         computer_policy=pol,
9162         user_policy=None,
9163         cumulative_rights_assignments=cumulative_rights_assignments,
9164         adml_language=adml_language,
9165     )
9166     return ret
9167 def set_user_policy(name, setting, adml_language="en-US"):
9168     """
9169     Set a single user policy
9170     Args:
9171         name (str):
9172             The name of the policy to configure
9173         setting (str):
9174             The setting to configure the named policy with
9175         adml_language (str):
9176             The language files to use for looking up Administrative Template
9177             policy data (i.e. how the policy is displayed in the GUI). Defaults
9178             to 'en-US' (U.S. English).
9179     Returns:
9180         bool: True if successful, Otherwise False
9181     CLI Example:
9182     .. code-block:: bash
9183         salt '*' lgpo.set_user_policy "Control Panel\\Display\\Disable the Display Control Panel" Enabled
9184     """
9185     pol = {}
9186     pol[name] = setting
9187     ret = set_(
9188         user_policy=pol,
9189         computer_policy=None,
9190         cumulative_rights_assignments=True,
9191         adml_language=adml_language,
9192     )
9193     return ret
9194 def set_(
9195     computer_policy=None,
9196     user_policy=None,
9197     cumulative_rights_assignments=True,
9198     adml_language="en-US",
9199 ):
9200     """
9201     Set a local server policy.
9202     Args:
9203         computer_policy (dict):
9204             A dictionary of "policyname: value" pairs of computer policies to
9205             set. 'value' should be how it is displayed in the gpedit GUI, i.e.
9206             if a setting can be 'Enabled'/'Disabled', then that should be passed
9207             Administrative Template data may require dicts within dicts, to
9208             specify each element of the Administrative Template policy.
9209             Administrative Templates policies are always cumulative.
9210             Policy names can be specified in a number of ways based on the type
9211             of policy:
9212                 Windows Settings Policies:
9213                     These policies can be specified using the GUI display name
9214                     or the key name from the _policy_info class in this module.
9215                     The GUI display name is also contained in the _policy_info
9216                     class in this module.
9217                 Administrative Template Policies:
9218                     These can be specified using the policy name as displayed in
9219                     the GUI (case sensitive). Some policies have the same name,
9220                     but a different location (for example, "Access data sources
9221                     across domains"). These can be differentiated by the "path"
9222                     in the GUI (for example, "Windows Components\\Internet
9223                     Explorer\\Internet Control Panel\\Security Page\\Internet
9224                     Zone\\Access data sources across domains").
9225                     Additionally, policies can be specified using the "name" and
9226                     "id" attributes from the ADMX files.
9227                     For Administrative Templates that have policy elements, each
9228                     element can be specified using the text string as seen in
9229                     the GUI or using the ID attribute from the ADMX file. Due to
9230                     the way some of the GUI text is laid out, some policy
9231                     element names could include descriptive text that appears
9232                     lbefore the policy element in the GUI.
9233                     Use the get_policy_info function for the policy name to view
9234                     the element ID/names that the module will accept.
9235         user_policy (dict):
9236             The same setup as the computer_policy, except with data to configure
9237             the local user policy.
9238         cumulative_rights_assignments (bool):
9239             Determine how user rights assignment policies are configured.
9240             If True, user right assignment specifications are simply added to
9241             the existing policy
9242             If False, only the users specified will get the right (any existing
9243             will have the right revoked)
9244         adml_language (str):
9245             The language files to use for looking up Administrative Template
9246             policy data (i.e. how the policy is displayed in the GUI). Defaults
9247             to 'en-US' (U.S. English).
9248     Returns:
9249         bool: True is successful, otherwise False
9250     CLI Example:
9251     .. code-block:: bash
9252         salt '*' lgpo.set computer_policy="{'LockoutDuration': 2, 'RestrictAnonymous': 'Enabled', 'AuditProcessTracking': 'Succes, Failure'}"
9253     """
9254     if computer_policy and not isinstance(computer_policy, dict):
9255         raise SaltInvocationError("computer_policy must be specified as a dict")
9256     if user_policy and not isinstance(user_policy, dict):
9257         raise SaltInvocationError("user_policy must be specified as a dict")
9258     policies = {}
9259     policies["User"] = user_policy
9260     policies["Machine"] = computer_policy
9261     if policies:
9262         adml_policy_resources = _get_policy_resources(language=adml_language)
9263         for p_class in policies:
9264             _secedits = {}
9265             _netshs = {}
9266             _advaudits = {}
9267             _modal_sets = {}
9268             _admTemplateData = {}
9269             _regedits = {}
9270             _lsarights = {}
9271             _policydata = _policy_info()
9272             if policies[p_class]:
9273                 for policy_name in policies[p_class]:
9274                     _pol = None
9275                     policy_key_name = policy_name
9276                     if policy_name in _policydata.policies[p_class]["policies"]:
9277                         _pol = _policydata.policies[p_class]["policies"][policy_name]
9278                     else:
9279                         for policy in _policydata.policies[p_class]["policies"]:
9280                             _p = _policydata.policies[p_class]["policies"][policy][
9281                                 "Policy"
9282                             ]
9283                             if _p == policy_name:
9284                                 _pol = _policydata.policies[p_class]["policies"][policy]
9285                                 policy_key_name = policy
9286                         if _pol is None:
9287                             for policy in _policydata.policies[p_class]["policies"]:
9288                                 _p = _policydata.policies[p_class]["policies"][policy][
9289                                     "Policy"
9290                                 ]
9291                                 if _p.lower() == policy_name.lower():
9292                                     _pol = _policydata.policies[p_class]["policies"][
9293                                         policy
9294                                     ]
9295                                     policy_key_name = policy
9296                     if _pol:
9297                         _value = _transform_value(
9298                             value=policies[p_class][policy_name],
9299                             policy=_policydata.policies[p_class]["policies"][
9300                                 policy_key_name
9301                             ],
9302                             transform_type="Put",
9303                         )
9304                         if not _validateSetting(
9305                             value=_value,
9306                             policy=_policydata.policies[p_class]["policies"][
9307                                 policy_key_name
9308                             ],
9309                         ):
9310                             raise SaltInvocationError(
9311                                 "The specified value {} is not an acceptable setting"
9312                                 " for policy {}.".format(
9313                                     policies[p_class][policy_name], policy_name
9314                                 )
9315                             )
9316                         if "Registry" in _pol:
9317                             log.trace("%s is a registry policy", policy_name)
9318                             _regedits[policy_name] = {"policy": _pol, "value": _value}
9319                         elif "Secedit" in _pol:
9320                             log.trace("%s is a Secedit policy", policy_name)
9321                             if _pol["Secedit"]["Section"] not in _secedits:
9322                                 _secedits[_pol["Secedit"]["Section"]] = []
9323                             _secedits[_pol["Secedit"]["Section"]].append(
9324                                 " ".join([_pol["Secedit"]["Option"], "=", str(_value)])
9325                             )
9326                         elif "NetSH" in _pol:
9327                             log.trace("%s is a NetSH policy", policy_name)
9328                             _netshs.setdefault(
9329                                 policy_name,
9330                                 {
9331                                     "profile": _pol["NetSH"]["Profile"],
9332                                     "section": _pol["NetSH"]["Section"],
9333                                     "option": _pol["NetSH"]["Option"],
9334                                     "value": str(_value),
9335                                 },
9336                             )
9337                         elif "AdvAudit" in _pol:
9338                             _advaudits.setdefault(
9339                                 policy_name,
9340                                 {
9341                                     "option": _pol["AdvAudit"]["Option"],
9342                                     "value": str(_value),
9343                                 },
9344                             )
9345                         elif "NetUserModal" in _pol:
9346                             log.trace("%s is a NetUserModal policy", policy_name)
9347                             if _pol["NetUserModal"]["Modal"] not in _modal_sets:
9348                                 _modal_sets[_pol["NetUserModal"]["Modal"]] = {}
9349                             _modal_sets[_pol["NetUserModal"]["Modal"]][
9350                                 _pol["NetUserModal"]["Option"]
9351                             ] = _value
9352                         elif "LsaRights" in _pol:
9353                             log.trace("%s is a LsaRights policy", policy_name)
9354                             _lsarights[policy_name] = {"policy": _pol, "value": _value}
9355                     else:
9356                         _value = policies[p_class][policy_name]
9357                         log.trace('searching for "%s" in admx data', policy_name)
9358                         (
9359                             success,
9360                             the_policy,
9361                             policy_name_list,
9362                             msg,
9363                         ) = _lookup_admin_template(
9364                             policy_name=policy_name,
9365                             policy_class=p_class,
9366                             adml_language=adml_language,
9367                         )
9368                         if success:
9369                             policy_name = the_policy.attrib["name"]
9370                             policy_namespace = the_policy.nsmap[the_policy.prefix]
9371                             if policy_namespace not in _admTemplateData:
9372                                 _admTemplateData[policy_namespace] = {}
9373                             _admTemplateData[policy_namespace][policy_name] = _value
9374                         else:
9375                             raise SaltInvocationError(msg)
9376                         if (
9377                             policy_namespace
9378                             and policy_name in _admTemplateData[policy_namespace]
9379                             and the_policy is not None
9380                         ):
9381                             log.trace(
9382                                 "setting == %s",
9383                                 str(
9384                                     _admTemplateData[policy_namespace][policy_name]
9385                                 ).lower(),
9386                             )
9387                             log.trace(
9388                                 str(
9389                                     _admTemplateData[policy_namespace][policy_name]
9390                                 ).lower()
9391                             )
9392                             if (
9393                                 str(
9394                                     _admTemplateData[policy_namespace][policy_name]
9395                                 ).lower()
9396                                 != "disabled"
9397                                 and str(
9398                                     _admTemplateData[policy_namespace][policy_name]
9399                                 ).lower()
9400                                 != "not configured"
9401                             ):
9402                                 if ELEMENTS_XPATH(the_policy):
9403                                     if isinstance(
9404                                         _admTemplateData[policy_namespace][policy_name],
9405                                         dict,
9406                                     ):
9407                                         for elements_item in ELEMENTS_XPATH(the_policy):
9408                                             for child_item in elements_item:
9409                                                 log.trace(
9410                                                     "checking element %s",
9411                                                     child_item.attrib["id"],
9412                                                 )
9413                                                 temp_element_name = None
9414                                                 this_element_name = _getFullPolicyName(
9415                                                     policy_item=child_item,
9416                                                     policy_name=child_item.attrib["id"],
9417                                                     return_full_policy_names=True,
9418                                                     adml_language=adml_language,
9419                                                 )
9420                                                 log.trace(
9421                                                     'id attribute == "%s" '
9422                                                     ' this_element_name == "%s"',
9423                                                     child_item.attrib["id"],
9424                                                     this_element_name,
9425                                                 )
9426                                                 if (
9427                                                     this_element_name
9428                                                     in _admTemplateData[
9429                                                         policy_namespace
9430                                                     ][policy_name]
9431                                                 ):
9432                                                     temp_element_name = (
9433                                                         this_element_name
9434                                                     )
9435                                                 elif (
9436                                                     child_item.attrib["id"]
9437                                                     in _admTemplateData[
9438                                                         policy_namespace
9439                                                     ][policy_name]
9440                                                 ):
9441                                                     temp_element_name = (
9442                                                         child_item.attrib["id"]
9443                                                     )
9444                                                 else:
9445                                                     raise SaltInvocationError(
9446                                                         'Element "{}" must be included'
9447                                                         " in the policy configuration"
9448                                                         " for policy {}".format(
9449                                                             this_element_name,
9450                                                             policy_name,
9451                                                         )
9452                                                     )
9453                                                 if (
9454                                                     "required" in child_item.attrib
9455                                                     and child_item.attrib[
9456                                                         "required"
9457                                                     ].lower()
9458                                                     == "true"
9459                                                 ):
9460                                                     if not _admTemplateData[
9461                                                         policy_namespace
9462                                                     ][policy_name][temp_element_name]:
9463                                                         raise SaltInvocationError(
9464                                                             'Element "{}" requires a value '
9465                                                             "to be specified".format(
9466                                                                 temp_element_name
9467                                                             )
9468                                                         )
9469                                                 if (
9470                                                     etree.QName(child_item).localname
9471                                                     == "boolean"
9472                                                 ):
9473                                                     if not isinstance(
9474                                                         _admTemplateData[
9475                                                             policy_namespace
9476                                                         ][policy_name][
9477                                                             temp_element_name
9478                                                         ],
9479                                                         bool,
9480                                                     ):
9481                                                         raise SaltInvocationError(
9482                                                             "Element {} requires a boolean "
9483                                                             "True or False".format(
9484                                                                 temp_element_name
9485                                                             )
9486                                                         )
9487                                                 elif (
9488                                                     etree.QName(child_item).localname
9489                                                     == "decimal"
9490                                                     or etree.QName(child_item).localname
9491                                                     == "longDecimal"
9492                                                 ):
9493                                                     min_val = 0
9494                                                     max_val = 9999
9495                                                     if "minValue" in child_item.attrib:
9496                                                         min_val = int(
9497                                                             child_item.attrib[
9498                                                                 "minValue"
9499                                                             ]
9500                                                         )
9501                                                     if "maxValue" in child_item.attrib:
9502                                                         max_val = int(
9503                                                             child_item.attrib[
9504                                                                 "maxValue"
9505                                                             ]
9506                                                         )
9507                                                     if (
9508                                                         int(
9509                                                             _admTemplateData[
9510                                                                 policy_namespace
9511                                                             ][policy_name][
9512                                                                 temp_element_name
9513                                                             ]
9514                                                         )
9515                                                         &lt; min_val
9516                                                         or int(
9517                                                             _admTemplateData[
9518                                                                 policy_namespace
9519                                                             ][policy_name][
9520                                                                 temp_element_name
9521                                                             ]
9522                                                         )
9523                                                         &gt; max_val
9524                                                     ):
9525                                                         raise SaltInvocationError(
9526                                                             'Element "{}" value must be between '
9527                                                             "{} and {}".format(
9528                                                                 temp_element_name,
9529                                                                 min_val,
9530                                                                 max_val,
9531                                                             )
9532                                                         )
9533                                                 elif (
9534                                                     etree.QName(child_item).localname
9535                                                     == "enum"
9536                                                 ):
9537                                                     found = False
9538                                                     for enum_item in child_item:
9539                                                         if (
9540                                                             _admTemplateData[
9541                                                                 policy_namespace
9542                                                             ][policy_name][
9543                                                                 temp_element_name
9544                                                             ]
9545                                                             == _getAdmlDisplayName(
9546                                                                 adml_policy_resources,
9547                                                                 enum_item.attrib[
9548                                                                     "displayName"
9549                                                                 ],
9550                                                             ).strip()
9551                                                         ):
9552                                                             found = True
9553                                                             break
9554                                                     if not found:
9555                                                         raise SaltInvocationError(
9556                                                             'Element "{}" does not have'
9557                                                             " a valid value".format(
9558                                                                 temp_element_name
9559                                                             )
9560                                                         )
9561                                                 elif (
9562                                                     etree.QName(child_item).localname
9563                                                     == "list"
9564                                                 ):
9565                                                     if (
9566                                                         "explicitValue"
9567                                                         in child_item.attrib
9568                                                         and child_item.attrib[
9569                                                             "explicitValue"
9570                                                         ].lower()
9571                                                         == "true"
9572                                                     ):
9573                                                         if not isinstance(
9574                                                             _admTemplateData[
9575                                                                 policy_namespace
9576                                                             ][policy_name][
9577                                                                 temp_element_name
9578                                                             ],
9579                                                             dict,
9580                                                         ):
9581                                                             raise SaltInvocationError(
9582                                                                 "Each list item of element "
9583                                                                 '"{}" requires a dict '
9584                                                                 "value".format(
9585                                                                     temp_element_name
9586                                                                 )
9587                                                             )
9588                                                     elif not isinstance(
9589                                                         _admTemplateData[
9590                                                             policy_namespace
9591                                                         ][policy_name][
9592                                                             temp_element_name
9593                                                         ],
9594                                                         list,
9595                                                     ):
9596                                                         raise SaltInvocationError(
9597                                                             'Element "{}" requires a'
9598                                                             " list value".format(
9599                                                                 temp_element_name
9600                                                             )
9601                                                         )
9602                                                 elif (
9603                                                     etree.QName(child_item).localname
9604                                                     == "multiText"
9605                                                 ):
9606                                                     if not isinstance(
9607                                                         _admTemplateData[
9608                                                             policy_namespace
9609                                                         ][policy_name][
9610                                                             temp_element_name
9611                                                         ],
9612                                                         list,
9613                                                     ):
9614                                                         raise SaltInvocationError(
9615                                                             'Element "{}" requires a'
9616                                                             " list value".format(
9617                                                                 temp_element_name
9618                                                             )
9619                                                         )
9620                                                 _admTemplateData[policy_namespace][
9621                                                     policy_name
9622                                                 ][
9623                                                     child_item.attrib["id"]
9624                                                 ] = _admTemplateData[
9625                                                     policy_namespace
9626                                                 ][
9627                                                     policy_name
9628                                                 ].pop(
9629                                                     temp_element_name
9630                                                 )
9631                                     else:
9632                                         raise SaltInvocationError(
9633                                             'The policy "{}" has elements which must be'
9634                                             " configured".format(policy_name)
9635                                         )
9636                                 else:
9637                                     if (
9638                                         str(
9639                                             _admTemplateData[policy_namespace][
9640                                                 policy_name
9641                                             ]
9642                                         ).lower()
9643                                         != "enabled"
9644                                     ):
9645                                         raise SaltInvocationError(
9646                                             'The policy {} must either be "Enabled", '
9647                                             '"Disabled", or "Not Configured"'.format(
9648                                                 policy_name
9649                                             )
9650                                         )
9651                 if _regedits:
9652                     for regedit in _regedits:
9653                         log.trace("%s is a Registry policy", regedit)
9654                         if (
9655                             _regedits[regedit]["value"] is not None
9656                             and _regedits[regedit]["value"] != "(value not set)"
9657                         ):
9658                             _ret = __utils__["reg.set_value"](
9659                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
9660                                 _regedits[regedit]["policy"]["Registry"]["Path"],
9661                                 _regedits[regedit]["policy"]["Registry"]["Value"],
9662                                 _regedits[regedit]["value"],
9663                                 _regedits[regedit]["policy"]["Registry"]["Type"],
9664                             )
9665                         else:
9666                             _ret = __utils__["reg.read_value"](
9667                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
9668                                 _regedits[regedit]["policy"]["Registry"]["Path"],
9669                                 _regedits[regedit]["policy"]["Registry"]["Value"],
9670                             )
9671                             if _ret["success"] and _ret["vdata"] != "(value not set)":
9672                                 _ret = __utils__["reg.delete_value"](
9673                                     _regedits[regedit]["policy"]["Registry"]["Hive"],
9674                                     _regedits[regedit]["policy"]["Registry"]["Path"],
9675                                     _regedits[regedit]["policy"]["Registry"]["Value"],
9676                                 )
9677                         if not _ret:
9678                             raise CommandExecutionError(
9679                                 "Error while attempting to set policy {} via the"
9680                                 " registry.  Some changes may not be applied as"
9681                                 " expected".format(regedit)
9682                             )
9683                 if _lsarights:
9684                     for lsaright in _lsarights:
9685                         _existingUsers = None
9686                         if not cumulative_rights_assignments:
9687                             _existingUsers = _getRightsAssignments(
9688                                 _lsarights[lsaright]["policy"]["LsaRights"]["Option"]
9689                             )
9690                         if _lsarights[lsaright]["value"]:
9691                             for acct in _lsarights[lsaright]["value"]:
9692                                 _ret = _addAccountRights(
9693                                     acct,
9694                                     _lsarights[lsaright]["policy"]["LsaRights"][
9695                                         "Option"
9696                                     ],
9697                                 )
9698                                 if not _ret:
9699                                     raise SaltInvocationError(
9700                                         "An error occurred attempting to configure the"
9701                                         " user right {}.".format(lsaright)
9702                                     )
9703                         if _existingUsers:
9704                             for acct in _existingUsers:
9705                                 if acct not in _lsarights[lsaright]["value"]:
9706                                     _ret = _delAccountRights(
9707                                         acct,
9708                                         _lsarights[lsaright]["policy"]["LsaRights"][
9709                                             "Option"
9710                                         ],
9711                                     )
9712                                     if not _ret:
9713                                         raise SaltInvocationError(
9714                                             "An error occurred attempting to remove previously "
9715                                             "configured users with right {}.".format(
9716                                                 lsaright
9717                                             )
9718                                         )
9719                 if _secedits:
9720                     log.trace(_secedits)
9721                     ini_data = "\r\n".join(["[Unicode]", "Unicode=yes"])
9722                     _seceditSections = [
9723                         "System Access",
9724                         "Event Audit",
9725                         "Registry Values",
9726                         "Privilege Rights",
9727                     ]
9728                     for _seceditSection in _seceditSections:
9729                         if _seceditSection in _secedits:
9730                             ini_data = "\r\n".join(
9731                                 [
9732                                     ini_data,
9733                                     "".join(["[", _seceditSection, "]"]),
9734                                     "\r\n".join(_secedits[_seceditSection]),
9735                                 ]
9736                             )
9737                     ini_data = "\r\n".join(
9738                         [ini_data, "[Version]", 'signature="$CHICAGO$"', "Revision=1"]
9739                     )
9740                     log.trace("ini_data == %s", ini_data)
9741                     if not _write_secedit_data(ini_data):
9742                         raise CommandExecutionError(
9743                             "Error while attempting to set policies via "
9744                             "secedit. Some changes may not be applied as "
9745                             "expected"
9746                         )
9747                 if _netshs:
9748                     for setting in _netshs:
9749                         log.trace("Setting firewall policy: %s", setting)
9750                         log.trace(_netshs[setting])
9751                         _set_netsh_value(**_netshs[setting])
9752                 if _advaudits:
9753                     for setting in _advaudits:
9754                         log.trace("Setting Advanced Audit policy: %s", setting)
9755                         log.trace(_advaudits[setting])
9756                         _set_advaudit_value(**_advaudits[setting])
9757                 if _modal_sets:
9758                     log.trace(_modal_sets)
9759                     for _modal_set in _modal_sets:
9760                         try:
9761                             _existingModalData = win32net.NetUserModalsGet(
9762                                 None, _modal_set
9763                             )
9764                             _newModalSetData = dictupdate.update(
9765                                 _existingModalData, _modal_sets[_modal_set]
9766                             )
9767                             log.trace("NEW MODAL SET = %s", _newModalSetData)
9768                             _ret = win32net.NetUserModalsSet(
9769                                 None, _modal_set, _newModalSetData
9770                             )
9771                         except Exception as exc:  # pylint: disable=broad-except
9772                             msg = (
9773                                 "An unhandled exception occurred while "
9774                                 "attempting to set policy via "
9775                                 "NetUserModalSet\n{}".format(exc)
9776                             )
9777                             log.exception(msg)
9778                             raise CommandExecutionError(msg)
9779                 if _admTemplateData:
9780                     _ret = False
9781                     log.trace(
9782                         "going to write some adm template data :: %s", _admTemplateData
9783                     )
9784                     _ret = _writeAdminTemplateRegPolFile(
9785                         _admTemplateData,
9786                         adml_language=adml_language,
9787                         registry_class=p_class,
9788                     )
9789                     if not _ret:
9790                         raise CommandExecutionError(
9791                             "Error while attempting to write Administrative Template"
9792                             " Policy data.  Some changes may not be applied as expected"
9793                         )
9794         return True
9795     else:
9796         raise SaltInvocationError("You have to specify something!")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
