<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for httpserver_test.py &amp; win_lgpo_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for httpserver_test.py &amp; win_lgpo_1.py
      </h3>
<h1 align="center">
        2.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>httpserver_test.py (7.725322%)<th>win_lgpo_1.py (1.8210431%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-24)<td><a href="#" name="0">(39-59)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(196-199)<td><a href="#" name="1">(1798-1822)</a><td align="center"><font color="#d80000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(271-275)<td><a href="#" name="2">(9617-9626)</a><td align="center"><font color="#b20000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(709-714)<td><a href="#" name="3">(5110-5112)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(261-267)<td><a href="#" name="4">(8922-8926)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(243-247)<td><a href="#" name="5">(8144-8155)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(865-869)<td><a href="#" name="6">(6241-6247)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(742-745)<td><a href="#" name="7">(7542-7548)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(727-731)<td><a href="#" name="8">(7632-7638)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(608-611)<td><a href="#" name="9">(6039-6043)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(276-278)<td><a href="#" name="10">(7462-7467)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(173-175)<td><a href="#" name="11">(5392-5394)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>httpserver_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado import netutil
3 from salt.ext.tornado.escape import json_decode, json_encode, utf8, _unicode, recursive_unicode, native_str
4 from salt.ext.tornado import gen
5 from salt.ext.tornado.http1connection import HTTP1Connection
6 from salt.ext.tornado.httpserver import HTTPServer
7 from salt.ext.tornado.httputil import HTTPHeaders, HTTPMessageDelegate, HTTPServerConnectionDelegate, ResponseStartLine
8 from salt.ext.tornado.iostream import IOStream
9 from salt.ext.tornado.log import gen_log
10 from salt.ext.tornado.netutil import ssl_options_to_context
11 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
12 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog, gen_test
13 from salt.ext.tornado.test.util import unittest, skipOnTravis
14 from salt.ext.tornado.web import Application, RequestHandler, asynchronous, stream_request_body
15 from contextlib import closing
16 import datetime
17 import gzip
18 import os
19 import shutil
20 import</b></font> socket
21 import ssl
22 import sys
23 import tempfile
24 from io import BytesIO
25 def read_stream_body(stream, callback):
26         module_dir <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= os.path.dirname(__file__)
27         existing_certificate = os.path.join(module_dir, 'test.crt')
28         existing_key = os.path.join(</b></font>module_dir, 'test.key')
29         self.assertRaises((ValueError, IOError),
30                           HTTPServer, application, ssl_options={
31                               "certfile": "/__mising__.crt",
32         })
33         self.assertRaises((ValueError, IOError),
34                           HTTPServer, application, ssl_options={
35                               "certfile": existing_certificate,
36                               "keyfile": "/__missing__.key"
37         })
38         HTTPServer(application, ssl_options={
39                    "certfile": existing_certificate,
40                    "keyfile": existing_key,
41                    })
42 <a name="1"></a>
43 class MultipartTestHandler(RequestHandler):
44     def post(self):
45         self.finish({<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"header": self.request.headers["X-Header-Encoding-Test"],
46                      "argument": self.get_argument("argument"),
47                      "filename": self.request.files["files"][0].filename,
48                      "filebody": _unicode(self.request.files["files"][0][</b></font>"body"]),
49                      })
50 class HTTPConnectionTest(AsyncHTTPTestCase):
51     def get_handlers(self):
52         return [("/multipart", MultipartTestHandler),
53                 ("/hello", HelloWorldRequestHandler)]
54     def get_app(self):
55         return Application(self.get_handlers())
56     def raw_fetch(self, headers, body, newline=b"\r\n"):
57         with closing(IOStream(socket.socket())) as stream:
58             stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
59             self.wait()
60             stream.write(
61                 newline.join(headers +
62                              [utf8("Content-Length: %d" % len(body))]) +
63                 newline + newline + body)
64             read_stream_body(stream, self.stop)
65             headers, body = self.wait()
66             return body
67     def test_multipart_form(self):
68         response = self.raw_fetch([
69             b"POST /multipart HTTP/1.0",
70             b"Content-Type: multipart/form-data; boundary=1234567890",
71             b"X-Header-encoding-test: \xe9",
72         ],
73             b"\r\n".join([
74                 b"Content-Disposition: form-data; name=argument",
75                 b"",
76                 u"\u00e1".encode("utf-8"),
77                 b"--1234567890",
78                 u'Content-Disposition: form-data; name="files"; filename="\u00f3"'.encode("utf8"),
79                 b"",
80                 u"\u00fa".encode("utf-8"),
81 <a name="5"></a>                b"--1234567890--",
82                 b"",
83             ]))
84         data = json_decode<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(response)
85         self.assertEqual(u"\u00e9", data["header"])
86         self.assertEqual(u"\u00e1", data["argument"])
87         self.assertEqual(u"\u00f3", data["filename"])
88         self.assertEqual(u"\u00fa", data[</b></font>"filebody"])
89     def test_newlines(self):
90         for newline in (b"\r\n", b"\n"):
91             response = self.raw_fetch([b"GET /hello HTTP/1.0"], b"",
92                                       newline=newline)
93             self.assertEqual(response, b'Hello world')
94     def test_100_continue(self):
95         stream = IOStream(socket.socket(), io_loop=self.io_loop)
96         stream.connect(("127.0.0.1", self<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get_http_port()), callback=self.stop)
97         self.wait()
98         stream.write(b"\r\n".join([b"POST /hello HTTP/1.1",
99                                    b"Content-Length: 1024",
100                                    b"Expect: 100-continue",
101                                    b"Connection: close",
102                                    b"\r\n"]), callback=self.</b></font>stop)
103 <a name="2"></a>        self.wait()
104         stream.read_until(b"\r\n\r\n", self.stop)
105         data = self.wait()
106         self.assertTrue<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(data.startswith(b"HTTP/1.1 100 "), data)
107         stream.write(b"a" * 1024)
108 <a name="10"></a>        stream.read_until(b"\r\n", self.stop)
109         first_line = self.wait()
110         self.assertTrue(first_line.</b></font>startswith(b"HTTP/1.1 200"), first_line)
111         stream<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.read_until(b"\r\n\r\n", self.stop)
112         header_data = self.wait()
113         headers = HTTPHeaders.parse(native_str(header_data.decode(</b></font>'latin1')))
114         stream.read_bytes(int(headers["Content-Length"]), self.stop)
115         body = self.wait()
116         self.assertEqual(body, b"Got 1024 bytes in POST")
117         stream.close()
118 class EchoHandler(RequestHandler):
119     def get(self):
120         self.write(recursive_unicode(self.request.arguments))
121     def post(self):
122         self.write(recursive_unicode(self.request.arguments))
123 class TypeCheckHandler(RequestHandler):
124     def prepare(self):
125         self.errors = {}
126         fields = [
127             ('method', str),
128             ('uri', str),
129             ('version', str),
130             ('remote_ip', str),
131             ('protocol', str),
132             ('host', str),
133             ('path', str),
134             ('query', str),
135         ]
136         for field, expected_type in fields:
137             self.check_type(field, getattr(self.request, field), expected_type)
138         self.check_type('header_key', list(self.request.headers.keys())[0], str)
139         self.check_type('header_value', list(self.request.headers.values())[0], str)
140         self.check_type('cookie_key', list(self.request.cookies.keys())[0], str)
141         self.check_type('cookie_value', list(self.request.cookies.values())[0].value, str)
142         self.check_type('arg_key', list(self.request.arguments.keys())[0], str)
143         self.check_type('arg_value', list(self.request.arguments.values())[0][0], bytes)
144     def post(self):
145         self.check_type('body', self.request.body, bytes)
146         self.write(self.errors)
147     def get(self):
148         self.write(self.errors)
149     def check_type(self, name, obj, expected_type):
150         actual_type = type(obj)
151         if expected_type != actual_type:
152             self.errors[name] = "expected %s, got %s" % (expected_type,
153                                                          actual_type)
154 class HTTPServerTest(AsyncHTTPTestCase):
155     def get_app(self):
156         return Application([("/echo", EchoHandler),
157                             ("/typecheck", TypeCheckHandler),
158                             ("//doubleslash", EchoHandler),
159                             ])
160     def test_query_string_encoding(self):
161         response = self.fetch("/echo?foo=%C3%A9")
162         data = json_decode(response.body)
163         self.assertEqual(data, {u"foo": [u"\u00e9"]})
164     def test_empty_query_string(self):
165         response = self.fetch("/echo?foo=&amp;foo=")
166         data = json_decode(response.body)
167         self.assertEqual(data, {u"foo": [u"", u""]})
168     def test_empty_post_parameters(self):
169         response = self.fetch("/echo", method="POST", body="foo=&amp;bar=")
170         data = json_decode(response.body)
171         self.assertEqual(data, {u"foo": [u""], u"bar": [u""]})
172     def test_types(self):
173         headers = {"Cookie": "foo=bar"}
174         response = self.fetch("/typecheck?foo=bar", headers=headers)
175         data = json_decode(response.body)
176         self.assertEqual(data, {})
177         response = self.fetch("/typecheck", method="POST", body="foo=bar", headers=headers)
178         data = json_decode(response.body)
179         self.assertEqual(data, {})
180     def test_double_slash(self):
181         response = self.fetch("//doubleslash")
182         self.assertEqual(200, response.code)
183         self.assertEqual(json_decode(response.body), {})
184     def test_malformed_body(self):
185         if str is bytes:
186             return
187         with ExpectLog(gen_log, 'Invalid x-www-form-urlencoded body'):
188             response = self.fetch(
189                 '/echo', method="POST",
190                 headers={'Content-Type': 'application/x-www-form-urlencoded'},
191                 body=b'\xe9')
192         self.assertEqual(200, response.code)
193         self.assertEqual(b'{}', response.body)
194 class HTTPServerRawTest(AsyncHTTPTestCase):
195     def get_app(self):
196         return Application([
197             ('/echo', EchoHandler),
198         ])
199     def setUp(self):
200         super(HTTPServerRawTest, self).setUp()
201         self.stream = IOStream(socket.socket())
202         self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
203         self.wait()
204     def tearDown(self):
205         self.stream.close()
206         super(HTTPServerRawTest, self).tearDown()
207     def test_empty_request(self):
208         self.stream.close()
209         self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
210         self.wait()
211     def test_malformed_first_line(self):
212         with ExpectLog(gen_log, '.*Malformed HTTP request line'):
213             self.stream.write(b'asdf\r\n\r\n')
214             self.io_loop.add_timeout(datetime.timedelta(seconds=0.05),
215                                      self.stop)
216             self.wait()
217     def test_malformed_headers(self):
218         with ExpectLog(gen_log, '.*Malformed HTTP headers'):
219             self.stream.write(b'GET / HTTP/1.0\r\nasdf\r\n\r\n')
220             self.io_loop.add_timeout(datetime.timedelta(seconds=0.05),
221                                      self.stop)
222             self.wait()
223     def test_chunked_request_body(self):
224         self.stream.write(b"""\
225 POST /echo HTTP/1.1
226 Transfer-Encoding: chunked
227 Content-Type: application/x-www-form-urlencoded
228 4
229 foo=
230 3
231 bar
232 0
233         read_stream_body(self.stream, self.stop)
234         headers, response = self.wait()
235         self.assertEqual(json_decode(response), {u'foo': [u'bar']})
236     def test_invalid_content_length(self):
237         with ExpectLog(gen_log, '.*Only integer Content-Length is allowed'):
238             self.stream.write(b"""\
239 POST /echo HTTP/1.1
240 Content-Length: foo
241 bar
242     Why would you want to do this?  Nginx can proxy to backends listening
243     on unix sockets, for one thing (and managing a namespace for unix
244     sockets can be easier than managing a bunch of TCP port numbers).
245     Unfortunately, there's no way to specify a unix socket in a url for
246     an HTTP client, so we have to test this by hand.
247         self<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.stream.close()
248         self.server.stop()
249         shutil.rmtree(self.tmpdir)
250         super(UnixSocketTest, self).tearDown(</b></font>)
251     def test_unix_socket(self):
252         self.stream.write(b"GET /hello HTTP/1.0\r\n\r\n")
253         self.stream.read_until(b"\r\n", self.stop)
254         response = self.wait()
255         self.assertEqual(response, b"HTTP/1.1 200 OK\r\n")
256         self.stream.read_until(b"\r\n\r\n", self.stop)
257         headers = HTTPHeaders.parse(self.wait().decode('latin1'))
258         self.stream.read_bytes(int(headers["Content-Length"]), self.stop)
259         body = self.wait()
260         self.assertEqual(body, b"Hello world")
261     def test_unix_socket_bad_request(self):
262         with ExpectLog(gen_log, "Malformed HTTP message from"):
263             self.stream.write(b"garbage\r\n\r\n")
264             self.stream.read_until_close(self.stop)
265             response = self.wait()
266         self.assertEqual(response, b"")
267 class KeepAliveTest(AsyncHTTPTestCase):
268     def get_app(self):
269         class HelloHandler(RequestHandler):
270             def get(self):
271                 self.finish('Hello world')
272             def post(self):
273                 self.finish('Hello world')
274         class LargeHandler(RequestHandler):
275             def get(self):
276                 self.write(''.join(chr(i % 256) * 1024 for i in range(512)))
277         class FinishOnCloseHandler(RequestHandler):
278             @asynchronous
279             def get(self):
280                 self.flush()
281             def on_connection_close(self):
282                 self.finish('closed')
283         return Application([('/', HelloHandler),
284                             ('/large', LargeHandler),
285                             ('/finish_on_close', FinishOnCloseHandler)])
286     def setUp(self):
287         super(KeepAliveTest, self).setUp()
288         self.http_version = b'HTTP/1.1'
289     def tearDown(self):
290         self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
291         self.wait()
292         if hasattr(self, 'stream'):
293             self.stream.close()
294         super(KeepAliveTest, self).tearDown()
295     def connect(self):
296         self.stream = IOStream(socket.socket(), io_loop=self.io_loop)
297         self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
298         self.wait()
299     def read_headers(self):
300         self.stream.read_until(b'\r\n', self.stop)
301         first_line = self.wait()
302         self.assertTrue(first_line.startswith(b'HTTP/1.1 200'), first_line)
303         self.stream.read_until(b'\r\n\r\n', self.stop)
304         header_bytes = self.wait()
305         headers = HTTPHeaders.parse(header_bytes.decode('latin1'))
306         return headers
307     def read_response(self):
308         self.headers = self.read_headers()
309         self.stream.read_bytes(int(self.headers['Content-Length']), self.stop)
310         body = self.wait()
311         self.assertEqual(b'Hello world', body)
312     def close(self):
313         self.stream.close()
314 <a name="3"></a>        del self.stream
315     def test_two_requests(self):
316         self<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.connect()
317         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
318         self.read_response()
319         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
320         self.read_response()
321         self.</b></font>close()
322     def test_request_close(self):
323         self.connect()
324         self.stream.write(b'GET / HTTP/1.1\r\nConnection: close\r\n\r\n')
325         self.read_response()
326         self.stream.read_until_close(callback=self.stop)
327         data = self.wait()
328         self.assertTrue(not data)
329         self.close()
330 <a name="8"></a>
331     def test_http10(self):
332         self<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.http_version = b'HTTP/1.0'
333         self.connect()
334         self.stream.write(b'GET / HTTP/1.0\r\n\r\n')
335         self.read_response()
336         self.stream.read_until_close(</b></font>callback=self.stop)
337         data = self.wait()
338         self.assertTrue(not data)
339         self.assertTrue('Connection' not in self.headers)
340         self.close()
341     def test_http10_keepalive(self):
342         self.http_version = b'HTTP/1.0'
343 <a name="7"></a>        self.connect()
344         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
345         self.read_response()
346         self<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(self.headers['Connection'], 'Keep-Alive')
347         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
348         self.read_response()
349         self.assertEqual(self.</b></font>headers['Connection'], 'Keep-Alive')
350         self.close()
351     def test_http10_keepalive_extra_crlf(self):
352         self.http_version = b'HTTP/1.0'
353         self.connect()
354         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n\r\n')
355         self.read_response()
356         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
357         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
358         self.read_response()
359         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
360         self.close()
361     def test_pipelined_requests(self):
362         self.connect()
363         self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
364         self.read_response()
365         self.read_response()
366         self.close()
367     def test_pipelined_cancel(self):
368         self.connect()
369         self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
370         self.read_response()
371         self.close()
372     def test_cancel_during_download(self):
373         self.connect()
374         self.stream.write(b'GET /large HTTP/1.1\r\n\r\n')
375         self.read_headers()
376         self.stream.read_bytes(1024, self.stop)
377         self.wait()
378         self.close()
379     def test_finish_while_closed(self):
380         self.connect()
381         self.stream.write(b'GET /finish_on_close HTTP/1.1\r\n\r\n')
382         self.read_headers()
383         self.close()
384     def test_keepalive_chunked(self):
385         self.http_version = b'HTTP/1.0'
386         self.connect()
387         self.stream.write(b'POST / HTTP/1.0\r\n'
388                           b'Connection: keep-alive\r\n'
389                           b'Transfer-Encoding: chunked\r\n'
390                           b'\r\n'
391                           b'0\r\n'
392                           b'\r\n')
393         self.read_response()
394         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
395         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
396         self.read_response()
397         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
398         self.close()
399 class GzipBaseTest(object):
400     def get_app(self):
401         return Application([('/', EchoHandler)])
402     def post_gzip(self, body):
403         bytesio = BytesIO()
404         gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
405         gzip_file.write(utf8(body))
406         gzip_file.close()
407         compressed_body = bytesio.getvalue()
408         return self.fetch('/', method='POST', body=compressed_body,
409                           headers={'Content-Encoding': 'gzip'})
410     def test_uncompressed(self):
411         response = self.fetch('/', method='POST', body='foo=bar')
412         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
413 class GzipTest(GzipBaseTest, AsyncHTTPTestCase):
414     def get_httpserver_options(self):
415         return dict(decompress_request=True)
416     def test_gzip(self):
417         response = self.post_gzip('foo=bar')
418         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
419 class GzipUnsupportedTest(GzipBaseTest, AsyncHTTPTestCase):
420     def test_gzip_unsupported(self):
421         with ExpectLog(gen_log, "Unsupported Content-Encoding"):
422             response = self.post_gzip('foo=bar')
423         self.assertEquals(json_decode(response.body), {})
424 class StreamingChunkSizeTest(AsyncHTTPTestCase):
425     BODY = b'01234567890123456789012345678901234567890123456789'
426     CHUNK_SIZE = 16
427     def get_http_client(self):
428         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
429     def get_httpserver_options(self):
430         return dict(chunk_size=self.CHUNK_SIZE, decompress_request=True)
431     class MessageDelegate(HTTPMessageDelegate):
432         def __init__(self, connection):
433             self.connection = connection
434         def headers_received(self, start_line, headers):
435             self.chunk_lengths = []
436         def data_received(self, chunk):
437 <a name="6"></a>            self.chunk_lengths.append(len(chunk))
438         def finish(self):
439             response_body = utf8<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(json_encode(self.chunk_lengths))
440             self.connection.write_headers(
441                 ResponseStartLine('HTTP/1.1', 200, 'OK'),
442                 HTTPHeaders({'Content-Length': str(len(response_body))}))
443             self.</b></font>connection.write(response_body)
444             self.connection.finish()
445     def get_app(self):
446         class App(HTTPServerConnectionDelegate):
447             def start_request(self, server_conn, request_conn):
448                 return StreamingChunkSizeTest.MessageDelegate(request_conn)
449         return App()
450     def fetch_chunk_sizes(self, **kwargs):
451         response = self.fetch('/', method='POST', **kwargs)
452         response.rethrow()
453         chunks = json_decode(response.body)
454         self.assertEqual(len(self.BODY), sum(chunks))
455         for chunk_size in chunks:
456             self.assertLessEqual(chunk_size, self.CHUNK_SIZE,
457                                  'oversized chunk: ' + str(chunks))
458             self.assertGreater(chunk_size, 0,
459                                'empty chunk: ' + str(chunks))
460         return chunks
461     def compress(self, body):
462         bytesio = BytesIO()
463         gzfile = gzip.GzipFile(mode='w', fileobj=bytesio)
464         gzfile.write(body)
465         gzfile.close()
466         compressed = bytesio.getvalue()
467         if len(compressed) &gt;= len(body):
468             raise Exception("body did not shrink when compressed")
469         return compressed
470     def test_regular_body(self):
471         chunks = self.fetch_chunk_sizes(body=self.BODY)
472         self.assertEqual([16, 16, 16, 2], chunks)
473     def test_compressed_body(self):
474         self.fetch_chunk_sizes(body=self.compress(self.BODY),
475                                headers={'Content-Encoding': 'gzip'})
476     def test_chunked_body(self):
477         def body_producer(write):
478             write(self.BODY[:20])
479             write(self.BODY[20:])
480         chunks = self.fetch_chunk_sizes(body_producer=body_producer)
481         self.assertEqual([16, 4, 16, 14], chunks)
482     def test_chunked_compressed(self):
483         compressed = self.compress(self.BODY)
484         self.assertGreater(len(compressed), 20)
485         def body_producer(write):
486             write(compressed[:20])
487             write(compressed[20:])
488         self.fetch_chunk_sizes(body_producer=body_producer,
489                                headers={'Content-Encoding': 'gzip'})
490 class MaxHeaderSizeTest(AsyncHTTPTestCase):
491     def get_app(self):
492         return Application([('/', HelloWorldRequestHandler)])
493     def get_httpserver_options(self):
494         return dict(max_header_size=1024)
495     def test_small_headers(self):
496         response = self.fetch("/", headers={'X-Filler': 'a' * 100})
497         response.rethrow()
498         self.assertEqual(response.body, b"Hello world")
499     def test_large_headers(self):
500         with ExpectLog(gen_log, "Unsatisfiable read", required=False):
501             response = self.fetch("/", headers={'X-Filler': 'a' * 1000})
502         self.assertIn(response.code, (431, 599))
503 @skipOnTravis
504 class IdleTimeoutTest(AsyncHTTPTestCase):
505     def get_app(self):
506         return Application([('/', HelloWorldRequestHandler)])
507     def get_httpserver_options(self):
508         return dict(idle_connection_timeout=0.1)
509     def setUp(self):
510         super(IdleTimeoutTest, self).setUp()
511         self.streams = []
512     def tearDown(self):
513         super(IdleTimeoutTest, self).tearDown()
514         for stream in self.streams:
515             stream.close()
516     def connect(self):
517         stream = IOStream(socket.socket())
518         stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
519         self.wait()
520         self.streams.append(stream)
521         return stream
522     def test_unused_connection(self):
523         stream = self.connect()
524         stream.set_close_callback(self.stop)
525         self.wait()
526     def test_idle_after_use(self):
527         stream = self.connect()
528         stream.set_close_callback(lambda: self.stop("closed"))
529         for i in range(2):
530             stream.write(b"GET / HTTP/1.1\r\n\r\n")
531             stream.read_until(b"\r\n\r\n", self.stop)
532             self.wait()
533             stream.read_bytes(11, self.stop)
534             data = self.wait()
535             self.assertEqual(data, b"Hello world")
536         data = self.wait()
537         self.assertEqual(data, "closed")
538 class BodyLimitsTest(AsyncHTTPTestCase):
539     def get_app(self):
540         class BufferedHandler(RequestHandler):
541             def put(self):
542                 self.write(str(len(self.request.body)))
543         @stream_request_body
544         class StreamingHandler(RequestHandler):
545             def initialize(self):
546                 self.bytes_read = 0
547             def prepare(self):
548                 if 'expected_size' in self.request.arguments:
549                     self.request.connection.set_max_body_size(
550                         int(self.get_argument('expected_size')))
551                 if 'body_timeout' in self.request.arguments:
552                     self.request.connection.set_body_timeout(
553                         float(self.get_argument('body_timeout')))
554             def data_received(self, data):
555                 self.bytes_read += len(data)
556             def put(self):
557                 self.write(str(self.bytes_read))
558         return Application([('/buffered', BufferedHandler),
559                             ('/streaming', StreamingHandler)])
560     def get_httpserver_options(self):
561         return dict(body_timeout=3600, max_body_size=4096)
562     def get_http_client(self):
563         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
564     def test_small_body(self):
565         response = self.fetch('/buffered', method='PUT', body=b'a' * 4096)
566         self.assertEqual(response.body, b'4096')
567         response = self.fetch('/streaming', method='PUT', body=b'a' * 4096)
568         self.assertEqual(response.body, b'4096')
569     def test_large_body_buffered(self):
570         with ExpectLog(gen_log, '.*Content-Length too long'):
571             response = self.fetch('/buffered', method='PUT', body=b'a' * 10240)
572         self.assertEqual(response.code, 599)
573     def test_large_body_buffered_chunked(self):
574         with ExpectLog(gen_log, '.*chunked body too large'):
575             response = self.fetch('/buffered', method='PUT',
576                                   body_producer=lambda write: write(b'a' * 10240))
577         self.assertEqual(response.code, 599)
578     def test_large_body_streaming(self):
579         with ExpectLog(gen_log, '.*Content-Length too long'):
580             response = self.fetch('/streaming', method='PUT', body=b'a' * 10240)
581         self.assertEqual(response.code, 599)
582     def test_large_body_streaming_chunked(self):
583         with ExpectLog(gen_log, '.*chunked body too large'):
584             response = self.fetch('/streaming', method='PUT',
585                                   body_producer=lambda write: write(b'a' * 10240))
586         self.assertEqual(response.code, 599)
587     def test_large_body_streaming_override(self):
588         response = self.fetch('/streaming?expected_size=10240', method='PUT',
589                               body=b'a' * 10240)
590         self.assertEqual(response.body, b'10240')
591     def test_large_body_streaming_chunked_override(self):
592         response = self.fetch('/streaming?expected_size=10240', method='PUT',
593                               body_producer=lambda write: write(b'a' * 10240))
594         self.assertEqual(response.body, b'10240')
595     @gen_test
596     def test_timeout(self):
597         stream = IOStream(socket.socket())
598         try:
599             yield stream.connect(('127.0.0.1', self.get_http_port()))
600             stream.write(b'PUT /streaming?body_timeout=0.1 HTTP/1.0\r\n'
601                          b'Content-Length: 42\r\n\r\n')
602             with ExpectLog(gen_log, 'Timeout reading body'):
603                 response = yield stream.read_until_close()
604             self.assertEqual(response, b'')
605         finally:
606             stream.close()
607     @gen_test
608     def test_body_size_override_reset(self):
609         stream = IOStream(socket.socket())
610         try:
611             yield stream.connect(('127.0.0.1', self.get_http_port()))
612             stream.write(b'PUT /streaming?expected_size=10240 HTTP/1.1\r\n'
613                          b'Content-Length: 10240\r\n\r\n')
614             stream.write(b'a' * 10240)
615             headers, response = yield gen.Task(read_stream_body, stream)
616             self.assertEqual(response, b'10240')
617             stream.write(b'PUT /streaming HTTP/1.1\r\n'
618                          b'Content-Length: 10240\r\n\r\n')
619             with ExpectLog(gen_log, '.*Content-Length too long'):
620                 data = yield stream.read_until_close()
621             self.assertEqual(data, b'')
622         finally:
623             stream.close()
624 class LegacyInterfaceTest(AsyncHTTPTestCase):
625     def get_app(self):
626         def handle_request(request):
627             self.http1 = request.version.startswith("HTTP/1.")
628             if not self.http1:
629                 request.connection.write_headers(
630                     ResponseStartLine('', 200, 'OK'),
631                     HTTPHeaders())
632                 request.connection.finish()
633                 return
634             message = b"Hello world"
635             request.write(utf8("HTTP/1.1 200 OK\r\n"
636                                "Content-Length: %d\r\n\r\n" % len(message)))
637             request.write(message)
638             request.finish()
639         return handle_request
640     def test_legacy_interface(self):
641         response = self.fetch('/')
642         if not self.http1:
643             self.skipTest("requires HTTP/1.x")
644         self.assertEqual(response.body, b"Hello world")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_lgpo_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import csv
2 import ctypes
3 import glob
4 import io
5 import locale
6 import logging
7 import os
8 import re
9 import tempfile
10 import time
11 import uuid
12 import zlib
13 import salt.utils.dictupdate as dictupdate
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import salt.utils.stringutils
18 import salt.utils.win_lgpo_netsh
19 from salt.exceptions import CommandExecutionError, SaltInvocationError
20 from</b></font> salt.serializers.configparser import deserialize
21 log = logging.getLogger(__name__)
22 __virtualname__ = "lgpo"
23 __func_alias__ = {"set_": "set"}
24 UUID = uuid.uuid4().hex
25 adm_policy_name_map = {True: {}, False: {}}
26 HAS_WINDOWS_MODULES = False
27 TRUE_VALUE_XPATH = None
28 FALSE_VALUE_XPATH = None
29 ELEMENTS_XPATH = None
30 ENABLED_VALUE_XPATH = None
31 DISABLED_VALUE_XPATH = None
32 ENABLED_LIST_XPATH = None
33 DISABLED_LIST_XPATH = None
34 VALUE_XPATH = None
35 TRUE_LIST_XPATH = None
36 FALSE_LIST_XPATH = None
37 REGKEY_XPATH = None
38 POLICY_ANCESTOR_XPATH = None
39 ALL_CLASS_POLICY_XPATH = None
40 ADML_DISPLAY_NAME_XPATH = None
41 VALUE_LIST_XPATH = None
42 ENUM_ITEM_DISPLAY_NAME_XPATH = None
43 ADMX_SEARCH_XPATH = None
44 ADML_SEARCH_XPATH = None
45 ADMX_DISPLAYNAME_SEARCH_XPATH = None
46 PRESENTATION_ANCESTOR_XPATH = None
47 TEXT_ELEMENT_XPATH = None
48 try:
49     import struct
50     import lxml
51     import win32net
52     import win32security
53     from lxml import etree
54     from salt.utils.win_reg import Registry
55     HAS_WINDOWS_MODULES = True
56     TRUE_VALUE_XPATH = etree.XPath('.//*[local-name() = "trueValue"]')
57     FALSE_VALUE_XPATH = etree.XPath('.//*[local-name() = "falseValue"]')
58     ELEMENTS_XPATH = etree.XPath('.//*[local-name() = "elements"]')
59     ENABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "enabledValue"]')
60     DISABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "disabledValue"]')
61     ENABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "enabledList"]')
62     DISABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "disabledList"]')
63     VALUE_XPATH = etree.XPath('.//*[local-name() = "value"]')
64     TRUE_LIST_XPATH = etree.XPath('.//*[local-name() = "trueList"]')
65     FALSE_LIST_XPATH = etree.XPath('.//*[local-name() = "falseList"]')
66     REGKEY_XPATH = etree.XPath("//*[@key = $keyvalue]")
67     POLICY_ANCESTOR_XPATH = etree.XPath('ancestor::*[local-name() = "policy"]')
68     ALL_CLASS_POLICY_XPATH = etree.XPath(
69         '//*[local-name() = "policy" and (@*[local-name() = "class"] = "Both" or'
70         ' @*[local-name() = "class"] = $registry_class)]'
71     )
72     ADML_DISPLAY_NAME_XPATH = etree.XPath(
73         '//*[local-name() = $displayNameType and @*[local-name() = "id"] ='
74         " $displayNameId]"
75     )
76     VALUE_LIST_XPATH = etree.XPath('.//*[local-name() = "valueList"]')
77     ENUM_ITEM_DISPLAY_NAME_XPATH = etree.XPath(
78         './/*[local-name() = "item" and @*[local-name() = "displayName" ='
79         " $display_name]]"
80     )
81     ADMX_SEARCH_XPATH = etree.XPath(
82         '//*[local-name() = "policy" and @*[local-name() = "name"] = $policy_name and'
83         ' (@*[local-name() = "class"] = "Both" or @*[local-name() = "class"] ='
84         " $registry_class)]"
85     )
86     ADML_SEARCH_XPATH = etree.XPath(
87         '//*[starts-with(text(), $policy_name) and @*[local-name() = "id"]]'
88     )
89     ADMX_DISPLAYNAME_SEARCH_XPATH = etree.XPath(
90         '//*[local-name() = "policy" and @*[local-name() = "displayName"] ='
91         ' $display_name and (@*[local-name() = "class"] = "Both" or @*[local-name() ='
92         ' "class"] = $registry_class) ]'
93     )
94     PRESENTATION_ANCESTOR_XPATH = etree.XPath(
95         'ancestor::*[local-name() = "presentation"]'
96     )
97     TEXT_ELEMENT_XPATH = etree.XPath('.//*[local-name() = "text"]')
98     windll = ctypes.windll.kernel32
99     INSTALL_LANGUAGE = locale.windows_locale.get(
100         windll.GetSystemDefaultUILanguage(), "en_US"
101     ).replace("_", "-")
102 except ImportError:
103     HAS_WINDOWS_MODULES = False
104 class _policy_info:
105     r"""
106     Policy Helper Class
107     ===================
108     The format of the policy dict is as follows:
109     The top most two key/value pairs in the dict divide the policies object into
110     the two sections of local group policy, using the keys "Machine" and "User".
111     The value make-up of these dicts are described below in "Policy Section
112     Definition"
113     Policy Section Definition
114     -------------------------
115     A policy section dict has two required key/value pairs:
116     ============  ==============================================================
117     Key
118     ============  ==============================================================
119     lgpo_section  String matching how the policy section is displayed in the mmc
120                   snap-in ("Computer Configuration" for "Machine" and "User
121                   Configuration" for "User")
122     policies      a dict containing the non-Administrative template policy
123                   definitions, the key for each item is a short/unique
124                   identifier for the policy, the value is described below in
125                   "Policies Definition"
126     ============  ==============================================================
127     Policies Definition
128     -------------------
129     A policies definition item describes the particular policy. There are three
130     child key/value pairs shared with all policy types:
131     ============  ==============================================================
132     Key           Value
133     ============  ==============================================================
134     lgpo_section  A list containing the hierarchical path to the policy in the
135                   gpedit mmc snap-in.
136     Policy        A string containing the name of the policy in the gpedit mmc
137                   snap-in
138     Settings      An object which describes valid settings for the policy. This
139                   can be None for no validation, a list of possible settings, or
140                   a dict with the following key/value pairs:
141                   - **Function:** The class function to use to validate the
142                     setting
143                   - **Args:** A dict of kwargs to pass to the class function
144     ============  ==============================================================
145     Additionally, each policies definition will contain a key/value pair that
146     defines the mechanism that will be used to configure the policy. The
147     available mechanisms are:  NetUserModal, Registry, Secedit, and LsaRights
148     Registry Mechanism
149     ------------------
150     Some policies simply set values in the Windows registry. The value of this
151     key is a dict with the following make-up:
152     =====  =====================================================================
153     Key    Value
154     =====  =====================================================================
155     Hive   A string containing the Registry hive, such as ``HKEY_LOCAL_MACHINE``
156     Path   A string containing the registry key path, such as
157            ``SYSTEM\\CurrentControlSet\\Control\\Lsa``
158     Value  A string containing the name of the registry value, such as
159            **restrictanonymous**
160     Type   A string containing the registry type of the value, such as
161            ``REG_DWORD``
162     =====  =====================================================================
163     Secedit Mechanism
164     -----------------
165     Some policies are configurable via the "secedit.exe" executable. The value
166     of this key is a dict with the following make-up:
167     =======  ===================================================================
168     Key      Value
169     =======  ===================================================================
170     Option   A string containing the name of the policy as it appears in an
171              export from secedit, such as **PasswordComplexity**
172     Section  A string containing the name of the section in which the "Option"
173              value appears in an export from ``secedit``, such as "System
174              Access"
175     =======  ===================================================================
176     LsaRights Mechanism
177     -------------------
178     LSA Rights policies are configured via the LsaRights mechanism. The value of
179     this key is a dict with the following make-up:
180     ======  ====================================================================
181     Key     Value
182     ======  ====================================================================
183     Option  A string containing the programmatic name of the Lsa Right, such as
184             **SeNetworkLogonRight**
185     ======  ====================================================================
186     NetUserModal Mechanism
187     ----------------------
188     Some policies are configurable by the **NetUserModalGet** and
189     **NetUserModalSet** function from pywin32.  The value of this key is a dict
190     with the following make-up:
191     ======  ====================================================================
192     Key     Value
193     ======  ====================================================================
194     Modal   The modal "level" that the particular option is specified in (0-3),
195             see `here &lt;https://msdn.microsoft.com/en-us/library/windows/desktop/
196             aa370656(v=vs.85).aspx&gt;`_
197     Option  The name of the structure member which contains the data for the
198             policy, for example **max_passwd_age**
199     ======  ====================================================================
200     NetSH Mechanism
201     ---------------
202     The firewall policies are configured by the ``netsh.exe`` executable. The
203     value of this key is a dict with the following make-up:
204     =======  ===================================================================
205     Key      Value
206     =======  ===================================================================
207     Profile  The firewall profile to modify. Can be one of Domain, Private, or
208              Public
209     Section  The section of the firewall to modify. Can be one of state,
210              firewallpolicy, settings, or logging.
211     Option   The setting within that section
212     Value    The value of the setting
213     =======  ===================================================================
214     More information can be found in the advfirewall context in netsh. This can
215     be access by opening a netsh prompt. At a command prompt type the following:
216     c:\&gt;netsh
217     netsh&gt;advfirewall
218     netsh advfirewall&gt;set help
219     netsh advfirewall&gt;set domain help
220     AdvAudit Mechanism
221     ------------------
222     The Advanced Audit Policies are configured using a combination of the
223     auditpol command-line utility and modifying the audit.csv file in two
224     locations. The value of this key is a dict with the following make-up:
225     ======  ===================================
226     Key     Value
227     ======  ===================================
228     Option  The Advanced Audit Policy to modify
229     ======  ===================================
230     Transforms
231     ----------
232     Optionally, each policy definition can contain a "Transform" key. The
233     Transform key is used to handle data that is stored and viewed differently.
234     This key's value is a dict with the following key/value pairs:
235     ===  =======================================================================
236     Key  Value
237     ===  =======================================================================
238     Get  The name of the class function to use to transform the data from the
239          stored value to how the value is displayed in the GUI
240     Put The name of the class function to use to transform the data supplied by
241         the user to the correct value that the policy is stored in
242     ===  =======================================================================
243     For example, "Minimum password age" is stored in seconds, but is displayed
244     in days.  Thus the "Get" and "Put" functions for this policy do these
245     conversions so the user is able to set and view the policy using the same
246     data that is shown in the GUI.
247                         "Transform": self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.enabled_one_disabled_zero_no_not_defined_transform,
248                     },
249                     "ClearTextPasswords": {
250                         "Policy": "Store passwords using reversible encryption",
251                         "lgpo_section": self.password_policy_gpedit_path,
252                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
253                         "Secedit": {
254                             "Option": "ClearTextPassword",
255                             "Section": "System Access",
256                         },
257                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
258                     },
259                     "AdminAccountStatus": {
260                         "Policy": "Accounts: Administrator account status",
261                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
262                         "lgpo_section": self.security_options_gpedit_path,
263                         "Secedit": {
264                             "Option": "EnableAdminAccount",
265                             "Section": "System Access",
266                         },
267                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
268                     },
269                     "NoConnectedUser": {
270                         "Policy": "Accounts: Block Microsoft accounts",
271                         "Settings": self.</b></font>block_ms_accounts.keys(),
272                         "lgpo_section": self.security_options_gpedit_path,
273                         "Registry": {
274                             "Hive": "HKEY_LOCAL_MACHINE",
275                             "Path": (
276                                 "SOFTWARE\\Microsoft\\Windows\\"
277                                 "CurrentVersion\\policies\\system"
278                             ),
279                             "Value": "NoConnectedUser",
280                             "Type": "REG_DWORD",
281                         },
282                         "Transform": {
283                             "Get": "_dict_lookup",
284                             "Put": "_dict_lookup",
285                             "GetArgs": {
286                                 "lookup": self.block_ms_accounts,
287                                 "value_lookup": False,
288                             },
289                             "PutArgs": {
290                                 "lookup": self.block_ms_accounts,
291                                 "value_lookup": True,
292                             },
293                         },
294                     },
295                     "GuestAccountStatus": {
296                         "Policy": "Accounts: Guest account status",
297                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
298                         "lgpo_section": self.security_options_gpedit_path,
299                         "Secedit": {
300                             "Option": "EnableGuestAccount",
301                             "Section": "System Access",
302                         },
303                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
304                     },
305                     "LimitBlankPasswordUse": {
306                         "Policy": (
307                             "Accounts: Limit local account use of blank "
308                             "passwords to console logon only"
309                         ),
310                         "lgpo_section": self.security_options_gpedit_path,
311                         "Settings": self.enabled_one_disabled_zero.keys(),
312                         "Registry": {
313                             "Hive": "HKEY_LOCAL_MACHINE",
314                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
315                             "Value": "limitblankpassworduse",
316                             "Type": "REG_DWORD",
317                         },
318                         "Transform": self.enabled_one_disabled_zero_transform,
319                     },
320                     "RenameAdministratorAccount": {
321                         "Policy": "Accounts: Rename administrator account",
322                         "Settings": None,
323                         "lgpo_section": self.security_options_gpedit_path,
324                         "Secedit": {
325                             "Option": "NewAdministratorName",
326                             "Section": "System Access",
327                         },
328                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
329                     },
330                     "RenameGuestAccount": {
331                         "Policy": "Accounts: Rename guest account",
332                         "Settings": None,
333                         "lgpo_section": self.security_options_gpedit_path,
334                         "Secedit": {
335                             "Option": "NewGuestName",
336                             "Section": "System Access",
337                         },
338                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
339                     },
340                     "AuditBaseObjects": {
341                         "Policy": "Audit: Audit the access of global system objects",
342                         "Settings": self.enabled_one_disabled_zero.keys(),
343                         "lgpo_section": self.security_options_gpedit_path,
344                         "Registry": {
345                             "Hive": "HKEY_LOCAL_MACHINE",
346                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
347                             "Value": "AuditBaseObjects",
348                             "Type": "REG_DWORD",
349                         },
350                         "Transform": self.enabled_one_disabled_zero_transform,
351                     },
352                     "SceNoApplyLegacyAuditPolicy": {
353                         "Policy": (
354                             "Audit: Force audit policy subcategory "
355                             "settings (Windows Vista or later) to "
356                             "override audit policy category settings"
357                         ),
358                         "Settings": self.enabled_one_disabled_zero.keys(),
359                         "lgpo_section": self.security_options_gpedit_path,
360                         "Registry": {
361                             "Hive": "HKEY_LOCAL_MACHINE",
362                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
363                             "Value": "SCENoApplyLegacyAuditPolicy",
364                             "Type": "REG_DWORD",
365                         },
366                         "Transform": self.enabled_one_disabled_zero_transform,
367                     },
368                     "DontDisplayLastUserName": {
369                         "Policy": "Interactive logon: Do not display last user name",
370                         "Settings": self.enabled_one_disabled_zero.keys(),
371                         "lgpo_section": self.security_options_gpedit_path,
372                         "Registry": {
373                             "Hive": "HKEY_LOCAL_MACHINE",
374                             "Path": (
375                                 "Software\\Microsoft\\Windows\\"
376                                 "CurrentVersion\\Policies\\System"
377                             ),
378                             "Value": "DontDisplayLastUserName",
379                             "Type": "REG_DWORD",
380                         },
381                         "Transform": self.enabled_one_disabled_zero_transform,
382                     },
383                     "CachedLogonsCount": {
384                         "Policy": (
385                             "Interactive logon: Number of previous "
386                             "logons to cache (in case domain controller "
387                             "is not available)"
388                         ),
389                         "Settings": {
390                             "Function": "_in_range_inclusive",
391                             "Args": {"min": 0, "max": 50},
392                         },
393                         "lgpo_section": self.security_options_gpedit_path,
394                         "Registry": {
395                             "Hive": "HKEY_LOCAL_MACHINE",
396                             "Path": (
397                                 "Software\\Microsoft\\Windows NT\\"
398                                 "CurrentVersion\\Winlogon"
399                             ),
400                             "Value": "CachedLogonsCount",
401                             "Type": "REG_SZ",
402                         },
403                     },
404                     "ForceUnlockLogon": {
405                         "Policy": (
406                             "Interactive logon: Require Domain "
407                             "Controller authentication to unlock "
408                             "workstation"
409                         ),
410                         "Settings": self.enabled_one_disabled_zero.keys(),
411                         "lgpo_section": self.security_options_gpedit_path,
412                         "Registry": {
413                             "Hive": "HKEY_LOCAL_MACHINE",
414                             "Path": (
415                                 "Software\\Microsoft\\Windows NT\\"
416                                 "CurrentVersion\\Winlogon"
417                             ),
418                             "Value": "ForceUnlockLogon",
419                             "Type": "REG_DWORD",
420                         },
421                         "Transform": self.enabled_one_disabled_zero_transform,
422                     },
423                     "ScRemoveOption": {
424                         "Policy": "Interactive logon: Smart card removal behavior",
425                         "Settings": self.sc_removal_lookup.keys(),
426                         "lgpo_section": self.security_options_gpedit_path,
427                         "Registry": {
428                             "Hive": "HKEY_LOCAL_MACHINE",
429                             "Path": (
430                                 "Software\\Microsoft\\Windows NT\\"
431                                 "CurrentVersion\\Winlogon"
432                             ),
433                             "Value": "ScRemoveOption",
434                             "Type": "REG_SZ",
435                         },
436                         "Transform": {
437                             "Get": "_dict_lookup",
438                             "Put": "_dict_lookup",
439                             "GetArgs": {
440                                 "lookup": self.sc_removal_lookup,
441                                 "value_lookup": False,
442                             },
443                             "PutArgs": {
444                                 "lookup": self.sc_removal_lookup,
445                                 "value_lookup": True,
446                             },
447                         },
448                     },
449                     "DisableCAD": {
450                         "Policy": "Interactive logon: Do not require CTRL+ALT+DEL",
451                         "Settings": self.enabled_one_disabled_zero.keys(),
452                         "lgpo_section": self.security_options_gpedit_path,
453                         "Registry": {
454                             "Hive": "HKEY_LOCAL_MACHINE",
455                             "Path": (
456                                 "Software\\Microsoft\\Windows\\"
457                                 "CurrentVersion\\Policies\\System"
458                             ),
459                             "Value": "DisableCAD",
460                             "Type": "REG_DWORD",
461                         },
462                         "Transform": self.enabled_one_disabled_zero_transform,
463                     },
464                     "FilterAdministratorToken": {
465                         "Policy": (
466                             "User Account Control: Admin Approval Mode "
467                             "for the built-in Administrator account"
468                         ),
469                         "Settings": self.enabled_one_disabled_zero.keys(),
470                         "lgpo_section": self.security_options_gpedit_path,
471                         "Registry": {
472                             "Hive": "HKEY_LOCAL_MACHINE",
473                             "Path": (
474                                 "Software\\Microsoft\\Windows\\"
475                                 "CurrentVersion\\Policies\\System"
476                             ),
477                             "Value": "FilterAdministratorToken",
478                             "Type": "REG_DWORD",
479                         },
480                         "Transform": self.enabled_one_disabled_zero_transform,
481                     },
482                     "EnableUIADesktopToggle": {
483                         "Policy": (
484                             "User Account Control: Allow UIAccess "
485                             "applications to prompt for elevation "
486                             "without using the secure desktop"
487                         ),
488                         "Settings": self.enabled_one_disabled_zero.keys(),
489                         "lgpo_section": self.security_options_gpedit_path,
490                         "Registry": {
491                             "Hive": "HKEY_LOCAL_MACHINE",
492                             "Path": (
493                                 "Software\\Microsoft\\Windows\\"
494                                 "CurrentVersion\\Policies\\System"
495                             ),
496                             "Value": "EnableUIADesktopToggle",
497                             "Type": "REG_DWORD",
498                         },
499                         "Transform": self.enabled_one_disabled_zero_transform,
500                     },
501                     "ConsentPromptBehaviorAdmin": {
502                         "Policy": (
503                             "User Account Control: Behavior of the "
504                             "elevation prompt for administrators in "
505                             "Admin Approval Mode"
506                         ),
507                         "Settings": self.uac_admin_prompt_lookup.keys(),
508                         "lgpo_section": self.security_options_gpedit_path,
509                         "Registry": {
510                             "Hive": "HKEY_LOCAL_MACHINE",
511                             "Path": (
512                                 "Software\\Microsoft\\Windows\\"
513                                 "CurrentVersion\\Policies\\System"
514                             ),
515                             "Value": "ConsentPromptBehaviorAdmin",
516                             "Type": "REG_DWORD",
517                         },
518                         "Transform": {
519                             "Get": "_dict_lookup",
520                             "Put": "_dict_lookup",
521                             "GetArgs": {
522                                 "lookup": self.uac_admin_prompt_lookup,
523                                 "value_lookup": False,
524                             },
525                             "PutArgs": {
526                                 "lookup": self.uac_admin_prompt_lookup,
527                                 "value_lookup": True,
528                             },
529                         },
530                     },
531                     "ConsentPromptBehaviorUser": {
532                         "Policy": (
533                             "User Account Control: Behavior of the "
534                             "elevation prompt for standard users"
535                         ),
536                         "Settings": self.uac_user_prompt_lookup.keys(),
537                         "lgpo_section": self.security_options_gpedit_path,
538                         "Registry": {
539                             "Hive": "HKEY_LOCAL_MACHINE",
540                             "Path": (
541                                 "Software\\Microsoft\\Windows\\"
542                                 "CurrentVersion\\Policies\\System"
543                             ),
544                             "Value": "ConsentPromptBehaviorUser",
545                             "Type": "REG_DWORD",
546                         },
547                         "Transform": {
548                             "Get": "_dict_lookup",
549                             "Put": "_dict_lookup",
550                             "GetArgs": {
551                                 "lookup": self.uac_user_prompt_lookup,
552                                 "value_lookup": False,
553                             },
554                             "PutArgs": {
555                                 "lookup": self.uac_user_prompt_lookup,
556                                 "value_lookup": True,
557                             },
558                         },
559                     },
560                     "EnableInstallerDetection": {
561                         "Policy": (
562                             "User Account Control: Detect application "
563                             "installations and prompt for elevation"
564                         ),
565                         "Settings": self.enabled_one_disabled_zero.keys(),
566                         "lgpo_section": self.security_options_gpedit_path,
567                         "Registry": {
568                             "Hive": "HKEY_LOCAL_MACHINE",
569                             "Path": (
570                                 "Software\\Microsoft\\Windows\\"
571                                 "CurrentVersion\\Policies\\System"
572                             ),
573                             "Value": "EnableInstallerDetection",
574                             "Type": "REG_DWORD",
575                         },
576                         "Transform": self.enabled_one_disabled_zero_transform,
577                     },
578                     "ValidateAdminCodeSignatures": {
579                         "Policy": (
580                             "User Account Control: Only elevate "
581                             "executables that are signed and validated"
582                         ),
583                         "Settings": self.enabled_one_disabled_zero.keys(),
584                         "lgpo_section": self.security_options_gpedit_path,
585                         "Registry": {
586                             "Hive": "HKEY_LOCAL_MACHINE",
587                             "Path": (
588                                 "Software\\Microsoft\\Windows\\"
589                                 "CurrentVersion\\Policies\\System"
590                             ),
591                             "Value": "ValidateAdminCodeSignatures",
592                             "Type": "REG_DWORD",
593                         },
594                         "Transform": self.enabled_one_disabled_zero_transform,
595                     },
596                     "EnableSecureUIAPaths": {
597                         "Policy": (
598                             "User Account Control: Only elevate UIAccess "
599                             "applications that are installed in secure "
600                             "locations"
601                         ),
602                         "Settings": self.enabled_one_disabled_zero.keys(),
603                         "lgpo_section": self.security_options_gpedit_path,
604                         "Registry": {
605                             "Hive": "HKEY_LOCAL_MACHINE",
606                             "Path": (
607                                 "Software\\Microsoft\\Windows\\"
608                                 "CurrentVersion\\Policies\\System"
609                             ),
610                             "Value": "EnableSecureUIAPaths",
611                             "Type": "REG_DWORD",
612                         },
613                         "Transform": self.enabled_one_disabled_zero_transform,
614                     },
615                     "EnableLUA": {
616                         "Policy": (
617                             "User Account Control: Run all "
618                             "administrators in Admin Approval Mode"
619                         ),
620                         "Settings": self.enabled_one_disabled_zero.keys(),
621                         "lgpo_section": self.security_options_gpedit_path,
622                         "Registry": {
623                             "Hive": "HKEY_LOCAL_MACHINE",
624                             "Path": (
625                                 "Software\\Microsoft\\Windows\\"
626                                 "CurrentVersion\\Policies\\System"
627                             ),
628                             "Value": "EnableLUA",
629                             "Type": "REG_DWORD",
630                         },
631                         "Transform": self.enabled_one_disabled_zero_transform,
632                     },
633                     "PromptOnSecureDesktop": {
634                         "Policy": (
635                             "User Account Control: Switch to the secure "
636                             "desktop when prompting for elevation"
637                         ),
638                         "Settings": self.enabled_one_disabled_zero.keys(),
639                         "lgpo_section": self.security_options_gpedit_path,
640                         "Registry": {
641                             "Hive": "HKEY_LOCAL_MACHINE",
642                             "Path": (
643                                 "Software\\Microsoft\\Windows\\"
644                                 "CurrentVersion\\Policies\\System"
645                             ),
646                             "Value": "PromptOnSecureDesktop",
647                             "Type": "REG_DWORD",
648                         },
649                         "Transform": self.enabled_one_disabled_zero_transform,
650                     },
651                     "EnableVirtualization": {
652                         "Policy": (
653                             "User Account Control: Virtualize file and "
654                             "registry write failures to per-user "
655                             "locations"
656                         ),
657                         "Settings": self.enabled_one_disabled_zero.keys(),
658                         "lgpo_section": self.security_options_gpedit_path,
659                         "Registry": {
660                             "Hive": "HKEY_LOCAL_MACHINE",
661                             "Path": (
662                                 "Software\\Microsoft\\Windows\\"
663                                 "CurrentVersion\\Policies\\System"
664                             ),
665                             "Value": "EnableVirtualization",
666                             "Type": "REG_DWORD",
667                         },
668                         "Transform": self.enabled_one_disabled_zero_transform,
669                     },
670                     "PasswordExpiryWarning": {
671                         "Policy": (
672                             "Interactive logon: Prompt user to change "
673                             "password before expiration"
674                         ),
675                         "Settings": {
676                             "Function": "_in_range_inclusive",
677                             "Args": {"min": 0, "max": 999},
678                         },
679                         "lgpo_section": self.security_options_gpedit_path,
680                         "Registry": {
681                             "Hive": "HKEY_LOCAL_MACHINE",
682                             "Path": (
683                                 "Software\\Microsoft\\Windows NT\\"
684                                 "CurrentVersion\\Winlogon"
685                             ),
686                             "Value": "PasswordExpiryWarning",
687                             "Type": "REG_DWORD",
688                         },
689                     },
690                     "MaxDevicePasswordFailedAttempts": {
691                         "Policy": (
692                             "Interactive logon: Machine account lockout threshold"
693                         ),
694                         "Settings": {
695                             "Function": "_in_range_inclusive",
696                             "Args": {"min": 0, "max": 999},
697                         },
698                         "lgpo_section": self.security_options_gpedit_path,
699                         "Registry": {
700                             "Hive": "HKEY_LOCAL_MACHINE",
701                             "Path": (
702                                 "SOFTWARE\\Microsoft\\Windows\\"
703                                 "CurrentVersion\\policies\\system"
704                             ),
705                             "Value": "MaxDevicePasswordFailedAttempts",
706                             "Type": "REG_DWORD",
707                         },
708                     },
709                     "InactivityTimeoutSecs": {
710                         "Policy": "Interactive logon: Machine inactivity limit",
711                         "Settings": {
712                             "Function": "_in_range_inclusive",
713                             "Args": {"min": 0, "max": 599940},
714                         },
715                         "lgpo_section": self.security_options_gpedit_path,
716                         "Registry": {
717                             "Hive": "HKEY_LOCAL_MACHINE",
718                             "Path": (
719                                 "SOFTWARE\\Microsoft\\Windows\\"
720                                 "CurrentVersion\\policies\\system"
721                             ),
722                             "Value": "InactivityTimeoutSecs",
723                             "Type": "REG_DWORD",
724                         },
725                     },
726                     "legalnoticetext": {
727                         "Policy": (
728                             "Interactive logon: Message text for users "
729                             "attempting to log on"
730                         ),
731                         "lgpo_section": self.security_options_gpedit_path,
732                         "Registry": {
733                             "Hive": "HKEY_LOCAL_MACHINE",
734                             "Path": (
735                                 "SOFTWARE\\Microsoft\\Windows\\"
736                                 "CurrentVersion\\policies\\system"
737                             ),
738                             "Value": "legalnoticetext",
739                             "Type": "REG_SZ",
740                         },
741                         "Transform": {"Put": "_string_put_transform"},
742                     },
743                     "legalnoticecaption": {
744                         "Policy": (
745                             "Interactive logon: Message title for users "
746                             "attempting to log on"
747                         ),
748                         "lgpo_section": self.security_options_gpedit_path,
749                         "Registry": {
750                             "Hive": "HKEY_LOCAL_MACHINE",
751                             "Path": (
752                                 "SOFTWARE\\Microsoft\\Windows\\"
753                                 "CurrentVersion\\policies\\system"
754                             ),
755                             "Value": "legalnoticecaption",
756                             "Type": "REG_SZ",
757                         },
758                         "Transform": {"Put": "_string_put_transform"},
759                     },
760                     "DontDisplayLockedUserId": {
761                         "Policy": (
762                             "Interactive logon: Display user information "
763                             "when the session is locked"
764                         ),
765                         "Settings": self.locked_session_user_info.keys(),
766                         "lgpo_section": self.security_options_gpedit_path,
767                         "Registry": {
768                             "Hive": "HKEY_LOCAL_MACHINE",
769                             "Path": (
770                                 "SOFTWARE\\Microsoft\\Windows\\"
771                                 "CurrentVersion\\policies\\system"
772                             ),
773                             "Value": "DontDisplayLockedUserId",
774                             "Type": "REG_DWORD",
775                         },
776                         "Transform": {
777                             "Get": "_dict_lookup",
778                             "Put": "_dict_lookup",
779                             "GetArgs": {
780                                 "lookup": self.locked_session_user_info,
781                                 "value_lookup": False,
782                             },
783                             "PutArgs": {
784                                 "lookup": self.locked_session_user_info,
785                                 "value_lookup": True,
786                             },
787                         },
788                     },
789                     "ScForceOption": {
790                         "Policy": "Interactive logon: Require smart card",
791                         "Settings": self.enabled_one_disabled_zero.keys(),
792                         "lgpo_section": self.security_options_gpedit_path,
793                         "Registry": {
794                             "Hive": "HKEY_LOCAL_MACHINE",
795                             "Path": (
796                                 "Software\\Microsoft\\Windows\\"
797                                 "CurrentVersion\\Policies\\System"
798                             ),
799                             "Value": "ScForceOption",
800                             "Type": "REG_DWORD",
801                         },
802                         "Transform": self.enabled_one_disabled_zero_transform,
803                     },
804                     "Client_RequireSecuritySignature": {
805                         "Policy": (
806                             "Microsoft network client: Digitally sign "
807                             "communications (always)"
808                         ),
809                         "Settings": self.enabled_one_disabled_zero.keys(),
810                         "lgpo_section": self.security_options_gpedit_path,
811                         "Registry": {
812                             "Hive": "HKEY_LOCAL_MACHINE",
813                             "Path": (
814                                 "SYSTEM\\CurrentControlSet\\Services\\"
815                                 "LanmanWorkstation\\Parameters"
816                             ),
817                             "Value": "RequireSecuritySignature",
818                             "Type": "REG_DWORD",
819                         },
820                         "Transform": self.enabled_one_disabled_zero_transform,
821                     },
822                     "Client_EnableSecuritySignature": {
823                         "Policy": (
824                             "Microsoft network client: Digitally sign "
825                             "communications (if server agrees)"
826                         ),
827                         "Settings": self.enabled_one_disabled_zero.keys(),
828                         "lgpo_section": self.security_options_gpedit_path,
829                         "Registry": {
830                             "Hive": "HKEY_LOCAL_MACHINE",
831                             "Path": (
832                                 "SYSTEM\\CurrentControlSet\\Services\\"
833                                 "LanmanWorkstation\\Parameters"
834                             ),
835                             "Value": "EnableSecuritySignature",
836                             "Type": "REG_DWORD",
837                         },
838                         "Transform": self.enabled_one_disabled_zero_transform,
839                     },
840                     "EnablePlainTextPassword": {
841                         "Policy": (
842                             "Microsoft network client: Send unencrypted "
843                             "password to third-party SMB servers"
844                         ),
845                         "Settings": self.enabled_one_disabled_zero.keys(),
846                         "lgpo_section": self.security_options_gpedit_path,
847                         "Registry": {
848                             "Hive": "HKEY_LOCAL_MACHINE",
849                             "Path": (
850                                 "SYSTEM\\CurrentControlSet\\Services\\"
851                                 "LanmanWorkstation\\Parameters"
852                             ),
853                             "Value": "EnablePlainTextPassword",
854                             "Type": "REG_DWORD",
855                         },
856                         "Transform": self.enabled_one_disabled_zero_transform,
857                     },
858                     "AutoDisconnect": {
859                         "Policy": (
860                             "Microsoft network server: Amount of idle "
861                             "time required before suspending session"
862                         ),
863                         "Settings": {
864                             "Function": "_in_range_inclusive",
865                             "Args": {"min": 0, "max": 99999},
866                         },
867                         "lgpo_section": self.security_options_gpedit_path,
868                         "Registry": {
869                             "Hive": "HKEY_LOCAL_MACHINE",
870                             "Path": (
871                                 "System\\CurrentControlSet\\Services\\"
872                                 "LanmanServer\\Parameters"
873                             ),
874                             "Value": "AutoDisconnect",
875                             "Type": "REG_DWORD",
876                         },
877                     },
878                     "EnableS4U2SelfForClaims": {
879                         "Policy": (
880                             "Microsoft network server: Attempt S4U2Self "
881                             "to obtain claim information"
882                         ),
883                         "Settings": self.s4u2self_options.keys(),
884                         "lgpo_section": self.security_options_gpedit_path,
885                         "Registry": {
886                             "Hive": "HKEY_LOCAL_MACHINE",
887                             "Path": (
888                                 "System\\CurrentControlSet\\Services\\"
889                                 "LanmanServer\\Parameters"
890                             ),
891                             "Value": "EnableS4U2SelfForClaims",
892                             "Type": "REG_DWORD",
893                         },
894                         "Transform": {
895                             "Get": "_dict_lookup",
896                             "Put": "_dict_lookup",
897                             "GetArgs": {
898                                 "lookup": self.s4u2self_options,
899                                 "value_lookup": False,
900                             },
901                             "PutArgs": {
902                                 "lookup": self.s4u2self_options,
903                                 "value_lookup": True,
904                             },
905                         },
906                     },
907                     "Server_RequireSecuritySignature": {
908                         "Policy": (
909                             "Microsoft network server: Digitally sign "
910                             "communications (always)"
911                         ),
912                         "Settings": self.enabled_one_disabled_zero.keys(),
913                         "lgpo_section": self.security_options_gpedit_path,
914                         "Registry": {
915                             "Hive": "HKEY_LOCAL_MACHINE",
916                             "Path": (
917                                 "SYSTEM\\CurrentControlSet\\Services\\"
918                                 "LanmanServer\\Parameters"
919                             ),
920                             "Value": "RequireSecuritySignature",
921                             "Type": "REG_DWORD",
922                         },
923                         "Transform": self.enabled_one_disabled_zero_transform,
924                     },
925                     "Server_EnableSecuritySignature": {
926                         "Policy": (
927                             "Microsoft network server: Digitally sign "
928                             "communications (if client agrees)"
929                         ),
930                         "Settings": self.enabled_one_disabled_zero.keys(),
931                         "lgpo_section": self.security_options_gpedit_path,
932                         "Registry": {
933                             "Hive": "HKEY_LOCAL_MACHINE",
934                             "Path": (
935                                 "SYSTEM\\CurrentControlSet\\Services\\"
936                                 "LanmanServer\\Parameters"
937                             ),
938                             "Value": "EnableSecuritySignature",
939                             "Type": "REG_DWORD",
940                         },
941                         "Transform": self.enabled_one_disabled_zero_transform,
942                     },
943                     "EnableForcedLogoff": {
944                         "Policy": (
945                             "Microsoft network server: Disconnect "
946                             "clients when logon hours expire"
947                         ),
948                         "Settings": self.enabled_one_disabled_zero.keys(),
949                         "lgpo_section": self.security_options_gpedit_path,
950                         "Registry": {
951                             "Hive": "HKEY_LOCAL_MACHINE",
952                             "Path": (
953                                 "SYSTEM\\CurrentControlSet\\Services\\"
954                                 "LanmanServer\\Parameters"
955                             ),
956                             "Value": "EnableForcedLogoff",
957                             "Type": "REG_DWORD",
958                         },
959                         "Transform": self.enabled_one_disabled_zero_transform,
960                     },
961                     "SmbServerNameHardeningLevel": {
962                         "Policy": (
963                             "Microsoft network server: Server SPN target "
964                             "name validation level"
965                         ),
966                         "Settings": self.smb_server_name_hardening_levels.keys(),
967                         "lgpo_section": self.security_options_gpedit_path,
968                         "Registry": {
969                             "Hive": "HKEY_LOCAL_MACHINE",
970                             "Path": (
971                                 "System\\CurrentControlSet\\Services\\"
972                                 "LanmanServer\\Parameters"
973                             ),
974                             "Value": "SmbServerNameHardeningLevel",
975                             "Type": "REG_DWORD",
976                         },
977                         "Transform": {
978                             "Get": "_dict_lookup",
979                             "Put": "_dict_lookup",
980                             "GetArgs": {
981                                 "lookup": self.smb_server_name_hardening_levels,
982                                 "value_lookup": False,
983                             },
984                             "PutArgs": {
985                                 "lookup": self.smb_server_name_hardening_levels,
986                                 "value_lookup": True,
987                             },
988                         },
989                     },
990                     "FullPrivilegeAuditing": {
991                         "Policy": (
992                             "Audit: Audit the use of Backup and Restore privilege"
993                         ),
994                         "Settings": [chr(0), chr(1)],
995                         "lgpo_section": self.security_options_gpedit_path,
996                         "Registry": {
997                             "Hive": "HKEY_LOCAL_MACHINE",
998                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
999                             "Value": "FullPrivilegeAuditing",
1000                             "Type": "REG_BINARY",
1001                         },
1002                         "Transform": {
1003                             "Get": "_binary_enable_zero_disable_one_conversion",
1004                             "Put": "_binary_enable_zero_disable_one_reverse_conversion",
1005                         },
1006                     },
1007                     "CrashOnAuditFail": {
1008                         "Policy": (
1009                             "Audit: Shut down system immediately if "
1010                             "unable to log security audits"
1011                         ),
1012                         "Settings": self.enabled_one_disabled_zero.keys(),
1013                         "lgpo_section": self.security_options_gpedit_path,
1014                         "Registry": {
1015                             "Hive": "HKEY_LOCAL_MACHINE",
1016                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1017                             "Value": "CrashOnAuditFail",
1018                             "Type": "REG_DWORD",
1019                         },
1020                         "Transform": self.enabled_one_disabled_zero_transform,
1021                     },
1022                     "UndockWithoutLogon": {
1023                         "Policy": "Devices: Allow undock without having to log on",
1024                         "Settings": self.enabled_one_disabled_zero.keys(),
1025                         "lgpo_section": self.security_options_gpedit_path,
1026                         "Registry": {
1027                             "Hive": "HKEY_LOCAL_MACHINE",
1028                             "Path": (
1029                                 "Software\\Microsoft\\Windows\\"
1030                                 "CurrentVersion\\Policies\\System"
1031                             ),
1032                             "Value": "UndockWithoutLogon",
1033                             "Type": "REG_DWORD",
1034                         },
1035                         "Transform": self.enabled_one_disabled_zero_transform,
1036                     },
1037                     "AddPrinterDrivers": {
1038                         "Policy": (
1039                             "Devices: Prevent users from installing printer drivers"
1040                         ),
1041                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1042                         "lgpo_section": self.security_options_gpedit_path,
1043                         "Registry": {
1044                             "Hive": "HKEY_LOCAL_MACHINE",
1045                             "Path": (
1046                                 "System\\CurrentControlSet\\Control\\"
1047                                 "Print\\Providers\\LanMan Print Services\\"
1048                                 "Servers"
1049                             ),
1050                             "Value": "AddPrinterDrivers",
1051                             "Type": "REG_DWORD",
1052                         },
1053                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1054                     },
1055                     "AllocateDASD": {
1056                         "Policy": (
1057                             "Devices: Allowed to format and eject removable media"
1058                         ),
1059                         "Settings": ["9999", "0", "1", "2"],
1060                         "lgpo_section": self.security_options_gpedit_path,
1061                         "Registry": {
1062                             "Hive": "HKEY_LOCAL_MACHINE",
1063                             "Path": (
1064                                 "Software\\Microsoft\\Windows NT\\"
1065                                 "CurrentVersion\\Winlogon"
1066                             ),
1067                             "Value": "AllocateDASD",
1068                             "Type": "REG_SZ",
1069                         },
1070                         "Transform": {
1071                             "Get": "_dasd_conversion",
1072                             "Put": "_dasd_reverse_conversion",
1073                         },
1074                     },
1075                     "AllocateCDRoms": {
1076                         "Policy": (
1077                             "Devices: Restrict CD-ROM access to locally "
1078                             "logged-on user only"
1079                         ),
1080                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1081                         "lgpo_section": self.security_options_gpedit_path,
1082                         "Registry": {
1083                             "Hive": "HKEY_LOCAL_MACHINE",
1084                             "Path": (
1085                                 "Software\\Microsoft\\Windows NT\\"
1086                                 "CurrentVersion\\Winlogon"
1087                             ),
1088                             "Value": "AllocateCDRoms",
1089                             "Type": "REG_SZ",
1090                         },
1091                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1092                     },
1093                     "AllocateFloppies": {
1094                         "Policy": (
1095                             "Devices: Restrict floppy access to locally "
1096                             "logged-on user only"
1097                         ),
1098                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1099                         "lgpo_section": self.security_options_gpedit_path,
1100                         "Registry": {
1101                             "Hive": "HKEY_LOCAL_MACHINE",
1102                             "Path": (
1103                                 "Software\\Microsoft\\Windows NT\\"
1104                                 "CurrentVersion\\Winlogon"
1105                             ),
1106                             "Value": "AllocateFloppies",
1107                             "Type": "REG_SZ",
1108                         },
1109                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1110                     },
1111                     "DriverSigningPolicy": {
1112                         "Policy": "Devices: Unsigned driver installation behavior",
1113                         "Settings": ["3,0", "3," + chr(1), "3," + chr(2)],
1114                         "lgpo_section": self.security_options_gpedit_path,
1115                         "Secedit": {
1116                             "Option": (
1117                                 "MACHINE\\Software\\Microsoft\\Driver Signing\\Policy"
1118                             ),
1119                             "Section": "Registry Values",
1120                         },
1121                         "Transform": {
1122                             "Get": "_driver_signing_reg_conversion",
1123                             "Put": "_driver_signing_reg_reverse_conversion",
1124                         },
1125                     },
1126                     "SubmitControl": {
1127                         "Policy": (
1128                             "Domain controller: Allow server operators "
1129                             "to schedule tasks"
1130                         ),
1131                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1132                         "lgpo_section": self.security_options_gpedit_path,
1133                         "Registry": {
1134                             "Hive": "HKEY_LOCAL_MACHINE",
1135                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
1136                             "Value": "SubmitControl",
1137                             "Type": "REG_DWORD",
1138                         },
1139                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1140                     },
1141                     "LDAPServerIntegrity": {
1142                         "Policy": "Domain controller: LDAP server signing requirements",
1143                         "Settings": self.ldap_server_signing_requirements.keys(),
1144                         "lgpo_section": self.security_options_gpedit_path,
1145                         "Registry": {
1146                             "Hive": "HKEY_LOCAL_MACHINE",
1147                             "Path": (
1148                                 "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
1149                             ),
1150                             "Value": "LDAPServerIntegrity",
1151                             "Type": "REG_DWORD",
1152                         },
1153                         "Transform": {
1154                             "Get": "_dict_lookup",
1155                             "Put": "_dict_lookup",
1156                             "GetArgs": {
1157                                 "lookup": self.ldap_server_signing_requirements,
1158                                 "value_lookup": False,
1159                             },
1160                             "PutArgs": {
1161                                 "lookup": self.ldap_server_signing_requirements,
1162                                 "value_lookup": True,
1163                             },
1164                         },
1165                     },
1166                     "RefusePasswordChange": {
1167                         "Policy": (
1168                             "Domain controller: Refuse machine account password changes"
1169                         ),
1170                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1171                         "lgpo_section": self.security_options_gpedit_path,
1172                         "Registry": {
1173                             "Hive": "HKEY_LOCAL_MACHINE",
1174                             "Path": (
1175                                 "SYSTEM\\CurrentControlSet\\Services\\"
1176                                 "Netlogon\\Parameters"
1177                             ),
1178                             "Value": "RefusePasswordChange",
1179                             "Type": "REG_DWORD",
1180                         },
1181                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1182                     },
1183                     "RequireSignOrSeal": {
1184                         "Policy": (
1185                             "Domain member: Digitally encrypt or sign "
1186                             "secure channel data (always)"
1187                         ),
1188                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1189                         "lgpo_section": self.security_options_gpedit_path,
1190                         "Registry": {
1191                             "Hive": "HKEY_LOCAL_MACHINE",
1192                             "Path": (
1193                                 "System\\CurrentControlSet\\Services\\"
1194                                 "Netlogon\\Parameters"
1195                             ),
1196                             "Value": "RequireSignOrSeal",
1197                             "Type": "REG_DWORD",
1198                         },
1199                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1200                     },
1201                     "SealSecureChannel": {
1202                         "Policy": (
1203                             "Domain member: Digitally encrypt secure "
1204                             "channel data (when possible)"
1205                         ),
1206                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1207                         "lgpo_section": self.security_options_gpedit_path,
1208                         "Registry": {
1209                             "Hive": "HKEY_LOCAL_MACHINE",
1210                             "Path": (
1211                                 "System\\CurrentControlSet\\Services\\"
1212                                 "Netlogon\\Parameters"
1213                             ),
1214                             "Value": "SealSecureChannel",
1215                             "Type": "REG_DWORD",
1216                         },
1217                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1218                     },
1219                     "SignSecureChannel": {
1220                         "Policy": (
1221                             "Domain member: Digitally sign secure "
1222                             "channel data (when possible)"
1223                         ),
1224                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1225                         "lgpo_section": self.security_options_gpedit_path,
1226                         "Registry": {
1227                             "Hive": "HKEY_LOCAL_MACHINE",
1228                             "Path": (
1229                                 "System\\CurrentControlSet\\Services\\"
1230                                 "Netlogon\\Parameters"
1231                             ),
1232                             "Value": "SignSecureChannel",
1233                             "Type": "REG_DWORD",
1234                         },
1235                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1236                     },
1237                     "DisablePasswordChange": {
1238                         "Policy": (
1239                             "Domain member: Disable machine account password changes"
1240                         ),
1241                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1242                         "lgpo_section": self.security_options_gpedit_path,
1243                         "Registry": {
1244                             "Hive": "HKEY_LOCAL_MACHINE",
1245                             "Path": (
1246                                 "System\\CurrentControlSet\\Services\\"
1247                                 "Netlogon\\Parameters"
1248                             ),
1249                             "Value": "DisablePasswordChange",
1250                             "Type": "REG_DWORD",
1251                         },
1252                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1253                     },
1254                     "MaximumPasswordAge": {
1255                         "Policy": "Domain member: Maximum machine account password age",
1256                         "Settings": {
1257                             "Function": "_in_range_inclusive",
1258                             "Args": {"min": 0, "max": 999},
1259                         },
1260                         "lgpo_section": self.security_options_gpedit_path,
1261                         "Registry": {
1262                             "Hive": "HKEY_LOCAL_MACHINE",
1263                             "Path": (
1264                                 "System\\CurrentControlSet\\Services\\"
1265                                 "Netlogon\\Parameters"
1266                             ),
1267                             "Value": "MaximumPasswordAge",
1268                             "Type": "REG_DWORD",
1269                         },
1270                     },
1271                     "RequireStrongKey": {
1272                         "Policy": (
1273                             "Domain member: Require strong (Windows 2000 "
1274                             "or later) session key"
1275                         ),
1276                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
1277                         "lgpo_section": self.security_options_gpedit_path,
1278                         "Registry": {
1279                             "Hive": "HKEY_LOCAL_MACHINE",
1280                             "Path": (
1281                                 "System\\CurrentControlSet\\Services\\"
1282                                 "Netlogon\\Parameters"
1283                             ),
1284                             "Value": "RequireStrongKey",
1285                             "Type": "REG_DWORD",
1286                         },
1287                         "Transform": self.enabled_one_disabled_zero_strings_transform,
1288                     },
1289                     "LockoutDuration": {
1290                         "Policy": "Account lockout duration",
1291                         "lgpo_section": self.account_lockout_policy_gpedit_path,
1292                         "Settings": {
1293                             "Function": "_in_range_inclusive",
1294                             "Args": {
1295                                 "min": 0,
1296                                 "max": 6000000,
1297                                 "zero_value": 0xFFFFFFFF,
1298                             },
1299                         },
1300                         "NetUserModal": {"Modal": 3, "Option": "lockout_duration"},
1301                         "Transform": {
1302                             "Get": "_seconds_to_minutes",
1303                             "Put": "_minutes_to_seconds",
1304                             "GetArgs": {"zero_value": 0xFFFFFFFF},
1305                             "PutArgs": {"zero_value": 0xFFFFFFFF},
1306                         },
1307                     },
1308                     "LockoutThreshold": {
1309                         "Policy": "Account lockout threshold",
1310                         "lgpo_section": self.account_lockout_policy_gpedit_path,
1311                         "Settings": {
1312                             "Function": "_in_range_inclusive",
1313                             "Args": {"min": 0, "max": 1000},
1314                         },
1315                         "NetUserModal": {"Modal": 3, "Option": "lockout_threshold"},
1316                     },
1317                     "LockoutWindow": {
1318                         "Policy": "Reset account lockout counter after",
1319                         "lgpo_section": self.account_lockout_policy_gpedit_path,
1320                         "Settings": {
1321                             "Function": "_in_range_inclusive",
1322                             "Args": {"min": 0, "max": 6000000},
1323                         },
1324                         "NetUserModal": {
1325                             "Modal": 3,
1326                             "Option": "lockout_observation_window",
1327                         },
1328                         "Transform": {
1329                             "Get": "_seconds_to_minutes",
1330                             "Put": "_minutes_to_seconds",
1331                         },
1332                     },
1333                     "AuditAccountLogon": {
1334                         "Policy": "Audit account logon events",
1335                         "lgpo_section": self.audit_policy_gpedit_path,
1336                         "Settings": self.audit_lookup.keys(),
1337                         "Secedit": {
1338                             "Option": "AuditAccountLogon",
1339                             "Section": "Event Audit",
1340                         },
1341                         "Transform": self.audit_transform,
1342                     },
1343                     "AuditAccountManage": {
1344                         "Policy": "Audit account management",
1345                         "lgpo_section": self.audit_policy_gpedit_path,
1346                         "Settings": self.audit_lookup.keys(),
1347                         "Secedit": {
1348                             "Option": "AuditAccountManage",
1349                             "Section": "Event Audit",
1350                         },
1351                         "Transform": self.audit_transform,
1352                     },
1353                     "AuditDSAccess": {
1354                         "Policy": "Audit directory service access",
1355                         "lgpo_section": self.audit_policy_gpedit_path,
1356                         "Settings": self.audit_lookup.keys(),
1357                         "Secedit": {
1358                             "Option": "AuditDSAccess",
1359                             "Section": "Event Audit",
1360                         },
1361                         "Transform": self.audit_transform,
1362                     },
1363                     "AuditLogonEvents": {
1364                         "Policy": "Audit logon events",
1365                         "lgpo_section": self.audit_policy_gpedit_path,
1366                         "Settings": self.audit_lookup.keys(),
1367                         "Secedit": {
1368                             "Option": "AuditLogonEvents",
1369                             "Section": "Event Audit",
1370                         },
1371                         "Transform": self.audit_transform,
1372                     },
1373                     "AuditObjectAccess": {
1374                         "Policy": "Audit object access",
1375                         "lgpo_section": self.audit_policy_gpedit_path,
1376                         "Settings": self.audit_lookup.keys(),
1377                         "Secedit": {
1378                             "Option": "AuditObjectAccess",
1379                             "Section": "Event Audit",
1380                         },
1381                         "Transform": self.audit_transform,
1382                     },
1383                     "AuditPolicyChange": {
1384                         "Policy": "Audit policy change",
1385                         "lgpo_section": self.audit_policy_gpedit_path,
1386                         "Settings": self.audit_lookup.keys(),
1387                         "Secedit": {
1388                             "Option": "AuditPolicyChange",
1389                             "Section": "Event Audit",
1390                         },
1391                         "Transform": self.audit_transform,
1392                     },
1393                     "AuditPrivilegeUse": {
1394                         "Policy": "Audit privilege use",
1395                         "lgpo_section": self.audit_policy_gpedit_path,
1396                         "Settings": self.audit_lookup.keys(),
1397                         "Secedit": {
1398                             "Option": "AuditPrivilegeUse",
1399                             "Section": "Event Audit",
1400                         },
1401                         "Transform": self.audit_transform,
1402                     },
1403                     "AuditProcessTracking": {
1404                         "Policy": "Audit process tracking",
1405                         "lgpo_section": self.audit_policy_gpedit_path,
1406                         "Settings": self.audit_lookup.keys(),
1407                         "Secedit": {
1408                             "Option": "AuditProcessTracking",
1409                             "Section": "Event Audit",
1410                         },
1411                         "Transform": self.audit_transform,
1412                     },
1413                     "AuditSystemEvents": {
1414                         "Policy": "Audit system events",
1415                         "lgpo_section": self.audit_policy_gpedit_path,
1416                         "Settings": self.audit_lookup.keys(),
1417                         "Secedit": {
1418                             "Option": "AuditSystemEvents",
1419                             "Section": "Event Audit",
1420                         },
1421                         "Transform": self.audit_transform,
1422                     },
1423                     "AuditCredentialValidation": {
1424                         "Policy": "Audit Credential Validation",
1425                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1426                         "Settings": self.advanced_audit_lookup.keys(),
1427                         "AdvAudit": {"Option": "Audit Credential Validation"},
1428                         "Transform": self.advanced_audit_transform,
1429                     },
1430                     "AuditKerberosAuthenticationService": {
1431                         "Policy": "Audit Kerberos Authentication Service",
1432                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1433                         "Settings": self.advanced_audit_lookup.keys(),
1434                         "AdvAudit": {
1435                             "Option": "Audit Kerberos Authentication Service",
1436                         },
1437                         "Transform": self.advanced_audit_transform,
1438                     },
1439                     "AuditKerberosServiceTicketOperations": {
1440                         "Policy": "Audit Kerberos Service Ticket Operations",
1441                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1442                         "Settings": self.advanced_audit_lookup.keys(),
1443                         "AdvAudit": {
1444                             "Option": "Audit Kerberos Service Ticket Operations",
1445                         },
1446                         "Transform": self.advanced_audit_transform,
1447                     },
1448                     "AuditOtherAccountLogonEvents": {
1449                         "Policy": "Audit Other Account Logon Events",
1450                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1451                         "Settings": self.advanced_audit_lookup.keys(),
1452                         "AdvAudit": {"Option": "Audit Other Account Logon Events"},
1453                         "Transform": self.advanced_audit_transform,
1454                     },
1455                     "AuditApplicationGroupManagement": {
1456                         "Policy": "Audit Application Group Management",
1457                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1458                         "Settings": self.advanced_audit_lookup.keys(),
1459                         "AdvAudit": {"Option": "Audit Application Group Management"},
1460                         "Transform": self.advanced_audit_transform,
1461                     },
1462                     "AuditComputerAccountManagement": {
1463                         "Policy": "Audit Computer Account Management",
1464                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1465                         "Settings": self.advanced_audit_lookup.keys(),
1466                         "AdvAudit": {"Option": "Audit Computer Account Management"},
1467                         "Transform": self.advanced_audit_transform,
1468                     },
1469                     "AuditDistributionGroupManagement": {
1470                         "Policy": "Audit Distribution Group Management",
1471                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1472                         "Settings": self.advanced_audit_lookup.keys(),
1473                         "AdvAudit": {"Option": "Audit Distribution Group Management"},
1474                         "Transform": self.advanced_audit_transform,
1475                     },
1476                     "AuditOtherAccountManagementEvents": {
1477                         "Policy": "Audit Other Account Management Events",
1478                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1479                         "Settings": self.advanced_audit_lookup.keys(),
1480                         "AdvAudit": {
1481                             "Option": "Audit Other Account Management Events",
1482                         },
1483                         "Transform": self.advanced_audit_transform,
1484                     },
1485                     "AuditSecurityGroupManagement": {
1486                         "Policy": "Audit Security Group Management",
1487                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1488                         "Settings": self.advanced_audit_lookup.keys(),
1489                         "AdvAudit": {"Option": "Audit Security Group Management"},
1490                         "Transform": self.advanced_audit_transform,
1491                     },
1492                     "AuditUserAccountManagement": {
1493                         "Policy": "Audit User Account Management",
1494                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1495                         "Settings": self.advanced_audit_lookup.keys(),
1496                         "AdvAudit": {"Option": "Audit User Account Management"},
1497                         "Transform": self.advanced_audit_transform,
1498                     },
1499                     "AuditDPAPIActivity": {
1500                         "Policy": "Audit DPAPI Activity",
1501                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1502                         "Settings": self.advanced_audit_lookup.keys(),
1503                         "AdvAudit": {"Option": "Audit DPAPI Activity"},
1504                         "Transform": self.advanced_audit_transform,
1505                     },
1506                     "AuditPNPActivity": {
1507                         "Policy": "Audit PNP Activity",
1508                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1509                         "Settings": self.advanced_audit_lookup.keys(),
1510                         "AdvAudit": {"Option": "Audit PNP Activity"},
1511                         "Transform": self.advanced_audit_transform,
1512                     },
1513                     "AuditProcessCreation": {
1514                         "Policy": "Audit Process Creation",
1515                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1516                         "Settings": self.advanced_audit_lookup.keys(),
1517                         "AdvAudit": {"Option": "Audit Process Creation"},
1518                         "Transform": self.advanced_audit_transform,
1519                     },
1520                     "AuditProcessTermination": {
1521                         "Policy": "Audit Process Termination",
1522                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1523                         "Settings": self.advanced_audit_lookup.keys(),
1524                         "AdvAudit": {"Option": "Audit Process Termination"},
1525                         "Transform": self.advanced_audit_transform,
1526                     },
1527                     "AuditRPCEvents": {
1528                         "Policy": "Audit RPC Events",
1529                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1530                         "Settings": self.advanced_audit_lookup.keys(),
1531                         "AdvAudit": {"Option": "Audit RPC Events"},
1532                         "Transform": self.advanced_audit_transform,
1533                     },
1534                     "AuditTokenRightAdjusted": {
1535                         "Policy": "Audit Token Right Adjusted",
1536                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1537                         "Settings": self.advanced_audit_lookup.keys(),
1538                         "AdvAudit": {"Option": "Audit Token Right Adjusted"},
1539                         "Transform": self.advanced_audit_transform,
1540                     },
1541                     "AuditDetailedDirectoryServiceReplication": {
1542                         "Policy": "Audit Detailed Directory Service Replication",
1543                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1544                         "Settings": self.advanced_audit_lookup.keys(),
1545                         "AdvAudit": {
1546                             "Option": "Audit Detailed Directory Service Replication",
1547                         },
1548                         "Transform": self.advanced_audit_transform,
1549                     },
1550                     "AuditDirectoryServiceAccess": {
1551                         "Policy": "Audit Directory Service Access",
1552                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1553                         "Settings": self.advanced_audit_lookup.keys(),
1554                         "AdvAudit": {"Option": "Audit Directory Service Access"},
1555                         "Transform": self.advanced_audit_transform,
1556                     },
1557                     "AuditDirectoryServiceChanges": {
1558                         "Policy": "Audit Directory Service Changes",
1559                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1560                         "Settings": self.advanced_audit_lookup.keys(),
1561                         "AdvAudit": {"Option": "Audit Directory Service Changes"},
1562                         "Transform": self.advanced_audit_transform,
1563                     },
1564                     "AuditDirectoryServiceReplication": {
1565                         "Policy": "Audit Directory Service Replication",
1566                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1567                         "Settings": self.advanced_audit_lookup.keys(),
1568                         "AdvAudit": {"Option": "Audit Directory Service Replication"},
1569                         "Transform": self.advanced_audit_transform,
1570                     },
1571                     "AuditAccountLockout": {
1572                         "Policy": "Audit Account Lockout",
1573                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1574                         "Settings": self.advanced_audit_lookup.keys(),
1575                         "AdvAudit": {"Option": "Audit Account Lockout"},
1576                         "Transform": self.advanced_audit_transform,
1577                     },
1578                     "AuditUserDeviceClaims": {
1579                         "Policy": "Audit User / Device Claims",
1580                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1581                         "Settings": self.advanced_audit_lookup.keys(),
1582                         "AdvAudit": {"Option": "Audit User / Device Claims"},
1583                         "Transform": self.advanced_audit_transform,
1584                     },
1585                     "AuditGroupMembership": {
1586                         "Policy": "Audit Group Membership",
1587                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1588                         "Settings": self.advanced_audit_lookup.keys(),
1589                         "AdvAudit": {"Option": "Audit Group Membership"},
1590                         "Transform": self.advanced_audit_transform,
1591                     },
1592                     "AuditIPsecExtendedMode": {
1593                         "Policy": "Audit IPsec Extended Mode",
1594                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1595                         "Settings": self.advanced_audit_lookup.keys(),
1596                         "AdvAudit": {"Option": "Audit IPsec Extended Mode"},
1597                         "Transform": self.advanced_audit_transform,
1598                     },
1599                     "AuditIPsecMainMode": {
1600                         "Policy": "Audit IPsec Main Mode",
1601                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1602                         "Settings": self.advanced_audit_lookup.keys(),
1603                         "AdvAudit": {"Option": "Audit IPsec Main Mode"},
1604                         "Transform": self.advanced_audit_transform,
1605                     },
1606                     "AuditIPsecQuickMode": {
1607                         "Policy": "Audit IPsec Quick Mode",
1608                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1609                         "Settings": self.advanced_audit_lookup.keys(),
1610                         "AdvAudit": {"Option": "Audit IPsec Quick Mode"},
1611                         "Transform": self.advanced_audit_transform,
1612                     },
1613                     "AuditLogoff": {
1614                         "Policy": "Audit Logoff",
1615                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1616                         "Settings": self.advanced_audit_lookup.keys(),
1617                         "AdvAudit": {"Option": "Audit Logoff"},
1618                         "Transform": self.advanced_audit_transform,
1619                     },
1620                     "AuditLogon": {
1621                         "Policy": "Audit Logon",
1622                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1623                         "Settings": self.advanced_audit_lookup.keys(),
1624                         "AdvAudit": {"Option": "Audit Logon"},
1625                         "Transform": self.advanced_audit_transform,
1626                     },
1627                     "AuditNetworkPolicyServer": {
1628                         "Policy": "Audit Network Policy Server",
1629                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1630                         "Settings": self.advanced_audit_lookup.keys(),
1631                         "AdvAudit": {"Option": "Audit Network Policy Server"},
1632                         "Transform": self.advanced_audit_transform,
1633                     },
1634                     "AuditOtherLogonLogoffEvents": {
1635                         "Policy": "Audit Other Logon/Logoff Events",
1636                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1637                         "Settings": self.advanced_audit_lookup.keys(),
1638                         "AdvAudit": {"Option": "Audit Other Logon/Logoff Events"},
1639                         "Transform": self.advanced_audit_transform,
1640                     },
1641                     "AuditSpecialLogon": {
1642                         "Policy": "Audit Special Logon",
1643                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1644                         "Settings": self.advanced_audit_lookup.keys(),
1645                         "AdvAudit": {"Option": "Audit Special Logon"},
1646                         "Transform": self.advanced_audit_transform,
1647                     },
1648                     "AuditApplicationGenerated": {
1649                         "Policy": "Audit Application Generated",
1650                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1651                         "Settings": self.advanced_audit_lookup.keys(),
1652                         "AdvAudit": {"Option": "Audit Application Generated"},
1653                         "Transform": self.advanced_audit_transform,
1654                     },
1655                     "AuditCertificationServices": {
1656                         "Policy": "Audit Certification Services",
1657                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1658                         "Settings": self.advanced_audit_lookup.keys(),
1659                         "AdvAudit": {"Option": "Audit Certification Services"},
1660                         "Transform": self.advanced_audit_transform,
1661                     },
1662                     "AuditDetailedFileShare": {
1663                         "Policy": "Audit Detailed File Share",
1664                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1665                         "Settings": self.advanced_audit_lookup.keys(),
1666                         "AdvAudit": {"Option": "Audit Detailed File Share"},
1667                         "Transform": self.advanced_audit_transform,
1668                     },
1669                     "AuditFileShare": {
1670                         "Policy": "Audit File Share",
1671                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1672                         "Settings": self.advanced_audit_lookup.keys(),
1673                         "AdvAudit": {"Option": "Audit File Share"},
1674                         "Transform": self.advanced_audit_transform,
1675                     },
1676                     "AuditFileSystem": {
1677                         "Policy": "Audit File System",
1678                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1679                         "Settings": self.advanced_audit_lookup.keys(),
1680                         "AdvAudit": {"Option": "Audit File System"},
1681                         "Transform": self.advanced_audit_transform,
1682                     },
1683                     "AuditFilteringPlatformConnection": {
1684                         "Policy": "Audit Filtering Platform Connection",
1685                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1686                         "Settings": self.advanced_audit_lookup.keys(),
1687                         "AdvAudit": {"Option": "Audit Filtering Platform Connection"},
1688                         "Transform": self.advanced_audit_transform,
1689                     },
1690                     "AuditFilteringPlatformPacketDrop": {
1691                         "Policy": "Audit Filtering Platform Packet Drop",
1692                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1693                         "Settings": self.advanced_audit_lookup.keys(),
1694                         "AdvAudit": {"Option": "Audit Filtering Platform Packet Drop"},
1695                         "Transform": self.advanced_audit_transform,
1696                     },
1697                     "AuditHandleManipulation": {
1698                         "Policy": "Audit Handle Manipulation",
1699                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1700                         "Settings": self.advanced_audit_lookup.keys(),
1701                         "AdvAudit": {"Option": "Audit Handle Manipulation"},
1702                         "Transform": self.advanced_audit_transform,
1703                     },
1704                     "AuditKernelObject": {
1705                         "Policy": "Audit Kernel Object",
1706                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1707                         "Settings": self.advanced_audit_lookup.keys(),
1708                         "AdvAudit": {"Option": "Audit Kernel Object"},
1709                         "Transform": self.advanced_audit_transform,
1710                     },
1711                     "AuditOtherObjectAccessEvents": {
1712                         "Policy": "Audit Other Object Access Events",
1713                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1714                         "Settings": self.advanced_audit_lookup.keys(),
1715                         "AdvAudit": {"Option": "Audit Other Object Access Events"},
1716                         "Transform": self.advanced_audit_transform,
1717                     },
1718                     "AuditRegistry": {
1719                         "Policy": "Audit Registry",
1720                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1721                         "Settings": self.advanced_audit_lookup.keys(),
1722                         "AdvAudit": {"Option": "Audit Registry"},
1723                         "Transform": self.advanced_audit_transform,
1724                     },
1725                     "AuditRemovableStorage": {
1726                         "Policy": "Audit Removable Storage",
1727                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1728                         "Settings": self.advanced_audit_lookup.keys(),
1729                         "AdvAudit": {"Option": "Audit Removable Storage"},
1730                         "Transform": self.advanced_audit_transform,
1731                     },
1732                     "AuditSAM": {
1733                         "Policy": "Audit SAM",
1734                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1735                         "Settings": self.advanced_audit_lookup.keys(),
1736                         "AdvAudit": {"Option": "Audit SAM"},
1737                         "Transform": self.advanced_audit_transform,
1738                     },
1739                     "AuditCentralAccessPolicyStaging": {
1740                         "Policy": "Audit Central Access Policy Staging",
1741                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1742                         "Settings": self.advanced_audit_lookup.keys(),
1743                         "AdvAudit": {"Option": "Audit Central Access Policy Staging"},
1744                         "Transform": self.advanced_audit_transform,
1745                     },
1746                     "AuditAuditPolicyChange": {
1747                         "Policy": "Audit Audit Policy Change",
1748                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1749                         "Settings": self.advanced_audit_lookup.keys(),
1750                         "AdvAudit": {"Option": "Audit Audit Policy Change"},
1751                         "Transform": self.advanced_audit_transform,
1752                     },
1753                     "AuditAuthenticationPolicyChange": {
1754                         "Policy": "Audit Authentication Policy Change",
1755                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1756                         "Settings": self.advanced_audit_lookup.keys(),
1757                         "AdvAudit": {"Option": "Audit Authentication Policy Change"},
1758                         "Transform": self.advanced_audit_transform,
1759                     },
1760                     "AuditAuthorizationPolicyChange": {
1761                         "Policy": "Audit Authorization Policy Change",
1762                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1763                         "Settings": self.advanced_audit_lookup.keys(),
1764                         "AdvAudit": {"Option": "Audit Authorization Policy Change"},
1765                         "Transform": self.advanced_audit_transform,
1766                     },
1767                     "AuditFilteringPlatformPolicyChange": {
1768                         "Policy": "Audit Filtering Platform Policy Change",
1769                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1770                         "Settings": self.advanced_audit_lookup.keys(),
1771                         "AdvAudit": {
1772                             "Option": "Audit Filtering Platform Policy Change",
1773                         },
1774                         "Transform": self.advanced_audit_transform,
1775                     },
1776                     "AuditMPSSVCRuleLevelPolicyChange": {
1777                         "Policy": "Audit MPSSVC Rule-Level Policy Change",
1778                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1779                         "Settings": self.advanced_audit_lookup.keys(),
1780                         "AdvAudit": {
1781                             "Option": "Audit MPSSVC Rule-Level Policy Change",
1782                         },
1783                         "Transform": self.advanced_audit_transform,
1784                     },
1785                     "AuditOtherPolicyChangeEvents": {
1786                         "Policy": "Audit Other Policy Change Events",
1787                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1788                         "Settings": self.advanced_audit_lookup.keys(),
1789                         "AdvAudit": {"Option": "Audit Other Policy Change Events"},
1790                         "Transform": self.advanced_audit_transform,
1791                     },
1792                     "AuditNonSensitivePrivilegeUse": {
1793                         "Policy": "Audit Non Sensitive Privilege Use",
1794                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1795                         "Settings": self.advanced_audit_lookup.keys(),
1796                         "AdvAudit": {"Option": "Audit Non Sensitive Privilege Use"},
1797                         "Transform": self.advanced_audit_transform,
1798                     },
1799                     "AuditOtherPrivilegeUseEvents": {
1800                         "Policy": "Audit Other Privilege Use Events",
1801                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1802                         "Settings": self.advanced_audit_lookup.keys(),
1803                         "AdvAudit": {"Option": "Audit Other Privilege Use Events"},
1804                         "Transform": self.advanced_audit_transform,
1805                     },
1806                     "AuditSensitivePrivilegeUse": {
1807                         "Policy": "Audit Sensitive Privilege Use",
1808                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1809                         "Settings": self.advanced_audit_lookup.keys(),
1810                         "AdvAudit": {"Option": "Audit Sensitive Privilege Use"},
1811                         "Transform": self.advanced_audit_transform,
1812                     },
1813                     "AuditIPsecDriver": {
1814                         "Policy": "Audit IPsec Driver",
1815                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1816                         "Settings": self.advanced_audit_lookup.keys(),
1817                         "AdvAudit": {"Option": "Audit IPsec Driver"},
1818                         "Transform": self.advanced_audit_transform,
1819                     },
1820                     "AuditOtherSystemEvents": {
1821                         "Policy": "Audit Other System Events",
1822                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1823                         "Settings": self.advanced_audit_lookup.keys(),
1824                         "AdvAudit": {"Option": "Audit Other System Events"},
1825                         "Transform": self.advanced_audit_transform,
1826                     },
1827                     "AuditSecurityStateChange": {
1828                         "Policy": "Audit Security State Change",
1829                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1830                         "Settings": self.advanced_audit_lookup.keys(),
1831                         "AdvAudit": {"Option": "Audit Security State Change"},
1832                         "Transform": self.advanced_audit_transform,
1833                     },
1834                     "AuditSecuritySystemExtension": {
1835                         "Policy": "Audit Security System Extension",
1836                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1837                         "Settings": self.advanced_audit_lookup.keys(),
1838                         "AdvAudit": {"Option": "Audit Security System Extension"},
1839                         "Transform": self.advanced_audit_transform,
1840                     },
1841                     "AuditSystemIntegrity": {
1842                         "Policy": "Audit System Integrity",
1843                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
1844                         "Settings": self.advanced_audit_lookup.keys(),
1845                         "AdvAudit": {"Option": "Audit System Integrity"},
1846                         "Transform": self.advanced_audit_transform,
1847                     },
1848                     "SeTrustedCredManAccessPrivilege": {
1849                         "Policy": "Access Credential Manager as a trusted caller",
1850                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1851                         "rights_assignment": True,
1852                         "Settings": None,
1853                         "LsaRights": {"Option": "SeTrustedCredManAccessPrivilege"},
1854                         "Transform": {
1855                             "Get": "_sidConversion",
1856                             "Put": "_usernamesToSidObjects",
1857                         },
1858                     },
1859                     "SeNetworkLogonRight": {
1860                         "Policy": "Access this computer from the network",
1861                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1862                         "rights_assignment": True,
1863                         "Settings": None,
1864                         "LsaRights": {"Option": "SeNetworkLogonRight"},
1865                         "Transform": {
1866                             "Get": "_sidConversion",
1867                             "Put": "_usernamesToSidObjects",
1868                         },
1869                     },
1870                     "SeTcbPrivilege": {
1871                         "Policy": "Act as part of the operating system",
1872                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1873                         "rights_assignment": True,
1874                         "Settings": None,
1875                         "LsaRights": {"Option": "SeTcbPrivilege"},
1876                         "Transform": {
1877                             "Get": "_sidConversion",
1878                             "Put": "_usernamesToSidObjects",
1879                         },
1880                     },
1881                     "SeMachineAccountPrivilege": {
1882                         "Policy": "Add workstations to domain",
1883                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1884                         "rights_assignment": True,
1885                         "Settings": None,
1886                         "LsaRights": {"Option": "SeMachineAccountPrivilege"},
1887                         "Transform": {
1888                             "Get": "_sidConversion",
1889                             "Put": "_usernamesToSidObjects",
1890                         },
1891                     },
1892                     "SeIncreaseQuotaPrivilege": {
1893                         "Policy": "Adjust memory quotas for a process",
1894                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1895                         "rights_assignment": True,
1896                         "Settings": None,
1897                         "LsaRights": {"Option": "SeIncreaseQuotaPrivilege"},
1898                         "Transform": {
1899                             "Get": "_sidConversion",
1900                             "Put": "_usernamesToSidObjects",
1901                         },
1902                     },
1903                     "SeInteractiveLogonRight": {
1904                         "Policy": "Allow log on locally",
1905                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1906                         "rights_assignment": True,
1907                         "Settings": None,
1908                         "LsaRights": {"Option": "SeInteractiveLogonRight"},
1909                         "Transform": {
1910                             "Get": "_sidConversion",
1911                             "Put": "_usernamesToSidObjects",
1912                         },
1913                     },
1914                     "SeRemoteInteractiveLogonRight": {
1915                         "Policy": "Allow log on through Remote Desktop Services",
1916                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1917                         "rights_assignment": True,
1918                         "Settings": None,
1919                         "LsaRights": {"Option": "SeRemoteInteractiveLogonRight"},
1920                         "Transform": {
1921                             "Get": "_sidConversion",
1922                             "Put": "_usernamesToSidObjects",
1923                         },
1924                     },
1925                     "SeBackupPrivilege": {
1926                         "Policy": "Backup files and directories",
1927                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1928                         "rights_assignment": True,
1929                         "Settings": None,
1930                         "LsaRights": {"Option": "SeBackupPrivilege"},
1931                         "Transform": {
1932                             "Get": "_sidConversion",
1933                             "Put": "_usernamesToSidObjects",
1934                         },
1935                     },
1936                     "SeChangeNotifyPrivilege": {
1937                         "Policy": "Bypass traverse checking",
1938                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1939                         "rights_assignment": True,
1940                         "Settings": None,
1941                         "LsaRights": {"Option": "SeChangeNotifyPrivilege"},
1942                         "Transform": {
1943                             "Get": "_sidConversion",
1944                             "Put": "_usernamesToSidObjects",
1945                         },
1946                     },
1947                     "SeSystemtimePrivilege": {
1948                         "Policy": "Change the system time",
1949                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1950                         "rights_assignment": True,
1951                         "Settings": None,
1952                         "LsaRights": {"Option": "SeSystemtimePrivilege"},
1953                         "Transform": {
1954                             "Get": "_sidConversion",
1955                             "Put": "_usernamesToSidObjects",
1956                         },
1957                     },
1958                     "SeTimeZonePrivilege": {
1959                         "Policy": "Change the time zone",
1960                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1961                         "rights_assignment": True,
1962                         "Settings": None,
1963                         "LsaRights": {"Option": "SeTimeZonePrivilege"},
1964                         "Transform": {
1965                             "Get": "_sidConversion",
1966                             "Put": "_usernamesToSidObjects",
1967                         },
1968                     },
1969                     "SeCreatePagefilePrivilege": {
1970                         "Policy": "Create a pagefile",
1971                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1972                         "rights_assignment": True,
1973                         "Settings": None,
1974                         "LsaRights": {"Option": "SeCreatePagefilePrivilege"},
1975                         "Transform": {
1976                             "Get": "_sidConversion",
1977                             "Put": "_usernamesToSidObjects",
1978                         },
1979                     },
1980                     "SeCreateTokenPrivilege": {
1981                         "Policy": "Create a token object",
1982                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1983                         "rights_assignment": True,
1984                         "Settings": None,
1985                         "LsaRights": {"Option": "SeCreateTokenPrivilege"},
1986                         "Transform": {
1987                             "Get": "_sidConversion",
1988                             "Put": "_usernamesToSidObjects",
1989                         },
1990                     },
1991                     "SeCreateGlobalPrivilege": {
1992                         "Policy": "Create global objects",
1993                         "lgpo_section": self.user_rights_assignment_gpedit_path,
1994                         "rights_assignment": True,
1995                         "Settings": None,
1996                         "LsaRights": {"Option": "SeCreateGlobalPrivilege"},
1997                         "Transform": {
1998                             "Get": "_sidConversion",
1999                             "Put": "_usernamesToSidObjects",
2000                         },
2001                     },
2002                     "SeCreatePermanentPrivilege": {
2003                         "Policy": "Create permanent shared objects",
2004                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2005                         "rights_assignment": True,
2006                         "Settings": None,
2007                         "LsaRights": {"Option": "SeCreatePermanentPrivilege"},
2008                         "Transform": {
2009                             "Get": "_sidConversion",
2010                             "Put": "_usernamesToSidObjects",
2011                         },
2012                     },
2013                     "SeCreateSymbolicLinkPrivilege": {
2014                         "Policy": "Create symbolic links",
2015                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2016                         "rights_assignment": True,
2017                         "Settings": None,
2018                         "LsaRights": {"Option": "SeCreateSymbolicLinkPrivilege"},
2019                         "Transform": {
2020                             "Get": "_sidConversion",
2021                             "Put": "_usernamesToSidObjects",
2022                         },
2023                     },
2024                     "SeDebugPrivilege": {
2025                         "Policy": "Debug programs",
2026                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2027                         "rights_assignment": True,
2028                         "Settings": None,
2029                         "LsaRights": {"Option": "SeDebugPrivilege"},
2030                         "Transform": {
2031                             "Get": "_sidConversion",
2032                             "Put": "_usernamesToSidObjects",
2033                         },
2034                     },
2035                     "SeDenyNetworkLogonRight": {
2036                         "Policy": "Deny access to this computer from the network",
2037                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2038                         "rights_assignment": True,
2039                         "Settings": None,
2040                         "LsaRights": {"Option": "SeDenyNetworkLogonRight"},
2041                         "Transform": {
2042                             "Get": "_sidConversion",
2043                             "Put": "_usernamesToSidObjects",
2044                         },
2045                     },
2046                     "SeDenyBatchLogonRight": {
2047                         "Policy": "Deny log on as a batch job",
2048                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2049                         "rights_assignment": True,
2050                         "Settings": None,
2051                         "LsaRights": {"Option": "SeDenyBatchLogonRight"},
2052                         "Transform": {
2053                             "Get": "_sidConversion",
2054                             "Put": "_usernamesToSidObjects",
2055                         },
2056                     },
2057                     "SeDenyServiceLogonRight": {
2058                         "Policy": "Deny log on as a service",
2059                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2060                         "rights_assignment": True,
2061                         "Settings": None,
2062                         "LsaRights": {"Option": "SeDenyServiceLogonRight"},
2063                         "Transform": {
2064                             "Get": "_sidConversion",
2065                             "Put": "_usernamesToSidObjects",
2066                         },
2067                     },
2068                     "SeDenyInteractiveLogonRight": {
2069                         "Policy": "Deny log on locally",
2070                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2071                         "rights_assignment": True,
2072                         "Settings": None,
2073                         "LsaRights": {"Option": "SeDenyInteractiveLogonRight"},
2074                         "Transform": {
2075                             "Get": "_sidConversion",
2076                             "Put": "_usernamesToSidObjects",
2077                         },
2078                     },
2079                     "SeDenyRemoteInteractiveLogonRight": {
2080                         "Policy": "Deny log on through Remote Desktop Services",
2081                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2082                         "rights_assignment": True,
2083                         "Settings": None,
2084                         "LsaRights": {"Option": "SeDenyRemoteInteractiveLogonRight"},
2085                         "Transform": {
2086                             "Get": "_sidConversion",
2087                             "Put": "_usernamesToSidObjects",
2088                         },
2089                     },
2090                     "SeEnableDelegationPrivilege": {
2091                         "Policy": (
2092                             "Enable computer and user accounts to be "
2093                             "trusted for delegation"
2094                         ),
2095                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2096                         "rights_assignment": True,
2097                         "Settings": None,
2098                         "LsaRights": {"Option": "SeEnableDelegationPrivilege"},
2099                         "Transform": {
2100                             "Get": "_sidConversion",
2101                             "Put": "_usernamesToSidObjects",
2102                         },
2103                     },
2104                     "SeRemoteShutdownPrivilege": {
2105                         "Policy": "Force shutdown from a remote system",
2106                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2107                         "rights_assignment": True,
2108                         "Settings": None,
2109                         "LsaRights": {"Option": "SeRemoteShutdownPrivilege"},
2110                         "Transform": {
2111                             "Get": "_sidConversion",
2112                             "Put": "_usernamesToSidObjects",
2113                         },
2114                     },
2115                     "SeAuditPrivilege": {
2116                         "Policy": "Generate security audits",
2117                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2118                         "rights_assignment": True,
2119                         "Settings": None,
2120                         "LsaRights": {"Option": "SeAuditPrivilege"},
2121                         "Transform": {
2122                             "Get": "_sidConversion",
2123                             "Put": "_usernamesToSidObjects",
2124                         },
2125                     },
2126                     "SeImpersonatePrivilege": {
2127                         "Policy": "Impersonate a client after authentication",
2128                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2129                         "rights_assignment": True,
2130                         "Settings": None,
2131                         "LsaRights": {"Option": "SeImpersonatePrivilege"},
2132                         "Transform": {
2133                             "Get": "_sidConversion",
2134                             "Put": "_usernamesToSidObjects",
2135                         },
2136                     },
2137                     "SeIncreaseWorkingSetPrivilege": {
2138                         "Policy": "Increase a process working set",
2139                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2140                         "rights_assignment": True,
2141                         "Settings": None,
2142                         "LsaRights": {"Option": "SeIncreaseWorkingSetPrivilege"},
2143                         "Transform": {
2144                             "Get": "_sidConversion",
2145                             "Put": "_usernamesToSidObjects",
2146                         },
2147                     },
2148                     "SeIncreaseBasePriorityPrivilege": {
2149                         "Policy": "Increase scheduling priority",
2150                         "rights_assignment": True,
2151                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2152                         "Settings": None,
2153                         "LsaRights": {"Option": "SeIncreaseBasePriorityPrivilege"},
2154                         "Transform": {
2155                             "Get": "_sidConversion",
2156                             "Put": "_usernamesToSidObjects",
2157                         },
2158                     },
2159                     "SeLoadDriverPrivilege": {
2160                         "Policy": "Load and unload device drivers",
2161                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2162                         "rights_assignment": True,
2163                         "Settings": None,
2164                         "LsaRights": {"Option": "SeLoadDriverPrivilege"},
2165                         "Transform": {
2166                             "Get": "_sidConversion",
2167                             "Put": "_usernamesToSidObjects",
2168                         },
2169                     },
2170                     "SeLockMemoryPrivilege": {
2171                         "Policy": "Lock pages in memory",
2172                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2173                         "rights_assignment": True,
2174                         "Settings": None,
2175                         "LsaRights": {"Option": "SeLockMemoryPrivilege"},
2176                         "Transform": {
2177                             "Get": "_sidConversion",
2178                             "Put": "_usernamesToSidObjects",
2179                         },
2180                     },
2181                     "SeBatchLogonRight": {
2182                         "Policy": "Log on as a batch job",
2183                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2184                         "rights_assignment": True,
2185                         "Settings": None,
2186                         "LsaRights": {"Option": "SeBatchLogonRight"},
2187                         "Transform": {
2188                             "Get": "_sidConversion",
2189                             "Put": "_usernamesToSidObjects",
2190                         },
2191                     },
2192                     "SeServiceLogonRight": {
2193                         "Policy": "Log on as a service",
2194                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2195                         "rights_assignment": True,
2196                         "Settings": None,
2197                         "LsaRights": {"Option": "SeServiceLogonRight"},
2198                         "Transform": {
2199                             "Get": "_sidConversion",
2200                             "Put": "_usernamesToSidObjects",
2201                         },
2202                     },
2203                     "SeSecurityPrivilege": {
2204                         "Policy": "Manage auditing and security log",
2205                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2206                         "rights_assignment": True,
2207                         "Settings": None,
2208                         "LsaRights": {"Option": "SeSecurityPrivilege"},
2209                         "Transform": {
2210                             "Get": "_sidConversion",
2211                             "Put": "_usernamesToSidObjects",
2212                         },
2213                     },
2214                     "SeRelabelPrivilege": {
2215                         "Policy": "Modify an object label",
2216                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2217                         "rights_assignment": True,
2218                         "Settings": None,
2219                         "LsaRights": {"Option": "SeRelabelPrivilege"},
2220                         "Transform": {
2221                             "Get": "_sidConversion",
2222                             "Put": "_usernamesToSidObjects",
2223                         },
2224                     },
2225                     "SeSystemEnvironmentPrivilege": {
2226                         "Policy": "Modify firmware environment values",
2227                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2228                         "rights_assignment": True,
2229                         "Settings": None,
2230                         "LsaRights": {"Option": "SeSystemEnvironmentPrivilege"},
2231                         "Transform": {
2232                             "Get": "_sidConversion",
2233                             "Put": "_usernamesToSidObjects",
2234                         },
2235                     },
2236                     "SeManageVolumePrivilege": {
2237                         "Policy": "Perform volume maintenance tasks",
2238                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2239                         "rights_assignment": True,
2240                         "Settings": None,
2241                         "LsaRights": {"Option": "SeManageVolumePrivilege"},
2242                         "Transform": {
2243                             "Get": "_sidConversion",
2244                             "Put": "_usernamesToSidObjects",
2245                         },
2246                     },
2247                     "SeProfileSingleProcessPrivilege": {
2248                         "Policy": "Profile single process",
2249                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2250                         "rights_assignment": True,
2251                         "Settings": None,
2252                         "LsaRights": {"Option": "SeProfileSingleProcessPrivilege"},
2253                         "Transform": {
2254                             "Get": "_sidConversion",
2255                             "Put": "_usernamesToSidObjects",
2256                         },
2257                     },
2258                     "SeSystemProfilePrivilege": {
2259                         "Policy": "Profile system performance",
2260                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2261                         "rights_assignment": True,
2262                         "Settings": None,
2263                         "LsaRights": {"Option": "SeSystemProfilePrivilege"},
2264                         "Transform": {
2265                             "Get": "_sidConversion",
2266                             "Put": "_usernamesToSidObjects",
2267                         },
2268                     },
2269                     "SeUndockPrivilege": {
2270                         "Policy": "Remove computer from docking station",
2271                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2272                         "rights_assignment": True,
2273                         "Settings": None,
2274                         "LsaRights": {"Option": "SeUndockPrivilege"},
2275                         "Transform": {
2276                             "Get": "_sidConversion",
2277                             "Put": "_usernamesToSidObjects",
2278                         },
2279                     },
2280                     "SeAssignPrimaryTokenPrivilege": {
2281                         "Policy": "Replace a process level token",
2282                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2283                         "rights_assignment": True,
2284                         "Settings": None,
2285                         "LsaRights": {"Option": "SeAssignPrimaryTokenPrivilege"},
2286                         "Transform": {
2287                             "Get": "_sidConversion",
2288                             "Put": "_usernamesToSidObjects",
2289                         },
2290                     },
2291                     "SeRestorePrivilege": {
2292                         "Policy": "Restore files and directories",
2293                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2294                         "rights_assignment": True,
2295                         "Settings": None,
2296                         "LsaRights": {"Option": "SeRestorePrivilege"},
2297                         "Transform": {
2298                             "Get": "_sidConversion",
2299                             "Put": "_usernamesToSidObjects",
2300                         },
2301                     },
2302                     "SeShutdownPrivilege": {
2303                         "Policy": "Shut down the system",
2304                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2305                         "rights_assignment": True,
2306                         "Settings": None,
2307                         "LsaRights": {"Option": "SeShutdownPrivilege"},
2308                         "Transform": {
2309                             "Get": "_sidConversion",
2310                             "Put": "_usernamesToSidObjects",
2311                         },
2312                     },
2313                     "SeSyncAgentPrivilege": {
2314                         "Policy": "Synchronize directory service data",
2315                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2316                         "rights_assignment": True,
2317                         "Settings": None,
2318                         "LsaRights": {"Option": "SeSyncAgentPrivilege"},
2319                         "Transform": {
2320                             "Get": "_sidConversion",
2321                             "Put": "_usernamesToSidObjects",
2322                         },
2323                     },
2324                     "SeTakeOwnershipPrivilege": {
2325                         "Policy": "Take ownership of files or other objects",
2326                         "lgpo_section": self.user_rights_assignment_gpedit_path,
2327                         "rights_assignment": True,
2328                         "Settings": None,
2329                         "LsaRights": {"Option": "SeTakeOwnershipPrivilege"},
2330                         "Transform": {
2331                             "Get": "_sidConversion",
2332                             "Put": "_usernamesToSidObjects",
2333                         },
2334                     },
2335                     "RecoveryConsoleSecurityLevel": {
2336                         "Policy": (
2337                             "Recovery console: Allow automatic administrative logon"
2338                         ),
2339                         "Settings": self.enabled_one_disabled_zero.keys(),
2340                         "lgpo_section": self.security_options_gpedit_path,
2341                         "Registry": {
2342                             "Hive": "HKEY_LOCAL_MACHINE",
2343                             "Path": (
2344                                 "Software\\Microsoft\\Windows NT\\"
2345                                 "CurrentVersion\\Setup\\RecoveryConsole"
2346                             ),
2347                             "Value": "SecurityLevel",
2348                             "Type": "REG_DWORD",
2349                         },
2350                         "Transform": self.enabled_one_disabled_zero_transform,
2351                     },
2352                     "RecoveryConsoleSetCommand": {
2353                         "Policy": (
2354                             "Recovery console: Allow floppy copy and "
2355                             "access to all drives and all folders"
2356                         ),
2357                         "Settings": self.enabled_one_disabled_zero.keys(),
2358                         "lgpo_section": self.security_options_gpedit_path,
2359                         "Registry": {
2360                             "Hive": "HKEY_LOCAL_MACHINE",
2361                             "Path": (
2362                                 "Software\\Microsoft\\Windows NT\\"
2363                                 "CurrentVersion\\Setup\\RecoveryConsole"
2364                             ),
2365                             "Value": "SetCommand",
2366                             "Type": "REG_DWORD",
2367                         },
2368                         "Transform": self.enabled_one_disabled_zero_transform,
2369                     },
2370                     "ForceKeyProtection": {
2371                         "Policy": (
2372                             "System Cryptography: Force strong key protection for "
2373                             "user keys stored on the computer"
2374                         ),
2375                         "Settings": self.force_key_protection.keys(),
2376                         "lgpo_section": self.security_options_gpedit_path,
2377                         "Registry": {
2378                             "Hive": "HKEY_LOCAL_MACHINE",
2379                             "Path": "Software\\Policies\\Microsoft\\Cryptography",
2380                             "Value": "ForceKeyProtection",
2381                             "Type": "REG_DWORD",
2382                         },
2383                         "Transform": {
2384                             "Get": "_dict_lookup",
2385                             "Put": "_dict_lookup",
2386                             "GetArgs": {
2387                                 "lookup": self.force_key_protection,
2388                                 "value_lookup": False,
2389                             },
2390                             "PutArgs": {
2391                                 "lookup": self.force_key_protection,
2392                                 "value_lookup": True,
2393                             },
2394                         },
2395                     },
2396                     "FIPSAlgorithmPolicy": {
2397                         "Policy": (
2398                             "System Cryptography: Use FIPS compliant algorithms "
2399                             "for encryption, hashing, and signing"
2400                         ),
2401                         "Settings": self.enabled_one_disabled_zero.keys(),
2402                         "lgpo_section": self.security_options_gpedit_path,
2403                         "Registry": {
2404                             "Hive": "HKEY_LOCAL_MACHINE",
2405                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\FIPSAlgorithmPolicy",
2406                             "Value": "Enabled",
2407                             "Type": "REG_DWORD",
2408                         },
2409                         "Transform": self.enabled_one_disabled_zero_transform,
2410                     },
2411                     "MachineAccessRestriction": {
2412                         "Policy": (
2413                             "DCOM: Machine Access Restrictions in Security Descriptor "
2414                             "Definition Language (SDDL) syntax"
2415                         ),
2416                         "Settings": None,
2417                         "lgpo_section": self.security_options_gpedit_path,
2418                         "Registry": {
2419                             "Hive": "HKEY_LOCAL_MACHINE",
2420                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
2421                             "Value": "MachineAccessRestriction",
2422                             "Type": "REG_SZ",
2423                         },
2424                         "Transform": {"Put": "_string_put_transform"},
2425                     },
2426                     "MachineLaunchRestriction": {
2427                         "Policy": (
2428                             "DCOM: Machine Launch Restrictions in Security Descriptor "
2429                             "Definition Language (SDDL) syntax"
2430                         ),
2431                         "Settings": None,
2432                         "lgpo_section": self.security_options_gpedit_path,
2433                         "Registry": {
2434                             "Hive": "HKEY_LOCAL_MACHINE",
2435                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
2436                             "Value": "MachineLaunchRestriction",
2437                             "Type": "REG_SZ",
2438                         },
2439                         "Transform": {"Put": "_string_put_transform"},
2440                     },
2441                     "UseMachineId": {
2442                         "Policy": (
2443                             "Network security: Allow Local System to use computer "
2444                             "identity for NTLM"
2445                         ),
2446                         "Settings": self.enabled_one_disabled_zero.keys(),
2447                         "lgpo_section": self.security_options_gpedit_path,
2448                         "Registry": {
2449                             "Hive": "HKEY_LOCAL_MACHINE",
2450                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
2451                             "Value": "UseMachineId",
2452                             "Type": "REG_DWORD",
2453                         },
2454                         "Transform": self.enabled_one_disabled_zero_transform,
2455                     },
2456                     "allownullsessionfallback": {
2457                         "Policy": (
2458                             "Network security: Allow LocalSystem NULL session fallback"
2459                         ),
2460                         "Settings": self.enabled_one_disabled_zero.keys(),
2461                         "lgpo_section": self.security_options_gpedit_path,
2462                         "Registry": {
2463                             "Hive": "HKEY_LOCAL_MACHINE",
2464                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
2465                             "Value": "allownullsessionfallback",
2466                             "Type": "REG_DWORD",
2467                         },
2468                         "Transform": self.enabled_one_disabled_zero_transform,
2469                     },
2470                     "AllowOnlineID": {
2471                         "Policy": (
2472                             "Network security: Allow PKU2U authentication requests "
2473                             "to this computer to use online identities."
2474                         ),
2475                         "Settings": self.enabled_one_disabled_zero.keys(),
2476                         "lgpo_section": self.security_options_gpedit_path,
2477                         "Registry": {
2478                             "Hive": "HKEY_LOCAL_MACHINE",
2479                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\pku2u",
2480                             "Value": "AllowOnlineID",
2481                             "Type": "REG_DWORD",
2482                         },
2483                         "Transform": self.enabled_one_disabled_zero_transform,
2484                     },
2485                     "KrbSupportedEncryptionTypes": {
2486                         "Policy": (
2487                             "Network security: Configure encryption types allowed "
2488                             "for Kerberos"
2489                         ),
2490                         "Settings": None,
2491                         "lgpo_section": self.security_options_gpedit_path,
2492                         "Registry": {
2493                             "Hive": "HKEY_LOCAL_MACHINE",
2494                             "Path": (
2495                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies"
2496                                 "\\system\\Kerberos\\Parameters"
2497                             ),
2498                             "Value": "SupportedEncryptionTypes",
2499                             "Type": "REG_DWORD",
2500                         },
2501                         "Transform": {
2502                             "Get": "_dict_lookup_bitwise_add",
2503                             "Put": "_dict_lookup_bitwise_add",
2504                             "GetArgs": {
2505                                 "lookup": self.krb_encryption_types,
2506                                 "value_lookup": False,
2507                             },
2508                             "PutArgs": {
2509                                 "lookup": self.krb_encryption_types,
2510                                 "value_lookup": True,
2511                             },
2512                         },
2513                     },
2514                     "NoLMHash": {
2515                         "Policy": (
2516                             "Network security: Do not store LAN Manager hash value "
2517                             "on next password change"
2518                         ),
2519                         "Settings": self.enabled_one_disabled_zero.keys(),
2520                         "lgpo_section": self.security_options_gpedit_path,
2521                         "Registry": {
2522                             "Hive": "HKEY_LOCAL_MACHINE",
2523                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
2524                             "Value": "NoLMHash",
2525                             "Type": "REG_DWORD",
2526                         },
2527                         "Transform": self.enabled_one_disabled_zero_transform,
2528                     },
2529                     "ForceLogoffWhenHourExpire": {
2530                         "Policy": (
2531                             "Network security: Force logoff when logon hours expire"
2532                         ),
2533                         "lgpo_section": self.security_options_gpedit_path,
2534                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
2535                         "Secedit": {
2536                             "Option": "ForceLogoffWhenHourExpire",
2537                             "Section": "System Access",
2538                         },
2539                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
2540                     },
2541                     "LmCompatibilityLevel": {
2542                         "Policy": "Network security: LAN Manager authentication level",
2543                         "Settings": self.lm_compat_levels.keys(),
2544                         "lgpo_section": self.security_options_gpedit_path,
2545                         "Registry": {
2546                             "Hive": "HKEY_LOCAL_MACHINE",
2547                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
2548                             "Value": "LmCompatibilityLevel",
2549                             "Type": "REG_DWORD",
2550                         },
2551                         "Transform": {
2552                             "Get": "_dict_lookup",
2553                             "Put": "_dict_lookup",
2554                             "GetArgs": {
2555                                 "lookup": self.lm_compat_levels,
2556                                 "value_lookup": False,
2557                             },
2558                             "PutArgs": {
2559                                 "lookup": self.lm_compat_levels,
2560                                 "value_lookup": True,
2561                             },
2562                         },
2563                     },
2564                     "LDAPClientIntegrity": {
2565                         "Policy": "Network security: LDAP client signing requirements",
2566                         "Settings": self.ldap_signing_reqs.keys(),
2567                         "lgpo_section": self.security_options_gpedit_path,
2568                         "Registry": {
2569                             "Hive": "HKEY_LOCAL_MACHINE",
2570                             "Path": "SYSTEM\\CurrentControlSet\\Services\\ldap",
2571                             "Value": "LDAPClientIntegrity",
2572                             "Type": "REG_DWORD",
2573                         },
2574                         "Transform": {
2575                             "Get": "_dict_lookup",
2576                             "Put": "_dict_lookup",
2577                             "GetArgs": {
2578                                 "lookup": self.ldap_signing_reqs,
2579                                 "value_lookup": False,
2580                             },
2581                             "PutArgs": {
2582                                 "lookup": self.ldap_signing_reqs,
2583                                 "value_lookup": True,
2584                             },
2585                         },
2586                     },
2587                     "NTLMMinClientSec": {
2588                         "Policy": (
2589                             "Network security: Minimum session security for NTLM SSP"
2590                             " based (including secure RPC) clients"
2591                         ),
2592                         "Settings": None,
2593                         "lgpo_section": self.security_options_gpedit_path,
2594                         "Registry": {
2595                             "Hive": "HKEY_LOCAL_MACHINE",
2596                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
2597                             "Value": "NTLMMinClientSec",
2598                             "Type": "REG_DWORD",
2599                         },
2600                         "Transform": {
2601                             "Get": "_dict_lookup_bitwise_add",
2602                             "Put": "_dict_lookup_bitwise_add",
2603                             "GetArgs": {
2604                                 "lookup": self.ntlm_session_security_levels,
2605                                 "value_lookup": False,
2606                             },
2607                             "PutArgs": {
2608                                 "lookup": self.ntlm_session_security_levels,
2609                                 "value_lookup": True,
2610                             },
2611                         },
2612                     },
2613                     "NTLMMinServerSec": {
2614                         "Policy": (
2615                             "Network security: Minimum session security for NTLM SSP"
2616                             " based (including secure RPC) servers"
2617                         ),
2618                         "Settings": None,
2619                         "lgpo_section": self.security_options_gpedit_path,
2620                         "Registry": {
2621                             "Hive": "HKEY_LOCAL_MACHINE",
2622                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
2623                             "Value": "NTLMMinServerSec",
2624                             "Type": "REG_DWORD",
2625                         },
2626                         "Transform": {
2627                             "Get": "_dict_lookup_bitwise_add",
2628                             "Put": "_dict_lookup_bitwise_add",
2629                             "GetArgs": {
2630                                 "lookup": self.ntlm_session_security_levels,
2631                                 "value_lookup": False,
2632                             },
2633                             "PutArgs": {
2634                                 "lookup": self.ntlm_session_security_levels,
2635                                 "value_lookup": True,
2636                             },
2637                         },
2638                     },
2639                     "ClientAllowedNTLMServers": {
2640                         "Policy": (
2641                             "Network security: Restrict NTLM: Add remote server"
2642                             " exceptions for NTLM authentication"
2643                         ),
2644                         "lgpo_section": self.security_options_gpedit_path,
2645                         "Registry": {
2646                             "Hive": "HKEY_LOCAL_MACHINE",
2647                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
2648                             "Value": "ClientAllowedNTLMServers",
2649                             "Type": "REG_MULTI_SZ",
2650                         },
2651                         "Transform": {
2652                             "Put": "_multi_string_put_transform",
2653                             "Get": "_multi_string_get_transform",
2654                         },
2655                     },
2656                     "DCAllowedNTLMServers": {
2657                         "Policy": (
2658                             "Network security: Restrict NTLM: Add server exceptions"
2659                             " in this domain"
2660                         ),
2661                         "lgpo_section": self.security_options_gpedit_path,
2662                         "Registry": {
2663                             "Hive": "HKEY_LOCAL_MACHINE",
2664                             "Path": "System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
2665                             "Value": "DCAllowedNTLMServers",
2666                             "Type": "REG_MULTI_SZ",
2667                         },
2668                         "Transform": {
2669                             "Put": "_multi_string_put_transform",
2670                             "Get": "_multi_string_get_transform",
2671                         },
2672                     },
2673                     "AuditReceivingNTLMTraffic": {
2674                         "Policy": (
2675                             "Network security: Restrict NTLM: Audit Incoming NTLM"
2676                             " Traffic"
2677                         ),
2678                         "Settings": self.ntlm_audit_settings.keys(),
2679                         "lgpo_section": self.security_options_gpedit_path,
2680                         "Registry": {
2681                             "Hive": "HKEY_LOCAL_MACHINE",
2682                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
2683                             "Value": "AuditReceivingNTLMTraffic",
2684                             "Type": "REG_DWORD",
2685                         },
2686                         "Transform": {
2687                             "Get": "_dict_lookup",
2688                             "Put": "_dict_lookup",
2689                             "GetArgs": {
2690                                 "lookup": self.ntlm_audit_settings,
2691                                 "value_lookup": False,
2692                             },
2693                             "PutArgs": {
2694                                 "lookup": self.ntlm_audit_settings,
2695                                 "value_lookup": True,
2696                             },
2697                         },
2698                     },
2699                     "AuditNTLMInDomain": {
2700                         "Policy": (
2701                             "Network security: Restrict NTLM: Audit NTLM "
2702                             "authentication in this domain"
2703                         ),
2704                         "Settings": self.ntlm_domain_audit_settings.keys(),
2705                         "lgpo_section": self.security_options_gpedit_path,
2706                         "Registry": {
2707                             "Hive": "HKEY_LOCAL_MACHINE",
2708                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
2709                             "Value": "AuditNTLMInDomain",
2710                             "Type": "REG_DWORD",
2711                         },
2712                         "Transform": {
2713                             "Get": "_dict_lookup",
2714                             "Put": "_dict_lookup",
2715                             "GetArgs": {
2716                                 "lookup": self.ntlm_domain_audit_settings,
2717                                 "value_lookup": False,
2718                             },
2719                             "PutArgs": {
2720                                 "lookup": self.ntlm_domain_audit_settings,
2721                                 "value_lookup": True,
2722                             },
2723                         },
2724                     },
2725                     "RestrictReceivingNTLMTraffic": {
2726                         "Policy": (
2727                             "Network security: Restrict NTLM: Incoming NTLM traffic"
2728                         ),
2729                         "Settings": self.incoming_ntlm_settings.keys(),
2730                         "lgpo_section": self.security_options_gpedit_path,
2731                         "Registry": {
2732                             "Hive": "HKEY_LOCAL_MACHINE",
2733                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
2734                             "Value": "RestrictReceivingNTLMTraffic",
2735                             "Type": "REG_DWORD",
2736                         },
2737                         "Transform": {
2738                             "Get": "_dict_lookup",
2739                             "Put": "_dict_lookup",
2740                             "GetArgs": {
2741                                 "lookup": self.incoming_ntlm_settings,
2742                                 "value_lookup": False,
2743                             },
2744                             "PutArgs": {
2745                                 "lookup": self.incoming_ntlm_settings,
2746                                 "value_lookup": True,
2747                             },
2748                         },
2749                     },
2750                     "RestrictNTLMInDomain": {
2751                         "Policy": (
2752                             "Network security: Restrict NTLM: NTLM "
2753                             "authentication in this domain"
2754                         ),
2755                         "Settings": self.ntlm_domain_auth_settings.keys(),
2756                         "lgpo_section": self.security_options_gpedit_path,
2757                         "Registry": {
2758                             "Hive": "HKEY_LOCAL_MACHINE",
2759                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
2760                             "Value": "RestrictNTLMInDomain",
2761                             "Type": "REG_DWORD",
2762                         },
2763                         "Transform": {
2764                             "Get": "_dict_lookup",
2765                             "Put": "_dict_lookup",
2766                             "GetArgs": {
2767                                 "lookup": self.ntlm_domain_auth_settings,
2768                                 "value_lookup": False,
2769                             },
2770                             "PutArgs": {
2771                                 "lookup": self.ntlm_domain_auth_settings,
2772                                 "value_lookup": True,
2773                             },
2774                         },
2775                     },
2776                     "RestrictSendingNTLMTraffic": {
2777                         "Policy": (
2778                             "Network security: Restrict NTLM: Outgoing NTLM"
2779                             " traffic to remote servers"
2780                         ),
2781                         "Settings": self.outgoing_ntlm_settings.keys(),
2782                         "lgpo_section": self.security_options_gpedit_path,
2783                         "Registry": {
2784                             "Hive": "HKEY_LOCAL_MACHINE",
2785                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
2786                             "Value": "RestrictSendingNTLMTraffic",
2787                             "Type": "REG_DWORD",
2788                         },
2789                         "Transform": {
2790                             "Get": "_dict_lookup",
2791                             "Put": "_dict_lookup",
2792                             "GetArgs": {
2793                                 "lookup": self.outgoing_ntlm_settings,
2794                                 "value_lookup": False,
2795                             },
2796                             "PutArgs": {
2797                                 "lookup": self.outgoing_ntlm_settings,
2798                                 "value_lookup": True,
2799                             },
2800                         },
2801                     },
2802                     "ShutdownWithoutLogon": {
2803                         "Policy": (
2804                             "Shutdown: Allow system to be shut down "
2805                             "without having to log on"
2806                         ),
2807                         "Settings": self.enabled_one_disabled_zero.keys(),
2808                         "lgpo_section": self.security_options_gpedit_path,
2809                         "Registry": {
2810                             "Hive": "HKEY_LOCAL_MACHINE",
2811                             "Path": "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
2812                             "Value": "ShutdownWithoutLogon",
2813                             "Type": "REG_DWORD",
2814                         },
2815                         "Transform": self.enabled_one_disabled_zero_transform,
2816                     },
2817                     "ClearPageFileAtShutdown": {
2818                         "Policy": "Shutdown: Clear virtual memory pagefile",
2819                         "Settings": self.enabled_one_disabled_zero.keys(),
2820                         "lgpo_section": self.security_options_gpedit_path,
2821                         "Registry": {
2822                             "Hive": "HKEY_LOCAL_MACHINE",
2823                             "Path": (
2824                                 "System\\CurrentControlSet\\Control\\"
2825                                 "SESSION MANAGER\\MEMORY MANAGEMENT"
2826                             ),
2827                             "Value": "ClearPageFileAtShutdown",
2828                             "Type": "REG_DWORD",
2829                         },
2830                         "Transform": self.enabled_one_disabled_zero_transform,
2831                     },
2832                     "ObCaseInsensitive": {
2833                         "Policy": (
2834                             "System objects: Require case insensitivity for "
2835                             "non-Windows subsystems"
2836                         ),
2837                         "Settings": self.enabled_one_disabled_zero.keys(),
2838                         "lgpo_section": self.security_options_gpedit_path,
2839                         "Registry": {
2840                             "Hive": "HKEY_LOCAL_MACHINE",
2841                             "Path": (
2842                                 "System\\CurrentControlSet\\Control\\"
2843                                 "SESSION MANAGER\\Kernel"
2844                             ),
2845                             "Value": "ObCaseInsensitive",
2846                             "Type": "REG_DWORD",
2847                         },
2848                         "Transform": self.enabled_one_disabled_zero_transform,
2849                     },
2850                     "ProtectionMode": {
2851                         "Policy": (
2852                             "System objects: Strengthen default permissions of "
2853                             "internal system objects (e.g. Symbolic Links)"
2854                         ),
2855                         "Settings": self.enabled_one_disabled_zero.keys(),
2856                         "lgpo_section": self.security_options_gpedit_path,
2857                         "Registry": {
2858                             "Hive": "HKEY_LOCAL_MACHINE",
2859                             "Path": (
2860                                 "System\\CurrentControlSet\\Control\\SESSION MANAGER"
2861                             ),
2862                             "Value": "ProtectionMode",
2863                             "Type": "REG_DWORD",
2864                         },
2865                         "Transform": self.enabled_one_disabled_zero_transform,
2866                     },
2867                     "OptionalSubsystems": {
2868                         "Policy": "System settings: Optional subsystems",
2869                         "lgpo_section": self.security_options_gpedit_path,
2870                         "Registry": {
2871                             "Hive": "HKEY_LOCAL_MACHINE",
2872                             "Path": (
2873                                 "System\\CurrentControlSet\\Control\\"
2874                                 "SESSION MANAGER\\SubSystems"
2875                             ),
2876                             "Value": "optional",
2877                             "Type": "REG_MULTI_SZ",
2878                         },
2879                         "Transform": {
2880                             "Put": "_multi_string_put_transform",
2881                             "Get": "_multi_string_get_transform",
2882                         },
2883                     },
2884                     "AuthenticodeEnabled": {
2885                         "Policy": (
2886                             "System settings: Use Certificate Rules on Windows"
2887                             " Executables for Software Restriction Policies"
2888                         ),
2889                         "Settings": self.enabled_one_disabled_zero.keys(),
2890                         "lgpo_section": self.security_options_gpedit_path,
2891                         "Registry": {
2892                             "Hive": "HKEY_LOCAL_MACHINE",
2893                             "Path": "SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers",
2894                             "Value": "AuthenticodeEnabled",
2895                             "Type": "REG_DWORD",
2896                         },
2897                         "Transform": self.enabled_one_disabled_zero_transform,
2898                     },
2899                 },
2900             },
2901             "User": {"lgpo_section": "User Configuration", "policies": {}},
2902         }
2903         self.admx_registry_classes = {
2904             "User": {
2905                 "policy_path": os.path.join(
2906                     os.getenv("WINDIR"),
2907                     "System32",
2908                     "GroupPolicy",
2909                     "User",
2910                     "Registry.pol",
2911                 ),
2912                 "hive": "HKEY_USERS",
2913                 "lgpo_section": "User Configuration",
2914                 "gpt_extension_location": "gPCUserExtensionNames",
2915                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F73-3407-48AE-BA88-E8213C6761F1}]",
2916             },
2917             "Machine": {
2918                 "policy_path": os.path.join(
2919                     os.getenv("WINDIR"),
2920                     "System32",
2921                     "GroupPolicy",
2922                     "Machine",
2923                     "Registry.pol",
2924                 ),
2925                 "hive": "HKEY_LOCAL_MACHINE",
2926                 "lgpo_section": "Computer Configuration",
2927                 "gpt_extension_location": "gPCMachineExtensionNames",
2928                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F72-3407-48AE-BA88-E8213C6761F1}]",
2929             },
2930         }
2931         self.reg_pol_header = "\u5250\u6765\x01\x00"
2932         self.gpt_ini_path = os.path.join(
2933             os.getenv("WINDIR"), "System32", "GroupPolicy", "gpt.ini"
2934         )
2935     @classmethod
2936     def _notEmpty(cls, val, **kwargs):
2937         if val:
2938             return True
2939         else:
2940             return False
2941     @classmethod
2942     def _seconds_to_days(cls, val, **kwargs):
2943         zero_value = kwargs.get("zero_value", 0)
2944         if val is not None:
2945             if val == zero_value:
2946                 return 0
2947             return val / 86400
2948         else:
2949             return "Not Defined"
2950     @classmethod
2951     def _days_to_seconds(cls, val, **kwargs):
2952         zero_value = kwargs.get("zero_value", 0)
2953         if val is not None:
2954             if val == 0:
2955                 return zero_value
2956             return val * 86400
2957         else:
2958             return "Not Defined"
2959     @classmethod
2960     def _seconds_to_minutes(cls, val, **kwargs):
2961         zero_value = kwargs.get("zero_value", 0)
2962         if val is not None:
2963             if val == zero_value:
2964                 return 0
2965             return val / 60
2966         else:
2967             return "Not Defined"
2968     @classmethod
2969     def _minutes_to_seconds(cls, val, **kwargs):
2970         zero_value = kwargs.get("zero_value", 0)
2971         if val is not None:
2972             if val == 0:
2973                 return zero_value
2974             return val * 60
2975         else:
2976             return "Not Defined"
2977     @classmethod
2978     def _strip_quotes(cls, val, **kwargs):
2979         return val.replace('"', "")
2980     @classmethod
2981     def _add_quotes(cls, val, **kwargs):
2982         return '"{}"'.format(val)
2983     @classmethod
2984     def _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):
2985         try:
2986             if val is not None:
2987                 if ord(val) == 0:
2988                     return "Disabled"
2989                 elif ord(val) == 1:
2990                     return "Enabled"
2991                 else:
2992                     return "Invalid Value: {!r}".format(val)
2993             else:
2994                 return "Not Defined"
2995         except TypeError:
2996             return "Invalid Value"
2997     @classmethod
2998     def _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):
2999         if val is not None:
3000             if val.upper() == "DISABLED":
3001                 return chr(0)
3002             elif val.upper() == "ENABLED":
3003                 return chr(1)
3004             else:
3005                 return None
3006         else:
3007             return None
3008     @classmethod
3009     def _dasd_conversion(cls, val, **kwargs):
3010         if val is not None:
3011             if val == "0" or val == 0 or val == "":
3012                 return "Administrators"
3013             elif val == "1" or val == 1:
3014                 return "Administrators and Power Users"
3015             elif val == "2" or val == 2:
3016                 return "Administrators and Interactive Users"
3017             else:
3018                 return "Not Defined"
3019         else:
3020             return "Not Defined"
3021     @classmethod
3022     def _dasd_reverse_conversion(cls, val, **kwargs):
3023         if val is not None:
3024             if val.upper() == "ADMINISTRATORS":
3025                 return "0"
3026             elif val.upper() == "ADMINISTRATORS AND POWER USERS":
3027                 return "1"
3028             elif val.upper() == "ADMINISTRATORS AND INTERACTIVE USERS":
3029                 return "2"
3030             elif val.upper() == "NOT DEFINED":
3031                 return "9999"
3032             else:
3033                 return "Invalid Value"
3034         else:
3035             return "Not Defined"
3036     @classmethod
3037     def _in_range_inclusive(cls, val, **kwargs):
3038         minimum = kwargs.get("min", 0)
3039         maximum = kwargs.get("max", 1)
3040         zero_value = kwargs.get("zero_value", 0)
3041         if isinstance(val, str):
3042             if val.lower() == "not defined":
3043                 return True
3044             else:
3045                 try:
3046                     val = int(val)
3047                 except ValueError:
3048                     return False
3049         if val is not None:
3050             if minimum &lt;= val &lt;= maximum or val == zero_value:
3051                 return True
3052             else:
3053                 return False
3054         else:
3055             return False
3056     @classmethod
3057     def _driver_signing_reg_conversion(cls, val, **kwargs):
3058         log.trace("we have %s for the driver signing value", val)
3059         if val is not None:
3060             _val = val.split(",")
3061             if len(_val) == 2:
3062                 if _val[1] == "0":
3063                     return "Silently Succeed"
3064                 elif _val[1] == "1":
3065                     return "Warn but allow installation"
3066                 elif _val[1] == "2":
3067                     return "Do not allow installation"
3068                 elif _val[1] == "Not Defined":
3069                     return "Not Defined"
3070                 else:
3071                     return "Invalid Value"
3072             else:
3073                 return "Not Defined"
3074         else:
3075             return "Not Defined"
3076     @classmethod
3077     def _driver_signing_reg_reverse_conversion(cls, val, **kwargs):
3078         if val is not None:
3079             if val.upper() == "SILENTLY SUCCEED":
3080                 return ",".join(["3", "0"])
3081             elif val.upper() == "WARN BUT ALLOW INSTALLATION":
3082                 return ",".join(["3", chr(1)])
3083             elif val.upper() == "DO NOT ALLOW INSTALLATION":
3084                 return ",".join(["3", chr(2)])
3085             else:
3086                 return "Invalid Value"
3087         else:
3088             return "Not Defined"
3089     @classmethod
3090     def _sidConversion(cls, val, **kwargs):
3091         if isinstance(val, str):
3092             val = val.split(",")
3093         usernames = []
3094         for _sid in val:
3095             try:
3096                 userSid = win32security.LookupAccountSid("", _sid)
3097                 if userSid[1]:
3098                     userSid = "{1}\\{0}".format(userSid[0], userSid[1])
3099                 else:
3100                     userSid = "{}".format(userSid[0])
3101             except Exception:  # pylint: disable=broad-except
3102                 userSid = win32security.ConvertSidToStringSid(_sid)
3103                 log.warning(
3104                     "Unable to convert SID '%s' to a friendly name. "
3105                     "The SID will be displayed instead of a user/group name.",
3106                     userSid,
3107                 )
3108             usernames.append(userSid)
3109         return usernames
3110     @classmethod
3111     def _usernamesToSidObjects(cls, val, **kwargs):
3112         if not val:
3113             return val
3114         if isinstance(val, str):
3115             val = val.split(",")
3116         sids = []
3117         for _user in val:
3118             try:
3119                 sid = win32security.LookupAccountName("", _user)[0]
3120                 sids.append(sid)
3121             except Exception as e:  # pylint: disable=broad-except
3122                 log.exception("Handle this explicitly")
3123                 raise CommandExecutionError(
3124                     'There was an error obtaining the SID of user "{}". Error '
3125                     "returned: {}".format(_user, e)
3126                 )
3127         return sids
3128     @classmethod
3129     def _powershell_script_order_conversion(cls, val, **kwargs):
3130         log.trace("script order value = %s", val)
3131         if val is None or val == "None":
3132             return "Not Configured"
3133         elif val == "true":
3134             return "Run Windows PowerShell scripts first"
3135         elif val == "false":
3136             return "Run Windows PowerShell scripts last"
3137         else:
3138             return "Invalid Value"
3139     @classmethod
3140     def _powershell_script_order_reverse_conversion(cls, val, **kwargs):
3141         if val.upper() == "Run Windows PowerShell scripts first".upper():
3142             return "true"
3143         elif val.upper() == "Run Windows PowerShell scripts last".upper():
3144             return "false"
3145         elif val == "Not Configured":
3146             return None
3147         else:
3148             return "Invalid Value"
3149     @classmethod
3150     def _dict_lookup(cls, item, **kwargs):
3151         log.trace("item == %s", item)
3152         value_lookup = kwargs.get("value_lookup", False)
3153         if "lookup" in kwargs:
3154             for k, v in kwargs["lookup"].items():
3155                 if value_lookup:
3156                     if str(v).lower() == str(item).lower():
3157                         log.trace("returning key %s", k)
3158                         return k
3159                 else:
3160                     if str(k).lower() == str(item).lower():
3161                         log.trace("returning value %s", v)
3162                         return v
3163         return "Invalid Value"
3164     @classmethod
3165     def _dict_lookup_bitwise_add(cls, item, **kwargs):
3166         value_lookup = kwargs.get("value_lookup", False)
3167         test_zero = kwargs.get("test_zero", False)
3168         ret_val = None
3169         if str(item).lower() == "not defined":
3170             return None
3171         if value_lookup:
3172             if not isinstance(item, list):
3173                 return "Invalid Value"
3174             ret_val = 0
3175         else:
3176             if not isinstance(item, int):
3177                 return "Invalid Value"
3178             ret_val = []
3179         if "lookup" in kwargs:
3180             for k, v in kwargs["lookup"].items():
3181                 if value_lookup:
3182                     if str(v).lower() in [z.lower() for z in item]:
3183                         ret_val = ret_val + k
3184                 else:
3185                     do_test = True
3186                     if not test_zero:
3187                         if k == 0:
3188                             do_test = False
3189                     if do_test and isinstance(k, int) and item &amp; k == k:
3190                         ret_val.append(v)
3191         else:
3192             return "Invalid Value"
3193         return ret_val
3194     @classmethod
3195     def _multi_string_put_transform(cls, item, **kwargs):
3196         if isinstance(item, list):
3197             return item
3198         elif isinstance(item, str):
3199             if item.lower() == "not defined":
3200                 return None
3201             else:
3202                 return item.split(",")
3203         else:
3204             return "Invalid Value"
3205     @classmethod
3206     def _multi_string_get_transform(cls, item, **kwargs):
3207         if isinstance(item, list):
3208             return item
3209         elif item is None:
3210             return "Not Defined"
3211         else:
3212             return "Invalid Value"
3213     @classmethod
3214     def _string_put_transform(cls, item, **kwargs):
3215         if isinstance(item, str):
3216             if item.lower() == "not defined":
3217                 return None
3218             else:
3219                 return item
3220 def __virtual__():
3221     if not salt.utils.platform.is_windows():
3222         return False, "win_lgpo: Not a Windows System"
3223     if not HAS_WINDOWS_MODULES:
3224         return False, "win_lgpo: Required modules failed to load"
3225     return __virtualname__
3226 def _updateNamespace(item, new_namespace):
3227     temp_item = ""
3228     i = item.tag.find("}")
3229     if i &gt;= 0:
3230         temp_item = item.tag[i + 1 :]
3231     else:
3232         temp_item = item.tag
3233     item.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
3234     for child in item.getiterator():
3235         if isinstance(child.tag, str):
3236             temp_item = ""
3237             i = child.tag.find("}")
3238             if i &gt;= 0:
3239                 temp_item = child.tag[i + 1 :]
3240             else:
3241                 temp_item = child.tag
3242             child.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
3243     return item
3244 def _updatePolicyElements(policy_item, regkey):
3245     for child in policy_item.getiterator():
3246         if "valueName" in child.attrib:
3247             if "key" not in child.attrib:
3248                 child.attrib["key"] = regkey
3249     return policy_item
3250 def _remove_unicode_encoding(xml_file):
3251     with salt.utils.files.fopen(xml_file, "rb") as f:
3252         xml_content = f.read()
3253     modified_xml = re.sub(
3254         r' encoding=[\'"]+unicode[\'"]+', "", xml_content.decode("utf-16"), count=1
3255     )
3256     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
3257     return xml_tree
3258 def _remove_invalid_xmlns(xml_file):
3259     with salt.utils.files.fopen(xml_file, "rb") as f:
3260         xml_content = f.read()
3261     modified_xml = re.sub(
3262         r' xmlns=[\'"]+.*[\'"]+', "", xml_content.decode("utf-8"), count=1
3263     )
3264     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
3265     return xml_tree
3266 def _parse_xml(adm_file):
3267     parser = lxml.etree.XMLParser(remove_comments=True)
3268     modified_xml = ""
3269     with salt.utils.files.fopen(adm_file, "rb") as rfh:
3270         file_hash = "{:X}".format(zlib.crc32(rfh.read()) &amp; 0xFFFFFFFF)
3271     name, ext = os.path.splitext(os.path.basename(adm_file))
3272     hashed_filename = "{}-{}{}".format(name, file_hash, ext)
3273     cache_dir = os.path.join(__opts__["cachedir"], "lgpo", "policy_defs")
3274     if not os.path.exists(cache_dir):
3275         os.makedirs(cache_dir)
3276     out_file = os.path.join(cache_dir, hashed_filename)
3277     if not os.path.isfile(out_file):
3278         log.debug("LGPO: Generating policy template cache for %s%s", name, ext)
3279         file_list = glob.glob(os.path.join(cache_dir, "{}*{}".format(name, ext)))
3280         for file_path in file_list:
3281             os.remove(file_path)
3282         with salt.utils.files.fopen(adm_file, "rb") as rfh:
3283             encoding = "utf-8"
3284             raw = rfh.read()
3285             try:
3286                 raw = raw.decode(encoding)
3287             except UnicodeDecodeError:
3288                 log.trace("LGPO: Detecting encoding")
3289                 encoding = "utf-16"
3290                 raw = raw.decode(encoding)
3291             for line in raw.split("\r\n"):
3292                 if 'key="' in line:
3293                     start = line.index('key="')
3294                     q1 = line[start:].index('"') + start
3295                     q2 = line[q1 + 1 :].index('"') + q1 + 1
3296                     line = line.replace(line[start:q2], line[start:q2].lower())
3297                     found_key = True
3298                 modified_xml += line + "\r\n"
3299         modified_xml = modified_xml.replace("\u201c", '"').replace("\u201d", '"')
3300         modified_xml = modified_xml.replace("\u2018", "'").replace("\u2019", "'")
3301         modified_xml = modified_xml.replace("\u2013", "-").replace("\u2014", "-")
3302         with salt.utils.files.fopen(out_file, "wb") as wfh:
3303             wfh.write(modified_xml.encode(encoding))
3304     try:
3305         xml_tree = lxml.etree.parse(out_file, parser=parser)
3306     except lxml.etree.XMLSyntaxError:
3307         try:
3308             xml_tree = _remove_unicode_encoding(out_file)
3309         except lxml.etree.XMLSyntaxError:
3310             xml_tree = _remove_invalid_xmlns(out_file)
3311     return xml_tree
3312 def _load_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
3313     display_language_fallback = INSTALL_LANGUAGE
3314     t_policy_definitions = lxml.etree.Element("policyDefinitions")
3315     t_policy_definitions<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(lxml.etree.Element("categories"))
3316     t_policy_definitions.append(lxml.etree.Element("policies"))
3317     t_policy_definitions.append(lxml.</b></font>etree.Element("policyNamespaces"))
3318     t_policy_definition_resources = lxml.etree.Element("policyDefinitionResources")
3319     policydefs_policies_xpath = etree.XPath("/policyDefinitions/policies")
3320     policydefs_categories_xpath = etree.XPath("/policyDefinitions/categories")
3321     policydefs_policyns_xpath = etree.XPath("/policyDefinitions/policyNamespaces")
3322     policydefs_resources_localname_xpath = etree.XPath(
3323         '//*[local-name() = "policyDefinitionResources"]/*'
3324     )
3325     policydef_resources_xpath = etree.XPath("/policyDefinitionResources")
3326     for root, dirs, files in salt.utils.path.os_walk(path):
3327         if root == path:
3328             for t_admx_file in files:
3329                 admx_file_name, admx_file_ext = os.path.splitext(t_admx_file)
3330                 if not admx_file_ext == ".admx":
3331                     log.debug("%s is not an ADMX file", t_admx_file)
3332                     continue
3333                 admx_file = os.path.join(root, t_admx_file)
3334                 try:
3335                     xml_tree = _parse_xml(admx_file)
3336                 except lxml.etree.XMLSyntaxError:
3337                     log.error(
3338                         "An error was found while processing admx "
3339                         "file %s, all policies from this file will "
3340                         "be unavailable via this module",
3341                         admx_file,
3342                     )
3343                     continue
3344                 namespaces = xml_tree.getroot().nsmap
3345                 namespace_string = ""
3346                 if None in namespaces:
3347                     namespaces["None"] = namespaces[None]
3348                     namespaces.pop(None)
3349                     namespace_string = "None:"
3350                 this_namespace = xml_tree.xpath(
3351                     "/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace".format(
3352                         namespace_string
3353                     ),
3354                     namespaces=namespaces,
3355                 )[0]
3356                 categories = xml_tree.xpath(
3357                     "/{0}policyDefinitions/{0}categories/{0}category".format(
3358                         namespace_string
3359                     ),
3360                     namespaces=namespaces,
3361                 )
3362                 for category in categories:
3363                     temp_cat = category
3364                     temp_cat = _updateNamespace(temp_cat, this_namespace)
3365                     policydefs_categories_xpath(t_policy_definitions)[0].append(
3366                         temp_cat
3367                     )
3368                 policies = xml_tree.xpath(
3369                     "/{0}policyDefinitions/{0}policies/{0}policy".format(
3370                         namespace_string
3371                     ),
3372                     namespaces=namespaces,
3373                 )
3374                 for policy in policies:
3375                     temp_pol = policy
3376                     temp_pol = _updateNamespace(temp_pol, this_namespace)
3377                     if "key" in temp_pol.attrib:
3378                         temp_pol = _updatePolicyElements(
3379                             temp_pol, temp_pol.attrib["key"]
3380                         )
3381                     policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)
3382                 policy_namespaces = xml_tree.xpath(
3383                     "/{0}policyDefinitions/{0}policyNamespaces/{0}*".format(
3384                         namespace_string
3385                     ),
3386                     namespaces=namespaces,
3387                 )
3388                 for policy_ns in policy_namespaces:
3389                     temp_ns = policy_ns
3390                     temp_ns = _updateNamespace(temp_ns, this_namespace)
3391                     policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)
3392                 adml_file = os.path.join(root, language, admx_file_name + ".adml")
3393                 if not __salt__["file.file_exists"](adml_file):
3394                     log.info(
3395                         "An ADML file in the specified ADML language "
3396                         '"%s" does not exist for the ADMX "%s", the '
3397                         "the abbreviated language code will be tried.",
3398                         language,
3399                         t_admx_file,
3400                     )
3401                     adml_file = os.path.join(
3402                         root, language.split("-")[0], admx_file_name + ".adml"
3403                     )
3404                     if not __salt__["file.file_exists"](adml_file):
3405                         log.info(
3406                             "An ADML file in the specified ADML language "
3407                             'code %s does not exist for the ADMX "%s", '
3408                             "the fallback language will be tried.",
3409                             language[:2],
3410                             t_admx_file,
3411                         )
3412                         adml_file = os.path.join(
3413                             root, display_language_fallback, admx_file_name + ".adml"
3414                         )
3415                         if not __salt__["file.file_exists"](adml_file):
3416                             log.info(
3417                                 "An ADML file in the specified ADML "
3418                                 'fallback language "%s" '
3419                                 'does not exist for the ADMX "%s" '
3420                                 "the abbreviated fallback language code "
3421                                 "will be tried.",
3422                                 display_language_fallback,
3423                                 t_admx_file,
3424                             )
3425                             adml_file = os.path.join(
3426                                 root,
3427                                 display_language_fallback.split("-")[0],
3428                                 admx_file_name + ".adml",
3429                             )
3430                             if not __salt__["file.file_exists"](adml_file):
3431                                 raise SaltInvocationError(
3432                                     "An ADML file in the specified ADML language "
3433                                     '"{}" and the fallback language "{}" do not '
3434                                     'exist for the ADMX "{}".'.format(
3435                                         language, display_language_fallback, t_admx_file
3436                                     )
3437                                 )
3438                 try:
3439                     xml_tree = _parse_xml(adml_file)
3440                 except lxml.etree.XMLSyntaxError:
3441                     log.error(
3442                         "An error was found while processing adml "
3443                         "file %s, all policies from this file will "
3444                         "be unavailable via this module",
3445                         adml_file,
3446                     )
3447                     continue
3448                 if None in namespaces:
3449                     namespaces["None"] = namespaces[None]
3450                     namespaces.pop(None)
3451                 policydefs_resources = policydefs_resources_localname_xpath(xml_tree)
3452                 for policydefs_resource in policydefs_resources:
3453                     t_poldef = policydefs_resource
3454                     t_poldef = _updateNamespace(t_poldef, this_namespace)
3455                     policydef_resources_xpath(t_policy_definition_resources)[0].append(
3456                         t_poldef
3457                     )
3458     __context__["lgpo.policy_definitions"] = t_policy_definitions
3459     __context__["lgpo.policy_resources"] = t_policy_definition_resources
3460 def _get_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
3461     if "lgpo.policy_definitions" not in __context__:
3462         log.debug("LGPO: Loading policy definitions")
3463         _load_policy_definitions(path=path, language=language)
3464     return __context__["lgpo.policy_definitions"]
3465 def _get_policy_resources(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
3466     if "lgpo.policy_resources" not in __context__:
3467         log.debug("LGPO: Loading policy resources")
3468         _load_policy_definitions(path=path, language=language)
3469     return __context__["lgpo.policy_resources"]
3470 def _buildElementNsmap(using_elements):
3471     thisMap = {}
3472     for e in using_elements:
3473         thisMap[e.attrib["prefix"]] = e.attrib["namespace"]
3474     return thisMap
3475 def _get_advaudit_defaults(option=None):
3476     if "lgpo.audit_defaults" not in __context__:
3477         log.debug("Loading auditpol defaults into __context__")
3478         dump = __utils__["auditpol.get_auditpol_dump"]()
3479         reader = csv.DictReader(dump)
3480         audit_defaults = {"fieldnames": reader.fieldnames}
3481         for row in reader:
3482             row["Machine Name"] = ""
3483             row["Auditpol Name"] = row["Subcategory"]
3484             if row["Subcategory"] == "Central Policy Staging":
3485                 row["Subcategory"] = "Audit Central Access Policy Staging"
3486             elif row["Subcategory"] == "Plug and Play Events":
3487                 row["Subcategory"] = "Audit PNP Activity"
3488             elif row["Subcategory"] == "Token Right Adjusted Events":
3489                 row["Subcategory"] = "Audit Token Right Adjusted"
3490             else:
3491                 row["Subcategory"] = "Audit {}".format(row["Subcategory"])
3492             audit_defaults[row["Subcategory"]] = row
3493         __context__["lgpo.audit_defaults"] = audit_defaults
3494     if option:
3495         return __context__["lgpo.audit_defaults"][option]
3496     else:
3497         return __context__["lgpo.audit_defaults"]
3498 def _advaudit_check_csv():
3499     system_root <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= os.environ.get("SystemRoot", "C:\\Windows")
3500     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
3501     f_audit_gpo = os.path.join(</b></font>
3502         system_root,
3503         "System32",
3504         "GroupPolicy",
3505         "Machine",
3506         "Microsoft",
3507         "Windows NT",
3508         "Audit",
3509         "audit.csv",
3510     )
3511     if not __salt__["file.file_exists"](f_audit):
3512         if __salt__["file.file_exists"](f_audit_gpo):
3513             __salt__["file.copy"](f_audit_gpo, f_audit)
3514         else:
3515             field_names = _get_advaudit_defaults("fieldnames")
3516             __salt__["file.makedirs"](f_audit)
3517             __salt__["file.write"](f_audit, ",".join(field_names))
3518 def _get_advaudit_value(option, refresh=False):
3519     if "lgpo.adv_audit_data" not in __context__ or refresh is True:
3520         system_root = os.environ.get("SystemRoot", "C:\\Windows")
3521         f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
3522         _advaudit_check_csv()
3523         audit_settings = {}
3524         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
3525             reader = csv.DictReader(csv_file)
3526             for row in reader:
3527                 audit_settings.update({row["Subcategory"]: row["Setting Value"]})
3528         __context__["lgpo.adv_audit_data"] = audit_settings
3529     return __context__["lgpo.adv_audit_data"].get(option, None)
3530 def _set_advaudit_file_data(option, value):
3531     system_root = os.environ.get("SystemRoot", "C:\\Windows")
3532     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
3533     f_audit_gpo = os.path.join(
3534         system_root,
3535         "System32",
3536         "GroupPolicy",
3537         "Machine",
3538         "Microsoft",
3539         "Windows NT",
3540         "Audit",
3541         "audit.csv",
3542     )
3543     f_temp = tempfile.NamedTemporaryFile(
3544         mode="w", delete=False, suffix=".csv", prefix="audit"
3545     )
3546     auditpol_values = {
3547         "None": "No Auditing",
3548         "0": "No Auditing",
3549         "1": "Success",
3550         "2": "Failure",
3551         "3": "Success and Failure",
3552     }
3553     _advaudit_check_csv()
3554     try:
3555         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
3556             reader = csv.DictReader(csv_file)
3557             with salt.utils.files.fopen(f_temp.name, mode="w") as tmp_file:
3558                 writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)
3559                 writer.writeheader()
3560                 value_written = False
3561                 for row in reader:
3562                     if row["Subcategory"] == option:
3563                         if not value == "None":
3564                             row["Inclusion Setting"] = auditpol_values[value]
3565                             row["Setting Value"] = value
3566                             log.trace("LGPO: Setting %s to %s", option, value)
3567                             writer.writerow(row)
3568                         else:
3569                             log.trace("LGPO: Removing %s", option)
3570                         value_written = True
3571                     else:
3572                         writer.writerow(row)
3573                 if not value_written:
3574                     if not value == "None":
3575                         log.trace("LGPO: Setting %s to %s", option, value)
3576                         defaults = _get_advaudit_defaults(option)
3577                         writer.writerow(
3578                             {
3579                                 "Machine Name": defaults["Machine Name"],
3580                                 "Policy Target": defaults["Policy Target"],
3581                                 "Subcategory": defaults["Subcategory"],
3582                                 "Subcategory GUID": defaults["Subcategory GUID"],
3583                                 "Inclusion Setting": auditpol_values[value],
3584                                 "Exclusion Setting": defaults["Exclusion Setting"],
3585                                 "Setting Value": value,
3586                             }
3587                         )
3588                     value_written = True
3589         if value_written:
3590             __salt__["file.copy"](f_temp.name, f_audit, remove_existing=True)
3591             __salt__["file.makedirs"](f_audit_gpo)
3592             __salt__["file.copy"](f_temp.name, f_audit_gpo, remove_existing=True)
3593     finally:
3594         f_temp.close()
3595         __salt__["file.remove"](f_temp.name)
3596     return value_written
3597 def _set_advaudit_pol_data(option, value):
3598     auditpol_values = {
3599         "None": "No Auditing",
3600         "0": "No Auditing",
3601         "1": "Success",
3602         "2": "Failure",
3603         "3": "Success and Failure",
3604     }
3605     defaults = _get_advaudit_defaults(option)
3606     return __utils__["auditpol.set_setting"](
3607         name=defaults["Auditpol Name"], value=auditpol_values[value]
3608     )
3609 def _set_advaudit_value(option, value):
3610     if not _set_advaudit_file_data(option=option, value=value):
3611         raise CommandExecutionError("Failed to set audit.csv option: {}".format(option))
3612     if not _set_advaudit_pol_data(option=option, value=value):
3613         log.error(
3614             "Failed to apply audit setting: %s\n"
3615             "Policy will take effect on next GPO update",
3616             option,
3617         )
3618     if "lgpo.adv_audit_data" not in __context__:
3619         _get_advaudit_value(option)
3620     if value is None:
3621         log.debug("LGPO: Removing Advanced Audit data: %s", option)
3622         __context__["lgpo.adv_audit_data"].pop(option)
3623     else:
3624         log.debug("LGPO: Updating Advanced Audit data: %s: %s", option, value)
3625         __context__["lgpo.adv_audit_data"][option] = value
3626     return True
3627 def _get_netsh_value(profile, option):
3628     if "lgpo.netsh_data" not in __context__:
3629         __context__["lgpo.netsh_data"] = {}
3630     if profile not in __context__["lgpo.netsh_data"]:
3631         log.debug("LGPO: Loading netsh data for %s profile", profile)
3632         settings = salt.utils.win_lgpo_netsh.get_all_settings(
3633             profile=profile, store="lgpo"
3634         )
3635         __context__["lgpo.netsh_data"].update({profile: settings})
3636     log.trace(
3637         "LGPO: netsh returning value: %s",
3638         __context__["lgpo.netsh_data"][profile][option],
3639     )
3640     return __context__["lgpo.netsh_data"][profile][option]
3641 def _set_netsh_value(profile, section, option, value):
3642     if section not in ("firewallpolicy", "settings", "logging", "state"):
3643         raise ValueError("LGPO: Invalid section: {}".format(section))
3644     log.trace(
3645         "LGPO: Setting the following\nProfile: %s\nSection: %s\nOption: %s\nValue: %s",
3646         profile,
3647         section,
3648         option,
3649         value,
3650     )
3651     if section == "firewallpolicy":
3652         salt.utils.win_lgpo_netsh.set_firewall_settings(
3653             profile=profile,
3654             inbound=value if option == "Inbound" else None,
3655             outbound=value if option == "Outbound" else None,
3656             store="lgpo",
3657         )
3658     if section == "settings":
3659         salt.utils.win_lgpo_netsh.set_settings(
3660             profile=profile, setting=option, value=value, store="lgpo"
3661         )
3662     if section == "state":
3663         salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store="lgpo")
3664     if section == "logging":
3665         if option in ("FileName", "MaxFileSize"):
3666             if value == "Not configured":
3667                 value = "notconfigured"
3668         if option.startswith("Log"):
3669             option = option[3:]
3670         salt.utils.win_lgpo_netsh.set_logging_settings(
3671             profile=profile, setting=option, value=value, store="lgpo"
3672         )
3673     log.trace("LGPO: Clearing netsh data for %s profile", profile)
3674     __context__["lgpo.netsh_data"].pop(profile)
3675     return True
3676 def _load_secedit_data():
3677     f_exp = os.path.join(__opts__["cachedir"], "secedit-{}.txt".format(UUID))
3678     try:
3679         __salt__["cmd.run"](["secedit", "/export", "/cfg", f_exp])
3680         with salt.utils.files.fopen(f_exp, encoding="utf-16") as fp:
3681             secedit_data = fp.readlines()
3682         return secedit_data
3683     finally:
3684         if __salt__["file.file_exists"](f_exp):
3685             __salt__["file.remove"](f_exp)
3686 def _get_secedit_data(refresh=False):
3687     if "lgpo.secedit_data" not in __context__ or refresh is True:
3688         log.debug("LGPO: Loading secedit data")
3689         __context__["lgpo.secedit_data"] = _load_secedit_data()
3690     return __context__["lgpo.secedit_data"]
3691 def _get_secedit_value(option):
3692     secedit_data = _get_secedit_data()
3693     for _line in secedit_data:
3694         if _line.startswith(option):
3695             return _line.split("=")[1].strip()
3696     return "Not Defined"
3697 def _write_secedit_data(inf_data):
3698     f_sdb = os.path.join(os.getenv("WINDIR"), "security", "database", "salt.sdb")
3699     f_inf = os.path.join(__opts__["cachedir"], "secedit-{}.inf".format(UUID))
3700     try:
3701         with salt.utils.files.fopen(f_inf, "w", encoding="utf-16") as fp:
3702             fp.write(inf_data)
3703         cmd = ["secedit", "/import", "/db", f_sdb, "/cfg", f_inf]
3704         retcode = __salt__["cmd.retcode"](cmd)
3705         if not retcode == 0:
3706             log.debug("Secedit failed to import template data")
3707             return False
3708         cmd = ["secedit", "/configure", "/db", f_sdb]
3709         retcode = __salt__["cmd.retcode"](cmd)
3710         if not retcode == 0:
3711             log.debug("Secedit failed to apply security database")
3712             return False
3713         __context__.pop("lgpo.secedit_data", None)
3714         return True
3715     finally:
3716         if __salt__["file.file_exists"](f_inf):
3717             __salt__["file.remove"](f_inf)
3718 def _transform_value(value, policy, transform_type):
3719     t_kwargs = {}
3720     if "Transform" in policy:
3721         if transform_type in policy["Transform"]:
3722             _policydata = _policy_info()
3723             if transform_type + "Args" in policy["Transform"]:
3724                 t_kwargs = policy["Transform"][transform_type + "Args"]
3725             return getattr(_policydata, policy["Transform"][transform_type])(
3726                 value, **t_kwargs
3727             )
3728         else:
3729             return value
3730     else:
3731         if "Registry" in policy:
3732             if value == "(value not set)":
3733                 return "Not Defined"
3734         return value
3735 def _validateSetting(value, policy):
3736     log.debug("validating %s for policy %s", value, policy)
3737     if "Settings" in policy:
3738         if policy["Settings"]:
3739             if isinstance(policy["Settings"], list):
3740                 if value not in policy["Settings"]:
3741                     return False
3742             elif isinstance(policy["Settings"], dict):
3743                 _policydata = _policy_info()
3744                 if not getattr(_policydata, policy["Settings"]["Function"])(
3745                     value, **policy["Settings"]["Args"]
3746                 ):
3747                     return False
3748     else:
3749         return True
3750     return True
3751 def _addAccountRights(sidObject, user_right):
3752     try:
3753         if sidObject:
3754             _polHandle = win32security.LsaOpenPolicy(
3755                 None, win32security.POLICY_ALL_ACCESS
3756             )
3757             user_rights_list = [user_right]
3758             _ret = win32security.LsaAddAccountRights(
3759                 _polHandle, sidObject, user_rights_list
3760             )
3761         return True
3762     except Exception as e:  # pylint: disable=broad-except
3763         log.exception("Error attempting to add account right, exception was %s", e)
3764         return False
3765 def _delAccountRights(sidObject, user_right):
3766     try:
3767         _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
3768         user_rights_list = [user_right]
3769         _ret = win32security.LsaRemoveAccountRights(
3770             _polHandle, sidObject, False, user_rights_list
3771         )
3772         return True
3773     except Exception as e:  # pylint: disable=broad-except
3774         log.exception("Error attempting to delete account right")
3775         return False
3776 def _getRightsAssignments(user_right):
3777     sids = []
3778     polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
3779     sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)
3780     return sids
3781 def _getAdmlDisplayName(adml_xml_data, display_name):
3782     if display_name.startswith("$(") and display_name.endswith(")"):
3783         display_name = re.sub(r"(^\$\(|\)$)", "", display_name)
3784         display_name = display_name.split(".")
3785         displayname_type = display_name[0]
3786         displayname_id = display_name[1]
3787         search_results = ADML_DISPLAY_NAME_XPATH(
3788             adml_xml_data,
3789             displayNameType=displayname_type,
3790             displayNameId=displayname_id,
3791         )
3792         if search_results:
3793             for result in search_results:
3794                 return result.text.strip()
3795     return None
3796 def _getAdmlPresentationRefId(adml_data, ref_id):
3797     search_results = adml_data.xpath(
3798         '//*[@*[local-name() = "refId"] = "{}"]'.format(ref_id)
3799     )
3800     alternate_label = ""
3801     if search_results:
3802         for result in search_results:
3803             the_localname = etree.QName(result.tag).localname
3804             if result.text is None:
3805                 presentation_element = PRESENTATION_ANCESTOR_XPATH(result)
3806                 if presentation_element:
3807                     presentation_element = presentation_element[0]
3808                     if TEXT_ELEMENT_XPATH(presentation_element):
3809                         for p_item in presentation_element:
3810                             if p_item == result:
3811                                 break
3812                             if etree.QName(p_item.tag).localname == "text":
3813                                 if getattr(p_item, "text"):
3814                                     alternate_label = getattr(p_item, "text").rstrip()
3815                         if alternate_label.endswith("."):
3816                             alternate_label = ""
3817             if the_localname in ["textBox", "comboBox"]:
3818                 label_items = result.xpath('.//*[local-name() = "label"]')
3819                 for label_item in label_items:
3820                     if label_item.text:
3821                         return label_item.text.rstrip().rstrip(":")
3822             elif the_localname in [
3823                 "decimalTextBox",
3824                 "longDecimalTextBox",
3825                 "dropdownList",
3826                 "listBox",
3827                 "checkBox",
3828                 "text",
3829                 "multiTextBox",
3830             ]:
3831                 if result.text:
3832                     return result.text.rstrip().rstrip(":")
3833                 else:
3834                     return alternate_label.rstrip(":")
3835     return None
3836 def _getFullPolicyName(
3837     policy_item, policy_name, return_full_policy_names, adml_language
3838 ):
3839     if policy_name in adm_policy_name_map[return_full_policy_names]:
3840         return adm_policy_name_map[return_full_policy_names][policy_name]
3841     adml_data = _get_policy_resources(language=adml_language)
3842     if return_full_policy_names and "displayName" in policy_item.attrib:
3843         fullPolicyName = _getAdmlDisplayName(
3844             adml_data, policy_item.attrib["displayName"]
3845         )
3846         if fullPolicyName:
3847             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
3848             policy_name = fullPolicyName
3849     elif return_full_policy_names and "id" in policy_item.attrib:
3850         fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib["id"])
3851         if fullPolicyName:
3852             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
3853             policy_name = fullPolicyName
3854     policy_name = policy_name.rstrip(":").rstrip()
3855     return policy_name
3856 def _regexSearchRegPolData(search_string, policy_data):
3857     if policy_data:
3858         if search_string:
3859             match = re.search(search_string, policy_data, re.IGNORECASE)
3860             if match:
3861                 return True
3862     return False
3863 def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):
3864     value = None
3865     values = []
3866     encoded_semicolon = ";".encode("utf-16-le")
3867     if return_value_name:
3868         values = {}
3869     if search_string:
3870         registry = Registry()
3871         if len(search_string.split(encoded_semicolon)) &gt;= 3:
3872             vtype = registry.vtype_reverse[
3873                 ord(search_string.split(encoded_semicolon)[2].decode("utf-32-le"))
3874             ]
3875         else:
3876             vtype = None
3877         search_string = re.escape(search_string)
3878         matches = re.finditer(search_string, policy_data, re.IGNORECASE)
3879 <a name="9"></a>        matches = [m for m in matches]
3880         if matches:
3881             for match in matches:
3882                 pol_entry = policy_data<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[
3883                     match.start() : (
3884                         policy_data.index("]".encode("utf-16-le"), match.end())
3885                     )
3886                 ].split(</b></font>encoded_semicolon, 4)
3887                 if len(pol_entry) &gt;= 2:
3888                     valueName = pol_entry[1].decode("utf-16-le").rstrip(chr(0))
3889                 if len(pol_entry) &gt;= 5:
3890                     value = encoded_semicolon.join(pol_entry[4:])
3891                     if vtype == "REG_DWORD" or vtype == "REG_QWORD":
3892                         if value:
3893                             if vtype == "REG_DWORD":
3894                                 for v in struct.unpack(b"I", value):
3895                                     value = v
3896                             elif vtype == "REG_QWORD":
3897                                 for v in struct.unpack(b"Q", value):
3898                                     value = v
3899                         else:
3900                             value = 0
3901                     elif vtype == "REG_MULTI_SZ":
3902                         value = value.decode("utf-16-le").rstrip(chr(0)).split(chr(0))
3903                     else:
3904                         value = value.decode("utf-16-le").rstrip(chr(0))
3905                 if return_value_name:
3906                     log.trace("we want value names and the value")
3907                     values[valueName] = value
3908                 elif len(matches) &gt; 1:
3909                     log.trace("we have multiple matches, we will return a list")
3910                     values.append(value)
3911     if values:
3912         value = values
3913     return value
3914 def _checkListItem(
3915     policy_element,
3916     policy_name,
3917     policy_key,
3918     xpath_object,
3919     policy_file_data,
3920     test_items=True,
3921 ):
3922     xpath_string = (
3923         './/*[local-name() = "decimal" or local-name() = "delete"'
3924         ' or local-name() = "longDecimal" or local-name() = "string"]'
3925     )
3926     value_item_child_xpath = etree.XPath(xpath_string)
3927     expected_strings = []
3928     for list_element in xpath_object(policy_element):
3929         configured_items = 0
3930         required_items = 0
3931         for item in list_element:
3932             required_items = required_items + 1
3933             if "key" in item.attrib:
3934                 item_key = item.attrib["key"]
3935             else:
3936                 item_key = policy_key
3937             if "valueName" in item.attrib:
3938                 item_valuename = item.attrib["valueName"]
3939             else:
3940                 log.error(
3941                     "%s item with attributes %s in policy %s does not "
3942                     'have the required "valueName" attribute',
3943                     etree.QName(list_element).localname,
3944                     item.attrib,
3945                     policy_element.attrib,
3946                 )
3947                 break
3948             for value_item in value_item_child_xpath(item):
3949                 search_string = _processValueItem(
3950                     value_item, item_key, item_valuename, policy_element, item
3951                 )
3952                 if test_items:
3953                     if _regexSearchRegPolData(
3954                         re.escape(search_string), policy_file_data
3955                     ):
3956                         configured_items = configured_items + 1
3957                         log.trace(
3958                             "found the search string in the pol file,"
3959                             "%s of %s items for policy %s are "
3960                             "configured in registry.pol",
3961                             configured_items,
3962                             required_items,
3963                             policy_name,
3964                         )
3965                 else:
3966                     expected_strings.append(search_string)
3967         if test_items:
3968             if required_items &gt; 0 and required_items == configured_items:
3969                 log.trace("%s all items are set", policy_name)
3970                 return True
3971     if test_items:
3972         return False
3973     else:
3974         return expected_strings
3975 def _checkValueItemParent(
3976     policy_element,
3977     policy_name,
3978     policy_key,
3979     policy_valueName,
3980     xpath_object,
3981     policy_file_data,
3982     check_deleted=False,
3983     test_item=True,
3984 ):
3985     for element in xpath_object(policy_element):
3986         for value_item in element:
3987             search_string = _processValueItem(
3988                 value_item,
3989                 policy_key,
3990                 policy_valueName,
3991                 policy_element,
3992                 element,
3993                 check_deleted=check_deleted,
3994             )
3995             if not test_item:
3996                 return search_string
3997             if _regexSearchRegPolData(re.escape(search_string), policy_file_data):
3998                 log.trace(
3999                     "found the search string in the pol file, %s is configured",
4000                     policy_name,
4001                 )
4002                 return True
4003     return False
4004 def _encode_string(value):
4005     encoded_null = chr(0).encode("utf-16-le")
4006     if value is None:
4007         return encoded_null
4008     elif not isinstance(value, str):
4009         raise TypeError(
4010             "Value {} is not a string type\nType: {}".format(repr(value), type(value))
4011         )
4012     return b"".join([value.encode("utf-16-le"), encoded_null])
4013 def _buildKnownDataSearchString(
4014     reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False
4015 ):
4016     registry = Registry()
4017     this_element_value = None
4018     expected_string = b""
4019     encoded_semicolon = ";".encode("utf-16-le")
4020     encoded_null = chr(0).encode("utf-16-le")
4021     if reg_key:
4022         reg_key = reg_key.encode("utf-16-le")
4023     if reg_valueName:
4024         reg_valueName = reg_valueName.encode("utf-16-le")
4025     if reg_data and not check_deleted:
4026         if reg_vtype == "REG_DWORD":
4027             this_element_value = struct.pack(b"I", int(reg_data))
4028         elif reg_vtype == "REG_QWORD":
4029             this_element_value = struct.pack(b"Q", int(reg_data))
4030         elif reg_vtype == "REG_SZ":
4031             this_element_value = _encode_string(reg_data)
4032     if check_deleted:
4033         reg_vtype = "REG_SZ"
4034         expected_string = b"".join(
4035             [
4036                 "[".encode("utf-16-le"),
4037 <a name="6"></a>                reg_key,
4038                 encoded_null,
4039                 encoded_semicolon,
4040                 "**del.".encode<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("utf-16-le"),
4041                 reg_valueName,
4042                 encoded_null,
4043                 encoded_semicolon,
4044                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
4045                 encoded_semicolon,
4046                 chr(len(" {}".format(chr(0)).</b></font>encode("utf-16-le"))).encode("utf-32-le"),
4047                 encoded_semicolon,
4048                 " ".encode("utf-16-le"),
4049                 encoded_null,
4050                 "]".encode("utf-16-le"),
4051             ]
4052         )
4053     else:
4054         expected_string = b"".join(
4055             [
4056                 "[".encode("utf-16-le"),
4057                 reg_key,
4058                 encoded_null,
4059                 encoded_semicolon,
4060                 reg_valueName,
4061                 encoded_null,
4062                 encoded_semicolon,
4063                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
4064                 encoded_semicolon,
4065                 chr(len(this_element_value)).encode("utf-32-le"),
4066                 encoded_semicolon,
4067                 this_element_value,
4068                 "]".encode("utf-16-le"),
4069             ]
4070         )
4071     return expected_string
4072 def _processValueItem(
4073     element,
4074     reg_key,
4075     reg_valuename,
4076     policy,
4077     parent_element,
4078     check_deleted=False,
4079     this_element_value=None,
4080 ):
4081     registry = Registry()
4082     expected_string = None
4083     this_vtype = "REG_SZ"
4084     encoded_semicolon = ";".encode("utf-16-le")
4085     encoded_null = chr(0).encode("utf-16-le")
4086     if reg_key:
4087         reg_key = reg_key.encode("utf-16-le")
4088     if reg_valuename:
4089         reg_valuename = reg_valuename.encode("utf-16-le")
4090     if (
4091         etree.QName(element).localname == "decimal"
4092         and etree.QName(parent_element).localname != "elements"
4093     ):
4094         this_vtype = "REG_DWORD"
4095         if "value" in element.attrib:
4096             this_element_value = struct.pack(b"I", int(element.attrib["value"]))
4097         else:
4098             log.error(
4099                 "The %s child %s element for the policy with "
4100                 'attributes: %s does not have the required "value" '
4101                 "attribute. The element attributes are: %s",
4102                 etree.QName(parent_element).localname,
4103                 etree.QName(element).localname,
4104                 policy.attrib,
4105                 element.attrib,
4106             )
4107             return None
4108     elif (
4109         etree.QName(element).localname == "longDecimal"
4110         and etree.QName(parent_element).localname != "elements"
4111     ):
4112         this_vtype = "REG_QWORD"
4113         if "value" in element.attrib:
4114             this_element_value = struct.pack(b"Q", int(element.attrib["value"]))
4115         else:
4116             log.error(
4117                 "The %s child %s element for the policy with "
4118                 'attributes: %s does not have the required "value" '
4119                 "attribute. The element attributes are: %s",
4120                 etree.QName(parent_element).localname,
4121                 etree.QName(element).localname,
4122                 policy.attrib,
4123                 element.attrib,
4124             )
4125             return None
4126     elif etree.QName(element).localname == "string":
4127         this_vtype = "REG_SZ"
4128         this_element_value = _encode_string(element.text)
4129     elif etree.QName(parent_element).localname == "elements":
4130         standard_element_expected_string = True
4131         if etree.QName(element).localname == "boolean":
4132             if this_element_value is False:
4133                 check_deleted = True
4134             if not check_deleted:
4135                 this_vtype = "REG_DWORD"
4136             this_element_value = struct.pack("I", 1)
4137             standard_element_expected_string = False
4138         elif etree.QName(element).localname == "decimal":
4139             this_vtype = "REG_DWORD"
4140             requested_val = this_element_value
4141             if this_element_value is not None:
4142                 this_element_value = struct.pack(b"I", int(this_element_value))
4143             if "storeAsText" in element.attrib:
4144                 if element.attrib["storeAsText"].lower() == "true":
4145                     this_vtype = "REG_SZ"
4146                     if requested_val is not None:
4147                         this_element_value = str(requested_val).encode("utf-16-le")
4148             if check_deleted:
4149                 this_vtype = "REG_SZ"
4150         elif etree.QName(element).localname == "longDecimal":
4151             this_vtype = "REG_QWORD"
4152             requested_val = this_element_value
4153             if this_element_value is not None:
4154                 this_element_value = struct.pack(b"Q", int(this_element_value))
4155             if "storeAsText" in element.attrib:
4156                 if element.attrib["storeAsText"].lower() == "true":
4157                     this_vtype = "REG_SZ"
4158                     if requested_val is not None:
4159                         this_element_value = str(requested_val).encode("utf-16-le")
4160         elif etree.QName(element).localname == "text":
4161             this_vtype = "REG_SZ"
4162             if "expandable" in element.attrib:
4163                 if element.attrib["expandable"].lower() == "true":
4164                     this_vtype = "REG_EXPAND_SZ"
4165             if this_element_value is not None:
4166                 this_element_value = _encode_string(this_element_value)
4167         elif etree.QName(element).localname == "multiText":
4168             this_vtype = "REG_MULTI_SZ" if not check_deleted else "REG_SZ"
4169             if this_element_value is not None:
4170                 this_element_value = "{0}{1}{1}".format(
4171                     chr(0).join(this_element_value), chr(0)
4172                 )
4173         elif etree.QName(element).localname == "list":
4174             standard_element_expected_string = False
4175             del_keys = b""
4176             element_valuenames = []
4177             element_values = this_element_value
4178             if this_element_value is not None:
4179                 element_valuenames = [
4180                     str(z) for z in range(1, len(this_element_value) + 1)
4181                 ]
4182             if "additive" in element.attrib:
4183                 if element.attrib["additive"].lower() == "false":
4184                     del_keys = b"".join(
4185                         [
4186                             "[".encode("utf-16-le"),
4187                             reg_key,
4188                             encoded_null,
4189                             encoded_semicolon,
4190                             "**delvals.".encode("utf-16-le"),
4191                             encoded_null,
4192                             encoded_semicolon,
4193                             chr(registry.vtype[this_vtype]).encode("utf-32-le"),
4194                             encoded_semicolon,
4195                             chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
4196                                 "utf-32-le"
4197                             ),
4198                             encoded_semicolon,
4199                             " ".encode("utf-16-le"),
4200                             encoded_null,
4201                             "]".encode("utf-16-le"),
4202                         ]
4203                     )
4204             if "expandable" in element.attrib:
4205                 this_vtype = "REG_EXPAND_SZ"
4206             if element.attrib.get("explicitValue", "false").lower() == "true":
4207                 if this_element_value is not None:
4208                     element_valuenames = [str(k) for k in this_element_value.keys()]
4209                     element_values = [str(v) for v in this_element_value.values()]
4210             elif "valuePrefix" in element.attrib:
4211                 if element.attrib["valuePrefix"] != "":
4212                     if this_element_value is not None:
4213                         element_valuenames = [
4214                             "{}{}".format(element.attrib["valuePrefix"], k)
4215                             for k in element_valuenames
4216                         ]
4217             else:
4218                 if element_values is not None:
4219                     element_valuenames = [str(z) for z in element_values]
4220             if not check_deleted:
4221                 if this_element_value is not None:
4222                     log.trace(
4223                         "_processValueItem has an explicit element_value of %s",
4224                         this_element_value,
4225                     )
4226                     expected_string = del_keys
4227                     log.trace(
4228                         "element_valuenames == %s and element_values == %s",
4229                         element_valuenames,
4230                         element_values,
4231                     )
4232                     for i, item in enumerate(element_valuenames):
4233                         expected_string = expected_string + b"".join(
4234                             [
4235                                 "[".encode("utf-16-le"),
4236                                 reg_key,
4237                                 encoded_null,
4238                                 encoded_semicolon,
4239                                 element_valuenames[i].encode("utf-16-le"),
4240                                 encoded_null,
4241                                 encoded_semicolon,
4242                                 chr(registry.vtype[this_vtype]).encode("utf-32-le"),
4243                                 encoded_semicolon,
4244                                 chr(
4245                                     len(
4246                                         "{}{}".format(element_values[i], chr(0)).encode(
4247                                             "utf-16-le"
4248                                         )
4249                                     )
4250                                 ).encode("utf-32-le"),
4251                                 encoded_semicolon,
4252                                 _encode_string(element_values[i]),
4253                                 "]".encode("utf-16-le"),
4254                             ]
4255                         )
4256                 else:
4257                     expected_string = del_keys + b"".join(
4258                         [
4259                             "[".encode("utf-16-le"),
4260                             reg_key,
4261                             encoded_null,
4262                             encoded_semicolon,
4263                         ]
4264                     )
4265             else:
4266                 expected_string = b"".join(
4267                     [
4268                         "[".encode("utf-16-le"),
4269                         reg_key,
4270                         encoded_null,
4271                         encoded_semicolon,
4272                         "**delvals.".encode("utf-16-le"),
4273                         encoded_null,
4274                         encoded_semicolon,
4275                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
4276                         encoded_semicolon,
4277                         chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
4278                             "utf-32-le"
4279                         ),
4280                         encoded_semicolon,
4281                         " ".encode("utf-16-le"),
4282                         encoded_null,
4283                         "]".encode("utf-16-le"),
4284                     ]
4285                 )
4286         elif etree.QName(element).localname == "enum":
4287             if this_element_value is not None:
4288                 pass
4289         if standard_element_expected_string and not check_deleted:
4290             if this_element_value is not None:
4291                 if isinstance(this_element_value, str):
4292                     log.debug("Converting %s to bytes", this_element_value)
4293                     this_element_value = this_element_value.encode("utf-32-le")
4294                 expected_string = b"".join(
4295                     [
4296                         "[".encode("utf-16-le"),
4297                         reg_key,
4298                         encoded_null,
4299                         encoded_semicolon,
4300                         reg_valuename,
4301                         encoded_null,
4302                         encoded_semicolon,
4303                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
4304                         encoded_semicolon,
4305                         chr(len(this_element_value)).encode("utf-32-le"),
4306                         encoded_semicolon,
4307                         this_element_value,
4308                         "]".encode("utf-16-le"),
4309                     ]
4310                 )
4311             else:
4312                 expected_string = b"".join(
4313                     [
4314                         "[".encode("utf-16-le"),
4315                         reg_key,
4316                         encoded_null,
4317                         encoded_semicolon,
4318                         reg_valuename,
4319                         encoded_null,
4320                         encoded_semicolon,
4321                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
4322                         encoded_semicolon,
4323                     ]
4324                 )
4325     if not expected_string:
4326         if etree.QName(element).localname == "delete" or check_deleted:
4327             expected_string = b"".join(
4328                 [
4329                     "[".encode("utf-16-le"),
4330                     reg_key,
4331                     encoded_null,
4332                     encoded_semicolon,
4333                     "**del.".encode("utf-16-le"),
4334                     reg_valuename,
4335                     encoded_null,
4336                     encoded_semicolon,
4337                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
4338                     encoded_semicolon,
4339                     chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
4340                         "utf-32-le"
4341                     ),
4342                     encoded_semicolon,
4343                     " ".encode("utf-16-le"),
4344                     encoded_null,
4345                     "]".encode("utf-16-le"),
4346                 ]
4347             )
4348         else:
4349             expected_string = b"".join(
4350                 [
4351                     "[".encode("utf-16-le"),
4352                     reg_key,
4353                     encoded_null,
4354                     encoded_semicolon,
4355                     reg_valuename,
4356                     encoded_null,
4357                     encoded_semicolon,
4358                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
4359                     encoded_semicolon,
4360                     chr(len(this_element_value)).encode("utf-32-le"),
4361                     encoded_semicolon,
4362                     this_element_value,
4363                     "]".encode("utf-16-le"),
4364                 ]
4365             )
4366     return expected_string
4367 def _checkAllAdmxPolicies(
4368     policy_class,
4369     adml_language="en-US",
4370     return_full_policy_names=False,
4371     hierarchical_return=False,
4372     return_not_configured=False,
4373 ):
4374     log.trace("POLICY CLASS == %s", policy_class)
4375     module_policy_data = _policy_info()
4376     policy_file_data = _read_regpol_file(
4377         module_policy_data.admx_registry_classes[policy_class]["policy_path"]
4378     )
4379     admx_policies = []
4380     policy_vals = {}
4381     hierarchy = {}
4382     full_names = {}
4383     admx_policy_definitions = _get_policy_definitions(language=adml_language)
4384     adml_policy_resources = _get_policy_resources(language=adml_language)
4385     if policy_file_data:
4386         log.trace("POLICY CLASS %s has file data", policy_class)
4387         policy_filedata_split = re.sub(
4388             salt.utils.stringutils.to_bytes(r"\]{}$".format(chr(0))),
4389             b"",
4390             re.sub(
4391                 salt.utils.stringutils.to_bytes(r"^\[{}".format(chr(0))),
4392                 b"",
4393                 re.sub(
4394                     re.escape(module_policy_data.reg_pol_header.encode("utf-16-le")),
4395                     b"",
4396                     policy_file_data,
4397                 ),
4398             ),
4399         ).split("][".encode("utf-16-le"))
4400         log.trace("Searching %s policies...", len(policy_filedata_split))
4401         start_time = time.time()
4402         for policy_item in policy_filedata_split:
4403             policy_item_key = (
4404                 policy_item.split("{};".format(chr(0)).encode("utf-16-le"))[0]
4405                 .decode("utf-16-le")
4406                 .lower()
4407             )
4408             if policy_item_key:
4409                 admx_items = REGKEY_XPATH(
4410                     admx_policy_definitions, keyvalue=policy_item_key
4411                 )
4412                 log.trace("Found %s policies for %s", len(admx_items), policy_item_key)
4413                 for admx_item in admx_items:
4414                     if etree.QName(admx_item).localname == "policy":
4415                         if admx_item not in admx_policies:
4416                             admx_policies.append(admx_item)
4417                     else:
4418                         for policy_item in POLICY_ANCESTOR_XPATH(admx_item):
4419                             if policy_item not in admx_policies:
4420                                 admx_policies.append(policy_item)
4421         log.trace("Search complete: %s seconds", time.time() - start_time)
4422         if return_not_configured:
4423             log.trace("Gathering non configured policies")
4424             start_time = time.time()
4425             not_configured_policies = ALL_CLASS_POLICY_XPATH(
4426                 admx_policy_definitions, registry_class=policy_class
4427             )
4428             for policy_item in admx_policies:
4429                 if policy_item in not_configured_policies:
4430                     not_configured_policies.remove(policy_item)
4431             for not_configured_policy in not_configured_policies:
4432                 not_configured_policy_namespace = not_configured_policy.nsmap[
4433                     not_configured_policy.prefix
4434                 ]
4435                 if not_configured_policy_namespace not in policy_vals:
4436                     policy_vals[not_configured_policy_namespace] = {}
4437                 policy_vals[not_configured_policy_namespace][
4438                     not_configured_policy.attrib["name"]
4439                 ] = "Not Configured"
4440                 if return_full_policy_names:
4441                     if not_configured_policy_namespace not in full_names:
4442                         full_names[not_configured_policy_namespace] = {}
4443                     full_names[not_configured_policy_namespace][
4444                         not_configured_policy.attrib["name"]
4445                     ] = _getFullPolicyName(
4446                         policy_item=not_configured_policy,
4447                         policy_name=not_configured_policy.attrib["name"],
4448                         return_full_policy_names=return_full_policy_names,
4449                         adml_language=adml_language,
4450                     )
4451                 log.trace(
4452                     "building hierarchy for non-configured item %s",
4453                     not_configured_policy.attrib["name"],
4454                 )
4455                 if not_configured_policy_namespace not in hierarchy:
4456                     hierarchy[not_configured_policy_namespace] = {}
4457                 hierarchy[not_configured_policy_namespace][
4458                     not_configured_policy.attrib["name"]
4459                 ] = _build_parent_list(
4460                     policy_definition=not_configured_policy,
4461                     return_full_policy_names=return_full_policy_names,
4462                     adml_language=adml_language,
4463                 )
4464             log.trace("Gathering complete: %s seconds", time.time() - start_time)
4465         log.trace("Examining %s policies...", len(admx_policies))
4466         start_time = time.time()
4467         for admx_policy in admx_policies:
4468             this_valuename = None
4469             this_policy_setting = "Not Configured"
4470             element_only_enabled_disabled = True
4471             explicit_enable_disable_value_setting = False
4472             if "key" in admx_policy.attrib:
4473                 this_key = admx_policy.attrib["key"]
4474             else:
4475                 log.error(
4476                     'policy item %s does not have the required "key" attribute',
4477                     admx_policy.attrib,
4478                 )
4479                 break
4480             if "valueName" in admx_policy.attrib:
4481                 this_valuename = admx_policy.attrib["valueName"]
4482             if "name" in admx_policy.attrib:
4483                 this_policyname = admx_policy.attrib["name"]
4484             else:
4485                 log.error(
4486                     'policy item %s does not have the required "name" attribute',
4487                     admx_policy.attrib,
4488                 )
4489                 break
4490             this_policynamespace = admx_policy.nsmap[admx_policy.prefix]
4491             if (
4492                 ENABLED_VALUE_XPATH(admx_policy)
4493                 and this_policy_setting == "Not Configured"
4494             ):
4495                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
4496                     admx_policy
4497                 ):
4498                     element_only_enabled_disabled = False
4499                     explicit_enable_disable_value_setting = True
4500                 if _checkValueItemParent(
4501                     admx_policy,
4502                     this_policyname,
4503                     this_key,
4504                     this_valuename,
4505                     ENABLED_VALUE_XPATH,
4506                     policy_file_data,
4507                 ):
4508                     this_policy_setting = "Enabled"
4509                     log.trace(
4510                         "%s is enabled by detected ENABLED_VALUE_XPATH", this_policyname
4511                     )
4512                     if this_policynamespace not in policy_vals:
4513                         policy_vals[this_policynamespace] = {}
4514                     policy_vals[this_policynamespace][
4515                         this_policyname
4516                     ] = this_policy_setting
4517             if (
4518                 DISABLED_VALUE_XPATH(admx_policy)
4519                 and this_policy_setting == "Not Configured"
4520             ):
4521                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
4522                     element_only_enabled_disabled = False
4523                     explicit_enable_disable_value_setting = True
4524                 if _checkValueItemParent(
4525                     admx_policy,
4526                     this_policyname,
4527                     this_key,
4528                     this_valuename,
4529                     DISABLED_VALUE_XPATH,
4530                     policy_file_data,
4531                 ):
4532                     this_policy_setting = "Disabled"
4533                     log.trace(
4534                         "%s is disabled by detected DISABLED_VALUE_XPATH",
4535                         this_policyname,
4536                     )
4537                     if this_policynamespace not in policy_vals:
4538                         policy_vals[this_policynamespace] = {}
4539                     policy_vals[this_policynamespace][
4540                         this_policyname
4541                     ] = this_policy_setting
4542             if (
4543                 ENABLED_LIST_XPATH(admx_policy)
4544                 and this_policy_setting == "Not Configured"
4545             ):
4546                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
4547                     admx_policy
4548                 ):
4549                     element_only_enabled_disabled = False
4550                     explicit_enable_disable_value_setting = True
4551                 if _checkListItem(
4552                     admx_policy,
4553                     this_policyname,
4554                     this_key,
4555                     ENABLED_LIST_XPATH,
4556                     policy_file_data,
4557                 ):
4558                     this_policy_setting = "Enabled"
4559                     log.trace(
4560                         "%s is enabled by detected ENABLED_LIST_XPATH", this_policyname
4561                     )
4562                     if this_policynamespace not in policy_vals:
4563                         policy_vals[this_policynamespace] = {}
4564                     policy_vals[this_policynamespace][
4565                         this_policyname
4566                     ] = this_policy_setting
4567             if (
4568                 DISABLED_LIST_XPATH(admx_policy)
4569                 and this_policy_setting == "Not Configured"
4570             ):
4571                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
4572                     element_only_enabled_disabled = False
4573                     explicit_enable_disable_value_setting = True
4574                 if _checkListItem(
4575                     admx_policy,
4576                     this_policyname,
4577                     this_key,
4578                     DISABLED_LIST_XPATH,
4579                     policy_file_data,
4580                 ):
4581                     this_policy_setting = "Disabled"
4582                     log.trace(
4583                         "%s is disabled by detected DISABLED_LIST_XPATH",
4584                         this_policyname,
4585                     )
4586                     if this_policynamespace not in policy_vals:
4587                         policy_vals[this_policynamespace] = {}
4588                     policy_vals[this_policynamespace][
4589                         this_policyname
4590                     ] = this_policy_setting
4591             if not explicit_enable_disable_value_setting and this_valuename:
4592                 if _regexSearchRegPolData(
4593                     re.escape(
4594                         _buildKnownDataSearchString(
4595                             this_key, this_valuename, "REG_DWORD", "1"
4596                         )
4597                     ),
4598                     policy_file_data,
4599                 ):
4600                     this_policy_setting = "Enabled"
4601                     log.trace(
4602                         "%s is enabled by no explicit enable/disable list or value",
4603                         this_policyname,
4604                     )
4605                     if this_policynamespace not in policy_vals:
4606                         policy_vals[this_policynamespace] = {}
4607                     policy_vals[this_policynamespace][
4608                         this_policyname
4609                     ] = this_policy_setting
4610                 elif _regexSearchRegPolData(
4611                     re.escape(
4612                         _buildKnownDataSearchString(
4613                             this_key,
4614                             this_valuename,
4615                             "REG_DWORD",
4616                             None,
4617                             check_deleted=True,
4618                         )
4619                     ),
4620                     policy_file_data,
4621                 ):
4622                     this_policy_setting = "Disabled"
4623                     log.trace(
4624                         "%s is disabled by no explicit enable/disable list or value",
4625                         this_policyname,
4626                     )
4627                     if this_policynamespace not in policy_vals:
4628                         policy_vals[this_policynamespace] = {}
4629                     policy_vals[this_policynamespace][
4630                         this_policyname
4631                     ] = this_policy_setting
4632             if ELEMENTS_XPATH(admx_policy):
4633                 if element_only_enabled_disabled or this_policy_setting == "Enabled":
4634                     required_elements = {}
4635                     configured_elements = {}
4636                     policy_disabled_elements = 0
4637                     for elements_item in ELEMENTS_XPATH(admx_policy):
4638                         for child_item in elements_item:
4639                             this_element_name = _getFullPolicyName(
4640                                 policy_item=child_item,
4641                                 policy_name=child_item.attrib["id"],
4642                                 return_full_policy_names=return_full_policy_names,
4643                                 adml_language=adml_language,
4644                             )
4645                             required_elements[this_element_name] = None
4646                             child_key = child_item.attrib.get("key", this_key)
4647                             child_valuename = child_item.attrib.get(
4648                                 "valueName", this_valuename
4649                             )
4650                             if etree.QName(child_item).localname == "boolean":
4651                                 if child_item is not None:
4652                                     if (
4653                                         TRUE_VALUE_XPATH(child_item)
4654                                         and this_element_name not in configured_elements
4655                                     ):
4656                                         if _checkValueItemParent(
4657                                             child_item,
4658                                             this_policyname,
4659                                             child_key,
4660                                             child_valuename,
4661                                             TRUE_VALUE_XPATH,
4662                                             policy_file_data,
4663                                         ):
4664                                             configured_elements[
4665                                                 this_element_name
4666                                             ] = True
4667                                             log.trace(
4668                                                 "element %s is configured true",
4669                                                 child_item.attrib["id"],
4670                                             )
4671                                     if (
4672                                         FALSE_VALUE_XPATH(child_item)
4673                                         and this_element_name not in configured_elements
4674                                     ):
4675                                         if _checkValueItemParent(
4676                                             child_item,
4677                                             this_policyname,
4678                                             child_key,
4679                                             child_valuename,
4680                                             FALSE_VALUE_XPATH,
4681                                             policy_file_data,
4682                                         ):
4683                                             configured_elements[
4684                                                 this_element_name
4685                                             ] = False
4686                                             policy_disabled_elements = (
4687                                                 policy_disabled_elements + 1
4688                                             )
4689                                             log.trace(
4690                                                 "element %s is configured false",
4691                                                 child_item.attrib["id"],
4692                                             )
4693                                     if (
4694                                         TRUE_LIST_XPATH(child_item)
4695                                         and this_element_name not in configured_elements
4696                                     ):
4697                                         log.trace("checking trueList")
4698                                         if _checkListItem(
4699                                             child_item,
4700                                             this_policyname,
4701                                             this_key,
4702                                             TRUE_LIST_XPATH,
4703                                             policy_file_data,
4704                                         ):
4705                                             configured_elements[
4706                                                 this_element_name
4707                                             ] = True
4708                                             log.trace(
4709                                                 "element %s is configured true",
4710                                                 child_item.attrib["id"],
4711                                             )
4712                                     if (
4713                                         FALSE_LIST_XPATH(child_item)
4714                                         and this_element_name not in configured_elements
4715                                     ):
4716                                         log.trace("checking falseList")
4717                                         if _checkListItem(
4718                                             child_item,
4719                                             this_policyname,
4720                                             this_key,
4721                                             FALSE_LIST_XPATH,
4722                                             policy_file_data,
4723                                         ):
4724                                             configured_elements[
4725                                                 this_element_name
4726                                             ] = False
4727                                             policy_disabled_elements = (
4728                                                 policy_disabled_elements + 1
4729                                             )
4730                                             log.trace(
4731                                                 "element %s is configured false",
4732                                                 child_item.attrib["id"],
4733                                             )
4734                                 else:
4735                                     if _regexSearchRegPolData(
4736                                         re.escape(
4737                                             _processValueItem(
4738                                                 child_item,
4739                                                 child_key,
4740                                                 child_valuename,
4741                                                 admx_policy,
4742                                                 elements_item,
4743                                                 check_deleted=True,
4744                                             )
4745                                         ),
4746                                         policy_file_data,
4747                                     ):
4748                                         configured_elements[this_element_name] = False
4749                                         policy_disabled_elements = (
4750                                             policy_disabled_elements + 1
4751                                         )
4752                                         log.trace(
4753                                             "element %s is configured false",
4754                                             child_item.attrib["id"],
4755                                         )
4756                                     elif _regexSearchRegPolData(
4757                                         re.escape(
4758                                             _processValueItem(
4759                                                 child_item,
4760                                                 child_key,
4761                                                 child_valuename,
4762                                                 admx_policy,
4763                                                 elements_item,
4764                                                 check_deleted=False,
4765                                             )
4766                                         ),
4767                                         policy_file_data,
4768                                     ):
4769                                         configured_elements[this_element_name] = True
4770                                         log.trace(
4771                                             "element %s is configured true",
4772                                             child_item.attrib["id"],
4773                                         )
4774                             elif (
4775                                 etree.QName(child_item).localname == "decimal"
4776                                 or etree.QName(child_item).localname == "text"
4777                                 or etree.QName(child_item).localname == "longDecimal"
4778                                 or etree.QName(child_item).localname == "multiText"
4779                             ):
4780                                 if _regexSearchRegPolData(
4781                                     re.escape(
4782                                         _processValueItem(
4783                                             child_item,
4784                                             child_key,
4785                                             child_valuename,
4786                                             admx_policy,
4787                                             elements_item,
4788                                             check_deleted=True,
4789                                         )
4790                                     ),
4791                                     policy_file_data,
4792                                 ):
4793                                     configured_elements[this_element_name] = "Disabled"
4794                                     policy_disabled_elements = (
4795                                         policy_disabled_elements + 1
4796                                     )
4797                                     log.trace(
4798                                         "element %s is disabled",
4799                                         child_item.attrib["id"],
4800                                     )
4801                                 elif _regexSearchRegPolData(
4802                                     re.escape(
4803                                         _processValueItem(
4804                                             child_item,
4805                                             child_key,
4806                                             child_valuename,
4807                                             admx_policy,
4808                                             elements_item,
4809                                             check_deleted=False,
4810                                         )
4811                                     ),
4812                                     policy_file_data,
4813                                 ):
4814                                     configured_value = _getDataFromRegPolData(
4815                                         _processValueItem(
4816                                             child_item,
4817                                             child_key,
4818                                             child_valuename,
4819                                             admx_policy,
4820                                             elements_item,
4821                                             check_deleted=False,
4822                                         ),
4823                                         policy_file_data,
4824                                     )
4825                                     configured_elements[
4826                                         this_element_name
4827                                     ] = configured_value
4828                                     log.trace(
4829                                         "element %s is enabled, value == %s",
4830                                         child_item.attrib["id"],
4831                                         configured_value,
4832                                     )
4833                             elif etree.QName(child_item).localname == "enum":
4834                                 if _regexSearchRegPolData(
4835                                     re.escape(
4836                                         _processValueItem(
4837                                             child_item,
4838                                             child_key,
4839                                             child_valuename,
4840                                             admx_policy,
4841                                             elements_item,
4842                                             check_deleted=True,
4843                                         )
4844                                     ),
4845                                     policy_file_data,
4846                                 ):
4847                                     log.trace(
4848                                         "enum element %s is disabled",
4849                                         child_item.attrib["id"],
4850                                     )
4851                                     configured_elements[this_element_name] = "Disabled"
4852                                     policy_disabled_elements = (
4853                                         policy_disabled_elements + 1
4854                                     )
4855                                 else:
4856                                     for enum_item in child_item:
4857                                         if _checkValueItemParent(
4858                                             enum_item,
4859                                             child_item.attrib["id"],
4860                                             child_key,
4861                                             child_valuename,
4862                                             VALUE_XPATH,
4863                                             policy_file_data,
4864                                         ):
4865                                             if VALUE_LIST_XPATH(enum_item):
4866                                                 log.trace("enum item has a valueList")
4867                                                 if _checkListItem(
4868                                                     enum_item,
4869                                                     this_policyname,
4870                                                     child_key,
4871                                                     VALUE_LIST_XPATH,
4872                                                     policy_file_data,
4873                                                 ):
4874                                                     log.trace(
4875                                                         "all valueList items exist in"
4876                                                         " file"
4877                                                     )
4878                                                     configured_elements[
4879                                                         this_element_name
4880                                                     ] = _getAdmlDisplayName(
4881                                                         adml_policy_resources,
4882                                                         enum_item.attrib["displayName"],
4883                                                     )
4884                                                     break
4885                                             else:
4886                                                 configured_elements[
4887                                                     this_element_name
4888                                                 ] = _getAdmlDisplayName(
4889                                                     adml_policy_resources,
4890                                                     enum_item.attrib["displayName"],
4891                                                 )
4892                                                 break
4893                             elif etree.QName(child_item).localname == "list":
4894                                 return_value_name = False
4895                                 if (
4896                                     "explicitValue" in child_item.attrib
4897                                     and child_item.attrib["explicitValue"].lower()
4898                                     == "true"
4899                                 ):
4900                                     log.trace(
4901                                         "explicitValue list, we will return value names"
4902                                     )
4903                                     return_value_name = True
4904                                 regex_str = [
4905                                     r"(?!\*",
4906                                     r"\*",
4907                                     "D",
4908                                     "e",
4909                                     "l",
4910                                     "V",
4911                                     "a",
4912                                     "l",
4913                                     "s",
4914                                     r"\.",
4915                                     ")",
4916                                 ]
4917                                 delvals_regex = "\x00".join(regex_str)
4918                                 delvals_regex = salt.utils.stringutils.to_bytes(
4919                                     delvals_regex
4920                                 )
4921                                 if _regexSearchRegPolData(
4922                                     re.escape(
4923                                         _processValueItem(
4924                                             child_item,
4925                                             child_key,
4926                                             child_valuename,
4927                                             admx_policy,
4928                                             elements_item,
4929                                             check_deleted=False,
4930                                         )
4931                                     )
4932                                     + delvals_regex,
4933                                     policy_file_data,
4934                                 ):
4935                                     configured_value = _getDataFromRegPolData(
4936                                         _processValueItem(
4937                                             child_item,
4938                                             child_key,
4939                                             child_valuename,
4940                                             admx_policy,
4941                                             elements_item,
4942                                             check_deleted=False,
4943                                         ),
4944                                         policy_file_data,
4945                                         return_value_name=return_value_name,
4946                                     )
4947                                     configured_elements[
4948                                         this_element_name
4949                                     ] = configured_value
4950                                     log.trace(
4951                                         "element %s is enabled values: %s",
4952                                         child_item.attrib["id"],
4953                                         configured_value,
4954                                     )
4955                                 elif _regexSearchRegPolData(
4956                                     re.escape(
4957                                         _processValueItem(
4958                                             child_item,
4959                                             child_key,
4960                                             child_valuename,
4961                                             admx_policy,
4962                                             elements_item,
4963                                             check_deleted=True,
4964                                         )
4965                                     ),
4966                                     policy_file_data,
4967                                 ):
4968                                     configured_elements[this_element_name] = "Disabled"
4969                                     policy_disabled_elements = (
4970                                         policy_disabled_elements + 1
4971                                     )
4972                                     log.trace(
4973                                         "element %s is disabled",
4974                                         child_item.attrib["id"],
4975                                     )
4976                     if element_only_enabled_disabled:
4977                         if len(required_elements.keys()) &gt; 0 and len(
4978                             configured_elements.keys()
4979                         ) == len(required_elements.keys()):
4980                             if policy_disabled_elements == len(
4981                                 required_elements.keys()
4982                             ):
4983                                 log.trace(
4984                                     "%s is disabled by all enum elements",
4985                                     this_policyname,
4986                                 )
4987                                 if this_policynamespace not in policy_vals:
4988                                     policy_vals[this_policynamespace] = {}
4989                                 policy_vals[this_policynamespace][
4990                                     this_policyname
4991                                 ] = "Disabled"
4992                             else:
4993                                 if this_policynamespace not in policy_vals:
4994                                     policy_vals[this_policynamespace] = {}
4995                                 policy_vals[this_policynamespace][
4996                                     this_policyname
4997                                 ] = configured_elements
4998                                 log.trace(
4999                                     "%s is enabled by enum elements", this_policyname
5000                                 )
5001                     else:
5002                         if this_policy_setting == "Enabled":
5003                             if this_policynamespace not in policy_vals:
5004                                 policy_vals[this_policynamespace] = {}
5005                             policy_vals[this_policynamespace][
5006                                 this_policyname
5007                             ] = configured_elements
5008             if (
5009                 return_full_policy_names
5010                 and this_policynamespace in policy_vals
5011                 and this_policyname in policy_vals[this_policynamespace]
5012             ):
5013                 if this_policynamespace not in full_names:
5014                     full_names[this_policynamespace] = {}
5015                 full_names[this_policynamespace][this_policyname] = _getFullPolicyName(
5016                     policy_item=admx_policy,
5017                     policy_name=admx_policy.attrib["name"],
5018                     return_full_policy_names=return_full_policy_names,
5019                     adml_language=adml_language,
5020                 )
5021                 if (
5022                     this_policyname
5023                     in policy_vals[this_policynamespace][this_policyname]
5024                 ):
5025                     full_name = full_names[this_policynamespace][this_policyname]
5026                     setting = policy_vals[this_policynamespace][this_policyname].pop(
5027                         this_policyname
5028                     )
5029                     policy_vals[this_policynamespace][this_policyname][
5030                         full_name
5031                     ] = setting
5032             if (
5033                 this_policynamespace in policy_vals
5034                 and this_policyname in policy_vals[this_policynamespace]
5035             ):
5036                 if this_policynamespace not in hierarchy:
5037                     hierarchy[this_policynamespace] = {}
5038                 hierarchy[this_policynamespace][this_policyname] = _build_parent_list(
5039                     policy_definition=admx_policy,
5040                     return_full_policy_names=return_full_policy_names,
5041                     adml_language=adml_language,
5042                 )
5043         log.trace("Examination complete: %s seconds", time.time() - start_time)
5044     if policy_vals and return_full_policy_names and not hierarchical_return:
5045         log.debug("Compiling non hierarchical return...")
5046         start_time = time.time()
5047         unpathed_dict = {}
5048         pathed_dict = {}
5049         for policy_namespace in list(policy_vals):
5050             for policy_item in list(policy_vals[policy_namespace]):
5051                 if (
5052                     full_names[policy_namespace][policy_item]
5053                     in policy_vals[policy_namespace]
5054                 ):
5055                     full_path_list = hierarchy[policy_namespace][policy_item]
5056                     full_path_list.reverse()
5057                     full_path_list.append(full_names[policy_namespace][policy_item])
5058                     policy_vals["\\".join(full_path_list)] = policy_vals[
5059                         policy_namespace
5060                     ].pop(policy_item)
5061                     pathed_dict[full_names[policy_namespace][policy_item]] = True
5062                 else:
5063                     policy_vals[policy_namespace][
5064                         full_names[policy_namespace][policy_item]
5065                     ] = policy_vals[policy_namespace].pop(policy_item)
5066                     if policy_namespace not in unpathed_dict:
5067                         unpathed_dict[policy_namespace] = {}
5068                     unpathed_dict[policy_namespace][
5069                         full_names[policy_namespace][policy_item]
5070                     ] = policy_item
5071             if policy_namespace in unpathed_dict:
5072                 for path_needed in unpathed_dict[policy_namespace]:
5073                     full_path_list = hierarchy[policy_namespace][
5074                         unpathed_dict[policy_namespace][path_needed]
5075                     ]
5076                     full_path_list.reverse()
5077                     full_path_list.append(path_needed)
5078                     log.trace("full_path_list == %s", full_path_list)
5079                     policy_vals["\\".join(full_path_list)] = policy_vals[
5080                         policy_namespace
5081                     ].pop(path_needed)
5082         log.trace("Compilation complete: %s seconds", time.time() - start_time)
5083     for policy_namespace in list(policy_vals):
5084         if policy_vals[policy_namespace] == {}:
5085             policy_vals.pop(policy_namespace)
5086     if policy_vals and hierarchical_return:
5087         if hierarchy:
5088             log.debug("Compiling hierarchical return...")
5089             start_time = time.time()
5090             for policy_namespace in hierarchy:
5091                 for hierarchy_item in hierarchy[policy_namespace]:
5092                     if hierarchy_item in policy_vals[policy_namespace]:
5093                         tdict = {}
5094                         first_item = True
5095                         for item in hierarchy[policy_namespace][hierarchy_item]:
5096                             newdict = {}
5097                             if first_item:
5098                                 h_policy_name = hierarchy_item
5099                                 if return_full_policy_names:
5100                                     h_policy_name = full_names[policy_namespace][
5101                                         hierarchy_item
5102                                     ]
5103                                 newdict[item] = {
5104                                     h_policy_name: policy_vals[policy_namespace].pop(
5105                                         hierarchy_item
5106                                     )
5107                                 }
5108                                 first_item = False
5109                             else:
5110                                 newdict[item] = tdict
5111                             tdict = newdict
5112                         if tdict:
5113                             policy_vals = dictupdate.update(policy_vals, tdict)
5114                 if (
5115                     policy_namespace in policy_vals
5116                     and policy_vals[policy_namespace] == {}
5117                 ):
5118                     policy_vals.pop(policy_namespace)
5119             log.trace("Compilation complete: %s seconds", time.time() - start_time)
5120         policy_vals = {
5121             module_policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
5122                 "Administrative Templates": policy_vals
5123             }
5124         }
5125     return policy_vals
5126 def _build_parent_list(policy_definition, return_full_policy_names, adml_language):
5127     parent_list = []
5128     policy_namespace = next(iter(policy_definition.nsmap))
5129     parent_category = policy_definition.xpath(
5130         "{}:parentCategory/@ref".format(policy_namespace),
5131         namespaces=policy_definition.nsmap,
5132     )
5133     admx_policy_definitions = _get_policy_definitions(language=adml_language)
5134     if parent_category:
5135         parent_category = parent_category[0]
5136         nsmap_xpath = "/policyDefinitions/policyNamespaces/{}:*".format(
5137             policy_namespace
5138         )
5139         this_namespace_map = _buildElementNsmap(
5140             admx_policy_definitions.xpath(
5141                 nsmap_xpath, namespaces=policy_definition.nsmap
5142             )
5143         )
5144         this_namespace_map = dictupdate.update(
5145             this_namespace_map, policy_definition.nsmap
5146         )
5147         parent_list = _admx_policy_parent_walk(
5148             path=parent_list,
5149             policy_namespace=policy_namespace,
5150             parent_category=parent_category,
5151             policy_nsmap=this_namespace_map,
5152             return_full_policy_names=return_full_policy_names,
5153             adml_language=adml_language,
5154         )
5155     return parent_list
5156 def _admx_policy_parent_walk(
5157     path,
5158     policy_namespace,
5159     parent_category,
5160     policy_nsmap,
5161     return_full_policy_names,
5162     adml_language,
5163 ):
5164     admx_policy_definitions = _get_policy_definitions(language=adml_language)
5165     category_xpath_string = '/policyDefinitions/categories/{}:category[@name="{}"]'
5166     using_xpath_string = "/policyDefinitions/policyNamespaces/{}:using"
5167 <a name="10"></a>    if parent_category.find(":") &gt;= 0:
5168         policy_namespace = parent_category.split(":")[0]
5169         parent_category = parent_category<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.split(":")[1]
5170         using_xpath_string = using_xpath_string.format(policy_namespace)
5171         policy_nsmap = dictupdate.update(
5172             policy_nsmap,
5173             _buildElementNsmap(
5174                 admx_policy_definitions.xpath(</b></font>
5175                     using_xpath_string, namespaces=policy_nsmap
5176                 )
5177             ),
5178         )
5179     category_xpath_string = category_xpath_string.format(
5180         policy_namespace, parent_category
5181     )
5182     if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):
5183         tparent_category = admx_policy_definitions.xpath(
5184             category_xpath_string, namespaces=policy_nsmap
5185         )[0]
5186         this_parent_name = _getFullPolicyName(
5187             policy_item=tparent_category,
5188             policy_name=tparent_category.attrib["name"],
5189             return_full_policy_names=return_full_policy_names,
5190             adml_language=adml_language,
5191         )
5192         path.append(this_parent_name)
5193         if tparent_category.xpath(
5194             "{}:parentCategory/@ref".format(policy_namespace), namespaces=policy_nsmap
5195         ):
5196             path = _admx_policy_parent_walk(
5197                 path=path,
5198                 policy_namespace=policy_namespace,
5199                 parent_category=tparent_category.xpath(
5200                     "{}:parentCategory/@ref".format(policy_namespace),
5201                     namespaces=policy_nsmap,
5202                 )[0],
5203                 policy_nsmap=policy_nsmap,
5204                 return_full_policy_names=return_full_policy_names,
5205                 adml_language=adml_language,
5206             )
5207     return path
5208 def _read_regpol_file(reg_pol_path):
5209     returndata = None
5210     if os.path.exists(reg_pol_path):
5211         with salt.utils.files.fopen(reg_pol_path, "rb") as pol_file:
5212             returndata = pol_file.read()
5213     return returndata
5214 def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):
5215     if policy_data:
5216         regex_str = [
5217             r"(\*",
5218             r"\*",
5219             "D",
5220             "e",
5221             "l",
5222             r"\.",
5223             r"|\*",
5224             r"\*",
5225             "D",
5226             "e",
5227             "l",
5228             "V",
5229             "a",
5230             "l",
5231             "s",
5232             r"\.",
5233             "){0,1}",
5234 <a name="7"></a>        ]
5235         specialValueRegex = "\x00".join(regex_str)
5236         specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)
5237         _thisSearch = b""<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.join(
5238             [
5239                 salt.utils.stringutils.to_bytes(r"\["),
5240                 re.escape(policy_regpath),
5241                 b"\x00;\x00",
5242                 specialValueRegex,
5243                 re.escape(policy_regkey.</b></font>lstrip(b"\x00")),
5244                 b"\x00;",
5245             ]
5246         )
5247         match = re.search(_thisSearch, policy_data, re.IGNORECASE)
5248         if match:
5249             return policy_data[
5250                 match.start() : (policy_data.index(b"]", match.end())) + 2
5251             ]
5252     return None
5253 def _write_regpol_data(
5254     data_to_write, policy_file_path, gpt_ini_path, gpt_extension, gpt_extension_guid
5255 ):
5256     if not os.path.exists(policy_file_path):
5257         __salt__["file.makedirs"](policy_file_path)
5258     try:
5259         with salt.utils.files.fopen(policy_file_path, "wb") as pol_file:
5260             reg_pol_header = "\u5250\u6765\x01\x00".encode("utf-16-le")
5261             if not data_to_write.startswith(reg_pol_header):
5262                 pol_file.write(reg_pol_header)
5263             pol_file.write(data_to_write)
5264     except Exception as e:  # pylint: disable=broad-except
5265         msg = (
5266             "An error occurred attempting to write to {}, the exception was: {}".format(
5267                 policy_file_path, e
5268             )
5269         )
5270         log.exception(msg)
5271         raise CommandExecutionError(msg)
5272     gpt_ini_data = ""
5273     if os.path.exists(gpt_ini_path):
5274         with salt.utils.files.fopen(gpt_ini_path, "r") as gpt_file:
5275             gpt_ini_data = gpt_file.read()
5276         gpt_ini_data = (
5277             gpt_ini_data.replace("\r\n", "_|-")
5278             .replace("\n", "_|-")
5279             .replace("_|-", "\r\n")
5280         )
5281     if not _regexSearchRegPolData(r"\[General\]\r\n", gpt_ini_data):
5282         gpt_ini_data = "[General]\r\n" + gpt_ini_data
5283     if _regexSearchRegPolData(r"{}=".format(re.escape(gpt_extension)), gpt_ini_data):
5284         gpt_ext_loc = re.search(
5285             r"^{}=.*\r\n".format(re.escape(gpt_extension)),
5286             gpt_ini_data,
5287             re.IGNORECASE | re.MULTILINE,
5288         )
5289         gpt_ext_str = gpt_ini_data[gpt_ext_loc.start() : gpt_ext_loc.end()]
5290         if not _regexSearchRegPolData(
5291             r"{}".format(re.escape(gpt_extension_guid)), gpt_ext_str
5292         ):
5293             gpt_ext_str = gpt_ext_str.split("=")
5294             gpt_ext_str[1] = gpt_extension_guid + gpt_ext_str[1]
5295             gpt_ext_str = "=".join(gpt_ext_str)
5296             gpt_ini_data = (
5297                 gpt_ini_data[0 : gpt_ext_loc.start()]
5298                 + gpt_ext_str
5299                 + gpt_ini_data[gpt_ext_loc.end() :]
5300 <a name="8"></a>            )
5301     else:
5302         general_location = re.search(
5303             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.MULTILINE
5304         )
5305         gpt_ini_data = "{}{}={}\r\n{}".format(
5306             gpt_ini_data[general_location.start() : general_location.end()],
5307             gpt_extension,
5308             gpt_extension_guid,
5309             gpt_ini_data[general_location.end(</b></font>) :],
5310         )
5311     if _regexSearchRegPolData(r"Version=", gpt_ini_data):
5312         version_loc = re.search(
5313             r"^Version=.*\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
5314         )
5315         version_str = gpt_ini_data[version_loc.start() : version_loc.end()]
5316         version_str = version_str.split("=")
5317         version_nums = struct.unpack(b"&gt;2H", struct.pack(b"&gt;I", int(version_str[1])))
5318         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
5319             version_nums = (version_nums[0], version_nums[1] + 1)
5320         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
5321             version_nums = (version_nums[0] + 1, version_nums[1])
5322         version_num = struct.unpack(b"&gt;I", struct.pack(b"&gt;2H", *version_nums))[0]
5323         gpt_ini_data = "{}{}={}\r\n{}".format(
5324             gpt_ini_data[0 : version_loc.start()],
5325             "Version",
5326             version_num,
5327             gpt_ini_data[version_loc.end() :],
5328         )
5329     else:
5330         general_location = re.search(
5331             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
5332         )
5333         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
5334             version_nums = (0, 1)
5335         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
5336             version_nums = (1, 0)
5337         gpt_ini_data = "{}{}={}\r\n{}".format(
5338             gpt_ini_data[general_location.start() : general_location.end()],
5339             "Version",
5340             int(
5341                 "{}{}".format(
5342                     str(version_nums[0]).zfill(4),
5343                     str(version_nums[1]).zfill(4),
5344                 ),
5345                 16,
5346             ),
5347             gpt_ini_data[general_location.end() :],
5348         )
5349     if gpt_ini_data:
5350         try:
5351             with salt.utils.files.fopen(gpt_ini_path, "w") as gpt_file:
5352                 gpt_file.write(gpt_ini_data)
5353         except Exception as e:  # pylint: disable=broad-except
5354             msg = (
5355                 "An error occurred attempting to write the gpg.ini file.\n"
5356                 "path: {}\n"
5357                 "exception: {}".format(gpt_ini_path, e)
5358             )
5359             log.exception(msg)
5360             raise CommandExecutionError(msg)
5361 def _policyFileReplaceOrAppendList(string_list, policy_data):
5362     if not policy_data:
5363         policy_data = b""
5364     specialValueRegex = salt.utils.stringutils.to_bytes(
5365         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
5366     )
5367     for this_string in string_list:
5368         list_item_key = this_string.split(b"\00;")[0].lstrip(b"[")
5369         list_item_value_name = re.sub(
5370             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
5371         )
5372         log.trace("item value name is %s", list_item_value_name)
5373         data_to_replace = _regexSearchKeyValueCombo(
5374             policy_data, list_item_key, list_item_value_name
5375         )
5376         if data_to_replace:
5377             log.trace("replacing %s with %s", data_to_replace, this_string)
5378             policy_data = policy_data.replace(data_to_replace, this_string)
5379         else:
5380             log.trace("appending %s", this_string)
5381             policy_data = b"".join([policy_data, this_string])
5382     return policy_data
5383 def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):
5384     if not policy_data:
5385         policy_data = b""
5386     specialValueRegex = salt.utils.stringutils.to_bytes(
5387         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
5388     )
5389     item_key = None
5390     item_value_name = None
5391     data_to_replace = None
5392     if not append_only:
5393         item_key = this_string.split(b"\00;")[0].lstrip(b"[")
5394         item_value_name = re.sub(
5395             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
5396         )
5397         log.trace("item value name is %s", item_value_name)
5398         data_to_replace = _regexSearchKeyValueCombo(
5399             policy_data, item_key, item_value_name
5400         )
5401     if data_to_replace:
5402         log.trace("replacing %s with %s", data_to_replace, this_string)
5403         policy_data = policy_data.replace(data_to_replace, this_string)
5404     else:
5405         log.trace("appending %s", this_string)
5406         policy_data = b"".join([policy_data, this_string])
5407     return policy_data
5408 def _writeAdminTemplateRegPolFile(
5409     admtemplate_data, adml_language="en-US", registry_class="Machine"
5410 ):
5411     r"""
5412     helper function to prep/write adm template data to the Registry.pol file
5413     each file begins with REGFILE_SIGNATURE (u'\u5250\u6765') and
5414     REGISTRY_FILE_VERSION (u'\x01\00')
5415     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
5416     +    https://msdn.microsoft.com/en-us/library/cc232696.aspx
5417     [Registry Path&lt;NULL&gt;;Reg Value&lt;NULL&gt;;Reg Type;SizeInBytes;Data&lt;NULL&gt;]
5418     """
5419     existing_data = b""
5420     policy_data = _policy_info()
5421     policySearchXpath = '//ns1:*[@id = "{0}" or @name = "{0}"]'
5422     admx_policy_definitions = _get_policy_definitions(language=adml_language)
5423     adml_policy_resources = _get_policy_resources(language=adml_language)
5424     base_policy_settings = _checkAllAdmxPolicies(
5425         policy_class=registry_class,
5426         adml_language=adml_language,
5427         return_full_policy_names=False,
5428         hierarchical_return=False,
5429         return_not_configured=False,
5430     )
5431     for adm_namespace in admtemplate_data:
5432         for adm_policy in admtemplate_data[adm_namespace]:
5433             if (
5434                 str(admtemplate_data[adm_namespace][adm_policy]).lower()
5435                 == "not configured"
5436             ):
5437                 if (
5438                     base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None)
5439                     is not None
5440                 ):
5441                     log.trace('Policy "%s" removed', adm_policy)
5442             else:
5443                 log.trace("adding %s to base_policy_settings", adm_policy)
5444                 if adm_namespace not in base_policy_settings:
5445                     base_policy_settings[adm_namespace] = {}
5446                 base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[
5447                     adm_namespace
5448                 ][adm_policy]
5449     for adm_namespace in base_policy_settings:
5450         for admPolicy in base_policy_settings[adm_namespace]:
5451             log.trace("working on admPolicy %s", admPolicy)
5452             explicit_enable_disable_value_setting = False
5453             this_key = None
5454             this_valuename = None
5455             if (
5456                 str(base_policy_settings[adm_namespace][admPolicy]).lower()
5457                 == "disabled"
5458             ):
5459                 log.trace("time to disable %s", admPolicy)
5460                 this_policy = admx_policy_definitions.xpath(
5461                     policySearchXpath.format(admPolicy),
5462                     namespaces={"ns1": adm_namespace},
5463                 )
5464                 if this_policy:
5465                     this_policy = this_policy[0]
5466                     if "class" in this_policy.attrib:
5467                         if (
5468                             this_policy.attrib["class"] == registry_class
5469                             or this_policy.attrib["class"] == "Both"
5470                         ):
5471                             if "key" in this_policy.attrib:
5472                                 this_key = this_policy.attrib["key"]
5473                             else:
5474                                 log.error(
5475                                     "policy item %s does not have "
5476                                     'the required "key" attribute',
5477                                     this_policy.attrib,
5478                                 )
5479                                 break
5480                             if "valueName" in this_policy.attrib:
5481                                 this_valuename = this_policy.attrib["valueName"]
5482                             if DISABLED_VALUE_XPATH(this_policy):
5483                                 explicit_enable_disable_value_setting = True
5484                                 disabled_value_string = _checkValueItemParent(
5485                                     this_policy,
5486                                     admPolicy,
5487                                     this_key,
5488                                     this_valuename,
5489                                     DISABLED_VALUE_XPATH,
5490                                     None,
5491                                     check_deleted=False,
5492                                     test_item=False,
5493                                 )
5494                                 existing_data = _policyFileReplaceOrAppend(
5495                                     disabled_value_string, existing_data
5496                                 )
5497                             if DISABLED_LIST_XPATH(this_policy):
5498                                 explicit_enable_disable_value_setting = True
5499                                 disabled_list_strings = _checkListItem(
5500                                     this_policy,
5501                                     admPolicy,
5502                                     this_key,
5503                                     DISABLED_LIST_XPATH,
5504                                     None,
5505                                     test_items=False,
5506                                 )
5507                                 log.trace(
5508                                     "working with disabledList portion of %s",
5509                                     admPolicy,
5510                                 )
5511                                 existing_data = _policyFileReplaceOrAppendList(
5512                                     disabled_list_strings, existing_data
5513                                 )
5514                             if (
5515                                 not explicit_enable_disable_value_setting
5516                                 and this_valuename
5517                             ):
5518                                 disabled_value_string = _buildKnownDataSearchString(
5519                                     this_key,
5520                                     this_valuename,
5521                                     "REG_DWORD",
5522                                     None,
5523                                     check_deleted=True,
5524                                 )
5525                                 existing_data = _policyFileReplaceOrAppend(
5526                                     disabled_value_string, existing_data
5527                                 )
5528                             if ELEMENTS_XPATH(this_policy):
5529                                 log.trace("checking elements of %s", admPolicy)
5530                                 for elements_item in ELEMENTS_XPATH(this_policy):
5531                                     for child_item in elements_item:
5532                                         child_key = this_key
5533                                         child_valuename = this_valuename
5534                                         if "key" in child_item.attrib:
5535                                             child_key = child_item.attrib["key"]
5536                                         if "valueName" in child_item.attrib:
5537                                             child_valuename = child_item.attrib[
5538                                                 "valueName"
5539                                             ]
5540                                         if etree.QName(
5541                                             child_item
5542                                         ).localname == "boolean" and (
5543                                             TRUE_LIST_XPATH(child_item)
5544                                             or FALSE_LIST_XPATH(child_item)
5545                                         ):
5546                                             temp_dict = {
5547                                                 "trueList": TRUE_LIST_XPATH,
5548                                                 "falseList": FALSE_LIST_XPATH,
5549                                             }
5550                                             for this_list in temp_dict:
5551                                                 disabled_list_strings = _checkListItem(
5552                                                     child_item,
5553                                                     admPolicy,
5554                                                     child_key,
5555                                                     temp_dict[this_list],
5556                                                     None,
5557                                                     test_items=False,
5558                                                 )
5559                                                 log.trace(
5560                                                     "working with %s portion of %s",
5561                                                     admPolicy,
5562                                                     this_list,
5563                                                 )
5564                                                 existing_data = (
5565                                                     _policyFileReplaceOrAppendList(
5566                                                         disabled_list_strings,
5567                                                         existing_data,
5568                                                     )
5569                                                 )
5570                                         elif (
5571                                             etree.QName(child_item).localname
5572                                             == "boolean"
5573                                             or etree.QName(child_item).localname
5574                                             == "decimal"
5575                                             or etree.QName(child_item).localname
5576                                             == "text"
5577                                             or etree.QName(child_item).localname
5578                                             == "longDecimal"
5579                                             or etree.QName(child_item).localname
5580                                             == "multiText"
5581                                             or etree.QName(child_item).localname
5582                                             == "enum"
5583                                         ):
5584                                             disabled_value_string = _processValueItem(
5585                                                 child_item,
5586                                                 child_key,
5587                                                 child_valuename,
5588                                                 this_policy,
5589                                                 elements_item,
5590                                                 check_deleted=True,
5591                                             )
5592                                             log.trace(
5593                                                 "I have disabled value string of %s",
5594                                                 disabled_value_string,
5595                                             )
5596                                             existing_data = _policyFileReplaceOrAppend(
5597                                                 disabled_value_string, existing_data
5598                                             )
5599                                         elif (
5600                                             etree.QName(child_item).localname == "list"
5601                                         ):
5602                                             disabled_value_string = _processValueItem(
5603                                                 child_item,
5604                                                 child_key,
5605                                                 child_valuename,
5606                                                 this_policy,
5607                                                 elements_item,
5608                                                 check_deleted=True,
5609                                             )
5610                                             log.trace(
5611                                                 "I have disabled value string of %s",
5612                                                 disabled_value_string,
5613                                             )
5614                                             existing_data = _policyFileReplaceOrAppend(
5615                                                 disabled_value_string, existing_data
5616                                             )
5617                         else:
5618                             log.error(
5619                                 "policy %s was found but it does not appear to be valid"
5620                                 " for the class %s",
5621                                 admPolicy,
5622                                 registry_class,
5623                             )
5624                     else:
5625                         log.error(
5626                             'policy item %s does not have the required "class"'
5627                             " attribute",
5628                             this_policy.attrib,
5629                         )
5630             else:
5631                 log.trace('time to enable and set the policy "%s"', admPolicy)
5632                 this_policy = admx_policy_definitions.xpath(
5633                     policySearchXpath.format(admPolicy),
5634                     namespaces={"ns1": adm_namespace},
5635                 )
5636                 log.trace("found this_policy == %s", this_policy)
5637                 if this_policy:
5638                     this_policy = this_policy[0]
5639                     if "class" in this_policy.attrib:
5640                         if (
5641                             this_policy.attrib["class"] == registry_class
5642                             or this_policy.attrib["class"] == "Both"
5643                         ):
5644                             if "key" in this_policy.attrib:
5645                                 this_key = this_policy.attrib["key"]
5646                             else:
5647                                 log.error(
5648                                     'policy item %s does not have the required "key"'
5649                                     " attribute",
5650                                     this_policy.attrib,
5651                                 )
5652                                 break
5653                             if "valueName" in this_policy.attrib:
5654                                 this_valuename = this_policy.attrib["valueName"]
5655                             if ENABLED_VALUE_XPATH(this_policy):
5656                                 explicit_enable_disable_value_setting = True
5657                                 enabled_value_string = _checkValueItemParent(
5658                                     this_policy,
5659                                     admPolicy,
5660                                     this_key,
5661                                     this_valuename,
5662                                     ENABLED_VALUE_XPATH,
5663                                     None,
5664                                     check_deleted=False,
5665                                     test_item=False,
5666                                 )
5667                                 existing_data = _policyFileReplaceOrAppend(
5668                                     enabled_value_string, existing_data
5669                                 )
5670                             if ENABLED_LIST_XPATH(this_policy):
5671                                 explicit_enable_disable_value_setting = True
5672                                 enabled_list_strings = _checkListItem(
5673                                     this_policy,
5674                                     admPolicy,
5675                                     this_key,
5676                                     ENABLED_LIST_XPATH,
5677                                     None,
5678                                     test_items=False,
5679                                 )
5680                                 log.trace(
5681                                     "working with enabledList portion of %s", admPolicy
5682                                 )
5683                                 existing_data = _policyFileReplaceOrAppendList(
5684                                     enabled_list_strings, existing_data
5685                                 )
5686                             if (
5687                                 not explicit_enable_disable_value_setting
5688                                 and this_valuename
5689                             ):
5690                                 enabled_value_string = _buildKnownDataSearchString(
5691                                     this_key,
5692                                     this_valuename,
5693                                     "REG_DWORD",
5694                                     "1",
5695                                     check_deleted=False,
5696                                 )
5697                                 existing_data = _policyFileReplaceOrAppend(
5698                                     enabled_value_string, existing_data
5699                                 )
5700                             if ELEMENTS_XPATH(this_policy):
5701                                 for elements_item in ELEMENTS_XPATH(this_policy):
5702                                     for child_item in elements_item:
5703                                         child_key = this_key
5704                                         child_valuename = this_valuename
5705                                         if "key" in child_item.attrib:
5706                                             child_key = child_item.attrib["key"]
5707                                         if "valueName" in child_item.attrib:
5708                                             child_valuename = child_item.attrib[
5709                                                 "valueName"
5710                                             ]
5711                                         if (
5712                                             child_item.attrib["id"]
5713                                             in base_policy_settings[adm_namespace][
5714                                                 admPolicy
5715                                             ]
5716                                         ):
5717                                             if etree.QName(
5718                                                 child_item
5719                                             ).localname == "boolean" and (
5720                                                 TRUE_LIST_XPATH(child_item)
5721                                                 or FALSE_LIST_XPATH(child_item)
5722                                             ):
5723                                                 list_strings = []
5724                                                 if base_policy_settings[adm_namespace][
5725                                                     admPolicy
5726                                                 ][child_item.attrib["id"]]:
5727                                                     list_strings = _checkListItem(
5728                                                         child_item,
5729                                                         admPolicy,
5730                                                         child_key,
5731                                                         TRUE_LIST_XPATH,
5732                                                         None,
5733                                                         test_items=False,
5734                                                     )
5735                                                     log.trace(
5736                                                         "working with trueList portion"
5737                                                         " of %s",
5738                                                         admPolicy,
5739                                                     )
5740                                                 else:
5741                                                     list_strings = _checkListItem(
5742                                                         child_item,
5743                                                         admPolicy,
5744                                                         child_key,
5745                                                         FALSE_LIST_XPATH,
5746                                                         None,
5747                                                         test_items=False,
5748                                                     )
5749                                                 existing_data = (
5750                                                     _policyFileReplaceOrAppendList(
5751                                                         list_strings, existing_data
5752                                                     )
5753                                                 )
5754                                             elif etree.QName(
5755                                                 child_item
5756                                             ).localname == "boolean" and (
5757                                                 TRUE_VALUE_XPATH(child_item)
5758                                                 or FALSE_VALUE_XPATH(child_item)
5759                                             ):
5760                                                 value_string = ""
5761                                                 if base_policy_settings[adm_namespace][
5762                                                     admPolicy
5763                                                 ][child_item.attrib["id"]]:
5764                                                     value_string = (
5765                                                         _checkValueItemParent(
5766                                                             child_item,
5767                                                             admPolicy,
5768                                                             child_key,
5769                                                             child_valuename,
5770                                                             TRUE_VALUE_XPATH,
5771                                                             None,
5772                                                             check_deleted=False,
5773                                                             test_item=False,
5774                                                         )
5775                                                     )
5776                                                 else:
5777                                                     value_string = (
5778                                                         _checkValueItemParent(
5779                                                             child_item,
5780                                                             admPolicy,
5781                                                             child_key,
5782                                                             child_valuename,
5783                                                             FALSE_VALUE_XPATH,
5784                                                             None,
5785                                                             check_deleted=False,
5786                                                             test_item=False,
5787 <a name="5"></a>                                                        )
5788                                                     )
5789                                                 existing_data = (
5790                                                     _policyFileReplaceOrAppend<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(
5791                                                         value_string, existing_data
5792                                                     )
5793                                                 )
5794                                             elif (
5795                                                 etree.QName(child_item).localname
5796                                                 == "boolean"
5797                                                 or etree.QName(child_item).localname
5798                                                 == "decimal"
5799                                                 or etree.QName(child_item).localname
5800                                                 == "text"
5801                                                 or etree.QName(child_item).</b></font>localname
5802                                                 == "longDecimal"
5803                                                 or etree.QName(child_item).localname
5804                                                 == "multiText"
5805                                             ):
5806                                                 enabled_value_string = _processValueItem(
5807                                                     child_item,
5808                                                     child_key,
5809                                                     child_valuename,
5810                                                     this_policy,
5811                                                     elements_item,
5812                                                     check_deleted=False,
5813                                                     this_element_value=base_policy_settings[
5814                                                         adm_namespace
5815                                                     ][
5816                                                         admPolicy
5817                                                     ][
5818                                                         child_item.attrib["id"]
5819                                                     ],
5820                                                 )
5821                                                 log.trace(
5822                                                     "I have enabled value string of %s",
5823                                                     enabled_value_string,
5824                                                 )
5825                                                 existing_data = (
5826                                                     _policyFileReplaceOrAppend(
5827                                                         enabled_value_string,
5828                                                         existing_data,
5829                                                     )
5830                                                 )
5831                                             elif (
5832                                                 etree.QName(child_item).localname
5833                                                 == "enum"
5834                                             ):
5835                                                 for enum_item in child_item:
5836                                                     if (
5837                                                         base_policy_settings[
5838                                                             adm_namespace
5839                                                         ][admPolicy][
5840                                                             child_item.attrib["id"]
5841                                                         ]
5842                                                         == _getAdmlDisplayName(
5843                                                             adml_policy_resources,
5844                                                             enum_item.attrib[
5845                                                                 "displayName"
5846                                                             ],
5847                                                         ).strip()
5848                                                     ):
5849                                                         enabled_value_string = (
5850                                                             _checkValueItemParent(
5851                                                                 enum_item,
5852                                                                 child_item.attrib["id"],
5853                                                                 child_key,
5854                                                                 child_valuename,
5855                                                                 VALUE_XPATH,
5856                                                                 None,
5857                                                                 check_deleted=False,
5858                                                                 test_item=False,
5859                                                             )
5860                                                         )
5861                                                         existing_data = (
5862                                                             _policyFileReplaceOrAppend(
5863                                                                 enabled_value_string,
5864                                                                 existing_data,
5865                                                             )
5866                                                         )
5867                                                         if VALUE_LIST_XPATH(enum_item):
5868                                                             enabled_list_strings = (
5869                                                                 _checkListItem(
5870                                                                     enum_item,
5871                                                                     admPolicy,
5872                                                                     child_key,
5873                                                                     VALUE_LIST_XPATH,
5874                                                                     None,
5875                                                                     test_items=False,
5876                                                                 )
5877                                                             )
5878                                                             log.trace(
5879                                                                 "working with valueList"
5880                                                                 " portion of %s",
5881                                                                 child_item.attrib["id"],
5882                                                             )
5883                                                             existing_data = _policyFileReplaceOrAppendList(
5884                                                                 enabled_list_strings,
5885                                                                 existing_data,
5886                                                             )
5887                                                         break
5888                                             elif (
5889                                                 etree.QName(child_item).localname
5890                                                 == "list"
5891                                             ):
5892                                                 enabled_value_string = _processValueItem(
5893                                                     child_item,
5894                                                     child_key,
5895                                                     child_valuename,
5896                                                     this_policy,
5897                                                     elements_item,
5898                                                     check_deleted=False,
5899                                                     this_element_value=base_policy_settings[
5900                                                         adm_namespace
5901                                                     ][
5902                                                         admPolicy
5903                                                     ][
5904                                                         child_item.attrib["id"]
5905                                                     ],
5906                                                 )
5907                                                 log.trace(
5908                                                     "I have enabled value string of %s",
5909                                                     enabled_value_string,
5910                                                 )
5911                                                 existing_data = (
5912                                                     _policyFileReplaceOrAppend(
5913                                                         enabled_value_string,
5914                                                         existing_data,
5915                                                         append_only=True,
5916                                                     )
5917                                                 )
5918     try:
5919         _write_regpol_data(
5920             existing_data,
5921             policy_data.admx_registry_classes[registry_class]["policy_path"],
5922             policy_data.gpt_ini_path,
5923             policy_data.admx_registry_classes[registry_class]["gpt_extension_location"],
5924             policy_data.admx_registry_classes[registry_class]["gpt_extension_guid"],
5925         )
5926     except CommandExecutionError as exc:  # pylint: disable=broad-except
5927         log.exception(
5928             "Unhandled exception occurred while attempting to "
5929             "write Adm Template Policy File.\nException: %s",
5930             exc,
5931         )
5932         return False
5933     return True
5934 def _getScriptSettingsFromIniFile(policy_info):
5935     _existingData = None
5936     if os.path.isfile(policy_info["ScriptIni"]["IniPath"]):
5937         with salt.utils.files.fopen(policy_info["ScriptIni"]["IniPath"], "rb") as fhr:
5938             _existingData = fhr.read()
5939         if _existingData:
5940             try:
5941                 _existingData = deserialize(
5942                     _existingData.decode("utf-16-le").lstrip("\ufeff")
5943                 )
5944                 log.trace("Have deserialized data %s", _existingData)
5945             except Exception as error:  # pylint: disable=broad-except
5946                 log.exception(
5947                     "An error occurred attempting to deserialize data for %s",
5948                     policy_info["Policy"],
5949                 )
5950                 raise CommandExecutionError(error)
5951             if "Section" in policy_info["ScriptIni"] and policy_info["ScriptIni"][
5952                 "Section"
5953             ].lower() in [z.lower() for z in _existingData.keys()]:
5954                 if "SettingName" in policy_info["ScriptIni"]:
5955                     log.trace(
5956                         "Need to look for %s", policy_info["ScriptIni"]["SettingName"]
5957                     )
5958                     if policy_info["ScriptIni"]["SettingName"].lower() in [
5959                         z.lower()
5960                         for z in _existingData[
5961                             policy_info["ScriptIni"]["Section"]
5962                         ].keys()
5963                     ]:
5964                         return _existingData[policy_info["ScriptIni"]["Section"]][
5965                             policy_info["ScriptIni"]["SettingName"].lower()
5966                         ]
5967                     else:
5968                         return None
5969                 else:
5970                     return _existingData[policy_info["ScriptIni"]["Section"]]
5971             else:
5972                 return None
5973     return None
5974 def _writeGpoScript(psscript=False):
5975     _machineScriptPolicyPath = os.path.join(
5976         os.getenv("WINDIR"),
5977         "System32",
5978         "GroupPolicy",
5979         "Machine",
5980         "Scripts",
5981         "scripts.ini",
5982     )
5983     _machinePowershellScriptPolicyPath = os.path.join(
5984         os.getenv("WINDIR"),
5985         "System32",
5986         "GroupPolicy",
5987         "Machine",
5988         "Scripts",
5989         "psscripts.ini",
5990     )
5991     _userScriptPolicyPath = os.path.join(
5992         os.getenv("WINDIR"), "System32", "GroupPolicy", "User", "Scripts", "scripts.ini"
5993     )
5994     _userPowershellScriptPolicyPath = os.path.join(
5995         os.getenv("WINDIR"),
5996         "System32",
5997         "GroupPolicy",
5998         "User",
5999         "Scripts",
6000         "psscripts.ini",
6001     )
6002 def _lookup_admin_template(policy_name, policy_class, adml_language="en-US"):
6003     policy_aliases = []
6004     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6005     adml_policy_resources = _get_policy_resources(language=adml_language)
6006     admx_search_results = ADMX_SEARCH_XPATH(
6007         admx_policy_definitions, policy_name=policy_name, registry_class=policy_class
6008     )
6009     if admx_search_results:
6010         if len(admx_search_results) == 1:
6011             the_policy = admx_search_results[0]
6012             policy_display_name = _getFullPolicyName(
6013                 policy_item=the_policy,
6014                 policy_name=the_policy.attrib["name"],
6015                 return_full_policy_names=True,
6016                 adml_language=adml_language,
6017             )
6018             policy_aliases.append(policy_display_name)
6019             policy_aliases.append(the_policy.attrib["name"])
6020             full_path_list = _build_parent_list(
6021                 policy_definition=the_policy,
6022                 return_full_policy_names=True,
6023                 adml_language=adml_language,
6024             )
6025             full_path_list.reverse()
6026             full_path_list.append(policy_display_name)
6027             policy_aliases.append("\\".join(full_path_list))
6028             return True, the_policy, policy_aliases, None
6029         else:
6030             msg = 'ADMX policy name/id "{}" is used in multiple ADMX files'
6031             return False, None, [], msg
6032     else:
6033         adml_search_results = ADML_SEARCH_XPATH(
6034             adml_policy_resources, policy_name=policy_name
6035         )
6036         hierarchy = []
6037         hierarchy_policy_name = policy_name
6038         if not adml_search_results:
6039             log.warning("Trying another: %s", policy_name)
6040             if "\\" in policy_name:
6041                 hierarchy = policy_name.split("\\")
6042                 policy_name = hierarchy.pop()
6043                 adml_search_results = ADML_SEARCH_XPATH(
6044                     adml_policy_resources, policy_name=policy_name
6045                 )
6046         if adml_search_results:
6047             multiple_adml_entries = False
6048             suggested_policies = ""
6049             adml_to_remove = []
6050             if len(adml_search_results) &gt; 1:
6051                 log.trace(
6052                     "multiple ADML entries found matching the policy name %s",
6053                     policy_name,
6054                 )
6055                 multiple_adml_entries = True
6056                 for adml_search_result in adml_search_results:
6057                     if (
6058                         not getattr(adml_search_result, "text", "").strip()
6059                         == policy_name
6060                     ):
6061                         adml_to_remove.append(adml_search_result)
6062                     else:
6063                         if hierarchy:
6064                             log.trace("we have hierarchy of %s", hierarchy)
6065                             display_name_searchval = "$({}.{})".format(
6066                                 adml_search_result.tag.split("}")[1],
6067                                 adml_search_result.attrib["id"],
6068                             )
6069                             policy_search_string = (
6070                                 '//{}:policy[@displayName = "{}" and (@class = "Both"'
6071                                 ' or @class = "{}") ]'.format(
6072                                     adml_search_result.prefix,
6073                                     display_name_searchval,
6074                                     policy_class,
6075                                 )
6076                             )
6077                             admx_results = []
6078                             these_admx_search_results = admx_policy_definitions.xpath(
6079                                 policy_search_string,
6080                                 namespaces=adml_search_result.nsmap,
6081                             )
6082                             if not these_admx_search_results:
6083                                 log.trace(
6084                                     "No admx was found for the adml entry %s, it will"
6085                                     " be removed",
6086                                     display_name_searchval,
6087                                 )
6088                                 adml_to_remove.append(adml_search_result)
6089                             for search_result in these_admx_search_results:
6090                                 log.trace("policy_name == %s", policy_name)
6091                                 this_hierarchy = _build_parent_list(
6092                                     policy_definition=search_result,
6093                                     return_full_policy_names=True,
6094                                     adml_language=adml_language,
6095                                 )
6096                                 this_hierarchy.reverse()
6097                                 if hierarchy != this_hierarchy:
6098                                     log.trace(
6099                                         "hierarchy %s does not match this item's"
6100                                         " hierarchy of %s",
6101                                         hierarchy,
6102                                         this_hierarchy,
6103                                     )
6104                                     if len(these_admx_search_results) == 1:
6105                                         log.trace(
6106                                             "only 1 admx was found and it does not "
6107                                             "match this adml, it is safe to remove "
6108                                             "from the list"
6109                                         )
6110                                         adml_to_remove.append(adml_search_result)
6111                                 else:
6112                                     log.trace(
6113                                         "hierarchy %s matches item's hierarchy of %s",
6114                                         hierarchy,
6115                                         this_hierarchy,
6116                                     )
6117                                     log.trace(
6118                                         "search_result %s added to results",
6119                                         search_result,
6120                                     )
6121                                     admx_results.append(search_result)
6122                             if len(admx_results) == 1:
6123                                 admx_search_results.append(admx_results[0])
6124                         else:
6125                             display_name_searchval = "$({}.{})".format(
6126                                 adml_search_result.tag.split("}")[1],
6127                                 adml_search_result.attrib["id"],
6128                             )
6129                             these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
6130                                 admx_policy_definitions,
6131                                 display_name=display_name_searchval,
6132                                 registry_class=policy_class,
6133                             )
6134                             if not these_admx_search_results:
6135                                 adml_to_remove.append(adml_search_result)
6136             for adml in adml_to_remove:
6137                 if adml in adml_search_results:
6138                     adml_search_results.remove(adml)
6139             if len(adml_search_results) == 1 and multiple_adml_entries:
6140                 multiple_adml_entries = False
6141             for adml_search_result in adml_search_results:
6142                 log.trace(
6143                     "found an ADML entry matching the string! %s -- %s",
6144                     adml_search_result.tag,
6145                     adml_search_result.attrib,
6146                 )
6147                 display_name_searchval = "$({}.{})".format(
6148                     adml_search_result.tag.split("}")[1],
6149                     adml_search_result.attrib["id"],
6150                 )
6151                 log.trace("searching for displayName == %s", display_name_searchval)
6152                 if not admx_search_results:
6153                     log.trace(
6154                         "search for an admx entry matching display_name %s and"
6155                         " registry_class %s",
6156                         display_name_searchval,
6157                         policy_class,
6158                     )
6159                     admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
6160                         admx_policy_definitions,
6161                         display_name=display_name_searchval,
6162                         registry_class=policy_class,
6163                     )
6164                 if admx_search_results:
6165                     log.trace(
6166                         "processing admx_search_results of %s", admx_search_results
6167                     )
6168                     log.trace("multiple_adml_entries is %s", multiple_adml_entries)
6169                     if (
6170                         len(admx_search_results) == 1 or hierarchy
6171                     ) and not multiple_adml_entries:
6172                         found = False
6173                         for search_result in admx_search_results:
6174                             found = False
6175                             if hierarchy:
6176                                 this_hierarchy = _build_parent_list(
6177                                     policy_definition=search_result,
6178                                     return_full_policy_names=True,
6179                                     adml_language=adml_language,
6180                                 )
6181                                 this_hierarchy.reverse()
6182                                 log.trace("testing %s == %s", hierarchy, this_hierarchy)
6183                                 if hierarchy == this_hierarchy:
6184                                     found = True
6185                             else:
6186                                 found = True
6187                             if found:
6188                                 log.trace(
6189                                     "found the ADMX policy matching "
6190                                     "the display name %s -- %s",
6191                                     search_result,
6192                                     policy_name,
6193                                 )
6194                                 if "name" in search_result.attrib:
6195                                     policy_display_name = _getFullPolicyName(
6196                                         policy_item=search_result,
6197                                         policy_name=search_result.attrib["name"],
6198                                         return_full_policy_names=True,
6199                                         adml_language=adml_language,
6200                                     )
6201                                     policy_aliases.append(policy_display_name)
6202                                     policy_aliases.append(search_result.attrib["name"])
6203                                     full_path_list = _build_parent_list(
6204                                         policy_definition=search_result,
6205                                         return_full_policy_names=True,
6206                                         adml_language=adml_language,
6207                                     )
6208                                     full_path_list.reverse()
6209                                     full_path_list.append(policy_display_name)
6210                                     policy_aliases.append("\\".join(full_path_list))
6211                                     return True, search_result, policy_aliases, None
6212                                 else:
6213                                     msg = (
6214                                         "ADMX policy with the display name {} does not"
6215                                         "have the required name attribute"
6216                                     )
6217                                     msg = msg.format(policy_name)
6218                                     return False, None, [], msg
6219                         if not found:
6220                             msg = "Unable to correlate {} to any policy".format(
6221                                 hierarchy_policy_name
6222                             )
6223                             return False, None, [], msg
6224                     else:
6225                         for possible_policy in admx_search_results:
6226                             this_parent_list = _build_parent_list(
6227                                 policy_definition=possible_policy,
6228                                 return_full_policy_names=True,
6229                                 adml_language=adml_language,
6230                             )
6231                             this_parent_list.reverse()
6232                             this_parent_list.append(policy_name)
6233                             if suggested_policies:
6234                                 suggested_policies = ", ".join(
6235                                     [suggested_policies, "\\".join(this_parent_list)]
6236                                 )
6237                             else:
6238                                 suggested_policies = "\\".join(this_parent_list)
6239             if suggested_policies:
6240                 msg = (
6241                     'ADML policy name "{}" is used as the display name for '
6242                     "multiple policies. These policies matched: {}. You can "
6243                     "utilize these long names to specify the correct policy"
6244                 )
6245                 return False, None, [], msg.format(policy_name, suggested_policies)
6246     return (
6247         False,
6248         None,
6249         [],
6250         "Unable to find {} policy {}".format(policy_class, policy_name),
6251     )
6252 def get_policy_info(policy_name, policy_class, adml_language="en-US"):
6253     r"""
6254     Returns information about a specified policy
6255     Args:
6256         policy_name (str):
6257             The name of the policy to lookup
6258         policy_class (str):
6259             The class of policy, i.e. machine, user, both
6260         adml_language (str):
6261             The ADML language to use for Administrative Template data lookup
6262     Returns:
6263         dict: Information about the specified policy
6264     CLI Example:
6265     .. code-block:: bash
6266         salt '*' lgpo.get_policy_info 'Maximum password age' machine
6267     You can use ``lgpo.get_policy_info`` to get all the possible names that
6268     could be used in a state file or from the command line (along with elements
6269     that need to be set/etc). The key is to match the text you see in the
6270     ``gpedit.msc`` gui exactly, including quotes around words or phrases. The
6271     "full path" style is really only needed when there are multiple policies
6272     that use the same base name. For example, ``Access data sources across
6273     domains`` exists in ~10 different paths. If you put that through
6274     ``get_policy_info`` you'll get back a message that it is used for multiple
6275     policies and you need to be more specific.
6276     CLI Example:
6277     .. code-block:: bash
6278         salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine
6279         local:
6280             ----------
6281             message:
6282             policy_aliases:
6283                 - Turn off the "Order Prints" picture task
6284                 - ShellRemoveOrderPrints_2
6285                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
6286             policy_class:
6287                 machine
6288             policy_elements:
6289             policy_found:
6290                 True
6291             policy_name:
6292                 ShellRemoveOrderPrints_2
6293             rights_assignment:
6294                 False
6295     Escaping can get tricky in cmd/Powershell. The following is an example of
6296     escaping in Powershell using backquotes:
6297     .. code-block:: bash
6298         PS&gt;salt-call --local lgpo.get_policy_info "Turn off the `\`"Order Prints`\`" picture task" machine
6299         local:
6300             ----------
6301             message:
6302             policy_aliases:
6303                 - Turn off the "Order Prints" picture task
6304                 - ShellRemoveOrderPrints_2
6305                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
6306             policy_class:
6307                 machine
6308             policy_elements:
6309             policy_found:
6310                 True
6311             policy_name:
6312                 Turn off the "Order Prints" picture task
6313             rights_assignment:
6314                 False
6315     This function can then be used to get the options available for specifying
6316     Group Policy Objects to be used in state files. Based on the above any of
6317     these *should* be usable:
6318     .. code-block:: bash
6319         internet_communications_settings:
6320           lgpo.set:
6321             - computer_policy:
6322                 Turn off the "Order Prints" picture task: Enabled
6323     .. code-block:: bash
6324         internet_communications_settings:
6325           lgpo.set:
6326             - computer_policy:
6327                 ShellRemoveOrderPrints_2: Enabled
6328     When using the full path, it might be a good idea to use single quotes
6329     around the path:
6330     .. code-block:: bash
6331         internet_communications_settings:
6332           lgpo.set:
6333             - computer_policy:
6334                 'System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task': 'Enabled'
6335     If you struggle to find the policy from ``get_policy_info`` using the name
6336     as you see in ``gpedit.msc``, the names such as "ShellRemoveOrderPrints_2"
6337     come from the ``.admx`` files. If you know nothing about ``.admx/.adml``
6338     relationships (ADML holds what you see in the GUI, ADMX holds the more
6339     technical details), then this may be a little bit too much info, but here is
6340     an example with the above policy using Powershell:
6341     .. code-block:: bash
6342         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.adml | Select-String "Order Prints"
6343         C:\windows\PolicyDefinitions\en-US\ICM.adml:152:      &lt;string id="ShellRemoveOrderPrints"&gt;Turn off the "Order Prints" picture task&lt;/string&gt;
6344         C:\windows\PolicyDefinitions\en-US\ICM.adml:153:      &lt;string id="ShellRemoveOrderPrints_Help"&gt;This policy setting specifies whether the "Order Prints Online" task is available from Picture Tasks in Windows folders.
6345         C:\windows\PolicyDefinitions\en-US\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.
6346         C:\windows\PolicyDefinitions\en-US\ICM.adml:157:If you enable this policy setting, the task "Order Prints Online" is removed from Picture Tasks in File Explorer folders.
6347     From this grep, we can see id "ShellRemoveOrderPrints" is the ID of the
6348     string used to describe this policy, then we search for it in the ADMX:
6349     .. code-block:: bash
6350         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.admx | Select-String "ShellRemoveOrderPrints"
6351         C:\windows\PolicyDefinitions\ICM.admx:661:    &lt;policy name="ShellRemoveOrderPrints_1" class="User" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
6352         C:\windows\PolicyDefinitions\ICM.admx:671:    &lt;policy name="ShellRemoveOrderPrints_2" class="Machine" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
6353     Now we have two to pick from. And if you notice the ``class="Machine"`` and
6354     ``class="User"`` (which details if it is a computer policy or user policy
6355     respectively) the ``ShellRemoveOrderPrints_2`` is the "short name" we could
6356     use to pass through ``get_policy_info`` to see what the module itself is
6357     expecting.
6358     Get a policy value
6359     Args:
6360         policy_class (str):
6361             Some policies are both user and computer, by default all policies
6362             will be pulled, but this can be used to retrieve only a specific
6363             policy class User/USER/user = retrieve user policies
6364             Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve
6365             machine/computer policies
6366         return_full_policy_names (bool):
6367             True/False to return the policy name as it is seen in the
6368             ``gpedit.msc`` GUI or to only return the policy key/id.
6369         hierarchical_return (bool):
6370             True/False to return the policy data in the hierarchy as seen in the
6371             ``gpedit.msc`` GUI. The default of False will return data split only
6372             into User/Computer configuration sections
6373         adml_language (str):
6374             The ADML language to use for processing display/descriptive names
6375             and enumeration values of ADMX template data, defaults to en-US
6376         return_not_configured (bool):
6377             Include Administrative Template policies that are 'Not Configured'
6378             in the return data
6379     Returns:
6380         dict: A dictionary containing the policy values for the specified class
6381     CLI Example:
6382     .. code-block:: bash
6383         salt '*' lgpo.get machine return_full_policy_names=True
6384     if policy_class is None or policy_class<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.lower() == "both":
6385         policy_class = _policydata.policies.keys()
6386     elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:
6387         msg = (
6388             "The policy_class {} is not an available policy class, please "</b></font>
6389             "use one of the following: {}, Both"
6390         )
6391         raise SaltInvocationError(
6392             msg.format(policy_class, ", ".join(_policydata.policies.keys()))
6393         )
6394     else:
6395         policy_class = [policy_class.title()]
6396     for p_class in policy_class:
6397         this_class_policy_names = _policydata.policies[p_class]["policies"]
6398         class_vals = {}
6399         for policy_name in this_class_policy_names:
6400             _pol = None
6401             if policy_name in _policydata.policies[p_class]["policies"]:
6402                 _pol = _policydata.policies[p_class]["policies"][policy_name]
6403             else:
6404                 for policy in _policydata.policies[p_class]["policies"]:
6405                     _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
6406                     if _p == policy_name:
6407                         _pol = _policydata.policies[p_class]["policies"][policy]
6408                         policy_name = policy
6409                 if _pol is None:
6410                     for policy in _policydata.policies[p_class]["policies"]:
6411                         _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
6412                         if _p.lower() == policy_name.lower():
6413                             _pol = _policydata.policies[p_class]["policies"][policy]
6414                             policy_name = policy
6415             if _pol:
6416                 vals_key_name = policy_name
6417                 class_vals[policy_name] = _get_policy_info_setting(_pol)
6418                 if return_full_policy_names:
6419                     class_vals[_pol["Policy"]] = class_vals.pop(policy_name)
6420                     vals_key_name = _pol["Policy"]
6421                 if hierarchical_return:
6422                     if "lgpo_section" in _pol:
6423                         firstItem = True
6424                         tdict = {}
6425                         for level in reversed(_pol["lgpo_section"]):
6426                             newdict = {}
6427                             if firstItem:
6428                                 newdict[level] = {
6429                                     vals_key_name: class_vals.pop(vals_key_name)
6430                                 }
6431                                 firstItem = False
6432                             else:
6433                                 newdict[level] = tdict
6434                             tdict = newdict
6435                         if tdict:
6436                             class_vals = dictupdate.update(class_vals, tdict)
6437             else:
6438                 raise CommandExecutionError(
6439                     "The specified policy {} is not currently available "
6440                     "to be configured via this module".format(policy_name)
6441                 )
6442         class_vals = dictupdate.update(
6443             class_vals,
6444             _checkAllAdmxPolicies(
6445                 policy_class=p_class,
6446                 adml_language=adml_language,
6447                 return_full_policy_names=return_full_policy_names,
6448                 hierarchical_return=hierarchical_return,
6449                 return_not_configured=return_not_configured,
6450             ),
6451         )
6452         if _policydata.policies[p_class]["lgpo_section"] not in class_vals:
6453             temp_dict = {_policydata.policies[p_class]["lgpo_section"]: class_vals}
6454             class_vals = temp_dict
6455         vals = dictupdate.update(vals, class_vals)
6456     return vals
6457 def _get_policy_info_setting(policy_definition):
6458     if "Registry" in policy_definition:
6459         value = __utils__["reg.read_value"](
6460             policy_definition["Registry"]["Hive"],
6461             policy_definition["Registry"]["Path"],
6462             policy_definition["Registry"]["Value"],
6463         )["vdata"]
6464         log.trace(
6465             "Value %r found for Regisry policy %s", value, policy_definition["Policy"]
6466         )
6467     elif "Secedit" in policy_definition:
6468         value = _get_secedit_value(option=policy_definition["Secedit"]["Option"])
6469         log.trace(
6470             "Value %r found for Secedit policy %s", value, policy_definition["Policy"]
6471         )
6472     elif "NetSH" in policy_definition:
6473         value = _get_netsh_value(
6474             profile=policy_definition["NetSH"]["Profile"],
6475             option=policy_definition["NetSH"]["Option"],
6476         )
6477         log.trace(
6478             "Value %r found for NetSH policy %s", value, policy_definition["Policy"]
6479         )
6480     elif "AdvAudit" in policy_definition:
6481         value = _get_advaudit_value(option=policy_definition["AdvAudit"]["Option"])
6482         log.trace(
6483             "Value %r found for AuditPol policy %s", value, policy_definition["Policy"]
6484         )
6485     elif "NetUserModal" in policy_definition:
6486         modal_return = win32net.NetUserModalsGet(
6487             None, policy_definition["NetUserModal"]["Modal"]
6488         )
6489         value = modal_return[policy_definition["NetUserModal"]["Option"]]
6490         log.trace(
6491             "Value %r found for NetUserModal policy %s",
6492             value,
6493             policy_definition["Policy"],
6494         )
6495     elif "LsaRights" in policy_definition:
6496         value = _getRightsAssignments(policy_definition["LsaRights"]["Option"])
6497         log.trace(
6498             "Value %r found for LSARights policy %s", value, policy_definition["Policy"]
6499         )
6500     elif "ScriptIni" in policy_definition:
6501         value = _getScriptSettingsFromIniFile(policy_definition)
6502         log.trace(
6503             "Value %r found for ScriptIni policy %s", value, policy_definition["Policy"]
6504         )
6505     else:
6506         raise CommandExecutionError(
6507             "Unknown or missing mechanism in policy_definition\n{}".format(
6508                 policy_definition
6509             )
6510         )
6511     value = _transform_value(
6512         value=value, policy=policy_definition, transform_type="Get"
6513     )
6514     return value
6515 def _get_policy_adm_setting(
6516     admx_policy,
6517     policy_class,
6518     adml_language="en-US",
6519     return_full_policy_names=False,
6520     hierarchical_return=False,
6521 ):
6522     this_key = admx_policy.attrib.get("key", None)
6523     this_policy_name = admx_policy.attrib.get("name", None)
6524     if this_key is None or this_policy_name is None:
6525         raise CommandExecutionError(
6526             'Policy is missing the required "key" or "name" attribute:\n{}'.format(
6527                 admx_policy.attrib
6528             )
6529         )
6530     this_value_name = admx_policy.attrib.get("valueName", None)
6531     this_policy_setting = "Not Configured"
6532     this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]
6533     element_only_enabled_disabled = True
6534     explicit_enable_disable_value_setting = False
6535     policy_data = _policy_info()
6536     policy_file_data = _read_regpol_file(
6537         policy_data.admx_registry_classes[policy_class]["policy_path"]
6538     )
6539     adml_policy_resources = _get_policy_resources(language=adml_language)
6540     policy_vals = {}
6541     if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
6542         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
6543             element_only_enabled_disabled = False
6544             explicit_enable_disable_value_setting = True
6545             if _checkValueItemParent(
6546                 policy_element=admx_policy,
6547                 policy_name=this_policy_name,
6548                 policy_key=this_key,
6549                 policy_valueName=this_value_name,
6550                 xpath_object=ENABLED_VALUE_XPATH,
6551                 policy_file_data=policy_file_data,
6552             ):
6553                 log.trace(
6554                     "%s is enabled by detected ENABLED_VALUE_XPATH", this_policy_name
6555                 )
6556                 this_policy_setting = "Enabled"
6557                 policy_vals.setdefault(this_policy_namespace, {})[
6558                     this_policy_name
6559                 ] = this_policy_setting
6560     if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
6561         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6562             element_only_enabled_disabled = False
6563             explicit_enable_disable_value_setting = True
6564             if _checkValueItemParent(
6565                 policy_element=admx_policy,
6566                 policy_name=this_policy_name,
6567                 policy_key=this_key,
6568                 policy_valueName=this_value_name,
6569                 xpath_object=DISABLED_VALUE_XPATH,
6570                 policy_file_data=policy_file_data,
6571             ):
6572                 log.trace(
6573                     "%s is disabled by detected DISABLED_VALUE_XPATH", this_policy_name
6574                 )
6575                 this_policy_setting = "Disabled"
6576                 policy_vals.setdefault(this_policy_namespace, {})[
6577                     this_policy_name
6578                 ] = this_policy_setting
6579     if ENABLED_LIST_XPATH(admx_policy):
6580         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
6581             element_only_enabled_disabled = False
6582             explicit_enable_disable_value_setting = True
6583             if _checkListItem(
6584                 policy_element=admx_policy,
6585                 policy_name=this_policy_name,
6586                 policy_key=this_key,
6587                 xpath_object=ENABLED_LIST_XPATH,
6588                 policy_file_data=policy_file_data,
6589             ):
6590                 log.trace(
6591                     "%s is enabled by detected ENABLED_LIST_XPATH", this_policy_name
6592                 )
6593                 this_policy_setting = "Enabled"
6594                 policy_vals.setdefault(this_policy_namespace, {})[
6595                     this_policy_name
6596                 ] = this_policy_setting
6597     if DISABLED_LIST_XPATH(admx_policy):
6598         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6599             element_only_enabled_disabled = False
6600             explicit_enable_disable_value_setting = True
6601             if _checkListItem(
6602                 policy_element=admx_policy,
6603                 policy_name=this_policy_name,
6604                 policy_key=this_key,
6605                 xpath_object=DISABLED_LIST_XPATH,
6606                 policy_file_data=policy_file_data,
6607             ):
6608                 log.trace(
6609                     "%s is disabled by detected DISABLED_LIST_XPATH", this_policy_name
6610                 )
6611                 this_policy_setting = "Disabled"
6612                 policy_vals.setdefault(this_policy_namespace, {})[
6613                     this_policy_name
6614                 ] = this_policy_setting
6615     if not explicit_enable_disable_value_setting and this_value_name:
6616         if _regexSearchRegPolData(
6617             re.escape(
6618                 _buildKnownDataSearchString(
6619                     reg_key=this_key,
6620                     reg_valueName=this_value_name,
6621                     reg_vtype="REG_DWORD",
6622                     reg_data="1",
6623                 )
6624             ),
6625             policy_file_data,
6626         ):
6627             log.trace(
6628                 "%s is enabled by no explicit enable/disable list or value",
6629                 this_policy_name,
6630             )
6631             this_policy_setting = "Enabled"
6632             policy_vals.setdefault(this_policy_namespace, {})[
6633                 this_policy_name
6634             ] = this_policy_setting
6635         elif _regexSearchRegPolData(
6636             re.escape(
6637                 _buildKnownDataSearchString(
6638                     reg_key=this_key,
6639                     reg_valueName=this_value_name,
6640                     reg_vtype="REG_DWORD",
6641                     reg_data=None,
6642                     check_deleted=True,
6643                 )
6644             ),
6645             policy_file_data,
6646         ):
6647             log.trace(
6648                 "%s is disabled by no explicit enable/disable list or value",
6649                 this_policy_name,
6650             )
6651             this_policy_setting = "Disabled"
6652             policy_vals.setdefault(this_policy_namespace, {})[
6653                 this_policy_name
6654             ] = this_policy_setting
6655     full_names = {}
6656     hierarchy = {}
6657     if ELEMENTS_XPATH(admx_policy):
6658         if element_only_enabled_disabled or this_policy_setting == "Enabled":
6659             required_elements = {}
6660             configured_elements = {}
6661             policy_disabled_elements = 0
6662             for elements_item in ELEMENTS_XPATH(admx_policy):
6663                 for child_item in elements_item:
6664                     this_element_name = _getFullPolicyName(
6665                         policy_item=child_item,
6666                         policy_name=child_item.attrib["id"],
6667                         return_full_policy_names=return_full_policy_names,
6668                         adml_language=adml_language,
6669                     )
6670                     required_elements[this_element_name] = None
6671                     child_key = child_item.attrib.get("key", this_key)
6672                     child_value_name = child_item.attrib.get(
6673                         "valueName", this_value_name
6674                     )
6675                     if etree.QName(child_item).localname == "boolean":
6676                         if child_item is not None:
6677                             if (
6678                                 TRUE_VALUE_XPATH(child_item)
6679                                 and this_element_name not in configured_elements
6680                             ):
6681                                 if _checkValueItemParent(
6682                                     policy_element=child_item,
6683                                     policy_name=this_policy_name,
6684                                     policy_key=child_key,
6685                                     policy_valueName=child_value_name,
6686                                     xpath_object=TRUE_VALUE_XPATH,
6687                                     policy_file_data=policy_file_data,
6688                                 ):
6689                                     configured_elements[this_element_name] = True
6690                                     log.trace(
6691                                         "element %s is configured true",
6692                                         child_item.attrib["id"],
6693                                     )
6694                             if (
6695                                 FALSE_VALUE_XPATH(child_item)
6696                                 and this_element_name not in configured_elements
6697                             ):
6698                                 if _checkValueItemParent(
6699                                     policy_element=child_item,
6700                                     policy_name=this_policy_name,
6701                                     policy_key=child_key,
6702                                     policy_valueName=child_value_name,
6703                                     xpath_object=FALSE_VALUE_XPATH,
6704                                     policy_file_data=policy_file_data,
6705                                 ):
6706                                     configured_elements[this_element_name] = False
6707                                     policy_disabled_elements = (
6708                                         policy_disabled_elements + 1
6709                                     )
6710                                     log.trace(
6711                                         "element %s is configured false",
6712                                         child_item.attrib["id"],
6713                                     )
6714                             if (
6715                                 TRUE_LIST_XPATH(child_item)
6716                                 and this_element_name not in configured_elements
6717                             ):
6718                                 log.trace("checking trueList")
6719                                 if _checkListItem(
6720                                     policy_element=child_item,
6721                                     policy_name=this_policy_name,
6722                                     policy_key=this_key,
6723                                     xpath_object=TRUE_LIST_XPATH,
6724                                     policy_file_data=policy_file_data,
6725                                 ):
6726                                     configured_elements[this_element_name] = True
6727                                     log.trace(
6728                                         "element %s is configured true",
6729                                         child_item.attrib["id"],
6730                                     )
6731                             if (
6732                                 FALSE_LIST_XPATH(child_item)
6733                                 and this_element_name not in configured_elements
6734                             ):
6735                                 log.trace("checking falseList")
6736                                 if _checkListItem(
6737                                     policy_element=child_item,
6738                                     policy_name=this_policy_name,
6739                                     policy_key=this_key,
6740                                     xpath_object=FALSE_LIST_XPATH,
6741                                     policy_file_data=policy_file_data,
6742                                 ):
6743                                     configured_elements[this_element_name] = False
6744                                     policy_disabled_elements = (
6745                                         policy_disabled_elements + 1
6746                                     )
6747                                     log.trace(
6748                                         "element %s is configured false",
6749                                         child_item.attrib["id"],
6750                                     )
6751                         else:
6752                             if _regexSearchRegPolData(
6753                                 re.escape(
6754                                     _processValueItem(
6755                                         element=child_item,
6756                                         reg_key=child_key,
6757                                         reg_valuename=child_value_name,
6758                                         policy=admx_policy,
6759                                         parent_element=elements_item,
6760                                         check_deleted=True,
6761                                     )
6762                                 ),
6763                                 policy_file_data,
6764                             ):
6765                                 configured_elements[this_element_name] = False
6766                                 policy_disabled_elements = policy_disabled_elements + 1
6767                                 log.trace(
6768                                     "element %s is configured false",
6769                                     child_item.attrib["id"],
6770                                 )
6771                             elif _regexSearchRegPolData(
6772                                 re.escape(
6773                                     _processValueItem(
6774                                         element=child_item,
6775                                         reg_key=child_key,
6776                                         reg_valuename=child_value_name,
6777                                         policy=admx_policy,
6778                                         parent_element=elements_item,
6779                                         check_deleted=False,
6780                                     )
6781                                 ),
6782                                 policy_file_data,
6783                             ):
6784                                 configured_elements[this_element_name] = True
6785                                 log.trace(
6786                                     "element %s is configured true",
6787                                     child_item.attrib["id"],
6788                                 )
6789                     elif etree.QName(child_item).localname in [
6790                         "decimal",
6791                         "text",
6792                         "longDecimal",
6793                         "multiText",
6794                     ]:
6795                         if _regexSearchRegPolData(
6796                             re.escape(
6797                                 _processValueItem(
6798                                     element=child_item,
6799                                     reg_key=child_key,
6800                                     reg_valuename=child_value_name,
6801                                     policy=admx_policy,
6802                                     parent_element=elements_item,
6803                                     check_deleted=True,
6804                                 )
6805                             ),
6806                             policy_file_data,
6807                         ):
6808                             configured_elements[this_element_name] = "Disabled"
6809                             policy_disabled_elements = policy_disabled_elements + 1
6810                             log.trace("element %s is disabled", child_item.attrib["id"])
6811                         elif _regexSearchRegPolData(
6812                             re.escape(
6813                                 _processValueItem(
6814                                     element=child_item,
6815                                     reg_key=child_key,
6816                                     reg_valuename=child_value_name,
6817                                     policy=admx_policy,
6818                                     parent_element=elements_item,
6819                                     check_deleted=False,
6820                                 )
6821                             ),
6822                             policy_data=policy_file_data,
6823                         ):
6824                             configured_value = _getDataFromRegPolData(
6825                                 _processValueItem(
6826                                     element=child_item,
6827                                     reg_key=child_key,
6828                                     reg_valuename=child_value_name,
6829                                     policy=admx_policy,
6830                                     parent_element=elements_item,
6831                                     check_deleted=False,
6832                                 ),
6833                                 policy_data=policy_file_data,
6834                             )
6835                             configured_elements[this_element_name] = configured_value
6836                             log.trace(
6837                                 "element %s is enabled, value == %s",
6838                                 child_item.attrib["id"],
6839                                 configured_value,
6840                             )
6841                     elif etree.QName(child_item).localname == "enum":
6842                         if _regexSearchRegPolData(
6843                             re.escape(
6844                                 _processValueItem(
6845                                     element=child_item,
6846                                     reg_key=child_key,
6847                                     reg_valuename=child_value_name,
6848                                     policy=admx_policy,
6849                                     parent_element=elements_item,
6850                                     check_deleted=True,
6851                                 )
6852                             ),
6853                             policy_file_data,
6854                         ):
6855                             log.trace(
6856                                 "enum element %s is disabled", child_item.attrib["id"]
6857                             )
6858                             configured_elements[this_element_name] = "Disabled"
6859                             policy_disabled_elements = policy_disabled_elements + 1
6860                         else:
6861                             for enum_item in child_item:
6862                                 if _checkValueItemParent(
6863                                     policy_element=enum_item,
6864                                     policy_name=child_item.attrib["id"],
6865                                     policy_key=child_key,
6866                                     policy_valueName=child_value_name,
6867                                     xpath_object=VALUE_XPATH,
6868                                     policy_file_data=policy_file_data,
6869                                 ):
6870                                     if VALUE_LIST_XPATH(enum_item):
6871                                         log.trace("enum item has a valueList")
6872                                         if _checkListItem(
6873                                             policy_element=enum_item,
6874                                             policy_name=this_policy_name,
6875                                             policy_key=child_key,
6876                                             xpath_object=VALUE_LIST_XPATH,
6877                                             policy_file_data=policy_file_data,
6878                                         ):
6879                                             log.trace(
6880                                                 "all valueList items exist in file"
6881                                             )
6882                                             configured_elements[
6883                                                 this_element_name
6884                                             ] = _getAdmlDisplayName(
6885                                                 adml_xml_data=adml_policy_resources,
6886                                                 display_name=enum_item.attrib[
6887                                                     "displayName"
6888                                                 ],
6889                                             )
6890                                             break
6891                                     else:
6892                                         configured_elements[
6893                                             this_element_name
6894                                         ] = _getAdmlDisplayName(
6895                                             adml_xml_data=adml_policy_resources,
6896                                             display_name=enum_item.attrib[
6897                                                 "displayName"
6898                                             ],
6899                                         )
6900                                         break
6901                     elif etree.QName(child_item).localname == "list":
6902                         return_value_name = False
6903                         if (
6904                             "explicitValue" in child_item.attrib
6905                             and child_item.attrib["explicitValue"].lower() == "true"
6906                         ):
6907                             log.trace("explicitValue list, we will return value names")
6908                             return_value_name = True
6909                         regex_str = [
6910                             r"(?!\*",
6911                             r"\*",
6912                             "D",
6913                             "e",
6914                             "l",
6915                             "V",
6916                             "a",
6917                             "l",
6918                             "s",
6919                             r"\.",
6920                             ")",
6921                         ]
6922                         delvals_regex = "\x00".join(regex_str)
6923                         delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)
6924                         if _regexSearchRegPolData(
6925                             re.escape(
6926                                 _processValueItem(
6927                                     element=child_item,
6928                                     reg_key=child_key,
6929                                     reg_valuename=child_value_name,
6930                                     policy=admx_policy,
6931                                     parent_element=elements_item,
6932                                     check_deleted=False,
6933                                 )
6934                             )
6935                             + delvals_regex,
6936                             policy_data=policy_file_data,
6937                         ):
6938                             configured_value = _getDataFromRegPolData(
6939                                 _processValueItem(
6940                                     element=child_item,
6941                                     reg_key=child_key,
6942                                     reg_valuename=child_value_name,
6943                                     policy=admx_policy,
6944                                     parent_element=elements_item,
6945                                     check_deleted=False,
6946                                 ),
6947                                 policy_data=policy_file_data,
6948                                 return_value_name=return_value_name,
6949                             )
6950                             configured_elements[this_element_name] = configured_value
6951                             log.trace(
6952                                 "element %s is enabled values: %s",
6953                                 child_item.attrib["id"],
6954                                 configured_value,
6955                             )
6956                         elif _regexSearchRegPolData(
6957                             re.escape(
6958                                 _processValueItem(
6959                                     element=child_item,
6960                                     reg_key=child_key,
6961                                     reg_valuename=child_value_name,
6962                                     policy=admx_policy,
6963                                     parent_element=elements_item,
6964                                     check_deleted=True,
6965                                 )
6966                             ),
6967                             policy_file_data,
6968                         ):
6969                             configured_elements[this_element_name] = "Disabled"
6970                             policy_disabled_elements = policy_disabled_elements + 1
6971 <a name="2"></a>                            log.trace("element %s is disabled", child_item.attrib["id"])
6972             if element_only_enabled_disabled:
6973                 if 0 &lt; len(required_elements.keys()) == len(configured_elements.keys()):
6974                     if policy_disabled_elements == len<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(required_elements.keys()):
6975                         log.trace(
6976                             "%s is disabled by all enum elements", this_policy_name
6977                         )
6978                         policy_vals.setdefault(this_policy_namespace, {})[
6979                             this_policy_name
6980                         ] = "Disabled"
6981                     else:
6982                         log.trace("%s is enabled by enum elements", this_policy_name)
6983                         policy_vals.setdefault(this_policy_namespace, {})[</b></font>
6984                             this_policy_name
6985                         ] = configured_elements
6986                 else:
6987                     policy_vals.setdefault(this_policy_namespace, {})[
6988                         this_policy_name
6989                     ] = this_policy_setting
6990             else:
6991                 if this_policy_setting == "Enabled":
6992                     policy_vals.setdefault(this_policy_namespace, {})[
6993                         this_policy_name
6994                     ] = configured_elements
6995         else:
6996             policy_vals.setdefault(this_policy_namespace, {})[
6997                 this_policy_name
6998             ] = this_policy_setting
6999     else:
7000         policy_vals.setdefault(this_policy_namespace, {})[
7001             this_policy_name
7002         ] = this_policy_setting
7003     if (
7004         return_full_policy_names
7005         and this_policy_namespace in policy_vals
7006         and this_policy_name in policy_vals[this_policy_namespace]
7007     ):
7008         full_names.setdefault(this_policy_namespace, {})
7009         full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(
7010             policy_item=admx_policy,
7011             policy_name=admx_policy.attrib["name"],
7012             return_full_policy_names=return_full_policy_names,
7013             adml_language=adml_language,
7014         )
7015         if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:
7016             full_name = full_names[this_policy_namespace][this_policy_name]
7017             setting = policy_vals[this_policy_namespace][this_policy_name].pop(
7018                 this_policy_name
7019             )
7020             policy_vals[this_policy_namespace][this_policy_name][full_name] = setting
7021     if (
7022         this_policy_namespace in policy_vals
7023         and this_policy_name in policy_vals[this_policy_namespace]
7024     ):
7025         hierarchy.setdefault(this_policy_namespace, {})[
7026             this_policy_name
7027         ] = _build_parent_list(
7028             policy_definition=admx_policy,
7029             return_full_policy_names=return_full_policy_names,
7030             adml_language=adml_language,
7031         )
7032     if policy_vals and return_full_policy_names and not hierarchical_return:
7033         log.debug("Compiling non hierarchical return...")
7034         unpathed_dict = {}
7035         pathed_dict = {}
7036         for policy_namespace in list(policy_vals):
7037             for policy_item in list(policy_vals[policy_namespace]):
7038                 full_name = full_names[policy_namespace][policy_item]
7039                 if full_name in policy_vals[policy_namespace]:
7040                     full_path_list = hierarchy[policy_namespace][policy_item]
7041                     full_path_list.reverse()
7042                     full_path_list.append(full_names[policy_namespace][policy_item])
7043                     policy_vals["\\".join(full_path_list)] = policy_vals[
7044                         policy_namespace
7045                     ].pop(policy_item)
7046                     pathed_dict[full_name] = True
7047                 else:
7048                     policy_vals[policy_namespace][full_name] = policy_vals[
7049                         policy_namespace
7050                     ].pop(policy_item)
7051                     unpathed_dict.setdefault(policy_namespace, {})[
7052                         full_name
7053                     ] = policy_item
7054             for path_needed in unpathed_dict[policy_namespace]:
7055                 full_path_list = hierarchy[policy_namespace][
7056                     unpathed_dict[policy_namespace][path_needed]
7057                 ]
7058                 full_path_list.reverse()
7059                 full_path_list.append(path_needed)
7060                 log.trace("full_path_list == %s", full_path_list)
7061                 policy_vals["\\".join(full_path_list)] = policy_vals[
7062                     policy_namespace
7063                 ].pop(path_needed)
7064     for policy_namespace in list(policy_vals):
7065         if policy_vals[policy_namespace] == {}:
7066             policy_vals.pop(policy_namespace)
7067         elif isinstance(policy_vals[policy_namespace], dict):
7068             if this_policy_namespace == policy_namespace and not hierarchical_return:
7069                 policy_vals.update(policy_vals[policy_namespace])
7070                 policy_vals.pop(policy_namespace)
7071     if policy_vals and hierarchical_return:
7072         if hierarchy:
7073             log.debug("Compiling hierarchical return...")
7074             for policy_namespace in hierarchy:
7075                 for hierarchy_item in hierarchy[policy_namespace]:
7076                     if hierarchy_item in policy_vals[policy_namespace]:
7077                         t_dict = {}
7078                         first_item = True
7079                         for item in hierarchy[policy_namespace][hierarchy_item]:
7080                             new_dict = {}
7081                             if first_item:
7082                                 h_policy_name = hierarchy_item
7083                                 if return_full_policy_names:
7084                                     h_policy_name = full_names[policy_namespace][
7085                                         hierarchy_item
7086                                     ]
7087                                 new_dict[item] = {
7088                                     h_policy_name: policy_vals[policy_namespace].pop(
7089                                         hierarchy_item
7090                                     )
7091                                 }
7092                                 first_item = False
7093                             else:
7094                                 new_dict[item] = t_dict
7095                             t_dict = new_dict
7096                         if t_dict:
7097                             policy_vals = dictupdate.update(policy_vals, t_dict)
7098                 if (
7099                     policy_namespace in policy_vals
7100                     and policy_vals[policy_namespace] == {}
7101                 ):
7102                     policy_vals.pop(policy_namespace)
7103         policy_vals = {
7104             policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
7105                 "Administrative Templates": policy_vals
7106             }
7107         }
7108     return policy_vals
7109 def get_policy(
7110     policy_name,
7111     policy_class,
7112     adml_language="en-US",
7113     return_value_only=True,
7114     return_full_policy_names=True,
7115     hierarchical_return=False,
7116 ):
7117     r"""
7118     Get the current settings for a single policy on the machine
7119     Args:
7120         policy_name (str):
7121             The name of the policy to retrieve. Can be the any of the names
7122             or alieses returned by ``lgpo.get_policy_info``
7123         policy_class (str):
7124             The policy class. Must be one of ``machine`` or ``user``
7125         adml_language (str):
7126             The language code for the adml file to use for localization. The
7127             default is ``en-US``
7128         return_value_only (bool):
7129             ``True`` will return only the value for the policy, without the
7130             name of the policy. ``return_full_policy_names`` and
7131             ``hierarchical_return`` will be ignored. Default is ``True``
7132         return_full_policy_names (bool):
7133             Returns the full policy name regardless of what was passed in
7134             ``policy_name``
7135             .. note::
7136                 This setting applies to sub-elements of the policy if they
7137                 exist. The value passed in ``policy_name`` will always be used
7138                 as the policy name when this setting is ``False``
7139         hierarchical_return (bool):
7140             Returns a hierarchical view of the policy showing its parents
7141     Returns:
7142         dict: A dictionary containing the policy settings
7143     CLI Example:
7144     .. code-block:: bash
7145         salt * lgpo.get_policy LockoutDuration machine
7146         salt * lgpo.get_policy AutoUpdateCfg machine
7147         salt * lgpo.get_policy "Account lockout duration" machine
7148         salt * lgpo.get_policy "Configure Automatic Updates" machine
7149         salt * lgpo.get_policy "Windows Components\Windows Update\Configure Automatic Updates" machine
7150     Set a single computer policy
7151     Args:
7152         name (str):
7153             The name of the policy to configure
7154         setting (str):
7155             The setting to configure the named policy with
7156         cumulative_rights_assignments (bool): Determine how user rights
7157             assignment policies are configured. If True, user right assignment
7158             specifications are simply added to the existing policy. If False,
7159             only the users specified will get the right (any existing will have
7160             the right revoked)
7161         adml_language (str): The language files to use for looking up
7162             Administrative Template policy data (i.e. how the policy is
7163             displayed in the GUI).  Defaults to 'en-US' (U.S. English).
7164     Returns:
7165         bool: True if successful, otherwise False
7166     CLI Example:
7167     .. code-block:: bash
7168         salt '*' lgpo.set_computer_policy LockoutDuration 1440
7169     Set a single user policy
7170     Args:
7171         name (str):
7172             The name of the policy to configure
7173         setting (str):
7174             The setting to configure the named policy with
7175         adml_language (str):
7176             The language files to use for looking up Administrative Template
7177             policy data (i.e. how the policy is displayed in the GUI). Defaults
7178             to 'en-US' (U.S. English).
7179     Returns:
7180         bool: True if successful, Otherwise False
7181     CLI Example:
7182     .. code-block:: bash
7183         salt '*' lgpo.set_user_policy "Control Panel\\Display\\Disable the Display Control Panel" Enabled
7184     Set a local server policy.
7185     Args:
7186         computer_policy (dict):
7187             A dictionary of "policyname: value" pairs of computer policies to
7188             set. 'value' should be how it is displayed in the gpedit GUI, i.e.
7189             if a setting can be 'Enabled'/'Disabled', then that should be passed
7190             Administrative Template data may require dicts within dicts, to
7191             specify each element of the Administrative Template policy.
7192             Administrative Templates policies are always cumulative.
7193             Policy names can be specified in a number of ways based on the type
7194             of policy:
7195                 Windows Settings Policies:
7196                     These policies can be specified using the GUI display name
7197                     or the key name from the _policy_info class in this module.
7198                     The GUI display name is also contained in the _policy_info
7199                     class in this module.
7200                 Administrative Template Policies:
7201                     These can be specified using the policy name as displayed in
7202                     the GUI (case sensitive). Some policies have the same name,
7203                     but a different location (for example, "Access data sources
7204                     across domains"). These can be differentiated by the "path"
7205                     in the GUI (for example, "Windows Components\\Internet
7206                     Explorer\\Internet Control Panel\\Security Page\\Internet
7207                     Zone\\Access data sources across domains").
7208                     Additionally, policies can be specified using the "name" and
7209                     "id" attributes from the ADMX files.
7210                     For Administrative Templates that have policy elements, each
7211                     element can be specified using the text string as seen in
7212                     the GUI or using the ID attribute from the ADMX file. Due to
7213                     the way some of the GUI text is laid out, some policy
7214                     element names could include descriptive text that appears
7215                     lbefore the policy element in the GUI.
7216                     Use the get_policy_info function for the policy name to view
7217                     the element ID/names that the module will accept.
7218         user_policy (dict):
7219             The same setup as the computer_policy, except with data to configure
7220             the local user policy.
7221         cumulative_rights_assignments (bool):
7222             Determine how user rights assignment policies are configured.
7223             If True, user right assignment specifications are simply added to
7224             the existing policy
7225             If False, only the users specified will get the right (any existing
7226             will have the right revoked)
7227         adml_language (str):
7228             The language files to use for looking up Administrative Template
7229             policy data (i.e. how the policy is displayed in the GUI). Defaults
7230             to 'en-US' (U.S. English).
7231     Returns:
7232         bool: True is successful, otherwise False
7233     CLI Example:
7234     .. code-block:: bash
7235         salt '*' lgpo.set computer_policy="{'LockoutDuration': 2, 'RestrictAnonymous': 'Enabled', 'AuditProcessTracking': 'Succes, Failure'}"
7236     """
7237     if computer_policy and not isinstance(computer_policy, dict):
7238         raise SaltInvocationError("computer_policy must be specified as a dict")
7239     if user_policy and not isinstance(user_policy, dict):
7240         raise SaltInvocationError("user_policy must be specified as a dict")
7241     policies = {}
7242     policies["User"] = user_policy
7243     policies["Machine"] = computer_policy
7244     if policies:
7245         adml_policy_resources = _get_policy_resources(language=adml_language)
7246         for p_class in policies:
7247             _secedits = {}
7248             _netshs = {}
7249             _advaudits = {}
7250             _modal_sets = {}
7251             _admTemplateData = {}
7252             _regedits = {}
7253             _lsarights = {}
7254             _policydata = _policy_info()
7255             if policies[p_class]:
7256                 for policy_name in policies[p_class]:
7257                     _pol = None
7258                     policy_key_name = policy_name
7259                     if policy_name in _policydata.policies[p_class]["policies"]:
7260                         _pol = _policydata.policies[p_class]["policies"][policy_name]
7261                     else:
7262                         for policy in _policydata.policies[p_class]["policies"]:
7263                             _p = _policydata.policies[p_class]["policies"][policy][
7264                                 "Policy"
7265                             ]
7266                             if _p == policy_name:
7267                                 _pol = _policydata.policies[p_class]["policies"][policy]
7268                                 policy_key_name = policy
7269                         if _pol is None:
7270                             for policy in _policydata.policies[p_class]["policies"]:
7271                                 _p = _policydata.policies[p_class]["policies"][policy][
7272                                     "Policy"
7273                                 ]
7274                                 if _p.lower() == policy_name.lower():
7275                                     _pol = _policydata.policies[p_class]["policies"][
7276                                         policy
7277                                     ]
7278                                     policy_key_name = policy
7279                     if _pol:
7280                         _value = _transform_value(
7281                             value=policies[p_class][policy_name],
7282                             policy=_policydata.policies[p_class]["policies"][
7283                                 policy_key_name
7284                             ],
7285                             transform_type="Put",
7286                         )
7287                         if not _validateSetting(
7288                             value=_value,
7289                             policy=_policydata.policies[p_class]["policies"][
7290                                 policy_key_name
7291                             ],
7292                         ):
7293                             raise SaltInvocationError(
7294                                 "The specified value {} is not an acceptable setting"
7295                                 " for policy {}.".format(
7296                                     policies[p_class][policy_name], policy_name
7297                                 )
7298                             )
7299                         if "Registry" in _pol:
7300                             log.trace("%s is a registry policy", policy_name)
7301                             _regedits[policy_name] = {"policy": _pol, "value": _value}
7302                         elif "Secedit" in _pol:
7303                             log.trace("%s is a Secedit policy", policy_name)
7304                             if _pol["Secedit"]["Section"] not in _secedits:
7305                                 _secedits[_pol["Secedit"]["Section"]] = []
7306                             _secedits[_pol["Secedit"]["Section"]].append(
7307                                 " ".join([_pol["Secedit"]["Option"], "=", str(_value)])
7308                             )
7309                         elif "NetSH" in _pol:
7310                             log.trace("%s is a NetSH policy", policy_name)
7311                             _netshs.setdefault(
7312                                 policy_name,
7313                                 {
7314                                     "profile": _pol["NetSH"]["Profile"],
7315                                     "section": _pol["NetSH"]["Section"],
7316                                     "option": _pol["NetSH"]["Option"],
7317                                     "value": str(_value),
7318                                 },
7319                             )
7320                         elif "AdvAudit" in _pol:
7321                             _advaudits.setdefault(
7322                                 policy_name,
7323                                 {
7324                                     "option": _pol["AdvAudit"]["Option"],
7325                                     "value": str(_value),
7326                                 },
7327                             )
7328                         elif "NetUserModal" in _pol:
7329                             log.trace("%s is a NetUserModal policy", policy_name)
7330                             if _pol["NetUserModal"]["Modal"] not in _modal_sets:
7331                                 _modal_sets[_pol["NetUserModal"]["Modal"]] = {}
7332                             _modal_sets[_pol["NetUserModal"]["Modal"]][
7333                                 _pol["NetUserModal"]["Option"]
7334                             ] = _value
7335                         elif "LsaRights" in _pol:
7336                             log.trace("%s is a LsaRights policy", policy_name)
7337                             _lsarights[policy_name] = {"policy": _pol, "value": _value}
7338                     else:
7339                         _value = policies[p_class][policy_name]
7340                         log.trace('searching for "%s" in admx data', policy_name)
7341                         (
7342                             success,
7343                             the_policy,
7344                             policy_name_list,
7345                             msg,
7346                         ) = _lookup_admin_template(
7347                             policy_name=policy_name,
7348                             policy_class=p_class,
7349                             adml_language=adml_language,
7350                         )
7351                         if success:
7352                             policy_name = the_policy.attrib["name"]
7353                             policy_namespace = the_policy.nsmap[the_policy.prefix]
7354                             if policy_namespace not in _admTemplateData:
7355                                 _admTemplateData[policy_namespace] = {}
7356                             _admTemplateData[policy_namespace][policy_name] = _value
7357                         else:
7358                             raise SaltInvocationError(msg)
7359                         if (
7360                             policy_namespace
7361                             and policy_name in _admTemplateData[policy_namespace]
7362                             and the_policy is not None
7363                         ):
7364                             log.trace(
7365                                 "setting == %s",
7366                                 str(
7367                                     _admTemplateData[policy_namespace][policy_name]
7368                                 ).lower(),
7369                             )
7370                             log.trace(
7371                                 str(
7372                                     _admTemplateData[policy_namespace][policy_name]
7373                                 ).lower()
7374                             )
7375                             if (
7376                                 str(
7377                                     _admTemplateData[policy_namespace][policy_name]
7378                                 ).lower()
7379                                 != "disabled"
7380                                 and str(
7381                                     _admTemplateData[policy_namespace][policy_name]
7382                                 ).lower()
7383                                 != "not configured"
7384                             ):
7385                                 if ELEMENTS_XPATH(the_policy):
7386                                     if isinstance(
7387                                         _admTemplateData[policy_namespace][policy_name],
7388                                         dict,
7389                                     ):
7390                                         for elements_item in ELEMENTS_XPATH(the_policy):
7391                                             for child_item in elements_item:
7392                                                 log.trace(
7393                                                     "checking element %s",
7394                                                     child_item.attrib["id"],
7395                                                 )
7396                                                 temp_element_name = None
7397                                                 this_element_name = _getFullPolicyName(
7398                                                     policy_item=child_item,
7399                                                     policy_name=child_item.attrib["id"],
7400                                                     return_full_policy_names=True,
7401                                                     adml_language=adml_language,
7402                                                 )
7403                                                 log.trace(
7404                                                     'id attribute == "%s" '
7405                                                     ' this_element_name == "%s"',
7406                                                     child_item.attrib["id"],
7407                                                     this_element_name,
7408                                                 )
7409                                                 if (
7410                                                     this_element_name
7411                                                     in _admTemplateData[
7412                                                         policy_namespace
7413                                                     ][policy_name]
7414                                                 ):
7415                                                     temp_element_name = (
7416                                                         this_element_name
7417                                                     )
7418                                                 elif (
7419                                                     child_item.attrib["id"]
7420                                                     in _admTemplateData[
7421                                                         policy_namespace
7422                                                     ][policy_name]
7423                                                 ):
7424                                                     temp_element_name = (
7425                                                         child_item.attrib["id"]
7426                                                     )
7427                                                 else:
7428                                                     raise SaltInvocationError(
7429                                                         'Element "{}" must be included'
7430                                                         " in the policy configuration"
7431                                                         " for policy {}".format(
7432                                                             this_element_name,
7433                                                             policy_name,
7434                                                         )
7435                                                     )
7436                                                 if (
7437                                                     "required" in child_item.attrib
7438                                                     and child_item.attrib[
7439                                                         "required"
7440                                                     ].lower()
7441                                                     == "true"
7442                                                 ):
7443                                                     if not _admTemplateData[
7444                                                         policy_namespace
7445                                                     ][policy_name][temp_element_name]:
7446                                                         raise SaltInvocationError(
7447                                                             'Element "{}" requires a value '
7448                                                             "to be specified".format(
7449                                                                 temp_element_name
7450                                                             )
7451                                                         )
7452                                                 if (
7453                                                     etree.QName(child_item).localname
7454                                                     == "boolean"
7455                                                 ):
7456                                                     if not isinstance(
7457                                                         _admTemplateData[
7458                                                             policy_namespace
7459                                                         ][policy_name][
7460                                                             temp_element_name
7461                                                         ],
7462                                                         bool,
7463                                                     ):
7464                                                         raise SaltInvocationError(
7465                                                             "Element {} requires a boolean "
7466                                                             "True or False".format(
7467                                                                 temp_element_name
7468                                                             )
7469                                                         )
7470                                                 elif (
7471                                                     etree.QName(child_item).localname
7472                                                     == "decimal"
7473                                                     or etree.QName(child_item).localname
7474                                                     == "longDecimal"
7475                                                 ):
7476                                                     min_val = 0
7477                                                     max_val = 9999
7478                                                     if "minValue" in child_item.attrib:
7479                                                         min_val = int(
7480                                                             child_item.attrib[
7481                                                                 "minValue"
7482                                                             ]
7483                                                         )
7484                                                     if "maxValue" in child_item.attrib:
7485                                                         max_val = int(
7486                                                             child_item.attrib[
7487                                                                 "maxValue"
7488                                                             ]
7489                                                         )
7490                                                     if (
7491                                                         int(
7492                                                             _admTemplateData[
7493                                                                 policy_namespace
7494                                                             ][policy_name][
7495                                                                 temp_element_name
7496                                                             ]
7497                                                         )
7498                                                         &lt; min_val
7499                                                         or int(
7500                                                             _admTemplateData[
7501                                                                 policy_namespace
7502                                                             ][policy_name][
7503                                                                 temp_element_name
7504                                                             ]
7505                                                         )
7506                                                         &gt; max_val
7507                                                     ):
7508                                                         raise SaltInvocationError(
7509                                                             'Element "{}" value must be between '
7510                                                             "{} and {}".format(
7511                                                                 temp_element_name,
7512                                                                 min_val,
7513                                                                 max_val,
7514                                                             )
7515                                                         )
7516                                                 elif (
7517                                                     etree.QName(child_item).localname
7518                                                     == "enum"
7519                                                 ):
7520                                                     found = False
7521                                                     for enum_item in child_item:
7522                                                         if (
7523                                                             _admTemplateData[
7524                                                                 policy_namespace
7525                                                             ][policy_name][
7526                                                                 temp_element_name
7527                                                             ]
7528                                                             == _getAdmlDisplayName(
7529                                                                 adml_policy_resources,
7530                                                                 enum_item.attrib[
7531                                                                     "displayName"
7532                                                                 ],
7533                                                             ).strip()
7534                                                         ):
7535                                                             found = True
7536                                                             break
7537                                                     if not found:
7538                                                         raise SaltInvocationError(
7539                                                             'Element "{}" does not have'
7540                                                             " a valid value".format(
7541                                                                 temp_element_name
7542                                                             )
7543                                                         )
7544                                                 elif (
7545                                                     etree.QName(child_item).localname
7546                                                     == "list"
7547                                                 ):
7548                                                     if (
7549                                                         "explicitValue"
7550                                                         in child_item.attrib
7551                                                         and child_item.attrib[
7552                                                             "explicitValue"
7553                                                         ].lower()
7554                                                         == "true"
7555                                                     ):
7556                                                         if not isinstance(
7557                                                             _admTemplateData[
7558                                                                 policy_namespace
7559                                                             ][policy_name][
7560                                                                 temp_element_name
7561                                                             ],
7562                                                             dict,
7563                                                         ):
7564                                                             raise SaltInvocationError(
7565                                                                 "Each list item of element "
7566                                                                 '"{}" requires a dict '
7567                                                                 "value".format(
7568                                                                     temp_element_name
7569                                                                 )
7570                                                             )
7571                                                     elif not isinstance(
7572                                                         _admTemplateData[
7573                                                             policy_namespace
7574                                                         ][policy_name][
7575                                                             temp_element_name
7576                                                         ],
7577                                                         list,
7578                                                     ):
7579                                                         raise SaltInvocationError(
7580                                                             'Element "{}" requires a'
7581                                                             " list value".format(
7582                                                                 temp_element_name
7583                                                             )
7584                                                         )
7585                                                 elif (
7586                                                     etree.QName(child_item).localname
7587                                                     == "multiText"
7588                                                 ):
7589                                                     if not isinstance(
7590                                                         _admTemplateData[
7591                                                             policy_namespace
7592                                                         ][policy_name][
7593                                                             temp_element_name
7594                                                         ],
7595                                                         list,
7596                                                     ):
7597                                                         raise SaltInvocationError(
7598                                                             'Element "{}" requires a'
7599                                                             " list value".format(
7600                                                                 temp_element_name
7601                                                             )
7602                                                         )
7603                                                 _admTemplateData[policy_namespace][
7604                                                     policy_name
7605                                                 ][
7606                                                     child_item.attrib["id"]
7607                                                 ] = _admTemplateData[
7608                                                     policy_namespace
7609                                                 ][
7610                                                     policy_name
7611                                                 ].pop(
7612                                                     temp_element_name
7613                                                 )
7614                                     else:
7615                                         raise SaltInvocationError(
7616                                             'The policy "{}" has elements which must be'
7617                                             " configured".format(policy_name)
7618                                         )
7619                                 else:
7620                                     if (
7621                                         str(
7622                                             _admTemplateData[policy_namespace][
7623                                                 policy_name
7624                                             ]
7625                                         ).lower()
7626                                         != "enabled"
7627                                     ):
7628                                         raise SaltInvocationError(
7629                                             'The policy {} must either be "Enabled", '
7630                                             '"Disabled", or "Not Configured"'.format(
7631                                                 policy_name
7632                                             )
7633                                         )
7634                 if _regedits:
7635                     for regedit in _regedits:
7636                         log.trace("%s is a Registry policy", regedit)
7637                         if (
7638                             _regedits[regedit]["value"] is not None
7639                             and _regedits[regedit]["value"] != "(value not set)"
7640                         ):
7641                             _ret = __utils__["reg.set_value"](
7642                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
7643                                 _regedits[regedit]["policy"]["Registry"]["Path"],
7644                                 _regedits[regedit]["policy"]["Registry"]["Value"],
7645                                 _regedits[regedit]["value"],
7646                                 _regedits[regedit]["policy"]["Registry"]["Type"],
7647                             )
7648                         else:
7649                             _ret = __utils__["reg.read_value"](
7650                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
7651                                 _regedits[regedit]["policy"]["Registry"]["Path"],
7652                                 _regedits[regedit]["policy"]["Registry"]["Value"],
7653                             )
7654                             if _ret["success"] and _ret["vdata"] != "(value not set)":
7655                                 _ret = __utils__["reg.delete_value"](
7656                                     _regedits[regedit]["policy"]["Registry"]["Hive"],
7657                                     _regedits[regedit]["policy"]["Registry"]["Path"],
7658                                     _regedits[regedit]["policy"]["Registry"]["Value"],
7659                                 )
7660                         if not _ret:
7661                             raise CommandExecutionError(
7662                                 "Error while attempting to set policy {} via the"
7663                                 " registry.  Some changes may not be applied as"
7664                                 " expected".format(regedit)
7665                             )
7666                 if _lsarights:
7667                     for lsaright in _lsarights:
7668                         _existingUsers = None
7669                         if not cumulative_rights_assignments:
7670                             _existingUsers = _getRightsAssignments(
7671                                 _lsarights[lsaright]["policy"]["LsaRights"]["Option"]
7672                             )
7673                         if _lsarights[lsaright]["value"]:
7674                             for acct in _lsarights[lsaright]["value"]:
7675                                 _ret = _addAccountRights(
7676                                     acct,
7677                                     _lsarights[lsaright]["policy"]["LsaRights"][
7678                                         "Option"
7679                                     ],
7680                                 )
7681                                 if not _ret:
7682                                     raise SaltInvocationError(
7683                                         "An error occurred attempting to configure the"
7684                                         " user right {}.".format(lsaright)
7685                                     )
7686                         if _existingUsers:
7687                             for acct in _existingUsers:
7688                                 if acct not in _lsarights[lsaright]["value"]:
7689                                     _ret = _delAccountRights(
7690                                         acct,
7691                                         _lsarights[lsaright]["policy"]["LsaRights"][
7692                                             "Option"
7693                                         ],
7694                                     )
7695                                     if not _ret:
7696                                         raise SaltInvocationError(
7697                                             "An error occurred attempting to remove previously "
7698                                             "configured users with right {}.".format(
7699                                                 lsaright
7700                                             )
7701                                         )
7702                 if _secedits:
7703                     log.trace(_secedits)
7704                     ini_data = "\r\n".join(["[Unicode]", "Unicode=yes"])
7705                     _seceditSections = [
7706                         "System Access",
7707                         "Event Audit",
7708                         "Registry Values",
7709                         "Privilege Rights",
7710                     ]
7711                     for _seceditSection in _seceditSections:
7712                         if _seceditSection in _secedits:
7713                             ini_data = "\r\n".join(
7714                                 [
7715                                     ini_data,
7716                                     "".join(["[", _seceditSection, "]"]),
7717                                     "\r\n".join(_secedits[_seceditSection]),
7718                                 ]
7719                             )
7720                     ini_data = "\r\n".join(
7721                         [ini_data, "[Version]", 'signature="$CHICAGO$"', "Revision=1"]
7722                     )
7723                     log.trace("ini_data == %s", ini_data)
7724                     if not _write_secedit_data(ini_data):
7725                         raise CommandExecutionError(
7726                             "Error while attempting to set policies via "
7727                             "secedit. Some changes may not be applied as "
7728                             "expected"
7729                         )
7730                 if _netshs:
7731                     for setting in _netshs:
7732                         log.trace("Setting firewall policy: %s", setting)
7733                         log.trace(_netshs[setting])
7734                         _set_netsh_value(**_netshs[setting])
7735                 if _advaudits:
7736                     for setting in _advaudits:
7737                         log.trace("Setting Advanced Audit policy: %s", setting)
7738                         log.trace(_advaudits[setting])
7739                         _set_advaudit_value(**_advaudits[setting])
7740                 if _modal_sets:
7741                     log.trace(_modal_sets)
7742                     for _modal_set in _modal_sets:
7743                         try:
7744                             _existingModalData = win32net.NetUserModalsGet(
7745                                 None, _modal_set
7746                             )
7747                             _newModalSetData = dictupdate.update(
7748                                 _existingModalData, _modal_sets[_modal_set]
7749                             )
7750                             log.trace("NEW MODAL SET = %s", _newModalSetData)
7751                             _ret = win32net.NetUserModalsSet(
7752                                 None, _modal_set, _newModalSetData
7753                             )
7754                         except Exception as exc:  # pylint: disable=broad-except
7755                             msg = (
7756                                 "An unhandled exception occurred while "
7757                                 "attempting to set policy via "
7758                                 "NetUserModalSet\n{}".format(exc)
7759                             )
7760                             log.exception(msg)
7761                             raise CommandExecutionError(msg)
7762                 if _admTemplateData:
7763                     _ret = False
7764                     log.trace(
7765                         "going to write some adm template data :: %s", _admTemplateData
7766                     )
7767                     _ret = _writeAdminTemplateRegPolFile(
7768                         _admTemplateData,
7769                         adml_language=adml_language,
7770                         registry_class=p_class,
7771                     )
7772                     if not _ret:
7773                         raise CommandExecutionError(
7774                             "Error while attempting to write Administrative Template"
7775                             " Policy data.  Some changes may not be applied as expected"
7776                         )
7777         return True
7778     else:
7779         raise SaltInvocationError("You have to specify something!")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
