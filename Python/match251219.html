<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for saltclass_2.py & test_zfs_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for saltclass_2.py & test_zfs_1.py
      </h3>
      <h1 align="center">
        1.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>saltclass_2.py (2.1164021%)<TH>test_zfs_1.py (0.72859746%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match251219-0.html#0',2,'match251219-1.html#0',3)" NAME="0">(422-426)<TD><A HREF="javascript:ZweiFrames('match251219-0.html#0',2,'match251219-1.html#0',3)" NAME="0">(28-31)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>saltclass_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import glob
import logging
import os
import re

import salt.utils.path
import salt.utils.yaml
from jinja2 import Environment, FileSystemLoader

log = logging.getLogger(__name__)


# Renders jinja from a template file
def render_jinja(_file, salt_data):
    j_env = Environment(loader=FileSystemLoader(os.path.dirname(_file)))
    j_env.globals.update(
        {
            &quot;__opts__&quot;: salt_data[&quot;__opts__&quot;],
            &quot;__salt__&quot;: salt_data[&quot;__salt__&quot;],
            &quot;__grains__&quot;: salt_data[&quot;__grains__&quot;],
            &quot;__pillar__&quot;: salt_data[&quot;__pillar__&quot;],
            &quot;minion_id&quot;: salt_data[&quot;minion_id&quot;],
        }
    )
    j_render = j_env.get_template(os.path.basename(_file)).render()
    return j_render


# Renders yaml from rendered jinja
def render_yaml(_file, salt_data):
    return salt.utils.yaml.safe_load(render_jinja(_file, salt_data))


# Returns a dict from a class yaml definition
def get_class(_class, salt_data):
    l_files = []
    saltclass_path = salt_data[&quot;path&quot;]

    straight, sub_init, sub_straight = get_class_paths(_class, saltclass_path)

    for root, dirs, files in salt.utils.path.os_walk(
        os.path.join(saltclass_path, &quot;classes&quot;), followlinks=True
    ):
        for l_file in files:
            l_files.append(os.path.join(root, l_file))

    if straight in l_files:
        return render_yaml(straight, salt_data)

    if sub_straight in l_files:
        return render_yaml(sub_straight, salt_data)

    if sub_init in l_files:
        return render_yaml(sub_init, salt_data)

    log.warning(&quot;%s: Class definition not found&quot;, _class)
    return {}


def get_class_paths(_class, saltclass_path):
    &quot;&quot;&quot;
    Converts the dotted notation of a saltclass class to its possible file counterparts.

    :param str _class: Dotted notation of the class
    :param str saltclass_path: Root to saltclass storage
    :return: 3-tuple of possible file counterparts
    :rtype: tuple(str)
    &quot;&quot;&quot;
    straight = os.path.join(saltclass_path, &quot;classes&quot;, &quot;{}.yml&quot;.format(_class))
    sub_straight = os.path.join(
        saltclass_path, &quot;classes&quot;, &quot;{}.yml&quot;.format(_class.replace(&quot;.&quot;, os.sep))
    )
    sub_init = os.path.join(
        saltclass_path, &quot;classes&quot;, _class.replace(&quot;.&quot;, os.sep), &quot;init.yml&quot;
    )
    return straight, sub_init, sub_straight


def get_class_from_file(_file, saltclass_path):
    &quot;&quot;&quot;
    Converts the absolute path to a saltclass file back to the dotted notation.

    .. code-block:: python

       print(get_class_from_file('/srv/saltclass/classes/services/nginx/init.yml', '/srv/saltclass'))
       # services.nginx

    :param str _file: Absolute path to file
    :param str saltclass_path: Root to saltclass storage
    :return: class name in dotted notation
    :rtype: str
    &quot;&quot;&quot;
    # remove classes path prefix
    _file = _file[len(os.path.join(saltclass_path, &quot;classes&quot;)) + len(os.sep) :]
    # remove .yml extension
    _file = _file[:-4]
    # revert to dotted notation
    _file = _file.replace(os.sep, &quot;.&quot;)
    # remove tailing init
    if _file.endswith(&quot;.init&quot;):
        _file = _file[:-5]
    return _file


# Return environment
def get_env_from_dict(exp_dict_list):
    environment = &quot;&quot;
    for s_class in exp_dict_list:
        if &quot;environment&quot; in s_class:
            environment = s_class[&quot;environment&quot;]
    return environment


# Merge dict b into a
def dict_merge(a, b, path=None):
    if path is None:
        path = []

    for key in b:
        if key in a:
            if isinstance(a[key], list) and isinstance(b[key], list):
                if b[key][0] == &quot;^&quot;:
                    b[key].pop(0)
                    a[key] = b[key]
                else:
                    a[key].extend(b[key])
            elif isinstance(a[key], dict) and isinstance(b[key], dict):
                dict_merge(a[key], b[key], path + [str(key)])
            elif a[key] == b[key]:
                pass
            else:
                a[key] = b[key]
        else:
            a[key] = b[key]
    return a


# Recursive search and replace in a dict
def dict_search_and_replace(d, old, new, expanded):
    for (k, v) in d.items():
        if isinstance(v, dict):
            dict_search_and_replace(d[k], old, new, expanded)

        if isinstance(v, list):
            x = 0
            for i in v:
                if isinstance(i, dict):
                    dict_search_and_replace(v[x], old, new, expanded)
                if isinstance(i, str):
                    if i == old:
                        v[x] = new
                x = x + 1

        if v == old:
            d[k] = new

    return d


# Retrieve original value from ${xx:yy:zz} to be expanded
def find_value_to_expand(x, v):
    a = x
    for i in v[2:-1].split(&quot;:&quot;):
        if a is None:
            return v
        if i in a:
            a = a.get(i)
        else:
            return v
    return a


# Look for regexes and expand them
def find_and_process_re(_str, v, k, b, expanded):
    vre = re.finditer(r&quot;(^|.)\$\{.*?\}&quot;, _str)
    if vre:
        for re_v in vre:
            re_str = str(re_v.group())
            if re_str.startswith(&quot;\\&quot;):
                v_new = _str.replace(re_str, re_str.lstrip(&quot;\\&quot;))
                b = dict_search_and_replace(b, _str, v_new, expanded)
                expanded.append(k)
            elif not re_str.startswith(&quot;$&quot;):
                v_expanded = find_value_to_expand(b, re_str[1:])
                v_new = _str.replace(re_str[1:], v_expanded)
                b = dict_search_and_replace(b, _str, v_new, expanded)
                _str = v_new
                expanded.append(k)
            else:
                v_expanded = find_value_to_expand(b, re_str)
                if isinstance(v, str):
                    v_new = v.replace(re_str, v_expanded)
                else:
                    v_new = _str.replace(re_str, v_expanded)
                b = dict_search_and_replace(b, _str, v_new, expanded)
                _str = v_new
                v = v_new
                expanded.append(k)
    return b


# Return a dict that contains expanded variables if found
def expand_variables(a, b, expanded, path=None):
    if path is None:
        b = a.copy()
        path = []

    for (k, v) in a.items():
        if isinstance(v, dict):
            expand_variables(v, b, expanded, path + [str(k)])
        else:
            if isinstance(v, list):
                for i in v:
                    if isinstance(i, dict):
                        expand_variables(i, b, expanded, path + [str(k)])
                    if isinstance(i, str):
                        b = find_and_process_re(i, v, k, b, expanded)

            if isinstance(v, str):
                b = find_and_process_re(v, v, k, b, expanded)
    return b


def match_class_glob(_class, saltclass_path):
    &quot;&quot;&quot;
    Takes a class name possibly including `*` or `?` wildcards (or any other wildcards supportet by `glob.glob`) and
    returns a list of expanded class names without wildcards.

    .. code-block:: python

       classes = match_class_glob('services.*', '/srv/saltclass')
       print(classes)
       # services.mariadb
       # services.nginx...


    :param str _class: dotted class name, globbing allowed.
    :param str saltclass_path: path to the saltclass root directory.

    :return: The list of expanded class matches.
    :rtype: list(str)
    &quot;&quot;&quot;
    straight, sub_init, sub_straight = get_class_paths(_class, saltclass_path)
    classes = []
    matches = []
    matches.extend(glob.glob(straight))
    matches.extend(glob.glob(sub_straight))
    matches.extend(glob.glob(sub_init))
    if not matches:
        log.warning(&quot;%s: Class globbing did not yield any results&quot;, _class)
    for match in matches:
        classes.append(get_class_from_file(match, saltclass_path))
    return classes


def expand_classes_glob(classes, salt_data):
    &quot;&quot;&quot;
    Expand the list of `classes` to no longer include any globbing.

    :param iterable(str) classes: Iterable of classes
    :param dict salt_data: configuration data
    :return: Expanded list of classes with resolved globbing
    :rtype: list(str)
    &quot;&quot;&quot;
    all_classes = []
    expanded_classes = []
    saltclass_path = salt_data[&quot;path&quot;]

    for _class in classes:
        all_classes.extend(match_class_glob(_class, saltclass_path))

    for _class in all_classes:
        if _class not in expanded_classes:
            expanded_classes.append(_class)

    return expanded_classes


def expand_classes_in_order(
    minion_dict, salt_data, seen_classes, expanded_classes, classes_to_expand
):
    # Get classes to expand from minion dictionary
    if not classes_to_expand and &quot;classes&quot; in minion_dict:
        classes_to_expand = minion_dict[&quot;classes&quot;]

    classes_to_expand = expand_classes_glob(classes_to_expand, salt_data)

    # Now loop on list to recursively expand them
    for klass in classes_to_expand:
        if klass not in seen_classes:
            seen_classes.append(klass)
            expanded_classes[klass] = get_class(klass, salt_data)
            # Fix corner case where class is loaded but doesn't contain anything
            if expanded_classes[klass] is None:
                expanded_classes[klass] = {}

            # Merge newly found pillars into existing ones
            new_pillars = expanded_classes[klass].get(&quot;pillars&quot;, {})
            if new_pillars:
                dict_merge(salt_data[&quot;__pillar__&quot;], new_pillars)

            # Now replace class element in classes_to_expand by expansion
            if expanded_classes[klass].get(&quot;classes&quot;):
                l_id = classes_to_expand.index(klass)
                classes_to_expand[l_id:l_id] = expanded_classes[klass][&quot;classes&quot;]
                expand_classes_in_order(
                    minion_dict,
                    salt_data,
                    seen_classes,
                    expanded_classes,
                    classes_to_expand,
                )
            else:
                expand_classes_in_order(
                    minion_dict,
                    salt_data,
                    seen_classes,
                    expanded_classes,
                    classes_to_expand,
                )

    # We may have duplicates here and we want to remove them
    tmp = []
    for t_element in classes_to_expand:
        if t_element not in tmp:
            tmp.append(t_element)

    classes_to_expand = tmp

    # Now that we've retrieved every class in order,
    # let's return an ordered list of dicts
    ord_expanded_classes = []
    ord_expanded_states = []
    for ord_klass in classes_to_expand:
        ord_expanded_classes.append(expanded_classes[ord_klass])
        # And be smart and sort out states list
        # Address the corner case where states is empty in a class definition
        if (
            &quot;states&quot; in expanded_classes[ord_klass]
            and expanded_classes[ord_klass][&quot;states&quot;] is None
        ):
            expanded_classes[ord_klass][&quot;states&quot;] = {}

        if &quot;states&quot; in expanded_classes[ord_klass]:
            ord_expanded_states.extend(expanded_classes[ord_klass][&quot;states&quot;])

    # Add our minion dict as final element but check if we have states to process
    if &quot;states&quot; in minion_dict and minion_dict[&quot;states&quot;] is None:
        minion_dict[&quot;states&quot;] = []

    if &quot;states&quot; in minion_dict:
        ord_expanded_states.extend(minion_dict[&quot;states&quot;])

    ord_expanded_classes.append(minion_dict)

    return ord_expanded_classes, classes_to_expand, ord_expanded_states


def expanded_dict_from_minion(minion_id, salt_data):
    _file = &quot;&quot;
    saltclass_path = salt_data[&quot;path&quot;]
    # Start
    for root, dirs, files in salt.utils.path.os_walk(
        os.path.join(saltclass_path, &quot;nodes&quot;), followlinks=True
    ):
        for minion_file in files:
            if minion_file == &quot;{}.yml&quot;.format(minion_id):
                _file = os.path.join(root, minion_file)

    # Load the minion_id definition if existing, else an empty dict
    node_dict = {}
    if _file:
        node_dict[minion_id] = render_yaml(_file, salt_data)
    else:
        log.warning(&quot;%s: Node definition not found&quot;, minion_id)
        node_dict[minion_id] = {}

    # Merge newly found pillars into existing ones
    dict_merge(salt_data[&quot;__pillar__&quot;], node_dict[minion_id].get(&quot;pillars&quot;, {}))

    # Get 2 ordered lists:
    # expanded_classes: A list of all the dicts
    # classes_list: List of all the classes
    expanded_classes, classes_list, states_list = expand_classes_in_order(
        node_dict[minion_id], salt_data, [], {}, []
    )

    # Here merge the pillars together
    pillars_dict = {}
    for exp_dict in expanded_classes:
        if &quot;pillars&quot; in exp_dict:
            dict_merge(pillars_dict, exp_dict)

    return expanded_classes, pillars_dict, classes_list, states_list


def get_pillars(minion_id, salt_data):
    # Get 2 dicts and 2 lists
    # expanded_classes: Full list of expanded dicts
    # pillars_dict: dict containing merged pillars in order
    # classes_list: All classes processed in order
    # states_list: All states listed in order
    (
        expanded_classes,
        pillars_dict,
        classes_list,
        states_list,
    ) = expanded_dict_from_minion(minion_id, salt_data)

    # Retrieve environment
    environment = get_env_from_dict(expanded_classes)

    # Expand ${} variables in merged dict
    # pillars key shouldn't exist if we haven't found any minion_id ref
    if &quot;pillars&quot; in pillars_dict:
        pillars_dict_expanded = expand_variables(pillars_dict[&quot;pillars&quot;], {}, [])
    else:
        pillars_dict_expanded = expand_variables({}, {}, [])
<A NAME="0"></A>
    # Build the final pillars dict
    pillars_dict = {}
    pillars_dict<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match251219-1.html#0',3,'match251219-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;__saltclass__&quot;] = {}
    pillars_dict[&quot;__saltclass__&quot;][&quot;states&quot;] = states_list
    pillars_dict[&quot;__saltclass__&quot;][&quot;classes&quot;] = classes_list
    pillars_dict[&quot;__saltclass__&quot;][&quot;environment&quot;] = environment
    pillars_dict[</B></FONT>&quot;__saltclass__&quot;][&quot;nodename&quot;] = minion_id
    pillars_dict.update(pillars_dict_expanded)

    return pillars_dict


def get_tops(minion_id, salt_data):
    # Get 2 dicts and 2 lists
    # expanded_classes: Full list of expanded dicts
    # pillars_dict: dict containing merged pillars in order
    # classes_list: All classes processed in order
    # states_list: All states listed in order
    (
        expanded_classes,
        pillars_dict,
        classes_list,
        states_list,
    ) = expanded_dict_from_minion(minion_id, salt_data)

    # Retrieve environment
    environment = get_env_from_dict(expanded_classes)

    # Build final top dict
    tops_dict = {}
    tops_dict[environment] = states_list

    return tops_dict
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zfs_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Tests for the zfs utils library

:codeauthor:    Jorge Schrauwen &lt;sjorge@blackdot.be&gt;
:maintainer:    Jorge Schrauwen &lt;sjorge@blackdot.be&gt;
:maturity:      new
:platform:      illumos,freebsd,linux

.. versionadded:: 2018.3.1
&quot;&quot;&quot;


import salt.utils.zfs as zfs
from salt.utils.odict import OrderedDict
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase
from tests.support.zfs import ZFSMockData


class ZfsUtilsTestCase(TestCase):
    &quot;&quot;&quot;
    This class contains a set of functions that test salt.utils.zfs utils
    &quot;&quot;&quot;

<A NAME="0"></A>    def setUp(self):
        # property_map mocks
        mock_data = ZFSMockData()
        self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match251219-0.html#0',2,'match251219-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.pmap_zfs = mock_data.pmap_zfs
        self.pmap_zpool = mock_data.pmap_zpool
        self.pmap_exec_zfs = mock_data.pmap_exec_zfs
        self.pmap_exec_zpool = mock_data.</B></FONT>pmap_exec_zpool
        for name in (&quot;pmap_zfs&quot;, &quot;pmap_zpool&quot;, &quot;pmap_exec_zfs&quot;, &quot;pmap_exec_zpool&quot;):
            self.addCleanup(delattr, self, name)

    # NOTE: test parameter parsing
    def test_is_supported(self):
        &quot;&quot;&quot;
        Test zfs.is_supported method
        &quot;&quot;&quot;
        for value in [False, True]:
            with patch(&quot;salt.utils.path.which&quot;, MagicMock(return_value=value)):
                with patch(
                    &quot;salt.utils.platform.is_linux&quot;, MagicMock(return_value=value)
                ):
                    self.assertEqual(value, zfs.is_supported())

    def test_property_data_zpool(self):
        &quot;&quot;&quot;
        Test parsing of zpool get output
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;_exec&quot;, MagicMock(return_value=self.pmap_exec_zpool)
                ):
                    self.assertEqual(zfs.property_data_zpool(), self.pmap_zpool)

    def test_property_data_zfs(self):
        &quot;&quot;&quot;
        Test parsing of zfs get output
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;_exec&quot;, MagicMock(return_value=self.pmap_exec_zfs)
                ):
                    self.assertEqual(zfs.property_data_zfs(), self.pmap_zfs)

    # NOTE: testing from_bool results
    def test_from_bool_on(self):
        &quot;&quot;&quot;
        Test from_bool with 'on'
        &quot;&quot;&quot;
        self.assertTrue(zfs.from_bool(&quot;on&quot;))
        self.assertTrue(zfs.from_bool(zfs.from_bool(&quot;on&quot;)))

    def test_from_bool_off(self):
        &quot;&quot;&quot;
        Test from_bool with 'off'
        &quot;&quot;&quot;
        self.assertFalse(zfs.from_bool(&quot;off&quot;))
        self.assertFalse(zfs.from_bool(zfs.from_bool(&quot;off&quot;)))

    def test_from_bool_none(self):
        &quot;&quot;&quot;
        Test from_bool with 'none'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_bool(&quot;none&quot;), None)
        self.assertEqual(zfs.from_bool(zfs.from_bool(&quot;none&quot;)), None)

    def test_from_bool_passthrough(self):
        &quot;&quot;&quot;
        Test from_bool with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_bool(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(zfs.from_bool(zfs.from_bool(&quot;passthrough&quot;)), &quot;passthrough&quot;)

    def test_from_bool_alt_yes(self):
        &quot;&quot;&quot;
        Test from_bool_alt with 'yes'
        &quot;&quot;&quot;
        self.assertTrue(zfs.from_bool_alt(&quot;yes&quot;))
        self.assertTrue(zfs.from_bool_alt(zfs.from_bool_alt(&quot;yes&quot;)))

    def test_from_bool_alt_no(self):
        &quot;&quot;&quot;
        Test from_bool_alt with 'no'
        &quot;&quot;&quot;
        self.assertFalse(zfs.from_bool_alt(&quot;no&quot;))
        self.assertFalse(zfs.from_bool_alt(zfs.from_bool_alt(&quot;no&quot;)))

    def test_from_bool_alt_none(self):
        &quot;&quot;&quot;
        Test from_bool_alt with 'none'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_bool_alt(&quot;none&quot;), None)
        self.assertEqual(zfs.from_bool_alt(zfs.from_bool_alt(&quot;none&quot;)), None)

    def test_from_bool_alt_passthrough(self):
        &quot;&quot;&quot;
        Test from_bool_alt with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_bool_alt(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(
            zfs.from_bool_alt(zfs.from_bool_alt(&quot;passthrough&quot;)), &quot;passthrough&quot;
        )

    # NOTE: testing to_bool results
    def test_to_bool_true(self):
        &quot;&quot;&quot;
        Test to_bool with True
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_bool(True), &quot;on&quot;)
        self.assertEqual(zfs.to_bool(zfs.to_bool(True)), &quot;on&quot;)

    def test_to_bool_false(self):
        &quot;&quot;&quot;
        Test to_bool with False
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_bool(False), &quot;off&quot;)
        self.assertEqual(zfs.to_bool(zfs.to_bool(False)), &quot;off&quot;)

    def test_to_bool_none(self):
        &quot;&quot;&quot;
        Test to_bool with None
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_bool(None), &quot;none&quot;)
        self.assertEqual(zfs.to_bool(zfs.to_bool(None)), &quot;none&quot;)

    def test_to_bool_passthrough(self):
        &quot;&quot;&quot;
        Test to_bool with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_bool(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(zfs.to_bool(zfs.to_bool(&quot;passthrough&quot;)), &quot;passthrough&quot;)

    def test_to_bool_alt_true(self):
        &quot;&quot;&quot;
        Test to_bool_alt with True
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_bool_alt(True), &quot;yes&quot;)
        self.assertEqual(zfs.to_bool_alt(zfs.to_bool_alt(True)), &quot;yes&quot;)

    def test_to_bool_alt_false(self):
        &quot;&quot;&quot;
        Test to_bool_alt with False
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_bool_alt(False), &quot;no&quot;)
        self.assertEqual(zfs.to_bool_alt(zfs.to_bool_alt(False)), &quot;no&quot;)

    def test_to_bool_alt_none(self):
        &quot;&quot;&quot;
        Test to_bool_alt with None
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_bool_alt(None), &quot;none&quot;)
        self.assertEqual(zfs.to_bool_alt(zfs.to_bool_alt(None)), &quot;none&quot;)

    def test_to_bool_alt_passthrough(self):
        &quot;&quot;&quot;
        Test to_bool_alt with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_bool_alt(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(zfs.to_bool_alt(zfs.to_bool_alt(&quot;passthrough&quot;)), &quot;passthrough&quot;)

    # NOTE: testing from_numeric results
    def test_from_numeric_str(self):
        &quot;&quot;&quot;
        Test from_numeric with '42'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_numeric(&quot;42&quot;), 42)
        self.assertEqual(zfs.from_numeric(zfs.from_numeric(&quot;42&quot;)), 42)

    def test_from_numeric_int(self):
        &quot;&quot;&quot;
        Test from_numeric with 42
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_numeric(42), 42)
        self.assertEqual(zfs.from_numeric(zfs.from_numeric(42)), 42)

    def test_from_numeric_none(self):
        &quot;&quot;&quot;
        Test from_numeric with 'none'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_numeric(&quot;none&quot;), None)
        self.assertEqual(zfs.from_numeric(zfs.from_numeric(&quot;none&quot;)), None)

    def test_from_numeric_passthrough(self):
        &quot;&quot;&quot;
        Test from_numeric with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_numeric(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(
            zfs.from_numeric(zfs.from_numeric(&quot;passthrough&quot;)), &quot;passthrough&quot;
        )

    # NOTE: testing to_numeric results
    def test_to_numeric_str(self):
        &quot;&quot;&quot;
        Test to_numeric with '42'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_numeric(&quot;42&quot;), 42)
        self.assertEqual(zfs.to_numeric(zfs.to_numeric(&quot;42&quot;)), 42)

    def test_to_numeric_int(self):
        &quot;&quot;&quot;
        Test to_numeric with 42
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_numeric(42), 42)
        self.assertEqual(zfs.to_numeric(zfs.to_numeric(42)), 42)

    def test_to_numeric_none(self):
        &quot;&quot;&quot;
        Test to_numeric with 'none'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_numeric(None), &quot;none&quot;)
        self.assertEqual(zfs.to_numeric(zfs.to_numeric(None)), &quot;none&quot;)

    def test_to_numeric_passthrough(self):
        &quot;&quot;&quot;
        Test to_numeric with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_numeric(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(zfs.to_numeric(zfs.to_numeric(&quot;passthrough&quot;)), &quot;passthrough&quot;)

    # NOTE: testing from_size results
    def test_from_size_absolute(self):
        &quot;&quot;&quot;
        Test from_size with '5G'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_size(&quot;5G&quot;), 5368709120)
        self.assertEqual(zfs.from_size(zfs.from_size(&quot;5G&quot;)), 5368709120)

    def test_from_size_decimal(self):
        &quot;&quot;&quot;
        Test from_size with '4.20M'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_size(&quot;4.20M&quot;), 4404019)
        self.assertEqual(zfs.from_size(zfs.from_size(&quot;4.20M&quot;)), 4404019)

    def test_from_size_none(self):
        &quot;&quot;&quot;
        Test from_size with 'none'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_size(&quot;none&quot;), None)
        self.assertEqual(zfs.from_size(zfs.from_size(&quot;none&quot;)), None)

    def test_from_size_passthrough(self):
        &quot;&quot;&quot;
        Test from_size with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_size(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(zfs.from_size(zfs.from_size(&quot;passthrough&quot;)), &quot;passthrough&quot;)

    # NOTE: testing to_size results
    def test_to_size_str_absolute(self):
        &quot;&quot;&quot;
        Test to_size with '5368709120'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_size(&quot;5368709120&quot;), &quot;5G&quot;)
        self.assertEqual(zfs.to_size(zfs.to_size(&quot;5368709120&quot;)), &quot;5G&quot;)

    def test_to_size_str_decimal(self):
        &quot;&quot;&quot;
        Test to_size with '4404019'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_size(&quot;4404019&quot;), &quot;4.20M&quot;)
        self.assertEqual(zfs.to_size(zfs.to_size(&quot;4404019&quot;)), &quot;4.20M&quot;)

    def test_to_size_int_absolute(self):
        &quot;&quot;&quot;
        Test to_size with 5368709120
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_size(5368709120), &quot;5G&quot;)
        self.assertEqual(zfs.to_size(zfs.to_size(5368709120)), &quot;5G&quot;)

    def test_to_size_int_decimal(self):
        &quot;&quot;&quot;
        Test to_size with 4404019
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_size(4404019), &quot;4.20M&quot;)
        self.assertEqual(zfs.to_size(zfs.to_size(4404019)), &quot;4.20M&quot;)

    def test_to_size_none(self):
        &quot;&quot;&quot;
        Test to_size with 'none'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_size(None), &quot;none&quot;)
        self.assertEqual(zfs.to_size(zfs.to_size(None)), &quot;none&quot;)

    def test_to_size_passthrough(self):
        &quot;&quot;&quot;
        Test to_size with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_size(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(zfs.to_size(zfs.to_size(&quot;passthrough&quot;)), &quot;passthrough&quot;)

    # NOTE: testing from_str results
    def test_from_str_space(self):
        &quot;&quot;&quot;
        Test from_str with &quot;\&quot;my pool/my dataset\&quot;
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_str('&quot;my pool/my dataset&quot;'), &quot;my pool/my dataset&quot;)
        self.assertEqual(
            zfs.from_str(zfs.from_str('&quot;my pool/my dataset&quot;')), &quot;my pool/my dataset&quot;
        )

    def test_from_str_squote_space(self):
        &quot;&quot;&quot;
        Test from_str with &quot;my pool/jorge's dataset&quot;
        &quot;&quot;&quot;
        self.assertEqual(
            zfs.from_str(&quot;my pool/jorge's dataset&quot;), &quot;my pool/jorge's dataset&quot;
        )
        self.assertEqual(
            zfs.from_str(zfs.from_str(&quot;my pool/jorge's dataset&quot;)),
            &quot;my pool/jorge's dataset&quot;,
        )

    def test_from_str_dquote_space(self):
        &quot;&quot;&quot;
        Test from_str with &quot;my pool/the \&quot;good\&quot; stuff&quot;
        &quot;&quot;&quot;
        self.assertEqual(
            zfs.from_str('my pool/the &quot;good&quot; stuff'), 'my pool/the &quot;good&quot; stuff'
        )
        self.assertEqual(
            zfs.from_str(zfs.from_str('my pool/the &quot;good&quot; stuff')),
            'my pool/the &quot;good&quot; stuff',
        )

    def test_from_str_none(self):
        &quot;&quot;&quot;
        Test from_str with 'none'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_str(&quot;none&quot;), None)
        self.assertEqual(zfs.from_str(zfs.from_str(&quot;none&quot;)), None)

    def test_from_str_passthrough(self):
        &quot;&quot;&quot;
        Test from_str with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.from_str(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(zfs.from_str(zfs.from_str(&quot;passthrough&quot;)), &quot;passthrough&quot;)

    # NOTE: testing to_str results
    def test_to_str_space(self):
        &quot;&quot;&quot;
        Test to_str with 'my pool/my dataset'
        &quot;&quot;&quot;
        # NOTE: for fun we use both the '&quot;str&quot;' and &quot;\&quot;str\&quot;&quot; way of getting the literal string: &quot;str&quot;
        self.assertEqual(zfs.to_str(&quot;my pool/my dataset&quot;), '&quot;my pool/my dataset&quot;')
        self.assertEqual(
            zfs.to_str(zfs.to_str(&quot;my pool/my dataset&quot;)), '&quot;my pool/my dataset&quot;'
        )

    def test_to_str_squote_space(self):
        &quot;&quot;&quot;
        Test to_str with &quot;my pool/jorge's dataset&quot;
        &quot;&quot;&quot;
        self.assertEqual(
            zfs.to_str(&quot;my pool/jorge's dataset&quot;), '&quot;my pool/jorge\'s dataset&quot;'
        )
        self.assertEqual(
            zfs.to_str(zfs.to_str(&quot;my pool/jorge's dataset&quot;)),
            '&quot;my pool/jorge\'s dataset&quot;',
        )

    def test_to_str_none(self):
        &quot;&quot;&quot;
        Test to_str with 'none'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_str(None), &quot;none&quot;)
        self.assertEqual(zfs.to_str(zfs.to_str(None)), &quot;none&quot;)

    def test_to_str_passthrough(self):
        &quot;&quot;&quot;
        Test to_str with 'passthrough'
        &quot;&quot;&quot;
        self.assertEqual(zfs.to_str(&quot;passthrough&quot;), &quot;passthrough&quot;)
        self.assertEqual(zfs.to_str(zfs.to_str(&quot;passthrough&quot;)), &quot;passthrough&quot;)

    # NOTE: testing is_snapshot
    def test_is_snapshot_snapshot(self):
        &quot;&quot;&quot;
        Test is_snapshot with a valid snapshot name
        &quot;&quot;&quot;
        self.assertTrue(zfs.is_snapshot(&quot;zpool_name/dataset@backup&quot;))

    def test_is_snapshot_bookmark(self):
        &quot;&quot;&quot;
        Test is_snapshot with a valid bookmark name
        &quot;&quot;&quot;
        self.assertFalse(zfs.is_snapshot(&quot;zpool_name/dataset#backup&quot;))

    def test_is_snapshot_filesystem(self):
        &quot;&quot;&quot;
        Test is_snapshot with a valid filesystem name
        &quot;&quot;&quot;
        self.assertFalse(zfs.is_snapshot(&quot;zpool_name/dataset&quot;))

    # NOTE: testing is_bookmark
    def test_is_bookmark_snapshot(self):
        &quot;&quot;&quot;
        Test is_bookmark with a valid snapshot name
        &quot;&quot;&quot;
        self.assertFalse(zfs.is_bookmark(&quot;zpool_name/dataset@backup&quot;))

    def test_is_bookmark_bookmark(self):
        &quot;&quot;&quot;
        Test is_bookmark with a valid bookmark name
        &quot;&quot;&quot;
        self.assertTrue(zfs.is_bookmark(&quot;zpool_name/dataset#backup&quot;))

    def test_is_bookmark_filesystem(self):
        &quot;&quot;&quot;
        Test is_bookmark with a valid filesystem name
        &quot;&quot;&quot;
        self.assertFalse(zfs.is_bookmark(&quot;zpool_name/dataset&quot;))

    # NOTE: testing is_dataset
    def test_is_dataset_snapshot(self):
        &quot;&quot;&quot;
        Test is_dataset with a valid snapshot name
        &quot;&quot;&quot;
        self.assertFalse(zfs.is_dataset(&quot;zpool_name/dataset@backup&quot;))

    def test_is_dataset_bookmark(self):
        &quot;&quot;&quot;
        Test is_dataset with a valid bookmark name
        &quot;&quot;&quot;
        self.assertFalse(zfs.is_dataset(&quot;zpool_name/dataset#backup&quot;))

    def test_is_dataset_filesystem(self):
        &quot;&quot;&quot;
        Test is_dataset with a valid filesystem/volume name
        &quot;&quot;&quot;
        self.assertTrue(zfs.is_dataset(&quot;zpool_name/dataset&quot;))

    # NOTE: testing zfs_command
    def test_zfs_command_simple(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(zfs.zfs_command(&quot;list&quot;), &quot;/sbin/zfs list&quot;)

    def test_zfs_command_none_target(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string with a target of None
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(
                            zfs.zfs_command(&quot;list&quot;, target=[None, &quot;mypool&quot;, None]),
                            &quot;/sbin/zfs list mypool&quot;,
                        )

    def test_zfs_command_flag(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            &quot;-r&quot;,  # recursive
                        ]
                        self.assertEqual(
                            zfs.zfs_command(&quot;list&quot;, flags=my_flags), &quot;/sbin/zfs list -r&quot;
                        )

    def test_zfs_command_opt(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            &quot;-t&quot;: &quot;snap&quot;,  # only list snapshots
                        }
                        self.assertEqual(
                            zfs.zfs_command(&quot;list&quot;, opts=my_opts),
                            &quot;/sbin/zfs list -t snap&quot;,
                        )

    def test_zfs_command_flag_opt(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            &quot;-r&quot;,  # recursive
                        ]
                        my_opts = {
                            &quot;-t&quot;: &quot;snap&quot;,  # only list snapshots
                        }
                        self.assertEqual(
                            zfs.zfs_command(&quot;list&quot;, flags=my_flags, opts=my_opts),
                            &quot;/sbin/zfs list -r -t snap&quot;,
                        )

    def test_zfs_command_target(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            &quot;-r&quot;,  # recursive
                        ]
                        my_opts = {
                            &quot;-t&quot;: &quot;snap&quot;,  # only list snapshots
                        }
                        self.assertEqual(
                            zfs.zfs_command(
                                &quot;list&quot;, flags=my_flags, opts=my_opts, target=&quot;mypool&quot;
                            ),
                            &quot;/sbin/zfs list -r -t snap mypool&quot;,
                        )

    def test_zfs_command_target_with_space(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            &quot;-r&quot;,  # recursive
                        ]
                        my_opts = {
                            &quot;-t&quot;: &quot;snap&quot;,  # only list snapshots
                        }
                        self.assertEqual(
                            zfs.zfs_command(
                                &quot;list&quot;, flags=my_flags, opts=my_opts, target=&quot;my pool&quot;
                            ),
                            '/sbin/zfs list -r -t snap &quot;my pool&quot;',
                        )

    def test_zfs_command_property(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(
                            zfs.zfs_command(
                                &quot;get&quot;, property_name=&quot;quota&quot;, target=&quot;mypool&quot;
                            ),
                            &quot;/sbin/zfs get quota mypool&quot;,
                        )

    def test_zfs_command_property_value(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            &quot;-r&quot;,  # recursive
                        ]
                        self.assertEqual(
                            zfs.zfs_command(
                                &quot;set&quot;,
                                flags=my_flags,
                                property_name=&quot;quota&quot;,
                                property_value=&quot;5G&quot;,
                                target=&quot;mypool&quot;,
                            ),
                            &quot;/sbin/zfs set -r quota=5368709120 mypool&quot;,
                        )

    def test_zfs_command_multi_property_value(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        property_name = [&quot;quota&quot;, &quot;readonly&quot;]
                        property_value = [&quot;5G&quot;, &quot;no&quot;]
                        self.assertEqual(
                            zfs.zfs_command(
                                &quot;set&quot;,
                                property_name=property_name,
                                property_value=property_value,
                                target=&quot;mypool&quot;,
                            ),
                            &quot;/sbin/zfs set quota=5368709120 readonly=off mypool&quot;,
                        )

    def test_zfs_command_fs_props(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            &quot;-p&quot;,  # create parent
                        ]
                        my_props = {
                            &quot;quota&quot;: &quot;1G&quot;,
                            &quot;compression&quot;: &quot;lz4&quot;,
                        }
                        self.assertEqual(
                            zfs.zfs_command(
                                &quot;create&quot;,
                                flags=my_flags,
                                filesystem_properties=my_props,
                                target=&quot;mypool/dataset&quot;,
                            ),
                            &quot;/sbin/zfs create -p -o compression=lz4 -o quota=1073741824&quot;
                            &quot; mypool/dataset&quot;,
                        )

    def test_zfs_command_fs_props_with_space(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_props = {
                            &quot;quota&quot;: &quot;4.2M&quot;,
                            &quot;compression&quot;: &quot;lz4&quot;,
                        }
                        self.assertEqual(
                            zfs.zfs_command(
                                &quot;create&quot;,
                                filesystem_properties=my_props,
                                target=&quot;my pool/jorge's dataset&quot;,
                            ),
                            '/sbin/zfs create -o compression=lz4 -o quota=4404019 &quot;my'
                            &quot; pool/jorge's dataset\&quot;&quot;,
                        )

    # NOTE: testing zpool_command
    def test_zpool_command_simple(self):
        &quot;&quot;&quot;
        Test if zfs_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(zfs.zpool_command(&quot;list&quot;), &quot;/sbin/zpool list&quot;)

    def test_zpool_command_opt(self):
        &quot;&quot;&quot;
        Test if zpool_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            &quot;-o&quot;: &quot;name,size&quot;,  # show only name and size
                        }
                        self.assertEqual(
                            zfs.zpool_command(&quot;list&quot;, opts=my_opts),
                            &quot;/sbin/zpool list -o name,size&quot;,
                        )

    def test_zpool_command_opt_list(self):
        &quot;&quot;&quot;
        Test if zpool_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            &quot;-d&quot;: [&quot;/tmp&quot;, &quot;/zvol&quot;],
                        }
                        self.assertEqual(
                            zfs.zpool_command(&quot;import&quot;, opts=my_opts, target=&quot;mypool&quot;),
                            &quot;/sbin/zpool import -d /tmp -d /zvol mypool&quot;,
                        )

    def test_zpool_command_flag_opt(self):
        &quot;&quot;&quot;
        Test if zpool_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            &quot;-o&quot;: &quot;name,size&quot;,  # show only name and size
                        }
                        self.assertEqual(
                            zfs.zpool_command(&quot;list&quot;, opts=my_opts),
                            &quot;/sbin/zpool list -o name,size&quot;,
                        )

    def test_zpool_command_target(self):
        &quot;&quot;&quot;
        Test if zpool_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            &quot;-o&quot;: &quot;name,size&quot;,  # show only name and size
                        }
                        self.assertEqual(
                            zfs.zpool_command(&quot;list&quot;, opts=my_opts, target=&quot;mypool&quot;),
                            &quot;/sbin/zpool list -o name,size mypool&quot;,
                        )

    def test_zpool_command_target_with_space(self):
        &quot;&quot;&quot;
        Test if zpool_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        fs_props = {
                            &quot;quota&quot;: &quot;100G&quot;,
                        }
                        pool_props = {
                            &quot;comment&quot;: &quot;jorge's comment has a space&quot;,
                        }
                        self.assertEqual(
                            zfs.zpool_command(
                                &quot;create&quot;,
                                pool_properties=pool_props,
                                filesystem_properties=fs_props,
                                target=&quot;my pool&quot;,
                            ),
                            &quot;/sbin/zpool create -O quota=107374182400 -o&quot;
                            ' comment=&quot;jorge\'s comment has a space&quot; &quot;my pool&quot;',
                        )

    def test_zpool_command_property(self):
        &quot;&quot;&quot;
        Test if zpool_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(
                            zfs.zpool_command(
                                &quot;get&quot;, property_name=&quot;comment&quot;, target=&quot;mypool&quot;
                            ),
                            &quot;/sbin/zpool get comment mypool&quot;,
                        )

    def test_zpool_command_property_value(self):
        &quot;&quot;&quot;
        Test if zpool_command builds the correct string
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            &quot;-v&quot;,  # verbose
                        ]
                        self.assertEqual(
                            zfs.zpool_command(
                                &quot;iostat&quot;, flags=my_flags, target=[&quot;mypool&quot;, 60, 1]
                            ),
                            &quot;/sbin/zpool iostat -v mypool 60 1&quot;,
                        )

    def test_parse_command_result_success(self):
        &quot;&quot;&quot;
        Test if parse_command_result returns the expected result
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res[&quot;retcode&quot;] = 0
                        res[&quot;stderr&quot;] = &quot;&quot;
                        res[&quot;stdout&quot;] = &quot;&quot;
                        self.assertEqual(
                            zfs.parse_command_result(res, &quot;tested&quot;),
                            OrderedDict([(&quot;tested&quot;, True)]),
                        )

    def test_parse_command_result_success_nolabel(self):
        &quot;&quot;&quot;
        Test if parse_command_result returns the expected result
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res[&quot;retcode&quot;] = 0
                        res[&quot;stderr&quot;] = &quot;&quot;
                        res[&quot;stdout&quot;] = &quot;&quot;
                        self.assertEqual(
                            zfs.parse_command_result(res),
                            OrderedDict(),
                        )

    def test_parse_command_result_fail(self):
        &quot;&quot;&quot;
        Test if parse_command_result returns the expected result on failure
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res[&quot;retcode&quot;] = 1
                        res[&quot;stderr&quot;] = &quot;&quot;
                        res[&quot;stdout&quot;] = &quot;&quot;
                        self.assertEqual(
                            zfs.parse_command_result(res, &quot;tested&quot;),
                            OrderedDict([(&quot;tested&quot;, False)]),
                        )

    def test_parse_command_result_nolabel(self):
        &quot;&quot;&quot;
        Test if parse_command_result returns the expected result on failure
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res[&quot;retcode&quot;] = 1
                        res[&quot;stderr&quot;] = &quot;&quot;
                        res[&quot;stdout&quot;] = &quot;&quot;
                        self.assertEqual(
                            zfs.parse_command_result(res),
                            OrderedDict(),
                        )

    def test_parse_command_result_fail_message(self):
        &quot;&quot;&quot;
        Test if parse_command_result returns the expected result on failure with stderr
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res[&quot;retcode&quot;] = 1
                        res[&quot;stderr&quot;] = &quot;\n&quot;.join(
                            [&quot;ice is not hot&quot;, &quot;usage:&quot;, &quot;this should not be printed&quot;]
                        )
                        res[&quot;stdout&quot;] = &quot;&quot;
                        self.assertEqual(
                            zfs.parse_command_result(res, &quot;tested&quot;),
                            OrderedDict(
                                [(&quot;tested&quot;, False), (&quot;error&quot;, &quot;ice is not hot&quot;)]
                            ),
                        )

    def test_parse_command_result_fail_message_nolabel(self):
        &quot;&quot;&quot;
        Test if parse_command_result returns the expected result on failure with stderr
        &quot;&quot;&quot;
        with patch.object(zfs, &quot;_zfs_cmd&quot;, MagicMock(return_value=&quot;/sbin/zfs&quot;)):
            with patch.object(zfs, &quot;_zpool_cmd&quot;, MagicMock(return_value=&quot;/sbin/zpool&quot;)):
                with patch.object(
                    zfs, &quot;property_data_zfs&quot;, MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        &quot;property_data_zpool&quot;,
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res[&quot;retcode&quot;] = 1
                        res[&quot;stderr&quot;] = &quot;\n&quot;.join(
                            [&quot;ice is not hot&quot;, &quot;usage:&quot;, &quot;this should not be printed&quot;]
                        )
                        res[&quot;stdout&quot;] = &quot;&quot;
                        self.assertEqual(
                            zfs.parse_command_result(res),
                            OrderedDict([(&quot;error&quot;, &quot;ice is not hot&quot;)]),
                        )
</PRE>
</div>
  </div>
</body>
</html>
