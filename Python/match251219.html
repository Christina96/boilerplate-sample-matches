<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for saltclass_2.py &amp; test_zfs_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for saltclass_2.py &amp; test_zfs_1.py
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>saltclass_2.py (2.1164021%)<th>test_zfs_1.py (0.72859746%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(422-426)<td><a href="#" name="0">(28-31)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>saltclass_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import glob
import logging
import os
import re
import salt.utils.path
import salt.utils.yaml
from jinja2 import Environment, FileSystemLoader
log = logging.getLogger(__name__)
def render_jinja(_file, salt_data):
    j_env = Environment(loader=FileSystemLoader(os.path.dirname(_file)))
    j_env.globals.update(
        {
            "__opts__": salt_data["__opts__"],
            "__salt__": salt_data["__salt__"],
            "__grains__": salt_data["__grains__"],
            "__pillar__": salt_data["__pillar__"],
            "minion_id": salt_data["minion_id"],
        }
    )
    j_render = j_env.get_template(os.path.basename(_file)).render()
    return j_render
def render_yaml(_file, salt_data):
    return salt.utils.yaml.safe_load(render_jinja(_file, salt_data))
def get_class(_class, salt_data):
    l_files = []
    saltclass_path = salt_data["path"]
    straight, sub_init, sub_straight = get_class_paths(_class, saltclass_path)
    for root, dirs, files in salt.utils.path.os_walk(
        os.path.join(saltclass_path, "classes"), followlinks=True
    ):
        for l_file in files:
            l_files.append(os.path.join(root, l_file))
    if straight in l_files:
        return render_yaml(straight, salt_data)
    if sub_straight in l_files:
        return render_yaml(sub_straight, salt_data)
    if sub_init in l_files:
        return render_yaml(sub_init, salt_data)
    log.warning("%s: Class definition not found", _class)
    return {}
def get_class_paths(_class, saltclass_path):
    straight = os.path.join(saltclass_path, "classes", "{}.yml".format(_class))
    sub_straight = os.path.join(
        saltclass_path, "classes", "{}.yml".format(_class.replace(".", os.sep))
    )
    sub_init = os.path.join(
        saltclass_path, "classes", _class.replace(".", os.sep), "init.yml"
    )
    return straight, sub_init, sub_straight
def get_class_from_file(_file, saltclass_path):
    _file = _file[len(os.path.join(saltclass_path, "classes")) + len(os.sep) :]
    _file = _file[:-4]
    _file = _file.replace(os.sep, ".")
    if _file.endswith(".init"):
        _file = _file[:-5]
    return _file
def get_env_from_dict(exp_dict_list):
    environment = ""
    for s_class in exp_dict_list:
        if "environment" in s_class:
            environment = s_class["environment"]
    return environment
def dict_merge(a, b, path=None):
    if path is None:
        path = []
    for key in b:
        if key in a:
            if isinstance(a[key], list) and isinstance(b[key], list):
                if b[key][0] == "^":
                    b[key].pop(0)
                    a[key] = b[key]
                else:
                    a[key].extend(b[key])
            elif isinstance(a[key], dict) and isinstance(b[key], dict):
                dict_merge(a[key], b[key], path + [str(key)])
            elif a[key] == b[key]:
                pass
            else:
                a[key] = b[key]
        else:
            a[key] = b[key]
    return a
def dict_search_and_replace(d, old, new, expanded):
    for (k, v) in d.items():
        if isinstance(v, dict):
            dict_search_and_replace(d[k], old, new, expanded)
        if isinstance(v, list):
            x = 0
            for i in v:
                if isinstance(i, dict):
                    dict_search_and_replace(v[x], old, new, expanded)
                if isinstance(i, str):
                    if i == old:
                        v[x] = new
                x = x + 1
        if v == old:
            d[k] = new
    return d
def find_value_to_expand(x, v):
    a = x
    for i in v[2:-1].split(":"):
        if a is None:
            return v
        if i in a:
            a = a.get(i)
        else:
            return v
    return a
def find_and_process_re(_str, v, k, b, expanded):
    vre = re.finditer(r"(^|.)\$\{.*?\}", _str)
    if vre:
        for re_v in vre:
            re_str = str(re_v.group())
            if re_str.startswith("\\"):
                v_new = _str.replace(re_str, re_str.lstrip("\\"))
                b = dict_search_and_replace(b, _str, v_new, expanded)
                expanded.append(k)
            elif not re_str.startswith("$"):
                v_expanded = find_value_to_expand(b, re_str[1:])
                v_new = _str.replace(re_str[1:], v_expanded)
                b = dict_search_and_replace(b, _str, v_new, expanded)
                _str = v_new
                expanded.append(k)
            else:
                v_expanded = find_value_to_expand(b, re_str)
                if isinstance(v, str):
                    v_new = v.replace(re_str, v_expanded)
                else:
                    v_new = _str.replace(re_str, v_expanded)
                b = dict_search_and_replace(b, _str, v_new, expanded)
                _str = v_new
                v = v_new
                expanded.append(k)
    return b
def expand_variables(a, b, expanded, path=None):
    if path is None:
        b = a.copy()
        path = []
    for (k, v) in a.items():
        if isinstance(v, dict):
            expand_variables(v, b, expanded, path + [str(k)])
        else:
            if isinstance(v, list):
                for i in v:
                    if isinstance(i, dict):
                        expand_variables(i, b, expanded, path + [str(k)])
                    if isinstance(i, str):
                        b = find_and_process_re(i, v, k, b, expanded)
            if isinstance(v, str):
                b = find_and_process_re(v, v, k, b, expanded)
    return b
def match_class_glob(_class, saltclass_path):
    straight, sub_init, sub_straight = get_class_paths(_class, saltclass_path)
    classes = []
    matches = []
    matches.extend(glob.glob(straight))
    matches.extend(glob.glob(sub_straight))
    matches.extend(glob.glob(sub_init))
    if not matches:
        log.warning("%s: Class globbing did not yield any results", _class)
    for match in matches:
        classes.append(get_class_from_file(match, saltclass_path))
    return classes
def expand_classes_glob(classes, salt_data):
    all_classes = []
    expanded_classes = []
    saltclass_path = salt_data["path"]
    for _class in classes:
        all_classes.extend(match_class_glob(_class, saltclass_path))
    for _class in all_classes:
        if _class not in expanded_classes:
            expanded_classes.append(_class)
    return expanded_classes
def expand_classes_in_order(
    minion_dict, salt_data, seen_classes, expanded_classes, classes_to_expand
):
    if not classes_to_expand and "classes" in minion_dict:
        classes_to_expand = minion_dict["classes"]
    classes_to_expand = expand_classes_glob(classes_to_expand, salt_data)
    for klass in classes_to_expand:
        if klass not in seen_classes:
            seen_classes.append(klass)
            expanded_classes[klass] = get_class(klass, salt_data)
            if expanded_classes[klass] is None:
                expanded_classes[klass] = {}
            new_pillars = expanded_classes[klass].get("pillars", {})
            if new_pillars:
                dict_merge(salt_data["__pillar__"], new_pillars)
            if expanded_classes[klass].get("classes"):
                l_id = classes_to_expand.index(klass)
                classes_to_expand[l_id:l_id] = expanded_classes[klass]["classes"]
                expand_classes_in_order(
                    minion_dict,
                    salt_data,
                    seen_classes,
                    expanded_classes,
                    classes_to_expand,
                )
            else:
                expand_classes_in_order(
                    minion_dict,
                    salt_data,
                    seen_classes,
                    expanded_classes,
                    classes_to_expand,
                )
    tmp = []
    for t_element in classes_to_expand:
        if t_element not in tmp:
            tmp.append(t_element)
    classes_to_expand = tmp
    ord_expanded_classes = []
    ord_expanded_states = []
    for ord_klass in classes_to_expand:
        ord_expanded_classes.append(expanded_classes[ord_klass])
        if (
            "states" in expanded_classes[ord_klass]
            and expanded_classes[ord_klass]["states"] is None
        ):
            expanded_classes[ord_klass]["states"] = {}
        if "states" in expanded_classes[ord_klass]:
            ord_expanded_states.extend(expanded_classes[ord_klass]["states"])
    if "states" in minion_dict and minion_dict["states"] is None:
        minion_dict["states"] = []
    if "states" in minion_dict:
        ord_expanded_states.extend(minion_dict["states"])
    ord_expanded_classes.append(minion_dict)
    return ord_expanded_classes, classes_to_expand, ord_expanded_states
def expanded_dict_from_minion(minion_id, salt_data):
    _file = ""
    saltclass_path = salt_data["path"]
    for root, dirs, files in salt.utils.path.os_walk(
        os.path.join(saltclass_path, "nodes"), followlinks=True
    ):
        for minion_file in files:
            if minion_file == "{}.yml".format(minion_id):
                _file = os.path.join(root, minion_file)
    node_dict = {}
    if _file:
        node_dict[minion_id] = render_yaml(_file, salt_data)
    else:
        log.warning("%s: Node definition not found", minion_id)
        node_dict[minion_id] = {}
    dict_merge(salt_data["__pillar__"], node_dict[minion_id].get("pillars", {}))
    expanded_classes, classes_list, states_list = expand_classes_in_order(
        node_dict[minion_id], salt_data, [], {}, []
    )
    pillars_dict = {}
    for exp_dict in expanded_classes:
        if "pillars" in exp_dict:
            dict_merge(pillars_dict, exp_dict)
    return expanded_classes, pillars_dict, classes_list, states_list
def get_pillars(minion_id, salt_data):
    (
        expanded_classes,
        pillars_dict,
        classes_list,
        states_list,
    ) = expanded_dict_from_minion(minion_id, salt_data)
    environment = get_env_from_dict(expanded_classes)
    if "pillars" in pillars_dict:
        pillars_dict_expanded = expand_variables(pillars_dict["pillars"], {}, [])
    else:
        pillars_dict_expanded = expand_variables({}, {}, [])
<a name="0"></a>
    pillars_dict = {}
    pillars_dict<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["__saltclass__"] = {}
    pillars_dict["__saltclass__"]["states"] = states_list
    pillars_dict["__saltclass__"]["classes"] = classes_list
    pillars_dict["__saltclass__"]["environment"] = environment
    pillars_dict[</b></font>"__saltclass__"]["nodename"] = minion_id
    pillars_dict.update(pillars_dict_expanded)
    return pillars_dict
def get_tops(minion_id, salt_data):
    (
        expanded_classes,
        pillars_dict,
        classes_list,
        states_list,
    ) = expanded_dict_from_minion(minion_id, salt_data)
    environment = get_env_from_dict(expanded_classes)
    tops_dict = {}
    tops_dict[environment] = states_list
    return tops_dict
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zfs_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import salt.utils.zfs as zfs
from salt.utils.odict import OrderedDict
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase
from tests.support.zfs import ZFSMockData
class ZfsUtilsTestCase(TestCase):
<a name="0"></a>    def setUp(self):
        mock_data = ZFSMockData()
        self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.pmap_zfs = mock_data.pmap_zfs
        self.pmap_zpool = mock_data.pmap_zpool
        self.pmap_exec_zfs = mock_data.pmap_exec_zfs
        self.pmap_exec_zpool = mock_data.</b></font>pmap_exec_zpool
        for name in ("pmap_zfs", "pmap_zpool", "pmap_exec_zfs", "pmap_exec_zpool"):
            self.addCleanup(delattr, self, name)
    def test_is_supported(self):
        for value in [False, True]:
            with patch("salt.utils.path.which", MagicMock(return_value=value)):
                with patch(
                    "salt.utils.platform.is_linux", MagicMock(return_value=value)
                ):
                    self.assertEqual(value, zfs.is_supported())
    def test_property_data_zpool(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "_exec", MagicMock(return_value=self.pmap_exec_zpool)
                ):
                    self.assertEqual(zfs.property_data_zpool(), self.pmap_zpool)
    def test_property_data_zfs(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "_exec", MagicMock(return_value=self.pmap_exec_zfs)
                ):
                    self.assertEqual(zfs.property_data_zfs(), self.pmap_zfs)
    def test_from_bool_on(self):
        self.assertTrue(zfs.from_bool("on"))
        self.assertTrue(zfs.from_bool(zfs.from_bool("on")))
    def test_from_bool_off(self):
        self.assertFalse(zfs.from_bool("off"))
        self.assertFalse(zfs.from_bool(zfs.from_bool("off")))
    def test_from_bool_none(self):
        self.assertEqual(zfs.from_bool("none"), None)
        self.assertEqual(zfs.from_bool(zfs.from_bool("none")), None)
    def test_from_bool_passthrough(self):
        self.assertEqual(zfs.from_bool("passthrough"), "passthrough")
        self.assertEqual(zfs.from_bool(zfs.from_bool("passthrough")), "passthrough")
    def test_from_bool_alt_yes(self):
        self.assertTrue(zfs.from_bool_alt("yes"))
        self.assertTrue(zfs.from_bool_alt(zfs.from_bool_alt("yes")))
    def test_from_bool_alt_no(self):
        self.assertFalse(zfs.from_bool_alt("no"))
        self.assertFalse(zfs.from_bool_alt(zfs.from_bool_alt("no")))
    def test_from_bool_alt_none(self):
        self.assertEqual(zfs.from_bool_alt("none"), None)
        self.assertEqual(zfs.from_bool_alt(zfs.from_bool_alt("none")), None)
    def test_from_bool_alt_passthrough(self):
        self.assertEqual(zfs.from_bool_alt("passthrough"), "passthrough")
        self.assertEqual(
            zfs.from_bool_alt(zfs.from_bool_alt("passthrough")), "passthrough"
        )
    def test_to_bool_true(self):
        self.assertEqual(zfs.to_bool(True), "on")
        self.assertEqual(zfs.to_bool(zfs.to_bool(True)), "on")
    def test_to_bool_false(self):
        self.assertEqual(zfs.to_bool(False), "off")
        self.assertEqual(zfs.to_bool(zfs.to_bool(False)), "off")
    def test_to_bool_none(self):
        self.assertEqual(zfs.to_bool(None), "none")
        self.assertEqual(zfs.to_bool(zfs.to_bool(None)), "none")
    def test_to_bool_passthrough(self):
        self.assertEqual(zfs.to_bool("passthrough"), "passthrough")
        self.assertEqual(zfs.to_bool(zfs.to_bool("passthrough")), "passthrough")
    def test_to_bool_alt_true(self):
        self.assertEqual(zfs.to_bool_alt(True), "yes")
        self.assertEqual(zfs.to_bool_alt(zfs.to_bool_alt(True)), "yes")
    def test_to_bool_alt_false(self):
        self.assertEqual(zfs.to_bool_alt(False), "no")
        self.assertEqual(zfs.to_bool_alt(zfs.to_bool_alt(False)), "no")
    def test_to_bool_alt_none(self):
        self.assertEqual(zfs.to_bool_alt(None), "none")
        self.assertEqual(zfs.to_bool_alt(zfs.to_bool_alt(None)), "none")
    def test_to_bool_alt_passthrough(self):
        self.assertEqual(zfs.to_bool_alt("passthrough"), "passthrough")
        self.assertEqual(zfs.to_bool_alt(zfs.to_bool_alt("passthrough")), "passthrough")
    def test_from_numeric_str(self):
        self.assertEqual(zfs.from_numeric("42"), 42)
        self.assertEqual(zfs.from_numeric(zfs.from_numeric("42")), 42)
    def test_from_numeric_int(self):
        self.assertEqual(zfs.from_numeric(42), 42)
        self.assertEqual(zfs.from_numeric(zfs.from_numeric(42)), 42)
    def test_from_numeric_none(self):
        self.assertEqual(zfs.from_numeric("none"), None)
        self.assertEqual(zfs.from_numeric(zfs.from_numeric("none")), None)
    def test_from_numeric_passthrough(self):
        self.assertEqual(zfs.from_numeric("passthrough"), "passthrough")
        self.assertEqual(
            zfs.from_numeric(zfs.from_numeric("passthrough")), "passthrough"
        )
    def test_to_numeric_str(self):
        self.assertEqual(zfs.to_numeric("42"), 42)
        self.assertEqual(zfs.to_numeric(zfs.to_numeric("42")), 42)
    def test_to_numeric_int(self):
        self.assertEqual(zfs.to_numeric(42), 42)
        self.assertEqual(zfs.to_numeric(zfs.to_numeric(42)), 42)
    def test_to_numeric_none(self):
        self.assertEqual(zfs.to_numeric(None), "none")
        self.assertEqual(zfs.to_numeric(zfs.to_numeric(None)), "none")
    def test_to_numeric_passthrough(self):
        self.assertEqual(zfs.to_numeric("passthrough"), "passthrough")
        self.assertEqual(zfs.to_numeric(zfs.to_numeric("passthrough")), "passthrough")
    def test_from_size_absolute(self):
        self.assertEqual(zfs.from_size("5G"), 5368709120)
        self.assertEqual(zfs.from_size(zfs.from_size("5G")), 5368709120)
    def test_from_size_decimal(self):
        self.assertEqual(zfs.from_size("4.20M"), 4404019)
        self.assertEqual(zfs.from_size(zfs.from_size("4.20M")), 4404019)
    def test_from_size_none(self):
        self.assertEqual(zfs.from_size("none"), None)
        self.assertEqual(zfs.from_size(zfs.from_size("none")), None)
    def test_from_size_passthrough(self):
        self.assertEqual(zfs.from_size("passthrough"), "passthrough")
        self.assertEqual(zfs.from_size(zfs.from_size("passthrough")), "passthrough")
    def test_to_size_str_absolute(self):
        self.assertEqual(zfs.to_size("5368709120"), "5G")
        self.assertEqual(zfs.to_size(zfs.to_size("5368709120")), "5G")
    def test_to_size_str_decimal(self):
        self.assertEqual(zfs.to_size("4404019"), "4.20M")
        self.assertEqual(zfs.to_size(zfs.to_size("4404019")), "4.20M")
    def test_to_size_int_absolute(self):
        self.assertEqual(zfs.to_size(5368709120), "5G")
        self.assertEqual(zfs.to_size(zfs.to_size(5368709120)), "5G")
    def test_to_size_int_decimal(self):
        self.assertEqual(zfs.to_size(4404019), "4.20M")
        self.assertEqual(zfs.to_size(zfs.to_size(4404019)), "4.20M")
    def test_to_size_none(self):
        self.assertEqual(zfs.to_size(None), "none")
        self.assertEqual(zfs.to_size(zfs.to_size(None)), "none")
    def test_to_size_passthrough(self):
        self.assertEqual(zfs.to_size("passthrough"), "passthrough")
        self.assertEqual(zfs.to_size(zfs.to_size("passthrough")), "passthrough")
    def test_from_str_space(self):
        self.assertEqual(zfs.from_str('"my pool/my dataset"'), "my pool/my dataset")
        self.assertEqual(
            zfs.from_str(zfs.from_str('"my pool/my dataset"')), "my pool/my dataset"
        )
    def test_from_str_squote_space(self):
        self.assertEqual(
            zfs.from_str("my pool/jorge's dataset"), "my pool/jorge's dataset"
        )
        self.assertEqual(
            zfs.from_str(zfs.from_str("my pool/jorge's dataset")),
            "my pool/jorge's dataset",
        )
    def test_from_str_dquote_space(self):
        self.assertEqual(
            zfs.from_str('my pool/the "good" stuff'), 'my pool/the "good" stuff'
        )
        self.assertEqual(
            zfs.from_str(zfs.from_str('my pool/the "good" stuff')),
            'my pool/the "good" stuff',
        )
    def test_from_str_none(self):
        self.assertEqual(zfs.from_str("none"), None)
        self.assertEqual(zfs.from_str(zfs.from_str("none")), None)
    def test_from_str_passthrough(self):
        self.assertEqual(zfs.from_str("passthrough"), "passthrough")
        self.assertEqual(zfs.from_str(zfs.from_str("passthrough")), "passthrough")
    def test_to_str_space(self):
        self.assertEqual(zfs.to_str("my pool/my dataset"), '"my pool/my dataset"')
        self.assertEqual(
            zfs.to_str(zfs.to_str("my pool/my dataset")), '"my pool/my dataset"'
        )
    def test_to_str_squote_space(self):
        self.assertEqual(
            zfs.to_str("my pool/jorge's dataset"), '"my pool/jorge\'s dataset"'
        )
        self.assertEqual(
            zfs.to_str(zfs.to_str("my pool/jorge's dataset")),
            '"my pool/jorge\'s dataset"',
        )
    def test_to_str_none(self):
        self.assertEqual(zfs.to_str(None), "none")
        self.assertEqual(zfs.to_str(zfs.to_str(None)), "none")
    def test_to_str_passthrough(self):
        self.assertEqual(zfs.to_str("passthrough"), "passthrough")
        self.assertEqual(zfs.to_str(zfs.to_str("passthrough")), "passthrough")
    def test_is_snapshot_snapshot(self):
        self.assertTrue(zfs.is_snapshot("zpool_name/dataset@backup"))
    def test_is_snapshot_bookmark(self):
        self.assertFalse(zfs.is_snapshot("zpool_name/dataset#backup"))
    def test_is_snapshot_filesystem(self):
        self.assertFalse(zfs.is_snapshot("zpool_name/dataset"))
    def test_is_bookmark_snapshot(self):
        self.assertFalse(zfs.is_bookmark("zpool_name/dataset@backup"))
    def test_is_bookmark_bookmark(self):
        self.assertTrue(zfs.is_bookmark("zpool_name/dataset#backup"))
    def test_is_bookmark_filesystem(self):
        self.assertFalse(zfs.is_bookmark("zpool_name/dataset"))
    def test_is_dataset_snapshot(self):
        self.assertFalse(zfs.is_dataset("zpool_name/dataset@backup"))
    def test_is_dataset_bookmark(self):
        self.assertFalse(zfs.is_dataset("zpool_name/dataset#backup"))
    def test_is_dataset_filesystem(self):
        self.assertTrue(zfs.is_dataset("zpool_name/dataset"))
    def test_zfs_command_simple(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(zfs.zfs_command("list"), "/sbin/zfs list")
    def test_zfs_command_none_target(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(
                            zfs.zfs_command("list", target=[None, "mypool", None]),
                            "/sbin/zfs list mypool",
                        )
    def test_zfs_command_flag(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            "-r",  # recursive
                        ]
                        self.assertEqual(
                            zfs.zfs_command("list", flags=my_flags), "/sbin/zfs list -r"
                        )
    def test_zfs_command_opt(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            "-t": "snap",  # only list snapshots
                        }
                        self.assertEqual(
                            zfs.zfs_command("list", opts=my_opts),
                            "/sbin/zfs list -t snap",
                        )
    def test_zfs_command_flag_opt(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            "-r",  # recursive
                        ]
                        my_opts = {
                            "-t": "snap",  # only list snapshots
                        }
                        self.assertEqual(
                            zfs.zfs_command("list", flags=my_flags, opts=my_opts),
                            "/sbin/zfs list -r -t snap",
                        )
    def test_zfs_command_target(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            "-r",  # recursive
                        ]
                        my_opts = {
                            "-t": "snap",  # only list snapshots
                        }
                        self.assertEqual(
                            zfs.zfs_command(
                                "list", flags=my_flags, opts=my_opts, target="mypool"
                            ),
                            "/sbin/zfs list -r -t snap mypool",
                        )
    def test_zfs_command_target_with_space(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            "-r",  # recursive
                        ]
                        my_opts = {
                            "-t": "snap",  # only list snapshots
                        }
                        self.assertEqual(
                            zfs.zfs_command(
                                "list", flags=my_flags, opts=my_opts, target="my pool"
                            ),
                            '/sbin/zfs list -r -t snap "my pool"',
                        )
    def test_zfs_command_property(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(
                            zfs.zfs_command(
                                "get", property_name="quota", target="mypool"
                            ),
                            "/sbin/zfs get quota mypool",
                        )
    def test_zfs_command_property_value(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            "-r",  # recursive
                        ]
                        self.assertEqual(
                            zfs.zfs_command(
                                "set",
                                flags=my_flags,
                                property_name="quota",
                                property_value="5G",
                                target="mypool",
                            ),
                            "/sbin/zfs set -r quota=5368709120 mypool",
                        )
    def test_zfs_command_multi_property_value(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        property_name = ["quota", "readonly"]
                        property_value = ["5G", "no"]
                        self.assertEqual(
                            zfs.zfs_command(
                                "set",
                                property_name=property_name,
                                property_value=property_value,
                                target="mypool",
                            ),
                            "/sbin/zfs set quota=5368709120 readonly=off mypool",
                        )
    def test_zfs_command_fs_props(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            "-p",  # create parent
                        ]
                        my_props = {
                            "quota": "1G",
                            "compression": "lz4",
                        }
                        self.assertEqual(
                            zfs.zfs_command(
                                "create",
                                flags=my_flags,
                                filesystem_properties=my_props,
                                target="mypool/dataset",
                            ),
                            "/sbin/zfs create -p -o compression=lz4 -o quota=1073741824"
                            " mypool/dataset",
                        )
    def test_zfs_command_fs_props_with_space(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_props = {
                            "quota": "4.2M",
                            "compression": "lz4",
                        }
                        self.assertEqual(
                            zfs.zfs_command(
                                "create",
                                filesystem_properties=my_props,
                                target="my pool/jorge's dataset",
                            ),
                            '/sbin/zfs create -o compression=lz4 -o quota=4404019 "my'
                            " pool/jorge's dataset\"",
                        )
    def test_zpool_command_simple(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(zfs.zpool_command("list"), "/sbin/zpool list")
    def test_zpool_command_opt(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            "-o": "name,size",  # show only name and size
                        }
                        self.assertEqual(
                            zfs.zpool_command("list", opts=my_opts),
                            "/sbin/zpool list -o name,size",
                        )
    def test_zpool_command_opt_list(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            "-d": ["/tmp", "/zvol"],
                        }
                        self.assertEqual(
                            zfs.zpool_command("import", opts=my_opts, target="mypool"),
                            "/sbin/zpool import -d /tmp -d /zvol mypool",
                        )
    def test_zpool_command_flag_opt(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            "-o": "name,size",  # show only name and size
                        }
                        self.assertEqual(
                            zfs.zpool_command("list", opts=my_opts),
                            "/sbin/zpool list -o name,size",
                        )
    def test_zpool_command_target(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_opts = {
                            "-o": "name,size",  # show only name and size
                        }
                        self.assertEqual(
                            zfs.zpool_command("list", opts=my_opts, target="mypool"),
                            "/sbin/zpool list -o name,size mypool",
                        )
    def test_zpool_command_target_with_space(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        fs_props = {
                            "quota": "100G",
                        }
                        pool_props = {
                            "comment": "jorge's comment has a space",
                        }
                        self.assertEqual(
                            zfs.zpool_command(
                                "create",
                                pool_properties=pool_props,
                                filesystem_properties=fs_props,
                                target="my pool",
                            ),
                            "/sbin/zpool create -O quota=107374182400 -o"
                            ' comment="jorge\'s comment has a space" "my pool"',
                        )
    def test_zpool_command_property(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        self.assertEqual(
                            zfs.zpool_command(
                                "get", property_name="comment", target="mypool"
                            ),
                            "/sbin/zpool get comment mypool",
                        )
    def test_zpool_command_property_value(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        my_flags = [
                            "-v",  # verbose
                        ]
                        self.assertEqual(
                            zfs.zpool_command(
                                "iostat", flags=my_flags, target=["mypool", 60, 1]
                            ),
                            "/sbin/zpool iostat -v mypool 60 1",
                        )
    def test_parse_command_result_success(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res["retcode"] = 0
                        res["stderr"] = ""
                        res["stdout"] = ""
                        self.assertEqual(
                            zfs.parse_command_result(res, "tested"),
                            OrderedDict([("tested", True)]),
                        )
    def test_parse_command_result_success_nolabel(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res["retcode"] = 0
                        res["stderr"] = ""
                        res["stdout"] = ""
                        self.assertEqual(
                            zfs.parse_command_result(res),
                            OrderedDict(),
                        )
    def test_parse_command_result_fail(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res["retcode"] = 1
                        res["stderr"] = ""
                        res["stdout"] = ""
                        self.assertEqual(
                            zfs.parse_command_result(res, "tested"),
                            OrderedDict([("tested", False)]),
                        )
    def test_parse_command_result_nolabel(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res["retcode"] = 1
                        res["stderr"] = ""
                        res["stdout"] = ""
                        self.assertEqual(
                            zfs.parse_command_result(res),
                            OrderedDict(),
                        )
    def test_parse_command_result_fail_message(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res["retcode"] = 1
                        res["stderr"] = "\n".join(
                            ["ice is not hot", "usage:", "this should not be printed"]
                        )
                        res["stdout"] = ""
                        self.assertEqual(
                            zfs.parse_command_result(res, "tested"),
                            OrderedDict(
                                [("tested", False), ("error", "ice is not hot")]
                            ),
                        )
    def test_parse_command_result_fail_message_nolabel(self):
        with patch.object(zfs, "_zfs_cmd", MagicMock(return_value="/sbin/zfs")):
            with patch.object(zfs, "_zpool_cmd", MagicMock(return_value="/sbin/zpool")):
                with patch.object(
                    zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
                ):
                    with patch.object(
                        zfs,
                        "property_data_zpool",
                        MagicMock(return_value=self.pmap_zpool),
                    ):
                        res = {}
                        res["retcode"] = 1
                        res["stderr"] = "\n".join(
                            ["ice is not hot", "usage:", "this should not be printed"]
                        )
                        res["stdout"] = ""
                        self.assertEqual(
                            zfs.parse_command_result(res),
                            OrderedDict([("error", "ice is not hot")]),
                        )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
