<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for test_archive.py &amp; test_file_basics.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_archive.py &amp; test_file_basics.py
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_archive.py (4.0540543%)<th>test_file_basics.py (3.2085562%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-13)<td><a href="#" name="0">(1-13)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_archive.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import functools
import hashlib
import http.server
import multiprocessing
import os
import random
import shutil
import socket
import sys
from contextlib import closing

import pytest
import</b></font> salt.utils.files


class TestRequestHandler(http.server.SimpleHTTPRequestHandler):
    """
    Modified request handler class
    """

    def __init__(self, *args, directory=None, **kwargs):
        if directory is None:
            directory = os.getcwd()
        self.directory = directory
        if sys.version_info.minor &lt; 7:
            super().__init__(*args, **kwargs)
        else:
            super().__init__(*args, directory=directory, **kwargs)

    def do_GET(self):
        """
        GET request handling
        """
        none_match = self.headers.get("If-None-Match")
        status_code = 200
        try:
            # Retrieve the local file from the web root to serve to clients
            with salt.utils.files.fopen(
                os.path.join(self.directory, self.path[1:]), "rb"
            ) as reqfp:
                return_data = reqfp.read()
                # We're using this checksum as the etag to show file changes
                checksum = hashlib.md5(return_data).hexdigest()
                if none_match == checksum:
                    # Status code 304 Not Modified is returned if the file is unchanged
                    status_code = 304
        except:  # pylint: disable=bare-except
            # Something went wrong. We didn't find the requested file
            status_code = 404
            return_data = None
            checksum = None

        self.send_response(status_code)

        # Return the Etag header if we have the checksum
        if checksum:
            # IMPORTANT: This introduces randomness into the tests. The Etag header key
            # will be converted to lowercase in the code... but if someone breaks that,
            # it'll rear it's head here as random failures that are hard to reproduce.
            # Any alternatives seem overly complex. So... don't break the case insensitivity
            # in the code.
            possible_etags = ["Etag", "ETag", "etag", "ETAG"]
            self.send_header(random.choice(possible_etags), checksum)
            self.end_headers()

        # Return file content
        if return_data:
            self.wfile.write(return_data)


def serve(port=8000, directory=None):
    """
    Function to serve a directory via http.server
    """
    handler = functools.partial(TestRequestHandler, directory=directory)
    s = http.server.HTTPServer(("127.0.0.1", port), handler)
    s.serve_forever()


@pytest.fixture(scope="module")
def free_port():
    """
    Utility fixture to grab a free port for the web server
    """
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
        s.bind(("", 0))
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        return s.getsockname()[1]


@pytest.fixture(autouse=True, scope="module")
def server(free_port, web_root):
    """
    Web server fixture
    """
    p = multiprocessing.Process(target=serve, args=(free_port, web_root))
    p.start()
    yield
    p.terminate()
    p.join()


@pytest.fixture(scope="module")
def web_root(tmp_path_factory):
    """
    Temporary directory fixture for the web server root
    """
    _web_root = tmp_path_factory.mktemp("web_root")
    try:
        yield str(_web_root)
    finally:
        shutil.rmtree(str(_web_root), ignore_errors=True)


def test_archive_extracted_web_source_etag_operation(
    modules, states, free_port, web_root, minion_opts
):
    """
    This functional test checks the operation of the use_etag parameter to the
    archive.extracted state. There are four (4) invocations of archive.extracted
    with a web source, but only three (3) will trigger a call to the web server
    as shown below and in comments within.

        127.0.0.1 - - [08/Mar/2022 13:07:10] "GET /foo.tar.gz HTTP/1.1" 200 -
        127.0.0.1 - - [08/Mar/2022 13:07:10] "GET /foo.tar.gz HTTP/1.1" 304 -
        127.0.0.1 - - [08/Mar/2022 13:07:10] "GET /foo.tar.gz HTTP/1.1" 200 -

    Checks are documented in the comments.
    """
    # Create file in the web root directory to serve
    states.file.managed(
        name=os.path.join(web_root, "foo", "bar.txt"),
        contents="this is my file",
        makedirs=True,
    )
    modules.archive.tar(
        options="czf",
        tarfile=os.path.join(web_root, "foo.tar.gz"),
        sources=[os.path.join(web_root, "foo")],
        cwd=web_root,
    )

    # File should not be cached yet
    cached_file = os.path.join(
        minion_opts["cachedir"],
        "extrn_files",
        "base",
        "localhost:{free_port}".format(free_port=free_port),
        "foo.tar.gz",
    )
    cached_etag = cached_file + ".etag"
    assert not os.path.exists(cached_file)
    assert not os.path.exists(cached_etag)

    # Pull the file from the web server
    #     Web server returns 200 status code with content:
    #     127.0.0.1 - - [08/Mar/2022 13:07:10] "GET /foo.tar.gz HTTP/1.1" 200 -
    states.archive.extracted(
        name=web_root,
        source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
        archive_format="tar",
        options="z",
        use_etag=True,
    )

    # Now the file is cached
    assert os.path.exists(cached_file)
    assert os.path.exists(cached_etag)

    # Store the original modified time of the cached file
    cached_file_mtime = os.path.getmtime(cached_file)

    # Pull the file again. Etag hasn't changed. No download occurs.
    #     Web server returns 304 status code and no content:
    #     127.0.0.1 - - [08/Mar/2022 13:07:10] "GET /foo.tar.gz HTTP/1.1" 304 -
    states.archive.extracted(
        name=web_root,
        source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
        archive_format="tar",
        options="z",
        use_etag=True,
    )

    # Check that the modified time of the cached file hasn't changed
    assert cached_file_mtime == os.path.getmtime(cached_file)

    # Change file in the web root directory
    states.file.managed(
        name=os.path.join(web_root, "foo", "bar.txt"),
        contents="this is my changed file",
    )
    modules.archive.tar(
        options="czf",
        tarfile=os.path.join(web_root, "foo.tar.gz"),
        sources=[os.path.join(web_root, "foo")],
        cwd=web_root,
    )

    # Don't use Etag. Cached file is there, Salt won't try to download.
    #     No call to the web server will be made.
    states.archive.extracted(
        name=web_root,
        source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
        archive_format="tar",
        options="z",
        use_etag=False,
    )

    # Check that the modified time of the cached file hasn't changed
    assert cached_file_mtime == os.path.getmtime(cached_file)

    # Now use Etag again. Cached file changes
    #     Web server returns 200 status code with content
    #     127.0.0.1 - - [08/Mar/2022 13:07:10] "GET /foo.tar.gz HTTP/1.1" 200 -
    states.archive.extracted(
        name=web_root,
        source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
        archive_format="tar",
        options="z",
        use_etag=True,
    )

    # The modified time of the cached file now changes
    assert cached_file_mtime != os.path.getmtime(cached_file)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_basics.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
import os
import shutil

import pytest
import salt.config
import salt.loader
import salt.modules.cmdmod as cmdmod
import salt.modules.config as configmod
import salt.modules.file as filemod
import salt.utils.data
import salt.utils.files
import</b></font> salt.utils.platform
import salt.utils.stringutils
from tests.support.mock import MagicMock, call, patch

log = logging.getLogger(__name__)


@pytest.fixture
def configure_loader_modules():
    return {
        filemod: {
            "__salt__": {
                "config.manage_mode": configmod.manage_mode,
                "cmd.run": cmdmod.run,
                "cmd.run_all": cmdmod.run_all,
            },
            "__opts__": {
                "test": False,
                "file_roots": {"base": "tmp"},
                "pillar_roots": {"base": "tmp"},
                "cachedir": "tmp",
                "grains": {},
            },
            "__grains__": {"kernel": "Linux"},
        }
    }


@pytest.fixture
def tmp_sub_dir(tmp_path):
    directory = tmp_path / "file-basics-test-dir"
    directory.mkdir()

    yield directory

    shutil.rmtree(str(directory))


@pytest.fixture
def tfile(tmp_sub_dir):
    filename = str(tmp_sub_dir / "file-basics-test-file")

    with salt.utils.files.fopen(filename, "w+") as fp:
        fp.write("Hi hello! I am a file.")

    yield filename

    os.remove(filename)


@pytest.fixture
def myfile(tmp_sub_dir):
    filename = str(tmp_sub_dir / "myfile")

    with salt.utils.files.fopen(filename, "w+") as fp:
        fp.write(salt.utils.stringutils.to_str("Hello\n"))

    yield filename

    os.remove(filename)


@pytest.fixture
def a_link(tmp_sub_dir):
    path = tmp_sub_dir / "a_link"
    linkname = str(path)

    yield linkname

    if path.exists():
        os.remove(linkname)


@pytest.fixture
def a_hardlink(tmp_sub_dir):
    path = tmp_sub_dir / "a_hardlink"
    linkname = str(path)

    yield linkname

    if path.exists():
        os.remove(linkname)


@pytest.mark.skip_on_windows(reason="os.symlink is not available on Windows")
def test_symlink_already_in_desired_state(tfile, a_link):
    os.symlink(tfile, a_link)
    result = filemod.symlink(tfile, a_link)
    assert result


@pytest.mark.skip_on_windows(reason="os.link is not available on Windows")
def test_hardlink_sanity(tfile, a_hardlink):
    target = a_hardlink
    result = filemod.link(tfile, target)
    assert result


@pytest.mark.skip_on_windows(reason="os.link is not available on Windows")
def test_hardlink_numlinks(tfile, a_hardlink):
    target = a_hardlink
    result = filemod.link(tfile, target)
    name_i = os.stat(tfile).st_nlink
    assert name_i &gt; 1


@pytest.mark.skip_on_windows(reason="os.link is not available on Windows")
def test_hardlink_working(tfile, a_hardlink):
    target = a_hardlink
    result = filemod.link(tfile, target)
    name_i = os.stat(tfile).st_ino
    target_i = os.stat(target).st_ino
    assert name_i == target_i


def test_source_list_for_list_returns_file_from_dict_via_http():
    with patch("salt.modules.file.os.remove") as remove:
        remove.return_value = None
        with patch.dict(
            filemod.__salt__,
            {
                "cp.list_master": MagicMock(return_value=[]),
                "cp.list_master_dirs": MagicMock(return_value=[]),
                "cp.cache_file": MagicMock(return_value="/tmp/http.conf"),
            },
        ):
            with patch("salt.utils.http.query") as http_query:
                http_query.return_value = {}
                ret = filemod.source_list(
                    [{"http://t.est.com/http/httpd.conf": "filehash"}], "", "base"
                )
                assert list(ret) == ["http://t.est.com/http/httpd.conf", "filehash"]


def test_source_list_use_requests():
    with patch("salt.modules.file.os.remove") as remove:
        remove.return_value = None
        with patch.dict(
            filemod.__salt__,
            {
                "cp.list_master": MagicMock(return_value=[]),
                "cp.list_master_dirs": MagicMock(return_value=[]),
                "cp.cache_file": MagicMock(return_value="/tmp/http.conf"),
            },
        ):
            expected_call = call(
                "http://t.est.com/http/file1",
                decode_body=False,
                method="HEAD",
            )
            with patch(
                "salt.utils.http.query", MagicMock(return_value={})
            ) as http_query:
                ret = filemod.source_list(
                    [{"http://t.est.com/http/file1": "filehash"}], "", "base"
                )
                assert list(ret) == ["http://t.est.com/http/file1", "filehash"]
                assert expected_call in http_query.mock_calls


def test_source_list_for_list_returns_existing_file():
    with patch.dict(
        filemod.__salt__,
        {
            "cp.list_master": MagicMock(return_value=["http/httpd.conf.fallback"]),
            "cp.list_master_dirs": MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list(
            ["salt://http/httpd.conf", "salt://http/httpd.conf.fallback"],
            "filehash",
            "base",
        )
        assert list(ret) == ["salt://http/httpd.conf.fallback", "filehash"]


def test_source_list_for_list_returns_file_from_other_env():
    def list_master(env):
        dct = {"base": [], "dev": ["http/httpd.conf"]}
        return dct[env]

    with patch.dict(
        filemod.__salt__,
        {
            "cp.list_master": MagicMock(side_effect=list_master),
            "cp.list_master_dirs": MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list(
            [
                "salt://http/httpd.conf?saltenv=dev",
                "salt://http/httpd.conf.fallback",
            ],
            "filehash",
            "base",
        )
        assert list(ret) == ["salt://http/httpd.conf?saltenv=dev", "filehash"]


def test_source_list_for_list_returns_file_from_dict():
    with patch.dict(
        filemod.__salt__,
        {
            "cp.list_master": MagicMock(return_value=["http/httpd.conf"]),
            "cp.list_master_dirs": MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list([{"salt://http/httpd.conf": ""}], "filehash", "base")
        assert list(ret) == ["salt://http/httpd.conf", "filehash"]


def test_source_list_for_list_returns_existing_local_file_slash(myfile):
    with patch.dict(
        filemod.__salt__,
        {
            "cp.list_master": MagicMock(return_value=[]),
            "cp.list_master_dirs": MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list([myfile + "-foo", myfile], "filehash", "base")
        assert list(ret) == [myfile, "filehash"]


def test_source_list_for_list_returns_existing_local_file_proto(myfile):
    with patch.dict(
        filemod.__salt__,
        {
            "cp.list_master": MagicMock(return_value=[]),
            "cp.list_master_dirs": MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list(
            ["file://" + myfile + "-foo", "file://" + myfile],
            "filehash",
            "base",
        )
        assert list(ret) == ["file://" + myfile, "filehash"]


def test_source_list_for_list_returns_local_file_slash_from_dict(myfile):
    with patch.dict(
        filemod.__salt__,
        {
            "cp.list_master": MagicMock(return_value=[]),
            "cp.list_master_dirs": MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list([{myfile: ""}], "filehash", "base")
        assert list(ret) == [myfile, "filehash"]


def test_source_list_for_list_returns_local_file_proto_from_dict(myfile):
    with patch.dict(
        filemod.__salt__,
        {
            "cp.list_master": MagicMock(return_value=[]),
            "cp.list_master_dirs": MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list([{"file://" + myfile: ""}], "filehash", "base")
        assert list(ret) == ["file://" + myfile, "filehash"]
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
