<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_archive.py & test_file_basics.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_archive.py & test_file_basics.py
      </h3>
      <h1 align="center">
        3.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_archive.py (4.0540543%)<TH>test_file_basics.py (3.2085562%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match94559-0.html#0',2,'match94559-1.html#0',3)" NAME="0">(1-13)<TD><A HREF="javascript:ZweiFrames('match94559-0.html#0',2,'match94559-1.html#0',3)" NAME="0">(1-13)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_archive.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match94559-1.html#0',3,'match94559-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import functools
import hashlib
import http.server
import multiprocessing
import os
import random
import shutil
import socket
import sys
from contextlib import closing

import pytest
import</B></FONT> salt.utils.files


class TestRequestHandler(http.server.SimpleHTTPRequestHandler):
    &quot;&quot;&quot;
    Modified request handler class
    &quot;&quot;&quot;

    def __init__(self, *args, directory=None, **kwargs):
        if directory is None:
            directory = os.getcwd()
        self.directory = directory
        if sys.version_info.minor &lt; 7:
            super().__init__(*args, **kwargs)
        else:
            super().__init__(*args, directory=directory, **kwargs)

    def do_GET(self):
        &quot;&quot;&quot;
        GET request handling
        &quot;&quot;&quot;
        none_match = self.headers.get(&quot;If-None-Match&quot;)
        status_code = 200
        try:
            # Retrieve the local file from the web root to serve to clients
            with salt.utils.files.fopen(
                os.path.join(self.directory, self.path[1:]), &quot;rb&quot;
            ) as reqfp:
                return_data = reqfp.read()
                # We're using this checksum as the etag to show file changes
                checksum = hashlib.md5(return_data).hexdigest()
                if none_match == checksum:
                    # Status code 304 Not Modified is returned if the file is unchanged
                    status_code = 304
        except:  # pylint: disable=bare-except
            # Something went wrong. We didn't find the requested file
            status_code = 404
            return_data = None
            checksum = None

        self.send_response(status_code)

        # Return the Etag header if we have the checksum
        if checksum:
            # IMPORTANT: This introduces randomness into the tests. The Etag header key
            # will be converted to lowercase in the code... but if someone breaks that,
            # it'll rear it's head here as random failures that are hard to reproduce.
            # Any alternatives seem overly complex. So... don't break the case insensitivity
            # in the code.
            possible_etags = [&quot;Etag&quot;, &quot;ETag&quot;, &quot;etag&quot;, &quot;ETAG&quot;]
            self.send_header(random.choice(possible_etags), checksum)
            self.end_headers()

        # Return file content
        if return_data:
            self.wfile.write(return_data)


def serve(port=8000, directory=None):
    &quot;&quot;&quot;
    Function to serve a directory via http.server
    &quot;&quot;&quot;
    handler = functools.partial(TestRequestHandler, directory=directory)
    s = http.server.HTTPServer((&quot;127.0.0.1&quot;, port), handler)
    s.serve_forever()


@pytest.fixture(scope=&quot;module&quot;)
def free_port():
    &quot;&quot;&quot;
    Utility fixture to grab a free port for the web server
    &quot;&quot;&quot;
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
        s.bind((&quot;&quot;, 0))
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        return s.getsockname()[1]


@pytest.fixture(autouse=True, scope=&quot;module&quot;)
def server(free_port, web_root):
    &quot;&quot;&quot;
    Web server fixture
    &quot;&quot;&quot;
    p = multiprocessing.Process(target=serve, args=(free_port, web_root))
    p.start()
    yield
    p.terminate()
    p.join()


@pytest.fixture(scope=&quot;module&quot;)
def web_root(tmp_path_factory):
    &quot;&quot;&quot;
    Temporary directory fixture for the web server root
    &quot;&quot;&quot;
    _web_root = tmp_path_factory.mktemp(&quot;web_root&quot;)
    try:
        yield str(_web_root)
    finally:
        shutil.rmtree(str(_web_root), ignore_errors=True)


def test_archive_extracted_web_source_etag_operation(
    modules, states, free_port, web_root, minion_opts
):
    &quot;&quot;&quot;
    This functional test checks the operation of the use_etag parameter to the
    archive.extracted state. There are four (4) invocations of archive.extracted
    with a web source, but only three (3) will trigger a call to the web server
    as shown below and in comments within.

        127.0.0.1 - - [08/Mar/2022 13:07:10] &quot;GET /foo.tar.gz HTTP/1.1&quot; 200 -
        127.0.0.1 - - [08/Mar/2022 13:07:10] &quot;GET /foo.tar.gz HTTP/1.1&quot; 304 -
        127.0.0.1 - - [08/Mar/2022 13:07:10] &quot;GET /foo.tar.gz HTTP/1.1&quot; 200 -

    Checks are documented in the comments.
    &quot;&quot;&quot;
    # Create file in the web root directory to serve
    states.file.managed(
        name=os.path.join(web_root, &quot;foo&quot;, &quot;bar.txt&quot;),
        contents=&quot;this is my file&quot;,
        makedirs=True,
    )
    modules.archive.tar(
        options=&quot;czf&quot;,
        tarfile=os.path.join(web_root, &quot;foo.tar.gz&quot;),
        sources=[os.path.join(web_root, &quot;foo&quot;)],
        cwd=web_root,
    )

    # File should not be cached yet
    cached_file = os.path.join(
        minion_opts[&quot;cachedir&quot;],
        &quot;extrn_files&quot;,
        &quot;base&quot;,
        &quot;localhost:{free_port}&quot;.format(free_port=free_port),
        &quot;foo.tar.gz&quot;,
    )
    cached_etag = cached_file + &quot;.etag&quot;
    assert not os.path.exists(cached_file)
    assert not os.path.exists(cached_etag)

    # Pull the file from the web server
    #     Web server returns 200 status code with content:
    #     127.0.0.1 - - [08/Mar/2022 13:07:10] &quot;GET /foo.tar.gz HTTP/1.1&quot; 200 -
    states.archive.extracted(
        name=web_root,
        source=&quot;http://localhost:{free_port}/foo.tar.gz&quot;.format(free_port=free_port),
        archive_format=&quot;tar&quot;,
        options=&quot;z&quot;,
        use_etag=True,
    )

    # Now the file is cached
    assert os.path.exists(cached_file)
    assert os.path.exists(cached_etag)

    # Store the original modified time of the cached file
    cached_file_mtime = os.path.getmtime(cached_file)

    # Pull the file again. Etag hasn't changed. No download occurs.
    #     Web server returns 304 status code and no content:
    #     127.0.0.1 - - [08/Mar/2022 13:07:10] &quot;GET /foo.tar.gz HTTP/1.1&quot; 304 -
    states.archive.extracted(
        name=web_root,
        source=&quot;http://localhost:{free_port}/foo.tar.gz&quot;.format(free_port=free_port),
        archive_format=&quot;tar&quot;,
        options=&quot;z&quot;,
        use_etag=True,
    )

    # Check that the modified time of the cached file hasn't changed
    assert cached_file_mtime == os.path.getmtime(cached_file)

    # Change file in the web root directory
    states.file.managed(
        name=os.path.join(web_root, &quot;foo&quot;, &quot;bar.txt&quot;),
        contents=&quot;this is my changed file&quot;,
    )
    modules.archive.tar(
        options=&quot;czf&quot;,
        tarfile=os.path.join(web_root, &quot;foo.tar.gz&quot;),
        sources=[os.path.join(web_root, &quot;foo&quot;)],
        cwd=web_root,
    )

    # Don't use Etag. Cached file is there, Salt won't try to download.
    #     No call to the web server will be made.
    states.archive.extracted(
        name=web_root,
        source=&quot;http://localhost:{free_port}/foo.tar.gz&quot;.format(free_port=free_port),
        archive_format=&quot;tar&quot;,
        options=&quot;z&quot;,
        use_etag=False,
    )

    # Check that the modified time of the cached file hasn't changed
    assert cached_file_mtime == os.path.getmtime(cached_file)

    # Now use Etag again. Cached file changes
    #     Web server returns 200 status code with content
    #     127.0.0.1 - - [08/Mar/2022 13:07:10] &quot;GET /foo.tar.gz HTTP/1.1&quot; 200 -
    states.archive.extracted(
        name=web_root,
        source=&quot;http://localhost:{free_port}/foo.tar.gz&quot;.format(free_port=free_port),
        archive_format=&quot;tar&quot;,
        options=&quot;z&quot;,
        use_etag=True,
    )

    # The modified time of the cached file now changes
    assert cached_file_mtime != os.path.getmtime(cached_file)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_basics.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match94559-0.html#0',2,'match94559-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import logging
import os
import shutil

import pytest
import salt.config
import salt.loader
import salt.modules.cmdmod as cmdmod
import salt.modules.config as configmod
import salt.modules.file as filemod
import salt.utils.data
import salt.utils.files
import</B></FONT> salt.utils.platform
import salt.utils.stringutils
from tests.support.mock import MagicMock, call, patch

log = logging.getLogger(__name__)


@pytest.fixture
def configure_loader_modules():
    return {
        filemod: {
            &quot;__salt__&quot;: {
                &quot;config.manage_mode&quot;: configmod.manage_mode,
                &quot;cmd.run&quot;: cmdmod.run,
                &quot;cmd.run_all&quot;: cmdmod.run_all,
            },
            &quot;__opts__&quot;: {
                &quot;test&quot;: False,
                &quot;file_roots&quot;: {&quot;base&quot;: &quot;tmp&quot;},
                &quot;pillar_roots&quot;: {&quot;base&quot;: &quot;tmp&quot;},
                &quot;cachedir&quot;: &quot;tmp&quot;,
                &quot;grains&quot;: {},
            },
            &quot;__grains__&quot;: {&quot;kernel&quot;: &quot;Linux&quot;},
        }
    }


@pytest.fixture
def tmp_sub_dir(tmp_path):
    directory = tmp_path / &quot;file-basics-test-dir&quot;
    directory.mkdir()

    yield directory

    shutil.rmtree(str(directory))


@pytest.fixture
def tfile(tmp_sub_dir):
    filename = str(tmp_sub_dir / &quot;file-basics-test-file&quot;)

    with salt.utils.files.fopen(filename, &quot;w+&quot;) as fp:
        fp.write(&quot;Hi hello! I am a file.&quot;)

    yield filename

    os.remove(filename)


@pytest.fixture
def myfile(tmp_sub_dir):
    filename = str(tmp_sub_dir / &quot;myfile&quot;)

    with salt.utils.files.fopen(filename, &quot;w+&quot;) as fp:
        fp.write(salt.utils.stringutils.to_str(&quot;Hello\n&quot;))

    yield filename

    os.remove(filename)


@pytest.fixture
def a_link(tmp_sub_dir):
    path = tmp_sub_dir / &quot;a_link&quot;
    linkname = str(path)

    yield linkname

    if path.exists():
        os.remove(linkname)


@pytest.fixture
def a_hardlink(tmp_sub_dir):
    path = tmp_sub_dir / &quot;a_hardlink&quot;
    linkname = str(path)

    yield linkname

    if path.exists():
        os.remove(linkname)


@pytest.mark.skip_on_windows(reason=&quot;os.symlink is not available on Windows&quot;)
def test_symlink_already_in_desired_state(tfile, a_link):
    os.symlink(tfile, a_link)
    result = filemod.symlink(tfile, a_link)
    assert result


@pytest.mark.skip_on_windows(reason=&quot;os.link is not available on Windows&quot;)
def test_hardlink_sanity(tfile, a_hardlink):
    target = a_hardlink
    result = filemod.link(tfile, target)
    assert result


@pytest.mark.skip_on_windows(reason=&quot;os.link is not available on Windows&quot;)
def test_hardlink_numlinks(tfile, a_hardlink):
    target = a_hardlink
    result = filemod.link(tfile, target)
    name_i = os.stat(tfile).st_nlink
    assert name_i &gt; 1


@pytest.mark.skip_on_windows(reason=&quot;os.link is not available on Windows&quot;)
def test_hardlink_working(tfile, a_hardlink):
    target = a_hardlink
    result = filemod.link(tfile, target)
    name_i = os.stat(tfile).st_ino
    target_i = os.stat(target).st_ino
    assert name_i == target_i


def test_source_list_for_list_returns_file_from_dict_via_http():
    with patch(&quot;salt.modules.file.os.remove&quot;) as remove:
        remove.return_value = None
        with patch.dict(
            filemod.__salt__,
            {
                &quot;cp.list_master&quot;: MagicMock(return_value=[]),
                &quot;cp.list_master_dirs&quot;: MagicMock(return_value=[]),
                &quot;cp.cache_file&quot;: MagicMock(return_value=&quot;/tmp/http.conf&quot;),
            },
        ):
            with patch(&quot;salt.utils.http.query&quot;) as http_query:
                http_query.return_value = {}
                ret = filemod.source_list(
                    [{&quot;http://t.est.com/http/httpd.conf&quot;: &quot;filehash&quot;}], &quot;&quot;, &quot;base&quot;
                )
                assert list(ret) == [&quot;http://t.est.com/http/httpd.conf&quot;, &quot;filehash&quot;]


def test_source_list_use_requests():
    with patch(&quot;salt.modules.file.os.remove&quot;) as remove:
        remove.return_value = None
        with patch.dict(
            filemod.__salt__,
            {
                &quot;cp.list_master&quot;: MagicMock(return_value=[]),
                &quot;cp.list_master_dirs&quot;: MagicMock(return_value=[]),
                &quot;cp.cache_file&quot;: MagicMock(return_value=&quot;/tmp/http.conf&quot;),
            },
        ):
            expected_call = call(
                &quot;http://t.est.com/http/file1&quot;,
                decode_body=False,
                method=&quot;HEAD&quot;,
            )
            with patch(
                &quot;salt.utils.http.query&quot;, MagicMock(return_value={})
            ) as http_query:
                ret = filemod.source_list(
                    [{&quot;http://t.est.com/http/file1&quot;: &quot;filehash&quot;}], &quot;&quot;, &quot;base&quot;
                )
                assert list(ret) == [&quot;http://t.est.com/http/file1&quot;, &quot;filehash&quot;]
                assert expected_call in http_query.mock_calls


def test_source_list_for_list_returns_existing_file():
    with patch.dict(
        filemod.__salt__,
        {
            &quot;cp.list_master&quot;: MagicMock(return_value=[&quot;http/httpd.conf.fallback&quot;]),
            &quot;cp.list_master_dirs&quot;: MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list(
            [&quot;salt://http/httpd.conf&quot;, &quot;salt://http/httpd.conf.fallback&quot;],
            &quot;filehash&quot;,
            &quot;base&quot;,
        )
        assert list(ret) == [&quot;salt://http/httpd.conf.fallback&quot;, &quot;filehash&quot;]


def test_source_list_for_list_returns_file_from_other_env():
    def list_master(env):
        dct = {&quot;base&quot;: [], &quot;dev&quot;: [&quot;http/httpd.conf&quot;]}
        return dct[env]

    with patch.dict(
        filemod.__salt__,
        {
            &quot;cp.list_master&quot;: MagicMock(side_effect=list_master),
            &quot;cp.list_master_dirs&quot;: MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list(
            [
                &quot;salt://http/httpd.conf?saltenv=dev&quot;,
                &quot;salt://http/httpd.conf.fallback&quot;,
            ],
            &quot;filehash&quot;,
            &quot;base&quot;,
        )
        assert list(ret) == [&quot;salt://http/httpd.conf?saltenv=dev&quot;, &quot;filehash&quot;]


def test_source_list_for_list_returns_file_from_dict():
    with patch.dict(
        filemod.__salt__,
        {
            &quot;cp.list_master&quot;: MagicMock(return_value=[&quot;http/httpd.conf&quot;]),
            &quot;cp.list_master_dirs&quot;: MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list([{&quot;salt://http/httpd.conf&quot;: &quot;&quot;}], &quot;filehash&quot;, &quot;base&quot;)
        assert list(ret) == [&quot;salt://http/httpd.conf&quot;, &quot;filehash&quot;]


def test_source_list_for_list_returns_existing_local_file_slash(myfile):
    with patch.dict(
        filemod.__salt__,
        {
            &quot;cp.list_master&quot;: MagicMock(return_value=[]),
            &quot;cp.list_master_dirs&quot;: MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list([myfile + &quot;-foo&quot;, myfile], &quot;filehash&quot;, &quot;base&quot;)
        assert list(ret) == [myfile, &quot;filehash&quot;]


def test_source_list_for_list_returns_existing_local_file_proto(myfile):
    with patch.dict(
        filemod.__salt__,
        {
            &quot;cp.list_master&quot;: MagicMock(return_value=[]),
            &quot;cp.list_master_dirs&quot;: MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list(
            [&quot;file://&quot; + myfile + &quot;-foo&quot;, &quot;file://&quot; + myfile],
            &quot;filehash&quot;,
            &quot;base&quot;,
        )
        assert list(ret) == [&quot;file://&quot; + myfile, &quot;filehash&quot;]


def test_source_list_for_list_returns_local_file_slash_from_dict(myfile):
    with patch.dict(
        filemod.__salt__,
        {
            &quot;cp.list_master&quot;: MagicMock(return_value=[]),
            &quot;cp.list_master_dirs&quot;: MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list([{myfile: &quot;&quot;}], &quot;filehash&quot;, &quot;base&quot;)
        assert list(ret) == [myfile, &quot;filehash&quot;]


def test_source_list_for_list_returns_local_file_proto_from_dict(myfile):
    with patch.dict(
        filemod.__salt__,
        {
            &quot;cp.list_master&quot;: MagicMock(return_value=[]),
            &quot;cp.list_master_dirs&quot;: MagicMock(return_value=[]),
        },
    ):
        ret = filemod.source_list([{&quot;file://&quot; + myfile: &quot;&quot;}], &quot;filehash&quot;, &quot;base&quot;)
        assert list(ret) == [&quot;file://&quot; + myfile, &quot;filehash&quot;]
</PRE>
</div>
  </div>
</body>
</html>
