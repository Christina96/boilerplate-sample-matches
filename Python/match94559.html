<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_archive.py &amp; test_file_basics.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_archive.py &amp; test_file_basics.py
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_archive.py (4.0540543%)<th>test_file_basics.py (3.2085562%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-13)<td><a href="#" name="0">(1-13)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_archive.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import functools
2 import hashlib
3 import http.server
4 import multiprocessing
5 import os
6 import random
7 import shutil
8 import socket
9 import sys
10 from contextlib import closing
11 import pytest
12 import</b></font> salt.utils.files
13 class TestRequestHandler(http.server.SimpleHTTPRequestHandler):
14     def __init__(self, *args, directory=None, **kwargs):
15         if directory is None:
16             directory = os.getcwd()
17         self.directory = directory
18         if sys.version_info.minor &lt; 7:
19             super().__init__(*args, **kwargs)
20         else:
21             super().__init__(*args, directory=directory, **kwargs)
22     def do_GET(self):
23         none_match = self.headers.get("If-None-Match")
24         status_code = 200
25         try:
26             with salt.utils.files.fopen(
27                 os.path.join(self.directory, self.path[1:]), "rb"
28             ) as reqfp:
29                 return_data = reqfp.read()
30                 checksum = hashlib.md5(return_data).hexdigest()
31                 if none_match == checksum:
32                     status_code = 304
33         except:  # pylint: disable=bare-except
34             status_code = 404
35             return_data = None
36             checksum = None
37         self.send_response(status_code)
38         if checksum:
39             possible_etags = ["Etag", "ETag", "etag", "ETAG"]
40             self.send_header(random.choice(possible_etags), checksum)
41             self.end_headers()
42         if return_data:
43             self.wfile.write(return_data)
44 def serve(port=8000, directory=None):
45     handler = functools.partial(TestRequestHandler, directory=directory)
46     s = http.server.HTTPServer(("127.0.0.1", port), handler)
47     s.serve_forever()
48 @pytest.fixture(scope="module")
49 def free_port():
50     with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
51         s.bind(("", 0))
52         s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
53         return s.getsockname()[1]
54 @pytest.fixture(autouse=True, scope="module")
55 def server(free_port, web_root):
56     p = multiprocessing.Process(target=serve, args=(free_port, web_root))
57     p.start()
58     yield
59     p.terminate()
60     p.join()
61 @pytest.fixture(scope="module")
62 def web_root(tmp_path_factory):
63     _web_root = tmp_path_factory.mktemp("web_root")
64     try:
65         yield str(_web_root)
66     finally:
67         shutil.rmtree(str(_web_root), ignore_errors=True)
68 def test_archive_extracted_web_source_etag_operation(
69     modules, states, free_port, web_root, minion_opts
70 ):
71     states.file.managed(
72         name=os.path.join(web_root, "foo", "bar.txt"),
73         contents="this is my file",
74         makedirs=True,
75     )
76     modules.archive.tar(
77         options="czf",
78         tarfile=os.path.join(web_root, "foo.tar.gz"),
79         sources=[os.path.join(web_root, "foo")],
80         cwd=web_root,
81     )
82     cached_file = os.path.join(
83         minion_opts["cachedir"],
84         "extrn_files",
85         "base",
86         "localhost:{free_port}".format(free_port=free_port),
87         "foo.tar.gz",
88     )
89     cached_etag = cached_file + ".etag"
90     assert not os.path.exists(cached_file)
91     assert not os.path.exists(cached_etag)
92     states.archive.extracted(
93         name=web_root,
94         source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
95         archive_format="tar",
96         options="z",
97         use_etag=True,
98     )
99     assert os.path.exists(cached_file)
100     assert os.path.exists(cached_etag)
101     cached_file_mtime = os.path.getmtime(cached_file)
102     states.archive.extracted(
103         name=web_root,
104         source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
105         archive_format="tar",
106         options="z",
107         use_etag=True,
108     )
109     assert cached_file_mtime == os.path.getmtime(cached_file)
110     states.file.managed(
111         name=os.path.join(web_root, "foo", "bar.txt"),
112         contents="this is my changed file",
113     )
114     modules.archive.tar(
115         options="czf",
116         tarfile=os.path.join(web_root, "foo.tar.gz"),
117         sources=[os.path.join(web_root, "foo")],
118         cwd=web_root,
119     )
120     states.archive.extracted(
121         name=web_root,
122         source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
123         archive_format="tar",
124         options="z",
125         use_etag=False,
126     )
127     assert cached_file_mtime == os.path.getmtime(cached_file)
128     states.archive.extracted(
129         name=web_root,
130         source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
131         archive_format="tar",
132         options="z",
133         use_etag=True,
134     )
135     assert cached_file_mtime != os.path.getmtime(cached_file)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_basics.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
2 import os
3 import shutil
4 import pytest
5 import salt.config
6 import salt.loader
7 import salt.modules.cmdmod as cmdmod
8 import salt.modules.config as configmod
9 import salt.modules.file as filemod
10 import salt.utils.data
11 import salt.utils.files
12 import</b></font> salt.utils.platform
13 import salt.utils.stringutils
14 from tests.support.mock import MagicMock, call, patch
15 log = logging.getLogger(__name__)
16 @pytest.fixture
17 def configure_loader_modules():
18     return {
19         filemod: {
20             "__salt__": {
21                 "config.manage_mode": configmod.manage_mode,
22                 "cmd.run": cmdmod.run,
23                 "cmd.run_all": cmdmod.run_all,
24             },
25             "__opts__": {
26                 "test": False,
27                 "file_roots": {"base": "tmp"},
28                 "pillar_roots": {"base": "tmp"},
29                 "cachedir": "tmp",
30                 "grains": {},
31             },
32             "__grains__": {"kernel": "Linux"},
33         }
34     }
35 @pytest.fixture
36 def tmp_sub_dir(tmp_path):
37     directory = tmp_path / "file-basics-test-dir"
38     directory.mkdir()
39     yield directory
40     shutil.rmtree(str(directory))
41 @pytest.fixture
42 def tfile(tmp_sub_dir):
43     filename = str(tmp_sub_dir / "file-basics-test-file")
44     with salt.utils.files.fopen(filename, "w+") as fp:
45         fp.write("Hi hello! I am a file.")
46     yield filename
47     os.remove(filename)
48 @pytest.fixture
49 def myfile(tmp_sub_dir):
50     filename = str(tmp_sub_dir / "myfile")
51     with salt.utils.files.fopen(filename, "w+") as fp:
52         fp.write(salt.utils.stringutils.to_str("Hello\n"))
53     yield filename
54     os.remove(filename)
55 @pytest.fixture
56 def a_link(tmp_sub_dir):
57     path = tmp_sub_dir / "a_link"
58     linkname = str(path)
59     yield linkname
60     if path.exists():
61         os.remove(linkname)
62 @pytest.fixture
63 def a_hardlink(tmp_sub_dir):
64     path = tmp_sub_dir / "a_hardlink"
65     linkname = str(path)
66     yield linkname
67     if path.exists():
68         os.remove(linkname)
69 @pytest.mark.skip_on_windows(reason="os.symlink is not available on Windows")
70 def test_symlink_already_in_desired_state(tfile, a_link):
71     os.symlink(tfile, a_link)
72     result = filemod.symlink(tfile, a_link)
73     assert result
74 @pytest.mark.skip_on_windows(reason="os.link is not available on Windows")
75 def test_hardlink_sanity(tfile, a_hardlink):
76     target = a_hardlink
77     result = filemod.link(tfile, target)
78     assert result
79 @pytest.mark.skip_on_windows(reason="os.link is not available on Windows")
80 def test_hardlink_numlinks(tfile, a_hardlink):
81     target = a_hardlink
82     result = filemod.link(tfile, target)
83     name_i = os.stat(tfile).st_nlink
84     assert name_i &gt; 1
85 @pytest.mark.skip_on_windows(reason="os.link is not available on Windows")
86 def test_hardlink_working(tfile, a_hardlink):
87     target = a_hardlink
88     result = filemod.link(tfile, target)
89     name_i = os.stat(tfile).st_ino
90     target_i = os.stat(target).st_ino
91     assert name_i == target_i
92 def test_source_list_for_list_returns_file_from_dict_via_http():
93     with patch("salt.modules.file.os.remove") as remove:
94         remove.return_value = None
95         with patch.dict(
96             filemod.__salt__,
97             {
98                 "cp.list_master": MagicMock(return_value=[]),
99                 "cp.list_master_dirs": MagicMock(return_value=[]),
100                 "cp.cache_file": MagicMock(return_value="/tmp/http.conf"),
101             },
102         ):
103             with patch("salt.utils.http.query") as http_query:
104                 http_query.return_value = {}
105                 ret = filemod.source_list(
106                     [{"http://t.est.com/http/httpd.conf": "filehash"}], "", "base"
107                 )
108                 assert list(ret) == ["http://t.est.com/http/httpd.conf", "filehash"]
109 def test_source_list_use_requests():
110     with patch("salt.modules.file.os.remove") as remove:
111         remove.return_value = None
112         with patch.dict(
113             filemod.__salt__,
114             {
115                 "cp.list_master": MagicMock(return_value=[]),
116                 "cp.list_master_dirs": MagicMock(return_value=[]),
117                 "cp.cache_file": MagicMock(return_value="/tmp/http.conf"),
118             },
119         ):
120             expected_call = call(
121                 "http://t.est.com/http/file1",
122                 decode_body=False,
123                 method="HEAD",
124             )
125             with patch(
126                 "salt.utils.http.query", MagicMock(return_value={})
127             ) as http_query:
128                 ret = filemod.source_list(
129                     [{"http://t.est.com/http/file1": "filehash"}], "", "base"
130                 )
131                 assert list(ret) == ["http://t.est.com/http/file1", "filehash"]
132                 assert expected_call in http_query.mock_calls
133 def test_source_list_for_list_returns_existing_file():
134     with patch.dict(
135         filemod.__salt__,
136         {
137             "cp.list_master": MagicMock(return_value=["http/httpd.conf.fallback"]),
138             "cp.list_master_dirs": MagicMock(return_value=[]),
139         },
140     ):
141         ret = filemod.source_list(
142             ["salt://http/httpd.conf", "salt://http/httpd.conf.fallback"],
143             "filehash",
144             "base",
145         )
146         assert list(ret) == ["salt://http/httpd.conf.fallback", "filehash"]
147 def test_source_list_for_list_returns_file_from_other_env():
148     def list_master(env):
149         dct = {"base": [], "dev": ["http/httpd.conf"]}
150         return dct[env]
151     with patch.dict(
152         filemod.__salt__,
153         {
154             "cp.list_master": MagicMock(side_effect=list_master),
155             "cp.list_master_dirs": MagicMock(return_value=[]),
156         },
157     ):
158         ret = filemod.source_list(
159             [
160                 "salt://http/httpd.conf?saltenv=dev",
161                 "salt://http/httpd.conf.fallback",
162             ],
163             "filehash",
164             "base",
165         )
166         assert list(ret) == ["salt://http/httpd.conf?saltenv=dev", "filehash"]
167 def test_source_list_for_list_returns_file_from_dict():
168     with patch.dict(
169         filemod.__salt__,
170         {
171             "cp.list_master": MagicMock(return_value=["http/httpd.conf"]),
172             "cp.list_master_dirs": MagicMock(return_value=[]),
173         },
174     ):
175         ret = filemod.source_list([{"salt://http/httpd.conf": ""}], "filehash", "base")
176         assert list(ret) == ["salt://http/httpd.conf", "filehash"]
177 def test_source_list_for_list_returns_existing_local_file_slash(myfile):
178     with patch.dict(
179         filemod.__salt__,
180         {
181             "cp.list_master": MagicMock(return_value=[]),
182             "cp.list_master_dirs": MagicMock(return_value=[]),
183         },
184     ):
185         ret = filemod.source_list([myfile + "-foo", myfile], "filehash", "base")
186         assert list(ret) == [myfile, "filehash"]
187 def test_source_list_for_list_returns_existing_local_file_proto(myfile):
188     with patch.dict(
189         filemod.__salt__,
190         {
191             "cp.list_master": MagicMock(return_value=[]),
192             "cp.list_master_dirs": MagicMock(return_value=[]),
193         },
194     ):
195         ret = filemod.source_list(
196             ["file://" + myfile + "-foo", "file://" + myfile],
197             "filehash",
198             "base",
199         )
200         assert list(ret) == ["file://" + myfile, "filehash"]
201 def test_source_list_for_list_returns_local_file_slash_from_dict(myfile):
202     with patch.dict(
203         filemod.__salt__,
204         {
205             "cp.list_master": MagicMock(return_value=[]),
206             "cp.list_master_dirs": MagicMock(return_value=[]),
207         },
208     ):
209         ret = filemod.source_list([{myfile: ""}], "filehash", "base")
210         assert list(ret) == [myfile, "filehash"]
211 def test_source_list_for_list_returns_local_file_proto_from_dict(myfile):
212     with patch.dict(
213         filemod.__salt__,
214         {
215             "cp.list_master": MagicMock(return_value=[]),
216             "cp.list_master_dirs": MagicMock(return_value=[]),
217         },
218     ):
219         ret = filemod.source_list([{"file://" + myfile: ""}], "filehash", "base")
220         assert list(ret) == ["file://" + myfile, "filehash"]
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
