<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_archive.py &amp; test_file_basics.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_archive.py &amp; test_file_basics.py
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_archive.py (4.0540543%)<th>test_file_basics.py (3.2085562%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-13)<td><a href="#" name="0">(1-13)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_archive.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import hashlib
2 import http.server
3 import multiprocessing
4 import os
5 import random
6 import shutil
7 import socket
8 import sys
9 from contextlib import closing
10 import pytest
11 import</b></font> salt.utils.files
12 class TestRequestHandler(http.server.SimpleHTTPRequestHandler):
13     def __init__(self, *args, directory=None, **kwargs):
14         if directory is None:
15             directory = os.getcwd()
16         self.directory = directory
17         if sys.version_info.minor &lt; 7:
18             super().__init__(*args, **kwargs)
19         else:
20             super().__init__(*args, directory=directory, **kwargs)
21     def do_GET(self):
22         none_match = self.headers.get("If-None-Match")
23         status_code = 200
24         try:
25             with salt.utils.files.fopen(
26                 os.path.join(self.directory, self.path[1:]), "rb"
27             ) as reqfp:
28                 return_data = reqfp.read()
29                 checksum = hashlib.md5(return_data).hexdigest()
30                 if none_match == checksum:
31                     status_code = 304
32         except:  # pylint: disable=bare-except
33             status_code = 404
34             return_data = None
35             checksum = None
36         self.send_response(status_code)
37         if checksum:
38             possible_etags = ["Etag", "ETag", "etag", "ETAG"]
39             self.send_header(random.choice(possible_etags), checksum)
40             self.end_headers()
41         if return_data:
42             self.wfile.write(return_data)
43 def serve(port=8000, directory=None):
44     handler = functools.partial(TestRequestHandler, directory=directory)
45     s = http.server.HTTPServer(("127.0.0.1", port), handler)
46     s.serve_forever()
47 @pytest.fixture(scope="module")
48 def free_port():
49     with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
50         s.bind(("", 0))
51         s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
52         return s.getsockname()[1]
53 @pytest.fixture(autouse=True, scope="module")
54 def server(free_port, web_root):
55     p = multiprocessing.Process(target=serve, args=(free_port, web_root))
56     p.start()
57     yield
58     p.terminate()
59     p.join()
60 @pytest.fixture(scope="module")
61 def web_root(tmp_path_factory):
62     _web_root = tmp_path_factory.mktemp("web_root")
63     try:
64         yield str(_web_root)
65     finally:
66         shutil.rmtree(str(_web_root), ignore_errors=True)
67 def test_archive_extracted_web_source_etag_operation(
68     modules, states, free_port, web_root, minion_opts
69 ):
70     states.file.managed(
71         name=os.path.join(web_root, "foo", "bar.txt"),
72         contents="this is my file",
73         makedirs=True,
74     )
75     modules.archive.tar(
76         options="czf",
77         tarfile=os.path.join(web_root, "foo.tar.gz"),
78         sources=[os.path.join(web_root, "foo")],
79         cwd=web_root,
80     )
81     cached_file = os.path.join(
82         minion_opts["cachedir"],
83         "extrn_files",
84         "base",
85         "localhost:{free_port}".format(free_port=free_port),
86         "foo.tar.gz",
87     )
88     cached_etag = cached_file + ".etag"
89     assert not os.path.exists(cached_file)
90     assert not os.path.exists(cached_etag)
91     states.archive.extracted(
92         name=web_root,
93         source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
94         archive_format="tar",
95         options="z",
96         use_etag=True,
97     )
98     assert os.path.exists(cached_file)
99     assert os.path.exists(cached_etag)
100     cached_file_mtime = os.path.getmtime(cached_file)
101     states.archive.extracted(
102         name=web_root,
103         source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
104         archive_format="tar",
105         options="z",
106         use_etag=True,
107     )
108     assert cached_file_mtime == os.path.getmtime(cached_file)
109     states.file.managed(
110         name=os.path.join(web_root, "foo", "bar.txt"),
111         contents="this is my changed file",
112     )
113     modules.archive.tar(
114         options="czf",
115         tarfile=os.path.join(web_root, "foo.tar.gz"),
116         sources=[os.path.join(web_root, "foo")],
117         cwd=web_root,
118     )
119     states.archive.extracted(
120         name=web_root,
121         source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
122         archive_format="tar",
123         options="z",
124         use_etag=False,
125     )
126     assert cached_file_mtime == os.path.getmtime(cached_file)
127     states.archive.extracted(
128         name=web_root,
129         source="http://localhost:{free_port}/foo.tar.gz".format(free_port=free_port),
130         archive_format="tar",
131         options="z",
132         use_etag=True,
133     )
134     assert cached_file_mtime != os.path.getmtime(cached_file)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_basics.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import shutil
3 import pytest
4 import salt.config
5 import salt.loader
6 import salt.modules.cmdmod as cmdmod
7 import salt.modules.config as configmod
8 import salt.modules.file as filemod
9 import salt.utils.data
10 import salt.utils.files
11 import</b></font> salt.utils.platform
12 import salt.utils.stringutils
13 from tests.support.mock import MagicMock, call, patch
14 log = logging.getLogger(__name__)
15 @pytest.fixture
16 def configure_loader_modules():
17     return {
18         filemod: {
19             "__salt__": {
20                 "config.manage_mode": configmod.manage_mode,
21                 "cmd.run": cmdmod.run,
22                 "cmd.run_all": cmdmod.run_all,
23             },
24             "__opts__": {
25                 "test": False,
26                 "file_roots": {"base": "tmp"},
27                 "pillar_roots": {"base": "tmp"},
28                 "cachedir": "tmp",
29                 "grains": {},
30             },
31             "__grains__": {"kernel": "Linux"},
32         }
33     }
34 @pytest.fixture
35 def tmp_sub_dir(tmp_path):
36     directory = tmp_path / "file-basics-test-dir"
37     directory.mkdir()
38     yield directory
39     shutil.rmtree(str(directory))
40 @pytest.fixture
41 def tfile(tmp_sub_dir):
42     filename = str(tmp_sub_dir / "file-basics-test-file")
43     with salt.utils.files.fopen(filename, "w+") as fp:
44         fp.write("Hi hello! I am a file.")
45     yield filename
46     os.remove(filename)
47 @pytest.fixture
48 def myfile(tmp_sub_dir):
49     filename = str(tmp_sub_dir / "myfile")
50     with salt.utils.files.fopen(filename, "w+") as fp:
51         fp.write(salt.utils.stringutils.to_str("Hello\n"))
52     yield filename
53     os.remove(filename)
54 @pytest.fixture
55 def a_link(tmp_sub_dir):
56     path = tmp_sub_dir / "a_link"
57     linkname = str(path)
58     yield linkname
59     if path.exists():
60         os.remove(linkname)
61 @pytest.fixture
62 def a_hardlink(tmp_sub_dir):
63     path = tmp_sub_dir / "a_hardlink"
64     linkname = str(path)
65     yield linkname
66     if path.exists():
67         os.remove(linkname)
68 @pytest.mark.skip_on_windows(reason="os.symlink is not available on Windows")
69 def test_symlink_already_in_desired_state(tfile, a_link):
70     os.symlink(tfile, a_link)
71     result = filemod.symlink(tfile, a_link)
72     assert result
73 @pytest.mark.skip_on_windows(reason="os.link is not available on Windows")
74 def test_hardlink_sanity(tfile, a_hardlink):
75     target = a_hardlink
76     result = filemod.link(tfile, target)
77     assert result
78 @pytest.mark.skip_on_windows(reason="os.link is not available on Windows")
79 def test_hardlink_numlinks(tfile, a_hardlink):
80     target = a_hardlink
81     result = filemod.link(tfile, target)
82     name_i = os.stat(tfile).st_nlink
83     assert name_i &gt; 1
84 @pytest.mark.skip_on_windows(reason="os.link is not available on Windows")
85 def test_hardlink_working(tfile, a_hardlink):
86     target = a_hardlink
87     result = filemod.link(tfile, target)
88     name_i = os.stat(tfile).st_ino
89     target_i = os.stat(target).st_ino
90     assert name_i == target_i
91 def test_source_list_for_list_returns_file_from_dict_via_http():
92     with patch("salt.modules.file.os.remove") as remove:
93         remove.return_value = None
94         with patch.dict(
95             filemod.__salt__,
96             {
97                 "cp.list_master": MagicMock(return_value=[]),
98                 "cp.list_master_dirs": MagicMock(return_value=[]),
99                 "cp.cache_file": MagicMock(return_value="/tmp/http.conf"),
100             },
101         ):
102             with patch("salt.utils.http.query") as http_query:
103                 http_query.return_value = {}
104                 ret = filemod.source_list(
105                     [{"http://t.est.com/http/httpd.conf": "filehash"}], "", "base"
106                 )
107                 assert list(ret) == ["http://t.est.com/http/httpd.conf", "filehash"]
108 def test_source_list_use_requests():
109     with patch("salt.modules.file.os.remove") as remove:
110         remove.return_value = None
111         with patch.dict(
112             filemod.__salt__,
113             {
114                 "cp.list_master": MagicMock(return_value=[]),
115                 "cp.list_master_dirs": MagicMock(return_value=[]),
116                 "cp.cache_file": MagicMock(return_value="/tmp/http.conf"),
117             },
118         ):
119             expected_call = call(
120                 "http://t.est.com/http/file1",
121                 decode_body=False,
122                 method="HEAD",
123             )
124             with patch(
125                 "salt.utils.http.query", MagicMock(return_value={})
126             ) as http_query:
127                 ret = filemod.source_list(
128                     [{"http://t.est.com/http/file1": "filehash"}], "", "base"
129                 )
130                 assert list(ret) == ["http://t.est.com/http/file1", "filehash"]
131                 assert expected_call in http_query.mock_calls
132 def test_source_list_for_list_returns_existing_file():
133     with patch.dict(
134         filemod.__salt__,
135         {
136             "cp.list_master": MagicMock(return_value=["http/httpd.conf.fallback"]),
137             "cp.list_master_dirs": MagicMock(return_value=[]),
138         },
139     ):
140         ret = filemod.source_list(
141             ["salt://http/httpd.conf", "salt://http/httpd.conf.fallback"],
142             "filehash",
143             "base",
144         )
145         assert list(ret) == ["salt://http/httpd.conf.fallback", "filehash"]
146 def test_source_list_for_list_returns_file_from_other_env():
147     def list_master(env):
148         dct = {"base": [], "dev": ["http/httpd.conf"]}
149         return dct[env]
150     with patch.dict(
151         filemod.__salt__,
152         {
153             "cp.list_master": MagicMock(side_effect=list_master),
154             "cp.list_master_dirs": MagicMock(return_value=[]),
155         },
156     ):
157         ret = filemod.source_list(
158             [
159                 "salt://http/httpd.conf?saltenv=dev",
160                 "salt://http/httpd.conf.fallback",
161             ],
162             "filehash",
163             "base",
164         )
165         assert list(ret) == ["salt://http/httpd.conf?saltenv=dev", "filehash"]
166 def test_source_list_for_list_returns_file_from_dict():
167     with patch.dict(
168         filemod.__salt__,
169         {
170             "cp.list_master": MagicMock(return_value=["http/httpd.conf"]),
171             "cp.list_master_dirs": MagicMock(return_value=[]),
172         },
173     ):
174         ret = filemod.source_list([{"salt://http/httpd.conf": ""}], "filehash", "base")
175         assert list(ret) == ["salt://http/httpd.conf", "filehash"]
176 def test_source_list_for_list_returns_existing_local_file_slash(myfile):
177     with patch.dict(
178         filemod.__salt__,
179         {
180             "cp.list_master": MagicMock(return_value=[]),
181             "cp.list_master_dirs": MagicMock(return_value=[]),
182         },
183     ):
184         ret = filemod.source_list([myfile + "-foo", myfile], "filehash", "base")
185         assert list(ret) == [myfile, "filehash"]
186 def test_source_list_for_list_returns_existing_local_file_proto(myfile):
187     with patch.dict(
188         filemod.__salt__,
189         {
190             "cp.list_master": MagicMock(return_value=[]),
191             "cp.list_master_dirs": MagicMock(return_value=[]),
192         },
193     ):
194         ret = filemod.source_list(
195             ["file://" + myfile + "-foo", "file://" + myfile],
196             "filehash",
197             "base",
198         )
199         assert list(ret) == ["file://" + myfile, "filehash"]
200 def test_source_list_for_list_returns_local_file_slash_from_dict(myfile):
201     with patch.dict(
202         filemod.__salt__,
203         {
204             "cp.list_master": MagicMock(return_value=[]),
205             "cp.list_master_dirs": MagicMock(return_value=[]),
206         },
207     ):
208         ret = filemod.source_list([{myfile: ""}], "filehash", "base")
209         assert list(ret) == [myfile, "filehash"]
210 def test_source_list_for_list_returns_local_file_proto_from_dict(myfile):
211     with patch.dict(
212         filemod.__salt__,
213         {
214             "cp.list_master": MagicMock(return_value=[]),
215             "cp.list_master_dirs": MagicMock(return_value=[]),
216         },
217     ):
218         ret = filemod.source_list([{"file://" + myfile: ""}], "filehash", "base")
219         assert list(ret) == ["file://" + myfile, "filehash"]
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
