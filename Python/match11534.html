<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for submit.py &amp; connection_8.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for submit.py &amp; connection_8.py
      </h3>
<h1 align="center">
        3.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>submit.py (10.526316%)<th>connection_8.py (2.2031825%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(56-59)<td><a href="#" name="0">(371-377)</a><td align="center"><font color="#ff0000">18</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>submit.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import time
2 import os
3 class Submitter(object):
4     def __init__(self, sd):
5         self.sd = sd
6         self.input_bucket = self.sd.get_obj('input_bucket')
7         self.output_bucket = self.sd.get_obj('output_bucket')
8         self.output_domain = self.sd.get_obj('output_domain')
9         self.queue = self.sd.get_obj('input_queue')
10     def get_key_name(self, fullpath, prefix):
11         key_name = fullpath[len(prefix):]
12         l = key_name.split(os.sep)
13         return '/'.join(l)
14     def write_message(self, key, metadata):
15         if self.queue:
16             m = self.queue.new_message()
17             m.for_key(key, metadata)
18             if self.output_bucket:
19                 m['OutputBucket'] = self.output_bucket.name
20             self.queue.write(m)
21     def submit_file(self, path, metadata=None, cb=None, num_cb=0, prefix='/'):
22         if not metadata:
23             metadata = {}
24         key_name = self.get_key_name(path, prefix)
25         k = self.input_bucket.new_key(key_name)
26         k.update_metadata(metadata)
27 <a name="0"></a>        k.set_contents_from_filename(path, replace=False, cb=cb, num_cb=num_cb)
28         self.write_message(k, metadata)
29     def submit_path(self, path, tags<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, ignore_dirs=None, cb=None, num_cb=0, status=False, prefix='/'):
30         path = os.path.expanduser(path)
31         path = os.path.expandvars(path)
32         path = os.path.abspath(</b></font>path)
33         total = 0
34         metadata = {}
35         if tags:
36             metadata['Tags'] = tags
37         l = []
38         for t in time.gmtime():
39             l.append(str(t))
40         metadata['Batch'] = '_'.join(l)
41         if self.output_domain:
42             self.output_domain.put_attributes(metadata['Batch'], {'type' : 'Batch'})
43         if os.path.isdir(path):
44             for root, dirs, files in os.walk(path):
45                 if ignore_dirs:
46                     for ignore in ignore_dirs:
47                         if ignore in dirs:
48                             dirs.remove(ignore)
49                 for file in files:
50                     fullpath = os.path.join(root, file)
51                     if status:
52                         print('Submitting %s' % fullpath)
53                     self.submit_file(fullpath, metadata, cb, num_cb, prefix)
54                     total += 1
55         elif os.path.isfile(path):
56             self.submit_file(path, metadata, cb, num_cb)
57             total += 1
58         else:
59             print('problem with %s' % path)
60         return (metadata['Batch'], total)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>connection_8.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import xml.sax
2 import base64
3 import time
4 from boto.compat import six, urllib
5 from boto.auth import detect_potential_s3sigv4
6 import boto.utils
7 from boto.connection import AWSAuthConnection
8 from boto import handler
9 from boto.s3.bucket import Bucket
10 from boto.s3.key import Key
11 from boto.resultset import ResultSet
12 from boto.exception import BotoClientError, S3ResponseError
13 from boto.utils import get_utf8able_str
14 def check_lowercase_bucketname(n):
15     if not (n + 'a').islower():
16         raise BotoClientError("Bucket names cannot contain upper-case " \
17             "characters when using either the sub-domain or virtual " \
18             "hosting calling format.")
19     return True
20 def assert_case_insensitive(f):
21     def wrapper(*args, **kwargs):
22         if len(args) == 3 and check_lowercase_bucketname(args[2]):
23             pass
24         return f(*args, **kwargs)
25     return wrapper
26 class _CallingFormat(object):
27     def get_bucket_server(self, server, bucket):
28         return ''
29     def build_url_base(self, connection, protocol, server, bucket, key=''):
30         url_base = '%s://' % protocol
31         url_base += self.build_host(server, bucket)
32         url_base += connection.get_path(self.build_path_base(bucket, key))
33         return url_base
34     def build_host(self, server, bucket):
35         if bucket == '':
36             return server
37         else:
38             return self.get_bucket_server(server, bucket)
39     def build_auth_path(self, bucket, key=''):
40         key = get_utf8able_str(key)
41         if isinstance(bucket, bytes):
42             bucket = bucket.decode('utf-8')
43         path = ''
44         if bucket != '':
45             path = '/' + bucket
46         return path + '/%s' % urllib.parse.quote(key)
47     def build_path_base(self, bucket, key=''):
48         key = get_utf8able_str(key)
49         return '/%s' % urllib.parse.quote(key)
50 class SubdomainCallingFormat(_CallingFormat):
51     @assert_case_insensitive
52     def get_bucket_server(self, server, bucket):
53         return '%s.%s' % (bucket, server)
54 class VHostCallingFormat(_CallingFormat):
55     @assert_case_insensitive
56     def get_bucket_server(self, server, bucket):
57         return bucket
58 class OrdinaryCallingFormat(_CallingFormat):
59     def get_bucket_server(self, server, bucket):
60         return server
61     def build_path_base(self, bucket, key=''):
62         key = get_utf8able_str(key)
63         path_base = '/'
64         if bucket:
65             path_base += "%s/" % bucket
66         return path_base + urllib.parse.quote(key)
67 class ProtocolIndependentOrdinaryCallingFormat(OrdinaryCallingFormat):
68     def build_url_base(self, connection, protocol, server, bucket, key=''):
69         url_base = '//'
70         url_base += self.build_host(server, bucket)
71         url_base += connection.get_path(self.build_path_base(bucket, key))
72         return url_base
73 class Location(object):
74     DEFAULT = ''  # US Classic Region
75     EU = 'EU'  # Ireland
76     EUCentral1 = 'eu-central-1'  # Frankfurt
77     USWest = 'us-west-1'
78     USWest2 = 'us-west-2'
79     SAEast = 'sa-east-1'
80     APNortheast = 'ap-northeast-1'
81     APSoutheast = 'ap-southeast-1'
82     APSoutheast2 = 'ap-southeast-2'
83     CNNorth1 = 'cn-north-1'
84 class NoHostProvided(object):
85     pass
86 class HostRequiredError(BotoClientError):
87     pass
88 class S3Connection(AWSAuthConnection):
89     DefaultHost = 's3.amazonaws.com'
90     DefaultCallingFormat = boto.config.get('s3', 'calling_format', 'boto.s3.connection.SubdomainCallingFormat')
91     QueryString = 'Signature=%s&amp;Expires=%d&amp;AWSAccessKeyId=%s'
92     def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
93                  is_secure=True, port=None, proxy=None, proxy_port=None,
94                  proxy_user=None, proxy_pass=None,
95                  host=NoHostProvided, debug=0, https_connection_factory=None,
96                  calling_format=DefaultCallingFormat, path='/',
97                  provider='aws', bucket_class=Bucket, security_token=None,
98                  suppress_consec_slashes=True, anon=None,
99                  validate_certs=None, profile_name=None):
100         self.bucket_class = bucket_class
101         if isinstance(calling_format, six.string_types):
102             calling_format=boto.utils.find_class(calling_format)()
103         self.calling_format = calling_format
104         if anon is None:
105             anon = boto.config.getbool('s3', 'no_sign_request', False)
106         self.anon = anon
107         no_host_provided = False
108         if host is NoHostProvided:
109             host = boto.config.get('s3', 'host')
110             if host is None:
111                 host = self.DefaultHost
112                 no_host_provided = True
113         super(S3Connection, self).__init__(host,
114                 aws_access_key_id, aws_secret_access_key,
115                 is_secure, port, proxy, proxy_port, proxy_user, proxy_pass,
116                 debug=debug, https_connection_factory=https_connection_factory,
117                 path=path, provider=provider, security_token=security_token,
118                 suppress_consec_slashes=suppress_consec_slashes,
119                 validate_certs=validate_certs, profile_name=profile_name)
120         if no_host_provided:
121             if 'hmac-v4-s3' in self._required_auth_capability():
122                 raise HostRequiredError(
123                     "When using SigV4, you must specify a 'host' parameter."
124                 )
125     @detect_potential_s3sigv4
126     def _required_auth_capability(self):
127         if self.anon:
128             return ['anon']
129         else:
130             return ['s3']
131     def __iter__(self):
132         for bucket in self.get_all_buckets():
133             yield bucket
134     def __contains__(self, bucket_name):
135         return not (self.lookup(bucket_name) is None)
136     def set_bucket_class(self, bucket_class):
137         self.bucket_class = bucket_class
138     def build_post_policy(self, expiration_time, conditions):
139         assert isinstance(expiration_time, time.struct_time), \
140             'Policy document must include a valid expiration Time object'
141         return '{"expiration": "%s",\n"conditions": [%s]}' % \
142             (time.strftime(boto.utils.ISO8601, expiration_time), ",".join(conditions))
143     def build_post_form_args(self, bucket_name, key, expires_in=6000,
144                              acl=None, success_action_redirect=None,
145                              max_content_length=None,
146                              http_method='http', fields=None,
147                              conditions=None, storage_class='STANDARD',
148                              server_side_encryption=None):
149         if fields is None:
150             fields = []
151         if conditions is None:
152             conditions = []
153         expiration = time.gmtime(int(time.time() + expires_in))
154         conditions.append('{"bucket": "%s"}' % bucket_name)
155         if key.endswith("${filename}"):
156             conditions.append('["starts-with", "$key", "%s"]' % key[:-len("${filename}")])
157         else:
158             conditions.append('{"key": "%s"}' % key)
159         if acl:
160             conditions.append('{"acl": "%s"}' % acl)
161             fields.append({"name": "acl", "value": acl})
162         if success_action_redirect:
163             conditions.append('{"success_action_redirect": "%s"}' % success_action_redirect)
164             fields.append({"name": "success_action_redirect", "value": success_action_redirect})
165         if max_content_length:
166             conditions.append('["content-length-range", 0, %i]' % max_content_length)
167         if self.provider.security_token:
168             fields.append({'name': 'x-amz-security-token',
169                            'value': self.provider.security_token})
170             conditions.append('{"x-amz-security-token": "%s"}' % self.provider.security_token)
171         if storage_class:
172             fields.append({'name': 'x-amz-storage-class',
173                            'value': storage_class})
174             conditions.append('{"x-amz-storage-class": "%s"}' % storage_class)
175         if server_side_encryption:
176             fields.append({'name': 'x-amz-server-side-encryption',
177                            'value': server_side_encryption})
178             conditions.append('{"x-amz-server-side-encryption": "%s"}' % server_side_encryption)
179         policy = self.build_post_policy(expiration, conditions)
180         policy_b64 = base64.b64encode(policy)
181         fields.append({"name": "policy", "value": policy_b64})
182         fields.append({"name": "AWSAccessKeyId",
183                        "value": self.aws_access_key_id})
184         signature = self._auth_handler.sign_string(policy_b64)
185         fields.append({"name": "signature", "value": signature})
186         fields.append({"name": "key", "value": key})
187         url = '%s://%s/' % (http_method,
188                             self.calling_format.build_host(self.server_name(),
189                                                            bucket_name))
190 <a name="0"></a>
191         return {"action": url, "fields": fields}
192     def generate_url_sigv4(self, expires_in, method, bucket='', key<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>='',
193                             headers=None, force_http=False,
194                             response_headers=None, version_id=None,
195                             iso_date=None):
196         path = self.calling_format.build_path_base(bucket, key)
197         auth_path = self.calling_format.build_auth_path(bucket, key)
198         host = self.calling_format.build_host(</b></font>self.server_name(), bucket)
199         if host.endswith(':443'):
200             host = host[:-4]
201         params = {}
202         if version_id is not None:
203             params['VersionId'] = version_id
204         if response_headers is not None:
205             params.update(response_headers)
206         http_request = self.build_base_http_request(method, path, auth_path,
207                                                     headers=headers, host=host,
208                                                     params=params)
209         return self._auth_handler.presign(http_request, expires_in,
210                                           iso_date=iso_date)
211     def generate_url(self, expires_in, method, bucket='', key='', headers=None,
212                      query_auth=True, force_http=False, response_headers=None,
213                      expires_in_absolute=False, version_id=None):
214         if self._auth_handler.capability[0] == 'hmac-v4-s3' and query_auth:
215             return self.generate_url_sigv4(expires_in, method, bucket=bucket,
216                 key=key, headers=headers, force_http=force_http,
217                 response_headers=response_headers, version_id=version_id)
218         headers = headers or {}
219         if expires_in_absolute:
220             expires = int(expires_in)
221         else:
222             expires = int(time.time() + expires_in)
223         auth_path = self.calling_format.build_auth_path(bucket, key)
224         auth_path = self.get_path(auth_path)
225         extra_qp = []
226         if version_id is not None:
227             extra_qp.append("versionId=%s" % version_id)
228         if response_headers:
229             for k, v in response_headers.items():
230                 extra_qp.append("%s=%s" % (k, urllib.parse.quote(v)))
231         if self.provider.security_token:
232             headers['x-amz-security-token'] = self.provider.security_token
233         if extra_qp:
234             delimiter = '?' if '?' not in auth_path else '&amp;'
235             auth_path += delimiter + '&amp;'.join(extra_qp)
236         self.calling_format.build_path_base(bucket, key)
237         if query_auth and not self.anon:
238             c_string = boto.utils.canonical_string(method, auth_path, headers,
239                                                    expires, self.provider)
240             b64_hmac = self._auth_handler.sign_string(c_string)
241             encoded_canonical = urllib.parse.quote(b64_hmac, safe='')
242             query_part = '?' + self.QueryString % (encoded_canonical, expires,
243                                                    self.aws_access_key_id)
244         else:
245             query_part = ''
246         if headers:
247             hdr_prefix = self.provider.header_prefix
248             for k, v in headers.items():
249                 if k.startswith(hdr_prefix):
250                     extra_qp.append("%s=%s" % (k, urllib.parse.quote(v)))
251         if extra_qp:
252             delimiter = '?' if not query_part else '&amp;'
253             query_part += delimiter + '&amp;'.join(extra_qp)
254         if force_http:
255             protocol = 'http'
256             port = 80
257         else:
258             protocol = self.protocol
259             port = self.port
260         return self.calling_format.build_url_base(self, protocol,
261                                                   self.server_name(port),
262                                                   bucket, key) + query_part
263     def get_all_buckets(self, headers=None):
264         response = self.make_request('GET', headers=headers)
265         body = response.read()
266         if response.status &gt; 300:
267             raise self.provider.storage_response_error(
268                 response.status, response.reason, body)
269         rs = ResultSet([('Bucket', self.bucket_class)])
270         h = handler.XmlHandler(rs, self)
271         if not isinstance(body, bytes):
272             body = body.encode('utf-8')
273         xml.sax.parseString(body, h)
274         return rs
275     def get_canonical_user_id(self, headers=None):
276         rs = self.get_all_buckets(headers=headers)
277         return rs.owner.id
278     def get_bucket(self, bucket_name, validate=True, headers=None):
279         if validate:
280             return self.head_bucket(bucket_name, headers=headers)
281         else:
282             return self.bucket_class(self, bucket_name)
283     def head_bucket(self, bucket_name, headers=None):
284         response = self.make_request('HEAD', bucket_name, headers=headers)
285         body = response.read()
286         if response.status == 200:
287             return self.bucket_class(self, bucket_name)
288         elif response.status == 403:
289             err = self.provider.storage_response_error(
290                 response.status,
291                 response.reason,
292                 body
293             )
294             err.error_code = 'AccessDenied'
295             err.error_message = 'Access Denied'
296             raise err
297         elif response.status == 404:
298             err = self.provider.storage_response_error(
299                 response.status,
300                 response.reason,
301                 body
302             )
303             err.error_code = 'NoSuchBucket'
304             err.error_message = 'The specified bucket does not exist'
305             raise err
306         else:
307             raise self.provider.storage_response_error(
308                 response.status, response.reason, body)
309     def lookup(self, bucket_name, validate=True, headers=None):
310         try:
311             bucket = self.get_bucket(bucket_name, validate, headers=headers)
312         except:
313             bucket = None
314         return bucket
315     def create_bucket(self, bucket_name, headers=None,
316                       location=Location.DEFAULT, policy=None):
317         check_lowercase_bucketname(bucket_name)
318         if policy:
319             if headers:
320                 headers[self.provider.acl_header] = policy
321             else:
322                 headers = {self.provider.acl_header: policy}
323         if location == Location.DEFAULT:
324             data = ''
325         else:
326             data = '&lt;CreateBucketConfiguration&gt;&lt;LocationConstraint&gt;' + \
327                     location + '&lt;/LocationConstraint&gt;&lt;/CreateBucketConfiguration&gt;'
328         response = self.make_request('PUT', bucket_name, headers=headers,
329                 data=data)
330         body = response.read()
331         if response.status == 409:
332             raise self.provider.storage_create_error(
333                 response.status, response.reason, body)
334         if response.status == 200:
335             return self.bucket_class(self, bucket_name)
336         else:
337             raise self.provider.storage_response_error(
338                 response.status, response.reason, body)
339     def delete_bucket(self, bucket, headers=None):
340         response = self.make_request('DELETE', bucket, headers=headers)
341         body = response.read()
342         if response.status != 204:
343             raise self.provider.storage_response_error(
344                 response.status, response.reason, body)
345     def make_request(self, method, bucket='', key='', headers=None, data='',
346                      query_args=None, sender=None, override_num_retries=None,
347                      retry_handler=None):
348         if isinstance(bucket, self.bucket_class):
349             bucket = bucket.name
350         if isinstance(key, Key):
351             key = key.name
352         path = self.calling_format.build_path_base(bucket, key)
353         boto.log.debug('path=%s' % path)
354         auth_path = self.calling_format.build_auth_path(bucket, key)
355         boto.log.debug('auth_path=%s' % auth_path)
356         host = self.calling_format.build_host(self.server_name(), bucket)
357         if query_args:
358             path += '?' + query_args
359             boto.log.debug('path=%s' % path)
360             auth_path += '?' + query_args
361             boto.log.debug('auth_path=%s' % auth_path)
362         return super(S3Connection, self).make_request(
363             method, path, headers,
364             data, host, auth_path, sender,
365             override_num_retries=override_num_retries,
366             retry_handler=retry_handler
367         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
