<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for rvm.py &amp; cabal.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for rvm.py &amp; cabal.py
      </h3>
<h1 align="center">
        6.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>rvm.py (6.763285%)<th>cabal.py (5.761317%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(122-126)<td><a href="#" name="0">(196-199)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rvm.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Managing Ruby installations and gemsets with Ruby Version Manager (RVM)
=======================================================================
This module is used to install and manage ruby installations and
gemsets with RVM, the Ruby Version Manager. Different versions of ruby
can be installed and gemsets created. RVM itself will be installed
automatically if it's not present. This module will not automatically
install packages that RVM depends on or ones that are needed to build
ruby. If you want to run RVM as an unprivileged user (recommended) you
will have to create this user yourself. This is how a state
configuration could look like:
.. code-block:: yaml
    rvm:
      group.present: []
      user.present:
        - gid: rvm
        - home: /home/rvm
        - require:
          - group: rvm
    rvm-deps:
      pkg.installed:
        - pkgs:
          - bash
          - coreutils
          - gzip
          - bzip2
          - gawk
          - sed
          - curl
          - git-core
          - subversion
    mri-deps:
      pkg.installed:
        - pkgs:
          - build-essential
          - openssl
          - libreadline6
          - libreadline6-dev
          - curl
          - git-core
          - zlib1g
          - zlib1g-dev
          - libssl-dev
          - libyaml-dev
          - libsqlite3-0
          - libsqlite3-dev
          - sqlite3
          - libxml2-dev
          - libxslt1-dev
          - autoconf
          - libc6-dev
          - libncurses5-dev
          - automake
          - libtool
          - bison
          - subversion
          - ruby
    jruby-deps:
      pkg.installed:
        - pkgs:
          - curl
          - g++
          - openjdk-6-jre-headless
    ruby-1.9.2:
      rvm.installed:
        - default: True
        - user: rvm
        - require:
          - pkg: rvm-deps
          - pkg: mri-deps
          - user: rvm
    jruby:
      rvm.installed:
        - user: rvm
        - require:
          - pkg: rvm-deps
          - pkg: jruby-deps
          - user: rvm
    jgemset:
      rvm.gemset_present:
        - ruby: jruby
        - user: rvm
        - require:
          - rvm: jruby
    mygemset:
      rvm.gemset_present:
        - ruby: ruby-1.9.2
        - user: rvm
        - require:
          - rvm: ruby-1.9.2
"""
import re
def _check_rvm(ret, user=None):
    """
    Check to see if rvm is installed.
    """
    if not __salt__["rvm.is_installed"](user):
        ret["result"] = False
        ret["comment"] = "RVM is not installed."
    return ret
def _check_and_install_ruby(ret, ruby, default=False, user=None, opts=None, env=None):
    """
    Verify that ruby is installed, install if unavailable
    ret = _check_ruby(ret, ruby, user=user)
    if not ret["result"]:
        <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if __salt__["rvm.install_ruby"](ruby, runas=user, opts=opts, env=env):
            ret["result"] = True
            ret["changes"][ruby] = "Installed"
            ret["comment"] = "Successfully installed ruby."
            ret[</b></font>"default"] = False
        else:
            ret["result"] = False
            ret["comment"] = "Could not install ruby."
            return ret
    if default:
        __salt__["rvm.set_default"](ruby, runas=user)
    return ret
def _check_ruby(ret, ruby, user=None):
    """
    Check that ruby is installed
    """
    match_version = True
    match_micro_version = False
    micro_version_regex = re.compile(r"-([0-9]{4}\.[0-9]{2}|p[0-9]+)$")
    if micro_version_regex.search(ruby):
        match_micro_version = True
    if re.search("^[a-z]+$", ruby):
        match_version = False
    ruby = re.sub("^ruby-", "", ruby)
    for impl, version, default in __salt__["rvm.list"](runas=user):
        if impl != "ruby":
            version = "{impl}-{version}".format(impl=impl, version=version)
        if not match_micro_version:
            version = micro_version_regex.sub("", version)
        if not match_version:
            version = re.sub("-.*", "", version)
        if version == ruby:
            ret["result"] = True
            ret["comment"] = "Requested ruby exists."
            ret["default"] = default
            break
    return ret
def installed(name, default=False, user=None, opts=None, env=None):
    """
    Verify that the specified ruby is installed with RVM. RVM is
    installed when necessary.
    name
        The version of ruby to install
    default : False
        Whether to make this ruby the default.
    user: None
        The user to run rvm as.
    env: None
        A list of environment variables to set (ie, RUBY_CONFIGURE_OPTS)
    opts: None
        A list of option flags to pass to RVM (ie -C, --patch)
        .. versionadded:: 0.17.0
    """
    ret = {"name": name, "result": None, "comment": "", "changes": {}}
    if __opts__["test"]:
        ret["comment"] = "Ruby {} is set to be installed".format(name)
        return ret
    ret = _check_rvm(ret, user)
    if ret["result"] is False:
        if not __salt__["rvm.install"](runas=user):
            ret["comment"] = "RVM failed to install."
            return ret
        else:
            return _check_and_install_ruby(
                ret, name, default, user=user, opts=opts, env=env
            )
    else:
        return _check_and_install_ruby(
            ret, name, default, user=user, opts=opts, env=env
        )
def gemset_present(name, ruby="default", user=None):
    """
    Verify that the gemset is present.
    name
        The name of the gemset.
    ruby: default
        The ruby version this gemset belongs to.
    user: None
        The user to run rvm as.
        .. versionadded:: 0.17.0
    """
    ret = {"name": name, "result": None, "comment": "", "changes": {}}
    ret = _check_rvm(ret, user)
    if ret["result"] is False:
        return ret
    if "@" in name:
        ruby, name = name.split("@")
        ret = _check_ruby(ret, ruby)
        if not ret["result"]:
            ret["result"] = False
            ret["comment"] = "Requested ruby implementation was not found."
            return ret
    if name in __salt__["rvm.gemset_list"](ruby, runas=user):
        ret["result"] = True
        ret["comment"] = "Gemset already exists."
    else:
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "Set to install gemset {}".format(name)
            return ret
        if __salt__["rvm.gemset_create"](ruby, name, runas=user):
            ret["result"] = True
            ret["comment"] = "Gemset successfully created."
            ret["changes"][name] = "created"
        else:
            ret["result"] = False
            ret["comment"] = "Gemset could not be created."
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>cabal.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Installation of Cabal Packages
==============================
.. versionadded:: 2015.8.0
These states manage the installed packages for Haskell using
cabal. Note that cabal-install must be installed for these states to
be available, so cabal states should include a requisite to a
pkg.installed state for the package which provides cabal
(``cabal-install`` in case of Debian based distributions). Example::
.. code-block:: yaml
   cabal-install:
     pkg.installed
   ShellCheck:
     cabal.installed:
       - require:
         - pkg: cabal-install
"""
import salt.utils.path
from salt.exceptions import CommandExecutionError, CommandNotFoundError
def __virtual__():
    """
    Only work when cabal-install is installed.
    """
    if (salt.utils.path.which("cabal") is not None) and (
        salt.utils.path.which("ghc-pkg") is not None
    ):
        return True
    return (False, "cabal or ghc-pkg commands not found")
def _parse_pkg_string(pkg):
    """
    Parse pkg string and return a tuple of package name, separator, and
    package version.
    Cabal support install package with following format:
    * foo-1.0
    * foo &lt; 1.2
    * foo &gt; 1.3
    For the sake of simplicity only the first form is supported,
    support for other forms can be added later.
    """
    pkg_name, separator, pkg_ver = pkg.partition("-")
    return (pkg_name.strip(), separator, pkg_ver.strip())
def installed(name, pkgs=None, user=None, install_global=False, env=None):
    """
    Verify that the given package is installed and is at the correct version
    (if specified).
    .. code-block:: yaml
        ShellCheck-0.3.5:
          cabal:
            - installed:
    name
        The package to install
    user
        The user to run cabal install with
    install_global
        Install package globally instead of locally
    env
        A list of environment variables to be set prior to execution. The
        format is the same as the :py:func:`cmd.run &lt;salt.states.cmd.run&gt;`.
        state function.
    """
    ret = {"name": name, "result": None, "comment": "", "changes": {}}
    try:
        call = __salt__["cabal.update"](user=user, env=env)
    except (CommandNotFoundError, CommandExecutionError) as err:
        ret["result"] = False
        ret["comment"] = "Could not run cabal update {}".format(err)
        return ret
    if pkgs is not None:
        pkg_list = pkgs
    else:
        pkg_list = [name]
    try:
        installed_pkgs = __salt__["cabal.list"](user=user, installed=True, env=env)
    except (CommandNotFoundError, CommandExecutionError) as err:
        ret["result"] = False
        ret["comment"] = "Error looking up '{}': {}".format(name, err)
        return ret
    pkgs_satisfied = []
    pkgs_to_install = []
    for pkg in pkg_list:
        pkg_name, _, pkg_ver = _parse_pkg_string(pkg)
        if pkg_name not in installed_pkgs:
            pkgs_to_install.append(pkg)
        else:
            if pkg_ver:  # version is specified
                if installed_pkgs[pkg_name] != pkg_ver:
                    pkgs_to_install.append(pkg)
                else:
                    pkgs_satisfied.append(pkg)
            else:
                pkgs_satisfied.append(pkg)
    if __opts__["test"]:
        ret["result"] = None
        comment_msg = []
        if pkgs_to_install:
            comment_msg.append(
                "Packages(s) '{}' are set to be installed".format(
                    ", ".join(pkgs_to_install)
                )
            )
        if pkgs_satisfied:
            comment_msg.append(
                "Packages(s) '{}' satisfied by {}".format(
                    ", ".join(pkg_list), ", ".join(pkgs_satisfied)
                )
            )
        ret["comment"] = ". ".join(comment_msg)
        return ret
    if not pkgs_to_install:
        ret["result"] = True
        ret["comment"] = "Packages(s) '{}' satisfied by {}".format(
            ", ".join(pkg_list), ", ".join(pkgs_satisfied)
        )
        return ret
    try:
        call = __salt__["cabal.install"](
            pkgs=pkg_list, user=user, install_global=install_global, env=env
        )
    except (CommandNotFoundError, CommandExecutionError) as err:
        ret["result"] = False
        ret["comment"] = "Error installing '{}': {}".format(", ".join(pkg_list), err)
        return ret
    if call and isinstance(call, dict):
        ret["result"] = True
        ret["changes"] = {"old": [], "new": pkgs_to_install}
        ret["comment"] = "Packages(s) '{}' successfully installed".format(
            ", ".join(pkgs_to_install)
        )
    else:
        ret["result"] = False
        ret["comment"] = "Could not install packages(s) '{}'".format(
            ", ".join(pkg_list)
        )
    return ret
def removed(name, user=None, env=None):
    """
    Verify that given package is not installed.
    """
    ret = {"name": name, "result": None, "comment": "", "changes": {}}
    try:
        installed_pkgs = __salt__["cabal.list"](user=user, installed=True, env=env)
    except (CommandNotFoundError, CommandExecutionError) as err:
        ret["result"] = False
        ret["comment"] = "Error looking up '{}': {}".format(name, err)
    if name not in installed_pkgs:
        ret["result"] = True
        ret["comment"] = "Package '{}' is not installed".format(name)
        return ret
    if __opts__["test"]:
        ret["result"] = None
        return ret
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if __salt__["cabal.uninstall"](pkg=name, user=user, env=env):
        ret["result"] = True
        ret["changes"][name] = "Removed"
        ret["comment"] = "Package '{}' was successfully removed".</b></font>format(name)
    else:
        ret["result"] = False
        ret["comment"] = "Error removing package '{}'".format(name)
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
