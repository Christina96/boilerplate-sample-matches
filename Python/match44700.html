<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for rvm.py & cabal.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for rvm.py & cabal.py
      </h3>
      <h1 align="center">
        6.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>rvm.py (6.763285%)<TH>cabal.py (5.761317%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match44700-0.html#0',2,'match44700-1.html#0',3)" NAME="0">(122-126)<TD><A HREF="javascript:ZweiFrames('match44700-0.html#0',2,'match44700-1.html#0',3)" NAME="0">(196-199)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rvm.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Managing Ruby installations and gemsets with Ruby Version Manager (RVM)
=======================================================================

This module is used to install and manage ruby installations and
gemsets with RVM, the Ruby Version Manager. Different versions of ruby
can be installed and gemsets created. RVM itself will be installed
automatically if it's not present. This module will not automatically
install packages that RVM depends on or ones that are needed to build
ruby. If you want to run RVM as an unprivileged user (recommended) you
will have to create this user yourself. This is how a state
configuration could look like:

.. code-block:: yaml

    rvm:
      group.present: []
      user.present:
        - gid: rvm
        - home: /home/rvm
        - require:
          - group: rvm

    rvm-deps:
      pkg.installed:
        - pkgs:
          - bash
          - coreutils
          - gzip
          - bzip2
          - gawk
          - sed
          - curl
          - git-core
          - subversion

    mri-deps:
      pkg.installed:
        - pkgs:
          - build-essential
          - openssl
          - libreadline6
          - libreadline6-dev
          - curl
          - git-core
          - zlib1g
          - zlib1g-dev
          - libssl-dev
          - libyaml-dev
          - libsqlite3-0
          - libsqlite3-dev
          - sqlite3
          - libxml2-dev
          - libxslt1-dev
          - autoconf
          - libc6-dev
          - libncurses5-dev
          - automake
          - libtool
          - bison
          - subversion
          - ruby

    jruby-deps:
      pkg.installed:
        - pkgs:
          - curl
          - g++
          - openjdk-6-jre-headless

    ruby-1.9.2:
      rvm.installed:
        - default: True
        - user: rvm
        - require:
          - pkg: rvm-deps
          - pkg: mri-deps
          - user: rvm

    jruby:
      rvm.installed:
        - user: rvm
        - require:
          - pkg: rvm-deps
          - pkg: jruby-deps
          - user: rvm

    jgemset:
      rvm.gemset_present:
        - ruby: jruby
        - user: rvm
        - require:
          - rvm: jruby

    mygemset:
      rvm.gemset_present:
        - ruby: ruby-1.9.2
        - user: rvm
        - require:
          - rvm: ruby-1.9.2
&quot;&quot;&quot;

import re


def _check_rvm(ret, user=None):
    &quot;&quot;&quot;
    Check to see if rvm is installed.
    &quot;&quot;&quot;
    if not __salt__[&quot;rvm.is_installed&quot;](user):
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;RVM is not installed.&quot;
    return ret


def _check_and_install_ruby(ret, ruby, default=False, user=None, opts=None, env=None):
    &quot;&quot;&quot;
    Verify that ruby is installed, install if unavailable
<A NAME="0"></A>    &quot;&quot;&quot;
    ret = _check_ruby(ret, ruby, user=user)
    if not ret[&quot;result&quot;]:
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match44700-1.html#0',3,'match44700-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>if __salt__[&quot;rvm.install_ruby&quot;](ruby, runas=user, opts=opts, env=env):
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][ruby] = &quot;Installed&quot;
            ret[&quot;comment&quot;] = &quot;Successfully installed ruby.&quot;
            ret[</B></FONT>&quot;default&quot;] = False
        else:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Could not install ruby.&quot;
            return ret

    if default:
        __salt__[&quot;rvm.set_default&quot;](ruby, runas=user)

    return ret


def _check_ruby(ret, ruby, user=None):
    &quot;&quot;&quot;
    Check that ruby is installed
    &quot;&quot;&quot;
    match_version = True
    match_micro_version = False
    micro_version_regex = re.compile(r&quot;-([0-9]{4}\.[0-9]{2}|p[0-9]+)$&quot;)
    if micro_version_regex.search(ruby):
        match_micro_version = True
    if re.search(&quot;^[a-z]+$&quot;, ruby):
        match_version = False
    ruby = re.sub(&quot;^ruby-&quot;, &quot;&quot;, ruby)

    for impl, version, default in __salt__[&quot;rvm.list&quot;](runas=user):
        if impl != &quot;ruby&quot;:
            version = &quot;{impl}-{version}&quot;.format(impl=impl, version=version)
        if not match_micro_version:
            version = micro_version_regex.sub(&quot;&quot;, version)
        if not match_version:
            version = re.sub(&quot;-.*&quot;, &quot;&quot;, version)
        if version == ruby:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Requested ruby exists.&quot;
            ret[&quot;default&quot;] = default
            break
    return ret


def installed(name, default=False, user=None, opts=None, env=None):
    &quot;&quot;&quot;
    Verify that the specified ruby is installed with RVM. RVM is
    installed when necessary.

    name
        The version of ruby to install

    default : False
        Whether to make this ruby the default.

    user: None
        The user to run rvm as.

    env: None
        A list of environment variables to set (ie, RUBY_CONFIGURE_OPTS)

    opts: None
        A list of option flags to pass to RVM (ie -C, --patch)

        .. versionadded:: 0.17.0
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Ruby {} is set to be installed&quot;.format(name)
        return ret

    ret = _check_rvm(ret, user)
    if ret[&quot;result&quot;] is False:
        if not __salt__[&quot;rvm.install&quot;](runas=user):
            ret[&quot;comment&quot;] = &quot;RVM failed to install.&quot;
            return ret
        else:
            return _check_and_install_ruby(
                ret, name, default, user=user, opts=opts, env=env
            )
    else:
        return _check_and_install_ruby(
            ret, name, default, user=user, opts=opts, env=env
        )


def gemset_present(name, ruby=&quot;default&quot;, user=None):
    &quot;&quot;&quot;
    Verify that the gemset is present.

    name
        The name of the gemset.

    ruby: default
        The ruby version this gemset belongs to.

    user: None
        The user to run rvm as.

        .. versionadded:: 0.17.0
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    ret = _check_rvm(ret, user)
    if ret[&quot;result&quot;] is False:
        return ret

    if &quot;@&quot; in name:
        ruby, name = name.split(&quot;@&quot;)
        ret = _check_ruby(ret, ruby)
        if not ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Requested ruby implementation was not found.&quot;
            return ret

    if name in __salt__[&quot;rvm.gemset_list&quot;](ruby, runas=user):
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Gemset already exists.&quot;
    else:
        if __opts__[&quot;test&quot;]:
            ret[&quot;result&quot;] = None
            ret[&quot;comment&quot;] = &quot;Set to install gemset {}&quot;.format(name)
            return ret
        if __salt__[&quot;rvm.gemset_create&quot;](ruby, name, runas=user):
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Gemset successfully created.&quot;
            ret[&quot;changes&quot;][name] = &quot;created&quot;
        else:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Gemset could not be created.&quot;

    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>cabal.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Installation of Cabal Packages
==============================

.. versionadded:: 2015.8.0

These states manage the installed packages for Haskell using
cabal. Note that cabal-install must be installed for these states to
be available, so cabal states should include a requisite to a
pkg.installed state for the package which provides cabal
(``cabal-install`` in case of Debian based distributions). Example::

.. code-block:: yaml

   cabal-install:
     pkg.installed

   ShellCheck:
     cabal.installed:
       - require:
         - pkg: cabal-install

&quot;&quot;&quot;


import salt.utils.path
from salt.exceptions import CommandExecutionError, CommandNotFoundError


def __virtual__():
    &quot;&quot;&quot;
    Only work when cabal-install is installed.
    &quot;&quot;&quot;
    if (salt.utils.path.which(&quot;cabal&quot;) is not None) and (
        salt.utils.path.which(&quot;ghc-pkg&quot;) is not None
    ):
        return True
    return (False, &quot;cabal or ghc-pkg commands not found&quot;)


def _parse_pkg_string(pkg):
    &quot;&quot;&quot;
    Parse pkg string and return a tuple of package name, separator, and
    package version.

    Cabal support install package with following format:

    * foo-1.0
    * foo &lt; 1.2
    * foo &gt; 1.3

    For the sake of simplicity only the first form is supported,
    support for other forms can be added later.
    &quot;&quot;&quot;
    pkg_name, separator, pkg_ver = pkg.partition(&quot;-&quot;)
    return (pkg_name.strip(), separator, pkg_ver.strip())


def installed(name, pkgs=None, user=None, install_global=False, env=None):
    &quot;&quot;&quot;
    Verify that the given package is installed and is at the correct version
    (if specified).

    .. code-block:: yaml

        ShellCheck-0.3.5:
          cabal:
            - installed:

    name
        The package to install
    user
        The user to run cabal install with
    install_global
        Install package globally instead of locally
    env
        A list of environment variables to be set prior to execution. The
        format is the same as the :py:func:`cmd.run &lt;salt.states.cmd.run&gt;`.
        state function.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    try:
        call = __salt__[&quot;cabal.update&quot;](user=user, env=env)
    except (CommandNotFoundError, CommandExecutionError) as err:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Could not run cabal update {}&quot;.format(err)
        return ret

    if pkgs is not None:
        pkg_list = pkgs
    else:
        pkg_list = [name]

    try:
        installed_pkgs = __salt__[&quot;cabal.list&quot;](user=user, installed=True, env=env)
    except (CommandNotFoundError, CommandExecutionError) as err:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Error looking up '{}': {}&quot;.format(name, err)
        return ret

    pkgs_satisfied = []
    pkgs_to_install = []

    for pkg in pkg_list:
        pkg_name, _, pkg_ver = _parse_pkg_string(pkg)

        if pkg_name not in installed_pkgs:
            pkgs_to_install.append(pkg)
        else:
            if pkg_ver:  # version is specified
                if installed_pkgs[pkg_name] != pkg_ver:
                    pkgs_to_install.append(pkg)
                else:
                    pkgs_satisfied.append(pkg)
            else:
                pkgs_satisfied.append(pkg)

    if __opts__[&quot;test&quot;]:
        ret[&quot;result&quot;] = None

        comment_msg = []

        if pkgs_to_install:
            comment_msg.append(
                &quot;Packages(s) '{}' are set to be installed&quot;.format(
                    &quot;, &quot;.join(pkgs_to_install)
                )
            )

        if pkgs_satisfied:
            comment_msg.append(
                &quot;Packages(s) '{}' satisfied by {}&quot;.format(
                    &quot;, &quot;.join(pkg_list), &quot;, &quot;.join(pkgs_satisfied)
                )
            )

        ret[&quot;comment&quot;] = &quot;. &quot;.join(comment_msg)
        return ret

    if not pkgs_to_install:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Packages(s) '{}' satisfied by {}&quot;.format(
            &quot;, &quot;.join(pkg_list), &quot;, &quot;.join(pkgs_satisfied)
        )

        return ret

    try:
        call = __salt__[&quot;cabal.install&quot;](
            pkgs=pkg_list, user=user, install_global=install_global, env=env
        )
    except (CommandNotFoundError, CommandExecutionError) as err:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Error installing '{}': {}&quot;.format(&quot;, &quot;.join(pkg_list), err)
        return ret

    if call and isinstance(call, dict):
        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;] = {&quot;old&quot;: [], &quot;new&quot;: pkgs_to_install}
        ret[&quot;comment&quot;] = &quot;Packages(s) '{}' successfully installed&quot;.format(
            &quot;, &quot;.join(pkgs_to_install)
        )
    else:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Could not install packages(s) '{}'&quot;.format(
            &quot;, &quot;.join(pkg_list)
        )

    return ret


def removed(name, user=None, env=None):
    &quot;&quot;&quot;
    Verify that given package is not installed.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    try:
        installed_pkgs = __salt__[&quot;cabal.list&quot;](user=user, installed=True, env=env)
    except (CommandNotFoundError, CommandExecutionError) as err:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Error looking up '{}': {}&quot;.format(name, err)

    if name not in installed_pkgs:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Package '{}' is not installed&quot;.format(name)
        return ret

    if __opts__[&quot;test&quot;]:
        ret[&quot;result&quot;] = None
<A NAME="0"></A>        ret[&quot;comment&quot;] = &quot;Package '{}' is set to be removed&quot;.format(name)
        return ret

    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44700-0.html#0',2,'match44700-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if __salt__[&quot;cabal.uninstall&quot;](pkg=name, user=user, env=env):
        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;][name] = &quot;Removed&quot;
        ret[&quot;comment&quot;] = &quot;Package '{}' was successfully removed&quot;.</B></FONT>format(name)
    else:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Error removing package '{}'&quot;.format(name)

    return ret
</PRE>
</div>
  </div>
</body>
</html>
