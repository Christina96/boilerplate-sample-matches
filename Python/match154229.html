<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for capirca_acl.py &amp; mount_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for capirca_acl.py &amp; mount_2.py
      </h3>
<h1 align="center">
        2.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>capirca_acl.py (3.2886724%)<th>mount_2.py (1.7464424%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(612-873)<td><a href="#" name="0">(51-70)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(899-915)<td><a href="#" name="1">(1070-1144)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>capirca_acl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import inspect
3 import logging
4 import re
5 import salt.utils.files
6 log = logging.getLogger(__file__)
7 try:
8     import capirca
9     import capirca.aclgen
10     import capirca.lib.policy
11     import capirca.lib.aclgenerator
12     HAS_CAPIRCA = True
13 except ImportError:
14     HAS_CAPIRCA = False
15 __virtualname__ = "capirca"
16 __proxyenabled__ = ["*"]
17 def __virtual__():
18     if HAS_CAPIRCA:
19         return __virtualname__
20     else:
21         return (False, "The capirca module (capirca_acl) cannot be loaded.")
22 _TERM_FIELDS = {
23     "action": [],
24     "address": [],
25     "address_exclude": [],
26     "comment": [],
27     "counter": None,
28     "expiration": None,
29     "destination_address": [],
30     "destination_address_exclude": [],
31     "destination_port": [],
32     "destination_prefix": [],
33     "forwarding_class": [],
34     "forwarding_class_except": [],
35     "logging": [],
36     "log_name": None,
37     "loss_priority": None,
38     "option": [],
39     "owner": None,
40     "policer": None,
41     "port": [],
42     "precedence": [],
43     "principals": [],
44     "protocol": [],
45     "protocol_except": [],
46     "qos": None,
47     "pan_application": [],
48     "routing_instance": None,
49     "source_address": [],
50     "source_address_exclude": [],
51     "source_port": [],
52     "source_prefix": [],
53     "verbatim": [],
54     "packet_length": None,
55     "fragment_offset": None,
56     "hop_limit": None,
57     "icmp_type": [],
58     "icmp_code": None,
59     "ether_type": [],
60     "traffic_class_count": None,
61     "traffic_type": [],
62     "translated": False,
63     "dscp_set": None,
64     "dscp_match": [],
65     "dscp_except": [],
66     "next_ip": None,
67     "flexible_match_range": [],
68     "source_prefix_except": [],
69     "destination_prefix_except": [],
70     "vpn": None,
71     "source_tag": [],
72     "destination_tag": [],
73     "source_interface": None,
74     "destination_interface": None,
75     "platform": [],
76     "platform_exclude": [],
77     "timeout": None,
78     "flattened": False,
79     "flattened_addr": None,
80     "flattened_saddr": None,
81     "flattened_daddr": None,
82     "priority": None,
83     "ttl": None,
84 }
85 _IP_FILEDS = [
86     "source_address",
87     "source_address_exclude",
88     "destination_address",
89     "address",
90     "address_exclude",
91     "flattened_addr",
92     "flattened_saddr",
93     "flattened_daddr",
94     "next_ip",
95 ]
96 _SERVICES = {}
97 if HAS_CAPIRCA:
98     _TempTerm = capirca.lib.policy.Term
99     def _add_object(self, obj):
100         return
101     setattr(_TempTerm, "AddObject", _add_object)
102     dumy_term = _TempTerm(None)
103     for item in dir(dumy_term):
104         if hasattr(item, "__func__") or item.startswith("_") or item != item.lower():
105             continue
106         _TERM_FIELDS[item] = getattr(dumy_term, item)
107     class _Policy(capirca.lib.policy.Policy):
108         def __init__(self):
109             self.filters = []
110             self.filename = ""
111     class _Term(capirca.lib.policy.Term):
112         def __init__(self):
113             for field, default in _TERM_FIELDS.items():
114                 setattr(self, field, default)
115 def _import_platform_generator(platform):
116     log.debug("Using platform: %s", platform)
117     for mod_name, mod_obj in inspect.getmembers(capirca.aclgen):
118         if mod_name == platform and inspect.ismodule(mod_obj):
119             for plat_obj_name, plat_obj in inspect.getmembers(
120                 mod_obj
121             ):  # pylint: disable=unused-variable
122                 if inspect.isclass(plat_obj) and issubclass(
123                     plat_obj, capirca.lib.aclgenerator.ACLGenerator
124                 ):
125                     log.debug("Identified Capirca class %s for %s", plat_obj, platform)
126                     return plat_obj
127     log.error("Unable to identify any Capirca plaform class for %s", platform)
128 def _get_services_mapping():
129     if _SERVICES:
130         return _SERVICES
131     services_txt = ""
132     try:
133         with salt.utils.files.fopen("/etc/services", "r") as srv_f:
134             services_txt = salt.utils.stringutils.to_unicode(srv_f.read())
135     except OSError as ioe:
136         log.error("Unable to read from /etc/services:")
137         log.error(ioe)
138         return _SERVICES  # no mapping possible, sorry
139     service_rgx = re.compile(r"^([a-zA-Z0-9-]+)\s+(\d+)\/(tcp|udp)(.*)$")
140     for line in services_txt.splitlines():
141         service_rgx_s = service_rgx.search(line)
142         if service_rgx_s and len(service_rgx_s.groups()) == 4:
143             srv_name, port, protocol, _ = service_rgx_s.groups()
144             if srv_name not in _SERVICES:
145                 _SERVICES[srv_name] = {"port": [], "protocol": []}
146             try:
147                 _SERVICES[srv_name]["port"].append(int(port))
148             except ValueError as verr:
149                 log.error(verr)
150                 log.error("Did not read that properly:")
151                 log.error(line)
152                 log.error(
153                     "Please report the above error: %s does not seem a valid port"
154                     " value!",
155                     port,
156                 )
157             _SERVICES[srv_name]["protocol"].append(protocol)
158     return _SERVICES
159 def _translate_port(port):
160     services = _get_services_mapping()
161     if port in services and services[port]["port"]:
162         return services[port]["port"][0]
163     return port
164 def _make_it_list(dict_, field_name, value):
165     prev_value = []
166     if field_name in dict_:
167         prev_value = dict_[field_name]
168     if value is None:
169         return prev_value
170     elif isinstance(value, (tuple, list)):
171         if field_name in ("source_port", "destination_port"):
172             portval = []
173             for port in value:
174                 if not isinstance(port, (tuple, list)):
175                     portval.append((port, port))
176                 else:
177                     portval.append(port)
178             translated_portval = []
179             for port_start, port_end in portval:
180                 if not isinstance(port_start, int):
181                     port_start = _translate_port(port_start)
182                 if not isinstance(port_end, int):
183                     port_end = _translate_port(port_end)
184                 translated_portval.append((port_start, port_end))
185             return list(set(prev_value + translated_portval))
186         return list(set(prev_value + list(value)))
187     if field_name in ("source_port", "destination_port"):
188         if not isinstance(value, int):
189             value = _translate_port(value)
190         return list(set(prev_value + [(value, value)]))  # a list of tuples
191     return list(set(prev_value + [value]))
192 def _clean_term_opts(term_opts):
193     clean_opts = {}
194     _services = _get_services_mapping()
195     for field, value in term_opts.items():
196         if field == "source_service" and value:
197             if isinstance(value, str):
198                 value = _make_it_list(clean_opts, field, value)
199             log.debug("Processing special source services:")
200             log.debug(value)
201             for service in value:
202                 if service and service in _services:
203                     clean_opts["source_port"] = _make_it_list(
204                         clean_opts, "source_port", _services[service]["port"]
205                     )
206                     clean_opts["protocol"] = _make_it_list(
207                         clean_opts, "protocol", _services[service]["protocol"]
208                     )
209             log.debug(
210                 "Built source_port field, after processing special source services:"
211             )
212             log.debug(clean_opts.get("source_port"))
213             log.debug("Built protocol field, after processing special source services:")
214             log.debug(clean_opts.get("protocol"))
215         elif field == "destination_service" and value:
216             if isinstance(value, str):
217                 value = _make_it_list(clean_opts, field, value)
218             log.debug("Processing special destination services:")
219             log.debug(value)
220             for service in value:
221                 if service and service in _services:
222                     clean_opts["destination_port"] = _make_it_list(
223                         clean_opts, "destination_port", _services[service]["port"]
224                     )
225                     clean_opts["protocol"] = _make_it_list(
226                         clean_opts, "protocol", _services[service]["protocol"]
227                     )
228             log.debug(
229                 "Built source_port field, after processing special destination"
230                 " services:"
231             )
232             log.debug(clean_opts.get("destination_service"))
233             log.debug(
234                 "Built protocol field, after processing special destination services:"
235             )
236             log.debug(clean_opts.get("protocol"))
237         elif field in _TERM_FIELDS and value and value != _TERM_FIELDS[field]:
238             if isinstance(_TERM_FIELDS[field], list):
239                 value = _make_it_list(clean_opts, field, value)
240             if field in _IP_FILEDS:
241                 ip_values = []
242                 for addr in value:
243                     ip_values.append(capirca.lib.policy.nacaddr.IP(addr))
244                 value = ip_values[:]
245             clean_opts[field] = value
246     return clean_opts
247 def _lookup_element(lst, key):
248     if not lst:
249         return {}
250     for ele in lst:
251         if not ele or not isinstance(ele, dict):
252             continue
253         if key in ele:
254             return ele[key]
255     return {}
256 def _get_pillar_cfg(pillar_key, pillarenv=None, saltenv=None):
257     pillar_cfg = __salt__["pillar.get"](
258         pillar_key, pillarenv=pillarenv, saltenv=saltenv
259     )
260     return pillar_cfg
261 def _cleanup(lst):
262     clean = []
263     for ele in lst:
264         if ele and isinstance(ele, dict):
265             clean.append(ele)
266     return clean
267 def _merge_list_of_dict(first, second, prepend=True):
268     first = _cleanup(first)
269     second = _cleanup(second)
270     if not first and not second:
271         return []
272     if not first and second:
273         return second
274     if first and not second:
275         return first
276     overlaps = []
277     merged = []
278     appended = []
279     for ele in first:
280         if _lookup_element(second, next(iter(ele))):
281             overlaps.append(ele)
282         elif prepend:
283             merged.append(ele)
284         elif not prepend:
285             appended.append(ele)
286     for ele in second:
287         ele_key = next(iter(ele))
288         if _lookup_element(overlaps, ele_key):
289             ele_val_first = _lookup_element(first, ele_key)
290             merged.append({ele_key: ele_val_first})
291         else:
292             merged.append(ele)
293     if not prepend:
294         merged.extend(appended)
295     return merged
296 def _get_term_object(
297     filter_name,
298     term_name,
299     pillar_key="acl",
300     pillarenv=None,
301     saltenv=None,
302     merge_pillar=True,
303     **term_fields
304 ):
305     log.debug("Generating config for term %s under filter %s", term_name, filter_name)
306     term = _Term()
307     term.name = term_name
308     term_opts = {}
309     if merge_pillar:
310         term_opts = get_term_pillar(
311             filter_name,
312             term_name,
313             pillar_key=pillar_key,
314             saltenv=saltenv,
315             pillarenv=pillarenv,
316         )
317         log.debug("Merging with pillar data:")
318         log.debug(term_opts)
319         term_opts = _clean_term_opts(term_opts)
320         log.debug("Cleaning up pillar data:")
321         log.debug(term_opts)
322     log.debug("Received processing opts:")
323     log.debug(term_fields)
324     log.debug("Cleaning up processing opts:")
325     term_fields = _clean_term_opts(term_fields)
326     log.debug(term_fields)
327     log.debug("Final term opts:")
328     term_opts.update(term_fields)
329     log.debug(term_fields)
330     for field, value in term_opts.items():
331         setattr(term, field, value)
332     log.debug("Term config:")
333     log.debug(str(term))
334     return term
335 def _get_policy_object(
336     platform,
337     filters=None,
338     pillar_key="acl",
339     pillarenv=None,
340     saltenv=None,
341     merge_pillar=True,
342 ):
343     policy = _Policy()
344     policy_filters = []
345     if not filters:
346         filters = []
347     for filter_ in filters:
348         if not filter_ or not isinstance(filter_, dict):
349             continue  # go to the next filter
350         filter_name, filter_config = next(iter(filter_.items()))
351         header = capirca.lib.policy.Header()  # same header everywhere
352         target_opts = [platform, filter_name]
353         filter_options = filter_config.pop("options", None)
354         if filter_options:
355             filter_options = _make_it_list({}, filter_name, filter_options)
356             target_opts.extend(filter_options)
357         target = capirca.lib.policy.Target(target_opts)
358         header.AddObject(target)
359         filter_terms = []
360         for term_ in filter_config.get("terms", []):
361             if term_ and isinstance(term_, dict):
362                 term_name, term_fields = next(iter(term_.items()))
363                 term = _get_term_object(
364                     filter_name,
365                     term_name,
366                     pillar_key=pillar_key,
367                     pillarenv=pillarenv,
368                     saltenv=saltenv,
369                     merge_pillar=merge_pillar,
370                     **term_fields
371                 )
372             filter_terms.append(term)
373         policy_filters.append((header, filter_terms))
374     policy.filters = policy_filters
375     log.debug("Policy config:")
376     log.debug(str(policy))
377     platform_generator = _import_platform_generator(platform)
378     policy_config = platform_generator(policy, 2)
379     log.debug("Generating policy config for %s:", platform)
380     log.debug(str(policy_config))
381     return policy_config
382 def _revision_tag(
383     text,
384     revision_id=None,
385     revision_no=None,
386     revision_date=True,
387     revision_date_format="%Y/%m/%d",
388 ):
389     timestamp = datetime.datetime.now().strftime(revision_date_format)
390     new_text = []
391     for line in text.splitlines():
392         if "$Id:$" in line:
393             if not revision_id:  # if no explicit revision ID required
394                 continue  # jump to next line, ignore this one
395             line = line.replace("$Id:$", "$Id: {rev_id} $".format(rev_id=revision_id))
396         if "$Revision:$" in line:
397             if not revision_no:  # if no explicit revision number required
398                 continue  # jump to next line, ignore this one
399             line = line.replace(
400                 "$Revision:$", "$Revision: {rev_no} $".format(rev_no=revision_no)
401             )
402         if "$Date:$" in line:
403             if not revision_date:
404             line = line.replace("$Date:$", "$Date: {ts} $".format(ts=timestamp))
405         new_text.append(line)
406     return "\n".join(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new_text)
407 def get_term_config(
408     platform,
409     filter_name,
410     term_name,
411     filter_options=None,
412     pillar_key="acl",
413     pillarenv=None,
414     saltenv=None,
415     merge_pillar=True,
416     revision_id=None,
417     revision_no=None,
418     revision_date=True,
419     revision_date_format="%Y/%m/%d",
420     source_service=None,
421     destination_service=None,
422     **term_fields
423 ):
424     terms = []
425     term =</b></font> {term_name: {}}
426     term[term_name].update(term_fields)
427     term[term_name].update(
428         {
429             "source_service": _make_it_list({}, "source_service", source_service),
430             "destination_service": _make_it_list(
431                 {}, "destination_service", destination_service
432             ),
433         }
434     )
435     terms.append(term)
436     if not filter_options:
437         filter_options = []
438     return get_filter_config(
439         platform,
440         filter_name,
441         filter_options=filter_options,
442         terms=terms,
443         pillar_key=pillar_key,
444         pillarenv=pillarenv,
445         saltenv=saltenv,
446         merge_pillar=merge_pillar,
447         only_lower_merge=True,
448         revision_no=revision_no,
449         revision_date=revision_date,
450         revision_date_format=<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>revision_date_format,
451     )
452 def get_filter_config(
453     platform,
454     filter_name,
455     filter_options=None,
456     terms=None,
457     prepend=True,
458     pillar_key="acl",
459     pillarenv=None,
460     saltenv=None,
461     merge_pillar=True,
462     only_lower_merge=False,
463     revision_id=None,
464     revision_no=</b></font>None,
465     revision_date=True,
466     revision_date_format="%Y/%m/%d",
467 ):
468     if not filter_options:
469         filter_options = []
470     if not terms:
471         terms = []
472     if merge_pillar and not only_lower_merge:
473         acl_pillar_cfg = _get_pillar_cfg(
474             pillar_key, saltenv=saltenv, pillarenv=pillarenv
475         )
476         filter_pillar_cfg = _lookup_element(acl_pillar_cfg, filter_name)
477         filter_options = filter_options or filter_pillar_cfg.pop("options", None)
478         if filter_pillar_cfg:
479             pillar_terms = filter_pillar_cfg.get(
480                 "terms", []
481             )  # No problem if empty in the pillar
482             terms = _merge_list_of_dict(terms, pillar_terms, prepend=prepend)
483     filters = []
484     filters.append(
485         {
486             filter_name: {
487                 "options": _make_it_list({}, filter_name, filter_options),
488                 "terms": terms,
489             }
490         }
491     )
492     return get_policy_config(
493         platform,
494         filters=filters,
495         pillar_key=pillar_key,
496         pillarenv=pillarenv,
497         saltenv=saltenv,
498         merge_pillar=merge_pillar,
499         only_lower_merge=True,
500         revision_id=revision_id,
501         revision_no=revision_no,
502         revision_date=revision_date,
503         revision_date_format=revision_date_format,
504     )
505 def get_policy_config(
506     platform,
507     filters=None,
508     prepend=True,
509     pillar_key="acl",
510     pillarenv=None,
511     saltenv=None,
512     merge_pillar=True,
513     only_lower_merge=False,
514     revision_id=None,
515     revision_no=None,
516     revision_date=True,
517     revision_date_format="%Y/%m/%d",
518 ):
519     if not filters:
520         filters = []
521     if merge_pillar and not only_lower_merge:
522         policy_pillar_cfg = _get_pillar_cfg(
523             pillar_key, saltenv=saltenv, pillarenv=pillarenv
524         )
525         filters = _merge_list_of_dict(filters, policy_pillar_cfg, prepend=prepend)
526     policy_object = _get_policy_object(
527         platform,
528         filters=filters,
529         pillar_key=pillar_key,
530         pillarenv=pillarenv,
531         saltenv=saltenv,
532         merge_pillar=merge_pillar,
533     )
534     policy_text = str(policy_object)
535     return _revision_tag(
536         policy_text,
537         revision_id=revision_id,
538         revision_no=revision_no,
539         revision_date=revision_date,
540         revision_date_format=revision_date_format,
541     )
542 def get_filter_pillar(filter_name, pillar_key="acl", pillarenv=None, saltenv=None):
543     pillar_cfg = _get_pillar_cfg(pillar_key, pillarenv=pillarenv, saltenv=saltenv)
544     return _lookup_element(pillar_cfg, filter_name)
545 def get_term_pillar(
546     filter_name, term_name, pillar_key="acl", pillarenv=None, saltenv=None
547 ):
548     filter_pillar_cfg = get_filter_pillar(
549         filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv
550     )
551     term_pillar_cfg = filter_pillar_cfg.get("terms", [])
552     term_opts = _lookup_element(term_pillar_cfg, term_name)
553     return term_opts
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mount_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os.path
3 import re
4 log = logging.getLogger(__name__)
5 def _size_convert(_re_size):
6     converted_size = int(_re_size.group("size_value"))
7     if _re_size.group("size_unit") == "m":
8     if _re_size.group("size_unit") == "g":
9         converted_size = int(converted_size) * 1024 * 1024
10     r<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn converted_size
11 def mounted(
12     name,
13     device,
14     fstype,
15     mkmnt=False,
16     opts="defaults",
17     dump=0,
18     pass_num=0,
19     config="/etc/fstab",
20     persist=True,
21     mount=True,
22     user=None,
23     match_on="auto",
24     device_name_regex=None,
25     extra_mount_invisible_options=None,
26     extra_mount_invisible_keys=None,
27     extra_mount_ignore_fs_keys=</b></font>None,
28     extra_mount_translate_options=None,
29     hidden_opts=None,
30     **kwargs
31 ):
32     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
33     update_mount_cache = False
34     if not name:
35         ret["result"] = False
36         ret["comment"] = "Must provide name to mount.mounted"
37         return ret
38     if not device:
39         ret["result"] = False
40         ret["comment"] = "Must provide device to mount.mounted"
41         return ret
42     if not fstype:
43         ret["result"] = False
44         ret["comment"] = "Must provide fstype to mount.mounted"
45         return ret
46     if device_name_regex is None:
47         device_name_regex = []
48     if __grains__["os"] in ["MacOS", "Darwin"] and opts == "defaults":
49         opts = "noowners"
50     if __grains__["os"] in ["AIX"]:
51         if opts == "defaults":
52             opts = ""
53     if isinstance(opts, str):
54         opts = opts.split(",")
55     if opts:
56         opts.sort()
57     if isinstance(hidden_opts, str):
58         hidden_opts = hidden_opts.split(",")
59     if not name == "/":
60         name = name.rstrip("/")
61     device_list = []
62     active = __salt__["mount.active"](extended=True)
63     real_name = os.path.realpath(name)
64     if device.startswith("/"):
65         if "bind" in opts and real_name in active:
66             _device = device
67             if active[real_name]["device"].startswith("/"):
68                 while True:
69                     if _device in active:
70                         _real_device = active[_device]["device"]
71                         opts = list(
72                             set(
73                                 opts
74                                 + active[_device]["opts"]
75                                 + active[_device]["superopts"]
76                             )
77                         )
78                         active[real_name]["opts"].append("bind")
79                         break
80                     _device = os.path.dirname(_device)
81                 real_device = _real_device
82             else:
83                 if _device in active:
84                     opts = list(
85                         set(
86                             opts
87                             + active[_device]["opts"]
88                             + active[_device]["superopts"]
89                         )
90                     )
91                     active[real_name]["opts"].append("bind")
92                 real_device = active[real_name]["device"]
93         else:
94             real_device = os.path.realpath(device)
95     elif device.upper().startswith("UUID="):
96         real_device = device.split("=")[1].strip('"').lower()
97     elif device.upper().startswith("LABEL="):
98         _label = device.split("=")[1]
99         cmd = "blkid -t LABEL={}".format(_label)
100         res = __salt__["cmd.run_all"]("{}".format(cmd))
101         if res["retcode"] &gt; 0:
102             ret["comment"] = "Unable to find device with label {}.".format(_label)
103             ret["result"] = False
104             return ret
105         else:
106             for line in res["stdout"]:
107                 dev_with_label = line.split(":")[0]
108                 device_list.append(dev_with_label)
109             real_device = device_list[0]
110     else:
111         real_device = device
112     lvs_match = re.match(r"^/dev/(?P&lt;vg_name&gt;[^/]+)/(?P&lt;lv_name&gt;[^/]+$)", device)
113     if lvs_match:
114         double_dash_escaped = {
115             k: re.sub(r"-", "--", v) for k, v in lvs_match.groupdict().items()
116         }
117         mapper_device = "/dev/mapper/{vg_name}-{lv_name}".format(**double_dash_escaped)
118         if os.path.exists(mapper_device):
119             real_device = mapper_device
120     fuse_match = re.match(r"^\w+\#(?P&lt;device_name&gt;.+)", device)
121     if fuse_match:
122         if "device_name" in fuse_match.groupdict():
123             real_device = fuse_match.group("device_name")
124     if real_name in active:
125         if "superopts" not in active[real_name]:
126             active[real_name]["superopts"] = []
127         if mount:
128             device_list.append(active[real_name]["device"])
129             device_list.append(os.path.realpath(device_list[0]))
130             alt_device = (
131                 active[real_name]["alt_device"]
132                 if "alt_device" in active[real_name]
133                 else None
134             )
135             uuid_device = (
136                 active[real_name]["device_uuid"]
137                 if "device_uuid" in active[real_name]
138                 else None
139             )
140             label_device = (
141                 active[real_name]["device_label"]
142                 if "device_label" in active[real_name]
143                 else None
144             )
145             if alt_device and alt_device not in device_list:
146                 device_list.append(alt_device)
147             if uuid_device and uuid_device not in device_list:
148                 device_list.append(uuid_device)
149             if label_device and label_device not in device_list:
150                 device_list.append(label_device)
151             if opts:
152                 opts.sort()
153                 mount_invisible_options = [
154                     "_netdev",
155                     "actimeo",
156                     "bg",
157                     "comment",
158                     "defaults",
159                     "delay_connect",
160                     "direct-io-mode",
161                     "intr",
162                     "loop",
163                     "nointr",
164                     "nobootwait",
165                     "nofail",
166                     "password",
167                     "reconnect",
168                     "retry",
169                     "soft",
170                     "auto",
171                     "users",
172                     "bind",
173                     "nonempty",
174                     "transform_symlinks",
175                     "port",
176                     "backup-volfile-servers",
177                 ]
178                 if extra_mount_invisible_options:
179                     mount_invisible_options.extend(extra_mount_invisible_options)
180                 if hidden_opts:
181                     mount_invisible_options = list(
182                         set(mount_invisible_options) | set(hidden_opts)
183                     )
184                 mount_invisible_keys = [
185                     "actimeo",
186                     "comment",
187                     "credentials",
188                     "direct-io-mode",
189                     "password",
190                     "port",
191                     "retry",
192                     "secretfile",
193                 ]
194                 if extra_mount_invisible_keys:
195                     mount_invisible_keys.extend(extra_mount_invisible_keys)
196                 mount_ignore_fs_keys = {"ramfs": ["size"]}
197                 if extra_mount_ignore_fs_keys:
198                     mount_ignore_fs_keys.update(extra_mount_ignore_fs_keys)
199                 mount_translate_options = {
200                     "tcp": "proto=tcp",
201                     "udp": "proto=udp",
202                 }
203                 if extra_mount_translate_options:
204                     mount_translate_options.update(extra_mount_translate_options)
205                 for opt in opts:
206                     if opt in mount_translate_options:
207                         opt = mount_translate_options[opt]
208                     keyval_option = opt.split("=")[0]
209                     if keyval_option in mount_invisible_keys:
210                         opt = keyval_option
211                     size_match = re.match(
212                         r"size=(?P&lt;size_value&gt;[0-9]+)(?P&lt;size_unit&gt;k|m|g)", opt
213                     )
214                     if size_match:
215                         converted_size = _size_convert(size_match)
216                         opt = "size={}k".format(converted_size)
217                     if fstype in ["cifs"] and opt.split("=")[0] == "user":
218                         opt = "username={}".format(opt.split("=")[1])
219                     if opt.split("=")[0] in mount_ignore_fs_keys.get(fstype, []):
220                         opt = opt.split("=")[0]
221                     name_id_opts = {"uid": "user.info", "gid": "group.info"}
222                     if opt.split("=")[0] in name_id_opts and len(opt.split("=")) &gt; 1:
223                         _givenid = opt.split("=")[1]
224                         _param = opt.split("=")[0]
225                         _id = _givenid
226                         if not re.match("[0-9]+$", _givenid):
227                             _info = __salt__[name_id_opts[_param]](_givenid)
228                             if _info and _param in _info:
229                                 _id = _info[_param]
230                         opt = _param + "=" + str(_id)
231                     _active_superopts = active[real_name].get("superopts", [])
232                     for _active_opt in _active_superopts:
233                         size_match = re.match(
234                             r"size=(?P&lt;size_value&gt;[0-9]+)(?P&lt;size_unit&gt;k|m|g)",
235                             _active_opt,
236                         )
237                         if size_match:
238                             converted_size = _size_convert(size_match)
239                             opt = "size={}k".format(converted_size)
240                             _active_superopts.remove(_active_opt)
241                             _active_opt = "size={}k".format(converted_size)
242                             _active_superopts.append(_active_opt)
243                     if (
244                         opt not in active[real_name]["opts"]
245                         and opt not in _active_superopts
246                         and opt not in mount_invisible_options
247                         and opt not in mount_ignore_fs_keys.get(fstype, [])
248                         and opt not in mount_invisible_keys
249                     ):
250                         if __opts__["test"]:
251                             ret["result"] = None
252                             ret[
253                                 "comment"
254                             ] = "Remount would be forced because options ({}) changed".format(
255                                 opt
256                             )
257                             return ret
258                         else:
259                             if fstype in ["nfs", "cvfs"] or fstype.startswith("fuse"):
260                                 ret["changes"]["umount"] = (
261                                     "Forced unmount and mount because "
262                                     + "options ({}) changed".format(opt)
263                                 )
264                                 unmount_result = __salt__["mount.umount"](real_name)
265                                 if unmount_result is True:
266                                     mount_result = __salt__["mount.mount"](
267                                         real_name,
268                                         device,
269                                         mkmnt=mkmnt,
270                                         fstype=fstype,
271                                         opts=opts,
272                                     )
273                                     ret["result"] = mount_result
274                                 else:
275                                     ret["result"] = False
276                                     ret["comment"] = "Unable to unmount {}: {}.".format(
277                                         real_name, unmount_result
278                                     )
279                                     return ret
280                             else:
281                                 ret["changes"]["umount"] = (
282                                     "Forced remount because "
283                                     + "options ({}) changed".format(opt)
284                                 )
285                                 remount_result = __salt__["mount.remount"](
286                                     real_name,
287                                     device,
288                                     mkmnt=mkmnt,
289                                     fstype=fstype,
290                                     opts=opts,
291                                 )
292                                 ret["result"] = remount_result
293                                 if "remount" in opts:
294                                     opts.remove("remount")
295                             update_mount_cache = True
296                 mount_cache = __salt__["mount.read_mount_cache"](real_name)
297                 if "opts" in mount_cache:
298                     _missing = [opt for opt in mount_cache["opts"] if opt not in opts]
299                     if _missing:
300                         if __opts__["test"]:
301                             ret["result"] = None
302                             ret["comment"] = (
303                                 "Remount would be forced because"
304                                 " options ({})"
305                                 "changed".format(",".join(_missing))
306                             )
307                             return ret
308                         else:
309                             if fstype in ["nfs", "cvfs"] or fstype.startswith("fuse"):
310                                 ret["changes"]["umount"] = (
311                                     "Forced unmount and mount because "
312                                     + "options ({}) changed".format(opt)
313                                 )
314                                 unmount_result = __salt__["mount.umount"](real_name)
315                                 if unmount_result is True:
316                                     mount_result = __salt__["mount.mount"](
317                                         real_name,
318                                         device,
319                                         mkmnt=mkmnt,
320                                         fstype=fstype,
321                                         opts=opts,
322                                     )
323                                     ret["result"] = mount_result
324                                 else:
325                                     ret["result"] = False
326                                     ret["comment"] = "Unable to unmount {}: {}.".format(
327                                         real_name, unmount_result
328                                     )
329                                     return ret
330                             else:
331                                 ret["changes"]["umount"] = (
332                                     "Forced remount because "
333                                     + "options ({}) changed".format(opt)
334                                 )
335                                 remount_result = __salt__["mount.remount"](
336                                     real_name,
337                                     device,
338                                     mkmnt=mkmnt,
339                                     fstype=fstype,
340                                     opts=opts,
341                                 )
342                                 ret["result"] = remount_result
343                                 if "remount" in opts:
344                                     opts.remove("remount")
345                         update_mount_cache = True
346                 else:
347                     update_mount_cache = True
348             if real_device not in device_list:
349                 _device_mismatch_is_ignored = None
350                 for regex in list(device_name_regex):
351                     for _device in device_list:
352                         if re.match(regex, _device):
353                             _device_mismatch_is_ignored = _device
354                             break
355                 if _device_mismatch_is_ignored:
356                     ret["result"] = True
357                     ret["comment"] = (
358                         "An umount will not be forced "
359                         + "because device matched device_name_regex: "
360                         + _device_mismatch_is_ignored
361                     )
362                 elif __opts__["test"]:
363                     ret["result"] = None
364                     ret["comment"] = (
365                         "An umount would have been forced "
366                         + "because devices do not match.  Watched: "
367                         + device
368                     )
369                 else:
370                     ret["changes"]["umount"] = (
371                         "Forced unmount because devices "
372                         + "don't match. Wanted: "
373                         + device
374                     )
375                     if real_device != device:
376                         ret["changes"]["umount"] += " (" + real_device + ")"
377                     ret["changes"]["umount"] += ", current: " + ", ".join(device_list)
378                     out = __salt__["mount.umount"](real_name, user=user)
379                     active = __salt__["mount.active"](extended=True)
380                     if real_name in active:
381                         ret["comment"] = "Unable to unmount"
382                         ret["result"] = None
383                         return ret
384                     update_mount_cache = True
385             else:
386                 ret["comment"] = "Target was already mounted"
387     if real_name not in active:
388         if mount:
389             if __opts__["test"]:
390                 ret["result"] = None
391                 if os.path.exists(name):
392                     ret["comment"] = "{} would be mounted".format(name)
393                 elif mkmnt:
394                     ret["comment"] = "{} would be created and mounted".format(name)
395                 else:
396                     ret[
397                         "comment"
398                     ] = "{} does not exist and would not be created".format(name)
399                 return ret
400             if not os.path.exists(name) and not mkmnt:
401                 ret["result"] = False
402                 ret["comment"] = "Mount directory is not present"
403                 return ret
404             out = __salt__["mount.mount"](name, device, mkmnt, fstype, opts, user=user)
405             active = __salt__["mount.active"](extended=True)
406             update_mount_cache = True
407             if isinstance(out, str):
408                 ret["comment"] = out
409                 ret["result"] = False
410                 return ret
411             elif real_name in active:
412                 ret["comment"] = "Target was successfully mounted"
413                 ret["changes"]["mount"] = True
414         elif not os.path.exists(name):
415             if __opts__["test"]:
416                 ret["result"] = None
417                 if mkmnt:
418                     ret["comment"] = "{} would be created, but not mounted".format(name)
419                 else:
420                     ret[
421                         "comment"
422                     ] = "{} does not exist and would neither be created nor mounted".format(
423                         name
424                     )
425             elif mkmnt:
426                 __salt__["file.mkdir"](name, user=user)
427                 ret["comment"] = "{} was created, not mounted".format(name)
428             else:
429                 ret["comment"] = "{} not present and not mounted".format(name)
430         else:
431             if __opts__["test"]:
432                 ret["result"] = None
433                 ret["comment"] = "{} would not be mounted".format(name)
434             else:
435                 ret["comment"] = "{} not mounted".format(name)
436     if persist:
437         if "/etc/fstab" == config:
438             if __grains__["os"] in ["MacOS", "Darwin"]:
439                 config = "/etc/auto_salt"
440             elif "AIX" in __grains__["os"]:
441                 config = "/etc/filesystems"
442         if __opts__["test"]:
443             if __grains__["os"] in ["MacOS", "Darwin"]:
444                 out = __salt__["mount.set_automaster"](
445                     name, device, fstype, opts, config, test=True
446                 )
447             elif __grains__["os"] in ["AIX"]:
448                 out = __salt__["mount.set_filesystems"](
449                     name,
450                     device,
451                     fstype,
452                     opts,
453                     mount,
454                     config,
455                     test=True,
456                     match_on=match_on,
457                 )
458             else:
459                 out = __salt__["mount.set_fstab"](
460                     name,
461                     device,
462                     fstype,
463                     opts,
464                     dump,
465                     pass_num,
466                     config,
467                     test=True,
468                     match_on=match_on,
469                 )
470             if out != "present":
471                 ret["result"] = None
472                 if out == "new":
473                     if mount:
474                         comment = (
475                             "{} is mounted, but needs to be "
476                             "written to the fstab in order to be "
477                             "made persistent.".format(name)
478                         )
479                     else:
480                         comment = (
481                             "{} needs to be "
482                             "written to the fstab in order to be "
483                             "made persistent.".format(name)
484                         )
485                 elif out == "change":
486                     if mount:
487                         comment = "{} is mounted, but its fstab entry must be updated.".format(
488                             name
489                         )
490                     else:
491                         comment = "The {} fstab entry must be updated.".format(name)
492                 else:
493                     ret["result"] = False
494                     comment = (
495                         "Unable to detect fstab status for "
496                         "mount point {} due to unexpected "
497                         "output '{}' from call to "
498                         "mount.set_fstab. This is most likely "
499                         "a bug.".format(name, out)
500                     )
501                 if "comment" in ret:
502                     ret["comment"] = "{}. {}".format(ret["comment"], comment)
503                 else:
504                     ret["comment"] = comment
505                 return ret
506         else:
507             if __grains__["os"] in ["MacOS", "Darwin"]:
508                 out = __salt__["mount.set_automaster"](
509                     name, device, fstype, opts, config
510                 )
511             elif __grains__["os"] in ["AIX"]:
512                 out = __salt__["mount.set_filesystems"](
513                     name, device, fstype, opts, mount, config, match_on=match_on
514                 )
515             else:
516                 out = __salt__["mount.set_fstab"](
517                     name,
518                     device,
519                     fstype,
520                     opts,
521                     dump,
522                     pass_num,
523                     config,
524                     match_on=match_on,
525                 )
526         if update_mount_cache:
527             cache_result = __salt__["mount.write_mount_cache"](
528                 real_name, device, mkmnt=mkmnt, fstype=fstype, mount_opts=opts
529             )
530         if out == "present":
531             ret["comment"] += ". Entry already exists in the fstab."
532             return ret
533         if out == "new":
534             ret["changes"]["persist"] = "new"
535             ret["comment"] += ". Added new entry to the fstab."
536             return ret
537         if out == "change":
538             ret["changes"]["persist"] = "update"
539             ret["comment"] += ". Updated the entry in the fstab."
540             return ret
541         if out == "bad config":
542             ret["result"] = False
543             ret["comment"] += ". However, the fstab was not found."
544             return ret
545     return ret
546 def swap(name, persist=True, config="/etc/fstab"):
547     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
548     on_ = __salt__["mount.swaps"]()
549     if __salt__["file.is_link"](name):
550         real_swap_device = __salt__["file.readlink"](name)
551         if not real_swap_device.startswith("/"):
552             real_swap_device = "/dev/{}".format(os.path.basename(real_swap_device))
553     else:
554         real_swap_device = name
555     if real_swap_device in on_:
556         ret["comment"] = "Swap {} already active".format(name)
557     elif __opts__["test"]:
558         ret["result"] = None
559         ret["comment"] = "Swap {} is set to be activated".format(name)
560     else:
561         __salt__["mount.swapon"](real_swap_device)
562         on_ = __salt__["mount.swaps"]()
563         if real_swap_device in on_:
564             ret["comment"] = "Swap {} activated".format(name)
565             ret["changes"] = on_[real_swap_device]
566         else:
567             ret["comment"] = "Swap {} failed to activate".format(name)
568             ret["result"] = False
569     if persist:
570         device_key_name = "device"
571         if "AIX" in __grains__["os"]:
572             device_key_name = "dev"
573             if "/etc/fstab" == config:
574                 config = "/etc/filesystems"
575             fstab_data = __salt__["mount.filesystems"](config)
576         else:
577             fstab_data = __salt__["mount.fstab"](config)
578         if __opts__["test"]:
579             if name not in fstab_data and name not in [
580                 fstab_data[item]["device"] for item in fstab_data
581             ]:
582                 ret["result"] = None
583                 if name in on_:
584                     ret[
585                         "comment"
586                     ] = "Swap {} is set to be added to the fstab and to be activated".format(
587                         name
588                     )
589             return ret
590         if "none" in fstab_data:
591             if (
592                 fstab_data["none"][device_key_name] == name
593                 and fstab_data["none"]["fstype"] != "swap"
594             ):
595                 return ret
596         if "AIX" in __grains__["os"]:
597             out = None
598             ret["result"] = False
599             ret["comment"] += ". swap not present in /etc/filesystems on AIX."
600             return ret
601         else:
602             out = __salt__["mount.set_fstab"](
603                 "none", name, "swap", ["defaults"], 0, 0, config
604             )
605         if out == "present":
606             return ret
607         if out == "new":
608             ret["changes"]["persist"] = "new"
609             ret["comment"] += ". Added new entry to the fstab."
610             return ret
611         if out == "change":
612             ret["changes"]["persist"] = "update"
613             ret["comment"] += ". Updated the entry in the fstab."
614             return ret
615         if out == "bad config":
616             ret["result"] = False
617             ret["comment"] += ". However, the fstab was not found."
618             return ret
619     return ret
620 def unmounted(
621     name, device=None, config="/etc/fstab", persist=False, user=None, **kwargs
622 ):
623     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
624     update_mount_cache = False
625     if not name:
626         ret["result"] = False
627         ret["comment"] = "Must provide name to mount.unmounted"
628         return ret
629     active = __salt__["mount.active"](extended=True)
630     if name not in active:
631         ret["comment"] = "Target was already unmounted"
632     if name in active:
633         if __opts__["test"]:
634             ret["result"] = None
635             ret["comment"] = "Mount point {} is mounted but should not be".format(name)
636             return ret
637         if device:
638             out = __salt__["mount.umount"](name, device, user=user)
639             update_mount_cache = True
640         else:
641             out = __salt__["mount.umount"](name, user=user)
642             update_mount_cache = True
643         if isinstance(out, str):
644             ret["comment"] = out
645             ret["result"] = False
646         elif out is True:
647             ret["comment"] = "Target was successfully unmounted"
648             ret["changes"]["umount"] = True
649         else:
650             ret["comment"] = "Execute set to False, Target was not unmounted"
651             ret["result"] = True
652     if update_mount_cache:
653         cache_result = __salt__["mount.delete_mount_cache"](name)
654     if persist:
655         device_key_name = "device"
656         if __grains__["os"] in ["MacOS", "Darwin"] and config == "/etc/fstab":
657             config = "/etc/auto_salt"
658             fstab_data = __salt__["mount.automaster"](config)
659         elif "AIX" in __grains__["os"]:
660             device_key_name = "dev"
661             if config == "/etc/fstab":
662                 config = "/etc/filesystems"
663             fstab_data = __salt__["mount.filesystems"](config)
664         else:
665             fstab_data = __salt__["mount.fstab"](config)
666         if name not in fstab_data:
667             ret["comment"] += ". fstab entry not found"
668         else:
669             if device:
670                 if fstab_data[name][device_key_name] != device:
671                     ret["comment"] += ". fstab entry for device {} not found".format(
672                         device
673                     )
674                     return ret
675             if __opts__["test"]:
676                 ret["result"] = None
677                 ret["comment"] = (
678                     "Mount point {} is unmounted but needs to "
679                     "be purged from {} to be made "
680                     "persistent".format(name, config)
681                 )
682                 return ret
683             else:
684                 if __grains__["os"] in ["MacOS", "Darwin"]:
685                     out = __salt__["mount.rm_automaster"](name, device, config)
686                 elif "AIX" in __grains__["os"]:
687                     out = __salt__["mount.rm_filesystems"](name, device, config)
688                 else:
689                     out = __salt__["mount.rm_fstab"](name, device, config)
690                 if out is not True:
691                     ret["result"] = False
692                     ret["comment"] += ". Failed to persist purge"
693                 else:
694                     ret["comment"] += ". Removed target from fstab"
695                     ret["changes"]["persist"] = "purged"
696     return ret
697 def mod_watch(name, user=None, **kwargs):
698     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
699     if kwargs["sfun"] == "mounted":
700         out = __salt__["mount.remount"](
701             name, kwargs["device"], False, kwargs["fstype"], kwargs["opts"], user=user
702         )
703         if out:
704             ret["comment"] = "{} remounted".format(name)
705         else:
706             ret["result"] = False
707             ret["comment"] = "{} failed to remount: {}".format(name, out)
708     else:
709         ret["comment"] = "Watch not supported in {} at this time".format(kwargs["sfun"])
710     return ret
711 def _convert_to(maybe_device, convert_to):
712     if (
713         not convert_to
714         or (convert_to == "device" and maybe_device.startswith("/"))
715         or maybe_device.startswith("{}=".format(convert_to.upper()))
716     ):
717         return maybe_device
718     if maybe_device.startswith("/"):
719         blkid = __salt__["disk.blkid"](maybe_device)
720     else:
721         blkid = __salt__["disk.blkid"](token=maybe_device)
722     result = None
723     if len(blkid) == 1:
724         if convert_to == "device":
725             result = next(iter(blkid))
726         else:
727             result = "{}={}".format(key, next(iter(blkid.values()))[key])
728     r<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn result
729 def fstab_present(
730     name,
731     fs_file,
732     fs_vfstype,
733     fs_mntops="defaults",
734     fs_freq=0,
735     fs_passno=0,
736     mount_by=None,
737     config="/etc/fstab",
738     mount=True,
739     match_on="auto",
740     not_change=False,
741     fs_mount=True,
742 ):
743     ret =</b></font> {
744         "name": name,
745         "result": False,
746         "changes": {},
747         "comment": [],
748     }
749     if fs_mntops == "defaults":
750         if __grains__["os"] in ["MacOS", "Darwin"]:
751             fs_mntops = "noowners"
752         elif __grains__["os"] == "AIX":
753             fs_mntops = ""
754     if config == "/etc/fstab":
755         if __grains__["os"] in ["MacOS", "Darwin"]:
756             config = "/etc/auto_salt"
757         elif __grains__["os"] == "AIX":
758             config = "/etc/filesystems"
759     if not fs_file == "/":
760         fs_file = fs_file.rstrip("/")
761     fs_spec = _convert_to(name, mount_by)
762     if not fs_spec:
763         msg = "Device {} cannot be converted to {}"
764         ret["comment"].append(msg.format(name, mount_by))
765         return ret
766     if __opts__["test"]:
767         if __grains__["os"] in ["MacOS", "Darwin"]:
768             out = __salt__["mount.set_automaster"](
769                 name=fs_file,
770                 device=fs_spec,
771                 fstype=fs_vfstype,
772                 opts=fs_mntops,
773                 config=config,
774                 test=True,
775                 not_change=not_change,
776             )
777         elif __grains__["os"] == "AIX":
778             out = __salt__["mount.set_filesystems"](
779                 name=fs_file,
780                 device=fs_spec,
781                 fstype=fs_vfstype,
782                 opts=fs_mntops,
783                 mount=fs_mount,
784                 config=config,
785                 test=True,
786                 match_on=match_on,
787                 not_change=not_change,
788             )
789         else:
790             out = __salt__["mount.set_fstab"](
791                 name=fs_file,
792                 device=fs_spec,
793                 fstype=fs_vfstype,
794                 opts=fs_mntops,
795                 dump=fs_freq,
796                 pass_num=fs_passno,
797                 config=config,
798                 test=True,
799                 match_on=match_on,
800                 not_change=not_change,
801             )
802         ret["result"] = None
803         if out == "present":
804             msg = "{} entry is already in {}."
805             ret["comment"].append(msg.format(fs_file, config))
806         elif out == "new":
807             msg = "{} entry will be written in {}."
808             ret["comment"].append(msg.format(fs_file, config))
809             if mount:
810                 msg = "Will mount {} on {}".format(name, fs_file)
811                 ret["comment"].append(msg)
812         elif out == "change":
813             msg = "{} entry will be updated in {}."
814             ret["comment"].append(msg.format(fs_file, config))
815         else:
816             ret["result"] = False
817             msg = "{} entry cannot be created in {}: {}."
818             ret["comment"].append(msg.format(fs_file, config, out))
819         return ret
820     if __grains__["os"] in ["MacOS", "Darwin"]:
821         out = __salt__["mount.set_automaster"](
822             name=fs_file,
823             device=fs_spec,
824             fstype=fs_vfstype,
825             opts=fs_mntops,
826             config=config,
827             not_change=not_change,
828         )
829     elif __grains__["os"] == "AIX":
830         out = __salt__["mount.set_filesystems"](
831             name=fs_file,
832             device=fs_spec,
833             fstype=fs_vfstype,
834             opts=fs_mntops,
835             mount=fs_mount,
836             config=config,
837             match_on=match_on,
838             not_change=not_change,
839         )
840     else:
841         out = __salt__["mount.set_fstab"](
842             name=fs_file,
843             device=fs_spec,
844             fstype=fs_vfstype,
845             opts=fs_mntops,
846             dump=fs_freq,
847             pass_num=fs_passno,
848             config=config,
849             match_on=match_on,
850             not_change=not_change,
851         )
852     ret["result"] = True
853     if out == "present":
854         msg = "{} entry was already in {}."
855         ret["comment"].append(msg.format(fs_file, config))
856     elif out == "new":
857         ret["changes"]["persist"] = out
858         msg = "{} entry added in {}."
859         ret["comment"].append(msg.format(fs_file, config))
860         if mount:
861             out = __salt__["mount.mount"](fs_file)
862             if type(out) == str:
863                 ret["result"] = False
864                 msg = "Error while mounting {}".format(out.split(":", maxsplit=1)[1])
865             else:
866                 msg = "Mounted {} on {}".format(name, fs_file)
867             ret["comment"].append(msg)
868     elif out == "change":
869         ret["changes"]["persist"] = out
870         msg = "{} entry updated in {}."
871         ret["comment"].append(msg.format(fs_file, config))
872     else:
873         ret["result"] = False
874         msg = "{} entry cannot be changed in {}: {}."
875         ret["comment"].append(msg.format(fs_file, config, out))
876     return ret
877 def fstab_absent(name, fs_file, mount_by=None, config="/etc/fstab"):
878     ret = {
879         "name": name,
880         "result": False,
881         "changes": {},
882         "comment": [],
883     }
884     if config == "/etc/fstab":
885         if __grains__["os"] in ["MacOS", "Darwin"]:
886             config = "/etc/auto_salt"
887         elif __grains__["os"] == "AIX":
888             config = "/etc/filesystems"
889     if not fs_file == "/":
890         fs_file = fs_file.rstrip("/")
891     fs_spec = _convert_to(name, mount_by)
892     if __grains__["os"] in ["MacOS", "Darwin"]:
893         fstab_data = __salt__["mount.automaster"](config)
894     elif __grains__["os"] == "AIX":
895         fstab_data = __salt__["mount.filesystems"](config)
896     else:
897         fstab_data = __salt__["mount.fstab"](config)
898     if __opts__["test"]:
899         ret["result"] = None
900         if fs_file not in fstab_data:
901             msg = "{} entry is already missing in {}."
902             ret["comment"].append(msg.format(fs_file, config))
903         else:
904             msg = "{} entry will be removed from {}."
905             ret["comment"].append(msg.format(fs_file, config))
906         return ret
907     if fs_file in fstab_data:
908         if __grains__["os"] in ["MacOS", "Darwin"]:
909             out = __salt__["mount.rm_automaster"](
910                 name=fs_file, device=fs_spec, config=config
911             )
912         elif __grains__["os"] == "AIX":
913             out = __salt__["mount.rm_filesystems"](
914                 name=fs_file, device=fs_spec, config=config
915             )
916         else:
917             out = __salt__["mount.rm_fstab"](
918                 name=fs_file, device=fs_spec, config=config
919             )
920         if out is not True:
921             ret["result"] = False
922             msg = "{} entry failed when removing from {}."
923             ret["comment"].append(msg.format(fs_file, config))
924         else:
925             ret["result"] = True
926             ret["changes"]["persist"] = "removed"
927             msg = "{} entry removed from {}."
928             ret["comment"].append(msg.format(fs_file, config))
929     else:
930         ret["result"] = True
931         msg = "{} entry is already missing in {}."
932         ret["comment"].append(msg.format(fs_file, config))
933     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
