<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for capirca_acl.py &amp; mount_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for capirca_acl.py &amp; mount_2.py
      </h3>
<h1 align="center">
        2.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>capirca_acl.py (3.2886724%)<th>mount_2.py (1.7464424%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(612-873)<td><a href="#" name="0">(51-70)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(899-915)<td><a href="#" name="1">(1070-1144)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>capirca_acl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import inspect
3 import logging
4 import re
5 import salt.utils.files
6 log = logging.getLogger(__file__)
7 try:
8     import capirca
9     import capirca.aclgen
10     import capirca.lib.policy
11     import capirca.lib.aclgenerator
12     HAS_CAPIRCA = True
13 except ImportError:
14     HAS_CAPIRCA = False
15 __virtualname__ = "capirca"
16 __proxyenabled__ = ["*"]
17 def __virtual__():
18     if HAS_CAPIRCA:
19         return __virtualname__
20     else:
21         return (False, "The capirca module (capirca_acl) cannot be loaded.")
22 _TERM_FIELDS = {
23     "action": [],
24     "address": [],
25     "address_exclude": [],
26     "comment": [],
27     "counter": None,
28     "expiration": None,
29     "destination_address": [],
30     "destination_address_exclude": [],
31     "destination_port": [],
32     "destination_prefix": [],
33     "forwarding_class": [],
34     "forwarding_class_except": [],
35     "logging": [],
36     "log_name": None,
37     "loss_priority": None,
38     "option": [],
39     "owner": None,
40     "policer": None,
41     "port": [],
42     "precedence": [],
43     "principals": [],
44     "protocol": [],
45     "protocol_except": [],
46     "qos": None,
47     "pan_application": [],
48     "routing_instance": None,
49     "source_address": [],
50     "source_address_exclude": [],
51     "source_port": [],
52     "source_prefix": [],
53     "verbatim": [],
54     "packet_length": None,
55     "fragment_offset": None,
56     "hop_limit": None,
57     "icmp_type": [],
58     "icmp_code": None,
59     "ether_type": [],
60     "traffic_class_count": None,
61     "traffic_type": [],
62     "translated": False,
63     "dscp_set": None,
64     "dscp_match": [],
65     "dscp_except": [],
66     "next_ip": None,
67     "flexible_match_range": [],
68     "source_prefix_except": [],
69     "destination_prefix_except": [],
70     "vpn": None,
71     "source_tag": [],
72     "destination_tag": [],
73     "source_interface": None,
74     "destination_interface": None,
75     "platform": [],
76     "platform_exclude": [],
77     "timeout": None,
78     "flattened": False,
79     "flattened_addr": None,
80     "flattened_saddr": None,
81     "flattened_daddr": None,
82     "priority": None,
83     "ttl": None,
84 }
85 _IP_FILEDS = [
86     "source_address",
87     "source_address_exclude",
88     "destination_address",
89     "address",
90     "address_exclude",
91     "flattened_addr",
92     "flattened_saddr",
93     "flattened_daddr",
94     "next_ip",
95 ]
96 _SERVICES = {}
97 if HAS_CAPIRCA:
98     _TempTerm = capirca.lib.policy.Term
99     def _add_object(self, obj):
100         return
101     setattr(_TempTerm, "AddObject", _add_object)
102     dumy_term = _TempTerm(None)
103     for item in dir(dumy_term):
104         if hasattr(item, "__func__") or item.startswith("_") or item != item.lower():
105             continue
106         _TERM_FIELDS[item] = getattr(dumy_term, item)
107     class _Policy(capirca.lib.policy.Policy):
108         def __init__(self):
109             self.filters = []
110             self.filename = ""
111     class _Term(capirca.lib.policy.Term):
112         def __init__(self):
113             for field, default in _TERM_FIELDS.items():
114                 setattr(self, field, default)
115 def _import_platform_generator(platform):
116     log.debug("Using platform: %s", platform)
117     for mod_name, mod_obj in inspect.getmembers(capirca.aclgen):
118         if mod_name == platform and inspect.ismodule(mod_obj):
119             for plat_obj_name, plat_obj in inspect.getmembers(
120                 mod_obj
121             ):  # pylint: disable=unused-variable
122                 if inspect.isclass(plat_obj) and issubclass(
123                     plat_obj, capirca.lib.aclgenerator.ACLGenerator
124                 ):
125                     log.debug("Identified Capirca class %s for %s", plat_obj, platform)
126                     return plat_obj
127     log.error("Unable to identify any Capirca plaform class for %s", platform)
128 def _get_services_mapping():
129     if _SERVICES:
130         return _SERVICES
131     services_txt = ""
132     try:
133         with salt.utils.files.fopen("/etc/services", "r") as srv_f:
134             services_txt = salt.utils.stringutils.to_unicode(srv_f.read())
135     except OSError as ioe:
136         log.error("Unable to read from /etc/services:")
137         log.error(ioe)
138         return _SERVICES  # no mapping possible, sorry
139     service_rgx = re.compile(r"^([a-zA-Z0-9-]+)\s+(\d+)\/(tcp|udp)(.*)$")
140     for line in services_txt.splitlines():
141         service_rgx_s = service_rgx.search(line)
142         if service_rgx_s and len(service_rgx_s.groups()) == 4:
143             srv_name, port, protocol, _ = service_rgx_s.groups()
144             if srv_name not in _SERVICES:
145                 _SERVICES[srv_name] = {"port": [], "protocol": []}
146             try:
147                 _SERVICES[srv_name]["port"].append(int(port))
148             except ValueError as verr:
149                 log.error(verr)
150                 log.error("Did not read that properly:")
151                 log.error(line)
152                 log.error(
153                     "Please report the above error: %s does not seem a valid port"
154                     " value!",
155                     port,
156                 )
157             _SERVICES[srv_name]["protocol"].append(protocol)
158     return _SERVICES
159 def _translate_port(port):
160     services = _get_services_mapping()
161     if port in services and services[port]["port"]:
162         return services[port]["port"][0]
163     return port
164 def _make_it_list(dict_, field_name, value):
165     prev_value = []
166     if field_name in dict_:
167         prev_value = dict_[field_name]
168     if value is None:
169         return prev_value
170     elif isinstance(value, (tuple, list)):
171         if field_name in ("source_port", "destination_port"):
172             portval = []
173             for port in value:
174                 if not isinstance(port, (tuple, list)):
175                     portval.append((port, port))
176                 else:
177                     portval.append(port)
178             translated_portval = []
179             for port_start, port_end in portval:
180                 if not isinstance(port_start, int):
181                     port_start = _translate_port(port_start)
182                 if not isinstance(port_end, int):
183                     port_end = _translate_port(port_end)
184                 translated_portval.append((port_start, port_end))
185             return list(set(prev_value + translated_portval))
186         return list(set(prev_value + list(value)))
187     if field_name in ("source_port", "destination_port"):
188         if not isinstance(value, int):
189             value = _translate_port(value)
190         return list(set(prev_value + [(value, value)]))  # a list of tuples
191     return list(set(prev_value + [value]))
192 def _clean_term_opts(term_opts):
193     clean_opts = {}
194     _services = _get_services_mapping()
195     for field, value in term_opts.items():
196         if field == "source_service" and value:
197             if isinstance(value, str):
198                 value = _make_it_list(clean_opts, field, value)
199             log.debug("Processing special source services:")
200             log.debug(value)
201             for service in value:
202                 if service and service in _services:
203                     clean_opts["source_port"] = _make_it_list(
204                         clean_opts, "source_port", _services[service]["port"]
205                     )
206                     clean_opts["protocol"] = _make_it_list(
207                         clean_opts, "protocol", _services[service]["protocol"]
208                     )
209             log.debug(
210                 "Built source_port field, after processing special source services:"
211             )
212             log.debug(clean_opts.get("source_port"))
213             log.debug("Built protocol field, after processing special source services:")
214             log.debug(clean_opts.get("protocol"))
215         elif field == "destination_service" and value:
216             if isinstance(value, str):
217                 value = _make_it_list(clean_opts, field, value)
218             log.debug("Processing special destination services:")
219             log.debug(value)
220             for service in value:
221                 if service and service in _services:
222                     clean_opts["destination_port"] = _make_it_list(
223                         clean_opts, "destination_port", _services[service]["port"]
224                     )
225                     clean_opts["protocol"] = _make_it_list(
226                         clean_opts, "protocol", _services[service]["protocol"]
227                     )
228             log.debug(
229                 "Built source_port field, after processing special destination"
230                 " services:"
231             )
232             log.debug(clean_opts.get("destination_service"))
233             log.debug(
234                 "Built protocol field, after processing special destination services:"
235             )
236             log.debug(clean_opts.get("protocol"))
237         elif field in _TERM_FIELDS and value and value != _TERM_FIELDS[field]:
238             if isinstance(_TERM_FIELDS[field], list):
239                 value = _make_it_list(clean_opts, field, value)
240             if field in _IP_FILEDS:
241                 ip_values = []
242                 for addr in value:
243                     ip_values.append(capirca.lib.policy.nacaddr.IP(addr))
244                 value = ip_values[:]
245             clean_opts[field] = value
246     return clean_opts
247 def _lookup_element(lst, key):
248     if not lst:
249         return {}
250     for ele in lst:
251         if not ele or not isinstance(ele, dict):
252             continue
253         if key in ele:
254             return ele[key]
255     return {}
256 def _get_pillar_cfg(pillar_key, pillarenv=None, saltenv=None):
257     pillar_cfg = __salt__["pillar.get"](
258         pillar_key, pillarenv=pillarenv, saltenv=saltenv
259     )
260     return pillar_cfg
261 def _cleanup(lst):
262     clean = []
263     for ele in lst:
264         if ele and isinstance(ele, dict):
265             clean.append(ele)
266     return clean
267 def _merge_list_of_dict(first, second, prepend=True):
268     first = _cleanup(first)
269     second = _cleanup(second)
270     if not first and not second:
271         return []
272     if not first and second:
273         return second
274     if first and not second:
275         return first
276     overlaps = []
277     merged = []
278     appended = []
279     for ele in first:
280         if _lookup_element(second, next(iter(ele))):
281             overlaps.append(ele)
282         elif prepend:
283             merged.append(ele)
284         elif not prepend:
285             appended.append(ele)
286     for ele in second:
287         ele_key = next(iter(ele))
288         if _lookup_element(overlaps, ele_key):
289             ele_val_first = _lookup_element(first, ele_key)
290             merged.append({ele_key: ele_val_first})
291         else:
292             merged.append(ele)
293     if not prepend:
294         merged.extend(appended)
295     return merged
296 def _get_term_object(
297     filter_name,
298     term_name,
299     pillar_key="acl",
300     pillarenv=None,
301     saltenv=None,
302     merge_pillar=True,
303     **term_fields
304 ):
305     log.debug("Generating config for term %s under filter %s", term_name, filter_name)
306     term = _Term()
307     term.name = term_name
308     term_opts = {}
309     if merge_pillar:
310         term_opts = get_term_pillar(
311             filter_name,
312             term_name,
313             pillar_key=pillar_key,
314             saltenv=saltenv,
315             pillarenv=pillarenv,
316         )
317         log.debug("Merging with pillar data:")
318         log.debug(term_opts)
319         term_opts = _clean_term_opts(term_opts)
320         log.debug("Cleaning up pillar data:")
321         log.debug(term_opts)
322     log.debug("Received processing opts:")
323     log.debug(term_fields)
324     log.debug("Cleaning up processing opts:")
325     term_fields = _clean_term_opts(term_fields)
326     log.debug(term_fields)
327     log.debug("Final term opts:")
328     term_opts.update(term_fields)
329     log.debug(term_fields)
330     for field, value in term_opts.items():
331         setattr(term, field, value)
332     log.debug("Term config:")
333     log.debug(str(term))
334     return term
335 def _get_policy_object(
336     platform,
337     filters=None,
338     pillar_key="acl",
339     pillarenv=None,
340     saltenv=None,
341     merge_pillar=True,
342 ):
343     policy = _Policy()
344     policy_filters = []
345     if not filters:
346         filters = []
347     for filter_ in filters:
348         if not filter_ or not isinstance(filter_, dict):
349             continue  # go to the next filter
350         filter_name, filter_config = next(iter(filter_.items()))
351         header = capirca.lib.policy.Header()  # same header everywhere
352         target_opts = [platform, filter_name]
353         filter_options = filter_config.pop("options", None)
354         if filter_options:
355             filter_options = _make_it_list({}, filter_name, filter_options)
356             target_opts.extend(filter_options)
357         target = capirca.lib.policy.Target(target_opts)
358         header.AddObject(target)
359         filter_terms = []
360         for term_ in filter_config.get("terms", []):
361             if term_ and isinstance(term_, dict):
362                 term_name, term_fields = next(iter(term_.items()))
363                 term = _get_term_object(
364                     filter_name,
365                     term_name,
366                     pillar_key=pillar_key,
367                     pillarenv=pillarenv,
368                     saltenv=saltenv,
369                     merge_pillar=merge_pillar,
370                     **term_fields
371                 )
372             filter_terms.append(term)
373         policy_filters.append((header, filter_terms))
374     policy.filters = policy_filters
375     log.debug("Policy config:")
376     log.debug(str(policy))
377     platform_generator = _import_platform_generator(platform)
378     policy_config = platform_generator(policy, 2)
379     log.debug("Generating policy config for %s:", platform)
380     log.debug(str(policy_config))
381     return policy_config
382 def _revision_tag(
383     text,
384     revision_id=None,
385     revision_no=None,
386     revision_date=True,
387     revision_date_format="%Y/%m/%d",
388 ):
389     timestamp = datetime.datetime.now().strftime(revision_date_format)
390     new_text = []
391     for line in text.splitlines():
392         if "$Id:$" in line:
393             if not revision_id:  # if no explicit revision ID required
394                 continue  # jump to next line, ignore this one
395             line = line.replace("$Id:$", "$Id: {rev_id} $".format(rev_id=revision_id))
396         if "$Revision:$" in line:
397             if not revision_no:  # if no explicit revision number required
398                 continue  # jump to next line, ignore this one
399             line = line.replace(
400                 "$Revision:$", "$Revision: {rev_no} $".format(rev_no=revision_no)
401             )
402         if "$Date:$" in line:
403             if not revision_date:
404             line = line.replace("$Date:$", "$Date: {ts} $".format(ts=timestamp))
405         new_text.append(line)
406     return "\n".join(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new_text)
407 def get_term_config(
408     platform,
409     filter_name,
410     term_name,
411     filter_options=None,
412     pillar_key="acl",
413     pillarenv=None,
414     saltenv=None,
415     merge_pillar=True,
416     revision_id=None,
417     revision_no=None,
418     revision_date=True,
419     revision_date_format="%Y/%m/%d",
420     source_service=None,
421     destination_service=None,
422     **term_fields
423 ):
424     terms = []
425     term =</b></font> {term_name: {}}
426     term[term_name].update(term_fields)
427     term[term_name].update(
428         {
429             "source_service": _make_it_list({}, "source_service", source_service),
430             "destination_service": _make_it_list(
431                 {}, "destination_service", destination_service
432             ),
433         }
434     )
435     terms.append(term)
436     if not filter_options:
437         filter_options = []
438     return get_filter_config(
439         platform,
440         filter_name,
441         filter_options=filter_options,
442         terms=terms,
443         pillar_key=pillar_key,
444         pillarenv=pillarenv,
445         saltenv=saltenv,
446         merge_pillar=merge_pillar,
447         only_lower_merge=True,
448 <a name="1"></a>        revision_id=revision_id,
449         revision_no=revision_no,
450         revision_date=revision_date,
451         revision_date_format=<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>revision_date_format,
452     )
453 def get_filter_config(
454     platform,
455     filter_name,
456     filter_options=None,
457     terms=None,
458     prepend=True,
459     pillar_key="acl",
460     pillarenv=None,
461     saltenv=None,
462     merge_pillar=True,
463     only_lower_merge=False,
464     revision_id=None,
465     revision_no=</b></font>None,
466     revision_date=True,
467     revision_date_format="%Y/%m/%d",
468 ):
469     if not filter_options:
470         filter_options = []
471     if not terms:
472         terms = []
473     if merge_pillar and not only_lower_merge:
474         acl_pillar_cfg = _get_pillar_cfg(
475             pillar_key, saltenv=saltenv, pillarenv=pillarenv
476         )
477         filter_pillar_cfg = _lookup_element(acl_pillar_cfg, filter_name)
478         filter_options = filter_options or filter_pillar_cfg.pop("options", None)
479         if filter_pillar_cfg:
480             pillar_terms = filter_pillar_cfg.get(
481                 "terms", []
482             )  # No problem if empty in the pillar
483             terms = _merge_list_of_dict(terms, pillar_terms, prepend=prepend)
484     filters = []
485     filters.append(
486         {
487             filter_name: {
488                 "options": _make_it_list({}, filter_name, filter_options),
489                 "terms": terms,
490             }
491         }
492     )
493     return get_policy_config(
494         platform,
495         filters=filters,
496         pillar_key=pillar_key,
497         pillarenv=pillarenv,
498         saltenv=saltenv,
499         merge_pillar=merge_pillar,
500         only_lower_merge=True,
501         revision_id=revision_id,
502         revision_no=revision_no,
503         revision_date=revision_date,
504         revision_date_format=revision_date_format,
505     )
506 def get_policy_config(
507     platform,
508     filters=None,
509     prepend=True,
510     pillar_key="acl",
511     pillarenv=None,
512     saltenv=None,
513     merge_pillar=True,
514     only_lower_merge=False,
515     revision_id=None,
516     revision_no=None,
517     revision_date=True,
518     revision_date_format="%Y/%m/%d",
519 ):
520     if not filters:
521         filters = []
522     if merge_pillar and not only_lower_merge:
523         policy_pillar_cfg = _get_pillar_cfg(
524             pillar_key, saltenv=saltenv, pillarenv=pillarenv
525         )
526         filters = _merge_list_of_dict(filters, policy_pillar_cfg, prepend=prepend)
527     policy_object = _get_policy_object(
528         platform,
529         filters=filters,
530         pillar_key=pillar_key,
531         pillarenv=pillarenv,
532         saltenv=saltenv,
533         merge_pillar=merge_pillar,
534     )
535     policy_text = str(policy_object)
536     return _revision_tag(
537         policy_text,
538         revision_id=revision_id,
539         revision_no=revision_no,
540         revision_date=revision_date,
541         revision_date_format=revision_date_format,
542     )
543 def get_filter_pillar(filter_name, pillar_key="acl", pillarenv=None, saltenv=None):
544     pillar_cfg = _get_pillar_cfg(pillar_key, pillarenv=pillarenv, saltenv=saltenv)
545     return _lookup_element(pillar_cfg, filter_name)
546 def get_term_pillar(
547     filter_name, term_name, pillar_key="acl", pillarenv=None, saltenv=None
548 ):
549     filter_pillar_cfg = get_filter_pillar(
550         filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv
551     )
552     term_pillar_cfg = filter_pillar_cfg.get("terms", [])
553     term_opts = _lookup_element(term_pillar_cfg, term_name)
554     return term_opts
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mount_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os.path
3 import re
4 log = logging.getLogger(__name__)
5 def _size_convert(_re_size):
6     converted_size = int(_re_size.group("size_value"))
7     if _re_size.group("size_unit") == "m":
8 <a name="0"></a>        converted_size = int(converted_size) * 1024
9     if _re_size.group("size_unit") == "g":
10         converted_size = int(converted_size) * 1024 * 1024
11     r<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn converted_size
12 def mounted(
13     name,
14     device,
15     fstype,
16     mkmnt=False,
17     opts="defaults",
18     dump=0,
19     pass_num=0,
20     config="/etc/fstab",
21     persist=True,
22     mount=True,
23     user=None,
24     match_on="auto",
25     device_name_regex=None,
26     extra_mount_invisible_options=None,
27     extra_mount_invisible_keys=None,
28     extra_mount_ignore_fs_keys=</b></font>None,
29     extra_mount_translate_options=None,
30     hidden_opts=None,
31     **kwargs
32 ):
33     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
34     update_mount_cache = False
35     if not name:
36         ret["result"] = False
37         ret["comment"] = "Must provide name to mount.mounted"
38         return ret
39     if not device:
40         ret["result"] = False
41         ret["comment"] = "Must provide device to mount.mounted"
42         return ret
43     if not fstype:
44         ret["result"] = False
45         ret["comment"] = "Must provide fstype to mount.mounted"
46         return ret
47     if device_name_regex is None:
48         device_name_regex = []
49     if __grains__["os"] in ["MacOS", "Darwin"] and opts == "defaults":
50         opts = "noowners"
51     if __grains__["os"] in ["AIX"]:
52         if opts == "defaults":
53             opts = ""
54     if isinstance(opts, str):
55         opts = opts.split(",")
56     if opts:
57         opts.sort()
58     if isinstance(hidden_opts, str):
59         hidden_opts = hidden_opts.split(",")
60     if not name == "/":
61         name = name.rstrip("/")
62     device_list = []
63     active = __salt__["mount.active"](extended=True)
64     real_name = os.path.realpath(name)
65     if device.startswith("/"):
66         if "bind" in opts and real_name in active:
67             _device = device
68             if active[real_name]["device"].startswith("/"):
69                 while True:
70                     if _device in active:
71                         _real_device = active[_device]["device"]
72                         opts = list(
73                             set(
74                                 opts
75                                 + active[_device]["opts"]
76                                 + active[_device]["superopts"]
77                             )
78                         )
79                         active[real_name]["opts"].append("bind")
80                         break
81                     _device = os.path.dirname(_device)
82                 real_device = _real_device
83             else:
84                 if _device in active:
85                     opts = list(
86                         set(
87                             opts
88                             + active[_device]["opts"]
89                             + active[_device]["superopts"]
90                         )
91                     )
92                     active[real_name]["opts"].append("bind")
93                 real_device = active[real_name]["device"]
94         else:
95             real_device = os.path.realpath(device)
96     elif device.upper().startswith("UUID="):
97         real_device = device.split("=")[1].strip('"').lower()
98     elif device.upper().startswith("LABEL="):
99         _label = device.split("=")[1]
100         cmd = "blkid -t LABEL={}".format(_label)
101         res = __salt__["cmd.run_all"]("{}".format(cmd))
102         if res["retcode"] &gt; 0:
103             ret["comment"] = "Unable to find device with label {}.".format(_label)
104             ret["result"] = False
105             return ret
106         else:
107             for line in res["stdout"]:
108                 dev_with_label = line.split(":")[0]
109                 device_list.append(dev_with_label)
110             real_device = device_list[0]
111     else:
112         real_device = device
113     lvs_match = re.match(r"^/dev/(?P&lt;vg_name&gt;[^/]+)/(?P&lt;lv_name&gt;[^/]+$)", device)
114     if lvs_match:
115         double_dash_escaped = {
116             k: re.sub(r"-", "--", v) for k, v in lvs_match.groupdict().items()
117         }
118         mapper_device = "/dev/mapper/{vg_name}-{lv_name}".format(**double_dash_escaped)
119         if os.path.exists(mapper_device):
120             real_device = mapper_device
121     fuse_match = re.match(r"^\w+\#(?P&lt;device_name&gt;.+)", device)
122     if fuse_match:
123         if "device_name" in fuse_match.groupdict():
124             real_device = fuse_match.group("device_name")
125     if real_name in active:
126         if "superopts" not in active[real_name]:
127             active[real_name]["superopts"] = []
128         if mount:
129             device_list.append(active[real_name]["device"])
130             device_list.append(os.path.realpath(device_list[0]))
131             alt_device = (
132                 active[real_name]["alt_device"]
133                 if "alt_device" in active[real_name]
134                 else None
135             )
136             uuid_device = (
137                 active[real_name]["device_uuid"]
138                 if "device_uuid" in active[real_name]
139                 else None
140             )
141             label_device = (
142                 active[real_name]["device_label"]
143                 if "device_label" in active[real_name]
144                 else None
145             )
146             if alt_device and alt_device not in device_list:
147                 device_list.append(alt_device)
148             if uuid_device and uuid_device not in device_list:
149                 device_list.append(uuid_device)
150             if label_device and label_device not in device_list:
151                 device_list.append(label_device)
152             if opts:
153                 opts.sort()
154                 mount_invisible_options = [
155                     "_netdev",
156                     "actimeo",
157                     "bg",
158                     "comment",
159                     "defaults",
160                     "delay_connect",
161                     "direct-io-mode",
162                     "intr",
163                     "loop",
164                     "nointr",
165                     "nobootwait",
166                     "nofail",
167                     "password",
168                     "reconnect",
169                     "retry",
170                     "soft",
171                     "auto",
172                     "users",
173                     "bind",
174                     "nonempty",
175                     "transform_symlinks",
176                     "port",
177                     "backup-volfile-servers",
178                 ]
179                 if extra_mount_invisible_options:
180                     mount_invisible_options.extend(extra_mount_invisible_options)
181                 if hidden_opts:
182                     mount_invisible_options = list(
183                         set(mount_invisible_options) | set(hidden_opts)
184                     )
185                 mount_invisible_keys = [
186                     "actimeo",
187                     "comment",
188                     "credentials",
189                     "direct-io-mode",
190                     "password",
191                     "port",
192                     "retry",
193                     "secretfile",
194                 ]
195                 if extra_mount_invisible_keys:
196                     mount_invisible_keys.extend(extra_mount_invisible_keys)
197                 mount_ignore_fs_keys = {"ramfs": ["size"]}
198                 if extra_mount_ignore_fs_keys:
199                     mount_ignore_fs_keys.update(extra_mount_ignore_fs_keys)
200                 mount_translate_options = {
201                     "tcp": "proto=tcp",
202                     "udp": "proto=udp",
203                 }
204                 if extra_mount_translate_options:
205                     mount_translate_options.update(extra_mount_translate_options)
206                 for opt in opts:
207                     if opt in mount_translate_options:
208                         opt = mount_translate_options[opt]
209                     keyval_option = opt.split("=")[0]
210                     if keyval_option in mount_invisible_keys:
211                         opt = keyval_option
212                     size_match = re.match(
213                         r"size=(?P&lt;size_value&gt;[0-9]+)(?P&lt;size_unit&gt;k|m|g)", opt
214                     )
215                     if size_match:
216                         converted_size = _size_convert(size_match)
217                         opt = "size={}k".format(converted_size)
218                     if fstype in ["cifs"] and opt.split("=")[0] == "user":
219                         opt = "username={}".format(opt.split("=")[1])
220                     if opt.split("=")[0] in mount_ignore_fs_keys.get(fstype, []):
221                         opt = opt.split("=")[0]
222                     name_id_opts = {"uid": "user.info", "gid": "group.info"}
223                     if opt.split("=")[0] in name_id_opts and len(opt.split("=")) &gt; 1:
224                         _givenid = opt.split("=")[1]
225                         _param = opt.split("=")[0]
226                         _id = _givenid
227                         if not re.match("[0-9]+$", _givenid):
228                             _info = __salt__[name_id_opts[_param]](_givenid)
229                             if _info and _param in _info:
230                                 _id = _info[_param]
231                         opt = _param + "=" + str(_id)
232                     _active_superopts = active[real_name].get("superopts", [])
233                     for _active_opt in _active_superopts:
234                         size_match = re.match(
235                             r"size=(?P&lt;size_value&gt;[0-9]+)(?P&lt;size_unit&gt;k|m|g)",
236                             _active_opt,
237                         )
238                         if size_match:
239                             converted_size = _size_convert(size_match)
240                             opt = "size={}k".format(converted_size)
241                             _active_superopts.remove(_active_opt)
242                             _active_opt = "size={}k".format(converted_size)
243                             _active_superopts.append(_active_opt)
244                     if (
245                         opt not in active[real_name]["opts"]
246                         and opt not in _active_superopts
247                         and opt not in mount_invisible_options
248                         and opt not in mount_ignore_fs_keys.get(fstype, [])
249                         and opt not in mount_invisible_keys
250                     ):
251                         if __opts__["test"]:
252                             ret["result"] = None
253                             ret[
254                                 "comment"
255                             ] = "Remount would be forced because options ({}) changed".format(
256                                 opt
257                             )
258                             return ret
259                         else:
260                             if fstype in ["nfs", "cvfs"] or fstype.startswith("fuse"):
261                                 ret["changes"]["umount"] = (
262                                     "Forced unmount and mount because "
263                                     + "options ({}) changed".format(opt)
264                                 )
265                                 unmount_result = __salt__["mount.umount"](real_name)
266                                 if unmount_result is True:
267                                     mount_result = __salt__["mount.mount"](
268                                         real_name,
269                                         device,
270                                         mkmnt=mkmnt,
271                                         fstype=fstype,
272                                         opts=opts,
273                                     )
274                                     ret["result"] = mount_result
275                                 else:
276                                     ret["result"] = False
277                                     ret["comment"] = "Unable to unmount {}: {}.".format(
278                                         real_name, unmount_result
279                                     )
280                                     return ret
281                             else:
282                                 ret["changes"]["umount"] = (
283                                     "Forced remount because "
284                                     + "options ({}) changed".format(opt)
285                                 )
286                                 remount_result = __salt__["mount.remount"](
287                                     real_name,
288                                     device,
289                                     mkmnt=mkmnt,
290                                     fstype=fstype,
291                                     opts=opts,
292                                 )
293                                 ret["result"] = remount_result
294                                 if "remount" in opts:
295                                     opts.remove("remount")
296                             update_mount_cache = True
297                 mount_cache = __salt__["mount.read_mount_cache"](real_name)
298                 if "opts" in mount_cache:
299                     _missing = [opt for opt in mount_cache["opts"] if opt not in opts]
300                     if _missing:
301                         if __opts__["test"]:
302                             ret["result"] = None
303                             ret["comment"] = (
304                                 "Remount would be forced because"
305                                 " options ({})"
306                                 "changed".format(",".join(_missing))
307                             )
308                             return ret
309                         else:
310                             if fstype in ["nfs", "cvfs"] or fstype.startswith("fuse"):
311                                 ret["changes"]["umount"] = (
312                                     "Forced unmount and mount because "
313                                     + "options ({}) changed".format(opt)
314                                 )
315                                 unmount_result = __salt__["mount.umount"](real_name)
316                                 if unmount_result is True:
317                                     mount_result = __salt__["mount.mount"](
318                                         real_name,
319                                         device,
320                                         mkmnt=mkmnt,
321                                         fstype=fstype,
322                                         opts=opts,
323                                     )
324                                     ret["result"] = mount_result
325                                 else:
326                                     ret["result"] = False
327                                     ret["comment"] = "Unable to unmount {}: {}.".format(
328                                         real_name, unmount_result
329                                     )
330                                     return ret
331                             else:
332                                 ret["changes"]["umount"] = (
333                                     "Forced remount because "
334                                     + "options ({}) changed".format(opt)
335                                 )
336                                 remount_result = __salt__["mount.remount"](
337                                     real_name,
338                                     device,
339                                     mkmnt=mkmnt,
340                                     fstype=fstype,
341                                     opts=opts,
342                                 )
343                                 ret["result"] = remount_result
344                                 if "remount" in opts:
345                                     opts.remove("remount")
346                         update_mount_cache = True
347                 else:
348                     update_mount_cache = True
349             if real_device not in device_list:
350                 _device_mismatch_is_ignored = None
351                 for regex in list(device_name_regex):
352                     for _device in device_list:
353                         if re.match(regex, _device):
354                             _device_mismatch_is_ignored = _device
355                             break
356                 if _device_mismatch_is_ignored:
357                     ret["result"] = True
358                     ret["comment"] = (
359                         "An umount will not be forced "
360                         + "because device matched device_name_regex: "
361                         + _device_mismatch_is_ignored
362                     )
363                 elif __opts__["test"]:
364                     ret["result"] = None
365                     ret["comment"] = (
366                         "An umount would have been forced "
367                         + "because devices do not match.  Watched: "
368                         + device
369                     )
370                 else:
371                     ret["changes"]["umount"] = (
372                         "Forced unmount because devices "
373                         + "don't match. Wanted: "
374                         + device
375                     )
376                     if real_device != device:
377                         ret["changes"]["umount"] += " (" + real_device + ")"
378                     ret["changes"]["umount"] += ", current: " + ", ".join(device_list)
379                     out = __salt__["mount.umount"](real_name, user=user)
380                     active = __salt__["mount.active"](extended=True)
381                     if real_name in active:
382                         ret["comment"] = "Unable to unmount"
383                         ret["result"] = None
384                         return ret
385                     update_mount_cache = True
386             else:
387                 ret["comment"] = "Target was already mounted"
388     if real_name not in active:
389         if mount:
390             if __opts__["test"]:
391                 ret["result"] = None
392                 if os.path.exists(name):
393                     ret["comment"] = "{} would be mounted".format(name)
394                 elif mkmnt:
395                     ret["comment"] = "{} would be created and mounted".format(name)
396                 else:
397                     ret[
398                         "comment"
399                     ] = "{} does not exist and would not be created".format(name)
400                 return ret
401             if not os.path.exists(name) and not mkmnt:
402                 ret["result"] = False
403                 ret["comment"] = "Mount directory is not present"
404                 return ret
405             out = __salt__["mount.mount"](name, device, mkmnt, fstype, opts, user=user)
406             active = __salt__["mount.active"](extended=True)
407             update_mount_cache = True
408             if isinstance(out, str):
409                 ret["comment"] = out
410                 ret["result"] = False
411                 return ret
412             elif real_name in active:
413                 ret["comment"] = "Target was successfully mounted"
414                 ret["changes"]["mount"] = True
415         elif not os.path.exists(name):
416             if __opts__["test"]:
417                 ret["result"] = None
418                 if mkmnt:
419                     ret["comment"] = "{} would be created, but not mounted".format(name)
420                 else:
421                     ret[
422                         "comment"
423                     ] = "{} does not exist and would neither be created nor mounted".format(
424                         name
425                     )
426             elif mkmnt:
427                 __salt__["file.mkdir"](name, user=user)
428                 ret["comment"] = "{} was created, not mounted".format(name)
429             else:
430                 ret["comment"] = "{} not present and not mounted".format(name)
431         else:
432             if __opts__["test"]:
433                 ret["result"] = None
434                 ret["comment"] = "{} would not be mounted".format(name)
435             else:
436                 ret["comment"] = "{} not mounted".format(name)
437     if persist:
438         if "/etc/fstab" == config:
439             if __grains__["os"] in ["MacOS", "Darwin"]:
440                 config = "/etc/auto_salt"
441             elif "AIX" in __grains__["os"]:
442                 config = "/etc/filesystems"
443         if __opts__["test"]:
444             if __grains__["os"] in ["MacOS", "Darwin"]:
445                 out = __salt__["mount.set_automaster"](
446                     name, device, fstype, opts, config, test=True
447                 )
448             elif __grains__["os"] in ["AIX"]:
449                 out = __salt__["mount.set_filesystems"](
450                     name,
451                     device,
452                     fstype,
453                     opts,
454                     mount,
455                     config,
456                     test=True,
457                     match_on=match_on,
458                 )
459             else:
460                 out = __salt__["mount.set_fstab"](
461                     name,
462                     device,
463                     fstype,
464                     opts,
465                     dump,
466                     pass_num,
467                     config,
468                     test=True,
469                     match_on=match_on,
470                 )
471             if out != "present":
472                 ret["result"] = None
473                 if out == "new":
474                     if mount:
475                         comment = (
476                             "{} is mounted, but needs to be "
477                             "written to the fstab in order to be "
478                             "made persistent.".format(name)
479                         )
480                     else:
481                         comment = (
482                             "{} needs to be "
483                             "written to the fstab in order to be "
484                             "made persistent.".format(name)
485                         )
486                 elif out == "change":
487                     if mount:
488                         comment = "{} is mounted, but its fstab entry must be updated.".format(
489                             name
490                         )
491                     else:
492                         comment = "The {} fstab entry must be updated.".format(name)
493                 else:
494                     ret["result"] = False
495                     comment = (
496                         "Unable to detect fstab status for "
497                         "mount point {} due to unexpected "
498                         "output '{}' from call to "
499                         "mount.set_fstab. This is most likely "
500                         "a bug.".format(name, out)
501                     )
502                 if "comment" in ret:
503                     ret["comment"] = "{}. {}".format(ret["comment"], comment)
504                 else:
505                     ret["comment"] = comment
506                 return ret
507         else:
508             if __grains__["os"] in ["MacOS", "Darwin"]:
509                 out = __salt__["mount.set_automaster"](
510                     name, device, fstype, opts, config
511                 )
512             elif __grains__["os"] in ["AIX"]:
513                 out = __salt__["mount.set_filesystems"](
514                     name, device, fstype, opts, mount, config, match_on=match_on
515                 )
516             else:
517                 out = __salt__["mount.set_fstab"](
518                     name,
519                     device,
520                     fstype,
521                     opts,
522                     dump,
523                     pass_num,
524                     config,
525                     match_on=match_on,
526                 )
527         if update_mount_cache:
528             cache_result = __salt__["mount.write_mount_cache"](
529                 real_name, device, mkmnt=mkmnt, fstype=fstype, mount_opts=opts
530             )
531         if out == "present":
532             ret["comment"] += ". Entry already exists in the fstab."
533             return ret
534         if out == "new":
535             ret["changes"]["persist"] = "new"
536             ret["comment"] += ". Added new entry to the fstab."
537             return ret
538         if out == "change":
539             ret["changes"]["persist"] = "update"
540             ret["comment"] += ". Updated the entry in the fstab."
541             return ret
542         if out == "bad config":
543             ret["result"] = False
544             ret["comment"] += ". However, the fstab was not found."
545             return ret
546     return ret
547 def swap(name, persist=True, config="/etc/fstab"):
548     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
549     on_ = __salt__["mount.swaps"]()
550     if __salt__["file.is_link"](name):
551         real_swap_device = __salt__["file.readlink"](name)
552         if not real_swap_device.startswith("/"):
553             real_swap_device = "/dev/{}".format(os.path.basename(real_swap_device))
554     else:
555         real_swap_device = name
556     if real_swap_device in on_:
557         ret["comment"] = "Swap {} already active".format(name)
558     elif __opts__["test"]:
559         ret["result"] = None
560         ret["comment"] = "Swap {} is set to be activated".format(name)
561     else:
562         __salt__["mount.swapon"](real_swap_device)
563         on_ = __salt__["mount.swaps"]()
564         if real_swap_device in on_:
565             ret["comment"] = "Swap {} activated".format(name)
566             ret["changes"] = on_[real_swap_device]
567         else:
568             ret["comment"] = "Swap {} failed to activate".format(name)
569             ret["result"] = False
570     if persist:
571         device_key_name = "device"
572         if "AIX" in __grains__["os"]:
573             device_key_name = "dev"
574             if "/etc/fstab" == config:
575                 config = "/etc/filesystems"
576             fstab_data = __salt__["mount.filesystems"](config)
577         else:
578             fstab_data = __salt__["mount.fstab"](config)
579         if __opts__["test"]:
580             if name not in fstab_data and name not in [
581                 fstab_data[item]["device"] for item in fstab_data
582             ]:
583                 ret["result"] = None
584                 if name in on_:
585                     ret[
586                         "comment"
587                     ] = "Swap {} is set to be added to the fstab and to be activated".format(
588                         name
589                     )
590             return ret
591         if "none" in fstab_data:
592             if (
593                 fstab_data["none"][device_key_name] == name
594                 and fstab_data["none"]["fstype"] != "swap"
595             ):
596                 return ret
597         if "AIX" in __grains__["os"]:
598             out = None
599             ret["result"] = False
600             ret["comment"] += ". swap not present in /etc/filesystems on AIX."
601             return ret
602         else:
603             out = __salt__["mount.set_fstab"](
604                 "none", name, "swap", ["defaults"], 0, 0, config
605             )
606         if out == "present":
607             return ret
608         if out == "new":
609             ret["changes"]["persist"] = "new"
610             ret["comment"] += ". Added new entry to the fstab."
611             return ret
612         if out == "change":
613             ret["changes"]["persist"] = "update"
614             ret["comment"] += ". Updated the entry in the fstab."
615             return ret
616         if out == "bad config":
617             ret["result"] = False
618             ret["comment"] += ". However, the fstab was not found."
619             return ret
620     return ret
621 def unmounted(
622     name, device=None, config="/etc/fstab", persist=False, user=None, **kwargs
623 ):
624     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
625     update_mount_cache = False
626     if not name:
627         ret["result"] = False
628         ret["comment"] = "Must provide name to mount.unmounted"
629         return ret
630     active = __salt__["mount.active"](extended=True)
631     if name not in active:
632         ret["comment"] = "Target was already unmounted"
633     if name in active:
634         if __opts__["test"]:
635             ret["result"] = None
636             ret["comment"] = "Mount point {} is mounted but should not be".format(name)
637             return ret
638         if device:
639             out = __salt__["mount.umount"](name, device, user=user)
640             update_mount_cache = True
641         else:
642             out = __salt__["mount.umount"](name, user=user)
643             update_mount_cache = True
644         if isinstance(out, str):
645             ret["comment"] = out
646             ret["result"] = False
647         elif out is True:
648             ret["comment"] = "Target was successfully unmounted"
649             ret["changes"]["umount"] = True
650         else:
651             ret["comment"] = "Execute set to False, Target was not unmounted"
652             ret["result"] = True
653     if update_mount_cache:
654         cache_result = __salt__["mount.delete_mount_cache"](name)
655     if persist:
656         device_key_name = "device"
657         if __grains__["os"] in ["MacOS", "Darwin"] and config == "/etc/fstab":
658             config = "/etc/auto_salt"
659             fstab_data = __salt__["mount.automaster"](config)
660         elif "AIX" in __grains__["os"]:
661             device_key_name = "dev"
662             if config == "/etc/fstab":
663                 config = "/etc/filesystems"
664             fstab_data = __salt__["mount.filesystems"](config)
665         else:
666             fstab_data = __salt__["mount.fstab"](config)
667         if name not in fstab_data:
668             ret["comment"] += ". fstab entry not found"
669         else:
670             if device:
671                 if fstab_data[name][device_key_name] != device:
672                     ret["comment"] += ". fstab entry for device {} not found".format(
673                         device
674                     )
675                     return ret
676             if __opts__["test"]:
677                 ret["result"] = None
678                 ret["comment"] = (
679                     "Mount point {} is unmounted but needs to "
680                     "be purged from {} to be made "
681                     "persistent".format(name, config)
682                 )
683                 return ret
684             else:
685                 if __grains__["os"] in ["MacOS", "Darwin"]:
686                     out = __salt__["mount.rm_automaster"](name, device, config)
687                 elif "AIX" in __grains__["os"]:
688                     out = __salt__["mount.rm_filesystems"](name, device, config)
689                 else:
690                     out = __salt__["mount.rm_fstab"](name, device, config)
691                 if out is not True:
692                     ret["result"] = False
693                     ret["comment"] += ". Failed to persist purge"
694                 else:
695                     ret["comment"] += ". Removed target from fstab"
696                     ret["changes"]["persist"] = "purged"
697     return ret
698 def mod_watch(name, user=None, **kwargs):
699     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
700     if kwargs["sfun"] == "mounted":
701         out = __salt__["mount.remount"](
702             name, kwargs["device"], False, kwargs["fstype"], kwargs["opts"], user=user
703         )
704         if out:
705             ret["comment"] = "{} remounted".format(name)
706         else:
707             ret["result"] = False
708             ret["comment"] = "{} failed to remount: {}".format(name, out)
709     else:
710         ret["comment"] = "Watch not supported in {} at this time".format(kwargs["sfun"])
711     return ret
712 def _convert_to(maybe_device, convert_to):
713     if (
714         not convert_to
715         or (convert_to == "device" and maybe_device.startswith("/"))
716         or maybe_device.startswith("{}=".format(convert_to.upper()))
717     ):
718         return maybe_device
719     if maybe_device.startswith("/"):
720         blkid = __salt__["disk.blkid"](maybe_device)
721     else:
722         blkid = __salt__["disk.blkid"](token=maybe_device)
723     result = None
724     if len(blkid) == 1:
725         if convert_to == "device":
726             result = next(iter(blkid))
727         else:
728 <a name="1"></a>            key = convert_to.upper()
729             result = "{}={}".format(key, next(iter(blkid.values()))[key])
730     r<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn result
731 def fstab_present(
732     name,
733     fs_file,
734     fs_vfstype,
735     fs_mntops="defaults",
736     fs_freq=0,
737     fs_passno=0,
738     mount_by=None,
739     config="/etc/fstab",
740     mount=True,
741     match_on="auto",
742     not_change=False,
743     fs_mount=True,
744 ):
745     ret =</b></font> {
746         "name": name,
747         "result": False,
748         "changes": {},
749         "comment": [],
750     }
751     if fs_mntops == "defaults":
752         if __grains__["os"] in ["MacOS", "Darwin"]:
753             fs_mntops = "noowners"
754         elif __grains__["os"] == "AIX":
755             fs_mntops = ""
756     if config == "/etc/fstab":
757         if __grains__["os"] in ["MacOS", "Darwin"]:
758             config = "/etc/auto_salt"
759         elif __grains__["os"] == "AIX":
760             config = "/etc/filesystems"
761     if not fs_file == "/":
762         fs_file = fs_file.rstrip("/")
763     fs_spec = _convert_to(name, mount_by)
764     if not fs_spec:
765         msg = "Device {} cannot be converted to {}"
766         ret["comment"].append(msg.format(name, mount_by))
767         return ret
768     if __opts__["test"]:
769         if __grains__["os"] in ["MacOS", "Darwin"]:
770             out = __salt__["mount.set_automaster"](
771                 name=fs_file,
772                 device=fs_spec,
773                 fstype=fs_vfstype,
774                 opts=fs_mntops,
775                 config=config,
776                 test=True,
777                 not_change=not_change,
778             )
779         elif __grains__["os"] == "AIX":
780             out = __salt__["mount.set_filesystems"](
781                 name=fs_file,
782                 device=fs_spec,
783                 fstype=fs_vfstype,
784                 opts=fs_mntops,
785                 mount=fs_mount,
786                 config=config,
787                 test=True,
788                 match_on=match_on,
789                 not_change=not_change,
790             )
791         else:
792             out = __salt__["mount.set_fstab"](
793                 name=fs_file,
794                 device=fs_spec,
795                 fstype=fs_vfstype,
796                 opts=fs_mntops,
797                 dump=fs_freq,
798                 pass_num=fs_passno,
799                 config=config,
800                 test=True,
801                 match_on=match_on,
802                 not_change=not_change,
803             )
804         ret["result"] = None
805         if out == "present":
806             msg = "{} entry is already in {}."
807             ret["comment"].append(msg.format(fs_file, config))
808         elif out == "new":
809             msg = "{} entry will be written in {}."
810             ret["comment"].append(msg.format(fs_file, config))
811             if mount:
812                 msg = "Will mount {} on {}".format(name, fs_file)
813                 ret["comment"].append(msg)
814         elif out == "change":
815             msg = "{} entry will be updated in {}."
816             ret["comment"].append(msg.format(fs_file, config))
817         else:
818             ret["result"] = False
819             msg = "{} entry cannot be created in {}: {}."
820             ret["comment"].append(msg.format(fs_file, config, out))
821         return ret
822     if __grains__["os"] in ["MacOS", "Darwin"]:
823         out = __salt__["mount.set_automaster"](
824             name=fs_file,
825             device=fs_spec,
826             fstype=fs_vfstype,
827             opts=fs_mntops,
828             config=config,
829             not_change=not_change,
830         )
831     elif __grains__["os"] == "AIX":
832         out = __salt__["mount.set_filesystems"](
833             name=fs_file,
834             device=fs_spec,
835             fstype=fs_vfstype,
836             opts=fs_mntops,
837             mount=fs_mount,
838             config=config,
839             match_on=match_on,
840             not_change=not_change,
841         )
842     else:
843         out = __salt__["mount.set_fstab"](
844             name=fs_file,
845             device=fs_spec,
846             fstype=fs_vfstype,
847             opts=fs_mntops,
848             dump=fs_freq,
849             pass_num=fs_passno,
850             config=config,
851             match_on=match_on,
852             not_change=not_change,
853         )
854     ret["result"] = True
855     if out == "present":
856         msg = "{} entry was already in {}."
857         ret["comment"].append(msg.format(fs_file, config))
858     elif out == "new":
859         ret["changes"]["persist"] = out
860         msg = "{} entry added in {}."
861         ret["comment"].append(msg.format(fs_file, config))
862         if mount:
863             out = __salt__["mount.mount"](fs_file)
864             if type(out) == str:
865                 ret["result"] = False
866                 msg = "Error while mounting {}".format(out.split(":", maxsplit=1)[1])
867             else:
868                 msg = "Mounted {} on {}".format(name, fs_file)
869             ret["comment"].append(msg)
870     elif out == "change":
871         ret["changes"]["persist"] = out
872         msg = "{} entry updated in {}."
873         ret["comment"].append(msg.format(fs_file, config))
874     else:
875         ret["result"] = False
876         msg = "{} entry cannot be changed in {}: {}."
877         ret["comment"].append(msg.format(fs_file, config, out))
878     return ret
879 def fstab_absent(name, fs_file, mount_by=None, config="/etc/fstab"):
880     ret = {
881         "name": name,
882         "result": False,
883         "changes": {},
884         "comment": [],
885     }
886     if config == "/etc/fstab":
887         if __grains__["os"] in ["MacOS", "Darwin"]:
888             config = "/etc/auto_salt"
889         elif __grains__["os"] == "AIX":
890             config = "/etc/filesystems"
891     if not fs_file == "/":
892         fs_file = fs_file.rstrip("/")
893     fs_spec = _convert_to(name, mount_by)
894     if __grains__["os"] in ["MacOS", "Darwin"]:
895         fstab_data = __salt__["mount.automaster"](config)
896     elif __grains__["os"] == "AIX":
897         fstab_data = __salt__["mount.filesystems"](config)
898     else:
899         fstab_data = __salt__["mount.fstab"](config)
900     if __opts__["test"]:
901         ret["result"] = None
902         if fs_file not in fstab_data:
903             msg = "{} entry is already missing in {}."
904             ret["comment"].append(msg.format(fs_file, config))
905         else:
906             msg = "{} entry will be removed from {}."
907             ret["comment"].append(msg.format(fs_file, config))
908         return ret
909     if fs_file in fstab_data:
910         if __grains__["os"] in ["MacOS", "Darwin"]:
911             out = __salt__["mount.rm_automaster"](
912                 name=fs_file, device=fs_spec, config=config
913             )
914         elif __grains__["os"] == "AIX":
915             out = __salt__["mount.rm_filesystems"](
916                 name=fs_file, device=fs_spec, config=config
917             )
918         else:
919             out = __salt__["mount.rm_fstab"](
920                 name=fs_file, device=fs_spec, config=config
921             )
922         if out is not True:
923             ret["result"] = False
924             msg = "{} entry failed when removing from {}."
925             ret["comment"].append(msg.format(fs_file, config))
926         else:
927             ret["result"] = True
928             ret["changes"]["persist"] = "removed"
929             msg = "{} entry removed from {}."
930             ret["comment"].append(msg.format(fs_file, config))
931     else:
932         ret["result"] = True
933         msg = "{} entry is already missing in {}."
934         ret["comment"].append(msg.format(fs_file, config))
935     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
