<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for capirca_acl.py &amp; mount_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for capirca_acl.py &amp; mount_2.py
      </h3>
<h1 align="center">
        2.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>capirca_acl.py (3.2886724%)<th>mount_2.py (1.7464424%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(612-873)<td><a href="#" name="0">(51-70)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(899-915)<td><a href="#" name="1">(1070-1144)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>capirca_acl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import datetime
import inspect
import logging
import re
import salt.utils.files
log = logging.getLogger(__file__)
try:
    import capirca
    import capirca.aclgen
    import capirca.lib.policy
    import capirca.lib.aclgenerator
    HAS_CAPIRCA = True
except ImportError:
    HAS_CAPIRCA = False
__virtualname__ = "capirca"
__proxyenabled__ = ["*"]
def __virtual__():
    if HAS_CAPIRCA:
        return __virtualname__
    else:
        return (False, "The capirca module (capirca_acl) cannot be loaded.")
_TERM_FIELDS = {
    "action": [],
    "address": [],
    "address_exclude": [],
    "comment": [],
    "counter": None,
    "expiration": None,
    "destination_address": [],
    "destination_address_exclude": [],
    "destination_port": [],
    "destination_prefix": [],
    "forwarding_class": [],
    "forwarding_class_except": [],
    "logging": [],
    "log_name": None,
    "loss_priority": None,
    "option": [],
    "owner": None,
    "policer": None,
    "port": [],
    "precedence": [],
    "principals": [],
    "protocol": [],
    "protocol_except": [],
    "qos": None,
    "pan_application": [],
    "routing_instance": None,
    "source_address": [],
    "source_address_exclude": [],
    "source_port": [],
    "source_prefix": [],
    "verbatim": [],
    "packet_length": None,
    "fragment_offset": None,
    "hop_limit": None,
    "icmp_type": [],
    "icmp_code": None,
    "ether_type": [],
    "traffic_class_count": None,
    "traffic_type": [],
    "translated": False,
    "dscp_set": None,
    "dscp_match": [],
    "dscp_except": [],
    "next_ip": None,
    "flexible_match_range": [],
    "source_prefix_except": [],
    "destination_prefix_except": [],
    "vpn": None,
    "source_tag": [],
    "destination_tag": [],
    "source_interface": None,
    "destination_interface": None,
    "platform": [],
    "platform_exclude": [],
    "timeout": None,
    "flattened": False,
    "flattened_addr": None,
    "flattened_saddr": None,
    "flattened_daddr": None,
    "priority": None,
    "ttl": None,
}
_IP_FILEDS = [
    "source_address",
    "source_address_exclude",
    "destination_address",
    "address",
    "address_exclude",
    "flattened_addr",
    "flattened_saddr",
    "flattened_daddr",
    "next_ip",
]
_SERVICES = {}
if HAS_CAPIRCA:
    _TempTerm = capirca.lib.policy.Term
    def _add_object(self, obj):
        return
    setattr(_TempTerm, "AddObject", _add_object)
    dumy_term = _TempTerm(None)
    for item in dir(dumy_term):
        if hasattr(item, "__func__") or item.startswith("_") or item != item.lower():
            continue
        _TERM_FIELDS[item] = getattr(dumy_term, item)
    class _Policy(capirca.lib.policy.Policy):
        def __init__(self):
            self.filters = []
            self.filename = ""
    class _Term(capirca.lib.policy.Term):
        def __init__(self):
            for field, default in _TERM_FIELDS.items():
                setattr(self, field, default)
def _import_platform_generator(platform):
    log.debug("Using platform: %s", platform)
    for mod_name, mod_obj in inspect.getmembers(capirca.aclgen):
        if mod_name == platform and inspect.ismodule(mod_obj):
            for plat_obj_name, plat_obj in inspect.getmembers(
                mod_obj
            ):  # pylint: disable=unused-variable
                if inspect.isclass(plat_obj) and issubclass(
                    plat_obj, capirca.lib.aclgenerator.ACLGenerator
                ):
                    log.debug("Identified Capirca class %s for %s", plat_obj, platform)
                    return plat_obj
    log.error("Unable to identify any Capirca plaform class for %s", platform)
def _get_services_mapping():
    if _SERVICES:
        return _SERVICES
    services_txt = ""
    try:
        with salt.utils.files.fopen("/etc/services", "r") as srv_f:
            services_txt = salt.utils.stringutils.to_unicode(srv_f.read())
    except OSError as ioe:
        log.error("Unable to read from /etc/services:")
        log.error(ioe)
        return _SERVICES  # no mapping possible, sorry
    service_rgx = re.compile(r"^([a-zA-Z0-9-]+)\s+(\d+)\/(tcp|udp)(.*)$")
    for line in services_txt.splitlines():
        service_rgx_s = service_rgx.search(line)
        if service_rgx_s and len(service_rgx_s.groups()) == 4:
            srv_name, port, protocol, _ = service_rgx_s.groups()
            if srv_name not in _SERVICES:
                _SERVICES[srv_name] = {"port": [], "protocol": []}
            try:
                _SERVICES[srv_name]["port"].append(int(port))
            except ValueError as verr:
                log.error(verr)
                log.error("Did not read that properly:")
                log.error(line)
                log.error(
                    "Please report the above error: %s does not seem a valid port"
                    " value!",
                    port,
                )
            _SERVICES[srv_name]["protocol"].append(protocol)
    return _SERVICES
def _translate_port(port):
    services = _get_services_mapping()
    if port in services and services[port]["port"]:
        return services[port]["port"][0]
    return port
def _make_it_list(dict_, field_name, value):
    prev_value = []
    if field_name in dict_:
        prev_value = dict_[field_name]
    if value is None:
        return prev_value
    elif isinstance(value, (tuple, list)):
        if field_name in ("source_port", "destination_port"):
            portval = []
            for port in value:
                if not isinstance(port, (tuple, list)):
                    portval.append((port, port))
                else:
                    portval.append(port)
            translated_portval = []
            for port_start, port_end in portval:
                if not isinstance(port_start, int):
                    port_start = _translate_port(port_start)
                if not isinstance(port_end, int):
                    port_end = _translate_port(port_end)
                translated_portval.append((port_start, port_end))
            return list(set(prev_value + translated_portval))
        return list(set(prev_value + list(value)))
    if field_name in ("source_port", "destination_port"):
        if not isinstance(value, int):
            value = _translate_port(value)
        return list(set(prev_value + [(value, value)]))  # a list of tuples
    return list(set(prev_value + [value]))
def _clean_term_opts(term_opts):
    clean_opts = {}
    _services = _get_services_mapping()
    for field, value in term_opts.items():
        if field == "source_service" and value:
            if isinstance(value, str):
                value = _make_it_list(clean_opts, field, value)
            log.debug("Processing special source services:")
            log.debug(value)
            for service in value:
                if service and service in _services:
                    clean_opts["source_port"] = _make_it_list(
                        clean_opts, "source_port", _services[service]["port"]
                    )
                    clean_opts["protocol"] = _make_it_list(
                        clean_opts, "protocol", _services[service]["protocol"]
                    )
            log.debug(
                "Built source_port field, after processing special source services:"
            )
            log.debug(clean_opts.get("source_port"))
            log.debug("Built protocol field, after processing special source services:")
            log.debug(clean_opts.get("protocol"))
        elif field == "destination_service" and value:
            if isinstance(value, str):
                value = _make_it_list(clean_opts, field, value)
            log.debug("Processing special destination services:")
            log.debug(value)
            for service in value:
                if service and service in _services:
                    clean_opts["destination_port"] = _make_it_list(
                        clean_opts, "destination_port", _services[service]["port"]
                    )
                    clean_opts["protocol"] = _make_it_list(
                        clean_opts, "protocol", _services[service]["protocol"]
                    )
            log.debug(
                "Built source_port field, after processing special destination"
                " services:"
            )
            log.debug(clean_opts.get("destination_service"))
            log.debug(
                "Built protocol field, after processing special destination services:"
            )
            log.debug(clean_opts.get("protocol"))
        elif field in _TERM_FIELDS and value and value != _TERM_FIELDS[field]:
            if isinstance(_TERM_FIELDS[field], list):
                value = _make_it_list(clean_opts, field, value)
            if field in _IP_FILEDS:
                ip_values = []
                for addr in value:
                    ip_values.append(capirca.lib.policy.nacaddr.IP(addr))
                value = ip_values[:]
            clean_opts[field] = value
    return clean_opts
def _lookup_element(lst, key):
    if not lst:
        return {}
    for ele in lst:
        if not ele or not isinstance(ele, dict):
            continue
        if key in ele:
            return ele[key]
    return {}
def _get_pillar_cfg(pillar_key, pillarenv=None, saltenv=None):
    pillar_cfg = __salt__["pillar.get"](
        pillar_key, pillarenv=pillarenv, saltenv=saltenv
    )
    return pillar_cfg
def _cleanup(lst):
    clean = []
    for ele in lst:
        if ele and isinstance(ele, dict):
            clean.append(ele)
    return clean
def _merge_list_of_dict(first, second, prepend=True):
    first = _cleanup(first)
    second = _cleanup(second)
    if not first and not second:
        return []
    if not first and second:
        return second
    if first and not second:
        return first
    overlaps = []
    merged = []
    appended = []
    for ele in first:
        if _lookup_element(second, next(iter(ele))):
            overlaps.append(ele)
        elif prepend:
            merged.append(ele)
        elif not prepend:
            appended.append(ele)
    for ele in second:
        ele_key = next(iter(ele))
        if _lookup_element(overlaps, ele_key):
            ele_val_first = _lookup_element(first, ele_key)
            merged.append({ele_key: ele_val_first})
        else:
            merged.append(ele)
    if not prepend:
        merged.extend(appended)
    return merged
def _get_term_object(
    filter_name,
    term_name,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    **term_fields
):
    log.debug("Generating config for term %s under filter %s", term_name, filter_name)
    term = _Term()
    term.name = term_name
    term_opts = {}
    if merge_pillar:
        term_opts = get_term_pillar(
            filter_name,
            term_name,
            pillar_key=pillar_key,
            saltenv=saltenv,
            pillarenv=pillarenv,
        )
        log.debug("Merging with pillar data:")
        log.debug(term_opts)
        term_opts = _clean_term_opts(term_opts)
        log.debug("Cleaning up pillar data:")
        log.debug(term_opts)
    log.debug("Received processing opts:")
    log.debug(term_fields)
    log.debug("Cleaning up processing opts:")
    term_fields = _clean_term_opts(term_fields)
    log.debug(term_fields)
    log.debug("Final term opts:")
    term_opts.update(term_fields)
    log.debug(term_fields)
    for field, value in term_opts.items():
        setattr(term, field, value)
    log.debug("Term config:")
    log.debug(str(term))
    return term
def _get_policy_object(
    platform,
    filters=None,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
):
    policy = _Policy()
    policy_filters = []
    if not filters:
        filters = []
    for filter_ in filters:
        if not filter_ or not isinstance(filter_, dict):
            continue  # go to the next filter
        filter_name, filter_config = next(iter(filter_.items()))
        header = capirca.lib.policy.Header()  # same header everywhere
        target_opts = [platform, filter_name]
        filter_options = filter_config.pop("options", None)
        if filter_options:
            filter_options = _make_it_list({}, filter_name, filter_options)
            target_opts.extend(filter_options)
        target = capirca.lib.policy.Target(target_opts)
        header.AddObject(target)
        filter_terms = []
        for term_ in filter_config.get("terms", []):
            if term_ and isinstance(term_, dict):
                term_name, term_fields = next(iter(term_.items()))
                term = _get_term_object(
                    filter_name,
                    term_name,
                    pillar_key=pillar_key,
                    pillarenv=pillarenv,
                    saltenv=saltenv,
                    merge_pillar=merge_pillar,
                    **term_fields
                )
            filter_terms.append(term)
        policy_filters.append((header, filter_terms))
    policy.filters = policy_filters
    log.debug("Policy config:")
    log.debug(str(policy))
    platform_generator = _import_platform_generator(platform)
    policy_config = platform_generator(policy, 2)
    log.debug("Generating policy config for %s:", platform)
    log.debug(str(policy_config))
    return policy_config
def _revision_tag(
    text,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
):
    timestamp = datetime.datetime.now().strftime(revision_date_format)
    new_text = []
    for line in text.splitlines():
        if "$Id:$" in line:
            if not revision_id:  # if no explicit revision ID required
                continue  # jump to next line, ignore this one
            line = line.replace("$Id:$", "$Id: {rev_id} $".format(rev_id=revision_id))
        if "$Revision:$" in line:
            if not revision_no:  # if no explicit revision number required
                continue  # jump to next line, ignore this one
            line = line.replace(
                "$Revision:$", "$Revision: {rev_no} $".format(rev_no=revision_no)
            )
        if "$Date:$" in line:
            if not revision_date:
            line = line.replace("$Date:$", "$Date: {ts} $".format(ts=timestamp))
        new_text.append(line)
    return "\n".join(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new_text)
def get_term_config(
    platform,
    filter_name,
    term_name,
    filter_options=None,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
    source_service=None,
    destination_service=None,
    **term_fields
):
    terms = []
    term =</b></font> {term_name: {}}
    term[term_name].update(term_fields)
    term[term_name].update(
        {
            "source_service": _make_it_list({}, "source_service", source_service),
            "destination_service": _make_it_list(
                {}, "destination_service", destination_service
            ),
        }
    )
    terms.append(term)
    if not filter_options:
        filter_options = []
    return get_filter_config(
        platform,
        filter_name,
        filter_options=filter_options,
        terms=terms,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
        only_lower_merge=True,
<a name="1"></a>        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>revision_date_format,
    )
def get_filter_config(
    platform,
    filter_name,
    filter_options=None,
    terms=None,
    prepend=True,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    only_lower_merge=False,
    revision_id=None,
    revision_no=</b></font>None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
):
    if not filter_options:
        filter_options = []
    if not terms:
        terms = []
    if merge_pillar and not only_lower_merge:
        acl_pillar_cfg = _get_pillar_cfg(
            pillar_key, saltenv=saltenv, pillarenv=pillarenv
        )
        filter_pillar_cfg = _lookup_element(acl_pillar_cfg, filter_name)
        filter_options = filter_options or filter_pillar_cfg.pop("options", None)
        if filter_pillar_cfg:
            pillar_terms = filter_pillar_cfg.get(
                "terms", []
            )  # No problem if empty in the pillar
            terms = _merge_list_of_dict(terms, pillar_terms, prepend=prepend)
    filters = []
    filters.append(
        {
            filter_name: {
                "options": _make_it_list({}, filter_name, filter_options),
                "terms": terms,
            }
        }
    )
    return get_policy_config(
        platform,
        filters=filters,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
        only_lower_merge=True,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )
def get_policy_config(
    platform,
    filters=None,
    prepend=True,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    only_lower_merge=False,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
):
    if not filters:
        filters = []
    if merge_pillar and not only_lower_merge:
        policy_pillar_cfg = _get_pillar_cfg(
            pillar_key, saltenv=saltenv, pillarenv=pillarenv
        )
        filters = _merge_list_of_dict(filters, policy_pillar_cfg, prepend=prepend)
    policy_object = _get_policy_object(
        platform,
        filters=filters,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
    )
    policy_text = str(policy_object)
    return _revision_tag(
        policy_text,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )
def get_filter_pillar(filter_name, pillar_key="acl", pillarenv=None, saltenv=None):
    pillar_cfg = _get_pillar_cfg(pillar_key, pillarenv=pillarenv, saltenv=saltenv)
    return _lookup_element(pillar_cfg, filter_name)
def get_term_pillar(
    filter_name, term_name, pillar_key="acl", pillarenv=None, saltenv=None
):
    filter_pillar_cfg = get_filter_pillar(
        filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv
    )
    term_pillar_cfg = filter_pillar_cfg.get("terms", [])
    term_opts = _lookup_element(term_pillar_cfg, term_name)
    return term_opts
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mount_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import os.path
import re
log = logging.getLogger(__name__)
def _size_convert(_re_size):
    converted_size = int(_re_size.group("size_value"))
    if _re_size.group("size_unit") == "m":
<a name="0"></a>        converted_size = int(converted_size) * 1024
    if _re_size.group("size_unit") == "g":
        converted_size = int(converted_size) * 1024 * 1024
    r<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn converted_size
def mounted(
    name,
    device,
    fstype,
    mkmnt=False,
    opts="defaults",
    dump=0,
    pass_num=0,
    config="/etc/fstab",
    persist=True,
    mount=True,
    user=None,
    match_on="auto",
    device_name_regex=None,
    extra_mount_invisible_options=None,
    extra_mount_invisible_keys=None,
    extra_mount_ignore_fs_keys=</b></font>None,
    extra_mount_translate_options=None,
    hidden_opts=None,
    **kwargs
):
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    update_mount_cache = False
    if not name:
        ret["result"] = False
        ret["comment"] = "Must provide name to mount.mounted"
        return ret
    if not device:
        ret["result"] = False
        ret["comment"] = "Must provide device to mount.mounted"
        return ret
    if not fstype:
        ret["result"] = False
        ret["comment"] = "Must provide fstype to mount.mounted"
        return ret
    if device_name_regex is None:
        device_name_regex = []
    if __grains__["os"] in ["MacOS", "Darwin"] and opts == "defaults":
        opts = "noowners"
    if __grains__["os"] in ["AIX"]:
        if opts == "defaults":
            opts = ""
    if isinstance(opts, str):
        opts = opts.split(",")
    if opts:
        opts.sort()
    if isinstance(hidden_opts, str):
        hidden_opts = hidden_opts.split(",")
    if not name == "/":
        name = name.rstrip("/")
    device_list = []
    active = __salt__["mount.active"](extended=True)
    real_name = os.path.realpath(name)
    if device.startswith("/"):
        if "bind" in opts and real_name in active:
            _device = device
            if active[real_name]["device"].startswith("/"):
                while True:
                    if _device in active:
                        _real_device = active[_device]["device"]
                        opts = list(
                            set(
                                opts
                                + active[_device]["opts"]
                                + active[_device]["superopts"]
                            )
                        )
                        active[real_name]["opts"].append("bind")
                        break
                    _device = os.path.dirname(_device)
                real_device = _real_device
            else:
                if _device in active:
                    opts = list(
                        set(
                            opts
                            + active[_device]["opts"]
                            + active[_device]["superopts"]
                        )
                    )
                    active[real_name]["opts"].append("bind")
                real_device = active[real_name]["device"]
        else:
            real_device = os.path.realpath(device)
    elif device.upper().startswith("UUID="):
        real_device = device.split("=")[1].strip('"').lower()
    elif device.upper().startswith("LABEL="):
        _label = device.split("=")[1]
        cmd = "blkid -t LABEL={}".format(_label)
        res = __salt__["cmd.run_all"]("{}".format(cmd))
        if res["retcode"] &gt; 0:
            ret["comment"] = "Unable to find device with label {}.".format(_label)
            ret["result"] = False
            return ret
        else:
            for line in res["stdout"]:
                dev_with_label = line.split(":")[0]
                device_list.append(dev_with_label)
            real_device = device_list[0]
    else:
        real_device = device
    lvs_match = re.match(r"^/dev/(?P&lt;vg_name&gt;[^/]+)/(?P&lt;lv_name&gt;[^/]+$)", device)
    if lvs_match:
        double_dash_escaped = {
            k: re.sub(r"-", "--", v) for k, v in lvs_match.groupdict().items()
        }
        mapper_device = "/dev/mapper/{vg_name}-{lv_name}".format(**double_dash_escaped)
        if os.path.exists(mapper_device):
            real_device = mapper_device
    fuse_match = re.match(r"^\w+\#(?P&lt;device_name&gt;.+)", device)
    if fuse_match:
        if "device_name" in fuse_match.groupdict():
            real_device = fuse_match.group("device_name")
    if real_name in active:
        if "superopts" not in active[real_name]:
            active[real_name]["superopts"] = []
        if mount:
            device_list.append(active[real_name]["device"])
            device_list.append(os.path.realpath(device_list[0]))
            alt_device = (
                active[real_name]["alt_device"]
                if "alt_device" in active[real_name]
                else None
            )
            uuid_device = (
                active[real_name]["device_uuid"]
                if "device_uuid" in active[real_name]
                else None
            )
            label_device = (
                active[real_name]["device_label"]
                if "device_label" in active[real_name]
                else None
            )
            if alt_device and alt_device not in device_list:
                device_list.append(alt_device)
            if uuid_device and uuid_device not in device_list:
                device_list.append(uuid_device)
            if label_device and label_device not in device_list:
                device_list.append(label_device)
            if opts:
                opts.sort()
                mount_invisible_options = [
                    "_netdev",
                    "actimeo",
                    "bg",
                    "comment",
                    "defaults",
                    "delay_connect",
                    "direct-io-mode",
                    "intr",
                    "loop",
                    "nointr",
                    "nobootwait",
                    "nofail",
                    "password",
                    "reconnect",
                    "retry",
                    "soft",
                    "auto",
                    "users",
                    "bind",
                    "nonempty",
                    "transform_symlinks",
                    "port",
                    "backup-volfile-servers",
                ]
                if extra_mount_invisible_options:
                    mount_invisible_options.extend(extra_mount_invisible_options)
                if hidden_opts:
                    mount_invisible_options = list(
                        set(mount_invisible_options) | set(hidden_opts)
                    )
                mount_invisible_keys = [
                    "actimeo",
                    "comment",
                    "credentials",
                    "direct-io-mode",
                    "password",
                    "port",
                    "retry",
                    "secretfile",
                ]
                if extra_mount_invisible_keys:
                    mount_invisible_keys.extend(extra_mount_invisible_keys)
                mount_ignore_fs_keys = {"ramfs": ["size"]}
                if extra_mount_ignore_fs_keys:
                    mount_ignore_fs_keys.update(extra_mount_ignore_fs_keys)
                mount_translate_options = {
                    "tcp": "proto=tcp",
                    "udp": "proto=udp",
                }
                if extra_mount_translate_options:
                    mount_translate_options.update(extra_mount_translate_options)
                for opt in opts:
                    if opt in mount_translate_options:
                        opt = mount_translate_options[opt]
                    keyval_option = opt.split("=")[0]
                    if keyval_option in mount_invisible_keys:
                        opt = keyval_option
                    size_match = re.match(
                        r"size=(?P&lt;size_value&gt;[0-9]+)(?P&lt;size_unit&gt;k|m|g)", opt
                    )
                    if size_match:
                        converted_size = _size_convert(size_match)
                        opt = "size={}k".format(converted_size)
                    if fstype in ["cifs"] and opt.split("=")[0] == "user":
                        opt = "username={}".format(opt.split("=")[1])
                    if opt.split("=")[0] in mount_ignore_fs_keys.get(fstype, []):
                        opt = opt.split("=")[0]
                    name_id_opts = {"uid": "user.info", "gid": "group.info"}
                    if opt.split("=")[0] in name_id_opts and len(opt.split("=")) &gt; 1:
                        _givenid = opt.split("=")[1]
                        _param = opt.split("=")[0]
                        _id = _givenid
                        if not re.match("[0-9]+$", _givenid):
                            _info = __salt__[name_id_opts[_param]](_givenid)
                            if _info and _param in _info:
                                _id = _info[_param]
                        opt = _param + "=" + str(_id)
                    _active_superopts = active[real_name].get("superopts", [])
                    for _active_opt in _active_superopts:
                        size_match = re.match(
                            r"size=(?P&lt;size_value&gt;[0-9]+)(?P&lt;size_unit&gt;k|m|g)",
                            _active_opt,
                        )
                        if size_match:
                            converted_size = _size_convert(size_match)
                            opt = "size={}k".format(converted_size)
                            _active_superopts.remove(_active_opt)
                            _active_opt = "size={}k".format(converted_size)
                            _active_superopts.append(_active_opt)
                    if (
                        opt not in active[real_name]["opts"]
                        and opt not in _active_superopts
                        and opt not in mount_invisible_options
                        and opt not in mount_ignore_fs_keys.get(fstype, [])
                        and opt not in mount_invisible_keys
                    ):
                        if __opts__["test"]:
                            ret["result"] = None
                            ret[
                                "comment"
                            ] = "Remount would be forced because options ({}) changed".format(
                                opt
                            )
                            return ret
                        else:
                            if fstype in ["nfs", "cvfs"] or fstype.startswith("fuse"):
                                ret["changes"]["umount"] = (
                                    "Forced unmount and mount because "
                                    + "options ({}) changed".format(opt)
                                )
                                unmount_result = __salt__["mount.umount"](real_name)
                                if unmount_result is True:
                                    mount_result = __salt__["mount.mount"](
                                        real_name,
                                        device,
                                        mkmnt=mkmnt,
                                        fstype=fstype,
                                        opts=opts,
                                    )
                                    ret["result"] = mount_result
                                else:
                                    ret["result"] = False
                                    ret["comment"] = "Unable to unmount {}: {}.".format(
                                        real_name, unmount_result
                                    )
                                    return ret
                            else:
                                ret["changes"]["umount"] = (
                                    "Forced remount because "
                                    + "options ({}) changed".format(opt)
                                )
                                remount_result = __salt__["mount.remount"](
                                    real_name,
                                    device,
                                    mkmnt=mkmnt,
                                    fstype=fstype,
                                    opts=opts,
                                )
                                ret["result"] = remount_result
                                if "remount" in opts:
                                    opts.remove("remount")
                            update_mount_cache = True
                mount_cache = __salt__["mount.read_mount_cache"](real_name)
                if "opts" in mount_cache:
                    _missing = [opt for opt in mount_cache["opts"] if opt not in opts]
                    if _missing:
                        if __opts__["test"]:
                            ret["result"] = None
                            ret["comment"] = (
                                "Remount would be forced because"
                                " options ({})"
                                "changed".format(",".join(_missing))
                            )
                            return ret
                        else:
                            if fstype in ["nfs", "cvfs"] or fstype.startswith("fuse"):
                                ret["changes"]["umount"] = (
                                    "Forced unmount and mount because "
                                    + "options ({}) changed".format(opt)
                                )
                                unmount_result = __salt__["mount.umount"](real_name)
                                if unmount_result is True:
                                    mount_result = __salt__["mount.mount"](
                                        real_name,
                                        device,
                                        mkmnt=mkmnt,
                                        fstype=fstype,
                                        opts=opts,
                                    )
                                    ret["result"] = mount_result
                                else:
                                    ret["result"] = False
                                    ret["comment"] = "Unable to unmount {}: {}.".format(
                                        real_name, unmount_result
                                    )
                                    return ret
                            else:
                                ret["changes"]["umount"] = (
                                    "Forced remount because "
                                    + "options ({}) changed".format(opt)
                                )
                                remount_result = __salt__["mount.remount"](
                                    real_name,
                                    device,
                                    mkmnt=mkmnt,
                                    fstype=fstype,
                                    opts=opts,
                                )
                                ret["result"] = remount_result
                                if "remount" in opts:
                                    opts.remove("remount")
                        update_mount_cache = True
                else:
                    update_mount_cache = True
            if real_device not in device_list:
                _device_mismatch_is_ignored = None
                for regex in list(device_name_regex):
                    for _device in device_list:
                        if re.match(regex, _device):
                            _device_mismatch_is_ignored = _device
                            break
                if _device_mismatch_is_ignored:
                    ret["result"] = True
                    ret["comment"] = (
                        "An umount will not be forced "
                        + "because device matched device_name_regex: "
                        + _device_mismatch_is_ignored
                    )
                elif __opts__["test"]:
                    ret["result"] = None
                    ret["comment"] = (
                        "An umount would have been forced "
                        + "because devices do not match.  Watched: "
                        + device
                    )
                else:
                    ret["changes"]["umount"] = (
                        "Forced unmount because devices "
                        + "don't match. Wanted: "
                        + device
                    )
                    if real_device != device:
                        ret["changes"]["umount"] += " (" + real_device + ")"
                    ret["changes"]["umount"] += ", current: " + ", ".join(device_list)
                    out = __salt__["mount.umount"](real_name, user=user)
                    active = __salt__["mount.active"](extended=True)
                    if real_name in active:
                        ret["comment"] = "Unable to unmount"
                        ret["result"] = None
                        return ret
                    update_mount_cache = True
            else:
                ret["comment"] = "Target was already mounted"
    if real_name not in active:
        if mount:
            if __opts__["test"]:
                ret["result"] = None
                if os.path.exists(name):
                    ret["comment"] = "{} would be mounted".format(name)
                elif mkmnt:
                    ret["comment"] = "{} would be created and mounted".format(name)
                else:
                    ret[
                        "comment"
                    ] = "{} does not exist and would not be created".format(name)
                return ret
            if not os.path.exists(name) and not mkmnt:
                ret["result"] = False
                ret["comment"] = "Mount directory is not present"
                return ret
            out = __salt__["mount.mount"](name, device, mkmnt, fstype, opts, user=user)
            active = __salt__["mount.active"](extended=True)
            update_mount_cache = True
            if isinstance(out, str):
                ret["comment"] = out
                ret["result"] = False
                return ret
            elif real_name in active:
                ret["comment"] = "Target was successfully mounted"
                ret["changes"]["mount"] = True
        elif not os.path.exists(name):
            if __opts__["test"]:
                ret["result"] = None
                if mkmnt:
                    ret["comment"] = "{} would be created, but not mounted".format(name)
                else:
                    ret[
                        "comment"
                    ] = "{} does not exist and would neither be created nor mounted".format(
                        name
                    )
            elif mkmnt:
                __salt__["file.mkdir"](name, user=user)
                ret["comment"] = "{} was created, not mounted".format(name)
            else:
                ret["comment"] = "{} not present and not mounted".format(name)
        else:
            if __opts__["test"]:
                ret["result"] = None
                ret["comment"] = "{} would not be mounted".format(name)
            else:
                ret["comment"] = "{} not mounted".format(name)
    if persist:
        if "/etc/fstab" == config:
            if __grains__["os"] in ["MacOS", "Darwin"]:
                config = "/etc/auto_salt"
            elif "AIX" in __grains__["os"]:
                config = "/etc/filesystems"
        if __opts__["test"]:
            if __grains__["os"] in ["MacOS", "Darwin"]:
                out = __salt__["mount.set_automaster"](
                    name, device, fstype, opts, config, test=True
                )
            elif __grains__["os"] in ["AIX"]:
                out = __salt__["mount.set_filesystems"](
                    name,
                    device,
                    fstype,
                    opts,
                    mount,
                    config,
                    test=True,
                    match_on=match_on,
                )
            else:
                out = __salt__["mount.set_fstab"](
                    name,
                    device,
                    fstype,
                    opts,
                    dump,
                    pass_num,
                    config,
                    test=True,
                    match_on=match_on,
                )
            if out != "present":
                ret["result"] = None
                if out == "new":
                    if mount:
                        comment = (
                            "{} is mounted, but needs to be "
                            "written to the fstab in order to be "
                            "made persistent.".format(name)
                        )
                    else:
                        comment = (
                            "{} needs to be "
                            "written to the fstab in order to be "
                            "made persistent.".format(name)
                        )
                elif out == "change":
                    if mount:
                        comment = "{} is mounted, but its fstab entry must be updated.".format(
                            name
                        )
                    else:
                        comment = "The {} fstab entry must be updated.".format(name)
                else:
                    ret["result"] = False
                    comment = (
                        "Unable to detect fstab status for "
                        "mount point {} due to unexpected "
                        "output '{}' from call to "
                        "mount.set_fstab. This is most likely "
                        "a bug.".format(name, out)
                    )
                if "comment" in ret:
                    ret["comment"] = "{}. {}".format(ret["comment"], comment)
                else:
                    ret["comment"] = comment
                return ret
        else:
            if __grains__["os"] in ["MacOS", "Darwin"]:
                out = __salt__["mount.set_automaster"](
                    name, device, fstype, opts, config
                )
            elif __grains__["os"] in ["AIX"]:
                out = __salt__["mount.set_filesystems"](
                    name, device, fstype, opts, mount, config, match_on=match_on
                )
            else:
                out = __salt__["mount.set_fstab"](
                    name,
                    device,
                    fstype,
                    opts,
                    dump,
                    pass_num,
                    config,
                    match_on=match_on,
                )
        if update_mount_cache:
            cache_result = __salt__["mount.write_mount_cache"](
                real_name, device, mkmnt=mkmnt, fstype=fstype, mount_opts=opts
            )
        if out == "present":
            ret["comment"] += ". Entry already exists in the fstab."
            return ret
        if out == "new":
            ret["changes"]["persist"] = "new"
            ret["comment"] += ". Added new entry to the fstab."
            return ret
        if out == "change":
            ret["changes"]["persist"] = "update"
            ret["comment"] += ". Updated the entry in the fstab."
            return ret
        if out == "bad config":
            ret["result"] = False
            ret["comment"] += ". However, the fstab was not found."
            return ret
    return ret
def swap(name, persist=True, config="/etc/fstab"):
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    on_ = __salt__["mount.swaps"]()
    if __salt__["file.is_link"](name):
        real_swap_device = __salt__["file.readlink"](name)
        if not real_swap_device.startswith("/"):
            real_swap_device = "/dev/{}".format(os.path.basename(real_swap_device))
    else:
        real_swap_device = name
    if real_swap_device in on_:
        ret["comment"] = "Swap {} already active".format(name)
    elif __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "Swap {} is set to be activated".format(name)
    else:
        __salt__["mount.swapon"](real_swap_device)
        on_ = __salt__["mount.swaps"]()
        if real_swap_device in on_:
            ret["comment"] = "Swap {} activated".format(name)
            ret["changes"] = on_[real_swap_device]
        else:
            ret["comment"] = "Swap {} failed to activate".format(name)
            ret["result"] = False
    if persist:
        device_key_name = "device"
        if "AIX" in __grains__["os"]:
            device_key_name = "dev"
            if "/etc/fstab" == config:
                config = "/etc/filesystems"
            fstab_data = __salt__["mount.filesystems"](config)
        else:
            fstab_data = __salt__["mount.fstab"](config)
        if __opts__["test"]:
            if name not in fstab_data and name not in [
                fstab_data[item]["device"] for item in fstab_data
            ]:
                ret["result"] = None
                if name in on_:
                    ret[
                        "comment"
                    ] = "Swap {} is set to be added to the fstab and to be activated".format(
                        name
                    )
            return ret
        if "none" in fstab_data:
            if (
                fstab_data["none"][device_key_name] == name
                and fstab_data["none"]["fstype"] != "swap"
            ):
                return ret
        if "AIX" in __grains__["os"]:
            out = None
            ret["result"] = False
            ret["comment"] += ". swap not present in /etc/filesystems on AIX."
            return ret
        else:
            out = __salt__["mount.set_fstab"](
                "none", name, "swap", ["defaults"], 0, 0, config
            )
        if out == "present":
            return ret
        if out == "new":
            ret["changes"]["persist"] = "new"
            ret["comment"] += ". Added new entry to the fstab."
            return ret
        if out == "change":
            ret["changes"]["persist"] = "update"
            ret["comment"] += ". Updated the entry in the fstab."
            return ret
        if out == "bad config":
            ret["result"] = False
            ret["comment"] += ". However, the fstab was not found."
            return ret
    return ret
def unmounted(
    name, device=None, config="/etc/fstab", persist=False, user=None, **kwargs
):
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    update_mount_cache = False
    if not name:
        ret["result"] = False
        ret["comment"] = "Must provide name to mount.unmounted"
        return ret
    active = __salt__["mount.active"](extended=True)
    if name not in active:
        ret["comment"] = "Target was already unmounted"
    if name in active:
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "Mount point {} is mounted but should not be".format(name)
            return ret
        if device:
            out = __salt__["mount.umount"](name, device, user=user)
            update_mount_cache = True
        else:
            out = __salt__["mount.umount"](name, user=user)
            update_mount_cache = True
        if isinstance(out, str):
            ret["comment"] = out
            ret["result"] = False
        elif out is True:
            ret["comment"] = "Target was successfully unmounted"
            ret["changes"]["umount"] = True
        else:
            ret["comment"] = "Execute set to False, Target was not unmounted"
            ret["result"] = True
    if update_mount_cache:
        cache_result = __salt__["mount.delete_mount_cache"](name)
    if persist:
        device_key_name = "device"
        if __grains__["os"] in ["MacOS", "Darwin"] and config == "/etc/fstab":
            config = "/etc/auto_salt"
            fstab_data = __salt__["mount.automaster"](config)
        elif "AIX" in __grains__["os"]:
            device_key_name = "dev"
            if config == "/etc/fstab":
                config = "/etc/filesystems"
            fstab_data = __salt__["mount.filesystems"](config)
        else:
            fstab_data = __salt__["mount.fstab"](config)
        if name not in fstab_data:
            ret["comment"] += ". fstab entry not found"
        else:
            if device:
                if fstab_data[name][device_key_name] != device:
                    ret["comment"] += ". fstab entry for device {} not found".format(
                        device
                    )
                    return ret
            if __opts__["test"]:
                ret["result"] = None
                ret["comment"] = (
                    "Mount point {} is unmounted but needs to "
                    "be purged from {} to be made "
                    "persistent".format(name, config)
                )
                return ret
            else:
                if __grains__["os"] in ["MacOS", "Darwin"]:
                    out = __salt__["mount.rm_automaster"](name, device, config)
                elif "AIX" in __grains__["os"]:
                    out = __salt__["mount.rm_filesystems"](name, device, config)
                else:
                    out = __salt__["mount.rm_fstab"](name, device, config)
                if out is not True:
                    ret["result"] = False
                    ret["comment"] += ". Failed to persist purge"
                else:
                    ret["comment"] += ". Removed target from fstab"
                    ret["changes"]["persist"] = "purged"
    return ret
def mod_watch(name, user=None, **kwargs):
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if kwargs["sfun"] == "mounted":
        out = __salt__["mount.remount"](
            name, kwargs["device"], False, kwargs["fstype"], kwargs["opts"], user=user
        )
        if out:
            ret["comment"] = "{} remounted".format(name)
        else:
            ret["result"] = False
            ret["comment"] = "{} failed to remount: {}".format(name, out)
    else:
        ret["comment"] = "Watch not supported in {} at this time".format(kwargs["sfun"])
    return ret
def _convert_to(maybe_device, convert_to):
    if (
        not convert_to
        or (convert_to == "device" and maybe_device.startswith("/"))
        or maybe_device.startswith("{}=".format(convert_to.upper()))
    ):
        return maybe_device
    if maybe_device.startswith("/"):
        blkid = __salt__["disk.blkid"](maybe_device)
    else:
        blkid = __salt__["disk.blkid"](token=maybe_device)
    result = None
    if len(blkid) == 1:
        if convert_to == "device":
            result = next(iter(blkid))
        else:
<a name="1"></a>            key = convert_to.upper()
            result = "{}={}".format(key, next(iter(blkid.values()))[key])
    r<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn result
def fstab_present(
    name,
    fs_file,
    fs_vfstype,
    fs_mntops="defaults",
    fs_freq=0,
    fs_passno=0,
    mount_by=None,
    config="/etc/fstab",
    mount=True,
    match_on="auto",
    not_change=False,
    fs_mount=True,
):
    ret =</b></font> {
        "name": name,
        "result": False,
        "changes": {},
        "comment": [],
    }
    if fs_mntops == "defaults":
        if __grains__["os"] in ["MacOS", "Darwin"]:
            fs_mntops = "noowners"
        elif __grains__["os"] == "AIX":
            fs_mntops = ""
    if config == "/etc/fstab":
        if __grains__["os"] in ["MacOS", "Darwin"]:
            config = "/etc/auto_salt"
        elif __grains__["os"] == "AIX":
            config = "/etc/filesystems"
    if not fs_file == "/":
        fs_file = fs_file.rstrip("/")
    fs_spec = _convert_to(name, mount_by)
    if not fs_spec:
        msg = "Device {} cannot be converted to {}"
        ret["comment"].append(msg.format(name, mount_by))
        return ret
    if __opts__["test"]:
        if __grains__["os"] in ["MacOS", "Darwin"]:
            out = __salt__["mount.set_automaster"](
                name=fs_file,
                device=fs_spec,
                fstype=fs_vfstype,
                opts=fs_mntops,
                config=config,
                test=True,
                not_change=not_change,
            )
        elif __grains__["os"] == "AIX":
            out = __salt__["mount.set_filesystems"](
                name=fs_file,
                device=fs_spec,
                fstype=fs_vfstype,
                opts=fs_mntops,
                mount=fs_mount,
                config=config,
                test=True,
                match_on=match_on,
                not_change=not_change,
            )
        else:
            out = __salt__["mount.set_fstab"](
                name=fs_file,
                device=fs_spec,
                fstype=fs_vfstype,
                opts=fs_mntops,
                dump=fs_freq,
                pass_num=fs_passno,
                config=config,
                test=True,
                match_on=match_on,
                not_change=not_change,
            )
        ret["result"] = None
        if out == "present":
            msg = "{} entry is already in {}."
            ret["comment"].append(msg.format(fs_file, config))
        elif out == "new":
            msg = "{} entry will be written in {}."
            ret["comment"].append(msg.format(fs_file, config))
            if mount:
                msg = "Will mount {} on {}".format(name, fs_file)
                ret["comment"].append(msg)
        elif out == "change":
            msg = "{} entry will be updated in {}."
            ret["comment"].append(msg.format(fs_file, config))
        else:
            ret["result"] = False
            msg = "{} entry cannot be created in {}: {}."
            ret["comment"].append(msg.format(fs_file, config, out))
        return ret
    if __grains__["os"] in ["MacOS", "Darwin"]:
        out = __salt__["mount.set_automaster"](
            name=fs_file,
            device=fs_spec,
            fstype=fs_vfstype,
            opts=fs_mntops,
            config=config,
            not_change=not_change,
        )
    elif __grains__["os"] == "AIX":
        out = __salt__["mount.set_filesystems"](
            name=fs_file,
            device=fs_spec,
            fstype=fs_vfstype,
            opts=fs_mntops,
            mount=fs_mount,
            config=config,
            match_on=match_on,
            not_change=not_change,
        )
    else:
        out = __salt__["mount.set_fstab"](
            name=fs_file,
            device=fs_spec,
            fstype=fs_vfstype,
            opts=fs_mntops,
            dump=fs_freq,
            pass_num=fs_passno,
            config=config,
            match_on=match_on,
            not_change=not_change,
        )
    ret["result"] = True
    if out == "present":
        msg = "{} entry was already in {}."
        ret["comment"].append(msg.format(fs_file, config))
    elif out == "new":
        ret["changes"]["persist"] = out
        msg = "{} entry added in {}."
        ret["comment"].append(msg.format(fs_file, config))
        if mount:
            out = __salt__["mount.mount"](fs_file)
            if type(out) == str:
                ret["result"] = False
                msg = "Error while mounting {}".format(out.split(":", maxsplit=1)[1])
            else:
                msg = "Mounted {} on {}".format(name, fs_file)
            ret["comment"].append(msg)
    elif out == "change":
        ret["changes"]["persist"] = out
        msg = "{} entry updated in {}."
        ret["comment"].append(msg.format(fs_file, config))
    else:
        ret["result"] = False
        msg = "{} entry cannot be changed in {}: {}."
        ret["comment"].append(msg.format(fs_file, config, out))
    return ret
def fstab_absent(name, fs_file, mount_by=None, config="/etc/fstab"):
    ret = {
        "name": name,
        "result": False,
        "changes": {},
        "comment": [],
    }
    if config == "/etc/fstab":
        if __grains__["os"] in ["MacOS", "Darwin"]:
            config = "/etc/auto_salt"
        elif __grains__["os"] == "AIX":
            config = "/etc/filesystems"
    if not fs_file == "/":
        fs_file = fs_file.rstrip("/")
    fs_spec = _convert_to(name, mount_by)
    if __grains__["os"] in ["MacOS", "Darwin"]:
        fstab_data = __salt__["mount.automaster"](config)
    elif __grains__["os"] == "AIX":
        fstab_data = __salt__["mount.filesystems"](config)
    else:
        fstab_data = __salt__["mount.fstab"](config)
    if __opts__["test"]:
        ret["result"] = None
        if fs_file not in fstab_data:
            msg = "{} entry is already missing in {}."
            ret["comment"].append(msg.format(fs_file, config))
        else:
            msg = "{} entry will be removed from {}."
            ret["comment"].append(msg.format(fs_file, config))
        return ret
    if fs_file in fstab_data:
        if __grains__["os"] in ["MacOS", "Darwin"]:
            out = __salt__["mount.rm_automaster"](
                name=fs_file, device=fs_spec, config=config
            )
        elif __grains__["os"] == "AIX":
            out = __salt__["mount.rm_filesystems"](
                name=fs_file, device=fs_spec, config=config
            )
        else:
            out = __salt__["mount.rm_fstab"](
                name=fs_file, device=fs_spec, config=config
            )
        if out is not True:
            ret["result"] = False
            msg = "{} entry failed when removing from {}."
            ret["comment"].append(msg.format(fs_file, config))
        else:
            ret["result"] = True
            ret["changes"]["persist"] = "removed"
            msg = "{} entry removed from {}."
            ret["comment"].append(msg.format(fs_file, config))
    else:
        ret["result"] = True
        msg = "{} entry is already missing in {}."
        ret["comment"].append(msg.format(fs_file, config))
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
