<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for capirca_acl.py &amp; mount_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for capirca_acl.py &amp; mount_2.py
      </h3>
<h1 align="center">
        2.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>capirca_acl.py (3.2886724%)<th>mount_2.py (1.7464424%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(612-873)<td><a href="#" name="0">(51-70)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(899-915)<td><a href="#" name="1">(1070-1144)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>capirca_acl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Capirca ACL
===========

Generate ACL (firewall) configuration for network devices.

.. versionadded:: 2017.7.0

:codeauthor: Mircea Ulinic &lt;ping@mirceaulinic.net&gt; &amp; Robert Ankeny &lt;robankeny@google.com&gt;
:maturity:   new
:depends:    capirca
:platform:   unix

Dependencies
------------

The firewall configuration is generated by Capirca_.

.. _Capirca: https://github.com/google/capirca

To install Capirca, execute: ``pip install capirca``.
"""

import datetime
import inspect
import logging
import re

import salt.utils.files

log = logging.getLogger(__file__)


try:
    import capirca
    import capirca.aclgen
    import capirca.lib.policy
    import capirca.lib.aclgenerator

    HAS_CAPIRCA = True
except ImportError:
    HAS_CAPIRCA = False


# ------------------------------------------------------------------------------
# module properties
# ------------------------------------------------------------------------------

__virtualname__ = "capirca"
__proxyenabled__ = ["*"]
# allow any proxy type

# ------------------------------------------------------------------------------
# property functions
# ------------------------------------------------------------------------------


def __virtual__():
    """
    This module requires at least Capirca to work.
    """
    if HAS_CAPIRCA:
        return __virtualname__
    else:
        return (False, "The capirca module (capirca_acl) cannot be loaded.")


# ------------------------------------------------------------------------------
# module globals
# ------------------------------------------------------------------------------


# define the default values for all possible term fields
# we could also extract them from the `policy` module, inspecting the `Policy`
# class, but that might be overkill &amp; it would make the code less obvious.
# we can revisit this later if necessary.

_TERM_FIELDS = {
    "action": [],
    "address": [],
    "address_exclude": [],
    "comment": [],
    "counter": None,
    "expiration": None,
    "destination_address": [],
    "destination_address_exclude": [],
    "destination_port": [],
    "destination_prefix": [],
    "forwarding_class": [],
    "forwarding_class_except": [],
    "logging": [],
    "log_name": None,
    "loss_priority": None,
    "option": [],
    "owner": None,
    "policer": None,
    "port": [],
    "precedence": [],
    "principals": [],
    "protocol": [],
    "protocol_except": [],
    "qos": None,
    "pan_application": [],
    "routing_instance": None,
    "source_address": [],
    "source_address_exclude": [],
    "source_port": [],
    "source_prefix": [],
    "verbatim": [],
    "packet_length": None,
    "fragment_offset": None,
    "hop_limit": None,
    "icmp_type": [],
    "icmp_code": None,
    "ether_type": [],
    "traffic_class_count": None,
    "traffic_type": [],
    "translated": False,
    "dscp_set": None,
    "dscp_match": [],
    "dscp_except": [],
    "next_ip": None,
    "flexible_match_range": [],
    "source_prefix_except": [],
    "destination_prefix_except": [],
    "vpn": None,
    "source_tag": [],
    "destination_tag": [],
    "source_interface": None,
    "destination_interface": None,
    "platform": [],
    "platform_exclude": [],
    "timeout": None,
    "flattened": False,
    "flattened_addr": None,
    "flattened_saddr": None,
    "flattened_daddr": None,
    "priority": None,
    "ttl": None,
}

# IP-type fields
# when it comes to IP fields, Capirca does not ingest raw text
# but they need to be converted to `nacaddr.IP`
# this pre-processing is done in `_clean_term_opts`
_IP_FILEDS = [
    "source_address",
    "source_address_exclude",
    "destination_address",
    "address",
    "address_exclude",
    "flattened_addr",
    "flattened_saddr",
    "flattened_daddr",
    "next_ip",
]

_SERVICES = {}

# ------------------------------------------------------------------------------
# helper functions -- will not be exported
# ------------------------------------------------------------------------------


if HAS_CAPIRCA:
    _TempTerm = capirca.lib.policy.Term

    def _add_object(self, obj):
        return

    setattr(_TempTerm, "AddObject", _add_object)
    dumy_term = _TempTerm(None)
    for item in dir(dumy_term):
        if hasattr(item, "__func__") or item.startswith("_") or item != item.lower():
            continue
        _TERM_FIELDS[item] = getattr(dumy_term, item)

    class _Policy(capirca.lib.policy.Policy):
        """
        Extending the Capirca Policy class to allow inserting custom filters.
        """

        def __init__(self):
            self.filters = []
            self.filename = ""

    class _Term(capirca.lib.policy.Term):
        """
        Extending the Capirca Term class to allow setting field valued on the fly.
        """

        def __init__(self):
            for field, default in _TERM_FIELDS.items():
                setattr(self, field, default)


def _import_platform_generator(platform):
    """
    Given a specific platform (under the Capirca conventions),
    return the generator class.
    The generator class is identified looking under the &lt;platform&gt; module
    for a class inheriting the `ACLGenerator` class.
    """
    log.debug("Using platform: %s", platform)
    for mod_name, mod_obj in inspect.getmembers(capirca.aclgen):
        if mod_name == platform and inspect.ismodule(mod_obj):
            for plat_obj_name, plat_obj in inspect.getmembers(
                mod_obj
            ):  # pylint: disable=unused-variable
                if inspect.isclass(plat_obj) and issubclass(
                    plat_obj, capirca.lib.aclgenerator.ACLGenerator
                ):
                    log.debug("Identified Capirca class %s for %s", plat_obj, platform)
                    return plat_obj
    log.error("Unable to identify any Capirca plaform class for %s", platform)


def _get_services_mapping():
    """
    Build a map of services based on the IANA assignment list:
    http://www.iana.org/assignments/port-numbers

    It will load the /etc/services file and will build the mapping on the fly,
    similar to the Capirca's SERVICES file:
    https://github.com/google/capirca/blob/master/def/SERVICES.svc

    As this module is be available on Unix systems only,
    we'll read the services from /etc/services.
    In the worst case, the user will not be able to specify the
    services shortcut and they will need to specify the protocol / port combination
    using the source_port / destination_port &amp; protocol fields.
    """
    if _SERVICES:
        return _SERVICES
    services_txt = ""
    try:
        with salt.utils.files.fopen("/etc/services", "r") as srv_f:
            services_txt = salt.utils.stringutils.to_unicode(srv_f.read())
    except OSError as ioe:
        log.error("Unable to read from /etc/services:")
        log.error(ioe)
        return _SERVICES  # no mapping possible, sorry
        # will return the default mapping
    service_rgx = re.compile(r"^([a-zA-Z0-9-]+)\s+(\d+)\/(tcp|udp)(.*)$")
    for line in services_txt.splitlines():
        service_rgx_s = service_rgx.search(line)
        if service_rgx_s and len(service_rgx_s.groups()) == 4:
            srv_name, port, protocol, _ = service_rgx_s.groups()
            if srv_name not in _SERVICES:
                _SERVICES[srv_name] = {"port": [], "protocol": []}
            try:
                _SERVICES[srv_name]["port"].append(int(port))
            except ValueError as verr:
                log.error(verr)
                log.error("Did not read that properly:")
                log.error(line)
                log.error(
                    "Please report the above error: %s does not seem a valid port"
                    " value!",
                    port,
                )
            _SERVICES[srv_name]["protocol"].append(protocol)
    return _SERVICES


def _translate_port(port):
    """
    Look into services and return the port value using the
    service name as lookup value.
    """
    services = _get_services_mapping()
    if port in services and services[port]["port"]:
        return services[port]["port"][0]
    return port


def _make_it_list(dict_, field_name, value):
    """
    Return the object list.
    """
    prev_value = []
    # firsly we'll collect the prev value
    if field_name in dict_:
        prev_value = dict_[field_name]
    if value is None:
        return prev_value
    elif isinstance(value, (tuple, list)):
        # other type of iterables
        if field_name in ("source_port", "destination_port"):
            # port fields are more special
            # they can either be a list of integers, either a list of tuples
            # list of integers = a list of ports
            # list of tuples = a list of ranges,
            # e.g.: [(1000, 2000), (3000, 4000)] means the 1000-2000 and 3000-4000 ranges
            portval = []
            for port in value:
                if not isinstance(port, (tuple, list)):
                    # to make sure everything is consistent,
                    # we'll transform indivitual ports into tuples
                    # thus an individual port e.g. 1000 will be transormed into the port range 1000-1000
                    # which is the equivalent
                    # but assures consistency for the Capirca parser
                    portval.append((port, port))
                else:
                    portval.append(port)
            translated_portval = []
            # and the ports sent as string, e.g. ntp instead of 123
            # needs to be translated
            # again, using the same /etc/services
            for port_start, port_end in portval:
                if not isinstance(port_start, int):
                    port_start = _translate_port(port_start)
                if not isinstance(port_end, int):
                    port_end = _translate_port(port_end)
                translated_portval.append((port_start, port_end))
            return list(set(prev_value + translated_portval))
        return list(set(prev_value + list(value)))
    if field_name in ("source_port", "destination_port"):
        if not isinstance(value, int):
            value = _translate_port(value)
        return list(set(prev_value + [(value, value)]))  # a list of tuples
    # anything else will be enclosed in a list-type
    return list(set(prev_value + [value]))


def _clean_term_opts(term_opts):
    """
    Cleanup the term opts:

    - strip Null and empty valuee, defaulting their value to their base definition from _TERM_FIELDS
    - convert to `nacaddr.IP` fields from `_IP_FILEDS`
    - create lists for those fields requiring it
    """
    clean_opts = {}
    _services = _get_services_mapping()
    for field, value in term_opts.items():
        # firstly we'll process special fields like source_service or destination_services
        # which will inject values directly in the source or destination port and protocol
        if field == "source_service" and value:
            if isinstance(value, str):
                value = _make_it_list(clean_opts, field, value)
            log.debug("Processing special source services:")
            log.debug(value)
            for service in value:
                if service and service in _services:
                    # if valid source_service
                    # take the port and protocol values from the global and inject in the term config
                    clean_opts["source_port"] = _make_it_list(
                        clean_opts, "source_port", _services[service]["port"]
                    )
                    clean_opts["protocol"] = _make_it_list(
                        clean_opts, "protocol", _services[service]["protocol"]
                    )
            log.debug(
                "Built source_port field, after processing special source services:"
            )
            log.debug(clean_opts.get("source_port"))
            log.debug("Built protocol field, after processing special source services:")
            log.debug(clean_opts.get("protocol"))
        elif field == "destination_service" and value:
            if isinstance(value, str):
                value = _make_it_list(clean_opts, field, value)
            log.debug("Processing special destination services:")
            log.debug(value)
            for service in value:
                if service and service in _services:
                    # if valid destination_service
                    # take the port and protocol values from the global and inject in the term config
                    clean_opts["destination_port"] = _make_it_list(
                        clean_opts, "destination_port", _services[service]["port"]
                    )
                    clean_opts["protocol"] = _make_it_list(
                        clean_opts, "protocol", _services[service]["protocol"]
                    )
            log.debug(
                "Built source_port field, after processing special destination"
                " services:"
            )
            log.debug(clean_opts.get("destination_service"))
            log.debug(
                "Built protocol field, after processing special destination services:"
            )
            log.debug(clean_opts.get("protocol"))
        # not a special field, but it has to be a valid one
        elif field in _TERM_FIELDS and value and value != _TERM_FIELDS[field]:
            # if not a special field type
            if isinstance(_TERM_FIELDS[field], list):
                value = _make_it_list(clean_opts, field, value)
            if field in _IP_FILEDS:
                # IP-type fields need to be transformed
                ip_values = []
                for addr in value:
                    ip_values.append(capirca.lib.policy.nacaddr.IP(addr))
                value = ip_values[:]
            clean_opts[field] = value
    return clean_opts


def _lookup_element(lst, key):
    """
    Find an dictionary in a list of dictionaries, given its main key.
    """
    if not lst:
        return {}
    for ele in lst:
        if not ele or not isinstance(ele, dict):
            continue
        if key in ele:
            return ele[key]
    return {}


def _get_pillar_cfg(pillar_key, pillarenv=None, saltenv=None):
    """
    Retrieve the pillar data from the right environment.
    """
    pillar_cfg = __salt__["pillar.get"](
        pillar_key, pillarenv=pillarenv, saltenv=saltenv
    )
    return pillar_cfg


def _cleanup(lst):
    """
    Return a list of non-empty dictionaries.
    """
    clean = []
    for ele in lst:
        if ele and isinstance(ele, dict):
            clean.append(ele)
    return clean


def _merge_list_of_dict(first, second, prepend=True):
    """
    Merge lists of dictionaries.
    Each element of the list is a dictionary having one single key.
    That key is then used as unique lookup.
    The first element list has higher priority than the second.
    When there's an overlap between the two lists,
    it won't change the position, but the content.
    """
    first = _cleanup(first)
    second = _cleanup(second)
    if not first and not second:
        return []
    if not first and second:
        return second
    if first and not second:
        return first
    # Determine overlaps
    # So we don't change the position of the existing terms/filters
    overlaps = []
    merged = []
    appended = []
    for ele in first:
        if _lookup_element(second, next(iter(ele))):
            overlaps.append(ele)
        elif prepend:
            merged.append(ele)
        elif not prepend:
            appended.append(ele)
    for ele in second:
        ele_key = next(iter(ele))
        if _lookup_element(overlaps, ele_key):
            # If there's an overlap, get the value from the first
            # But inserted into the right position
            ele_val_first = _lookup_element(first, ele_key)
            merged.append({ele_key: ele_val_first})
        else:
            merged.append(ele)
    if not prepend:
        merged.extend(appended)
    return merged


def _get_term_object(
    filter_name,
    term_name,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    **term_fields
):
    """
    Return an instance of the ``_Term`` class given the term options.
    """
    log.debug("Generating config for term %s under filter %s", term_name, filter_name)
    term = _Term()
    term.name = term_name
    term_opts = {}
    if merge_pillar:
        term_opts = get_term_pillar(
            filter_name,
            term_name,
            pillar_key=pillar_key,
            saltenv=saltenv,
            pillarenv=pillarenv,
        )
        log.debug("Merging with pillar data:")
        log.debug(term_opts)
        term_opts = _clean_term_opts(term_opts)
        log.debug("Cleaning up pillar data:")
        log.debug(term_opts)
    log.debug("Received processing opts:")
    log.debug(term_fields)
    log.debug("Cleaning up processing opts:")
    term_fields = _clean_term_opts(term_fields)
    log.debug(term_fields)
    log.debug("Final term opts:")
    term_opts.update(term_fields)
    log.debug(term_fields)
    for field, value in term_opts.items():
        # setting the field attributes to the term instance of _Term
        setattr(term, field, value)
    log.debug("Term config:")
    log.debug(str(term))
    return term


def _get_policy_object(
    platform,
    filters=None,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
):
    """
    Return an instance of the ``_Policy`` class given the filters config.
    """
    policy = _Policy()
    policy_filters = []
    if not filters:
        filters = []
    for filter_ in filters:
        if not filter_ or not isinstance(filter_, dict):
            continue  # go to the next filter
        filter_name, filter_config = next(iter(filter_.items()))
        header = capirca.lib.policy.Header()  # same header everywhere
        target_opts = [platform, filter_name]
        filter_options = filter_config.pop("options", None)
        if filter_options:
            filter_options = _make_it_list({}, filter_name, filter_options)
            # make sure the filter options are sent as list
            target_opts.extend(filter_options)
        target = capirca.lib.policy.Target(target_opts)
        header.AddObject(target)
        filter_terms = []
        for term_ in filter_config.get("terms", []):
            if term_ and isinstance(term_, dict):
                term_name, term_fields = next(iter(term_.items()))
                term = _get_term_object(
                    filter_name,
                    term_name,
                    pillar_key=pillar_key,
                    pillarenv=pillarenv,
                    saltenv=saltenv,
                    merge_pillar=merge_pillar,
                    **term_fields
                )
            filter_terms.append(term)
        policy_filters.append((header, filter_terms))
    policy.filters = policy_filters
    log.debug("Policy config:")
    log.debug(str(policy))
    platform_generator = _import_platform_generator(platform)
    policy_config = platform_generator(policy, 2)
    log.debug("Generating policy config for %s:", platform)
    log.debug(str(policy_config))
    return policy_config


def _revision_tag(
    text,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
):
    """
    Refactor revision tag comments.
    Capirca generates the filter text having the following tag keys:

    - $Id:$
    - $Revision:$
    - $Date:$

    This function goes through all the config lines and replaces
    those tags with the content requested by the user.
    If a certain value is not provided, the corresponding tag will be stripped.
    """
    timestamp = datetime.datetime.now().strftime(revision_date_format)
    new_text = []
    for line in text.splitlines():
        if "$Id:$" in line:
            if not revision_id:  # if no explicit revision ID required
                continue  # jump to next line, ignore this one
            line = line.replace("$Id:$", "$Id: {rev_id} $".format(rev_id=revision_id))
        if "$Revision:$" in line:
            if not revision_no:  # if no explicit revision number required
                continue  # jump to next line, ignore this one
            line = line.replace(
                "$Revision:$", "$Revision: {rev_no} $".format(rev_no=revision_no)
            )
        if "$Date:$" in line:
            if not revision_date:
<a name="0"></a>                continue  # jump
            line = line.replace("$Date:$", "$Date: {ts} $".format(ts=timestamp))
        new_text.append(line)
    return "\n".join(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>new_text)


# ------------------------------------------------------------------------------
# callable functions
# ------------------------------------------------------------------------------


def get_term_config(
    platform,
    filter_name,
    term_name,
    filter_options=None,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
    source_service=None,
    destination_service=None,
    **term_fields
):
    """
    Return the configuration of a single policy term.

    platform
        The name of the Capirca platform.

    filter_name
        The name of the policy filter.

    term_name
        The name of the term.

    filter_options
        Additional filter options. These options are platform-specific.
        E.g.: ``inet6``, ``bridge``, ``object-group``,
        See the complete list of options_.

        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section

    pillar_key: ``acl``
        The key in the pillar containing the default attributes values. Default: ``acl``.
        If the pillar contains the following structure:

        .. code-block:: yaml

            firewall:
              - my-filter:
                  terms:
                    - my-term:
                        source_port: 1234
                        source_address:
                            - 1.2.3.4/32
                            - 5.6.7.8/32

        The ``pillar_key`` field would be specified as ``firewall``.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.

    merge_pillar: ``True``
        Merge the CLI variables with the pillar. Default: ``True``.

    revision_id
        Add a comment in the term config having the description for the changes applied.

    revision_no
        The revision count.

    revision_date: ``True``
        Boolean flag: display the date when the term configuration was generated. Default: ``True``.

    revision_date_format: ``%Y/%m/%d``
        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (&lt;year&gt;/&lt;month&gt;/&lt;day&gt;).

    source_service
        A special service to choose from. This is a helper so the user is able to
        select a source just using the name, instead of specifying a source_port and protocol.

        As this module is available on Unix platforms only,
        it reads the IANA_ port assignment from ``/etc/services``.

        If the user requires additional shortcuts to be referenced, they can add entries under ``/etc/services``,
        which can be managed using the :mod:`file state &lt;salt.states.file&gt;`.

        .. _IANA: http://www.iana.org/assignments/port-numbers

    destination_service
        A special service to choose from. This is a helper so the user is able to
        select a source just using the name, instead of specifying a destination_port and protocol.
        Allows the same options as ``source_service``.

    term_fields
        Term attributes.
        To see what fields are supported, please consult the list of supported keywords_.
        Some platforms have few other optional_ keywords.

        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords
        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords

    .. note::
        The following fields are accepted:

        - action
        - address
        - address_exclude
        - comment
        - counter
        - expiration
        - destination_address
        - destination_address_exclude
        - destination_port
        - destination_prefix
        - forwarding_class
        - forwarding_class_except
        - logging
        - log_name
        - loss_priority
        - option
        - policer
        - port
        - precedence
        - principals
        - protocol
        - protocol_except
        - qos
        - pan_application
        - routing_instance
        - source_address
        - source_address_exclude
        - source_port
        - source_prefix
        - verbatim
        - packet_length
        - fragment_offset
        - hop_limit
        - icmp_type
        - ether_type
        - traffic_class_count
        - traffic_type
        - translated
        - dscp_set
        - dscp_match
        - dscp_except
        - next_ip
        - flexible_match_range
        - source_prefix_except
        - destination_prefix_except
        - vpn
        - source_tag
        - destination_tag
        - source_interface
        - destination_interface
        - flattened
        - flattened_addr
        - flattened_saddr
        - flattened_daddr
        - priority

    .. note::
        The following fields can be also a single value and a list of values:

        - action
        - address
        - address_exclude
        - comment
        - destination_address
        - destination_address_exclude
        - destination_port
        - destination_prefix
        - forwarding_class
        - forwarding_class_except
        - logging
        - option
        - port
        - precedence
        - principals
        - protocol
        - protocol_except
        - pan_application
        - source_address
        - source_address_exclude
        - source_port
        - source_prefix
        - verbatim
        - icmp_type
        - ether_type
        - traffic_type
        - dscp_match
        - dscp_except
        - flexible_match_range
        - source_prefix_except
        - destination_prefix_except
        - source_tag
        - destination_tag
        - source_service
        - destination_service

        Example: ``destination_address`` can be either defined as:

        .. code-block:: yaml

            destination_address: 172.17.17.1/24

        or as a list of destination IP addresses:

        .. code-block:: yaml

            destination_address:
                - 172.17.17.1/24
                - 172.17.19.1/24

        or a list of services to be matched:

        .. code-block:: yaml

            source_service:
                - ntp
                - snmp
                - ldap
                - bgpd

    .. note::
        The port fields ``source_port`` and ``destination_port`` can be used as above to select either
        a single value, either a list of values, but also they can select port ranges. Example:

        .. code-block:: yaml

            source_port:
                - [1000, 2000]
                - [3000, 4000]

        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.

    CLI Example:

    .. code-block:: bash

        salt '*' capirca.get_term_config arista filter-name term-name source_address=1.2.3.4 destination_address=5.6.7.8 action=accept

    Output Example:

    .. code-block:: text

        ! $Date: 2017/03/22 $
        no ip access-list filter-name
        ip access-list filter-name
         remark term-name
         permit ip host 1.2.3.4 host 5.6.7.8
        exit
    """
    terms = []
    term =</b></font> {term_name: {}}
    term[term_name].update(term_fields)
    term[term_name].update(
        {
            "source_service": _make_it_list({}, "source_service", source_service),
            "destination_service": _make_it_list(
                {}, "destination_service", destination_service
            ),
        }
    )
    terms.append(term)
    if not filter_options:
        filter_options = []
    return get_filter_config(
        platform,
        filter_name,
        filter_options=filter_options,
        terms=terms,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
        only_lower_merge=True,
<a name="1"></a>        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>revision_date_format,
    )


def get_filter_config(
    platform,
    filter_name,
    filter_options=None,
    terms=None,
    prepend=True,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    only_lower_merge=False,
    revision_id=None,
    revision_no=</b></font>None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
):
    """
    Return the configuration of a policy filter.

    platform
        The name of the Capirca platform.

    filter_name
        The name of the policy filter.

    filter_options
        Additional filter options. These options are platform-specific.
        See the complete list of options_.

        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section

    terms
        List of terms for this policy filter.
        If not specified or empty, will try to load the configuration from the pillar,
        unless ``merge_pillar`` is set as ``False``.

    prepend: ``True``
        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging
        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended
        at the beginning, while existing ones will preserve the position. To add the new terms
        at the end of the list, set this argument to ``False``.

    pillar_key: ``acl``
        The key in the pillar containing the default attributes values. Default: ``acl``.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.

    merge_pillar: ``True``
        Merge the CLI variables with the pillar. Default: ``True``.

    only_lower_merge: ``False``
        Specify if it should merge only the terms fields. Otherwise it will try
        to merge also filters fields. Default: ``False``.

    revision_id
        Add a comment in the filter config having the description for the changes applied.

    revision_no
        The revision count.

    revision_date: ``True``
        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.

    revision_date_format: ``%Y/%m/%d``
        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (&lt;year&gt;/&lt;month&gt;/&lt;day&gt;).

    CLI Example:

    .. code-block:: bash

        salt '*' capirca.get_filter_config ciscoxr my-filter pillar_key=netacl

    Output Example:

    .. code-block:: text

        ! $Id:$
        ! $Date:$
        ! $Revision:$
        no ipv4 access-list my-filter
        ipv4 access-list my-filter
         remark $Id:$
         remark my-term
         deny ipv4 any eq 1234 any
         deny ipv4 any eq 1235 any
         remark my-other-term
         permit tcp any range 5678 5680 any
        exit

    The filter configuration has been loaded from the pillar, having the following structure:

    .. code-block:: yaml

        netacl:
          - my-filter:
              terms:
                - my-term:
                    source_port: [1234, 1235]
                    action: reject
                - my-other-term:
                    source_port:
                      - [5678, 5680]
                    protocol: tcp
                    action: accept
    """
    if not filter_options:
        filter_options = []
    if not terms:
        terms = []
    if merge_pillar and not only_lower_merge:
        acl_pillar_cfg = _get_pillar_cfg(
            pillar_key, saltenv=saltenv, pillarenv=pillarenv
        )
        filter_pillar_cfg = _lookup_element(acl_pillar_cfg, filter_name)
        filter_options = filter_options or filter_pillar_cfg.pop("options", None)
        if filter_pillar_cfg:
            # Only when it was able to find the filter in the ACL config
            pillar_terms = filter_pillar_cfg.get(
                "terms", []
            )  # No problem if empty in the pillar
            terms = _merge_list_of_dict(terms, pillar_terms, prepend=prepend)
            # merge the passed variable with the pillar data
            # any filter term not defined here, will be appended from the pillar
            # new terms won't be removed
    filters = []
    filters.append(
        {
            filter_name: {
                "options": _make_it_list({}, filter_name, filter_options),
                "terms": terms,
            }
        }
    )
    return get_policy_config(
        platform,
        filters=filters,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
        only_lower_merge=True,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )


def get_policy_config(
    platform,
    filters=None,
    prepend=True,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    only_lower_merge=False,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
):
    """
    Return the configuration of the whole policy.

    platform
        The name of the Capirca platform.

    filters
        List of filters for this policy.
        If not specified or empty, will try to load the configuration from the pillar,
        unless ``merge_pillar`` is set as ``False``.

    prepend: ``True``
        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging
        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended
        at the beginning, while existing ones will preserve the position. To add the new filters
        at the end of the list, set this argument to ``False``.

    pillar_key: ``acl``
        The key in the pillar containing the default attributes values. Default: ``acl``.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.

    merge_pillar: ``True``
        Merge the CLI variables with the pillar. Default: ``True``.

    only_lower_merge: ``False``
        Specify if it should merge only the filters and terms fields. Otherwise it will try
        to merge everything at the policy level. Default: ``False``.

    revision_id
        Add a comment in the policy config having the description for the changes applied.

    revision_no
        The revision count.

    revision_date: ``True``
        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.

    revision_date_format: ``%Y/%m/%d``
        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (&lt;year&gt;/&lt;month&gt;/&lt;day&gt;).

    CLI Example:

    .. code-block:: bash

        salt '*' capirca.get_policy_config juniper pillar_key=netacl

    Output Example:

    .. code-block:: text

        firewall {
            family inet {
                replace:
                /*
                ** $Id:$
                ** $Date:$
                ** $Revision:$
                **
                */
                filter my-filter {
                    term my-term {
                        from {
                            source-port [ 1234 1235 ];
                        }
                        then {
                            reject;
                        }
                    }
                    term my-other-term {
                        from {
                            protocol tcp;
                            source-port 5678-5680;
                        }
                        then accept;
                    }
                }
            }
        }
        firewall {
            family inet {
                replace:
                /*
                ** $Id:$
                ** $Date:$
                ** $Revision:$
                **
                */
                filter my-other-filter {
                    interface-specific;
                    term dummy-term {
                        from {
                            protocol [ tcp udp ];
                        }
                        then {
                            reject;
                        }
                    }
                }
            }
        }

    The policy configuration has been loaded from the pillar, having the following structure:

    .. code-block:: yaml

        netacl:
          - my-filter:
              options:
                - not-interface-specific
              terms:
                - my-term:
                    source_port: [1234, 1235]
                    action: reject
                - my-other-term:
                    source_port:
                      - [5678, 5680]
                    protocol: tcp
                    action: accept
          - my-other-filter:
              terms:
                - dummy-term:
                    protocol:
                      - tcp
                      - udp
                    action: reject
    """
    if not filters:
        filters = []
    if merge_pillar and not only_lower_merge:
        # the pillar key for the policy config is the `pillar_key` itself
        policy_pillar_cfg = _get_pillar_cfg(
            pillar_key, saltenv=saltenv, pillarenv=pillarenv
        )
        # now, let's merge everything witht the pillar data
        # again, this will not remove any extra filters/terms
        # but it will merge with the pillar data
        # if this behaviour is not wanted, the user can set `merge_pillar` as `False`
        filters = _merge_list_of_dict(filters, policy_pillar_cfg, prepend=prepend)
    policy_object = _get_policy_object(
        platform,
        filters=filters,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
    )
    policy_text = str(policy_object)
    return _revision_tag(
        policy_text,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )


def get_filter_pillar(filter_name, pillar_key="acl", pillarenv=None, saltenv=None):
    """
    Helper that can be used inside a state SLS,
    in order to get the filter configuration given its name.

    filter_name
        The name of the filter.

    pillar_key
        The root key of the whole policy config.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.
    """
    pillar_cfg = _get_pillar_cfg(pillar_key, pillarenv=pillarenv, saltenv=saltenv)
    return _lookup_element(pillar_cfg, filter_name)


def get_term_pillar(
    filter_name, term_name, pillar_key="acl", pillarenv=None, saltenv=None
):
    """
    Helper that can be used inside a state SLS,
    in order to get the term configuration given its name,
    under a certain filter uniquely identified by its name.

    filter_name
        The name of the filter.

    term_name
        The name of the term.

    pillar_key: ``acl``
        The root key of the whole policy config. Default: ``acl``.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.
    """
    filter_pillar_cfg = get_filter_pillar(
        filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv
    )
    term_pillar_cfg = filter_pillar_cfg.get("terms", [])
    term_opts = _lookup_element(term_pillar_cfg, term_name)
    return term_opts
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mount_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Mounting of filesystems
=======================

Mount any type of mountable filesystem with the mounted function:

.. code-block:: yaml

    /mnt/sdb:
      mount.mounted:
        - device: /dev/sdb1
        - fstype: ext4
        - mkmnt: True
        - opts:
          - defaults

    /srv/bigdata:
      mount.mounted:
        - device: UUID=066e0200-2867-4ebe-b9e6-f30026ca2314
        - fstype: xfs
        - opts: nobootwait,noatime,nodiratime,nobarrier,logbufs=8
        - dump: 0
        - pass_num: 2
        - persist: True
        - mkmnt: True

    /var/lib/bigdata:
      mount.mounted:
        - device: /srv/bigdata
        - fstype: none
        - opts: bind
        - dump: 0
        - pass_num: 0
        - persist: True
        - mkmnt: True
"""

import logging
import os.path
import re

log = logging.getLogger(__name__)


def _size_convert(_re_size):
    converted_size = int(_re_size.group("size_value"))
    if _re_size.group("size_unit") == "m":
<a name="0"></a>        converted_size = int(converted_size) * 1024
    if _re_size.group("size_unit") == "g":
        converted_size = int(converted_size) * 1024 * 1024
    r<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn converted_size


def mounted(
    name,
    device,
    fstype,
    mkmnt=False,
    opts="defaults",
    dump=0,
    pass_num=0,
    config="/etc/fstab",
    persist=True,
    mount=True,
    user=None,
    match_on="auto",
    device_name_regex=None,
    extra_mount_invisible_options=None,
    extra_mount_invisible_keys=None,
    extra_mount_ignore_fs_keys=</b></font>None,
    extra_mount_translate_options=None,
    hidden_opts=None,
    **kwargs
):
    """
    Verify that a device is mounted

    name
        The path to the location where the device is to be mounted

    device
        The device name, typically the device node, such as ``/dev/sdb1``
        or ``UUID=066e0200-2867-4ebe-b9e6-f30026ca2314`` or ``LABEL=DATA``

    fstype
        The filesystem type, this will be ``xfs``, ``ext2/3/4`` in the case of classic
        filesystems, ``fuse`` in the case of fuse mounts, and ``nfs`` in the case of nfs mounts

    mkmnt
        If the mount point is not present then the state will fail, set ``mkmnt: True``
        to create the mount point if it is otherwise not present

    opts
        A list object of options or a comma delimited list

    dump
        The dump value to be passed into the fstab, Default is ``0``

    pass_num
        The pass value to be passed into the fstab, Default is ``0``

    config
        Set an alternative location for the fstab, Default is ``/etc/fstab``

    persist
        Set if the mount should be saved in the fstab, Default is ``True``

    mount
        Set if the mount should be mounted immediately, Default is ``True``

    user
        The account used to execute the mount; this defaults to the user salt is
        running as on the minion

    match_on
        A name or list of fstab properties on which this state should be applied.
        Default is ``auto``, a special value indicating to guess based on fstype.
        In general, ``auto`` matches on name for recognized special devices and
        device otherwise.

    device_name_regex
        A list of device exact names or regular expressions which should
        not force a remount. For example, glusterfs may be mounted with a
        comma-separated list of servers in fstab, but the /proc/self/mountinfo
        will show only the first available server.

        .. code-block:: jinja

            {% set glusterfs_ip_list = ['10.0.0.1', '10.0.0.2', '10.0.0.3'] %}

            mount glusterfs volume:
              mount.mounted:
                - name: /mnt/glusterfs_mount_point
                - device: {{ glusterfs_ip_list|join(',') }}:/volume_name
                - fstype: glusterfs
                - opts: _netdev,rw,defaults,direct-io-mode=disable
                - mkmnt: True
                - persist: True
                - dump: 0
                - pass_num: 0
                - device_name_regex:
                  - ({{ glusterfs_ip_list|join('|') }}):/volume_name

        .. versionadded:: 2016.11.0

    extra_mount_invisible_options
        A list of extra options that are not visible through the
        ``/proc/self/mountinfo`` interface.

        If a option is not visible through this interface it will always remount
        the device. This option extends the builtin ``mount_invisible_options``
        list.

    extra_mount_invisible_keys
        A list of extra key options that are not visible through the
        ``/proc/self/mountinfo`` interface.

        If a key option is not visible through this interface it will always
        remount the device. This option extends the builtin
        ``mount_invisible_keys`` list.

        A good example for a key option is the password option::

            password=badsecret

    extra_mount_ignore_fs_keys
        A dict of filesystem options which should not force a remount. This will update
        the internal dictionary. The dict should look like this::

            {
                'ramfs': ['size']
            }

    extra_mount_translate_options
        A dict of mount options that gets translated when mounted. To prevent a remount
        add additional options to the default dictionary. This will update the internal
        dictionary. The dictionary should look like this::

            {
                'tcp': 'proto=tcp',
                'udp': 'proto=udp'
            }

    hidden_opts
        A list of mount options that will be ignored when considering a remount
        as part of the state application

        .. versionadded:: 2015.8.2
    """
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}

    update_mount_cache = False

    if not name:
        ret["result"] = False
        ret["comment"] = "Must provide name to mount.mounted"
        return ret

    if not device:
        ret["result"] = False
        ret["comment"] = "Must provide device to mount.mounted"
        return ret

    if not fstype:
        ret["result"] = False
        ret["comment"] = "Must provide fstype to mount.mounted"
        return ret

    if device_name_regex is None:
        device_name_regex = []

    # Defaults is not a valid option on Mac OS
    if __grains__["os"] in ["MacOS", "Darwin"] and opts == "defaults":
        opts = "noowners"

    # Defaults is not a valid option on AIX
    if __grains__["os"] in ["AIX"]:
        if opts == "defaults":
            opts = ""

    # Make sure that opts is correct, it can be a list or a comma delimited
    # string
    if isinstance(opts, str):
        opts = opts.split(",")
    if opts:
        opts.sort()

    if isinstance(hidden_opts, str):
        hidden_opts = hidden_opts.split(",")

    # remove possible trailing slash
    if not name == "/":
        name = name.rstrip("/")

    device_list = []
    # Get the active data
    active = __salt__["mount.active"](extended=True)
    real_name = os.path.realpath(name)
    if device.startswith("/"):
        if "bind" in opts and real_name in active:
            _device = device
            if active[real_name]["device"].startswith("/"):
                # Find the device that the bind really points at.
                while True:
                    if _device in active:
                        _real_device = active[_device]["device"]
                        opts = list(
                            set(
                                opts
                                + active[_device]["opts"]
                                + active[_device]["superopts"]
                            )
                        )
                        active[real_name]["opts"].append("bind")
                        break
                    _device = os.path.dirname(_device)
                real_device = _real_device
            else:
                # Remote file systems act differently.
                if _device in active:
                    opts = list(
                        set(
                            opts
                            + active[_device]["opts"]
                            + active[_device]["superopts"]
                        )
                    )
                    active[real_name]["opts"].append("bind")
                real_device = active[real_name]["device"]
        else:
            real_device = os.path.realpath(device)
    elif device.upper().startswith("UUID="):
        real_device = device.split("=")[1].strip('"').lower()
    elif device.upper().startswith("LABEL="):
        _label = device.split("=")[1]
        cmd = "blkid -t LABEL={}".format(_label)
        res = __salt__["cmd.run_all"]("{}".format(cmd))
        if res["retcode"] &gt; 0:
            ret["comment"] = "Unable to find device with label {}.".format(_label)
            ret["result"] = False
            return ret
        else:
            # output is a list of entries like this:
            # /dev/sda: LABEL="&lt;label&gt;" UUID="&lt;uuid&gt;" UUID_SUB="&lt;uuid&gt;" TYPE="btrfs"
            # exact list of properties varies between filesystems, but we're
            # only interested in the device in the first column
            for line in res["stdout"]:
                dev_with_label = line.split(":")[0]
                device_list.append(dev_with_label)
            real_device = device_list[0]
    else:
        real_device = device

    # LVS devices have 2 names under /dev:
    # /dev/mapper/vg--name-lv--name and /dev/vg-name/lv-name
    # No matter what name is used for mounting,
    # mount always displays the device as /dev/mapper/vg--name-lv--name
    # Note the double-dash escaping.
    # So, let's call that the canonical device name
    # We should normalize names of the /dev/vg-name/lv-name type to the canonical name
    lvs_match = re.match(r"^/dev/(?P&lt;vg_name&gt;[^/]+)/(?P&lt;lv_name&gt;[^/]+$)", device)
    if lvs_match:
        double_dash_escaped = {
            k: re.sub(r"-", "--", v) for k, v in lvs_match.groupdict().items()
        }
        mapper_device = "/dev/mapper/{vg_name}-{lv_name}".format(**double_dash_escaped)
        if os.path.exists(mapper_device):
            real_device = mapper_device

    # When included in a Salt state file, FUSE devices are prefaced by the
    # filesystem type and a hash, e.g. sshfs.  In the mount list only the
    # hostname is included.  So if we detect that the device is a FUSE device
    # then we remove the prefaced string so that the device in state matches
    # the device in the mount list.
    fuse_match = re.match(r"^\w+\#(?P&lt;device_name&gt;.+)", device)
    if fuse_match:
        if "device_name" in fuse_match.groupdict():
            real_device = fuse_match.group("device_name")

    if real_name in active:
        if "superopts" not in active[real_name]:
            active[real_name]["superopts"] = []
        if mount:
            device_list.append(active[real_name]["device"])
            device_list.append(os.path.realpath(device_list[0]))
            alt_device = (
                active[real_name]["alt_device"]
                if "alt_device" in active[real_name]
                else None
            )
            uuid_device = (
                active[real_name]["device_uuid"]
                if "device_uuid" in active[real_name]
                else None
            )
            label_device = (
                active[real_name]["device_label"]
                if "device_label" in active[real_name]
                else None
            )
            if alt_device and alt_device not in device_list:
                device_list.append(alt_device)
            if uuid_device and uuid_device not in device_list:
                device_list.append(uuid_device)
            if label_device and label_device not in device_list:
                device_list.append(label_device)
            if opts:
                opts.sort()

                mount_invisible_options = [
                    "_netdev",
                    "actimeo",
                    "bg",
                    "comment",
                    "defaults",
                    "delay_connect",
                    "direct-io-mode",
                    "intr",
                    "loop",
                    "nointr",
                    "nobootwait",
                    "nofail",
                    "password",
                    "reconnect",
                    "retry",
                    "soft",
                    "auto",
                    "users",
                    "bind",
                    "nonempty",
                    "transform_symlinks",
                    "port",
                    "backup-volfile-servers",
                ]

                if extra_mount_invisible_options:
                    mount_invisible_options.extend(extra_mount_invisible_options)

                if hidden_opts:
                    mount_invisible_options = list(
                        set(mount_invisible_options) | set(hidden_opts)
                    )

                # options which are provided as key=value (e.g. password=Zohp5ohb)
                mount_invisible_keys = [
                    "actimeo",
                    "comment",
                    "credentials",
                    "direct-io-mode",
                    "password",
                    "port",
                    "retry",
                    "secretfile",
                ]

                if extra_mount_invisible_keys:
                    mount_invisible_keys.extend(extra_mount_invisible_keys)

                # Some filesystems have options which should not force a remount.
                mount_ignore_fs_keys = {"ramfs": ["size"]}

                if extra_mount_ignore_fs_keys:
                    mount_ignore_fs_keys.update(extra_mount_ignore_fs_keys)

                # Some options are translated once mounted
                mount_translate_options = {
                    "tcp": "proto=tcp",
                    "udp": "proto=udp",
                }

                if extra_mount_translate_options:
                    mount_translate_options.update(extra_mount_translate_options)

                for opt in opts:
                    if opt in mount_translate_options:
                        opt = mount_translate_options[opt]

                    keyval_option = opt.split("=")[0]
                    if keyval_option in mount_invisible_keys:
                        opt = keyval_option

                    size_match = re.match(
                        r"size=(?P&lt;size_value&gt;[0-9]+)(?P&lt;size_unit&gt;k|m|g)", opt
                    )
                    if size_match:
                        converted_size = _size_convert(size_match)
                        opt = "size={}k".format(converted_size)
                    # make cifs option user synonym for option username which is reported by /proc/mounts
                    if fstype in ["cifs"] and opt.split("=")[0] == "user":
                        opt = "username={}".format(opt.split("=")[1])

                    if opt.split("=")[0] in mount_ignore_fs_keys.get(fstype, []):
                        opt = opt.split("=")[0]

                    # convert uid/gid to numeric value from user/group name
                    name_id_opts = {"uid": "user.info", "gid": "group.info"}
                    if opt.split("=")[0] in name_id_opts and len(opt.split("=")) &gt; 1:
                        _givenid = opt.split("=")[1]
                        _param = opt.split("=")[0]
                        _id = _givenid
                        if not re.match("[0-9]+$", _givenid):
                            _info = __salt__[name_id_opts[_param]](_givenid)
                            if _info and _param in _info:
                                _id = _info[_param]
                        opt = _param + "=" + str(_id)

                    _active_superopts = active[real_name].get("superopts", [])
                    for _active_opt in _active_superopts:
                        size_match = re.match(
                            r"size=(?P&lt;size_value&gt;[0-9]+)(?P&lt;size_unit&gt;k|m|g)",
                            _active_opt,
                        )
                        if size_match:
                            converted_size = _size_convert(size_match)
                            opt = "size={}k".format(converted_size)
                            _active_superopts.remove(_active_opt)
                            _active_opt = "size={}k".format(converted_size)
                            _active_superopts.append(_active_opt)

                    if (
                        opt not in active[real_name]["opts"]
                        and opt not in _active_superopts
                        and opt not in mount_invisible_options
                        and opt not in mount_ignore_fs_keys.get(fstype, [])
                        and opt not in mount_invisible_keys
                    ):
                        if __opts__["test"]:
                            ret["result"] = None
                            ret[
                                "comment"
                            ] = "Remount would be forced because options ({}) changed".format(
                                opt
                            )
                            return ret
                        else:
                            # Some file systems require umounting and mounting if options change
                            # add others to list that require similiar functionality
                            if fstype in ["nfs", "cvfs"] or fstype.startswith("fuse"):
                                ret["changes"]["umount"] = (
                                    "Forced unmount and mount because "
                                    + "options ({}) changed".format(opt)
                                )
                                unmount_result = __salt__["mount.umount"](real_name)
                                if unmount_result is True:
                                    mount_result = __salt__["mount.mount"](
                                        real_name,
                                        device,
                                        mkmnt=mkmnt,
                                        fstype=fstype,
                                        opts=opts,
                                    )
                                    ret["result"] = mount_result
                                else:
                                    ret["result"] = False
                                    ret["comment"] = "Unable to unmount {}: {}.".format(
                                        real_name, unmount_result
                                    )
                                    return ret
                            else:
                                ret["changes"]["umount"] = (
                                    "Forced remount because "
                                    + "options ({}) changed".format(opt)
                                )
                                remount_result = __salt__["mount.remount"](
                                    real_name,
                                    device,
                                    mkmnt=mkmnt,
                                    fstype=fstype,
                                    opts=opts,
                                )
                                ret["result"] = remount_result
                                # Cleanup after the remount, so we
                                # don't write remount into fstab
                                if "remount" in opts:
                                    opts.remove("remount")

                            # Update the cache
                            update_mount_cache = True

                mount_cache = __salt__["mount.read_mount_cache"](real_name)
                if "opts" in mount_cache:
                    _missing = [opt for opt in mount_cache["opts"] if opt not in opts]

                    if _missing:
                        if __opts__["test"]:
                            ret["result"] = None
                            ret["comment"] = (
                                "Remount would be forced because"
                                " options ({})"
                                "changed".format(",".join(_missing))
                            )
                            return ret
                        else:
                            # Some file systems require umounting and mounting if options change
                            # add others to list that require similiar functionality
                            if fstype in ["nfs", "cvfs"] or fstype.startswith("fuse"):
                                ret["changes"]["umount"] = (
                                    "Forced unmount and mount because "
                                    + "options ({}) changed".format(opt)
                                )
                                unmount_result = __salt__["mount.umount"](real_name)
                                if unmount_result is True:
                                    mount_result = __salt__["mount.mount"](
                                        real_name,
                                        device,
                                        mkmnt=mkmnt,
                                        fstype=fstype,
                                        opts=opts,
                                    )
                                    ret["result"] = mount_result
                                else:
                                    ret["result"] = False
                                    ret["comment"] = "Unable to unmount {}: {}.".format(
                                        real_name, unmount_result
                                    )
                                    return ret
                            else:
                                ret["changes"]["umount"] = (
                                    "Forced remount because "
                                    + "options ({}) changed".format(opt)
                                )
                                remount_result = __salt__["mount.remount"](
                                    real_name,
                                    device,
                                    mkmnt=mkmnt,
                                    fstype=fstype,
                                    opts=opts,
                                )
                                ret["result"] = remount_result
                                # Cleanup after the remount, so we
                                # don't write remount into fstab
                                if "remount" in opts:
                                    opts.remove("remount")

                        update_mount_cache = True
                else:
                    update_mount_cache = True

            if real_device not in device_list:
                # name matches but device doesn't - need to umount
                _device_mismatch_is_ignored = None
                for regex in list(device_name_regex):
                    for _device in device_list:
                        if re.match(regex, _device):
                            _device_mismatch_is_ignored = _device
                            break
                if _device_mismatch_is_ignored:
                    ret["result"] = True
                    ret["comment"] = (
                        "An umount will not be forced "
                        + "because device matched device_name_regex: "
                        + _device_mismatch_is_ignored
                    )
                elif __opts__["test"]:
                    ret["result"] = None
                    ret["comment"] = (
                        "An umount would have been forced "
                        + "because devices do not match.  Watched: "
                        + device
                    )
                else:
                    ret["changes"]["umount"] = (
                        "Forced unmount because devices "
                        + "don't match. Wanted: "
                        + device
                    )
                    if real_device != device:
                        ret["changes"]["umount"] += " (" + real_device + ")"
                    ret["changes"]["umount"] += ", current: " + ", ".join(device_list)
                    out = __salt__["mount.umount"](real_name, user=user)
                    active = __salt__["mount.active"](extended=True)
                    if real_name in active:
                        ret["comment"] = "Unable to unmount"
                        ret["result"] = None
                        return ret
                    update_mount_cache = True
            else:
                ret["comment"] = "Target was already mounted"
    # using a duplicate check so I can catch the results of a umount
    if real_name not in active:
        if mount:
            # The mount is not present! Mount it
            if __opts__["test"]:
                ret["result"] = None
                if os.path.exists(name):
                    ret["comment"] = "{} would be mounted".format(name)
                elif mkmnt:
                    ret["comment"] = "{} would be created and mounted".format(name)
                else:
                    ret[
                        "comment"
                    ] = "{} does not exist and would not be created".format(name)
                return ret

            if not os.path.exists(name) and not mkmnt:
                ret["result"] = False
                ret["comment"] = "Mount directory is not present"
                return ret

            out = __salt__["mount.mount"](name, device, mkmnt, fstype, opts, user=user)
            active = __salt__["mount.active"](extended=True)
            update_mount_cache = True
            if isinstance(out, str):
                # Failed to (re)mount, the state has failed!
                ret["comment"] = out
                ret["result"] = False
                return ret
            elif real_name in active:
                # (Re)mount worked!
                ret["comment"] = "Target was successfully mounted"
                ret["changes"]["mount"] = True
        elif not os.path.exists(name):
            if __opts__["test"]:
                ret["result"] = None
                if mkmnt:
                    ret["comment"] = "{} would be created, but not mounted".format(name)
                else:
                    ret[
                        "comment"
                    ] = "{} does not exist and would neither be created nor mounted".format(
                        name
                    )
            elif mkmnt:
                __salt__["file.mkdir"](name, user=user)
                ret["comment"] = "{} was created, not mounted".format(name)
            else:
                ret["comment"] = "{} not present and not mounted".format(name)
        else:
            if __opts__["test"]:
                ret["result"] = None
                ret["comment"] = "{} would not be mounted".format(name)
            else:
                ret["comment"] = "{} not mounted".format(name)

    if persist:
        if "/etc/fstab" == config:
            # Override default for Mac OS
            if __grains__["os"] in ["MacOS", "Darwin"]:
                config = "/etc/auto_salt"

            # Override default for AIX
            elif "AIX" in __grains__["os"]:
                config = "/etc/filesystems"

        if __opts__["test"]:
            if __grains__["os"] in ["MacOS", "Darwin"]:
                out = __salt__["mount.set_automaster"](
                    name, device, fstype, opts, config, test=True
                )
            elif __grains__["os"] in ["AIX"]:
                out = __salt__["mount.set_filesystems"](
                    name,
                    device,
                    fstype,
                    opts,
                    mount,
                    config,
                    test=True,
                    match_on=match_on,
                )
            else:
                out = __salt__["mount.set_fstab"](
                    name,
                    device,
                    fstype,
                    opts,
                    dump,
                    pass_num,
                    config,
                    test=True,
                    match_on=match_on,
                )
            if out != "present":
                ret["result"] = None
                if out == "new":
                    if mount:
                        comment = (
                            "{} is mounted, but needs to be "
                            "written to the fstab in order to be "
                            "made persistent.".format(name)
                        )
                    else:
                        comment = (
                            "{} needs to be "
                            "written to the fstab in order to be "
                            "made persistent.".format(name)
                        )
                elif out == "change":
                    if mount:
                        comment = "{} is mounted, but its fstab entry must be updated.".format(
                            name
                        )
                    else:
                        comment = "The {} fstab entry must be updated.".format(name)
                else:
                    ret["result"] = False
                    comment = (
                        "Unable to detect fstab status for "
                        "mount point {} due to unexpected "
                        "output '{}' from call to "
                        "mount.set_fstab. This is most likely "
                        "a bug.".format(name, out)
                    )
                if "comment" in ret:
                    ret["comment"] = "{}. {}".format(ret["comment"], comment)
                else:
                    ret["comment"] = comment
                return ret

        else:
            if __grains__["os"] in ["MacOS", "Darwin"]:
                out = __salt__["mount.set_automaster"](
                    name, device, fstype, opts, config
                )
            elif __grains__["os"] in ["AIX"]:
                out = __salt__["mount.set_filesystems"](
                    name, device, fstype, opts, mount, config, match_on=match_on
                )
            else:
                out = __salt__["mount.set_fstab"](
                    name,
                    device,
                    fstype,
                    opts,
                    dump,
                    pass_num,
                    config,
                    match_on=match_on,
                )

        if update_mount_cache:
            cache_result = __salt__["mount.write_mount_cache"](
                real_name, device, mkmnt=mkmnt, fstype=fstype, mount_opts=opts
            )

        if out == "present":
            ret["comment"] += ". Entry already exists in the fstab."
            return ret
        if out == "new":
            ret["changes"]["persist"] = "new"
            ret["comment"] += ". Added new entry to the fstab."
            return ret
        if out == "change":
            ret["changes"]["persist"] = "update"
            ret["comment"] += ". Updated the entry in the fstab."
            return ret
        if out == "bad config":
            ret["result"] = False
            ret["comment"] += ". However, the fstab was not found."
            return ret

    return ret


def swap(name, persist=True, config="/etc/fstab"):
    """
    Activates a swap device

    .. code-block:: yaml

        /root/swapfile:
          mount.swap

    .. note::
        ``swap`` does not currently support LABEL
    """
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    on_ = __salt__["mount.swaps"]()

    if __salt__["file.is_link"](name):
        real_swap_device = __salt__["file.readlink"](name)
        if not real_swap_device.startswith("/"):
            real_swap_device = "/dev/{}".format(os.path.basename(real_swap_device))
    else:
        real_swap_device = name

    if real_swap_device in on_:
        ret["comment"] = "Swap {} already active".format(name)
    elif __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "Swap {} is set to be activated".format(name)
    else:
        __salt__["mount.swapon"](real_swap_device)

        on_ = __salt__["mount.swaps"]()

        if real_swap_device in on_:
            ret["comment"] = "Swap {} activated".format(name)
            ret["changes"] = on_[real_swap_device]
        else:
            ret["comment"] = "Swap {} failed to activate".format(name)
            ret["result"] = False

    if persist:
        device_key_name = "device"
        if "AIX" in __grains__["os"]:
            device_key_name = "dev"
            if "/etc/fstab" == config:
                # Override default for AIX
                config = "/etc/filesystems"
            fstab_data = __salt__["mount.filesystems"](config)
        else:
            fstab_data = __salt__["mount.fstab"](config)
        if __opts__["test"]:
            if name not in fstab_data and name not in [
                fstab_data[item]["device"] for item in fstab_data
            ]:
                ret["result"] = None
                if name in on_:
                    ret[
                        "comment"
                    ] = "Swap {} is set to be added to the fstab and to be activated".format(
                        name
                    )
            return ret

        if "none" in fstab_data:
            if (
                fstab_data["none"][device_key_name] == name
                and fstab_data["none"]["fstype"] != "swap"
            ):
                return ret

        if "AIX" in __grains__["os"]:
            out = None
            ret["result"] = False
            ret["comment"] += ". swap not present in /etc/filesystems on AIX."
            return ret
        else:
            # present, new, change, bad config
            # Make sure the entry is in the fstab
            out = __salt__["mount.set_fstab"](
                "none", name, "swap", ["defaults"], 0, 0, config
            )
        if out == "present":
            return ret
        if out == "new":
            ret["changes"]["persist"] = "new"
            ret["comment"] += ". Added new entry to the fstab."
            return ret
        if out == "change":
            ret["changes"]["persist"] = "update"
            ret["comment"] += ". Updated the entry in the fstab."
            return ret
        if out == "bad config":
            ret["result"] = False
            ret["comment"] += ". However, the fstab was not found."
            return ret
    return ret


def unmounted(
    name, device=None, config="/etc/fstab", persist=False, user=None, **kwargs
):
    """
    .. versionadded:: 0.17.0

    Verify that a device is not mounted

    name
        The path to the location where the device is to be unmounted from

    device
        The device to be unmounted.  This is optional because the device could
        be mounted in multiple places.

        .. versionadded:: 2015.5.0

    config
        Set an alternative location for the fstab, Default is ``/etc/fstab``

    persist
        Set if the mount should be purged from the fstab, Default is ``False``

    user
        The user to own the mount; this defaults to the user salt is
        running as on the minion
    """
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}

    update_mount_cache = False

    if not name:
        ret["result"] = False
        ret["comment"] = "Must provide name to mount.unmounted"
        return ret

    # Get the active data
    active = __salt__["mount.active"](extended=True)
    if name not in active:
        # Nothing to unmount
        ret["comment"] = "Target was already unmounted"
    if name in active:
        # The mount is present! Unmount it
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "Mount point {} is mounted but should not be".format(name)
            return ret
        if device:
            out = __salt__["mount.umount"](name, device, user=user)
            update_mount_cache = True
        else:
            out = __salt__["mount.umount"](name, user=user)
            update_mount_cache = True
        if isinstance(out, str):
            # Failed to umount, the state has failed!
            ret["comment"] = out
            ret["result"] = False
        elif out is True:
            # umount worked!
            ret["comment"] = "Target was successfully unmounted"
            ret["changes"]["umount"] = True
        else:
            ret["comment"] = "Execute set to False, Target was not unmounted"
            ret["result"] = True

    if update_mount_cache:
        cache_result = __salt__["mount.delete_mount_cache"](name)

    if persist:
        device_key_name = "device"
        # Override default for Mac OS
        if __grains__["os"] in ["MacOS", "Darwin"] and config == "/etc/fstab":
            config = "/etc/auto_salt"
            fstab_data = __salt__["mount.automaster"](config)
        elif "AIX" in __grains__["os"]:
            device_key_name = "dev"
            if config == "/etc/fstab":
                config = "/etc/filesystems"
            fstab_data = __salt__["mount.filesystems"](config)
        else:
            fstab_data = __salt__["mount.fstab"](config)

        if name not in fstab_data:
            ret["comment"] += ". fstab entry not found"
        else:
            if device:
                if fstab_data[name][device_key_name] != device:
                    ret["comment"] += ". fstab entry for device {} not found".format(
                        device
                    )
                    return ret
            if __opts__["test"]:
                ret["result"] = None
                ret["comment"] = (
                    "Mount point {} is unmounted but needs to "
                    "be purged from {} to be made "
                    "persistent".format(name, config)
                )
                return ret
            else:
                if __grains__["os"] in ["MacOS", "Darwin"]:
                    out = __salt__["mount.rm_automaster"](name, device, config)
                elif "AIX" in __grains__["os"]:
                    out = __salt__["mount.rm_filesystems"](name, device, config)
                else:
                    out = __salt__["mount.rm_fstab"](name, device, config)
                if out is not True:
                    ret["result"] = False
                    ret["comment"] += ". Failed to persist purge"
                else:
                    ret["comment"] += ". Removed target from fstab"
                    ret["changes"]["persist"] = "purged"

    return ret


def mod_watch(name, user=None, **kwargs):
    """
    The mounted watcher, called to invoke the watch command.

    .. note::
        This state exists to support special handling of the ``watch``
        :ref:`requisite &lt;requisites&gt;`. It should not be called directly.

        Parameters for this function should be set by the state being triggered.

    name
        The name of the mount point

    """
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}

    if kwargs["sfun"] == "mounted":
        out = __salt__["mount.remount"](
            name, kwargs["device"], False, kwargs["fstype"], kwargs["opts"], user=user
        )
        if out:
            ret["comment"] = "{} remounted".format(name)
        else:
            ret["result"] = False
            ret["comment"] = "{} failed to remount: {}".format(name, out)
    else:
        ret["comment"] = "Watch not supported in {} at this time".format(kwargs["sfun"])
    return ret


def _convert_to(maybe_device, convert_to):
    """
    Convert a device name, UUID or LABEL to a device name, UUID or
    LABEL.

    Return the fs_spec required for fstab.

    """

    # Fast path. If we already have the information required, we can
    # save one blkid call
    if (
        not convert_to
        or (convert_to == "device" and maybe_device.startswith("/"))
        or maybe_device.startswith("{}=".format(convert_to.upper()))
    ):
        return maybe_device

    # Get the device information
    if maybe_device.startswith("/"):
        blkid = __salt__["disk.blkid"](maybe_device)
    else:
        blkid = __salt__["disk.blkid"](token=maybe_device)

    result = None
    if len(blkid) == 1:
        if convert_to == "device":
            result = next(iter(blkid))
        else:
<a name="1"></a>            key = convert_to.upper()
            result = "{}={}".format(key, next(iter(blkid.values()))[key])

    r<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn result


def fstab_present(
    name,
    fs_file,
    fs_vfstype,
    fs_mntops="defaults",
    fs_freq=0,
    fs_passno=0,
    mount_by=None,
    config="/etc/fstab",
    mount=True,
    match_on="auto",
    not_change=False,
    fs_mount=True,
):
    """Makes sure that a fstab mount point is present.

    name
        The name of block device. Can be any valid fs_spec value.

    fs_file
        Mount point (target) for the filesystem.

    fs_vfstype
        The type of the filesystem (e.g. ext4, xfs, btrfs, ...)

    fs_mntops
        The mount options associated with the filesystem. Default is
        ``defaults``.

    fs_freq
        Field is used by dump to determine which fs need to be
        dumped. Default is ``0``

    fs_passno
        Field is used by fsck to determine the order in which
        filesystem checks are done at boot time. Default is ``0``

    fs_mount
        Field is used only in AIX systems to determine if the
        filesystem will be mounted by ``mount all``

    mount_by
        Select the final value for fs_spec. Can be [``None``,
        ``device``, ``label``, ``uuid``, ``partlabel``,
        ``partuuid``]. If ``None``, the value for fs_spect will be the
        parameter ``name``, in other case will search the correct
        value based on the device name. For example, for ``uuid``, the
        value for fs_spec will be of type 'UUID=xxx' instead of the
        device name set in ``name``.

    config
        Place where the fstab file lives. Default is ``/etc/fstab``

    mount
        Set if the mount should be mounted immediately. Default is
        ``True``

    match_on
        A name or list of fstab properties on which this state should
        be applied.  Default is ``auto``, a special value indicating
        to guess based on fstype.  In general, ``auto`` matches on
        name for recognized special devices and device otherwise.

    not_change
        By default, if the entry is found in the fstab file but is
        different from the expected content (like different options),
        the entry will be replaced with the correct content. If this
        parameter is set to ``True`` and the line is found, the
        original content will be preserved.

    """
    ret =</b></font> {
        "name": name,
        "result": False,
        "changes": {},
        "comment": [],
    }

    # Adjust fs_mntops based on the OS
    if fs_mntops == "defaults":
        if __grains__["os"] in ["MacOS", "Darwin"]:
            fs_mntops = "noowners"
        elif __grains__["os"] == "AIX":
            fs_mntops = ""

    # Adjust the config file based on the OS
    if config == "/etc/fstab":
        if __grains__["os"] in ["MacOS", "Darwin"]:
            config = "/etc/auto_salt"
        elif __grains__["os"] == "AIX":
            config = "/etc/filesystems"

    if not fs_file == "/":
        fs_file = fs_file.rstrip("/")

    fs_spec = _convert_to(name, mount_by)

    # Validate that the device is valid after the conversion
    if not fs_spec:
        msg = "Device {} cannot be converted to {}"
        ret["comment"].append(msg.format(name, mount_by))
        return ret

    if __opts__["test"]:
        if __grains__["os"] in ["MacOS", "Darwin"]:
            out = __salt__["mount.set_automaster"](
                name=fs_file,
                device=fs_spec,
                fstype=fs_vfstype,
                opts=fs_mntops,
                config=config,
                test=True,
                not_change=not_change,
            )
        elif __grains__["os"] == "AIX":
            out = __salt__["mount.set_filesystems"](
                name=fs_file,
                device=fs_spec,
                fstype=fs_vfstype,
                opts=fs_mntops,
                mount=fs_mount,
                config=config,
                test=True,
                match_on=match_on,
                not_change=not_change,
            )
        else:
            out = __salt__["mount.set_fstab"](
                name=fs_file,
                device=fs_spec,
                fstype=fs_vfstype,
                opts=fs_mntops,
                dump=fs_freq,
                pass_num=fs_passno,
                config=config,
                test=True,
                match_on=match_on,
                not_change=not_change,
            )
        ret["result"] = None
        if out == "present":
            msg = "{} entry is already in {}."
            ret["comment"].append(msg.format(fs_file, config))
        elif out == "new":
            msg = "{} entry will be written in {}."
            ret["comment"].append(msg.format(fs_file, config))
            if mount:
                msg = "Will mount {} on {}".format(name, fs_file)
                ret["comment"].append(msg)
        elif out == "change":
            msg = "{} entry will be updated in {}."
            ret["comment"].append(msg.format(fs_file, config))
        else:
            ret["result"] = False
            msg = "{} entry cannot be created in {}: {}."
            ret["comment"].append(msg.format(fs_file, config, out))
        return ret

    if __grains__["os"] in ["MacOS", "Darwin"]:
        out = __salt__["mount.set_automaster"](
            name=fs_file,
            device=fs_spec,
            fstype=fs_vfstype,
            opts=fs_mntops,
            config=config,
            not_change=not_change,
        )
    elif __grains__["os"] == "AIX":
        out = __salt__["mount.set_filesystems"](
            name=fs_file,
            device=fs_spec,
            fstype=fs_vfstype,
            opts=fs_mntops,
            mount=fs_mount,
            config=config,
            match_on=match_on,
            not_change=not_change,
        )
    else:
        out = __salt__["mount.set_fstab"](
            name=fs_file,
            device=fs_spec,
            fstype=fs_vfstype,
            opts=fs_mntops,
            dump=fs_freq,
            pass_num=fs_passno,
            config=config,
            match_on=match_on,
            not_change=not_change,
        )

    ret["result"] = True
    if out == "present":
        msg = "{} entry was already in {}."
        ret["comment"].append(msg.format(fs_file, config))
    elif out == "new":
        ret["changes"]["persist"] = out
        msg = "{} entry added in {}."
        ret["comment"].append(msg.format(fs_file, config))
        if mount:
            out = __salt__["mount.mount"](fs_file)
            if type(out) == str:
                ret["result"] = False
                msg = "Error while mounting {}".format(out.split(":", maxsplit=1)[1])
            else:
                msg = "Mounted {} on {}".format(name, fs_file)
            ret["comment"].append(msg)
    elif out == "change":
        ret["changes"]["persist"] = out
        msg = "{} entry updated in {}."
        ret["comment"].append(msg.format(fs_file, config))
    else:
        ret["result"] = False
        msg = "{} entry cannot be changed in {}: {}."
        ret["comment"].append(msg.format(fs_file, config, out))

    return ret


def fstab_absent(name, fs_file, mount_by=None, config="/etc/fstab"):
    """
    Makes sure that a fstab mount point is absent.

    name
        The name of block device. Can be any valid fs_spec value.

    fs_file
        Mount point (target) for the filesystem.

    mount_by
        Select the final value for fs_spec. Can be [``None``,
        ``device``, ``label``, ``uuid``, ``partlabel``,
        ``partuuid``]. If ``None``, the value for fs_spect will be the
        parameter ``name``, in other case will search the correct
        value based on the device name. For example, for ``uuid``, the
        value for fs_spec will be of type 'UUID=xxx' instead of the
        device name set in ``name``.

    config
        Place where the fstab file lives

    """
    ret = {
        "name": name,
        "result": False,
        "changes": {},
        "comment": [],
    }

    # Adjust the config file based on the OS
    if config == "/etc/fstab":
        if __grains__["os"] in ["MacOS", "Darwin"]:
            config = "/etc/auto_salt"
        elif __grains__["os"] == "AIX":
            config = "/etc/filesystems"

    if not fs_file == "/":
        fs_file = fs_file.rstrip("/")

    fs_spec = _convert_to(name, mount_by)

    if __grains__["os"] in ["MacOS", "Darwin"]:
        fstab_data = __salt__["mount.automaster"](config)
    elif __grains__["os"] == "AIX":
        fstab_data = __salt__["mount.filesystems"](config)
    else:
        fstab_data = __salt__["mount.fstab"](config)

    if __opts__["test"]:
        ret["result"] = None
        if fs_file not in fstab_data:
            msg = "{} entry is already missing in {}."
            ret["comment"].append(msg.format(fs_file, config))
        else:
            msg = "{} entry will be removed from {}."
            ret["comment"].append(msg.format(fs_file, config))
        return ret

    if fs_file in fstab_data:
        if __grains__["os"] in ["MacOS", "Darwin"]:
            out = __salt__["mount.rm_automaster"](
                name=fs_file, device=fs_spec, config=config
            )
        elif __grains__["os"] == "AIX":
            out = __salt__["mount.rm_filesystems"](
                name=fs_file, device=fs_spec, config=config
            )
        else:
            out = __salt__["mount.rm_fstab"](
                name=fs_file, device=fs_spec, config=config
            )

        if out is not True:
            ret["result"] = False
            msg = "{} entry failed when removing from {}."
            ret["comment"].append(msg.format(fs_file, config))
        else:
            ret["result"] = True
            ret["changes"]["persist"] = "removed"
            msg = "{} entry removed from {}."
            ret["comment"].append(msg.format(fs_file, config))
    else:
        ret["result"] = True
        msg = "{} entry is already missing in {}."
        ret["comment"].append(msg.format(fs_file, config))

    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
