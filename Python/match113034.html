<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for versions.py &amp; case.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for versions.py &amp; case.py
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>versions.py (5.3452115%)<th>case.py (2.1582735%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(325-334)<td><a href="#" name="0">(275-294)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(14-28)<td><a href="#" name="1">(24-38)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>versions.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import datetime
3 import inspect
4 import logging
5 import numbers
6 import sys
7 import warnings
8 from distutils.version import LooseVersion as _LooseVersion
9 from distutils.version import StrictVersion as _StrictVersion
10 import salt.version
11 log = logging.getLogger(</b></font>__name__)
12 class StrictVersion(_StrictVersion):
13     def parse(self, vstring):
14         _StrictVersion.parse(self, vstring)
15     def _cmp(self, other):
16         if isinstance(other, str):
17             other = StrictVersion(other)
18         return _StrictVersion._cmp(self, other)
19 class LooseVersion(_LooseVersion):
20     def parse(self, vstring):
21         _LooseVersion.parse(self, vstring)
22         self._str_version = [
23             str(vp).zfill(8) if isinstance(vp, int) else vp for vp in self.version
24         ]
25     def _cmp(self, other):
26         if isinstance(other, str):
27             other = LooseVersion(other)
28         string_in_version = False
29         for part in self.version + other.version:
30             if not isinstance(part, int):
31                 string_in_version = True
32                 break
33         if string_in_version is False:
34             return _LooseVersion._cmp(self, other)
35         if self._str_version == other._str_version:
36             return 0
37         if self._str_version &lt; other._str_version:
38             return -1
39         if self._str_version &gt; other._str_version:
40             return 1
41 def _format_warning(message, category, filename, lineno, line=None):
42     """
43     Replacement for warnings.formatwarning that disables the echoing of
44     the 'line' parameter.
45     """
46     return "{}:{}: {}: {}\n".format(filename, lineno, category.__name__, message)
47 def warn_until(
48     version,
49     message,
50     category=DeprecationWarning,
51     stacklevel=None,
52     _version_info_=None,
53     _dont_call_warnings=False,
54 ):
55     """
56     Helper function to raise a warning, by default, a ``DeprecationWarning``,
57     until the provided ``version``, after which, a ``RuntimeError`` will
58     be raised to remind the developers to remove the warning because the
59     target version has been reached.
60     :param version: The version info or name after which the warning becomes a ``RuntimeError``.
61                     For example ``(2019, 2)``, ``3000``, ``Hydrogen`` or an instance of
62                     :class:`salt.version.SaltStackVersion` or :class:`salt.version.SaltVersion`.
63     :param message: The warning message to be displayed.
64     :param category: The warning class to be thrown, by default
65                      ``DeprecationWarning``
66     :param stacklevel: There should be no need to set the value of
67                        ``stacklevel``. Salt should be able to do the right thing.
68     :param _version_info_: In order to reuse this function for other SaltStack
69                            projects, they need to be able to provide the
70                            version info to compare to.
71     :param _dont_call_warnings: This parameter is used just to get the
72                                 functionality until the actual error is to be
73                                 issued. When we're only after the salt version
74                                 checks to raise a ``RuntimeError``.
75     """
76     if isinstance(version, salt.version.SaltVersion):
77         version = salt.version.SaltStackVersion(*version.info)
78     elif isinstance(version, int):
79         version = salt.version.SaltStackVersion(version)
80     elif isinstance(version, tuple):
81         version = salt.version.SaltStackVersion(*version)
82     elif isinstance(version, str):
83         if version.lower() not in salt.version.SaltStackVersion.LNAMES:
84             raise RuntimeError(
85                 "Incorrect spelling for the release name in the warn_utils "
86                 "call. Expecting one of these release names: {}".format(
87                     [vs.name for vs in salt.version.SaltVersionsInfo.versions()]
88                 )
89             )
90         version = salt.version.SaltStackVersion.from_name(version)
91     elif not isinstance(version, salt.version.SaltStackVersion):
92         raise RuntimeError(
93             "The 'version' argument should be passed as a tuple, integer, string or "
94             "an instance of 'salt.version.SaltVersion' or "
95             "'salt.version.SaltStackVersion'."
96         )
97     if stacklevel is None:
98         stacklevel = 2
99     if _version_info_ is None:
100         _version_info_ = salt.version.__version_info__
101     _version_ = salt.version.SaltStackVersion(*_version_info_)
102     if _version_ &gt;= version:
103         caller = inspect.getframeinfo(sys._getframe(stacklevel - 1))
104         raise RuntimeError(
105             "The warning triggered on filename '{filename}', line number "
106             "{lineno}, is supposed to be shown until version "
107             "{until_version} is released. Current version is now "
108             "{salt_version}. Please remove the warning.".format(
109                 filename=caller.filename,
110                 lineno=caller.lineno,
111                 until_version=version.formatted_version,
112                 salt_version=_version_.formatted_version,
113             ),
114         )
115     if _dont_call_warnings is False:
116         warnings.warn(
117             message.format(version=version.formatted_version),
118             category,
119             stacklevel=stacklevel,
120         )
121 def warn_until_date(
122     date,
123     message,
124     category=DeprecationWarning,
125     stacklevel=None,
126     _current_date=None,
127     _dont_call_warnings=False,
128 ):
129     """
130     Helper function to raise a warning, by default, a ``DeprecationWarning``,
131     until the provided ``date``, after which, a ``RuntimeError`` will
132     be raised to remind the developers to remove the warning because the
133     target date has been reached.
134     :param date: A ``datetime.date`` or ``datetime.datetime`` instance.
135     :param message: The warning message to be displayed.
136     :param category: The warning class to be thrown, by default
137                      ``DeprecationWarning``
138     :param stacklevel: There should be no need to set the value of
139                        ``stacklevel``. Salt should be able to do the right thing.
140     :param _dont_call_warnings: This parameter is used just to get the
141                                 functionality until the actual error is to be
142                                 issued. When we're only after the date
143                                 checks to raise a ``RuntimeError``.
144     """
145     _strptime_fmt = "%Y%m%d"
146     if not isinstance(date, (str, datetime.date, datetime.datetime)):
147         raise RuntimeError(
148             "The 'date' argument should be passed as a 'datetime.date()' or "
149             "'datetime.datetime()' objects or as string parserable by "
150             "'datetime.datetime.strptime()' with the following format '{}'.".format(
151                 _strptime_fmt
152             )
153         )
154     elif isinstance(date, str):
155         date = datetime.datetime.strptime(date, _strptime_fmt)
156     if isinstance(date, datetime.datetime):
157         date = date.date()
158     if stacklevel is None:
159         stacklevel = 2
160     today = _current_date or datetime.datetime.utcnow().date()
161     if today &gt;= date:
162         caller = inspect.getframeinfo(sys._getframe(stacklevel - 1))
163         raise RuntimeError(
164             "{message} This warning(now exception) triggered on "
165             "filename '{filename}', line number {lineno}, is "
166             "supposed to be shown until {date}. Today is {today}. "
167             "Please remove the warning.".format(
168                 message=message.format(date=date.isoformat(), today=today.isoformat()),
169                 filename=caller.filename,
170                 lineno=caller.lineno,
171                 date=date.isoformat(),
172                 today=today.isoformat(),
173             ),
174         )
175     if _dont_call_warnings is False:
176         warnings.warn(
177             message.format(date=date.isoformat(), today=today.isoformat()),
178             category,
179             stacklevel=stacklevel,
180         )
181 def kwargs_warn_until(
182     kwargs,
183     version,
184     category=DeprecationWarning,
185     stacklevel=None,
186     _version_info_=None,
187     _dont_call_warnings=False,
188 ):
189     """
190     Helper function to raise a warning (by default, a ``DeprecationWarning``)
191     when unhandled keyword arguments are passed to function, until the
192     provided ``version_info``, after which, a ``RuntimeError`` will be raised
193     to remind the developers to remove the ``**kwargs`` because the target
194     version has been reached.
195     This function is used to help deprecate unused legacy ``**kwargs`` that
196     were added to function parameters lists to preserve backwards compatibility
197     when removing a parameter. See
198     :ref:`the deprecation development docs &lt;deprecations&gt;`
199     for the modern strategy for deprecating a function parameter.
200     :param kwargs: The caller's ``**kwargs`` argument value (a ``dict``).
201     :param version: The version info or name after which the warning becomes a
202                     ``RuntimeError``. For example ``(0, 17)`` or ``Hydrogen``
203                     or an instance of :class:`salt.version.SaltStackVersion`.
204     :param category: The warning class to be thrown, by default
205                      ``DeprecationWarning``
206     :param stacklevel: There should be no need to set the value of
207                        ``stacklevel``. Salt should be able to do the right thing.
208     :param _version_info_: In order to reuse this function for other SaltStack
209                            projects, they need to be able to provide the
210                            version info to compare to.
211     :param _dont_call_warnings: This parameter is used just to get the
212                                 functionality until the actual error is to be
213                                 issued. When we're only after the salt version
214                                 checks to raise a ``RuntimeError``.
215     """
216     if not isinstance(version, (tuple, str, salt.version.SaltStackVersion)):
217         raise RuntimeError(
218             "The 'version' argument should be passed as a tuple, string or "
219             "an instance of 'salt.version.SaltStackVersion'."
220         )
221     elif isinstance(version, tuple):
222         version = salt.version.SaltStackVersion(*version)
223     elif isinstance(version, str):
224         version = salt.version.SaltStackVersion.from_name(version)
225     if stacklevel is None:
226         stacklevel = 3
227     if _version_info_ is None:
228         _version_info_ = salt.version.__version_info__
229     _version_ = salt.version.SaltStackVersion(*_version_info_)
230     if kwargs or _version_.info &gt;= version.info:
231         arg_names = ", ".join("'{}'".format(key) for key in kwargs)
232         warn_until(
233             version,
234             message=(
235                 "The following parameter(s) have been deprecated and "
236                 "will be removed in '{}': {}.".format(version.string, arg_names)
237             ),
238             category=category,
239             stacklevel=stacklevel,
240             _version_info_=_version_.info,
241             _dont_call_warnings=_dont_call_warnings,
242         )
243 def version_cmp(pkg1, pkg2, ignore_epoch=False):
244     """
245     Compares two version strings using salt.utils.versions.LooseVersion. This
246     is a fallback for providers which don't have a version comparison utility
247     built into them.  Return -1 if version1 &lt; version2, 0 if version1 ==
248     version2, and 1 if version1 &gt; version2. Return None if there was a problem
249     making the comparison.
250     """
251     normalize = lambda x: str(x).split(":", 1)[-1] if ignore_epoch else str(x)
252     pkg1 = normalize(pkg1)
253     pkg2 = normalize(pkg2)
254     try:
255         if LooseVersion(pkg1) &lt; LooseVersion(pkg2):
256             return -1
257         elif LooseVersion(pkg1) == LooseVersion(pkg2):
258             return 0
259             return 1
260     except Exception as exc:  # pylint: disable=broad-except
261         log<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.exception(exc)
262     return None
263 def compare(ver1="", oper="==", ver2="", cmp_func=None, ignore_epoch=False):
264     """
265     Compares two version numbers. Accepts a custom function to perform the
266     cmp-style version comparison, otherwise uses version_cmp().
267     """
268     cmp_map = {"&lt;"</b></font>: (-1,), "&lt;=": (-1, 0), "==": (0,), "&gt;=": (0, 1), "&gt;": (1,)}
269     if oper not in ("!=",) and oper not in cmp_map:
270         log.error("Invalid operator '%s' for version comparison", oper)
271         return False
272     if cmp_func is None:
273         cmp_func = version_cmp
274     cmp_result = cmp_func(ver1, ver2, ignore_epoch=ignore_epoch)
275     if cmp_result is None:
276         return False
277     if not isinstance(cmp_result, numbers.Integral):
278         log.error("The version comparison function did not return an integer/long.")
279         return False
280     if oper == "!=":
281         return cmp_result not in cmp_map["=="]
282     else:
283         if cmp_result &lt; -1:
284             cmp_result = -1
285         elif cmp_result &gt; 1:
286             cmp_result = 1
287         return cmp_result in cmp_map[oper]
288 def check_boto_reqs(
289     boto_ver=None, boto3_ver=None, botocore_ver=None, check_boto=True, check_boto3=True
290 ):
291     """
292     Checks for the version of various required boto libs in one central location. Most
293     boto states and modules rely on a single version of the boto, boto3, or botocore libs.
294     However, some require newer versions of any of these dependencies. This function allows
295     the module to pass in a version to override the default minimum required version.
296     This function is useful in centralizing checks for ``__virtual__()`` functions in the
297     various, and many, boto modules and states.
298     boto_ver
299         The minimum required version of the boto library. Defaults to ``2.0.0``.
300     boto3_ver
301         The minimum required version of the boto3 library. Defaults to ``1.2.6``.
302     botocore_ver
303         The minimum required version of the botocore library. Defaults to ``1.3.23``.
304     check_boto
305         Boolean defining whether or not to check for boto deps. This defaults to ``True`` as
306         most boto modules/states rely on boto, but some do not.
307     check_boto3
308         Boolean defining whether or not to check for boto3 (and therefore botocore) deps.
309         This defaults to ``True`` as most boto modules/states rely on boto3/botocore, but
310         some do not.
311     """
312     if check_boto is True:
313         try:
314             import boto
315             has_boto = True
316         except ImportError:
317             has_boto = False
318         if boto_ver is None:
319             boto_ver = "2.0.0"
320         if not has_boto or version_cmp(boto.__version__, boto_ver) == -1:
321             return False, "A minimum version of boto {} is required.".format(boto_ver)
322     if check_boto3 is True:
323         try:
324             import boto3
325             import botocore
326             has_boto3 = True
327         except ImportError:
328             has_boto3 = False
329         if boto3_ver is None:
330             boto3_ver = "1.2.6"
331         if botocore_ver is None:
332             botocore_ver = "1.3.23"
333         if not has_boto3 or version_cmp(boto3.__version__, boto3_ver) == -1:
334             return (
335                 False,
336                 "A minimum version of boto3 {} is required.".format(boto3_ver),
337             )
338         elif version_cmp(botocore.__version__, botocore_ver) == -1:
339             return (
340                 False,
341                 "A minimum version of botocore {} is required".format(botocore_ver),
342             )
343     return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>case.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2     :codeauthor: Pedro Algarvio (pedro@algarvio.me)
3     ====================================
4     Custom Salt TestCase Implementations
5     ====================================
6     Custom reusable :class:`TestCase&lt;python2:unittest.TestCase&gt;`
7     implementations.
8 """
9 import errno
10 import io
11 import json
12 import logging
13 import os
14 import re
15 import subprocess
16 import sys
17 import textwrap
18 import time
19 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from datetime import datetime, timedelta
20 import pytest
21 import salt.utils.files
22 from saltfactories.utils.processes import terminate_process
23 from tests.support.cli_scripts import ScriptPathMixin
24 from tests.support.helpers import RedirectStdStreams
25 from tests.support.mixins import (  # pylint: disable=unused-import
26     AdaptedConfigurationTestCaseMixin,
27     SaltClientTestCaseMixin,
28 )
29 from tests.support.runtests import RUNTIME_VARS
30 from tests.support.unit import TestCase
31 STATE_FUNCTION_RUNNING_RE = re.compile(</b></font>
32     r"""The function (?:"|')(?P&lt;state_func&gt;.*)(?:"|') is running as PID """
33     r"(?P&lt;pid&gt;[\d]+) and was started at (?P&lt;date&gt;.*) with jid (?P&lt;jid&gt;[\d]+)"
34 )
35 log = logging.getLogger(__name__)
36 class ShellCase(TestCase, AdaptedConfigurationTestCaseMixin, ScriptPathMixin):
37     """
38     Execute a test for a shell command
39     """
40     RUN_TIMEOUT = 30
41     def run_salt(
42         self,
43         arg_str,
44         with_retcode=False,
45         catch_stderr=False,
46         timeout=None,
47         popen_kwargs=None,
48         config_dir=None,
49     ):
50         r'''
51         Run the ``salt`` CLI tool with the provided arguments
52         .. code-block:: python
53             class MatchTest(ShellCase):
54                 def test_list(self):
55                     """
56                     test salt -L matcher
57                     """
58                     data = self.run_salt('-L minion test.ping')
59                     data = '\n'.join(data)
60                     self.assertIn('minion', data)
61         '''
62         if timeout is None:
63             timeout = self.RUN_TIMEOUT
64         arg_str = "-t {} {}".format(timeout, arg_str)
65         return self.run_script(
66             "salt",
67             arg_str,
68             with_retcode=with_retcode,
69             catch_stderr=catch_stderr,
70             timeout=timeout,
71             config_dir=config_dir,
72         )
73     def run_ssh(
74         self,
75         arg_str,
76         with_retcode=False,
77         catch_stderr=False,
78         timeout=None,
79         wipe=False,
80         raw=False,
81         roster_file=None,
82         ssh_opts="",
83         log_level="error",
84         config_dir=None,
85         **kwargs
86     ):
87         """
88         Execute salt-ssh
89         """
90         if timeout is None:
91             timeout = self.RUN_TIMEOUT
92         if not roster_file:
93             roster_file = os.path.join(RUNTIME_VARS.TMP_CONF_DIR, "roster")
94         arg_str = (
95             "{wipe} {raw} -l {log_level} --ignore-host-keys --priv {client_key}"
96             " --roster-file {roster_file} {ssh_opts} localhost {arg_str} --out=json"
97         ).format(
98             wipe=" -W" if wipe else "",
99             raw=" -r" if raw else "",
100             log_level=log_level,
101             client_key=os.path.join(RUNTIME_VARS.TMP_SSH_CONF_DIR, "client_key"),
102             roster_file=roster_file,
103             ssh_opts=ssh_opts,
104             arg_str=arg_str,
105         )
106         ret = self.run_script(
107             "salt-ssh",
108             arg_str,
109             with_retcode=with_retcode,
110             catch_stderr=catch_stderr,
111             raw=True,
112             timeout=timeout,
113             config_dir=config_dir,
114             **kwargs
115         )
116         log.debug("Result of run_ssh for command '%s %s': %s", arg_str, kwargs, ret)
117         return ret
118     def run_run(
119         self,
120         arg_str,
121         with_retcode=False,
122         catch_stderr=False,
123         asynchronous=False,
124         timeout=None,
125         config_dir=None,
126         **kwargs
127     ):
128         """
129         Execute salt-run
130         """
131         if timeout is None:
132             timeout = self.RUN_TIMEOUT
133         asynchronous = kwargs.get("async", asynchronous)
134         arg_str = "{async_flag} -t {timeout} {}".format(
135             arg_str,
136             timeout=timeout,
137             async_flag=" --async" if asynchronous else "",
138         )
139         ret = self.run_script(
140             "salt-run",
141             arg_str,
142             with_retcode=with_retcode,
143             catch_stderr=catch_stderr,
144             timeout=timeout,
145             config_dir=config_dir,
146         )
147         log.debug("Result of run_run for command '%s': %s", arg_str, ret)
148         return ret
149     def run_run_plus(self, fun, *arg, **kwargs):
150         """
151         Execute the runner function and return the return data and output in a dict
152         """
153         output = kwargs.pop("_output", None)
154         opts_overrides = kwargs.pop("opts_overrides", None)
155         ret = {"fun": fun}
156         import salt.config
157         import salt.output
158         import salt.runner
159         opts = salt.config.client_config(self.get_config_file_path("master"))
160         if opts_overrides:
161             opts.update(opts_overrides)
162         opts_arg = list(arg)
163         if kwargs:
164             opts_arg.append({"__kwarg__": True})
165             opts_arg[-1].update(kwargs)
166         opts.update({"doc": False, "fun": fun, "arg": opts_arg})
167         with RedirectStdStreams():
168             runner = salt.runner.Runner(opts)
169             ret["return"] = runner.run()
170             try:
171                 ret["jid"] = runner.jid
172             except AttributeError:
173                 ret["jid"] = None
174         opts["color"] = False
175         opts["output_file"] = io.StringIO()
176         try:
177             salt.output.display_output(ret["return"], opts=opts, out=output)
178             out = opts["output_file"].getvalue()
179             if output is None:
180                 out = out.splitlines()
181             elif output == "json":
182                 out = json.loads(out)
183             ret["out"] = out
184         finally:
185             opts["output_file"].close()
186         log.debug(
187             "Result of run_run_plus for fun '%s' with arg '%s': %s", fun, opts_arg, ret
188         )
189         return ret
190     def run_key(self, arg_str, catch_stderr=False, with_retcode=False, config_dir=None):
191         """
192         Execute salt-key
193         """
194         return self.run_script(
195             "salt-key",
196             arg_str,
197             catch_stderr=catch_stderr,
198             with_retcode=with_retcode,
199             config_dir=config_dir,
200         )
201     def run_cp(
202         self,
203         arg_str,
204         with_retcode=False,
205         catch_stderr=False,
206         timeout=None,
207         config_dir=None,
208     ):
209         """
210         Execute salt-cp
211         """
212         if timeout is None:
213             timeout = self.RUN_TIMEOUT
214         return self.run_script(
215             "salt-cp",
216             arg_str,
217             with_retcode=with_retcode,
218             catch_stderr=catch_stderr,
219             timeout=timeout,
220             config_dir=config_dir,
221         )
222     def run_call(
223         self,
224         arg_str,
225         with_retcode=False,
226         catch_stderr=False,
227         local=False,
228         timeout=None,
229         config_dir=None,
230     ):
231         if timeout is None:
232             timeout = self.RUN_TIMEOUT
233         if not config_dir:
234             config_dir = RUNTIME_VARS.TMP_MINION_CONF_DIR
235         arg_str = "{} {}".format("--local" if local else "", arg_str)
236         ret = self.run_script(
237             "salt-call",
238             arg_str,
239             with_retcode=with_retcode,
240             catch_stderr=catch_stderr,
241             config_dir=config_dir,
242         )
243         log<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.debug("Result of run_call for command '%s': %s", arg_str, ret)
244         return ret
245     def run_function(
246         self,
247         function,
248         arg=(),
249         with_retcode=False,
250         catch_stderr=False,
251         local=False,
252         timeout=RUN_TIMEOUT,
253         **kwargs
254     ):
255         """
256         Execute function with salt-call.
257         This function is added for compatibility with ModuleCase. This makes it possible to use
258         decorators like @with_system_user.
259         """
260         arg_str = "{} {} {}".</b></font>format(
261             function,
262             " ".join(str(arg_) for arg_ in arg),
263             " ".join("{}={}".format(*item) for item in kwargs.items()),
264         )
265         return self.run_call(arg_str, with_retcode, catch_stderr, local, timeout)
266     def run_cloud(self, arg_str, catch_stderr=False, timeout=None, config_dir=None):
267         """
268         Execute salt-cloud
269         """
270         if timeout is None:
271             timeout = self.RUN_TIMEOUT
272         ret = self.run_script(
273             "salt-cloud", arg_str, catch_stderr, timeout=timeout, config_dir=config_dir
274         )
275         log.debug("Result of run_cloud for command '%s': %s", arg_str, ret)
276         return ret
277     def run_spm(
278         self,
279         arg_str,
280         with_retcode=False,
281         catch_stderr=False,
282         timeout=None,
283         config_dir=None,
284     ):
285         """
286         Execute spm
287         """
288         if timeout is None:
289             timeout = self.RUN_TIMEOUT
290         ret = self.run_script(
291             "spm",
292             arg_str,
293             with_retcode=with_retcode,
294             catch_stderr=catch_stderr,
295             timeout=timeout,
296             config_dir=config_dir,
297         )
298         log.debug("Result of run_spm for command '%s': %s", arg_str, ret)
299         return ret
300     def run_script(
301         self,
302         script,
303         arg_str,
304         catch_stderr=False,
305         with_retcode=False,
306         catch_timeout=False,
307         timeout=15,
308         raw=False,
309         popen_kwargs=None,
310         log_output=None,
311         config_dir=None,
312         **kwargs
313     ):
314         """
315         Execute a script with the given argument string
316         The ``log_output`` argument is ternary, it can be True, False, or None.
317         If the value is boolean, then it forces the results to either be logged
318         or not logged. If it is None, then the return code of the subprocess
319         determines whether or not to log results.
320         """
321         import salt.utils.platform
322         script_path = self.get_script_path(script)
323         if not os.path.isfile(script_path):
324             return False
325         popen_kwargs = popen_kwargs or {}
326         python_path_env_var = os.environ.get("PYTHONPATH") or None
327         if python_path_env_var is None:
328             python_path_entries = [RUNTIME_VARS.CODE_DIR]
329         else:
330             python_path_entries = python_path_env_var.split(os.pathsep)
331             if RUNTIME_VARS.CODE_DIR in python_path_entries:
332                 python_path_entries.remove(RUNTIME_VARS.CODE_DIR)
333             python_path_entries.insert(0, RUNTIME_VARS.CODE_DIR)
334         python_path_entries.extend(sys.path[0:])
335         if "env" not in popen_kwargs:
336             popen_kwargs["env"] = os.environ.copy()
337         popen_kwargs["env"]["PYTHONPATH"] = os.pathsep.join(python_path_entries)
338         if "cwd" not in popen_kwargs:
339             popen_kwargs["cwd"] = RUNTIME_VARS.TMP
340         if salt.utils.platform.is_windows():
341             cmd = "python "
342         else:
343             cmd = "python{}.{} ".format(*sys.version_info)
344         cmd += "{} --config-dir={} {} ".format(
345             script_path, config_dir or RUNTIME_VARS.TMP_CONF_DIR, arg_str
346         )
347         if kwargs:
348             import salt.utils.json
349             for key, value in kwargs.items():
350                 cmd += "'{}={} '".format(key, salt.utils.json.dumps(value))
351         tmp_file = tempfile.SpooledTemporaryFile()
352         popen_kwargs = dict(
353             {"shell": True, "stdout": tmp_file, "universal_newlines": True},
354             **popen_kwargs
355         )
356         if catch_stderr is True:
357             popen_kwargs["stderr"] = subprocess.PIPE
358         if salt.utils.platform.is_windows():
359             close_fds = False
360         elif salt.utils.platform.is_freebsd() and sys.version_info &lt; (3, 9):
361             close_fds = False
362         else:
363             close_fds = True
364         popen_kwargs["close_fds"] = close_fds
365         if not salt.utils.platform.is_windows():
366             def detach_from_parent_group():
367                 os.setpgrp()
368             popen_kwargs["preexec_fn"] = detach_from_parent_group
369         def format_return(retcode, stdout, stderr=None, timed_out=False):
370             """
371             DRY helper to log script result if it failed, and then return the
372             desired output based on whether or not stderr was desired, and
373             wither or not a retcode was desired.
374             """
375             log_func = log.debug
376             if timed_out:
377                 log.error(
378                     "run_script timed out after %d seconds (process killed)", timeout
379                 )
380                 log_func = log.error
381             if log_output is True or timed_out or (log_output is None and retcode != 0):
382                 log_func(
383                     "run_script results for: %s %s\n"
384                     "return code: %s\n"
385                     "stdout:\n"
386                     "%s\n\n"
387                     "stderr:\n"
388                     "%s",
389                     script,
390                     arg_str,
391                     retcode,
392                     stdout,
393                     stderr,
394                 )
395             stdout = stdout or ""
396             stderr = stderr or ""
397             if not raw:
398                 stdout = stdout.splitlines()
399                 stderr = stderr.splitlines()
400             ret = [stdout]
401             if catch_stderr:
402                 ret.append(stderr)
403             if with_retcode:
404                 ret.append(retcode)
405             if catch_timeout:
406                 ret.append(timed_out)
407             return ret[0] if len(ret) == 1 else tuple(ret)
408         log.debug("Running Popen(%r, %r)", cmd, popen_kwargs)
409         process = subprocess.Popen(cmd, **popen_kwargs)
410         if timeout is not None:
411             stop_at = datetime.now() + timedelta(seconds=timeout)
412             while True:
413                 process.poll()
414                 time.sleep(0.1)
415                 if datetime.now() &lt;= stop_at:
416                     if process.returncode is not None:
417                         break
418                 else:
419                     terminate_process(process.pid, kill_children=True)
420                     return format_return(
421                         process.returncode, *process.communicate(), timed_out=True
422                     )
423         tmp_file.seek(0)
424         try:
425             out = tmp_file.read().decode(__salt_system_encoding__)
426         except (NameError, UnicodeDecodeError):
427             out = tmp_file.read().decode("utf-8")
428         if catch_stderr:
429             _, err = process.communicate()
430             if process.stdout is not None:
431                 process.stdout.close()
432             if process.stderr is not None:
433                 process.stderr.close()
434             try:
435                 return format_return(process.returncode, out, err or "")
436             finally:
437                 try:
438                     if os.path.exists(tmp_file.name):
439                         if isinstance(tmp_file.name, str):
440                             os.remove(tmp_file.name)
441                         else:
442                             tmp_file.close()
443                     process.terminate()
444                 except OSError as err:
445                     pass
446         process.communicate()
447         if process.stdout is not None:
448             process.stdout.close()
449         try:
450             return format_return(process.returncode, out)
451         finally:
452             try:
453                 if os.path.exists(tmp_file.name):
454                     if isinstance(tmp_file.name, str):
455                         os.remove(tmp_file.name)
456                     else:
457                         tmp_file.close()
458                 process.terminate()
459             except OSError as err:
460                 pass
461 class SPMTestUserInterface:
462     """
463     Test user interface to SPMClient
464     """
465     def __init__(self):
466         self._status = []
467         self._confirm = []
468         self._error = []
469     def status(self, msg):
470         self._status.append(msg)
471     def confirm(self, action):
472         self._confirm.append(action)
473     def error(self, msg):
474         self._error.append(msg)
475 class SPMCase(TestCase, AdaptedConfigurationTestCaseMixin):
476     """
477     Class for handling spm commands
478     """
479     def _spm_build_files(self, config):
480         self.formula_dir = os.path.join(
481             " ".join(config["file_roots"]["base"]), "formulas"
482         )
483         self.formula_sls_dir = os.path.join(self.formula_dir, "apache")
484         self.formula_sls = os.path.join(self.formula_sls_dir, "apache.sls")
485         self.formula_file = os.path.join(self.formula_dir, "FORMULA")
486         dirs = [self.formula_dir, self.formula_sls_dir]
487         for f_dir in dirs:
488             os.makedirs(f_dir)
489         with salt.utils.files.fopen(self.formula_sls, "w") as fp:
490             fp.write(
491                 textwrap.dedent(
492                     """\
493                      install-apache:
494                        pkg.installed:
495                          - name: apache2
496                      """
497                 )
498             )
499         with salt.utils.files.fopen(self.formula_file, "w") as fp:
500             fp.write(
501                 textwrap.dedent(
502                     """\
503                      name: apache
504                      os: RedHat, Debian, Ubuntu, Suse, FreeBSD
505                      os_family: RedHat, Debian, Suse, FreeBSD
506                      version: 201506
507                      release: 2
508                      summary: Formula for installing Apache
509                      description: Formula for installing Apache
510                      """
511                 )
512             )
513     def _spm_config(self, assume_yes=True):
514         self._tmp_spm = tempfile.mkdtemp()
515         config = self.get_temp_config(
516             "minion",
517             **{
518                 "spm_logfile": os.path.join(self._tmp_spm, "log"),
519                 "spm_repos_config": os.path.join(self._tmp_spm, "etc", "spm.repos"),
520                 "spm_cache_dir": os.path.join(self._tmp_spm, "cache"),
521                 "spm_build_dir": os.path.join(self._tmp_spm, "build"),
522                 "spm_build_exclude": ["apache/.git"],
523                 "spm_db_provider": "sqlite3",
524                 "spm_files_provider": "local",
525                 "spm_db": os.path.join(self._tmp_spm, "packages.db"),
526                 "extension_modules": os.path.join(self._tmp_spm, "modules"),
527                 "file_roots": {"base": [self._tmp_spm]},
528                 "formula_path": os.path.join(self._tmp_spm, "salt"),
529                 "pillar_path": os.path.join(self._tmp_spm, "pillar"),
530                 "reactor_path": os.path.join(self._tmp_spm, "reactor"),
531                 "assume_yes": True if assume_yes else False,
532                 "force": False,
533                 "verbose": False,
534                 "cache": "localfs",
535                 "cachedir": os.path.join(self._tmp_spm, "cache"),
536                 "spm_repo_dups": "ignore",
537                 "spm_share_dir": os.path.join(self._tmp_spm, "share"),
538             }
539         )
540         import salt.utils.yaml
541         if not os.path.isdir(config["formula_path"]):
542             os.makedirs(config["formula_path"])
543         with salt.utils.files.fopen(os.path.join(self._tmp_spm, "spm"), "w") as fp:
544             salt.utils.yaml.safe_dump(config, fp)
545         return config
546     def _spm_create_update_repo(self, config):
547         build_spm = self.run_spm("build", self.config, self.formula_dir)
548         c_repo = self.run_spm("create_repo", self.config, self.config["spm_build_dir"])
549         repo_conf_dir = self.config["spm_repos_config"] + ".d"
550         os.makedirs(repo_conf_dir)
551         with salt.utils.files.fopen(os.path.join(repo_conf_dir, "spm.repo"), "w") as fp:
552             fp.write(
553                 textwrap.dedent(
554                     """\
555                      local_repo:
556                        url: file://{}
557                      """.format(
558                         self.config["spm_build_dir"]
559                     )
560                 )
561             )
562         u_repo = self.run_spm("update_repo", self.config)
563     def _spm_client(self, config):
564         import salt.spm
565         self.ui = SPMTestUserInterface()
566         client = salt.spm.SPMClient(self.ui, config)
567         return client
568     def run_spm(self, cmd, config, arg=None):
569         client = self._spm_client(config)
570         client.run([cmd, arg])
571         client._close()
572         return self.ui._status
573 class ModuleCase(TestCase, SaltClientTestCaseMixin):
574     """
575     Execute a module function
576     """
577     def wait_for_all_jobs(self, minions=("minion", "sub_minion"), sleep=0.3):
578         """
579         Wait for all jobs currently running on the list of minions to finish
580         """
581         for minion in minions:
582             while True:
583                 ret = self.run_function(
584                     "saltutil.running", minion_tgt=minion, timeout=300
585                 )
586                 if ret:
587                     log.debug("Waiting for minion's jobs: %s", minion)
588                     time.sleep(sleep)
589                 else:
590                     break
591     def minion_run(self, _function, *args, **kw):
592         """
593         Run a single salt function on the 'minion' target and condition
594         the return down to match the behavior of the raw function call
595         """
596         return self.run_function(_function, args, **kw)
597     def run_function(
598         self,
599         function,
600         arg=(),
601         minion_tgt="minion",
602         timeout=300,
603         master_tgt=None,
604         **kwargs
605     ):
606         """
607         Run a single salt function and condition the return down to match the
608         behavior of the raw function call
609         """
610         known_to_return_none = (
611             "data.get",
612             "file.chown",
613             "file.chgrp",
614             "pkg.refresh_db",
615             "ssh.recv_known_host_entries",
616             "time.sleep",
617             "grains.delkey",
618             "grains.delval",
619         )
620         if "f_arg" in kwargs:
621             kwargs["arg"] = kwargs.pop("f_arg")
622         if "f_timeout" in kwargs:
623             kwargs["timeout"] = kwargs.pop("f_timeout")
624         client = self.client if master_tgt is None else self.clients[master_tgt]
625         log.debug(
626             "Running client.cmd(minion_tgt=%r, function=%r, arg=%r, timeout=%r,"
627             " kwarg=%r)",
628             minion_tgt,
629             function,
630             arg,
631             timeout,
632             kwargs,
633         )
634         orig = client.cmd(minion_tgt, function, arg, timeout=timeout, kwarg=kwargs)
635         if minion_tgt not in orig:
636             self.fail(
637                 "WARNING(SHOULD NOT HAPPEN #1935): Failed to get a reply "
638                 "from the minion '{}'. Command output: {}".format(minion_tgt, orig)
639             )
640         elif orig[minion_tgt] is None and function not in known_to_return_none:
641             self.fail(
642                 "WARNING(SHOULD NOT HAPPEN #1935): Failed to get '{}' from "
643                 "the minion '{}'. Command output: {}".format(function, minion_tgt, orig)
644             )
645         orig[minion_tgt] = self._check_state_return(orig[minion_tgt])
646         return orig[minion_tgt]
647     def run_state(self, function, **kwargs):
648         """
649         Run the state.single command and return the state return structure
650         """
651         ret = self.run_function("state.single", [function], **kwargs)
652         return self._check_state_return(ret)
653     def _check_state_return(self, ret):
654         if isinstance(ret, dict):
655             return ret
656         if isinstance(ret, list):
657             jids = []
658             for item in ret[:]:
659                 if not isinstance(item, str):
660                     continue
661                 match = STATE_FUNCTION_RUNNING_RE.match(item)
662                 if not match:
663                     continue
664                 jid = match.group("jid")
665                 if jid in jids:
666                     continue
667                 jids.append(jid)
668                 job_data = self.run_function("saltutil.find_job", [jid])
669                 job_kill = self.run_function("saltutil.kill_job", [jid])
670                 msg = (
671                     "A running state.single was found causing a state lock. "
672                     "Job details: '{}'  Killing Job Returned: '{}'".format(
673                         job_data, job_kill
674                     )
675                 )
676                 ret.append("[TEST SUITE ENFORCED]{}[/TEST SUITE ENFORCED]".format(msg))
677         return ret
678 class SyndicCase(TestCase, SaltClientTestCaseMixin):
679     """
680     Execute a syndic based execution test
681     """
682     _salt_client_config_file_name_ = "syndic_master"
683     def run_function(self, function, arg=(), timeout=90):
684         """
685         Run a single salt function and condition the return down to match the
686         behavior of the raw function call
687         """
688         orig = self.client.cmd("minion", function, arg, timeout=timeout)
689         if "minion" not in orig:
690             self.fail(
691                 "WARNING(SHOULD NOT HAPPEN #1935): Failed to get a reply "
692                 "from the minion. Command output: {}".format(orig)
693             )
694         return orig["minion"]
695 @pytest.mark.requires_sshd_server
696 class SSHCase(ShellCase):
697     """
698     Execute a command via salt-ssh
699     """
700     def _arg_str(self, function, arg):
701         return "{} {}".format(function, " ".join(arg))
702     def run_function(
703         self, function, arg=(), timeout=180, wipe=True, raw=False, **kwargs
704     ):
705         """
706         We use a 180s timeout here, which some slower systems do end up needing
707         """
708         ret = self.run_ssh(
709             self._arg_str(function, arg), timeout=timeout, wipe=wipe, raw=raw, **kwargs
710         )
711         log.debug(
712             "SSHCase run_function executed %s with arg %s and kwargs %s",
713             function,
714             arg,
715             kwargs,
716         )
717         log.debug("SSHCase JSON return: %s", ret)
718         import salt.utils.json
719         try:
720             return salt.utils.json.loads(ret)["localhost"]
721         except Exception:  # pylint: disable=broad-except
722             return ret
723     def custom_roster(self, new_roster, data):
724         """
725         helper method to create a custom roster to use for a ssh test
726         """
727         roster = os.path.join(RUNTIME_VARS.TMP_CONF_DIR, "roster")
728         with salt.utils.files.fopen(roster, "r") as fp_:
729             conf = salt.utils.yaml.safe_load(fp_)
730         conf["localhost"].update(data)
731         with salt.utils.files.fopen(new_roster, "w") as fp_:
732             salt.utils.yaml.safe_dump(conf, fp_)
733 class ClientCase(AdaptedConfigurationTestCaseMixin, TestCase):
734     """
735     A base class containing relevant options for starting the various Salt
736     Python API entrypoints
737     """
738     def get_opts(self):
739         import salt.config
740         return salt.config.client_config(self.get_config_file_path("master"))
741     def mkdir_p(self, path):
742         try:
743             os.makedirs(path)
744         except OSError as exc:  # Python &gt;2.5
745             if exc.errno == errno.EEXIST and os.path.isdir(path):
746                 pass
747             else:
748                 raise
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
