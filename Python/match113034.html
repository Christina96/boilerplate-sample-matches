<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for versions.py &amp; case.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for versions.py &amp; case.py
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>versions.py (5.3452115%)<th>case.py (2.1582735%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(325-334)<td><a href="#" name="0">(275-294)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(14-28)<td><a href="#" name="1">(24-38)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>versions.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import datetime
2 import inspect
3 import logging
4 import numbers
5 import sys
6 import warnings
7 from distutils.version import LooseVersion as _LooseVersion
8 from distutils.version import StrictVersion as _StrictVersion
9 import salt.version
10 log = logging.getLogger(</b></font>__name__)
11 class StrictVersion(_StrictVersion):
12     def parse(self, vstring):
13         _StrictVersion.parse(self, vstring)
14     def _cmp(self, other):
15         if isinstance(other, str):
16             other = StrictVersion(other)
17         return _StrictVersion._cmp(self, other)
18 class LooseVersion(_LooseVersion):
19     def parse(self, vstring):
20         _LooseVersion.parse(self, vstring)
21         self._str_version = [
22             str(vp).zfill(8) if isinstance(vp, int) else vp for vp in self.version
23         ]
24     def _cmp(self, other):
25         if isinstance(other, str):
26             other = LooseVersion(other)
27         string_in_version = False
28         for part in self.version + other.version:
29             if not isinstance(part, int):
30                 string_in_version = True
31                 break
32         if string_in_version is False:
33             return _LooseVersion._cmp(self, other)
34         if self._str_version == other._str_version:
35             return 0
36         if self._str_version &lt; other._str_version:
37             return -1
38         if self._str_version &gt; other._str_version:
39             return 1
40 def _format_warning(message, category, filename, lineno, line=None):
41     return "{}:{}: {}: {}\n".format(filename, lineno, category.__name__, message)
42 def warn_until(
43     version,
44     message,
45     category=DeprecationWarning,
46     stacklevel=None,
47     _version_info_=None,
48     _dont_call_warnings=False,
49 ):
50     if isinstance(version, salt.version.SaltVersion):
51         version = salt.version.SaltStackVersion(*version.info)
52     elif isinstance(version, int):
53         version = salt.version.SaltStackVersion(version)
54     elif isinstance(version, tuple):
55         version = salt.version.SaltStackVersion(*version)
56     elif isinstance(version, str):
57         if version.lower() not in salt.version.SaltStackVersion.LNAMES:
58             raise RuntimeError(
59                 "Incorrect spelling for the release name in the warn_utils "
60                 "call. Expecting one of these release names: {}".format(
61                     [vs.name for vs in salt.version.SaltVersionsInfo.versions()]
62                 )
63             )
64         version = salt.version.SaltStackVersion.from_name(version)
65     elif not isinstance(version, salt.version.SaltStackVersion):
66         raise RuntimeError(
67             "The 'version' argument should be passed as a tuple, integer, string or "
68             "an instance of 'salt.version.SaltVersion' or "
69             "'salt.version.SaltStackVersion'."
70         )
71     if stacklevel is None:
72         stacklevel = 2
73     if _version_info_ is None:
74         _version_info_ = salt.version.__version_info__
75     _version_ = salt.version.SaltStackVersion(*_version_info_)
76     if _version_ &gt;= version:
77         caller = inspect.getframeinfo(sys._getframe(stacklevel - 1))
78         raise RuntimeError(
79             "The warning triggered on filename '{filename}', line number "
80             "{lineno}, is supposed to be shown until version "
81             "{until_version} is released. Current version is now "
82             "{salt_version}. Please remove the warning.".format(
83                 filename=caller.filename,
84                 lineno=caller.lineno,
85                 until_version=version.formatted_version,
86                 salt_version=_version_.formatted_version,
87             ),
88         )
89     if _dont_call_warnings is False:
90         warnings.warn(
91             message.format(version=version.formatted_version),
92             category,
93             stacklevel=stacklevel,
94         )
95 def warn_until_date(
96     date,
97     message,
98     category=DeprecationWarning,
99     stacklevel=None,
100     _current_date=None,
101     _dont_call_warnings=False,
102 ):
103     _strptime_fmt = "%Y%m%d"
104     if not isinstance(date, (str, datetime.date, datetime.datetime)):
105         raise RuntimeError(
106             "The 'date' argument should be passed as a 'datetime.date()' or "
107             "'datetime.datetime()' objects or as string parserable by "
108             "'datetime.datetime.strptime()' with the following format '{}'.".format(
109                 _strptime_fmt
110             )
111         )
112     elif isinstance(date, str):
113         date = datetime.datetime.strptime(date, _strptime_fmt)
114     if isinstance(date, datetime.datetime):
115         date = date.date()
116     if stacklevel is None:
117         stacklevel = 2
118     today = _current_date or datetime.datetime.utcnow().date()
119     if today &gt;= date:
120         caller = inspect.getframeinfo(sys._getframe(stacklevel - 1))
121         raise RuntimeError(
122             "{message} This warning(now exception) triggered on "
123             "filename '{filename}', line number {lineno}, is "
124             "supposed to be shown until {date}. Today is {today}. "
125             "Please remove the warning.".format(
126                 message=message.format(date=date.isoformat(), today=today.isoformat()),
127                 filename=caller.filename,
128                 lineno=caller.lineno,
129                 date=date.isoformat(),
130                 today=today.isoformat(),
131             ),
132         )
133     if _dont_call_warnings is False:
134         warnings.warn(
135             message.format(date=date.isoformat(), today=today.isoformat()),
136             category,
137             stacklevel=stacklevel,
138         )
139 def kwargs_warn_until(
140     kwargs,
141     version,
142     category=DeprecationWarning,
143     stacklevel=None,
144     _version_info_=None,
145     _dont_call_warnings=False,
146 ):
147     if not isinstance(version, (tuple, str, salt.version.SaltStackVersion)):
148         raise RuntimeError(
149             "The 'version' argument should be passed as a tuple, string or "
150             "an instance of 'salt.version.SaltStackVersion'."
151         )
152     elif isinstance(version, tuple):
153         version = salt.version.SaltStackVersion(*version)
154     elif isinstance(version, str):
155         version = salt.version.SaltStackVersion.from_name(version)
156     if stacklevel is None:
157         stacklevel = 3
158     if _version_info_ is None:
159         _version_info_ = salt.version.__version_info__
160     _version_ = salt.version.SaltStackVersion(*_version_info_)
161     if kwargs or _version_.info &gt;= version.info:
162         arg_names = ", ".join("'{}'".format(key) for key in kwargs)
163         warn_until(
164             version,
165             message=(
166                 "The following parameter(s) have been deprecated and "
167                 "will be removed in '{}': {}.".format(version.string, arg_names)
168             ),
169             category=category,
170             stacklevel=stacklevel,
171             _version_info_=_version_.info,
172             _dont_call_warnings=_dont_call_warnings,
173         )
174 def version_cmp(pkg1, pkg2, ignore_epoch=False):
175     normalize = lambda x: str(x).split(":", 1)[-1] if ignore_epoch else str(x)
176     pkg1 = normalize(pkg1)
177     pkg2 = normalize(pkg2)
178     try:
179         if LooseVersion(pkg1) &lt; LooseVersion(pkg2):
180             return -1
181         elif LooseVersion(pkg1) == LooseVersion(pkg2):
182             return 0
183 <a name="0"></a>        elif LooseVersion(pkg1) &gt; LooseVersion(pkg2):
184             return 1
185     except Exception as exc:  # pylint: disable=broad-except
186         log<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.exception(exc)
187     return None
188 def compare(ver1="", oper="==", ver2="", cmp_func=None, ignore_epoch=False):
189     cmp_map = {"&lt;"</b></font>: (-1,), "&lt;=": (-1, 0), "==": (0,), "&gt;=": (0, 1), "&gt;": (1,)}
190     if oper not in ("!=",) and oper not in cmp_map:
191         log.error("Invalid operator '%s' for version comparison", oper)
192         return False
193     if cmp_func is None:
194         cmp_func = version_cmp
195     cmp_result = cmp_func(ver1, ver2, ignore_epoch=ignore_epoch)
196     if cmp_result is None:
197         return False
198     if not isinstance(cmp_result, numbers.Integral):
199         log.error("The version comparison function did not return an integer/long.")
200         return False
201     if oper == "!=":
202         return cmp_result not in cmp_map["=="]
203     else:
204         if cmp_result &lt; -1:
205             cmp_result = -1
206         elif cmp_result &gt; 1:
207             cmp_result = 1
208         return cmp_result in cmp_map[oper]
209 def check_boto_reqs(
210     boto_ver=None, boto3_ver=None, botocore_ver=None, check_boto=True, check_boto3=True
211 ):
212     if check_boto is True:
213         try:
214             import boto
215             has_boto = True
216         except ImportError:
217             has_boto = False
218         if boto_ver is None:
219             boto_ver = "2.0.0"
220         if not has_boto or version_cmp(boto.__version__, boto_ver) == -1:
221             return False, "A minimum version of boto {} is required.".format(boto_ver)
222     if check_boto3 is True:
223         try:
224             import boto3
225             import botocore
226             has_boto3 = True
227         except ImportError:
228             has_boto3 = False
229         if boto3_ver is None:
230             boto3_ver = "1.2.6"
231         if botocore_ver is None:
232             botocore_ver = "1.3.23"
233         if not has_boto3 or version_cmp(boto3.__version__, boto3_ver) == -1:
234             return (
235                 False,
236                 "A minimum version of boto3 {} is required.".format(boto3_ver),
237             )
238         elif version_cmp(botocore.__version__, botocore_ver) == -1:
239             return (
240                 False,
241                 "A minimum version of botocore {} is required".format(botocore_ver),
242             )
243     return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>case.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import errno
2 import io
3 import json
4 import logging
5 import os
6 import re
7 import subprocess
8 import sys
9 <a name="1"></a>import tempfile
10 import textwrap
11 import time
12 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from datetime import datetime, timedelta
13 import pytest
14 import salt.utils.files
15 from saltfactories.utils.processes import terminate_process
16 from tests.support.cli_scripts import ScriptPathMixin
17 from tests.support.helpers import RedirectStdStreams
18 from tests.support.mixins import (  # pylint: disable=unused-import
19     AdaptedConfigurationTestCaseMixin,
20     SaltClientTestCaseMixin,
21 )
22 from tests.support.runtests import RUNTIME_VARS
23 from tests.support.unit import TestCase
24 STATE_FUNCTION_RUNNING_RE = re.compile(</b></font>
25     r"""The function (?:"|')(?P&lt;state_func&gt;.*)(?:"|') is running as PID """
26     r"(?P&lt;pid&gt;[\d]+) and was started at (?P&lt;date&gt;.*) with jid (?P&lt;jid&gt;[\d]+)"
27 )
28 log = logging.getLogger(__name__)
29 class ShellCase(TestCase, AdaptedConfigurationTestCaseMixin, ScriptPathMixin):
30     RUN_TIMEOUT = 30
31     def run_salt(
32         self,
33         arg_str,
34         with_retcode=False,
35         catch_stderr=False,
36         timeout=None,
37         popen_kwargs=None,
38         config_dir=None,
39     ):
40         r'''
41         Run the ``salt`` CLI tool with the provided arguments
42         .. code-block:: python
43             class MatchTest(ShellCase):
44                 def test_list(self):
45                     data = self.run_salt('-L minion test.ping')
46                     data = '\n'.join(data)
47                     self.assertIn('minion', data)
48         log<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.debug("Result of run_call for command '%s': %s", arg_str, ret)
49         return ret
50     def run_function(
51         self,
52         function,
53         arg=(),
54         with_retcode=False,
55         catch_stderr=False,
56         local=False,
57         timeout=RUN_TIMEOUT,
58         **kwargs
59     ):
60         arg_str = "{} {} {}".</b></font>format(
61             function,
62             " ".join(str(arg_) for arg_ in arg),
63             " ".join("{}={}".format(*item) for item in kwargs.items()),
64         )
65         return self.run_call(arg_str, with_retcode, catch_stderr, local, timeout)
66     def run_cloud(self, arg_str, catch_stderr=False, timeout=None, config_dir=None):
67         if timeout is None:
68             timeout = self.RUN_TIMEOUT
69         ret = self.run_script(
70             "salt-cloud", arg_str, catch_stderr, timeout=timeout, config_dir=config_dir
71         )
72         log.debug("Result of run_cloud for command '%s': %s", arg_str, ret)
73         return ret
74     def run_spm(
75         self,
76         arg_str,
77         with_retcode=False,
78         catch_stderr=False,
79         timeout=None,
80         config_dir=None,
81     ):
82         if timeout is None:
83             timeout = self.RUN_TIMEOUT
84         ret = self.run_script(
85             "spm",
86             arg_str,
87             with_retcode=with_retcode,
88             catch_stderr=catch_stderr,
89             timeout=timeout,
90             config_dir=config_dir,
91         )
92         log.debug("Result of run_spm for command '%s': %s", arg_str, ret)
93         return ret
94     def run_script(
95         self,
96         script,
97         arg_str,
98         catch_stderr=False,
99         with_retcode=False,
100         catch_timeout=False,
101         timeout=15,
102         raw=False,
103         popen_kwargs=None,
104         log_output=None,
105         config_dir=None,
106         **kwargs
107     ):
108         import salt.utils.platform
109         script_path = self.get_script_path(script)
110         if not os.path.isfile(script_path):
111             return False
112         popen_kwargs = popen_kwargs or {}
113         python_path_env_var = os.environ.get("PYTHONPATH") or None
114         if python_path_env_var is None:
115             python_path_entries = [RUNTIME_VARS.CODE_DIR]
116         else:
117             python_path_entries = python_path_env_var.split(os.pathsep)
118             if RUNTIME_VARS.CODE_DIR in python_path_entries:
119                 python_path_entries.remove(RUNTIME_VARS.CODE_DIR)
120             python_path_entries.insert(0, RUNTIME_VARS.CODE_DIR)
121         python_path_entries.extend(sys.path[0:])
122         if "env" not in popen_kwargs:
123             popen_kwargs["env"] = os.environ.copy()
124         popen_kwargs["env"]["PYTHONPATH"] = os.pathsep.join(python_path_entries)
125         if "cwd" not in popen_kwargs:
126             popen_kwargs["cwd"] = RUNTIME_VARS.TMP
127         if salt.utils.platform.is_windows():
128             cmd = "python "
129         else:
130             cmd = "python{}.{} ".format(*sys.version_info)
131         cmd += "{} --config-dir={} {} ".format(
132             script_path, config_dir or RUNTIME_VARS.TMP_CONF_DIR, arg_str
133         )
134         if kwargs:
135             import salt.utils.json
136             for key, value in kwargs.items():
137                 cmd += "'{}={} '".format(key, salt.utils.json.dumps(value))
138         tmp_file = tempfile.SpooledTemporaryFile()
139         popen_kwargs = dict(
140             {"shell": True, "stdout": tmp_file, "universal_newlines": True},
141             **popen_kwargs
142         )
143         if catch_stderr is True:
144             popen_kwargs["stderr"] = subprocess.PIPE
145         if salt.utils.platform.is_windows():
146             close_fds = False
147         elif salt.utils.platform.is_freebsd() and sys.version_info &lt; (3, 9):
148             close_fds = False
149         else:
150             close_fds = True
151         popen_kwargs["close_fds"] = close_fds
152         if not salt.utils.platform.is_windows():
153             def detach_from_parent_group():
154                 os.setpgrp()
155             popen_kwargs["preexec_fn"] = detach_from_parent_group
156         def format_return(retcode, stdout, stderr=None, timed_out=False):
157             log_func = log.debug
158             if timed_out:
159                 log.error(
160                     "run_script timed out after %d seconds (process killed)", timeout
161                 )
162                 log_func = log.error
163             if log_output is True or timed_out or (log_output is None and retcode != 0):
164                 log_func(
165                     "run_script results for: %s %s\n"
166                     "return code: %s\n"
167                     "stdout:\n"
168                     "%s\n\n"
169                     "stderr:\n"
170                     "%s",
171                     script,
172                     arg_str,
173                     retcode,
174                     stdout,
175                     stderr,
176                 )
177             stdout = stdout or ""
178             stderr = stderr or ""
179             if not raw:
180                 stdout = stdout.splitlines()
181                 stderr = stderr.splitlines()
182             ret = [stdout]
183             if catch_stderr:
184                 ret.append(stderr)
185             if with_retcode:
186                 ret.append(retcode)
187             if catch_timeout:
188                 ret.append(timed_out)
189             return ret[0] if len(ret) == 1 else tuple(ret)
190         log.debug("Running Popen(%r, %r)", cmd, popen_kwargs)
191         process = subprocess.Popen(cmd, **popen_kwargs)
192         if timeout is not None:
193             stop_at = datetime.now() + timedelta(seconds=timeout)
194             while True:
195                 process.poll()
196                 time.sleep(0.1)
197                 if datetime.now() &lt;= stop_at:
198                     if process.returncode is not None:
199                         break
200                 else:
201                     terminate_process(process.pid, kill_children=True)
202                     return format_return(
203                         process.returncode, *process.communicate(), timed_out=True
204                     )
205         tmp_file.seek(0)
206         try:
207             out = tmp_file.read().decode(__salt_system_encoding__)
208         except (NameError, UnicodeDecodeError):
209             out = tmp_file.read().decode("utf-8")
210         if catch_stderr:
211             _, err = process.communicate()
212             if process.stdout is not None:
213                 process.stdout.close()
214             if process.stderr is not None:
215                 process.stderr.close()
216             try:
217                 return format_return(process.returncode, out, err or "")
218             finally:
219                 try:
220                     if os.path.exists(tmp_file.name):
221                         if isinstance(tmp_file.name, str):
222                             os.remove(tmp_file.name)
223                         else:
224                             tmp_file.close()
225                     process.terminate()
226                 except OSError as err:
227                     pass
228         process.communicate()
229         if process.stdout is not None:
230             process.stdout.close()
231         try:
232             return format_return(process.returncode, out)
233         finally:
234             try:
235                 if os.path.exists(tmp_file.name):
236                     if isinstance(tmp_file.name, str):
237                         os.remove(tmp_file.name)
238                     else:
239                         tmp_file.close()
240                 process.terminate()
241             except OSError as err:
242                 pass
243 class SPMTestUserInterface:
244     def __init__(self):
245         self._status = []
246         self._confirm = []
247         self._error = []
248     def status(self, msg):
249         self._status.append(msg)
250     def confirm(self, action):
251         self._confirm.append(action)
252     def error(self, msg):
253         self._error.append(msg)
254 class SPMCase(TestCase, AdaptedConfigurationTestCaseMixin):
255     def _spm_build_files(self, config):
256         self.formula_dir = os.path.join(
257             " ".join(config["file_roots"]["base"]), "formulas"
258         )
259         self.formula_sls_dir = os.path.join(self.formula_dir, "apache")
260         self.formula_sls = os.path.join(self.formula_sls_dir, "apache.sls")
261         self.formula_file = os.path.join(self.formula_dir, "FORMULA")
262         dirs = [self.formula_dir, self.formula_sls_dir]
263         for f_dir in dirs:
264             os.makedirs(f_dir)
265         with salt.utils.files.fopen(self.formula_sls, "w") as fp:
266             fp.write(
267                 textwrap.dedent(
268                 )
269             )
270         with salt.utils.files.fopen(self.formula_file, "w") as fp:
271             fp.write(
272                 textwrap.dedent(
273                 )
274             )
275     def _spm_config(self, assume_yes=True):
276         self._tmp_spm = tempfile.mkdtemp()
277         config = self.get_temp_config(
278             "minion",
279             **{
280                 "spm_logfile": os.path.join(self._tmp_spm, "log"),
281                 "spm_repos_config": os.path.join(self._tmp_spm, "etc", "spm.repos"),
282                 "spm_cache_dir": os.path.join(self._tmp_spm, "cache"),
283                 "spm_build_dir": os.path.join(self._tmp_spm, "build"),
284                 "spm_build_exclude": ["apache/.git"],
285                 "spm_db_provider": "sqlite3",
286                 "spm_files_provider": "local",
287                 "spm_db": os.path.join(self._tmp_spm, "packages.db"),
288                 "extension_modules": os.path.join(self._tmp_spm, "modules"),
289                 "file_roots": {"base": [self._tmp_spm]},
290                 "formula_path": os.path.join(self._tmp_spm, "salt"),
291                 "pillar_path": os.path.join(self._tmp_spm, "pillar"),
292                 "reactor_path": os.path.join(self._tmp_spm, "reactor"),
293                 "assume_yes": True if assume_yes else False,
294                 "force": False,
295                 "verbose": False,
296                 "cache": "localfs",
297                 "cachedir": os.path.join(self._tmp_spm, "cache"),
298                 "spm_repo_dups": "ignore",
299                 "spm_share_dir": os.path.join(self._tmp_spm, "share"),
300             }
301         )
302         import salt.utils.yaml
303         if not os.path.isdir(config["formula_path"]):
304             os.makedirs(config["formula_path"])
305         with salt.utils.files.fopen(os.path.join(self._tmp_spm, "spm"), "w") as fp:
306             salt.utils.yaml.safe_dump(config, fp)
307         return config
308     def _spm_create_update_repo(self, config):
309         build_spm = self.run_spm("build", self.config, self.formula_dir)
310         c_repo = self.run_spm("create_repo", self.config, self.config["spm_build_dir"])
311         repo_conf_dir = self.config["spm_repos_config"] + ".d"
312         os.makedirs(repo_conf_dir)
313         with salt.utils.files.fopen(os.path.join(repo_conf_dir, "spm.repo"), "w") as fp:
314             fp.write(
315                 textwrap.dedent(
316                         self.config["spm_build_dir"]
317                     )
318                 )
319             )
320         u_repo = self.run_spm("update_repo", self.config)
321     def _spm_client(self, config):
322         import salt.spm
323         self.ui = SPMTestUserInterface()
324         client = salt.spm.SPMClient(self.ui, config)
325         return client
326     def run_spm(self, cmd, config, arg=None):
327         client = self._spm_client(config)
328         client.run([cmd, arg])
329         client._close()
330         return self.ui._status
331 class ModuleCase(TestCase, SaltClientTestCaseMixin):
332     def wait_for_all_jobs(self, minions=("minion", "sub_minion"), sleep=0.3):
333         for minion in minions:
334             while True:
335                 ret = self.run_function(
336                     "saltutil.running", minion_tgt=minion, timeout=300
337                 )
338                 if ret:
339                     log.debug("Waiting for minion's jobs: %s", minion)
340                     time.sleep(sleep)
341                 else:
342                     break
343     def minion_run(self, _function, *args, **kw):
344         return self.run_function(_function, args, **kw)
345     def run_function(
346         self,
347         function,
348         arg=(),
349         minion_tgt="minion",
350         timeout=300,
351         master_tgt=None,
352         **kwargs
353     ):
354         known_to_return_none = (
355             "data.get",
356             "file.chown",
357             "file.chgrp",
358             "pkg.refresh_db",
359             "ssh.recv_known_host_entries",
360             "time.sleep",
361             "grains.delkey",
362             "grains.delval",
363         )
364         if "f_arg" in kwargs:
365             kwargs["arg"] = kwargs.pop("f_arg")
366         if "f_timeout" in kwargs:
367             kwargs["timeout"] = kwargs.pop("f_timeout")
368         client = self.client if master_tgt is None else self.clients[master_tgt]
369         log.debug(
370             "Running client.cmd(minion_tgt=%r, function=%r, arg=%r, timeout=%r,"
371             " kwarg=%r)",
372             minion_tgt,
373             function,
374             arg,
375             timeout,
376             kwargs,
377         )
378         orig = client.cmd(minion_tgt, function, arg, timeout=timeout, kwarg=kwargs)
379         if minion_tgt not in orig:
380             self.fail(
381                 "WARNING(SHOULD NOT HAPPEN #1935): Failed to get a reply "
382                 "from the minion '{}'. Command output: {}".format(minion_tgt, orig)
383             )
384         elif orig[minion_tgt] is None and function not in known_to_return_none:
385             self.fail(
386                 "WARNING(SHOULD NOT HAPPEN #1935): Failed to get '{}' from "
387                 "the minion '{}'. Command output: {}".format(function, minion_tgt, orig)
388             )
389         orig[minion_tgt] = self._check_state_return(orig[minion_tgt])
390         return orig[minion_tgt]
391     def run_state(self, function, **kwargs):
392         ret = self.run_function("state.single", [function], **kwargs)
393         return self._check_state_return(ret)
394     def _check_state_return(self, ret):
395         if isinstance(ret, dict):
396             return ret
397         if isinstance(ret, list):
398             jids = []
399             for item in ret[:]:
400                 if not isinstance(item, str):
401                     continue
402                 match = STATE_FUNCTION_RUNNING_RE.match(item)
403                 if not match:
404                     continue
405                 jid = match.group("jid")
406                 if jid in jids:
407                     continue
408                 jids.append(jid)
409                 job_data = self.run_function("saltutil.find_job", [jid])
410                 job_kill = self.run_function("saltutil.kill_job", [jid])
411                 msg = (
412                     "A running state.single was found causing a state lock. "
413                     "Job details: '{}'  Killing Job Returned: '{}'".format(
414                         job_data, job_kill
415                     )
416                 )
417                 ret.append("[TEST SUITE ENFORCED]{}[/TEST SUITE ENFORCED]".format(msg))
418         return ret
419 class SyndicCase(TestCase, SaltClientTestCaseMixin):
420     _salt_client_config_file_name_ = "syndic_master"
421     def run_function(self, function, arg=(), timeout=90):
422         orig = self.client.cmd("minion", function, arg, timeout=timeout)
423         if "minion" not in orig:
424             self.fail(
425                 "WARNING(SHOULD NOT HAPPEN #1935): Failed to get a reply "
426                 "from the minion. Command output: {}".format(orig)
427             )
428         return orig["minion"]
429 @pytest.mark.requires_sshd_server
430 class SSHCase(ShellCase):
431     def _arg_str(self, function, arg):
432         return "{} {}".format(function, " ".join(arg))
433     def run_function(
434         self, function, arg=(), timeout=180, wipe=True, raw=False, **kwargs
435     ):
436         ret = self.run_ssh(
437             self._arg_str(function, arg), timeout=timeout, wipe=wipe, raw=raw, **kwargs
438         )
439         log.debug(
440             "SSHCase run_function executed %s with arg %s and kwargs %s",
441             function,
442             arg,
443             kwargs,
444         )
445         log.debug("SSHCase JSON return: %s", ret)
446         import salt.utils.json
447         try:
448             return salt.utils.json.loads(ret)["localhost"]
449         except Exception:  # pylint: disable=broad-except
450             return ret
451     def custom_roster(self, new_roster, data):
452         roster = os.path.join(RUNTIME_VARS.TMP_CONF_DIR, "roster")
453         with salt.utils.files.fopen(roster, "r") as fp_:
454             conf = salt.utils.yaml.safe_load(fp_)
455         conf["localhost"].update(data)
456         with salt.utils.files.fopen(new_roster, "w") as fp_:
457             salt.utils.yaml.safe_dump(conf, fp_)
458 class ClientCase(AdaptedConfigurationTestCaseMixin, TestCase):
459     def get_opts(self):
460         import salt.config
461         return salt.config.client_config(self.get_config_file_path("master"))
462     def mkdir_p(self, path):
463         try:
464             os.makedirs(path)
465         except OSError as exc:  # Python &gt;2.5
466             if exc.errno == errno.EEXIST and os.path.isdir(path):
467                 pass
468             else:
469                 raise
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
