<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_gentoo_service.py &amp; test_virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_gentoo_service.py &amp; test_virt_1.py
      </h3>
<h1 align="center">
        3.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_gentoo_service.py (14.976303%)<th>test_virt_1.py (1.8811764%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(101-106)<td><a href="#" name="0">(1022-1026)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(118-121)<td><a href="#" name="1">(1868-1872)</a><td align="center"><font color="#aa0000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(493-499)<td><a href="#" name="2">(1724-1727)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(132-135)<td><a href="#" name="3">(1002-1007)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(75-78)<td><a href="#" name="4">(986-991)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(61-64)<td><a href="#" name="5">(6420-6422)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(46-49)<td><a href="#" name="6">(970-975)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(502-508)<td><a href="#" name="7">(3617-3621)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(258-267)<td><a href="#" name="8">(2060-2064)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(32-35)<td><a href="#" name="9">(764-776)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(21-23)<td><a href="#" name="10">(6638-6641)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_gentoo_service.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.modules.gentoo_service as gentoo_service
2 from tests.support.mixins import LoaderModuleMockMixin
3 from tests.support.mock import MagicMock, call, patch
4 from tests.support.unit import TestCase
5 class GentooServicesTestCase(TestCase, LoaderModuleMockMixin):
6     def setup_loader_modules(self):
7         return {gentoo_service: {}}
8     def test_service_list_parser(self):
9         <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
10             self.assertFalse(gentoo_service.get_enabled())
11         mock.assert_called_once_with(</b></font>"rc-update -v show")
12     def test_get_enabled_single_runlevel(self):
13 <a name="9"></a>        service_name = "name"
14         runlevels = ["default"]
15         mock = MagicMock(return_value=self.__services({service_name: runlevels}))
16         with patch<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dict(gentoo_service.__salt__, {"cmd.run": mock}):
17             enabled_services = gentoo_service.get_enabled()
18             self.assertTrue(service_name in enabled_services)
19             self.assertEqual(enabled_services[</b></font>service_name], runlevels)
20     def test_get_enabled_filters_out_disabled_services(self):
21         service_name = "name"
22         runlevels = ["default"]
23 <a name="6"></a>        disabled_service = "disabled"
24         service_list = self.__services({service_name: runlevels, disabled_service: []})
25         mock <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value=service_list)
26         with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
27             enabled_services = gentoo_service.get_enabled()
28             self.assertEqual(len(</b></font>enabled_services), 1)
29             self.assertTrue(service_name in enabled_services)
30             self.assertEqual(enabled_services[service_name], runlevels)
31     def test_get_enabled_with_multiple_runlevels(self):
32         service_name = "name"
33 <a name="5"></a>        runlevels = ["non-default", "default"]
34         mock = MagicMock(return_value=self.__services({service_name: runlevels}))
35         with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
36             enabled_services = gentoo_service<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get_enabled()
37             self.assertTrue(service_name in enabled_services)
38             self.assertEqual(enabled_services[service_name][0], runlevels[1])
39             self.assertEqual(enabled_services[service_name][1], runlevels[</b></font>0])
40     def test_get_disabled(self):
41         disabled_service = "disabled"
42         enabled_service = "enabled"
43 <a name="4"></a>        service_list = self.__services(
44             {disabled_service: [], enabled_service: ["default"]}
45         )
46         mock <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value=service_list)
47         with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
48             disabled_services = gentoo_service.get_disabled()
49             self.assertTrue(len(</b></font>disabled_services), 1)
50             self.assertTrue(disabled_service in disabled_services)
51     def test_available(self):
52         disabled_service = "disabled"
53         enabled_service = "enabled"
54         multilevel_service = "multilevel"
55         missing_service = "missing"
56         shutdown_service = "shutdown"
57         service_list = self.__services(
58             {
59                 disabled_service: [],
60                 enabled_service: ["default"],
61                 multilevel_service: ["default", "shutdown"],
62                 shutdown_service: ["shutdown"],
63 <a name="0"></a>            }
64         )
65         mock = MagicMock(return_value=service_list)
66         with patch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dict(gentoo_service.__salt__, {"cmd.run": mock}):
67             self.assertTrue(gentoo_service.available(enabled_service))
68             self.assertTrue(gentoo_service.available(multilevel_service))
69             self.assertTrue(gentoo_service.available(disabled_service))
70             self.assertTrue(gentoo_service.available(shutdown_service))
71             self.assertFalse(gentoo_service.available(</b></font>missing_service))
72     def test_missing(self):
73         disabled_service = "disabled"
74         enabled_service = "enabled"
75         service_list = self.__services(
76 <a name="1"></a>            {disabled_service: [], enabled_service: ["default"]}
77         )
78         mock = MagicMock(return_value=service_list)
79         with patch<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dict(gentoo_service.__salt__, {"cmd.run": mock}):
80             self.assertFalse(gentoo_service.missing(enabled_service))
81             self.assertFalse(gentoo_service.missing(disabled_service))
82             self.assertTrue(gentoo_service.missing(</b></font>"missing"))
83     def test_getall(self):
84         disabled_service = "disabled"
85         enabled_service = "enabled"
86 <a name="3"></a>        service_list = self.__services(
87             {disabled_service: [], enabled_service: ["default"]}
88         )
89         mock <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value=service_list)
90         with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
91             all_services = gentoo_service.get_all()
92             self.assertEqual(len(</b></font>all_services), 2)
93             self.assertTrue(disabled_service in all_services)
94             self.assertTrue(enabled_service in all_services)
95     def test_start(self):
96         mock = MagicMock(return_value=True)
97         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
98             self.assertFalse(gentoo_service.start("name"))
99         mock.assert_called_once_with(
100             "/etc/init.d/name start", ignore_retcode=False, python_shell=False
101         )
102     def test_stop(self):
103         mock = MagicMock(return_value=True)
104         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
105             self.assertFalse(gentoo_service.stop("name"))
106         mock.assert_called_once_with(
107             "/etc/init.d/name stop", ignore_retcode=False, python_shell=False
108         )
109     def test_restart(self):
110         mock = MagicMock(return_value=True)
111         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
112             self.assertFalse(gentoo_service.restart("name"))
113         mock.assert_called_once_with(
114             "/etc/init.d/name restart", ignore_retcode=False, python_shell=False
115         )
116     def test_reload_(self):
117         mock = MagicMock(return_value=True)
118         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
119             self.assertFalse(gentoo_service.reload_("name"))
120         mock.assert_called_once_with(
121             "/etc/init.d/name reload", ignore_retcode=False, python_shell=False
122         )
123     def test_zap(self):
124         mock = MagicMock(return_value=True)
125         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
126             self.assertFalse(gentoo_service.zap("name"))
127         mock.assert_called_once_with(
128             "/etc/init.d/name zap", ignore_retcode=False, python_shell=False
129         )
130     def test_status(self):
131         mock = MagicMock(return_value=True)
132         with patch.dict(gentoo_service.__salt__, {"status.pid": mock}):
133             self.assertTrue(gentoo_service.status("name", 1))
134         mock = MagicMock(return_value=0)
135         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
136             self.assertTrue(gentoo_service.status("name"))
137         mock.assert_called_once_with(
138             "/etc/init.d/name status", ignore_retcode=True, python_shell=False
139         )
140         mock = MagicMock(return_value=1)
141         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
142             self.assertFalse(gentoo_service.status("name"))
143         mock.assert_called_once_with(
144             "/etc/init.d/name status", ignore_retcode=True, python_shell=False
145         )
146         mock = MagicMock(return_value=3)
147         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
148             self.assertFalse(gentoo_service.status("name"))
149         mock.assert_called_once_with(
150             "/etc/init.d/name status", ignore_retcode=True, python_shell=False
151         )
152         mock = MagicMock(return_value=32)
153         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
154             self.assertFalse(gentoo_service.status("name"))
155         mock.assert_called_once_with(
156             "/etc/init.d/name status", ignore_retcode=True, python_shell=False
157         )
158     def test_enable(self):
159         rc_update_mock = MagicMock(return_value=0)
160         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
161             self.assertTrue(gentoo_service.enable("name"))
162         rc_update_mock.assert_called_once_with(
163             "rc-update add name", ignore_retcode=False, python_shell=False
164         )
165         rc_update_mock.reset_mock()
166         service_name = "name"
167         runlevels = ["l1"]
168         level_list_mock = MagicMock(
169             return_value=self.__services({service_name: runlevels})
170         )
171         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
172             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
173                 self.assertTrue(gentoo_service.enable("name", runlevels="l2"))
174 <a name="8"></a>        rc_update_mock.assert_has_calls(
175             [
176                 call(
177                     "rc-update delete name l1", ignore_retcode=False, python_shell<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=False
178                 ),
179                 call("rc-update add name l2", ignore_retcode=False, python_shell=False),
180             ]
181         )
182         rc_update_mock.reset_mock()
183         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
184             with</b></font> patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
185                 self.assertTrue(gentoo_service.enable("name", runlevels="l1"))
186         self.assertTrue(rc_update_mock.call_count == 0)
187         rc_update_mock.reset_mock()
188         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
189             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
190                 self.assertTrue(gentoo_service.enable("name", runlevels=["l1"]))
191         self.assertTrue(rc_update_mock.call_count == 0)
192         rc_update_mock.reset_mock()
193         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
194             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
195                 self.assertTrue(gentoo_service.enable("name", runlevels=["l2", "l1"]))
196         rc_update_mock.assert_called_once_with(
197             "rc-update add name l2", ignore_retcode=False, python_shell=False
198         )
199         rc_update_mock.reset_mock()
200         runlevels = ["l1", "l2"]
201         level_list_mock = MagicMock(
202             return_value=self.__services({service_name: runlevels})
203         )
204         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
205             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
206                 self.assertTrue(gentoo_service.enable("name", runlevels=["l2"]))
207         rc_update_mock.assert_called_once_with(
208             "rc-update delete name l1", ignore_retcode=False, python_shell=False
209         )
210         rc_update_mock.reset_mock()
211         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
212             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
213                 self.assertTrue(gentoo_service.enable("name", runlevels=["l1", "l3"]))
214         rc_update_mock.assert_has_calls(
215             [
216                 call(
217                     "rc-update delete name l2", ignore_retcode=False, python_shell=False
218                 ),
219                 call("rc-update add name l3", ignore_retcode=False, python_shell=False),
220             ]
221         )
222         rc_update_mock.reset_mock()
223         runlevels = ["l1", "l3", "l5"]
224         level_list_mock = MagicMock(
225             return_value=self.__services({service_name: runlevels})
226         )
227         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
228             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
229                 self.assertTrue(
230                     gentoo_service.enable("name", runlevels=["l2", "l4", "l5"])
231                 )
232         rc_update_mock.assert_has_calls(
233             [
234                 call(
235                     "rc-update delete name l1 l3",
236                     ignore_retcode=False,
237                     python_shell=False,
238                 ),
239                 call(
240                     "rc-update add name l2 l4", ignore_retcode=False, python_shell=False
241                 ),
242             ]
243         )
244         rc_update_mock.reset_mock()
245         rc_update_mock = MagicMock(return_value=1)
246         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
247             self.assertFalse(gentoo_service.enable("name"))
248         rc_update_mock.assert_called_once_with(
249             "rc-update add name", ignore_retcode=False, python_shell=False
250         )
251         rc_update_mock.reset_mock()
252         runlevels = ["l1"]
253         level_list_mock = MagicMock(
254             return_value=self.__services({service_name: runlevels})
255         )
256         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
257             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
258                 self.assertFalse(gentoo_service.enable("name", runlevels="l2"))
259         rc_update_mock.assert_called_once_with(
260             "rc-update delete name l1", ignore_retcode=False, python_shell=False
261         )
262         rc_update_mock.reset_mock()
263         rc_update_mock = MagicMock()
264         rc_update_mock.side_effect = [0, 1]
265         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
266             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
267                 self.assertFalse(gentoo_service.enable("name", runlevels="l2"))
268         rc_update_mock.assert_has_calls(
269             [
270                 call(
271                     "rc-update delete name l1", ignore_retcode=False, python_shell=False
272                 ),
273                 call("rc-update add name l2", ignore_retcode=False, python_shell=False),
274             ]
275         )
276         rc_update_mock.reset_mock()
277     def test_disable(self):
278         rc_update_mock = MagicMock(return_value=0)
279         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
280             self.assertTrue(gentoo_service.disable("name"))
281         rc_update_mock.assert_called_once_with(
282             "rc-update delete name", ignore_retcode=False, python_shell=False
283         )
284         rc_update_mock.reset_mock()
285         service_name = "name"
286         runlevels = ["l1"]
287         level_list_mock = MagicMock(
288             return_value=self.__services({service_name: runlevels})
289         )
290         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
291             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
292                 self.assertTrue(gentoo_service.disable("name", runlevels="l1"))
293         rc_update_mock.assert_called_once_with(
294             "rc-update delete name l1", ignore_retcode=False, python_shell=False
295         )
296         rc_update_mock.reset_mock()
297         runlevels = ["l1"]
298         level_list_mock = MagicMock(
299             return_value=self.__services({service_name: runlevels})
300         )
301         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
302             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
303                 self.assertTrue(gentoo_service.disable("name", runlevels=["l1"]))
304         rc_update_mock.assert_called_once_with(
305             "rc-update delete name l1", ignore_retcode=False, python_shell=False
306         )
307         rc_update_mock.reset_mock()
308         runlevels = ["l1", "l2"]
309         level_list_mock = MagicMock(
310             return_value=self.__services({service_name: runlevels})
311         )
312         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
313             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
314                 self.assertTrue(gentoo_service.disable("name", runlevels=["l1"]))
315         rc_update_mock.assert_called_once_with(
316             "rc-update delete name l1", ignore_retcode=False, python_shell=False
317         )
318         rc_update_mock.reset_mock()
319         runlevels = ["l2"]
320         level_list_mock = MagicMock(
321             return_value=self.__services({service_name: runlevels})
322         )
323         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
324             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
325                 self.assertTrue(gentoo_service.disable("name", runlevels=["l1"]))
326         self.assertTrue(rc_update_mock.call_count == 0)
327         rc_update_mock.reset_mock()
328         runlevels = ["l1", "l2", "l3"]
329         level_list_mock = MagicMock(
330             return_value=self.__services({service_name: runlevels})
331         )
332         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
333             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
334                 self.assertTrue(gentoo_service.disable("name", runlevels=["l1", "l3"]))
335         rc_update_mock.assert_called_once_with(
336             "rc-update delete name l1 l3", ignore_retcode=False, python_shell=False
337         )
338         rc_update_mock.reset_mock()
339         rc_update_mock = MagicMock(return_value=1)
340         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
341             self.assertFalse(gentoo_service.disable("name"))
342         rc_update_mock.assert_called_once_with(
343             "rc-update delete name", ignore_retcode=False, python_shell=False
344         )
345         rc_update_mock.reset_mock()
346         runlevels = ["l1"]
347         level_list_mock = MagicMock(
348             return_value=self.__services({service_name: runlevels})
349         )
350         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
351             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
352                 self.assertFalse(gentoo_service.disable("name", runlevels="l1"))
353         rc_update_mock.assert_called_once_with(
354             "rc-update delete name l1", ignore_retcode=False, python_shell=False
355         )
356         rc_update_mock.reset_mock()
357         runlevels = ["l1", "l2", "l3"]
358         level_list_mock = MagicMock(
359             return_value=self.__services({service_name: runlevels})
360         )
361         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
362             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
363                 self.assertFalse(gentoo_service.disable("name", runlevels=["l1", "l3"]))
364         rc_update_mock.assert_called_once_with(
365             "rc-update delete name l1 l3", ignore_retcode=False, python_shell=False
366         )
367         rc_update_mock.reset_mock()
368     def test_enabled(self):
369         mock = MagicMock(return_value={"name": ["default"]})
370         with patch<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.object(gentoo_service, "get_enabled", mock):
371             self.assertTrue(gentoo_service.enabled("name"))
372             self.assertTrue(gentoo_service.enabled("name", runlevels="default"))
373 <a name="7"></a>            self.assertFalse(gentoo_service.</b></font>enabled("name", runlevels="boot"))
374         mock = MagicMock(return_value={"name": ["boot", "default"]})
375         with patch<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.object(gentoo_service, "get_enabled", mock):
376             self.assertTrue(gentoo_service.enabled("name"))
377             self.assertTrue(gentoo_service.enabled("name", runlevels="default"))
378             self.</b></font>assertTrue(
379                 gentoo_service.enabled("name", runlevels=["boot", "default"])
380             )
381             self.assertFalse(
382                 gentoo_service.enabled("name", runlevels="some-other-level")
383             )
384             self.assertFalse(
385                 gentoo_service.enabled("name", runlevels=["boot", "some-other-level"])
386             )
387     def test_disabled(self):
388         mock = MagicMock(return_value=["name"])
389         with patch.object(gentoo_service, "get_disabled", mock):
390             self.assertTrue(gentoo_service.disabled("name"))
391     def __services(self, services):
392         return "\n".join(
393             [" | ".join([svc, " ".join(services[svc])]) for svc in services]
394         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import os
3 import shutil
4 import tempfile
5 import xml.etree.ElementTree as ET
6 import salt.config
7 import salt.modules.config as config
8 import salt.modules.virt as virt
9 import salt.syspaths
10 import salt.utils.yaml
11 from salt.exceptions import CommandExecutionError, SaltInvocationError
12 from tests.support.helpers import dedent
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase
16 class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
17     class virDomain(MagicMock):
18     class libvirtError(Exception):
19         def __init__(self, msg):
20             super().__init__(msg)
21             self.msg = msg
22         def get_error_message(self):
23             return self.msg
24 class VirtTestCase(TestCase, LoaderModuleMockMixin):
25     def setup_loader_modules(self):
26         self.mock_libvirt = LibvirtMock()
27         self.mock_conn = MagicMock()
28         self.mock_conn.getStoragePoolCapabilities.return_value = (
29             "&lt;storagepoolCapabilities/&gt;"
30         )
31         self.mock_libvirt.openAuth.return_value = self.mock_conn
32         self.mock_popen = MagicMock()
33         self.addCleanup(delattr, self, "mock_libvirt")
34         self.addCleanup(delattr, self, "mock_conn")
35         self.addCleanup(delattr, self, "mock_popen")
36         self.mock_subprocess = MagicMock()
37         self.mock_subprocess.return_value = (
38             self.mock_subprocess
39         )  # pylint: disable=no-member
40         self.mock_subprocess.Popen.return_value = (
41             self.mock_popen
42         )  # pylint: disable=no-member
43         loader_globals = {
44             "__salt__": {"config.get": config.get, "config.option": config.option},
45             "libvirt": self.mock_libvirt,
46             "subprocess": self.mock_subprocess,
47         }
48         return {virt: loader_globals, config: loader_globals}
49     def set_mock_vm(self, name, xml):
50         self.mock_conn.listDefinedDomains.return_value = [
51             name
52         ]  # pylint: disable=no-member
53         mock_domain = self.mock_libvirt.virDomain()
54         self.mock_conn.lookupByName.return_value = (
55             mock_domain  # pylint: disable=no-member
56         )
57         mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member
58         mock_domain.info.return_value = [
59             4,
60             2048 * 1024,
61             1024 * 1024,
62             2,
63             1234,
64         ]  # pylint: disable=no-member
65         mock_domain.ID.return_value = 1
66         mock_domain.name.return_value = name
67         return mock_domain
68     def assert_equal_unit(self, actual, expected, unit="KiB"):
69         self.assertEqual(actual.get("unit"), unit)
70         self.assertEqual(actual.text, str(expected))
71     def test_disk_profile_merge(self):
72         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
73         userdisks = [
74             {"name": "system", "image": "/path/to/image"},
75             {"name": "data", "size": 16384, "format": "raw"},
76         ]
77         disks = virt._disk_profile(self.mock_conn, "default", "kvm", userdisks, "myvm")
78         self.assertEqual(
79             [
80                 {
81                     "name": "system",
82                     "device": "disk",
83                     "size": 8192,
84                     "format": "qcow2",
85                     "model": "virtio",
86                     "filename": "myvm_system.qcow2",
87                     "image": "/path/to/image",
88                     "source_file": "{}{}myvm_system.qcow2".format(root_dir, os.sep),
89                 },
90                 {
91                     "name": "data",
92                     "device": "disk",
93                     "size": 16384,
94                     "format": "raw",
95                     "model": "virtio",
96                     "filename": "myvm_data.raw",
97                     "source_file": "{}{}myvm_data.raw".format(root_dir, os.sep),
98                 },
99             ],
100             disks,
101         )
102     def test_boot_default_dev(self):
103         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
104         nicp = virt._nic_profile("default", "kvm")
105         xml_data = virt._gen_xml(
106             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
107         )
108         root = ET.fromstring(xml_data)
109         self.assertEqual(root.find("os/boot").attrib["dev"], "hd")
110         self.assertEqual(root.find("os/type").attrib["arch"], "x86_64")
111         self.assertEqual(root.find("os/type").text, "hvm")
112     def test_boot_custom_dev(self):
113         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
114         nicp = virt._nic_profile("default", "kvm")
115         xml_data = virt._gen_xml(
116             self.mock_conn,
117             "hello",
118             1,
119             512,
120             diskp,
121             nicp,
122             "kvm",
123             "hvm",
124             "x86_64",
125             boot_dev="cdrom",
126         )
127         root = ET.fromstring(xml_data)
128         self.assertEqual(root.find("os/boot").attrib["dev"], "cdrom")
129     def test_boot_multiple_devs(self):
130         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
131         nicp = virt._nic_profile("default", "kvm")
132         xml_data = virt._gen_xml(
133             self.mock_conn,
134             "hello",
135             1,
136             512,
137             diskp,
138             nicp,
139             "kvm",
140             "hvm",
141             "x86_64",
142             boot_dev="cdrom network",
143         )
144         root = ET.fromstring(xml_data)
145         devs = root.findall(".//boot")
146         self.assertTrue(len(devs) == 2)
147     def test_gen_xml_no_nic(self):
148         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
149         nicp = virt._nic_profile("default", "kvm")
150         xml_data = virt._gen_xml(
151             self.mock_conn,
152             "hello",
153             1,
154             512,
155             diskp,
156             nicp,
157             "kvm",
158             "hvm",
159             "x86_64",
160             serials=[{"type": "pty"}],
161         )
162         root = ET.fromstring(xml_data)
163         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
164     def test_gen_xml_for_telnet_serial(self):
165         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
166         nicp = virt._nic_profile("default", "kvm")
167         xml_data = virt._gen_xml(
168             self.mock_conn,
169             "hello",
170             1,
171             512,
172             diskp,
173             nicp,
174             "kvm",
175             "hvm",
176             "x86_64",
177             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
178         )
179         root = ET.fromstring(xml_data)
180         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
181         self.assertEqual(root.find("devices/serial/source").attrib["service"], "22223")
182         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
183     def test_gen_xml_for_telnet_serial_unspecified_port(self):
184         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
185         nicp = virt._nic_profile("default", "kvm")
186         xml_data = virt._gen_xml(
187             self.mock_conn,
188             "hello",
189             1,
190             512,
191             diskp,
192             nicp,
193             "kvm",
194             "hvm",
195             "x86_64",
196             serials=[{"type": "tcp"}],
197         )
198         root = ET.fromstring(xml_data)
199         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
200         self.assertEqual(root.find("devices/serial/source").attrib["service"], "23023")
201         self.assertFalse("tls" in root.find("devices/serial/source").keys())
202         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
203     def test_gen_xml_for_chardev_types(self):
204         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
205         nicp = virt._nic_profile("default", "kvm")
206         xml_data = virt._gen_xml(
207             self.mock_conn,
208             "hello",
209             1,
210             512,
211             diskp,
212             nicp,
213             "kvm",
214             "hvm",
215             "x86_64",
216             consoles=[
217                 {"type": "pty", "path": "/dev/pts/2", "target_port": 2},
218                 {"type": "pty", "target_type": "usb-serial"},
219                 {"type": "stdio"},
220                 {"type": "file", "path": "/path/to/serial.log"},
221             ],
222             serials=[
223                 {"type": "pipe", "path": "/tmp/mypipe"},
224                 {"type": "udp", "host": "127.0.0.1", "port": 1234},
225                 {"type": "tcp", "port": 22223, "protocol": "raw", "tls": True},
226                 {"type": "unix", "path": "/path/to/socket"},
227             ],
228         )
229         root = ET.fromstring(xml_data)
230         self.assertEqual(root.find("devices/console[1]").attrib["type"], "pty")
231         self.assertEqual(
232             root.find("devices/console[1]/source").attrib["path"], "/dev/pts/2"
233         )
234         self.assertEqual(root.find("devices/console[1]/target").attrib["port"], "2")
235         self.assertEqual(root.find("devices/console[2]").attrib["type"], "pty")
236         self.assertIsNone(root.find("devices/console[2]/source"))
237         self.assertEqual(
238             root.find("devices/console[2]/target").attrib["type"], "usb-serial"
239         )
240         self.assertEqual(root.find("devices/console[3]").attrib["type"], "stdio")
241         self.assertIsNone(root.find("devices/console[3]/source"))
242         self.assertEqual(root.find("devices/console[4]").attrib["type"], "file")
243         self.assertEqual(
244             root.find("devices/console[4]/source").attrib["path"], "/path/to/serial.log"
245         )
246         self.assertEqual(root.find("devices/serial[1]").attrib["type"], "pipe")
247         self.assertEqual(
248             root.find("devices/serial[1]/source").attrib["path"], "/tmp/mypipe"
249         )
250         self.assertEqual(root.find("devices/serial[2]").attrib["type"], "udp")
251         self.assertEqual(root.find("devices/serial[2]/source").attrib["mode"], "bind")
252         self.assertEqual(
253             root.find("devices/serial[2]/source").attrib["service"], "1234"
254         )
255         self.assertEqual(
256             root.find("devices/serial[2]/source").attrib["host"], "127.0.0.1"
257         )
258         self.assertEqual(root.find("devices/serial[3]").attrib["type"], "tcp")
259         self.assertEqual(root.find("devices/serial[3]/source").attrib["mode"], "bind")
260         self.assertEqual(
261             root.find("devices/serial[3]/source").attrib["service"], "22223"
262         )
263         self.assertEqual(root.find("devices/serial[3]/source").attrib["tls"], "yes")
264         self.assertEqual(root.find("devices/serial[3]/protocol").attrib["type"], "raw")
265         self.assertEqual(root.find("devices/serial[4]").attrib["type"], "unix")
266         self.assertEqual(
267             root.find("devices/serial[4]/source").attrib["path"], "/path/to/socket"
268         )
269     def test_gen_xml_no_nic_console(self):
270         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
271         nicp = virt._nic_profile("default", "kvm")
272         xml_data = virt._gen_xml(
273             self.mock_conn,
274             "hello",
275             1,
276             512,
277             diskp,
278             nicp,
279             "kvm",
280             "hvm",
281             "x86_64",
282             consoles=[{"type": "pty"}],
283         )
284         root = ET.fromstring(xml_data)
285         self.assertEqual(root.find("devices/console").attrib["type"], "pty")
286     def test_gen_xml_for_telnet_console(self):
287         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
288         nicp = virt._nic_profile("default", "kvm")
289         xml_data = virt._gen_xml(
290             self.mock_conn,
291             "hello",
292             1,
293             512,
294             diskp,
295             nicp,
296             "kvm",
297             "hvm",
298             "x86_64",
299             consoles=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
300         )
301         root = ET.fromstring(xml_data)
302         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
303         self.assertEqual(root.find("devices/console/source").attrib["service"], "22223")
304         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
305     def test_gen_xml_for_telnet_console_unspecified_port(self):
306         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
307         nicp = virt._nic_profile("default", "kvm")
308         xml_data = virt._gen_xml(
309             self.mock_conn,
310             "hello",
311             1,
312             512,
313             diskp,
314             nicp,
315             "kvm",
316             "hvm",
317             "x86_64",
318             consoles=[{"type": "tcp"}],
319         )
320         root = ET.fromstring(xml_data)
321         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
322         self.assertEqual(root.find("devices/console/source").attrib["service"], "23023")
323         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
324     def test_gen_xml_for_serial_no_console(self):
325         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
326         nicp = virt._nic_profile("default", "kvm")
327         xml_data = virt._gen_xml(
328             self.mock_conn,
329             "hello",
330             1,
331             512,
332             diskp,
333             nicp,
334             "kvm",
335             "hvm",
336             "x86_64",
337             serials=[{"type": "pty"}],
338             consoles=[],
339         )
340         root = ET.fromstring(xml_data)
341         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
342         self.assertEqual(root.find("devices/console"), None)
343     def test_gen_xml_for_telnet_no_console(self):
344         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
345         nicp = virt._nic_profile("default", "kvm")
346         xml_data = virt._gen_xml(
347             self.mock_conn,
348             "hello",
349             1,
350             512,
351             diskp,
352             nicp,
353             "kvm",
354             "hvm",
355             "x86_64",
356             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
357             consoles=[],
358         )
359         root = ET.fromstring(xml_data)
360         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
361         self.assertEqual(root.find("devices/console"), None)
362     def test_gen_xml_nographics_default(self):
363         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
364         nicp = virt._nic_profile("default", "kvm")
365         xml_data = virt._gen_xml(
366             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
367         )
368         root = ET.fromstring(xml_data)
369         self.assertIsNone(root.find("devices/graphics"))
370     def test_gen_xml_noloader_default(self):
371         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
372         nicp = virt._nic_profile("default", "kvm")
373         xml_data = virt._gen_xml(
374             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
375         )
376         root = ET.fromstring(xml_data)
377         self.assertIsNone(root.find("os/loader"))
378     def test_gen_xml_vnc_default(self):
379         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
380         nicp = virt._nic_profile("default", "kvm")
381         xml_data = virt._gen_xml(
382             self.mock_conn,
383             "hello",
384             1,
385             512,
386             diskp,
387             nicp,
388             "kvm",
389             "hvm",
390             "x86_64",
391             graphics={
392                 "type": "vnc",
393                 "port": 1234,
394                 "tlsPort": 5678,
395                 "listen": {"type": "address", "address": "myhost"},
396             },
397         )
398         root = ET.fromstring(xml_data)
399         self.assertEqual(root.find("devices/graphics").attrib["type"], "vnc")
400         self.assertEqual(root.find("devices/graphics").attrib["autoport"], "no")
401         self.assertEqual(root.find("devices/graphics").attrib["port"], "1234")
402         self.assertFalse("tlsPort" in root.find("devices/graphics").attrib)
403         self.assertEqual(root.find("devices/graphics").attrib["listen"], "myhost")
404         self.assertEqual(root.find("devices/graphics/listen").attrib["type"], "address")
405         self.assertEqual(
406             root.find("devices/graphics/listen").attrib["address"], "myhost"
407         )
408     def test_gen_xml_memory(self):
409         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
410         nicp = virt._nic_profile("default", "kvm")
411         xml_data = virt._gen_xml(
412             self.mock_conn,
413             "hello",
414             1,
415             {
416                 "boot": "512m",
417                 "current": "256m",
418                 "max": "1g",
419                 "hard_limit": "1024",
420                 "soft_limit": "512m",
421                 "swap_hard_limit": "1g",
422                 "min_guarantee": "256m",
423                 "hugepages": [
424                     {"size": "128m"},
425                     {"nodeset": "0", "size": "256m"},
426                     {"nodeset": "1", "size": "512m"},
427                 ],
428                 "nosharepages": True,
429                 "locked": True,
430                 "source": "file",
431                 "access": "shared",
432                 "allocation": "immediate",
433                 "discard": True,
434             },
435             diskp,
436             nicp,
437             "kvm",
438             "hvm",
439             "x86_64",
440         )
441         root = ET.fromstring(xml_data)
442         self.assert_equal_unit(root.find("memory"), 512 * 1024)
443         self.assert_equal_unit(root.find("currentMemory"), 256 * 1024)
444         self.assert_equal_unit(root.find("maxMemory"), 1024 * 1024)
445         self.assertFalse("slots" in root.find("maxMemory").keys())
446         self.assert_equal_unit(root.find("memtune/hard_limit"), 1024 * 1024)
447         self.assert_equal_unit(root.find("memtune/soft_limit"), 512 * 1024)
448         self.assert_equal_unit(root.find("memtune/swap_hard_limit"), 1024 ** 2)
449         self.assert_equal_unit(root.find("memtune/min_guarantee"), 256 * 1024)
450         self.assertEqual(
451             [
452                 {"nodeset": page.get("nodeset"), "size": page.get("size")}
453                 for page in root.findall("memoryBacking/hugepages/page")
454             ],
455             [
456                 {"nodeset": None, "size": str(128 * 1024)},
457                 {"nodeset": "0", "size": str(256 * 1024)},
458                 {"nodeset": "1", "size": str(512 * 1024)},
459             ],
460         )
461         self.assertIsNotNone(root.find("memoryBacking/nosharepages"))
462         self.assertIsNotNone(root.find("memoryBacking/locked"))
463         self.assertIsNotNone(root.find("memoryBacking/discard"))
464         self.assertEqual(root.find("memoryBacking/source").get("type"), "file")
465         self.assertEqual(root.find("memoryBacking/access").get("mode"), "shared")
466         self.assertEqual(root.find("memoryBacking/allocation").get("mode"), "immediate")
467     def test_gen_xml_cpu(self):
468         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
469         nicp = virt._nic_profile("default", "kvm")
470         xml_data = virt._gen_xml(
471             self.mock_conn,
472             "hello",
473             {
474                 "maximum": 12,
475                 "placement": "static",
476                 "cpuset": "0-11",
477                 "current": 5,
478                 "mode": "custom",
479                 "match": "minimum",
480                 "check": "full",
481                 "vendor": "Intel",
482                 "model": {
483                     "name": "core2duo",
484                     "fallback": "allow",
485                     "vendor_id": "GenuineIntel",
486                 },
487                 "cache": {"level": 3, "mode": "emulate"},
488                 "features": {"lahf": "optional", "vmx": "require"},
489                 "vcpus": {
490                     0: {"enabled": True, "hotpluggable": True},
491                     1: {"enabled": False},
492                 },
493             },
494             512,
495             diskp,
496             nicp,
497             "kvm",
498             "hvm",
499             "x86_64",
500         )
501         root = ET.fromstring(xml_data)
502         self.assertEqual(root.find("vcpu").get("current"), "5")
503         self.assertEqual(root.find("vcpu").get("placement"), "static")
504         self.assertEqual(root.find("vcpu").get("cpuset"), "0-11")
505         self.assertEqual(root.find("vcpu").text, "12")
506         self.assertEqual(root.find("cpu").get("match"), "minimum")
507         self.assertEqual(root.find("cpu").get("mode"), "custom")
508         self.assertEqual(root.find("cpu").get("check"), "full")
509         self.assertEqual(root.find("cpu/vendor").text, "Intel")
510         self.assertEqual(root.find("cpu/model").text, "core2duo")
511         self.assertEqual(root.find("cpu/model").get("fallback"), "allow")
512         self.assertEqual(root.find("cpu/model").get("vendor_id"), "GenuineIntel")
513         self.assertEqual(root.find("cpu/cache").get("level"), "3")
514         self.assertEqual(root.find("cpu/cache").get("mode"), "emulate")
515         self.assertEqual(
516             {f.get("name"): f.get("policy") for f in root.findall("cpu/feature")},
517             {"lahf": "optional", "vmx": "require"},
518         )
519         self.assertEqual(
520             {
521                 v.get("id"): {
522                     "enabled": v.get("enabled"),
523                     "hotpluggable": v.get("hotpluggable"),
524                 }
525                 for v in root.findall("vcpus/vcpu")
526             },
527             {
528                 "0": {"enabled": "yes", "hotpluggable": "yes"},
529                 "1": {"enabled": "no", "hotpluggable": None},
530             },
531         )
532     def test_gen_xml_cpu_topology(self):
533         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
534         nicp = virt._nic_profile("default", "kvm")
535         xml_data = virt._gen_xml(
536             self.mock_conn,
537             "hello",
538             {"maximum": 1, "topology": {"sockets": 4, "cores": 16, "threads": 2}},
539             512,
540             diskp,
541             nicp,
542             "kvm",
543             "hvm",
544             "x86_64",
545         )
546         root = ET.fromstring(xml_data)
547         self.assertEqual(root.find("cpu/topology").get("sockets"), "4")
548         self.assertEqual(root.find("cpu/topology").get("cores"), "16")
549         self.assertEqual(root.find("cpu/topology").get("threads"), "2")
550     def test_gen_xml_cpu_numa(self):
551         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
552         nicp = virt._nic_profile("default", "kvm")
553         xml_data = virt._gen_xml(
554             self.mock_conn,
555             "hello",
556             {
557                 "maximum": 1,
558                 "numa": {
559                     0: {
560                         "cpus": "0-3",
561                         "memory": "1g",
562                         "discard": True,
563                         "distances": {0: 10, 1: 20},
564                     },
565                     1: {"cpus": "4-7", "memory": "2g", "distances": {0: 20, 1: 10}},
566                 },
567             },
568             512,
569             diskp,
570             nicp,
571             "kvm",
572             "hvm",
573             "x86_64",
574         )
575         root = ET.fromstring(xml_data)
576         cell0 = root.find("cpu/numa/cell[@id='0']")
577         self.assertEqual(cell0.get("cpus"), "0-3")
578         self.assertIsNone(cell0.get("unit"))
579         self.assertEqual(cell0.get("memory"), str(1024 ** 2))
580         self.assertEqual(cell0.get("discard"), "yes")
581         self.assertEqual(
582             {d.get("id"): d.get("value") for d in cell0.findall("distances/sibling")},
583             {"0": "10", "1": "20"},
584         )
585         cell1 = root.find("cpu/numa/cell[@id='1']")
586         self.assertEqual(cell1.get("cpus"), "4-7")
587         self.assertIsNone(cell0.get("unit"))
588         self.assertEqual(cell1.get("memory"), str(2 * 1024 ** 2))
589         self.assertFalse("discard" in cell1.keys())
590         self.assertEqual(
591             {d.get("id"): d.get("value") for d in cell1.findall("distances/sibling")},
592             {"0": "20", "1": "10"},
593         )
594     def test_gen_xml_cputune(self):
595         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
596         nicp = virt._nic_profile("default", "kvm")
597         cputune = {
598             "shares": 2048,
599             "period": 122000,
600             "quota": -1,
601             "global_period": 1000000,
602             "global_quota": -3,
603             "emulator_period": 1200000,
604             "emulator_quota": -10,
605             "iothread_period": 133000,
606             "iothread_quota": -1,
607             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
608             "emulatorpin": "1-3",
609             "iothreadpin": {1: "5-6", 2: "7-8"},
610             "vcpusched": [
611                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
612                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
613                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
614             ],
615             "iothreadsched": [
616                 {"scheduler": "idle"},
617                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1},
618             ],
619             "emulatorsched": {"scheduler": "rr", "priority": 2},
620             "cachetune": {
621                 "0-3": {
622                     0: {"level": 3, "type": "both", "size": 3},
623                     1: {"level": 3, "type": "both", "size": 3},
624                     "monitor": {1: 3, "0-3": 3},
625                 },
626                 "4-5": {"monitor": {4: 3, 5: 2}},
627 <a name="9"></a>            },
628             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
629         }
630         xml_data = virt<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._gen_xml(
631             self.mock_conn,
632             "hello",
633             {"maximum": 1, "tuning": cputune, "iothreads": 2},
634             512,
635             diskp,
636             nicp,
637             "kvm",
638             "hvm",
639             "x86_64",
640         )
641         root = ET.fromstring(xml_data)
642         self.assertEqual(root.find("cputune").</b></font>find("shares").text, "2048")
643         self.assertEqual(root.find("cputune").find("period").text, "122000")
644         self.assertEqual(root.find("cputune").find("quota").text, "-1")
645         self.assertEqual(root.find("cputune").find("global_period").text, "1000000")
646         self.assertEqual(root.find("cputune").find("global_quota").text, "-3")
647         self.assertEqual(root.find("cputune").find("emulator_period").text, "1200000")
648         self.assertEqual(root.find("cputune").find("emulator_quota").text, "-10")
649         self.assertEqual(root.find("cputune").find("iothread_period").text, "133000")
650         self.assertEqual(root.find("cputune").find("iothread_quota").text, "-1")
651         self.assertEqual(
652             root.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
653             "1-4,^2",
654         )
655         self.assertEqual(
656             root.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
657             "0,1",
658         )
659         self.assertEqual(
660             root.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
661             "2,3",
662         )
663         self.assertEqual(
664             root.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
665             "0,4",
666         )
667         self.assertEqual(
668             root.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1-3"
669         )
670         self.assertEqual(
671             root.find("cputune")
672             .find("iothreadpin[@iothread='1']")
673             .attrib.get("cpuset"),
674             "5-6",
675         )
676         self.assertEqual(
677             root.find("cputune")
678             .find("iothreadpin[@iothread='2']")
679             .attrib.get("cpuset"),
680             "7-8",
681         )
682         self.assertDictEqual(
683             {
684                 s.get("vcpus"): {
685                     "scheduler": s.get("scheduler"),
686                     "priority": s.get("priority"),
687                 }
688                 for s in root.findall("cputune/vcpusched")
689             },
690             {
691                 "0": {"scheduler": "fifo", "priority": "1"},
692                 "1": {"scheduler": "fifo", "priority": "2"},
693                 "2": {"scheduler": "idle", "priority": "3"},
694             },
695         )
696         self.assertDictEqual(
697             {
698                 s.get("iothreads"): {
699                     "scheduler": s.get("scheduler"),
700                     "priority": s.get("priority"),
701                 }
702                 for s in root.findall("cputune/iothreadsched")
703             },
704             {
705                 None: {"scheduler": "idle", "priority": None},
706                 "5-7": {"scheduler": "batch", "priority": "1"},
707             },
708         )
709         self.assertEqual(root.find("cputune/emulatorsched").get("scheduler"), "rr")
710         self.assertEqual(root.find("cputune/emulatorsched").get("priority"), "2")
711         self.assertEqual(
712             root.find("./cputune/cachetune[@vcpus='0-3']").attrib.get("vcpus"), "0-3"
713         )
714         self.assertEqual(
715             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
716                 "level"
717             ),
718             "3",
719         )
720         self.assertEqual(
721             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
722                 "type"
723             ),
724             "both",
725         )
726         self.assertEqual(
727             root.find(
728                 "./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"
729             ).attrib.get("level"),
730             "3",
731         )
732         self.assertNotEqual(
733             root.find("./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"), None
734         )
735         self.assertNotEqual(
736             root.find("./cputune/cachetune[@vcpus='4-5']").attrib.get("vcpus"), None
737         )
738         self.assertEqual(
739             root.find("./cputune/cachetune[@vcpus='4-5']/cache[@id='0']"), None
740         )
741         self.assertEqual(
742             root.find(
743                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']"
744             ).attrib.get("level"),
745             "3",
746         )
747         self.assertEqual(
748             root.find(
749                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']"
750             ).attrib.get("level"),
751             "2",
752         )
753         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='0-2']"), None)
754         self.assertEqual(
755             root.find("./cputune/memorytune[@vcpus='0-2']/node[@id='0']").attrib.get(
756                 "bandwidth"
757             ),
758             "60",
759         )
760         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='3-4']"), None)
761         self.assertEqual(
762             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='0']").attrib.get(
763                 "bandwidth"
764             ),
765             "50",
766         )
767         self.assertEqual(
768             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='1']").attrib.get(
769                 "bandwidth"
770             ),
771             "70",
772         )
773         self.assertEqual(root.find("iothreads").text, "2")
774     def test_default_disk_profile_hypervisor_esxi(self):
775         mock = MagicMock(return_value={})
776         with patch.dict(
777             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
778         ):
779             ret = virt._disk_profile(
780                 self.mock_conn, "nonexistent", "vmware", None, "test-vm"
781             )
782             self.assertTrue(len(ret) == 1)
783             found = [disk for disk in ret if disk["name"] == "system"]
784             self.assertTrue(bool(found))
785             system = found[0]
786             self.assertEqual(system["format"], "vmdk")
787             self.assertEqual(system["model"], "scsi")
788             self.assertTrue(int(system["size"]) &gt;= 1)
789     def test_default_disk_profile_hypervisor_kvm(self):
790         mock = MagicMock(side_effect=[{}, "/images/dir"])
791         with patch.dict(
792             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
793         ):
794             ret = virt._disk_profile(
795                 self.mock_conn, "nonexistent", "kvm", None, "test-vm"
796             )
797             self.assertTrue(len(ret) == 1)
798             found = [disk for disk in ret if disk["name"] == "system"]
799             self.assertTrue(bool(found))
800             system = found[0]
801             self.assertEqual(system["format"], "qcow2")
802             self.assertEqual(system["model"], "virtio")
803             self.assertTrue(int(system["size"]) &gt;= 1)
804     def test_default_disk_profile_hypervisor_xen(self):
805         mock = MagicMock(side_effect=[{}, "/images/dir"])
806         with patch.dict(
807             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
808         ):
809             ret = virt._disk_profile(
810                 self.mock_conn, "nonexistent", "xen", None, "test-vm"
811             )
812             self.assertTrue(len(ret) == 1)
813             found = [disk for disk in ret if disk["name"] == "system"]
814             self.assertTrue(bool(found))
815             system = found[0]
816             self.assertEqual(system["format"], "qcow2")
817             self.assertEqual(system["model"], "xen")
818             self.assertTrue(int(system["size"]) &gt;= 1)
819     def test_default_nic_profile_hypervisor_esxi(self):
820 <a name="6"></a>        """
821         Test virt._nic_profile() default ESXi profile
822         mock <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value={})
823         with patch.dict(
824             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
825         ):
826             ret = virt._nic_profile("nonexistent", "vmware")
827             self.assertTrue(len(</b></font>ret) == 1)
828             eth0 = ret[0]
829             self.assertEqual(eth0["name"], "eth0")
830             self.assertEqual(eth0["type"], "bridge")
831             self.assertEqual(eth0["source"], "DEFAULT")
832             self.assertEqual(eth0["model"], "e1000")
833     def test_default_nic_profile_hypervisor_kvm(self):
834 <a name="4"></a>        """
835         Test virt._nic_profile() default KVM profile
836         mock <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value={})
837         with patch.dict(
838             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
839         ):
840             ret = virt._nic_profile("nonexistent", "kvm")
841             self.assertTrue(len(</b></font>ret) == 1)
842             eth0 = ret[0]
843             self.assertEqual(eth0["name"], "eth0")
844             self.assertEqual(eth0["type"], "bridge")
845             self.assertEqual(eth0["source"], "br0")
846             self.assertEqual(eth0["model"], "virtio")
847     def test_default_nic_profile_hypervisor_xen(self):
848 <a name="3"></a>        """
849         Test virt._nic_profile() default XEN profile
850         mock <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value={})
851         with patch.dict(
852             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
853         ):
854             ret = virt._nic_profile("nonexistent", "xen")
855             self.assertTrue(len(</b></font>ret) == 1)
856             eth0 = ret[0]
857             self.assertEqual(eth0["name"], "eth0")
858             self.assertEqual(eth0["type"], "bridge")
859             self.assertEqual(eth0["source"], "br0")
860             self.assertFalse(eth0["model"])
861     def test_gen_vol_xml_esx(self):
862         xml_data = virt._gen_vol_xml("vmname/system.vmdk", 8192, format="vmdk")
863 <a name="0"></a>        root = ET.fromstring(xml_data)
864         self.assertIsNone(root.get("type"))
865         self.assertEqual(root.find("name").text, "vmname/system.vmdk")
866         self.assertEqual(root<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("capacity").attrib["unit"], "KiB")
867         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
868         self.assertEqual(root.find("allocation").text, str(0))
869         self.assertEqual(root.find("target/format").get("type"), "vmdk")
870         self.assertIsNone(</b></font>root.find("target/permissions"))
871         self.assertIsNone(root.find("target/nocow"))
872         self.assertIsNone(root.find("backingStore"))
873     def test_gen_vol_xml_file(self):
874         xml_data = virt._gen_vol_xml(
875             "myvm_system.qcow2",
876             8192,
877             format="qcow2",
878             allocation=4096,
879             type="file",
880             permissions={
881                 "mode": "0775",
882                 "owner": "123",
883                 "group": "456",
884                 "label": "sec_label",
885             },
886             backing_store={"path": "/backing/image", "format": "raw"},
887             nocow=True,
888         )
889         root = ET.fromstring(xml_data)
890         self.assertEqual(root.get("type"), "file")
891         self.assertEqual(root.find("name").text, "myvm_system.qcow2")
892         self.assertIsNone(root.find("key"))
893         self.assertIsNone(root.find("target/path"))
894         self.assertEqual(root.find("target/format").get("type"), "qcow2")
895         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
896         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
897         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
898         self.assertEqual(root.find("allocation").text, str(4096 * 1024))
899         self.assertEqual(root.find("target/permissions/mode").text, "0775")
900         self.assertEqual(root.find("target/permissions/owner").text, "123")
901         self.assertEqual(root.find("target/permissions/group").text, "456")
902         self.assertEqual(root.find("target/permissions/label").text, "sec_label")
903         self.assertIsNotNone(root.find("target/nocow"))
904         self.assertEqual(root.find("backingStore/path").text, "/backing/image")
905         self.assertEqual(root.find("backingStore/format").get("type"), "raw")
906     def test_gen_xml_for_kvm_default_profile(self):
907         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
908         nicp = virt._nic_profile("default", "kvm")
909         xml_data = virt._gen_xml(
910             self.mock_conn,
911             "hello",
912             1,
913             512,
914             diskp,
915             nicp,
916             "kvm",
917             "hvm",
918             "x86_64",
919         )
920         root = ET.fromstring(xml_data)
921         self.assertEqual(root.attrib["type"], "kvm")
922         self.assertEqual(root.find("vcpu").text, "1")
923         self.assertEqual(root.find("memory").text, str(512 * 1024))
924         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
925         disks = root.findall(".//disk")
926         self.assertEqual(len(disks), 1)
927         disk = disks[0]
928         root_dir = salt.config.DEFAULT_MINION_OPTS.get("root_dir")
929         self.assertTrue(disk.find("source").attrib["file"].startswith(root_dir))
930         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
931         self.assertEqual(disk.find("target").attrib["dev"], "vda")
932         self.assertEqual(disk.find("target").attrib["bus"], "virtio")
933         self.assertEqual(disk.find("driver").attrib["name"], "qemu")
934         self.assertEqual(disk.find("driver").attrib["type"], "qcow2")
935         interfaces = root.findall(".//interface")
936         self.assertEqual(len(interfaces), 1)
937         iface = interfaces[0]
938         self.assertEqual(iface.attrib["type"], "bridge")
939         self.assertEqual(iface.find("source").attrib["bridge"], "br0")
940         self.assertEqual(iface.find("model").attrib["type"], "virtio")
941     def test_gen_xml_for_esxi_default_profile(self):
942         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
943         nicp = virt._nic_profile("default", "vmware")
944         xml_data = virt._gen_xml(
945             self.mock_conn,
946             "hello",
947             1,
948             512,
949             diskp,
950             nicp,
951             "vmware",
952             "hvm",
953             "x86_64",
954         )
955         root = ET.fromstring(xml_data)
956         self.assertEqual(root.attrib["type"], "vmware")
957         self.assertEqual(root.find("vcpu").text, "1")
958         self.assertEqual(root.find("memory").text, str(512 * 1024))
959         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
960         disks = root.findall(".//disk")
961         self.assertEqual(len(disks), 1)
962         disk = disks[0]
963         self.assertTrue("[0]" in disk.find("source").attrib["file"])
964         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
965         self.assertEqual(disk.find("target").attrib["dev"], "sda")
966         self.assertEqual(disk.find("target").attrib["bus"], "scsi")
967         self.assertEqual(disk.find("address").attrib["unit"], "0")
968         interfaces = root.findall(".//interface")
969         self.assertEqual(len(interfaces), 1)
970         iface = interfaces[0]
971         self.assertEqual(iface.attrib["type"], "bridge")
972         self.assertEqual(iface.find("source").attrib["bridge"], "DEFAULT")
973         self.assertEqual(iface.find("model").attrib["type"], "e1000")
974     def test_gen_xml_for_esxi_custom_profile(self):
975         disks = {
976             "noeffect": [
977                 {"first": {"size": 8192, "pool": "datastore1"}},
978                 {"second": {"size": 4096, "pool": "datastore2"}},
979             ]
980         }
981         nics = {
982             "noeffect": [
983                 {"name": "eth1", "source": "ONENET"},
984                 {"name": "eth2", "source": "TWONET"},
985             ]
986         }
987         with patch.dict(
988             virt.__salt__,  # pylint: disable=no-member
989             {"config.get": MagicMock(side_effect=[disks, nics])},
990         ):
991             diskp = virt._disk_profile(
992                 self.mock_conn, "noeffect", "vmware", [], "hello"
993             )
994             nicp = virt._nic_profile("noeffect", "vmware")
995             xml_data = virt._gen_xml(
996                 self.mock_conn,
997                 "hello",
998                 1,
999                 512,
1000                 diskp,
1001                 nicp,
1002                 "vmware",
1003                 "hvm",
1004                 "x86_64",
1005             )
1006             root = ET.fromstring(xml_data)
1007             self.assertEqual(root.attrib["type"], "vmware")
1008             self.assertEqual(root.find("vcpu").text, "1")
1009             self.assertEqual(root.find("memory").text, str(512 * 1024))
1010             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1011             self.assertTrue(len(root.findall(".//disk")) == 2)
1012             self.assertTrue(len(root.findall(".//interface")) == 2)
1013     def test_gen_xml_for_kvm_custom_profile(self):
1014         disks = {
1015             "noeffect": [
1016                 {"first": {"size": 8192, "pool": "/var/lib/images"}},
1017                 {"second": {"size": 4096, "pool": "/var/lib/images"}},
1018             ]
1019         }
1020         nics = {
1021             "noeffect": [
1022                 {"name": "eth1", "source": "b2"},
1023                 {"name": "eth2", "source": "b2"},
1024             ]
1025         }
1026         with patch.dict(
1027             virt.__salt__,  # pylint: disable=no-member
1028             {"config.get": MagicMock(side_effect=[disks, nics])},
1029         ):
1030             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1031             nicp = virt._nic_profile("noeffect", "kvm")
1032             xml_data = virt._gen_xml(
1033                 self.mock_conn,
1034                 "hello",
1035                 1,
1036                 512,
1037                 diskp,
1038                 nicp,
1039                 "kvm",
1040                 "hvm",
1041                 "x86_64",
1042             )
1043             root = ET.fromstring(xml_data)
1044             self.assertEqual(root.attrib["type"], "kvm")
1045             self.assertEqual(root.find("vcpu").text, "1")
1046             self.assertEqual(root.find("memory").text, str(512 * 1024))
1047             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1048             disks = root.findall(".//disk")
1049             self.assertTrue(len(disks) == 2)
1050             self.assertEqual(disks[0].find("target").get("dev"), "vda")
1051             self.assertEqual(disks[1].find("target").get("dev"), "vdb")
1052             self.assertTrue(len(root.findall(".//interface")) == 2)
1053     def test_disk_profile_kvm_disk_pool(self):
1054         disks = {
1055             "noeffect": [
1056                 {"first": {"size": 8192, "pool": "mypool"}},
1057                 {"second": {"size": 4096}},
1058             ]
1059         }
1060         with patch.dict(
1061             virt.__salt__,
1062             {
1063                 "config.get": MagicMock(
1064                     side_effect=[
1065                         disks,
1066                         os.path.join(salt.syspaths.ROOT_DIR, "default", "path"),
1067                     ]
1068                 )
1069             },
1070         ):
1071             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1072             pools_path = (
1073                 os.path.join(salt.syspaths.ROOT_DIR, "pools", "mypool") + os.sep
1074             )
1075             default_path = (
1076                 os.path.join(salt.syspaths.ROOT_DIR, "default", "path") + os.sep
1077             )
1078             self.assertEqual(len(diskp), 2)
1079             self.assertTrue(diskp[1]["source_file"].startswith(default_path))
1080     def test_disk_profile_kvm_disk_external_image(self):
1081         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1082             diskp = virt._disk_profile(
1083                 self.mock_conn,
1084                 None,
1085                 "kvm",
1086                 [{"name": "mydisk", "source_file": "/path/to/my/image.qcow2"}],
1087                 "hello",
1088             )
1089             self.assertEqual(len(diskp), 1)
1090             self.assertEqual(diskp[0]["source_file"], "/path/to/my/image.qcow2")
1091     def test_disk_profile_cdrom_default(self):
1092         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1093             diskp = virt._disk_profile(
1094                 self.mock_conn,
1095                 None,
1096                 "kvm",
1097                 [
1098                     {
1099                         "name": "mydisk",
1100                         "device": "cdrom",
1101                         "source_file": "/path/to/my.iso",
1102                     }
1103                 ],
1104                 "hello",
1105             )
1106             self.assertEqual(len(diskp), 1)
1107             self.assertEqual(diskp[0]["model"], "ide")
1108             self.assertEqual(diskp[0]["format"], "raw")
1109     def test_disk_profile_pool_disk_type(self):
1110         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1111         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1112             &lt;pool type="disk"&gt;
1113               &lt;name&gt;test-vdb&lt;/name&gt;
1114               &lt;source&gt;
1115                 &lt;device path='/dev/vdb'/&gt;
1116               &lt;/source&gt;
1117               &lt;target&gt;
1118                 &lt;path&gt;/dev&lt;/path&gt;
1119               &lt;/target&gt;
1120             &lt;/pool&gt;
1121         """
1122         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = (
1123             []
1124         )
1125         diskp = virt._disk_profile(
1126             self.mock_conn,
1127             None,
1128             "kvm",
1129             [{"name": "mydisk", "pool": "test-vdb"}],
1130             "hello",
1131         )
1132         self.assertEqual(diskp[0]["filename"], "vdb1")
1133         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1134             "vdb1",
1135             "vdb2",
1136         ]
1137         diskp = virt._disk_profile(
1138             self.mock_conn,
1139             None,
1140             "kvm",
1141             [{"name": "mydisk", "pool": "test-vdb"}],
1142             "hello",
1143         )
1144         self.assertEqual(diskp[0]["filename"], "vdb3")
1145         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1146             "vdb1",
1147             "vdb3",
1148         ]
1149         diskp = virt._disk_profile(
1150             self.mock_conn,
1151             None,
1152             "kvm",
1153             [{"name": "mydisk", "pool": "test-vdb"}],
1154             "hello",
1155         )
1156         self.assertEqual(diskp[0]["filename"], "vdb2")
1157         diskp = virt._disk_profile(
1158             self.mock_conn,
1159             None,
1160             "kvm",
1161             [{"name": "mydisk", "pool": "test-vdb", "source_file": "vdb1"}],
1162             "hello",
1163         )
1164         self.assertEqual(diskp[0]["filename"], "vdb1")
1165     def test_gen_xml_volume(self):
1166         self.mock_conn.listStoragePools.return_value = ["default"]
1167         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1168             "&lt;pool type='dir'/&gt;"
1169         )
1170         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1171             "myvolume"
1172         ]
1173         diskp = virt._disk_profile(
1174             self.mock_conn,
1175             None,
1176             "kvm",
1177             [
1178                 {"name": "system", "pool": "default"},
1179                 {"name": "data", "pool": "default", "source_file": "myvolume"},
1180             ],
1181             "hello",
1182         )
1183         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1184             "&lt;pool type='dir'/&gt;"
1185         )
1186         nicp = virt._nic_profile(None, "kvm")
1187         xml_data = virt._gen_xml(
1188             self.mock_conn,
1189             "hello",
1190             1,
1191             512,
1192             diskp,
1193             nicp,
1194             "kvm",
1195             "hvm",
1196             "x86_64",
1197         )
1198         root = ET.fromstring(xml_data)
1199         disk = root.findall(".//disk")[0]
1200         self.assertEqual(disk.attrib["device"], "disk")
1201         self.assertEqual(disk.attrib["type"], "volume")
1202         source = disk.find("source")
1203         self.assertEqual("default", source.attrib["pool"])
1204         self.assertEqual("hello_system", source.attrib["volume"])
1205         self.assertEqual("myvolume", root.find(".//disk[2]/source").get("volume"))
1206         self.mock_conn.listStoragePools.return_value = ["test-rbd"]
1207         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1208             &lt;pool type='rbd'&gt;
1209               &lt;name&gt;test-rbd&lt;/name&gt;
1210               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1211               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1212               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1213               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1214               &lt;source&gt;
1215                 &lt;host name='ses2.tf.local'/&gt;
1216                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1217                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1218                 &lt;auth type='ceph' username='libvirt'&gt;
1219                   &lt;secret usage='pool_test-rbd'/&gt;
1220                 &lt;/auth&gt;
1221               &lt;/source&gt;
1222             &lt;/pool&gt;
1223         """
1224         self.mock_conn.getStoragePoolCapabilities.return_value = """
1225             &lt;storagepoolCapabilities&gt;
1226               &lt;pool type='rbd' supported='yes'&gt;
1227                 &lt;volOptions&gt;
1228                   &lt;defaultFormat type='raw'/&gt;
1229                   &lt;enum name='targetFormatType'&gt;
1230                   &lt;/enum&gt;
1231                 &lt;/volOptions&gt;
1232               &lt;/pool&gt;
1233             &lt;/storagepoolCapabilities&gt;
1234         """
1235         diskp = virt._disk_profile(
1236             self.mock_conn,
1237             None,
1238             "kvm",
1239             [{"name": "system", "pool": "test-rbd"}],
1240             "test-vm",
1241         )
1242         xml_data = virt._gen_xml(
1243             self.mock_conn,
1244             "hello",
1245             1,
1246             512,
1247             diskp,
1248             nicp,
1249             "kvm",
1250             "hvm",
1251             "x86_64",
1252         )
1253         root = ET.fromstring(xml_data)
1254         disk = root.findall(".//disk")[0]
1255         self.assertDictEqual(
1256             {
1257                 "type": "network",
1258                 "device": "disk",
1259                 "source": {
1260                     "protocol": "rbd",
1261                     "name": "libvirt-pool/test-vm_system",
1262                     "host": [
1263                         {"name": "ses2.tf.local"},
1264                         {"name": "ses3.tf.local", "port": "1234"},
1265                     ],
1266                     "auth": {
1267                         "username": "libvirt",
1268                         "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1269                     },
1270                 },
1271                 "target": {"dev": "vda", "bus": "virtio"},
1272                 "driver": {
1273                     "name": "qemu",
1274                     "type": "raw",
1275                     "cache": "none",
1276                     "io": "native",
1277                 },
1278             },
1279             salt.utils.xmlutil.to_dict(disk, True),
1280         )
1281         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1282             &lt;pool type='rbd'&gt;
1283               &lt;name&gt;test-rbd&lt;/name&gt;
1284               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1285               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1286               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1287               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1288               &lt;source&gt;
1289                 &lt;host name='ses2.tf.local'/&gt;
1290                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1291                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1292                 &lt;auth type='ceph' username='libvirt'&gt;
1293                   &lt;secret uuid='some-uuid'/&gt;
1294                 &lt;/auth&gt;
1295               &lt;/source&gt;
1296             &lt;/pool&gt;
1297         """
1298         self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
1299             "pool_test-rbd"
1300         )
1301         diskp = virt._disk_profile(
1302             self.mock_conn,
1303             None,
1304             "kvm",
1305             [{"name": "system", "pool": "test-rbd"}],
1306             "test-vm",
1307         )
1308         xml_data = virt._gen_xml(
1309             self.mock_conn,
1310             "hello",
1311             1,
1312             512,
1313             diskp,
1314             nicp,
1315             "kvm",
1316             "hvm",
1317             "x86_64",
1318         )
1319         root = ET.fromstring(xml_data)
1320         self.assertDictEqual(
1321             {
1322                 "username": "libvirt",
1323                 "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1324             },
1325             salt.utils.xmlutil.to_dict(root.find(".//disk/source/auth"), True),
1326         )
1327         self.mock_conn.secretLookupByUUIDString.assert_called_once_with("some-uuid")
1328         self.mock_conn.getStoragePoolCapabilities.return_value = """
1329             &lt;storagepoolCapabilities&gt;
1330               &lt;pool type='disk' supported='yes'&gt;
1331                 &lt;volOptions&gt;
1332                   &lt;defaultFormat type='none'/&gt;
1333                   &lt;enum name='targetFormatType'&gt;
1334                     &lt;value&gt;none&lt;/value&gt;
1335                     &lt;value&gt;linux&lt;/value&gt;
1336                     &lt;value&gt;fat16&lt;/value&gt;
1337                   &lt;/enum&gt;
1338                 &lt;/volOptions&gt;
1339               &lt;/pool&gt;
1340             &lt;/storagepoolCapabilities&gt;
1341         """
1342         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1343             &lt;pool type='disk'&gt;
1344               &lt;name&gt;test-vdb&lt;/name&gt;
1345               &lt;source&gt;
1346                 &lt;device path='/dev/vdb'/&gt;
1347                 &lt;format type='gpt'/&gt;
1348               &lt;/source&gt;
1349             &lt;/pool&gt;
1350         """
1351         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1352         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1353             "vdb1",
1354         ]
1355         diskp = virt._disk_profile(
1356             self.mock_conn,
1357             None,
1358             "kvm",
1359             [{"name": "system", "pool": "test-vdb"}],
1360             "test-vm",
1361         )
1362         xml_data = virt._gen_xml(
1363             self.mock_conn,
1364             "hello",
1365             1,
1366             512,
1367             diskp,
1368             nicp,
1369             "kvm",
1370             "hvm",
1371             "x86_64",
1372         )
1373         root = ET.fromstring(xml_data)
1374         disk = root.findall(".//disk")[0]
1375         self.assertEqual(disk.attrib["type"], "volume")
1376         source = disk.find("source")
1377         self.assertEqual("test-vdb", source.attrib["pool"])
1378         self.assertEqual("vdb2", source.attrib["volume"])
1379         self.assertEqual("raw", disk.find("driver").get("type"))
1380     def test_get_xml_volume_xen_dir(self):
1381         self.mock_conn.listStoragePools.return_value = ["default"]
1382         pool_mock = MagicMock()
1383         pool_mock.XMLDesc.return_value = (
1384             "&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;"
1385         )
1386         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1387         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1388         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1389         diskp = virt._disk_profile(
1390             self.mock_conn,
1391             None,
1392             "xen",
1393             [{"name": "system", "pool": "default"}],
1394             "hello",
1395         )
1396         xml_data = virt._gen_xml(
1397             self.mock_conn,
1398             "hello",
1399             1,
1400             512,
1401             diskp,
1402             [],
1403             "xen",
1404             "hvm",
1405             "x86_64",
1406         )
1407         root = ET.fromstring(xml_data)
1408         disk = root.findall(".//disk")[0]
1409         self.assertEqual(disk.attrib["type"], "file")
1410         self.assertEqual(
1411             "/path/to/images/hello_system", disk.find("source").attrib["file"]
1412         )
1413     def test_get_xml_volume_xen_block(self):
1414         self.mock_conn.listStoragePools.return_value = ["default"]
1415         pool_mock = MagicMock()
1416         pool_mock.listVolumes.return_value = ["vol01"]
1417         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1418         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1419         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1420         for pool_type in ["logical", "disk", "iscsi", "scsi"]:
1421             pool_mock.XMLDesc.return_value = "&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;".format(
1422                 pool_type
1423             )
1424             diskp = virt._disk_profile(
1425                 self.mock_conn,
1426                 None,
1427                 "xen",
1428                 [{"name": "system", "pool": "default", "source_file": "vol01"}],
1429                 "hello",
1430             )
1431             xml_data = virt._gen_xml(
1432                 self.mock_conn,
1433                 "hello",
1434                 1,
1435                 512,
1436                 diskp,
1437                 [],
1438                 "xen",
1439                 "hvm",
1440                 "x86_64",
1441             )
1442             root = ET.fromstring(xml_data)
1443             disk = root.findall(".//disk")[0]
1444             self.assertEqual(disk.attrib["type"], "block")
1445             self.assertEqual("/dev/to/vol01", disk.find("source").attrib["dev"])
1446     def test_gen_xml_cdrom(self):
1447         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1448             "&lt;pool type='dir'/&gt;"
1449         )
1450         diskp = virt._disk_profile(
1451             self.mock_conn,
1452             None,
1453             "kvm",
1454             [
1455                 {"name": "system", "pool": "default"},
1456                 {
1457                     "name": "tested",
1458                     "device": "cdrom",
1459                     "source_file": None,
1460                     "model": "ide",
1461                 },
1462                 {
1463                     "name": "remote",
1464                     "device": "cdrom",
1465                     "source_file": (
1466                         "http://myhost:8080/url/to/image?query=foo&amp;filter=bar"
1467                     ),
1468                     "model": "ide",
1469                 },
1470             ],
1471             "hello",
1472         )
1473         nicp = virt._nic_profile(None, "kvm")
1474         xml_data = virt._gen_xml(
1475             self.mock_conn,
1476             "hello",
1477             1,
1478             512,
1479             diskp,
1480             nicp,
1481             "kvm",
1482             "hvm",
1483             "x86_64",
1484         )
1485         root = ET.fromstring(xml_data)
1486 <a name="2"></a>        disk = root.findall(".//disk")[1]
1487         self.assertEqual(disk.get("type"), "file")
1488         self.assertEqual(disk.attrib["device"], "cdrom")
1489         self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertIsNone(disk.find("source"))
1490         self.assertEqual(disk.find("target").get("dev"), "hda")
1491         disk = root.findall(".//disk")[</b></font>2]
1492         self.assertEqual(disk.get("type"), "network")
1493         self.assertEqual(disk.attrib["device"], "cdrom")
1494         self.assertEqual(
1495             {
1496                 "protocol": "http",
1497                 "name": "/url/to/image",
1498                 "query": "query=foo&amp;filter=bar",
1499                 "host": {"name": "myhost", "port": "8080"},
1500             },
1501             salt.utils.xmlutil.to_dict(disk.find("source"), True),
1502         )
1503     def test_controller_for_esxi(self):
1504         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
1505         nicp = virt._nic_profile("default", "vmware")
1506         xml_data = virt._gen_xml(
1507             self.mock_conn,
1508             "hello",
1509             1,
1510             512,
1511             diskp,
1512             nicp,
1513             "vmware",
1514             "hvm",
1515             "x86_64",
1516         )
1517         root = ET.fromstring(xml_data)
1518         controllers = root.findall(".//devices/controller")
1519         self.assertTrue(len(controllers) == 1)
1520         controller = controllers[0]
1521         self.assertEqual(controller.attrib["model"], "lsilogic")
1522     def test_controller_for_kvm(self):
1523         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
1524         nicp = virt._nic_profile("default", "kvm")
1525         xml_data = virt._gen_xml(
1526             self.mock_conn,
1527             "hello",
1528             1,
1529             512,
1530             diskp,
1531             nicp,
1532             "kvm",
1533             "hvm",
1534             "x86_64",
1535         )
1536         root = ET.fromstring(xml_data)
1537         controllers = root.findall(".//devices/controller")
1538         self.assertTrue(len(controllers) == 0)
1539     def test_diff_disks(self):
1540         old_disks = ET.fromstring(
1541         ).findall("disk")
1542         new_disks = ET.fromstring(
1543         ).findall("disk")
1544         ret = virt._diff_disk_lists(old_disks, new_disks)
1545         self.assertEqual(
1546             [
1547                 disk.find("source").get("file")
1548                 if disk.find("source") is not None
1549                 else None
1550                 for disk in ret["unchanged"]
1551             ],
1552             [],
1553         )
1554         self.assertEqual(
1555             [
1556                 disk.find("source").get("file")
1557                 if disk.find("source") is not None
1558                 else None
1559                 for disk in ret["new"]
1560             ],
1561             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1562         )
1563         self.assertEqual(
1564             [disk.find("target").get("dev") for disk in ret["sorted"]],
1565             ["vda", "vdb", "vdc", "hda"],
1566         )
1567         self.assertEqual(
1568             [
1569                 disk.find("source").get("file")
1570                 if disk.find("source") is not None
1571                 else None
1572                 for disk in ret["sorted"]
1573 <a name="1"></a>            ],
1574             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1575         )
1576         self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(ret["new"][1].find("target").get("bus"), "virtio")
1577         self.assertEqual(
1578             [
1579                 disk.find("source").get("file")
1580                 if disk.find(</b></font>"source") is not None
1581                 else None
1582                 for disk in ret["deleted"]
1583             ],
1584             [
1585                 "/path/to/img0.qcow2",
1586                 "/path/to/img1.qcow2",
1587                 "/path/to/img2.qcow2",
1588                 "/path/to/img4.qcow2",
1589                 None,
1590             ],
1591         )
1592     def test_init(self):
1593         xml = """
1594 &lt;capabilities&gt;
1595   &lt;host&gt;
1596     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
1597     &lt;cpu&gt;
1598       &lt;arch&gt;x86_64&lt;/arch&gt;
1599       &lt;model&gt;Nehalem&lt;/model&gt;
1600       &lt;vendor&gt;Intel&lt;/vendor&gt;
1601       &lt;microcode version='25'/&gt;
1602       &lt;topology sockets='1' cores='4' threads='2'/&gt;
1603       &lt;feature name='vme'/&gt;
1604       &lt;feature name='ds'/&gt;
1605       &lt;feature name='acpi'/&gt;
1606       &lt;pages unit='KiB' size='4'/&gt;
1607       &lt;pages unit='KiB' size='2048'/&gt;
1608     &lt;/cpu&gt;
1609     &lt;power_management&gt;
1610       &lt;suspend_mem/&gt;
1611       &lt;suspend_disk/&gt;
1612       &lt;suspend_hybrid/&gt;
1613     &lt;/power_management&gt;
1614     &lt;migration_features&gt;
1615       &lt;live/&gt;
1616       &lt;uri_transports&gt;
1617         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
1618         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
1619       &lt;/uri_transports&gt;
1620     &lt;/migration_features&gt;
1621     &lt;topology&gt;
1622       &lt;cells num='1'&gt;
1623         &lt;cell id='0'&gt;
1624           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
1625           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
1626           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
1627           &lt;distances&gt;
1628             &lt;sibling id='0' value='10'/&gt;
1629           &lt;/distances&gt;
1630           &lt;cpus num='8'&gt;
1631             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
1632             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
1633             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
1634             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
1635             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
1636             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
1637             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
1638             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
1639           &lt;/cpus&gt;
1640         &lt;/cell&gt;
1641       &lt;/cells&gt;
1642     &lt;/topology&gt;
1643     &lt;cache&gt;
1644       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
1645     &lt;/cache&gt;
1646     &lt;secmodel&gt;
1647       &lt;model&gt;apparmor&lt;/model&gt;
1648       &lt;doi&gt;0&lt;/doi&gt;
1649     &lt;/secmodel&gt;
1650     &lt;secmodel&gt;
1651       &lt;model&gt;dac&lt;/model&gt;
1652       &lt;doi&gt;0&lt;/doi&gt;
1653       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
1654       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
1655     &lt;/secmodel&gt;
1656   &lt;/host&gt;
1657   &lt;guest&gt;
1658     &lt;os_type&gt;hvm&lt;/os_type&gt;
1659     &lt;arch name='i686'&gt;
1660       &lt;wordsize&gt;32&lt;/wordsize&gt;
1661       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
1662       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1663       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1664       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1665       &lt;domain type='qemu'/&gt;
1666       &lt;domain type='kvm'&gt;
1667         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1668         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1669         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1670         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1671       &lt;/domain&gt;
1672     &lt;/arch&gt;
1673     &lt;features&gt;
1674       &lt;cpuselection/&gt;
1675       &lt;deviceboot/&gt;
1676       &lt;disksnapshot default='on' toggle='no'/&gt;
1677       &lt;acpi default='on' toggle='yes'/&gt;
1678       &lt;apic default='on' toggle='no'/&gt;
1679       &lt;pae/&gt;
1680       &lt;nonpae/&gt;
1681     &lt;/features&gt;
1682   &lt;/guest&gt;
1683   &lt;guest&gt;
1684     &lt;os_type&gt;hvm&lt;/os_type&gt;
1685     &lt;arch name='x86_64'&gt;
1686       &lt;wordsize&gt;64&lt;/wordsize&gt;
1687       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
1688       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1689       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1690       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1691       &lt;domain type='qemu'/&gt;
1692       &lt;domain type='kvm'&gt;
1693         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1694         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1695         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1696         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1697       &lt;/domain&gt;
1698     &lt;/arch&gt;
1699     &lt;features&gt;
1700       &lt;cpuselection/&gt;
1701       &lt;deviceboot/&gt;
1702       &lt;disksnapshot default='on' toggle='no'/&gt;
1703       &lt;acpi default='on' toggle='yes'/&gt;
1704       &lt;apic default='on' toggle='no'/&gt;
1705     &lt;/features&gt;
1706   &lt;/guest&gt;
1707 &lt;/capabilities&gt;
1708         """
1709         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
1710         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
1711         defineMock = MagicMock(return_value=1)
1712         self.mock_conn.defineXML = defineMock
1713         mock_chmod = MagicMock()
1714         mock_run = MagicMock()
1715         with patch.dict(
1716             os.__dict__, {"chmod": mock_chmod, "makedirs": MagicMock()}
1717         ):  # pylint: disable=no-member
1718             with patch.dict(
1719                 virt.__salt__, {"cmd.run": mock_run}
1720             ):  # pylint: disable=no-member
1721                 virt.init(
1722                     "test vm", 2, 1234, nic=None, disk=None, seed=False, start=False
1723                 )
1724                 definition = defineMock.call_args_list[0][0][0]
1725                 self.assertFalse("&lt;interface" in definition)
1726                 self.assertFalse("&lt;disk" in definition)
1727                 defineMock.reset_mock()
1728                 mock_run.reset_mock()
1729                 boot = {
1730                     "kernel": "/root/f8-i386-vmlinuz",
1731                     "initrd": "/root/f8-i386-initrd",
1732                     "cmdline": "console=ttyS0 ks=http://example.com/f8-i386/os/",
1733                 }
1734                 retval = virt.init(
1735                     "test vm boot params",
1736                     2,
1737                     1234,
1738                     nic=None,
1739                     disk=None,
1740                     seed=False,
1741                     start=False,
1742                     boot=boot,
1743                 )
1744                 definition = defineMock.call_args_list[0][0][0]
1745                 self.assertEqual("&lt;kernel" in definition, True)
1746                 self.assertEqual("&lt;initrd" in definition, True)
1747                 self.assertEqual("&lt;cmdline" in definition, True)
1748                 self.assertEqual(retval, True)
1749                 mock_response = MagicMock()
1750                 mock_response.read <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value="filecontent")
1751                 cache_dir = tempfile.mkdtemp()
1752                 with patch.dict(virt.__dict__, {"CACHE_DIR": cache_dir}):
1753                     with</b></font> patch(
1754                         "urllib.request.urlopen",
1755                         MagicMock(return_value=mock_response),
1756                     ):
1757                         with patch(
1758                             "salt.utils.files.fopen", return_value=mock_response
1759                         ):
1760                             defineMock.reset_mock()
1761                             mock_run.reset_mock()
1762                             boot = {
1763                                 "kernel": "https://www.example.com/download/vmlinuz",
1764                                 "initrd": "",
1765                                 "cmdline": (
1766                                     "console=ttyS0 ks=http://example.com/f8-i386/os/"
1767                                 ),
1768                             }
1769                             retval = virt.init(
1770                                 "test remote vm boot params",
1771                                 2,
1772                                 1234,
1773                                 nic=None,
1774                                 disk=None,
1775                                 seed=False,
1776                                 start=False,
1777                                 boot=boot,
1778                             )
1779                             definition = defineMock.call_args_list[0][0][0]
1780                             self.assertEqual(cache_dir in definition, True)
1781                     shutil.rmtree(cache_dir)
1782                 defineMock.reset_mock()
1783                 mock_run.reset_mock()
1784                 pool_mock = MagicMock()
1785                 pool_mock.XMLDesc.return_value = '&lt;pool type="dir"/&gt;'
1786                 self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1787                 virt.init(
1788                     "test vm",
1789                     2,
1790                     1234,
1791                     nic=None,
1792                     disk=None,
1793                     disks=[
1794                         {"name": "system", "size": 10240},
1795                         {
1796                             "name": "cddrive",
1797                             "device": "cdrom",
1798                             "source_file": None,
1799                             "model": "ide",
1800                         },
1801                     ],
1802                     seed=False,
1803                     start=False,
1804                 )
1805                 definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1806                 expected_disk_path = os.path.join(root_dir, "test vm_system.qcow2")
1807                 self.assertEqual(
1808                     expected_disk_path,
1809                     definition.find("./devices/disk[1]/source").get("file"),
1810                 )
1811                 self.assertIsNone(definition.find("./devices/disk[2]/source"))
1812                 self.assertEqual(
1813                     mock_run.call_args[0][0],
1814                     'qemu-img create -f qcow2 "{}" 10240M'.format(expected_disk_path),
1815                 )
1816                 self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)
1817                 defineMock.reset_mock()
1818                 mock_run.reset_mock()
1819                 vol_mock = MagicMock()
1820                 pool_mock.storageVolLookupByName.return_value = vol_mock
1821                 pool_mock.listVolumes.return_value = ["test vm_data"]
1822                 stream_mock = MagicMock()
1823                 self.mock_conn.newStream.return_value = stream_mock
1824                 self.mock_conn.listStoragePools.return_value = ["default", "test"]
1825                 with patch.dict(
1826                     os.__dict__, {"open": MagicMock(), "close": MagicMock()}
1827                 ):
1828                     cache_mock = MagicMock()
1829                     with patch.dict(virt.__salt__, {"cp.cache_file": cache_mock}):
1830                         virt.init(
1831                             "test vm",
1832                             2,
1833                             1234,
1834                             nic=None,
1835                             disk=None,
1836                             disks=[
1837                                 {
1838                                     "name": "system",
1839                                     "size": 10240,
1840                                     "image": "/path/to/image",
1841                                     "pool": "test",
1842                                 },
1843                                 {"name": "data", "size": 10240, "pool": "default"},
1844                                 {
1845                                     "name": "test",
1846                                     "size": 1024,
1847                                     "pool": "default",
1848                                     "format": "qcow2",
1849                                     "backing_store_path": "/backing/path",
1850                                     "backing_store_format": "raw",
1851                                 },
1852                             ],
1853                             seed=False,
1854                             start=False,
1855                         )
1856                         definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1857                         self.assertTrue(
1858                             all(
1859                                 [
1860                                     disk.get("type") == "volume"
1861                                     for disk in definition.findall("./devices/disk")
1862                                 ]
1863                             )
1864                         )
1865                         self.assertEqual(
1866                             ["test", "default", "default"],
1867                             [
1868                                 src.get("pool")
1869                                 for src in definition.findall("./devices/disk/source")
1870                             ],
1871                         )
1872                         self.assertEqual(
1873                             ["test vm_system", "test vm_data", "test vm_test"],
1874                             [
1875                                 src.get("volume")
1876                                 for src in definition.findall("./devices/disk/source")
1877                             ],
1878                         )
1879                         create_calls = pool_mock.createXML.call_args_list
1880                         vol_names = [
1881                             ET.fromstring(call[0][0]).find("name").text
1882                             for call in create_calls
1883                         ]
1884                         self.assertEqual(
1885                             ["test vm_system", "test vm_test"],
1886                             vol_names,
1887                         )
1888                         stream_mock.sendAll.assert_called_once()
1889                         stream_mock.finish.assert_called_once()
1890                         vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
1891     def test_update_backing_store(self):
1892         xml = """
1893             &lt;domain type='kvm' id='7'&gt;
1894               &lt;name&gt;my_vm&lt;/name&gt;
1895               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1896               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1897               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1898               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
1899               &lt;os&gt;
1900                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1901               &lt;/os&gt;
1902               &lt;devices&gt;
1903                 &lt;disk type='volume' device='disk'&gt;
1904                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
1905                   &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
1906                   &lt;backingStore type='file' index='2'&gt;
1907                     &lt;format type='qcow2'/&gt;
1908                     &lt;source file='/path/to/base.qcow2'/&gt;
1909                     &lt;backingStore/&gt;
1910                   &lt;/backingStore&gt;
1911                   &lt;target dev='vda' bus='virtio'/&gt;
1912                   &lt;alias name='virtio-disk0'/&gt;
1913                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
1914                 &lt;/disk&gt;
1915               &lt;/devices&gt;
1916             &lt;/domain&gt;
1917         """
1918         domain_mock = self.set_mock_vm("my_vm", xml)
1919         domain_mock.OSType.return_value = "hvm"
1920         self.mock_conn.defineXML.return_value = True
1921         updatedev_mock = MagicMock(return_value=0)
1922         domain_mock.updateDeviceFlags = updatedev_mock
1923         self.mock_conn.listStoragePools.return_value = ["default"]
1924         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1925             "&lt;pool type='dir'/&gt;"
1926         )
1927         ret = virt.update(
1928             "my_vm",
1929             disks=[
1930                 {
1931                     "name": "system",
1932                     "pool": "default",
1933                     "backing_store_path": "/path/to/base.qcow2",
1934                     "backing_store_format": "qcow2",
1935                 },
1936             ],
1937         )
1938         self.assertFalse(ret["definition"])
1939         self.assertFalse(ret["disk"]["attached"])
1940         self.assertFalse(ret["disk"]["detached"])
1941     def test_update_removables(self):
1942         xml = """
1943             &lt;domain type='kvm' id='7'&gt;
1944               &lt;name&gt;my_vm&lt;/name&gt;
1945               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1946               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1947               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1948               &lt;os&gt;
1949                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1950               &lt;/os&gt;
1951               &lt;devices&gt;
1952                 &lt;disk type='network' device='cdrom'&gt;
1953                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1954                   &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
1955                     &lt;host name='test-srv.local' port='80'/&gt;
1956                   &lt;/source&gt;
1957                   &lt;backingStore/&gt;
1958                   &lt;target dev='hda' bus='ide'/&gt;
1959                   &lt;readonly/&gt;
1960                   &lt;alias name='ide0-0-0'/&gt;
1961                   &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
1962                 &lt;/disk&gt;
1963                 &lt;disk type='file' device='cdrom'&gt;
1964                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1965                   &lt;target dev='hdb' bus='ide'/&gt;
1966                   &lt;readonly/&gt;
1967                   &lt;alias name='ide0-0-1'/&gt;
1968                   &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
1969                 &lt;/disk&gt;
1970                 &lt;disk type='file' device='cdrom'&gt;
1971                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1972                   &lt;source file='/srv/dvd-image-2.iso'/&gt;
1973                   &lt;backingStore/&gt;
1974                   &lt;target dev='hdc' bus='ide'/&gt;
1975                   &lt;readonly/&gt;
1976                   &lt;alias name='ide0-0-2'/&gt;
1977                   &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
1978                 &lt;/disk&gt;
1979                 &lt;disk type='file' device='cdrom'&gt;
1980                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1981                   &lt;source file='/srv/dvd-image-3.iso'/&gt;
1982                   &lt;backingStore/&gt;
1983                   &lt;target dev='hdd' bus='ide'/&gt;
1984                   &lt;readonly/&gt;
1985                   &lt;alias name='ide0-0-3'/&gt;
1986                   &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
1987                 &lt;/disk&gt;
1988                 &lt;disk type='network' device='cdrom'&gt;
1989                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1990                   &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
1991                     &lt;host name='test-srv.local' port='80'/&gt;
1992                   &lt;/source&gt;
1993                   &lt;backingStore/&gt;
1994                   &lt;target dev='hde' bus='ide'/&gt;
1995                   &lt;readonly/&gt;
1996                 &lt;/disk&gt;
1997               &lt;/devices&gt;
1998             &lt;/domain&gt;
1999         """
2000         domain_mock = self.set_mock_vm("my_vm", xml)
2001         domain_mock.OSType.return_value = "hvm"
2002         self.mock_conn.defineXML.return_value = True
2003         updatedev_mock = MagicMock(return_value=0)
2004         domain_mock.updateDeviceFlags = updatedev_mock
2005         ret = virt.update(
2006             "my_vm",
2007             disks=[
2008                 {
2009                     "name": "dvd1",
2010                     "device": "cdrom",
2011                     "source_file": None,
2012                     "model": "ide",
2013                 },
2014                 {
2015                     "name": "dvd2",
2016                     "device": "cdrom",
2017                     "source_file": "/srv/dvd-image-4.iso",
2018                     "model": "ide",
2019                 },
2020                 {
2021                     "name": "dvd3",
2022                     "device": "cdrom",
2023                     "source_file": "/srv/dvd-image-2.iso",
2024                     "model": "ide",
2025                 },
2026                 {
2027                     "name": "dvd4",
2028                     "device": "cdrom",
2029                     "source_file": "/srv/dvd-image-5.iso",
2030                     "model": "ide",
2031                 },
2032                 {
2033                     "name": "dvd5",
2034                     "device": "cdrom",
2035                     "source_file": "/srv/dvd-image-6.iso",
2036                     "model": "ide",
2037                 },
2038             ],
2039         )
2040         self.assertTrue(ret["definition"])
2041         self.assertFalse(ret["disk"].get("attached"))
2042         self.assertFalse(ret["disk"].get("detached"))
2043         self.assertEqual(
2044             [
2045                 {
2046                     "type": "file",
2047                     "device": "cdrom",
2048                     "driver": {
2049                         "name": "qemu",
2050                         "type": "raw",
2051                         "cache": "none",
2052                         "io": "native",
2053                     },
2054                     "backingStore": None,
2055                     "target": {"dev": "hda", "bus": "ide"},
2056                     "readonly": None,
2057                     "alias": {"name": "ide0-0-0"},
2058                     "address": {
2059                         "type": "drive",
2060                         "controller": "0",
2061                         "bus": "0",
2062                         "target": "0",
2063                         "unit": "0",
2064                     },
2065                 },
2066                 {
2067                     "type": "file",
2068                     "device": "cdrom",
2069                     "driver": {
2070                         "name": "qemu",
2071                         "type": "raw",
2072                         "cache": "none",
2073                         "io": "native",
2074                     },
2075                     "target": {"dev": "hdb", "bus": "ide"},
2076                     "readonly": None,
2077                     "alias": {"name": "ide0-0-1"},
2078                     "address": {
2079                         "type": "drive",
2080                         "controller": "0",
2081                         "bus": "0",
2082                         "target": "0",
2083                         "unit": "1",
2084                     },
2085                     "source": {"file": "/srv/dvd-image-4.iso"},
2086                 },
2087                 {
2088                     "type": "file",
2089                     "device": "cdrom",
2090                     "driver": {
2091                         "name": "qemu",
2092                         "type": "raw",
2093                         "cache": "none",
2094                         "io": "native",
2095                     },
2096                     "backingStore": None,
2097                     "target": {"dev": "hdd", "bus": "ide"},
2098                     "readonly": None,
2099                     "alias": {"name": "ide0-0-3"},
2100                     "address": {
2101                         "type": "drive",
2102                         "controller": "0",
2103                         "bus": "0",
2104                         "target": "0",
2105                         "unit": "3",
2106                     },
2107                     "source": {"file": "/srv/dvd-image-5.iso"},
2108                 },
2109                 {
2110                     "type": "file",
2111                     "device": "cdrom",
2112                     "driver": {
2113                         "name": "qemu",
2114                         "type": "raw",
2115                         "cache": "none",
2116                         "io": "native",
2117                     },
2118                     "backingStore": None,
2119                     "target": {"dev": "hde", "bus": "ide"},
2120                     "readonly": None,
2121                     "source": {"file": "/srv/dvd-image-6.iso"},
2122                 },
2123             ],
2124             [
2125                 salt.utils.xmlutil.to_dict(ET.fromstring(disk), True)
2126                 for disk in ret["disk"]["updated"]
2127             ],
2128         )
2129     def test_update_xen_boot_params(self):
2130         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
2131         xml_boot = """
2132             &lt;domain type='xen' id='8'&gt;
2133               &lt;name&gt;vm&lt;/name&gt;
2134               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2135               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2136               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2137               &lt;os&gt;
2138                 &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
2139                 &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
2140               &lt;/os&gt;
2141             &lt;/domain&gt;
2142         """
2143         domain_mock_boot = self.set_mock_vm("vm", xml_boot)
2144         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2145         define_mock_boot = MagicMock(return_value=True)
2146         define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
2147         self.mock_conn.defineXML = define_mock_boot
2148         self.assertEqual(
2149             {
2150                 "cpu": False,
2151                 "definition": True,
2152                 "disk": {"attached": [], "detached": [], "updated": []},
2153                 "interface": {"attached": [], "detached": []},
2154             },
2155             virt.update("vm", cpu=2),
2156         )
2157         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2158         self.assertEqual(setxml.find("os").find("loader").attrib.get("type"), "rom")
2159         self.assertEqual(
2160             setxml.find("os").find("loader").text, "/usr/lib/xen/boot/hvmloader"
2161         )
2162     def test_update_existing_boot_params(self):
2163         xml_boot = """
2164             &lt;domain type='kvm' id='8'&gt;
2165               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2166               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2167               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2168               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2169               &lt;os&gt;
2170                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2171                 &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
2172                 &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
2173                 &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
2174                 &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
2175                 &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
2176               &lt;/os&gt;
2177             &lt;/domain&gt;
2178         """
2179         domain_mock_boot = self.set_mock_vm("vm_with_boot_param", xml_boot)
2180         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2181         define_mock_boot = MagicMock(return_value=True)
2182         self.mock_conn.defineXML = define_mock_boot
2183         boot_new = {
2184             "kernel": "/root/new-vmlinuz",
2185             "initrd": "/root/new-initrd",
2186             "cmdline": "console=ttyS0 ks=http://example.com/new/os/",
2187         }
2188         uefi_boot_new = {
2189             "loader": "/usr/share/new/OVMF_CODE.fd",
2190             "nvram": "/usr/share/new/OVMF_VARS.ms.fd",
2191         }
2192         self.assertEqual(
2193             {
2194                 "definition": True,
2195                 "disk": {"attached": [], "detached": [], "updated": []},
2196                 "interface": {"attached": [], "detached": []},
2197             },
2198             virt.update("vm_with_boot_param", boot=boot_new),
2199         )
2200         setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
2201         self.assertEqual(
2202             setxml_boot.find("os").find("kernel").text, "/root/new-vmlinuz"
2203         )
2204         self.assertEqual(setxml_boot.find("os").find("initrd").text, "/root/new-initrd")
2205         self.assertEqual(
2206             setxml_boot.find("os").find("cmdline").text,
2207             "console=ttyS0 ks=http://example.com/new/os/",
2208         )
2209         self.assertEqual(
2210             {
2211                 "definition": True,
2212                 "disk": {"attached": [], "detached": [], "updated": []},
2213                 "interface": {"attached": [], "detached": []},
2214             },
2215             virt.update("vm_with_boot_param", boot=uefi_boot_new),
2216         )
2217         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2218         self.assertEqual(
2219             setxml.find("os").find("loader").text, "/usr/share/new/OVMF_CODE.fd"
2220         )
2221         self.assertEqual(setxml.find("os").find("loader").attrib.get("readonly"), "yes")
2222         self.assertEqual(setxml.find("os").find("loader").attrib["type"], "pflash")
2223         self.assertEqual(
2224             setxml.find("os").find("nvram").attrib["template"],
2225             "/usr/share/new/OVMF_VARS.ms.fd",
2226         )
2227         kernel_none = {
2228             "kernel": None,
2229             "initrd": None,
2230             "cmdline": None,
2231         }
2232         uefi_none = {"loader": None, "nvram": None}
2233         self.assertEqual(
2234             {
2235                 "definition": True,
2236                 "disk": {"attached": [], "detached": [], "updated": []},
2237                 "interface": {"attached": [], "detached": []},
2238             },
2239             virt.update("vm_with_boot_param", boot=kernel_none),
2240         )
2241         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2242         self.assertEqual(setxml.find("os").find("kernel"), None)
2243         self.assertEqual(setxml.find("os").find("initrd"), None)
2244         self.assertEqual(setxml.find("os").find("cmdline"), None)
2245         self.assertEqual(
2246             {
2247                 "definition": True,
2248                 "disk": {"attached": [], "detached": [], "updated": []},
2249                 "interface": {"attached": [], "detached": []},
2250             },
2251             virt.update("vm_with_boot_param", boot={"efi": False}),
2252         )
2253         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2254         self.assertEqual(setxml.find("os").find("nvram"), None)
2255         self.assertEqual(setxml.find("os").find("loader"), None)
2256         self.assertEqual(
2257             {
2258                 "definition": True,
2259                 "disk": {"attached": [], "detached": [], "updated": []},
2260                 "interface": {"attached": [], "detached": []},
2261             },
2262             virt.update("vm_with_boot_param", boot=uefi_none),
2263         )
2264         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2265         self.assertEqual(setxml.find("os").find("loader"), None)
2266         self.assertEqual(setxml.find("os").find("nvram"), None)
2267     def test_update_existing_numatune_params(self):
2268         xml_numatune = """
2269             &lt;domain type='kvm' id='8'&gt;
2270               &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
2271               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2272               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2273               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
2274               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2275               &lt;numatune&gt;
2276                 &lt;memory mode="strict" nodeset="0-11"/&gt;
2277                 &lt;memnode cellid="1" mode="strict" nodeset="3"/&gt;
2278                 &lt;memnode cellid="3" mode="preferred" nodeset="7"/&gt;
2279               &lt;/numatune&gt;
2280               &lt;os&gt;
2281                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2282               &lt;/os&gt;
2283               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
2284             &lt;/domain&gt;
2285         """
2286         domain_mock = self.set_mock_vm("vm_with_numatune_param", xml_numatune)
2287         domain_mock.OSType = MagicMock(return_value="hvm")
2288         define_mock = MagicMock(return_value=True)
2289         self.mock_conn.defineXML = define_mock
2290         numatune = {
2291             "memory": {"mode": "preferred", "nodeset": "0-5"},
2292             "memnodes": {
2293                 0: {"mode": "strict", "nodeset": "4"},
2294                 3: {"mode": "preferred", "nodeset": "7"},
2295                 4: {"mode": "strict", "nodeset": "6"},
2296             },
2297         }
2298         self.assertEqual(
2299             {
2300                 "definition": True,
2301                 "disk": {"attached": [], "detached": [], "updated": []},
2302                 "interface": {"attached": [], "detached": []},
2303             },
2304             virt.update("vm_with_numatune_param", numatune=numatune),
2305         )
2306         setxml = ET.fromstring(define_mock.call_args[0][0])
2307         self.assertEqual(
2308             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2309         )
2310         self.assertEqual(
2311             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2312             ",".join([str(i) for i in range(0, 6)]),
2313         )
2314         self.assertEqual(
2315             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2316         )
2317         self.assertEqual(
2318             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2319         )
2320         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='1']"), None)
2321         self.assertEqual(
2322             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2323             "preferred",
2324         )
2325         self.assertEqual(
2326             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2327         )
2328         self.assertEqual(
2329             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("mode"), "strict"
2330         )
2331         self.assertEqual(
2332             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("nodeset"), "6"
2333         )
2334         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2335         numatune_mem_none = {
2336             "memory": None,
2337             "memnodes": {
2338                 0: {"mode": "strict", "nodeset": "4"},
2339                 3: {"mode": "preferred", "nodeset": "7"},
2340                 4: {"mode": "strict", "nodeset": "6"},
2341             },
2342         }
2343         self.assertEqual(
2344             {
2345                 "definition": True,
2346                 "disk": {"attached": [], "detached": [], "updated": []},
2347                 "interface": {"attached": [], "detached": []},
2348             },
2349             virt.update("vm_with_numatune_param", numatune=numatune_mem_none),
2350         )
2351         setxml = ET.fromstring(define_mock.call_args[0][0])
2352         self.assertEqual(setxml.find("numatune").find("memory"), None)
2353         self.assertEqual(
2354             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2355         )
2356         self.assertEqual(
2357             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2358         )
2359         self.assertEqual(
2360             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2361             "preferred",
2362         )
2363         self.assertEqual(
2364             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2365         )
2366         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2367         numatune_mnodes_none = {
2368             "memory": {"mode": "preferred", "nodeset": "0-5"},
2369             "memnodes": None,
2370         }
2371         self.assertEqual(
2372             {
2373                 "definition": True,
2374                 "disk": {"attached": [], "detached": [], "updated": []},
2375                 "interface": {"attached": [], "detached": []},
2376             },
2377             virt.update("vm_with_numatune_param", numatune=numatune_mnodes_none),
2378         )
2379         setxml = ET.fromstring(define_mock.call_args[0][0])
2380         self.assertEqual(
2381             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2382         )
2383         self.assertEqual(
2384             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2385             ",".join([str(i) for i in range(0, 6)]),
2386         )
2387         self.assertEqual(setxml.find("./numatune/memnode"), None)
2388         numatune_without_change = {
2389             "memory": {"mode": "strict", "nodeset": "0-5,6,7-11"},
2390             "memnodes": {
2391                 1: {"mode": "strict", "nodeset": "3"},
2392                 3: {"mode": "preferred", "nodeset": "7"},
2393             },
2394         }
2395         self.assertEqual(
2396             {
2397                 "definition": False,
2398                 "disk": {"attached": [], "detached": [], "updated": []},
2399                 "interface": {"attached": [], "detached": []},
2400             },
2401             virt.update("vm_with_numatune_param", numatune=numatune_without_change),
2402         )
2403         self.assertEqual(
2404             {
2405                 "definition": True,
2406                 "disk": {"attached": [], "detached": [], "updated": []},
2407                 "interface": {"attached": [], "detached": []},
2408             },
2409             virt.update(
2410                 "vm_with_numatune_param", numatune={"memory": None, "memnodes": None}
2411             ),
2412         )
2413         setxml = ET.fromstring(define_mock.call_args[0][0])
2414         self.assertEqual(setxml.find("numatune"), None)
2415     def test_update_existing_cpu_params(self):
2416         xml_with_existing_params = """
2417             &lt;domain type='kvm' id='8'&gt;
2418               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2419               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2420               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2421               &lt;vcpu placement="static" cpuset="0-11" current="3"&gt;6&lt;/vcpu&gt;
2422               &lt;vcpus&gt;
2423                 &lt;vcpu id="0" enabled="yes" hotpluggable="no" order="1"/&gt;
2424                 &lt;vcpu id="1" enabled="no" hotpluggable="yes"/&gt;
2425                 &lt;vcpu id="2" enabled="no" hotpluggable="yes"/&gt;
2426                 &lt;vcpu id="3" enabled="no" hotpluggable="yes"/&gt;
2427                 &lt;vcpu id="4" enabled="no" hotpluggable="yes"/&gt;
2428                 &lt;vcpu id="5" enabled="no" hotpluggable="yes"/&gt;
2429                 &lt;vcpu id="6" enabled="no" hotpluggable="yes"/&gt;
2430                 &lt;vcpu id="7" enabled="no" hotpluggable="yes"/&gt;
2431                 &lt;vcpu id="8" enabled="no" hotpluggable="yes"/&gt;
2432                 &lt;vcpu id="9" enabled="no" hotpluggable="yes"/&gt;
2433                 &lt;vcpu id="10" enabled="no" hotpluggable="yes"/&gt;
2434                 &lt;vcpu id="11" enabled="no" hotpluggable="yes"/&gt;
2435               &lt;/vcpus&gt;
2436               &lt;cpu mode="custom" match="exact" check="full"&gt;
2437                  &lt;model fallback="allow" vendor_id="Genuine20201"&gt;core2duo&lt;/model&gt;
2438                  &lt;vendor&gt;Intel&lt;/vendor&gt;
2439                  &lt;topology sockets="2" cores="5" threads="2"/&gt;
2440                  &lt;cache level="3" mode="emulate"/&gt;
2441                  &lt;feature policy="optional" name="lahf_lm"/&gt;
2442                  &lt;feature policy="require" name="pcid"/&gt;
2443                  &lt;numa&gt;
2444                     &lt;cell id="0" cpus="0-3" memory="1073741824" unit="KiB" discard="no"&gt;
2445                         &lt;distances&gt;
2446                             &lt;sibling id="0" value="10"/&gt;
2447                             &lt;sibling id="1" value="21"/&gt;
2448                             &lt;sibling id="2" value="31"/&gt;
2449                             &lt;sibling id="3" value="41"/&gt;
2450                         &lt;/distances&gt;
2451                     &lt;/cell&gt;
2452                     &lt;cell id="1" cpus="4-6" memory="1073741824" unit="KiB" memAccess="private"&gt;
2453                         &lt;distances&gt;
2454                             &lt;sibling id="0" value="21"/&gt;
2455                             &lt;sibling id="1" value="10"/&gt;
2456                             &lt;sibling id="2" value="21"/&gt;
2457                             &lt;sibling id="3" value="31"/&gt;
2458                         &lt;/distances&gt;
2459                     &lt;/cell&gt;
2460                  &lt;/numa&gt;
2461               &lt;/cpu&gt;
2462               &lt;os&gt;
2463                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2464               &lt;/os&gt;
2465               &lt;/domain&gt;
2466          """
2467         domain_mock = self.set_mock_vm(
2468             "vm_with_existing_param", xml_with_existing_params
2469         )
2470         domain_mock.OSType = MagicMock(return_value="hvm")
2471         define_mock = MagicMock(return_value=True)
2472         self.mock_conn.defineXML = define_mock
2473         setvcpus_mock = MagicMock(return_value=0)
2474         domain_mock.setVcpusFlags = setvcpus_mock
2475         cpu_attr = {"placement": "static", "cpuset": "0-5", "current": 3, "maximum": 5}
2476         self.assertEqual(
2477             {
2478                 "definition": True,
2479                 "cpu": True,
2480                 "disk": {"attached": [], "detached": [], "updated": []},
2481                 "interface": {"attached": [], "detached": []},
2482             },
2483             virt.update("vm_with_existing_param", cpu=cpu_attr),
2484         )
2485         setxml = ET.fromstring(define_mock.call_args[0][0])
2486         self.assertEqual(setxml.find("vcpu").text, "5")
2487         self.assertEqual(setxml.find("vcpu").attrib["placement"], "static")
2488         self.assertEqual(
2489             setxml.find("vcpu").attrib["cpuset"],
2490             ",".join([str(i) for i in range(0, 6)]),
2491         )
2492         self.assertEqual(setxml.find("vcpu").attrib["current"], "3")
2493         cpu_none = {"placement": "auto", "cpuset": None, "current": 2, "maximum": 5}
2494         self.assertEqual(
2495             {
2496                 "definition": True,
2497                 "cpu": True,
2498                 "disk": {"attached": [], "detached": [], "updated": []},
2499                 "interface": {"attached": [], "detached": []},
2500             },
2501             virt.update("vm_with_existing_param", cpu=cpu_none),
2502         )
2503         setxml = ET.fromstring(define_mock.call_args[0][0])
2504         self.assertEqual(setxml.find("vcpu").text, "5")
2505         self.assertEqual(setxml.find("vcpu").attrib["placement"], "auto")
2506         self.assertEqual(setxml.find("vcpu").attrib.get("cpuset"), None)
2507         self.assertEqual(setxml.find("vcpu").attrib.get("current"), "2")
2508         vcpus = {
2509             "vcpus": {
2510                 "0": {"enabled": False, "hotpluggable": True, "order": 5},
2511                 "3": {"enabled": True, "hotpluggable": False, "order": 3},
2512                 "7": {"enabled": True, "hotpluggable": False},
2513             }
2514         }
2515         self.assertEqual(
2516             {
2517                 "definition": True,
2518                 "disk": {"attached": [], "detached": [], "updated": []},
2519                 "interface": {"attached": [], "detached": []},
2520             },
2521             virt.update("vm_with_existing_param", cpu=vcpus),
2522         )
2523         setxml = ET.fromstring(define_mock.call_args[0][0])
2524         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["id"], "0")
2525         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["enabled"], "no")
2526         self.assertEqual(
2527             setxml.find("./vcpus/vcpu/[@id='0']").attrib["hotpluggable"], "yes"
2528         )
2529         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["order"], "5")
2530         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["id"], "3")
2531         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2532         self.assertEqual(
2533             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2534         )
2535         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["order"], "3")
2536         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["id"], "7")
2537         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["enabled"], "yes")
2538         self.assertEqual(
2539             setxml.find("./vcpus/vcpu/[@id='7']").attrib["hotpluggable"], "no"
2540         )
2541         self.assertEqual(
2542             setxml.find("./vcpus/vcpu/[@id='7']").attrib.get("order"), None
2543         )
2544         ind_vcpu = {
2545             "vcpus": {"3": {"enabled": True, "hotpluggable": False, "order": None}}
2546         }
2547         self.assertEqual(
2548             {
2549                 "definition": True,
2550                 "disk": {"attached": [], "detached": [], "updated": []},
2551                 "interface": {"attached": [], "detached": []},
2552             },
2553             virt.update("vm_with_existing_param", cpu=ind_vcpu),
2554         )
2555         setxml = ET.fromstring(define_mock.call_args[0][0])
2556         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']"), None)
2557         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2558         self.assertEqual(
2559             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2560         )
2561         self.assertEqual(
2562             setxml.find("./vcpus/vcpu/[@id='3']").attrib.get("order"), None
2563         )
2564         vcpus_none = {"vcpus": None}
2565         self.assertEqual(
2566             {
2567                 "definition": True,
2568                 "disk": {"attached": [], "detached": [], "updated": []},
2569                 "interface": {"attached": [], "detached": []},
2570             },
2571             virt.update("vm_with_existing_param", cpu=vcpus_none),
2572         )
2573         setxml = ET.fromstring(define_mock.call_args[0][0])
2574         self.assertEqual(setxml.find("vcpus"), None)
2575         cpu_atr_none = {"match": None, "mode": None, "check": None}
2576         self.assertEqual(
2577             {
2578                 "definition": True,
2579                 "disk": {"attached": [], "detached": [], "updated": []},
2580                 "interface": {"attached": [], "detached": []},
2581             },
2582             virt.update("vm_with_existing_param", cpu=cpu_atr_none),
2583         )
2584         setxml = ET.fromstring(define_mock.call_args[0][0])
2585         self.assertEqual(setxml.find("cpu").attrib, {})
2586         cpu_atr_mn = {"match": None}
2587         self.assertEqual(
2588             {
2589                 "definition": True,
2590                 "disk": {"attached": [], "detached": [], "updated": []},
2591                 "interface": {"attached": [], "detached": []},
2592             },
2593             virt.update("vm_with_existing_param", cpu=cpu_atr_mn),
2594         )
2595         setxml = ET.fromstring(define_mock.call_args[0][0])
2596         self.assertEqual(setxml.find("cpu").attrib.get("match"), None)
2597         self.assertEqual(setxml.find("cpu").attrib.get("mode"), "custom")
2598         self.assertEqual(setxml.find("cpu").attrib.get("check"), "full")
2599         cpu_model_none = {"model": None}
2600         self.assertEqual(
2601             {
2602                 "definition": True,
2603                 "disk": {"attached": [], "detached": [], "updated": []},
2604                 "interface": {"attached": [], "detached": []},
2605             },
2606             virt.update("vm_with_existing_param", cpu=cpu_model_none),
2607         )
2608         setxml = ET.fromstring(define_mock.call_args[0][0])
2609         self.assertEqual(setxml.find("cpu").find("model"), None)
2610         cpu_model_atr_none = {
2611             "model": {"name": "coresolo", "fallback": "forbid", "vendor_id": None}
2612         }
2613         self.assertEqual(
2614             {
2615                 "definition": True,
2616                 "disk": {"attached": [], "detached": [], "updated": []},
2617                 "interface": {"attached": [], "detached": []},
2618             },
2619             virt.update("vm_with_existing_param", cpu=cpu_model_atr_none),
2620         )
2621         setxml = ET.fromstring(define_mock.call_args[0][0])
2622         self.assertEqual(setxml.find("cpu").find("model").attrib.get("vendor_id"), None)
2623         self.assertEqual(
2624             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2625         )
2626         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2627         cpu_model_atr = {
2628             "model": {
2629                 "name": "coresolo",
2630                 "fallback": "forbid",
2631                 "vendor_id": "AuthenticAMD",
2632             }
2633         }
2634         self.assertEqual(
2635             {
2636                 "definition": True,
2637                 "disk": {"attached": [], "detached": [], "updated": []},
2638                 "interface": {"attached": [], "detached": []},
2639             },
2640             virt.update("vm_with_existing_param", cpu=cpu_model_atr),
2641         )
2642         setxml = ET.fromstring(define_mock.call_args[0][0])
2643         self.assertEqual(
2644             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2645         )
2646         self.assertEqual(
2647             setxml.find("cpu").find("model").attrib.get("vendor_id"), "AuthenticAMD"
2648         )
2649         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2650         cpu_vendor = {"vendor": "AMD"}
2651         self.assertEqual(
2652             {
2653                 "definition": True,
2654                 "disk": {"attached": [], "detached": [], "updated": []},
2655                 "interface": {"attached": [], "detached": []},
2656             },
2657             virt.update("vm_with_existing_param", cpu=cpu_vendor),
2658         )
2659         setxml = ET.fromstring(define_mock.call_args[0][0])
2660         self.assertEqual(setxml.find("cpu").find("vendor").text, "AMD")
2661         cpu_vendor_none = {"vendor": None}
2662         self.assertEqual(
2663             {
2664                 "definition": True,
2665                 "disk": {"attached": [], "detached": [], "updated": []},
2666                 "interface": {"attached": [], "detached": []},
2667             },
2668             virt.update("vm_with_existing_param", cpu=cpu_vendor_none),
2669         )
2670         setxml = ET.fromstring(define_mock.call_args[0][0])
2671         self.assertEqual(setxml.find("cpu").find("vendor"), None)
2672         cpu_topology = {"topology": {"sockets": 1, "cores": 12, "threads": 1}}
2673         self.assertEqual(
2674             {
2675                 "definition": True,
2676                 "disk": {"attached": [], "detached": [], "updated": []},
2677                 "interface": {"attached": [], "detached": []},
2678             },
2679             virt.update("vm_with_existing_param", cpu=cpu_topology),
2680         )
2681         setxml = ET.fromstring(define_mock.call_args[0][0])
2682         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("sockets"), "1")
2683         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2684         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2685         cpu_topology_atr_none = {
2686             "topology": {"sockets": None, "cores": 12, "threads": 1}
2687         }
2688         self.assertEqual(
2689             {
2690                 "definition": True,
2691                 "disk": {"attached": [], "detached": [], "updated": []},
2692                 "interface": {"attached": [], "detached": []},
2693             },
2694             virt.update("vm_with_existing_param", cpu=cpu_topology_atr_none),
2695         )
2696         setxml = ET.fromstring(define_mock.call_args[0][0])
2697         self.assertEqual(
2698             setxml.find("cpu").find("topology").attrib.get("sockets"), None
2699         )
2700         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2701         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2702         cpu_topology_none = {"topology": None}
2703         self.assertEqual(
2704             {
2705                 "definition": True,
2706                 "disk": {"attached": [], "detached": [], "updated": []},
2707                 "interface": {"attached": [], "detached": []},
2708             },
2709             virt.update("vm_with_existing_param", cpu=cpu_topology_none),
2710         )
2711         setxml = ET.fromstring(define_mock.call_args[0][0])
2712         self.assertEqual(setxml.find("cpu").find("topology"), None)
2713         cpu_cache = {"cache": {"mode": "passthrough", "level": 2}}
2714         self.assertEqual(
2715             {
2716                 "definition": True,
2717                 "disk": {"attached": [], "detached": [], "updated": []},
2718                 "interface": {"attached": [], "detached": []},
2719             },
2720             virt.update("vm_with_existing_param", cpu=cpu_cache),
2721         )
2722         setxml = ET.fromstring(define_mock.call_args[0][0])
2723         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), "2")
2724         self.assertEqual(
2725             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2726         )
2727         cpu_cache_atr_none = {"cache": {"mode": "passthrough", "level": None}}
2728         self.assertEqual(
2729             {
2730                 "definition": True,
2731                 "disk": {"attached": [], "detached": [], "updated": []},
2732                 "interface": {"attached": [], "detached": []},
2733             },
2734             virt.update("vm_with_existing_param", cpu=cpu_cache_atr_none),
2735         )
2736         setxml = ET.fromstring(define_mock.call_args[0][0])
2737         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), None)
2738         self.assertEqual(
2739             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2740         )
2741         cpu_cache_none = {"cache": None}
2742         self.assertEqual(
2743             {
2744                 "definition": True,
2745                 "disk": {"attached": [], "detached": [], "updated": []},
2746                 "interface": {"attached": [], "detached": []},
2747             },
2748             virt.update("vm_with_existing_param", cpu=cpu_cache_none),
2749         )
2750         setxml = ET.fromstring(define_mock.call_args[0][0])
2751         self.assertEqual(setxml.find("cpu").find("cache"), None)
2752         cpu_feature = {"features": {"lahf_lm": "require", "pcid": "optional"}}
2753         self.assertEqual(
2754             {
2755                 "definition": True,
2756                 "disk": {"attached": [], "detached": [], "updated": []},
2757                 "interface": {"attached": [], "detached": []},
2758             },
2759             virt.update("vm_with_existing_param", cpu=cpu_feature),
2760         )
2761         setxml = ET.fromstring(define_mock.call_args[0][0])
2762         self.assertEqual(
2763             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2764         )
2765         self.assertEqual(
2766             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2767             "require",
2768         )
2769         cpu_feature_atr_none = {"features": {"pcid": "optional", "lahf_lm": "disable"}}
2770         self.assertEqual(
2771             {
2772                 "definition": True,
2773                 "disk": {"attached": [], "detached": [], "updated": []},
2774                 "interface": {"attached": [], "detached": []},
2775             },
2776             virt.update("vm_with_existing_param", cpu=cpu_feature_atr_none),
2777         )
2778         setxml = ET.fromstring(define_mock.call_args[0][0])
2779         self.assertEqual(
2780             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2781             "disable",
2782         )
2783         self.assertEqual(
2784             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2785         )
2786         cpu_feature_none = {"features": {"lahf_lm": None, "pcid": None}}
2787         self.assertEqual(
2788             {
2789                 "definition": True,
2790                 "disk": {"attached": [], "detached": [], "updated": []},
2791                 "interface": {"attached": [], "detached": []},
2792             },
2793             virt.update("vm_with_existing_param", cpu=cpu_feature_none),
2794         )
2795         setxml = ET.fromstring(define_mock.call_args[0][0])
2796         self.assertEqual(setxml.find("./cpu/feature"), None)
2797         numa_cell = {
2798             "numa": {
2799                 0: {
2800                     "cpus": "0-6",
2801                     "memory": "512m",
2802                     "discard": True,
2803                     "distances": {0: 15, 1: 16, 2: 17, 3: 18},
2804                 },
2805                 1: {
2806                     "cpus": "7-12",
2807                     "memory": "2g",
2808                     "discard": True,
2809                     "memAccess": "shared",
2810                     "distances": {0: 23, 1: 24, 2: 25, 3: 26},
2811                 },
2812             }
2813         }
2814         self.assertEqual(
2815             {
2816                 "definition": True,
2817                 "disk": {"attached": [], "detached": [], "updated": []},
2818                 "interface": {"attached": [], "detached": []},
2819             },
2820             virt.update("vm_with_existing_param", cpu=numa_cell),
2821         )
2822         setxml = ET.fromstring(define_mock.call_args[0][0])
2823         self.assertEqual(
2824             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2825             ",".join([str(i) for i in range(0, 7)]),
2826         )
2827         self.assertEqual(
2828             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2829             str(512 * 1024 ** 2),
2830         )
2831         self.assertEqual(
2832             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2833             "bytes",
2834         )
2835         self.assertEqual(
2836             setxml.find("./cpu/numa/cell/[@id='0']").attrib["discard"], "yes"
2837         )
2838         self.assertEqual(
2839             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2840                 "value"
2841             ],
2842             "15",
2843         )
2844         self.assertEqual(
2845             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']").attrib[
2846                 "value"
2847             ],
2848             "16",
2849         )
2850         self.assertEqual(
2851             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2852                 "value"
2853             ],
2854             "17",
2855         )
2856         self.assertEqual(
2857             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2858                 "value"
2859             ],
2860             "18",
2861         )
2862         self.assertEqual(
2863             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2864             ",".join([str(i) for i in range(7, 13)]),
2865         )
2866         self.assertEqual(
2867             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2868             str(int(2 * 1024 ** 3)),
2869         )
2870         self.assertEqual(
2871             setxml.find("./cpu/numa/cell/[@id='1']").get("unit"),
2872             "bytes",
2873         )
2874         self.assertEqual(
2875             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2876         )
2877         self.assertEqual(
2878             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memAccess"], "shared"
2879         )
2880         self.assertEqual(
2881             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2882                 "value"
2883             ],
2884             "23",
2885         )
2886         self.assertEqual(
2887             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2888                 "value"
2889             ],
2890             "24",
2891         )
2892         self.assertEqual(
2893             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2894                 "value"
2895             ],
2896             "25",
2897         )
2898         self.assertEqual(
2899             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']").attrib[
2900                 "value"
2901             ],
2902             "26",
2903         )
2904         numa_cell_atr_none = {
2905             "numa": {
2906                 "0": {
2907                     "cpus": "0-6",
2908                     "memory": "512m",
2909                     "discard": False,
2910                     "distances": {0: 15, 2: 17, 3: 18},
2911                 },
2912                 "1": {
2913                     "cpus": "7-12",
2914                     "memory": "2g",
2915                     "discard": True,
2916                     "distances": {0: 23, 1: 24, 2: 25},
2917                 },
2918             }
2919         }
2920         self.assertEqual(
2921             {
2922                 "definition": True,
2923                 "disk": {"attached": [], "detached": [], "updated": []},
2924                 "interface": {"attached": [], "detached": []},
2925             },
2926             virt.update("vm_with_existing_param", cpu=numa_cell_atr_none),
2927         )
2928         setxml = ET.fromstring(define_mock.call_args[0][0])
2929         self.assertEqual(
2930             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2931             ",".join([str(i) for i in range(0, 7)]),
2932         )
2933         self.assertEqual(
2934             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2935             str(512 * 1024 ** 2),
2936         )
2937         self.assertEqual(
2938             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2939             "bytes",
2940         )
2941         self.assertEqual(
2942             setxml.find("./cpu/numa/cell/[@id='0']").attrib.get("discard"), "no"
2943         )
2944         self.assertEqual(
2945             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2946                 "value"
2947             ],
2948             "15",
2949         )
2950         self.assertEqual(
2951             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']"), None
2952         )
2953         self.assertEqual(
2954             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2955                 "value"
2956             ],
2957             "17",
2958         )
2959         self.assertEqual(
2960             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2961                 "value"
2962             ],
2963             "18",
2964         )
2965         self.assertEqual(
2966             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2967             ",".join([str(i) for i in range(7, 13)]),
2968         )
2969         self.assertEqual(
2970             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2971             str(int(2 * 1024 ** 3)),
2972         )
2973         self.assertEqual(
2974             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2975         )
2976         self.assertEqual(
2977             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2978                 "value"
2979             ],
2980             "23",
2981         )
2982         self.assertEqual(
2983             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2984                 "value"
2985             ],
2986             "24",
2987         )
2988         self.assertEqual(
2989             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2990                 "value"
2991             ],
2992             "25",
2993         )
2994         self.assertEqual(
2995             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"), None
2996         )
2997         self.assertEqual(
2998             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2999             ",".join([str(i) for i in range(7, 13)]),
3000         )
3001         self.assertEqual(
3002             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
3003             str(int(1024 ** 3 * 2)),
3004         )
3005         self.assertEqual(
3006             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
3007         )
3008         self.assertEqual(
3009             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
3010                 "value"
3011             ],
3012             "23",
3013         )
3014         self.assertEqual(
3015             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3016                 "value"
3017             ],
3018             "24",
3019         )
3020         self.assertEqual(
3021             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3022                 "value"
3023             ],
3024             "25",
3025         )
3026         self.assertEqual(
3027             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"),
3028             None,
3029         )
3030     def test_update_memtune_params(self):
3031         xml_with_memtune_params = """
3032             &lt;domain type='kvm' id='8'&gt;
3033               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
3034               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3035               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3036               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
3037               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3038               &lt;memtune&gt;
3039                 &lt;hard_limit unit="KiB"&gt;1048576&lt;/hard_limit&gt;
3040                 &lt;soft_limit unit="KiB"&gt;2097152&lt;/soft_limit&gt;
3041                 &lt;swap_hard_limit unit="KiB"&gt;2621440&lt;/swap_hard_limit&gt;
3042                 &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
3043               &lt;/memtune&gt;
3044               &lt;os&gt;
3045                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3046               &lt;/os&gt;
3047             &lt;/domain&gt;
3048         """
3049         domain_mock = self.set_mock_vm("vm_with_memtune_param", xml_with_memtune_params)
3050         domain_mock.OSType = MagicMock(return_value="hvm")
3051         define_mock = MagicMock(return_value=True)
3052         self.mock_conn.defineXML = define_mock
3053         memtune_new_val = {
3054             "boot": "0.7g",
3055             "current": "2.5g",
3056             "max": "3096m",
3057             "slots": "10",
3058             "soft_limit": "2048m",
3059             "hard_limit": "1024",
3060             "swap_hard_limit": "2.5g",
3061             "min_guarantee": "1 g",
3062         }
3063         domain_mock.setMemoryFlags.return_value = 0
3064         self.assertEqual(
3065             {
3066                 "definition": True,
3067                 "disk": {"attached": [], "detached": [], "updated": []},
3068                 "interface": {"attached": [], "detached": []},
3069                 "mem": True,
3070             },
3071             virt.update("vm_with_memtune_param", mem=memtune_new_val),
3072         )
3073         self.assertEqual(
3074             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3075         )
3076         setxml = ET.fromstring(define_mock.call_args[0][0])
3077         self.assertEqual(
3078             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3079         )
3080         self.assertEqual(
3081             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3082         )
3083         self.assertEqual(
3084             setxml.find("memtune").find("swap_hard_limit").text,
3085             str(int(2.5 * 1024 ** 2)),
3086         )
3087         self.assertEqual(
3088             setxml.find("memtune").find("swap_hard_limit").get("unit"),
3089             "KiB",
3090         )
3091         self.assertEqual(
3092             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3093         )
3094         self.assertEqual(
3095             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3096         )
3097         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3098         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3099         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3100         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3101         max_slot_reverse = {
3102             "slots": "10",
3103             "max": "3096m",
3104         }
3105         self.assertEqual(
3106             {
3107                 "definition": True,
3108                 "disk": {"attached": [], "detached": [], "updated": []},
3109                 "interface": {"attached": [], "detached": []},
3110             },
3111             virt.update("vm_with_memtune_param", mem=max_slot_reverse),
3112         )
3113         setxml = ET.fromstring(define_mock.call_args[0][0])
3114         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3115         self.assertEqual(setxml.find("maxMemory").get("unit"), "bytes")
3116         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3117         max_swap_none = {
3118             "boot": "0.7g",
3119             "current": "2.5g",
3120             "max": None,
3121             "slots": "10",
3122             "soft_limit": "2048m",
3123             "hard_limit": "1024",
3124             "swap_hard_limit": None,
3125             "min_guarantee": "1 g",
3126         }
3127         domain_mock.setMemoryFlags.reset_mock()
3128         self.assertEqual(
3129             {
3130                 "definition": True,
3131                 "disk": {"attached": [], "detached": [], "updated": []},
3132                 "interface": {"attached": [], "detached": []},
3133                 "mem": True,
3134             },
3135             virt.update("vm_with_memtune_param", mem=max_swap_none),
3136         )
3137         self.assertEqual(
3138             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3139         )
3140         setxml = ET.fromstring(define_mock.call_args[0][0])
3141         self.assertEqual(
3142             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3143         )
3144         self.assertEqual(
3145             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3146         )
3147         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3148         self.assertEqual(
3149             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3150         )
3151         self.assertEqual(
3152             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3153         )
3154         self.assertEqual(setxml.find("maxMemory").text, None)
3155         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3156         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3157         memtune_none = {
3158             "soft_limit": None,
3159             "hard_limit": None,
3160             "swap_hard_limit": None,
3161             "min_guarantee": None,
3162         }
3163         self.assertEqual(
3164             {
3165                 "definition": True,
3166                 "disk": {"attached": [], "detached": [], "updated": []},
3167                 "interface": {"attached": [], "detached": []},
3168             },
3169             virt.update("vm_with_memtune_param", mem=memtune_none),
3170         )
3171 <a name="7"></a>        setxml = ET.fromstring(define_mock.call_args[0][0])
3172         self.assertEqual(setxml.find("memtune").find("soft_limit"), None)
3173         self.assertEqual(setxml.find("memtune").find("hard_limit"), None)
3174         self.assertEqual(setxml<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("memtune").find("swap_hard_limit"), None)
3175         self.assertEqual(setxml.find("memtune").find("min_guarantee"), None)
3176         max_none = {
3177             "max"</b></font>: None,
3178         }
3179         self.assertEqual(
3180             {
3181                 "definition": True,
3182                 "disk": {"attached": [], "detached": [], "updated": []},
3183                 "interface": {"attached": [], "detached": []},
3184             },
3185             virt.update("vm_with_memtune_param", mem=max_none),
3186         )
3187         setxml = ET.fromstring(define_mock.call_args[0][0])
3188         self.assertEqual(setxml.find("maxMemory"), None)
3189         self.assertEqual(setxml.find("currentMemory").text, str(int(1 * 1024 ** 2)))
3190         self.assertEqual(setxml.find("memory").text, str(int(1 * 1024 ** 2)))
3191     def test_update_exist_memorybacking_params(self):
3192         xml_with_memback_params = """
3193             &lt;domain type='kvm' id='8'&gt;
3194               &lt;name&gt;vm_with_memback_param&lt;/name&gt;
3195               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3196               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3197               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3198               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3199               &lt;memoryBacking&gt;
3200                 &lt;hugepages&gt;
3201                   &lt;page size="2048" unit="KiB"/&gt;
3202                   &lt;page size="3145728" nodeset="1-4,^3" unit="KiB"/&gt;
3203                   &lt;page size="1048576" nodeset="3" unit="KiB"/&gt;
3204                 &lt;/hugepages&gt;
3205                 &lt;nosharepages/&gt;
3206                 &lt;locked/&gt;
3207                 &lt;source type="file"/&gt;
3208                 &lt;access mode="shared"/&gt;
3209                 &lt;discard/&gt;
3210               &lt;/memoryBacking&gt;
3211               &lt;os&gt;
3212                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3213               &lt;/os&gt;
3214               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
3215             &lt;/domain&gt;
3216         """
3217         domain_mock = self.set_mock_vm("vm_with_memback_param", xml_with_memback_params)
3218         domain_mock.OSType = MagicMock(return_value="hvm")
3219         define_mock = MagicMock(return_value=True)
3220         self.mock_conn.defineXML = define_mock
3221         mem_back_param = {
3222             "hugepages": [
3223                 {"nodeset": "1-4,^3", "size": "1g"},
3224                 {"nodeset": "3", "size": "2g"},
3225             ],
3226             "nosharepages": None,
3227             "locked": None,
3228             "source": "anonymous",
3229             "access": "private",
3230             "allocation": "ondemand",
3231             "discard": None,
3232         }
3233         self.assertEqual(
3234             {
3235                 "definition": True,
3236                 "disk": {"attached": [], "detached": [], "updated": []},
3237                 "interface": {"attached": [], "detached": []},
3238             },
3239             virt.update("vm_with_memback_param", mem=mem_back_param),
3240         )
3241         setxml = ET.fromstring(define_mock.call_args[0][0])
3242         self.assertDictEqual(
3243             {
3244                 p.get("nodeset"): {"size": p.get("size"), "unit": p.get("unit")}
3245                 for p in setxml.findall("memoryBacking/hugepages/page")
3246             },
3247             {
3248                 "1,2,4": {"size": str(1024 ** 3), "unit": "bytes"},
3249                 "3": {"size": str(2 * 1024 ** 3), "unit": "bytes"},
3250             },
3251         )
3252         self.assertEqual(setxml.find("./memoryBacking/nosharepages"), None)
3253         self.assertEqual(setxml.find("./memoryBacking/locked"), None)
3254         self.assertEqual(
3255             setxml.find("./memoryBacking/source").attrib["type"], "anonymous"
3256         )
3257         self.assertEqual(
3258             setxml.find("./memoryBacking/access").attrib["mode"], "private"
3259         )
3260         self.assertEqual(
3261             setxml.find("./memoryBacking/allocation").attrib["mode"], "ondemand"
3262         )
3263         self.assertEqual(setxml.find("./memoryBacking/discard"), None)
3264         unchanged_page = {
3265             "hugepages": [
3266                 {"size": "2m"},
3267                 {"nodeset": "1-4,^3", "size": "3g"},
3268                 {"nodeset": "3", "size": "1g"},
3269             ],
3270         }
3271         self.assertEqual(
3272             {
3273                 "definition": False,
3274                 "disk": {"attached": [], "detached": [], "updated": []},
3275                 "interface": {"attached": [], "detached": []},
3276             },
3277             virt.update("vm_with_memback_param", mem=unchanged_page),
3278         )
3279     def test_update_iothreads_params(self):
3280         xml_with_iothreads_params = """
3281             &lt;domain type='kvm' id='8'&gt;
3282               &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
3283               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3284               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3285               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3286               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3287               &lt;iothreads&gt;6&lt;/iothreads&gt;
3288               &lt;os&gt;
3289                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3290               &lt;/os&gt;
3291             &lt;/domain&gt;
3292         """
3293         domain_mock = self.set_mock_vm(
3294             "xml_with_iothreads_params", xml_with_iothreads_params
3295         )
3296         domain_mock.OSType = MagicMock(return_value="hvm")
3297         define_mock = MagicMock(return_value=True)
3298         self.mock_conn.defineXML = define_mock
3299         self.assertEqual(
3300             {
3301                 "definition": True,
3302                 "disk": {"attached": [], "detached": [], "updated": []},
3303                 "interface": {"attached": [], "detached": []},
3304             },
3305             virt.update("xml_with_iothreads_params", cpu={"iothreads": 7}),
3306         )
3307         setxml = ET.fromstring(define_mock.call_args[0][0])
3308         self.assertEqual(setxml.find("iothreads").text, "7")
3309     def test_update_cputune_paramters(self):
3310         xml_with_cputune_params = """
3311                     &lt;domain type='kvm' id='8'&gt;
3312                       &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
3313                       &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3314                       &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3315                       &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3316                       &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3317                       &lt;iothreads&gt;4&lt;/iothreads&gt;
3318                       &lt;cputune&gt;
3319                         &lt;shares&gt;2048&lt;/shares&gt;
3320                         &lt;period&gt;1000000&lt;/period&gt;
3321                         &lt;quota&gt;-1&lt;/quota&gt;
3322                         &lt;global_period&gt;1000000&lt;/global_period&gt;
3323                         &lt;global_quota&gt;-1&lt;/global_quota&gt;
3324                         &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
3325                         &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
3326                         &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
3327                         &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
3328                         &lt;vcpupin vcpu="0" cpuset="0-2"/&gt;
3329                         &lt;vcpupin vcpu="1" cpuset="3"/&gt;
3330                         &lt;vcpupin vcpu="2" cpuset="4"/&gt;
3331                         &lt;vcpupin vcpu="3" cpuset="5-7"/&gt;
3332                         &lt;emulatorpin cpuset="1-2"/&gt;
3333                         &lt;iothreadpin iothread="1" cpuset="1-5"/&gt;
3334                         &lt;iothreadpin iothread="2" cpuset="6-7"/&gt;
3335                         &lt;vcpusched vcpus="0" scheduler="idle" priority="3"/&gt;
3336                         &lt;vcpusched vcpus="1" scheduler="rr" priority="1"/&gt;
3337                         &lt;vcpusched vcpus="2" scheduler="fifo" priority="2"/&gt;
3338                         &lt;iothreadsched iothreads="4" scheduler="fifo"/&gt;
3339                         &lt;emulatorsched scheduler="idle"/&gt;
3340                         &lt;cachetune vcpus="0-4"&gt;
3341                           &lt;cache id="0" level="2" type="both" size="4" unit="KiB"/&gt;
3342                           &lt;cache id="1" level="2" type="both" size="4" unit="KiB"/&gt;
3343                           &lt;monitor level="5" vcpus="0-2"/&gt;
3344                           &lt;monitor level="6" vcpus="1-3"/&gt;
3345                         &lt;/cachetune&gt;
3346                         &lt;cachetune vcpus="5-8"&gt;
3347                           &lt;monitor level="5" vcpus="5-6"/&gt;
3348                           &lt;monitor level="3" vcpus="7-8"/&gt;
3349                         &lt;/cachetune&gt;
3350                         &lt;memorytune vcpus="0-6"&gt;
3351                           &lt;node id="0" bandwidth="45"/&gt;
3352                         &lt;/memorytune&gt;
3353                         &lt;memorytune vcpus="7-8"&gt;
3354                           &lt;node id="0" bandwidth="120"/&gt;
3355                         &lt;/memorytune&gt;
3356                       &lt;/cputune&gt;
3357                       &lt;os&gt;
3358                         &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3359                       &lt;/os&gt;
3360                     &lt;/domain&gt;
3361                 """
3362         domain_mock = self.set_mock_vm(
3363             "xml_with_cputune_params", xml_with_cputune_params
3364         )
3365         domain_mock.OSType = MagicMock(return_value="hvm")
3366         define_mock = MagicMock(return_value=True)
3367         self.mock_conn.defineXML = define_mock
3368         cputune = {
3369             "shares": 1024,
3370             "period": 5000,
3371             "quota": -20,
3372             "global_period": 4000,
3373             "global_quota": -30,
3374             "emulator_period": 3000,
3375             "emulator_quota": -4,
3376             "iothread_period": 7000,
3377             "iothread_quota": -5,
3378             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
3379             "emulatorpin": "1-3",
3380             "iothreadpin": {1: "5-6", 2: "7-8"},
3381             "vcpusched": [
3382                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
3383                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
3384                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
3385             ],
3386             "iothreadsched": [
3387                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1}
3388             ],
3389             "emulatorsched": {"scheduler": "rr", "priority": 2},
3390             "cachetune": {
3391                 "0-3": {
3392                     0: {"level": 3, "type": "both", "size": 3},
3393                     1: {"level": 3, "type": "both", "size": 3},
3394                     "monitor": {1: 3, "0-3": 3},
3395                 },
3396                 "4-5": {"monitor": {4: 3, 5: 2}},
3397             },
3398             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
3399         }
3400         self.assertEqual(
3401             {
3402                 "definition": True,
3403                 "disk": {"attached": [], "detached": [], "updated": []},
3404                 "interface": {"attached": [], "detached": []},
3405             },
3406             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3407         )
3408         setxml = ET.fromstring(define_mock.call_args[0][0])
3409         self.assertEqual(setxml.find("cputune").find("shares").text, "1024")
3410         self.assertEqual(setxml.find("cputune").find("period").text, "5000")
3411         self.assertEqual(setxml.find("cputune").find("quota").text, "-20")
3412         self.assertEqual(setxml.find("cputune").find("global_period").text, "4000")
3413         self.assertEqual(setxml.find("cputune").find("global_quota").text, "-30")
3414         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "3000")
3415         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3416         self.assertEqual(setxml.find("cputune").find("iothread_period").text, "7000")
3417         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3418         self.assertEqual(
3419             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3420             "1,3,4",
3421         )
3422         self.assertEqual(
3423             setxml.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
3424             "0,1",
3425         )
3426         self.assertEqual(
3427             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3428             "2,3",
3429         )
3430         self.assertEqual(
3431             setxml.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
3432             "0,4",
3433         )
3434         self.assertEqual(
3435             setxml.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1,2,3"
3436         )
3437         self.assertEqual(
3438             setxml.find("cputune")
3439             .find("iothreadpin[@iothread='1']")
3440             .attrib.get("cpuset"),
3441             "5,6",
3442         )
3443         self.assertEqual(
3444             setxml.find("cputune")
3445             .find("iothreadpin[@iothread='2']")
3446             .attrib.get("cpuset"),
3447             "7,8",
3448         )
3449         self.assertDictEqual(
3450             {
3451                 s.get("vcpus"): {
3452                     "scheduler": s.get("scheduler"),
3453                     "priority": s.get("priority"),
3454                 }
3455                 for s in setxml.findall("cputune/vcpusched")
3456             },
3457             {
3458                 "0": {"scheduler": "fifo", "priority": "1"},
3459                 "1": {"scheduler": "fifo", "priority": "2"},
3460                 "2": {"scheduler": "idle", "priority": "3"},
3461             },
3462         )
3463         self.assertDictEqual(
3464             {
3465                 s.get("iothreads"): {
3466                     "scheduler": s.get("scheduler"),
3467                     "priority": s.get("priority"),
3468                 }
3469                 for s in setxml.findall("cputune/iothreadsched")
3470             },
3471             {"5,6,7": {"scheduler": "batch", "priority": "1"}},
3472         )
3473         self.assertEqual(setxml.find("cputune/emulatorsched").get("scheduler"), "rr")
3474         self.assertEqual(setxml.find("cputune/emulatorsched").get("priority"), "2")
3475         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3476         self.assertEqual(
3477             setxml.find(
3478                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3479             ).attrib.get("level"),
3480             "3",
3481         )
3482         self.assertEqual(
3483             setxml.find(
3484                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3485             ).attrib.get("type"),
3486             "both",
3487         )
3488         self.assertEqual(
3489             setxml.find(
3490                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"
3491             ).attrib.get("level"),
3492             "3",
3493         )
3494         self.assertNotEqual(
3495             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"),
3496             None,
3497         )
3498         self.assertNotEqual(
3499             setxml.find("./cputune/cachetune[@vcpus='4,5']").attrib.get("vcpus"), None
3500         )
3501         self.assertEqual(
3502             setxml.find("./cputune/cachetune[@vcpus='4,5']/cache[@id='0']"), None
3503         )
3504         self.assertEqual(
3505             setxml.find(
3506                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']"
3507             ).attrib.get("level"),
3508             "3",
3509         )
3510         self.assertEqual(
3511             setxml.find(
3512                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']"
3513             ).attrib.get("level"),
3514             "2",
3515         )
3516         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3517         self.assertEqual(
3518             setxml.find(
3519                 "./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']"
3520             ).attrib.get("bandwidth"),
3521             "60",
3522         )
3523         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='3,4']"), None)
3524         self.assertEqual(
3525             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3526                 "bandwidth"
3527             ),
3528             "50",
3529         )
3530         self.assertEqual(
3531             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3532                 "bandwidth"
3533             ),
3534             "70",
3535         )
3536         cputune = {
3537             "shares": None,
3538             "period": 20000,
3539             "quota": None,
3540             "global_period": 5000,
3541             "global_quota": None,
3542             "emulator_period": 2000,
3543             "emulator_quota": -4,
3544             "iothread_period": None,
3545             "iothread_quota": -5,
3546             "vcpupin": {0: "1-4,^2", 2: "2,4"},
3547             "emulatorpin": None,
3548             "iothreadpin": {1: "5-6"},
3549             "vcpusched": [{"scheduler": "idle", "priority": 5, "vcpus": "1"}],
3550             "iothreadsched": None,
3551             "cachetune": {
3552                 "0-3": {
3553                     0: {"level": 4, "type": "data", "size": 7},
3554                     "monitor": {"1-2": 11},
3555                 },
3556             },
3557             "memorytune": {"3-4": {0: 37, 1: 73}},
3558         }
3559         self.assertEqual(
3560             {
3561                 "definition": True,
3562                 "disk": {"attached": [], "detached": [], "updated": []},
3563                 "interface": {"attached": [], "detached": []},
3564             },
3565             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3566         )
3567         setxml = ET.fromstring(define_mock.call_args[0][0])
3568         self.assertEqual(setxml.find("cputune").find("shares"), None)
3569         self.assertEqual(setxml.find("cputune").find("period").text, "20000")
3570         self.assertEqual(setxml.find("cputune").find("quota"), None)
3571         self.assertEqual(setxml.find("cputune").find("global_period").text, "5000")
3572         self.assertEqual(setxml.find("cputune").find("global_quota"), None)
3573         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "2000")
3574         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3575         self.assertEqual(setxml.find("cputune").find("iothread_period"), None)
3576         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3577         self.assertEqual(
3578             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3579             "1,3,4",
3580         )
3581         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='1']"), None)
3582         self.assertEqual(
3583             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3584             "2,4",
3585         )
3586         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='3']"), None)
3587         self.assertEqual(setxml.find("cputune").find("emulatorpin"), None)
3588         self.assertEqual(
3589             setxml.find("cputune")
3590             .find("iothreadpin[@iothread='1']")
3591             .attrib.get("cpuset"),
3592             "5,6",
3593         )
3594         self.assertEqual(
3595             setxml.find("cputune").find("iothreadpin[@iothread='2']"), None
3596         )
3597         self.assertDictEqual(
3598             {
3599                 s.get("vcpus"): {
3600                     "scheduler": s.get("scheduler"),
3601                     "priority": s.get("priority"),
3602                 }
3603                 for s in setxml.findall("cputune/vcpusched")
3604             },
3605             {"1": {"scheduler": "idle", "priority": "5"}},
3606         )
3607         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3608         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3609         self.assertEqual(
3610             setxml.find(
3611                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3612             ).attrib.get("size"),
3613             "7",
3614         )
3615         self.assertEqual(
3616             setxml.find(
3617                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3618             ).attrib.get("level"),
3619             "4",
3620         )
3621         self.assertEqual(
3622             setxml.find(
3623                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3624             ).attrib.get("type"),
3625             "data",
3626         )
3627         self.assertEqual(
3628             setxml.find(
3629                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']"
3630             ).attrib.get("level"),
3631             "11",
3632         )
3633         self.assertEqual(
3634             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']"),
3635             None,
3636         )
3637         self.assertEqual(
3638             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']"), None
3639         )
3640         self.assertEqual(setxml.find("./cputune/cachetune[@vcpus='4,5']"), None)
3641         self.assertEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3642         self.assertEqual(
3643             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3644                 "bandwidth"
3645             ),
3646             "37",
3647         )
3648         self.assertEqual(
3649             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3650                 "bandwidth"
3651             ),
3652             "73",
3653         )
3654         cputune_subelement = {
3655             "vcpupin": None,
3656             "iothreadpin": None,
3657             "vcpusched": None,
3658             "iothreadsched": None,
3659             "cachetune": None,
3660             "memorytune": None,
3661         }
3662         self.assertEqual(
3663             {
3664                 "definition": True,
3665                 "disk": {"attached": [], "detached": [], "updated": []},
3666                 "interface": {"attached": [], "detached": []},
3667             },
3668             virt.update("xml_with_cputune_params", cpu={"tuning": cputune_subelement}),
3669         )
3670         setxml = ET.fromstring(define_mock.call_args[0][0])
3671         self.assertEqual(setxml.find("cputune").find("vcpupin"), None)
3672         self.assertEqual(setxml.find("cputune").find("iothreadpin"), None)
3673         self.assertEqual(setxml.find("cputune").find("vcpusched"), None)
3674         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3675         self.assertEqual(setxml.find("cputune").find("cachetune"), None)
3676         self.assertEqual(setxml.find("cputune").find("memorytune"), None)
3677     def test_handle_unit(self):
3678         valid_case = [
3679             ("2", 2097152),
3680             ("42", 44040192),
3681             ("5b", 5),
3682             ("2.3Kib", 2355),
3683             ("5.8Kb", 5800),
3684             ("16MiB", 16777216),
3685             ("20 GB", 20000000000),
3686             ("16KB", 16000),
3687             (".5k", 512),
3688             ("2.k", 2048),
3689         ]
3690         for key, val in valid_case:
3691             self.assertEqual(virt._handle_unit(key), val)
3692         invalid_case = [
3693             ("9ib", "invalid units"),
3694             ("8byte", "invalid units"),
3695             ("512bytes", "invalid units"),
3696             ("4 Kbytes", "invalid units"),
3697             ("3.4.MB", "invalid number"),
3698             ("", "invalid number"),
3699             ("bytes", "invalid number"),
3700             ("2HB", "invalid units"),
3701         ]
3702         for key, val in invalid_case:
3703             with self.assertRaises(SaltInvocationError):
3704                 virt._handle_unit(key)
3705     def test_mixed_dict_and_list_as_profile_objects(self):
3706         yaml_config = """
3707           virt:
3708              nic:
3709                 new-listonly-profile:
3710                    - bridge: br0
3711                      name: eth0
3712                    - model: virtio
3713                      name: eth1
3714                      source: test_network
3715                      type: network
3716                 new-list-with-legacy-names:
3717                    - eth0:
3718                         bridge: br0
3719                    - eth1:
3720                         bridge: br1
3721                         model: virtio
3722                 non-default-legacy-profile:
3723                    eth0:
3724                       bridge: br0
3725                    eth1:
3726                       bridge: br1
3727                       model: virtio
3728         Test virt.get_xml()
3729         domain = self.set_mock_vm("test-vm", xml)
3730         self.assertEqual(xml, virt.get_xml("test-vm"))
3731         self.assertEqual(xml, virt.get_xml(domain))
3732     def test_get_loader(self):
3733         xml = """&lt;domain type='kvm' id='7'&gt;
3734               &lt;name&gt;test-vm&lt;/name&gt;
3735               &lt;os&gt;
3736                 &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
3737               &lt;/os&gt;
3738             &lt;/domain&gt;
3739         """
3740         self.set_mock_vm("test-vm", xml)
3741         loader = virt.get_loader("test-vm")
3742         self.assertEqual("/foo/bar", loader["path"])
3743         self.assertEqual("yes", loader["readonly"])
3744     def test_cpu_baseline(self):
3745         capabilities_xml = dedent(
3746         Make sure that qemu-img info output is properly parsed
3747         Test virt.purge() with default parameters
3748         self.set_mock_vm("test-vm", xml)
3749         qemu_infos = """[{
3750             "virtual-size": 25769803776,
3751             "filename": "/disks/test.qcow2",
3752             "cluster-size": 65536,
3753             "format": "qcow2",
3754             "actual-size": 217088,
3755             "format-specific": {
3756                 "type": "qcow2",
3757                 "data": {
3758                     "compat": "1.1",
3759                     "lazy-refcounts": false,
3760                     "refcount-bits": 16,
3761                     "corrupt": false
3762                 }
3763             },
3764             "dirty-flag": false
3765         }]"""
3766         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3767         self.mock_popen.returncode = 0
3768         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3769             res = virt.purge("test-vm")
3770             self.assertTrue(res)
3771             mock_remove.assert_called_once()
3772             mock_remove.assert_any_call("/disks/test.qcow2")
3773     @patch("salt.modules.virt.stop", return_value=True)
3774     @patch("salt.modules.virt.undefine")
3775     def test_purge_volumes(self, mock_undefine, mock_stop):
3776         xml = """&lt;domain type='kvm' id='7'&gt;
3777               &lt;name&gt;test-vm&lt;/name&gt;
3778               &lt;devices&gt;
3779                 &lt;disk type='volume' device='disk'&gt;
3780                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
3781                   &lt;source pool='default' volume='vm05_system'/&gt;
3782                   &lt;backingStore type='file' index='1'&gt;
3783                     &lt;format type='qcow2'/&gt;
3784                     &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
3785                     &lt;backingStore type='file' index='2'&gt;
3786                       &lt;format type='qcow2'/&gt;
3787                       &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
3788                       &lt;backingStore/&gt;
3789                     &lt;/backingStore&gt;
3790                   &lt;/backingStore&gt;
3791                   &lt;target dev='vda' bus='virtio'/&gt;
3792                   &lt;alias name='virtio-disk0'/&gt;
3793                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
3794                 &lt;/disk&gt;
3795               &lt;/devices&gt;
3796             &lt;/domain&gt;
3797         """
3798         self.set_mock_vm("test-vm", xml)
3799         pool_mock = MagicMock()
3800         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3801             0,
3802             1234567,
3803             12345,
3804         ]
3805         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3806         ]
3807         pool_mock.listVolumes.return_value = ["vm05_system", "vm04_system.qcow2"]
3808         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3809         self.mock_conn.listStoragePools.return_value = ["default"]
3810         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3811             res = virt.purge("test-vm")
3812             self.assertTrue(res)
3813             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3814     @patch("salt.modules.virt.stop", return_value=True)
3815     @patch("salt.modules.virt.undefine")
3816     def test_purge_rbd(self, mock_undefine, mock_stop):
3817         xml = """&lt;domain type='kvm' id='7'&gt;
3818               &lt;name&gt;test-vm&lt;/name&gt;
3819               &lt;devices&gt;
3820                 &lt;disk type="network" device="disk"&gt;
3821                   &lt;driver name='raw' type='qcow2'/&gt;
3822                   &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
3823                     &lt;host name='ses2.tf.local'/&gt;
3824                     &lt;host name='ses3.tf.local' port='1234'/&gt;
3825                     &lt;auth username='libvirt'&gt;
3826                       &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
3827                     &lt;/auth&gt;
3828                   &lt;/source&gt;
3829                   &lt;target dev='vdc' bus='virtio'/&gt;
3830                   &lt;alias name='virtio-disk2'/&gt;
3831                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
3832                 &lt;/disk&gt;
3833               &lt;/devices&gt;
3834             &lt;/domain&gt;
3835         """
3836         self.set_mock_vm("test-vm", xml)
3837         pool_mock = MagicMock()
3838         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3839             0,
3840             1234567,
3841             12345,
3842         ]
3843         pool_mock.XMLDesc.return_value = """
3844         &lt;pool type='rbd'&gt;
3845           &lt;name&gt;test-ses&lt;/name&gt;
3846           &lt;source&gt;
3847             &lt;host name='ses2.tf.local'/&gt;
3848             &lt;name&gt;libvirt-pool&lt;/name&gt;
3849             &lt;auth type='ceph' username='libvirt'&gt;
3850               &lt;secret usage='pool_test-ses'/&gt;
3851             &lt;/auth&gt;
3852           &lt;/source&gt;
3853         &lt;/pool&gt;
3854         """
3855         pool_mock.name.return_value = "test-ses"
3856         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3857         ]
3858         pool_mock.listVolumes.return_value = ["my_vm_data2"]
3859         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
3860         self.mock_conn.listStoragePools.return_value = ["test-ses"]
3861         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3862         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3863             res = virt.purge("test-vm")
3864             self.assertTrue(res)
3865             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3866     @patch("salt.modules.virt.stop", return_value=True)
3867     @patch("salt.modules.virt.undefine")
3868     @patch("os.remove")
3869     def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
3870         xml = """&lt;domain type="kvm" id="7"&gt;
3871               &lt;name&gt;test-vm&lt;/name&gt;
3872               &lt;devices&gt;
3873                 &lt;disk type='file' device='disk'&gt;
3874                 &lt;driver name='qemu' type='qcow2'/&gt;
3875                 &lt;source file='/disks/test.qcow2'/&gt;
3876                 &lt;target dev='vda' bus='virtio'/&gt;
3877               &lt;/disk&gt;
3878               &lt;disk type='file' device='cdrom'&gt;
3879                 &lt;driver name='qemu' type='raw'/&gt;
3880                 &lt;source file='/disks/test-cdrom.iso'/&gt;
3881                 &lt;target dev='hda' bus='ide'/&gt;
3882                 &lt;readonly/&gt;
3883               &lt;/disk&gt;
3884               &lt;disk type='file' device='floppy'&gt;
3885                 &lt;driver name='qemu' type='raw'/&gt;
3886                 &lt;source file='/disks/test-floppy.iso'/&gt;
3887                 &lt;target dev='hdb' bus='ide'/&gt;
3888                 &lt;readonly/&gt;
3889               &lt;/disk&gt;
3890               &lt;/devices&gt;
3891             &lt;/domain&gt;
3892         """
3893         self.set_mock_vm("test-vm", xml)
3894         qemu_infos = """[{
3895             "virtual-size": 25769803776,
3896             "filename": "/disks/test.qcow2",
3897             "cluster-size": 65536,
3898             "format": "qcow2",
3899             "actual-size": 217088,
3900             "format-specific": {
3901                 "type": "qcow2",
3902                 "data": {
3903                     "compat": "1.1",
3904                     "lazy-refcounts": false,
3905                     "refcount-bits": 16,
3906                     "corrupt": false
3907                 }
3908             },
3909             "dirty-flag": false
3910         }]"""
3911         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3912         self.mock_popen.returncode = 0
3913         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3914             res = virt.purge("test-vm", removables=True)
3915             self.assertTrue(res)
3916             mock_remove.assert_any_call("/disks/test.qcow2")
3917             mock_remove.assert_any_call("/disks/test-cdrom.iso")
3918     def test_capabilities(self):
3919         xml = """
3920 &lt;capabilities&gt;
3921   &lt;host&gt;
3922     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
3923     &lt;cpu&gt;
3924       &lt;arch&gt;x86_64&lt;/arch&gt;
3925       &lt;model&gt;Nehalem&lt;/model&gt;
3926       &lt;vendor&gt;Intel&lt;/vendor&gt;
3927       &lt;microcode version='25'/&gt;
3928       &lt;topology sockets='1' cores='4' threads='2'/&gt;
3929       &lt;feature name='vme'/&gt;
3930       &lt;feature name='ds'/&gt;
3931       &lt;feature name='acpi'/&gt;
3932       &lt;pages unit='KiB' size='4'/&gt;
3933       &lt;pages unit='KiB' size='2048'/&gt;
3934     &lt;/cpu&gt;
3935     &lt;power_management&gt;
3936       &lt;suspend_mem/&gt;
3937       &lt;suspend_disk/&gt;
3938       &lt;suspend_hybrid/&gt;
3939     &lt;/power_management&gt;
3940     &lt;migration_features&gt;
3941       &lt;live/&gt;
3942       &lt;uri_transports&gt;
3943         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
3944         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
3945       &lt;/uri_transports&gt;
3946     &lt;/migration_features&gt;
3947     &lt;topology&gt;
3948       &lt;cells num='1'&gt;
3949         &lt;cell id='0'&gt;
3950           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
3951           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
3952           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
3953           &lt;distances&gt;
3954             &lt;sibling id='0' value='10'/&gt;
3955           &lt;/distances&gt;
3956           &lt;cpus num='8'&gt;
3957             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
3958             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
3959             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
3960             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
3961             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
3962             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
3963             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
3964             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
3965           &lt;/cpus&gt;
3966         &lt;/cell&gt;
3967       &lt;/cells&gt;
3968     &lt;/topology&gt;
3969     &lt;cache&gt;
3970       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
3971     &lt;/cache&gt;
3972     &lt;secmodel&gt;
3973       &lt;model&gt;apparmor&lt;/model&gt;
3974       &lt;doi&gt;0&lt;/doi&gt;
3975     &lt;/secmodel&gt;
3976     &lt;secmodel&gt;
3977       &lt;model&gt;dac&lt;/model&gt;
3978       &lt;doi&gt;0&lt;/doi&gt;
3979       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
3980       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
3981     &lt;/secmodel&gt;
3982   &lt;/host&gt;
3983   &lt;guest&gt;
3984     &lt;os_type&gt;hvm&lt;/os_type&gt;
3985     &lt;arch name='i686'&gt;
3986       &lt;wordsize&gt;32&lt;/wordsize&gt;
3987       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
3988       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3989       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3990       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3991       &lt;domain type='qemu'/&gt;
3992       &lt;domain type='kvm'&gt;
3993         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
3994         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3995         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3996         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3997       &lt;/domain&gt;
3998     &lt;/arch&gt;
3999     &lt;features&gt;
4000       &lt;cpuselection/&gt;
4001       &lt;deviceboot/&gt;
4002       &lt;disksnapshot default='on' toggle='no'/&gt;
4003       &lt;acpi default='off' toggle='yes'/&gt;
4004       &lt;apic default='on' toggle='no'/&gt;
4005       &lt;pae/&gt;
4006       &lt;nonpae/&gt;
4007     &lt;/features&gt;
4008   &lt;/guest&gt;
4009   &lt;guest&gt;
4010     &lt;os_type&gt;hvm&lt;/os_type&gt;
4011     &lt;arch name='x86_64'&gt;
4012       &lt;wordsize&gt;64&lt;/wordsize&gt;
4013       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4014       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4015       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4016       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4017       &lt;domain type='qemu'/&gt;
4018       &lt;domain type='kvm'&gt;
4019         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4020         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4021         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4022         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4023       &lt;/domain&gt;
4024     &lt;/arch&gt;
4025     &lt;features&gt;
4026       &lt;cpuselection/&gt;
4027       &lt;deviceboot/&gt;
4028       &lt;disksnapshot default='on' toggle='no'/&gt;
4029       &lt;acpi default='on' toggle='yes'/&gt;
4030       &lt;apic default='off' toggle='no'/&gt;
4031     &lt;/features&gt;
4032   &lt;/guest&gt;
4033   &lt;guest&gt;
4034     &lt;os_type&gt;xen&lt;/os_type&gt;
4035     &lt;arch name='x86_64'&gt;
4036       &lt;wordsize&gt;64&lt;/wordsize&gt;
4037       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4038       &lt;machine&gt;xenpv&lt;/machine&gt;
4039       &lt;domain type='xen'/&gt;
4040     &lt;/arch&gt;
4041   &lt;/guest&gt;
4042 &lt;/capabilities&gt;
4043         """
4044         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
4045         caps = virt.capabilities()
4046         expected = {
4047             "host": {
4048                 "uuid": "44454c4c-3400-105a-8033-b3c04f4b344a",
4049                 "cpu": {
4050                     "arch": "x86_64",
4051                     "model": "Nehalem",
4052                     "vendor": "Intel",
4053                     "microcode": "25",
4054                     "sockets": 1,
4055                     "cores": 4,
4056                     "threads": 2,
4057                     "features": ["vme", "ds", "acpi"],
4058                     "pages": [{"size": "4 KiB"}, {"size": "2048 KiB"}],
4059                 },
4060                 "power_management": ["suspend_mem", "suspend_disk", "suspend_hybrid"],
4061                 "migration": {"live": True, "transports": ["tcp", "rdma"]},
4062                 "topology": {
4063                     "cells": [
4064                         {
4065                             "id": 0,
4066                             "memory": "12367120 KiB",
4067                             "pages": [
4068                                 {"size": "4 KiB", "available": 3091780},
4069                                 {"size": "2048 KiB", "available": 0},
4070                             ],
4071                             "distances": {0: 10},
4072                             "cpus": [
4073                                 {
4074                                     "id": 0,
4075                                     "socket_id": 0,
4076                                     "core_id": 0,
4077                                     "siblings": "0,4",
4078                                 },
4079                                 {
4080                                     "id": 1,
4081                                     "socket_id": 0,
4082                                     "core_id": 1,
4083                                     "siblings": "1,5",
4084                                 },
4085                                 {
4086                                     "id": 2,
4087                                     "socket_id": 0,
4088                                     "core_id": 2,
4089                                     "siblings": "2,6",
4090                                 },
4091                                 {
4092                                     "id": 3,
4093                                     "socket_id": 0,
4094                                     "core_id": 3,
4095                                     "siblings": "3,7",
4096                                 },
4097                                 {
4098                                     "id": 4,
4099                                     "socket_id": 0,
4100                                     "core_id": 0,
4101                                     "siblings": "0,4",
4102                                 },
4103                                 {
4104                                     "id": 5,
4105                                     "socket_id": 0,
4106                                     "core_id": 1,
4107                                     "siblings": "1,5",
4108                                 },
4109                                 {
4110                                     "id": 6,
4111                                     "socket_id": 0,
4112                                     "core_id": 2,
4113                                     "siblings": "2,6",
4114                                 },
4115                                 {
4116                                     "id": 7,
4117                                     "socket_id": 0,
4118                                     "core_id": 3,
4119                                     "siblings": "3,7",
4120                                 },
4121                             ],
4122                         }
4123                     ]
4124                 },
4125                 "cache": {
4126                     "banks": [
4127                         {
4128                             "id": 0,
4129                             "level": 3,
4130                             "type": "both",
4131                             "size": "8 MiB",
4132                             "cpus": "0-7",
4133                         }
4134                     ]
4135                 },
4136                 "security": [
4137                     {"model": "apparmor", "doi": "0", "baselabels": []},
4138                     {
4139                         "model": "dac",
4140                         "doi": "0",
4141                         "baselabels": [
4142                             {"type": "kvm", "label": "+487:+486"},
4143                             {"type": "qemu", "label": "+487:+486"},
4144                         ],
4145                     },
4146                 ],
4147             },
4148             "guests": [
4149                 {
4150                     "os_type": "hvm",
4151                     "arch": {
4152                         "name": "i686",
4153                         "wordsize": 32,
4154                         "emulator": "/usr/bin/qemu-system-i386",
4155                         "machines": {
4156                             "pc-i440fx-2.6": {
4157                                 "maxcpus": 255,
4158                                 "alternate_names": ["pc"],
4159                             },
4160                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4161                         },
4162                         "domains": {
4163                             "qemu": {"emulator": None, "machines": {}},
4164                             "kvm": {
4165                                 "emulator": "/usr/bin/qemu-kvm",
4166                                 "machines": {
4167                                     "pc-i440fx-2.6": {
4168                                         "maxcpus": 255,
4169                                         "alternate_names": ["pc"],
4170                                     },
4171                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4172                                 },
4173                             },
4174                         },
4175                     },
4176                     "features": {
4177                         "cpuselection": {"default": True, "toggle": False},
4178                         "deviceboot": {"default": True, "toggle": False},
4179                         "disksnapshot": {"default": True, "toggle": False},
4180                         "acpi": {"default": False, "toggle": True},
4181                         "apic": {"default": True, "toggle": False},
4182                         "pae": {"default": True, "toggle": False},
4183                         "nonpae": {"default": True, "toggle": False},
4184                     },
4185                 },
4186                 {
4187                     "os_type": "hvm",
4188                     "arch": {
4189                         "name": "x86_64",
4190                         "wordsize": 64,
4191                         "emulator": "/usr/bin/qemu-system-x86_64",
4192                         "machines": {
4193                             "pc-i440fx-2.6": {
4194                                 "maxcpus": 255,
4195                                 "alternate_names": ["pc"],
4196                             },
4197                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4198                         },
4199                         "domains": {
4200                             "qemu": {"emulator": None, "machines": {}},
4201                             "kvm": {
4202                                 "emulator": "/usr/bin/qemu-kvm",
4203                                 "machines": {
4204                                     "pc-i440fx-2.6": {
4205                                         "maxcpus": 255,
4206                                         "alternate_names": ["pc"],
4207                                     },
4208                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4209                                 },
4210                             },
4211                         },
4212                     },
4213                     "features": {
4214                         "cpuselection": {"default": True, "toggle": False},
4215                         "deviceboot": {"default": True, "toggle": False},
4216                         "disksnapshot": {"default": True, "toggle": False},
4217                         "acpi": {"default": True, "toggle": True},
4218                         "apic": {"default": False, "toggle": False},
4219                     },
4220                 },
4221                 {
4222                     "os_type": "xen",
4223                     "arch": {
4224                         "name": "x86_64",
4225                         "wordsize": 64,
4226                         "emulator": "/usr/bin/qemu-system-x86_64",
4227                         "machines": {"xenpv": {"alternate_names": []}},
4228                         "domains": {"xen": {"emulator": None, "machines": {}}},
4229                     },
4230                 },
4231             ],
4232         }
4233         self.assertEqual(expected, caps)
4234     def test_domain_capabilities(self):
4235         xml = """
4236 &lt;domainCapabilities&gt;
4237   &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
4238   &lt;domain&gt;kvm&lt;/domain&gt;
4239   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4240   &lt;arch&gt;aarch64&lt;/arch&gt;
4241   &lt;vcpu max='255'/&gt;
4242   &lt;iothreads supported='yes'/&gt;
4243   &lt;os supported='yes'&gt;
4244     &lt;loader supported='yes'&gt;
4245       &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
4246       &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
4247       &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
4248       &lt;enum name='type'&gt;
4249         &lt;value&gt;rom&lt;/value&gt;
4250         &lt;value&gt;pflash&lt;/value&gt;
4251       &lt;/enum&gt;
4252       &lt;enum name='readonly'&gt;
4253         &lt;value&gt;yes&lt;/value&gt;
4254         &lt;value&gt;no&lt;/value&gt;
4255       &lt;/enum&gt;
4256     &lt;/loader&gt;
4257   &lt;/os&gt;
4258   &lt;cpu&gt;
4259     &lt;mode name='host-passthrough' supported='yes'/&gt;
4260     &lt;mode name='host-model' supported='yes'&gt;
4261       &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
4262       &lt;vendor&gt;ACME&lt;/vendor&gt;
4263       &lt;feature policy='require' name='vme'/&gt;
4264       &lt;feature policy='require' name='ss'/&gt;
4265     &lt;/mode&gt;
4266     &lt;mode name='custom' supported='yes'&gt;
4267       &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
4268       &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
4269       &lt;model usable='no'&gt;arm1136&lt;/model&gt;
4270     &lt;/mode&gt;
4271   &lt;/cpu&gt;
4272   &lt;devices&gt;
4273     &lt;disk supported='yes'&gt;
4274       &lt;enum name='diskDevice'&gt;
4275         &lt;value&gt;disk&lt;/value&gt;
4276         &lt;value&gt;cdrom&lt;/value&gt;
4277         &lt;value&gt;floppy&lt;/value&gt;
4278         &lt;value&gt;lun&lt;/value&gt;
4279       &lt;/enum&gt;
4280       &lt;enum name='bus'&gt;
4281         &lt;value&gt;fdc&lt;/value&gt;
4282         &lt;value&gt;scsi&lt;/value&gt;
4283         &lt;value&gt;virtio&lt;/value&gt;
4284         &lt;value&gt;usb&lt;/value&gt;
4285         &lt;value&gt;sata&lt;/value&gt;
4286       &lt;/enum&gt;
4287     &lt;/disk&gt;
4288     &lt;graphics supported='yes'&gt;
4289       &lt;enum name='type'&gt;
4290         &lt;value&gt;sdl&lt;/value&gt;
4291         &lt;value&gt;vnc&lt;/value&gt;
4292       &lt;/enum&gt;
4293     &lt;/graphics&gt;
4294     &lt;video supported='yes'&gt;
4295       &lt;enum name='modelType'&gt;
4296         &lt;value&gt;vga&lt;/value&gt;
4297         &lt;value&gt;virtio&lt;/value&gt;
4298       &lt;/enum&gt;
4299     &lt;/video&gt;
4300     &lt;hostdev supported='yes'&gt;
4301       &lt;enum name='mode'&gt;
4302         &lt;value&gt;subsystem&lt;/value&gt;
4303       &lt;/enum&gt;
4304       &lt;enum name='startupPolicy'&gt;
4305         &lt;value&gt;default&lt;/value&gt;
4306         &lt;value&gt;mandatory&lt;/value&gt;
4307         &lt;value&gt;requisite&lt;/value&gt;
4308         &lt;value&gt;optional&lt;/value&gt;
4309       &lt;/enum&gt;
4310       &lt;enum name='subsysType'&gt;
4311         &lt;value&gt;usb&lt;/value&gt;
4312         &lt;value&gt;pci&lt;/value&gt;
4313         &lt;value&gt;scsi&lt;/value&gt;
4314       &lt;/enum&gt;
4315       &lt;enum name='capsType'/&gt;
4316       &lt;enum name='pciBackend'&gt;
4317         &lt;value&gt;default&lt;/value&gt;
4318         &lt;value&gt;kvm&lt;/value&gt;
4319         &lt;value&gt;vfio&lt;/value&gt;
4320       &lt;/enum&gt;
4321     &lt;/hostdev&gt;
4322   &lt;/devices&gt;
4323   &lt;features&gt;
4324     &lt;gic supported='yes'&gt;
4325       &lt;enum name='version'&gt;
4326         &lt;value&gt;3&lt;/value&gt;
4327       &lt;/enum&gt;
4328     &lt;/gic&gt;
4329     &lt;vmcoreinfo supported='yes'/&gt;
4330   &lt;/features&gt;
4331 &lt;/domainCapabilities&gt;
4332         """
4333         self.mock_conn.getDomainCapabilities.return_value = (
4334             xml  # pylint: disable=no-member
4335         )
4336         caps = virt.domain_capabilities()
4337         expected = {
4338             "emulator": "/usr/bin/qemu-system-aarch64",
4339             "domain": "kvm",
4340             "machine": "virt-2.12",
4341             "arch": "aarch64",
4342             "max_vcpus": 255,
4343             "iothreads": True,
4344             "os": {
4345                 "loader": {
4346                     "type": ["rom", "pflash"],
4347                     "readonly": ["yes", "no"],
4348                     "values": [
4349                         "/usr/share/AAVMF/AAVMF_CODE.fd",
4350                         "/usr/share/AAVMF/AAVMF32_CODE.fd",
4351                         "/usr/share/OVMF/OVMF_CODE.fd",
4352                     ],
4353                 }
4354             },
4355             "cpu": {
4356                 "host-passthrough": True,
4357                 "host-model": {
4358                     "model": {"name": "sample-cpu", "fallback": "forbid"},
4359                     "vendor": "ACME",
4360                     "features": {"vme": "require", "ss": "require"},
4361                 },
4362                 "custom": {
4363                     "models": {"pxa262": "unknown", "pxa270-a0": "yes", "arm1136": "no"}
4364                 },
4365             },
4366             "devices": {
4367                 "disk": {
4368                     "diskDevice": ["disk", "cdrom", "floppy", "lun"],
4369                     "bus": ["fdc", "scsi", "virtio", "usb", "sata"],
4370                 },
4371                 "graphics": {"type": ["sdl", "vnc"]},
4372                 "video": {"modelType": ["vga", "virtio"]},
4373                 "hostdev": {
4374                     "mode": ["subsystem"],
4375                     "startupPolicy": ["default", "mandatory", "requisite", "optional"],
4376                     "subsysType": ["usb", "pci", "scsi"],
4377                     "capsType": [],
4378                     "pciBackend": ["default", "kvm", "vfio"],
4379                 },
4380             },
4381             "features": {"gic": {"version": ["3"]}, "vmcoreinfo": {}},
4382         }
4383         self.assertEqual(expected, caps)
4384     def test_all_capabilities(self):
4385         domainXml = """
4386 &lt;domainCapabilities&gt;
4387   &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
4388   &lt;domain&gt;kvm&lt;/domain&gt;
4389   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4390   &lt;arch&gt;x86_64&lt;/arch&gt;
4391   &lt;vcpu max='255'/&gt;
4392   &lt;iothreads supported='yes'/&gt;
4393 &lt;/domainCapabilities&gt;
4394         """
4395         hostXml = """
4396 &lt;capabilities&gt;
4397   &lt;host&gt;
4398     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
4399     &lt;cpu&gt;
4400       &lt;arch&gt;x86_64&lt;/arch&gt;
4401       &lt;model&gt;Nehalem&lt;/model&gt;
4402       &lt;vendor&gt;Intel&lt;/vendor&gt;
4403       &lt;microcode version='25'/&gt;
4404       &lt;topology sockets='1' cores='4' threads='2'/&gt;
4405     &lt;/cpu&gt;
4406   &lt;/host&gt;
4407   &lt;guest&gt;
4408     &lt;os_type&gt;hvm&lt;/os_type&gt;
4409     &lt;arch name='x86_64'&gt;
4410       &lt;wordsize&gt;64&lt;/wordsize&gt;
4411       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4412       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4413       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4414       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4415       &lt;domain type='qemu'/&gt;
4416       &lt;domain type='kvm'&gt;
4417         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4418         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4419         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4420         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4421       &lt;/domain&gt;
4422     &lt;/arch&gt;
4423   &lt;/guest&gt;
4424 &lt;/capabilities&gt;
4425         """
4426         self.mock_conn.getCapabilities.return_value = hostXml
4427         self.mock_conn.getDomainCapabilities.side_effect = [
4428             domainXml,
4429             domainXml.replace("&lt;domain&gt;kvm", "&lt;domain&gt;qemu"),
4430         ]
4431         caps = virt.all_capabilities()
4432         self.assertEqual(
4433             "44454c4c-3400-105a-8033-b3c04f4b344a", caps["host"]["host"]["uuid"]
4434         )
4435         self.assertEqual(
4436             {"qemu", "kvm"},
4437             {domainCaps["domain"] for domainCaps in caps["domains"]},
4438         )
4439         self.assertEqual(
4440             {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
4441             {
4442                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "kvm"),
4443                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "qemu"),
4444             },
4445         )
4446     def test_network_tag(self):
4447         xml_data = virt._gen_net_xml("network", "main", "bridge", "openvswitch", 1001)
4448         root = ET.fromstring(xml_data)
4449         self.assertEqual(root.find("name").text, "network")
4450         self.assertEqual(root.find("bridge").attrib["name"], "main")
4451         self.assertEqual(root.find("forward").attrib["mode"], "bridge")
4452         self.assertEqual(root.find("virtualport").attrib["type"], "openvswitch")
4453         self.assertEqual(root.find("vlan/tag").attrib["id"], "1001")
4454     def test_list_networks(self):
4455         names = ["net1", "default", "net2"]
4456         net_mocks = [MagicMock(), MagicMock(), MagicMock()]
4457         for i, value in enumerate(names):
4458             net_mocks[i].name.return_value = value
4459         self.mock_conn.listAllNetworks.return_value = (
4460             net_mocks  # pylint: disable=no-member
4461         )
4462         actual = virt.list_networks()
4463         self.assertEqual(names, actual)
4464     def test_network_info(self):
4465         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4466         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4467         net_mock = MagicMock()
4468         net_mock.name.return_value = "foo"
4469         net_mock.UUIDString.return_value = "some-uuid"
4470         net_mock.bridgeName.return_value = "br0"
4471         net_mock.autostart.return_value = True
4472         net_mock.isActive.return_value = False
4473         net_mock.isPersistent.return_value = True
4474         net_mock.DHCPLeases.return_value = [
4475             {
4476                 "iface": "virbr0",
4477                 "expirytime": 1527757552,
4478                 "type": 0,
4479                 "mac": "52:54:00:01:71:bd",
4480                 "ipaddr": "192.168.122.45",
4481                 "prefix": 24,
4482                 "hostname": "py3-test",
4483                 "clientid": "01:52:54:00:01:71:bd",
4484                 "iaid": None,
4485             }
4486         ]
4487         self.mock_conn.listAllNetworks.return_value = [net_mock]
4488         net = virt.network_info("foo")
4489         self.assertEqual(
4490             {
4491                 "foo": {
4492                     "uuid": "some-uuid",
4493                     "bridge": "br0",
4494                     "autostart": True,
4495                     "active": False,
4496                     "persistent": True,
4497                     "leases": [
4498                         {
4499                             "iface": "virbr0",
4500                             "expirytime": 1527757552,
4501                             "type": "ipv4",
4502                             "mac": "52:54:00:01:71:bd",
4503                             "ipaddr": "192.168.122.45",
4504                             "prefix": 24,
4505                             "hostname": "py3-test",
4506                             "clientid": "01:52:54:00:01:71:bd",
4507                             "iaid": None,
4508                         }
4509                     ],
4510                 }
4511             },
4512             net,
4513         )
4514     def test_network_info_all(self):
4515         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4516         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4517         net_mocks = []
4518         for i in range(2):
4519             net_mock = MagicMock()
4520             net_mock.name.return_value = "net{}".format(i)
4521             net_mock.UUIDString.return_value = "some-uuid"
4522             net_mock.bridgeName.return_value = "br{}".format(i)
4523             net_mock.autostart.return_value = True
4524             net_mock.isActive.return_value = False
4525             net_mock.isPersistent.return_value = True
4526             net_mock.DHCPLeases.return_value = []
4527             net_mocks.append(net_mock)
4528         self.mock_conn.listAllNetworks.return_value = net_mocks
4529         net = virt.network_info()
4530         self.assertEqual(
4531             {
4532                 "net0": {
4533                     "uuid": "some-uuid",
4534                     "bridge": "br0",
4535                     "autostart": True,
4536                     "active": False,
4537                     "persistent": True,
4538                     "leases": [],
4539                 },
4540                 "net1": {
4541                     "uuid": "some-uuid",
4542                     "bridge": "br1",
4543                     "autostart": True,
4544                     "active": False,
4545                     "persistent": True,
4546                     "leases": [],
4547                 },
4548             },
4549             net,
4550         )
4551     def test_network_info_notfound(self):
4552         self.mock_conn.listAllNetworks.return_value = []
4553         net = virt.network_info("foo")
4554         self.assertEqual({}, net)
4555     def test_network_get_xml(self):
4556         network_mock = MagicMock()
4557         network_mock.XMLDesc.return_value = "&lt;net&gt;Raw XML&lt;/net&gt;"
4558         self.mock_conn.networkLookupByName.return_value = network_mock
4559         self.assertEqual("&lt;net&gt;Raw XML&lt;/net&gt;", virt.network_get_xml("default"))
4560     def test_pool(self):
4561         xml_data = virt._gen_pool_xml("pool", "logical", "/dev/base")
4562         root = ET.fromstring(xml_data)
4563         self.assertEqual(root.find("name").text, "pool")
4564         self.assertEqual(root.attrib["type"], "logical")
4565         self.assertEqual(root.find("target/path").text, "/dev/base")
4566     def test_pool_with_source(self):
4567         xml_data = virt._gen_pool_xml(
4568             "pool", "logical", "/dev/base", source_devices=[{"path": "/dev/sda"}]
4569         )
4570         root = ET.fromstring(xml_data)
4571         self.assertEqual(root.find("name").text, "pool")
4572         self.assertEqual(root.attrib["type"], "logical")
4573         self.assertEqual(root.find("target/path").text, "/dev/base")
4574         self.assertEqual(root.find("source/device").attrib["path"], "/dev/sda")
4575     def test_pool_with_scsi(self):
4576         xml_data = virt._gen_pool_xml(
4577             "pool",
4578             "scsi",
4579             "/dev/disk/by-path",
4580             source_devices=[{"path": "/dev/sda"}],
4581             source_adapter={
4582                 "type": "scsi_host",
4583                 "parent_address": {
4584                     "unique_id": 5,
4585                     "address": {
4586                         "domain": "0x0000",
4587                         "bus": "0x00",
4588                         "slot": "0x1f",
4589                         "function": "0x2",
4590                     },
4591                 },
4592             },
4593             source_name="srcname",
4594         )
4595         root = ET.fromstring(xml_data)
4596         self.assertEqual(root.find("name").text, "pool")
4597         self.assertEqual(root.attrib["type"], "scsi")
4598         self.assertEqual(root.find("target/path").text, "/dev/disk/by-path")
4599         self.assertEqual(root.find("source/device"), None)
4600         self.assertEqual(root.find("source/name"), None)
4601         self.assertEqual(root.find("source/adapter").attrib["type"], "scsi_host")
4602         self.assertEqual(
4603             root.find("source/adapter/parentaddr").attrib["unique_id"], "5"
4604         )
4605         self.assertEqual(
4606             root.find("source/adapter/parentaddr/address").attrib["domain"], "0x0000"
4607         )
4608         self.assertEqual(
4609             root.find("source/adapter/parentaddr/address").attrib["bus"], "0x00"
4610         )
4611         self.assertEqual(
4612             root.find("source/adapter/parentaddr/address").attrib["slot"], "0x1f"
4613         )
4614         self.assertEqual(
4615             root.find("source/adapter/parentaddr/address").attrib["function"], "0x2"
4616         )
4617     def test_pool_with_rbd(self):
4618         xml_data = virt._gen_pool_xml(
4619             "pool",
4620             "rbd",
4621             source_devices=[{"path": "/dev/sda"}],
4622             source_hosts=["1.2.3.4", "my.ceph.monitor:69"],
4623             source_auth={
4624                 "type": "ceph",
4625                 "username": "admin",
4626                 "secret": {"type": "uuid", "value": "someuuid"},
4627             },
4628             source_name="srcname",
4629             source_adapter={"type": "scsi_host", "name": "host0"},
4630             source_dir="/some/dir",
4631             source_format="fmt",
4632         )
4633         root = ET.fromstring(xml_data)
4634         self.assertEqual(root.find("name").text, "pool")
4635         self.assertEqual(root.attrib["type"], "rbd")
4636         self.assertEqual(root.find("target"), None)
4637         self.assertEqual(root.find("source/device"), None)
4638         self.assertEqual(root.find("source/name").text, "srcname")
4639         self.assertEqual(root.find("source/adapter"), None)
4640         self.assertEqual(root.find("source/dir"), None)
4641         self.assertEqual(root.find("source/format"), None)
4642         self.assertEqual(root.findall("source/host")[0].attrib["name"], "1.2.3.4")
4643         self.assertTrue("port" not in root.findall("source/host")[0].attrib)
4644         self.assertEqual(
4645             root.findall("source/host")[1].attrib["name"], "my.ceph.monitor"
4646         )
4647         self.assertEqual(root.findall("source/host")[1].attrib["port"], "69")
4648         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4649         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4650         self.assertEqual(root.find("source/auth/secret").attrib["uuid"], "someuuid")
4651     def test_pool_with_netfs(self):
4652         xml_data = virt._gen_pool_xml(
4653             "pool",
4654             "netfs",
4655             target="/path/to/target",
4656             permissions={
4657                 "mode": "0770",
4658                 "owner": 1000,
4659                 "group": 100,
4660                 "label": "seclabel",
4661             },
4662             source_devices=[{"path": "/dev/sda"}],
4663             source_hosts=["nfs.host"],
4664             source_name="srcname",
4665             source_adapter={"type": "scsi_host", "name": "host0"},
4666             source_dir="/some/dir",
4667             source_format="nfs",
4668         )
4669         root = ET.fromstring(xml_data)
4670         self.assertEqual(root.find("name").text, "pool")
4671         self.assertEqual(root.attrib["type"], "netfs")
4672         self.assertEqual(root.find("target/path").text, "/path/to/target")
4673         self.assertEqual(root.find("target/permissions/mode").text, "0770")
4674         self.assertEqual(root.find("target/permissions/owner").text, "1000")
4675         self.assertEqual(root.find("target/permissions/group").text, "100")
4676         self.assertEqual(root.find("target/permissions/label").text, "seclabel")
4677         self.assertEqual(root.find("source/device"), None)
4678         self.assertEqual(root.find("source/name"), None)
4679         self.assertEqual(root.find("source/adapter"), None)
4680         self.assertEqual(root.find("source/dir").attrib["path"], "/some/dir")
4681         self.assertEqual(root.find("source/format").attrib["type"], "nfs")
4682         self.assertEqual(root.find("source/host").attrib["name"], "nfs.host")
4683         self.assertEqual(root.find("source/auth"), None)
4684     def test_pool_with_iscsi_direct(self):
4685         xml_data = virt._gen_pool_xml(
4686             "pool",
4687             "iscsi-direct",
4688             source_hosts=["iscsi.example.com"],
4689             source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4690             source_initiator="iqn.2013-06.com.example:iscsi-initiator",
4691         )
4692         root = ET.fromstring(xml_data)
4693         self.assertEqual(root.find("name").text, "pool")
4694         self.assertEqual(root.attrib["type"], "iscsi-direct")
4695         self.assertEqual(root.find("target"), None)
4696         self.assertEqual(
4697             root.find("source/device").attrib["path"],
4698             "iqn.2013-06.com.example:iscsi-pool",
4699         )
4700         self.assertEqual(
4701             root.findall("source/host")[0].attrib["name"], "iscsi.example.com"
4702         )
4703         self.assertEqual(
4704             root.find("source/initiator/iqn").attrib["name"],
4705             "iqn.2013-06.com.example:iscsi-initiator",
4706         )
4707     def test_pool_define(self):
4708         mock_pool = MagicMock()
4709         mock_secret = MagicMock()
4710         mock_secret_define = MagicMock(return_value=mock_secret)
4711         self.mock_conn.secretDefineXML = mock_secret_define
4712         self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
4713         self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)
4714         mocks = [
4715             mock_pool,
4716             mock_secret,
4717             mock_secret_define,
4718             self.mock_conn.storagePoolCreateXML,
4719             self.mock_conn.secretDefineXML,
4720             self.mock_conn.storagePoolDefineXML,
4721         ]
4722         self.assertTrue(
4723             virt.pool_define(
4724                 "default",
4725                 "rbd",
4726                 source_hosts=["one.example.com", "two.example.com"],
4727                 source_name="rbdvol",
4728                 source_auth={
4729                     "type": "ceph",
4730                     "username": "admin",
4731                     "secret": {"type": "uuid", "value": "someuuid"},
4732                 },
4733             )
4734         )
4735         self.mock_conn.storagePoolDefineXML.assert_called_once()
4736         self.mock_conn.storagePoolCreateXML.assert_not_called()
4737         mock_pool.create.assert_called_once()
4738         mock_secret_define.assert_not_called()
4739         for mock in mocks:
4740             mock.reset_mock()
4741         self.assertTrue(
4742             virt.pool_define(
4743                 "default",
4744                 "rbd",
4745                 transient=True,
4746                 source_hosts=["one.example.com", "two.example.com"],
4747                 source_name="rbdvol",
4748                 source_auth={"username": "admin", "password": "c2VjcmV0"},
4749             )
4750         )
4751         self.mock_conn.storagePoolDefineXML.assert_not_called()
4752         pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
4753         root = ET.fromstring(pool_xml)
4754         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4755         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4756         self.assertEqual(
4757             root.find("source/auth/secret").attrib["usage"], "pool_default"
4758         )
4759         mock_pool.create.assert_not_called()
4760         mock_secret.setValue.assert_called_once_with(b"secret")
4761         secret_xml = mock_secret_define.call_args[0][0]
4762         root = ET.fromstring(secret_xml)
4763         self.assertEqual(root.find("usage/name").text, "pool_default")
4764         self.assertEqual(root.find("usage").attrib["type"], "ceph")
4765         self.assertEqual(root.attrib["private"], "yes")
4766         self.assertEqual(
4767             root.find("description").text, "Passphrase for default pool created by Salt"
4768         )
4769         for mock in mocks:
4770             mock.reset_mock()
4771         self.assertTrue(
4772             virt.pool_define(
4773                 "default",
4774                 "iscsi",
4775                 target="/dev/disk/by-path",
4776                 source_hosts=["iscsi.example.com"],
4777                 source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4778                 source_auth={"username": "admin", "password": "secret"},
4779                 start=False,
4780             )
4781         )
4782         self.mock_conn.storagePoolCreateXML.assert_not_called()
4783         pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
4784         root = ET.fromstring(pool_xml)
4785         self.assertEqual(root.find("source/auth").attrib["type"], "chap")
4786         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4787         self.assertEqual(
4788             root.find("source/auth/secret").attrib["usage"], "pool_default"
4789         )
4790         mock_pool.create.assert_not_called()
4791         mock_secret.setValue.assert_called_once_with("secret")
4792         secret_xml = mock_secret_define.call_args[0][0]
4793         root = ET.fromstring(secret_xml)
4794         self.assertEqual(root.find("usage/target").text, "pool_default")
4795         self.assertEqual(root.find("usage").attrib["type"], "iscsi")
4796         self.assertEqual(root.attrib["private"], "yes")
4797         self.assertEqual(
4798             root.find("description").text, "Passphrase for default pool created by Salt"
4799         )
4800     def test_list_pools(self):
4801         names = ["pool1", "default", "pool2"]
4802         pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
4803         for i, value in enumerate(names):
4804             pool_mocks[i].name.return_value = value
4805         self.mock_conn.listAllStoragePools.return_value = (
4806             pool_mocks  # pylint: disable=no-member
4807         )
4808         actual = virt.list_pools()
4809         self.assertEqual(names, actual)
4810     def test_pool_info(self):
4811         pool_mock = MagicMock()
4812         pool_mock.name.return_value = "foo"
4813         pool_mock.UUIDString.return_value = "some-uuid"
4814         pool_mock.info.return_value = [0, 1234, 5678, 123]
4815         pool_mock.autostart.return_value = True
4816         pool_mock.isPersistent.return_value = True
4817         pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4818   &lt;name&gt;default&lt;/name&gt;
4819   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4820   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4821   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4822   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4823   &lt;source&gt;
4824   &lt;/source&gt;
4825   &lt;target&gt;
4826     &lt;path&gt;/srv/vms&lt;/path&gt;
4827     &lt;permissions&gt;
4828       &lt;mode&gt;0755&lt;/mode&gt;
4829       &lt;owner&gt;0&lt;/owner&gt;
4830       &lt;group&gt;0&lt;/group&gt;
4831     &lt;/permissions&gt;
4832   &lt;/target&gt;
4833 &lt;/pool&gt;"""
4834         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4835         pool = virt.pool_info("foo")
4836         self.assertEqual(
4837             {
4838                 "foo": {
4839                     "uuid": "some-uuid",
4840                     "state": "inactive",
4841                     "capacity": 1234,
4842                     "allocation": 5678,
4843                     "free": 123,
4844                     "autostart": True,
4845                     "persistent": True,
4846                     "type": "dir",
4847                     "target_path": "/srv/vms",
4848                 }
4849             },
4850             pool,
4851         )
4852     def test_pool_info_notarget(self):
4853         pool_mock = MagicMock()
4854         pool_mock.name.return_value = "ceph"
4855         pool_mock.UUIDString.return_value = "some-uuid"
4856         pool_mock.info.return_value = [0, 0, 0, 0]
4857         pool_mock.autostart.return_value = True
4858         pool_mock.isPersistent.return_value = True
4859         pool_mock.XMLDesc.return_value = """&lt;pool type='rbd'&gt;
4860   &lt;name&gt;ceph&lt;/name&gt;
4861   &lt;uuid&gt;some-uuid&lt;/uuid&gt;
4862   &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
4863   &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
4864   &lt;available unit='bytes'&gt;0&lt;/available&gt;
4865   &lt;source&gt;
4866     &lt;host name='localhost' port='6789'/&gt;
4867     &lt;host name='localhost' port='6790'/&gt;
4868     &lt;name&gt;rbd&lt;/name&gt;
4869     &lt;auth type='ceph' username='admin'&gt;
4870       &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
4871     &lt;/auth&gt;
4872   &lt;/source&gt;
4873 &lt;/pool&gt;"""
4874         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4875         pool = virt.pool_info("ceph")
4876         self.assertEqual(
4877             {
4878                 "ceph": {
4879                     "uuid": "some-uuid",
4880                     "state": "inactive",
4881                     "capacity": 0,
4882                     "allocation": 0,
4883                     "free": 0,
4884                     "autostart": True,
4885                     "persistent": True,
4886                     "type": "rbd",
4887                     "target_path": None,
4888                 }
4889             },
4890             pool,
4891         )
4892     def test_pool_info_notfound(self):
4893         self.mock_conn.listAllStoragePools.return_value = []
4894         pool = virt.pool_info("foo")
4895         self.assertEqual({}, pool)
4896     def test_pool_info_all(self):
4897         pool_mocks = []
4898         for i in range(2):
4899             pool_mock = MagicMock()
4900             pool_mock.name.return_value = "pool{}".format(i)
4901             pool_mock.UUIDString.return_value = "some-uuid-{}".format(i)
4902             pool_mock.info.return_value = [0, 1234, 5678, 123]
4903             pool_mock.autostart.return_value = True
4904             pool_mock.isPersistent.return_value = True
4905             pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4906   &lt;name&gt;default&lt;/name&gt;
4907   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4908   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4909   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4910   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4911   &lt;source&gt;
4912   &lt;/source&gt;
4913   &lt;target&gt;
4914     &lt;path&gt;/srv/vms&lt;/path&gt;
4915     &lt;permissions&gt;
4916       &lt;mode&gt;0755&lt;/mode&gt;
4917       &lt;owner&gt;0&lt;/owner&gt;
4918       &lt;group&gt;0&lt;/group&gt;
4919     &lt;/permissions&gt;
4920   &lt;/target&gt;
4921 &lt;/pool&gt;"""
4922             pool_mocks.append(pool_mock)
4923         self.mock_conn.listAllStoragePools.return_value = pool_mocks
4924         pool = virt.pool_info()
4925         self.assertEqual(
4926             {
4927                 "pool0": {
4928                     "uuid": "some-uuid-0",
4929                     "state": "inactive",
4930                     "capacity": 1234,
4931                     "allocation": 5678,
4932                     "free": 123,
4933                     "autostart": True,
4934                     "persistent": True,
4935                     "type": "dir",
4936                     "target_path": "/srv/vms",
4937                 },
4938                 "pool1": {
4939                     "uuid": "some-uuid-1",
4940                     "state": "inactive",
4941                     "capacity": 1234,
4942                     "allocation": 5678,
4943                     "free": 123,
4944                     "autostart": True,
4945                     "persistent": True,
4946                     "type": "dir",
4947                     "target_path": "/srv/vms",
4948                 },
4949             },
4950             pool,
4951         )
4952     def test_pool_get_xml(self):
4953         pool_mock = MagicMock()
4954         pool_mock.XMLDesc.return_value = "&lt;pool&gt;Raw XML&lt;/pool&gt;"
4955         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
4956         self.assertEqual("&lt;pool&gt;Raw XML&lt;/pool&gt;", virt.pool_get_xml("default"))
4957     def test_pool_list_volumes(self):
4958         names = ["volume1", "volume2"]
4959         mock_pool = MagicMock()
4960         mock_pool.listVolumes.return_value = names
4961         self.mock_conn.storagePoolLookupByName.return_value = mock_pool
4962         self.assertEqual(names, virt.pool_list_volumes("default"))
4963     @patch("salt.modules.virt._is_bhyve_hyper", return_value=False)
4964     @patch("salt.modules.virt._is_kvm_hyper", return_value=True)
4965     @patch("salt.modules.virt._is_xen_hyper", return_value=False)
4966     def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
4967         self.assertEqual("kvm", virt.get_hypervisor())
4968         iskvm_mock.return_value = False
4969         self.assertIsNone(virt.get_hypervisor())
4970         is_bhyve_mock.return_value = False
4971         self.assertIsNone(virt.get_hypervisor())
4972         isxen_mock.return_value = True
4973         self.assertEqual("xen", virt.get_hypervisor())
4974     def test_pool_delete(self):
4975         mock_pool = MagicMock()
4976         mock_pool.delete = MagicMock(return_value=0)
4977         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4978         res = virt.pool_delete("test-pool")
4979         self.assertTrue(res)
4980         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-pool")
4981         mock_pool.delete.assert_called_once_with(
4982             self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
4983         )
4984     def test_pool_undefine_secret(self):
4985         mock_pool = MagicMock()
4986         mock_pool.undefine = MagicMock(return_value=0)
4987         mock_pool.XMLDesc.return_value = """
4988             &lt;pool type='rbd'&gt;
4989               &lt;name&gt;test-ses&lt;/name&gt;
4990               &lt;source&gt;
4991                 &lt;host name='myhost'/&gt;
4992                 &lt;name&gt;libvirt-pool&lt;/name&gt;
4993                 &lt;auth type='ceph' username='libvirt'&gt;
4994                   &lt;secret usage='pool_test-ses'/&gt;
4995                 &lt;/auth&gt;
4996               &lt;/source&gt;
4997             &lt;/pool&gt;
4998         """
4999         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
5000         mock_undefine = MagicMock(return_value=0)
5001         self.mock_conn.secretLookupByUsage.return_value.undefine = mock_undefine
5002         res = virt.pool_undefine("test-ses")
5003         self.assertTrue(res)
5004         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-ses")
5005         mock_pool.undefine.assert_called_once_with()
5006         self.mock_conn.secretLookupByUsage.assert_called_once_with(
5007             self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, "pool_test-ses"
5008         )
5009         mock_undefine.assert_called_once()
5010     def test_full_info(self):
5011         xml = """&lt;domain type='kvm' id='7'&gt;
5012               &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
5013               &lt;name&gt;test-vm&lt;/name&gt;
5014               &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
5015               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
5016               &lt;on_crash&gt;destroy&lt;/on_crash&gt;
5017               &lt;devices&gt;
5018                 &lt;disk type='file' device='disk'&gt;
5019                 &lt;driver name='qemu' type='qcow2'/&gt;
5020                 &lt;source file='/disks/test.qcow2'/&gt;
5021                 &lt;target dev='vda' bus='virtio'/&gt;
5022               &lt;/disk&gt;
5023               &lt;disk type='file' device='cdrom'&gt;
5024                 &lt;driver name='qemu' type='raw'/&gt;
5025                 &lt;source file='/disks/test-cdrom.iso'/&gt;
5026                 &lt;target dev='hda' bus='ide'/&gt;
5027                 &lt;readonly/&gt;
5028               &lt;/disk&gt;
5029               &lt;interface type='bridge'&gt;
5030                 &lt;mac address='ac:de:48:b6:8b:59'/&gt;
5031                 &lt;source bridge='br0'/&gt;
5032                 &lt;model type='virtio'/&gt;
5033                 &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
5034               &lt;/interface&gt;
5035               &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
5036                 &lt;listen type='address' address='0.0.0.0'/&gt;
5037               &lt;/graphics&gt;
5038               &lt;/devices&gt;
5039             &lt;/domain&gt;
5040         """
5041         self.set_mock_vm("test-vm", xml)
5042         qemu_infos = """[{
5043             "virtual-size": 25769803776,
5044             "filename": "/disks/test.qcow2",
5045             "cluster-size": 65536,
5046             "format": "qcow2",
5047             "actual-size": 217088,
5048             "format-specific": {
5049                 "type": "qcow2",
5050                 "data": {
5051                     "compat": "1.1",
5052                     "lazy-refcounts": false,
5053                     "refcount-bits": 16,
5054                     "corrupt": false
5055                 }
5056             },
5057             "full-backing-filename": "/disks/mybacking.qcow2",
5058             "backing-filename": "mybacking.qcow2",
5059             "dirty-flag": false
5060         },
5061         {
5062             "virtual-size": 25769803776,
5063             "filename": "/disks/mybacking.qcow2",
5064             "cluster-size": 65536,
5065             "format": "qcow2",
5066             "actual-size": 393744384,
5067             "format-specific": {
5068                 "type": "qcow2",
5069                 "data": {
5070                     "compat": "1.1",
5071                     "lazy-refcounts": false,
5072                     "refcount-bits": 16,
5073                     "corrupt": false
5074                 }
5075             },
5076             "dirty-flag": false
5077         }]"""
5078         self.mock_popen.communicate.return_value = [qemu_infos, ""]
5079         self.mock_popen.returncode = 0
5080         self.mock_conn.getInfo = MagicMock(
5081             return_value=["x86_64", 4096, 8, 2712, 1, 2, 4, 2]
5082         )
5083         actual = virt.full_info()
5084         qemu_img_call = [
5085             call
5086             for call in self.mock_subprocess.Popen.call_args_list
5087             if "qemu-img" in call[0][0]
5088         ][0]
5089         self.assertIn("info", qemu_img_call[0][0])
5090         self.assertIn("-U", qemu_img_call[0][0])
5091         self.assertEqual(2816, actual["freemem"])
5092         self.assertEqual(6, actual["freecpu"])
5093         self.assertEqual(4, actual["node_info"]["cpucores"])
5094         self.assertEqual(2712, actual["node_info"]["cpumhz"])
5095         self.assertEqual("x86_64", actual["node_info"]["cpumodel"])
5096         self.assertEqual(8, actual["node_info"]["cpus"])
5097         self.assertEqual(2, actual["node_info"]["cputhreads"])
5098         self.assertEqual(1, actual["node_info"]["numanodes"])
5099         self.assertEqual(4096, actual["node_info"]["phymemory"])
5100         self.assertEqual(2, actual["node_info"]["sockets"])
5101         self.assertEqual(2, actual["vm_info"]["test-vm"]["cpu"])
5102         self.assertEqual(1234, actual["vm_info"]["test-vm"]["cputime"])
5103         self.assertEqual(1024 * 1024, actual["vm_info"]["test-vm"]["mem"])
5104         self.assertEqual(2048 * 1024, actual["vm_info"]["test-vm"]["maxMem"])
5105         self.assertEqual("shutdown", actual["vm_info"]["test-vm"]["state"])
5106         self.assertEqual(
5107             "28deee33-4859-4f23-891c-ee239cffec94", actual["vm_info"]["test-vm"]["uuid"]
5108         )
5109         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_crash"])
5110         self.assertEqual("restart", actual["vm_info"]["test-vm"]["on_reboot"])
5111         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_poweroff"])
5112         nic = actual["vm_info"]["test-vm"]["nics"]["ac:de:48:b6:8b:59"]
5113         self.assertEqual("bridge", nic["type"])
5114         self.assertEqual("ac:de:48:b6:8b:59", nic["mac"])
5115         disks = actual["vm_info"]["test-vm"]["disks"]
5116         disk = disks.get("vda")
5117         self.assertEqual("/disks/test.qcow2", disk["file"])
5118         self.assertEqual("disk", disk["type"])
5119         self.assertEqual("/disks/mybacking.qcow2", disk["backing file"]["file"])
5120         cdrom = disks.get("hda")
5121         self.assertEqual("/disks/test-cdrom.iso", cdrom["file"])
5122         self.assertEqual("cdrom", cdrom["type"])
5123         self.assertFalse("backing file" in cdrom.keys())
5124         graphics = actual["vm_info"]["test-vm"]["graphics"]
5125         self.assertEqual("vnc", graphics["type"])
5126         self.assertEqual("5900", graphics["port"])
5127         self.assertEqual("0.0.0.0", graphics["listen"])
5128     def test_pool_update(self):
5129         current_xml = """&lt;pool type='dir'&gt;
5130           &lt;name&gt;default&lt;/name&gt;
5131           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5132           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5133           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5134           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5135           &lt;source&gt;
5136           &lt;/source&gt;
5137           &lt;target&gt;
5138             &lt;path&gt;/path/to/pool&lt;/path&gt;
5139             &lt;permissions&gt;
5140               &lt;mode&gt;0775&lt;/mode&gt;
5141               &lt;owner&gt;0&lt;/owner&gt;
5142               &lt;group&gt;100&lt;/group&gt;
5143             &lt;/permissions&gt;
5144           &lt;/target&gt;
5145         &lt;/pool&gt;"""
5146         expected_xml = (
5147             '&lt;pool type="netfs"&gt;'
5148             "&lt;name&gt;default&lt;/name&gt;"
5149             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5150             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5151             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5152             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5153             "&lt;target&gt;"
5154             "&lt;path&gt;/mnt/cifs&lt;/path&gt;"
5155             "&lt;permissions&gt;"
5156             "&lt;mode&gt;0774&lt;/mode&gt;"
5157             "&lt;owner&gt;1234&lt;/owner&gt;"
5158             "&lt;group&gt;123&lt;/group&gt;"
5159             "&lt;/permissions&gt;"
5160             "&lt;/target&gt;"
5161             "&lt;source&gt;"
5162             '&lt;dir path="samba_share" /&gt;'
5163             '&lt;host name="one.example.com" /&gt;'
5164             '&lt;host name="two.example.com" /&gt;'
5165             '&lt;format type="cifs" /&gt;'
5166             "&lt;/source&gt;"
5167             "&lt;/pool&gt;"
5168         )
5169         mocked_pool = MagicMock()
5170         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5171         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5172         self.mock_conn.storagePoolDefineXML = MagicMock()
5173         self.assertTrue(
5174             virt.pool_update(
5175                 "default",
5176                 "netfs",
5177                 target="/mnt/cifs",
5178                 permissions={"mode": "0774", "owner": "1234", "group": "123"},
5179                 source_format="cifs",
5180                 source_dir="samba_share",
5181                 source_hosts=["one.example.com", "two.example.com"],
5182             )
5183         )
5184         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5185     def test_pool_update_nochange(self):
5186         current_xml = """&lt;pool type='dir'&gt;
5187           &lt;name&gt;default&lt;/name&gt;
5188           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5189           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5190           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5191           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5192           &lt;source&gt;
5193           &lt;/source&gt;
5194           &lt;target&gt;
5195             &lt;path&gt;/path/to/pool&lt;/path&gt;
5196             &lt;permissions&gt;
5197               &lt;mode&gt;0775&lt;/mode&gt;
5198               &lt;owner&gt;0&lt;/owner&gt;
5199               &lt;group&gt;100&lt;/group&gt;
5200             &lt;/permissions&gt;
5201           &lt;/target&gt;
5202         &lt;/pool&gt;"""
5203         mocked_pool = MagicMock()
5204         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5205         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5206         self.mock_conn.storagePoolDefineXML = MagicMock()
5207         self.assertFalse(
5208             virt.pool_update(
5209                 "default",
5210                 "dir",
5211                 target="/path/to/pool",
5212                 permissions={"mode": "0775", "owner": "0", "group": "100"},
5213                 test=True,
5214             )
5215         )
5216         self.mock_conn.storagePoolDefineXML.assert_not_called()
5217     def test_pool_update_password(self):
5218         current_xml = """&lt;pool type='rbd'&gt;
5219           &lt;name&gt;default&lt;/name&gt;
5220           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5221           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5222           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5223           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5224           &lt;source&gt;
5225             &lt;name&gt;iscsi-images&lt;/name&gt;
5226             &lt;host name='ses4.tf.local'/&gt;
5227             &lt;host name='ses5.tf.local'/&gt;
5228             &lt;auth username='libvirt' type='ceph'&gt;
5229               &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
5230             &lt;/auth&gt;
5231           &lt;/source&gt;
5232         &lt;/pool&gt;"""
5233         mock_secret = MagicMock()
5234         self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)
5235         mocked_pool = MagicMock()
5236         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5237         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5238         self.mock_conn.storagePoolDefineXML = MagicMock()
5239         self.assertFalse(
5240             virt.pool_update(
5241                 "default",
5242                 "rbd",
5243                 source_name="iscsi-images",
5244                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5245                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5246             )
5247         )
5248         self.mock_conn.storagePoolDefineXML.assert_not_called()
5249         mock_secret.setValue.assert_called_once_with(b"secret")
5250         self.mock_conn.secretLookupByUUIDString = MagicMock(
5251             side_effect=self.mock_libvirt.libvirtError("secret not found")
5252         )
5253         self.assertFalse(
5254             virt.pool_update(
5255                 "default",
5256                 "rbd",
5257                 source_name="iscsi-images",
5258                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5259                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5260             )
5261         )
5262         self.mock_conn.storagePoolDefineXML.assert_not_called()
5263         self.mock_conn.secretDefineXML.assert_called_once()
5264         mock_secret.setValue.assert_called_once_with(b"secret")
5265     def test_pool_update_password_create(self):
5266         current_xml = """&lt;pool type='rbd'&gt;
5267           &lt;name&gt;default&lt;/name&gt;
5268           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5269           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5270           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5271           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5272           &lt;source&gt;
5273             &lt;name&gt;iscsi-images&lt;/name&gt;
5274             &lt;host name='ses4.tf.local'/&gt;
5275             &lt;host name='ses5.tf.local'/&gt;
5276           &lt;/source&gt;
5277         &lt;/pool&gt;"""
5278         expected_xml = (
5279             '&lt;pool type="rbd"&gt;'
5280             "&lt;name&gt;default&lt;/name&gt;"
5281             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5282             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5283             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5284             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5285             "&lt;source&gt;"
5286             '&lt;host name="ses4.tf.local" /&gt;'
5287             '&lt;host name="ses5.tf.local" /&gt;'
5288             '&lt;auth type="ceph" username="libvirt"&gt;'
5289             '&lt;secret usage="pool_default" /&gt;'
5290             "&lt;/auth&gt;"
5291             "&lt;name&gt;iscsi-images&lt;/name&gt;"
5292             "&lt;/source&gt;"
5293             "&lt;/pool&gt;"
5294         )
5295         mock_secret = MagicMock()
5296         self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)
5297         mocked_pool = MagicMock()
5298         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5299         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5300         self.mock_conn.storagePoolDefineXML = MagicMock()
5301         self.assertTrue(
5302             virt.pool_update(
5303                 "default",
5304                 "rbd",
5305                 source_name="iscsi-images",
5306                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5307                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5308             )
5309         )
5310         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5311         mock_secret.setValue.assert_called_once_with(b"secret")
5312     def test_volume_infos(self):
5313         vms_disks = [
5314         ]
5315         mock_vms = []
5316         for idx, disk in enumerate(vms_disks):
5317             vm = MagicMock()
5318             vm.name.return_value = "vm{}".format(idx)
5319             vm.XMLDesc.return_value = """
5320                     &lt;domain type='kvm' id='1'&gt;
5321                       &lt;name&gt;vm{}&lt;/name&gt;
5322                       &lt;devices&gt;{}&lt;/devices&gt;
5323                     &lt;/domain&gt;
5324                 """.format(
5325                 idx, disk
5326             )
5327             mock_vms.append(vm)
5328         mock_pool_data = [
5329             {
5330                 "name": "pool0",
5331                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5332                 "volumes": [
5333                     {
5334                         "key": "/key/of/vol0",
5335                         "name": "vol0",
5336                         "path": "/path/to/vol0.qcow2",
5337                         "info": [0, 123456789, 123456],
5338                         "backingStore": None,
5339                     }
5340                 ],
5341             },
5342             {
5343                 "name": "pool1",
5344                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5345                 "volumes": [
5346                     {
5347                         "key": "/key/of/vol0bad",
5348                         "name": "vol0bad",
5349                         "path": "/path/to/vol0bad.qcow2",
5350                         "info": None,
5351                         "backingStore": None,
5352                     },
5353                     {
5354                         "key": "/key/of/vol1",
5355                         "name": "vol1",
5356                         "path": "/path/to/vol1.qcow2",
5357                         "info": [0, 12345, 1234],
5358                         "backingStore": None,
5359                     },
5360                     {
5361                         "key": "/key/of/vol2",
5362                         "name": "vol2",
5363                         "path": "/path/to/vol2.qcow2",
5364                         "info": [0, 12345, 1234],
5365                         "backingStore": "/path/to/vol0.qcow2",
5366                     },
5367                 ],
5368             },
5369         ]
5370         mock_pools = []
5371         for pool_data in mock_pool_data:
5372             mock_pool = MagicMock()
5373             mock_pool.name.return_value = pool_data["name"]  # pylint: disable=no-member
5374             mock_pool.info.return_value = [pool_data["state"]]
5375             mock_volumes = []
5376             for vol_data in pool_data["volumes"]:
5377                 mock_volume = MagicMock()
5378                 mock_volume.name.return_value = vol_data["name"]
5379                 mock_volume.key.return_value = vol_data["key"]
5380                 mock_volume.path.return_value = "/path/to/{}.qcow2".format(
5381                     vol_data["name"]
5382                 )
5383                 if vol_data["info"]:
5384                     mock_volume.info.return_value = vol_data["info"]
5385                     backing_store = (
5386                             vol_data["backingStore"]
5387                         )
5388                         if vol_data["backingStore"]
5389                         else "&lt;backingStore/&gt;"
5390                     )
5391                     mock_volume.XMLDesc.return_value = """
5392                         &lt;volume type='file'&gt;
5393                           &lt;name&gt;{0}&lt;/name&gt;
5394                           &lt;target&gt;
5395                             &lt;format type="qcow2"/&gt;
5396                             &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
5397                           &lt;/target&gt;
5398                           {1}
5399                         &lt;/volume&gt;
5400                     """.format(
5401                         vol_data["name"], backing_store
5402                     )
5403                 else:
5404                     mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
5405                         "No such volume"
5406                     )
5407                     mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
5408                         "No such volume"
5409                     )
5410                 mock_volumes.append(mock_volume)
5411             mock_pool.listAllVolumes.return_value = (
5412                 mock_volumes  # pylint: disable=no-member
5413             )
5414             mock_pools.append(mock_pool)
5415         inactive_pool = MagicMock()
5416         inactive_pool.name.return_value = "pool2"
5417         inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
5418         inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
5419             "pool is inactive"
5420         )
5421         mock_pools.append(inactive_pool)
5422         self.mock_conn.listAllStoragePools.return_value = (
5423             mock_pools  # pylint: disable=no-member
5424         )
5425 <a name="5"></a>        with patch("salt.modules.virt._get_domain", MagicMock(return_value=mock_vms)):
5426             actual = virt.volume_infos("pool0", "vol0")
5427             self.assertEqual(1, len(actual.keys()))
5428             self.assertEqual(1, len(actual["pool0"]<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.keys()))
5429             self.assertEqual(["vm0", "vm2"], sorted(actual["pool0"]["vol0"]["used_by"]))
5430             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"][</b></font>"path"])
5431             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5432             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5433             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5434             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5435             self.assertEqual(
5436                 virt.volume_infos("pool1", None),
5437                 {
5438                     "pool1": {
5439                         "vol1": {
5440                             "type": "file",
5441                             "key": "/key/of/vol1",
5442                             "path": "/path/to/vol1.qcow2",
5443                             "capacity": 12345,
5444                             "allocation": 1234,
5445                             "used_by": [],
5446                             "backing_store": None,
5447                             "format": "qcow2",
5448                         },
5449                         "vol2": {
5450                             "type": "file",
5451                             "key": "/key/of/vol2",
5452                             "path": "/path/to/vol2.qcow2",
5453                             "capacity": 12345,
5454                             "allocation": 1234,
5455                             "used_by": ["vm2"],
5456                             "backing_store": {
5457                                 "path": "/path/to/vol0.qcow2",
5458                                 "format": "qcow2",
5459                             },
5460                             "format": "qcow2",
5461                         },
5462                     }
5463                 },
5464             )
5465             self.assertEqual(
5466                 virt.volume_infos(None, "vol2"),
5467                 {
5468                     "pool1": {
5469                         "vol2": {
5470                             "type": "file",
5471                             "key": "/key/of/vol2",
5472                             "path": "/path/to/vol2.qcow2",
5473                             "capacity": 12345,
5474                             "allocation": 1234,
5475                             "used_by": ["vm2"],
5476                             "backing_store": {
5477                                 "path": "/path/to/vol0.qcow2",
5478                                 "format": "qcow2",
5479                             },
5480                             "format": "qcow2",
5481                         }
5482                     }
5483                 },
5484             )
5485         with patch(
5486             "salt.modules.virt._get_domain", MagicMock(return_value=mock_vms[0])
5487         ):
5488             actual = virt.volume_infos("pool0", "vol0")
5489             self.assertEqual(1, len(actual.keys()))
5490             self.assertEqual(1, len(actual["pool0"].keys()))
5491             self.assertEqual(["vm0"], sorted(actual["pool0"]["vol0"]["used_by"]))
5492             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5493             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5494             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5495             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5496             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5497             self.assertEqual(
5498                 virt.volume_infos("pool1", None),
5499                 {
5500                     "pool1": {
5501                         "vol1": {
5502                             "type": "file",
5503                             "key": "/key/of/vol1",
5504                             "path": "/path/to/vol1.qcow2",
5505                             "capacity": 12345,
5506                             "allocation": 1234,
5507                             "used_by": [],
5508                             "backing_store": None,
5509                             "format": "qcow2",
5510                         },
5511                         "vol2": {
5512                             "type": "file",
5513                             "key": "/key/of/vol2",
5514                             "path": "/path/to/vol2.qcow2",
5515                             "capacity": 12345,
5516                             "allocation": 1234,
5517                             "used_by": [],
5518                             "backing_store": {
5519                                 "path": "/path/to/vol0.qcow2",
5520                                 "format": "qcow2",
5521                             },
5522                             "format": "qcow2",
5523                         },
5524                     }
5525                 },
5526             )
5527             self.assertEqual(
5528                 virt.volume_infos(None, "vol2"),
5529                 {
5530                     "pool1": {
5531                         "vol2": {
5532                             "type": "file",
5533                             "key": "/key/of/vol2",
5534                             "path": "/path/to/vol2.qcow2",
5535                             "capacity": 12345,
5536                             "allocation": 1234,
5537                             "used_by": [],
5538                             "backing_store": {
5539                                 "path": "/path/to/vol0.qcow2",
5540                                 "format": "qcow2",
5541                             },
5542                             "format": "qcow2",
5543                         }
5544                     }
5545                 },
5546             )
5547         with patch(
5548             "salt.modules.virt._get_domain",
5549             MagicMock(side_effect=CommandExecutionError("no VM")),
5550         ):
5551             actual = virt.volume_infos("pool0", "vol0")
5552             self.assertEqual(1, len(actual.keys()))
5553             self.assertEqual(1, len(actual["pool0"].keys()))
5554             self.assertEqual([], sorted(actual["pool0"]["vol0"]["used_by"]))
5555             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5556             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5557             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5558             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5559             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5560             self.assertEqual(
5561                 virt.volume_infos("pool1", None),
5562                 {
5563                     "pool1": {
5564                         "vol1": {
5565                             "type": "file",
5566                             "key": "/key/of/vol1",
5567                             "path": "/path/to/vol1.qcow2",
5568                             "capacity": 12345,
5569                             "allocation": 1234,
5570                             "used_by": [],
5571                             "backing_store": None,
5572                             "format": "qcow2",
5573                         },
5574                         "vol2": {
5575                             "type": "file",
5576                             "key": "/key/of/vol2",
5577                             "path": "/path/to/vol2.qcow2",
5578                             "capacity": 12345,
5579                             "allocation": 1234,
5580                             "used_by": [],
5581                             "backing_store": {
5582                                 "path": "/path/to/vol0.qcow2",
5583                                 "format": "qcow2",
5584                             },
5585                             "format": "qcow2",
5586                         },
5587                     }
5588                 },
5589             )
5590             self.assertEqual(
5591                 virt.volume_infos(None, "vol2"),
5592                 {
5593                     "pool1": {
5594                         "vol2": {
5595                             "type": "file",
5596                             "key": "/key/of/vol2",
5597                             "path": "/path/to/vol2.qcow2",
5598                             "capacity": 12345,
5599                             "allocation": 1234,
5600                             "used_by": [],
5601                             "backing_store": {
5602                                 "path": "/path/to/vol0.qcow2",
5603                                 "format": "qcow2",
5604                             },
5605                             "format": "qcow2",
5606                         }
5607                     }
5608                 },
5609             )
5610     def test_volume_delete(self):
5611         mock_delete = MagicMock(side_effect=[0, 1])
5612         mock_volume = MagicMock()
5613         mock_volume.delete = mock_delete  # pylint: disable=no-member
5614         mock_pool = MagicMock()
5615         mock_pool.storageVolLookupByName.side_effect = [
5616             mock_volume,
5617             mock_volume,
5618             self.mock_libvirt.libvirtError("Missing volume"),
5619             mock_volume,
5620         ]
5621         self.mock_conn.storagePoolLookupByName.side_effect = [
5622             mock_pool,
5623             mock_pool,
5624             mock_pool,
5625             self.mock_libvirt.libvirtError("Missing pool"),
5626         ]
5627         self.assertTrue(virt.volume_delete("default", "test_volume"))
5628         self.assertFalse(virt.volume_delete("default", "test_volume"))
5629         <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with self.assertRaises(self.mock_libvirt.libvirtError):
5630             virt.volume_delete("default", "missing")
5631             virt.volume_delete("missing", "test_volume")
5632         self.assertEqual(</b></font>mock_delete.call_count, 2)
5633     def test_pool_capabilities(self):
5634         xml_caps = """
5635 &lt;storagepoolCapabilities&gt;
5636   &lt;pool type='disk' supported='yes'&gt;
5637     &lt;poolOptions&gt;
5638       &lt;defaultFormat type='unknown'/&gt;
5639       &lt;enum name='sourceFormatType'&gt;
5640         &lt;value&gt;unknown&lt;/value&gt;
5641         &lt;value&gt;dos&lt;/value&gt;
5642         &lt;value&gt;dvh&lt;/value&gt;
5643       &lt;/enum&gt;
5644     &lt;/poolOptions&gt;
5645     &lt;volOptions&gt;
5646       &lt;defaultFormat type='none'/&gt;
5647       &lt;enum name='targetFormatType'&gt;
5648         &lt;value&gt;none&lt;/value&gt;
5649         &lt;value&gt;linux&lt;/value&gt;
5650       &lt;/enum&gt;
5651     &lt;/volOptions&gt;
5652   &lt;/pool&gt;
5653   &lt;pool type='iscsi' supported='yes'&gt;
5654   &lt;/pool&gt;
5655   &lt;pool type='rbd' supported='yes'&gt;
5656     &lt;volOptions&gt;
5657       &lt;defaultFormat type='raw'/&gt;
5658       &lt;enum name='targetFormatType'&gt;
5659       &lt;/enum&gt;
5660     &lt;/volOptions&gt;
5661   &lt;/pool&gt;
5662   &lt;pool type='sheepdog' supported='no'&gt;
5663   &lt;/pool&gt;
5664 &lt;/storagepoolCapabilities&gt;
5665         """
5666         self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)
5667         actual = virt.pool_capabilities()
5668         self.assertEqual(
5669             {
5670                 "computed": False,
5671                 "pool_types": [
5672                     {
5673                         "name": "disk",
5674                         "supported": True,
5675                         "options": {
5676                             "pool": {
5677                                 "default_format": "unknown",
5678                                 "sourceFormatType": ["unknown", "dos", "dvh"],
5679                             },
5680                             "volume": {
5681                                 "default_format": "none",
5682                                 "targetFormatType": ["none", "linux"],
5683                             },
5684                         },
5685                     },
5686                     {"name": "iscsi", "supported": True},
5687                     {
5688                         "name": "rbd",
5689                         "supported": True,
5690                         "options": {
5691                             "volume": {"default_format": "raw", "targetFormatType": []}
5692                         },
5693                     },
5694                     {"name": "sheepdog", "supported": False},
5695                 ],
5696             },
5697             actual,
5698         )
5699     @patch("salt.modules.virt.get_hypervisor", return_value="kvm")
5700     def test_pool_capabilities_computed(self, mock_get_hypervisor):
5701         self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
5702         del self.mock_conn.getStoragePoolCapabilities
5703         actual = virt.pool_capabilities()
5704         self.assertTrue(actual["computed"])
5705         backends = actual["pool_types"]
5706         self.assertFalse(
5707             [backend for backend in backends if backend["name"] == "iscsi-direct"][0][
5708                 "supported"
5709             ]
5710         )
5711         self.assertTrue(
5712             [backend for backend in backends if backend["name"] == "gluster"][0][
5713                 "supported"
5714             ]
5715         )
5716         self.assertFalse(
5717             [backend for backend in backends if backend["name"] == "zfs"][0][
5718                 "supported"
5719             ]
5720         )
5721         mock_get_hypervisor.return_value = "xen"
5722         backends = virt.pool_capabilities()["pool_types"]
5723         self.assertFalse(
5724             [backend for backend in backends if backend["name"] == "gluster"][0][
5725                 "supported"
5726             ]
5727         )
5728         mock_get_hypervisor.return_value = "bhyve"
5729         backends = virt.pool_capabilities()["pool_types"]
5730         self.assertFalse(
5731             [backend for backend in backends if backend["name"] == "gluster"][0][
5732                 "supported"
5733             ]
5734         )
5735         self.assertTrue(
5736             [backend for backend in backends if backend["name"] == "zfs"][0][
5737                 "supported"
5738             ]
5739         )
5740         self.assertNotIn(
5741             "options",
5742             [backend for backend in backends if backend["name"] == "iscsi"][0],
5743         )
5744         self.assertNotIn(
5745             "pool",
5746             [backend for backend in backends if backend["name"] == "dir"][0]["options"],
5747         )
5748         self.assertNotIn(
5749             "volume",
5750             [backend for backend in backends if backend["name"] == "logical"][0][
5751                 "options"
5752             ],
5753         )
5754         self.assertEqual(
5755             {
5756                 "pool": {
5757                     "default_format": "auto",
5758                     "sourceFormatType": ["auto", "nfs", "glusterfs", "cifs"],
5759                 },
5760                 "volume": {
5761                     "default_format": "raw",
5762                     "targetFormatType": [
5763                         "none",
5764                         "raw",
5765                         "dir",
5766                         "bochs",
5767                         "cloop",
5768                         "dmg",
5769                         "iso",
5770                         "vpc",
5771                         "vdi",
5772                         "fat",
5773                         "vhd",
5774                         "ploop",
5775                         "cow",
5776                         "qcow",
5777                         "qcow2",
5778                         "qed",
5779                         "vmdk",
5780                     ],
5781                 },
5782             },
5783             [backend for backend in backends if backend["name"] == "netfs"][0][
5784                 "options"
5785             ],
5786         )
5787     def test_get_domain(self):
5788         self.mock_conn.listDomainsID.return_value = []
5789         self.mock_conn.listDefinedDomains.return_value = []
5790         self.assertEqual([], virt._get_domain(self.mock_conn))
5791         self.assertRaisesRegex(
5792             CommandExecutionError,
5793             "No virtual machines found.",
5794             virt._get_domain,
5795             self.mock_conn,
5796             "vm2",
5797         )
5798         self.mock_conn.listDomainsID.return_value = [1]
5799         def create_mock_vm(idx):
5800             mock_vm = MagicMock()
5801             mock_vm.name.return_value = "vm{}".format(idx)
5802             return mock_vm
5803         mock_vms = [create_mock_vm(idx) for idx in range(3)]
5804         self.mock_conn.lookupByID.return_value = mock_vms[0]
5805         self.mock_conn.listDefinedDomains.return_value = ["vm1", "vm2"]
5806         self.mock_conn.lookupByName.side_effect = mock_vms
5807         self.assertEqual(mock_vms, virt._get_domain(self.mock_conn))
5808         self.mock_conn.lookupByName.side_effect = None
5809         self.mock_conn.lookupByName.return_value = mock_vms[0]
5810         self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))
5811         self.mock_conn.lookupByName.return_value = None
5812         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5813         self.assertEqual(
5814             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
5815         )
5816         self.mock_conn.reset_mock()
5817         self.mock_conn.lookupByName.return_value = None
5818         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5819         self.assertEqual(
5820             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, "vm1", "vm2")
5821         )
5822         self.assertRaisesRegex(
5823             CommandExecutionError,
5824             'The VM "vm2" is not present',
5825             virt._get_domain,
5826             self.mock_conn,
5827             "vm2",
5828             inactive=False,
5829         )
5830     def test_volume_define(self):
5831         pool_mock = MagicMock()
5832         pool_mock.XMLDesc.return_value = "&lt;pool type='dir'&gt;&lt;/pool&gt;"
5833         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5834         self.assertTrue(
5835             virt.volume_define(
5836                 "testpool",
5837                 "myvm_system.qcow2",
5838                 8192,
5839                 allocation=4096,
5840                 format="qcow2",
5841                 type="file",
5842             )
5843         )
5844         expected_xml = (
5845             "&lt;volume type='file'&gt;\n"
5846             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5847             "  &lt;source&gt;\n"
5848             "  &lt;/source&gt;\n"
5849             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5850             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5851             "  &lt;target&gt;\n"
5852             "    &lt;format type='qcow2'/&gt;\n"
5853             "  &lt;/target&gt;\n"
5854             "&lt;/volume&gt;"
5855         )
5856         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5857         pool_mock.reset_mock()
5858         self.assertTrue(
5859             virt.volume_define(
5860                 "testpool",
5861                 "myvm_system.qcow2",
5862                 8192,
5863                 allocation=4096,
5864                 format="qcow2",
5865                 type="file",
5866                 backing_store={"path": "/path/to/base.raw", "format": "raw"},
5867             )
5868         )
5869         expected_xml = (
5870             "&lt;volume type='file'&gt;\n"
5871             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5872             "  &lt;source&gt;\n"
5873             "  &lt;/source&gt;\n"
5874             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5875             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5876             "  &lt;target&gt;\n"
5877             "    &lt;format type='qcow2'/&gt;\n"
5878             "  &lt;/target&gt;\n"
5879             "  &lt;backingStore&gt;\n"
5880             "    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n"
5881             "    &lt;format type='raw'/&gt;\n"
5882             "  &lt;/backingStore&gt;\n"
5883             "&lt;/volume&gt;"
5884         )
5885         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5886         pool_mock.reset_mock()
5887         pool_mock.XMLDesc.return_value = "&lt;pool type='logical'&gt;&lt;/pool&gt;"
5888         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5889         self.assertTrue(
5890             virt.volume_define(
5891                 "testVG",
5892                 "myvm_system",
5893                 8192,
5894                 backing_store={"path": "/dev/testVG/base"},
5895             )
5896         )
5897         expected_xml = (
5898             "&lt;volume&gt;\n"
5899             "  &lt;name&gt;myvm_system&lt;/name&gt;\n"
5900             "  &lt;source&gt;\n"
5901             "  &lt;/source&gt;\n"
5902             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5903             "  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n"
5904             "  &lt;target&gt;\n"
5905             "  &lt;/target&gt;\n"
5906             "  &lt;backingStore&gt;\n"
5907             "    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n"
5908             "  &lt;/backingStore&gt;\n"
5909             "&lt;/volume&gt;"
5910         )
5911         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5912     def test_volume_upload(self):
5913         pool_mock = MagicMock()
5914         vol_mock = MagicMock()
5915         pool_mock.storageVolLookupByName.return_value = vol_mock
5916         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5917         stream_mock = MagicMock()
5918         self.mock_conn.newStream.return_value = stream_mock
5919         open_mock = MagicMock()
5920         close_mock = MagicMock()
5921         with patch.dict(
5922             os.__dict__, {"open": open_mock, "close": close_mock}
5923         ):  # pylint: disable=no-member
5924             self.assertTrue(virt.volume_upload("pool0", "vol1.qcow2", "/path/to/file"))
5925             stream_mock.sendAll.assert_called_once()
5926             stream_mock.finish.assert_called_once()
5927             self.mock_conn.close.assert_called_once()
5928             vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
5929             stream_mock.sendAll.reset_mock()
5930             vol_mock.upload.reset_mock()
5931             self.assertTrue(
5932                 virt.volume_upload(
5933                     "pool0",
5934                     "vol1.qcow2",
5935                     "/path/to/file",
5936                     offset=123,
5937                     length=456,
5938                     sparse=True,
5939                 )
5940             )
5941             stream_mock.sendAll.assert_not_called()
5942             stream_mock.sparseSendAll.assert_called_once()
5943             vol_mock.upload.assert_called_once_with(
5944                 stream_mock,
5945                 123,
5946                 456,
5947                 self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
5948             )
5949             vol_mock.upload.side_effect = self.mock_libvirt.libvirtError("Unsupported")
5950             self.assertRaisesRegex(
5951                 CommandExecutionError,
5952                 "Unsupported",
5953                 virt.volume_upload,
5954                 "pool0",
5955                 "vol1.qcow2",
5956                 "/path/to/file",
5957             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
