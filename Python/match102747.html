<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_gentoo_service.py &amp; test_virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_gentoo_service.py &amp; test_virt_1.py
      </h3>
<h1 align="center">
        3.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_gentoo_service.py (14.976303%)<th>test_virt_1.py (1.8811764%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(101-106)<td><a href="#" name="0">(1022-1026)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(118-121)<td><a href="#" name="1">(1868-1872)</a><td align="center"><font color="#aa0000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(493-499)<td><a href="#" name="2">(1724-1727)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(132-135)<td><a href="#" name="3">(1002-1007)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(75-78)<td><a href="#" name="4">(986-991)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(61-64)<td><a href="#" name="5">(6420-6422)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(46-49)<td><a href="#" name="6">(970-975)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(502-508)<td><a href="#" name="7">(3617-3621)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(258-267)<td><a href="#" name="8">(2060-2064)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(32-35)<td><a href="#" name="9">(764-776)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(21-23)<td><a href="#" name="10">(6638-6641)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_gentoo_service.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.modules.gentoo_service as gentoo_service
2 from tests.support.mixins import LoaderModuleMockMixin
3 from tests.support.mock import MagicMock, call, patch
4 from tests.support.unit import TestCase
5 class GentooServicesTestCase(TestCase, LoaderModuleMockMixin):
6     def setup_loader_modules(self):
7         return {gentoo_service: {}}
8     def test_service_list_parser(self):
9         """
10         <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
11             self.assertFalse(gentoo_service.get_enabled())
12         mock.assert_called_once_with(</b></font>"rc-update -v show")
13     def test_get_enabled_single_runlevel(self):
14         """
15         Test for Return a list of service that are enabled on boot
16         """
17         runlevels = ["default"]
18         mock = MagicMock(return_value=self.__services({service_name: runlevels}))
19         with patch<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dict(gentoo_service.__salt__, {"cmd.run": mock}):
20             enabled_services = gentoo_service.get_enabled()
21             self.assertTrue(service_name in enabled_services)
22             self.assertEqual(enabled_services[</b></font>service_name], runlevels)
23     def test_get_enabled_filters_out_disabled_services(self):
24         """
25         Test for Return a list of service that are enabled on boot
26         """
27         service_name = "name"
28         runlevels = ["default"]
29         service_list = self.__services({service_name: runlevels, disabled_service: []})
30         mock <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value=service_list)
31         with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
32             enabled_services = gentoo_service.get_enabled()
33             self.assertEqual(len(</b></font>enabled_services), 1)
34             self.assertTrue(service_name in enabled_services)
35             self.assertEqual(enabled_services[service_name], runlevels)
36     def test_get_enabled_with_multiple_runlevels(self):
37         """
38         Test for Return a list of service that are enabled on boot at more than one runlevel
39         """
40         service_name = "name"
41         mock = MagicMock(return_value=self.__services({service_name: runlevels}))
42         with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
43             enabled_services = gentoo_service<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get_enabled()
44             self.assertTrue(service_name in enabled_services)
45             self.assertEqual(enabled_services[service_name][0], runlevels[1])
46             self.assertEqual(enabled_services[service_name][1], runlevels[</b></font>0])
47     def test_get_disabled(self):
48         """
49         Test for Return a list of service that are installed but disabled
50         """
51         disabled_service = "disabled"
52         enabled_service = "enabled"
53             {disabled_service: [], enabled_service: ["default"]}
54         )
55         mock <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value=service_list)
56         with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
57             disabled_services = gentoo_service.get_disabled()
58             self.assertTrue(len(</b></font>disabled_services), 1)
59             self.assertTrue(disabled_service in disabled_services)
60     def test_available(self):
61         """
62         Test for Returns ``True`` if the specified service is
63         available, otherwise returns
64         ``False``.
65         """
66         disabled_service = "disabled"
67         enabled_service = "enabled"
68         multilevel_service = "multilevel"
69         missing_service = "missing"
70         shutdown_service = "shutdown"
71         service_list = self.__services(
72             {
73                 disabled_service: [],
74                 enabled_service: ["default"],
75                 multilevel_service: ["default", "shutdown"],
76                 shutdown_service: ["shutdown"],
77         )
78         mock = MagicMock(return_value=service_list)
79         with patch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dict(gentoo_service.__salt__, {"cmd.run": mock}):
80             self.assertTrue(gentoo_service.available(enabled_service))
81             self.assertTrue(gentoo_service.available(multilevel_service))
82             self.assertTrue(gentoo_service.available(disabled_service))
83             self.assertTrue(gentoo_service.available(shutdown_service))
84             self.assertFalse(gentoo_service.available(</b></font>missing_service))
85     def test_missing(self):
86         """
87         Test for The inverse of service.available.
88         """
89         disabled_service = "disabled"
90         enabled_service = "enabled"
91         service_list = self.__services(
92         )
93         mock = MagicMock(return_value=service_list)
94         with patch<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dict(gentoo_service.__salt__, {"cmd.run": mock}):
95             self.assertFalse(gentoo_service.missing(enabled_service))
96             self.assertFalse(gentoo_service.missing(disabled_service))
97             self.assertTrue(gentoo_service.missing(</b></font>"missing"))
98     def test_getall(self):
99         """
100         Test for Return all available boot services
101         """
102         disabled_service = "disabled"
103         enabled_service = "enabled"
104             {disabled_service: [], enabled_service: ["default"]}
105         )
106         mock <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value=service_list)
107         with patch.dict(gentoo_service.__salt__, {"cmd.run": mock}):
108             all_services = gentoo_service.get_all()
109             self.assertEqual(len(</b></font>all_services), 2)
110             self.assertTrue(disabled_service in all_services)
111             self.assertTrue(enabled_service in all_services)
112     def test_start(self):
113         """
114         Test for Start the specified service
115         """
116         mock = MagicMock(return_value=True)
117         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
118             self.assertFalse(gentoo_service.start("name"))
119         mock.assert_called_once_with(
120             "/etc/init.d/name start", ignore_retcode=False, python_shell=False
121         )
122     def test_stop(self):
123         """
124         Test for Stop the specified service
125         """
126         mock = MagicMock(return_value=True)
127         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
128             self.assertFalse(gentoo_service.stop("name"))
129         mock.assert_called_once_with(
130             "/etc/init.d/name stop", ignore_retcode=False, python_shell=False
131         )
132     def test_restart(self):
133         """
134         Test for Restart the named service
135         """
136         mock = MagicMock(return_value=True)
137         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
138             self.assertFalse(gentoo_service.restart("name"))
139         mock.assert_called_once_with(
140             "/etc/init.d/name restart", ignore_retcode=False, python_shell=False
141         )
142     def test_reload_(self):
143         """
144         Test for Reload the named service
145         """
146         mock = MagicMock(return_value=True)
147         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
148             self.assertFalse(gentoo_service.reload_("name"))
149         mock.assert_called_once_with(
150             "/etc/init.d/name reload", ignore_retcode=False, python_shell=False
151         )
152     def test_zap(self):
153         """
154         Test for Reload the named service
155         """
156         mock = MagicMock(return_value=True)
157         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
158             self.assertFalse(gentoo_service.zap("name"))
159         mock.assert_called_once_with(
160             "/etc/init.d/name zap", ignore_retcode=False, python_shell=False
161         )
162     def test_status(self):
163         """
164         Test for Return the status for a service
165         """
166         mock = MagicMock(return_value=True)
167         with patch.dict(gentoo_service.__salt__, {"status.pid": mock}):
168             self.assertTrue(gentoo_service.status("name", 1))
169         mock = MagicMock(return_value=0)
170         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
171             self.assertTrue(gentoo_service.status("name"))
172         mock.assert_called_once_with(
173             "/etc/init.d/name status", ignore_retcode=True, python_shell=False
174         )
175         mock = MagicMock(return_value=1)
176         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
177             self.assertFalse(gentoo_service.status("name"))
178         mock.assert_called_once_with(
179             "/etc/init.d/name status", ignore_retcode=True, python_shell=False
180         )
181         mock = MagicMock(return_value=3)
182         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
183             self.assertFalse(gentoo_service.status("name"))
184         mock.assert_called_once_with(
185             "/etc/init.d/name status", ignore_retcode=True, python_shell=False
186         )
187         mock = MagicMock(return_value=32)
188         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": mock}):
189             self.assertFalse(gentoo_service.status("name"))
190         mock.assert_called_once_with(
191             "/etc/init.d/name status", ignore_retcode=True, python_shell=False
192         )
193     def test_enable(self):
194         """
195         Test for Enable the named service to start at boot
196         """
197         rc_update_mock = MagicMock(return_value=0)
198         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
199             self.assertTrue(gentoo_service.enable("name"))
200         rc_update_mock.assert_called_once_with(
201             "rc-update add name", ignore_retcode=False, python_shell=False
202         )
203         rc_update_mock.reset_mock()
204         service_name = "name"
205         runlevels = ["l1"]
206         level_list_mock = MagicMock(
207             return_value=self.__services({service_name: runlevels})
208         )
209         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
210             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
211                 self.assertTrue(gentoo_service.enable("name", runlevels="l2"))
212             [
213                 call(
214                     "rc-update delete name l1", ignore_retcode=False, python_shell<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=False
215                 ),
216                 call("rc-update add name l2", ignore_retcode=False, python_shell=False),
217             ]
218         )
219         rc_update_mock.reset_mock()
220         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
221             with</b></font> patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
222                 self.assertTrue(gentoo_service.enable("name", runlevels="l1"))
223         self.assertTrue(rc_update_mock.call_count == 0)
224         rc_update_mock.reset_mock()
225         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
226             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
227                 self.assertTrue(gentoo_service.enable("name", runlevels=["l1"]))
228         self.assertTrue(rc_update_mock.call_count == 0)
229         rc_update_mock.reset_mock()
230         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
231             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
232                 self.assertTrue(gentoo_service.enable("name", runlevels=["l2", "l1"]))
233         rc_update_mock.assert_called_once_with(
234             "rc-update add name l2", ignore_retcode=False, python_shell=False
235         )
236         rc_update_mock.reset_mock()
237         runlevels = ["l1", "l2"]
238         level_list_mock = MagicMock(
239             return_value=self.__services({service_name: runlevels})
240         )
241         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
242             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
243                 self.assertTrue(gentoo_service.enable("name", runlevels=["l2"]))
244         rc_update_mock.assert_called_once_with(
245             "rc-update delete name l1", ignore_retcode=False, python_shell=False
246         )
247         rc_update_mock.reset_mock()
248         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
249             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
250                 self.assertTrue(gentoo_service.enable("name", runlevels=["l1", "l3"]))
251         rc_update_mock.assert_has_calls(
252             [
253                 call(
254                     "rc-update delete name l2", ignore_retcode=False, python_shell=False
255                 ),
256                 call("rc-update add name l3", ignore_retcode=False, python_shell=False),
257             ]
258         )
259         rc_update_mock.reset_mock()
260         runlevels = ["l1", "l3", "l5"]
261         level_list_mock = MagicMock(
262             return_value=self.__services({service_name: runlevels})
263         )
264         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
265             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
266                 self.assertTrue(
267                     gentoo_service.enable("name", runlevels=["l2", "l4", "l5"])
268                 )
269         rc_update_mock.assert_has_calls(
270             [
271                 call(
272                     "rc-update delete name l1 l3",
273                     ignore_retcode=False,
274                     python_shell=False,
275                 ),
276                 call(
277                     "rc-update add name l2 l4", ignore_retcode=False, python_shell=False
278                 ),
279             ]
280         )
281         rc_update_mock.reset_mock()
282         rc_update_mock = MagicMock(return_value=1)
283         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
284             self.assertFalse(gentoo_service.enable("name"))
285         rc_update_mock.assert_called_once_with(
286             "rc-update add name", ignore_retcode=False, python_shell=False
287         )
288         rc_update_mock.reset_mock()
289         runlevels = ["l1"]
290         level_list_mock = MagicMock(
291             return_value=self.__services({service_name: runlevels})
292         )
293         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
294             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
295                 self.assertFalse(gentoo_service.enable("name", runlevels="l2"))
296         rc_update_mock.assert_called_once_with(
297             "rc-update delete name l1", ignore_retcode=False, python_shell=False
298         )
299         rc_update_mock.reset_mock()
300         rc_update_mock = MagicMock()
301         rc_update_mock.side_effect = [0, 1]
302         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
303             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
304                 self.assertFalse(gentoo_service.enable("name", runlevels="l2"))
305         rc_update_mock.assert_has_calls(
306             [
307                 call(
308                     "rc-update delete name l1", ignore_retcode=False, python_shell=False
309                 ),
310                 call("rc-update add name l2", ignore_retcode=False, python_shell=False),
311             ]
312         )
313         rc_update_mock.reset_mock()
314     def test_disable(self):
315         """
316         Test for Disable the named service to start at boot
317         """
318         rc_update_mock = MagicMock(return_value=0)
319         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
320             self.assertTrue(gentoo_service.disable("name"))
321         rc_update_mock.assert_called_once_with(
322             "rc-update delete name", ignore_retcode=False, python_shell=False
323         )
324         rc_update_mock.reset_mock()
325         service_name = "name"
326         runlevels = ["l1"]
327         level_list_mock = MagicMock(
328             return_value=self.__services({service_name: runlevels})
329         )
330         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
331             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
332                 self.assertTrue(gentoo_service.disable("name", runlevels="l1"))
333         rc_update_mock.assert_called_once_with(
334             "rc-update delete name l1", ignore_retcode=False, python_shell=False
335         )
336         rc_update_mock.reset_mock()
337         runlevels = ["l1"]
338         level_list_mock = MagicMock(
339             return_value=self.__services({service_name: runlevels})
340         )
341         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
342             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
343                 self.assertTrue(gentoo_service.disable("name", runlevels=["l1"]))
344         rc_update_mock.assert_called_once_with(
345             "rc-update delete name l1", ignore_retcode=False, python_shell=False
346         )
347         rc_update_mock.reset_mock()
348         runlevels = ["l1", "l2"]
349         level_list_mock = MagicMock(
350             return_value=self.__services({service_name: runlevels})
351         )
352         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
353             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
354                 self.assertTrue(gentoo_service.disable("name", runlevels=["l1"]))
355         rc_update_mock.assert_called_once_with(
356             "rc-update delete name l1", ignore_retcode=False, python_shell=False
357         )
358         rc_update_mock.reset_mock()
359         runlevels = ["l2"]
360         level_list_mock = MagicMock(
361             return_value=self.__services({service_name: runlevels})
362         )
363         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
364             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
365                 self.assertTrue(gentoo_service.disable("name", runlevels=["l1"]))
366         self.assertTrue(rc_update_mock.call_count == 0)
367         rc_update_mock.reset_mock()
368         runlevels = ["l1", "l2", "l3"]
369         level_list_mock = MagicMock(
370             return_value=self.__services({service_name: runlevels})
371         )
372         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
373             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
374                 self.assertTrue(gentoo_service.disable("name", runlevels=["l1", "l3"]))
375         rc_update_mock.assert_called_once_with(
376             "rc-update delete name l1 l3", ignore_retcode=False, python_shell=False
377         )
378         rc_update_mock.reset_mock()
379         rc_update_mock = MagicMock(return_value=1)
380         with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
381             self.assertFalse(gentoo_service.disable("name"))
382         rc_update_mock.assert_called_once_with(
383             "rc-update delete name", ignore_retcode=False, python_shell=False
384         )
385         rc_update_mock.reset_mock()
386         runlevels = ["l1"]
387         level_list_mock = MagicMock(
388             return_value=self.__services({service_name: runlevels})
389         )
390         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
391             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
392                 self.assertFalse(gentoo_service.disable("name", runlevels="l1"))
393         rc_update_mock.assert_called_once_with(
394             "rc-update delete name l1", ignore_retcode=False, python_shell=False
395         )
396         rc_update_mock.reset_mock()
397         runlevels = ["l1", "l2", "l3"]
398         level_list_mock = MagicMock(
399             return_value=self.__services({service_name: runlevels})
400         )
401         with patch.dict(gentoo_service.__salt__, {"cmd.run": level_list_mock}):
402             with patch.dict(gentoo_service.__salt__, {"cmd.retcode": rc_update_mock}):
403                 self.assertFalse(gentoo_service.disable("name", runlevels=["l1", "l3"]))
404         rc_update_mock.assert_called_once_with(
405             "rc-update delete name l1 l3", ignore_retcode=False, python_shell=False
406         )
407         rc_update_mock.reset_mock()
408     def test_enabled(self):
409         """
410         """
411         mock = MagicMock(return_value={"name": ["default"]})
412         with patch<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.object(gentoo_service, "get_enabled", mock):
413             self.assertTrue(gentoo_service.enabled("name"))
414             self.assertTrue(gentoo_service.enabled("name", runlevels="default"))
415         mock = MagicMock(return_value={"name": ["boot", "default"]})
416         with patch<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.object(gentoo_service, "get_enabled", mock):
417             self.assertTrue(gentoo_service.enabled("name"))
418             self.assertTrue(gentoo_service.enabled("name", runlevels="default"))
419             self.</b></font>assertTrue(
420                 gentoo_service.enabled("name", runlevels=["boot", "default"])
421             )
422             self.assertFalse(
423                 gentoo_service.enabled("name", runlevels="some-other-level")
424             )
425             self.assertFalse(
426                 gentoo_service.enabled("name", runlevels=["boot", "some-other-level"])
427             )
428     def test_disabled(self):
429         """
430         Test for Return True if the named service is disabled, false otherwise
431         """
432         mock = MagicMock(return_value=["name"])
433         with patch.object(gentoo_service, "get_disabled", mock):
434             self.assertTrue(gentoo_service.disabled("name"))
435     def __services(self, services):
436         return "\n".join(
437             [" | ".join([svc, " ".join(services[svc])]) for svc in services]
438         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 virt execution module unit tests
3 """
4 import datetime
5 import os
6 import shutil
7 import tempfile
8 import xml.etree.ElementTree as ET
9 import salt.config
10 import salt.modules.config as config
11 import salt.modules.virt as virt
12 import salt.syspaths
13 import salt.utils.yaml
14 from salt.exceptions import CommandExecutionError, SaltInvocationError
15 from tests.support.helpers import dedent
16 from tests.support.mixins import LoaderModuleMockMixin
17 from tests.support.mock import MagicMock, patch
18 from tests.support.unit import TestCase
19 class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
20     """
21     Libvirt library mock
22     """
23     class virDomain(MagicMock):
24         """
25         virDomain mock
26         """
27     class libvirtError(Exception):
28         """
29         libvirtError mock
30         """
31         def __init__(self, msg):
32             super().__init__(msg)
33             self.msg = msg
34         def get_error_message(self):
35             return self.msg
36 class VirtTestCase(TestCase, LoaderModuleMockMixin):
37     """
38     Test cases for salt.module.virt
39     """
40     def setup_loader_modules(self):
41         self.mock_libvirt = LibvirtMock()
42         self.mock_conn = MagicMock()
43         self.mock_conn.getStoragePoolCapabilities.return_value = (
44             "&lt;storagepoolCapabilities/&gt;"
45         )
46         self.mock_libvirt.openAuth.return_value = self.mock_conn
47         self.mock_popen = MagicMock()
48         self.addCleanup(delattr, self, "mock_libvirt")
49         self.addCleanup(delattr, self, "mock_conn")
50         self.addCleanup(delattr, self, "mock_popen")
51         self.mock_subprocess = MagicMock()
52         self.mock_subprocess.return_value = (
53             self.mock_subprocess
54         )  # pylint: disable=no-member
55         self.mock_subprocess.Popen.return_value = (
56             self.mock_popen
57         )  # pylint: disable=no-member
58         loader_globals = {
59             "__salt__": {"config.get": config.get, "config.option": config.option},
60             "libvirt": self.mock_libvirt,
61             "subprocess": self.mock_subprocess,
62         }
63         return {virt: loader_globals, config: loader_globals}
64     def set_mock_vm(self, name, xml):
65         """
66         Define VM to use in tests
67         """
68         self.mock_conn.listDefinedDomains.return_value = [
69             name
70         ]  # pylint: disable=no-member
71         mock_domain = self.mock_libvirt.virDomain()
72         self.mock_conn.lookupByName.return_value = (
73             mock_domain  # pylint: disable=no-member
74         )
75         mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member
76         mock_domain.info.return_value = [
77             4,
78             2048 * 1024,
79             1024 * 1024,
80             2,
81             1234,
82         ]  # pylint: disable=no-member
83         mock_domain.ID.return_value = 1
84         mock_domain.name.return_value = name
85         return mock_domain
86     def assert_equal_unit(self, actual, expected, unit="KiB"):
87         self.assertEqual(actual.get("unit"), unit)
88         self.assertEqual(actual.text, str(expected))
89     def test_disk_profile_merge(self):
90         """
91         Test virt._disk_profile() when merging with user-defined disks
92         """
93         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
94         userdisks = [
95             {"name": "system", "image": "/path/to/image"},
96             {"name": "data", "size": 16384, "format": "raw"},
97         ]
98         disks = virt._disk_profile(self.mock_conn, "default", "kvm", userdisks, "myvm")
99         self.assertEqual(
100             [
101                 {
102                     "name": "system",
103                     "device": "disk",
104                     "size": 8192,
105                     "format": "qcow2",
106                     "model": "virtio",
107                     "filename": "myvm_system.qcow2",
108                     "image": "/path/to/image",
109                     "source_file": "{}{}myvm_system.qcow2".format(root_dir, os.sep),
110                 },
111                 {
112                     "name": "data",
113                     "device": "disk",
114                     "size": 16384,
115                     "format": "raw",
116                     "model": "virtio",
117                     "filename": "myvm_data.raw",
118                     "source_file": "{}{}myvm_data.raw".format(root_dir, os.sep),
119                 },
120             ],
121             disks,
122         )
123     def test_boot_default_dev(self):
124         """
125         Test virt._gen_xml() default boot device
126         """
127         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
128         nicp = virt._nic_profile("default", "kvm")
129         xml_data = virt._gen_xml(
130             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
131         )
132         root = ET.fromstring(xml_data)
133         self.assertEqual(root.find("os/boot").attrib["dev"], "hd")
134         self.assertEqual(root.find("os/type").attrib["arch"], "x86_64")
135         self.assertEqual(root.find("os/type").text, "hvm")
136     def test_boot_custom_dev(self):
137         """
138         Test virt._gen_xml() custom boot device
139         """
140         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
141         nicp = virt._nic_profile("default", "kvm")
142         xml_data = virt._gen_xml(
143             self.mock_conn,
144             "hello",
145             1,
146             512,
147             diskp,
148             nicp,
149             "kvm",
150             "hvm",
151             "x86_64",
152             boot_dev="cdrom",
153         )
154         root = ET.fromstring(xml_data)
155         self.assertEqual(root.find("os/boot").attrib["dev"], "cdrom")
156     def test_boot_multiple_devs(self):
157         """
158         Test virt._gen_xml() multiple boot devices
159         """
160         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
161         nicp = virt._nic_profile("default", "kvm")
162         xml_data = virt._gen_xml(
163             self.mock_conn,
164             "hello",
165             1,
166             512,
167             diskp,
168             nicp,
169             "kvm",
170             "hvm",
171             "x86_64",
172             boot_dev="cdrom network",
173         )
174         root = ET.fromstring(xml_data)
175         devs = root.findall(".//boot")
176         self.assertTrue(len(devs) == 2)
177     def test_gen_xml_no_nic(self):
178         """
179         Test virt._gen_xml() serial console
180         """
181         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
182         nicp = virt._nic_profile("default", "kvm")
183         xml_data = virt._gen_xml(
184             self.mock_conn,
185             "hello",
186             1,
187             512,
188             diskp,
189             nicp,
190             "kvm",
191             "hvm",
192             "x86_64",
193             serials=[{"type": "pty"}],
194         )
195         root = ET.fromstring(xml_data)
196         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
197     def test_gen_xml_for_telnet_serial(self):
198         """
199         Test virt._gen_xml() telnet serial
200         """
201         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
202         nicp = virt._nic_profile("default", "kvm")
203         xml_data = virt._gen_xml(
204             self.mock_conn,
205             "hello",
206             1,
207             512,
208             diskp,
209             nicp,
210             "kvm",
211             "hvm",
212             "x86_64",
213             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
214         )
215         root = ET.fromstring(xml_data)
216         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
217         self.assertEqual(root.find("devices/serial/source").attrib["service"], "22223")
218         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
219     def test_gen_xml_for_telnet_serial_unspecified_port(self):
220         """
221         Test virt._gen_xml() telnet serial without any specified port
222         """
223         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
224         nicp = virt._nic_profile("default", "kvm")
225         xml_data = virt._gen_xml(
226             self.mock_conn,
227             "hello",
228             1,
229             512,
230             diskp,
231             nicp,
232             "kvm",
233             "hvm",
234             "x86_64",
235             serials=[{"type": "tcp"}],
236         )
237         root = ET.fromstring(xml_data)
238         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
239         self.assertEqual(root.find("devices/serial/source").attrib["service"], "23023")
240         self.assertFalse("tls" in root.find("devices/serial/source").keys())
241         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
242     def test_gen_xml_for_chardev_types(self):
243         """
244         Test virt._gen_xml() consoles and serials of various types
245         """
246         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
247         nicp = virt._nic_profile("default", "kvm")
248         xml_data = virt._gen_xml(
249             self.mock_conn,
250             "hello",
251             1,
252             512,
253             diskp,
254             nicp,
255             "kvm",
256             "hvm",
257             "x86_64",
258             consoles=[
259                 {"type": "pty", "path": "/dev/pts/2", "target_port": 2},
260                 {"type": "pty", "target_type": "usb-serial"},
261                 {"type": "stdio"},
262                 {"type": "file", "path": "/path/to/serial.log"},
263             ],
264             serials=[
265                 {"type": "pipe", "path": "/tmp/mypipe"},
266                 {"type": "udp", "host": "127.0.0.1", "port": 1234},
267                 {"type": "tcp", "port": 22223, "protocol": "raw", "tls": True},
268                 {"type": "unix", "path": "/path/to/socket"},
269             ],
270         )
271         root = ET.fromstring(xml_data)
272         self.assertEqual(root.find("devices/console[1]").attrib["type"], "pty")
273         self.assertEqual(
274             root.find("devices/console[1]/source").attrib["path"], "/dev/pts/2"
275         )
276         self.assertEqual(root.find("devices/console[1]/target").attrib["port"], "2")
277         self.assertEqual(root.find("devices/console[2]").attrib["type"], "pty")
278         self.assertIsNone(root.find("devices/console[2]/source"))
279         self.assertEqual(
280             root.find("devices/console[2]/target").attrib["type"], "usb-serial"
281         )
282         self.assertEqual(root.find("devices/console[3]").attrib["type"], "stdio")
283         self.assertIsNone(root.find("devices/console[3]/source"))
284         self.assertEqual(root.find("devices/console[4]").attrib["type"], "file")
285         self.assertEqual(
286             root.find("devices/console[4]/source").attrib["path"], "/path/to/serial.log"
287         )
288         self.assertEqual(root.find("devices/serial[1]").attrib["type"], "pipe")
289         self.assertEqual(
290             root.find("devices/serial[1]/source").attrib["path"], "/tmp/mypipe"
291         )
292         self.assertEqual(root.find("devices/serial[2]").attrib["type"], "udp")
293         self.assertEqual(root.find("devices/serial[2]/source").attrib["mode"], "bind")
294         self.assertEqual(
295             root.find("devices/serial[2]/source").attrib["service"], "1234"
296         )
297         self.assertEqual(
298             root.find("devices/serial[2]/source").attrib["host"], "127.0.0.1"
299         )
300         self.assertEqual(root.find("devices/serial[3]").attrib["type"], "tcp")
301         self.assertEqual(root.find("devices/serial[3]/source").attrib["mode"], "bind")
302         self.assertEqual(
303             root.find("devices/serial[3]/source").attrib["service"], "22223"
304         )
305         self.assertEqual(root.find("devices/serial[3]/source").attrib["tls"], "yes")
306         self.assertEqual(root.find("devices/serial[3]/protocol").attrib["type"], "raw")
307         self.assertEqual(root.find("devices/serial[4]").attrib["type"], "unix")
308         self.assertEqual(
309             root.find("devices/serial[4]/source").attrib["path"], "/path/to/socket"
310         )
311     def test_gen_xml_no_nic_console(self):
312         """
313         Test virt._gen_xml()  console
314         """
315         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
316         nicp = virt._nic_profile("default", "kvm")
317         xml_data = virt._gen_xml(
318             self.mock_conn,
319             "hello",
320             1,
321             512,
322             diskp,
323             nicp,
324             "kvm",
325             "hvm",
326             "x86_64",
327             consoles=[{"type": "pty"}],
328         )
329         root = ET.fromstring(xml_data)
330         self.assertEqual(root.find("devices/console").attrib["type"], "pty")
331     def test_gen_xml_for_telnet_console(self):
332         """
333         Test virt._gen_xml() telnet console
334         """
335         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
336         nicp = virt._nic_profile("default", "kvm")
337         xml_data = virt._gen_xml(
338             self.mock_conn,
339             "hello",
340             1,
341             512,
342             diskp,
343             nicp,
344             "kvm",
345             "hvm",
346             "x86_64",
347             consoles=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
348         )
349         root = ET.fromstring(xml_data)
350         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
351         self.assertEqual(root.find("devices/console/source").attrib["service"], "22223")
352         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
353     def test_gen_xml_for_telnet_console_unspecified_port(self):
354         """
355         Test virt._gen_xml() telnet console without any specified port
356         """
357         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
358         nicp = virt._nic_profile("default", "kvm")
359         xml_data = virt._gen_xml(
360             self.mock_conn,
361             "hello",
362             1,
363             512,
364             diskp,
365             nicp,
366             "kvm",
367             "hvm",
368             "x86_64",
369             consoles=[{"type": "tcp"}],
370         )
371         root = ET.fromstring(xml_data)
372         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
373         self.assertEqual(root.find("devices/console/source").attrib["service"], "23023")
374         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
375     def test_gen_xml_for_serial_no_console(self):
376         """
377         Test virt._gen_xml() with no serial console
378         """
379         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
380         nicp = virt._nic_profile("default", "kvm")
381         xml_data = virt._gen_xml(
382             self.mock_conn,
383             "hello",
384             1,
385             512,
386             diskp,
387             nicp,
388             "kvm",
389             "hvm",
390             "x86_64",
391             serials=[{"type": "pty"}],
392             consoles=[],
393         )
394         root = ET.fromstring(xml_data)
395         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
396         self.assertEqual(root.find("devices/console"), None)
397     def test_gen_xml_for_telnet_no_console(self):
398         """
399         Test virt._gen_xml() with no telnet console
400         """
401         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
402         nicp = virt._nic_profile("default", "kvm")
403         xml_data = virt._gen_xml(
404             self.mock_conn,
405             "hello",
406             1,
407             512,
408             diskp,
409             nicp,
410             "kvm",
411             "hvm",
412             "x86_64",
413             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
414             consoles=[],
415         )
416         root = ET.fromstring(xml_data)
417         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
418         self.assertEqual(root.find("devices/console"), None)
419     def test_gen_xml_nographics_default(self):
420         """
421         Test virt._gen_xml() with default no graphics device
422         """
423         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
424         nicp = virt._nic_profile("default", "kvm")
425         xml_data = virt._gen_xml(
426             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
427         )
428         root = ET.fromstring(xml_data)
429         self.assertIsNone(root.find("devices/graphics"))
430     def test_gen_xml_noloader_default(self):
431         """
432         Test virt._gen_xml() with default no loader
433         """
434         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
435         nicp = virt._nic_profile("default", "kvm")
436         xml_data = virt._gen_xml(
437             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
438         )
439         root = ET.fromstring(xml_data)
440         self.assertIsNone(root.find("os/loader"))
441     def test_gen_xml_vnc_default(self):
442         """
443         Test virt._gen_xml() with default vnc graphics device
444         """
445         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
446         nicp = virt._nic_profile("default", "kvm")
447         xml_data = virt._gen_xml(
448             self.mock_conn,
449             "hello",
450             1,
451             512,
452             diskp,
453             nicp,
454             "kvm",
455             "hvm",
456             "x86_64",
457             graphics={
458                 "type": "vnc",
459                 "port": 1234,
460                 "tlsPort": 5678,
461                 "listen": {"type": "address", "address": "myhost"},
462             },
463         )
464         root = ET.fromstring(xml_data)
465         self.assertEqual(root.find("devices/graphics").attrib["type"], "vnc")
466         self.assertEqual(root.find("devices/graphics").attrib["autoport"], "no")
467         self.assertEqual(root.find("devices/graphics").attrib["port"], "1234")
468         self.assertFalse("tlsPort" in root.find("devices/graphics").attrib)
469         self.assertEqual(root.find("devices/graphics").attrib["listen"], "myhost")
470         self.assertEqual(root.find("devices/graphics/listen").attrib["type"], "address")
471         self.assertEqual(
472             root.find("devices/graphics/listen").attrib["address"], "myhost"
473         )
474     def test_gen_xml_memory(self):
475         """
476         Test virt._gen_xml() with advanced memory settings
477         """
478         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
479         nicp = virt._nic_profile("default", "kvm")
480         xml_data = virt._gen_xml(
481             self.mock_conn,
482             "hello",
483             1,
484             {
485                 "boot": "512m",
486                 "current": "256m",
487                 "max": "1g",
488                 "hard_limit": "1024",
489                 "soft_limit": "512m",
490                 "swap_hard_limit": "1g",
491                 "min_guarantee": "256m",
492                 "hugepages": [
493                     {"size": "128m"},
494                     {"nodeset": "0", "size": "256m"},
495                     {"nodeset": "1", "size": "512m"},
496                 ],
497                 "nosharepages": True,
498                 "locked": True,
499                 "source": "file",
500                 "access": "shared",
501                 "allocation": "immediate",
502                 "discard": True,
503             },
504             diskp,
505             nicp,
506             "kvm",
507             "hvm",
508             "x86_64",
509         )
510         root = ET.fromstring(xml_data)
511         self.assert_equal_unit(root.find("memory"), 512 * 1024)
512         self.assert_equal_unit(root.find("currentMemory"), 256 * 1024)
513         self.assert_equal_unit(root.find("maxMemory"), 1024 * 1024)
514         self.assertFalse("slots" in root.find("maxMemory").keys())
515         self.assert_equal_unit(root.find("memtune/hard_limit"), 1024 * 1024)
516         self.assert_equal_unit(root.find("memtune/soft_limit"), 512 * 1024)
517         self.assert_equal_unit(root.find("memtune/swap_hard_limit"), 1024 ** 2)
518         self.assert_equal_unit(root.find("memtune/min_guarantee"), 256 * 1024)
519         self.assertEqual(
520             [
521                 {"nodeset": page.get("nodeset"), "size": page.get("size")}
522                 for page in root.findall("memoryBacking/hugepages/page")
523             ],
524             [
525                 {"nodeset": None, "size": str(128 * 1024)},
526                 {"nodeset": "0", "size": str(256 * 1024)},
527                 {"nodeset": "1", "size": str(512 * 1024)},
528             ],
529         )
530         self.assertIsNotNone(root.find("memoryBacking/nosharepages"))
531         self.assertIsNotNone(root.find("memoryBacking/locked"))
532         self.assertIsNotNone(root.find("memoryBacking/discard"))
533         self.assertEqual(root.find("memoryBacking/source").get("type"), "file")
534         self.assertEqual(root.find("memoryBacking/access").get("mode"), "shared")
535         self.assertEqual(root.find("memoryBacking/allocation").get("mode"), "immediate")
536     def test_gen_xml_cpu(self):
537         """
538         Test virt._gen_xml() with CPU advanced properties
539         """
540         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
541         nicp = virt._nic_profile("default", "kvm")
542         xml_data = virt._gen_xml(
543             self.mock_conn,
544             "hello",
545             {
546                 "maximum": 12,
547                 "placement": "static",
548                 "cpuset": "0-11",
549                 "current": 5,
550                 "mode": "custom",
551                 "match": "minimum",
552                 "check": "full",
553                 "vendor": "Intel",
554                 "model": {
555                     "name": "core2duo",
556                     "fallback": "allow",
557                     "vendor_id": "GenuineIntel",
558                 },
559                 "cache": {"level": 3, "mode": "emulate"},
560                 "features": {"lahf": "optional", "vmx": "require"},
561                 "vcpus": {
562                     0: {"enabled": True, "hotpluggable": True},
563                     1: {"enabled": False},
564                 },
565             },
566             512,
567             diskp,
568             nicp,
569             "kvm",
570             "hvm",
571             "x86_64",
572         )
573         root = ET.fromstring(xml_data)
574         self.assertEqual(root.find("vcpu").get("current"), "5")
575         self.assertEqual(root.find("vcpu").get("placement"), "static")
576         self.assertEqual(root.find("vcpu").get("cpuset"), "0-11")
577         self.assertEqual(root.find("vcpu").text, "12")
578         self.assertEqual(root.find("cpu").get("match"), "minimum")
579         self.assertEqual(root.find("cpu").get("mode"), "custom")
580         self.assertEqual(root.find("cpu").get("check"), "full")
581         self.assertEqual(root.find("cpu/vendor").text, "Intel")
582         self.assertEqual(root.find("cpu/model").text, "core2duo")
583         self.assertEqual(root.find("cpu/model").get("fallback"), "allow")
584         self.assertEqual(root.find("cpu/model").get("vendor_id"), "GenuineIntel")
585         self.assertEqual(root.find("cpu/cache").get("level"), "3")
586         self.assertEqual(root.find("cpu/cache").get("mode"), "emulate")
587         self.assertEqual(
588             {f.get("name"): f.get("policy") for f in root.findall("cpu/feature")},
589             {"lahf": "optional", "vmx": "require"},
590         )
591         self.assertEqual(
592             {
593                 v.get("id"): {
594                     "enabled": v.get("enabled"),
595                     "hotpluggable": v.get("hotpluggable"),
596                 }
597                 for v in root.findall("vcpus/vcpu")
598             },
599             {
600                 "0": {"enabled": "yes", "hotpluggable": "yes"},
601                 "1": {"enabled": "no", "hotpluggable": None},
602             },
603         )
604     def test_gen_xml_cpu_topology(self):
605         """
606         Test virt._gen_xml() with CPU topology
607         """
608         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
609         nicp = virt._nic_profile("default", "kvm")
610         xml_data = virt._gen_xml(
611             self.mock_conn,
612             "hello",
613             {"maximum": 1, "topology": {"sockets": 4, "cores": 16, "threads": 2}},
614             512,
615             diskp,
616             nicp,
617             "kvm",
618             "hvm",
619             "x86_64",
620         )
621         root = ET.fromstring(xml_data)
622         self.assertEqual(root.find("cpu/topology").get("sockets"), "4")
623         self.assertEqual(root.find("cpu/topology").get("cores"), "16")
624         self.assertEqual(root.find("cpu/topology").get("threads"), "2")
625     def test_gen_xml_cpu_numa(self):
626         """
627         Test virt._gen_xml() with CPU numa settings
628         """
629         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
630         nicp = virt._nic_profile("default", "kvm")
631         xml_data = virt._gen_xml(
632             self.mock_conn,
633             "hello",
634             {
635                 "maximum": 1,
636                 "numa": {
637                     0: {
638                         "cpus": "0-3",
639                         "memory": "1g",
640                         "discard": True,
641                         "distances": {0: 10, 1: 20},
642                     },
643                     1: {"cpus": "4-7", "memory": "2g", "distances": {0: 20, 1: 10}},
644                 },
645             },
646             512,
647             diskp,
648             nicp,
649             "kvm",
650             "hvm",
651             "x86_64",
652         )
653         root = ET.fromstring(xml_data)
654         cell0 = root.find("cpu/numa/cell[@id='0']")
655         self.assertEqual(cell0.get("cpus"), "0-3")
656         self.assertIsNone(cell0.get("unit"))
657         self.assertEqual(cell0.get("memory"), str(1024 ** 2))
658         self.assertEqual(cell0.get("discard"), "yes")
659         self.assertEqual(
660             {d.get("id"): d.get("value") for d in cell0.findall("distances/sibling")},
661             {"0": "10", "1": "20"},
662         )
663         cell1 = root.find("cpu/numa/cell[@id='1']")
664         self.assertEqual(cell1.get("cpus"), "4-7")
665         self.assertIsNone(cell0.get("unit"))
666         self.assertEqual(cell1.get("memory"), str(2 * 1024 ** 2))
667         self.assertFalse("discard" in cell1.keys())
668         self.assertEqual(
669             {d.get("id"): d.get("value") for d in cell1.findall("distances/sibling")},
670             {"0": "20", "1": "10"},
671         )
672     def test_gen_xml_cputune(self):
673         """
674         Test virt._gen_xml() with CPU tuning
675         """
676         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
677         nicp = virt._nic_profile("default", "kvm")
678         cputune = {
679             "shares": 2048,
680             "period": 122000,
681             "quota": -1,
682             "global_period": 1000000,
683             "global_quota": -3,
684             "emulator_period": 1200000,
685             "emulator_quota": -10,
686             "iothread_period": 133000,
687             "iothread_quota": -1,
688             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
689             "emulatorpin": "1-3",
690             "iothreadpin": {1: "5-6", 2: "7-8"},
691             "vcpusched": [
692                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
693                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
694                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
695             ],
696             "iothreadsched": [
697                 {"scheduler": "idle"},
698                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1},
699             ],
700             "emulatorsched": {"scheduler": "rr", "priority": 2},
701             "cachetune": {
702                 "0-3": {
703                     0: {"level": 3, "type": "both", "size": 3},
704                     1: {"level": 3, "type": "both", "size": 3},
705                     "monitor": {1: 3, "0-3": 3},
706                 },
707                 "4-5": {"monitor": {4: 3, 5: 2}},
708             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
709         }
710         xml_data = virt<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._gen_xml(
711             self.mock_conn,
712             "hello",
713             {"maximum": 1, "tuning": cputune, "iothreads": 2},
714             512,
715             diskp,
716             nicp,
717             "kvm",
718             "hvm",
719             "x86_64",
720         )
721         root = ET.fromstring(xml_data)
722         self.assertEqual(root.find("cputune").</b></font>find("shares").text, "2048")
723         self.assertEqual(root.find("cputune").find("period").text, "122000")
724         self.assertEqual(root.find("cputune").find("quota").text, "-1")
725         self.assertEqual(root.find("cputune").find("global_period").text, "1000000")
726         self.assertEqual(root.find("cputune").find("global_quota").text, "-3")
727         self.assertEqual(root.find("cputune").find("emulator_period").text, "1200000")
728         self.assertEqual(root.find("cputune").find("emulator_quota").text, "-10")
729         self.assertEqual(root.find("cputune").find("iothread_period").text, "133000")
730         self.assertEqual(root.find("cputune").find("iothread_quota").text, "-1")
731         self.assertEqual(
732             root.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
733             "1-4,^2",
734         )
735         self.assertEqual(
736             root.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
737             "0,1",
738         )
739         self.assertEqual(
740             root.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
741             "2,3",
742         )
743         self.assertEqual(
744             root.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
745             "0,4",
746         )
747         self.assertEqual(
748             root.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1-3"
749         )
750         self.assertEqual(
751             root.find("cputune")
752             .find("iothreadpin[@iothread='1']")
753             .attrib.get("cpuset"),
754             "5-6",
755         )
756         self.assertEqual(
757             root.find("cputune")
758             .find("iothreadpin[@iothread='2']")
759             .attrib.get("cpuset"),
760             "7-8",
761         )
762         self.assertDictEqual(
763             {
764                 s.get("vcpus"): {
765                     "scheduler": s.get("scheduler"),
766                     "priority": s.get("priority"),
767                 }
768                 for s in root.findall("cputune/vcpusched")
769             },
770             {
771                 "0": {"scheduler": "fifo", "priority": "1"},
772                 "1": {"scheduler": "fifo", "priority": "2"},
773                 "2": {"scheduler": "idle", "priority": "3"},
774             },
775         )
776         self.assertDictEqual(
777             {
778                 s.get("iothreads"): {
779                     "scheduler": s.get("scheduler"),
780                     "priority": s.get("priority"),
781                 }
782                 for s in root.findall("cputune/iothreadsched")
783             },
784             {
785                 None: {"scheduler": "idle", "priority": None},
786                 "5-7": {"scheduler": "batch", "priority": "1"},
787             },
788         )
789         self.assertEqual(root.find("cputune/emulatorsched").get("scheduler"), "rr")
790         self.assertEqual(root.find("cputune/emulatorsched").get("priority"), "2")
791         self.assertEqual(
792             root.find("./cputune/cachetune[@vcpus='0-3']").attrib.get("vcpus"), "0-3"
793         )
794         self.assertEqual(
795             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
796                 "level"
797             ),
798             "3",
799         )
800         self.assertEqual(
801             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
802                 "type"
803             ),
804             "both",
805         )
806         self.assertEqual(
807             root.find(
808                 "./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"
809             ).attrib.get("level"),
810             "3",
811         )
812         self.assertNotEqual(
813             root.find("./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"), None
814         )
815         self.assertNotEqual(
816             root.find("./cputune/cachetune[@vcpus='4-5']").attrib.get("vcpus"), None
817         )
818         self.assertEqual(
819             root.find("./cputune/cachetune[@vcpus='4-5']/cache[@id='0']"), None
820         )
821         self.assertEqual(
822             root.find(
823                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']"
824             ).attrib.get("level"),
825             "3",
826         )
827         self.assertEqual(
828             root.find(
829                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']"
830             ).attrib.get("level"),
831             "2",
832         )
833         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='0-2']"), None)
834         self.assertEqual(
835             root.find("./cputune/memorytune[@vcpus='0-2']/node[@id='0']").attrib.get(
836                 "bandwidth"
837             ),
838             "60",
839         )
840         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='3-4']"), None)
841         self.assertEqual(
842             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='0']").attrib.get(
843                 "bandwidth"
844             ),
845             "50",
846         )
847         self.assertEqual(
848             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='1']").attrib.get(
849                 "bandwidth"
850             ),
851             "70",
852         )
853         self.assertEqual(root.find("iothreads").text, "2")
854     def test_default_disk_profile_hypervisor_esxi(self):
855         """
856         Test virt._disk_profile() default ESXi profile
857         """
858         mock = MagicMock(return_value={})
859         with patch.dict(
860             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
861         ):
862             ret = virt._disk_profile(
863                 self.mock_conn, "nonexistent", "vmware", None, "test-vm"
864             )
865             self.assertTrue(len(ret) == 1)
866             found = [disk for disk in ret if disk["name"] == "system"]
867             self.assertTrue(bool(found))
868             system = found[0]
869             self.assertEqual(system["format"], "vmdk")
870             self.assertEqual(system["model"], "scsi")
871             self.assertTrue(int(system["size"]) &gt;= 1)
872     def test_default_disk_profile_hypervisor_kvm(self):
873         """
874         Test virt._disk_profile() default KVM profile
875         """
876         mock = MagicMock(side_effect=[{}, "/images/dir"])
877         with patch.dict(
878             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
879         ):
880             ret = virt._disk_profile(
881                 self.mock_conn, "nonexistent", "kvm", None, "test-vm"
882             )
883             self.assertTrue(len(ret) == 1)
884             found = [disk for disk in ret if disk["name"] == "system"]
885             self.assertTrue(bool(found))
886             system = found[0]
887             self.assertEqual(system["format"], "qcow2")
888             self.assertEqual(system["model"], "virtio")
889             self.assertTrue(int(system["size"]) &gt;= 1)
890     def test_default_disk_profile_hypervisor_xen(self):
891         """
892         Test virt._disk_profile() default XEN profile
893         """
894         mock = MagicMock(side_effect=[{}, "/images/dir"])
895         with patch.dict(
896             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
897         ):
898             ret = virt._disk_profile(
899                 self.mock_conn, "nonexistent", "xen", None, "test-vm"
900             )
901             self.assertTrue(len(ret) == 1)
902             found = [disk for disk in ret if disk["name"] == "system"]
903             self.assertTrue(bool(found))
904             system = found[0]
905             self.assertEqual(system["format"], "qcow2")
906             self.assertEqual(system["model"], "xen")
907             self.assertTrue(int(system["size"]) &gt;= 1)
908     def test_default_nic_profile_hypervisor_esxi(self):
909         Test virt._nic_profile() default ESXi profile
910         """
911         mock <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value={})
912         with patch.dict(
913             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
914         ):
915             ret = virt._nic_profile("nonexistent", "vmware")
916             self.assertTrue(len(</b></font>ret) == 1)
917             eth0 = ret[0]
918             self.assertEqual(eth0["name"], "eth0")
919             self.assertEqual(eth0["type"], "bridge")
920             self.assertEqual(eth0["source"], "DEFAULT")
921             self.assertEqual(eth0["model"], "e1000")
922     def test_default_nic_profile_hypervisor_kvm(self):
923         Test virt._nic_profile() default KVM profile
924         """
925         mock <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value={})
926         with patch.dict(
927             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
928         ):
929             ret = virt._nic_profile("nonexistent", "kvm")
930             self.assertTrue(len(</b></font>ret) == 1)
931             eth0 = ret[0]
932             self.assertEqual(eth0["name"], "eth0")
933             self.assertEqual(eth0["type"], "bridge")
934             self.assertEqual(eth0["source"], "br0")
935             self.assertEqual(eth0["model"], "virtio")
936     def test_default_nic_profile_hypervisor_xen(self):
937         Test virt._nic_profile() default XEN profile
938         """
939         mock <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value={})
940         with patch.dict(
941             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
942         ):
943             ret = virt._nic_profile("nonexistent", "xen")
944             self.assertTrue(len(</b></font>ret) == 1)
945             eth0 = ret[0]
946             self.assertEqual(eth0["name"], "eth0")
947             self.assertEqual(eth0["type"], "bridge")
948             self.assertEqual(eth0["source"], "br0")
949             self.assertFalse(eth0["model"])
950     def test_gen_vol_xml_esx(self):
951         """
952         Test virt._get_vol_xml() for the ESX case
953         """
954         xml_data = virt._gen_vol_xml("vmname/system.vmdk", 8192, format="vmdk")
955         self.assertIsNone(root.get("type"))
956         self.assertEqual(root.find("name").text, "vmname/system.vmdk")
957         self.assertEqual(root<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("capacity").attrib["unit"], "KiB")
958         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
959         self.assertEqual(root.find("allocation").text, str(0))
960         self.assertEqual(root.find("target/format").get("type"), "vmdk")
961         self.assertIsNone(</b></font>root.find("target/permissions"))
962         self.assertIsNone(root.find("target/nocow"))
963         self.assertIsNone(root.find("backingStore"))
964     def test_gen_vol_xml_file(self):
965         """
966         Test virt._get_vol_xml() for a file volume
967         """
968         xml_data = virt._gen_vol_xml(
969             "myvm_system.qcow2",
970             8192,
971             format="qcow2",
972             allocation=4096,
973             type="file",
974             permissions={
975                 "mode": "0775",
976                 "owner": "123",
977                 "group": "456",
978                 "label": "sec_label",
979             },
980             backing_store={"path": "/backing/image", "format": "raw"},
981             nocow=True,
982         )
983         root = ET.fromstring(xml_data)
984         self.assertEqual(root.get("type"), "file")
985         self.assertEqual(root.find("name").text, "myvm_system.qcow2")
986         self.assertIsNone(root.find("key"))
987         self.assertIsNone(root.find("target/path"))
988         self.assertEqual(root.find("target/format").get("type"), "qcow2")
989         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
990         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
991         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
992         self.assertEqual(root.find("allocation").text, str(4096 * 1024))
993         self.assertEqual(root.find("target/permissions/mode").text, "0775")
994         self.assertEqual(root.find("target/permissions/owner").text, "123")
995         self.assertEqual(root.find("target/permissions/group").text, "456")
996         self.assertEqual(root.find("target/permissions/label").text, "sec_label")
997         self.assertIsNotNone(root.find("target/nocow"))
998         self.assertEqual(root.find("backingStore/path").text, "/backing/image")
999         self.assertEqual(root.find("backingStore/format").get("type"), "raw")
1000     def test_gen_xml_for_kvm_default_profile(self):
1001         """
1002         Test virt._gen_xml(), KVM default profile case
1003         """
1004         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
1005         nicp = virt._nic_profile("default", "kvm")
1006         xml_data = virt._gen_xml(
1007             self.mock_conn,
1008             "hello",
1009             1,
1010             512,
1011             diskp,
1012             nicp,
1013             "kvm",
1014             "hvm",
1015             "x86_64",
1016         )
1017         root = ET.fromstring(xml_data)
1018         self.assertEqual(root.attrib["type"], "kvm")
1019         self.assertEqual(root.find("vcpu").text, "1")
1020         self.assertEqual(root.find("memory").text, str(512 * 1024))
1021         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1022         disks = root.findall(".//disk")
1023         self.assertEqual(len(disks), 1)
1024         disk = disks[0]
1025         root_dir = salt.config.DEFAULT_MINION_OPTS.get("root_dir")
1026         self.assertTrue(disk.find("source").attrib["file"].startswith(root_dir))
1027         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
1028         self.assertEqual(disk.find("target").attrib["dev"], "vda")
1029         self.assertEqual(disk.find("target").attrib["bus"], "virtio")
1030         self.assertEqual(disk.find("driver").attrib["name"], "qemu")
1031         self.assertEqual(disk.find("driver").attrib["type"], "qcow2")
1032         interfaces = root.findall(".//interface")
1033         self.assertEqual(len(interfaces), 1)
1034         iface = interfaces[0]
1035         self.assertEqual(iface.attrib["type"], "bridge")
1036         self.assertEqual(iface.find("source").attrib["bridge"], "br0")
1037         self.assertEqual(iface.find("model").attrib["type"], "virtio")
1038     def test_gen_xml_for_esxi_default_profile(self):
1039         """
1040         Test virt._gen_xml(), ESXi/vmware default profile case
1041         """
1042         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
1043         nicp = virt._nic_profile("default", "vmware")
1044         xml_data = virt._gen_xml(
1045             self.mock_conn,
1046             "hello",
1047             1,
1048             512,
1049             diskp,
1050             nicp,
1051             "vmware",
1052             "hvm",
1053             "x86_64",
1054         )
1055         root = ET.fromstring(xml_data)
1056         self.assertEqual(root.attrib["type"], "vmware")
1057         self.assertEqual(root.find("vcpu").text, "1")
1058         self.assertEqual(root.find("memory").text, str(512 * 1024))
1059         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1060         disks = root.findall(".//disk")
1061         self.assertEqual(len(disks), 1)
1062         disk = disks[0]
1063         self.assertTrue("[0]" in disk.find("source").attrib["file"])
1064         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
1065         self.assertEqual(disk.find("target").attrib["dev"], "sda")
1066         self.assertEqual(disk.find("target").attrib["bus"], "scsi")
1067         self.assertEqual(disk.find("address").attrib["unit"], "0")
1068         interfaces = root.findall(".//interface")
1069         self.assertEqual(len(interfaces), 1)
1070         iface = interfaces[0]
1071         self.assertEqual(iface.attrib["type"], "bridge")
1072         self.assertEqual(iface.find("source").attrib["bridge"], "DEFAULT")
1073         self.assertEqual(iface.find("model").attrib["type"], "e1000")
1074     def test_gen_xml_for_esxi_custom_profile(self):
1075         """
1076         Test virt._gen_xml(), ESXi/vmware custom profile case
1077         """
1078         disks = {
1079             "noeffect": [
1080                 {"first": {"size": 8192, "pool": "datastore1"}},
1081                 {"second": {"size": 4096, "pool": "datastore2"}},
1082             ]
1083         }
1084         nics = {
1085             "noeffect": [
1086                 {"name": "eth1", "source": "ONENET"},
1087                 {"name": "eth2", "source": "TWONET"},
1088             ]
1089         }
1090         with patch.dict(
1091             virt.__salt__,  # pylint: disable=no-member
1092             {"config.get": MagicMock(side_effect=[disks, nics])},
1093         ):
1094             diskp = virt._disk_profile(
1095                 self.mock_conn, "noeffect", "vmware", [], "hello"
1096             )
1097             nicp = virt._nic_profile("noeffect", "vmware")
1098             xml_data = virt._gen_xml(
1099                 self.mock_conn,
1100                 "hello",
1101                 1,
1102                 512,
1103                 diskp,
1104                 nicp,
1105                 "vmware",
1106                 "hvm",
1107                 "x86_64",
1108             )
1109             root = ET.fromstring(xml_data)
1110             self.assertEqual(root.attrib["type"], "vmware")
1111             self.assertEqual(root.find("vcpu").text, "1")
1112             self.assertEqual(root.find("memory").text, str(512 * 1024))
1113             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1114             self.assertTrue(len(root.findall(".//disk")) == 2)
1115             self.assertTrue(len(root.findall(".//interface")) == 2)
1116     def test_gen_xml_for_kvm_custom_profile(self):
1117         """
1118         Test virt._gen_xml(), KVM custom profile case
1119         """
1120         disks = {
1121             "noeffect": [
1122                 {"first": {"size": 8192, "pool": "/var/lib/images"}},
1123                 {"second": {"size": 4096, "pool": "/var/lib/images"}},
1124             ]
1125         }
1126         nics = {
1127             "noeffect": [
1128                 {"name": "eth1", "source": "b2"},
1129                 {"name": "eth2", "source": "b2"},
1130             ]
1131         }
1132         with patch.dict(
1133             virt.__salt__,  # pylint: disable=no-member
1134             {"config.get": MagicMock(side_effect=[disks, nics])},
1135         ):
1136             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1137             nicp = virt._nic_profile("noeffect", "kvm")
1138             xml_data = virt._gen_xml(
1139                 self.mock_conn,
1140                 "hello",
1141                 1,
1142                 512,
1143                 diskp,
1144                 nicp,
1145                 "kvm",
1146                 "hvm",
1147                 "x86_64",
1148             )
1149             root = ET.fromstring(xml_data)
1150             self.assertEqual(root.attrib["type"], "kvm")
1151             self.assertEqual(root.find("vcpu").text, "1")
1152             self.assertEqual(root.find("memory").text, str(512 * 1024))
1153             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1154             disks = root.findall(".//disk")
1155             self.assertTrue(len(disks) == 2)
1156             self.assertEqual(disks[0].find("target").get("dev"), "vda")
1157             self.assertEqual(disks[1].find("target").get("dev"), "vdb")
1158             self.assertTrue(len(root.findall(".//interface")) == 2)
1159     def test_disk_profile_kvm_disk_pool(self):
1160         """
1161         Test virt._disk_profile(), KVM case with pools defined.
1162         """
1163         disks = {
1164             "noeffect": [
1165                 {"first": {"size": 8192, "pool": "mypool"}},
1166                 {"second": {"size": 4096}},
1167             ]
1168         }
1169         with patch.dict(
1170             virt.__salt__,
1171             {
1172                 "config.get": MagicMock(
1173                     side_effect=[
1174                         disks,
1175                         os.path.join(salt.syspaths.ROOT_DIR, "default", "path"),
1176                     ]
1177                 )
1178             },
1179         ):
1180             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1181             pools_path = (
1182                 os.path.join(salt.syspaths.ROOT_DIR, "pools", "mypool") + os.sep
1183             )
1184             default_path = (
1185                 os.path.join(salt.syspaths.ROOT_DIR, "default", "path") + os.sep
1186             )
1187             self.assertEqual(len(diskp), 2)
1188             self.assertTrue(diskp[1]["source_file"].startswith(default_path))
1189     def test_disk_profile_kvm_disk_external_image(self):
1190         """
1191         Test virt._gen_xml(), KVM case with an external image.
1192         """
1193         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1194             diskp = virt._disk_profile(
1195                 self.mock_conn,
1196                 None,
1197                 "kvm",
1198                 [{"name": "mydisk", "source_file": "/path/to/my/image.qcow2"}],
1199                 "hello",
1200             )
1201             self.assertEqual(len(diskp), 1)
1202             self.assertEqual(diskp[0]["source_file"], "/path/to/my/image.qcow2")
1203     def test_disk_profile_cdrom_default(self):
1204         """
1205         Test virt._gen_xml(), KVM case with cdrom.
1206         """
1207         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1208             diskp = virt._disk_profile(
1209                 self.mock_conn,
1210                 None,
1211                 "kvm",
1212                 [
1213                     {
1214                         "name": "mydisk",
1215                         "device": "cdrom",
1216                         "source_file": "/path/to/my.iso",
1217                     }
1218                 ],
1219                 "hello",
1220             )
1221             self.assertEqual(len(diskp), 1)
1222             self.assertEqual(diskp[0]["model"], "ide")
1223             self.assertEqual(diskp[0]["format"], "raw")
1224     def test_disk_profile_pool_disk_type(self):
1225         """
1226         Test virt._disk_profile(), with a disk pool of disk type
1227         """
1228         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1229         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1230             &lt;pool type="disk"&gt;
1231               &lt;name&gt;test-vdb&lt;/name&gt;
1232               &lt;source&gt;
1233                 &lt;device path='/dev/vdb'/&gt;
1234               &lt;/source&gt;
1235               &lt;target&gt;
1236                 &lt;path&gt;/dev&lt;/path&gt;
1237               &lt;/target&gt;
1238             &lt;/pool&gt;
1239         """
1240         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = (
1241             []
1242         )
1243         diskp = virt._disk_profile(
1244             self.mock_conn,
1245             None,
1246             "kvm",
1247             [{"name": "mydisk", "pool": "test-vdb"}],
1248             "hello",
1249         )
1250         self.assertEqual(diskp[0]["filename"], "vdb1")
1251         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1252             "vdb1",
1253             "vdb2",
1254         ]
1255         diskp = virt._disk_profile(
1256             self.mock_conn,
1257             None,
1258             "kvm",
1259             [{"name": "mydisk", "pool": "test-vdb"}],
1260             "hello",
1261         )
1262         self.assertEqual(diskp[0]["filename"], "vdb3")
1263         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1264             "vdb1",
1265             "vdb3",
1266         ]
1267         diskp = virt._disk_profile(
1268             self.mock_conn,
1269             None,
1270             "kvm",
1271             [{"name": "mydisk", "pool": "test-vdb"}],
1272             "hello",
1273         )
1274         self.assertEqual(diskp[0]["filename"], "vdb2")
1275         diskp = virt._disk_profile(
1276             self.mock_conn,
1277             None,
1278             "kvm",
1279             [{"name": "mydisk", "pool": "test-vdb", "source_file": "vdb1"}],
1280             "hello",
1281         )
1282         self.assertEqual(diskp[0]["filename"], "vdb1")
1283     def test_gen_xml_volume(self):
1284         """
1285         Test virt._gen_xml(), generating a disk of volume type
1286         """
1287         self.mock_conn.listStoragePools.return_value = ["default"]
1288         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1289             "&lt;pool type='dir'/&gt;"
1290         )
1291         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1292             "myvolume"
1293         ]
1294         diskp = virt._disk_profile(
1295             self.mock_conn,
1296             None,
1297             "kvm",
1298             [
1299                 {"name": "system", "pool": "default"},
1300                 {"name": "data", "pool": "default", "source_file": "myvolume"},
1301             ],
1302             "hello",
1303         )
1304         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1305             "&lt;pool type='dir'/&gt;"
1306         )
1307         nicp = virt._nic_profile(None, "kvm")
1308         xml_data = virt._gen_xml(
1309             self.mock_conn,
1310             "hello",
1311             1,
1312             512,
1313             diskp,
1314             nicp,
1315             "kvm",
1316             "hvm",
1317             "x86_64",
1318         )
1319         root = ET.fromstring(xml_data)
1320         disk = root.findall(".//disk")[0]
1321         self.assertEqual(disk.attrib["device"], "disk")
1322         self.assertEqual(disk.attrib["type"], "volume")
1323         source = disk.find("source")
1324         self.assertEqual("default", source.attrib["pool"])
1325         self.assertEqual("hello_system", source.attrib["volume"])
1326         self.assertEqual("myvolume", root.find(".//disk[2]/source").get("volume"))
1327         self.mock_conn.listStoragePools.return_value = ["test-rbd"]
1328         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1329             &lt;pool type='rbd'&gt;
1330               &lt;name&gt;test-rbd&lt;/name&gt;
1331               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1332               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1333               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1334               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1335               &lt;source&gt;
1336                 &lt;host name='ses2.tf.local'/&gt;
1337                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1338                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1339                 &lt;auth type='ceph' username='libvirt'&gt;
1340                   &lt;secret usage='pool_test-rbd'/&gt;
1341                 &lt;/auth&gt;
1342               &lt;/source&gt;
1343             &lt;/pool&gt;
1344         """
1345         self.mock_conn.getStoragePoolCapabilities.return_value = """
1346             &lt;storagepoolCapabilities&gt;
1347               &lt;pool type='rbd' supported='yes'&gt;
1348                 &lt;volOptions&gt;
1349                   &lt;defaultFormat type='raw'/&gt;
1350                   &lt;enum name='targetFormatType'&gt;
1351                   &lt;/enum&gt;
1352                 &lt;/volOptions&gt;
1353               &lt;/pool&gt;
1354             &lt;/storagepoolCapabilities&gt;
1355         """
1356         diskp = virt._disk_profile(
1357             self.mock_conn,
1358             None,
1359             "kvm",
1360             [{"name": "system", "pool": "test-rbd"}],
1361             "test-vm",
1362         )
1363         xml_data = virt._gen_xml(
1364             self.mock_conn,
1365             "hello",
1366             1,
1367             512,
1368             diskp,
1369             nicp,
1370             "kvm",
1371             "hvm",
1372             "x86_64",
1373         )
1374         root = ET.fromstring(xml_data)
1375         disk = root.findall(".//disk")[0]
1376         self.assertDictEqual(
1377             {
1378                 "type": "network",
1379                 "device": "disk",
1380                 "source": {
1381                     "protocol": "rbd",
1382                     "name": "libvirt-pool/test-vm_system",
1383                     "host": [
1384                         {"name": "ses2.tf.local"},
1385                         {"name": "ses3.tf.local", "port": "1234"},
1386                     ],
1387                     "auth": {
1388                         "username": "libvirt",
1389                         "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1390                     },
1391                 },
1392                 "target": {"dev": "vda", "bus": "virtio"},
1393                 "driver": {
1394                     "name": "qemu",
1395                     "type": "raw",
1396                     "cache": "none",
1397                     "io": "native",
1398                 },
1399             },
1400             salt.utils.xmlutil.to_dict(disk, True),
1401         )
1402         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1403             &lt;pool type='rbd'&gt;
1404               &lt;name&gt;test-rbd&lt;/name&gt;
1405               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1406               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1407               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1408               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1409               &lt;source&gt;
1410                 &lt;host name='ses2.tf.local'/&gt;
1411                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1412                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1413                 &lt;auth type='ceph' username='libvirt'&gt;
1414                   &lt;secret uuid='some-uuid'/&gt;
1415                 &lt;/auth&gt;
1416               &lt;/source&gt;
1417             &lt;/pool&gt;
1418         """
1419         self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
1420             "pool_test-rbd"
1421         )
1422         diskp = virt._disk_profile(
1423             self.mock_conn,
1424             None,
1425             "kvm",
1426             [{"name": "system", "pool": "test-rbd"}],
1427             "test-vm",
1428         )
1429         xml_data = virt._gen_xml(
1430             self.mock_conn,
1431             "hello",
1432             1,
1433             512,
1434             diskp,
1435             nicp,
1436             "kvm",
1437             "hvm",
1438             "x86_64",
1439         )
1440         root = ET.fromstring(xml_data)
1441         self.assertDictEqual(
1442             {
1443                 "username": "libvirt",
1444                 "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1445             },
1446             salt.utils.xmlutil.to_dict(root.find(".//disk/source/auth"), True),
1447         )
1448         self.mock_conn.secretLookupByUUIDString.assert_called_once_with("some-uuid")
1449         self.mock_conn.getStoragePoolCapabilities.return_value = """
1450             &lt;storagepoolCapabilities&gt;
1451               &lt;pool type='disk' supported='yes'&gt;
1452                 &lt;volOptions&gt;
1453                   &lt;defaultFormat type='none'/&gt;
1454                   &lt;enum name='targetFormatType'&gt;
1455                     &lt;value&gt;none&lt;/value&gt;
1456                     &lt;value&gt;linux&lt;/value&gt;
1457                     &lt;value&gt;fat16&lt;/value&gt;
1458                   &lt;/enum&gt;
1459                 &lt;/volOptions&gt;
1460               &lt;/pool&gt;
1461             &lt;/storagepoolCapabilities&gt;
1462         """
1463         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1464             &lt;pool type='disk'&gt;
1465               &lt;name&gt;test-vdb&lt;/name&gt;
1466               &lt;source&gt;
1467                 &lt;device path='/dev/vdb'/&gt;
1468                 &lt;format type='gpt'/&gt;
1469               &lt;/source&gt;
1470             &lt;/pool&gt;
1471         """
1472         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1473         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1474             "vdb1",
1475         ]
1476         diskp = virt._disk_profile(
1477             self.mock_conn,
1478             None,
1479             "kvm",
1480             [{"name": "system", "pool": "test-vdb"}],
1481             "test-vm",
1482         )
1483         xml_data = virt._gen_xml(
1484             self.mock_conn,
1485             "hello",
1486             1,
1487             512,
1488             diskp,
1489             nicp,
1490             "kvm",
1491             "hvm",
1492             "x86_64",
1493         )
1494         root = ET.fromstring(xml_data)
1495         disk = root.findall(".//disk")[0]
1496         self.assertEqual(disk.attrib["type"], "volume")
1497         source = disk.find("source")
1498         self.assertEqual("test-vdb", source.attrib["pool"])
1499         self.assertEqual("vdb2", source.attrib["volume"])
1500         self.assertEqual("raw", disk.find("driver").get("type"))
1501     def test_get_xml_volume_xen_dir(self):
1502         """
1503         Test virt._gen_xml generating disks for a Xen hypervisor
1504         """
1505         self.mock_conn.listStoragePools.return_value = ["default"]
1506         pool_mock = MagicMock()
1507         pool_mock.XMLDesc.return_value = (
1508             "&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;"
1509         )
1510         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1511         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1512         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1513         diskp = virt._disk_profile(
1514             self.mock_conn,
1515             None,
1516             "xen",
1517             [{"name": "system", "pool": "default"}],
1518             "hello",
1519         )
1520         xml_data = virt._gen_xml(
1521             self.mock_conn,
1522             "hello",
1523             1,
1524             512,
1525             diskp,
1526             [],
1527             "xen",
1528             "hvm",
1529             "x86_64",
1530         )
1531         root = ET.fromstring(xml_data)
1532         disk = root.findall(".//disk")[0]
1533         self.assertEqual(disk.attrib["type"], "file")
1534         self.assertEqual(
1535             "/path/to/images/hello_system", disk.find("source").attrib["file"]
1536         )
1537     def test_get_xml_volume_xen_block(self):
1538         """
1539         Test virt._gen_xml generating disks for a Xen hypervisor
1540         """
1541         self.mock_conn.listStoragePools.return_value = ["default"]
1542         pool_mock = MagicMock()
1543         pool_mock.listVolumes.return_value = ["vol01"]
1544         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1545         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1546         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1547         for pool_type in ["logical", "disk", "iscsi", "scsi"]:
1548             pool_mock.XMLDesc.return_value = "&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;".format(
1549                 pool_type
1550             )
1551             diskp = virt._disk_profile(
1552                 self.mock_conn,
1553                 None,
1554                 "xen",
1555                 [{"name": "system", "pool": "default", "source_file": "vol01"}],
1556                 "hello",
1557             )
1558             xml_data = virt._gen_xml(
1559                 self.mock_conn,
1560                 "hello",
1561                 1,
1562                 512,
1563                 diskp,
1564                 [],
1565                 "xen",
1566                 "hvm",
1567                 "x86_64",
1568             )
1569             root = ET.fromstring(xml_data)
1570             disk = root.findall(".//disk")[0]
1571             self.assertEqual(disk.attrib["type"], "block")
1572             self.assertEqual("/dev/to/vol01", disk.find("source").attrib["dev"])
1573     def test_gen_xml_cdrom(self):
1574         """
1575         Test virt._gen_xml(), generating a cdrom device (different disk type, no source)
1576         """
1577         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1578             "&lt;pool type='dir'/&gt;"
1579         )
1580         diskp = virt._disk_profile(
1581             self.mock_conn,
1582             None,
1583             "kvm",
1584             [
1585                 {"name": "system", "pool": "default"},
1586                 {
1587                     "name": "tested",
1588                     "device": "cdrom",
1589                     "source_file": None,
1590                     "model": "ide",
1591                 },
1592                 {
1593                     "name": "remote",
1594                     "device": "cdrom",
1595                     "source_file": (
1596                         "http://myhost:8080/url/to/image?query=foo&amp;filter=bar"
1597                     ),
1598                     "model": "ide",
1599                 },
1600             ],
1601             "hello",
1602         )
1603         nicp = virt._nic_profile(None, "kvm")
1604         xml_data = virt._gen_xml(
1605             self.mock_conn,
1606             "hello",
1607             1,
1608             512,
1609             diskp,
1610             nicp,
1611             "kvm",
1612             "hvm",
1613             "x86_64",
1614         )
1615         root = ET.fromstring(xml_data)
1616         self.assertEqual(disk.get("type"), "file")
1617         self.assertEqual(disk.attrib["device"], "cdrom")
1618         self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertIsNone(disk.find("source"))
1619         self.assertEqual(disk.find("target").get("dev"), "hda")
1620         disk = root.findall(".//disk")[</b></font>2]
1621         self.assertEqual(disk.get("type"), "network")
1622         self.assertEqual(disk.attrib["device"], "cdrom")
1623         self.assertEqual(
1624             {
1625                 "protocol": "http",
1626                 "name": "/url/to/image",
1627                 "query": "query=foo&amp;filter=bar",
1628                 "host": {"name": "myhost", "port": "8080"},
1629             },
1630             salt.utils.xmlutil.to_dict(disk.find("source"), True),
1631         )
1632     def test_controller_for_esxi(self):
1633         """
1634         Test virt._gen_xml() generated device controller for ESXi/vmware
1635         """
1636         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
1637         nicp = virt._nic_profile("default", "vmware")
1638         xml_data = virt._gen_xml(
1639             self.mock_conn,
1640             "hello",
1641             1,
1642             512,
1643             diskp,
1644             nicp,
1645             "vmware",
1646             "hvm",
1647             "x86_64",
1648         )
1649         root = ET.fromstring(xml_data)
1650         controllers = root.findall(".//devices/controller")
1651         self.assertTrue(len(controllers) == 1)
1652         controller = controllers[0]
1653         self.assertEqual(controller.attrib["model"], "lsilogic")
1654     def test_controller_for_kvm(self):
1655         """
1656         Test virt._gen_xml() generated device controller for KVM
1657         """
1658         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
1659         nicp = virt._nic_profile("default", "kvm")
1660         xml_data = virt._gen_xml(
1661             self.mock_conn,
1662             "hello",
1663             1,
1664             512,
1665             diskp,
1666             nicp,
1667             "kvm",
1668             "hvm",
1669             "x86_64",
1670         )
1671         root = ET.fromstring(xml_data)
1672         controllers = root.findall(".//devices/controller")
1673         self.assertTrue(len(controllers) == 0)
1674     def test_diff_disks(self):
1675         """
1676         Test virt._diff_disks()
1677         """
1678         old_disks = ET.fromstring(
1679             """
1680             &lt;devices&gt;
1681               &lt;disk type='file' device='disk'&gt;
1682                 &lt;source file='/path/to/img0.qcow2'/&gt;
1683                 &lt;target dev='vda' bus='virtio'/&gt;
1684               &lt;/disk&gt;
1685               &lt;disk type='file' device='disk'&gt;
1686                 &lt;source file='/path/to/img1.qcow2'/&gt;
1687                 &lt;target dev='vdb' bus='virtio'/&gt;
1688               &lt;/disk&gt;
1689               &lt;disk type='file' device='disk'&gt;
1690                 &lt;source file='/path/to/img2.qcow2'/&gt;
1691                 &lt;target dev='hda' bus='ide'/&gt;
1692               &lt;/disk&gt;
1693               &lt;disk type='file' device='disk'&gt;
1694                 &lt;source file='/path/to/img4.qcow2'/&gt;
1695                 &lt;target dev='hdb' bus='ide'/&gt;
1696               &lt;/disk&gt;
1697               &lt;disk type='file' device='cdrom'&gt;
1698                 &lt;target dev='hdc' bus='ide'/&gt;
1699               &lt;/disk&gt;
1700             &lt;/devices&gt;
1701         """
1702         ).findall("disk")
1703         new_disks = ET.fromstring(
1704             """
1705             &lt;devices&gt;
1706               &lt;disk type='file' device='disk'&gt;
1707                 &lt;source file='/path/to/img3.qcow2'/&gt;
1708                 &lt;target dev='vda' bus='virtio'/&gt;
1709               &lt;/disk&gt;
1710               &lt;disk type='file' device='disk' cache='default'&gt;
1711                 &lt;source file='/path/to/img0.qcow2'/&gt;
1712                 &lt;target dev='vda' bus='virtio'/&gt;
1713               &lt;/disk&gt;
1714               &lt;disk type='file' device='disk'&gt;
1715                 &lt;source file='/path/to/img4.qcow2'/&gt;
1716                 &lt;target dev='vda' bus='virtio'/&gt;
1717               &lt;/disk&gt;
1718               &lt;disk type='file' device='cdrom'&gt;
1719                 &lt;target dev='hda' bus='ide'/&gt;
1720               &lt;/disk&gt;
1721             &lt;/devices&gt;
1722         """
1723         ).findall("disk")
1724         ret = virt._diff_disk_lists(old_disks, new_disks)
1725         self.assertEqual(
1726             [
1727                 disk.find("source").get("file")
1728                 if disk.find("source") is not None
1729                 else None
1730                 for disk in ret["unchanged"]
1731             ],
1732             [],
1733         )
1734         self.assertEqual(
1735             [
1736                 disk.find("source").get("file")
1737                 if disk.find("source") is not None
1738                 else None
1739                 for disk in ret["new"]
1740             ],
1741             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1742         )
1743         self.assertEqual(
1744             [disk.find("target").get("dev") for disk in ret["sorted"]],
1745             ["vda", "vdb", "vdc", "hda"],
1746         )
1747         self.assertEqual(
1748             [
1749                 disk.find("source").get("file")
1750                 if disk.find("source") is not None
1751                 else None
1752                 for disk in ret["sorted"]
1753             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1754         )
1755         self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(ret["new"][1].find("target").get("bus"), "virtio")
1756         self.assertEqual(
1757             [
1758                 disk.find("source").get("file")
1759                 if disk.find(</b></font>"source") is not None
1760                 else None
1761                 for disk in ret["deleted"]
1762             ],
1763             [
1764                 "/path/to/img0.qcow2",
1765                 "/path/to/img1.qcow2",
1766                 "/path/to/img2.qcow2",
1767                 "/path/to/img4.qcow2",
1768                 None,
1769             ],
1770         )
1771     def test_init(self):
1772         """
1773         Test init() function
1774         """
1775         xml = """
1776 &lt;capabilities&gt;
1777   &lt;host&gt;
1778     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
1779     &lt;cpu&gt;
1780       &lt;arch&gt;x86_64&lt;/arch&gt;
1781       &lt;model&gt;Nehalem&lt;/model&gt;
1782       &lt;vendor&gt;Intel&lt;/vendor&gt;
1783       &lt;microcode version='25'/&gt;
1784       &lt;topology sockets='1' cores='4' threads='2'/&gt;
1785       &lt;feature name='vme'/&gt;
1786       &lt;feature name='ds'/&gt;
1787       &lt;feature name='acpi'/&gt;
1788       &lt;pages unit='KiB' size='4'/&gt;
1789       &lt;pages unit='KiB' size='2048'/&gt;
1790     &lt;/cpu&gt;
1791     &lt;power_management&gt;
1792       &lt;suspend_mem/&gt;
1793       &lt;suspend_disk/&gt;
1794       &lt;suspend_hybrid/&gt;
1795     &lt;/power_management&gt;
1796     &lt;migration_features&gt;
1797       &lt;live/&gt;
1798       &lt;uri_transports&gt;
1799         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
1800         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
1801       &lt;/uri_transports&gt;
1802     &lt;/migration_features&gt;
1803     &lt;topology&gt;
1804       &lt;cells num='1'&gt;
1805         &lt;cell id='0'&gt;
1806           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
1807           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
1808           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
1809           &lt;distances&gt;
1810             &lt;sibling id='0' value='10'/&gt;
1811           &lt;/distances&gt;
1812           &lt;cpus num='8'&gt;
1813             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
1814             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
1815             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
1816             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
1817             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
1818             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
1819             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
1820             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
1821           &lt;/cpus&gt;
1822         &lt;/cell&gt;
1823       &lt;/cells&gt;
1824     &lt;/topology&gt;
1825     &lt;cache&gt;
1826       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
1827     &lt;/cache&gt;
1828     &lt;secmodel&gt;
1829       &lt;model&gt;apparmor&lt;/model&gt;
1830       &lt;doi&gt;0&lt;/doi&gt;
1831     &lt;/secmodel&gt;
1832     &lt;secmodel&gt;
1833       &lt;model&gt;dac&lt;/model&gt;
1834       &lt;doi&gt;0&lt;/doi&gt;
1835       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
1836       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
1837     &lt;/secmodel&gt;
1838   &lt;/host&gt;
1839   &lt;guest&gt;
1840     &lt;os_type&gt;hvm&lt;/os_type&gt;
1841     &lt;arch name='i686'&gt;
1842       &lt;wordsize&gt;32&lt;/wordsize&gt;
1843       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
1844       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1845       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1846       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1847       &lt;domain type='qemu'/&gt;
1848       &lt;domain type='kvm'&gt;
1849         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1850         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1851         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1852         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1853       &lt;/domain&gt;
1854     &lt;/arch&gt;
1855     &lt;features&gt;
1856       &lt;cpuselection/&gt;
1857       &lt;deviceboot/&gt;
1858       &lt;disksnapshot default='on' toggle='no'/&gt;
1859       &lt;acpi default='on' toggle='yes'/&gt;
1860       &lt;apic default='on' toggle='no'/&gt;
1861       &lt;pae/&gt;
1862       &lt;nonpae/&gt;
1863     &lt;/features&gt;
1864   &lt;/guest&gt;
1865   &lt;guest&gt;
1866     &lt;os_type&gt;hvm&lt;/os_type&gt;
1867     &lt;arch name='x86_64'&gt;
1868       &lt;wordsize&gt;64&lt;/wordsize&gt;
1869       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
1870       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1871       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1872       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1873       &lt;domain type='qemu'/&gt;
1874       &lt;domain type='kvm'&gt;
1875         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1876         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1877         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1878         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1879       &lt;/domain&gt;
1880     &lt;/arch&gt;
1881     &lt;features&gt;
1882       &lt;cpuselection/&gt;
1883       &lt;deviceboot/&gt;
1884       &lt;disksnapshot default='on' toggle='no'/&gt;
1885       &lt;acpi default='on' toggle='yes'/&gt;
1886       &lt;apic default='on' toggle='no'/&gt;
1887     &lt;/features&gt;
1888   &lt;/guest&gt;
1889 &lt;/capabilities&gt;
1890         """
1891         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
1892         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
1893         defineMock = MagicMock(return_value=1)
1894         self.mock_conn.defineXML = defineMock
1895         mock_chmod = MagicMock()
1896         mock_run = MagicMock()
1897         with patch.dict(
1898             os.__dict__, {"chmod": mock_chmod, "makedirs": MagicMock()}
1899         ):  # pylint: disable=no-member
1900             with patch.dict(
1901                 virt.__salt__, {"cmd.run": mock_run}
1902             ):  # pylint: disable=no-member
1903                 virt.init(
1904                     "test vm", 2, 1234, nic=None, disk=None, seed=False, start=False
1905                 )
1906                 definition = defineMock.call_args_list[0][0][0]
1907                 self.assertFalse("&lt;interface" in definition)
1908                 self.assertFalse("&lt;disk" in definition)
1909                 defineMock.reset_mock()
1910                 mock_run.reset_mock()
1911                 boot = {
1912                     "kernel": "/root/f8-i386-vmlinuz",
1913                     "initrd": "/root/f8-i386-initrd",
1914                     "cmdline": "console=ttyS0 ks=http://example.com/f8-i386/os/",
1915                 }
1916                 retval = virt.init(
1917                     "test vm boot params",
1918                     2,
1919                     1234,
1920                     nic=None,
1921                     disk=None,
1922                     seed=False,
1923                     start=False,
1924                     boot=boot,
1925                 )
1926                 definition = defineMock.call_args_list[0][0][0]
1927                 self.assertEqual("&lt;kernel" in definition, True)
1928                 self.assertEqual("&lt;initrd" in definition, True)
1929                 self.assertEqual("&lt;cmdline" in definition, True)
1930                 self.assertEqual(retval, True)
1931                 mock_response = MagicMock()
1932                 mock_response.read <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value="filecontent")
1933                 cache_dir = tempfile.mkdtemp()
1934                 with patch.dict(virt.__dict__, {"CACHE_DIR": cache_dir}):
1935                     with</b></font> patch(
1936                         "urllib.request.urlopen",
1937                         MagicMock(return_value=mock_response),
1938                     ):
1939                         with patch(
1940                             "salt.utils.files.fopen", return_value=mock_response
1941                         ):
1942                             defineMock.reset_mock()
1943                             mock_run.reset_mock()
1944                             boot = {
1945                                 "kernel": "https://www.example.com/download/vmlinuz",
1946                                 "initrd": "",
1947                                 "cmdline": (
1948                                     "console=ttyS0 ks=http://example.com/f8-i386/os/"
1949                                 ),
1950                             }
1951                             retval = virt.init(
1952                                 "test remote vm boot params",
1953                                 2,
1954                                 1234,
1955                                 nic=None,
1956                                 disk=None,
1957                                 seed=False,
1958                                 start=False,
1959                                 boot=boot,
1960                             )
1961                             definition = defineMock.call_args_list[0][0][0]
1962                             self.assertEqual(cache_dir in definition, True)
1963                     shutil.rmtree(cache_dir)
1964                 defineMock.reset_mock()
1965                 mock_run.reset_mock()
1966                 pool_mock = MagicMock()
1967                 pool_mock.XMLDesc.return_value = '&lt;pool type="dir"/&gt;'
1968                 self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1969                 virt.init(
1970                     "test vm",
1971                     2,
1972                     1234,
1973                     nic=None,
1974                     disk=None,
1975                     disks=[
1976                         {"name": "system", "size": 10240},
1977                         {
1978                             "name": "cddrive",
1979                             "device": "cdrom",
1980                             "source_file": None,
1981                             "model": "ide",
1982                         },
1983                     ],
1984                     seed=False,
1985                     start=False,
1986                 )
1987                 definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1988                 expected_disk_path = os.path.join(root_dir, "test vm_system.qcow2")
1989                 self.assertEqual(
1990                     expected_disk_path,
1991                     definition.find("./devices/disk[1]/source").get("file"),
1992                 )
1993                 self.assertIsNone(definition.find("./devices/disk[2]/source"))
1994                 self.assertEqual(
1995                     mock_run.call_args[0][0],
1996                     'qemu-img create -f qcow2 "{}" 10240M'.format(expected_disk_path),
1997                 )
1998                 self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)
1999                 defineMock.reset_mock()
2000                 mock_run.reset_mock()
2001                 vol_mock = MagicMock()
2002                 pool_mock.storageVolLookupByName.return_value = vol_mock
2003                 pool_mock.listVolumes.return_value = ["test vm_data"]
2004                 stream_mock = MagicMock()
2005                 self.mock_conn.newStream.return_value = stream_mock
2006                 self.mock_conn.listStoragePools.return_value = ["default", "test"]
2007                 with patch.dict(
2008                     os.__dict__, {"open": MagicMock(), "close": MagicMock()}
2009                 ):
2010                     cache_mock = MagicMock()
2011                     with patch.dict(virt.__salt__, {"cp.cache_file": cache_mock}):
2012                         virt.init(
2013                             "test vm",
2014                             2,
2015                             1234,
2016                             nic=None,
2017                             disk=None,
2018                             disks=[
2019                                 {
2020                                     "name": "system",
2021                                     "size": 10240,
2022                                     "image": "/path/to/image",
2023                                     "pool": "test",
2024                                 },
2025                                 {"name": "data", "size": 10240, "pool": "default"},
2026                                 {
2027                                     "name": "test",
2028                                     "size": 1024,
2029                                     "pool": "default",
2030                                     "format": "qcow2",
2031                                     "backing_store_path": "/backing/path",
2032                                     "backing_store_format": "raw",
2033                                 },
2034                             ],
2035                             seed=False,
2036                             start=False,
2037                         )
2038                         definition = ET.fromstring(defineMock.call_args_list[0][0][0])
2039                         self.assertTrue(
2040                             all(
2041                                 [
2042                                     disk.get("type") == "volume"
2043                                     for disk in definition.findall("./devices/disk")
2044                                 ]
2045                             )
2046                         )
2047                         self.assertEqual(
2048                             ["test", "default", "default"],
2049                             [
2050                                 src.get("pool")
2051                                 for src in definition.findall("./devices/disk/source")
2052                             ],
2053                         )
2054                         self.assertEqual(
2055                             ["test vm_system", "test vm_data", "test vm_test"],
2056                             [
2057                                 src.get("volume")
2058                                 for src in definition.findall("./devices/disk/source")
2059                             ],
2060                         )
2061                         create_calls = pool_mock.createXML.call_args_list
2062                         vol_names = [
2063                             ET.fromstring(call[0][0]).find("name").text
2064                             for call in create_calls
2065                         ]
2066                         self.assertEqual(
2067                             ["test vm_system", "test vm_test"],
2068                             vol_names,
2069                         )
2070                         stream_mock.sendAll.assert_called_once()
2071                         stream_mock.finish.assert_called_once()
2072                         vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
2073     def test_update_backing_store(self):
2074         """
2075         Test updating a disk with a backing store
2076         """
2077         xml = """
2078             &lt;domain type='kvm' id='7'&gt;
2079               &lt;name&gt;my_vm&lt;/name&gt;
2080               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2081               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2082               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2083               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
2084               &lt;os&gt;
2085                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2086               &lt;/os&gt;
2087               &lt;devices&gt;
2088                 &lt;disk type='volume' device='disk'&gt;
2089                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
2090                   &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
2091                   &lt;backingStore type='file' index='2'&gt;
2092                     &lt;format type='qcow2'/&gt;
2093                     &lt;source file='/path/to/base.qcow2'/&gt;
2094                     &lt;backingStore/&gt;
2095                   &lt;/backingStore&gt;
2096                   &lt;target dev='vda' bus='virtio'/&gt;
2097                   &lt;alias name='virtio-disk0'/&gt;
2098                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
2099                 &lt;/disk&gt;
2100               &lt;/devices&gt;
2101             &lt;/domain&gt;
2102         """
2103         domain_mock = self.set_mock_vm("my_vm", xml)
2104         domain_mock.OSType.return_value = "hvm"
2105         self.mock_conn.defineXML.return_value = True
2106         updatedev_mock = MagicMock(return_value=0)
2107         domain_mock.updateDeviceFlags = updatedev_mock
2108         self.mock_conn.listStoragePools.return_value = ["default"]
2109         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
2110             "&lt;pool type='dir'/&gt;"
2111         )
2112         ret = virt.update(
2113             "my_vm",
2114             disks=[
2115                 {
2116                     "name": "system",
2117                     "pool": "default",
2118                     "backing_store_path": "/path/to/base.qcow2",
2119                     "backing_store_format": "qcow2",
2120                 },
2121             ],
2122         )
2123         self.assertFalse(ret["definition"])
2124         self.assertFalse(ret["disk"]["attached"])
2125         self.assertFalse(ret["disk"]["detached"])
2126     def test_update_removables(self):
2127         """
2128         Test attaching, detaching, changing removable devices
2129         """
2130         xml = """
2131             &lt;domain type='kvm' id='7'&gt;
2132               &lt;name&gt;my_vm&lt;/name&gt;
2133               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2134               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2135               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2136               &lt;os&gt;
2137                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2138               &lt;/os&gt;
2139               &lt;devices&gt;
2140                 &lt;disk type='network' device='cdrom'&gt;
2141                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
2142                   &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
2143                     &lt;host name='test-srv.local' port='80'/&gt;
2144                   &lt;/source&gt;
2145                   &lt;backingStore/&gt;
2146                   &lt;target dev='hda' bus='ide'/&gt;
2147                   &lt;readonly/&gt;
2148                   &lt;alias name='ide0-0-0'/&gt;
2149                   &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
2150                 &lt;/disk&gt;
2151                 &lt;disk type='file' device='cdrom'&gt;
2152                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
2153                   &lt;target dev='hdb' bus='ide'/&gt;
2154                   &lt;readonly/&gt;
2155                   &lt;alias name='ide0-0-1'/&gt;
2156                   &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
2157                 &lt;/disk&gt;
2158                 &lt;disk type='file' device='cdrom'&gt;
2159                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
2160                   &lt;source file='/srv/dvd-image-2.iso'/&gt;
2161                   &lt;backingStore/&gt;
2162                   &lt;target dev='hdc' bus='ide'/&gt;
2163                   &lt;readonly/&gt;
2164                   &lt;alias name='ide0-0-2'/&gt;
2165                   &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
2166                 &lt;/disk&gt;
2167                 &lt;disk type='file' device='cdrom'&gt;
2168                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
2169                   &lt;source file='/srv/dvd-image-3.iso'/&gt;
2170                   &lt;backingStore/&gt;
2171                   &lt;target dev='hdd' bus='ide'/&gt;
2172                   &lt;readonly/&gt;
2173                   &lt;alias name='ide0-0-3'/&gt;
2174                   &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
2175                 &lt;/disk&gt;
2176                 &lt;disk type='network' device='cdrom'&gt;
2177                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
2178                   &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
2179                     &lt;host name='test-srv.local' port='80'/&gt;
2180                   &lt;/source&gt;
2181                   &lt;backingStore/&gt;
2182                   &lt;target dev='hde' bus='ide'/&gt;
2183                   &lt;readonly/&gt;
2184                 &lt;/disk&gt;
2185               &lt;/devices&gt;
2186             &lt;/domain&gt;
2187         """
2188         domain_mock = self.set_mock_vm("my_vm", xml)
2189         domain_mock.OSType.return_value = "hvm"
2190         self.mock_conn.defineXML.return_value = True
2191         updatedev_mock = MagicMock(return_value=0)
2192         domain_mock.updateDeviceFlags = updatedev_mock
2193         ret = virt.update(
2194             "my_vm",
2195             disks=[
2196                 {
2197                     "name": "dvd1",
2198                     "device": "cdrom",
2199                     "source_file": None,
2200                     "model": "ide",
2201                 },
2202                 {
2203                     "name": "dvd2",
2204                     "device": "cdrom",
2205                     "source_file": "/srv/dvd-image-4.iso",
2206                     "model": "ide",
2207                 },
2208                 {
2209                     "name": "dvd3",
2210                     "device": "cdrom",
2211                     "source_file": "/srv/dvd-image-2.iso",
2212                     "model": "ide",
2213                 },
2214                 {
2215                     "name": "dvd4",
2216                     "device": "cdrom",
2217                     "source_file": "/srv/dvd-image-5.iso",
2218                     "model": "ide",
2219                 },
2220                 {
2221                     "name": "dvd5",
2222                     "device": "cdrom",
2223                     "source_file": "/srv/dvd-image-6.iso",
2224                     "model": "ide",
2225                 },
2226             ],
2227         )
2228         self.assertTrue(ret["definition"])
2229         self.assertFalse(ret["disk"].get("attached"))
2230         self.assertFalse(ret["disk"].get("detached"))
2231         self.assertEqual(
2232             [
2233                 {
2234                     "type": "file",
2235                     "device": "cdrom",
2236                     "driver": {
2237                         "name": "qemu",
2238                         "type": "raw",
2239                         "cache": "none",
2240                         "io": "native",
2241                     },
2242                     "backingStore": None,
2243                     "target": {"dev": "hda", "bus": "ide"},
2244                     "readonly": None,
2245                     "alias": {"name": "ide0-0-0"},
2246                     "address": {
2247                         "type": "drive",
2248                         "controller": "0",
2249                         "bus": "0",
2250                         "target": "0",
2251                         "unit": "0",
2252                     },
2253                 },
2254                 {
2255                     "type": "file",
2256                     "device": "cdrom",
2257                     "driver": {
2258                         "name": "qemu",
2259                         "type": "raw",
2260                         "cache": "none",
2261                         "io": "native",
2262                     },
2263                     "target": {"dev": "hdb", "bus": "ide"},
2264                     "readonly": None,
2265                     "alias": {"name": "ide0-0-1"},
2266                     "address": {
2267                         "type": "drive",
2268                         "controller": "0",
2269                         "bus": "0",
2270                         "target": "0",
2271                         "unit": "1",
2272                     },
2273                     "source": {"file": "/srv/dvd-image-4.iso"},
2274                 },
2275                 {
2276                     "type": "file",
2277                     "device": "cdrom",
2278                     "driver": {
2279                         "name": "qemu",
2280                         "type": "raw",
2281                         "cache": "none",
2282                         "io": "native",
2283                     },
2284                     "backingStore": None,
2285                     "target": {"dev": "hdd", "bus": "ide"},
2286                     "readonly": None,
2287                     "alias": {"name": "ide0-0-3"},
2288                     "address": {
2289                         "type": "drive",
2290                         "controller": "0",
2291                         "bus": "0",
2292                         "target": "0",
2293                         "unit": "3",
2294                     },
2295                     "source": {"file": "/srv/dvd-image-5.iso"},
2296                 },
2297                 {
2298                     "type": "file",
2299                     "device": "cdrom",
2300                     "driver": {
2301                         "name": "qemu",
2302                         "type": "raw",
2303                         "cache": "none",
2304                         "io": "native",
2305                     },
2306                     "backingStore": None,
2307                     "target": {"dev": "hde", "bus": "ide"},
2308                     "readonly": None,
2309                     "source": {"file": "/srv/dvd-image-6.iso"},
2310                 },
2311             ],
2312             [
2313                 salt.utils.xmlutil.to_dict(ET.fromstring(disk), True)
2314                 for disk in ret["disk"]["updated"]
2315             ],
2316         )
2317     def test_update_xen_boot_params(self):
2318         """
2319         Test virt.update() a Xen definition no boot parameter.
2320         """
2321         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
2322         xml_boot = """
2323             &lt;domain type='xen' id='8'&gt;
2324               &lt;name&gt;vm&lt;/name&gt;
2325               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2326               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2327               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2328               &lt;os&gt;
2329                 &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
2330                 &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
2331               &lt;/os&gt;
2332             &lt;/domain&gt;
2333         """
2334         domain_mock_boot = self.set_mock_vm("vm", xml_boot)
2335         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2336         define_mock_boot = MagicMock(return_value=True)
2337         define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
2338         self.mock_conn.defineXML = define_mock_boot
2339         self.assertEqual(
2340             {
2341                 "cpu": False,
2342                 "definition": True,
2343                 "disk": {"attached": [], "detached": [], "updated": []},
2344                 "interface": {"attached": [], "detached": []},
2345             },
2346             virt.update("vm", cpu=2),
2347         )
2348         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2349         self.assertEqual(setxml.find("os").find("loader").attrib.get("type"), "rom")
2350         self.assertEqual(
2351             setxml.find("os").find("loader").text, "/usr/lib/xen/boot/hvmloader"
2352         )
2353     def test_update_existing_boot_params(self):
2354         """
2355         Test virt.update() with existing boot parameters.
2356         """
2357         xml_boot = """
2358             &lt;domain type='kvm' id='8'&gt;
2359               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2360               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2361               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2362               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2363               &lt;os&gt;
2364                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2365                 &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
2366                 &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
2367                 &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
2368                 &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
2369                 &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
2370               &lt;/os&gt;
2371             &lt;/domain&gt;
2372         """
2373         domain_mock_boot = self.set_mock_vm("vm_with_boot_param", xml_boot)
2374         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2375         define_mock_boot = MagicMock(return_value=True)
2376         self.mock_conn.defineXML = define_mock_boot
2377         boot_new = {
2378             "kernel": "/root/new-vmlinuz",
2379             "initrd": "/root/new-initrd",
2380             "cmdline": "console=ttyS0 ks=http://example.com/new/os/",
2381         }
2382         uefi_boot_new = {
2383             "loader": "/usr/share/new/OVMF_CODE.fd",
2384             "nvram": "/usr/share/new/OVMF_VARS.ms.fd",
2385         }
2386         self.assertEqual(
2387             {
2388                 "definition": True,
2389                 "disk": {"attached": [], "detached": [], "updated": []},
2390                 "interface": {"attached": [], "detached": []},
2391             },
2392             virt.update("vm_with_boot_param", boot=boot_new),
2393         )
2394         setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
2395         self.assertEqual(
2396             setxml_boot.find("os").find("kernel").text, "/root/new-vmlinuz"
2397         )
2398         self.assertEqual(setxml_boot.find("os").find("initrd").text, "/root/new-initrd")
2399         self.assertEqual(
2400             setxml_boot.find("os").find("cmdline").text,
2401             "console=ttyS0 ks=http://example.com/new/os/",
2402         )
2403         self.assertEqual(
2404             {
2405                 "definition": True,
2406                 "disk": {"attached": [], "detached": [], "updated": []},
2407                 "interface": {"attached": [], "detached": []},
2408             },
2409             virt.update("vm_with_boot_param", boot=uefi_boot_new),
2410         )
2411         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2412         self.assertEqual(
2413             setxml.find("os").find("loader").text, "/usr/share/new/OVMF_CODE.fd"
2414         )
2415         self.assertEqual(setxml.find("os").find("loader").attrib.get("readonly"), "yes")
2416         self.assertEqual(setxml.find("os").find("loader").attrib["type"], "pflash")
2417         self.assertEqual(
2418             setxml.find("os").find("nvram").attrib["template"],
2419             "/usr/share/new/OVMF_VARS.ms.fd",
2420         )
2421         kernel_none = {
2422             "kernel": None,
2423             "initrd": None,
2424             "cmdline": None,
2425         }
2426         uefi_none = {"loader": None, "nvram": None}
2427         self.assertEqual(
2428             {
2429                 "definition": True,
2430                 "disk": {"attached": [], "detached": [], "updated": []},
2431                 "interface": {"attached": [], "detached": []},
2432             },
2433             virt.update("vm_with_boot_param", boot=kernel_none),
2434         )
2435         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2436         self.assertEqual(setxml.find("os").find("kernel"), None)
2437         self.assertEqual(setxml.find("os").find("initrd"), None)
2438         self.assertEqual(setxml.find("os").find("cmdline"), None)
2439         self.assertEqual(
2440             {
2441                 "definition": True,
2442                 "disk": {"attached": [], "detached": [], "updated": []},
2443                 "interface": {"attached": [], "detached": []},
2444             },
2445             virt.update("vm_with_boot_param", boot={"efi": False}),
2446         )
2447         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2448         self.assertEqual(setxml.find("os").find("nvram"), None)
2449         self.assertEqual(setxml.find("os").find("loader"), None)
2450         self.assertEqual(
2451             {
2452                 "definition": True,
2453                 "disk": {"attached": [], "detached": [], "updated": []},
2454                 "interface": {"attached": [], "detached": []},
2455             },
2456             virt.update("vm_with_boot_param", boot=uefi_none),
2457         )
2458         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2459         self.assertEqual(setxml.find("os").find("loader"), None)
2460         self.assertEqual(setxml.find("os").find("nvram"), None)
2461     def test_update_existing_numatune_params(self):
2462         """
2463         Test virt.update() with existing numatune parameters.
2464         """
2465         xml_numatune = """
2466             &lt;domain type='kvm' id='8'&gt;
2467               &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
2468               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2469               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2470               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
2471               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2472               &lt;numatune&gt;
2473                 &lt;memory mode="strict" nodeset="0-11"/&gt;
2474                 &lt;memnode cellid="1" mode="strict" nodeset="3"/&gt;
2475                 &lt;memnode cellid="3" mode="preferred" nodeset="7"/&gt;
2476               &lt;/numatune&gt;
2477               &lt;os&gt;
2478                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2479               &lt;/os&gt;
2480               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
2481             &lt;/domain&gt;
2482         """
2483         domain_mock = self.set_mock_vm("vm_with_numatune_param", xml_numatune)
2484         domain_mock.OSType = MagicMock(return_value="hvm")
2485         define_mock = MagicMock(return_value=True)
2486         self.mock_conn.defineXML = define_mock
2487         numatune = {
2488             "memory": {"mode": "preferred", "nodeset": "0-5"},
2489             "memnodes": {
2490                 0: {"mode": "strict", "nodeset": "4"},
2491                 3: {"mode": "preferred", "nodeset": "7"},
2492                 4: {"mode": "strict", "nodeset": "6"},
2493             },
2494         }
2495         self.assertEqual(
2496             {
2497                 "definition": True,
2498                 "disk": {"attached": [], "detached": [], "updated": []},
2499                 "interface": {"attached": [], "detached": []},
2500             },
2501             virt.update("vm_with_numatune_param", numatune=numatune),
2502         )
2503         setxml = ET.fromstring(define_mock.call_args[0][0])
2504         self.assertEqual(
2505             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2506         )
2507         self.assertEqual(
2508             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2509             ",".join([str(i) for i in range(0, 6)]),
2510         )
2511         self.assertEqual(
2512             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2513         )
2514         self.assertEqual(
2515             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2516         )
2517         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='1']"), None)
2518         self.assertEqual(
2519             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2520             "preferred",
2521         )
2522         self.assertEqual(
2523             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2524         )
2525         self.assertEqual(
2526             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("mode"), "strict"
2527         )
2528         self.assertEqual(
2529             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("nodeset"), "6"
2530         )
2531         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2532         numatune_mem_none = {
2533             "memory": None,
2534             "memnodes": {
2535                 0: {"mode": "strict", "nodeset": "4"},
2536                 3: {"mode": "preferred", "nodeset": "7"},
2537                 4: {"mode": "strict", "nodeset": "6"},
2538             },
2539         }
2540         self.assertEqual(
2541             {
2542                 "definition": True,
2543                 "disk": {"attached": [], "detached": [], "updated": []},
2544                 "interface": {"attached": [], "detached": []},
2545             },
2546             virt.update("vm_with_numatune_param", numatune=numatune_mem_none),
2547         )
2548         setxml = ET.fromstring(define_mock.call_args[0][0])
2549         self.assertEqual(setxml.find("numatune").find("memory"), None)
2550         self.assertEqual(
2551             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2552         )
2553         self.assertEqual(
2554             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2555         )
2556         self.assertEqual(
2557             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2558             "preferred",
2559         )
2560         self.assertEqual(
2561             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2562         )
2563         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2564         numatune_mnodes_none = {
2565             "memory": {"mode": "preferred", "nodeset": "0-5"},
2566             "memnodes": None,
2567         }
2568         self.assertEqual(
2569             {
2570                 "definition": True,
2571                 "disk": {"attached": [], "detached": [], "updated": []},
2572                 "interface": {"attached": [], "detached": []},
2573             },
2574             virt.update("vm_with_numatune_param", numatune=numatune_mnodes_none),
2575         )
2576         setxml = ET.fromstring(define_mock.call_args[0][0])
2577         self.assertEqual(
2578             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2579         )
2580         self.assertEqual(
2581             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2582             ",".join([str(i) for i in range(0, 6)]),
2583         )
2584         self.assertEqual(setxml.find("./numatune/memnode"), None)
2585         numatune_without_change = {
2586             "memory": {"mode": "strict", "nodeset": "0-5,6,7-11"},
2587             "memnodes": {
2588                 1: {"mode": "strict", "nodeset": "3"},
2589                 3: {"mode": "preferred", "nodeset": "7"},
2590             },
2591         }
2592         self.assertEqual(
2593             {
2594                 "definition": False,
2595                 "disk": {"attached": [], "detached": [], "updated": []},
2596                 "interface": {"attached": [], "detached": []},
2597             },
2598             virt.update("vm_with_numatune_param", numatune=numatune_without_change),
2599         )
2600         self.assertEqual(
2601             {
2602                 "definition": True,
2603                 "disk": {"attached": [], "detached": [], "updated": []},
2604                 "interface": {"attached": [], "detached": []},
2605             },
2606             virt.update(
2607                 "vm_with_numatune_param", numatune={"memory": None, "memnodes": None}
2608             ),
2609         )
2610         setxml = ET.fromstring(define_mock.call_args[0][0])
2611         self.assertEqual(setxml.find("numatune"), None)
2612     def test_update_existing_cpu_params(self):
2613         """
2614         Test virt.update() with existing cpu-related parameters.
2615         """
2616         xml_with_existing_params = """
2617             &lt;domain type='kvm' id='8'&gt;
2618               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2619               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2620               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2621               &lt;vcpu placement="static" cpuset="0-11" current="3"&gt;6&lt;/vcpu&gt;
2622               &lt;vcpus&gt;
2623                 &lt;vcpu id="0" enabled="yes" hotpluggable="no" order="1"/&gt;
2624                 &lt;vcpu id="1" enabled="no" hotpluggable="yes"/&gt;
2625                 &lt;vcpu id="2" enabled="no" hotpluggable="yes"/&gt;
2626                 &lt;vcpu id="3" enabled="no" hotpluggable="yes"/&gt;
2627                 &lt;vcpu id="4" enabled="no" hotpluggable="yes"/&gt;
2628                 &lt;vcpu id="5" enabled="no" hotpluggable="yes"/&gt;
2629                 &lt;vcpu id="6" enabled="no" hotpluggable="yes"/&gt;
2630                 &lt;vcpu id="7" enabled="no" hotpluggable="yes"/&gt;
2631                 &lt;vcpu id="8" enabled="no" hotpluggable="yes"/&gt;
2632                 &lt;vcpu id="9" enabled="no" hotpluggable="yes"/&gt;
2633                 &lt;vcpu id="10" enabled="no" hotpluggable="yes"/&gt;
2634                 &lt;vcpu id="11" enabled="no" hotpluggable="yes"/&gt;
2635               &lt;/vcpus&gt;
2636               &lt;cpu mode="custom" match="exact" check="full"&gt;
2637                  &lt;model fallback="allow" vendor_id="Genuine20201"&gt;core2duo&lt;/model&gt;
2638                  &lt;vendor&gt;Intel&lt;/vendor&gt;
2639                  &lt;topology sockets="2" cores="5" threads="2"/&gt;
2640                  &lt;cache level="3" mode="emulate"/&gt;
2641                  &lt;feature policy="optional" name="lahf_lm"/&gt;
2642                  &lt;feature policy="require" name="pcid"/&gt;
2643                  &lt;numa&gt;
2644                     &lt;cell id="0" cpus="0-3" memory="1073741824" unit="KiB" discard="no"&gt;
2645                         &lt;distances&gt;
2646                             &lt;sibling id="0" value="10"/&gt;
2647                             &lt;sibling id="1" value="21"/&gt;
2648                             &lt;sibling id="2" value="31"/&gt;
2649                             &lt;sibling id="3" value="41"/&gt;
2650                         &lt;/distances&gt;
2651                     &lt;/cell&gt;
2652                     &lt;cell id="1" cpus="4-6" memory="1073741824" unit="KiB" memAccess="private"&gt;
2653                         &lt;distances&gt;
2654                             &lt;sibling id="0" value="21"/&gt;
2655                             &lt;sibling id="1" value="10"/&gt;
2656                             &lt;sibling id="2" value="21"/&gt;
2657                             &lt;sibling id="3" value="31"/&gt;
2658                         &lt;/distances&gt;
2659                     &lt;/cell&gt;
2660                  &lt;/numa&gt;
2661               &lt;/cpu&gt;
2662               &lt;os&gt;
2663                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2664               &lt;/os&gt;
2665               &lt;/domain&gt;
2666          """
2667         domain_mock = self.set_mock_vm(
2668             "vm_with_existing_param", xml_with_existing_params
2669         )
2670         domain_mock.OSType = MagicMock(return_value="hvm")
2671         define_mock = MagicMock(return_value=True)
2672         self.mock_conn.defineXML = define_mock
2673         setvcpus_mock = MagicMock(return_value=0)
2674         domain_mock.setVcpusFlags = setvcpus_mock
2675         cpu_attr = {"placement": "static", "cpuset": "0-5", "current": 3, "maximum": 5}
2676         self.assertEqual(
2677             {
2678                 "definition": True,
2679                 "cpu": True,
2680                 "disk": {"attached": [], "detached": [], "updated": []},
2681                 "interface": {"attached": [], "detached": []},
2682             },
2683             virt.update("vm_with_existing_param", cpu=cpu_attr),
2684         )
2685         setxml = ET.fromstring(define_mock.call_args[0][0])
2686         self.assertEqual(setxml.find("vcpu").text, "5")
2687         self.assertEqual(setxml.find("vcpu").attrib["placement"], "static")
2688         self.assertEqual(
2689             setxml.find("vcpu").attrib["cpuset"],
2690             ",".join([str(i) for i in range(0, 6)]),
2691         )
2692         self.assertEqual(setxml.find("vcpu").attrib["current"], "3")
2693         cpu_none = {"placement": "auto", "cpuset": None, "current": 2, "maximum": 5}
2694         self.assertEqual(
2695             {
2696                 "definition": True,
2697                 "cpu": True,
2698                 "disk": {"attached": [], "detached": [], "updated": []},
2699                 "interface": {"attached": [], "detached": []},
2700             },
2701             virt.update("vm_with_existing_param", cpu=cpu_none),
2702         )
2703         setxml = ET.fromstring(define_mock.call_args[0][0])
2704         self.assertEqual(setxml.find("vcpu").text, "5")
2705         self.assertEqual(setxml.find("vcpu").attrib["placement"], "auto")
2706         self.assertEqual(setxml.find("vcpu").attrib.get("cpuset"), None)
2707         self.assertEqual(setxml.find("vcpu").attrib.get("current"), "2")
2708         vcpus = {
2709             "vcpus": {
2710                 "0": {"enabled": False, "hotpluggable": True, "order": 5},
2711                 "3": {"enabled": True, "hotpluggable": False, "order": 3},
2712                 "7": {"enabled": True, "hotpluggable": False},
2713             }
2714         }
2715         self.assertEqual(
2716             {
2717                 "definition": True,
2718                 "disk": {"attached": [], "detached": [], "updated": []},
2719                 "interface": {"attached": [], "detached": []},
2720             },
2721             virt.update("vm_with_existing_param", cpu=vcpus),
2722         )
2723         setxml = ET.fromstring(define_mock.call_args[0][0])
2724         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["id"], "0")
2725         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["enabled"], "no")
2726         self.assertEqual(
2727             setxml.find("./vcpus/vcpu/[@id='0']").attrib["hotpluggable"], "yes"
2728         )
2729         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["order"], "5")
2730         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["id"], "3")
2731         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2732         self.assertEqual(
2733             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2734         )
2735         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["order"], "3")
2736         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["id"], "7")
2737         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["enabled"], "yes")
2738         self.assertEqual(
2739             setxml.find("./vcpus/vcpu/[@id='7']").attrib["hotpluggable"], "no"
2740         )
2741         self.assertEqual(
2742             setxml.find("./vcpus/vcpu/[@id='7']").attrib.get("order"), None
2743         )
2744         ind_vcpu = {
2745             "vcpus": {"3": {"enabled": True, "hotpluggable": False, "order": None}}
2746         }
2747         self.assertEqual(
2748             {
2749                 "definition": True,
2750                 "disk": {"attached": [], "detached": [], "updated": []},
2751                 "interface": {"attached": [], "detached": []},
2752             },
2753             virt.update("vm_with_existing_param", cpu=ind_vcpu),
2754         )
2755         setxml = ET.fromstring(define_mock.call_args[0][0])
2756         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']"), None)
2757         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2758         self.assertEqual(
2759             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2760         )
2761         self.assertEqual(
2762             setxml.find("./vcpus/vcpu/[@id='3']").attrib.get("order"), None
2763         )
2764         vcpus_none = {"vcpus": None}
2765         self.assertEqual(
2766             {
2767                 "definition": True,
2768                 "disk": {"attached": [], "detached": [], "updated": []},
2769                 "interface": {"attached": [], "detached": []},
2770             },
2771             virt.update("vm_with_existing_param", cpu=vcpus_none),
2772         )
2773         setxml = ET.fromstring(define_mock.call_args[0][0])
2774         self.assertEqual(setxml.find("vcpus"), None)
2775         cpu_atr_none = {"match": None, "mode": None, "check": None}
2776         self.assertEqual(
2777             {
2778                 "definition": True,
2779                 "disk": {"attached": [], "detached": [], "updated": []},
2780                 "interface": {"attached": [], "detached": []},
2781             },
2782             virt.update("vm_with_existing_param", cpu=cpu_atr_none),
2783         )
2784         setxml = ET.fromstring(define_mock.call_args[0][0])
2785         self.assertEqual(setxml.find("cpu").attrib, {})
2786         cpu_atr_mn = {"match": None}
2787         self.assertEqual(
2788             {
2789                 "definition": True,
2790                 "disk": {"attached": [], "detached": [], "updated": []},
2791                 "interface": {"attached": [], "detached": []},
2792             },
2793             virt.update("vm_with_existing_param", cpu=cpu_atr_mn),
2794         )
2795         setxml = ET.fromstring(define_mock.call_args[0][0])
2796         self.assertEqual(setxml.find("cpu").attrib.get("match"), None)
2797         self.assertEqual(setxml.find("cpu").attrib.get("mode"), "custom")
2798         self.assertEqual(setxml.find("cpu").attrib.get("check"), "full")
2799         cpu_model_none = {"model": None}
2800         self.assertEqual(
2801             {
2802                 "definition": True,
2803                 "disk": {"attached": [], "detached": [], "updated": []},
2804                 "interface": {"attached": [], "detached": []},
2805             },
2806             virt.update("vm_with_existing_param", cpu=cpu_model_none),
2807         )
2808         setxml = ET.fromstring(define_mock.call_args[0][0])
2809         self.assertEqual(setxml.find("cpu").find("model"), None)
2810         cpu_model_atr_none = {
2811             "model": {"name": "coresolo", "fallback": "forbid", "vendor_id": None}
2812         }
2813         self.assertEqual(
2814             {
2815                 "definition": True,
2816                 "disk": {"attached": [], "detached": [], "updated": []},
2817                 "interface": {"attached": [], "detached": []},
2818             },
2819             virt.update("vm_with_existing_param", cpu=cpu_model_atr_none),
2820         )
2821         setxml = ET.fromstring(define_mock.call_args[0][0])
2822         self.assertEqual(setxml.find("cpu").find("model").attrib.get("vendor_id"), None)
2823         self.assertEqual(
2824             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2825         )
2826         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2827         cpu_model_atr = {
2828             "model": {
2829                 "name": "coresolo",
2830                 "fallback": "forbid",
2831                 "vendor_id": "AuthenticAMD",
2832             }
2833         }
2834         self.assertEqual(
2835             {
2836                 "definition": True,
2837                 "disk": {"attached": [], "detached": [], "updated": []},
2838                 "interface": {"attached": [], "detached": []},
2839             },
2840             virt.update("vm_with_existing_param", cpu=cpu_model_atr),
2841         )
2842         setxml = ET.fromstring(define_mock.call_args[0][0])
2843         self.assertEqual(
2844             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2845         )
2846         self.assertEqual(
2847             setxml.find("cpu").find("model").attrib.get("vendor_id"), "AuthenticAMD"
2848         )
2849         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2850         cpu_vendor = {"vendor": "AMD"}
2851         self.assertEqual(
2852             {
2853                 "definition": True,
2854                 "disk": {"attached": [], "detached": [], "updated": []},
2855                 "interface": {"attached": [], "detached": []},
2856             },
2857             virt.update("vm_with_existing_param", cpu=cpu_vendor),
2858         )
2859         setxml = ET.fromstring(define_mock.call_args[0][0])
2860         self.assertEqual(setxml.find("cpu").find("vendor").text, "AMD")
2861         cpu_vendor_none = {"vendor": None}
2862         self.assertEqual(
2863             {
2864                 "definition": True,
2865                 "disk": {"attached": [], "detached": [], "updated": []},
2866                 "interface": {"attached": [], "detached": []},
2867             },
2868             virt.update("vm_with_existing_param", cpu=cpu_vendor_none),
2869         )
2870         setxml = ET.fromstring(define_mock.call_args[0][0])
2871         self.assertEqual(setxml.find("cpu").find("vendor"), None)
2872         cpu_topology = {"topology": {"sockets": 1, "cores": 12, "threads": 1}}
2873         self.assertEqual(
2874             {
2875                 "definition": True,
2876                 "disk": {"attached": [], "detached": [], "updated": []},
2877                 "interface": {"attached": [], "detached": []},
2878             },
2879             virt.update("vm_with_existing_param", cpu=cpu_topology),
2880         )
2881         setxml = ET.fromstring(define_mock.call_args[0][0])
2882         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("sockets"), "1")
2883         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2884         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2885         cpu_topology_atr_none = {
2886             "topology": {"sockets": None, "cores": 12, "threads": 1}
2887         }
2888         self.assertEqual(
2889             {
2890                 "definition": True,
2891                 "disk": {"attached": [], "detached": [], "updated": []},
2892                 "interface": {"attached": [], "detached": []},
2893             },
2894             virt.update("vm_with_existing_param", cpu=cpu_topology_atr_none),
2895         )
2896         setxml = ET.fromstring(define_mock.call_args[0][0])
2897         self.assertEqual(
2898             setxml.find("cpu").find("topology").attrib.get("sockets"), None
2899         )
2900         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2901         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2902         cpu_topology_none = {"topology": None}
2903         self.assertEqual(
2904             {
2905                 "definition": True,
2906                 "disk": {"attached": [], "detached": [], "updated": []},
2907                 "interface": {"attached": [], "detached": []},
2908             },
2909             virt.update("vm_with_existing_param", cpu=cpu_topology_none),
2910         )
2911         setxml = ET.fromstring(define_mock.call_args[0][0])
2912         self.assertEqual(setxml.find("cpu").find("topology"), None)
2913         cpu_cache = {"cache": {"mode": "passthrough", "level": 2}}
2914         self.assertEqual(
2915             {
2916                 "definition": True,
2917                 "disk": {"attached": [], "detached": [], "updated": []},
2918                 "interface": {"attached": [], "detached": []},
2919             },
2920             virt.update("vm_with_existing_param", cpu=cpu_cache),
2921         )
2922         setxml = ET.fromstring(define_mock.call_args[0][0])
2923         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), "2")
2924         self.assertEqual(
2925             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2926         )
2927         cpu_cache_atr_none = {"cache": {"mode": "passthrough", "level": None}}
2928         self.assertEqual(
2929             {
2930                 "definition": True,
2931                 "disk": {"attached": [], "detached": [], "updated": []},
2932                 "interface": {"attached": [], "detached": []},
2933             },
2934             virt.update("vm_with_existing_param", cpu=cpu_cache_atr_none),
2935         )
2936         setxml = ET.fromstring(define_mock.call_args[0][0])
2937         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), None)
2938         self.assertEqual(
2939             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2940         )
2941         cpu_cache_none = {"cache": None}
2942         self.assertEqual(
2943             {
2944                 "definition": True,
2945                 "disk": {"attached": [], "detached": [], "updated": []},
2946                 "interface": {"attached": [], "detached": []},
2947             },
2948             virt.update("vm_with_existing_param", cpu=cpu_cache_none),
2949         )
2950         setxml = ET.fromstring(define_mock.call_args[0][0])
2951         self.assertEqual(setxml.find("cpu").find("cache"), None)
2952         cpu_feature = {"features": {"lahf_lm": "require", "pcid": "optional"}}
2953         self.assertEqual(
2954             {
2955                 "definition": True,
2956                 "disk": {"attached": [], "detached": [], "updated": []},
2957                 "interface": {"attached": [], "detached": []},
2958             },
2959             virt.update("vm_with_existing_param", cpu=cpu_feature),
2960         )
2961         setxml = ET.fromstring(define_mock.call_args[0][0])
2962         self.assertEqual(
2963             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2964         )
2965         self.assertEqual(
2966             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2967             "require",
2968         )
2969         cpu_feature_atr_none = {"features": {"pcid": "optional", "lahf_lm": "disable"}}
2970         self.assertEqual(
2971             {
2972                 "definition": True,
2973                 "disk": {"attached": [], "detached": [], "updated": []},
2974                 "interface": {"attached": [], "detached": []},
2975             },
2976             virt.update("vm_with_existing_param", cpu=cpu_feature_atr_none),
2977         )
2978         setxml = ET.fromstring(define_mock.call_args[0][0])
2979         self.assertEqual(
2980             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2981             "disable",
2982         )
2983         self.assertEqual(
2984             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2985         )
2986         cpu_feature_none = {"features": {"lahf_lm": None, "pcid": None}}
2987         self.assertEqual(
2988             {
2989                 "definition": True,
2990                 "disk": {"attached": [], "detached": [], "updated": []},
2991                 "interface": {"attached": [], "detached": []},
2992             },
2993             virt.update("vm_with_existing_param", cpu=cpu_feature_none),
2994         )
2995         setxml = ET.fromstring(define_mock.call_args[0][0])
2996         self.assertEqual(setxml.find("./cpu/feature"), None)
2997         numa_cell = {
2998             "numa": {
2999                 0: {
3000                     "cpus": "0-6",
3001                     "memory": "512m",
3002                     "discard": True,
3003                     "distances": {0: 15, 1: 16, 2: 17, 3: 18},
3004                 },
3005                 1: {
3006                     "cpus": "7-12",
3007                     "memory": "2g",
3008                     "discard": True,
3009                     "memAccess": "shared",
3010                     "distances": {0: 23, 1: 24, 2: 25, 3: 26},
3011                 },
3012             }
3013         }
3014         self.assertEqual(
3015             {
3016                 "definition": True,
3017                 "disk": {"attached": [], "detached": [], "updated": []},
3018                 "interface": {"attached": [], "detached": []},
3019             },
3020             virt.update("vm_with_existing_param", cpu=numa_cell),
3021         )
3022         setxml = ET.fromstring(define_mock.call_args[0][0])
3023         self.assertEqual(
3024             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
3025             ",".join([str(i) for i in range(0, 7)]),
3026         )
3027         self.assertEqual(
3028             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
3029             str(512 * 1024 ** 2),
3030         )
3031         self.assertEqual(
3032             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
3033             "bytes",
3034         )
3035         self.assertEqual(
3036             setxml.find("./cpu/numa/cell/[@id='0']").attrib["discard"], "yes"
3037         )
3038         self.assertEqual(
3039             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
3040                 "value"
3041             ],
3042             "15",
3043         )
3044         self.assertEqual(
3045             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']").attrib[
3046                 "value"
3047             ],
3048             "16",
3049         )
3050         self.assertEqual(
3051             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
3052                 "value"
3053             ],
3054             "17",
3055         )
3056         self.assertEqual(
3057             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
3058                 "value"
3059             ],
3060             "18",
3061         )
3062         self.assertEqual(
3063             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
3064             ",".join([str(i) for i in range(7, 13)]),
3065         )
3066         self.assertEqual(
3067             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
3068             str(int(2 * 1024 ** 3)),
3069         )
3070         self.assertEqual(
3071             setxml.find("./cpu/numa/cell/[@id='1']").get("unit"),
3072             "bytes",
3073         )
3074         self.assertEqual(
3075             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
3076         )
3077         self.assertEqual(
3078             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memAccess"], "shared"
3079         )
3080         self.assertEqual(
3081             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
3082                 "value"
3083             ],
3084             "23",
3085         )
3086         self.assertEqual(
3087             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3088                 "value"
3089             ],
3090             "24",
3091         )
3092         self.assertEqual(
3093             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3094                 "value"
3095             ],
3096             "25",
3097         )
3098         self.assertEqual(
3099             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']").attrib[
3100                 "value"
3101             ],
3102             "26",
3103         )
3104         numa_cell_atr_none = {
3105             "numa": {
3106                 "0": {
3107                     "cpus": "0-6",
3108                     "memory": "512m",
3109                     "discard": False,
3110                     "distances": {0: 15, 2: 17, 3: 18},
3111                 },
3112                 "1": {
3113                     "cpus": "7-12",
3114                     "memory": "2g",
3115                     "discard": True,
3116                     "distances": {0: 23, 1: 24, 2: 25},
3117                 },
3118             }
3119         }
3120         self.assertEqual(
3121             {
3122                 "definition": True,
3123                 "disk": {"attached": [], "detached": [], "updated": []},
3124                 "interface": {"attached": [], "detached": []},
3125             },
3126             virt.update("vm_with_existing_param", cpu=numa_cell_atr_none),
3127         )
3128         setxml = ET.fromstring(define_mock.call_args[0][0])
3129         self.assertEqual(
3130             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
3131             ",".join([str(i) for i in range(0, 7)]),
3132         )
3133         self.assertEqual(
3134             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
3135             str(512 * 1024 ** 2),
3136         )
3137         self.assertEqual(
3138             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
3139             "bytes",
3140         )
3141         self.assertEqual(
3142             setxml.find("./cpu/numa/cell/[@id='0']").attrib.get("discard"), "no"
3143         )
3144         self.assertEqual(
3145             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
3146                 "value"
3147             ],
3148             "15",
3149         )
3150         self.assertEqual(
3151             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']"), None
3152         )
3153         self.assertEqual(
3154             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
3155                 "value"
3156             ],
3157             "17",
3158         )
3159         self.assertEqual(
3160             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
3161                 "value"
3162             ],
3163             "18",
3164         )
3165         self.assertEqual(
3166             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
3167             ",".join([str(i) for i in range(7, 13)]),
3168         )
3169         self.assertEqual(
3170             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
3171             str(int(2 * 1024 ** 3)),
3172         )
3173         self.assertEqual(
3174             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
3175         )
3176         self.assertEqual(
3177             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
3178                 "value"
3179             ],
3180             "23",
3181         )
3182         self.assertEqual(
3183             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3184                 "value"
3185             ],
3186             "24",
3187         )
3188         self.assertEqual(
3189             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3190                 "value"
3191             ],
3192             "25",
3193         )
3194         self.assertEqual(
3195             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"), None
3196         )
3197         self.assertEqual(
3198             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
3199             ",".join([str(i) for i in range(7, 13)]),
3200         )
3201         self.assertEqual(
3202             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
3203             str(int(1024 ** 3 * 2)),
3204         )
3205         self.assertEqual(
3206             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
3207         )
3208         self.assertEqual(
3209             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
3210                 "value"
3211             ],
3212             "23",
3213         )
3214         self.assertEqual(
3215             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3216                 "value"
3217             ],
3218             "24",
3219         )
3220         self.assertEqual(
3221             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3222                 "value"
3223             ],
3224             "25",
3225         )
3226         self.assertEqual(
3227             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"),
3228             None,
3229         )
3230     def test_update_memtune_params(self):
3231         """
3232         Test virt.update() with memory tuning parameters.
3233         """
3234         xml_with_memtune_params = """
3235             &lt;domain type='kvm' id='8'&gt;
3236               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
3237               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3238               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3239               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
3240               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3241               &lt;memtune&gt;
3242                 &lt;hard_limit unit="KiB"&gt;1048576&lt;/hard_limit&gt;
3243                 &lt;soft_limit unit="KiB"&gt;2097152&lt;/soft_limit&gt;
3244                 &lt;swap_hard_limit unit="KiB"&gt;2621440&lt;/swap_hard_limit&gt;
3245                 &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
3246               &lt;/memtune&gt;
3247               &lt;os&gt;
3248                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3249               &lt;/os&gt;
3250             &lt;/domain&gt;
3251         """
3252         domain_mock = self.set_mock_vm("vm_with_memtune_param", xml_with_memtune_params)
3253         domain_mock.OSType = MagicMock(return_value="hvm")
3254         define_mock = MagicMock(return_value=True)
3255         self.mock_conn.defineXML = define_mock
3256         memtune_new_val = {
3257             "boot": "0.7g",
3258             "current": "2.5g",
3259             "max": "3096m",
3260             "slots": "10",
3261             "soft_limit": "2048m",
3262             "hard_limit": "1024",
3263             "swap_hard_limit": "2.5g",
3264             "min_guarantee": "1 g",
3265         }
3266         domain_mock.setMemoryFlags.return_value = 0
3267         self.assertEqual(
3268             {
3269                 "definition": True,
3270                 "disk": {"attached": [], "detached": [], "updated": []},
3271                 "interface": {"attached": [], "detached": []},
3272                 "mem": True,
3273             },
3274             virt.update("vm_with_memtune_param", mem=memtune_new_val),
3275         )
3276         self.assertEqual(
3277             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3278         )
3279         setxml = ET.fromstring(define_mock.call_args[0][0])
3280         self.assertEqual(
3281             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3282         )
3283         self.assertEqual(
3284             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3285         )
3286         self.assertEqual(
3287             setxml.find("memtune").find("swap_hard_limit").text,
3288             str(int(2.5 * 1024 ** 2)),
3289         )
3290         self.assertEqual(
3291             setxml.find("memtune").find("swap_hard_limit").get("unit"),
3292             "KiB",
3293         )
3294         self.assertEqual(
3295             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3296         )
3297         self.assertEqual(
3298             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3299         )
3300         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3301         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3302         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3303         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3304         max_slot_reverse = {
3305             "slots": "10",
3306             "max": "3096m",
3307         }
3308         self.assertEqual(
3309             {
3310                 "definition": True,
3311                 "disk": {"attached": [], "detached": [], "updated": []},
3312                 "interface": {"attached": [], "detached": []},
3313             },
3314             virt.update("vm_with_memtune_param", mem=max_slot_reverse),
3315         )
3316         setxml = ET.fromstring(define_mock.call_args[0][0])
3317         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3318         self.assertEqual(setxml.find("maxMemory").get("unit"), "bytes")
3319         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3320         max_swap_none = {
3321             "boot": "0.7g",
3322             "current": "2.5g",
3323             "max": None,
3324             "slots": "10",
3325             "soft_limit": "2048m",
3326             "hard_limit": "1024",
3327             "swap_hard_limit": None,
3328             "min_guarantee": "1 g",
3329         }
3330         domain_mock.setMemoryFlags.reset_mock()
3331         self.assertEqual(
3332             {
3333                 "definition": True,
3334                 "disk": {"attached": [], "detached": [], "updated": []},
3335                 "interface": {"attached": [], "detached": []},
3336                 "mem": True,
3337             },
3338             virt.update("vm_with_memtune_param", mem=max_swap_none),
3339         )
3340         self.assertEqual(
3341             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3342         )
3343         setxml = ET.fromstring(define_mock.call_args[0][0])
3344         self.assertEqual(
3345             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3346         )
3347         self.assertEqual(
3348             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3349         )
3350         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3351         self.assertEqual(
3352             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3353         )
3354         self.assertEqual(
3355             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3356         )
3357         self.assertEqual(setxml.find("maxMemory").text, None)
3358         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3359         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3360         memtune_none = {
3361             "soft_limit": None,
3362             "hard_limit": None,
3363             "swap_hard_limit": None,
3364             "min_guarantee": None,
3365         }
3366         self.assertEqual(
3367             {
3368                 "definition": True,
3369                 "disk": {"attached": [], "detached": [], "updated": []},
3370                 "interface": {"attached": [], "detached": []},
3371             },
3372             virt.update("vm_with_memtune_param", mem=memtune_none),
3373         )
3374         self.assertEqual(setxml.find("memtune").find("soft_limit"), None)
3375         self.assertEqual(setxml.find("memtune").find("hard_limit"), None)
3376         self.assertEqual(setxml<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.find("memtune").find("swap_hard_limit"), None)
3377         self.assertEqual(setxml.find("memtune").find("min_guarantee"), None)
3378         max_none = {
3379             "max"</b></font>: None,
3380         }
3381         self.assertEqual(
3382             {
3383                 "definition": True,
3384                 "disk": {"attached": [], "detached": [], "updated": []},
3385                 "interface": {"attached": [], "detached": []},
3386             },
3387             virt.update("vm_with_memtune_param", mem=max_none),
3388         )
3389         setxml = ET.fromstring(define_mock.call_args[0][0])
3390         self.assertEqual(setxml.find("maxMemory"), None)
3391         self.assertEqual(setxml.find("currentMemory").text, str(int(1 * 1024 ** 2)))
3392         self.assertEqual(setxml.find("memory").text, str(int(1 * 1024 ** 2)))
3393     def test_update_exist_memorybacking_params(self):
3394         """
3395         Test virt.update() with memory backing parameters.
3396         """
3397         xml_with_memback_params = """
3398             &lt;domain type='kvm' id='8'&gt;
3399               &lt;name&gt;vm_with_memback_param&lt;/name&gt;
3400               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3401               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3402               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3403               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3404               &lt;memoryBacking&gt;
3405                 &lt;hugepages&gt;
3406                   &lt;page size="2048" unit="KiB"/&gt;
3407                   &lt;page size="3145728" nodeset="1-4,^3" unit="KiB"/&gt;
3408                   &lt;page size="1048576" nodeset="3" unit="KiB"/&gt;
3409                 &lt;/hugepages&gt;
3410                 &lt;nosharepages/&gt;
3411                 &lt;locked/&gt;
3412                 &lt;source type="file"/&gt;
3413                 &lt;access mode="shared"/&gt;
3414                 &lt;discard/&gt;
3415               &lt;/memoryBacking&gt;
3416               &lt;os&gt;
3417                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3418               &lt;/os&gt;
3419               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
3420             &lt;/domain&gt;
3421         """
3422         domain_mock = self.set_mock_vm("vm_with_memback_param", xml_with_memback_params)
3423         domain_mock.OSType = MagicMock(return_value="hvm")
3424         define_mock = MagicMock(return_value=True)
3425         self.mock_conn.defineXML = define_mock
3426         mem_back_param = {
3427             "hugepages": [
3428                 {"nodeset": "1-4,^3", "size": "1g"},
3429                 {"nodeset": "3", "size": "2g"},
3430             ],
3431             "nosharepages": None,
3432             "locked": None,
3433             "source": "anonymous",
3434             "access": "private",
3435             "allocation": "ondemand",
3436             "discard": None,
3437         }
3438         self.assertEqual(
3439             {
3440                 "definition": True,
3441                 "disk": {"attached": [], "detached": [], "updated": []},
3442                 "interface": {"attached": [], "detached": []},
3443             },
3444             virt.update("vm_with_memback_param", mem=mem_back_param),
3445         )
3446         setxml = ET.fromstring(define_mock.call_args[0][0])
3447         self.assertDictEqual(
3448             {
3449                 p.get("nodeset"): {"size": p.get("size"), "unit": p.get("unit")}
3450                 for p in setxml.findall("memoryBacking/hugepages/page")
3451             },
3452             {
3453                 "1,2,4": {"size": str(1024 ** 3), "unit": "bytes"},
3454                 "3": {"size": str(2 * 1024 ** 3), "unit": "bytes"},
3455             },
3456         )
3457         self.assertEqual(setxml.find("./memoryBacking/nosharepages"), None)
3458         self.assertEqual(setxml.find("./memoryBacking/locked"), None)
3459         self.assertEqual(
3460             setxml.find("./memoryBacking/source").attrib["type"], "anonymous"
3461         )
3462         self.assertEqual(
3463             setxml.find("./memoryBacking/access").attrib["mode"], "private"
3464         )
3465         self.assertEqual(
3466             setxml.find("./memoryBacking/allocation").attrib["mode"], "ondemand"
3467         )
3468         self.assertEqual(setxml.find("./memoryBacking/discard"), None)
3469         unchanged_page = {
3470             "hugepages": [
3471                 {"size": "2m"},
3472                 {"nodeset": "1-4,^3", "size": "3g"},
3473                 {"nodeset": "3", "size": "1g"},
3474             ],
3475         }
3476         self.assertEqual(
3477             {
3478                 "definition": False,
3479                 "disk": {"attached": [], "detached": [], "updated": []},
3480                 "interface": {"attached": [], "detached": []},
3481             },
3482             virt.update("vm_with_memback_param", mem=unchanged_page),
3483         )
3484     def test_update_iothreads_params(self):
3485         """
3486         Test virt.update() with iothreads parameters.
3487         """
3488         xml_with_iothreads_params = """
3489             &lt;domain type='kvm' id='8'&gt;
3490               &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
3491               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3492               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3493               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3494               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3495               &lt;iothreads&gt;6&lt;/iothreads&gt;
3496               &lt;os&gt;
3497                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3498               &lt;/os&gt;
3499             &lt;/domain&gt;
3500         """
3501         domain_mock = self.set_mock_vm(
3502             "xml_with_iothreads_params", xml_with_iothreads_params
3503         )
3504         domain_mock.OSType = MagicMock(return_value="hvm")
3505         define_mock = MagicMock(return_value=True)
3506         self.mock_conn.defineXML = define_mock
3507         self.assertEqual(
3508             {
3509                 "definition": True,
3510                 "disk": {"attached": [], "detached": [], "updated": []},
3511                 "interface": {"attached": [], "detached": []},
3512             },
3513             virt.update("xml_with_iothreads_params", cpu={"iothreads": 7}),
3514         )
3515         setxml = ET.fromstring(define_mock.call_args[0][0])
3516         self.assertEqual(setxml.find("iothreads").text, "7")
3517     def test_update_cputune_paramters(self):
3518         """
3519         Test virt.update() with cputune parameters.
3520         """
3521         xml_with_cputune_params = """
3522                     &lt;domain type='kvm' id='8'&gt;
3523                       &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
3524                       &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3525                       &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3526                       &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3527                       &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3528                       &lt;iothreads&gt;4&lt;/iothreads&gt;
3529                       &lt;cputune&gt;
3530                         &lt;shares&gt;2048&lt;/shares&gt;
3531                         &lt;period&gt;1000000&lt;/period&gt;
3532                         &lt;quota&gt;-1&lt;/quota&gt;
3533                         &lt;global_period&gt;1000000&lt;/global_period&gt;
3534                         &lt;global_quota&gt;-1&lt;/global_quota&gt;
3535                         &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
3536                         &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
3537                         &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
3538                         &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
3539                         &lt;vcpupin vcpu="0" cpuset="0-2"/&gt;
3540                         &lt;vcpupin vcpu="1" cpuset="3"/&gt;
3541                         &lt;vcpupin vcpu="2" cpuset="4"/&gt;
3542                         &lt;vcpupin vcpu="3" cpuset="5-7"/&gt;
3543                         &lt;emulatorpin cpuset="1-2"/&gt;
3544                         &lt;iothreadpin iothread="1" cpuset="1-5"/&gt;
3545                         &lt;iothreadpin iothread="2" cpuset="6-7"/&gt;
3546                         &lt;vcpusched vcpus="0" scheduler="idle" priority="3"/&gt;
3547                         &lt;vcpusched vcpus="1" scheduler="rr" priority="1"/&gt;
3548                         &lt;vcpusched vcpus="2" scheduler="fifo" priority="2"/&gt;
3549                         &lt;iothreadsched iothreads="4" scheduler="fifo"/&gt;
3550                         &lt;emulatorsched scheduler="idle"/&gt;
3551                         &lt;cachetune vcpus="0-4"&gt;
3552                           &lt;cache id="0" level="2" type="both" size="4" unit="KiB"/&gt;
3553                           &lt;cache id="1" level="2" type="both" size="4" unit="KiB"/&gt;
3554                           &lt;monitor level="5" vcpus="0-2"/&gt;
3555                           &lt;monitor level="6" vcpus="1-3"/&gt;
3556                         &lt;/cachetune&gt;
3557                         &lt;cachetune vcpus="5-8"&gt;
3558                           &lt;monitor level="5" vcpus="5-6"/&gt;
3559                           &lt;monitor level="3" vcpus="7-8"/&gt;
3560                         &lt;/cachetune&gt;
3561                         &lt;memorytune vcpus="0-6"&gt;
3562                           &lt;node id="0" bandwidth="45"/&gt;
3563                         &lt;/memorytune&gt;
3564                         &lt;memorytune vcpus="7-8"&gt;
3565                           &lt;node id="0" bandwidth="120"/&gt;
3566                         &lt;/memorytune&gt;
3567                       &lt;/cputune&gt;
3568                       &lt;os&gt;
3569                         &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3570                       &lt;/os&gt;
3571                     &lt;/domain&gt;
3572                 """
3573         domain_mock = self.set_mock_vm(
3574             "xml_with_cputune_params", xml_with_cputune_params
3575         )
3576         domain_mock.OSType = MagicMock(return_value="hvm")
3577         define_mock = MagicMock(return_value=True)
3578         self.mock_conn.defineXML = define_mock
3579         cputune = {
3580             "shares": 1024,
3581             "period": 5000,
3582             "quota": -20,
3583             "global_period": 4000,
3584             "global_quota": -30,
3585             "emulator_period": 3000,
3586             "emulator_quota": -4,
3587             "iothread_period": 7000,
3588             "iothread_quota": -5,
3589             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
3590             "emulatorpin": "1-3",
3591             "iothreadpin": {1: "5-6", 2: "7-8"},
3592             "vcpusched": [
3593                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
3594                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
3595                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
3596             ],
3597             "iothreadsched": [
3598                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1}
3599             ],
3600             "emulatorsched": {"scheduler": "rr", "priority": 2},
3601             "cachetune": {
3602                 "0-3": {
3603                     0: {"level": 3, "type": "both", "size": 3},
3604                     1: {"level": 3, "type": "both", "size": 3},
3605                     "monitor": {1: 3, "0-3": 3},
3606                 },
3607                 "4-5": {"monitor": {4: 3, 5: 2}},
3608             },
3609             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
3610         }
3611         self.assertEqual(
3612             {
3613                 "definition": True,
3614                 "disk": {"attached": [], "detached": [], "updated": []},
3615                 "interface": {"attached": [], "detached": []},
3616             },
3617             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3618         )
3619         setxml = ET.fromstring(define_mock.call_args[0][0])
3620         self.assertEqual(setxml.find("cputune").find("shares").text, "1024")
3621         self.assertEqual(setxml.find("cputune").find("period").text, "5000")
3622         self.assertEqual(setxml.find("cputune").find("quota").text, "-20")
3623         self.assertEqual(setxml.find("cputune").find("global_period").text, "4000")
3624         self.assertEqual(setxml.find("cputune").find("global_quota").text, "-30")
3625         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "3000")
3626         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3627         self.assertEqual(setxml.find("cputune").find("iothread_period").text, "7000")
3628         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3629         self.assertEqual(
3630             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3631             "1,3,4",
3632         )
3633         self.assertEqual(
3634             setxml.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
3635             "0,1",
3636         )
3637         self.assertEqual(
3638             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3639             "2,3",
3640         )
3641         self.assertEqual(
3642             setxml.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
3643             "0,4",
3644         )
3645         self.assertEqual(
3646             setxml.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1,2,3"
3647         )
3648         self.assertEqual(
3649             setxml.find("cputune")
3650             .find("iothreadpin[@iothread='1']")
3651             .attrib.get("cpuset"),
3652             "5,6",
3653         )
3654         self.assertEqual(
3655             setxml.find("cputune")
3656             .find("iothreadpin[@iothread='2']")
3657             .attrib.get("cpuset"),
3658             "7,8",
3659         )
3660         self.assertDictEqual(
3661             {
3662                 s.get("vcpus"): {
3663                     "scheduler": s.get("scheduler"),
3664                     "priority": s.get("priority"),
3665                 }
3666                 for s in setxml.findall("cputune/vcpusched")
3667             },
3668             {
3669                 "0": {"scheduler": "fifo", "priority": "1"},
3670                 "1": {"scheduler": "fifo", "priority": "2"},
3671                 "2": {"scheduler": "idle", "priority": "3"},
3672             },
3673         )
3674         self.assertDictEqual(
3675             {
3676                 s.get("iothreads"): {
3677                     "scheduler": s.get("scheduler"),
3678                     "priority": s.get("priority"),
3679                 }
3680                 for s in setxml.findall("cputune/iothreadsched")
3681             },
3682             {"5,6,7": {"scheduler": "batch", "priority": "1"}},
3683         )
3684         self.assertEqual(setxml.find("cputune/emulatorsched").get("scheduler"), "rr")
3685         self.assertEqual(setxml.find("cputune/emulatorsched").get("priority"), "2")
3686         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3687         self.assertEqual(
3688             setxml.find(
3689                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3690             ).attrib.get("level"),
3691             "3",
3692         )
3693         self.assertEqual(
3694             setxml.find(
3695                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3696             ).attrib.get("type"),
3697             "both",
3698         )
3699         self.assertEqual(
3700             setxml.find(
3701                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"
3702             ).attrib.get("level"),
3703             "3",
3704         )
3705         self.assertNotEqual(
3706             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"),
3707             None,
3708         )
3709         self.assertNotEqual(
3710             setxml.find("./cputune/cachetune[@vcpus='4,5']").attrib.get("vcpus"), None
3711         )
3712         self.assertEqual(
3713             setxml.find("./cputune/cachetune[@vcpus='4,5']/cache[@id='0']"), None
3714         )
3715         self.assertEqual(
3716             setxml.find(
3717                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']"
3718             ).attrib.get("level"),
3719             "3",
3720         )
3721         self.assertEqual(
3722             setxml.find(
3723                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']"
3724             ).attrib.get("level"),
3725             "2",
3726         )
3727         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3728         self.assertEqual(
3729             setxml.find(
3730                 "./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']"
3731             ).attrib.get("bandwidth"),
3732             "60",
3733         )
3734         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='3,4']"), None)
3735         self.assertEqual(
3736             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3737                 "bandwidth"
3738             ),
3739             "50",
3740         )
3741         self.assertEqual(
3742             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3743                 "bandwidth"
3744             ),
3745             "70",
3746         )
3747         cputune = {
3748             "shares": None,
3749             "period": 20000,
3750             "quota": None,
3751             "global_period": 5000,
3752             "global_quota": None,
3753             "emulator_period": 2000,
3754             "emulator_quota": -4,
3755             "iothread_period": None,
3756             "iothread_quota": -5,
3757             "vcpupin": {0: "1-4,^2", 2: "2,4"},
3758             "emulatorpin": None,
3759             "iothreadpin": {1: "5-6"},
3760             "vcpusched": [{"scheduler": "idle", "priority": 5, "vcpus": "1"}],
3761             "iothreadsched": None,
3762             "cachetune": {
3763                 "0-3": {
3764                     0: {"level": 4, "type": "data", "size": 7},
3765                     "monitor": {"1-2": 11},
3766                 },
3767             },
3768             "memorytune": {"3-4": {0: 37, 1: 73}},
3769         }
3770         self.assertEqual(
3771             {
3772                 "definition": True,
3773                 "disk": {"attached": [], "detached": [], "updated": []},
3774                 "interface": {"attached": [], "detached": []},
3775             },
3776             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3777         )
3778         setxml = ET.fromstring(define_mock.call_args[0][0])
3779         self.assertEqual(setxml.find("cputune").find("shares"), None)
3780         self.assertEqual(setxml.find("cputune").find("period").text, "20000")
3781         self.assertEqual(setxml.find("cputune").find("quota"), None)
3782         self.assertEqual(setxml.find("cputune").find("global_period").text, "5000")
3783         self.assertEqual(setxml.find("cputune").find("global_quota"), None)
3784         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "2000")
3785         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3786         self.assertEqual(setxml.find("cputune").find("iothread_period"), None)
3787         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3788         self.assertEqual(
3789             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3790             "1,3,4",
3791         )
3792         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='1']"), None)
3793         self.assertEqual(
3794             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3795             "2,4",
3796         )
3797         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='3']"), None)
3798         self.assertEqual(setxml.find("cputune").find("emulatorpin"), None)
3799         self.assertEqual(
3800             setxml.find("cputune")
3801             .find("iothreadpin[@iothread='1']")
3802             .attrib.get("cpuset"),
3803             "5,6",
3804         )
3805         self.assertEqual(
3806             setxml.find("cputune").find("iothreadpin[@iothread='2']"), None
3807         )
3808         self.assertDictEqual(
3809             {
3810                 s.get("vcpus"): {
3811                     "scheduler": s.get("scheduler"),
3812                     "priority": s.get("priority"),
3813                 }
3814                 for s in setxml.findall("cputune/vcpusched")
3815             },
3816             {"1": {"scheduler": "idle", "priority": "5"}},
3817         )
3818         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3819         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3820         self.assertEqual(
3821             setxml.find(
3822                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3823             ).attrib.get("size"),
3824             "7",
3825         )
3826         self.assertEqual(
3827             setxml.find(
3828                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3829             ).attrib.get("level"),
3830             "4",
3831         )
3832         self.assertEqual(
3833             setxml.find(
3834                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3835             ).attrib.get("type"),
3836             "data",
3837         )
3838         self.assertEqual(
3839             setxml.find(
3840                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']"
3841             ).attrib.get("level"),
3842             "11",
3843         )
3844         self.assertEqual(
3845             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']"),
3846             None,
3847         )
3848         self.assertEqual(
3849             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']"), None
3850         )
3851         self.assertEqual(setxml.find("./cputune/cachetune[@vcpus='4,5']"), None)
3852         self.assertEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3853         self.assertEqual(
3854             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3855                 "bandwidth"
3856             ),
3857             "37",
3858         )
3859         self.assertEqual(
3860             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3861                 "bandwidth"
3862             ),
3863             "73",
3864         )
3865         cputune_subelement = {
3866             "vcpupin": None,
3867             "iothreadpin": None,
3868             "vcpusched": None,
3869             "iothreadsched": None,
3870             "cachetune": None,
3871             "memorytune": None,
3872         }
3873         self.assertEqual(
3874             {
3875                 "definition": True,
3876                 "disk": {"attached": [], "detached": [], "updated": []},
3877                 "interface": {"attached": [], "detached": []},
3878             },
3879             virt.update("xml_with_cputune_params", cpu={"tuning": cputune_subelement}),
3880         )
3881         setxml = ET.fromstring(define_mock.call_args[0][0])
3882         self.assertEqual(setxml.find("cputune").find("vcpupin"), None)
3883         self.assertEqual(setxml.find("cputune").find("iothreadpin"), None)
3884         self.assertEqual(setxml.find("cputune").find("vcpusched"), None)
3885         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3886         self.assertEqual(setxml.find("cputune").find("cachetune"), None)
3887         self.assertEqual(setxml.find("cputune").find("memorytune"), None)
3888     def test_handle_unit(self):
3889         """
3890         Test regex function for handling units
3891         """
3892         valid_case = [
3893             ("2", 2097152),
3894             ("42", 44040192),
3895             ("5b", 5),
3896             ("2.3Kib", 2355),
3897             ("5.8Kb", 5800),
3898             ("16MiB", 16777216),
3899             ("20 GB", 20000000000),
3900             ("16KB", 16000),
3901             (".5k", 512),
3902             ("2.k", 2048),
3903         ]
3904         for key, val in valid_case:
3905             self.assertEqual(virt._handle_unit(key), val)
3906         invalid_case = [
3907             ("9ib", "invalid units"),
3908             ("8byte", "invalid units"),
3909             ("512bytes", "invalid units"),
3910             ("4 Kbytes", "invalid units"),
3911             ("3.4.MB", "invalid number"),
3912             ("", "invalid number"),
3913             ("bytes", "invalid number"),
3914             ("2HB", "invalid units"),
3915         ]
3916         for key, val in invalid_case:
3917             with self.assertRaises(SaltInvocationError):
3918                 virt._handle_unit(key)
3919     def test_mixed_dict_and_list_as_profile_objects(self):
3920         """
3921         Test virt._nic_profile with mixed dictionaries and lists as input.
3922         """
3923         yaml_config = """
3924           virt:
3925              nic:
3926                 new-listonly-profile:
3927                    - bridge: br0
3928                      name: eth0
3929                    - model: virtio
3930                      name: eth1
3931                      source: test_network
3932                      type: network
3933                 new-list-with-legacy-names:
3934                    - eth0:
3935                         bridge: br0
3936                    - eth1:
3937                         bridge: br1
3938                         model: virtio
3939                 non-default-legacy-profile:
3940                    eth0:
3941                       bridge: br0
3942                    eth1:
3943                       bridge: br1
3944                       model: virtio
3945         """
3946         mock_config = salt.utils.yaml.safe_load(yaml_config)
3947         with patch.dict(
3948             salt.modules.config.__opts__, mock_config  # pylint: disable=no-member
3949         ):
3950             for name in mock_config["virt"]["nic"].keys():
3951                 profile = salt.modules.virt._nic_profile(name, "kvm")
3952                 self.assertEqual(len(profile), 2)
3953                 interface_attrs = profile[0]
3954                 self.assertIn("source", interface_attrs)
3955                 self.assertIn("type", interface_attrs)
3956                 self.assertIn("name", interface_attrs)
3957                 self.assertIn("model", interface_attrs)
3958                 self.assertEqual(interface_attrs["model"], "virtio")
3959     def test_get_xml(self):
3960         """
3961         Test virt.get_xml()
3962         """
3963         xml = """&lt;domain type='kvm' id='7'&gt;
3964               &lt;name&gt;test-vm&lt;/name&gt;
3965               &lt;devices&gt;
3966                 &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
3967                   &lt;listen type='address' address='0.0.0.0'/&gt;
3968                 &lt;/graphics&gt;
3969               &lt;/devices&gt;
3970             &lt;/domain&gt;
3971         """
3972         domain = self.set_mock_vm("test-vm", xml)
3973         self.assertEqual(xml, virt.get_xml("test-vm"))
3974         self.assertEqual(xml, virt.get_xml(domain))
3975     def test_get_loader(self):
3976         """
3977         Test virt.get_loader()
3978         """
3979         xml = """&lt;domain type='kvm' id='7'&gt;
3980               &lt;name&gt;test-vm&lt;/name&gt;
3981               &lt;os&gt;
3982                 &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
3983               &lt;/os&gt;
3984             &lt;/domain&gt;
3985         """
3986         self.set_mock_vm("test-vm", xml)
3987         loader = virt.get_loader("test-vm")
3988         self.assertEqual("/foo/bar", loader["path"])
3989         self.assertEqual("yes", loader["readonly"])
3990     def test_cpu_baseline(self):
3991         """
3992         Test virt.cpu_baseline()
3993         """
3994         capabilities_xml = dedent(
3995             """&lt;capabilities&gt;
3996                   &lt;host&gt;
3997                     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
3998                     &lt;cpu&gt;
3999                       &lt;arch&gt;x86_64&lt;/arch&gt;
4000                       &lt;vendor&gt;Intel&lt;/vendor&gt;
4001                     &lt;/cpu&gt;
4002                   &lt;/host&gt;
4003                 &lt;/capabilities&gt;"""
4004         )
4005         baseline_cpu_xml = b"""&lt;cpu match="exact" mode="custom"&gt;
4006                                   &lt;vendor&gt;Intel&lt;/vendor&gt;
4007                                 &lt;/cpu&gt;"""
4008         self.mock_conn.getCapabilities.return_value = capabilities_xml
4009         self.mock_conn.baselineCPU.return_value = baseline_cpu_xml
4010         self.assertMultiLineEqual(str(baseline_cpu_xml), str(virt.cpu_baseline()))
4011     def test_parse_qemu_img_info(self):
4012         """
4013         Make sure that qemu-img info output is properly parsed
4014         """
4015         qemu_infos = """[{
4016             "snapshots": [
4017                 {
4018                     "vm-clock-nsec": 0,
4019                     "name": "first-snap",
4020                     "date-sec": 1528877587,
4021                     "date-nsec": 380589000,
4022                     "vm-clock-sec": 0,
4023                     "id": "1",
4024                     "vm-state-size": 1234
4025                 },
4026                 {
4027                     "vm-clock-nsec": 0,
4028                     "name": "second snap",
4029                     "date-sec": 1528877592,
4030                     "date-nsec": 933509000,
4031                     "vm-clock-sec": 0,
4032                     "id": "2",
4033                     "vm-state-size": 4567
4034                 }
4035             ],
4036             "virtual-size": 25769803776,
4037             "filename": "/disks/test.qcow2",
4038             "cluster-size": 65536,
4039             "format": "qcow2",
4040             "actual-size": 217088,
4041             "format-specific": {
4042                 "type": "qcow2",
4043                 "data": {
4044                     "compat": "1.1",
4045                     "lazy-refcounts": false,
4046                     "refcount-bits": 16,
4047                     "corrupt": false
4048                 }
4049             },
4050             "full-backing-filename": "/disks/mybacking.qcow2",
4051             "backing-filename": "mybacking.qcow2",
4052             "dirty-flag": false
4053         },
4054         {
4055             "virtual-size": 25769803776,
4056             "filename": "/disks/mybacking.qcow2",
4057             "cluster-size": 65536,
4058             "format": "qcow2",
4059             "actual-size": 393744384,
4060             "format-specific": {
4061                 "type": "qcow2",
4062                 "data": {
4063                     "compat": "1.1",
4064                     "lazy-refcounts": false,
4065                     "refcount-bits": 16,
4066                     "corrupt": false
4067                 }
4068             },
4069             "full-backing-filename": "/disks/root.qcow2",
4070             "backing-filename": "root.qcow2",
4071             "dirty-flag": false
4072         },
4073         {
4074             "virtual-size": 25769803776,
4075             "filename": "/disks/root.qcow2",
4076             "cluster-size": 65536,
4077             "format": "qcow2",
4078             "actual-size": 196872192,
4079             "format-specific": {
4080                 "type": "qcow2",
4081                 "data": {
4082                     "compat": "1.1",
4083                     "lazy-refcounts": false,
4084                     "refcount-bits": 16,
4085                     "corrupt": false
4086                 }
4087             },
4088             "dirty-flag": false
4089         }]"""
4090         self.assertEqual(
4091             {
4092                 "file": "/disks/test.qcow2",
4093                 "file format": "qcow2",
4094                 "backing file": {
4095                     "file": "/disks/mybacking.qcow2",
4096                     "file format": "qcow2",
4097                     "disk size": 393744384,
4098                     "virtual size": 25769803776,
4099                     "cluster size": 65536,
4100                     "backing file": {
4101                         "file": "/disks/root.qcow2",
4102                         "file format": "qcow2",
4103                         "disk size": 196872192,
4104                         "virtual size": 25769803776,
4105                         "cluster size": 65536,
4106                     },
4107                 },
4108                 "disk size": 217088,
4109                 "virtual size": 25769803776,
4110                 "cluster size": 65536,
4111                 "snapshots": [
4112                     {
4113                         "id": "1",
4114                         "tag": "first-snap",
4115                         "vmsize": 1234,
4116                         "date": datetime.datetime.fromtimestamp(
4117                             float("{}.{}".format(1528877587, 380589000))
4118                         ).isoformat(),
4119                         "vmclock": "00:00:00",
4120                     },
4121                     {
4122                         "id": "2",
4123                         "tag": "second snap",
4124                         "vmsize": 4567,
4125                         "date": datetime.datetime.fromtimestamp(
4126                             float("{}.{}".format(1528877592, 933509000))
4127                         ).isoformat(),
4128                         "vmclock": "00:00:00",
4129                     },
4130                 ],
4131             },
4132             virt._parse_qemu_img_info(qemu_infos),
4133         )
4134     @patch("salt.modules.virt.stop", return_value=True)
4135     @patch("salt.modules.virt.undefine")
4136     @patch("os.remove")
4137     def test_purge_default(self, mock_remove, mock_undefine, mock_stop):
4138         """
4139         Test virt.purge() with default parameters
4140         """
4141         xml = """&lt;domain type='kvm' id='7'&gt;
4142               &lt;name&gt;test-vm&lt;/name&gt;
4143               &lt;devices&gt;
4144                 &lt;disk type='file' device='disk'&gt;
4145                 &lt;driver name='qemu' type='qcow2'/&gt;
4146                 &lt;source file='/disks/test.qcow2'/&gt;
4147                 &lt;target dev='vda' bus='virtio'/&gt;
4148               &lt;/disk&gt;
4149               &lt;disk type='file' device='cdrom'&gt;
4150                 &lt;driver name='qemu' type='raw'/&gt;
4151                 &lt;source file='/disks/test-cdrom.iso'/&gt;
4152                 &lt;target dev='hda' bus='ide'/&gt;
4153                 &lt;readonly/&gt;
4154               &lt;/disk&gt;
4155               &lt;/devices&gt;
4156             &lt;/domain&gt;
4157         """
4158         self.set_mock_vm("test-vm", xml)
4159         qemu_infos = """[{
4160             "virtual-size": 25769803776,
4161             "filename": "/disks/test.qcow2",
4162             "cluster-size": 65536,
4163             "format": "qcow2",
4164             "actual-size": 217088,
4165             "format-specific": {
4166                 "type": "qcow2",
4167                 "data": {
4168                     "compat": "1.1",
4169                     "lazy-refcounts": false,
4170                     "refcount-bits": 16,
4171                     "corrupt": false
4172                 }
4173             },
4174             "dirty-flag": false
4175         }]"""
4176         self.mock_popen.communicate.return_value = [qemu_infos, ""]
4177         self.mock_popen.returncode = 0
4178         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
4179             res = virt.purge("test-vm")
4180             self.assertTrue(res)
4181             mock_remove.assert_called_once()
4182             mock_remove.assert_any_call("/disks/test.qcow2")
4183     @patch("salt.modules.virt.stop", return_value=True)
4184     @patch("salt.modules.virt.undefine")
4185     def test_purge_volumes(self, mock_undefine, mock_stop):
4186         """
4187         Test virt.purge() with volume disks
4188         """
4189         xml = """&lt;domain type='kvm' id='7'&gt;
4190               &lt;name&gt;test-vm&lt;/name&gt;
4191               &lt;devices&gt;
4192                 &lt;disk type='volume' device='disk'&gt;
4193                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
4194                   &lt;source pool='default' volume='vm05_system'/&gt;
4195                   &lt;backingStore type='file' index='1'&gt;
4196                     &lt;format type='qcow2'/&gt;
4197                     &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
4198                     &lt;backingStore type='file' index='2'&gt;
4199                       &lt;format type='qcow2'/&gt;
4200                       &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
4201                       &lt;backingStore/&gt;
4202                     &lt;/backingStore&gt;
4203                   &lt;/backingStore&gt;
4204                   &lt;target dev='vda' bus='virtio'/&gt;
4205                   &lt;alias name='virtio-disk0'/&gt;
4206                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
4207                 &lt;/disk&gt;
4208               &lt;/devices&gt;
4209             &lt;/domain&gt;
4210         """
4211         self.set_mock_vm("test-vm", xml)
4212         pool_mock = MagicMock()
4213         pool_mock.storageVolLookupByName.return_value.info.return_value = [
4214             0,
4215             1234567,
4216             12345,
4217         ]
4218         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
4219             """
4220             &lt;volume type='file'&gt;
4221               &lt;name&gt;vm05_system&lt;/name&gt;
4222               &lt;target&gt;
4223                 &lt;path&gt;/var/lib/libvirt/images/vm05_system&lt;/path&gt;
4224                 &lt;format type='qcow2'/&gt;
4225               &lt;/target&gt;
4226               &lt;backingStore&gt;
4227                 &lt;path&gt;/var/lib/libvirt/images/vm04_system.qcow2&lt;/path&gt;
4228                 &lt;format type='qcow2'/&gt;
4229               &lt;/backingStore&gt;
4230             &lt;/volume&gt;
4231             """,
4232         ]
4233         pool_mock.listVolumes.return_value = ["vm05_system", "vm04_system.qcow2"]
4234         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
4235         self.mock_conn.listStoragePools.return_value = ["default"]
4236         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
4237             res = virt.purge("test-vm")
4238             self.assertTrue(res)
4239             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
4240     @patch("salt.modules.virt.stop", return_value=True)
4241     @patch("salt.modules.virt.undefine")
4242     def test_purge_rbd(self, mock_undefine, mock_stop):
4243         """
4244         Test virt.purge() with RBD disks
4245         """
4246         xml = """&lt;domain type='kvm' id='7'&gt;
4247               &lt;name&gt;test-vm&lt;/name&gt;
4248               &lt;devices&gt;
4249                 &lt;disk type="network" device="disk"&gt;
4250                   &lt;driver name='raw' type='qcow2'/&gt;
4251                   &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
4252                     &lt;host name='ses2.tf.local'/&gt;
4253                     &lt;host name='ses3.tf.local' port='1234'/&gt;
4254                     &lt;auth username='libvirt'&gt;
4255                       &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
4256                     &lt;/auth&gt;
4257                   &lt;/source&gt;
4258                   &lt;target dev='vdc' bus='virtio'/&gt;
4259                   &lt;alias name='virtio-disk2'/&gt;
4260                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
4261                 &lt;/disk&gt;
4262               &lt;/devices&gt;
4263             &lt;/domain&gt;
4264         """
4265         self.set_mock_vm("test-vm", xml)
4266         pool_mock = MagicMock()
4267         pool_mock.storageVolLookupByName.return_value.info.return_value = [
4268             0,
4269             1234567,
4270             12345,
4271         ]
4272         pool_mock.XMLDesc.return_value = """
4273         &lt;pool type='rbd'&gt;
4274           &lt;name&gt;test-ses&lt;/name&gt;
4275           &lt;source&gt;
4276             &lt;host name='ses2.tf.local'/&gt;
4277             &lt;name&gt;libvirt-pool&lt;/name&gt;
4278             &lt;auth type='ceph' username='libvirt'&gt;
4279               &lt;secret usage='pool_test-ses'/&gt;
4280             &lt;/auth&gt;
4281           &lt;/source&gt;
4282         &lt;/pool&gt;
4283         """
4284         pool_mock.name.return_value = "test-ses"
4285         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
4286             """
4287             &lt;volume type='network'&gt;
4288               &lt;name&gt;my_vm_data2&lt;/name&gt;
4289               &lt;source&gt;
4290               &lt;/source&gt;
4291               &lt;capacity unit='bytes'&gt;536870912&lt;/capacity&gt;
4292               &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
4293               &lt;target&gt;
4294                 &lt;path&gt;libvirt-pool/my_vm_data2&lt;/path&gt;
4295                 &lt;format type='raw'/&gt;
4296               &lt;/target&gt;
4297             &lt;/volume&gt;
4298             """,
4299         ]
4300         pool_mock.listVolumes.return_value = ["my_vm_data2"]
4301         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4302         self.mock_conn.listStoragePools.return_value = ["test-ses"]
4303         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
4304         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
4305             res = virt.purge("test-vm")
4306             self.assertTrue(res)
4307             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
4308     @patch("salt.modules.virt.stop", return_value=True)
4309     @patch("salt.modules.virt.undefine")
4310     @patch("os.remove")
4311     def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
4312         """
4313         Test virt.purge(removables=True)
4314         """
4315         xml = """&lt;domain type="kvm" id="7"&gt;
4316               &lt;name&gt;test-vm&lt;/name&gt;
4317               &lt;devices&gt;
4318                 &lt;disk type='file' device='disk'&gt;
4319                 &lt;driver name='qemu' type='qcow2'/&gt;
4320                 &lt;source file='/disks/test.qcow2'/&gt;
4321                 &lt;target dev='vda' bus='virtio'/&gt;
4322               &lt;/disk&gt;
4323               &lt;disk type='file' device='cdrom'&gt;
4324                 &lt;driver name='qemu' type='raw'/&gt;
4325                 &lt;source file='/disks/test-cdrom.iso'/&gt;
4326                 &lt;target dev='hda' bus='ide'/&gt;
4327                 &lt;readonly/&gt;
4328               &lt;/disk&gt;
4329               &lt;disk type='file' device='floppy'&gt;
4330                 &lt;driver name='qemu' type='raw'/&gt;
4331                 &lt;source file='/disks/test-floppy.iso'/&gt;
4332                 &lt;target dev='hdb' bus='ide'/&gt;
4333                 &lt;readonly/&gt;
4334               &lt;/disk&gt;
4335               &lt;/devices&gt;
4336             &lt;/domain&gt;
4337         """
4338         self.set_mock_vm("test-vm", xml)
4339         qemu_infos = """[{
4340             "virtual-size": 25769803776,
4341             "filename": "/disks/test.qcow2",
4342             "cluster-size": 65536,
4343             "format": "qcow2",
4344             "actual-size": 217088,
4345             "format-specific": {
4346                 "type": "qcow2",
4347                 "data": {
4348                     "compat": "1.1",
4349                     "lazy-refcounts": false,
4350                     "refcount-bits": 16,
4351                     "corrupt": false
4352                 }
4353             },
4354             "dirty-flag": false
4355         }]"""
4356         self.mock_popen.communicate.return_value = [qemu_infos, ""]
4357         self.mock_popen.returncode = 0
4358         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
4359             res = virt.purge("test-vm", removables=True)
4360             self.assertTrue(res)
4361             mock_remove.assert_any_call("/disks/test.qcow2")
4362             mock_remove.assert_any_call("/disks/test-cdrom.iso")
4363     def test_capabilities(self):
4364         """
4365         Test the virt.capabilities parsing
4366         """
4367         xml = """
4368 &lt;capabilities&gt;
4369   &lt;host&gt;
4370     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
4371     &lt;cpu&gt;
4372       &lt;arch&gt;x86_64&lt;/arch&gt;
4373       &lt;model&gt;Nehalem&lt;/model&gt;
4374       &lt;vendor&gt;Intel&lt;/vendor&gt;
4375       &lt;microcode version='25'/&gt;
4376       &lt;topology sockets='1' cores='4' threads='2'/&gt;
4377       &lt;feature name='vme'/&gt;
4378       &lt;feature name='ds'/&gt;
4379       &lt;feature name='acpi'/&gt;
4380       &lt;pages unit='KiB' size='4'/&gt;
4381       &lt;pages unit='KiB' size='2048'/&gt;
4382     &lt;/cpu&gt;
4383     &lt;power_management&gt;
4384       &lt;suspend_mem/&gt;
4385       &lt;suspend_disk/&gt;
4386       &lt;suspend_hybrid/&gt;
4387     &lt;/power_management&gt;
4388     &lt;migration_features&gt;
4389       &lt;live/&gt;
4390       &lt;uri_transports&gt;
4391         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
4392         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
4393       &lt;/uri_transports&gt;
4394     &lt;/migration_features&gt;
4395     &lt;topology&gt;
4396       &lt;cells num='1'&gt;
4397         &lt;cell id='0'&gt;
4398           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
4399           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
4400           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
4401           &lt;distances&gt;
4402             &lt;sibling id='0' value='10'/&gt;
4403           &lt;/distances&gt;
4404           &lt;cpus num='8'&gt;
4405             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
4406             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
4407             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
4408             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
4409             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
4410             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
4411             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
4412             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
4413           &lt;/cpus&gt;
4414         &lt;/cell&gt;
4415       &lt;/cells&gt;
4416     &lt;/topology&gt;
4417     &lt;cache&gt;
4418       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
4419     &lt;/cache&gt;
4420     &lt;secmodel&gt;
4421       &lt;model&gt;apparmor&lt;/model&gt;
4422       &lt;doi&gt;0&lt;/doi&gt;
4423     &lt;/secmodel&gt;
4424     &lt;secmodel&gt;
4425       &lt;model&gt;dac&lt;/model&gt;
4426       &lt;doi&gt;0&lt;/doi&gt;
4427       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
4428       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
4429     &lt;/secmodel&gt;
4430   &lt;/host&gt;
4431   &lt;guest&gt;
4432     &lt;os_type&gt;hvm&lt;/os_type&gt;
4433     &lt;arch name='i686'&gt;
4434       &lt;wordsize&gt;32&lt;/wordsize&gt;
4435       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
4436       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4437       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4438       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4439       &lt;domain type='qemu'/&gt;
4440       &lt;domain type='kvm'&gt;
4441         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4442         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4443         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4444         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4445       &lt;/domain&gt;
4446     &lt;/arch&gt;
4447     &lt;features&gt;
4448       &lt;cpuselection/&gt;
4449       &lt;deviceboot/&gt;
4450       &lt;disksnapshot default='on' toggle='no'/&gt;
4451       &lt;acpi default='off' toggle='yes'/&gt;
4452       &lt;apic default='on' toggle='no'/&gt;
4453       &lt;pae/&gt;
4454       &lt;nonpae/&gt;
4455     &lt;/features&gt;
4456   &lt;/guest&gt;
4457   &lt;guest&gt;
4458     &lt;os_type&gt;hvm&lt;/os_type&gt;
4459     &lt;arch name='x86_64'&gt;
4460       &lt;wordsize&gt;64&lt;/wordsize&gt;
4461       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4462       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4463       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4464       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4465       &lt;domain type='qemu'/&gt;
4466       &lt;domain type='kvm'&gt;
4467         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4468         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4469         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4470         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4471       &lt;/domain&gt;
4472     &lt;/arch&gt;
4473     &lt;features&gt;
4474       &lt;cpuselection/&gt;
4475       &lt;deviceboot/&gt;
4476       &lt;disksnapshot default='on' toggle='no'/&gt;
4477       &lt;acpi default='on' toggle='yes'/&gt;
4478       &lt;apic default='off' toggle='no'/&gt;
4479     &lt;/features&gt;
4480   &lt;/guest&gt;
4481   &lt;guest&gt;
4482     &lt;os_type&gt;xen&lt;/os_type&gt;
4483     &lt;arch name='x86_64'&gt;
4484       &lt;wordsize&gt;64&lt;/wordsize&gt;
4485       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4486       &lt;machine&gt;xenpv&lt;/machine&gt;
4487       &lt;domain type='xen'/&gt;
4488     &lt;/arch&gt;
4489   &lt;/guest&gt;
4490 &lt;/capabilities&gt;
4491         """
4492         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
4493         caps = virt.capabilities()
4494         expected = {
4495             "host": {
4496                 "uuid": "44454c4c-3400-105a-8033-b3c04f4b344a",
4497                 "cpu": {
4498                     "arch": "x86_64",
4499                     "model": "Nehalem",
4500                     "vendor": "Intel",
4501                     "microcode": "25",
4502                     "sockets": 1,
4503                     "cores": 4,
4504                     "threads": 2,
4505                     "features": ["vme", "ds", "acpi"],
4506                     "pages": [{"size": "4 KiB"}, {"size": "2048 KiB"}],
4507                 },
4508                 "power_management": ["suspend_mem", "suspend_disk", "suspend_hybrid"],
4509                 "migration": {"live": True, "transports": ["tcp", "rdma"]},
4510                 "topology": {
4511                     "cells": [
4512                         {
4513                             "id": 0,
4514                             "memory": "12367120 KiB",
4515                             "pages": [
4516                                 {"size": "4 KiB", "available": 3091780},
4517                                 {"size": "2048 KiB", "available": 0},
4518                             ],
4519                             "distances": {0: 10},
4520                             "cpus": [
4521                                 {
4522                                     "id": 0,
4523                                     "socket_id": 0,
4524                                     "core_id": 0,
4525                                     "siblings": "0,4",
4526                                 },
4527                                 {
4528                                     "id": 1,
4529                                     "socket_id": 0,
4530                                     "core_id": 1,
4531                                     "siblings": "1,5",
4532                                 },
4533                                 {
4534                                     "id": 2,
4535                                     "socket_id": 0,
4536                                     "core_id": 2,
4537                                     "siblings": "2,6",
4538                                 },
4539                                 {
4540                                     "id": 3,
4541                                     "socket_id": 0,
4542                                     "core_id": 3,
4543                                     "siblings": "3,7",
4544                                 },
4545                                 {
4546                                     "id": 4,
4547                                     "socket_id": 0,
4548                                     "core_id": 0,
4549                                     "siblings": "0,4",
4550                                 },
4551                                 {
4552                                     "id": 5,
4553                                     "socket_id": 0,
4554                                     "core_id": 1,
4555                                     "siblings": "1,5",
4556                                 },
4557                                 {
4558                                     "id": 6,
4559                                     "socket_id": 0,
4560                                     "core_id": 2,
4561                                     "siblings": "2,6",
4562                                 },
4563                                 {
4564                                     "id": 7,
4565                                     "socket_id": 0,
4566                                     "core_id": 3,
4567                                     "siblings": "3,7",
4568                                 },
4569                             ],
4570                         }
4571                     ]
4572                 },
4573                 "cache": {
4574                     "banks": [
4575                         {
4576                             "id": 0,
4577                             "level": 3,
4578                             "type": "both",
4579                             "size": "8 MiB",
4580                             "cpus": "0-7",
4581                         }
4582                     ]
4583                 },
4584                 "security": [
4585                     {"model": "apparmor", "doi": "0", "baselabels": []},
4586                     {
4587                         "model": "dac",
4588                         "doi": "0",
4589                         "baselabels": [
4590                             {"type": "kvm", "label": "+487:+486"},
4591                             {"type": "qemu", "label": "+487:+486"},
4592                         ],
4593                     },
4594                 ],
4595             },
4596             "guests": [
4597                 {
4598                     "os_type": "hvm",
4599                     "arch": {
4600                         "name": "i686",
4601                         "wordsize": 32,
4602                         "emulator": "/usr/bin/qemu-system-i386",
4603                         "machines": {
4604                             "pc-i440fx-2.6": {
4605                                 "maxcpus": 255,
4606                                 "alternate_names": ["pc"],
4607                             },
4608                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4609                         },
4610                         "domains": {
4611                             "qemu": {"emulator": None, "machines": {}},
4612                             "kvm": {
4613                                 "emulator": "/usr/bin/qemu-kvm",
4614                                 "machines": {
4615                                     "pc-i440fx-2.6": {
4616                                         "maxcpus": 255,
4617                                         "alternate_names": ["pc"],
4618                                     },
4619                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4620                                 },
4621                             },
4622                         },
4623                     },
4624                     "features": {
4625                         "cpuselection": {"default": True, "toggle": False},
4626                         "deviceboot": {"default": True, "toggle": False},
4627                         "disksnapshot": {"default": True, "toggle": False},
4628                         "acpi": {"default": False, "toggle": True},
4629                         "apic": {"default": True, "toggle": False},
4630                         "pae": {"default": True, "toggle": False},
4631                         "nonpae": {"default": True, "toggle": False},
4632                     },
4633                 },
4634                 {
4635                     "os_type": "hvm",
4636                     "arch": {
4637                         "name": "x86_64",
4638                         "wordsize": 64,
4639                         "emulator": "/usr/bin/qemu-system-x86_64",
4640                         "machines": {
4641                             "pc-i440fx-2.6": {
4642                                 "maxcpus": 255,
4643                                 "alternate_names": ["pc"],
4644                             },
4645                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4646                         },
4647                         "domains": {
4648                             "qemu": {"emulator": None, "machines": {}},
4649                             "kvm": {
4650                                 "emulator": "/usr/bin/qemu-kvm",
4651                                 "machines": {
4652                                     "pc-i440fx-2.6": {
4653                                         "maxcpus": 255,
4654                                         "alternate_names": ["pc"],
4655                                     },
4656                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4657                                 },
4658                             },
4659                         },
4660                     },
4661                     "features": {
4662                         "cpuselection": {"default": True, "toggle": False},
4663                         "deviceboot": {"default": True, "toggle": False},
4664                         "disksnapshot": {"default": True, "toggle": False},
4665                         "acpi": {"default": True, "toggle": True},
4666                         "apic": {"default": False, "toggle": False},
4667                     },
4668                 },
4669                 {
4670                     "os_type": "xen",
4671                     "arch": {
4672                         "name": "x86_64",
4673                         "wordsize": 64,
4674                         "emulator": "/usr/bin/qemu-system-x86_64",
4675                         "machines": {"xenpv": {"alternate_names": []}},
4676                         "domains": {"xen": {"emulator": None, "machines": {}}},
4677                     },
4678                 },
4679             ],
4680         }
4681         self.assertEqual(expected, caps)
4682     def test_domain_capabilities(self):
4683         """
4684         Test the virt.domain_capabilities parsing
4685         """
4686         xml = """
4687 &lt;domainCapabilities&gt;
4688   &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
4689   &lt;domain&gt;kvm&lt;/domain&gt;
4690   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4691   &lt;arch&gt;aarch64&lt;/arch&gt;
4692   &lt;vcpu max='255'/&gt;
4693   &lt;iothreads supported='yes'/&gt;
4694   &lt;os supported='yes'&gt;
4695     &lt;loader supported='yes'&gt;
4696       &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
4697       &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
4698       &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
4699       &lt;enum name='type'&gt;
4700         &lt;value&gt;rom&lt;/value&gt;
4701         &lt;value&gt;pflash&lt;/value&gt;
4702       &lt;/enum&gt;
4703       &lt;enum name='readonly'&gt;
4704         &lt;value&gt;yes&lt;/value&gt;
4705         &lt;value&gt;no&lt;/value&gt;
4706       &lt;/enum&gt;
4707     &lt;/loader&gt;
4708   &lt;/os&gt;
4709   &lt;cpu&gt;
4710     &lt;mode name='host-passthrough' supported='yes'/&gt;
4711     &lt;mode name='host-model' supported='yes'&gt;
4712       &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
4713       &lt;vendor&gt;ACME&lt;/vendor&gt;
4714       &lt;feature policy='require' name='vme'/&gt;
4715       &lt;feature policy='require' name='ss'/&gt;
4716     &lt;/mode&gt;
4717     &lt;mode name='custom' supported='yes'&gt;
4718       &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
4719       &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
4720       &lt;model usable='no'&gt;arm1136&lt;/model&gt;
4721     &lt;/mode&gt;
4722   &lt;/cpu&gt;
4723   &lt;devices&gt;
4724     &lt;disk supported='yes'&gt;
4725       &lt;enum name='diskDevice'&gt;
4726         &lt;value&gt;disk&lt;/value&gt;
4727         &lt;value&gt;cdrom&lt;/value&gt;
4728         &lt;value&gt;floppy&lt;/value&gt;
4729         &lt;value&gt;lun&lt;/value&gt;
4730       &lt;/enum&gt;
4731       &lt;enum name='bus'&gt;
4732         &lt;value&gt;fdc&lt;/value&gt;
4733         &lt;value&gt;scsi&lt;/value&gt;
4734         &lt;value&gt;virtio&lt;/value&gt;
4735         &lt;value&gt;usb&lt;/value&gt;
4736         &lt;value&gt;sata&lt;/value&gt;
4737       &lt;/enum&gt;
4738     &lt;/disk&gt;
4739     &lt;graphics supported='yes'&gt;
4740       &lt;enum name='type'&gt;
4741         &lt;value&gt;sdl&lt;/value&gt;
4742         &lt;value&gt;vnc&lt;/value&gt;
4743       &lt;/enum&gt;
4744     &lt;/graphics&gt;
4745     &lt;video supported='yes'&gt;
4746       &lt;enum name='modelType'&gt;
4747         &lt;value&gt;vga&lt;/value&gt;
4748         &lt;value&gt;virtio&lt;/value&gt;
4749       &lt;/enum&gt;
4750     &lt;/video&gt;
4751     &lt;hostdev supported='yes'&gt;
4752       &lt;enum name='mode'&gt;
4753         &lt;value&gt;subsystem&lt;/value&gt;
4754       &lt;/enum&gt;
4755       &lt;enum name='startupPolicy'&gt;
4756         &lt;value&gt;default&lt;/value&gt;
4757         &lt;value&gt;mandatory&lt;/value&gt;
4758         &lt;value&gt;requisite&lt;/value&gt;
4759         &lt;value&gt;optional&lt;/value&gt;
4760       &lt;/enum&gt;
4761       &lt;enum name='subsysType'&gt;
4762         &lt;value&gt;usb&lt;/value&gt;
4763         &lt;value&gt;pci&lt;/value&gt;
4764         &lt;value&gt;scsi&lt;/value&gt;
4765       &lt;/enum&gt;
4766       &lt;enum name='capsType'/&gt;
4767       &lt;enum name='pciBackend'&gt;
4768         &lt;value&gt;default&lt;/value&gt;
4769         &lt;value&gt;kvm&lt;/value&gt;
4770         &lt;value&gt;vfio&lt;/value&gt;
4771       &lt;/enum&gt;
4772     &lt;/hostdev&gt;
4773   &lt;/devices&gt;
4774   &lt;features&gt;
4775     &lt;gic supported='yes'&gt;
4776       &lt;enum name='version'&gt;
4777         &lt;value&gt;3&lt;/value&gt;
4778       &lt;/enum&gt;
4779     &lt;/gic&gt;
4780     &lt;vmcoreinfo supported='yes'/&gt;
4781   &lt;/features&gt;
4782 &lt;/domainCapabilities&gt;
4783         """
4784         self.mock_conn.getDomainCapabilities.return_value = (
4785             xml  # pylint: disable=no-member
4786         )
4787         caps = virt.domain_capabilities()
4788         expected = {
4789             "emulator": "/usr/bin/qemu-system-aarch64",
4790             "domain": "kvm",
4791             "machine": "virt-2.12",
4792             "arch": "aarch64",
4793             "max_vcpus": 255,
4794             "iothreads": True,
4795             "os": {
4796                 "loader": {
4797                     "type": ["rom", "pflash"],
4798                     "readonly": ["yes", "no"],
4799                     "values": [
4800                         "/usr/share/AAVMF/AAVMF_CODE.fd",
4801                         "/usr/share/AAVMF/AAVMF32_CODE.fd",
4802                         "/usr/share/OVMF/OVMF_CODE.fd",
4803                     ],
4804                 }
4805             },
4806             "cpu": {
4807                 "host-passthrough": True,
4808                 "host-model": {
4809                     "model": {"name": "sample-cpu", "fallback": "forbid"},
4810                     "vendor": "ACME",
4811                     "features": {"vme": "require", "ss": "require"},
4812                 },
4813                 "custom": {
4814                     "models": {"pxa262": "unknown", "pxa270-a0": "yes", "arm1136": "no"}
4815                 },
4816             },
4817             "devices": {
4818                 "disk": {
4819                     "diskDevice": ["disk", "cdrom", "floppy", "lun"],
4820                     "bus": ["fdc", "scsi", "virtio", "usb", "sata"],
4821                 },
4822                 "graphics": {"type": ["sdl", "vnc"]},
4823                 "video": {"modelType": ["vga", "virtio"]},
4824                 "hostdev": {
4825                     "mode": ["subsystem"],
4826                     "startupPolicy": ["default", "mandatory", "requisite", "optional"],
4827                     "subsysType": ["usb", "pci", "scsi"],
4828                     "capsType": [],
4829                     "pciBackend": ["default", "kvm", "vfio"],
4830                 },
4831             },
4832             "features": {"gic": {"version": ["3"]}, "vmcoreinfo": {}},
4833         }
4834         self.assertEqual(expected, caps)
4835     def test_all_capabilities(self):
4836         """
4837         Test the virt.domain_capabilities default output
4838         """
4839         domainXml = """
4840 &lt;domainCapabilities&gt;
4841   &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
4842   &lt;domain&gt;kvm&lt;/domain&gt;
4843   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4844   &lt;arch&gt;x86_64&lt;/arch&gt;
4845   &lt;vcpu max='255'/&gt;
4846   &lt;iothreads supported='yes'/&gt;
4847 &lt;/domainCapabilities&gt;
4848         """
4849         hostXml = """
4850 &lt;capabilities&gt;
4851   &lt;host&gt;
4852     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
4853     &lt;cpu&gt;
4854       &lt;arch&gt;x86_64&lt;/arch&gt;
4855       &lt;model&gt;Nehalem&lt;/model&gt;
4856       &lt;vendor&gt;Intel&lt;/vendor&gt;
4857       &lt;microcode version='25'/&gt;
4858       &lt;topology sockets='1' cores='4' threads='2'/&gt;
4859     &lt;/cpu&gt;
4860   &lt;/host&gt;
4861   &lt;guest&gt;
4862     &lt;os_type&gt;hvm&lt;/os_type&gt;
4863     &lt;arch name='x86_64'&gt;
4864       &lt;wordsize&gt;64&lt;/wordsize&gt;
4865       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4866       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4867       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4868       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4869       &lt;domain type='qemu'/&gt;
4870       &lt;domain type='kvm'&gt;
4871         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4872         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4873         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4874         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4875       &lt;/domain&gt;
4876     &lt;/arch&gt;
4877   &lt;/guest&gt;
4878 &lt;/capabilities&gt;
4879         """
4880         self.mock_conn.getCapabilities.return_value = hostXml
4881         self.mock_conn.getDomainCapabilities.side_effect = [
4882             domainXml,
4883             domainXml.replace("&lt;domain&gt;kvm", "&lt;domain&gt;qemu"),
4884         ]
4885         caps = virt.all_capabilities()
4886         self.assertEqual(
4887             "44454c4c-3400-105a-8033-b3c04f4b344a", caps["host"]["host"]["uuid"]
4888         )
4889         self.assertEqual(
4890             {"qemu", "kvm"},
4891             {domainCaps["domain"] for domainCaps in caps["domains"]},
4892         )
4893         self.assertEqual(
4894             {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
4895             {
4896                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "kvm"),
4897                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "qemu"),
4898             },
4899         )
4900     def test_network_tag(self):
4901         """
4902         Test virt._get_net_xml() with VLAN tag
4903         """
4904         xml_data = virt._gen_net_xml("network", "main", "bridge", "openvswitch", 1001)
4905         root = ET.fromstring(xml_data)
4906         self.assertEqual(root.find("name").text, "network")
4907         self.assertEqual(root.find("bridge").attrib["name"], "main")
4908         self.assertEqual(root.find("forward").attrib["mode"], "bridge")
4909         self.assertEqual(root.find("virtualport").attrib["type"], "openvswitch")
4910         self.assertEqual(root.find("vlan/tag").attrib["id"], "1001")
4911     def test_list_networks(self):
4912         """
4913         Test virt.list_networks()
4914         """
4915         names = ["net1", "default", "net2"]
4916         net_mocks = [MagicMock(), MagicMock(), MagicMock()]
4917         for i, value in enumerate(names):
4918             net_mocks[i].name.return_value = value
4919         self.mock_conn.listAllNetworks.return_value = (
4920             net_mocks  # pylint: disable=no-member
4921         )
4922         actual = virt.list_networks()
4923         self.assertEqual(names, actual)
4924     def test_network_info(self):
4925         """
4926         Test virt.network_info()
4927         """
4928         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4929         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4930         net_mock = MagicMock()
4931         net_mock.name.return_value = "foo"
4932         net_mock.UUIDString.return_value = "some-uuid"
4933         net_mock.bridgeName.return_value = "br0"
4934         net_mock.autostart.return_value = True
4935         net_mock.isActive.return_value = False
4936         net_mock.isPersistent.return_value = True
4937         net_mock.DHCPLeases.return_value = [
4938             {
4939                 "iface": "virbr0",
4940                 "expirytime": 1527757552,
4941                 "type": 0,
4942                 "mac": "52:54:00:01:71:bd",
4943                 "ipaddr": "192.168.122.45",
4944                 "prefix": 24,
4945                 "hostname": "py3-test",
4946                 "clientid": "01:52:54:00:01:71:bd",
4947                 "iaid": None,
4948             }
4949         ]
4950         self.mock_conn.listAllNetworks.return_value = [net_mock]
4951         net = virt.network_info("foo")
4952         self.assertEqual(
4953             {
4954                 "foo": {
4955                     "uuid": "some-uuid",
4956                     "bridge": "br0",
4957                     "autostart": True,
4958                     "active": False,
4959                     "persistent": True,
4960                     "leases": [
4961                         {
4962                             "iface": "virbr0",
4963                             "expirytime": 1527757552,
4964                             "type": "ipv4",
4965                             "mac": "52:54:00:01:71:bd",
4966                             "ipaddr": "192.168.122.45",
4967                             "prefix": 24,
4968                             "hostname": "py3-test",
4969                             "clientid": "01:52:54:00:01:71:bd",
4970                             "iaid": None,
4971                         }
4972                     ],
4973                 }
4974             },
4975             net,
4976         )
4977     def test_network_info_all(self):
4978         """
4979         Test virt.network_info()
4980         """
4981         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4982         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4983         net_mocks = []
4984         for i in range(2):
4985             net_mock = MagicMock()
4986             net_mock.name.return_value = "net{}".format(i)
4987             net_mock.UUIDString.return_value = "some-uuid"
4988             net_mock.bridgeName.return_value = "br{}".format(i)
4989             net_mock.autostart.return_value = True
4990             net_mock.isActive.return_value = False
4991             net_mock.isPersistent.return_value = True
4992             net_mock.DHCPLeases.return_value = []
4993             net_mocks.append(net_mock)
4994         self.mock_conn.listAllNetworks.return_value = net_mocks
4995         net = virt.network_info()
4996         self.assertEqual(
4997             {
4998                 "net0": {
4999                     "uuid": "some-uuid",
5000                     "bridge": "br0",
5001                     "autostart": True,
5002                     "active": False,
5003                     "persistent": True,
5004                     "leases": [],
5005                 },
5006                 "net1": {
5007                     "uuid": "some-uuid",
5008                     "bridge": "br1",
5009                     "autostart": True,
5010                     "active": False,
5011                     "persistent": True,
5012                     "leases": [],
5013                 },
5014             },
5015             net,
5016         )
5017     def test_network_info_notfound(self):
5018         """
5019         Test virt.network_info() when the network can't be found
5020         """
5021         self.mock_conn.listAllNetworks.return_value = []
5022         net = virt.network_info("foo")
5023         self.assertEqual({}, net)
5024     def test_network_get_xml(self):
5025         """
5026         Test virt.network_get_xml
5027         """
5028         network_mock = MagicMock()
5029         network_mock.XMLDesc.return_value = "&lt;net&gt;Raw XML&lt;/net&gt;"
5030         self.mock_conn.networkLookupByName.return_value = network_mock
5031         self.assertEqual("&lt;net&gt;Raw XML&lt;/net&gt;", virt.network_get_xml("default"))
5032     def test_pool(self):
5033         """
5034         Test virt._gen_pool_xml()
5035         """
5036         xml_data = virt._gen_pool_xml("pool", "logical", "/dev/base")
5037         root = ET.fromstring(xml_data)
5038         self.assertEqual(root.find("name").text, "pool")
5039         self.assertEqual(root.attrib["type"], "logical")
5040         self.assertEqual(root.find("target/path").text, "/dev/base")
5041     def test_pool_with_source(self):
5042         """
5043         Test virt._gen_pool_xml() with a source device
5044         """
5045         xml_data = virt._gen_pool_xml(
5046             "pool", "logical", "/dev/base", source_devices=[{"path": "/dev/sda"}]
5047         )
5048         root = ET.fromstring(xml_data)
5049         self.assertEqual(root.find("name").text, "pool")
5050         self.assertEqual(root.attrib["type"], "logical")
5051         self.assertEqual(root.find("target/path").text, "/dev/base")
5052         self.assertEqual(root.find("source/device").attrib["path"], "/dev/sda")
5053     def test_pool_with_scsi(self):
5054         """
5055         Test virt._gen_pool_xml() with a SCSI source
5056         """
5057         xml_data = virt._gen_pool_xml(
5058             "pool",
5059             "scsi",
5060             "/dev/disk/by-path",
5061             source_devices=[{"path": "/dev/sda"}],
5062             source_adapter={
5063                 "type": "scsi_host",
5064                 "parent_address": {
5065                     "unique_id": 5,
5066                     "address": {
5067                         "domain": "0x0000",
5068                         "bus": "0x00",
5069                         "slot": "0x1f",
5070                         "function": "0x2",
5071                     },
5072                 },
5073             },
5074             source_name="srcname",
5075         )
5076         root = ET.fromstring(xml_data)
5077         self.assertEqual(root.find("name").text, "pool")
5078         self.assertEqual(root.attrib["type"], "scsi")
5079         self.assertEqual(root.find("target/path").text, "/dev/disk/by-path")
5080         self.assertEqual(root.find("source/device"), None)
5081         self.assertEqual(root.find("source/name"), None)
5082         self.assertEqual(root.find("source/adapter").attrib["type"], "scsi_host")
5083         self.assertEqual(
5084             root.find("source/adapter/parentaddr").attrib["unique_id"], "5"
5085         )
5086         self.assertEqual(
5087             root.find("source/adapter/parentaddr/address").attrib["domain"], "0x0000"
5088         )
5089         self.assertEqual(
5090             root.find("source/adapter/parentaddr/address").attrib["bus"], "0x00"
5091         )
5092         self.assertEqual(
5093             root.find("source/adapter/parentaddr/address").attrib["slot"], "0x1f"
5094         )
5095         self.assertEqual(
5096             root.find("source/adapter/parentaddr/address").attrib["function"], "0x2"
5097         )
5098     def test_pool_with_rbd(self):
5099         """
5100         Test virt._gen_pool_xml() with an RBD source
5101         """
5102         xml_data = virt._gen_pool_xml(
5103             "pool",
5104             "rbd",
5105             source_devices=[{"path": "/dev/sda"}],
5106             source_hosts=["1.2.3.4", "my.ceph.monitor:69"],
5107             source_auth={
5108                 "type": "ceph",
5109                 "username": "admin",
5110                 "secret": {"type": "uuid", "value": "someuuid"},
5111             },
5112             source_name="srcname",
5113             source_adapter={"type": "scsi_host", "name": "host0"},
5114             source_dir="/some/dir",
5115             source_format="fmt",
5116         )
5117         root = ET.fromstring(xml_data)
5118         self.assertEqual(root.find("name").text, "pool")
5119         self.assertEqual(root.attrib["type"], "rbd")
5120         self.assertEqual(root.find("target"), None)
5121         self.assertEqual(root.find("source/device"), None)
5122         self.assertEqual(root.find("source/name").text, "srcname")
5123         self.assertEqual(root.find("source/adapter"), None)
5124         self.assertEqual(root.find("source/dir"), None)
5125         self.assertEqual(root.find("source/format"), None)
5126         self.assertEqual(root.findall("source/host")[0].attrib["name"], "1.2.3.4")
5127         self.assertTrue("port" not in root.findall("source/host")[0].attrib)
5128         self.assertEqual(
5129             root.findall("source/host")[1].attrib["name"], "my.ceph.monitor"
5130         )
5131         self.assertEqual(root.findall("source/host")[1].attrib["port"], "69")
5132         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
5133         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
5134         self.assertEqual(root.find("source/auth/secret").attrib["uuid"], "someuuid")
5135     def test_pool_with_netfs(self):
5136         """
5137         Test virt._gen_pool_xml() with a netfs source
5138         """
5139         xml_data = virt._gen_pool_xml(
5140             "pool",
5141             "netfs",
5142             target="/path/to/target",
5143             permissions={
5144                 "mode": "0770",
5145                 "owner": 1000,
5146                 "group": 100,
5147                 "label": "seclabel",
5148             },
5149             source_devices=[{"path": "/dev/sda"}],
5150             source_hosts=["nfs.host"],
5151             source_name="srcname",
5152             source_adapter={"type": "scsi_host", "name": "host0"},
5153             source_dir="/some/dir",
5154             source_format="nfs",
5155         )
5156         root = ET.fromstring(xml_data)
5157         self.assertEqual(root.find("name").text, "pool")
5158         self.assertEqual(root.attrib["type"], "netfs")
5159         self.assertEqual(root.find("target/path").text, "/path/to/target")
5160         self.assertEqual(root.find("target/permissions/mode").text, "0770")
5161         self.assertEqual(root.find("target/permissions/owner").text, "1000")
5162         self.assertEqual(root.find("target/permissions/group").text, "100")
5163         self.assertEqual(root.find("target/permissions/label").text, "seclabel")
5164         self.assertEqual(root.find("source/device"), None)
5165         self.assertEqual(root.find("source/name"), None)
5166         self.assertEqual(root.find("source/adapter"), None)
5167         self.assertEqual(root.find("source/dir").attrib["path"], "/some/dir")
5168         self.assertEqual(root.find("source/format").attrib["type"], "nfs")
5169         self.assertEqual(root.find("source/host").attrib["name"], "nfs.host")
5170         self.assertEqual(root.find("source/auth"), None)
5171     def test_pool_with_iscsi_direct(self):
5172         """
5173         Test virt._gen_pool_xml() with a iscsi-direct source
5174         """
5175         xml_data = virt._gen_pool_xml(
5176             "pool",
5177             "iscsi-direct",
5178             source_hosts=["iscsi.example.com"],
5179             source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
5180             source_initiator="iqn.2013-06.com.example:iscsi-initiator",
5181         )
5182         root = ET.fromstring(xml_data)
5183         self.assertEqual(root.find("name").text, "pool")
5184         self.assertEqual(root.attrib["type"], "iscsi-direct")
5185         self.assertEqual(root.find("target"), None)
5186         self.assertEqual(
5187             root.find("source/device").attrib["path"],
5188             "iqn.2013-06.com.example:iscsi-pool",
5189         )
5190         self.assertEqual(
5191             root.findall("source/host")[0].attrib["name"], "iscsi.example.com"
5192         )
5193         self.assertEqual(
5194             root.find("source/initiator/iqn").attrib["name"],
5195             "iqn.2013-06.com.example:iscsi-initiator",
5196         )
5197     def test_pool_define(self):
5198         """
5199         Test virt.pool_define()
5200         """
5201         mock_pool = MagicMock()
5202         mock_secret = MagicMock()
5203         mock_secret_define = MagicMock(return_value=mock_secret)
5204         self.mock_conn.secretDefineXML = mock_secret_define
5205         self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
5206         self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)
5207         mocks = [
5208             mock_pool,
5209             mock_secret,
5210             mock_secret_define,
5211             self.mock_conn.storagePoolCreateXML,
5212             self.mock_conn.secretDefineXML,
5213             self.mock_conn.storagePoolDefineXML,
5214         ]
5215         self.assertTrue(
5216             virt.pool_define(
5217                 "default",
5218                 "rbd",
5219                 source_hosts=["one.example.com", "two.example.com"],
5220                 source_name="rbdvol",
5221                 source_auth={
5222                     "type": "ceph",
5223                     "username": "admin",
5224                     "secret": {"type": "uuid", "value": "someuuid"},
5225                 },
5226             )
5227         )
5228         self.mock_conn.storagePoolDefineXML.assert_called_once()
5229         self.mock_conn.storagePoolCreateXML.assert_not_called()
5230         mock_pool.create.assert_called_once()
5231         mock_secret_define.assert_not_called()
5232         for mock in mocks:
5233             mock.reset_mock()
5234         self.assertTrue(
5235             virt.pool_define(
5236                 "default",
5237                 "rbd",
5238                 transient=True,
5239                 source_hosts=["one.example.com", "two.example.com"],
5240                 source_name="rbdvol",
5241                 source_auth={"username": "admin", "password": "c2VjcmV0"},
5242             )
5243         )
5244         self.mock_conn.storagePoolDefineXML.assert_not_called()
5245         pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
5246         root = ET.fromstring(pool_xml)
5247         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
5248         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
5249         self.assertEqual(
5250             root.find("source/auth/secret").attrib["usage"], "pool_default"
5251         )
5252         mock_pool.create.assert_not_called()
5253         mock_secret.setValue.assert_called_once_with(b"secret")
5254         secret_xml = mock_secret_define.call_args[0][0]
5255         root = ET.fromstring(secret_xml)
5256         self.assertEqual(root.find("usage/name").text, "pool_default")
5257         self.assertEqual(root.find("usage").attrib["type"], "ceph")
5258         self.assertEqual(root.attrib["private"], "yes")
5259         self.assertEqual(
5260             root.find("description").text, "Passphrase for default pool created by Salt"
5261         )
5262         for mock in mocks:
5263             mock.reset_mock()
5264         self.assertTrue(
5265             virt.pool_define(
5266                 "default",
5267                 "iscsi",
5268                 target="/dev/disk/by-path",
5269                 source_hosts=["iscsi.example.com"],
5270                 source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
5271                 source_auth={"username": "admin", "password": "secret"},
5272                 start=False,
5273             )
5274         )
5275         self.mock_conn.storagePoolCreateXML.assert_not_called()
5276         pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
5277         root = ET.fromstring(pool_xml)
5278         self.assertEqual(root.find("source/auth").attrib["type"], "chap")
5279         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
5280         self.assertEqual(
5281             root.find("source/auth/secret").attrib["usage"], "pool_default"
5282         )
5283         mock_pool.create.assert_not_called()
5284         mock_secret.setValue.assert_called_once_with("secret")
5285         secret_xml = mock_secret_define.call_args[0][0]
5286         root = ET.fromstring(secret_xml)
5287         self.assertEqual(root.find("usage/target").text, "pool_default")
5288         self.assertEqual(root.find("usage").attrib["type"], "iscsi")
5289         self.assertEqual(root.attrib["private"], "yes")
5290         self.assertEqual(
5291             root.find("description").text, "Passphrase for default pool created by Salt"
5292         )
5293     def test_list_pools(self):
5294         """
5295         Test virt.list_pools()
5296         """
5297         names = ["pool1", "default", "pool2"]
5298         pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
5299         for i, value in enumerate(names):
5300             pool_mocks[i].name.return_value = value
5301         self.mock_conn.listAllStoragePools.return_value = (
5302             pool_mocks  # pylint: disable=no-member
5303         )
5304         actual = virt.list_pools()
5305         self.assertEqual(names, actual)
5306     def test_pool_info(self):
5307         """
5308         Test virt.pool_info()
5309         """
5310         pool_mock = MagicMock()
5311         pool_mock.name.return_value = "foo"
5312         pool_mock.UUIDString.return_value = "some-uuid"
5313         pool_mock.info.return_value = [0, 1234, 5678, 123]
5314         pool_mock.autostart.return_value = True
5315         pool_mock.isPersistent.return_value = True
5316         pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
5317   &lt;name&gt;default&lt;/name&gt;
5318   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
5319   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
5320   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
5321   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
5322   &lt;source&gt;
5323   &lt;/source&gt;
5324   &lt;target&gt;
5325     &lt;path&gt;/srv/vms&lt;/path&gt;
5326     &lt;permissions&gt;
5327       &lt;mode&gt;0755&lt;/mode&gt;
5328       &lt;owner&gt;0&lt;/owner&gt;
5329       &lt;group&gt;0&lt;/group&gt;
5330     &lt;/permissions&gt;
5331   &lt;/target&gt;
5332 &lt;/pool&gt;"""
5333         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
5334         pool = virt.pool_info("foo")
5335         self.assertEqual(
5336             {
5337                 "foo": {
5338                     "uuid": "some-uuid",
5339                     "state": "inactive",
5340                     "capacity": 1234,
5341                     "allocation": 5678,
5342                     "free": 123,
5343                     "autostart": True,
5344                     "persistent": True,
5345                     "type": "dir",
5346                     "target_path": "/srv/vms",
5347                 }
5348             },
5349             pool,
5350         )
5351     def test_pool_info_notarget(self):
5352         """
5353         Test virt.pool_info()
5354         """
5355         pool_mock = MagicMock()
5356         pool_mock.name.return_value = "ceph"
5357         pool_mock.UUIDString.return_value = "some-uuid"
5358         pool_mock.info.return_value = [0, 0, 0, 0]
5359         pool_mock.autostart.return_value = True
5360         pool_mock.isPersistent.return_value = True
5361         pool_mock.XMLDesc.return_value = """&lt;pool type='rbd'&gt;
5362   &lt;name&gt;ceph&lt;/name&gt;
5363   &lt;uuid&gt;some-uuid&lt;/uuid&gt;
5364   &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
5365   &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
5366   &lt;available unit='bytes'&gt;0&lt;/available&gt;
5367   &lt;source&gt;
5368     &lt;host name='localhost' port='6789'/&gt;
5369     &lt;host name='localhost' port='6790'/&gt;
5370     &lt;name&gt;rbd&lt;/name&gt;
5371     &lt;auth type='ceph' username='admin'&gt;
5372       &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
5373     &lt;/auth&gt;
5374   &lt;/source&gt;
5375 &lt;/pool&gt;"""
5376         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
5377         pool = virt.pool_info("ceph")
5378         self.assertEqual(
5379             {
5380                 "ceph": {
5381                     "uuid": "some-uuid",
5382                     "state": "inactive",
5383                     "capacity": 0,
5384                     "allocation": 0,
5385                     "free": 0,
5386                     "autostart": True,
5387                     "persistent": True,
5388                     "type": "rbd",
5389                     "target_path": None,
5390                 }
5391             },
5392             pool,
5393         )
5394     def test_pool_info_notfound(self):
5395         """
5396         Test virt.pool_info() when the pool can't be found
5397         """
5398         self.mock_conn.listAllStoragePools.return_value = []
5399         pool = virt.pool_info("foo")
5400         self.assertEqual({}, pool)
5401     def test_pool_info_all(self):
5402         """
5403         Test virt.pool_info()
5404         """
5405         pool_mocks = []
5406         for i in range(2):
5407             pool_mock = MagicMock()
5408             pool_mock.name.return_value = "pool{}".format(i)
5409             pool_mock.UUIDString.return_value = "some-uuid-{}".format(i)
5410             pool_mock.info.return_value = [0, 1234, 5678, 123]
5411             pool_mock.autostart.return_value = True
5412             pool_mock.isPersistent.return_value = True
5413             pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
5414   &lt;name&gt;default&lt;/name&gt;
5415   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
5416   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
5417   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
5418   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
5419   &lt;source&gt;
5420   &lt;/source&gt;
5421   &lt;target&gt;
5422     &lt;path&gt;/srv/vms&lt;/path&gt;
5423     &lt;permissions&gt;
5424       &lt;mode&gt;0755&lt;/mode&gt;
5425       &lt;owner&gt;0&lt;/owner&gt;
5426       &lt;group&gt;0&lt;/group&gt;
5427     &lt;/permissions&gt;
5428   &lt;/target&gt;
5429 &lt;/pool&gt;"""
5430             pool_mocks.append(pool_mock)
5431         self.mock_conn.listAllStoragePools.return_value = pool_mocks
5432         pool = virt.pool_info()
5433         self.assertEqual(
5434             {
5435                 "pool0": {
5436                     "uuid": "some-uuid-0",
5437                     "state": "inactive",
5438                     "capacity": 1234,
5439                     "allocation": 5678,
5440                     "free": 123,
5441                     "autostart": True,
5442                     "persistent": True,
5443                     "type": "dir",
5444                     "target_path": "/srv/vms",
5445                 },
5446                 "pool1": {
5447                     "uuid": "some-uuid-1",
5448                     "state": "inactive",
5449                     "capacity": 1234,
5450                     "allocation": 5678,
5451                     "free": 123,
5452                     "autostart": True,
5453                     "persistent": True,
5454                     "type": "dir",
5455                     "target_path": "/srv/vms",
5456                 },
5457             },
5458             pool,
5459         )
5460     def test_pool_get_xml(self):
5461         """
5462         Test virt.pool_get_xml
5463         """
5464         pool_mock = MagicMock()
5465         pool_mock.XMLDesc.return_value = "&lt;pool&gt;Raw XML&lt;/pool&gt;"
5466         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5467         self.assertEqual("&lt;pool&gt;Raw XML&lt;/pool&gt;", virt.pool_get_xml("default"))
5468     def test_pool_list_volumes(self):
5469         """
5470         Test virt.pool_list_volumes
5471         """
5472         names = ["volume1", "volume2"]
5473         mock_pool = MagicMock()
5474         mock_pool.listVolumes.return_value = names
5475         self.mock_conn.storagePoolLookupByName.return_value = mock_pool
5476         self.assertEqual(names, virt.pool_list_volumes("default"))
5477     @patch("salt.modules.virt._is_bhyve_hyper", return_value=False)
5478     @patch("salt.modules.virt._is_kvm_hyper", return_value=True)
5479     @patch("salt.modules.virt._is_xen_hyper", return_value=False)
5480     def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
5481         """
5482         test the virt.get_hypervisor() function
5483         """
5484         self.assertEqual("kvm", virt.get_hypervisor())
5485         iskvm_mock.return_value = False
5486         self.assertIsNone(virt.get_hypervisor())
5487         is_bhyve_mock.return_value = False
5488         self.assertIsNone(virt.get_hypervisor())
5489         isxen_mock.return_value = True
5490         self.assertEqual("xen", virt.get_hypervisor())
5491     def test_pool_delete(self):
5492         """
5493         Test virt.pool_delete function
5494         """
5495         mock_pool = MagicMock()
5496         mock_pool.delete = MagicMock(return_value=0)
5497         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
5498         res = virt.pool_delete("test-pool")
5499         self.assertTrue(res)
5500         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-pool")
5501         mock_pool.delete.assert_called_once_with(
5502             self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
5503         )
5504     def test_pool_undefine_secret(self):
5505         """
5506         Test virt.pool_undefine function where the pool has a secret
5507         """
5508         mock_pool = MagicMock()
5509         mock_pool.undefine = MagicMock(return_value=0)
5510         mock_pool.XMLDesc.return_value = """
5511             &lt;pool type='rbd'&gt;
5512               &lt;name&gt;test-ses&lt;/name&gt;
5513               &lt;source&gt;
5514                 &lt;host name='myhost'/&gt;
5515                 &lt;name&gt;libvirt-pool&lt;/name&gt;
5516                 &lt;auth type='ceph' username='libvirt'&gt;
5517                   &lt;secret usage='pool_test-ses'/&gt;
5518                 &lt;/auth&gt;
5519               &lt;/source&gt;
5520             &lt;/pool&gt;
5521         """
5522         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
5523         mock_undefine = MagicMock(return_value=0)
5524         self.mock_conn.secretLookupByUsage.return_value.undefine = mock_undefine
5525         res = virt.pool_undefine("test-ses")
5526         self.assertTrue(res)
5527         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-ses")
5528         mock_pool.undefine.assert_called_once_with()
5529         self.mock_conn.secretLookupByUsage.assert_called_once_with(
5530             self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, "pool_test-ses"
5531         )
5532         mock_undefine.assert_called_once()
5533     def test_full_info(self):
5534         """
5535         Test virt.full_info
5536         """
5537         xml = """&lt;domain type='kvm' id='7'&gt;
5538               &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
5539               &lt;name&gt;test-vm&lt;/name&gt;
5540               &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
5541               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
5542               &lt;on_crash&gt;destroy&lt;/on_crash&gt;
5543               &lt;devices&gt;
5544                 &lt;disk type='file' device='disk'&gt;
5545                 &lt;driver name='qemu' type='qcow2'/&gt;
5546                 &lt;source file='/disks/test.qcow2'/&gt;
5547                 &lt;target dev='vda' bus='virtio'/&gt;
5548               &lt;/disk&gt;
5549               &lt;disk type='file' device='cdrom'&gt;
5550                 &lt;driver name='qemu' type='raw'/&gt;
5551                 &lt;source file='/disks/test-cdrom.iso'/&gt;
5552                 &lt;target dev='hda' bus='ide'/&gt;
5553                 &lt;readonly/&gt;
5554               &lt;/disk&gt;
5555               &lt;interface type='bridge'&gt;
5556                 &lt;mac address='ac:de:48:b6:8b:59'/&gt;
5557                 &lt;source bridge='br0'/&gt;
5558                 &lt;model type='virtio'/&gt;
5559                 &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
5560               &lt;/interface&gt;
5561               &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
5562                 &lt;listen type='address' address='0.0.0.0'/&gt;
5563               &lt;/graphics&gt;
5564               &lt;/devices&gt;
5565             &lt;/domain&gt;
5566         """
5567         self.set_mock_vm("test-vm", xml)
5568         qemu_infos = """[{
5569             "virtual-size": 25769803776,
5570             "filename": "/disks/test.qcow2",
5571             "cluster-size": 65536,
5572             "format": "qcow2",
5573             "actual-size": 217088,
5574             "format-specific": {
5575                 "type": "qcow2",
5576                 "data": {
5577                     "compat": "1.1",
5578                     "lazy-refcounts": false,
5579                     "refcount-bits": 16,
5580                     "corrupt": false
5581                 }
5582             },
5583             "full-backing-filename": "/disks/mybacking.qcow2",
5584             "backing-filename": "mybacking.qcow2",
5585             "dirty-flag": false
5586         },
5587         {
5588             "virtual-size": 25769803776,
5589             "filename": "/disks/mybacking.qcow2",
5590             "cluster-size": 65536,
5591             "format": "qcow2",
5592             "actual-size": 393744384,
5593             "format-specific": {
5594                 "type": "qcow2",
5595                 "data": {
5596                     "compat": "1.1",
5597                     "lazy-refcounts": false,
5598                     "refcount-bits": 16,
5599                     "corrupt": false
5600                 }
5601             },
5602             "dirty-flag": false
5603         }]"""
5604         self.mock_popen.communicate.return_value = [qemu_infos, ""]
5605         self.mock_popen.returncode = 0
5606         self.mock_conn.getInfo = MagicMock(
5607             return_value=["x86_64", 4096, 8, 2712, 1, 2, 4, 2]
5608         )
5609         actual = virt.full_info()
5610         qemu_img_call = [
5611             call
5612             for call in self.mock_subprocess.Popen.call_args_list
5613             if "qemu-img" in call[0][0]
5614         ][0]
5615         self.assertIn("info", qemu_img_call[0][0])
5616         self.assertIn("-U", qemu_img_call[0][0])
5617         self.assertEqual(2816, actual["freemem"])
5618         self.assertEqual(6, actual["freecpu"])
5619         self.assertEqual(4, actual["node_info"]["cpucores"])
5620         self.assertEqual(2712, actual["node_info"]["cpumhz"])
5621         self.assertEqual("x86_64", actual["node_info"]["cpumodel"])
5622         self.assertEqual(8, actual["node_info"]["cpus"])
5623         self.assertEqual(2, actual["node_info"]["cputhreads"])
5624         self.assertEqual(1, actual["node_info"]["numanodes"])
5625         self.assertEqual(4096, actual["node_info"]["phymemory"])
5626         self.assertEqual(2, actual["node_info"]["sockets"])
5627         self.assertEqual(2, actual["vm_info"]["test-vm"]["cpu"])
5628         self.assertEqual(1234, actual["vm_info"]["test-vm"]["cputime"])
5629         self.assertEqual(1024 * 1024, actual["vm_info"]["test-vm"]["mem"])
5630         self.assertEqual(2048 * 1024, actual["vm_info"]["test-vm"]["maxMem"])
5631         self.assertEqual("shutdown", actual["vm_info"]["test-vm"]["state"])
5632         self.assertEqual(
5633             "28deee33-4859-4f23-891c-ee239cffec94", actual["vm_info"]["test-vm"]["uuid"]
5634         )
5635         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_crash"])
5636         self.assertEqual("restart", actual["vm_info"]["test-vm"]["on_reboot"])
5637         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_poweroff"])
5638         nic = actual["vm_info"]["test-vm"]["nics"]["ac:de:48:b6:8b:59"]
5639         self.assertEqual("bridge", nic["type"])
5640         self.assertEqual("ac:de:48:b6:8b:59", nic["mac"])
5641         disks = actual["vm_info"]["test-vm"]["disks"]
5642         disk = disks.get("vda")
5643         self.assertEqual("/disks/test.qcow2", disk["file"])
5644         self.assertEqual("disk", disk["type"])
5645         self.assertEqual("/disks/mybacking.qcow2", disk["backing file"]["file"])
5646         cdrom = disks.get("hda")
5647         self.assertEqual("/disks/test-cdrom.iso", cdrom["file"])
5648         self.assertEqual("cdrom", cdrom["type"])
5649         self.assertFalse("backing file" in cdrom.keys())
5650         graphics = actual["vm_info"]["test-vm"]["graphics"]
5651         self.assertEqual("vnc", graphics["type"])
5652         self.assertEqual("5900", graphics["port"])
5653         self.assertEqual("0.0.0.0", graphics["listen"])
5654     def test_pool_update(self):
5655         """
5656         Test the pool_update function
5657         """
5658         current_xml = """&lt;pool type='dir'&gt;
5659           &lt;name&gt;default&lt;/name&gt;
5660           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5661           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5662           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5663           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5664           &lt;source&gt;
5665           &lt;/source&gt;
5666           &lt;target&gt;
5667             &lt;path&gt;/path/to/pool&lt;/path&gt;
5668             &lt;permissions&gt;
5669               &lt;mode&gt;0775&lt;/mode&gt;
5670               &lt;owner&gt;0&lt;/owner&gt;
5671               &lt;group&gt;100&lt;/group&gt;
5672             &lt;/permissions&gt;
5673           &lt;/target&gt;
5674         &lt;/pool&gt;"""
5675         expected_xml = (
5676             '&lt;pool type="netfs"&gt;'
5677             "&lt;name&gt;default&lt;/name&gt;"
5678             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5679             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5680             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5681             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5682             "&lt;target&gt;"
5683             "&lt;path&gt;/mnt/cifs&lt;/path&gt;"
5684             "&lt;permissions&gt;"
5685             "&lt;mode&gt;0774&lt;/mode&gt;"
5686             "&lt;owner&gt;1234&lt;/owner&gt;"
5687             "&lt;group&gt;123&lt;/group&gt;"
5688             "&lt;/permissions&gt;"
5689             "&lt;/target&gt;"
5690             "&lt;source&gt;"
5691             '&lt;dir path="samba_share" /&gt;'
5692             '&lt;host name="one.example.com" /&gt;'
5693             '&lt;host name="two.example.com" /&gt;'
5694             '&lt;format type="cifs" /&gt;'
5695             "&lt;/source&gt;"
5696             "&lt;/pool&gt;"
5697         )
5698         mocked_pool = MagicMock()
5699         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5700         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5701         self.mock_conn.storagePoolDefineXML = MagicMock()
5702         self.assertTrue(
5703             virt.pool_update(
5704                 "default",
5705                 "netfs",
5706                 target="/mnt/cifs",
5707                 permissions={"mode": "0774", "owner": "1234", "group": "123"},
5708                 source_format="cifs",
5709                 source_dir="samba_share",
5710                 source_hosts=["one.example.com", "two.example.com"],
5711             )
5712         )
5713         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5714     def test_pool_update_nochange(self):
5715         """
5716         Test the pool_update function when no change is needed
5717         """
5718         current_xml = """&lt;pool type='dir'&gt;
5719           &lt;name&gt;default&lt;/name&gt;
5720           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5721           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5722           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5723           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5724           &lt;source&gt;
5725           &lt;/source&gt;
5726           &lt;target&gt;
5727             &lt;path&gt;/path/to/pool&lt;/path&gt;
5728             &lt;permissions&gt;
5729               &lt;mode&gt;0775&lt;/mode&gt;
5730               &lt;owner&gt;0&lt;/owner&gt;
5731               &lt;group&gt;100&lt;/group&gt;
5732             &lt;/permissions&gt;
5733           &lt;/target&gt;
5734         &lt;/pool&gt;"""
5735         mocked_pool = MagicMock()
5736         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5737         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5738         self.mock_conn.storagePoolDefineXML = MagicMock()
5739         self.assertFalse(
5740             virt.pool_update(
5741                 "default",
5742                 "dir",
5743                 target="/path/to/pool",
5744                 permissions={"mode": "0775", "owner": "0", "group": "100"},
5745                 test=True,
5746             )
5747         )
5748         self.mock_conn.storagePoolDefineXML.assert_not_called()
5749     def test_pool_update_password(self):
5750         """
5751         Test the pool_update function, where the password only is changed
5752         """
5753         current_xml = """&lt;pool type='rbd'&gt;
5754           &lt;name&gt;default&lt;/name&gt;
5755           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5756           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5757           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5758           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5759           &lt;source&gt;
5760             &lt;name&gt;iscsi-images&lt;/name&gt;
5761             &lt;host name='ses4.tf.local'/&gt;
5762             &lt;host name='ses5.tf.local'/&gt;
5763             &lt;auth username='libvirt' type='ceph'&gt;
5764               &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
5765             &lt;/auth&gt;
5766           &lt;/source&gt;
5767         &lt;/pool&gt;"""
5768         mock_secret = MagicMock()
5769         self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)
5770         mocked_pool = MagicMock()
5771         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5772         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5773         self.mock_conn.storagePoolDefineXML = MagicMock()
5774         self.assertFalse(
5775             virt.pool_update(
5776                 "default",
5777                 "rbd",
5778                 source_name="iscsi-images",
5779                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5780                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5781             )
5782         )
5783         self.mock_conn.storagePoolDefineXML.assert_not_called()
5784         mock_secret.setValue.assert_called_once_with(b"secret")
5785         self.mock_conn.secretLookupByUUIDString = MagicMock(
5786             side_effect=self.mock_libvirt.libvirtError("secret not found")
5787         )
5788         self.assertFalse(
5789             virt.pool_update(
5790                 "default",
5791                 "rbd",
5792                 source_name="iscsi-images",
5793                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5794                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5795             )
5796         )
5797         self.mock_conn.storagePoolDefineXML.assert_not_called()
5798         self.mock_conn.secretDefineXML.assert_called_once()
5799         mock_secret.setValue.assert_called_once_with(b"secret")
5800     def test_pool_update_password_create(self):
5801         """
5802         Test the pool_update function, where the password only is changed
5803         """
5804         current_xml = """&lt;pool type='rbd'&gt;
5805           &lt;name&gt;default&lt;/name&gt;
5806           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5807           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5808           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5809           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5810           &lt;source&gt;
5811             &lt;name&gt;iscsi-images&lt;/name&gt;
5812             &lt;host name='ses4.tf.local'/&gt;
5813             &lt;host name='ses5.tf.local'/&gt;
5814           &lt;/source&gt;
5815         &lt;/pool&gt;"""
5816         expected_xml = (
5817             '&lt;pool type="rbd"&gt;'
5818             "&lt;name&gt;default&lt;/name&gt;"
5819             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5820             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5821             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5822             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5823             "&lt;source&gt;"
5824             '&lt;host name="ses4.tf.local" /&gt;'
5825             '&lt;host name="ses5.tf.local" /&gt;'
5826             '&lt;auth type="ceph" username="libvirt"&gt;'
5827             '&lt;secret usage="pool_default" /&gt;'
5828             "&lt;/auth&gt;"
5829             "&lt;name&gt;iscsi-images&lt;/name&gt;"
5830             "&lt;/source&gt;"
5831             "&lt;/pool&gt;"
5832         )
5833         mock_secret = MagicMock()
5834         self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)
5835         mocked_pool = MagicMock()
5836         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5837         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5838         self.mock_conn.storagePoolDefineXML = MagicMock()
5839         self.assertTrue(
5840             virt.pool_update(
5841                 "default",
5842                 "rbd",
5843                 source_name="iscsi-images",
5844                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5845                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5846             )
5847         )
5848         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5849         mock_secret.setValue.assert_called_once_with(b"secret")
5850     def test_volume_infos(self):
5851         """
5852         Test virt.volume_infos
5853         """
5854         vms_disks = [
5855             """
5856                 &lt;disk type='file' device='disk'&gt;
5857                   &lt;driver name='qemu' type='qcow2'/&gt;
5858                   &lt;source file='/path/to/vol0.qcow2'/&gt;
5859                   &lt;target dev='vda' bus='virtio'/&gt;
5860                 &lt;/disk&gt;
5861             """,
5862             """
5863                 &lt;disk type='file' device='disk'&gt;
5864                   &lt;driver name='qemu' type='qcow2'/&gt;
5865                   &lt;source file='/path/to/vol3.qcow2'/&gt;
5866                   &lt;target dev='vda' bus='virtio'/&gt;
5867                 &lt;/disk&gt;
5868             """,
5869             """
5870                 &lt;disk type='file' device='disk'&gt;
5871                   &lt;driver name='qemu' type='qcow2'/&gt;
5872                   &lt;source file='/path/to/vol2.qcow2'/&gt;
5873                   &lt;target dev='vda' bus='virtio'/&gt;
5874                 &lt;/disk&gt;
5875             """,
5876         ]
5877         mock_vms = []
5878         for idx, disk in enumerate(vms_disks):
5879             vm = MagicMock()
5880             vm.name.return_value = "vm{}".format(idx)
5881             vm.XMLDesc.return_value = """
5882                     &lt;domain type='kvm' id='1'&gt;
5883                       &lt;name&gt;vm{}&lt;/name&gt;
5884                       &lt;devices&gt;{}&lt;/devices&gt;
5885                     &lt;/domain&gt;
5886                 """.format(
5887                 idx, disk
5888             )
5889             mock_vms.append(vm)
5890         mock_pool_data = [
5891             {
5892                 "name": "pool0",
5893                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5894                 "volumes": [
5895                     {
5896                         "key": "/key/of/vol0",
5897                         "name": "vol0",
5898                         "path": "/path/to/vol0.qcow2",
5899                         "info": [0, 123456789, 123456],
5900                         "backingStore": None,
5901                     }
5902                 ],
5903             },
5904             {
5905                 "name": "pool1",
5906                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5907                 "volumes": [
5908                     {
5909                         "key": "/key/of/vol0bad",
5910                         "name": "vol0bad",
5911                         "path": "/path/to/vol0bad.qcow2",
5912                         "info": None,
5913                         "backingStore": None,
5914                     },
5915                     {
5916                         "key": "/key/of/vol1",
5917                         "name": "vol1",
5918                         "path": "/path/to/vol1.qcow2",
5919                         "info": [0, 12345, 1234],
5920                         "backingStore": None,
5921                     },
5922                     {
5923                         "key": "/key/of/vol2",
5924                         "name": "vol2",
5925                         "path": "/path/to/vol2.qcow2",
5926                         "info": [0, 12345, 1234],
5927                         "backingStore": "/path/to/vol0.qcow2",
5928                     },
5929                 ],
5930             },
5931         ]
5932         mock_pools = []
5933         for pool_data in mock_pool_data:
5934             mock_pool = MagicMock()
5935             mock_pool.name.return_value = pool_data["name"]  # pylint: disable=no-member
5936             mock_pool.info.return_value = [pool_data["state"]]
5937             mock_volumes = []
5938             for vol_data in pool_data["volumes"]:
5939                 mock_volume = MagicMock()
5940                 mock_volume.name.return_value = vol_data["name"]
5941                 mock_volume.key.return_value = vol_data["key"]
5942                 mock_volume.path.return_value = "/path/to/{}.qcow2".format(
5943                     vol_data["name"]
5944                 )
5945                 if vol_data["info"]:
5946                     mock_volume.info.return_value = vol_data["info"]
5947                     backing_store = (
5948                         """
5949                         &lt;backingStore&gt;
5950                           &lt;format type="qcow2"/&gt;
5951                           &lt;path&gt;{}&lt;/path&gt;
5952                         &lt;/backingStore&gt;
5953                     """.format(
5954                             vol_data["backingStore"]
5955                         )
5956                         if vol_data["backingStore"]
5957                         else "&lt;backingStore/&gt;"
5958                     )
5959                     mock_volume.XMLDesc.return_value = """
5960                         &lt;volume type='file'&gt;
5961                           &lt;name&gt;{0}&lt;/name&gt;
5962                           &lt;target&gt;
5963                             &lt;format type="qcow2"/&gt;
5964                             &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
5965                           &lt;/target&gt;
5966                           {1}
5967                         &lt;/volume&gt;
5968                     """.format(
5969                         vol_data["name"], backing_store
5970                     )
5971                 else:
5972                     mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
5973                         "No such volume"
5974                     )
5975                     mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
5976                         "No such volume"
5977                     )
5978                 mock_volumes.append(mock_volume)
5979             mock_pool.listAllVolumes.return_value = (
5980                 mock_volumes  # pylint: disable=no-member
5981             )
5982             mock_pools.append(mock_pool)
5983         inactive_pool = MagicMock()
5984         inactive_pool.name.return_value = "pool2"
5985         inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
5986         inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
5987             "pool is inactive"
5988         )
5989         mock_pools.append(inactive_pool)
5990         self.mock_conn.listAllStoragePools.return_value = (
5991             mock_pools  # pylint: disable=no-member
5992         )
5993             actual = virt.volume_infos("pool0", "vol0")
5994             self.assertEqual(1, len(actual.keys()))
5995             self.assertEqual(1, len(actual["pool0"]<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.keys()))
5996             self.assertEqual(["vm0", "vm2"], sorted(actual["pool0"]["vol0"]["used_by"]))
5997             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"][</b></font>"path"])
5998             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5999             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
6000             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
6001             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
6002             self.assertEqual(
6003                 virt.volume_infos("pool1", None),
6004                 {
6005                     "pool1": {
6006                         "vol1": {
6007                             "type": "file",
6008                             "key": "/key/of/vol1",
6009                             "path": "/path/to/vol1.qcow2",
6010                             "capacity": 12345,
6011                             "allocation": 1234,
6012                             "used_by": [],
6013                             "backing_store": None,
6014                             "format": "qcow2",
6015                         },
6016                         "vol2": {
6017                             "type": "file",
6018                             "key": "/key/of/vol2",
6019                             "path": "/path/to/vol2.qcow2",
6020                             "capacity": 12345,
6021                             "allocation": 1234,
6022                             "used_by": ["vm2"],
6023                             "backing_store": {
6024                                 "path": "/path/to/vol0.qcow2",
6025                                 "format": "qcow2",
6026                             },
6027                             "format": "qcow2",
6028                         },
6029                     }
6030                 },
6031             )
6032             self.assertEqual(
6033                 virt.volume_infos(None, "vol2"),
6034                 {
6035                     "pool1": {
6036                         "vol2": {
6037                             "type": "file",
6038                             "key": "/key/of/vol2",
6039                             "path": "/path/to/vol2.qcow2",
6040                             "capacity": 12345,
6041                             "allocation": 1234,
6042                             "used_by": ["vm2"],
6043                             "backing_store": {
6044                                 "path": "/path/to/vol0.qcow2",
6045                                 "format": "qcow2",
6046                             },
6047                             "format": "qcow2",
6048                         }
6049                     }
6050                 },
6051             )
6052         with patch(
6053             "salt.modules.virt._get_domain", MagicMock(return_value=mock_vms[0])
6054         ):
6055             actual = virt.volume_infos("pool0", "vol0")
6056             self.assertEqual(1, len(actual.keys()))
6057             self.assertEqual(1, len(actual["pool0"].keys()))
6058             self.assertEqual(["vm0"], sorted(actual["pool0"]["vol0"]["used_by"]))
6059             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
6060             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
6061             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
6062             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
6063             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
6064             self.assertEqual(
6065                 virt.volume_infos("pool1", None),
6066                 {
6067                     "pool1": {
6068                         "vol1": {
6069                             "type": "file",
6070                             "key": "/key/of/vol1",
6071                             "path": "/path/to/vol1.qcow2",
6072                             "capacity": 12345,
6073                             "allocation": 1234,
6074                             "used_by": [],
6075                             "backing_store": None,
6076                             "format": "qcow2",
6077                         },
6078                         "vol2": {
6079                             "type": "file",
6080                             "key": "/key/of/vol2",
6081                             "path": "/path/to/vol2.qcow2",
6082                             "capacity": 12345,
6083                             "allocation": 1234,
6084                             "used_by": [],
6085                             "backing_store": {
6086                                 "path": "/path/to/vol0.qcow2",
6087                                 "format": "qcow2",
6088                             },
6089                             "format": "qcow2",
6090                         },
6091                     }
6092                 },
6093             )
6094             self.assertEqual(
6095                 virt.volume_infos(None, "vol2"),
6096                 {
6097                     "pool1": {
6098                         "vol2": {
6099                             "type": "file",
6100                             "key": "/key/of/vol2",
6101                             "path": "/path/to/vol2.qcow2",
6102                             "capacity": 12345,
6103                             "allocation": 1234,
6104                             "used_by": [],
6105                             "backing_store": {
6106                                 "path": "/path/to/vol0.qcow2",
6107                                 "format": "qcow2",
6108                             },
6109                             "format": "qcow2",
6110                         }
6111                     }
6112                 },
6113             )
6114         with patch(
6115             "salt.modules.virt._get_domain",
6116             MagicMock(side_effect=CommandExecutionError("no VM")),
6117         ):
6118             actual = virt.volume_infos("pool0", "vol0")
6119             self.assertEqual(1, len(actual.keys()))
6120             self.assertEqual(1, len(actual["pool0"].keys()))
6121             self.assertEqual([], sorted(actual["pool0"]["vol0"]["used_by"]))
6122             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
6123             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
6124             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
6125             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
6126             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
6127             self.assertEqual(
6128                 virt.volume_infos("pool1", None),
6129                 {
6130                     "pool1": {
6131                         "vol1": {
6132                             "type": "file",
6133                             "key": "/key/of/vol1",
6134                             "path": "/path/to/vol1.qcow2",
6135                             "capacity": 12345,
6136                             "allocation": 1234,
6137                             "used_by": [],
6138                             "backing_store": None,
6139                             "format": "qcow2",
6140                         },
6141                         "vol2": {
6142                             "type": "file",
6143                             "key": "/key/of/vol2",
6144                             "path": "/path/to/vol2.qcow2",
6145                             "capacity": 12345,
6146                             "allocation": 1234,
6147                             "used_by": [],
6148                             "backing_store": {
6149                                 "path": "/path/to/vol0.qcow2",
6150                                 "format": "qcow2",
6151                             },
6152                             "format": "qcow2",
6153                         },
6154                     }
6155                 },
6156             )
6157             self.assertEqual(
6158                 virt.volume_infos(None, "vol2"),
6159                 {
6160                     "pool1": {
6161                         "vol2": {
6162                             "type": "file",
6163                             "key": "/key/of/vol2",
6164                             "path": "/path/to/vol2.qcow2",
6165                             "capacity": 12345,
6166                             "allocation": 1234,
6167                             "used_by": [],
6168                             "backing_store": {
6169                                 "path": "/path/to/vol0.qcow2",
6170                                 "format": "qcow2",
6171                             },
6172                             "format": "qcow2",
6173                         }
6174                     }
6175                 },
6176             )
6177     def test_volume_delete(self):
6178         """
6179         Test virt.volume_delete
6180         """
6181         mock_delete = MagicMock(side_effect=[0, 1])
6182         mock_volume = MagicMock()
6183         mock_volume.delete = mock_delete  # pylint: disable=no-member
6184         mock_pool = MagicMock()
6185         mock_pool.storageVolLookupByName.side_effect = [
6186             mock_volume,
6187             mock_volume,
6188             self.mock_libvirt.libvirtError("Missing volume"),
6189             mock_volume,
6190         ]
6191         self.mock_conn.storagePoolLookupByName.side_effect = [
6192             mock_pool,
6193             mock_pool,
6194             mock_pool,
6195             self.mock_libvirt.libvirtError("Missing pool"),
6196         ]
6197         self.assertTrue(virt.volume_delete("default", "test_volume"))
6198         self.assertFalse(virt.volume_delete("default", "test_volume"))
6199         <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with self.assertRaises(self.mock_libvirt.libvirtError):
6200             virt.volume_delete("default", "missing")
6201             virt.volume_delete("missing", "test_volume")
6202         self.assertEqual(</b></font>mock_delete.call_count, 2)
6203     def test_pool_capabilities(self):
6204         """
6205         Test virt.pool_capabilities where libvirt has the pool-capabilities feature
6206         """
6207         xml_caps = """
6208 &lt;storagepoolCapabilities&gt;
6209   &lt;pool type='disk' supported='yes'&gt;
6210     &lt;poolOptions&gt;
6211       &lt;defaultFormat type='unknown'/&gt;
6212       &lt;enum name='sourceFormatType'&gt;
6213         &lt;value&gt;unknown&lt;/value&gt;
6214         &lt;value&gt;dos&lt;/value&gt;
6215         &lt;value&gt;dvh&lt;/value&gt;
6216       &lt;/enum&gt;
6217     &lt;/poolOptions&gt;
6218     &lt;volOptions&gt;
6219       &lt;defaultFormat type='none'/&gt;
6220       &lt;enum name='targetFormatType'&gt;
6221         &lt;value&gt;none&lt;/value&gt;
6222         &lt;value&gt;linux&lt;/value&gt;
6223       &lt;/enum&gt;
6224     &lt;/volOptions&gt;
6225   &lt;/pool&gt;
6226   &lt;pool type='iscsi' supported='yes'&gt;
6227   &lt;/pool&gt;
6228   &lt;pool type='rbd' supported='yes'&gt;
6229     &lt;volOptions&gt;
6230       &lt;defaultFormat type='raw'/&gt;
6231       &lt;enum name='targetFormatType'&gt;
6232       &lt;/enum&gt;
6233     &lt;/volOptions&gt;
6234   &lt;/pool&gt;
6235   &lt;pool type='sheepdog' supported='no'&gt;
6236   &lt;/pool&gt;
6237 &lt;/storagepoolCapabilities&gt;
6238         """
6239         self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)
6240         actual = virt.pool_capabilities()
6241         self.assertEqual(
6242             {
6243                 "computed": False,
6244                 "pool_types": [
6245                     {
6246                         "name": "disk",
6247                         "supported": True,
6248                         "options": {
6249                             "pool": {
6250                                 "default_format": "unknown",
6251                                 "sourceFormatType": ["unknown", "dos", "dvh"],
6252                             },
6253                             "volume": {
6254                                 "default_format": "none",
6255                                 "targetFormatType": ["none", "linux"],
6256                             },
6257                         },
6258                     },
6259                     {"name": "iscsi", "supported": True},
6260                     {
6261                         "name": "rbd",
6262                         "supported": True,
6263                         "options": {
6264                             "volume": {"default_format": "raw", "targetFormatType": []}
6265                         },
6266                     },
6267                     {"name": "sheepdog", "supported": False},
6268                 ],
6269             },
6270             actual,
6271         )
6272     @patch("salt.modules.virt.get_hypervisor", return_value="kvm")
6273     def test_pool_capabilities_computed(self, mock_get_hypervisor):
6274         """
6275         Test virt.pool_capabilities where libvirt doesn't have the pool-capabilities feature
6276         """
6277         self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
6278         del self.mock_conn.getStoragePoolCapabilities
6279         actual = virt.pool_capabilities()
6280         self.assertTrue(actual["computed"])
6281         backends = actual["pool_types"]
6282         self.assertFalse(
6283             [backend for backend in backends if backend["name"] == "iscsi-direct"][0][
6284                 "supported"
6285             ]
6286         )
6287         self.assertTrue(
6288             [backend for backend in backends if backend["name"] == "gluster"][0][
6289                 "supported"
6290             ]
6291         )
6292         self.assertFalse(
6293             [backend for backend in backends if backend["name"] == "zfs"][0][
6294                 "supported"
6295             ]
6296         )
6297         mock_get_hypervisor.return_value = "xen"
6298         backends = virt.pool_capabilities()["pool_types"]
6299         self.assertFalse(
6300             [backend for backend in backends if backend["name"] == "gluster"][0][
6301                 "supported"
6302             ]
6303         )
6304         mock_get_hypervisor.return_value = "bhyve"
6305         backends = virt.pool_capabilities()["pool_types"]
6306         self.assertFalse(
6307             [backend for backend in backends if backend["name"] == "gluster"][0][
6308                 "supported"
6309             ]
6310         )
6311         self.assertTrue(
6312             [backend for backend in backends if backend["name"] == "zfs"][0][
6313                 "supported"
6314             ]
6315         )
6316         self.assertNotIn(
6317             "options",
6318             [backend for backend in backends if backend["name"] == "iscsi"][0],
6319         )
6320         self.assertNotIn(
6321             "pool",
6322             [backend for backend in backends if backend["name"] == "dir"][0]["options"],
6323         )
6324         self.assertNotIn(
6325             "volume",
6326             [backend for backend in backends if backend["name"] == "logical"][0][
6327                 "options"
6328             ],
6329         )
6330         self.assertEqual(
6331             {
6332                 "pool": {
6333                     "default_format": "auto",
6334                     "sourceFormatType": ["auto", "nfs", "glusterfs", "cifs"],
6335                 },
6336                 "volume": {
6337                     "default_format": "raw",
6338                     "targetFormatType": [
6339                         "none",
6340                         "raw",
6341                         "dir",
6342                         "bochs",
6343                         "cloop",
6344                         "dmg",
6345                         "iso",
6346                         "vpc",
6347                         "vdi",
6348                         "fat",
6349                         "vhd",
6350                         "ploop",
6351                         "cow",
6352                         "qcow",
6353                         "qcow2",
6354                         "qed",
6355                         "vmdk",
6356                     ],
6357                 },
6358             },
6359             [backend for backend in backends if backend["name"] == "netfs"][0][
6360                 "options"
6361             ],
6362         )
6363     def test_get_domain(self):
6364         """
6365         Test the virt._get_domain function
6366         """
6367         self.mock_conn.listDomainsID.return_value = []
6368         self.mock_conn.listDefinedDomains.return_value = []
6369         self.assertEqual([], virt._get_domain(self.mock_conn))
6370         self.assertRaisesRegex(
6371             CommandExecutionError,
6372             "No virtual machines found.",
6373             virt._get_domain,
6374             self.mock_conn,
6375             "vm2",
6376         )
6377         self.mock_conn.listDomainsID.return_value = [1]
6378         def create_mock_vm(idx):
6379             mock_vm = MagicMock()
6380             mock_vm.name.return_value = "vm{}".format(idx)
6381             return mock_vm
6382         mock_vms = [create_mock_vm(idx) for idx in range(3)]
6383         self.mock_conn.lookupByID.return_value = mock_vms[0]
6384         self.mock_conn.listDefinedDomains.return_value = ["vm1", "vm2"]
6385         self.mock_conn.lookupByName.side_effect = mock_vms
6386         self.assertEqual(mock_vms, virt._get_domain(self.mock_conn))
6387         self.mock_conn.lookupByName.side_effect = None
6388         self.mock_conn.lookupByName.return_value = mock_vms[0]
6389         self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))
6390         self.mock_conn.lookupByName.return_value = None
6391         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
6392         self.assertEqual(
6393             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
6394         )
6395         self.mock_conn.reset_mock()
6396         self.mock_conn.lookupByName.return_value = None
6397         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
6398         self.assertEqual(
6399             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, "vm1", "vm2")
6400         )
6401         self.assertRaisesRegex(
6402             CommandExecutionError,
6403             'The VM "vm2" is not present',
6404             virt._get_domain,
6405             self.mock_conn,
6406             "vm2",
6407             inactive=False,
6408         )
6409     def test_volume_define(self):
6410         """
6411         Test virt.volume_define function
6412         """
6413         pool_mock = MagicMock()
6414         pool_mock.XMLDesc.return_value = "&lt;pool type='dir'&gt;&lt;/pool&gt;"
6415         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
6416         self.assertTrue(
6417             virt.volume_define(
6418                 "testpool",
6419                 "myvm_system.qcow2",
6420                 8192,
6421                 allocation=4096,
6422                 format="qcow2",
6423                 type="file",
6424             )
6425         )
6426         expected_xml = (
6427             "&lt;volume type='file'&gt;\n"
6428             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
6429             "  &lt;source&gt;\n"
6430             "  &lt;/source&gt;\n"
6431             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
6432             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
6433             "  &lt;target&gt;\n"
6434             "    &lt;format type='qcow2'/&gt;\n"
6435             "  &lt;/target&gt;\n"
6436             "&lt;/volume&gt;"
6437         )
6438         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
6439         pool_mock.reset_mock()
6440         self.assertTrue(
6441             virt.volume_define(
6442                 "testpool",
6443                 "myvm_system.qcow2",
6444                 8192,
6445                 allocation=4096,
6446                 format="qcow2",
6447                 type="file",
6448                 backing_store={"path": "/path/to/base.raw", "format": "raw"},
6449             )
6450         )
6451         expected_xml = (
6452             "&lt;volume type='file'&gt;\n"
6453             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
6454             "  &lt;source&gt;\n"
6455             "  &lt;/source&gt;\n"
6456             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
6457             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
6458             "  &lt;target&gt;\n"
6459             "    &lt;format type='qcow2'/&gt;\n"
6460             "  &lt;/target&gt;\n"
6461             "  &lt;backingStore&gt;\n"
6462             "    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n"
6463             "    &lt;format type='raw'/&gt;\n"
6464             "  &lt;/backingStore&gt;\n"
6465             "&lt;/volume&gt;"
6466         )
6467         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
6468         pool_mock.reset_mock()
6469         pool_mock.XMLDesc.return_value = "&lt;pool type='logical'&gt;&lt;/pool&gt;"
6470         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
6471         self.assertTrue(
6472             virt.volume_define(
6473                 "testVG",
6474                 "myvm_system",
6475                 8192,
6476                 backing_store={"path": "/dev/testVG/base"},
6477             )
6478         )
6479         expected_xml = (
6480             "&lt;volume&gt;\n"
6481             "  &lt;name&gt;myvm_system&lt;/name&gt;\n"
6482             "  &lt;source&gt;\n"
6483             "  &lt;/source&gt;\n"
6484             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
6485             "  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n"
6486             "  &lt;target&gt;\n"
6487             "  &lt;/target&gt;\n"
6488             "  &lt;backingStore&gt;\n"
6489             "    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n"
6490             "  &lt;/backingStore&gt;\n"
6491             "&lt;/volume&gt;"
6492         )
6493         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
6494     def test_volume_upload(self):
6495         """
6496         Test virt.volume_upload function
6497         """
6498         pool_mock = MagicMock()
6499         vol_mock = MagicMock()
6500         pool_mock.storageVolLookupByName.return_value = vol_mock
6501         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
6502         stream_mock = MagicMock()
6503         self.mock_conn.newStream.return_value = stream_mock
6504         open_mock = MagicMock()
6505         close_mock = MagicMock()
6506         with patch.dict(
6507             os.__dict__, {"open": open_mock, "close": close_mock}
6508         ):  # pylint: disable=no-member
6509             self.assertTrue(virt.volume_upload("pool0", "vol1.qcow2", "/path/to/file"))
6510             stream_mock.sendAll.assert_called_once()
6511             stream_mock.finish.assert_called_once()
6512             self.mock_conn.close.assert_called_once()
6513             vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
6514             stream_mock.sendAll.reset_mock()
6515             vol_mock.upload.reset_mock()
6516             self.assertTrue(
6517                 virt.volume_upload(
6518                     "pool0",
6519                     "vol1.qcow2",
6520                     "/path/to/file",
6521                     offset=123,
6522                     length=456,
6523                     sparse=True,
6524                 )
6525             )
6526             stream_mock.sendAll.assert_not_called()
6527             stream_mock.sparseSendAll.assert_called_once()
6528             vol_mock.upload.assert_called_once_with(
6529                 stream_mock,
6530                 123,
6531                 456,
6532                 self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
6533             )
6534             vol_mock.upload.side_effect = self.mock_libvirt.libvirtError("Unsupported")
6535             self.assertRaisesRegex(
6536                 CommandExecutionError,
6537                 "Unsupported",
6538                 virt.volume_upload,
6539                 "pool0",
6540                 "vol1.qcow2",
6541                 "/path/to/file",
6542             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
