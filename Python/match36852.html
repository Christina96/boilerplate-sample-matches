<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_state_format_slots.py &amp; test_symlink_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_state_format_slots.py &amp; test_symlink_1.py
      </h3>
<h1 align="center">
        7.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_state_format_slots.py (9.404388%)<th>test_symlink_1.py (5.6497173%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(130-137)<td><a href="#" name="0">(72-77)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(5-19)<td><a href="#" name="1">(9-22)</a><td align="center"><font color="#c30000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_state_format_slots.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
2 import pytest  # pylint: disable=unused-import
3 import salt.exceptions
4 import salt.state
5 import salt.utils.files
6 import salt.utils.platform
7 from tests.support.mock import MagicMock, patch
8 from tests.support.unit import skipIf
9 log = logging.getLogger(__name__)
10 @pytest.fixture
11 def</b></font> state_obj():
12     with patch("salt.state.State._gather_pillar"):
13         minion_opts = salt.config.DEFAULT_MINION_OPTS.copy()
14         yield salt.state.State(minion_opts)
15 def test_format_slots_no_slots(state_obj):
16     cdata = {"args": ["arg"], "kwargs": {"key": "val"}}
17     state_obj.format_slots(cdata)
18     assert cdata == {"args": ["arg"], "kwargs": {"key": "val"}}
19 @pytest.mark.slow_test
20 def test_format_slots_arg(state_obj):
21     cdata = {
22         "args": ["__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"],
23         "kwargs": {"key": "val"},
24     }
25     mock = MagicMock(return_value="fun_return")
26     with patch.dict(state_obj.functions, {"mod.fun": mock}):
27         state_obj.format_slots(cdata)
28     mock.assert_called_once_with("fun_arg", fun_key="fun_val")
29     assert cdata == {"args": ["fun_return"], "kwargs": {"key": "val"}}
30 @pytest.mark.slow_test
31 def test_format_slots_dict_arg(state_obj):
32     cdata = {
33         "args": [{"subarg": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"}],
34         "kwargs": {"key": "val"},
35     }
36     mock = MagicMock(return_value="fun_return")
37     with patch.dict(state_obj.functions, {"mod.fun": mock}):
38         state_obj.format_slots(cdata)
39     mock.assert_called_once_with("fun_arg", fun_key="fun_val")
40     assert cdata == {"args": [{"subarg": "fun_return"}], "kwargs": {"key": "val"}}
41 @pytest.mark.slow_test
42 def test_format_slots_listdict_arg(state_obj):
43     cdata = {
44         "args": [[{"subarg": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"}]],
45         "kwargs": {"key": "val"},
46     }
47     mock = MagicMock(return_value="fun_return")
48     with patch.dict(state_obj.functions, {"mod.fun": mock}):
49         state_obj.format_slots(cdata)
50     mock.assert_called_once_with("fun_arg", fun_key="fun_val")
51     assert cdata == {"args": [[{"subarg": "fun_return"}]], "kwargs": {"key": "val"}}
52 @pytest.mark.slow_test
53 def test_format_slots_liststr_arg(state_obj):
54     cdata = {
55         "args": [["__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"]],
56         "kwargs": {"key": "val"},
57     }
58     mock = MagicMock(return_value="fun_return")
59     with patch.dict(state_obj.functions, {"mod.fun": mock}):
60         state_obj.format_slots(cdata)
61     mock.assert_called_once_with("fun_arg", fun_key="fun_val")
62     assert cdata == {"args": [["fun_return"]], "kwargs": {"key": "val"}}
63 @pytest.mark.slow_test
64 def test_format_slots_kwarg(state_obj):
65     cdata = {
66         "args": ["arg"],
67         "kwargs": {"key": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"},
68     }
69     mock = MagicMock(return_value="fun_return")
70     with patch.dict(state_obj.functions, {"mod.fun": mock}):
71         state_obj.format_slots(cdata)
72     mock.assert_called_once_with("fun_arg", fun_key="fun_val")
73     assert cdata == {"args": ["arg"], "kwargs": {"key": "fun_return"}}
74 @pytest.mark.slow_test
75 def test_format_slots_multi(state_obj):
76     cdata = {
77         "args": [
78             "__slot__:salt:test_mod.fun_a(a_arg, a_key=a_kwarg)",
79             "__slot__:salt:test_mod.fun_b(b_arg, b_key=b_kwarg)",
80         ],
81         "kwargs": {
82             "kw_key_1": "__slot__:salt:test_mod.fun_c(c_arg, c_key=c_kwarg)",
83         },
84     }
85     mock_a <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value="fun_a_return")
86     mock_b = MagicMock(return_value="fun_b_return")
87     mock_c = MagicMock(return_value="fun_c_return")
88     mock_d = MagicMock(return_value="fun_d_return")
89     with patch.dict(
90         state_obj.functions,
91         {
92             "test_mod.fun_a"</b></font>: mock_a,
93             "test_mod.fun_b": mock_b,
94             "test_mod.fun_c": mock_c,
95             "test_mod.fun_d": mock_d,
96         },
97     ):
98         state_obj.format_slots(cdata)
99     mock_a.assert_called_once_with("a_arg", a_key="a_kwarg")
100     mock_b.assert_called_once_with("b_arg", b_key="b_kwarg")
101     mock_c.assert_called_once_with("c_arg", c_key="c_kwarg")
102     mock_d.assert_called_once_with("d_arg", d_key="d_kwarg")
103     assert cdata == {
104         "args": ["fun_a_return", "fun_b_return"],
105         "kwargs": {"kw_key_1": "fun_c_return", "kw_key_2": "fun_d_return"},
106     }
107 @pytest.mark.slow_test
108 def test_format_slots_malformed(state_obj):
109     sls_data = {
110         "args": [
111             "__slot__:NOT_SUPPORTED:not.called()",
112             "__slot__:salt:not.called(",
113             "__slot__:salt:",
114             "__slot__:salt",
115             "__slot__:",
116             "__slot__",
117         ],
118         "kwargs": {
119             "key3": "__slot__:NOT_SUPPORTED:not.called()",
120             "key4": "__slot__:salt:not.called(",
121             "key5": "__slot__:salt:",
122             "key6": "__slot__:salt",
123             "key7": "__slot__:",
124             "key8": "__slot__",
125         },
126     }
127     cdata = sls_data.copy()
128     mock = MagicMock(return_value="return")
129     with patch.dict(state_obj.functions, {"not.called": mock}):
130         state_obj.format_slots(cdata)
131     mock.assert_not_called()
132     assert cdata == sls_data
133 @pytest.mark.slow_test
134 def test_slot_traverse_dict(state_obj):
135     cdata = {
136         "args": ["arg"],
137         "kwargs": {"key": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val).key1"},
138     }
139     return_data = {"key1": "value1"}
140     mock = MagicMock(return_value=return_data)
141     with patch.dict(state_obj.functions, {"mod.fun": mock}):
142         state_obj.format_slots(cdata)
143     mock.assert_called_once_with("fun_arg", fun_key="fun_val")
144     assert cdata == {"args": ["arg"], "kwargs": {"key": "value1"}}
145 @pytest.mark.slow_test
146 def test_slot_append(state_obj):
147     cdata = {
148         "args": ["arg"],
149         "kwargs": {
150             "key": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val).key1 ~ thing~",
151         },
152     }
153     return_data = {"key1": "value1"}
154     mock = MagicMock(return_value=return_data)
155     with patch.dict(state_obj.functions, {"mod.fun": mock}):
156         state_obj.format_slots(cdata)
157     mock.assert_called_once_with("fun_arg", fun_key="fun_val")
158     assert cdata == {"args": ["arg"], "kwargs": {"key": "value1thing~"}}
159 @skipIf(
160     salt.utils.platform.is_windows(),
161     "Skipped until parallel states can be fixed on Windows",
162 )
163 def test_format_slots_parallel(state_obj):
164     high_data = {
165         "always-changes-and-succeeds": {
166             "test": [
167                 {"changes": True},
168                 {"comment": "__slot__:salt:test.echo(fun_return)"},
169                 {"parallel": True},
170                 "configurable_test_state",
171                 {"order": 10000},
172             ],
173             "__env__": "base",
174             "__sls__": "parallel_slots",
175         }
176     }
177     state_obj.jid = "123"
178     res = state_obj.call_high(high_data)
179     state_obj.jid = None
180     [(_, data)] = res.items()
181     assert data["comment"] == "fun_return"
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_symlink_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import pytest
4 import salt.serializers.json as jsonserializer
5 import salt.serializers.plist as plistserializer
6 import salt.serializers.python as pythonserializer
7 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.serializers.yaml as yamlserializer
8 import salt.states.file as filestate
9 import salt.utils.files
10 import salt.utils.json
11 import salt.utils.platform
12 import salt.utils.win_functions
13 import salt.utils.yaml
14 from tests.support.mock import MagicMock, patch
15 log = logging.getLogger(__name__)
16 @pytest.fixture
17 def</b></font> configure_loader_modules():
18     return {
19         filestate: {
20             "__env__": "base",
21             "__salt__": {"file.manage_file": False},
22             "__serializers__": {
23                 "yaml.serialize": yamlserializer.serialize,
24                 "yaml.seserialize": yamlserializer.serialize,
25                 "python.serialize": pythonserializer.serialize,
26                 "json.serialize": jsonserializer.serialize,
27                 "plist.serialize": plistserializer.serialize,
28                 "msgpack.serialize": msgpackserializer.serialize,
29             },
30             "__opts__": {"test": False, "cachedir": ""},
31             "__instance_id__": "",
32             "__low__": {},
33             "__utils__": {},
34         }
35     }
36 def test_symlink():
37     name = os.sep + os.path.join("tmp", "testfile.txt")
38     target = salt.utils.files.mkstemp()
39     test_dir = os.sep + "tmp"
40     user = "salt"
41     if salt.utils.platform.is_windows():
42         group = "salt"
43     else:
44         group = "saltstack"
45     def return_val(kwargs):
46         val = {
47             "name": name,
48             "result": False,
49             "comment": "",
50             "changes": {},
51         }
52         val.update(kwargs)
53         return val
54     mock_t = MagicMock(return_value=True)
55     mock_f = MagicMock(return_value=False)
56     mock_uid = MagicMock(return_value="U1001")
57     mock_gid = MagicMock(return_value="g1001")
58     mock_target <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value=target)
59     mock_user = MagicMock(return_value=user)
60     mock_grp = MagicMock(return_value=group)
61     mock_os_error = MagicMock(side_effect=OSError)
62     with patch.dict(filestate.__salt__, {"config.manage_mode"</b></font>: mock_t}):
63         comt = "Must provide name to file.symlink"
64         ret = return_val({"comment": comt, "name": ""})
65         assert filestate.symlink("", target) == ret
66     with patch.dict(
67         filestate.__salt__,
68         {
69             "config.manage_mode": mock_t,
70             "file.user_to_uid": mock_empty,
71             "file.group_to_gid": mock_empty,
72             "user.info": mock_empty,
73             "user.current": mock_user,
74         },
75     ):
76         if salt.utils.platform.is_windows():
77             comt = "User {} does not exist".format(user)
78             ret = return_val({"comment": comt, "name": name})
79         else:
80             comt = "User {} does not exist. Group {} does not exist.".format(
81                 user, group
82             )
83             ret = return_val({"comment": comt, "name": name})
84         assert filestate.symlink(name, target, user=user, group=group) == ret
85     with patch.dict(
86         filestate.__salt__,
87         {
88             "config.manage_mode": mock_t,
89             "file.user_to_uid": mock_uid,
90             "file.group_to_gid": mock_gid,
91             "file.is_link": mock_f,
92             "user.info": mock_empty,
93             "user.current": mock_user,
94         },
95     ), patch.dict(filestate.__opts__, {"test": True}), patch.object(
96         os.path, "exists", mock_f
97     ):
98         if salt.utils.platform.is_windows():
99             comt = "User {} does not exist".format(user)
100             ret = return_val(
101                 {"comment": comt, "result": False, "name": name, "changes": {}}
102             )
103         else:
104             comt = "Symlink {} to {} is set for creation".format(name, target)
105             ret = return_val(
106                 {"comment": comt, "result": None, "changes": {"new": name}}
107             )
108         assert filestate.symlink(name, target, user=user, group=group) == ret
109     with patch.dict(
110         filestate.__salt__,
111         {
112             "config.manage_mode": mock_t,
113             "file.user_to_uid": mock_uid,
114             "file.group_to_gid": mock_gid,
115             "file.is_link": mock_f,
116             "user.info": mock_empty,
117             "user.current": mock_user,
118         },
119     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
120         os.path, "isdir", mock_f
121     ), patch.object(
122         os.path, "exists", mock_f
123     ):
124         if salt.utils.platform.is_windows():
125             comt = "User {} does not exist".format(user)
126             ret = return_val(
127                 {"comment": comt, "result": False, "name": name, "changes": {}}
128             )
129         else:
130             comt = "Directory {} for symlink is not present".format(test_dir)
131             ret = return_val({"comment": comt, "result": False, "changes": {}})
132         assert filestate.symlink(name, target, user=user, group=group) == ret
133     with patch.dict(
134         filestate.__salt__,
135         {
136             "config.manage_mode": mock_t,
137             "file.user_to_uid": mock_uid,
138             "file.group_to_gid": mock_gid,
139             "file.is_link": mock_t,
140             "file.readlink": mock_target,
141             "user.info": mock_empty,
142             "user.current": mock_user,
143         },
144     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
145         os.path, "isdir", mock_t
146     ), patch.object(
147         salt.states.file, "_check_symlink_ownership", mock_t
148     ), patch(
149         "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
150     ):
151         if salt.utils.platform.is_windows():
152             comt = "Symlink {} is present and owned by {}".format(name, user)
153         else:
154             comt = "Symlink {} is present and owned by {}:{}".format(name, user, group)
155         ret = return_val({"comment": comt, "result": True, "changes": {}})
156         assert filestate.symlink(name, target, user=user, group=group) == ret
157     with patch.dict(
158         filestate.__salt__,
159         {
160             "config.manage_mode": mock_t,
161             "file.user_to_uid": mock_uid,
162             "file.group_to_gid": mock_gid,
163             "file.is_link": mock_f,
164             "file.readlink": mock_target,
165             "user.info": mock_empty,
166             "user.current": mock_user,
167         },
168     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
169         os.path, "isdir", mock_t
170     ), patch.object(
171         os.path, "exists", mock_t
172     ), patch.object(
173         os.path, "lexists", mock_t
174     ), patch(
175         "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
176     ):
177         comt = (
178             "Symlink &amp; backup dest exists and Force not set. {} -&gt; "
179             "{} - backup: {}".format(name, target, os.path.join(test_dir, "SALT"))
180         )
181         ret.update({"comment": comt, "result": False, "changes": {}})
182         assert (
183             filestate.symlink(name, target, user=user, group=group, backupname="SALT")
184             == ret
185         )
186     with patch.dict(
187         filestate.__salt__,
188         {
189             "config.manage_mode": mock_t,
190             "file.user_to_uid": mock_uid,
191             "file.group_to_gid": mock_gid,
192             "file.is_link": mock_f,
193             "file.readlink": mock_target,
194             "user.info": mock_empty,
195             "user.current": mock_user,
196         },
197     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
198         os.path, "exists", mock_t
199     ), patch.object(
200         os.path, "isfile", mock_t
201     ), patch.object(
202         os.path, "isdir", mock_t
203     ), patch(
204         "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
205     ):
206         comt = "Backupname must be an absolute path or a file name: {}".format(
207             "tmp/SALT"
208         )
209         ret.update({"comment": comt, "result": False, "changes": {}})
210         assert (
211             filestate.symlink(
212                 name, target, user=user, group=group, backupname="tmp/SALT"
213             )
214             == ret
215         )
216     with patch.dict(
217         filestate.__salt__,
218         {
219             "config.manage_mode": mock_t,
220             "file.user_to_uid": mock_uid,
221             "file.group_to_gid": mock_gid,
222             "file.is_link": mock_f,
223             "file.readlink": mock_target,
224             "user.info": mock_empty,
225             "user.current": mock_user,
226         },
227     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
228         os.path, "isdir", mock_t
229     ), patch.object(
230         os.path, "exists", mock_t
231     ), patch.object(
232         os.path, "isfile", mock_t
233     ), patch(
234         "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
235     ):
236         comt = "File exists where the symlink {} should be".format(name)
237         ret = return_val({"comment": comt, "changes": {}, "result": False})
238         assert filestate.symlink(name, target, user=user, group=group) == ret
239     with patch.dict(
240         filestate.__salt__,
241         {
242             "config.manage_mode": mock_t,
243             "file.user_to_uid": mock_uid,
244             "file.group_to_gid": mock_gid,
245             "file.is_link": mock_f,
246             "file.readlink": mock_target,
247             "file.symlink": mock_t,
248             "user.info": mock_t,
249             "file.lchown": mock_f,
250         },
251     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
252         os.path, "isdir", MagicMock(side_effect=[True, False])
253     ), patch.object(
254         os.path, "isdir", mock_t
255     ), patch.object(
256         os.path, "exists", mock_t
257     ), patch(
258         "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
259     ):
260         comt = "Directory exists where the symlink {} should be".format(name)
261         ret = return_val({"comment": comt, "result": False, "changes": {}})
262         assert filestate.symlink(name, target, user=user, group=group) == ret
263     with patch.dict(
264         filestate.__salt__,
265         {
266             "config.manage_mode": mock_t,
267             "file.user_to_uid": mock_uid,
268             "file.group_to_gid": mock_gid,
269             "file.is_link": mock_f,
270             "file.readlink": mock_target,
271             "file.symlink": mock_os_error,
272             "user.info": mock_t,
273             "file.lchown": mock_f,
274         },
275     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
276         os.path, "isdir", MagicMock(side_effect=[True, False])
277     ), patch.object(
278         os.path, "isfile", mock_f
279     ), patch(
280         "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
281     ):
282         comt = "Unable to create new symlink {} -&gt; {}: ".format(name, target)
283         ret = return_val({"comment": comt, "result": False, "changes": {}})
284         assert filestate.symlink(name, target, user=user, group=group) == ret
285     with patch.dict(
286         filestate.__salt__,
287         {
288             "config.manage_mode": mock_t,
289             "file.user_to_uid": mock_uid,
290             "file.group_to_gid": mock_gid,
291             "file.is_link": mock_f,
292             "file.readlink": mock_target,
293             "file.symlink": mock_t,
294             "user.info": mock_t,
295             "file.lchown": mock_f,
296             "file.get_user": mock_user,
297             "file.get_group": mock_grp,
298         },
299     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
300         os.path, "isdir", MagicMock(side_effect=[True, False])
301     ), patch.object(
302         os.path, "isfile", mock_f
303     ), patch(
304         "salt.states.file._check_symlink_ownership", return_value=True
305     ), patch(
306         "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
307     ):
308         comt = "Created new symlink {} -&gt; {}".format(name, target)
309         ret = return_val({"comment": comt, "result": True, "changes": {"new": name}})
310         assert filestate.symlink(name, target, user=user, group=group) == ret
311     with patch.dict(
312         filestate.__salt__,
313         {
314             "config.manage_mode": mock_t,
315             "file.user_to_uid": mock_uid,
316             "file.group_to_gid": mock_gid,
317             "file.is_link": mock_f,
318             "file.readlink": mock_target,
319             "file.symlink": mock_t,
320             "user.info": mock_t,
321             "file.lchown": mock_f,
322             "file.get_user": mock_empty,
323             "file.get_group": mock_empty,
324         },
325     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
326         os.path, "isdir", MagicMock(side_effect=[True, False])
327     ), patch.object(
328         os.path, "isfile", mock_f
329     ), patch(
330         "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
331     ), patch(
332         "salt.states.file._set_symlink_ownership", return_value=False
333     ), patch(
334         "salt.states.file._check_symlink_ownership", return_value=False
335     ):
336         comt = (
337             "Created new symlink {} -&gt; {}, but was unable to set "
338             "ownership to {}:{}".format(name, target, user, group)
339         )
340         ret = return_val({"comment": comt, "result": False, "changes": {"new": name}})
341         assert filestate.symlink(name, target, user=user, group=group) == ret
342     with patch.dict(
343         filestate.__salt__,
344         {
345             "config.manage_mode": mock_t,
346             "file.user_to_uid": mock_uid,
347             "file.group_to_gid": mock_gid,
348             "file.is_link": mock_f,
349             "file.readlink": mock_target,
350             "file.symlink": mock_t,
351             "user.info": mock_t,
352             "file.lchown": mock_f,
353             "file.get_user": mock_empty,
354             "file.get_group": mock_empty,
355         },
356     ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
357         os.path, "isdir", MagicMock(side_effect=[True, False])
358     ), patch.object(
359         os.path, "isfile", mock_f
360     ), patch(
361         "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
362     ), patch(
363         "salt.states.file._set_symlink_ownership", return_value=True
364     ), patch(
365         "salt.states.file._check_symlink_ownership", return_value=True
366     ):
367         group = None
368         comt = "Created new symlink {} -&gt; {}".format(name, target)
369         ret = return_val({"comment": comt, "result": True, "changes": {"new": name}})
370         res = filestate.symlink(name, target, user=user, group=user)
371         assert res == ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
