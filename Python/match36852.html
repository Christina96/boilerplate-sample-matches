<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_state_format_slots.py &amp; test_symlink_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_state_format_slots.py &amp; test_symlink_1.py
      </h3>
<h1 align="center">
        7.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_state_format_slots.py (9.404388%)<th>test_symlink_1.py (5.6497173%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(130-137)<td><a href="#" name="0">(72-77)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(5-19)<td><a href="#" name="1">(9-22)</a><td align="center"><font color="#c30000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_state_format_slots.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
import pytest  # pylint: disable=unused-import
import salt.exceptions
import salt.state
import salt.utils.files
import salt.utils.platform
from tests.support.mock import MagicMock, patch
from tests.support.unit import skipIf
log = logging.getLogger(__name__)
@pytest.fixture
def</b></font> state_obj():
    with patch("salt.state.State._gather_pillar"):
        minion_opts = salt.config.DEFAULT_MINION_OPTS.copy()
        yield salt.state.State(minion_opts)
def test_format_slots_no_slots(state_obj):
    cdata = {"args": ["arg"], "kwargs": {"key": "val"}}
    state_obj.format_slots(cdata)
    assert cdata == {"args": ["arg"], "kwargs": {"key": "val"}}
@pytest.mark.slow_test
def test_format_slots_arg(state_obj):
    cdata = {
        "args": ["__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"],
        "kwargs": {"key": "val"},
    }
    mock = MagicMock(return_value="fun_return")
    with patch.dict(state_obj.functions, {"mod.fun": mock}):
        state_obj.format_slots(cdata)
    mock.assert_called_once_with("fun_arg", fun_key="fun_val")
    assert cdata == {"args": ["fun_return"], "kwargs": {"key": "val"}}
@pytest.mark.slow_test
def test_format_slots_dict_arg(state_obj):
    cdata = {
        "args": [{"subarg": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"}],
        "kwargs": {"key": "val"},
    }
    mock = MagicMock(return_value="fun_return")
    with patch.dict(state_obj.functions, {"mod.fun": mock}):
        state_obj.format_slots(cdata)
    mock.assert_called_once_with("fun_arg", fun_key="fun_val")
    assert cdata == {"args": [{"subarg": "fun_return"}], "kwargs": {"key": "val"}}
@pytest.mark.slow_test
def test_format_slots_listdict_arg(state_obj):
    cdata = {
        "args": [[{"subarg": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"}]],
        "kwargs": {"key": "val"},
    }
    mock = MagicMock(return_value="fun_return")
    with patch.dict(state_obj.functions, {"mod.fun": mock}):
        state_obj.format_slots(cdata)
    mock.assert_called_once_with("fun_arg", fun_key="fun_val")
    assert cdata == {"args": [[{"subarg": "fun_return"}]], "kwargs": {"key": "val"}}
@pytest.mark.slow_test
def test_format_slots_liststr_arg(state_obj):
    cdata = {
        "args": [["__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"]],
        "kwargs": {"key": "val"},
    }
    mock = MagicMock(return_value="fun_return")
    with patch.dict(state_obj.functions, {"mod.fun": mock}):
        state_obj.format_slots(cdata)
    mock.assert_called_once_with("fun_arg", fun_key="fun_val")
    assert cdata == {"args": [["fun_return"]], "kwargs": {"key": "val"}}
@pytest.mark.slow_test
def test_format_slots_kwarg(state_obj):
    cdata = {
        "args": ["arg"],
        "kwargs": {"key": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val)"},
    }
    mock = MagicMock(return_value="fun_return")
    with patch.dict(state_obj.functions, {"mod.fun": mock}):
        state_obj.format_slots(cdata)
    mock.assert_called_once_with("fun_arg", fun_key="fun_val")
    assert cdata == {"args": ["arg"], "kwargs": {"key": "fun_return"}}
@pytest.mark.slow_test
def test_format_slots_multi(state_obj):
    cdata = {
        "args": [
            "__slot__:salt:test_mod.fun_a(a_arg, a_key=a_kwarg)",
            "__slot__:salt:test_mod.fun_b(b_arg, b_key=b_kwarg)",
        ],
        "kwargs": {
            "kw_key_1": "__slot__:salt:test_mod.fun_c(c_arg, c_key=c_kwarg)",
<a name="0"></a>            "kw_key_2": "__slot__:salt:test_mod.fun_d(d_arg, d_key=d_kwarg)",
        },
    }
    mock_a <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value="fun_a_return")
    mock_b = MagicMock(return_value="fun_b_return")
    mock_c = MagicMock(return_value="fun_c_return")
    mock_d = MagicMock(return_value="fun_d_return")
    with patch.dict(
        state_obj.functions,
        {
            "test_mod.fun_a"</b></font>: mock_a,
            "test_mod.fun_b": mock_b,
            "test_mod.fun_c": mock_c,
            "test_mod.fun_d": mock_d,
        },
    ):
        state_obj.format_slots(cdata)
    mock_a.assert_called_once_with("a_arg", a_key="a_kwarg")
    mock_b.assert_called_once_with("b_arg", b_key="b_kwarg")
    mock_c.assert_called_once_with("c_arg", c_key="c_kwarg")
    mock_d.assert_called_once_with("d_arg", d_key="d_kwarg")
    assert cdata == {
        "args": ["fun_a_return", "fun_b_return"],
        "kwargs": {"kw_key_1": "fun_c_return", "kw_key_2": "fun_d_return"},
    }
@pytest.mark.slow_test
def test_format_slots_malformed(state_obj):
    sls_data = {
        "args": [
            "__slot__:NOT_SUPPORTED:not.called()",
            "__slot__:salt:not.called(",
            "__slot__:salt:",
            "__slot__:salt",
            "__slot__:",
            "__slot__",
        ],
        "kwargs": {
            "key3": "__slot__:NOT_SUPPORTED:not.called()",
            "key4": "__slot__:salt:not.called(",
            "key5": "__slot__:salt:",
            "key6": "__slot__:salt",
            "key7": "__slot__:",
            "key8": "__slot__",
        },
    }
    cdata = sls_data.copy()
    mock = MagicMock(return_value="return")
    with patch.dict(state_obj.functions, {"not.called": mock}):
        state_obj.format_slots(cdata)
    mock.assert_not_called()
    assert cdata == sls_data
@pytest.mark.slow_test
def test_slot_traverse_dict(state_obj):
    cdata = {
        "args": ["arg"],
        "kwargs": {"key": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val).key1"},
    }
    return_data = {"key1": "value1"}
    mock = MagicMock(return_value=return_data)
    with patch.dict(state_obj.functions, {"mod.fun": mock}):
        state_obj.format_slots(cdata)
    mock.assert_called_once_with("fun_arg", fun_key="fun_val")
    assert cdata == {"args": ["arg"], "kwargs": {"key": "value1"}}
@pytest.mark.slow_test
def test_slot_append(state_obj):
    cdata = {
        "args": ["arg"],
        "kwargs": {
            "key": "__slot__:salt:mod.fun(fun_arg, fun_key=fun_val).key1 ~ thing~",
        },
    }
    return_data = {"key1": "value1"}
    mock = MagicMock(return_value=return_data)
    with patch.dict(state_obj.functions, {"mod.fun": mock}):
        state_obj.format_slots(cdata)
    mock.assert_called_once_with("fun_arg", fun_key="fun_val")
    assert cdata == {"args": ["arg"], "kwargs": {"key": "value1thing~"}}
@skipIf(
    salt.utils.platform.is_windows(),
    "Skipped until parallel states can be fixed on Windows",
)
def test_format_slots_parallel(state_obj):
    high_data = {
        "always-changes-and-succeeds": {
            "test": [
                {"changes": True},
                {"comment": "__slot__:salt:test.echo(fun_return)"},
                {"parallel": True},
                "configurable_test_state",
                {"order": 10000},
            ],
            "__env__": "base",
            "__sls__": "parallel_slots",
        }
    }
    state_obj.jid = "123"
    res = state_obj.call_high(high_data)
    state_obj.jid = None
    [(_, data)] = res.items()
    assert data["comment"] == "fun_return"
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_symlink_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import os
import pytest
import salt.serializers.json as jsonserializer
<a name="1"></a>import salt.serializers.msgpack as msgpackserializer
import salt.serializers.plist as plistserializer
import salt.serializers.python as pythonserializer
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.serializers.yaml as yamlserializer
import salt.states.file as filestate
import salt.utils.files
import salt.utils.json
import salt.utils.platform
import salt.utils.win_functions
import salt.utils.yaml
from tests.support.mock import MagicMock, patch
log = logging.getLogger(__name__)
@pytest.fixture
def</b></font> configure_loader_modules():
    return {
        filestate: {
            "__env__": "base",
            "__salt__": {"file.manage_file": False},
            "__serializers__": {
                "yaml.serialize": yamlserializer.serialize,
                "yaml.seserialize": yamlserializer.serialize,
                "python.serialize": pythonserializer.serialize,
                "json.serialize": jsonserializer.serialize,
                "plist.serialize": plistserializer.serialize,
                "msgpack.serialize": msgpackserializer.serialize,
            },
            "__opts__": {"test": False, "cachedir": ""},
            "__instance_id__": "",
            "__low__": {},
            "__utils__": {},
        }
    }
def test_symlink():
    name = os.sep + os.path.join("tmp", "testfile.txt")
    target = salt.utils.files.mkstemp()
    test_dir = os.sep + "tmp"
    user = "salt"
    if salt.utils.platform.is_windows():
        group = "salt"
    else:
        group = "saltstack"
    def return_val(kwargs):
        val = {
            "name": name,
            "result": False,
            "comment": "",
            "changes": {},
        }
        val.update(kwargs)
        return val
    mock_t = MagicMock(return_value=True)
    mock_f = MagicMock(return_value=False)
<a name="0"></a>    mock_empty = MagicMock(return_value="")
    mock_uid = MagicMock(return_value="U1001")
    mock_gid = MagicMock(return_value="g1001")
    mock_target <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value=target)
    mock_user = MagicMock(return_value=user)
    mock_grp = MagicMock(return_value=group)
    mock_os_error = MagicMock(side_effect=OSError)
    with patch.dict(filestate.__salt__, {"config.manage_mode"</b></font>: mock_t}):
        comt = "Must provide name to file.symlink"
        ret = return_val({"comment": comt, "name": ""})
        assert filestate.symlink("", target) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_empty,
            "file.group_to_gid": mock_empty,
            "user.info": mock_empty,
            "user.current": mock_user,
        },
    ):
        if salt.utils.platform.is_windows():
            comt = "User {} does not exist".format(user)
            ret = return_val({"comment": comt, "name": name})
        else:
            comt = "User {} does not exist. Group {} does not exist.".format(
                user, group
            )
            ret = return_val({"comment": comt, "name": name})
        assert filestate.symlink(name, target, user=user, group=group) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "user.info": mock_empty,
            "user.current": mock_user,
        },
    ), patch.dict(filestate.__opts__, {"test": True}), patch.object(
        os.path, "exists", mock_f
    ):
        if salt.utils.platform.is_windows():
            comt = "User {} does not exist".format(user)
            ret = return_val(
                {"comment": comt, "result": False, "name": name, "changes": {}}
            )
        else:
            comt = "Symlink {} to {} is set for creation".format(name, target)
            ret = return_val(
                {"comment": comt, "result": None, "changes": {"new": name}}
            )
        assert filestate.symlink(name, target, user=user, group=group) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "user.info": mock_empty,
            "user.current": mock_user,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "isdir", mock_f
    ), patch.object(
        os.path, "exists", mock_f
    ):
        if salt.utils.platform.is_windows():
            comt = "User {} does not exist".format(user)
            ret = return_val(
                {"comment": comt, "result": False, "name": name, "changes": {}}
            )
        else:
            comt = "Directory {} for symlink is not present".format(test_dir)
            ret = return_val({"comment": comt, "result": False, "changes": {}})
        assert filestate.symlink(name, target, user=user, group=group) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_t,
            "file.readlink": mock_target,
            "user.info": mock_empty,
            "user.current": mock_user,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "isdir", mock_t
    ), patch.object(
        salt.states.file, "_check_symlink_ownership", mock_t
    ), patch(
        "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
    ):
        if salt.utils.platform.is_windows():
            comt = "Symlink {} is present and owned by {}".format(name, user)
        else:
            comt = "Symlink {} is present and owned by {}:{}".format(name, user, group)
        ret = return_val({"comment": comt, "result": True, "changes": {}})
        assert filestate.symlink(name, target, user=user, group=group) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "file.readlink": mock_target,
            "user.info": mock_empty,
            "user.current": mock_user,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "isdir", mock_t
    ), patch.object(
        os.path, "exists", mock_t
    ), patch.object(
        os.path, "lexists", mock_t
    ), patch(
        "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
    ):
        comt = (
            "Symlink &amp; backup dest exists and Force not set. {} -&gt; "
            "{} - backup: {}".format(name, target, os.path.join(test_dir, "SALT"))
        )
        ret.update({"comment": comt, "result": False, "changes": {}})
        assert (
            filestate.symlink(name, target, user=user, group=group, backupname="SALT")
            == ret
        )
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "file.readlink": mock_target,
            "user.info": mock_empty,
            "user.current": mock_user,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "exists", mock_t
    ), patch.object(
        os.path, "isfile", mock_t
    ), patch.object(
        os.path, "isdir", mock_t
    ), patch(
        "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
    ):
        comt = "Backupname must be an absolute path or a file name: {}".format(
            "tmp/SALT"
        )
        ret.update({"comment": comt, "result": False, "changes": {}})
        assert (
            filestate.symlink(
                name, target, user=user, group=group, backupname="tmp/SALT"
            )
            == ret
        )
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "file.readlink": mock_target,
            "user.info": mock_empty,
            "user.current": mock_user,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "isdir", mock_t
    ), patch.object(
        os.path, "exists", mock_t
    ), patch.object(
        os.path, "isfile", mock_t
    ), patch(
        "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
    ):
        comt = "File exists where the symlink {} should be".format(name)
        ret = return_val({"comment": comt, "changes": {}, "result": False})
        assert filestate.symlink(name, target, user=user, group=group) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "file.readlink": mock_target,
            "file.symlink": mock_t,
            "user.info": mock_t,
            "file.lchown": mock_f,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "isdir", MagicMock(side_effect=[True, False])
    ), patch.object(
        os.path, "isdir", mock_t
    ), patch.object(
        os.path, "exists", mock_t
    ), patch(
        "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
    ):
        comt = "Directory exists where the symlink {} should be".format(name)
        ret = return_val({"comment": comt, "result": False, "changes": {}})
        assert filestate.symlink(name, target, user=user, group=group) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "file.readlink": mock_target,
            "file.symlink": mock_os_error,
            "user.info": mock_t,
            "file.lchown": mock_f,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "isdir", MagicMock(side_effect=[True, False])
    ), patch.object(
        os.path, "isfile", mock_f
    ), patch(
        "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
    ):
        comt = "Unable to create new symlink {} -&gt; {}: ".format(name, target)
        ret = return_val({"comment": comt, "result": False, "changes": {}})
        assert filestate.symlink(name, target, user=user, group=group) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "file.readlink": mock_target,
            "file.symlink": mock_t,
            "user.info": mock_t,
            "file.lchown": mock_f,
            "file.get_user": mock_user,
            "file.get_group": mock_grp,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "isdir", MagicMock(side_effect=[True, False])
    ), patch.object(
        os.path, "isfile", mock_f
    ), patch(
        "salt.states.file._check_symlink_ownership", return_value=True
    ), patch(
        "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
    ):
        comt = "Created new symlink {} -&gt; {}".format(name, target)
        ret = return_val({"comment": comt, "result": True, "changes": {"new": name}})
        assert filestate.symlink(name, target, user=user, group=group) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "file.readlink": mock_target,
            "file.symlink": mock_t,
            "user.info": mock_t,
            "file.lchown": mock_f,
            "file.get_user": mock_empty,
            "file.get_group": mock_empty,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "isdir", MagicMock(side_effect=[True, False])
    ), patch.object(
        os.path, "isfile", mock_f
    ), patch(
        "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
    ), patch(
        "salt.states.file._set_symlink_ownership", return_value=False
    ), patch(
        "salt.states.file._check_symlink_ownership", return_value=False
    ):
        comt = (
            "Created new symlink {} -&gt; {}, but was unable to set "
            "ownership to {}:{}".format(name, target, user, group)
        )
        ret = return_val({"comment": comt, "result": False, "changes": {"new": name}})
        assert filestate.symlink(name, target, user=user, group=group) == ret
    with patch.dict(
        filestate.__salt__,
        {
            "config.manage_mode": mock_t,
            "file.user_to_uid": mock_uid,
            "file.group_to_gid": mock_gid,
            "file.is_link": mock_f,
            "file.readlink": mock_target,
            "file.symlink": mock_t,
            "user.info": mock_t,
            "file.lchown": mock_f,
            "file.get_user": mock_empty,
            "file.get_group": mock_empty,
        },
    ), patch.dict(filestate.__opts__, {"test": False}), patch.object(
        os.path, "isdir", MagicMock(side_effect=[True, False])
    ), patch.object(
        os.path, "isfile", mock_f
    ), patch(
        "salt.utils.win_functions.get_sid_from_name", return_value="test-sid"
    ), patch(
        "salt.states.file._set_symlink_ownership", return_value=True
    ), patch(
        "salt.states.file._check_symlink_ownership", return_value=True
    ):
        group = None
        comt = "Created new symlink {} -&gt; {}".format(name, target)
        ret = return_val({"comment": comt, "result": True, "changes": {"new": name}})
        res = filestate.symlink(name, target, user=user, group=user)
        assert res == ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
