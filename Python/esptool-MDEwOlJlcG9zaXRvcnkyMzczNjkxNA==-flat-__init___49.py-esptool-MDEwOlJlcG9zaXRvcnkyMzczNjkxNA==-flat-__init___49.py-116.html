
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___49.py</h3>
            <pre><code>1  __all__ = [
2      &quot;chip_id&quot;,
3      &quot;detect_chip&quot;,
4      &quot;dump_mem&quot;,
5      &quot;elf2image&quot;,
6      &quot;erase_flash&quot;,
7      &quot;erase_region&quot;,
8      &quot;flash_id&quot;,
9      &quot;get_security_info&quot;,
10      &quot;image_info&quot;,
11      &quot;load_ram&quot;,
12      &quot;make_image&quot;,
13      &quot;merge_bin&quot;,
14      &quot;read_flash&quot;,
15      &quot;read_flash_status&quot;,
16      &quot;read_mac&quot;,
17      &quot;read_mem&quot;,
18      &quot;run&quot;,
19      &quot;verify_flash&quot;,
20      &quot;version&quot;,
21      &quot;write_flash&quot;,
22      &quot;write_flash_status&quot;,
23      &quot;write_mem&quot;,
24  ]
25  __version__ = &quot;4.7-dev&quot;
26  import argparse
27  import inspect
28  import os
29  import shlex
30  import sys
31  import time
32  import traceback
33  from esptool.cmds import (
34      DETECTED_FLASH_SIZES,
35      chip_id,
36      detect_chip,
37      detect_flash_size,
38      dump_mem,
39      elf2image,
40      erase_flash,
41      erase_region,
42      flash_id,
43      get_security_info,
44      image_info,
45      load_ram,
46      make_image,
47      merge_bin,
48      read_flash,
49      read_flash_status,
50      read_mac,
51      read_mem,
52      run,
53      verify_flash,
54      version,
55      write_flash,
56      write_flash_status,
57      write_mem,
58  )
59  from esptool.config import load_config_file
60  from esptool.loader import DEFAULT_CONNECT_ATTEMPTS, ESPLoader, list_ports
61  from esptool.targets import CHIP_DEFS, CHIP_LIST, ESP32ROM
62  from esptool.util import (
63      FatalError,
64      NotImplementedInROMError,
65      flash_size_bytes,
66      strip_chip_name,
67  )
68  import serial
69  def main(argv=None, esp=None):
70      external_esp = esp is not None
71      parser = argparse.ArgumentParser(
72          description=&quot;esptool.py v%s - Espressif chips ROM Bootloader Utility&quot;
73          % __version__,
74          prog=&quot;esptool&quot;,
75      )
76      parser.add_argument(
77          &quot;--chip&quot;,
78          &quot;-c&quot;,
79          help=&quot;Target chip type&quot;,
80          type=strip_chip_name,
81          choices=[&quot;auto&quot;] + CHIP_LIST,
82          default=os.environ.get(&quot;ESPTOOL_CHIP&quot;, &quot;auto&quot;),
83      )
84      parser.add_argument(
85          &quot;--port&quot;,
86          &quot;-p&quot;,
87          help=&quot;Serial port device&quot;,
88          default=os.environ.get(&quot;ESPTOOL_PORT&quot;, None),
89      )
90      parser.add_argument(
91          &quot;--baud&quot;,
92          &quot;-b&quot;,
93          help=&quot;Serial port baud rate used when flashing/reading&quot;,
94          type=arg_auto_int,
95          default=os.environ.get(&quot;ESPTOOL_BAUD&quot;, ESPLoader.ESP_ROM_BAUD),
96      )
97      parser.add_argument(
98          &quot;--before&quot;,
99          help=&quot;What to do before connecting to the chip&quot;,
100          choices=[&quot;default_reset&quot;, &quot;usb_reset&quot;, &quot;no_reset&quot;, &quot;no_reset_no_sync&quot;],
101          default=os.environ.get(&quot;ESPTOOL_BEFORE&quot;, &quot;default_reset&quot;),
102      )
103      parser.add_argument(
104          &quot;--after&quot;,
105          &quot;-a&quot;,
106          help=&quot;What to do after esptool.py is finished&quot;,
107          choices=[&quot;hard_reset&quot;, &quot;soft_reset&quot;, &quot;no_reset&quot;, &quot;no_reset_stub&quot;],
108          default=os.environ.get(&quot;ESPTOOL_AFTER&quot;, &quot;hard_reset&quot;),
109      )
110      parser.add_argument(
111          &quot;--no-stub&quot;,
112          help=&quot;Disable launching the flasher stub, only talk to ROM bootloader. &quot;
113          &quot;Some features will not be available.&quot;,
114          action=&quot;store_true&quot;,
115      )
116      parser.add_argument(
117          &quot;--trace&quot;,
118          &quot;-t&quot;,
119          help=&quot;Enable trace-level output of esptool.py interactions.&quot;,
120          action=&quot;store_true&quot;,
121      )
122      parser.add_argument(
123          &quot;--override-vddsdio&quot;,
124          help=&quot;Override ESP32 VDDSDIO internal voltage regulator (use with care)&quot;,
125          choices=ESP32ROM.OVERRIDE_VDDSDIO_CHOICES,
126          nargs=&quot;?&quot;,
127      )
128      parser.add_argument(
129          &quot;--connect-attempts&quot;,
130          help=(
131              &quot;Number of attempts to connect, negative or 0 for infinite. &quot;
132              &quot;Default: %d.&quot; % DEFAULT_CONNECT_ATTEMPTS
133          ),
134          type=int,
135          default=os.environ.get(&quot;ESPTOOL_CONNECT_ATTEMPTS&quot;, DEFAULT_CONNECT_ATTEMPTS),
136      )
137      subparsers = parser.add_subparsers(
138          dest=&quot;operation&quot;, help=&quot;Run esptool.py {command} -h for additional help&quot;
139      )
140      def add_spi_connection_arg(parent):
141          parent.add_argument(
142              &quot;--spi-connection&quot;,
143              &quot;-sc&quot;,
144              help=&quot;ESP32-only argument. Override default SPI Flash connection. &quot;
145              &quot;Value can be SPI, HSPI or a comma-separated list of 5 I/O numbers &quot;
146              &quot;to use for SPI flash (CLK,Q,D,HD,CS).&quot;,
147              action=SpiConnectionAction,
148          )
149      parser_load_ram = subparsers.add_parser(
150          &quot;load_ram&quot;, help=&quot;Download an image to RAM and execute&quot;
151      )
152      parser_load_ram.add_argument(&quot;filename&quot;, help=&quot;Firmware image&quot;)
153      parser_dump_mem = subparsers.add_parser(
154          &quot;dump_mem&quot;, help=&quot;Dump arbitrary memory to disk&quot;
155      )
156      parser_dump_mem.add_argument(&quot;address&quot;, help=&quot;Base address&quot;, type=arg_auto_int)
157      parser_dump_mem.add_argument(
158          &quot;size&quot;, help=&quot;Size of region to dump&quot;, type=arg_auto_int
159      )
160      parser_dump_mem.add_argument(&quot;filename&quot;, help=&quot;Name of binary dump&quot;)
161      parser_read_mem = subparsers.add_parser(
162          &quot;read_mem&quot;, help=&quot;Read arbitrary memory location&quot;
163      )
164      parser_read_mem.add_argument(&quot;address&quot;, help=&quot;Address to read&quot;, type=arg_auto_int)
165      parser_write_mem = subparsers.add_parser(
166          &quot;write_mem&quot;, help=&quot;Read-modify-write to arbitrary memory location&quot;
167      )
168      parser_write_mem.add_argument(&quot;address&quot;, help=&quot;Address to write&quot;, type=arg_auto_int)
169      parser_write_mem.add_argument(&quot;value&quot;, help=&quot;Value&quot;, type=arg_auto_int)
170      parser_write_mem.add_argument(
171          &quot;mask&quot;,
172          help=&quot;Mask of bits to write&quot;,
173          type=arg_auto_int,
174          nargs=&quot;?&quot;,
175          default=&quot;0xFFFFFFFF&quot;,
176      )
177      def add_spi_flash_subparsers(parent, allow_keep, auto_detect):
178          extra_keep_args = [&quot;keep&quot;] if allow_keep else []
179          if auto_detect and allow_keep:
180              extra_fs_message = &quot;, detect, or keep&quot;
181              flash_sizes = [&quot;detect&quot;, &quot;keep&quot;]
182          elif auto_detect:
183              extra_fs_message = &quot;, or detect&quot;
184              flash_sizes = [&quot;detect&quot;]
185          elif allow_keep:
186              extra_fs_message = &quot;, or keep&quot;
187              flash_sizes = [&quot;keep&quot;]
188          else:
189              extra_fs_message = &quot;&quot;
190              flash_sizes = []
191          parent.add_argument(
192              &quot;--flash_freq&quot;,
193              &quot;-ff&quot;,
194              help=&quot;SPI Flash frequency&quot;,
195              choices=extra_keep_args
196              + [
197                  &quot;80m&quot;,
198                  &quot;60m&quot;,
199                  &quot;48m&quot;,
200                  &quot;40m&quot;,
201                  &quot;30m&quot;,
202                  &quot;26m&quot;,
203                  &quot;24m&quot;,
204                  &quot;20m&quot;,
205                  &quot;16m&quot;,
206                  &quot;15m&quot;,
207                  &quot;12m&quot;,
208              ],
209              default=os.environ.get(&quot;ESPTOOL_FF&quot;, &quot;keep&quot; if allow_keep else None),
210          )
211          parent.add_argument(
212              &quot;--flash_mode&quot;,
213              &quot;-fm&quot;,
214              help=&quot;SPI Flash mode&quot;,
215              choices=extra_keep_args + [&quot;qio&quot;, &quot;qout&quot;, &quot;dio&quot;, &quot;dout&quot;],
216              default=os.environ.get(&quot;ESPTOOL_FM&quot;, &quot;keep&quot; if allow_keep else &quot;qio&quot;),
217          )
218          parent.add_argument(
219              &quot;--flash_size&quot;,
220              &quot;-fs&quot;,
221              help=&quot;SPI Flash size in MegaBytes &quot;
222              &quot;(1MB, 2MB, 4MB, 8MB, 16MB, 32MB, 64MB, 128MB) &quot;
223              &quot;plus ESP8266-only (256KB, 512KB, 2MB-c1, 4MB-c1)&quot; + extra_fs_message,
224              choices=flash_sizes
225              + [
226                  &quot;256KB&quot;,
227                  &quot;512KB&quot;,
228                  &quot;1MB&quot;,
229                  &quot;2MB&quot;,
230                  &quot;2MB-c1&quot;,
231                  &quot;4MB&quot;,
232                  &quot;4MB-c1&quot;,
233                  &quot;8MB&quot;,
234                  &quot;16MB&quot;,
235                  &quot;32MB&quot;,
236                  &quot;64MB&quot;,
237                  &quot;128MB&quot;,
238              ],
239              default=os.environ.get(&quot;ESPTOOL_FS&quot;, &quot;keep&quot; if allow_keep else &quot;1MB&quot;),
240          )
241          add_spi_connection_arg(parent)
242      parser_write_flash = subparsers.add_parser(
243          &quot;write_flash&quot;, help=&quot;Write a binary blob to flash&quot;
244      )
245      parser_write_flash.add_argument(
246          &quot;addr_filename&quot;,
247          metavar=&quot;&lt;address&gt; &lt;filename&gt;&quot;,
248          help=&quot;Address followed by binary filename, separated by space&quot;,
249          action=AddrFilenamePairAction,
250      )
251      parser_write_flash.add_argument(
252          &quot;--erase-all&quot;,
253          &quot;-e&quot;,
254          help=&quot;Erase all regions of flash (not just write areas) before programming&quot;,
255          action=&quot;store_true&quot;,
256      )
257      add_spi_flash_subparsers(parser_write_flash, allow_keep=True, auto_detect=True)
258      parser_write_flash.add_argument(
259          &quot;--no-progress&quot;, &quot;-p&quot;, help=&quot;Suppress progress output&quot;, action=&quot;store_true&quot;
260      )
261      parser_write_flash.add_argument(
262          &quot;--verify&quot;,
263          help=&quot;Verify just-written data on flash &quot;
264          &quot;(mostly superfluous, data is read back during flashing)&quot;,
265          action=&quot;store_true&quot;,
266      )
267      parser_write_flash.add_argument(
268          &quot;--encrypt&quot;,
269          help=&quot;Apply flash encryption when writing data &quot;
270          &quot;(required correct efuse settings)&quot;,
271          action=&quot;store_true&quot;,
272      )
273      parser_write_flash.add_argument(
274          &quot;--encrypt-files&quot;,
275          metavar=&quot;&lt;address&gt; &lt;filename&gt;&quot;,
276          help=&quot;Files to be encrypted on the flash. &quot;
277          &quot;Address followed by binary filename, separated by space.&quot;,
278          action=AddrFilenamePairAction,
279      )
280      parser_write_flash.add_argument(
281          &quot;--ignore-flash-encryption-efuse-setting&quot;,
282          help=&quot;Ignore flash encryption efuse settings &quot;,
283          action=&quot;store_true&quot;,
284      )
285      parser_write_flash.add_argument(
286          &quot;--force&quot;,
287          help=&quot;Force write, skip security and compatibility checks. Use with caution!&quot;,
288          action=&quot;store_true&quot;,
289      )
290      compress_args = parser_write_flash.add_mutually_exclusive_group(required=False)
291      compress_args.add_argument(
292          &quot;--compress&quot;,
293          &quot;-z&quot;,
294          help=&quot;Compress data in transfer (default unless --no-stub is specified)&quot;,
295          action=&quot;store_true&quot;,
296          default=None,
297      )
298      compress_args.add_argument(
299          &quot;--no-compress&quot;,
300          &quot;-u&quot;,
301          help=&quot;Disable data compression during transfer &quot;
302          &quot;(default if --no-stub is specified)&quot;,
303          action=&quot;store_true&quot;,
304      )
305      subparsers.add_parser(&quot;run&quot;, help=&quot;Run application code in flash&quot;)
306      parser_image_info = subparsers.add_parser(
307          &quot;image_info&quot;, help=&quot;Dump headers from a binary file (bootloader or application)&quot;
308      )
309      parser_image_info.add_argument(&quot;filename&quot;, help=&quot;Image file to parse&quot;)
310      parser_image_info.add_argument(
311          &quot;--version&quot;,
312          &quot;-v&quot;,
313          help=&quot;Output format version (1 - legacy, 2 - extended)&quot;,
314          choices=[&quot;1&quot;, &quot;2&quot;],
315          default=&quot;1&quot;,
316      )
317      parser_make_image = subparsers.add_parser(
318          &quot;make_image&quot;, help=&quot;Create an application image from binary files&quot;
319      )
320      parser_make_image.add_argument(&quot;output&quot;, help=&quot;Output image file&quot;)
321      parser_make_image.add_argument(
322          &quot;--segfile&quot;, &quot;-f&quot;, action=&quot;append&quot;, help=&quot;Segment input file&quot;
323      )
324      parser_make_image.add_argument(
325          &quot;--segaddr&quot;,
326          &quot;-a&quot;,
327          action=&quot;append&quot;,
328          help=&quot;Segment base address&quot;,
329          type=arg_auto_int,
330      )
331      parser_make_image.add_argument(
332          &quot;--entrypoint&quot;,
333          &quot;-e&quot;,
334          help=&quot;Address of entry point&quot;,
335          type=arg_auto_int,
336          default=0,
337      )
338      parser_elf2image = subparsers.add_parser(
339          &quot;elf2image&quot;, help=&quot;Create an application image from ELF file&quot;
340      )
341      parser_elf2image.add_argument(&quot;input&quot;, help=&quot;Input ELF file&quot;)
342      parser_elf2image.add_argument(
343          &quot;--output&quot;,
<span onclick='openModal()' class='match'>344          &quot;-o&quot;,
345          help=&quot;Output filename prefix (for version 1 image), &quot;
346          &quot;or filename (for version 2 single image)&quot;,
347          type=str,
348      )
349      parser_elf2image.add_argument(
</span>350          &quot;--version&quot;,
351          &quot;-e&quot;,
352          help=&quot;Output image version&quot;,
353          choices=[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;],
354          default=&quot;1&quot;,
355      )
356      parser_elf2image.add_argument(
357          &quot;--min-rev&quot;,
358          &quot;-r&quot;,
359          help=argparse.SUPPRESS,
360          type=int,
361          choices=range(256),
362          metavar=&quot;{0, ... 255}&quot;,
363          default=0,
364      )
365      parser_elf2image.add_argument(
366          &quot;--min-rev-full&quot;,
367          help=&quot;Minimal chip revision (in format: major * 100 + minor)&quot;,
368          type=int,
369          choices=range(65536),
370          metavar=&quot;{0, ... 65535}&quot;,
371          default=0,
372      )
373      parser_elf2image.add_argument(
374          &quot;--max-rev-full&quot;,
375          help=&quot;Maximal chip revision (in format: major * 100 + minor)&quot;,
376          type=int,
377          choices=range(65536),
378          metavar=&quot;{0, ... 65535}&quot;,
379          default=65535,
380      )
381      parser_elf2image.add_argument(
382          &quot;--secure-pad&quot;,
383          action=&quot;store_true&quot;,
384          help=&quot;Pad image so once signed it will end on a 64KB boundary. &quot;
385          &quot;For Secure Boot v1 images only.&quot;,
386      )
387      parser_elf2image.add_argument(
388          &quot;--secure-pad-v2&quot;,
389          action=&quot;store_true&quot;,
390          help=&quot;Pad image to 64KB, so once signed its signature sector will&quot;
391          &quot;start at the next 64K block. For Secure Boot v2 images only.&quot;,
392      )
393      parser_elf2image.add_argument(
394          &quot;--elf-sha256-offset&quot;,
395          help=&quot;If set, insert SHA256 hash (32 bytes) of the input ELF file &quot;
396          &quot;at specified offset in the binary.&quot;,
397          type=arg_auto_int,
398          default=None,
399      )
400      parser_elf2image.add_argument(
401          &quot;--dont-append-digest&quot;,
402          dest=&quot;append_digest&quot;,
403          help=&quot;Don&#x27;t append a SHA256 digest of the entire image after the checksum. &quot;
404          &quot;This argument is not supported and ignored for ESP8266.&quot;,
405          action=&quot;store_false&quot;,
406          default=True,
407      )
408      parser_elf2image.add_argument(
409          &quot;--use_segments&quot;,
410          help=&quot;If set, ELF segments will be used instead of ELF sections &quot;
411          &quot;to genereate the image.&quot;,
412          action=&quot;store_true&quot;,
413      )
414      parser_elf2image.add_argument(
415          &quot;--flash-mmu-page-size&quot;,
416          help=&quot;Change flash MMU page size.&quot;,
417          choices=[&quot;64KB&quot;, &quot;32KB&quot;, &quot;16KB&quot;, &quot;8KB&quot;],
418      )
419      parser_elf2image.add_argument(
420          &quot;--pad-to-size&quot;,
421          help=&quot;The block size with which the final binary image after padding &quot;
422          &quot;must be aligned to. Value 0xFF is used for padding, similar to erase_flash&quot;,
423          default=None,
424      )
425      add_spi_flash_subparsers(parser_elf2image, allow_keep=False, auto_detect=False)
426      subparsers.add_parser(&quot;read_mac&quot;, help=&quot;Read MAC address from OTP ROM&quot;)
427      subparsers.add_parser(&quot;chip_id&quot;, help=&quot;Read Chip ID from OTP ROM&quot;)
428      parser_flash_id = subparsers.add_parser(
429          &quot;flash_id&quot;, help=&quot;Read SPI flash manufacturer and device ID&quot;
430      )
431      add_spi_connection_arg(parser_flash_id)
432      parser_read_status = subparsers.add_parser(
433          &quot;read_flash_status&quot;, help=&quot;Read SPI flash status register&quot;
434      )
435      add_spi_connection_arg(parser_read_status)
436      parser_read_status.add_argument(
437          &quot;--bytes&quot;,
438          help=&quot;Number of bytes to read (1-3)&quot;,
439          type=int,
440          choices=[1, 2, 3],
441          default=2,
442      )
443      parser_write_status = subparsers.add_parser(
444          &quot;write_flash_status&quot;, help=&quot;Write SPI flash status register&quot;
445      )
446      add_spi_connection_arg(parser_write_status)
447      parser_write_status.add_argument(
448          &quot;--non-volatile&quot;,
449          help=&quot;Write non-volatile bits (use with caution)&quot;,
450          action=&quot;store_true&quot;,
451      )
452      parser_write_status.add_argument(
453          &quot;--bytes&quot;,
454          help=&quot;Number of status bytes to write (1-3)&quot;,
455          type=int,
456          choices=[1, 2, 3],
457          default=2,
458      )
459      parser_write_status.add_argument(&quot;value&quot;, help=&quot;New value&quot;, type=arg_auto_int)
460      parser_read_flash = subparsers.add_parser(
461          &quot;read_flash&quot;, help=&quot;Read SPI flash content&quot;
462      )
463      add_spi_connection_arg(parser_read_flash)
464      parser_read_flash.add_argument(&quot;address&quot;, help=&quot;Start address&quot;, type=arg_auto_int)
465      parser_read_flash.add_argument(
466          &quot;size&quot;,
467          help=&quot;Size of region to dump. Use `ALL` to read to the end of flash.&quot;,
468          type=arg_auto_size,
469      )
470      parser_read_flash.add_argument(&quot;filename&quot;, help=&quot;Name of binary dump&quot;)
471      parser_read_flash.add_argument(
472          &quot;--no-progress&quot;, &quot;-p&quot;, help=&quot;Suppress progress output&quot;, action=&quot;store_true&quot;
473      )
474      parser_verify_flash = subparsers.add_parser(
475          &quot;verify_flash&quot;, help=&quot;Verify a binary blob against flash&quot;
476      )
477      parser_verify_flash.add_argument(
478          &quot;addr_filename&quot;,
479          help=&quot;Address and binary file to verify there, separated by space&quot;,
480          action=AddrFilenamePairAction,
481      )
482      parser_verify_flash.add_argument(
483          &quot;--diff&quot;, &quot;-d&quot;, help=&quot;Show differences&quot;, choices=[&quot;no&quot;, &quot;yes&quot;], default=&quot;no&quot;
484      )
485      add_spi_flash_subparsers(parser_verify_flash, allow_keep=True, auto_detect=True)
486      parser_erase_flash = subparsers.add_parser(
487          &quot;erase_flash&quot;, help=&quot;Perform Chip Erase on SPI flash&quot;
488      )
489      parser_erase_flash.add_argument(
490          &quot;--force&quot;,
491          help=&quot;Erase flash even if security features are enabled. Use with caution!&quot;,
492          action=&quot;store_true&quot;,
493      )
494      add_spi_connection_arg(parser_erase_flash)
495      parser_erase_region = subparsers.add_parser(
496          &quot;erase_region&quot;, help=&quot;Erase a region of the flash&quot;
497      )
498      parser_erase_region.add_argument(
499          &quot;--force&quot;,
500          help=&quot;Erase region even if security features are enabled. Use with caution!&quot;,
501          action=&quot;store_true&quot;,
502      )
503      add_spi_connection_arg(parser_erase_region)
504      parser_erase_region.add_argument(
505          &quot;address&quot;, help=&quot;Start address (must be multiple of 4096)&quot;, type=arg_auto_int
506      )
507      parser_erase_region.add_argument(
508          &quot;size&quot;,
509          help=&quot;Size of region to erase (must be multiple of 4096). &quot;
510          &quot;Use `ALL` to erase to the end of flash.&quot;,
511          type=arg_auto_size,
512      )
513      parser_merge_bin = subparsers.add_parser(
514          &quot;merge_bin&quot;,
515          help=&quot;Merge multiple raw binary files into a single file for later flashing&quot;,
516      )
517      parser_merge_bin.add_argument(
518          &quot;--output&quot;, &quot;-o&quot;, help=&quot;Output filename&quot;, type=str, required=True
519      )
520      parser_merge_bin.add_argument(
521          &quot;--format&quot;, &quot;-f&quot;, help=&quot;Format of the output file&quot;, choices=&quot;raw&quot;, default=&quot;raw&quot;
522      )  # for future expansion
523      add_spi_flash_subparsers(parser_merge_bin, allow_keep=True, auto_detect=False)
524      parser_merge_bin.add_argument(
525          &quot;--target-offset&quot;,
526          &quot;-t&quot;,
527          help=&quot;Target offset where the output file will be flashed&quot;,
528          type=arg_auto_int,
529          default=0,
530      )
531      parser_merge_bin.add_argument(
532          &quot;--fill-flash-size&quot;,
533          help=&quot;If set, the final binary file will be padded with FF &quot;
534          &quot;bytes up to this flash size.&quot;,
535          choices=[
536              &quot;256KB&quot;,
537              &quot;512KB&quot;,
538              &quot;1MB&quot;,
539              &quot;2MB&quot;,
540              &quot;4MB&quot;,
541              &quot;8MB&quot;,
542              &quot;16MB&quot;,
543              &quot;32MB&quot;,
544              &quot;64MB&quot;,
545              &quot;128MB&quot;,
546          ],
547      )
548      parser_merge_bin.add_argument(
549          &quot;addr_filename&quot;,
550          metavar=&quot;&lt;address&gt; &lt;filename&gt;&quot;,
551          help=&quot;Address followed by binary filename, separated by space&quot;,
552          action=AddrFilenamePairAction,
553      )
554      subparsers.add_parser(&quot;get_security_info&quot;, help=&quot;Get some security-related data&quot;)
555      subparsers.add_parser(&quot;version&quot;, help=&quot;Print esptool version&quot;)
556      for operation in subparsers.choices.keys():
557          assert operation in globals(), &quot;%s should be a module function&quot; % operation
558      argv = expand_file_arguments(argv or sys.argv[1:])
559      args = parser.parse_args(argv)
560      print(&quot;esptool.py v%s&quot; % __version__)
561      load_config_file(verbose=True)
562      if args.operation is None:
563          parser.print_help()
564          sys.exit(1)
565      if (
566          args.operation == &quot;write_flash&quot;
567          and args.encrypt
568          and args.encrypt_files is not None
569      ):
570          raise FatalError(
571              &quot;Options --encrypt and --encrypt-files &quot;
572              &quot;must not be specified at the same time.&quot;
573          )
574      operation_func = globals()[args.operation]
575      operation_args = inspect.getfullargspec(operation_func).args
576      if (
577          operation_args[0] == &quot;esp&quot;
578      ):  # operation function takes an ESPLoader connection object
579          if args.before != &quot;no_reset_no_sync&quot;:
580              initial_baud = min(
581                  ESPLoader.ESP_ROM_BAUD, args.baud
582              )  # don&#x27;t sync faster than the default baud rate
583          else:
584              initial_baud = args.baud
585          if args.port is None:
586              ser_list = get_port_list()
587              print(&quot;Found %d serial ports&quot; % len(ser_list))
588          else:
589              ser_list = [args.port]
590          esp = esp or get_default_connected_device(
591              ser_list,
592              port=args.port,
593              connect_attempts=args.connect_attempts,
594              initial_baud=initial_baud,
595              chip=args.chip,
596              trace=args.trace,
597              before=args.before,
598          )
599          if esp is None:
600              raise FatalError(
601                  &quot;Could not connect to an Espressif device &quot;
602                  &quot;on any of the %d available serial ports.&quot; % len(ser_list)
603              )
604          if esp.secure_download_mode:
605              print(&quot;Chip is %s in Secure Download Mode&quot; % esp.CHIP_NAME)
606          else:
607              print(&quot;Chip is %s&quot; % (esp.get_chip_description()))
608              print(&quot;Features: %s&quot; % &quot;, &quot;.join(esp.get_chip_features()))
609              print(&quot;Crystal is %dMHz&quot; % esp.get_crystal_freq())
610              read_mac(esp, args)
611          if not args.no_stub:
612              if esp.secure_download_mode:
613                  print(
614                      &quot;WARNING: Stub loader is not supported in Secure Download Mode, &quot;
615                      &quot;setting --no-stub&quot;
616                  )
617                  args.no_stub = True
618              elif not esp.IS_STUB and esp.stub_is_disabled:
619                  print(
620                      &quot;WARNING: Stub loader has been disabled for compatibility, &quot;
621                      &quot;setting --no-stub&quot;
622                  )
623                  args.no_stub = True
624              else:
625                  try:
626                      esp = esp.run_stub()
627                  except Exception:
628                      if sys.platform == &quot;darwin&quot; and esp._get_pid() == 0x55D4:
629                          print(
630                              &quot;\nNote: If issues persist, &quot;
631                              &quot;try installing the WCH USB-to-Serial MacOS driver.&quot;
632                          )
633                      raise
634          if args.override_vddsdio:
635              esp.override_vddsdio(args.override_vddsdio)
636          if args.baud &gt; initial_baud:
637              try:
638                  esp.change_baud(args.baud)
639              except NotImplementedInROMError:
640                  print(
641                      &quot;WARNING: ROM doesn&#x27;t support changing baud rate. &quot;
642                      &quot;Keeping initial baud rate %d&quot; % initial_baud
643                  )
644          if hasattr(args, &quot;spi_connection&quot;) and args.spi_connection is not None:
645              if esp.CHIP_NAME != &quot;ESP32&quot;:
646                  raise FatalError(
647                      &quot;Chip %s does not support --spi-connection option.&quot; % esp.CHIP_NAME
648                  )
649              print(&quot;Configuring SPI flash mode...&quot;)
650              esp.flash_spi_attach(args.spi_connection)
651          elif args.no_stub:
652              print(&quot;Enabling default SPI flash mode...&quot;)
653              esp.flash_spi_attach(0)
654          XMC_VENDOR_ID = 0x20
655          def is_xmc_chip_strict():
656              id = esp.flash_id()
657              rdid = ((id &amp; 0xFF) &lt;&lt; 16) | ((id &gt;&gt; 16) &amp; 0xFF) | (id &amp; 0xFF00)
658              vendor_id = (rdid &gt;&gt; 16) &amp; 0xFF
659              mfid = (rdid &gt;&gt; 8) &amp; 0xFF
660              cpid = rdid &amp; 0xFF
661              if vendor_id != XMC_VENDOR_ID:
662                  return False
663              matched = False
664              if mfid == 0x40:
665                  if cpid &gt;= 0x13 and cpid &lt;= 0x20:
666                      matched = True
667              elif mfid == 0x41:
668                  if cpid &gt;= 0x17 and cpid &lt;= 0x20:
669                      matched = True
670              elif mfid == 0x50:
671                  if cpid &gt;= 0x15 and cpid &lt;= 0x16:
672                      matched = True
673              return matched
674          def flash_xmc_startup():
675              fast_check = True
676              if fast_check and is_xmc_chip_strict():
677                  return  # Successful XMC flash chip boot-up detected by RDID, skipping.
678              sfdp_mfid_addr = 0x10
679              mf_id = esp.read_spiflash_sfdp(sfdp_mfid_addr, 8)
680              if mf_id != XMC_VENDOR_ID:  # Non-XMC chip detected by SFDP Read, skipping.
681                  return
682              print(
683                  &quot;WARNING: XMC flash chip boot-up failure detected! &quot;
684                  &quot;Running XMC25QHxxC startup flow&quot;
685              )
686              esp.run_spiflash_command(0xB9)  # Enter DPD
687              esp.run_spiflash_command(0x79)  # Enter UDPD
688              esp.run_spiflash_command(0xFF)  # Exit UDPD
689              time.sleep(0.002)  # Delay tXUDPD
690              esp.run_spiflash_command(0xAB)  # Release Power-Down
691              time.sleep(0.00002)
692              if not is_xmc_chip_strict():
693                  print(&quot;WARNING: XMC flash boot-up fix failed.&quot;)
694              print(&quot;XMC flash chip boot-up fix successful!&quot;)
695          if not esp.secure_download_mode:
696              try:
697                  flash_id = esp.flash_id()
698                  if flash_id in (0xFFFFFF, 0x000000):
699                      print(
700                          &quot;WARNING: Failed to communicate with the flash chip, &quot;
701                          &quot;read/write operations will fail. &quot;
702                          &quot;Try checking the chip connections or removing &quot;
703                          &quot;any other hardware connected to IOs.&quot;
704                      )
705              except FatalError as e:
706                  raise FatalError(f&quot;Unable to verify flash chip connection ({e}).&quot;)
707          if not esp.secure_download_mode:
708              try:
709                  flash_xmc_startup()
710              except FatalError as e:
711                  esp.trace(f&quot;Unable to perform XMC flash chip startup sequence ({e}).&quot;)
712          if hasattr(args, &quot;flash_size&quot;):
713              print(&quot;Configuring flash size...&quot;)
714              if args.flash_size == &quot;detect&quot;:
715                  flash_size = detect_flash_size(esp, args)
716              elif args.flash_size == &quot;keep&quot;:
717                  flash_size = detect_flash_size(esp, args=None)
718              else:
719                  flash_size = args.flash_size
720              if flash_size is not None:  # Secure download mode
721                  esp.flash_set_parameters(flash_size_bytes(flash_size))
722                  if esp.IS_STUB and flash_size in (&quot;32MB&quot;, &quot;64MB&quot;, &quot;128MB&quot;):
723                      print(
724                          &quot;WARNING: Flasher stub doesn&#x27;t fully support flash size larger &quot;
725                          &quot;than 16MB, in case of failure use --no-stub.&quot;
726                      )
727          if getattr(args, &quot;size&quot;, &quot;&quot;) == &quot;all&quot;:
728              if esp.secure_download_mode:
729                  raise FatalError(
730                      &quot;Detecting flash size is not supported in secure download mode. &quot;
731                      &quot;Set an exact size value.&quot;
732                  )
733              flash_id = esp.flash_id()
734              size_id = flash_id &gt;&gt; 16
735              size_str = DETECTED_FLASH_SIZES.get(size_id)
736              if size_str is None:
737                  raise FatalError(
738                      &quot;Detecting flash size failed. Set an exact size value.&quot;
739                  )
740              print(f&quot;Detected flash size: {size_str}&quot;)
741              args.size = flash_size_bytes(size_str)
742          if esp.IS_STUB and hasattr(args, &quot;address&quot;) and hasattr(args, &quot;size&quot;):
743              if args.address + args.size &gt; 0x1000000:
744                  print(
745                      &quot;WARNING: Flasher stub doesn&#x27;t fully support flash size larger &quot;
746                      &quot;than 16MB, in case of failure use --no-stub.&quot;
747                  )
748          try:
749              operation_func(esp, args)
750          finally:
751              try:  # Clean up AddrFilenamePairAction files
752                  for address, argfile in args.addr_filename:
753                      argfile.close()
754              except AttributeError:
755                  pass
756          if operation_func == load_ram:
757              print(&quot;Exiting immediately.&quot;)
758          elif args.after == &quot;hard_reset&quot;:
759              esp.hard_reset()
760          elif args.after == &quot;soft_reset&quot;:
761              print(&quot;Soft resetting...&quot;)
762              esp.soft_reset(False)
763          elif args.after == &quot;no_reset_stub&quot;:
764              print(&quot;Staying in flasher stub.&quot;)
765          else:  # args.after == &#x27;no_reset&#x27;
766              print(&quot;Staying in bootloader.&quot;)
767              if esp.IS_STUB:
768                  esp.soft_reset(True)  # exit stub back to ROM loader
769          if not external_esp:
770              esp._port.close()
771      else:
772          operation_func(args)
773  def arg_auto_int(x):
774      return int(x, 0)
775  def arg_auto_size(x):
776      x = x.lower()
777      return x if x == &quot;all&quot; else arg_auto_int(x)
778  def get_port_list():
779      if list_ports is None:
780          raise FatalError(
781              &quot;Listing all serial ports is currently not available. &quot;
782              &quot;Please try to specify the port when running esptool.py or update &quot;
783              &quot;the pyserial package to the latest version&quot;
784          )
785      return sorted(ports.device for ports in list_ports.comports())
786  def expand_file_arguments(argv):
787      new_args = []
788      expanded = False
789      for arg in argv:
790          if arg.startswith(&quot;@&quot;):
791              expanded = True
792              with open(arg[1:], &quot;r&quot;) as f:
793                  for line in f.readlines():
794                      new_args += shlex.split(line)
795          else:
796              new_args.append(arg)
797      if expanded:
798          print(&quot;esptool %s&quot; % (&quot; &quot;.join(new_args[1:])))
799          return new_args
800      return argv
801  def get_default_connected_device(
802      serial_list,
803      port,
804      connect_attempts,
805      initial_baud,
806      chip=&quot;auto&quot;,
807      trace=False,
808      before=&quot;default_reset&quot;,
809  ):
810      _esp = None
811      for each_port in reversed(serial_list):
812          print(&quot;Serial port %s&quot; % each_port)
813          try:
814              if chip == &quot;auto&quot;:
815                  _esp = detect_chip(
816                      each_port, initial_baud, before, trace, connect_attempts
817                  )
818              else:
819                  chip_class = CHIP_DEFS[chip]
820                  _esp = chip_class(each_port, initial_baud, trace)
821                  _esp.connect(before, connect_attempts)
822              break
823          except (FatalError, OSError) as err:
824              if port is not None:
825                  raise
826              print(&quot;%s failed to connect: %s&quot; % (each_port, err))
827              if _esp and _esp._port:
828                  _esp._port.close()
829              _esp = None
830      return _esp
831  class SpiConnectionAction(argparse.Action):
832      def __call__(self, parser, namespace, value, option_string=None):
833          if value.upper() == &quot;SPI&quot;:
834              value = 0
835          elif value.upper() == &quot;HSPI&quot;:
836              value = 1
837          elif &quot;,&quot; in value:
838              values = value.split(&quot;,&quot;)
839              if len(values) != 5:
840                  raise argparse.ArgumentError(
841                      self,
842                      &quot;%s is not a valid list of comma-separate pin numbers. &quot;
843                      &quot;Must be 5 numbers - CLK,Q,D,HD,CS.&quot; % value,
844                  )
845              try:
846                  values = tuple(int(v, 0) for v in values)
847              except ValueError:
848                  raise argparse.ArgumentError(
849                      self,
850                      &quot;%s is not a valid argument. All pins must be numeric values&quot;
851                      % values,
852                  )
853              if any([v for v in values if v &gt; 33 or v &lt; 0]):
854                  raise argparse.ArgumentError(
855                      self, &quot;Pin numbers must be in the range 0-33.&quot;
856                  )
857              clk, q, d, hd, cs = values
858              value = (hd &lt;&lt; 24) | (cs &lt;&lt; 18) | (d &lt;&lt; 12) | (q &lt;&lt; 6) | clk
859          else:
860              raise argparse.ArgumentError(
861                  self,
862                  &quot;%s is not a valid spi-connection value. &quot;
863                  &quot;Values are SPI, HSPI, or a sequence of 5 pin numbers CLK,Q,D,HD,CS).&quot;
864                  % value,
865              )
866          setattr(namespace, self.dest, value)
867  class AddrFilenamePairAction(argparse.Action):
868      def __init__(self, option_strings, dest, nargs=&quot;+&quot;, **kwargs):
869          super(AddrFilenamePairAction, self).__init__(
870              option_strings, dest, nargs, **kwargs
871          )
872      def __call__(self, parser, namespace, values, option_string=None):
873          pairs = []
874          for i in range(0, len(values), 2):
875              try:
876                  address = int(values[i], 0)
877              except ValueError:
878                  raise argparse.ArgumentError(
879                      self, &#x27;Address &quot;%s&quot; must be a number&#x27; % values[i]
880                  )
881              try:
882                  argfile = open(values[i + 1], &quot;rb&quot;)
883              except IOError as e:
884                  raise argparse.ArgumentError(self, e)
885              except IndexError:
886                  raise argparse.ArgumentError(
887                      self,
888                      &quot;Must be pairs of an address &quot;
889                      &quot;and the binary filename to write there&quot;,
890                  )
891              pairs.append((address, argfile))
892          end = 0
893          for address, argfile in sorted(pairs, key=lambda x: x[0]):
894              argfile.seek(0, 2)  # seek to end
895              size = argfile.tell()
896              argfile.seek(0)
897              sector_start = address &amp; ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
898              sector_end = (
899                  (address + size + ESPLoader.FLASH_SECTOR_SIZE - 1)
900                  &amp; ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
901              ) - 1
902              if sector_start &lt; end:
903                  message = &quot;Detected overlap at address: 0x%x for file: %s&quot; % (
904                      address,
905                      argfile.name,
906                  )
907                  raise argparse.ArgumentError(self, message)
908              end = sector_end
909          setattr(namespace, self.dest, pairs)
910  def _main():
911      try:
912          main()
913      except FatalError as e:
914          print(f&quot;\nA fatal error occurred: {e}&quot;)
915          sys.exit(2)
916      except serial.serialutil.SerialException as e:
917          print(f&quot;\nA serial exception error occurred: {e}&quot;)
918          print(
919              &quot;Note: This error originates from pySerial. &quot;
920              &quot;It is likely not a problem with esptool, &quot;
921              &quot;but with the hardware connection or drivers.&quot;
922          )
923          print(
924              &quot;For troubleshooting steps visit: &quot;
925              &quot;https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html&quot;
926          )
927          sys.exit(1)
928      except StopIteration:
929          print(traceback.format_exc())
930          print(&quot;A fatal error occurred: The chip stopped responding.&quot;)
931          sys.exit(2)
932  if __name__ == &quot;__main__&quot;:
933      _main()
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___49.py</h3>
            <pre><code>1  __all__ = [
2      &quot;chip_id&quot;,
3      &quot;detect_chip&quot;,
4      &quot;dump_mem&quot;,
5      &quot;elf2image&quot;,
6      &quot;erase_flash&quot;,
7      &quot;erase_region&quot;,
8      &quot;flash_id&quot;,
9      &quot;get_security_info&quot;,
10      &quot;image_info&quot;,
11      &quot;load_ram&quot;,
12      &quot;make_image&quot;,
13      &quot;merge_bin&quot;,
14      &quot;read_flash&quot;,
15      &quot;read_flash_status&quot;,
16      &quot;read_mac&quot;,
17      &quot;read_mem&quot;,
18      &quot;run&quot;,
19      &quot;verify_flash&quot;,
20      &quot;version&quot;,
21      &quot;write_flash&quot;,
22      &quot;write_flash_status&quot;,
23      &quot;write_mem&quot;,
24  ]
25  __version__ = &quot;4.7-dev&quot;
26  import argparse
27  import inspect
28  import os
29  import shlex
30  import sys
31  import time
32  import traceback
33  from esptool.cmds import (
34      DETECTED_FLASH_SIZES,
35      chip_id,
36      detect_chip,
37      detect_flash_size,
38      dump_mem,
39      elf2image,
40      erase_flash,
41      erase_region,
42      flash_id,
43      get_security_info,
44      image_info,
45      load_ram,
46      make_image,
47      merge_bin,
48      read_flash,
49      read_flash_status,
50      read_mac,
51      read_mem,
52      run,
53      verify_flash,
54      version,
55      write_flash,
56      write_flash_status,
57      write_mem,
58  )
59  from esptool.config import load_config_file
60  from esptool.loader import DEFAULT_CONNECT_ATTEMPTS, ESPLoader, list_ports
61  from esptool.targets import CHIP_DEFS, CHIP_LIST, ESP32ROM
62  from esptool.util import (
63      FatalError,
64      NotImplementedInROMError,
65      flash_size_bytes,
66      strip_chip_name,
67  )
68  import serial
69  def main(argv=None, esp=None):
70      external_esp = esp is not None
71      parser = argparse.ArgumentParser(
72          description=&quot;esptool.py v%s - Espressif chips ROM Bootloader Utility&quot;
73          % __version__,
74          prog=&quot;esptool&quot;,
75      )
76      parser.add_argument(
77          &quot;--chip&quot;,
78          &quot;-c&quot;,
79          help=&quot;Target chip type&quot;,
80          type=strip_chip_name,
81          choices=[&quot;auto&quot;] + CHIP_LIST,
82          default=os.environ.get(&quot;ESPTOOL_CHIP&quot;, &quot;auto&quot;),
83      )
84      parser.add_argument(
85          &quot;--port&quot;,
86          &quot;-p&quot;,
87          help=&quot;Serial port device&quot;,
88          default=os.environ.get(&quot;ESPTOOL_PORT&quot;, None),
89      )
90      parser.add_argument(
91          &quot;--baud&quot;,
92          &quot;-b&quot;,
93          help=&quot;Serial port baud rate used when flashing/reading&quot;,
94          type=arg_auto_int,
95          default=os.environ.get(&quot;ESPTOOL_BAUD&quot;, ESPLoader.ESP_ROM_BAUD),
96      )
97      parser.add_argument(
98          &quot;--before&quot;,
99          help=&quot;What to do before connecting to the chip&quot;,
100          choices=[&quot;default_reset&quot;, &quot;usb_reset&quot;, &quot;no_reset&quot;, &quot;no_reset_no_sync&quot;],
101          default=os.environ.get(&quot;ESPTOOL_BEFORE&quot;, &quot;default_reset&quot;),
102      )
103      parser.add_argument(
104          &quot;--after&quot;,
105          &quot;-a&quot;,
106          help=&quot;What to do after esptool.py is finished&quot;,
107          choices=[&quot;hard_reset&quot;, &quot;soft_reset&quot;, &quot;no_reset&quot;, &quot;no_reset_stub&quot;],
108          default=os.environ.get(&quot;ESPTOOL_AFTER&quot;, &quot;hard_reset&quot;),
109      )
110      parser.add_argument(
111          &quot;--no-stub&quot;,
112          help=&quot;Disable launching the flasher stub, only talk to ROM bootloader. &quot;
113          &quot;Some features will not be available.&quot;,
114          action=&quot;store_true&quot;,
115      )
116      parser.add_argument(
117          &quot;--trace&quot;,
118          &quot;-t&quot;,
119          help=&quot;Enable trace-level output of esptool.py interactions.&quot;,
120          action=&quot;store_true&quot;,
121      )
122      parser.add_argument(
123          &quot;--override-vddsdio&quot;,
124          help=&quot;Override ESP32 VDDSDIO internal voltage regulator (use with care)&quot;,
125          choices=ESP32ROM.OVERRIDE_VDDSDIO_CHOICES,
126          nargs=&quot;?&quot;,
127      )
128      parser.add_argument(
129          &quot;--connect-attempts&quot;,
130          help=(
131              &quot;Number of attempts to connect, negative or 0 for infinite. &quot;
132              &quot;Default: %d.&quot; % DEFAULT_CONNECT_ATTEMPTS
133          ),
134          type=int,
135          default=os.environ.get(&quot;ESPTOOL_CONNECT_ATTEMPTS&quot;, DEFAULT_CONNECT_ATTEMPTS),
136      )
137      subparsers = parser.add_subparsers(
138          dest=&quot;operation&quot;, help=&quot;Run esptool.py {command} -h for additional help&quot;
139      )
140      def add_spi_connection_arg(parent):
141          parent.add_argument(
142              &quot;--spi-connection&quot;,
143              &quot;-sc&quot;,
144              help=&quot;ESP32-only argument. Override default SPI Flash connection. &quot;
145              &quot;Value can be SPI, HSPI or a comma-separated list of 5 I/O numbers &quot;
146              &quot;to use for SPI flash (CLK,Q,D,HD,CS).&quot;,
147              action=SpiConnectionAction,
148          )
149      parser_load_ram = subparsers.add_parser(
150          &quot;load_ram&quot;, help=&quot;Download an image to RAM and execute&quot;
151      )
152      parser_load_ram.add_argument(&quot;filename&quot;, help=&quot;Firmware image&quot;)
153      parser_dump_mem = subparsers.add_parser(
154          &quot;dump_mem&quot;, help=&quot;Dump arbitrary memory to disk&quot;
155      )
156      parser_dump_mem.add_argument(&quot;address&quot;, help=&quot;Base address&quot;, type=arg_auto_int)
157      parser_dump_mem.add_argument(
158          &quot;size&quot;, help=&quot;Size of region to dump&quot;, type=arg_auto_int
159      )
160      parser_dump_mem.add_argument(&quot;filename&quot;, help=&quot;Name of binary dump&quot;)
161      parser_read_mem = subparsers.add_parser(
162          &quot;read_mem&quot;, help=&quot;Read arbitrary memory location&quot;
163      )
164      parser_read_mem.add_argument(&quot;address&quot;, help=&quot;Address to read&quot;, type=arg_auto_int)
165      parser_write_mem = subparsers.add_parser(
166          &quot;write_mem&quot;, help=&quot;Read-modify-write to arbitrary memory location&quot;
167      )
168      parser_write_mem.add_argument(&quot;address&quot;, help=&quot;Address to write&quot;, type=arg_auto_int)
169      parser_write_mem.add_argument(&quot;value&quot;, help=&quot;Value&quot;, type=arg_auto_int)
170      parser_write_mem.add_argument(
171          &quot;mask&quot;,
172          help=&quot;Mask of bits to write&quot;,
173          type=arg_auto_int,
174          nargs=&quot;?&quot;,
175          default=&quot;0xFFFFFFFF&quot;,
176      )
177      def add_spi_flash_subparsers(parent, allow_keep, auto_detect):
178          extra_keep_args = [&quot;keep&quot;] if allow_keep else []
179          if auto_detect and allow_keep:
180              extra_fs_message = &quot;, detect, or keep&quot;
181              flash_sizes = [&quot;detect&quot;, &quot;keep&quot;]
182          elif auto_detect:
183              extra_fs_message = &quot;, or detect&quot;
184              flash_sizes = [&quot;detect&quot;]
185          elif allow_keep:
186              extra_fs_message = &quot;, or keep&quot;
187              flash_sizes = [&quot;keep&quot;]
188          else:
189              extra_fs_message = &quot;&quot;
190              flash_sizes = []
191          parent.add_argument(
192              &quot;--flash_freq&quot;,
193              &quot;-ff&quot;,
194              help=&quot;SPI Flash frequency&quot;,
195              choices=extra_keep_args
196              + [
197                  &quot;80m&quot;,
198                  &quot;60m&quot;,
199                  &quot;48m&quot;,
200                  &quot;40m&quot;,
201                  &quot;30m&quot;,
202                  &quot;26m&quot;,
203                  &quot;24m&quot;,
204                  &quot;20m&quot;,
205                  &quot;16m&quot;,
206                  &quot;15m&quot;,
207                  &quot;12m&quot;,
208              ],
209              default=os.environ.get(&quot;ESPTOOL_FF&quot;, &quot;keep&quot; if allow_keep else None),
210          )
211          parent.add_argument(
212              &quot;--flash_mode&quot;,
213              &quot;-fm&quot;,
214              help=&quot;SPI Flash mode&quot;,
215              choices=extra_keep_args + [&quot;qio&quot;, &quot;qout&quot;, &quot;dio&quot;, &quot;dout&quot;],
216              default=os.environ.get(&quot;ESPTOOL_FM&quot;, &quot;keep&quot; if allow_keep else &quot;qio&quot;),
217          )
218          parent.add_argument(
219              &quot;--flash_size&quot;,
220              &quot;-fs&quot;,
221              help=&quot;SPI Flash size in MegaBytes &quot;
222              &quot;(1MB, 2MB, 4MB, 8MB, 16MB, 32MB, 64MB, 128MB) &quot;
223              &quot;plus ESP8266-only (256KB, 512KB, 2MB-c1, 4MB-c1)&quot; + extra_fs_message,
224              choices=flash_sizes
225              + [
226                  &quot;256KB&quot;,
227                  &quot;512KB&quot;,
228                  &quot;1MB&quot;,
229                  &quot;2MB&quot;,
230                  &quot;2MB-c1&quot;,
231                  &quot;4MB&quot;,
232                  &quot;4MB-c1&quot;,
233                  &quot;8MB&quot;,
234                  &quot;16MB&quot;,
235                  &quot;32MB&quot;,
236                  &quot;64MB&quot;,
237                  &quot;128MB&quot;,
238              ],
239              default=os.environ.get(&quot;ESPTOOL_FS&quot;, &quot;keep&quot; if allow_keep else &quot;1MB&quot;),
240          )
241          add_spi_connection_arg(parent)
242      parser_write_flash = subparsers.add_parser(
243          &quot;write_flash&quot;, help=&quot;Write a binary blob to flash&quot;
244      )
245      parser_write_flash.add_argument(
246          &quot;addr_filename&quot;,
247          metavar=&quot;&lt;address&gt; &lt;filename&gt;&quot;,
248          help=&quot;Address followed by binary filename, separated by space&quot;,
249          action=AddrFilenamePairAction,
250      )
251      parser_write_flash.add_argument(
252          &quot;--erase-all&quot;,
253          &quot;-e&quot;,
254          help=&quot;Erase all regions of flash (not just write areas) before programming&quot;,
255          action=&quot;store_true&quot;,
256      )
257      add_spi_flash_subparsers(parser_write_flash, allow_keep=True, auto_detect=True)
258      parser_write_flash.add_argument(
259          &quot;--no-progress&quot;, &quot;-p&quot;, help=&quot;Suppress progress output&quot;, action=&quot;store_true&quot;
260      )
261      parser_write_flash.add_argument(
262          &quot;--verify&quot;,
263          help=&quot;Verify just-written data on flash &quot;
264          &quot;(mostly superfluous, data is read back during flashing)&quot;,
265          action=&quot;store_true&quot;,
266      )
267      parser_write_flash.add_argument(
268          &quot;--encrypt&quot;,
269          help=&quot;Apply flash encryption when writing data &quot;
270          &quot;(required correct efuse settings)&quot;,
271          action=&quot;store_true&quot;,
272      )
273      parser_write_flash.add_argument(
274          &quot;--encrypt-files&quot;,
275          metavar=&quot;&lt;address&gt; &lt;filename&gt;&quot;,
276          help=&quot;Files to be encrypted on the flash. &quot;
277          &quot;Address followed by binary filename, separated by space.&quot;,
278          action=AddrFilenamePairAction,
279      )
280      parser_write_flash.add_argument(
281          &quot;--ignore-flash-encryption-efuse-setting&quot;,
282          help=&quot;Ignore flash encryption efuse settings &quot;,
283          action=&quot;store_true&quot;,
284      )
285      parser_write_flash.add_argument(
286          &quot;--force&quot;,
287          help=&quot;Force write, skip security and compatibility checks. Use with caution!&quot;,
288          action=&quot;store_true&quot;,
289      )
290      compress_args = parser_write_flash.add_mutually_exclusive_group(required=False)
291      compress_args.add_argument(
292          &quot;--compress&quot;,
293          &quot;-z&quot;,
294          help=&quot;Compress data in transfer (default unless --no-stub is specified)&quot;,
295          action=&quot;store_true&quot;,
296          default=None,
297      )
298      compress_args.add_argument(
299          &quot;--no-compress&quot;,
300          &quot;-u&quot;,
301          help=&quot;Disable data compression during transfer &quot;
302          &quot;(default if --no-stub is specified)&quot;,
303          action=&quot;store_true&quot;,
304      )
305      subparsers.add_parser(&quot;run&quot;, help=&quot;Run application code in flash&quot;)
306      parser_image_info = subparsers.add_parser(
307          &quot;image_info&quot;, help=&quot;Dump headers from a binary file (bootloader or application)&quot;
308      )
309      parser_image_info.add_argument(&quot;filename&quot;, help=&quot;Image file to parse&quot;)
310      parser_image_info.add_argument(
311          &quot;--version&quot;,
312          &quot;-v&quot;,
313          help=&quot;Output format version (1 - legacy, 2 - extended)&quot;,
314          choices=[&quot;1&quot;, &quot;2&quot;],
315          default=&quot;1&quot;,
316      )
317      parser_make_image = subparsers.add_parser(
318          &quot;make_image&quot;, help=&quot;Create an application image from binary files&quot;
319      )
320      parser_make_image.add_argument(&quot;output&quot;, help=&quot;Output image file&quot;)
321      parser_make_image.add_argument(
322          &quot;--segfile&quot;, &quot;-f&quot;, action=&quot;append&quot;, help=&quot;Segment input file&quot;
323      )
324      parser_make_image.add_argument(
325          &quot;--segaddr&quot;,
326          &quot;-a&quot;,
327          action=&quot;append&quot;,
328          help=&quot;Segment base address&quot;,
329          type=arg_auto_int,
330      )
331      parser_make_image.add_argument(
332          &quot;--entrypoint&quot;,
333          &quot;-e&quot;,
334          help=&quot;Address of entry point&quot;,
335          type=arg_auto_int,
336          default=0,
337      )
338      parser_elf2image = subparsers.add_parser(
339          &quot;elf2image&quot;, help=&quot;Create an application image from ELF file&quot;
340      )
341      parser_elf2image.add_argument(&quot;input&quot;, help=&quot;Input ELF file&quot;)
342      parser_elf2image.add_argument(
343          &quot;--output&quot;,
344          &quot;-o&quot;,
345          help=&quot;Output filename prefix (for version 1 image), &quot;
346          &quot;or filename (for version 2 single image)&quot;,
347          type=str,
348      )
349      parser_elf2image.add_argument(
350          &quot;--version&quot;,
351          &quot;-e&quot;,
352          help=&quot;Output image version&quot;,
353          choices=[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;],
354          default=&quot;1&quot;,
355      )
356      parser_elf2image.add_argument(
357          &quot;--min-rev&quot;,
358          &quot;-r&quot;,
359          help=argparse.SUPPRESS,
360          type=int,
361          choices=range(256),
362          metavar=&quot;{0, ... 255}&quot;,
363          default=0,
364      )
365      parser_elf2image.add_argument(
366          &quot;--min-rev-full&quot;,
367          help=&quot;Minimal chip revision (in format: major * 100 + minor)&quot;,
368          type=int,
369          choices=range(65536),
370          metavar=&quot;{0, ... 65535}&quot;,
371          default=0,
372      )
373      parser_elf2image.add_argument(
374          &quot;--max-rev-full&quot;,
375          help=&quot;Maximal chip revision (in format: major * 100 + minor)&quot;,
376          type=int,
377          choices=range(65536),
378          metavar=&quot;{0, ... 65535}&quot;,
379          default=65535,
380      )
381      parser_elf2image.add_argument(
382          &quot;--secure-pad&quot;,
383          action=&quot;store_true&quot;,
384          help=&quot;Pad image so once signed it will end on a 64KB boundary. &quot;
385          &quot;For Secure Boot v1 images only.&quot;,
386      )
387      parser_elf2image.add_argument(
388          &quot;--secure-pad-v2&quot;,
389          action=&quot;store_true&quot;,
390          help=&quot;Pad image to 64KB, so once signed its signature sector will&quot;
391          &quot;start at the next 64K block. For Secure Boot v2 images only.&quot;,
392      )
393      parser_elf2image.add_argument(
394          &quot;--elf-sha256-offset&quot;,
395          help=&quot;If set, insert SHA256 hash (32 bytes) of the input ELF file &quot;
396          &quot;at specified offset in the binary.&quot;,
397          type=arg_auto_int,
398          default=None,
399      )
400      parser_elf2image.add_argument(
401          &quot;--dont-append-digest&quot;,
402          dest=&quot;append_digest&quot;,
403          help=&quot;Don&#x27;t append a SHA256 digest of the entire image after the checksum. &quot;
404          &quot;This argument is not supported and ignored for ESP8266.&quot;,
405          action=&quot;store_false&quot;,
406          default=True,
407      )
408      parser_elf2image.add_argument(
409          &quot;--use_segments&quot;,
410          help=&quot;If set, ELF segments will be used instead of ELF sections &quot;
411          &quot;to genereate the image.&quot;,
412          action=&quot;store_true&quot;,
413      )
414      parser_elf2image.add_argument(
415          &quot;--flash-mmu-page-size&quot;,
416          help=&quot;Change flash MMU page size.&quot;,
417          choices=[&quot;64KB&quot;, &quot;32KB&quot;, &quot;16KB&quot;, &quot;8KB&quot;],
418      )
419      parser_elf2image.add_argument(
420          &quot;--pad-to-size&quot;,
421          help=&quot;The block size with which the final binary image after padding &quot;
422          &quot;must be aligned to. Value 0xFF is used for padding, similar to erase_flash&quot;,
423          default=None,
424      )
425      add_spi_flash_subparsers(parser_elf2image, allow_keep=False, auto_detect=False)
426      subparsers.add_parser(&quot;read_mac&quot;, help=&quot;Read MAC address from OTP ROM&quot;)
427      subparsers.add_parser(&quot;chip_id&quot;, help=&quot;Read Chip ID from OTP ROM&quot;)
428      parser_flash_id = subparsers.add_parser(
429          &quot;flash_id&quot;, help=&quot;Read SPI flash manufacturer and device ID&quot;
430      )
431      add_spi_connection_arg(parser_flash_id)
432      parser_read_status = subparsers.add_parser(
433          &quot;read_flash_status&quot;, help=&quot;Read SPI flash status register&quot;
434      )
435      add_spi_connection_arg(parser_read_status)
436      parser_read_status.add_argument(
437          &quot;--bytes&quot;,
438          help=&quot;Number of bytes to read (1-3)&quot;,
439          type=int,
440          choices=[1, 2, 3],
441          default=2,
442      )
443      parser_write_status = subparsers.add_parser(
444          &quot;write_flash_status&quot;, help=&quot;Write SPI flash status register&quot;
445      )
446      add_spi_connection_arg(parser_write_status)
447      parser_write_status.add_argument(
448          &quot;--non-volatile&quot;,
449          help=&quot;Write non-volatile bits (use with caution)&quot;,
450          action=&quot;store_true&quot;,
451      )
452      parser_write_status.add_argument(
453          &quot;--bytes&quot;,
454          help=&quot;Number of status bytes to write (1-3)&quot;,
455          type=int,
456          choices=[1, 2, 3],
457          default=2,
458      )
459      parser_write_status.add_argument(&quot;value&quot;, help=&quot;New value&quot;, type=arg_auto_int)
460      parser_read_flash = subparsers.add_parser(
461          &quot;read_flash&quot;, help=&quot;Read SPI flash content&quot;
462      )
463      add_spi_connection_arg(parser_read_flash)
464      parser_read_flash.add_argument(&quot;address&quot;, help=&quot;Start address&quot;, type=arg_auto_int)
465      parser_read_flash.add_argument(
466          &quot;size&quot;,
467          help=&quot;Size of region to dump. Use `ALL` to read to the end of flash.&quot;,
468          type=arg_auto_size,
469      )
470      parser_read_flash.add_argument(&quot;filename&quot;, help=&quot;Name of binary dump&quot;)
471      parser_read_flash.add_argument(
472          &quot;--no-progress&quot;, &quot;-p&quot;, help=&quot;Suppress progress output&quot;, action=&quot;store_true&quot;
473      )
474      parser_verify_flash = subparsers.add_parser(
475          &quot;verify_flash&quot;, help=&quot;Verify a binary blob against flash&quot;
476      )
477      parser_verify_flash.add_argument(
478          &quot;addr_filename&quot;,
479          help=&quot;Address and binary file to verify there, separated by space&quot;,
480          action=AddrFilenamePairAction,
481      )
482      parser_verify_flash.add_argument(
483          &quot;--diff&quot;, &quot;-d&quot;, help=&quot;Show differences&quot;, choices=[&quot;no&quot;, &quot;yes&quot;], default=&quot;no&quot;
484      )
485      add_spi_flash_subparsers(parser_verify_flash, allow_keep=True, auto_detect=True)
486      parser_erase_flash = subparsers.add_parser(
487          &quot;erase_flash&quot;, help=&quot;Perform Chip Erase on SPI flash&quot;
488      )
489      parser_erase_flash.add_argument(
490          &quot;--force&quot;,
491          help=&quot;Erase flash even if security features are enabled. Use with caution!&quot;,
492          action=&quot;store_true&quot;,
493      )
494      add_spi_connection_arg(parser_erase_flash)
495      parser_erase_region = subparsers.add_parser(
496          &quot;erase_region&quot;, help=&quot;Erase a region of the flash&quot;
497      )
498      parser_erase_region.add_argument(
499          &quot;--force&quot;,
500          help=&quot;Erase region even if security features are enabled. Use with caution!&quot;,
501          action=&quot;store_true&quot;,
502      )
503      add_spi_connection_arg(parser_erase_region)
504      parser_erase_region.add_argument(
505          &quot;address&quot;, help=&quot;Start address (must be multiple of 4096)&quot;, type=arg_auto_int
506      )
507      parser_erase_region.add_argument(
<span onclick='openModal()' class='match'>508          &quot;size&quot;,
509          help=&quot;Size of region to erase (must be multiple of 4096). &quot;
510          &quot;Use `ALL` to erase to the end of flash.&quot;,
511          type=arg_auto_size,
512      )
513      parser_merge_bin = subparsers.add_parser(
</span>514          &quot;merge_bin&quot;,
515          help=&quot;Merge multiple raw binary files into a single file for later flashing&quot;,
516      )
517      parser_merge_bin.add_argument(
518          &quot;--output&quot;, &quot;-o&quot;, help=&quot;Output filename&quot;, type=str, required=True
519      )
520      parser_merge_bin.add_argument(
521          &quot;--format&quot;, &quot;-f&quot;, help=&quot;Format of the output file&quot;, choices=&quot;raw&quot;, default=&quot;raw&quot;
522      )  # for future expansion
523      add_spi_flash_subparsers(parser_merge_bin, allow_keep=True, auto_detect=False)
524      parser_merge_bin.add_argument(
525          &quot;--target-offset&quot;,
526          &quot;-t&quot;,
527          help=&quot;Target offset where the output file will be flashed&quot;,
528          type=arg_auto_int,
529          default=0,
530      )
531      parser_merge_bin.add_argument(
532          &quot;--fill-flash-size&quot;,
533          help=&quot;If set, the final binary file will be padded with FF &quot;
534          &quot;bytes up to this flash size.&quot;,
535          choices=[
536              &quot;256KB&quot;,
537              &quot;512KB&quot;,
538              &quot;1MB&quot;,
539              &quot;2MB&quot;,
540              &quot;4MB&quot;,
541              &quot;8MB&quot;,
542              &quot;16MB&quot;,
543              &quot;32MB&quot;,
544              &quot;64MB&quot;,
545              &quot;128MB&quot;,
546          ],
547      )
548      parser_merge_bin.add_argument(
549          &quot;addr_filename&quot;,
550          metavar=&quot;&lt;address&gt; &lt;filename&gt;&quot;,
551          help=&quot;Address followed by binary filename, separated by space&quot;,
552          action=AddrFilenamePairAction,
553      )
554      subparsers.add_parser(&quot;get_security_info&quot;, help=&quot;Get some security-related data&quot;)
555      subparsers.add_parser(&quot;version&quot;, help=&quot;Print esptool version&quot;)
556      for operation in subparsers.choices.keys():
557          assert operation in globals(), &quot;%s should be a module function&quot; % operation
558      argv = expand_file_arguments(argv or sys.argv[1:])
559      args = parser.parse_args(argv)
560      print(&quot;esptool.py v%s&quot; % __version__)
561      load_config_file(verbose=True)
562      if args.operation is None:
563          parser.print_help()
564          sys.exit(1)
565      if (
566          args.operation == &quot;write_flash&quot;
567          and args.encrypt
568          and args.encrypt_files is not None
569      ):
570          raise FatalError(
571              &quot;Options --encrypt and --encrypt-files &quot;
572              &quot;must not be specified at the same time.&quot;
573          )
574      operation_func = globals()[args.operation]
575      operation_args = inspect.getfullargspec(operation_func).args
576      if (
577          operation_args[0] == &quot;esp&quot;
578      ):  # operation function takes an ESPLoader connection object
579          if args.before != &quot;no_reset_no_sync&quot;:
580              initial_baud = min(
581                  ESPLoader.ESP_ROM_BAUD, args.baud
582              )  # don&#x27;t sync faster than the default baud rate
583          else:
584              initial_baud = args.baud
585          if args.port is None:
586              ser_list = get_port_list()
587              print(&quot;Found %d serial ports&quot; % len(ser_list))
588          else:
589              ser_list = [args.port]
590          esp = esp or get_default_connected_device(
591              ser_list,
592              port=args.port,
593              connect_attempts=args.connect_attempts,
594              initial_baud=initial_baud,
595              chip=args.chip,
596              trace=args.trace,
597              before=args.before,
598          )
599          if esp is None:
600              raise FatalError(
601                  &quot;Could not connect to an Espressif device &quot;
602                  &quot;on any of the %d available serial ports.&quot; % len(ser_list)
603              )
604          if esp.secure_download_mode:
605              print(&quot;Chip is %s in Secure Download Mode&quot; % esp.CHIP_NAME)
606          else:
607              print(&quot;Chip is %s&quot; % (esp.get_chip_description()))
608              print(&quot;Features: %s&quot; % &quot;, &quot;.join(esp.get_chip_features()))
609              print(&quot;Crystal is %dMHz&quot; % esp.get_crystal_freq())
610              read_mac(esp, args)
611          if not args.no_stub:
612              if esp.secure_download_mode:
613                  print(
614                      &quot;WARNING: Stub loader is not supported in Secure Download Mode, &quot;
615                      &quot;setting --no-stub&quot;
616                  )
617                  args.no_stub = True
618              elif not esp.IS_STUB and esp.stub_is_disabled:
619                  print(
620                      &quot;WARNING: Stub loader has been disabled for compatibility, &quot;
621                      &quot;setting --no-stub&quot;
622                  )
623                  args.no_stub = True
624              else:
625                  try:
626                      esp = esp.run_stub()
627                  except Exception:
628                      if sys.platform == &quot;darwin&quot; and esp._get_pid() == 0x55D4:
629                          print(
630                              &quot;\nNote: If issues persist, &quot;
631                              &quot;try installing the WCH USB-to-Serial MacOS driver.&quot;
632                          )
633                      raise
634          if args.override_vddsdio:
635              esp.override_vddsdio(args.override_vddsdio)
636          if args.baud &gt; initial_baud:
637              try:
638                  esp.change_baud(args.baud)
639              except NotImplementedInROMError:
640                  print(
641                      &quot;WARNING: ROM doesn&#x27;t support changing baud rate. &quot;
642                      &quot;Keeping initial baud rate %d&quot; % initial_baud
643                  )
644          if hasattr(args, &quot;spi_connection&quot;) and args.spi_connection is not None:
645              if esp.CHIP_NAME != &quot;ESP32&quot;:
646                  raise FatalError(
647                      &quot;Chip %s does not support --spi-connection option.&quot; % esp.CHIP_NAME
648                  )
649              print(&quot;Configuring SPI flash mode...&quot;)
650              esp.flash_spi_attach(args.spi_connection)
651          elif args.no_stub:
652              print(&quot;Enabling default SPI flash mode...&quot;)
653              esp.flash_spi_attach(0)
654          XMC_VENDOR_ID = 0x20
655          def is_xmc_chip_strict():
656              id = esp.flash_id()
657              rdid = ((id &amp; 0xFF) &lt;&lt; 16) | ((id &gt;&gt; 16) &amp; 0xFF) | (id &amp; 0xFF00)
658              vendor_id = (rdid &gt;&gt; 16) &amp; 0xFF
659              mfid = (rdid &gt;&gt; 8) &amp; 0xFF
660              cpid = rdid &amp; 0xFF
661              if vendor_id != XMC_VENDOR_ID:
662                  return False
663              matched = False
664              if mfid == 0x40:
665                  if cpid &gt;= 0x13 and cpid &lt;= 0x20:
666                      matched = True
667              elif mfid == 0x41:
668                  if cpid &gt;= 0x17 and cpid &lt;= 0x20:
669                      matched = True
670              elif mfid == 0x50:
671                  if cpid &gt;= 0x15 and cpid &lt;= 0x16:
672                      matched = True
673              return matched
674          def flash_xmc_startup():
675              fast_check = True
676              if fast_check and is_xmc_chip_strict():
677                  return  # Successful XMC flash chip boot-up detected by RDID, skipping.
678              sfdp_mfid_addr = 0x10
679              mf_id = esp.read_spiflash_sfdp(sfdp_mfid_addr, 8)
680              if mf_id != XMC_VENDOR_ID:  # Non-XMC chip detected by SFDP Read, skipping.
681                  return
682              print(
683                  &quot;WARNING: XMC flash chip boot-up failure detected! &quot;
684                  &quot;Running XMC25QHxxC startup flow&quot;
685              )
686              esp.run_spiflash_command(0xB9)  # Enter DPD
687              esp.run_spiflash_command(0x79)  # Enter UDPD
688              esp.run_spiflash_command(0xFF)  # Exit UDPD
689              time.sleep(0.002)  # Delay tXUDPD
690              esp.run_spiflash_command(0xAB)  # Release Power-Down
691              time.sleep(0.00002)
692              if not is_xmc_chip_strict():
693                  print(&quot;WARNING: XMC flash boot-up fix failed.&quot;)
694              print(&quot;XMC flash chip boot-up fix successful!&quot;)
695          if not esp.secure_download_mode:
696              try:
697                  flash_id = esp.flash_id()
698                  if flash_id in (0xFFFFFF, 0x000000):
699                      print(
700                          &quot;WARNING: Failed to communicate with the flash chip, &quot;
701                          &quot;read/write operations will fail. &quot;
702                          &quot;Try checking the chip connections or removing &quot;
703                          &quot;any other hardware connected to IOs.&quot;
704                      )
705              except FatalError as e:
706                  raise FatalError(f&quot;Unable to verify flash chip connection ({e}).&quot;)
707          if not esp.secure_download_mode:
708              try:
709                  flash_xmc_startup()
710              except FatalError as e:
711                  esp.trace(f&quot;Unable to perform XMC flash chip startup sequence ({e}).&quot;)
712          if hasattr(args, &quot;flash_size&quot;):
713              print(&quot;Configuring flash size...&quot;)
714              if args.flash_size == &quot;detect&quot;:
715                  flash_size = detect_flash_size(esp, args)
716              elif args.flash_size == &quot;keep&quot;:
717                  flash_size = detect_flash_size(esp, args=None)
718              else:
719                  flash_size = args.flash_size
720              if flash_size is not None:  # Secure download mode
721                  esp.flash_set_parameters(flash_size_bytes(flash_size))
722                  if esp.IS_STUB and flash_size in (&quot;32MB&quot;, &quot;64MB&quot;, &quot;128MB&quot;):
723                      print(
724                          &quot;WARNING: Flasher stub doesn&#x27;t fully support flash size larger &quot;
725                          &quot;than 16MB, in case of failure use --no-stub.&quot;
726                      )
727          if getattr(args, &quot;size&quot;, &quot;&quot;) == &quot;all&quot;:
728              if esp.secure_download_mode:
729                  raise FatalError(
730                      &quot;Detecting flash size is not supported in secure download mode. &quot;
731                      &quot;Set an exact size value.&quot;
732                  )
733              flash_id = esp.flash_id()
734              size_id = flash_id &gt;&gt; 16
735              size_str = DETECTED_FLASH_SIZES.get(size_id)
736              if size_str is None:
737                  raise FatalError(
738                      &quot;Detecting flash size failed. Set an exact size value.&quot;
739                  )
740              print(f&quot;Detected flash size: {size_str}&quot;)
741              args.size = flash_size_bytes(size_str)
742          if esp.IS_STUB and hasattr(args, &quot;address&quot;) and hasattr(args, &quot;size&quot;):
743              if args.address + args.size &gt; 0x1000000:
744                  print(
745                      &quot;WARNING: Flasher stub doesn&#x27;t fully support flash size larger &quot;
746                      &quot;than 16MB, in case of failure use --no-stub.&quot;
747                  )
748          try:
749              operation_func(esp, args)
750          finally:
751              try:  # Clean up AddrFilenamePairAction files
752                  for address, argfile in args.addr_filename:
753                      argfile.close()
754              except AttributeError:
755                  pass
756          if operation_func == load_ram:
757              print(&quot;Exiting immediately.&quot;)
758          elif args.after == &quot;hard_reset&quot;:
759              esp.hard_reset()
760          elif args.after == &quot;soft_reset&quot;:
761              print(&quot;Soft resetting...&quot;)
762              esp.soft_reset(False)
763          elif args.after == &quot;no_reset_stub&quot;:
764              print(&quot;Staying in flasher stub.&quot;)
765          else:  # args.after == &#x27;no_reset&#x27;
766              print(&quot;Staying in bootloader.&quot;)
767              if esp.IS_STUB:
768                  esp.soft_reset(True)  # exit stub back to ROM loader
769          if not external_esp:
770              esp._port.close()
771      else:
772          operation_func(args)
773  def arg_auto_int(x):
774      return int(x, 0)
775  def arg_auto_size(x):
776      x = x.lower()
777      return x if x == &quot;all&quot; else arg_auto_int(x)
778  def get_port_list():
779      if list_ports is None:
780          raise FatalError(
781              &quot;Listing all serial ports is currently not available. &quot;
782              &quot;Please try to specify the port when running esptool.py or update &quot;
783              &quot;the pyserial package to the latest version&quot;
784          )
785      return sorted(ports.device for ports in list_ports.comports())
786  def expand_file_arguments(argv):
787      new_args = []
788      expanded = False
789      for arg in argv:
790          if arg.startswith(&quot;@&quot;):
791              expanded = True
792              with open(arg[1:], &quot;r&quot;) as f:
793                  for line in f.readlines():
794                      new_args += shlex.split(line)
795          else:
796              new_args.append(arg)
797      if expanded:
798          print(&quot;esptool %s&quot; % (&quot; &quot;.join(new_args[1:])))
799          return new_args
800      return argv
801  def get_default_connected_device(
802      serial_list,
803      port,
804      connect_attempts,
805      initial_baud,
806      chip=&quot;auto&quot;,
807      trace=False,
808      before=&quot;default_reset&quot;,
809  ):
810      _esp = None
811      for each_port in reversed(serial_list):
812          print(&quot;Serial port %s&quot; % each_port)
813          try:
814              if chip == &quot;auto&quot;:
815                  _esp = detect_chip(
816                      each_port, initial_baud, before, trace, connect_attempts
817                  )
818              else:
819                  chip_class = CHIP_DEFS[chip]
820                  _esp = chip_class(each_port, initial_baud, trace)
821                  _esp.connect(before, connect_attempts)
822              break
823          except (FatalError, OSError) as err:
824              if port is not None:
825                  raise
826              print(&quot;%s failed to connect: %s&quot; % (each_port, err))
827              if _esp and _esp._port:
828                  _esp._port.close()
829              _esp = None
830      return _esp
831  class SpiConnectionAction(argparse.Action):
832      def __call__(self, parser, namespace, value, option_string=None):
833          if value.upper() == &quot;SPI&quot;:
834              value = 0
835          elif value.upper() == &quot;HSPI&quot;:
836              value = 1
837          elif &quot;,&quot; in value:
838              values = value.split(&quot;,&quot;)
839              if len(values) != 5:
840                  raise argparse.ArgumentError(
841                      self,
842                      &quot;%s is not a valid list of comma-separate pin numbers. &quot;
843                      &quot;Must be 5 numbers - CLK,Q,D,HD,CS.&quot; % value,
844                  )
845              try:
846                  values = tuple(int(v, 0) for v in values)
847              except ValueError:
848                  raise argparse.ArgumentError(
849                      self,
850                      &quot;%s is not a valid argument. All pins must be numeric values&quot;
851                      % values,
852                  )
853              if any([v for v in values if v &gt; 33 or v &lt; 0]):
854                  raise argparse.ArgumentError(
855                      self, &quot;Pin numbers must be in the range 0-33.&quot;
856                  )
857              clk, q, d, hd, cs = values
858              value = (hd &lt;&lt; 24) | (cs &lt;&lt; 18) | (d &lt;&lt; 12) | (q &lt;&lt; 6) | clk
859          else:
860              raise argparse.ArgumentError(
861                  self,
862                  &quot;%s is not a valid spi-connection value. &quot;
863                  &quot;Values are SPI, HSPI, or a sequence of 5 pin numbers CLK,Q,D,HD,CS).&quot;
864                  % value,
865              )
866          setattr(namespace, self.dest, value)
867  class AddrFilenamePairAction(argparse.Action):
868      def __init__(self, option_strings, dest, nargs=&quot;+&quot;, **kwargs):
869          super(AddrFilenamePairAction, self).__init__(
870              option_strings, dest, nargs, **kwargs
871          )
872      def __call__(self, parser, namespace, values, option_string=None):
873          pairs = []
874          for i in range(0, len(values), 2):
875              try:
876                  address = int(values[i], 0)
877              except ValueError:
878                  raise argparse.ArgumentError(
879                      self, &#x27;Address &quot;%s&quot; must be a number&#x27; % values[i]
880                  )
881              try:
882                  argfile = open(values[i + 1], &quot;rb&quot;)
883              except IOError as e:
884                  raise argparse.ArgumentError(self, e)
885              except IndexError:
886                  raise argparse.ArgumentError(
887                      self,
888                      &quot;Must be pairs of an address &quot;
889                      &quot;and the binary filename to write there&quot;,
890                  )
891              pairs.append((address, argfile))
892          end = 0
893          for address, argfile in sorted(pairs, key=lambda x: x[0]):
894              argfile.seek(0, 2)  # seek to end
895              size = argfile.tell()
896              argfile.seek(0)
897              sector_start = address &amp; ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
898              sector_end = (
899                  (address + size + ESPLoader.FLASH_SECTOR_SIZE - 1)
900                  &amp; ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
901              ) - 1
902              if sector_start &lt; end:
903                  message = &quot;Detected overlap at address: 0x%x for file: %s&quot; % (
904                      address,
905                      argfile.name,
906                  )
907                  raise argparse.ArgumentError(self, message)
908              end = sector_end
909          setattr(namespace, self.dest, pairs)
910  def _main():
911      try:
912          main()
913      except FatalError as e:
914          print(f&quot;\nA fatal error occurred: {e}&quot;)
915          sys.exit(2)
916      except serial.serialutil.SerialException as e:
917          print(f&quot;\nA serial exception error occurred: {e}&quot;)
918          print(
919              &quot;Note: This error originates from pySerial. &quot;
920              &quot;It is likely not a problem with esptool, &quot;
921              &quot;but with the hardware connection or drivers.&quot;
922          )
923          print(
924              &quot;For troubleshooting steps visit: &quot;
925              &quot;https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html&quot;
926          )
927          sys.exit(1)
928      except StopIteration:
929          print(traceback.format_exc())
930          print(&quot;A fatal error occurred: The chip stopped responding.&quot;)
931          sys.exit(2)
932  if __name__ == &quot;__main__&quot;:
933      _main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___49.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___49.py</div>
                </div>
                <div class="column column_space"><pre><code>344          &quot;-o&quot;,
345          help=&quot;Output filename prefix (for version 1 image), &quot;
346          &quot;or filename (for version 2 single image)&quot;,
347          type=str,
348      )
349      parser_elf2image.add_argument(
</pre></code></div>
                <div class="column column_space"><pre><code>508          &quot;size&quot;,
509          help=&quot;Size of region to erase (must be multiple of 4096). &quot;
510          &quot;Use `ALL` to erase to the end of flash.&quot;,
511          type=arg_auto_size,
512      )
513      parser_merge_bin = subparsers.add_parser(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    