<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for batch.py &amp; pip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for batch.py &amp; pip.py
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>batch.py (2.1818182%)<th>pip.py (0.6263048%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-16)<td><a href="#" name="0">(89-100)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>batch.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
2 import logging
3 import math
4 import time
5 from datetime import datetime, timedelta
6 import salt.client
7 import salt.exceptions
8 import salt.output
9 import salt.utils.stringutils
10 log = logging.getLogger(</b></font>__name__)
11 class Batch:
12     def __init__(self, opts, eauth=None, quiet=False, _parser=None):
13         self.opts = opts
14         self.eauth = eauth if eauth else {}
15         self.pub_kwargs = eauth if eauth else {}
16         self.quiet = quiet
17         self.options = _parser
18         self.local = salt.client.get_local_client(opts["conf_file"], listen=True)
19     def gather_minions(self):
20         args = [
21             self.opts["tgt"],
22             "test.ping",
23             [],
24             self.opts["timeout"],
25         ]
26         selected_target_option = self.opts.get("selected_target_option", None)
27         if selected_target_option is not None:
28             args.append(selected_target_option)
29         else:
30             args.append(self.opts.get("tgt_type", "glob"))
31         self.pub_kwargs["yield_pub_data"] = True
32         ping_gen = self.local.cmd_iter(
33             *args, gather_job_timeout=self.opts["gather_job_timeout"], **self.pub_kwargs
34         )
35         fret = set()
36         nret = set()
37         for ret in ping_gen:
38             if ("minions" and "jid") in ret:
39                 for minion in ret["minions"]:
40                     nret.add(minion)
41                 continue
42             else:
43                 try:
44                     m = next(iter(ret.keys()))
45                 except StopIteration:
46                     if not self.quiet:
47                         salt.utils.stringutils.print_cli(
48                             "No minions matched the target."
49                         )
50                     break
51                 if m is not None:
52                     fret.add(m)
53         return (list(fret), ping_gen, nret.difference(fret))
54     def get_bnum(self):
55         partition = lambda x: float(x) / 100.0 * len(self.minions)
56         try:
57             if isinstance(self.opts["batch"], str) and "%" in self.opts["batch"]:
58                 res = partition(float(self.opts["batch"].strip("%")))
59                 if res &lt; 1:
60                     return int(math.ceil(res))
61                 else:
62                     return int(res)
63             else:
64                 return int(self.opts["batch"])
65         except ValueError:
66             if not self.quiet:
67                 salt.utils.stringutils.print_cli(
68                     "Invalid batch data sent: {}\nData must be in the "
69                     "form of %10, 10% or 3".format(self.opts["batch"])
70                 )
71     def __update_wait(self, wait):
72         now = datetime.now()
73         i = 0
74         while i &lt; len(wait) and wait[i] &lt;= now:
75             i += 1
76         if i:
77             del wait[:i]
78     def run(self):
79         self.minions, self.ping_gen, self.down_minions = self.gather_minions()
80         args = [
81             [],
82             self.opts["fun"],
83             self.opts["arg"],
84             self.opts["timeout"],
85             "list",
86         ]
87         bnum = self.get_bnum()
88         if not self.minions:
89             return
90         to_run = copy.deepcopy(self.minions)
91         active = []
92         ret = {}
93         iters = []
94         bwait = self.opts.get("batch_wait", 0)
95         wait = []
96         if self.options:
97             show_jid = self.options.show_jid
98             show_verbose = self.options.verbose
99         else:
100             show_jid = False
101             show_verbose = False
102         minion_tracker = {}
103         if not self.quiet:
104             for down_minion in self.down_minions:
105                 salt.utils.stringutils.print_cli(
106                     "Minion {} did not respond. No job will be sent.".format(
107                         down_minion
108                     )
109                 )
110         while len(ret) &lt; len(self.minions):
111             next_ = []
112             if bwait and wait:
113                 self.__update_wait(wait)
114             if len(to_run) &lt;= bnum - len(wait) and not active:
115                 while to_run:
116                     next_.append(to_run.pop())
117             else:
118                 for i in range(bnum - len(active) - len(wait)):
119                     if to_run:
120                         minion_id = to_run.pop()
121                         if isinstance(minion_id, dict):
122                             next_.append(next(iter(minion_id)))
123                         else:
124                             next_.append(minion_id)
125             active += next_
126             args[0] = next_
127             if next_:
128                 if not self.quiet:
129                     salt.utils.stringutils.print_cli(
130                         "\nExecuting run on {}\n".format(sorted(next_))
131                     )
132                 return_value = self.opts.get("return", self.opts.get("ret", ""))
133                 new_iter = self.local.cmd_iter_no_block(
134                     *args,
135                     raw=self.opts.get("raw", False),
136                     ret=return_value,
137                     show_jid=show_jid,
138                     verbose=show_verbose,
139                     gather_job_timeout=self.opts["gather_job_timeout"],
140                     **self.eauth,
141                 )
142                 iters.append(new_iter)
143                 minion_tracker[new_iter] = {}
144                 minion_tracker[new_iter]["minions"] = next_
145                 minion_tracker[new_iter]["active"] = True
146             else:
147                 time.sleep(0.02)
148             parts = {}
149             for ping_ret in self.ping_gen:
150                 if ping_ret is None:
151                     break
152                 m = next(iter(ping_ret.keys()))
153                 if m not in self.minions:
154                     self.minions.append(m)
155                     to_run.append(m)
156             for queue in iters:
157                 try:
158                     ncnt = 0
159                     while True:
160                         part = next(queue)
161                         if part is None:
162                             time.sleep(0.01)
163                             ncnt += 1
164                             if ncnt &gt; 5:
165                                 break
166                             continue
167                         if self.opts.get("raw"):
168                             parts.update({part["data"]["id"]: part})
169                             if part["data"]["id"] in minion_tracker[queue]["minions"]:
170                                 minion_tracker[queue]["minions"].remove(
171                                     part["data"]["id"]
172                                 )
173                             else:
174                                 salt.utils.stringutils.print_cli(
175                                     "minion {} was already deleted from tracker,"
176                                     " probably a duplicate key".format(part["id"])
177                                 )
178                         else:
179                             parts.update(part)
180                             for id in part:
181                                 if id in minion_tracker[queue]["minions"]:
182                                     minion_tracker[queue]["minions"].remove(id)
183                                 else:
184                                     salt.utils.stringutils.print_cli(
185                                         "minion {} was already deleted from tracker,"
186                                         " probably a duplicate key".format(id)
187                                     )
188                 except StopIteration:
189                     if queue in minion_tracker:
190                         minion_tracker[queue]["active"] = False
191                         for minion in minion_tracker[queue]["minions"]:
192                             if minion not in parts:
193                                 parts[minion] = {}
194                                 parts[minion]["ret"] = {}
195             for minion, data in parts.items():
196                 if minion in active:
197                     active.remove(minion)
198                     if bwait:
199                         wait.append(datetime.now() + timedelta(seconds=bwait))
200                 failhard = False
201                 failed_check = data.get("failed", False)
202                 if failed_check:
203                     log.debug(
204                         "Minion '%s' failed to respond to job sent, data '%s'",
205                         minion,
206                         data,
207                     )
208                     if not self.quiet:
209                         salt.utils.stringutils.print_cli(
210                             "Minion '%s' failed to respond to job sent", minion
211                         )
212                     if self.opts.get("failhard"):
213                         failhard = True
214                 else:
215                     retcode = 0
216                     if "retcode" in data:
217                         if isinstance(data["retcode"], dict):
218                             try:
219                                 data["retcode"] = max(data["retcode"].values())
220                             except ValueError:
221                                 data["retcode"] = 0
222                         if self.opts.get("failhard") and data["retcode"] &gt; 0:
223                             failhard = True
224                         retcode = data["retcode"]
225                     if self.opts.get("raw"):
226                         ret[minion] = data
227                         yield data, retcode
228                     else:
229                         ret[minion] = data["ret"]
230                         yield {minion: data["ret"]}, retcode
231                     if not self.quiet:
232                         ret[minion] = data["ret"]
233                         data[minion] = data.pop("ret")
234                         if "out" in data:
235                             out = data.pop("out")
236                         else:
237                             out = None
238                         salt.output.display_output(data, out, self.opts)
239                 if failhard:
240                     log.error(
241                         "Minion %s returned with non-zero exit code. "
242                         "Batch run stopped due to failhard",
243                         minion,
244                     )
245                     return
246             for queue in minion_tracker:
247                 if not minion_tracker[queue]["active"] and queue in iters:
248                     iters.remove(queue)
249                     for minion in minion_tracker[queue]["minions"]:
250                         if minion in active:
251                             active.remove(minion)
252                             if bwait:
253                                 wait.append(datetime.now() + timedelta(seconds=bwait))
254         self.local.destroy()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 r"""
2 Install Python packages with pip to either the system or a virtualenv
3 Windows Support
4 ===============
5 .. versionadded:: 2014.7.4
6 Salt now uses a portable python. As a result the entire pip module is now
7 functional on the salt installation itself. You can pip install dependencies
8 for your custom modules. You can even upgrade salt itself using pip. For this
9 to work properly, you must specify the Current Working Directory (``cwd``) and
10 the Pip Binary (``bin_env``) salt should use.  The variable ``pip_bin`` can be
11 either a virtualenv path or the path to the pip binary itself.
12 For example, the following command will list all software installed using pip
13 to your current salt environment:
14 .. code-block:: bat
15    salt &lt;minion&gt; pip.list cwd='C:\salt\bin\Scripts' bin_env='C:\salt\bin\Scripts\pip.exe'
16 Specifying the ``cwd`` and ``bin_env`` options ensures you're modifying the
17 salt environment. If these are omitted, it will default to the local
18 installation of python. If python is not installed locally it will fail saying
19 it couldn't find pip.
20 State File Support
21 ------------------
22 This functionality works in states as well. If you need to pip install colorama
23 with a state, for example, the following will work:
24 .. code-block:: yaml
25    install_colorama:
26      pip.installed:
27        - name: colorama
28        - cwd: 'C:\salt\bin\scripts'
29        - bin_env: 'C:\salt\bin\scripts\pip.exe'
30        - upgrade: True
31 Upgrading Salt using Pip
32 ------------------------
33 You can now update salt using pip to any version from the 2014.7 branch
34 forward. Previous version require recompiling some of the dependencies which is
35 painful in windows.
36 To do this you just use pip with git to update to the version you want and then
37 restart the service. Here is a sample state file that upgrades salt to the head
38 of the 2015.5 branch:
39 .. code-block:: yaml
40    install_salt:
41      pip.installed:
42        - cwd: 'C:\salt\bin\scripts'
43        - bin_env: 'C:\salt\bin\scripts\pip.exe'
44        - editable: git+https://github.com/saltstack/salt@2015.5#egg=salt
45        - upgrade: True
46    restart_service:
47      service.running:
48        - name: salt-minion
49        - enable: True
50        - watch:
51          - pip: install_salt
52 .. note::
53    If you're having problems, you might try doubling the back slashes. For
54    example, cwd: 'C:\\salt\\bin\\scripts'. Sometimes python thinks the single
55    back slash is an escape character.
56    There is a known incompatibility between Python2 pip&gt;=10.* and Salt &lt;=2018.3.0.
57    The issue is described here: https://github.com/saltstack/salt/issues/46163
58 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.data
59 import salt.utils.files
60 import salt.utils.json
61 import salt.utils.locales
62 import salt.utils.platform
63 import salt.utils.stringutils
64 import salt.utils.url
65 import salt.utils.versions
66 from salt.exceptions import CommandExecutionError, CommandNotFoundError
67 logger = logging.getLogger(</b></font>__name__)  # pylint: disable=invalid-name
68 __func_alias__ = {"list_": "list"}
69 VALID_PROTOS = ["http", "https", "ftp", "file"]
70 rex_pip_chain_read = re.compile(r"(?:-r\s|--requirement[=\s])(.*)\n?", re.MULTILINE)
71 rex_pip_reqs_comment = re.compile(r"(?:^|\s+)#.*$", re.MULTILINE)
72 def __virtual__():
73     return "pip"
74 def _pip_bin_env(cwd, bin_env):
75     if salt.utils.platform.is_windows():
76         if bin_env is not None and cwd is None and "pip" in os.path.basename(bin_env):
77             cwd = os.path.dirname(bin_env)
78     return cwd
79 def _clear_context(bin_env=None):
80     contextkey = "pip.version"
81     if bin_env is not None:
82         contextkey = "{}.{}".format(contextkey, bin_env)
83     __context__.pop(contextkey, None)
84 def _check_bundled():
85     if getattr(sys, "frozen", False) and hasattr(sys, "_MEIPASS"):
86         return True
87     return False
88 def _get_pip_bin(bin_env):
89     bundled = _check_bundled()
90     if not bin_env:
91         if bundled:
92             logger.debug("pip: Using pip from bundled app")
93             return [os.path.normpath(sys.executable), "pip"]
94         else:
95             logger.debug("pip: Using pip from currently-running Python")
96             return [os.path.normpath(sys.executable), "-m", "pip"]
97     python_bin = "python.exe" if salt.utils.platform.is_windows() else "python"
98     def _search_paths(*basedirs):
99         ret = []
100         for path in basedirs:
101             ret.extend(
102                 [
103                     os.path.join(path, python_bin),
104                     os.path.join(path, "bin", python_bin),
105                     os.path.join(path, "Scripts", python_bin),
106                 ]
107             )
108         return ret
109     if os.path.isdir(bin_env):
110         for bin_path in _search_paths(bin_env):
111             if os.path.isfile(bin_path):
112                 if os.access(bin_path, os.X_OK):
113                     logger.debug("pip: Found python binary: %s", bin_path)
114                     return [os.path.normpath(bin_path), "-m", "pip"]
115                 else:
116                     logger.debug(
117                         "pip: Found python binary by name but it is not executable: %s",
118                         bin_path,
119                     )
120         raise CommandNotFoundError(
121             "Could not find a pip binary in virtualenv {}".format(bin_env)
122         )
123     elif os.access(bin_env, os.X_OK):
124         if os.path.isfile(bin_env):
125             if "python" in os.path.basename(bin_env):
126                 return [os.path.normpath(bin_env), "-m", "pip"]
127             return [os.path.normpath(bin_env)]
128         raise CommandExecutionError(
129             "Could not find a pip binary within {}".format(bin_env)
130         )
131     else:
132         raise CommandNotFoundError(
133             "Access denied to {}, could not find a pip binary".format(bin_env)
134         )
135 def _get_cached_requirements(requirements, saltenv):
136     req_file, senv = salt.utils.url.parse(requirements)
137     if senv:
138         saltenv = senv
139     if req_file not in __salt__["cp.list_master"](saltenv):
140         return False
141     cached_requirements = __salt__["cp.is_cached"](requirements, saltenv)
142     if not cached_requirements:
143         cached_requirements = __salt__["cp.cache_file"](requirements, saltenv)
144     if __salt__["cp.hash_file"](requirements, saltenv) != __salt__["cp.hash_file"](
145         cached_requirements, saltenv
146     ):
147         cached_requirements = __salt__["cp.cache_file"](requirements, saltenv)
148     return cached_requirements
149 def _get_env_activate(bin_env):
150     if not bin_env:
151         raise CommandNotFoundError("Could not find a `activate` binary")
152     if os.path.isdir(bin_env):
153         if salt.utils.platform.is_windows():
154             activate_bin = os.path.join(bin_env, "Scripts", "activate.bat")
155         else:
156             activate_bin = os.path.join(bin_env, "bin", "activate")
157         if os.path.isfile(activate_bin):
158             return activate_bin
159     raise CommandNotFoundError("Could not find a `activate` binary")
160 def _find_req(link):
161     logger.info("_find_req -- link = %s", link)
162     with salt.utils.files.fopen(link) as fh_link:
163         reqs_content = salt.utils.stringutils.to_unicode(fh_link.read())
164     reqs_content = rex_pip_reqs_comment.sub("", reqs_content)  # remove comments
165     child_links = rex_pip_chain_read.findall(reqs_content)
166     base_path = os.path.dirname(link)
167     child_links = [os.path.join(base_path, d) for d in child_links]
168     return child_links
169 def _resolve_requirements_chain(requirements):
170     chain = []
171     if isinstance(requirements, str):
172         requirements = [requirements]
173     for req_file in requirements:
174         chain.append(req_file)
175         chain.extend(_resolve_requirements_chain(_find_req(req_file)))
176     return chain
177 def _process_requirements(requirements, cmd, cwd, saltenv, user):
178     cleanup_requirements = []
179     if requirements is not None:
180         if isinstance(requirements, str):
181             requirements = [r.strip() for r in requirements.split(",")]
182         elif not isinstance(requirements, list):
183             raise TypeError("requirements must be a string or list")
184         treq = None
185         for requirement in requirements:
186             logger.debug("TREQ IS: %s", treq)
187             if requirement.startswith("salt://"):
188                 cached_requirements = _get_cached_requirements(requirement, saltenv)
189                 if not cached_requirements:
190                     ret = {
191                         "result": False,
192                         "comment": "pip requirements file '{}' not found".format(
193                             requirement
194                         ),
195                     }
196                     return None, ret
197                 requirement = cached_requirements
198             if user:
199                 if not treq:
200                     treq = tempfile.mkdtemp()
201                 __salt__["file.chown"](treq, user, None)
202                 if salt.utils.platform.is_windows():
203                     __utils__["dacl.set_permissions"](
204                         obj_name=treq, principal=user, permissions="read_execute"
205                     )
206                 current_directory = None
207                 if not current_directory:
208                     current_directory = os.path.abspath(os.curdir)
209                 logger.info(
210                     "_process_requirements from directory, %s -- requirement: %s",
211                     cwd,
212                     requirement,
213                 )
214                 if cwd is None:
215                     r = requirement
216                     c = cwd
217                     requirement_abspath = os.path.abspath(requirement)
218                     cwd = os.path.dirname(requirement_abspath)
219                     requirement = os.path.basename(requirement)
220                     logger.debug(
221                         "\n\tcwd: %s -&gt; %s\n\trequirement: %s -&gt; %s\n",
222                         c,
223                         cwd,
224                         r,
225                         requirement,
226                     )
227                 os.chdir(cwd)
228                 reqs = _resolve_requirements_chain(requirement)
229                 os.chdir(current_directory)
230                 logger.info("request files: %s", reqs)
231                 for req_file in reqs:
232                     if not os.path.isabs(req_file):
233                         req_file = os.path.join(cwd, req_file)
234                     logger.debug("TREQ N CWD: %s -- %s -- for %s", treq, cwd, req_file)
235                     target_path = os.path.join(treq, os.path.basename(req_file))
236                     logger.debug("S: %s", req_file)
237                     logger.debug("T: %s", target_path)
238                     target_base = os.path.dirname(target_path)
239                     if not os.path.exists(target_base):
240                         os.makedirs(target_base, mode=0o755)
241                         __salt__["file.chown"](target_base, user, None)
242                     if not os.path.exists(target_path):
243                         logger.debug("Copying %s to %s", req_file, target_path)
244                         __salt__["file.copy"](req_file, target_path)
245                     logger.debug(
246                         "Changing ownership of requirements file '%s' to user '%s'",
247                         target_path,
248                         user,
249                     )
250                     __salt__["file.chown"](target_path, user, None)
251             req_args = os.path.join(treq, requirement) if treq else requirement
252             cmd.extend(["--requirement", req_args])
253         cleanup_requirements.append(treq)
254     logger.debug("CLEANUP_REQUIREMENTS: %s", cleanup_requirements)
255     return cleanup_requirements, None
256 def _format_env_vars(env_vars):
257     ret = {}
258     if env_vars:
259         if isinstance(env_vars, dict):
260             for key, val in env_vars.items():
261                 if not isinstance(key, str):
262                     key = str(key)
263                 if not isinstance(val, str):
264                     val = str(val)
265                 ret[key] = val
266         else:
267             raise CommandExecutionError(
268                 "env_vars {} is not a dictionary".format(env_vars)
269             )
270     return ret
271 def install(
272     pkgs=None,  # pylint: disable=R0912,R0913,R0914
273     requirements=None,
274     bin_env=None,
275     use_wheel=False,
276     no_use_wheel=False,
277     log=None,
278     proxy=None,
279     timeout=None,
280     editable=None,
281     find_links=None,
282     index_url=None,
283     extra_index_url=None,
284     no_index=False,
285     mirrors=None,
286     build=None,
287     target=None,
288     download=None,
289     download_cache=None,
290     source=None,
291     upgrade=False,
292     force_reinstall=False,
293     ignore_installed=False,
294     exists_action=None,
295     no_deps=False,
296     no_install=False,
297     no_download=False,
298     global_options=None,
299     install_options=None,
300     user=None,
301     cwd=None,
302     pre_releases=False,
303     cert=None,
304     allow_all_external=False,
305     allow_external=None,
306     allow_unverified=None,
307     process_dependency_links=False,
308     saltenv="base",
309     env_vars=None,
310     use_vt=False,
311     trusted_host=None,
312     no_cache_dir=False,
313     extra_args=None,
314     cache_dir=None,
315     no_binary=None,
316     disable_version_check=False,
317     **kwargs
318 ):
319     cwd = _pip_bin_env(cwd, bin_env)
320     cmd = _get_pip_bin(bin_env)
321     cmd.append("install")
322     cleanup_requirements, error = _process_requirements(
323         requirements=requirements, cmd=cmd, cwd=cwd, saltenv=saltenv, user=user
324     )
325     if error:
326         return error
327     cur_version = version(bin_env, cwd, user=user)
328     if use_wheel:
329         min_version = "1.4"
330         max_version = "9.0.3"
331         too_low = salt.utils.versions.compare(
332             ver1=cur_version, oper="&lt;", ver2=min_version
333         )
334         too_high = salt.utils.versions.compare(
335             ver1=cur_version, oper="&gt;", ver2=max_version
336         )
337         if too_low or too_high:
338             logger.error(
339                 "The --use-wheel option is only supported in pip between %s and "
340                 "%s. The version of pip detected is %s. This option "
341                 "will be ignored.",
342                 min_version,
343                 max_version,
344                 cur_version,
345             )
346         else:
347             cmd.append("--use-wheel")
348     if no_use_wheel:
349         min_version = "1.4"
350         max_version = "9.0.3"
351         too_low = salt.utils.versions.compare(
352             ver1=cur_version, oper="&lt;", ver2=min_version
353         )
354         too_high = salt.utils.versions.compare(
355             ver1=cur_version, oper="&gt;", ver2=max_version
356         )
357         if too_low or too_high:
358             logger.error(
359                 "The --no-use-wheel option is only supported in pip between %s and "
360                 "%s. The version of pip detected is %s. This option "
361                 "will be ignored.",
362                 min_version,
363                 max_version,
364                 cur_version,
365             )
366         else:
367             cmd.append("--no-use-wheel")
368     if no_binary:
369         min_version = "7.0.0"
370         too_low = salt.utils.versions.compare(
371             ver1=cur_version, oper="&lt;", ver2=min_version
372         )
373         if too_low:
374             logger.error(
375                 "The --no-binary option is only supported in pip %s and "
376                 "newer. The version of pip detected is %s. This option "
377                 "will be ignored.",
378                 min_version,
379                 cur_version,
380             )
381         else:
382             if isinstance(no_binary, list):
383                 no_binary = ",".join(no_binary)
384             cmd.extend(["--no-binary", no_binary])
385     if log:
386         if os.path.isdir(log):
387             raise OSError("'{}' is a directory. Use --log path_to_file".format(log))
388         elif not os.access(log, os.W_OK):
389             raise OSError("'{}' is not writeable".format(log))
390         cmd.extend(["--log", log])
391     config = __opts__
392     if proxy:
393         cmd.extend(["--proxy", proxy])
394     elif proxy is not False and config.get("proxy_host") and config.get("proxy_port"):
395         if config.get("proxy_username") and config.get("proxy_password"):
396             http_proxy_url = "http://{proxy_username}:{proxy_password}@{proxy_host}:{proxy_port}".format(
397                 **config
398             )
399         else:
400             http_proxy_url = "http://{proxy_host}:{proxy_port}".format(**config)
401         cmd.extend(["--proxy", http_proxy_url])
402     if timeout:
403         try:
404             if isinstance(timeout, float):
405                 raise ValueError("Timeout cannot be a float")
406             int(timeout)
407         except ValueError:
408             raise ValueError(
409                 "'{}' is not a valid timeout, must be an integer".format(timeout)
410             )
411         cmd.extend(["--timeout", timeout])
412     if find_links:
413         if isinstance(find_links, str):
414             find_links = [l.strip() for l in find_links.split(",")]
415         for link in find_links:
416             if not (
417                 salt.utils.url.validate(link, VALID_PROTOS) or os.path.exists(link)
418             ):
419                 raise CommandExecutionError(
420                     "'{}' is not a valid URL or path".format(link)
421                 )
422             cmd.extend(["--find-links", link])
423     if no_index and (index_url or extra_index_url):
424         raise CommandExecutionError(
425             "'no_index' and ('index_url' or 'extra_index_url') are mutually exclusive."
426         )
427     if index_url:
428         if not salt.utils.url.validate(index_url, VALID_PROTOS):
429             raise CommandExecutionError("'{}' is not a valid URL".format(index_url))
430         cmd.extend(["--index-url", index_url])
431     if extra_index_url:
432         if not salt.utils.url.validate(extra_index_url, VALID_PROTOS):
433             raise CommandExecutionError(
434                 "'{}' is not a valid URL".format(extra_index_url)
435             )
436         cmd.extend(["--extra-index-url", extra_index_url])
437     if no_index:
438         cmd.append("--no-index")
439     if mirrors:
440         if salt.utils.versions.compare(ver1=cur_version, oper="&gt;=", ver2="7.0.0"):
441             raise CommandExecutionError(
442                 "pip &gt;= 7.0.0 does not support mirror argument:"
443                 " use index_url and/or extra_index_url instead"
444             )
445         if isinstance(mirrors, str):
446             mirrors = [m.strip() for m in mirrors.split(",")]
447         cmd.append("--use-mirrors")
448         for mirror in mirrors:
449             if not mirror.startswith("http://"):
450                 raise CommandExecutionError("'{}' is not a valid URL".format(mirror))
451             cmd.extend(["--mirrors", mirror])
452     if disable_version_check:
453         cmd.extend(["--disable-pip-version-check"])
454     if build:
455         cmd.extend(["--build", build])
456     if target:
457         cmd.extend(["--target", target])
458     if download:
459         cmd.extend(["--download", download])
460     if download_cache or cache_dir:
461         cmd.extend(
462             [
463                 "--cache-dir"
464                 if salt.utils.versions.compare(ver1=cur_version, oper="&gt;=", ver2="6.0")
465                 else "--download-cache",
466                 download_cache or cache_dir,
467             ]
468         )
469     if source:
470         cmd.extend(["--source", source])
471     if upgrade:
472         cmd.append("--upgrade")
473     if force_reinstall:
474         cmd.append("--force-reinstall")
475     if ignore_installed:
476         cmd.append("--ignore-installed")
477     if exists_action:
478         if exists_action.lower() not in ("s", "i", "w", "b"):
479             raise CommandExecutionError(
480                 "The exists_action pip option only supports the values "
481                 "s, i, w, and b. '{}' is not valid.".format(exists_action)
482             )
483         cmd.extend(["--exists-action", exists_action])
484     if no_deps:
485         cmd.append("--no-deps")
486     if no_install:
487         cmd.append("--no-install")
488     if no_download:
489         cmd.append("--no-download")
490     if no_cache_dir:
491         cmd.append("--no-cache-dir")
492     if pre_releases:
493         pip_version = cur_version
494         if salt.utils.versions.compare(ver1=pip_version, oper="&gt;=", ver2="1.4"):
495             cmd.append("--pre")
496     if cert:
497         cmd.extend(["--cert", cert])
498     if global_options:
499         if isinstance(global_options, str):
500             global_options = [go.strip() for go in global_options.split(",")]
501         for opt in global_options:
502             cmd.extend(["--global-option", opt])
503     if install_options:
504         if isinstance(install_options, str):
505             install_options = [io.strip() for io in install_options.split(",")]
506         for opt in install_options:
507             cmd.extend(["--install-option", opt])
508     if pkgs:
509         if not isinstance(pkgs, list):
510             try:
511                 pkgs = [p.strip() for p in pkgs.split(",")]
512             except AttributeError:
513                 pkgs = [p.strip() for p in str(pkgs).split(",")]
514         pkgs = salt.utils.data.stringify(salt.utils.data.decode_list(pkgs))
515         cmd.extend([p.replace(";", ",") for p in pkgs])
516     elif not any([requirements, editable]):
517         return {"retcode": 0, "stdout": "No packages to install."}
518     if editable:
519         egg_match = re.compile(r"(?:#|#.*?&amp;)egg=([^&amp;]*)")
520         if isinstance(editable, str):
521             editable = [e.strip() for e in editable.split(",")]
522         for entry in editable:
523             if not (entry == "." or entry.startswith(("file://", "/"))):
524                 match = egg_match.search(entry)
525                 if not match or not match.group(1):
526                     raise CommandExecutionError(
527                         "You must specify an egg for this editable"
528                     )
529             cmd.extend(["--editable", entry])
530     if allow_all_external:
531         cmd.append("--allow-all-external")
532     if allow_external:
533         if isinstance(allow_external, str):
534             allow_external = [p.strip() for p in allow_external.split(",")]
535         for pkg in allow_external:
536             cmd.extend(["--allow-external", pkg])
537     if allow_unverified:
538         if isinstance(allow_unverified, str):
539             allow_unverified = [p.strip() for p in allow_unverified.split(",")]
540         for pkg in allow_unverified:
541             cmd.extend(["--allow-unverified", pkg])
542     if process_dependency_links:
543         cmd.append("--process-dependency-links")
544     if trusted_host:
545         cmd.extend(["--trusted-host", trusted_host])
546     if extra_args:
547         for arg in extra_args:
548             if isinstance(arg, dict):
549                 key, val = arg.popitem()
550                 if isinstance(val, (dict, list)):
551                     raise TypeError("Too many levels in: {}".format(key))
552                 cmd.extend([key, val])
553             else:
554                 cmd.append(arg)
555     cmd_kwargs = dict(saltenv=saltenv, use_vt=use_vt, runas=user)
556     if kwargs:
557         cmd_kwargs.update(kwargs)
558     if env_vars:
559         cmd_kwargs.setdefault("env", {}).update(_format_env_vars(env_vars))
560     try:
561         if cwd:
562             cmd_kwargs["cwd"] = cwd
563         if bin_env and os.path.isdir(bin_env):
564             cmd_kwargs.setdefault("env", {})["VIRTUAL_ENV"] = bin_env
565         logger.debug(
566             "TRY BLOCK: end of pip.install -- cmd: %s, cmd_kwargs: %s", cmd, cmd_kwargs
567         )
568         return __salt__["cmd.run_all"](cmd, python_shell=False, **cmd_kwargs)
569     finally:
570         _clear_context(bin_env)
571         for tempdir in [cr for cr in cleanup_requirements if cr is not None]:
572             if os.path.isdir(tempdir):
573                 shutil.rmtree(tempdir)
574 def uninstall(
575     pkgs=None,
576     requirements=None,
577     bin_env=None,
578     log=None,
579     proxy=None,
580     timeout=None,
581     user=None,
582     cwd=None,
583     saltenv="base",
584     use_vt=False,
585 ):
586     cwd = _pip_bin_env(cwd, bin_env)
587     cmd = _get_pip_bin(bin_env)
588     cmd.extend(["uninstall", "-y"])
589     cleanup_requirements, error = _process_requirements(
590         requirements=requirements, cmd=cmd, saltenv=saltenv, user=user, cwd=cwd
591     )
592     if error:
593         return error
594     if log:
595         try:
596             os.path.exists(log)
597         except OSError:
598             raise OSError("'{}' is not writeable".format(log))
599         cmd.extend(["--log", log])
600     config = __opts__
601     if proxy:
602         cmd.extend(["--proxy", proxy])
603     elif proxy is not False and config.get("proxy_host") and config.get("proxy_port"):
604         if config.get("proxy_username") and config.get("proxy_password"):
605             http_proxy_url = "http://{proxy_username}:{proxy_password}@{proxy_host}:{proxy_port}".format(
606                 **config
607             )
608         else:
609             http_proxy_url = "http://{proxy_host}:{proxy_port}".format(**config)
610         cmd.extend(["--proxy", http_proxy_url])
611     if timeout:
612         try:
613             if isinstance(timeout, float):
614                 raise ValueError("Timeout cannot be a float")
615             int(timeout)
616         except ValueError:
617             raise ValueError(
618                 "'{}' is not a valid timeout, must be an integer".format(timeout)
619             )
620         cmd.extend(["--timeout", timeout])
621     if pkgs:
622         if isinstance(pkgs, str):
623             pkgs = [p.strip() for p in pkgs.split(",")]
624         if requirements:
625             for requirement in requirements:
626                 with salt.utils.files.fopen(requirement) as rq_:
627                     for req in rq_:
628                         req = salt.utils.stringutils.to_unicode(req)
629                         try:
630                             req_pkg, _ = req.split("==")
631                             if req_pkg in pkgs:
632                                 pkgs.remove(req_pkg)
633                         except ValueError:
634                             pass
635         cmd.extend(pkgs)
636     cmd_kwargs = dict(
637         python_shell=False, runas=user, cwd=cwd, saltenv=saltenv, use_vt=use_vt
638     )
639     if bin_env and os.path.isdir(bin_env):
640         cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
641     try:
642         return __salt__["cmd.run_all"](cmd, **cmd_kwargs)
643     finally:
644         _clear_context(bin_env)
645         for requirement in cleanup_requirements:
646             if requirement:
647                 try:
648                     os.remove(requirement)
649                 except OSError:
650                     pass
651 def freeze(bin_env=None, user=None, cwd=None, use_vt=False, env_vars=None, **kwargs):
652     cwd = _pip_bin_env(cwd, bin_env)
653     cmd = _get_pip_bin(bin_env)
654     cmd.append("freeze")
655     min_version = "8.0.3"
656     cur_version = version(bin_env, cwd)
657     if salt.utils.versions.compare(ver1=cur_version, oper="&lt;", ver2=min_version):
658         logger.warning(
659             "The version of pip installed is %s, which is older than %s. "
660             "The packages pip, wheel, setuptools, and distribute will not be "
661             "included in the output of pip.freeze",
662             cur_version,
663             min_version,
664         )
665     else:
666         cmd.append("--all")
667     cmd_kwargs = dict(runas=user, cwd=cwd, use_vt=use_vt, python_shell=False)
668     if kwargs:
669         cmd_kwargs.update(**kwargs)
670     if bin_env and os.path.isdir(bin_env):
671         cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
672     if env_vars:
673         cmd_kwargs.setdefault("env", {}).update(_format_env_vars(env_vars))
674     result = __salt__["cmd.run_all"](cmd, **cmd_kwargs)
675     if result["retcode"]:
676         raise CommandExecutionError(result["stderr"], info=result)
677     return result["stdout"].splitlines()
678 def list_(prefix=None, bin_env=None, user=None, cwd=None, env_vars=None, **kwargs):
679     cwd = _pip_bin_env(cwd, bin_env)
680     packages = {}
681     if prefix is None or "pip".startswith(prefix):
682         packages["pip"] = version(bin_env, cwd)
683     for line in freeze(
684         bin_env=bin_env, user=user, cwd=cwd, env_vars=env_vars, **kwargs
685     ):
686         if line.startswith("-f") or line.startswith("#"):
687             continue
688         elif line.startswith("-e hg+not trust"):
689             continue
690         elif line.startswith("-e"):
691             line = line.split("-e ")[1]
692             if "#egg=" in line:
693                 version_, name = line.split("#egg=")
694             else:
695                 if len(line.split("===")) &gt;= 2:
696                     name = line.split("===")[0]
697                     version_ = line.split("===")[1]
698                 elif len(line.split("==")) &gt;= 2:
699                     name = line.split("==")[0]
700                     version_ = line.split("==")[1]
701         elif len(line.split("===")) &gt;= 2:
702             name = line.split("===")[0]
703             version_ = line.split("===")[1]
704         elif len(line.split("==")) &gt;= 2:
705             name = line.split("==")[0]
706             version_ = line.split("==")[1]
707         else:
708             logger.error("Can't parse line '%s'", line)
709             continue
710         if prefix:
711             if name.lower().startswith(prefix.lower()):
712                 packages[name] = version_
713         else:
714             packages[name] = version_
715     return packages
716 def version(bin_env=None, cwd=None, user=None):
717     cwd = _pip_bin_env(cwd, bin_env)
718     contextkey = "pip.version"
719     if bin_env is not None:
720         contextkey = "{}.{}".format(contextkey, bin_env)
721     if contextkey in __context__:
722         return __context__[contextkey]
723     cmd = _get_pip_bin(bin_env)[:]
724     cmd.append("--version")
725     ret = __salt__["cmd.run_all"](cmd, cwd=cwd, runas=user, python_shell=False)
726     if ret["retcode"]:
727         raise CommandNotFoundError("Could not find a `pip` binary")
728     try:
729         pip_version = re.match(r"^pip (\S+)", ret["stdout"]).group(1)
730     except AttributeError:
731         pip_version = None
732     __context__[contextkey] = pip_version
733     return pip_version
734 def list_upgrades(bin_env=None, user=None, cwd=None):
735     cwd = _pip_bin_env(cwd, bin_env)
736     cmd = _get_pip_bin(bin_env)
737     cmd.extend(["list", "--outdated"])
738     pip_version = version(bin_env, cwd, user=user)
739     min_version = "9.0"
740     if salt.utils.versions.compare(ver1=pip_version, oper="&gt;=", ver2=min_version):
741         cmd.append("--format=json")
742     cmd_kwargs = dict(cwd=cwd, runas=user)
743     if bin_env and os.path.isdir(bin_env):
744         cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
745     result = __salt__["cmd.run_all"](cmd, **cmd_kwargs)
746     if result["retcode"]:
747         raise CommandExecutionError(result["stderr"], info=result)
748     packages = {}
749     if salt.utils.versions.compare(ver1=pip_version, oper="&lt;", ver2="9.0.0"):
750         if salt.utils.versions.compare(ver1=pip_version, oper="&lt;", ver2="8.0.0"):
751             logger.debug("pip module: Old output format")
752             pat = re.compile(r"(\S*)\s+\(.*Latest:\s+(.*)\)")
753         else:
754             logger.debug("pip module: New output format")
755             pat = re.compile(r"(\S*)\s+\(.*\)\s+-\s+Latest:\s+(.*)")
756         for line in result["stdout"].splitlines():
757             match = pat.search(line)
758             if match:
759                 name, version_ = match.groups()
760             else:
761                 logger.error("Can't parse line %r", line)
762                 continue
763             packages[name] = version_
764     else:
765         logger.debug("pip module: JSON output format")
766         try:
767             pkgs = salt.utils.json.loads(result["stdout"], strict=False)
768         except ValueError:
769             raise CommandExecutionError("Invalid JSON", info=result)
770         for pkg in pkgs:
771             packages[pkg["name"]] = "{} [{}]".format(
772                 pkg["latest_version"], pkg["latest_filetype"]
773             )
774     return packages
775 def is_installed(pkgname=None, bin_env=None, user=None, cwd=None):
776     cwd = _pip_bin_env(cwd, bin_env)
777     for line in freeze(bin_env=bin_env, user=user, cwd=cwd):
778         if line.startswith("-f") or line.startswith("#"):
779             continue
780         elif line.startswith("-e hg+not trust"):
781             continue
782         elif line.startswith("-e"):
783             line = line.split("-e ")[1]
784             version_, name = line.split("#egg=")
785         elif len(line.split("===")) &gt;= 2:
786             name = line.split("===")[0]
787             version_ = line.split("===")[1]
788         elif len(line.split("==")) &gt;= 2:
789             name = line.split("==")[0]
790             version_ = line.split("==")[1]
791         else:
792             logger.error("Can't parse line '%s'", line)
793             continue
794         if pkgname:
795             if pkgname == name.lower():
796                 return True
797     return False
798 def upgrade_available(pkg, bin_env=None, user=None, cwd=None):
799     cwd = _pip_bin_env(cwd, bin_env)
800     return pkg in list_upgrades(bin_env=bin_env, user=user, cwd=cwd)
801 def upgrade(bin_env=None, user=None, cwd=None, use_vt=False):
802     cwd = _pip_bin_env(cwd, bin_env)
803     ret = {
804         "changes": {},
805         "result": True,
806         "comment": "",
807     }
808     cmd = _get_pip_bin(bin_env)
809     cmd.extend(["install", "-U"])
810     old = list_(bin_env=bin_env, user=user, cwd=cwd)
811     cmd_kwargs = dict(cwd=cwd, runas=user, use_vt=use_vt)
812     if bin_env and os.path.isdir(bin_env):
813         cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
814     errors = False
815     for pkg in list_upgrades(bin_env=bin_env, user=user, cwd=cwd):
816         if pkg == "salt":
817             if salt.utils.platform.is_windows():
818                 continue
819         result = __salt__["cmd.run_all"](cmd + [pkg], **cmd_kwargs)
820         if result["retcode"] != 0:
821             errors = True
822         if "stderr" in result:
823             ret["comment"] += result["stderr"]
824     if errors:
825         ret["result"] = False
826     _clear_context(bin_env)
827     new = list_(bin_env=bin_env, user=user, cwd=cwd)
828     ret["changes"] = salt.utils.data.compare_dicts(old, new)
829     return ret
830 def list_all_versions(
831     pkg,
832     bin_env=None,
833     include_alpha=False,
834     include_beta=False,
835     include_rc=False,
836     user=None,
837     cwd=None,
838     index_url=None,
839     extra_index_url=None,
840 ):
841     cwd = _pip_bin_env(cwd, bin_env)
842     cmd = _get_pip_bin(bin_env)
843     if index_url:
844         if not salt.utils.url.validate(index_url, VALID_PROTOS):
845             raise CommandExecutionError("'{}' is not a valid URL".format(index_url))
846         cmd.extend(["--index-url", index_url])
847     if extra_index_url:
848         if not salt.utils.url.validate(extra_index_url, VALID_PROTOS):
849             raise CommandExecutionError(
850                 "'{}' is not a valid URL".format(extra_index_url)
851             )
852         cmd.extend(["--extra-index-url", extra_index_url])
853     pip_version = version(bin_env=bin_env, cwd=cwd, user=user)
854     if salt.utils.versions.compare(ver1=pip_version, oper="&gt;=", ver2="21.2"):
855         regex = re.compile(r"\s*Available versions: (.*)")
856         cmd.extend(["index", "versions", pkg])
857     else:
858         if salt.utils.versions.compare(ver1=pip_version, oper="&gt;=", ver2="20.3"):
859             cmd.append("--use-deprecated=legacy-resolver")
860         regex = re.compile(r"\s*Could not find a version.* \(from versions: (.*)\)")
861         cmd.extend(["install", "{}==versions".format(pkg)])
862     cmd_kwargs = dict(
863         cwd=cwd, runas=user, output_loglevel="quiet", redirect_stderr=True
864     )
865     if bin_env and os.path.isdir(bin_env):
866         cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
867     result = __salt__["cmd.run_all"](cmd, **cmd_kwargs)
868     filtered = []
869     if not include_alpha:
870         filtered.append("a")
871     if not include_beta:
872         filtered.append("b")
873     if not include_rc:
874         filtered.append("rc")
875     if filtered:
876         excludes = re.compile(r"^((?!{}).)*$".format("|".join(filtered)))
877     else:
878         excludes = re.compile(r"")
879     versions = []
880     for line in result["stdout"].splitlines():
881         match = regex.search(line)
882         if match:
883             versions = [
884                 v for v in match.group(1).split(", ") if v and excludes.match(v)
885             ]
886             versions.sort(key=pkg_resources.parse_version)
887             break
888     if not versions:
889         return None
890     return versions
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
