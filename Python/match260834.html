<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for batch.py &amp; pip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for batch.py &amp; pip.py
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>batch.py (2.1818182%)<th>pip.py (0.6263048%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-16)<td><a href="#" name="0">(89-100)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>batch.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
import logging
import math
import time
from datetime import datetime, timedelta
import salt.client
import salt.exceptions
import salt.output
import salt.utils.stringutils
log = logging.getLogger(</b></font>__name__)
class Batch:
    def __init__(self, opts, eauth=None, quiet=False, _parser=None):
        self.opts = opts
        self.eauth = eauth if eauth else {}
        self.pub_kwargs = eauth if eauth else {}
        self.quiet = quiet
        self.options = _parser
        self.local = salt.client.get_local_client(opts["conf_file"], listen=True)
    def gather_minions(self):
        args = [
            self.opts["tgt"],
            "test.ping",
            [],
            self.opts["timeout"],
        ]
        selected_target_option = self.opts.get("selected_target_option", None)
        if selected_target_option is not None:
            args.append(selected_target_option)
        else:
            args.append(self.opts.get("tgt_type", "glob"))
        self.pub_kwargs["yield_pub_data"] = True
        ping_gen = self.local.cmd_iter(
            *args, gather_job_timeout=self.opts["gather_job_timeout"], **self.pub_kwargs
        )
        fret = set()
        nret = set()
        for ret in ping_gen:
            if ("minions" and "jid") in ret:
                for minion in ret["minions"]:
                    nret.add(minion)
                continue
            else:
                try:
                    m = next(iter(ret.keys()))
                except StopIteration:
                    if not self.quiet:
                        salt.utils.stringutils.print_cli(
                            "No minions matched the target."
                        )
                    break
                if m is not None:
                    fret.add(m)
        return (list(fret), ping_gen, nret.difference(fret))
    def get_bnum(self):
        partition = lambda x: float(x) / 100.0 * len(self.minions)
        try:
            if isinstance(self.opts["batch"], str) and "%" in self.opts["batch"]:
                res = partition(float(self.opts["batch"].strip("%")))
                if res &lt; 1:
                    return int(math.ceil(res))
                else:
                    return int(res)
            else:
                return int(self.opts["batch"])
        except ValueError:
            if not self.quiet:
                salt.utils.stringutils.print_cli(
                    "Invalid batch data sent: {}\nData must be in the "
                    "form of %10, 10% or 3".format(self.opts["batch"])
                )
    def __update_wait(self, wait):
        now = datetime.now()
        i = 0
        while i &lt; len(wait) and wait[i] &lt;= now:
            i += 1
        if i:
            del wait[:i]
    def run(self):
        self.minions, self.ping_gen, self.down_minions = self.gather_minions()
        args = [
            [],
            self.opts["fun"],
            self.opts["arg"],
            self.opts["timeout"],
            "list",
        ]
        bnum = self.get_bnum()
        if not self.minions:
            return
        to_run = copy.deepcopy(self.minions)
        active = []
        ret = {}
        iters = []
        bwait = self.opts.get("batch_wait", 0)
        wait = []
        if self.options:
            show_jid = self.options.show_jid
            show_verbose = self.options.verbose
        else:
            show_jid = False
            show_verbose = False
        minion_tracker = {}
        if not self.quiet:
            for down_minion in self.down_minions:
                salt.utils.stringutils.print_cli(
                    "Minion {} did not respond. No job will be sent.".format(
                        down_minion
                    )
                )
        while len(ret) &lt; len(self.minions):
            next_ = []
            if bwait and wait:
                self.__update_wait(wait)
            if len(to_run) &lt;= bnum - len(wait) and not active:
                while to_run:
                    next_.append(to_run.pop())
            else:
                for i in range(bnum - len(active) - len(wait)):
                    if to_run:
                        minion_id = to_run.pop()
                        if isinstance(minion_id, dict):
                            next_.append(next(iter(minion_id)))
                        else:
                            next_.append(minion_id)
            active += next_
            args[0] = next_
            if next_:
                if not self.quiet:
                    salt.utils.stringutils.print_cli(
                        "\nExecuting run on {}\n".format(sorted(next_))
                    )
                return_value = self.opts.get("return", self.opts.get("ret", ""))
                new_iter = self.local.cmd_iter_no_block(
                    *args,
                    raw=self.opts.get("raw", False),
                    ret=return_value,
                    show_jid=show_jid,
                    verbose=show_verbose,
                    gather_job_timeout=self.opts["gather_job_timeout"],
                    **self.eauth,
                )
                iters.append(new_iter)
                minion_tracker[new_iter] = {}
                minion_tracker[new_iter]["minions"] = next_
                minion_tracker[new_iter]["active"] = True
            else:
                time.sleep(0.02)
            parts = {}
            for ping_ret in self.ping_gen:
                if ping_ret is None:
                    break
                m = next(iter(ping_ret.keys()))
                if m not in self.minions:
                    self.minions.append(m)
                    to_run.append(m)
            for queue in iters:
                try:
                    ncnt = 0
                    while True:
                        part = next(queue)
                        if part is None:
                            time.sleep(0.01)
                            ncnt += 1
                            if ncnt &gt; 5:
                                break
                            continue
                        if self.opts.get("raw"):
                            parts.update({part["data"]["id"]: part})
                            if part["data"]["id"] in minion_tracker[queue]["minions"]:
                                minion_tracker[queue]["minions"].remove(
                                    part["data"]["id"]
                                )
                            else:
                                salt.utils.stringutils.print_cli(
                                    "minion {} was already deleted from tracker,"
                                    " probably a duplicate key".format(part["id"])
                                )
                        else:
                            parts.update(part)
                            for id in part:
                                if id in minion_tracker[queue]["minions"]:
                                    minion_tracker[queue]["minions"].remove(id)
                                else:
                                    salt.utils.stringutils.print_cli(
                                        "minion {} was already deleted from tracker,"
                                        " probably a duplicate key".format(id)
                                    )
                except StopIteration:
                    if queue in minion_tracker:
                        minion_tracker[queue]["active"] = False
                        for minion in minion_tracker[queue]["minions"]:
                            if minion not in parts:
                                parts[minion] = {}
                                parts[minion]["ret"] = {}
            for minion, data in parts.items():
                if minion in active:
                    active.remove(minion)
                    if bwait:
                        wait.append(datetime.now() + timedelta(seconds=bwait))
                failhard = False
                failed_check = data.get("failed", False)
                if failed_check:
                    log.debug(
                        "Minion '%s' failed to respond to job sent, data '%s'",
                        minion,
                        data,
                    )
                    if not self.quiet:
                        salt.utils.stringutils.print_cli(
                            "Minion '%s' failed to respond to job sent", minion
                        )
                    if self.opts.get("failhard"):
                        failhard = True
                else:
                    retcode = 0
                    if "retcode" in data:
                        if isinstance(data["retcode"], dict):
                            try:
                                data["retcode"] = max(data["retcode"].values())
                            except ValueError:
                                data["retcode"] = 0
                        if self.opts.get("failhard") and data["retcode"] &gt; 0:
                            failhard = True
                        retcode = data["retcode"]
                    if self.opts.get("raw"):
                        ret[minion] = data
                        yield data, retcode
                    else:
                        ret[minion] = data["ret"]
                        yield {minion: data["ret"]}, retcode
                    if not self.quiet:
                        ret[minion] = data["ret"]
                        data[minion] = data.pop("ret")
                        if "out" in data:
                            out = data.pop("out")
                        else:
                            out = None
                        salt.output.display_output(data, out, self.opts)
                if failhard:
                    log.error(
                        "Minion %s returned with non-zero exit code. "
                        "Batch run stopped due to failhard",
                        minion,
                    )
                    return
            for queue in minion_tracker:
                if not minion_tracker[queue]["active"] and queue in iters:
                    iters.remove(queue)
                    for minion in minion_tracker[queue]["minions"]:
                        if minion in active:
                            active.remove(minion)
                            if bwait:
                                wait.append(datetime.now() + timedelta(seconds=bwait))
        self.local.destroy()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
r"""
Install Python packages with pip to either the system or a virtualenv
Windows Support
===============
.. versionadded:: 2014.7.4
Salt now uses a portable python. As a result the entire pip module is now
functional on the salt installation itself. You can pip install dependencies
for your custom modules. You can even upgrade salt itself using pip. For this
to work properly, you must specify the Current Working Directory (``cwd``) and
the Pip Binary (``bin_env``) salt should use.  The variable ``pip_bin`` can be
either a virtualenv path or the path to the pip binary itself.
For example, the following command will list all software installed using pip
to your current salt environment:
.. code-block:: bat
   salt &lt;minion&gt; pip.list cwd='C:\salt\bin\Scripts' bin_env='C:\salt\bin\Scripts\pip.exe'
Specifying the ``cwd`` and ``bin_env`` options ensures you're modifying the
salt environment. If these are omitted, it will default to the local
installation of python. If python is not installed locally it will fail saying
it couldn't find pip.
State File Support
------------------
This functionality works in states as well. If you need to pip install colorama
with a state, for example, the following will work:
.. code-block:: yaml
   install_colorama:
     pip.installed:
       - name: colorama
       - cwd: 'C:\salt\bin\scripts'
       - bin_env: 'C:\salt\bin\scripts\pip.exe'
       - upgrade: True
Upgrading Salt using Pip
------------------------
You can now update salt using pip to any version from the 2014.7 branch
forward. Previous version require recompiling some of the dependencies which is
painful in windows.
To do this you just use pip with git to update to the version you want and then
restart the service. Here is a sample state file that upgrades salt to the head
of the 2015.5 branch:
.. code-block:: yaml
   install_salt:
     pip.installed:
       - cwd: 'C:\salt\bin\scripts'
       - bin_env: 'C:\salt\bin\scripts\pip.exe'
       - editable: git+https://github.com/saltstack/salt@2015.5#egg=salt
       - upgrade: True
   restart_service:
     service.running:
       - name: salt-minion
       - enable: True
       - watch:
         - pip: install_salt
.. note::
   If you're having problems, you might try doubling the back slashes. For
   example, cwd: 'C:\\salt\\bin\\scripts'. Sometimes python thinks the single
   back slash is an escape character.
   There is a known incompatibility between Python2 pip&gt;=10.* and Salt &lt;=2018.3.0.
   The issue is described here: https://github.com/saltstack/salt/issues/46163
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.data
import salt.utils.files
import salt.utils.json
import salt.utils.locales
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.url
import salt.utils.versions
from salt.exceptions import CommandExecutionError, CommandNotFoundError
logger = logging.getLogger(</b></font>__name__)  # pylint: disable=invalid-name
__func_alias__ = {"list_": "list"}
VALID_PROTOS = ["http", "https", "ftp", "file"]
rex_pip_chain_read = re.compile(r"(?:-r\s|--requirement[=\s])(.*)\n?", re.MULTILINE)
rex_pip_reqs_comment = re.compile(r"(?:^|\s+)#.*$", re.MULTILINE)
def __virtual__():
    return "pip"
def _pip_bin_env(cwd, bin_env):
    if salt.utils.platform.is_windows():
        if bin_env is not None and cwd is None and "pip" in os.path.basename(bin_env):
            cwd = os.path.dirname(bin_env)
    return cwd
def _clear_context(bin_env=None):
    contextkey = "pip.version"
    if bin_env is not None:
        contextkey = "{}.{}".format(contextkey, bin_env)
    __context__.pop(contextkey, None)
def _check_bundled():
    if getattr(sys, "frozen", False) and hasattr(sys, "_MEIPASS"):
        return True
    return False
def _get_pip_bin(bin_env):
    bundled = _check_bundled()
    if not bin_env:
        if bundled:
            logger.debug("pip: Using pip from bundled app")
            return [os.path.normpath(sys.executable), "pip"]
        else:
            logger.debug("pip: Using pip from currently-running Python")
            return [os.path.normpath(sys.executable), "-m", "pip"]
    python_bin = "python.exe" if salt.utils.platform.is_windows() else "python"
    def _search_paths(*basedirs):
        ret = []
        for path in basedirs:
            ret.extend(
                [
                    os.path.join(path, python_bin),
                    os.path.join(path, "bin", python_bin),
                    os.path.join(path, "Scripts", python_bin),
                ]
            )
        return ret
    if os.path.isdir(bin_env):
        for bin_path in _search_paths(bin_env):
            if os.path.isfile(bin_path):
                if os.access(bin_path, os.X_OK):
                    logger.debug("pip: Found python binary: %s", bin_path)
                    return [os.path.normpath(bin_path), "-m", "pip"]
                else:
                    logger.debug(
                        "pip: Found python binary by name but it is not executable: %s",
                        bin_path,
                    )
        raise CommandNotFoundError(
            "Could not find a pip binary in virtualenv {}".format(bin_env)
        )
    elif os.access(bin_env, os.X_OK):
        if os.path.isfile(bin_env):
            if "python" in os.path.basename(bin_env):
                return [os.path.normpath(bin_env), "-m", "pip"]
            return [os.path.normpath(bin_env)]
        raise CommandExecutionError(
            "Could not find a pip binary within {}".format(bin_env)
        )
    else:
        raise CommandNotFoundError(
            "Access denied to {}, could not find a pip binary".format(bin_env)
        )
def _get_cached_requirements(requirements, saltenv):
    req_file, senv = salt.utils.url.parse(requirements)
    if senv:
        saltenv = senv
    if req_file not in __salt__["cp.list_master"](saltenv):
        return False
    cached_requirements = __salt__["cp.is_cached"](requirements, saltenv)
    if not cached_requirements:
        cached_requirements = __salt__["cp.cache_file"](requirements, saltenv)
    if __salt__["cp.hash_file"](requirements, saltenv) != __salt__["cp.hash_file"](
        cached_requirements, saltenv
    ):
        cached_requirements = __salt__["cp.cache_file"](requirements, saltenv)
    return cached_requirements
def _get_env_activate(bin_env):
    if not bin_env:
        raise CommandNotFoundError("Could not find a `activate` binary")
    if os.path.isdir(bin_env):
        if salt.utils.platform.is_windows():
            activate_bin = os.path.join(bin_env, "Scripts", "activate.bat")
        else:
            activate_bin = os.path.join(bin_env, "bin", "activate")
        if os.path.isfile(activate_bin):
            return activate_bin
    raise CommandNotFoundError("Could not find a `activate` binary")
def _find_req(link):
    logger.info("_find_req -- link = %s", link)
    with salt.utils.files.fopen(link) as fh_link:
        reqs_content = salt.utils.stringutils.to_unicode(fh_link.read())
    reqs_content = rex_pip_reqs_comment.sub("", reqs_content)  # remove comments
    child_links = rex_pip_chain_read.findall(reqs_content)
    base_path = os.path.dirname(link)
    child_links = [os.path.join(base_path, d) for d in child_links]
    return child_links
def _resolve_requirements_chain(requirements):
    chain = []
    if isinstance(requirements, str):
        requirements = [requirements]
    for req_file in requirements:
        chain.append(req_file)
        chain.extend(_resolve_requirements_chain(_find_req(req_file)))
    return chain
def _process_requirements(requirements, cmd, cwd, saltenv, user):
    cleanup_requirements = []
    if requirements is not None:
        if isinstance(requirements, str):
            requirements = [r.strip() for r in requirements.split(",")]
        elif not isinstance(requirements, list):
            raise TypeError("requirements must be a string or list")
        treq = None
        for requirement in requirements:
            logger.debug("TREQ IS: %s", treq)
            if requirement.startswith("salt://"):
                cached_requirements = _get_cached_requirements(requirement, saltenv)
                if not cached_requirements:
                    ret = {
                        "result": False,
                        "comment": "pip requirements file '{}' not found".format(
                            requirement
                        ),
                    }
                    return None, ret
                requirement = cached_requirements
            if user:
                if not treq:
                    treq = tempfile.mkdtemp()
                __salt__["file.chown"](treq, user, None)
                if salt.utils.platform.is_windows():
                    __utils__["dacl.set_permissions"](
                        obj_name=treq, principal=user, permissions="read_execute"
                    )
                current_directory = None
                if not current_directory:
                    current_directory = os.path.abspath(os.curdir)
                logger.info(
                    "_process_requirements from directory, %s -- requirement: %s",
                    cwd,
                    requirement,
                )
                if cwd is None:
                    r = requirement
                    c = cwd
                    requirement_abspath = os.path.abspath(requirement)
                    cwd = os.path.dirname(requirement_abspath)
                    requirement = os.path.basename(requirement)
                    logger.debug(
                        "\n\tcwd: %s -&gt; %s\n\trequirement: %s -&gt; %s\n",
                        c,
                        cwd,
                        r,
                        requirement,
                    )
                os.chdir(cwd)
                reqs = _resolve_requirements_chain(requirement)
                os.chdir(current_directory)
                logger.info("request files: %s", reqs)
                for req_file in reqs:
                    if not os.path.isabs(req_file):
                        req_file = os.path.join(cwd, req_file)
                    logger.debug("TREQ N CWD: %s -- %s -- for %s", treq, cwd, req_file)
                    target_path = os.path.join(treq, os.path.basename(req_file))
                    logger.debug("S: %s", req_file)
                    logger.debug("T: %s", target_path)
                    target_base = os.path.dirname(target_path)
                    if not os.path.exists(target_base):
                        os.makedirs(target_base, mode=0o755)
                        __salt__["file.chown"](target_base, user, None)
                    if not os.path.exists(target_path):
                        logger.debug("Copying %s to %s", req_file, target_path)
                        __salt__["file.copy"](req_file, target_path)
                    logger.debug(
                        "Changing ownership of requirements file '%s' to user '%s'",
                        target_path,
                        user,
                    )
                    __salt__["file.chown"](target_path, user, None)
            req_args = os.path.join(treq, requirement) if treq else requirement
            cmd.extend(["--requirement", req_args])
        cleanup_requirements.append(treq)
    logger.debug("CLEANUP_REQUIREMENTS: %s", cleanup_requirements)
    return cleanup_requirements, None
def _format_env_vars(env_vars):
    ret = {}
    if env_vars:
        if isinstance(env_vars, dict):
            for key, val in env_vars.items():
                if not isinstance(key, str):
                    key = str(key)
                if not isinstance(val, str):
                    val = str(val)
                ret[key] = val
        else:
            raise CommandExecutionError(
                "env_vars {} is not a dictionary".format(env_vars)
            )
    return ret
def install(
    pkgs=None,  # pylint: disable=R0912,R0913,R0914
    requirements=None,
    bin_env=None,
    use_wheel=False,
    no_use_wheel=False,
    log=None,
    proxy=None,
    timeout=None,
    editable=None,
    find_links=None,
    index_url=None,
    extra_index_url=None,
    no_index=False,
    mirrors=None,
    build=None,
    target=None,
    download=None,
    download_cache=None,
    source=None,
    upgrade=False,
    force_reinstall=False,
    ignore_installed=False,
    exists_action=None,
    no_deps=False,
    no_install=False,
    no_download=False,
    global_options=None,
    install_options=None,
    user=None,
    cwd=None,
    pre_releases=False,
    cert=None,
    allow_all_external=False,
    allow_external=None,
    allow_unverified=None,
    process_dependency_links=False,
    saltenv="base",
    env_vars=None,
    use_vt=False,
    trusted_host=None,
    no_cache_dir=False,
    extra_args=None,
    cache_dir=None,
    no_binary=None,
    disable_version_check=False,
    **kwargs
):
    cwd = _pip_bin_env(cwd, bin_env)
    cmd = _get_pip_bin(bin_env)
    cmd.append("install")
    cleanup_requirements, error = _process_requirements(
        requirements=requirements, cmd=cmd, cwd=cwd, saltenv=saltenv, user=user
    )
    if error:
        return error
    cur_version = version(bin_env, cwd, user=user)
    if use_wheel:
        min_version = "1.4"
        max_version = "9.0.3"
        too_low = salt.utils.versions.compare(
            ver1=cur_version, oper="&lt;", ver2=min_version
        )
        too_high = salt.utils.versions.compare(
            ver1=cur_version, oper="&gt;", ver2=max_version
        )
        if too_low or too_high:
            logger.error(
                "The --use-wheel option is only supported in pip between %s and "
                "%s. The version of pip detected is %s. This option "
                "will be ignored.",
                min_version,
                max_version,
                cur_version,
            )
        else:
            cmd.append("--use-wheel")
    if no_use_wheel:
        min_version = "1.4"
        max_version = "9.0.3"
        too_low = salt.utils.versions.compare(
            ver1=cur_version, oper="&lt;", ver2=min_version
        )
        too_high = salt.utils.versions.compare(
            ver1=cur_version, oper="&gt;", ver2=max_version
        )
        if too_low or too_high:
            logger.error(
                "The --no-use-wheel option is only supported in pip between %s and "
                "%s. The version of pip detected is %s. This option "
                "will be ignored.",
                min_version,
                max_version,
                cur_version,
            )
        else:
            cmd.append("--no-use-wheel")
    if no_binary:
        min_version = "7.0.0"
        too_low = salt.utils.versions.compare(
            ver1=cur_version, oper="&lt;", ver2=min_version
        )
        if too_low:
            logger.error(
                "The --no-binary option is only supported in pip %s and "
                "newer. The version of pip detected is %s. This option "
                "will be ignored.",
                min_version,
                cur_version,
            )
        else:
            if isinstance(no_binary, list):
                no_binary = ",".join(no_binary)
            cmd.extend(["--no-binary", no_binary])
    if log:
        if os.path.isdir(log):
            raise OSError("'{}' is a directory. Use --log path_to_file".format(log))
        elif not os.access(log, os.W_OK):
            raise OSError("'{}' is not writeable".format(log))
        cmd.extend(["--log", log])
    config = __opts__
    if proxy:
        cmd.extend(["--proxy", proxy])
    elif proxy is not False and config.get("proxy_host") and config.get("proxy_port"):
        if config.get("proxy_username") and config.get("proxy_password"):
            http_proxy_url = "http://{proxy_username}:{proxy_password}@{proxy_host}:{proxy_port}".format(
                **config
            )
        else:
            http_proxy_url = "http://{proxy_host}:{proxy_port}".format(**config)
        cmd.extend(["--proxy", http_proxy_url])
    if timeout:
        try:
            if isinstance(timeout, float):
                raise ValueError("Timeout cannot be a float")
            int(timeout)
        except ValueError:
            raise ValueError(
                "'{}' is not a valid timeout, must be an integer".format(timeout)
            )
        cmd.extend(["--timeout", timeout])
    if find_links:
        if isinstance(find_links, str):
            find_links = [l.strip() for l in find_links.split(",")]
        for link in find_links:
            if not (
                salt.utils.url.validate(link, VALID_PROTOS) or os.path.exists(link)
            ):
                raise CommandExecutionError(
                    "'{}' is not a valid URL or path".format(link)
                )
            cmd.extend(["--find-links", link])
    if no_index and (index_url or extra_index_url):
        raise CommandExecutionError(
            "'no_index' and ('index_url' or 'extra_index_url') are mutually exclusive."
        )
    if index_url:
        if not salt.utils.url.validate(index_url, VALID_PROTOS):
            raise CommandExecutionError("'{}' is not a valid URL".format(index_url))
        cmd.extend(["--index-url", index_url])
    if extra_index_url:
        if not salt.utils.url.validate(extra_index_url, VALID_PROTOS):
            raise CommandExecutionError(
                "'{}' is not a valid URL".format(extra_index_url)
            )
        cmd.extend(["--extra-index-url", extra_index_url])
    if no_index:
        cmd.append("--no-index")
    if mirrors:
        if salt.utils.versions.compare(ver1=cur_version, oper="&gt;=", ver2="7.0.0"):
            raise CommandExecutionError(
                "pip &gt;= 7.0.0 does not support mirror argument:"
                " use index_url and/or extra_index_url instead"
            )
        if isinstance(mirrors, str):
            mirrors = [m.strip() for m in mirrors.split(",")]
        cmd.append("--use-mirrors")
        for mirror in mirrors:
            if not mirror.startswith("http://"):
                raise CommandExecutionError("'{}' is not a valid URL".format(mirror))
            cmd.extend(["--mirrors", mirror])
    if disable_version_check:
        cmd.extend(["--disable-pip-version-check"])
    if build:
        cmd.extend(["--build", build])
    if target:
        cmd.extend(["--target", target])
    if download:
        cmd.extend(["--download", download])
    if download_cache or cache_dir:
        cmd.extend(
            [
                "--cache-dir"
                if salt.utils.versions.compare(ver1=cur_version, oper="&gt;=", ver2="6.0")
                else "--download-cache",
                download_cache or cache_dir,
            ]
        )
    if source:
        cmd.extend(["--source", source])
    if upgrade:
        cmd.append("--upgrade")
    if force_reinstall:
        cmd.append("--force-reinstall")
    if ignore_installed:
        cmd.append("--ignore-installed")
    if exists_action:
        if exists_action.lower() not in ("s", "i", "w", "b"):
            raise CommandExecutionError(
                "The exists_action pip option only supports the values "
                "s, i, w, and b. '{}' is not valid.".format(exists_action)
            )
        cmd.extend(["--exists-action", exists_action])
    if no_deps:
        cmd.append("--no-deps")
    if no_install:
        cmd.append("--no-install")
    if no_download:
        cmd.append("--no-download")
    if no_cache_dir:
        cmd.append("--no-cache-dir")
    if pre_releases:
        pip_version = cur_version
        if salt.utils.versions.compare(ver1=pip_version, oper="&gt;=", ver2="1.4"):
            cmd.append("--pre")
    if cert:
        cmd.extend(["--cert", cert])
    if global_options:
        if isinstance(global_options, str):
            global_options = [go.strip() for go in global_options.split(",")]
        for opt in global_options:
            cmd.extend(["--global-option", opt])
    if install_options:
        if isinstance(install_options, str):
            install_options = [io.strip() for io in install_options.split(",")]
        for opt in install_options:
            cmd.extend(["--install-option", opt])
    if pkgs:
        if not isinstance(pkgs, list):
            try:
                pkgs = [p.strip() for p in pkgs.split(",")]
            except AttributeError:
                pkgs = [p.strip() for p in str(pkgs).split(",")]
        pkgs = salt.utils.data.stringify(salt.utils.data.decode_list(pkgs))
        cmd.extend([p.replace(";", ",") for p in pkgs])
    elif not any([requirements, editable]):
        return {"retcode": 0, "stdout": "No packages to install."}
    if editable:
        egg_match = re.compile(r"(?:#|#.*?&amp;)egg=([^&amp;]*)")
        if isinstance(editable, str):
            editable = [e.strip() for e in editable.split(",")]
        for entry in editable:
            if not (entry == "." or entry.startswith(("file://", "/"))):
                match = egg_match.search(entry)
                if not match or not match.group(1):
                    raise CommandExecutionError(
                        "You must specify an egg for this editable"
                    )
            cmd.extend(["--editable", entry])
    if allow_all_external:
        cmd.append("--allow-all-external")
    if allow_external:
        if isinstance(allow_external, str):
            allow_external = [p.strip() for p in allow_external.split(",")]
        for pkg in allow_external:
            cmd.extend(["--allow-external", pkg])
    if allow_unverified:
        if isinstance(allow_unverified, str):
            allow_unverified = [p.strip() for p in allow_unverified.split(",")]
        for pkg in allow_unverified:
            cmd.extend(["--allow-unverified", pkg])
    if process_dependency_links:
        cmd.append("--process-dependency-links")
    if trusted_host:
        cmd.extend(["--trusted-host", trusted_host])
    if extra_args:
        for arg in extra_args:
            if isinstance(arg, dict):
                key, val = arg.popitem()
                if isinstance(val, (dict, list)):
                    raise TypeError("Too many levels in: {}".format(key))
                cmd.extend([key, val])
            else:
                cmd.append(arg)
    cmd_kwargs = dict(saltenv=saltenv, use_vt=use_vt, runas=user)
    if kwargs:
        cmd_kwargs.update(kwargs)
    if env_vars:
        cmd_kwargs.setdefault("env", {}).update(_format_env_vars(env_vars))
    try:
        if cwd:
            cmd_kwargs["cwd"] = cwd
        if bin_env and os.path.isdir(bin_env):
            cmd_kwargs.setdefault("env", {})["VIRTUAL_ENV"] = bin_env
        logger.debug(
            "TRY BLOCK: end of pip.install -- cmd: %s, cmd_kwargs: %s", cmd, cmd_kwargs
        )
        return __salt__["cmd.run_all"](cmd, python_shell=False, **cmd_kwargs)
    finally:
        _clear_context(bin_env)
        for tempdir in [cr for cr in cleanup_requirements if cr is not None]:
            if os.path.isdir(tempdir):
                shutil.rmtree(tempdir)
def uninstall(
    pkgs=None,
    requirements=None,
    bin_env=None,
    log=None,
    proxy=None,
    timeout=None,
    user=None,
    cwd=None,
    saltenv="base",
    use_vt=False,
):
    cwd = _pip_bin_env(cwd, bin_env)
    cmd = _get_pip_bin(bin_env)
    cmd.extend(["uninstall", "-y"])
    cleanup_requirements, error = _process_requirements(
        requirements=requirements, cmd=cmd, saltenv=saltenv, user=user, cwd=cwd
    )
    if error:
        return error
    if log:
        try:
            os.path.exists(log)
        except OSError:
            raise OSError("'{}' is not writeable".format(log))
        cmd.extend(["--log", log])
    config = __opts__
    if proxy:
        cmd.extend(["--proxy", proxy])
    elif proxy is not False and config.get("proxy_host") and config.get("proxy_port"):
        if config.get("proxy_username") and config.get("proxy_password"):
            http_proxy_url = "http://{proxy_username}:{proxy_password}@{proxy_host}:{proxy_port}".format(
                **config
            )
        else:
            http_proxy_url = "http://{proxy_host}:{proxy_port}".format(**config)
        cmd.extend(["--proxy", http_proxy_url])
    if timeout:
        try:
            if isinstance(timeout, float):
                raise ValueError("Timeout cannot be a float")
            int(timeout)
        except ValueError:
            raise ValueError(
                "'{}' is not a valid timeout, must be an integer".format(timeout)
            )
        cmd.extend(["--timeout", timeout])
    if pkgs:
        if isinstance(pkgs, str):
            pkgs = [p.strip() for p in pkgs.split(",")]
        if requirements:
            for requirement in requirements:
                with salt.utils.files.fopen(requirement) as rq_:
                    for req in rq_:
                        req = salt.utils.stringutils.to_unicode(req)
                        try:
                            req_pkg, _ = req.split("==")
                            if req_pkg in pkgs:
                                pkgs.remove(req_pkg)
                        except ValueError:
                            pass
        cmd.extend(pkgs)
    cmd_kwargs = dict(
        python_shell=False, runas=user, cwd=cwd, saltenv=saltenv, use_vt=use_vt
    )
    if bin_env and os.path.isdir(bin_env):
        cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
    try:
        return __salt__["cmd.run_all"](cmd, **cmd_kwargs)
    finally:
        _clear_context(bin_env)
        for requirement in cleanup_requirements:
            if requirement:
                try:
                    os.remove(requirement)
                except OSError:
                    pass
def freeze(bin_env=None, user=None, cwd=None, use_vt=False, env_vars=None, **kwargs):
    cwd = _pip_bin_env(cwd, bin_env)
    cmd = _get_pip_bin(bin_env)
    cmd.append("freeze")
    min_version = "8.0.3"
    cur_version = version(bin_env, cwd)
    if salt.utils.versions.compare(ver1=cur_version, oper="&lt;", ver2=min_version):
        logger.warning(
            "The version of pip installed is %s, which is older than %s. "
            "The packages pip, wheel, setuptools, and distribute will not be "
            "included in the output of pip.freeze",
            cur_version,
            min_version,
        )
    else:
        cmd.append("--all")
    cmd_kwargs = dict(runas=user, cwd=cwd, use_vt=use_vt, python_shell=False)
    if kwargs:
        cmd_kwargs.update(**kwargs)
    if bin_env and os.path.isdir(bin_env):
        cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
    if env_vars:
        cmd_kwargs.setdefault("env", {}).update(_format_env_vars(env_vars))
    result = __salt__["cmd.run_all"](cmd, **cmd_kwargs)
    if result["retcode"]:
        raise CommandExecutionError(result["stderr"], info=result)
    return result["stdout"].splitlines()
def list_(prefix=None, bin_env=None, user=None, cwd=None, env_vars=None, **kwargs):
    cwd = _pip_bin_env(cwd, bin_env)
    packages = {}
    if prefix is None or "pip".startswith(prefix):
        packages["pip"] = version(bin_env, cwd)
    for line in freeze(
        bin_env=bin_env, user=user, cwd=cwd, env_vars=env_vars, **kwargs
    ):
        if line.startswith("-f") or line.startswith("#"):
            continue
        elif line.startswith("-e hg+not trust"):
            continue
        elif line.startswith("-e"):
            line = line.split("-e ")[1]
            if "#egg=" in line:
                version_, name = line.split("#egg=")
            else:
                if len(line.split("===")) &gt;= 2:
                    name = line.split("===")[0]
                    version_ = line.split("===")[1]
                elif len(line.split("==")) &gt;= 2:
                    name = line.split("==")[0]
                    version_ = line.split("==")[1]
        elif len(line.split("===")) &gt;= 2:
            name = line.split("===")[0]
            version_ = line.split("===")[1]
        elif len(line.split("==")) &gt;= 2:
            name = line.split("==")[0]
            version_ = line.split("==")[1]
        else:
            logger.error("Can't parse line '%s'", line)
            continue
        if prefix:
            if name.lower().startswith(prefix.lower()):
                packages[name] = version_
        else:
            packages[name] = version_
    return packages
def version(bin_env=None, cwd=None, user=None):
    cwd = _pip_bin_env(cwd, bin_env)
    contextkey = "pip.version"
    if bin_env is not None:
        contextkey = "{}.{}".format(contextkey, bin_env)
    if contextkey in __context__:
        return __context__[contextkey]
    cmd = _get_pip_bin(bin_env)[:]
    cmd.append("--version")
    ret = __salt__["cmd.run_all"](cmd, cwd=cwd, runas=user, python_shell=False)
    if ret["retcode"]:
        raise CommandNotFoundError("Could not find a `pip` binary")
    try:
        pip_version = re.match(r"^pip (\S+)", ret["stdout"]).group(1)
    except AttributeError:
        pip_version = None
    __context__[contextkey] = pip_version
    return pip_version
def list_upgrades(bin_env=None, user=None, cwd=None):
    cwd = _pip_bin_env(cwd, bin_env)
    cmd = _get_pip_bin(bin_env)
    cmd.extend(["list", "--outdated"])
    pip_version = version(bin_env, cwd, user=user)
    min_version = "9.0"
    if salt.utils.versions.compare(ver1=pip_version, oper="&gt;=", ver2=min_version):
        cmd.append("--format=json")
    cmd_kwargs = dict(cwd=cwd, runas=user)
    if bin_env and os.path.isdir(bin_env):
        cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
    result = __salt__["cmd.run_all"](cmd, **cmd_kwargs)
    if result["retcode"]:
        raise CommandExecutionError(result["stderr"], info=result)
    packages = {}
    if salt.utils.versions.compare(ver1=pip_version, oper="&lt;", ver2="9.0.0"):
        if salt.utils.versions.compare(ver1=pip_version, oper="&lt;", ver2="8.0.0"):
            logger.debug("pip module: Old output format")
            pat = re.compile(r"(\S*)\s+\(.*Latest:\s+(.*)\)")
        else:
            logger.debug("pip module: New output format")
            pat = re.compile(r"(\S*)\s+\(.*\)\s+-\s+Latest:\s+(.*)")
        for line in result["stdout"].splitlines():
            match = pat.search(line)
            if match:
                name, version_ = match.groups()
            else:
                logger.error("Can't parse line %r", line)
                continue
            packages[name] = version_
    else:
        logger.debug("pip module: JSON output format")
        try:
            pkgs = salt.utils.json.loads(result["stdout"], strict=False)
        except ValueError:
            raise CommandExecutionError("Invalid JSON", info=result)
        for pkg in pkgs:
            packages[pkg["name"]] = "{} [{}]".format(
                pkg["latest_version"], pkg["latest_filetype"]
            )
    return packages
def is_installed(pkgname=None, bin_env=None, user=None, cwd=None):
    cwd = _pip_bin_env(cwd, bin_env)
    for line in freeze(bin_env=bin_env, user=user, cwd=cwd):
        if line.startswith("-f") or line.startswith("#"):
            continue
        elif line.startswith("-e hg+not trust"):
            continue
        elif line.startswith("-e"):
            line = line.split("-e ")[1]
            version_, name = line.split("#egg=")
        elif len(line.split("===")) &gt;= 2:
            name = line.split("===")[0]
            version_ = line.split("===")[1]
        elif len(line.split("==")) &gt;= 2:
            name = line.split("==")[0]
            version_ = line.split("==")[1]
        else:
            logger.error("Can't parse line '%s'", line)
            continue
        if pkgname:
            if pkgname == name.lower():
                return True
    return False
def upgrade_available(pkg, bin_env=None, user=None, cwd=None):
    cwd = _pip_bin_env(cwd, bin_env)
    return pkg in list_upgrades(bin_env=bin_env, user=user, cwd=cwd)
def upgrade(bin_env=None, user=None, cwd=None, use_vt=False):
    cwd = _pip_bin_env(cwd, bin_env)
    ret = {
        "changes": {},
        "result": True,
        "comment": "",
    }
    cmd = _get_pip_bin(bin_env)
    cmd.extend(["install", "-U"])
    old = list_(bin_env=bin_env, user=user, cwd=cwd)
    cmd_kwargs = dict(cwd=cwd, runas=user, use_vt=use_vt)
    if bin_env and os.path.isdir(bin_env):
        cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
    errors = False
    for pkg in list_upgrades(bin_env=bin_env, user=user, cwd=cwd):
        if pkg == "salt":
            if salt.utils.platform.is_windows():
                continue
        result = __salt__["cmd.run_all"](cmd + [pkg], **cmd_kwargs)
        if result["retcode"] != 0:
            errors = True
        if "stderr" in result:
            ret["comment"] += result["stderr"]
    if errors:
        ret["result"] = False
    _clear_context(bin_env)
    new = list_(bin_env=bin_env, user=user, cwd=cwd)
    ret["changes"] = salt.utils.data.compare_dicts(old, new)
    return ret
def list_all_versions(
    pkg,
    bin_env=None,
    include_alpha=False,
    include_beta=False,
    include_rc=False,
    user=None,
    cwd=None,
    index_url=None,
    extra_index_url=None,
):
    cwd = _pip_bin_env(cwd, bin_env)
    cmd = _get_pip_bin(bin_env)
    if index_url:
        if not salt.utils.url.validate(index_url, VALID_PROTOS):
            raise CommandExecutionError("'{}' is not a valid URL".format(index_url))
        cmd.extend(["--index-url", index_url])
    if extra_index_url:
        if not salt.utils.url.validate(extra_index_url, VALID_PROTOS):
            raise CommandExecutionError(
                "'{}' is not a valid URL".format(extra_index_url)
            )
        cmd.extend(["--extra-index-url", extra_index_url])
    pip_version = version(bin_env=bin_env, cwd=cwd, user=user)
    if salt.utils.versions.compare(ver1=pip_version, oper="&gt;=", ver2="21.2"):
        regex = re.compile(r"\s*Available versions: (.*)")
        cmd.extend(["index", "versions", pkg])
    else:
        if salt.utils.versions.compare(ver1=pip_version, oper="&gt;=", ver2="20.3"):
            cmd.append("--use-deprecated=legacy-resolver")
        regex = re.compile(r"\s*Could not find a version.* \(from versions: (.*)\)")
        cmd.extend(["install", "{}==versions".format(pkg)])
    cmd_kwargs = dict(
        cwd=cwd, runas=user, output_loglevel="quiet", redirect_stderr=True
    )
    if bin_env and os.path.isdir(bin_env):
        cmd_kwargs["env"] = {"VIRTUAL_ENV": bin_env}
    result = __salt__["cmd.run_all"](cmd, **cmd_kwargs)
    filtered = []
    if not include_alpha:
        filtered.append("a")
    if not include_beta:
        filtered.append("b")
    if not include_rc:
        filtered.append("rc")
    if filtered:
        excludes = re.compile(r"^((?!{}).)*$".format("|".join(filtered)))
    else:
        excludes = re.compile(r"")
    versions = []
    for line in result["stdout"].splitlines():
        match = regex.search(line)
        if match:
            versions = [
                v for v in match.group(1).split(", ") if v and excludes.match(v)
            ]
            versions.sort(key=pkg_resources.parse_version)
            break
    if not versions:
        return None
    return versions
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
