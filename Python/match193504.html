<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for sysmod.py & test_saltnado.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for sysmod.py & test_saltnado.py
      </h3>
      <h1 align="center">
        1.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>sysmod.py (2.7874565%)<TH>test_saltnado.py (1.2624934%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match193504-0.html#0',2,'match193504-1.html#0',3)" NAME="0">(851-853)<TD><A HREF="javascript:ZweiFrames('match193504-0.html#0',2,'match193504-1.html#0',3)" NAME="0">(621-625)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match193504-0.html#1',2,'match193504-1.html#1',3)" NAME="1">(839-841)<TD><A HREF="javascript:ZweiFrames('match193504-0.html#1',2,'match193504-1.html#1',3)" NAME="1">(401-404)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>sysmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
The sys module provides information about the available functions on the minion
&quot;&quot;&quot;

import fnmatch
import logging

import salt.loader
import salt.runner
import salt.state
import salt.utils.args
import salt.utils.doc
import salt.utils.schema

log = logging.getLogger(__name__)

# Define the module's virtual name
__virtualname__ = &quot;sys&quot;

__proxyenabled__ = [&quot;*&quot;]


def __virtual__():
    &quot;&quot;&quot;
    Return as sys
    &quot;&quot;&quot;
    return __virtualname__


def doc(*args):
    &quot;&quot;&quot;
    Return the docstrings for all modules. Optionally, specify a module or a
    function to narrow the selection.

    The strings are aggregated into a single document on the master for easy
    reading.

    Multiple modules/functions can be specified.

    CLI Example:

    .. code-block:: bash

        salt '*' sys.doc
        salt '*' sys.doc sys
        salt '*' sys.doc sys.doc
        salt '*' sys.doc network.traceroute user.info

    Modules can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.doc 'sys.*'
        salt '*' sys.doc 'sys.list_*'
    &quot;&quot;&quot;
    docs = {}
    if not args:
        for fun in __salt__:
            docs[fun] = __salt__[fun].__doc__
        return salt.utils.doc.strip_rst(docs)

    for module in args:
        _use_fnmatch = False
        if &quot;*&quot; in module:
            target_mod = module
            _use_fnmatch = True
        elif module:
            # allow both &quot;sys&quot; and &quot;sys.&quot; to match sys, without also matching
            # sysctl
            target_mod = module + &quot;.&quot; if not module.endswith(&quot;.&quot;) else module
        else:
            target_mod = &quot;&quot;
        if _use_fnmatch:
            for fun in fnmatch.filter(__salt__, target_mod):
                docs[fun] = __salt__[fun].__doc__
        else:

            for fun in __salt__:
                if fun == module or fun.startswith(target_mod):
                    docs[fun] = __salt__[fun].__doc__
    return salt.utils.doc.strip_rst(docs)


def state_doc(*args):
    &quot;&quot;&quot;
    Return the docstrings for all states. Optionally, specify a state or a
    function to narrow the selection.

    The strings are aggregated into a single document on the master for easy
    reading.

    Multiple states/functions can be specified.

    .. versionadded:: 2014.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.state_doc
        salt '*' sys.state_doc service
        salt '*' sys.state_doc service.running
        salt '*' sys.state_doc service.running ipables.append

    State names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.state_doc 'service.*' 'iptables.*'

    &quot;&quot;&quot;
    st_ = salt.state.State(__opts__)

    docs = {}
    if not args:
        for fun in st_.states:
            state = fun.split(&quot;.&quot;)[0]
            if state not in docs:
                if hasattr(st_.states[fun], &quot;__globals__&quot;):
                    docs[state] = st_.states[fun].__globals__[&quot;__doc__&quot;]
            docs[fun] = st_.states[fun].__doc__
        return salt.utils.doc.strip_rst(docs)

    for module in args:
        _use_fnmatch = False
        if &quot;*&quot; in module:
            target_mod = module
            _use_fnmatch = True
        elif module:
            # allow both &quot;sys&quot; and &quot;sys.&quot; to match sys, without also matching
            # sysctl
            target_mod = module + &quot;.&quot; if not module.endswith(&quot;.&quot;) else module
        else:
            target_mod = &quot;&quot;
        if _use_fnmatch:
            for fun in fnmatch.filter(st_.states, target_mod):
                state = fun.split(&quot;.&quot;)[0]
                if hasattr(st_.states[fun], &quot;__globals__&quot;):
                    docs[state] = st_.states[fun].__globals__[&quot;__doc__&quot;]
                docs[fun] = st_.states[fun].__doc__
        else:
            for fun in st_.states:
                if fun == module or fun.startswith(target_mod):
                    state = module.split(&quot;.&quot;)[0]
                    if state not in docs:
                        if hasattr(st_.states[fun], &quot;__globals__&quot;):
                            docs[state] = st_.states[fun].__globals__[&quot;__doc__&quot;]
                    docs[fun] = st_.states[fun].__doc__
    return salt.utils.doc.strip_rst(docs)


def runner_doc(*args):
    &quot;&quot;&quot;
    Return the docstrings for all runners. Optionally, specify a runner or a
    function to narrow the selection.

    The strings are aggregated into a single document on the master for easy
    reading.

    Multiple runners/functions can be specified.

    .. versionadded:: 2014.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.runner_doc
        salt '*' sys.runner_doc cache
        salt '*' sys.runner_doc cache.grains
        salt '*' sys.runner_doc cache.grains mine.get

    Runner names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.runner_doc 'cache.clear_*'

    &quot;&quot;&quot;
    run_ = salt.runner.Runner(__opts__)
    docs = {}
    if not args:
        for fun in run_.functions:
            docs[fun] = run_.functions[fun].__doc__
        return salt.utils.doc.strip_rst(docs)

    for module in args:
        _use_fnmatch = False
        if &quot;*&quot; in module:
            target_mod = module
            _use_fnmatch = True
        elif module:
            # allow both &quot;sys&quot; and &quot;sys.&quot; to match sys, without also matching
            # sysctl
            target_mod = module + &quot;.&quot; if not module.endswith(&quot;.&quot;) else module
        else:
            target_mod = &quot;&quot;
        if _use_fnmatch:
            for fun in fnmatch.filter(run_.functions, target_mod):
                docs[fun] = run_.functions[fun].__doc__
        else:
            for fun in run_.functions:
                if fun == module or fun.startswith(target_mod):
                    docs[fun] = run_.functions[fun].__doc__
    return salt.utils.doc.strip_rst(docs)


def returner_doc(*args):
    &quot;&quot;&quot;
    Return the docstrings for all returners. Optionally, specify a returner or a
    function to narrow the selection.

    The strings are aggregated into a single document on the master for easy
    reading.

    Multiple returners/functions can be specified.

    .. versionadded:: 2014.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.returner_doc
        salt '*' sys.returner_doc sqlite3
        salt '*' sys.returner_doc sqlite3.get_fun
        salt '*' sys.returner_doc sqlite3.get_fun etcd.get_fun

    Returner names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.returner_doc 'sqlite3.get_*'

    &quot;&quot;&quot;

    returners_ = salt.loader.returners(__opts__, [])
    docs = {}
    if not args:
        for fun in returners_:
            docs[fun] = returners_[fun].__doc__
        return salt.utils.doc.strip_rst(docs)

    for module in args:
        _use_fnmatch = False
        if &quot;*&quot; in module:
            target_mod = module
            _use_fnmatch = True
        elif module:
            # allow both &quot;sys&quot; and &quot;sys.&quot; to match sys, without also matching
            # sysctl
            target_mod = module + &quot;.&quot; if not module.endswith(&quot;.&quot;) else module
        else:
            target_mod = &quot;&quot;
        if _use_fnmatch:
            for fun in returners_:
                if fun == module or fun.startswith(target_mod):
                    docs[fun] = returners_[fun].__doc__
        else:
            for fun in returners_.keys():
                if fun == module or fun.startswith(target_mod):
                    docs[fun] = returners_[fun].__doc__
    return salt.utils.doc.strip_rst(docs)


def renderer_doc(*args):
    &quot;&quot;&quot;
    Return the docstrings for all renderers. Optionally, specify a renderer or a
    function to narrow the selection.

    The strings are aggregated into a single document on the master for easy
    reading.

    Multiple renderers can be specified.

    .. versionadded:: 2015.5.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.renderer_doc
        salt '*' sys.renderer_doc cheetah
        salt '*' sys.renderer_doc jinja json

    Renderer names can be specified as globs.

    .. code-block:: bash

        salt '*' sys.renderer_doc 'c*' 'j*'

    &quot;&quot;&quot;
    renderers_ = salt.loader.render(__opts__, [])
    docs = {}
    if not args:
        for func in renderers_.keys():
            docs[func] = renderers_[func].__doc__
        return salt.utils.doc.strip_rst(docs)

    for module in args:
        if &quot;*&quot; in module or &quot;.&quot; in module:
            for func in fnmatch.filter(renderers_, module):
                docs[func] = renderers_[func].__doc__
        else:
            moduledot = module + &quot;.&quot;
            for func in renderers_.keys():
                if func.startswith(moduledot):
                    docs[func] = renderers_[func].__doc__
    return salt.utils.doc.strip_rst(docs)


def list_functions(*args, **kwargs):  # pylint: disable=unused-argument
    &quot;&quot;&quot;
    List the functions for all modules. Optionally, specify a module or modules
    from which to list.

    CLI Example:

    .. code-block:: bash

        salt '*' sys.list_functions
        salt '*' sys.list_functions sys
        salt '*' sys.list_functions sys user

    .. versionadded:: 0.12.0

    .. code-block:: bash

        salt '*' sys.list_functions 'module.specific_function'

    Function names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.list_functions 'sys.list_*'

    &quot;&quot;&quot;
    # ## NOTE: **kwargs is used here to prevent a traceback when garbage
    # ##       arguments are tacked on to the end.

    if not args:
        # We're being asked for all functions
        return sorted(__salt__)

    names = set()
    for module in args:
        if &quot;*&quot; in module or &quot;.&quot; in module:
            for func in fnmatch.filter(__salt__, module):
                names.add(func)
        else:
            # &quot;sys&quot; should just match sys without also matching sysctl
            moduledot = module + &quot;.&quot;
            for func in __salt__:
                if func.startswith(moduledot):
                    names.add(func)
    return sorted(names)


def list_modules(*args):
    &quot;&quot;&quot;
    List the modules loaded on the minion

    .. versionadded:: 2015.5.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.list_modules

    Module names can be specified as globs.

    .. code-block:: bash

        salt '*' sys.list_modules 's*'

    &quot;&quot;&quot;
    modules = set()
    if not args:
        for func in __salt__:
            modules.add(func.split(&quot;.&quot;)[0])
        return sorted(modules)

    for module in args:
        if &quot;*&quot; in module:
            for func in fnmatch.filter(__salt__, module):
                modules.add(func.split(&quot;.&quot;)[0])
        else:
            for func in __salt__:
                mod_test = func.split(&quot;.&quot;)[0]
                if mod_test == module:
                    modules.add(mod_test)
    return sorted(modules)


def reload_modules():
    &quot;&quot;&quot;
    Tell the minion to reload the execution modules

    CLI Example:

    .. code-block:: bash

        salt '*' sys.reload_modules
    &quot;&quot;&quot;
    # This function is actually handled inside the minion.py file, the function
    # is caught before it ever gets here. Therefore, the docstring above is
    # only for the online docs, and ANY CHANGES made to it must also be made in
    # each of the gen_modules() funcs in minion.py.
    return True


def argspec(module=&quot;&quot;):
    &quot;&quot;&quot;
    Return the argument specification of functions in Salt execution
    modules.

    CLI Example:

    .. code-block:: bash

        salt '*' sys.argspec pkg.install
        salt '*' sys.argspec sys
        salt '*' sys.argspec

    Module names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.argspec 'pkg.*'

    &quot;&quot;&quot;
    return salt.utils.args.argspec_report(__salt__, module)


def state_argspec(module=&quot;&quot;):
    &quot;&quot;&quot;
    Return the argument specification of functions in Salt state
    modules.

    .. versionadded:: 2015.5.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.state_argspec pkg.installed
        salt '*' sys.state_argspec file
        salt '*' sys.state_argspec

    State names can be specified as globs.

    .. code-block:: bash

        salt '*' sys.state_argspec 'pkg.*'

    &quot;&quot;&quot;
    st_ = salt.state.State(__opts__)
    return salt.utils.args.argspec_report(st_.states, module)


def returner_argspec(module=&quot;&quot;):
    &quot;&quot;&quot;
    Return the argument specification of functions in Salt returner
    modules.

    .. versionadded:: 2015.5.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.returner_argspec xmpp
        salt '*' sys.returner_argspec xmpp smtp
        salt '*' sys.returner_argspec

    Returner names can be specified as globs.

    .. code-block:: bash

        salt '*' sys.returner_argspec 'sqlite3.*'

    &quot;&quot;&quot;
    returners_ = salt.loader.returners(__opts__, [])
    return salt.utils.args.argspec_report(returners_, module)


def runner_argspec(module=&quot;&quot;):
    &quot;&quot;&quot;
    Return the argument specification of functions in Salt runner
    modules.

    .. versionadded:: 2015.5.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.runner_argspec state
        salt '*' sys.runner_argspec http
        salt '*' sys.runner_argspec

    Runner names can be specified as globs.

    .. code-block:: bash

        salt '*' sys.runner_argspec 'winrepo.*'
    &quot;&quot;&quot;
    run_ = salt.runner.Runner(__opts__)
    return salt.utils.args.argspec_report(run_.functions, module)


def list_state_functions(*args, **kwargs):  # pylint: disable=unused-argument
    &quot;&quot;&quot;
    List the functions for all state modules. Optionally, specify a state
    module or modules from which to list.

    .. versionadded:: 2014.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.list_state_functions
        salt '*' sys.list_state_functions file
        salt '*' sys.list_state_functions pkg user

    State function names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.list_state_functions 'file.*'
        salt '*' sys.list_state_functions 'file.s*'

    .. versionadded:: 2016.9

    .. code-block:: bash

        salt '*' sys.list_state_functions 'module.specific_function'

    &quot;&quot;&quot;
    # NOTE: **kwargs is used here to prevent a traceback when garbage
    #       arguments are tacked on to the end.

    st_ = salt.state.State(__opts__)
    if not args:
        # We're being asked for all functions
        return sorted(st_.states)

    names = set()
    for module in args:
        if &quot;*&quot; in module or &quot;.&quot; in module:
            for func in fnmatch.filter(st_.states, module):
                names.add(func)
        else:
            # &quot;sys&quot; should just match sys without also matching sysctl
            moduledot = module + &quot;.&quot;
            for func in st_.states:
                if func.startswith(moduledot):
                    names.add(func)
    return sorted(names)


def list_state_modules(*args):
    &quot;&quot;&quot;
    List the modules loaded on the minion

    .. versionadded:: 2014.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.list_state_modules

    State module names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.list_state_modules 'mysql_*'

    &quot;&quot;&quot;
    st_ = salt.state.State(__opts__)
    modules = set()

    if not args:
        for func in st_.states:
            log.debug(&quot;func %s&quot;, func)
            modules.add(func.split(&quot;.&quot;)[0])
        return sorted(modules)

    for module in args:
        if &quot;*&quot; in module:
            for func in fnmatch.filter(st_.states, module):
                modules.add(func.split(&quot;.&quot;)[0])
        else:
            for func in st_.states:
                mod_test = func.split(&quot;.&quot;)[0]
                if mod_test == module:
                    modules.add(mod_test)
    return sorted(modules)


def list_runners(*args):
    &quot;&quot;&quot;
    List the runners loaded on the minion

    .. versionadded:: 2014.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.list_runners

    Runner names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.list_runners 'm*'

    &quot;&quot;&quot;
    run_ = salt.runner.Runner(__opts__)
    runners = set()
    if not args:
        for func in run_.functions:
            runners.add(func.split(&quot;.&quot;)[0])
        return sorted(runners)

    for module in args:
        if &quot;*&quot; in module:
            for func in fnmatch.filter(run_.functions, module):
                runners.add(func.split(&quot;.&quot;)[0])
        else:
            for func in run_.functions:
                mod_test = func.split(&quot;.&quot;)[0]
                if mod_test == module:
                    runners.add(mod_test)
    return sorted(runners)


def list_runner_functions(*args, **kwargs):  # pylint: disable=unused-argument
    &quot;&quot;&quot;
    List the functions for all runner modules. Optionally, specify a runner
    module or modules from which to list.

    .. versionadded:: 2014.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.list_runner_functions
        salt '*' sys.list_runner_functions state
        salt '*' sys.list_runner_functions state virt

    Runner function names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.list_runner_functions 'state.*' 'virt.*'

    &quot;&quot;&quot;
    # ## NOTE: **kwargs is used here to prevent a traceback when garbage
    # ##       arguments are tacked on to the end.

    run_ = salt.runner.Runner(__opts__)
    if not args:
        # We're being asked for all functions
        return sorted(run_.functions)

    names = set()
    for module in args:
        if &quot;*&quot; in module or &quot;.&quot; in module:
            for func in fnmatch.filter(run_.functions, module):
                names.add(func)
        else:
            # &quot;sys&quot; should just match sys without also matching sysctl
            moduledot = module + &quot;.&quot;
            for func in run_.functions:
                if func.startswith(moduledot):
                    names.add(func)
    return sorted(names)


def list_returners(*args):
    &quot;&quot;&quot;
    List the returners loaded on the minion

    .. versionadded:: 2014.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.list_returners

    Returner names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.list_returners 's*'

    &quot;&quot;&quot;
    returners_ = salt.loader.returners(__opts__, [])
    returners = set()

    if not args:
        for func in returners_.keys():
            returners.add(func.split(&quot;.&quot;)[0])
        return sorted(returners)

    for module in args:
        if &quot;*&quot; in module:
            for func in fnmatch.filter(returners_, module):
                returners.add(func.split(&quot;.&quot;)[0])
        else:
            for func in returners_:
                mod_test = func.split(&quot;.&quot;)[0]
                if mod_test == module:
                    returners.add(mod_test)
    return sorted(returners)


def list_returner_functions(*args, **kwargs):  # pylint: disable=unused-argument
    &quot;&quot;&quot;
    List the functions for all returner modules. Optionally, specify a returner
    module or modules from which to list.

    .. versionadded:: 2014.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.list_returner_functions
        salt '*' sys.list_returner_functions mysql
        salt '*' sys.list_returner_functions mysql etcd

    Returner names can be specified as globs.

    .. versionadded:: 2015.5.0

    .. code-block:: bash

        salt '*' sys.list_returner_functions 'sqlite3.get_*'

    &quot;&quot;&quot;
    # NOTE: **kwargs is used here to prevent a traceback when garbage
    #       arguments are tacked on to the end.

    returners_ = salt.loader.returners(__opts__, [])
    if not args:
        # We're being asked for all functions
        return sorted(returners_)

    names = set()
    for module in args:
        if &quot;*&quot; in module or &quot;.&quot; in module:
            for func in fnmatch.filter(returners_, module):
                names.add(func)
        else:
            # &quot;sys&quot; should just match sys without also matching sysctl
            moduledot = module + &quot;.&quot;
            for func in returners_:
                if func.startswith(moduledot):
                    names.add(func)
    return sorted(names)


def list_renderers(*args):
    &quot;&quot;&quot;
    List the renderers loaded on the minion

    .. versionadded:: 2015.5.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.list_renderers

    Render names can be specified as globs.

    .. code-block:: bash

        salt '*' sys.list_renderers 'yaml*'

    &quot;&quot;&quot;
    renderers_ = salt.loader.render(__opts__, [])
    renderers = set()

    if not args:
        for rend in renderers_.keys():
            renderers.add(rend)
        return sorted(renderers)

    for module in args:
        for rend in fnmatch.filter(renderers_, module):
            renderers.add(rend)
    return sorted(renderers)


def _argspec_to_schema(mod, spec):
    args = spec[&quot;args&quot;]
    defaults = spec[&quot;defaults&quot;] or []

    args_req = args[: len(args) - len(defaults)]
    args_defaults = list(zip(args[-len(defaults) :], defaults))

    types = {
        &quot;title&quot;: mod,
        &quot;description&quot;: mod,
<A NAME="1"></A>    }

    for i in args_req:
        types[i] = salt<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match193504-1.html#1',3,'match193504-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.utils.schema.OneOfItem(
            items=(
                salt.utils.schema.BooleanItem(title=i, description=</B></FONT>i, required=True),
                salt.utils.schema.IntegerItem(title=i, description=i, required=True),
                salt.utils.schema.NumberItem(title=i, description=i, required=True),
                salt.utils.schema.StringItem(title=i, description=i, required=True),
                # S.ArrayItem(title=i, description=i, required=True),
                # S.DictItem(title=i, description=i, required=True),
            )
<A NAME="0"></A>        )

    for i, j in args_defaults:
        types[i] = salt<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match193504-1.html#0',3,'match193504-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.utils.schema.OneOfItem(
            items=(
                salt.utils.schema.BooleanItem(title=i, description=</B></FONT>i, default=j),
                salt.utils.schema.IntegerItem(title=i, description=i, default=j),
                salt.utils.schema.NumberItem(title=i, description=i, default=j),
                salt.utils.schema.StringItem(title=i, description=i, default=j),
                # S.ArrayItem(title=i, description=i, default=j),
                # S.DictItem(title=i, description=i, default=j),
            )
        )

    return type(mod, (salt.utils.schema.Schema,), types).serialize()


def state_schema(module=&quot;&quot;):
    &quot;&quot;&quot;
    Return a JSON Schema for the given state function(s)

    .. versionadded:: 2016.3.0

    CLI Example:

    .. code-block:: bash

        salt '*' sys.state_schema
        salt '*' sys.state_schema pkg.installed
    &quot;&quot;&quot;
    specs = state_argspec(module)

    schemas = []
    for state_mod, state_spec in specs.items():
        schemas.append(_argspec_to_schema(state_mod, state_spec))

    return schemas
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltnado.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import salt.ext.tornado
import salt.ext.tornado.testing
import salt.netapi.rest_tornado.saltnado as saltnado
from tests.support.mock import MagicMock, patch


class TestJobNotRunning(salt.ext.tornado.testing.AsyncTestCase):
    def setUp(self):
        super().setUp()
        self.mock = MagicMock()
        self.mock.opts = {
            &quot;syndic_wait&quot;: 0.1,
            &quot;cachedir&quot;: &quot;/tmp/testing/cachedir&quot;,
            &quot;sock_dir&quot;: &quot;/tmp/testing/sock_drawer&quot;,
            &quot;transport&quot;: &quot;zeromq&quot;,
            &quot;extension_modules&quot;: &quot;/tmp/testing/moduuuuules&quot;,
            &quot;order_masters&quot;: False,
            &quot;gather_job_timeout&quot;: 10.001,
        }
        self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
        self.handler._write_buffer = []
        self.handler._transforms = []
        self.handler.lowstate = []
        self.handler.content_type = &quot;text/plain&quot;
        self.handler.dumper = lambda x: x
        f = salt.ext.tornado.gen.Future()
        f.set_result({&quot;jid&quot;: f, &quot;minions&quot;: []})
        self.handler.saltclients.update({&quot;local&quot;: lambda *args, **kwargs: f})

    @salt.ext.tornado.testing.gen_test
    def test_when_disbatch_has_already_finished_then_writing_return_should_not_fail(
        self,
    ):
        self.handler.finish()
        result = yield self.handler.disbatch()
        # No assertion necessary, because we just want no failure here.
        # Asserting that it doesn't raise anything is... the default behavior
        # for a test.

    @salt.ext.tornado.testing.gen_test
    def test_when_disbatch_has_already_finished_then_finishing_should_not_fail(self):
        self.handler.finish()
        result = yield self.handler.disbatch()
        # No assertion necessary, because we just want no failure here.
        # Asserting that it doesn't raise anything is... the default behavior
        # for a test.

    @salt.ext.tornado.testing.gen_test
    def test_when_event_times_out_and_minion_is_not_running_result_should_be_True(self):
        fut = salt.ext.tornado.gen.Future()
        fut.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.return_value = fut
        wrong_future = salt.ext.tornado.gen.Future()

        result = yield self.handler.job_not_running(
            jid=42, tgt=&quot;*&quot;, tgt_type=&quot;glob&quot;, minions=[], is_finished=wrong_future
        )

        self.assertTrue(result)

    @salt.ext.tornado.testing.gen_test
    def test_when_event_times_out_and_minion_is_not_running_minion_data_should_not_be_set(
        self,
    ):
        fut = salt.ext.tornado.gen.Future()
        fut.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.return_value = fut
        wrong_future = salt.ext.tornado.gen.Future()
        minions = {}

        result = yield self.handler.job_not_running(
            jid=42, tgt=&quot;*&quot;, tgt_type=&quot;glob&quot;, minions=minions, is_finished=wrong_future
        )

        assert not minions

    @salt.ext.tornado.testing.gen_test
    def test_when_event_finally_finishes_and_returned_minion_not_in_minions_it_should_be_set_to_False(
        self,
    ):
        expected_id = 42
        no_data_event = salt.ext.tornado.gen.Future()
        no_data_event.set_result({&quot;data&quot;: {}})
        empty_return_event = salt.ext.tornado.gen.Future()
        empty_return_event.set_result({&quot;data&quot;: {&quot;return&quot;: {}}})
        actual_return_event = salt.ext.tornado.gen.Future()
        actual_return_event.set_result(
            {&quot;data&quot;: {&quot;return&quot;: {&quot;something happened here&quot;: &quot;OK?&quot;}, &quot;id&quot;: expected_id}}
        )
        timed_out_event = salt.ext.tornado.gen.Future()
        timed_out_event.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.side_effect = [
            no_data_event,
            empty_return_event,
            actual_return_event,
            timed_out_event,
            timed_out_event,
        ]
        minions = {}

        yield self.handler.job_not_running(
            jid=99,
            tgt=&quot;*&quot;,
            tgt_type=&quot;fnord&quot;,
            minions=minions,
            is_finished=salt.ext.tornado.gen.Future(),
        )

        self.assertFalse(minions[expected_id])

    @salt.ext.tornado.testing.gen_test
    def test_when_event_finally_finishes_and_returned_minion_already_in_minions_it_should_not_be_changed(
        self,
    ):
        expected_id = 42
        expected_value = object()
        minions = {expected_id: expected_value}
        no_data_event = salt.ext.tornado.gen.Future()
        no_data_event.set_result({&quot;data&quot;: {}})
        empty_return_event = salt.ext.tornado.gen.Future()
        empty_return_event.set_result({&quot;data&quot;: {&quot;return&quot;: {}}})
        actual_return_event = salt.ext.tornado.gen.Future()
        actual_return_event.set_result(
            {&quot;data&quot;: {&quot;return&quot;: {&quot;something happened here&quot;: &quot;OK?&quot;}, &quot;id&quot;: expected_id}}
        )
        timed_out_event = salt.ext.tornado.gen.Future()
        timed_out_event.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.side_effect = [
            no_data_event,
            empty_return_event,
            actual_return_event,
            timed_out_event,
            timed_out_event,
        ]

        yield self.handler.job_not_running(
            jid=99,
            tgt=&quot;*&quot;,
            tgt_type=&quot;fnord&quot;,
            minions=minions,
            is_finished=salt.ext.tornado.gen.Future(),
        )

        self.assertIs(minions[expected_id], expected_value)

    @salt.ext.tornado.testing.gen_test
    def test_when_event_returns_early_and_finally_times_out_result_should_be_True(self):
        no_data_event = salt.ext.tornado.gen.Future()
        no_data_event.set_result({&quot;data&quot;: {}})
        empty_return_event = salt.ext.tornado.gen.Future()
        empty_return_event.set_result({&quot;data&quot;: {&quot;return&quot;: {}}})
        actual_return_event = salt.ext.tornado.gen.Future()
        actual_return_event.set_result(
            {&quot;data&quot;: {&quot;return&quot;: {&quot;something happened here&quot;: &quot;OK?&quot;}, &quot;id&quot;: &quot;fnord&quot;}}
        )
        timed_out_event = salt.ext.tornado.gen.Future()
        timed_out_event.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.side_effect = [
            no_data_event,
            empty_return_event,
            actual_return_event,
            timed_out_event,
            timed_out_event,
        ]

        result = yield self.handler.job_not_running(
            jid=99,
            tgt=&quot;*&quot;,
            tgt_type=&quot;fnord&quot;,
            minions={},
            is_finished=salt.ext.tornado.gen.Future(),
        )
        self.assertTrue(result)

    @salt.ext.tornado.testing.gen_test
    def test_when_event_finishes_but_is_finished_is_done_then_result_should_be_True(
        self,
    ):
        expected_minion_id = &quot;fnord&quot;
        expected_minion_value = object()
        no_data_event = salt.ext.tornado.gen.Future()
        no_data_event.set_result({&quot;data&quot;: {}})
        empty_return_event = salt.ext.tornado.gen.Future()
        empty_return_event.set_result({&quot;data&quot;: {&quot;return&quot;: {}}})
        actual_return_event = salt.ext.tornado.gen.Future()
        actual_return_event.set_result(
            {
                &quot;data&quot;: {
                    &quot;return&quot;: {&quot;something happened here&quot;: &quot;OK?&quot;},
                    &quot;id&quot;: expected_minion_id,
                }
            }
        )
        is_finished = salt.ext.tornado.gen.Future()

        def abort(*args, **kwargs):
            yield actual_return_event
            f = salt.ext.tornado.gen.Future()
            f.set_exception(saltnado.TimeoutException())
            is_finished.set_result(&quot;This is done&quot;)
            yield f
            assert False, &quot;Never should make it here&quot;

        minions = {expected_minion_id: expected_minion_value}

        self.mock.event_listener.get_event.side_effect = (x for x in abort())

        result = yield self.handler.job_not_running(
            jid=99,
            tgt=&quot;*&quot;,
            tgt_type=&quot;fnord&quot;,
            minions=minions,
            is_finished=is_finished,
        )
        self.assertTrue(result)

        # These are failsafes to ensure nothing super sideways happened
        self.assertTrue(len(minions) == 1, str(minions))
        self.assertIs(minions[expected_minion_id], expected_minion_value)

    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_times_out_before_event_finishes_result_should_be_True(
        self,
    ):
        # Other test times out with event - this one should time out for is_finished
        finished = salt.ext.tornado.gen.Future()
        finished.set_exception(saltnado.TimeoutException())
        wrong_future = salt.ext.tornado.gen.Future()
        self.mock.event_listener.get_event.return_value = wrong_future

        result = yield self.handler.job_not_running(
            jid=42, tgt=&quot;*&quot;, tgt_type=&quot;glob&quot;, minions=[], is_finished=finished
        )

        self.assertTrue(result)

    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_times_out_before_event_finishes_event_should_have_result_set_to_None(
        self,
    ):
        finished = salt.ext.tornado.gen.Future()
        finished.set_exception(saltnado.TimeoutException())
        wrong_future = salt.ext.tornado.gen.Future()
        self.mock.event_listener.get_event.return_value = wrong_future

        result = yield self.handler.job_not_running(
            jid=42, tgt=&quot;*&quot;, tgt_type=&quot;glob&quot;, minions=[], is_finished=finished
        )

        self.assertIsNone(wrong_future.result())


# TODO: I think we can extract seUp into a superclass -W. Werner, 2020-11-03
class TestGetMinionReturns(salt.ext.tornado.testing.AsyncTestCase):
    def setUp(self):
        super().setUp()
        self.mock = MagicMock()
        self.mock.opts = {
            &quot;syndic_wait&quot;: 0.1,
            &quot;cachedir&quot;: &quot;/tmp/testing/cachedir&quot;,
            &quot;sock_dir&quot;: &quot;/tmp/testing/sock_drawer&quot;,
            &quot;transport&quot;: &quot;zeromq&quot;,
            &quot;extension_modules&quot;: &quot;/tmp/testing/moduuuuules&quot;,
            &quot;order_masters&quot;: False,
            &quot;gather_job_timeout&quot;: 10.001,
        }
        self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
        f = salt.ext.tornado.gen.Future()
        f.set_result({&quot;jid&quot;: f, &quot;minions&quot;: []})

    @salt.ext.tornado.testing.gen_test
    def test_if_finished_before_any_events_return_then_result_should_be_empty_dictionary(
        self,
    ):
        expected_result = {}
        xxx = salt.ext.tornado.gen.Future()
        xxx.set_result(None)
        is_finished = salt.ext.tornado.gen.Future()
        is_finished.set_result(None)
        actual_result = yield self.handler.get_minion_returns(
            events=[],
            is_finished=is_finished,
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=xxx,
            minions={},
        )
        self.assertDictEqual(actual_result, expected_result)

    # TODO: Copy above - test with timed out -W. Werner, 2020-11-05

    @salt.ext.tornado.testing.gen_test
    def test_if_is_finished_after_events_return_then_result_should_contain_event_result_data(
        self,
    ):
        expected_result = {
            &quot;minion1&quot;: {&quot;fnord&quot;: &quot;this is some fnordish data&quot;},
            &quot;minion2&quot;: {&quot;fnord&quot;: &quot;this is some other fnordish data&quot;},
        }
        xxx = salt.ext.tornado.gen.Future()
        xxx.set_result(None)
        is_finished = salt.ext.tornado.gen.Future()
        # XXX what do I do here?
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]
        events[0].set_result(
            {
                &quot;tag&quot;: &quot;fnord&quot;,
                &quot;data&quot;: {&quot;id&quot;: &quot;minion1&quot;, &quot;return&quot;: expected_result[&quot;minion1&quot;]},
            }
        )
        events[1].set_result(
            {
                &quot;tag&quot;: &quot;fnord&quot;,
                &quot;data&quot;: {&quot;id&quot;: &quot;minion2&quot;, &quot;return&quot;: expected_result[&quot;minion2&quot;]},
            }
        )
        self.io_loop.call_later(0.2, lambda: is_finished.set_result(None))

        actual_result = yield self.handler.get_minion_returns(
            events=events,
            is_finished=is_finished,
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=xxx,
            minions={
                &quot;minion1&quot;: False,
                &quot;minion2&quot;: False,
                &quot;never returning minion&quot;: False,
            },
        )

        assert actual_result == expected_result

    @salt.ext.tornado.testing.gen_test
    def test_if_timed_out_after_events_return_then_result_should_contain_event_result_data(
        self,
    ):
        expected_result = {
            &quot;minion1&quot;: {&quot;fnord&quot;: &quot;this is some fnordish data&quot;},
            &quot;minion2&quot;: {&quot;fnord&quot;: &quot;this is some other fnordish data&quot;},
        }
        xxx = salt.ext.tornado.gen.Future()
        xxx.set_result(None)
        is_timed_out = salt.ext.tornado.gen.Future()
        # XXX what do I do here?
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]
        events[0].set_result(
            {
                &quot;tag&quot;: &quot;fnord&quot;,
                &quot;data&quot;: {&quot;id&quot;: &quot;minion1&quot;, &quot;return&quot;: expected_result[&quot;minion1&quot;]},
            }
        )
        events[1].set_result(
            {
                &quot;tag&quot;: &quot;fnord&quot;,
                &quot;data&quot;: {&quot;id&quot;: &quot;minion2&quot;, &quot;return&quot;: expected_result[&quot;minion2&quot;]},
            }
        )
        self.io_loop.call_later(0.2, lambda: is_timed_out.set_result(None))

        actual_result = yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=is_timed_out,
            min_wait_time=xxx,
            minions={
                &quot;minion1&quot;: False,
                &quot;minion2&quot;: False,
                &quot;never returning minion&quot;: False,
            },
        )

        assert actual_result == expected_result

    @salt.ext.tornado.testing.gen_test
    def test_if_wait_timer_is_not_done_even_though_results_are_then_data_should_not_yet_be_returned(
        self,
    ):
        expected_result = {
            &quot;one&quot;: {&quot;fnordy one&quot;: &quot;one has some data&quot;},
            &quot;two&quot;: {&quot;fnordy two&quot;: &quot;two has some data&quot;},
        }
        events = [salt.ext.tornado.gen.Future(), salt.ext.tornado.gen.Future()]
        events[0].set_result(
            {&quot;tag&quot;: &quot;fnord&quot;, &quot;data&quot;: {&quot;id&quot;: &quot;one&quot;, &quot;return&quot;: expected_result[&quot;one&quot;]}}
        )
        events[1].set_result(
            {&quot;tag&quot;: &quot;fnord&quot;, &quot;data&quot;: {&quot;id&quot;: &quot;two&quot;, &quot;return&quot;: expected_result[&quot;two&quot;]}}
        )
<A NAME="1"></A>        wait_timer = salt.ext.tornado.gen.Future()
        fut = self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match193504-0.html#1',2,'match193504-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.tornado.gen.Future(),
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=wait_timer,
            minions=</B></FONT>{&quot;one&quot;: False, &quot;two&quot;: False},
        )

        def boop():
            yield fut

        self.io_loop.spawn_callback(boop)
        yield salt.ext.tornado.gen.sleep(0.1)

        assert not fut.done()

        wait_timer.set_result(None)
        actual_result = yield fut

        assert actual_result == expected_result

    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_any_other_futures_should_be_canceled(self):
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]

        is_finished = salt.ext.tornado.gen.Future()
        is_finished.set_result(None)
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=is_finished,
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=salt.ext.tornado.gen.Future(),
            minions={&quot;one&quot;: False, &quot;two&quot;: False},
        )

        are_done = [event.done() for event in events]
        assert all(are_done)

    @salt.ext.tornado.testing.gen_test
    def test_when_an_event_times_out_then_we_should_not_enter_an_infinite_loop(self):
        # NOTE: this test will enter an infinite loop if the code is broken. I
        # was not able to figure out a way to ensure that the test exits with
        # failure rather than stalling forever. That is because the
        # TimeoutException happens first and then tornado will never yield
        # control to another coroutine. Like a coroutine to remove the future
        # with the TimeoutException. It is also not possible to clear the
        # TimeoutException.

        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]

        # Arguably any event would work, but 3 isn't the first, so it
        # gives us a little more confidence that this test is testing
        # correctly
        events[3].set_exception(saltnado.TimeoutException())
        times_out_later = salt.ext.tornado.gen.Future()
        # 0.5s should be long enough that the test gets through doing other
        # things before hitting this timeout, which will cancel all the
        # in-flight futures.
        self.io_loop.call_later(0.5, lambda: times_out_later.set_result(None))
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=times_out_later,
            min_wait_time=salt.ext.tornado.gen.Future(),
            minions={&quot;one&quot;: False, &quot;two&quot;: False},
        )

        # Technically we don't /need/ to check that all events are done,
        # but it's incorrect to exit the function without ensuring all
        # futures are canceled.
        are_done = [event.done() for event in events]
        assert all(are_done)
        assert times_out_later.done()

    @salt.ext.tornado.testing.gen_test
    def test_when_is_timed_out_any_other_futures_should_be_canceled(self):
        # There is some question about whether this test is or should be
        # necessary. Or if it's meaningful. The code that this is testing
        # should never actually be able to make it to this point -- because
        # when all events have completed it should exit at a different branch.
        # That being said, the worst case is that this is just a duplicate
        # or irrelevant test, and can be removed.
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]

        is_timed_out = salt.ext.tornado.gen.Future()
        is_timed_out.set_result(None)
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=is_timed_out,
            min_wait_time=salt.ext.tornado.gen.Future(),
            minions={&quot;one&quot;: False, &quot;two&quot;: False},
        )

        are_done = [event.done() for event in events]
        assert all(are_done)

    @salt.ext.tornado.testing.gen_test
    def test_when_min_wait_time_and_nothing_todo_any_other_futures_should_be_canceled(
        self,
    ):
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]

        is_finished = salt.ext.tornado.gen.Future()
        min_wait_time = salt.ext.tornado.gen.Future()
        self.io_loop.call_later(0.2, lambda: min_wait_time.set_result(None))

        yield self.handler.get_minion_returns(
            events=events,
            is_finished=is_finished,
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=min_wait_time,
            minions={&quot;one&quot;: True, &quot;two&quot;: True},
        )

        are_done = [event.done() for event in events] + [is_finished.done()]
        assert all(are_done)

    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_but_not_is_timed_out_then_timed_out_should_not_be_set_to_done(
        self,
    ):
        events = [salt.ext.tornado.gen.Future()]
        is_timed_out = salt.ext.tornado.gen.Future()
        is_finished = salt.ext.tornado.gen.Future()
        is_finished.set_result(None)

        yield self.handler.get_minion_returns(
            events=events,
            is_finished=is_finished,
            is_timed_out=is_timed_out,
            min_wait_time=salt.ext.tornado.gen.Future(),
            minions={&quot;one&quot;: False, &quot;two&quot;: False},
        )

        assert not is_timed_out.done()

    @salt.ext.tornado.testing.gen_test
    def test_when_min_wait_time_and_all_completed_but_not_is_timed_out_then_timed_out_should_not_be_set_to_done(
        self,
    ):
        events = [salt.ext.tornado.gen.Future()]
        is_timed_out = salt.ext.tornado.gen.Future()
        min_wait_time = salt.ext.tornado.gen.Future()
        self.io_loop.call_later(0.2, lambda: min_wait_time.set_result(None))

        yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=is_timed_out,
            min_wait_time=min_wait_time,
            minions={&quot;one&quot;: True},
        )

        assert not is_timed_out.done()

    @salt.ext.tornado.testing.gen_test
    def test_when_things_are_completed_but_not_timed_out_then_timed_out_event_should_not_be_done(
        self,
    ):
        events = [
            salt.ext.tornado.gen.Future(),
        ]
        events[0].set_result({&quot;tag&quot;: &quot;fnord&quot;, &quot;data&quot;: {&quot;id&quot;: &quot;one&quot;, &quot;return&quot;: {}}})
        min_wait_time = salt.ext.tornado.gen.Future()
        min_wait_time.set_result(None)
        is_timed_out = salt.ext.tornado.gen.Future()

        yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=is_timed_out,
            min_wait_time=min_wait_time,
            minions={&quot;one&quot;: True},
        )

        assert not is_timed_out.done()


class TestDisbatchLocal(salt.ext.tornado.testing.AsyncTestCase):
    def setUp(self):
        super().setUp()
        self.mock = MagicMock()
        self.mock.opts = {
            &quot;syndic_wait&quot;: 0.1,
            &quot;cachedir&quot;: &quot;/tmp/testing/cachedir&quot;,
            &quot;sock_dir&quot;: &quot;/tmp/testing/sock_drawer&quot;,
            &quot;transport&quot;: &quot;zeromq&quot;,
            &quot;extension_modules&quot;: &quot;/tmp/testing/moduuuuules&quot;,
            &quot;order_masters&quot;: False,
            &quot;gather_job_timeout&quot;: 10.001,
        }
        self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)

    @salt.ext.tornado.testing.gen_test
<A NAME="0"></A>    def test_when_is_timed_out_is_set_before_other_events_are_completed_then_result_should_be_empty_dictionary(
        self,
    ):
        completed_event = salt.ext<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match193504-0.html#0',2,'match193504-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        # TODO: We may need to tweak these values to get them close enough but not so far away -W. Werner, 2020-11-17
        gather_timeout = 0.1
        event_timeout =</B></FONT> gather_timeout + 0.05

        def fancy_get_event(*args, **kwargs):
            if kwargs.get(&quot;tag&quot;).endswith(&quot;/ret&quot;):
                return never_completed
            return completed_event

        def completer():
            completed_event.set_result(
                {
                    &quot;tag&quot;: &quot;fnord&quot;,
                    &quot;data&quot;: {
                        &quot;return&quot;: &quot;This should never be in chunk_ret&quot;,
                        &quot;id&quot;: &quot;fnord&quot;,
                    },
                }
            )

        self.io_loop.call_later(event_timeout, completer)

        f = salt.ext.tornado.gen.Future()
        f.set_result({&quot;jid&quot;: &quot;42&quot;, &quot;minions&quot;: []})
        with patch.object(
            self.handler.application.event_listener,
            &quot;get_event&quot;,
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.dict(
            self.handler.application.opts,
            {&quot;gather_job_timeout&quot;: gather_timeout, &quot;timeout&quot;: 42},
        ), patch.dict(
            self.handler.saltclients, {&quot;local&quot;: lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={&quot;tgt&quot;: &quot;*&quot;, &quot;tgt_type&quot;: &quot;glob&quot;, &quot;fun&quot;: &quot;test.ping&quot;}
            )

        assert result == {}

    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_is_set_before_events_return_then_no_data_should_be_returned(
        self,
    ):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        gather_timeout = 2
        event_timeout = gather_timeout - 1

        def fancy_get_event(*args, **kwargs):
            if kwargs.get(&quot;tag&quot;).endswith(&quot;/ret&quot;):
                return never_completed
            return completed_event

        def completer():
            completed_event.set_result(
                {
                    &quot;tag&quot;: &quot;fnord&quot;,
                    &quot;data&quot;: {
                        &quot;return&quot;: &quot;This should never be in chunk_ret&quot;,
                        &quot;id&quot;: &quot;fnord&quot;,
                    },
                }
            )

        self.io_loop.call_later(event_timeout, completer)

        def toggle_is_finished(*args, **kwargs):
            finished = kwargs.get(&quot;is_finished&quot;, args[4] if len(args) &gt; 4 else None)
            assert finished is not None
            finished.set_result(42)

        f = salt.ext.tornado.gen.Future()
        f.set_result({&quot;jid&quot;: &quot;42&quot;, &quot;minions&quot;: []})
        with patch.object(
            self.handler.application.event_listener,
            &quot;get_event&quot;,
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.object(
            self.handler,
            &quot;job_not_running&quot;,
            autospec=True,
            side_effect=toggle_is_finished,
        ), patch.dict(
            self.handler.application.opts,
            {&quot;gather_job_timeout&quot;: gather_timeout, &quot;timeout&quot;: 42},
        ), patch.dict(
            self.handler.saltclients, {&quot;local&quot;: lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={&quot;tgt&quot;: &quot;*&quot;, &quot;tgt_type&quot;: &quot;glob&quot;, &quot;fun&quot;: &quot;test.ping&quot;}
            )

        assert result == {}

    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_then_all_collected_data_should_be_returned(self):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        # This timeout should never be reached
        gather_timeout = 42
        completed_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
        for i, event in enumerate(completed_events):
            event.set_result(
                {
                    &quot;tag&quot;: &quot;fnord&quot;,
                    &quot;data&quot;: {
                        &quot;return&quot;: &quot;return from fnord {}&quot;.format(i),
                        &quot;id&quot;: &quot;fnord {}&quot;.format(i),
                    },
                }
            )
        uncompleted_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
        events = iter(completed_events + uncompleted_events)
        expected_result = {
            &quot;fnord 0&quot;: &quot;return from fnord 0&quot;,
            &quot;fnord 1&quot;: &quot;return from fnord 1&quot;,
            &quot;fnord 2&quot;: &quot;return from fnord 2&quot;,
            &quot;fnord 3&quot;: &quot;return from fnord 3&quot;,
            &quot;fnord 4&quot;: &quot;return from fnord 4&quot;,
        }

        def fancy_get_event(*args, **kwargs):
            if kwargs.get(&quot;tag&quot;).endswith(&quot;/ret&quot;):
                return never_completed
            else:
                return next(events)

        def toggle_is_finished(*args, **kwargs):
            finished = kwargs.get(&quot;is_finished&quot;, args[4] if len(args) &gt; 4 else None)
            assert finished is not None
            finished.set_result(42)

        f = salt.ext.tornado.gen.Future()
        f.set_result({&quot;jid&quot;: &quot;42&quot;, &quot;minions&quot;: [&quot;non-existent minion&quot;]})
        with patch.object(
            self.handler.application.event_listener,
            &quot;get_event&quot;,
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.object(
            self.handler,
            &quot;job_not_running&quot;,
            autospec=True,
            side_effect=toggle_is_finished,
        ), patch.dict(
            self.handler.application.opts,
            {&quot;gather_job_timeout&quot;: gather_timeout, &quot;timeout&quot;: 42},
        ), patch.dict(
            self.handler.saltclients, {&quot;local&quot;: lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={&quot;tgt&quot;: &quot;*&quot;, &quot;tgt_type&quot;: &quot;glob&quot;, &quot;fun&quot;: &quot;test.ping&quot;}
            )

        assert result == expected_result

    @salt.ext.tornado.testing.gen_test
    def test_when_is_timed_out_then_all_collected_data_should_be_returned(self):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        # 2s is probably enough for any kind of computer to manage to
        # do all the other processing. We could maybe reduce this - just
        # depends on how slow of a system we're running on.
        # TODO: Maybe we should have a test helper/fixture that benchmarks the system and gets a reasonable timeout? -W. Werner, 2020-11-19
        gather_timeout = 2
        completed_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
        for i, event in enumerate(completed_events):
            event.set_result(
                {
                    &quot;tag&quot;: &quot;fnord&quot;,
                    &quot;data&quot;: {
                        &quot;return&quot;: &quot;return from fnord {}&quot;.format(i),
                        &quot;id&quot;: &quot;fnord {}&quot;.format(i),
                    },
                }
            )
        uncompleted_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
        events = iter(completed_events + uncompleted_events)
        expected_result = {
            &quot;fnord 0&quot;: &quot;return from fnord 0&quot;,
            &quot;fnord 1&quot;: &quot;return from fnord 1&quot;,
            &quot;fnord 2&quot;: &quot;return from fnord 2&quot;,
            &quot;fnord 3&quot;: &quot;return from fnord 3&quot;,
            &quot;fnord 4&quot;: &quot;return from fnord 4&quot;,
        }

        def fancy_get_event(*args, **kwargs):
            if kwargs.get(&quot;tag&quot;).endswith(&quot;/ret&quot;):
                return never_completed
            else:
                return next(events)

        f = salt.ext.tornado.gen.Future()
        f.set_result({&quot;jid&quot;: &quot;42&quot;, &quot;minions&quot;: [&quot;non-existent minion&quot;]})
        with patch.object(
            self.handler.application.event_listener,
            &quot;get_event&quot;,
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.dict(
            self.handler.application.opts,
            {&quot;gather_job_timeout&quot;: gather_timeout, &quot;timeout&quot;: 42},
        ), patch.dict(
            self.handler.saltclients, {&quot;local&quot;: lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={&quot;tgt&quot;: &quot;*&quot;, &quot;tgt_type&quot;: &quot;glob&quot;, &quot;fun&quot;: &quot;test.ping&quot;}
            )

        assert result == expected_result

    @salt.ext.tornado.testing.gen_test
    def test_when_minions_all_return_then_all_collected_data_should_be_returned(self):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        # Timeout is something ridiculously high - it should never be reached
        gather_timeout = 20
        completed_events = [salt.ext.tornado.gen.Future() for _ in range(10)]
        events_by_id = {}
        for i, event in enumerate(completed_events):
            id_ = &quot;fnord {}&quot;.format(i)
            events_by_id[id_] = event
            event.set_result(
                {
                    &quot;tag&quot;: &quot;fnord&quot;,
                    &quot;data&quot;: {&quot;return&quot;: &quot;return from {}&quot;.format(id_), &quot;id&quot;: id_},
                }
            )
        expected_result = {
            &quot;fnord 0&quot;: &quot;return from fnord 0&quot;,
            &quot;fnord 1&quot;: &quot;return from fnord 1&quot;,
            &quot;fnord 2&quot;: &quot;return from fnord 2&quot;,
            &quot;fnord 3&quot;: &quot;return from fnord 3&quot;,
            &quot;fnord 4&quot;: &quot;return from fnord 4&quot;,
            &quot;fnord 5&quot;: &quot;return from fnord 5&quot;,
            &quot;fnord 6&quot;: &quot;return from fnord 6&quot;,
            &quot;fnord 7&quot;: &quot;return from fnord 7&quot;,
            &quot;fnord 8&quot;: &quot;return from fnord 8&quot;,
            &quot;fnord 9&quot;: &quot;return from fnord 9&quot;,
        }

        def fancy_get_event(*args, **kwargs):
            tag = kwargs.get(&quot;tag&quot;, &quot;&quot;).rpartition(&quot;/&quot;)[-1]
            return events_by_id.get(tag, never_completed)

        f = salt.ext.tornado.gen.Future()
        f.set_result(
            {
                &quot;jid&quot;: &quot;42&quot;,
                &quot;minions&quot;: [e.result()[&quot;data&quot;][&quot;id&quot;] for e in completed_events],
            }
        )
        with patch.object(
            self.handler.application.event_listener,
            &quot;get_event&quot;,
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.dict(
            self.handler.application.opts,
            {&quot;gather_job_timeout&quot;: gather_timeout, &quot;timeout&quot;: 42},
        ), patch.dict(
            self.handler.saltclients, {&quot;local&quot;: lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={&quot;tgt&quot;: &quot;*&quot;, &quot;tgt_type&quot;: &quot;glob&quot;, &quot;fun&quot;: &quot;test.ping&quot;}
            )

        assert result == expected_result

    @salt.ext.tornado.testing.gen_test
    def test_when_min_wait_time_has_not_passed_then_disbatch_should_not_return_expected_data_until_time_has_passed(
        self,
    ):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        wait_timer = salt.ext.tornado.gen.Future()
        gather_timeout = 20
        completed_events = [salt.ext.tornado.gen.Future() for _ in range(10)]
        events_by_id = {}
        # Setup some real-enough looking return data
        for i, event in enumerate(completed_events):
            id_ = &quot;fnord {}&quot;.format(i)
            events_by_id[id_] = event
            event.set_result(
                {
                    &quot;tag&quot;: &quot;fnord&quot;,
                    &quot;data&quot;: {&quot;return&quot;: &quot;return from {}&quot;.format(id_), &quot;id&quot;: id_},
                }
            )
        # Hard coded instead of dynamic to avoid potentially writing a test
        # that does nothing
        expected_result = {
            &quot;fnord 0&quot;: &quot;return from fnord 0&quot;,
            &quot;fnord 1&quot;: &quot;return from fnord 1&quot;,
            &quot;fnord 2&quot;: &quot;return from fnord 2&quot;,
            &quot;fnord 3&quot;: &quot;return from fnord 3&quot;,
            &quot;fnord 4&quot;: &quot;return from fnord 4&quot;,
            &quot;fnord 5&quot;: &quot;return from fnord 5&quot;,
            &quot;fnord 6&quot;: &quot;return from fnord 6&quot;,
            &quot;fnord 7&quot;: &quot;return from fnord 7&quot;,
            &quot;fnord 8&quot;: &quot;return from fnord 8&quot;,
            &quot;fnord 9&quot;: &quot;return from fnord 9&quot;,
        }

        # If this is one of our fnord events, return that future, otherwise
        # they're bogus events that are irrelevant to our current testing.
        # They get to wait for-ev-errrrr
        def fancy_get_event(*args, **kwargs):
            tag = kwargs.get(&quot;tag&quot;, &quot;&quot;).rpartition(&quot;/&quot;)[-1]
            return events_by_id.get(tag, never_completed)

        minions = {}

        def capture_minions(*args, **kwargs):
            &quot;&quot;&quot;
            Take minions that would be passed to a function, and
            store them for later checking.
            &quot;&quot;&quot;
            nonlocal minions
            minions = args[3]

        # Needed to have both a fake sleep, as well as a *real* sleep.
        # The fake sleep is necessary so that we can return our own
        # min_wait_time future. The fakeo_timer object is how we signal
        # which one we need to be returning.
        orig_sleep = salt.ext.tornado.gen.sleep

        fakeo_timer = object()

        @salt.ext.tornado.gen.coroutine
        def fake_sleep(timer):
            # only return our fake min_wait_time future when the sentinel
            # value is provided. Otherwise it's just a number.
            if timer is fakeo_timer:
                yield wait_timer
            else:
                yield orig_sleep(timer)

        f = salt.ext.tornado.gen.Future()
        f.set_result(
            {
                &quot;jid&quot;: &quot;42&quot;,
                &quot;minions&quot;: [e.result()[&quot;data&quot;][&quot;id&quot;] for e in completed_events],
            }
        )
        with patch.object(
            self.handler.application.event_listener,
            &quot;get_event&quot;,
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.object(
            self.handler,
            &quot;job_not_running&quot;,
            autospec=True,
            side_effect=capture_minions,
        ), patch.dict(
            self.handler.application.opts,
            {
                &quot;gather_job_timeout&quot;: gather_timeout,
                &quot;timeout&quot;: 42,
                &quot;syndic_wait&quot;: fakeo_timer,
                &quot;order_masters&quot;: True,
            },
        ), patch(
            &quot;salt.ext.tornado.gen.sleep&quot;,
            autospec=True,
            side_effect=fake_sleep,
        ), patch.dict(
            self.handler.saltclients, {&quot;local&quot;: lambda *args, **kwargs: f}
        ):

            # Example timeline that we're testing:
            #
            # If there's a min wait time of 10s, and all the results come
            # back in 5s, we still need to wait the full 10s.
            #
            # Here:
            # t=0, all events are completed
            # t=0.1, we check that all minions have been set to True, i.e. all
            #        events are completed. We also ensure that the future has
            #        not completed.
            # t=0.1+, we complete our injected timer, and then ensure that all
            #         the correct data has been returned.

            fut = self.handler._disbatch_local(
                chunk={&quot;tgt&quot;: &quot;*&quot;, &quot;tgt_type&quot;: &quot;glob&quot;, &quot;fun&quot;: &quot;test.ping&quot;}
            )

            def boop():
                yield fut

            self.io_loop.spawn_callback(boop)
            yield salt.ext.tornado.gen.sleep(0.1)
            # here, all the minions should be complete (i.e. &quot;True&quot;)
            assert all(minions[m_id] for m_id in minions)
            # But _disbatch_local is not returned yet because min_wait_time has not passed
            assert not fut.done()
            wait_timer.set_result(None)
            result = yield fut

        assert result == expected_result

    # Question: Currently, job_not_running can add to the minions dict, which
    # affects the more_todo result. However, the events are never added to
    # once we have entered the loop. I'm not sure if this is an oversight, or
    # simply an implicit expectation. I am making the assumption that this
    # behavior is correct and does not need extra testing. Otherwise, we should
    # be testing that when minions are added within job_not_running, that it
    # should affect the regular loop
    # -W. Werner, 2020-11-19
</PRE>
</div>
  </div>
</body>
</html>
