<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for sysmod.py &amp; test_saltnado.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for sysmod.py &amp; test_saltnado.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>sysmod.py (2.7874565%)<th>test_saltnado.py (1.2624934%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(851-853)<td><a href="#" name="0">(621-625)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(839-841)<td><a href="#" name="1">(401-404)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>sysmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import fnmatch
2 import logging
3 import salt.loader
4 import salt.runner
5 import salt.state
6 import salt.utils.args
7 import salt.utils.doc
8 import salt.utils.schema
9 log = logging.getLogger(__name__)
10 __virtualname__ = "sys"
11 __proxyenabled__ = ["*"]
12 def __virtual__():
13     return __virtualname__
14 def doc(*args):
15     docs = {}
16     if not args:
17         for fun in __salt__:
18             docs[fun] = __salt__[fun].__doc__
19         return salt.utils.doc.strip_rst(docs)
20     for module in args:
21         _use_fnmatch = False
22         if "*" in module:
23             target_mod = module
24             _use_fnmatch = True
25         elif module:
26             target_mod = module + "." if not module.endswith(".") else module
27         else:
28             target_mod = ""
29         if _use_fnmatch:
30             for fun in fnmatch.filter(__salt__, target_mod):
31                 docs[fun] = __salt__[fun].__doc__
32         else:
33             for fun in __salt__:
34                 if fun == module or fun.startswith(target_mod):
35                     docs[fun] = __salt__[fun].__doc__
36     return salt.utils.doc.strip_rst(docs)
37 def state_doc(*args):
38     st_ = salt.state.State(__opts__)
39     docs = {}
40     if not args:
41         for fun in st_.states:
42             state = fun.split(".")[0]
43             if state not in docs:
44                 if hasattr(st_.states[fun], "__globals__"):
45                     docs[state] = st_.states[fun].__globals__["__doc__"]
46             docs[fun] = st_.states[fun].__doc__
47         return salt.utils.doc.strip_rst(docs)
48     for module in args:
49         _use_fnmatch = False
50         if "*" in module:
51             target_mod = module
52             _use_fnmatch = True
53         elif module:
54             target_mod = module + "." if not module.endswith(".") else module
55         else:
56             target_mod = ""
57         if _use_fnmatch:
58             for fun in fnmatch.filter(st_.states, target_mod):
59                 state = fun.split(".")[0]
60                 if hasattr(st_.states[fun], "__globals__"):
61                     docs[state] = st_.states[fun].__globals__["__doc__"]
62                 docs[fun] = st_.states[fun].__doc__
63         else:
64             for fun in st_.states:
65                 if fun == module or fun.startswith(target_mod):
66                     state = module.split(".")[0]
67                     if state not in docs:
68                         if hasattr(st_.states[fun], "__globals__"):
69                             docs[state] = st_.states[fun].__globals__["__doc__"]
70                     docs[fun] = st_.states[fun].__doc__
71     return salt.utils.doc.strip_rst(docs)
72 def runner_doc(*args):
73     run_ = salt.runner.Runner(__opts__)
74     docs = {}
75     if not args:
76         for fun in run_.functions:
77             docs[fun] = run_.functions[fun].__doc__
78         return salt.utils.doc.strip_rst(docs)
79     for module in args:
80         _use_fnmatch = False
81         if "*" in module:
82             target_mod = module
83             _use_fnmatch = True
84         elif module:
85             target_mod = module + "." if not module.endswith(".") else module
86         else:
87             target_mod = ""
88         if _use_fnmatch:
89             for fun in fnmatch.filter(run_.functions, target_mod):
90                 docs[fun] = run_.functions[fun].__doc__
91         else:
92             for fun in run_.functions:
93                 if fun == module or fun.startswith(target_mod):
94                     docs[fun] = run_.functions[fun].__doc__
95     return salt.utils.doc.strip_rst(docs)
96 def returner_doc(*args):
97     returners_ = salt.loader.returners(__opts__, [])
98     docs = {}
99     if not args:
100         for fun in returners_:
101             docs[fun] = returners_[fun].__doc__
102         return salt.utils.doc.strip_rst(docs)
103     for module in args:
104         _use_fnmatch = False
105         if "*" in module:
106             target_mod = module
107             _use_fnmatch = True
108         elif module:
109             target_mod = module + "." if not module.endswith(".") else module
110         else:
111             target_mod = ""
112         if _use_fnmatch:
113             for fun in returners_:
114                 if fun == module or fun.startswith(target_mod):
115                     docs[fun] = returners_[fun].__doc__
116         else:
117             for fun in returners_.keys():
118                 if fun == module or fun.startswith(target_mod):
119                     docs[fun] = returners_[fun].__doc__
120     return salt.utils.doc.strip_rst(docs)
121 def renderer_doc(*args):
122     renderers_ = salt.loader.render(__opts__, [])
123     docs = {}
124     if not args:
125         for func in renderers_.keys():
126             docs[func] = renderers_[func].__doc__
127         return salt.utils.doc.strip_rst(docs)
128     for module in args:
129         if "*" in module or "." in module:
130             for func in fnmatch.filter(renderers_, module):
131                 docs[func] = renderers_[func].__doc__
132         else:
133             moduledot = module + "."
134             for func in renderers_.keys():
135                 if func.startswith(moduledot):
136                     docs[func] = renderers_[func].__doc__
137     return salt.utils.doc.strip_rst(docs)
138 def list_functions(*args, **kwargs):  # pylint: disable=unused-argument
139     if not args:
140         return sorted(__salt__)
141     names = set()
142     for module in args:
143         if "*" in module or "." in module:
144             for func in fnmatch.filter(__salt__, module):
145                 names.add(func)
146         else:
147             moduledot = module + "."
148             for func in __salt__:
149                 if func.startswith(moduledot):
150                     names.add(func)
151     return sorted(names)
152 def list_modules(*args):
153     modules = set()
154     if not args:
155         for func in __salt__:
156             modules.add(func.split(".")[0])
157         return sorted(modules)
158     for module in args:
159         if "*" in module:
160             for func in fnmatch.filter(__salt__, module):
161                 modules.add(func.split(".")[0])
162         else:
163             for func in __salt__:
164                 mod_test = func.split(".")[0]
165                 if mod_test == module:
166                     modules.add(mod_test)
167     return sorted(modules)
168 def reload_modules():
169     return True
170 def argspec(module=""):
171     return salt.utils.args.argspec_report(__salt__, module)
172 def state_argspec(module=""):
173     st_ = salt.state.State(__opts__)
174     return salt.utils.args.argspec_report(st_.states, module)
175 def returner_argspec(module=""):
176     returners_ = salt.loader.returners(__opts__, [])
177     return salt.utils.args.argspec_report(returners_, module)
178 def runner_argspec(module=""):
179     run_ = salt.runner.Runner(__opts__)
180     return salt.utils.args.argspec_report(run_.functions, module)
181 def list_state_functions(*args, **kwargs):  # pylint: disable=unused-argument
182     st_ = salt.state.State(__opts__)
183     if not args:
184         return sorted(st_.states)
185     names = set()
186     for module in args:
187         if "*" in module or "." in module:
188             for func in fnmatch.filter(st_.states, module):
189                 names.add(func)
190         else:
191             moduledot = module + "."
192             for func in st_.states:
193                 if func.startswith(moduledot):
194                     names.add(func)
195     return sorted(names)
196 def list_state_modules(*args):
197     st_ = salt.state.State(__opts__)
198     modules = set()
199     if not args:
200         for func in st_.states:
201             log.debug("func %s", func)
202             modules.add(func.split(".")[0])
203         return sorted(modules)
204     for module in args:
205         if "*" in module:
206             for func in fnmatch.filter(st_.states, module):
207                 modules.add(func.split(".")[0])
208         else:
209             for func in st_.states:
210                 mod_test = func.split(".")[0]
211                 if mod_test == module:
212                     modules.add(mod_test)
213     return sorted(modules)
214 def list_runners(*args):
215     run_ = salt.runner.Runner(__opts__)
216     runners = set()
217     if not args:
218         for func in run_.functions:
219             runners.add(func.split(".")[0])
220         return sorted(runners)
221     for module in args:
222         if "*" in module:
223             for func in fnmatch.filter(run_.functions, module):
224                 runners.add(func.split(".")[0])
225         else:
226             for func in run_.functions:
227                 mod_test = func.split(".")[0]
228                 if mod_test == module:
229                     runners.add(mod_test)
230     return sorted(runners)
231 def list_runner_functions(*args, **kwargs):  # pylint: disable=unused-argument
232     run_ = salt.runner.Runner(__opts__)
233     if not args:
234         return sorted(run_.functions)
235     names = set()
236     for module in args:
237         if "*" in module or "." in module:
238             for func in fnmatch.filter(run_.functions, module):
239                 names.add(func)
240         else:
241             moduledot = module + "."
242             for func in run_.functions:
243                 if func.startswith(moduledot):
244                     names.add(func)
245     return sorted(names)
246 def list_returners(*args):
247     returners_ = salt.loader.returners(__opts__, [])
248     returners = set()
249     if not args:
250         for func in returners_.keys():
251             returners.add(func.split(".")[0])
252         return sorted(returners)
253     for module in args:
254         if "*" in module:
255             for func in fnmatch.filter(returners_, module):
256                 returners.add(func.split(".")[0])
257         else:
258             for func in returners_:
259                 mod_test = func.split(".")[0]
260                 if mod_test == module:
261                     returners.add(mod_test)
262     return sorted(returners)
263 def list_returner_functions(*args, **kwargs):  # pylint: disable=unused-argument
264     returners_ = salt.loader.returners(__opts__, [])
265     if not args:
266         return sorted(returners_)
267     names = set()
268     for module in args:
269         if "*" in module or "." in module:
270             for func in fnmatch.filter(returners_, module):
271                 names.add(func)
272         else:
273             moduledot = module + "."
274             for func in returners_:
275                 if func.startswith(moduledot):
276                     names.add(func)
277     return sorted(names)
278 def list_renderers(*args):
279     renderers_ = salt.loader.render(__opts__, [])
280     renderers = set()
281     if not args:
282         for rend in renderers_.keys():
283             renderers.add(rend)
284         return sorted(renderers)
285     for module in args:
286         for rend in fnmatch.filter(renderers_, module):
287             renderers.add(rend)
288     return sorted(renderers)
289 def _argspec_to_schema(mod, spec):
290     args = spec["args"]
291     defaults = spec["defaults"] or []
292     args_req = args[: len(args) - len(defaults)]
293     args_defaults = list(zip(args[-len(defaults) :], defaults))
294     types = {
295         "title": mod,
296         "description": mod,
297     for i in args_req:
298         types[i] = salt<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.schema.OneOfItem(
299             items=(
300                 salt.utils.schema.BooleanItem(title=i, description=</b></font>i, required=True),
301                 salt.utils.schema.IntegerItem(title=i, description=i, required=True),
302                 salt.utils.schema.NumberItem(title=i, description=i, required=True),
303                 salt.utils.schema.StringItem(title=i, description=i, required=True),
304             )
305     for i, j in args_defaults:
306         types[i] = salt<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.schema.OneOfItem(
307             items=(
308                 salt.utils.schema.BooleanItem(title=i, description=</b></font>i, default=j),
309                 salt.utils.schema.IntegerItem(title=i, description=i, default=j),
310                 salt.utils.schema.NumberItem(title=i, description=i, default=j),
311                 salt.utils.schema.StringItem(title=i, description=i, default=j),
312             )
313         )
314     return type(mod, (salt.utils.schema.Schema,), types).serialize()
315 def state_schema(module=""):
316     specs = state_argspec(module)
317     schemas = []
318     for state_mod, state_spec in specs.items():
319         schemas.append(_argspec_to_schema(state_mod, state_spec))
320     return schemas
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltnado.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.ext.tornado
2 import salt.ext.tornado.testing
3 import salt.netapi.rest_tornado.saltnado as saltnado
4 from tests.support.mock import MagicMock, patch
5 class TestJobNotRunning(salt.ext.tornado.testing.AsyncTestCase):
6     def setUp(self):
7         super().setUp()
8         self.mock = MagicMock()
9         self.mock.opts = {
10             "syndic_wait": 0.1,
11             "cachedir": "/tmp/testing/cachedir",
12             "sock_dir": "/tmp/testing/sock_drawer",
13             "transport": "zeromq",
14             "extension_modules": "/tmp/testing/moduuuuules",
15             "order_masters": False,
16             "gather_job_timeout": 10.001,
17         }
18         self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
19         self.handler._write_buffer = []
20         self.handler._transforms = []
21         self.handler.lowstate = []
22         self.handler.content_type = "text/plain"
23         self.handler.dumper = lambda x: x
24         f = salt.ext.tornado.gen.Future()
25         f.set_result({"jid": f, "minions": []})
26         self.handler.saltclients.update({"local": lambda *args, **kwargs: f})
27     @salt.ext.tornado.testing.gen_test
28     def test_when_disbatch_has_already_finished_then_writing_return_should_not_fail(
29         self,
30     ):
31         self.handler.finish()
32         result = yield self.handler.disbatch()
33     @salt.ext.tornado.testing.gen_test
34     def test_when_disbatch_has_already_finished_then_finishing_should_not_fail(self):
35         self.handler.finish()
36         result = yield self.handler.disbatch()
37     @salt.ext.tornado.testing.gen_test
38     def test_when_event_times_out_and_minion_is_not_running_result_should_be_True(self):
39         fut = salt.ext.tornado.gen.Future()
40         fut.set_exception(saltnado.TimeoutException())
41         self.mock.event_listener.get_event.return_value = fut
42         wrong_future = salt.ext.tornado.gen.Future()
43         result = yield self.handler.job_not_running(
44             jid=42, tgt="*", tgt_type="glob", minions=[], is_finished=wrong_future
45         )
46         self.assertTrue(result)
47     @salt.ext.tornado.testing.gen_test
48     def test_when_event_times_out_and_minion_is_not_running_minion_data_should_not_be_set(
49         self,
50     ):
51         fut = salt.ext.tornado.gen.Future()
52         fut.set_exception(saltnado.TimeoutException())
53         self.mock.event_listener.get_event.return_value = fut
54         wrong_future = salt.ext.tornado.gen.Future()
55         minions = {}
56         result = yield self.handler.job_not_running(
57             jid=42, tgt="*", tgt_type="glob", minions=minions, is_finished=wrong_future
58         )
59         assert not minions
60     @salt.ext.tornado.testing.gen_test
61     def test_when_event_finally_finishes_and_returned_minion_not_in_minions_it_should_be_set_to_False(
62         self,
63     ):
64         expected_id = 42
65         no_data_event = salt.ext.tornado.gen.Future()
66         no_data_event.set_result({"data": {}})
67         empty_return_event = salt.ext.tornado.gen.Future()
68         empty_return_event.set_result({"data": {"return": {}}})
69         actual_return_event = salt.ext.tornado.gen.Future()
70         actual_return_event.set_result(
71             {"data": {"return": {"something happened here": "OK?"}, "id": expected_id}}
72         )
73         timed_out_event = salt.ext.tornado.gen.Future()
74         timed_out_event.set_exception(saltnado.TimeoutException())
75         self.mock.event_listener.get_event.side_effect = [
76             no_data_event,
77             empty_return_event,
78             actual_return_event,
79             timed_out_event,
80             timed_out_event,
81         ]
82         minions = {}
83         yield self.handler.job_not_running(
84             jid=99,
85             tgt="*",
86             tgt_type="fnord",
87             minions=minions,
88             is_finished=salt.ext.tornado.gen.Future(),
89         )
90         self.assertFalse(minions[expected_id])
91     @salt.ext.tornado.testing.gen_test
92     def test_when_event_finally_finishes_and_returned_minion_already_in_minions_it_should_not_be_changed(
93         self,
94     ):
95         expected_id = 42
96         expected_value = object()
97         minions = {expected_id: expected_value}
98         no_data_event = salt.ext.tornado.gen.Future()
99         no_data_event.set_result({"data": {}})
100         empty_return_event = salt.ext.tornado.gen.Future()
101         empty_return_event.set_result({"data": {"return": {}}})
102         actual_return_event = salt.ext.tornado.gen.Future()
103         actual_return_event.set_result(
104             {"data": {"return": {"something happened here": "OK?"}, "id": expected_id}}
105         )
106         timed_out_event = salt.ext.tornado.gen.Future()
107         timed_out_event.set_exception(saltnado.TimeoutException())
108         self.mock.event_listener.get_event.side_effect = [
109             no_data_event,
110             empty_return_event,
111             actual_return_event,
112             timed_out_event,
113             timed_out_event,
114         ]
115         yield self.handler.job_not_running(
116             jid=99,
117             tgt="*",
118             tgt_type="fnord",
119             minions=minions,
120             is_finished=salt.ext.tornado.gen.Future(),
121         )
122         self.assertIs(minions[expected_id], expected_value)
123     @salt.ext.tornado.testing.gen_test
124     def test_when_event_returns_early_and_finally_times_out_result_should_be_True(self):
125         no_data_event = salt.ext.tornado.gen.Future()
126         no_data_event.set_result({"data": {}})
127         empty_return_event = salt.ext.tornado.gen.Future()
128         empty_return_event.set_result({"data": {"return": {}}})
129         actual_return_event = salt.ext.tornado.gen.Future()
130         actual_return_event.set_result(
131             {"data": {"return": {"something happened here": "OK?"}, "id": "fnord"}}
132         )
133         timed_out_event = salt.ext.tornado.gen.Future()
134         timed_out_event.set_exception(saltnado.TimeoutException())
135         self.mock.event_listener.get_event.side_effect = [
136             no_data_event,
137             empty_return_event,
138             actual_return_event,
139             timed_out_event,
140             timed_out_event,
141         ]
142         result = yield self.handler.job_not_running(
143             jid=99,
144             tgt="*",
145             tgt_type="fnord",
146             minions={},
147             is_finished=salt.ext.tornado.gen.Future(),
148         )
149         self.assertTrue(result)
150     @salt.ext.tornado.testing.gen_test
151     def test_when_event_finishes_but_is_finished_is_done_then_result_should_be_True(
152         self,
153     ):
154         expected_minion_id = "fnord"
155         expected_minion_value = object()
156         no_data_event = salt.ext.tornado.gen.Future()
157         no_data_event.set_result({"data": {}})
158         empty_return_event = salt.ext.tornado.gen.Future()
159         empty_return_event.set_result({"data": {"return": {}}})
160         actual_return_event = salt.ext.tornado.gen.Future()
161         actual_return_event.set_result(
162             {
163                 "data": {
164                     "return": {"something happened here": "OK?"},
165                     "id": expected_minion_id,
166                 }
167             }
168         )
169         is_finished = salt.ext.tornado.gen.Future()
170         def abort(*args, **kwargs):
171             yield actual_return_event
172             f = salt.ext.tornado.gen.Future()
173             f.set_exception(saltnado.TimeoutException())
174             is_finished.set_result("This is done")
175             yield f
176             assert False, "Never should make it here"
177         minions = {expected_minion_id: expected_minion_value}
178         self.mock.event_listener.get_event.side_effect = (x for x in abort())
179         result = yield self.handler.job_not_running(
180             jid=99,
181             tgt="*",
182             tgt_type="fnord",
183             minions=minions,
184             is_finished=is_finished,
185         )
186         self.assertTrue(result)
187         self.assertTrue(len(minions) == 1, str(minions))
188         self.assertIs(minions[expected_minion_id], expected_minion_value)
189     @salt.ext.tornado.testing.gen_test
190     def test_when_is_finished_times_out_before_event_finishes_result_should_be_True(
191         self,
192     ):
193         finished = salt.ext.tornado.gen.Future()
194         finished.set_exception(saltnado.TimeoutException())
195         wrong_future = salt.ext.tornado.gen.Future()
196         self.mock.event_listener.get_event.return_value = wrong_future
197         result = yield self.handler.job_not_running(
198             jid=42, tgt="*", tgt_type="glob", minions=[], is_finished=finished
199         )
200         self.assertTrue(result)
201     @salt.ext.tornado.testing.gen_test
202     def test_when_is_finished_times_out_before_event_finishes_event_should_have_result_set_to_None(
203         self,
204     ):
205         finished = salt.ext.tornado.gen.Future()
206         finished.set_exception(saltnado.TimeoutException())
207         wrong_future = salt.ext.tornado.gen.Future()
208         self.mock.event_listener.get_event.return_value = wrong_future
209         result = yield self.handler.job_not_running(
210             jid=42, tgt="*", tgt_type="glob", minions=[], is_finished=finished
211         )
212         self.assertIsNone(wrong_future.result())
213 class TestGetMinionReturns(salt.ext.tornado.testing.AsyncTestCase):
214     def setUp(self):
215         super().setUp()
216         self.mock = MagicMock()
217         self.mock.opts = {
218             "syndic_wait": 0.1,
219             "cachedir": "/tmp/testing/cachedir",
220             "sock_dir": "/tmp/testing/sock_drawer",
221             "transport": "zeromq",
222             "extension_modules": "/tmp/testing/moduuuuules",
223             "order_masters": False,
224             "gather_job_timeout": 10.001,
225         }
226         self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
227         f = salt.ext.tornado.gen.Future()
228         f.set_result({"jid": f, "minions": []})
229     @salt.ext.tornado.testing.gen_test
230     def test_if_finished_before_any_events_return_then_result_should_be_empty_dictionary(
231         self,
232     ):
233         expected_result = {}
234         xxx = salt.ext.tornado.gen.Future()
235         xxx.set_result(None)
236         is_finished = salt.ext.tornado.gen.Future()
237         is_finished.set_result(None)
238         actual_result = yield self.handler.get_minion_returns(
239             events=[],
240             is_finished=is_finished,
241             is_timed_out=salt.ext.tornado.gen.Future(),
242             min_wait_time=xxx,
243             minions={},
244         )
245         self.assertDictEqual(actual_result, expected_result)
246     @salt.ext.tornado.testing.gen_test
247     def test_if_is_finished_after_events_return_then_result_should_contain_event_result_data(
248         self,
249     ):
250         expected_result = {
251             "minion1": {"fnord": "this is some fnordish data"},
252             "minion2": {"fnord": "this is some other fnordish data"},
253         }
254         xxx = salt.ext.tornado.gen.Future()
255         xxx.set_result(None)
256         is_finished = salt.ext.tornado.gen.Future()
257         events = [
258             salt.ext.tornado.gen.Future(),
259             salt.ext.tornado.gen.Future(),
260             salt.ext.tornado.gen.Future(),
261             salt.ext.tornado.gen.Future(),
262         ]
263         events[0].set_result(
264             {
265                 "tag": "fnord",
266                 "data": {"id": "minion1", "return": expected_result["minion1"]},
267             }
268         )
269         events[1].set_result(
270             {
271                 "tag": "fnord",
272                 "data": {"id": "minion2", "return": expected_result["minion2"]},
273             }
274         )
275         self.io_loop.call_later(0.2, lambda: is_finished.set_result(None))
276         actual_result = yield self.handler.get_minion_returns(
277             events=events,
278             is_finished=is_finished,
279             is_timed_out=salt.ext.tornado.gen.Future(),
280             min_wait_time=xxx,
281             minions={
282                 "minion1": False,
283                 "minion2": False,
284                 "never returning minion": False,
285             },
286         )
287         assert actual_result == expected_result
288     @salt.ext.tornado.testing.gen_test
289     def test_if_timed_out_after_events_return_then_result_should_contain_event_result_data(
290         self,
291     ):
292         expected_result = {
293             "minion1": {"fnord": "this is some fnordish data"},
294             "minion2": {"fnord": "this is some other fnordish data"},
295         }
296         xxx = salt.ext.tornado.gen.Future()
297         xxx.set_result(None)
298         is_timed_out = salt.ext.tornado.gen.Future()
299         events = [
300             salt.ext.tornado.gen.Future(),
301             salt.ext.tornado.gen.Future(),
302             salt.ext.tornado.gen.Future(),
303             salt.ext.tornado.gen.Future(),
304         ]
305         events[0].set_result(
306             {
307                 "tag": "fnord",
308                 "data": {"id": "minion1", "return": expected_result["minion1"]},
309             }
310         )
311         events[1].set_result(
312             {
313                 "tag": "fnord",
314                 "data": {"id": "minion2", "return": expected_result["minion2"]},
315             }
316         )
317         self.io_loop.call_later(0.2, lambda: is_timed_out.set_result(None))
318         actual_result = yield self.handler.get_minion_returns(
319             events=events,
320             is_finished=salt.ext.tornado.gen.Future(),
321             is_timed_out=is_timed_out,
322             min_wait_time=xxx,
323             minions={
324                 "minion1": False,
325                 "minion2": False,
326                 "never returning minion": False,
327             },
328         )
329         assert actual_result == expected_result
330     @salt.ext.tornado.testing.gen_test
331     def test_if_wait_timer_is_not_done_even_though_results_are_then_data_should_not_yet_be_returned(
332         self,
333     ):
334         expected_result = {
335             "one": {"fnordy one": "one has some data"},
336             "two": {"fnordy two": "two has some data"},
337         }
338         events = [salt.ext.tornado.gen.Future(), salt.ext.tornado.gen.Future()]
339         events[0].set_result(
340             {"tag": "fnord", "data": {"id": "one", "return": expected_result["one"]}}
341         )
342         events[1].set_result(
343             {"tag": "fnord", "data": {"id": "two", "return": expected_result["two"]}}
344         )
345         fut = self.handler.get_minion_returns(
346             events=events,
347             is_finished=salt.ext<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.tornado.gen.Future(),
348             is_timed_out=salt.ext.tornado.gen.Future(),
349             min_wait_time=wait_timer,
350             minions=</b></font>{"one": False, "two": False},
351         )
352         def boop():
353             yield fut
354         self.io_loop.spawn_callback(boop)
355         yield salt.ext.tornado.gen.sleep(0.1)
356         assert not fut.done()
357         wait_timer.set_result(None)
358         actual_result = yield fut
359         assert actual_result == expected_result
360     @salt.ext.tornado.testing.gen_test
361     def test_when_is_finished_any_other_futures_should_be_canceled(self):
362         events = [
363             salt.ext.tornado.gen.Future(),
364             salt.ext.tornado.gen.Future(),
365             salt.ext.tornado.gen.Future(),
366             salt.ext.tornado.gen.Future(),
367             salt.ext.tornado.gen.Future(),
368         ]
369         is_finished = salt.ext.tornado.gen.Future()
370         is_finished.set_result(None)
371         yield self.handler.get_minion_returns(
372             events=events,
373             is_finished=is_finished,
374             is_timed_out=salt.ext.tornado.gen.Future(),
375             min_wait_time=salt.ext.tornado.gen.Future(),
376             minions={"one": False, "two": False},
377         )
378         are_done = [event.done() for event in events]
379         assert all(are_done)
380     @salt.ext.tornado.testing.gen_test
381     def test_when_an_event_times_out_then_we_should_not_enter_an_infinite_loop(self):
382         events = [
383             salt.ext.tornado.gen.Future(),
384             salt.ext.tornado.gen.Future(),
385             salt.ext.tornado.gen.Future(),
386             salt.ext.tornado.gen.Future(),
387             salt.ext.tornado.gen.Future(),
388         ]
389         events[3].set_exception(saltnado.TimeoutException())
390         times_out_later = salt.ext.tornado.gen.Future()
391         self.io_loop.call_later(0.5, lambda: times_out_later.set_result(None))
392         yield self.handler.get_minion_returns(
393             events=events,
394             is_finished=salt.ext.tornado.gen.Future(),
395             is_timed_out=times_out_later,
396             min_wait_time=salt.ext.tornado.gen.Future(),
397             minions={"one": False, "two": False},
398         )
399         are_done = [event.done() for event in events]
400         assert all(are_done)
401         assert times_out_later.done()
402     @salt.ext.tornado.testing.gen_test
403     def test_when_is_timed_out_any_other_futures_should_be_canceled(self):
404         events = [
405             salt.ext.tornado.gen.Future(),
406             salt.ext.tornado.gen.Future(),
407             salt.ext.tornado.gen.Future(),
408             salt.ext.tornado.gen.Future(),
409             salt.ext.tornado.gen.Future(),
410         ]
411         is_timed_out = salt.ext.tornado.gen.Future()
412         is_timed_out.set_result(None)
413         yield self.handler.get_minion_returns(
414             events=events,
415             is_finished=salt.ext.tornado.gen.Future(),
416             is_timed_out=is_timed_out,
417             min_wait_time=salt.ext.tornado.gen.Future(),
418             minions={"one": False, "two": False},
419         )
420         are_done = [event.done() for event in events]
421         assert all(are_done)
422     @salt.ext.tornado.testing.gen_test
423     def test_when_min_wait_time_and_nothing_todo_any_other_futures_should_be_canceled(
424         self,
425     ):
426         events = [
427             salt.ext.tornado.gen.Future(),
428             salt.ext.tornado.gen.Future(),
429             salt.ext.tornado.gen.Future(),
430             salt.ext.tornado.gen.Future(),
431             salt.ext.tornado.gen.Future(),
432         ]
433         is_finished = salt.ext.tornado.gen.Future()
434         min_wait_time = salt.ext.tornado.gen.Future()
435         self.io_loop.call_later(0.2, lambda: min_wait_time.set_result(None))
436         yield self.handler.get_minion_returns(
437             events=events,
438             is_finished=is_finished,
439             is_timed_out=salt.ext.tornado.gen.Future(),
440             min_wait_time=min_wait_time,
441             minions={"one": True, "two": True},
442         )
443         are_done = [event.done() for event in events] + [is_finished.done()]
444         assert all(are_done)
445     @salt.ext.tornado.testing.gen_test
446     def test_when_is_finished_but_not_is_timed_out_then_timed_out_should_not_be_set_to_done(
447         self,
448     ):
449         events = [salt.ext.tornado.gen.Future()]
450         is_timed_out = salt.ext.tornado.gen.Future()
451         is_finished = salt.ext.tornado.gen.Future()
452         is_finished.set_result(None)
453         yield self.handler.get_minion_returns(
454             events=events,
455             is_finished=is_finished,
456             is_timed_out=is_timed_out,
457             min_wait_time=salt.ext.tornado.gen.Future(),
458             minions={"one": False, "two": False},
459         )
460         assert not is_timed_out.done()
461     @salt.ext.tornado.testing.gen_test
462     def test_when_min_wait_time_and_all_completed_but_not_is_timed_out_then_timed_out_should_not_be_set_to_done(
463         self,
464     ):
465         events = [salt.ext.tornado.gen.Future()]
466         is_timed_out = salt.ext.tornado.gen.Future()
467         min_wait_time = salt.ext.tornado.gen.Future()
468         self.io_loop.call_later(0.2, lambda: min_wait_time.set_result(None))
469         yield self.handler.get_minion_returns(
470             events=events,
471             is_finished=salt.ext.tornado.gen.Future(),
472             is_timed_out=is_timed_out,
473             min_wait_time=min_wait_time,
474             minions={"one": True},
475         )
476         assert not is_timed_out.done()
477     @salt.ext.tornado.testing.gen_test
478     def test_when_things_are_completed_but_not_timed_out_then_timed_out_event_should_not_be_done(
479         self,
480     ):
481         events = [
482             salt.ext.tornado.gen.Future(),
483         ]
484         events[0].set_result({"tag": "fnord", "data": {"id": "one", "return": {}}})
485         min_wait_time = salt.ext.tornado.gen.Future()
486         min_wait_time.set_result(None)
487         is_timed_out = salt.ext.tornado.gen.Future()
488         yield self.handler.get_minion_returns(
489             events=events,
490             is_finished=salt.ext.tornado.gen.Future(),
491             is_timed_out=is_timed_out,
492             min_wait_time=min_wait_time,
493             minions={"one": True},
494         )
495         assert not is_timed_out.done()
496 class TestDisbatchLocal(salt.ext.tornado.testing.AsyncTestCase):
497     def setUp(self):
498         super().setUp()
499         self.mock = MagicMock()
500         self.mock.opts = {
501             "syndic_wait": 0.1,
502             "cachedir": "/tmp/testing/cachedir",
503             "sock_dir": "/tmp/testing/sock_drawer",
504             "transport": "zeromq",
505             "extension_modules": "/tmp/testing/moduuuuules",
506             "order_masters": False,
507             "gather_job_timeout": 10.001,
508         }
509         self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
510     @salt.ext.tornado.testing.gen_test
511         self,
512     ):
513         completed_event = salt.ext<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.tornado.gen.Future()
514         never_completed = salt.ext.tornado.gen.Future()
515         gather_timeout = 0.1
516         event_timeout =</b></font> gather_timeout + 0.05
517         def fancy_get_event(*args, **kwargs):
518             if kwargs.get("tag").endswith("/ret"):
519                 return never_completed
520             return completed_event
521         def completer():
522             completed_event.set_result(
523                 {
524                     "tag": "fnord",
525                     "data": {
526                         "return": "This should never be in chunk_ret",
527                         "id": "fnord",
528                     },
529                 }
530             )
531         self.io_loop.call_later(event_timeout, completer)
532         f = salt.ext.tornado.gen.Future()
533         f.set_result({"jid": "42", "minions": []})
534         with patch.object(
535             self.handler.application.event_listener,
536             "get_event",
537             autospec=True,
538             side_effect=fancy_get_event,
539         ), patch.dict(
540             self.handler.application.opts,
541             {"gather_job_timeout": gather_timeout, "timeout": 42},
542         ), patch.dict(
543             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
544         ):
545             result = yield self.handler._disbatch_local(
546                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
547             )
548         assert result == {}
549     @salt.ext.tornado.testing.gen_test
550     def test_when_is_finished_is_set_before_events_return_then_no_data_should_be_returned(
551         self,
552     ):
553         completed_event = salt.ext.tornado.gen.Future()
554         never_completed = salt.ext.tornado.gen.Future()
555         gather_timeout = 2
556         event_timeout = gather_timeout - 1
557         def fancy_get_event(*args, **kwargs):
558             if kwargs.get("tag").endswith("/ret"):
559                 return never_completed
560             return completed_event
561         def completer():
562             completed_event.set_result(
563                 {
564                     "tag": "fnord",
565                     "data": {
566                         "return": "This should never be in chunk_ret",
567                         "id": "fnord",
568                     },
569                 }
570             )
571         self.io_loop.call_later(event_timeout, completer)
572         def toggle_is_finished(*args, **kwargs):
573             finished = kwargs.get("is_finished", args[4] if len(args) &gt; 4 else None)
574             assert finished is not None
575             finished.set_result(42)
576         f = salt.ext.tornado.gen.Future()
577         f.set_result({"jid": "42", "minions": []})
578         with patch.object(
579             self.handler.application.event_listener,
580             "get_event",
581             autospec=True,
582             side_effect=fancy_get_event,
583         ), patch.object(
584             self.handler,
585             "job_not_running",
586             autospec=True,
587             side_effect=toggle_is_finished,
588         ), patch.dict(
589             self.handler.application.opts,
590             {"gather_job_timeout": gather_timeout, "timeout": 42},
591         ), patch.dict(
592             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
593         ):
594             result = yield self.handler._disbatch_local(
595                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
596             )
597         assert result == {}
598     @salt.ext.tornado.testing.gen_test
599     def test_when_is_finished_then_all_collected_data_should_be_returned(self):
600         completed_event = salt.ext.tornado.gen.Future()
601         never_completed = salt.ext.tornado.gen.Future()
602         gather_timeout = 42
603         completed_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
604         for i, event in enumerate(completed_events):
605             event.set_result(
606                 {
607                     "tag": "fnord",
608                     "data": {
609                         "return": "return from fnord {}".format(i),
610                         "id": "fnord {}".format(i),
611                     },
612                 }
613             )
614         uncompleted_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
615         events = iter(completed_events + uncompleted_events)
616         expected_result = {
617             "fnord 0": "return from fnord 0",
618             "fnord 1": "return from fnord 1",
619             "fnord 2": "return from fnord 2",
620             "fnord 3": "return from fnord 3",
621             "fnord 4": "return from fnord 4",
622         }
623         def fancy_get_event(*args, **kwargs):
624             if kwargs.get("tag").endswith("/ret"):
625                 return never_completed
626             else:
627                 return next(events)
628         def toggle_is_finished(*args, **kwargs):
629             finished = kwargs.get("is_finished", args[4] if len(args) &gt; 4 else None)
630             assert finished is not None
631             finished.set_result(42)
632         f = salt.ext.tornado.gen.Future()
633         f.set_result({"jid": "42", "minions": ["non-existent minion"]})
634         with patch.object(
635             self.handler.application.event_listener,
636             "get_event",
637             autospec=True,
638             side_effect=fancy_get_event,
639         ), patch.object(
640             self.handler,
641             "job_not_running",
642             autospec=True,
643             side_effect=toggle_is_finished,
644         ), patch.dict(
645             self.handler.application.opts,
646             {"gather_job_timeout": gather_timeout, "timeout": 42},
647         ), patch.dict(
648             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
649         ):
650             result = yield self.handler._disbatch_local(
651                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
652             )
653         assert result == expected_result
654     @salt.ext.tornado.testing.gen_test
655     def test_when_is_timed_out_then_all_collected_data_should_be_returned(self):
656         completed_event = salt.ext.tornado.gen.Future()
657         never_completed = salt.ext.tornado.gen.Future()
658         gather_timeout = 2
659         completed_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
660         for i, event in enumerate(completed_events):
661             event.set_result(
662                 {
663                     "tag": "fnord",
664                     "data": {
665                         "return": "return from fnord {}".format(i),
666                         "id": "fnord {}".format(i),
667                     },
668                 }
669             )
670         uncompleted_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
671         events = iter(completed_events + uncompleted_events)
672         expected_result = {
673             "fnord 0": "return from fnord 0",
674             "fnord 1": "return from fnord 1",
675             "fnord 2": "return from fnord 2",
676             "fnord 3": "return from fnord 3",
677             "fnord 4": "return from fnord 4",
678         }
679         def fancy_get_event(*args, **kwargs):
680             if kwargs.get("tag").endswith("/ret"):
681                 return never_completed
682             else:
683                 return next(events)
684         f = salt.ext.tornado.gen.Future()
685         f.set_result({"jid": "42", "minions": ["non-existent minion"]})
686         with patch.object(
687             self.handler.application.event_listener,
688             "get_event",
689             autospec=True,
690             side_effect=fancy_get_event,
691         ), patch.dict(
692             self.handler.application.opts,
693             {"gather_job_timeout": gather_timeout, "timeout": 42},
694         ), patch.dict(
695             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
696         ):
697             result = yield self.handler._disbatch_local(
698                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
699             )
700         assert result == expected_result
701     @salt.ext.tornado.testing.gen_test
702     def test_when_minions_all_return_then_all_collected_data_should_be_returned(self):
703         completed_event = salt.ext.tornado.gen.Future()
704         never_completed = salt.ext.tornado.gen.Future()
705         gather_timeout = 20
706         completed_events = [salt.ext.tornado.gen.Future() for _ in range(10)]
707         events_by_id = {}
708         for i, event in enumerate(completed_events):
709             id_ = "fnord {}".format(i)
710             events_by_id[id_] = event
711             event.set_result(
712                 {
713                     "tag": "fnord",
714                     "data": {"return": "return from {}".format(id_), "id": id_},
715                 }
716             )
717         expected_result = {
718             "fnord 0": "return from fnord 0",
719             "fnord 1": "return from fnord 1",
720             "fnord 2": "return from fnord 2",
721             "fnord 3": "return from fnord 3",
722             "fnord 4": "return from fnord 4",
723             "fnord 5": "return from fnord 5",
724             "fnord 6": "return from fnord 6",
725             "fnord 7": "return from fnord 7",
726             "fnord 8": "return from fnord 8",
727             "fnord 9": "return from fnord 9",
728         }
729         def fancy_get_event(*args, **kwargs):
730             tag = kwargs.get("tag", "").rpartition("/")[-1]
731             return events_by_id.get(tag, never_completed)
732         f = salt.ext.tornado.gen.Future()
733         f.set_result(
734             {
735                 "jid": "42",
736                 "minions": [e.result()["data"]["id"] for e in completed_events],
737             }
738         )
739         with patch.object(
740             self.handler.application.event_listener,
741             "get_event",
742             autospec=True,
743             side_effect=fancy_get_event,
744         ), patch.dict(
745             self.handler.application.opts,
746             {"gather_job_timeout": gather_timeout, "timeout": 42},
747         ), patch.dict(
748             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
749         ):
750             result = yield self.handler._disbatch_local(
751                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
752             )
753         assert result == expected_result
754     @salt.ext.tornado.testing.gen_test
755     def test_when_min_wait_time_has_not_passed_then_disbatch_should_not_return_expected_data_until_time_has_passed(
756         self,
757     ):
758         completed_event = salt.ext.tornado.gen.Future()
759         never_completed = salt.ext.tornado.gen.Future()
760         wait_timer = salt.ext.tornado.gen.Future()
761         gather_timeout = 20
762         completed_events = [salt.ext.tornado.gen.Future() for _ in range(10)]
763         events_by_id = {}
764         for i, event in enumerate(completed_events):
765             id_ = "fnord {}".format(i)
766             events_by_id[id_] = event
767             event.set_result(
768                 {
769                     "tag": "fnord",
770                     "data": {"return": "return from {}".format(id_), "id": id_},
771                 }
772             )
773         expected_result = {
774             "fnord 0": "return from fnord 0",
775             "fnord 1": "return from fnord 1",
776             "fnord 2": "return from fnord 2",
777             "fnord 3": "return from fnord 3",
778             "fnord 4": "return from fnord 4",
779             "fnord 5": "return from fnord 5",
780             "fnord 6": "return from fnord 6",
781             "fnord 7": "return from fnord 7",
782             "fnord 8": "return from fnord 8",
783             "fnord 9": "return from fnord 9",
784         }
785         def fancy_get_event(*args, **kwargs):
786             tag = kwargs.get("tag", "").rpartition("/")[-1]
787             return events_by_id.get(tag, never_completed)
788         minions = {}
789         def capture_minions(*args, **kwargs):
790             nonlocal minions
791             minions = args[3]
792         orig_sleep = salt.ext.tornado.gen.sleep
793         fakeo_timer = object()
794         @salt.ext.tornado.gen.coroutine
795         def fake_sleep(timer):
796             if timer is fakeo_timer:
797                 yield wait_timer
798             else:
799                 yield orig_sleep(timer)
800         f = salt.ext.tornado.gen.Future()
801         f.set_result(
802             {
803                 "jid": "42",
804                 "minions": [e.result()["data"]["id"] for e in completed_events],
805             }
806         )
807         with patch.object(
808             self.handler.application.event_listener,
809             "get_event",
810             autospec=True,
811             side_effect=fancy_get_event,
812         ), patch.object(
813             self.handler,
814             "job_not_running",
815             autospec=True,
816             side_effect=capture_minions,
817         ), patch.dict(
818             self.handler.application.opts,
819             {
820                 "gather_job_timeout": gather_timeout,
821                 "timeout": 42,
822                 "syndic_wait": fakeo_timer,
823                 "order_masters": True,
824             },
825         ), patch(
826             "salt.ext.tornado.gen.sleep",
827             autospec=True,
828             side_effect=fake_sleep,
829         ), patch.dict(
830             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
831         ):
832             fut = self.handler._disbatch_local(
833                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
834             )
835             def boop():
836                 yield fut
837             self.io_loop.spawn_callback(boop)
838             yield salt.ext.tornado.gen.sleep(0.1)
839             assert all(minions[m_id] for m_id in minions)
840             assert not fut.done()
841             wait_timer.set_result(None)
842             result = yield fut
843         assert result == expected_result
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
