<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for sysmod.py &amp; test_saltnado.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for sysmod.py &amp; test_saltnado.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>sysmod.py (2.7874565%)<th>test_saltnado.py (1.2624934%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(851-853)<td><a href="#" name="0">(621-625)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(839-841)<td><a href="#" name="1">(401-404)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>sysmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import fnmatch
import logging
import salt.loader
import salt.runner
import salt.state
import salt.utils.args
import salt.utils.doc
import salt.utils.schema
log = logging.getLogger(__name__)
__virtualname__ = "sys"
__proxyenabled__ = ["*"]
def __virtual__():
    return __virtualname__
def doc(*args):
    docs = {}
    if not args:
        for fun in __salt__:
            docs[fun] = __salt__[fun].__doc__
        return salt.utils.doc.strip_rst(docs)
    for module in args:
        _use_fnmatch = False
        if "*" in module:
            target_mod = module
            _use_fnmatch = True
        elif module:
            target_mod = module + "." if not module.endswith(".") else module
        else:
            target_mod = ""
        if _use_fnmatch:
            for fun in fnmatch.filter(__salt__, target_mod):
                docs[fun] = __salt__[fun].__doc__
        else:
            for fun in __salt__:
                if fun == module or fun.startswith(target_mod):
                    docs[fun] = __salt__[fun].__doc__
    return salt.utils.doc.strip_rst(docs)
def state_doc(*args):
    st_ = salt.state.State(__opts__)
    docs = {}
    if not args:
        for fun in st_.states:
            state = fun.split(".")[0]
            if state not in docs:
                if hasattr(st_.states[fun], "__globals__"):
                    docs[state] = st_.states[fun].__globals__["__doc__"]
            docs[fun] = st_.states[fun].__doc__
        return salt.utils.doc.strip_rst(docs)
    for module in args:
        _use_fnmatch = False
        if "*" in module:
            target_mod = module
            _use_fnmatch = True
        elif module:
            target_mod = module + "." if not module.endswith(".") else module
        else:
            target_mod = ""
        if _use_fnmatch:
            for fun in fnmatch.filter(st_.states, target_mod):
                state = fun.split(".")[0]
                if hasattr(st_.states[fun], "__globals__"):
                    docs[state] = st_.states[fun].__globals__["__doc__"]
                docs[fun] = st_.states[fun].__doc__
        else:
            for fun in st_.states:
                if fun == module or fun.startswith(target_mod):
                    state = module.split(".")[0]
                    if state not in docs:
                        if hasattr(st_.states[fun], "__globals__"):
                            docs[state] = st_.states[fun].__globals__["__doc__"]
                    docs[fun] = st_.states[fun].__doc__
    return salt.utils.doc.strip_rst(docs)
def runner_doc(*args):
    run_ = salt.runner.Runner(__opts__)
    docs = {}
    if not args:
        for fun in run_.functions:
            docs[fun] = run_.functions[fun].__doc__
        return salt.utils.doc.strip_rst(docs)
    for module in args:
        _use_fnmatch = False
        if "*" in module:
            target_mod = module
            _use_fnmatch = True
        elif module:
            target_mod = module + "." if not module.endswith(".") else module
        else:
            target_mod = ""
        if _use_fnmatch:
            for fun in fnmatch.filter(run_.functions, target_mod):
                docs[fun] = run_.functions[fun].__doc__
        else:
            for fun in run_.functions:
                if fun == module or fun.startswith(target_mod):
                    docs[fun] = run_.functions[fun].__doc__
    return salt.utils.doc.strip_rst(docs)
def returner_doc(*args):
    returners_ = salt.loader.returners(__opts__, [])
    docs = {}
    if not args:
        for fun in returners_:
            docs[fun] = returners_[fun].__doc__
        return salt.utils.doc.strip_rst(docs)
    for module in args:
        _use_fnmatch = False
        if "*" in module:
            target_mod = module
            _use_fnmatch = True
        elif module:
            target_mod = module + "." if not module.endswith(".") else module
        else:
            target_mod = ""
        if _use_fnmatch:
            for fun in returners_:
                if fun == module or fun.startswith(target_mod):
                    docs[fun] = returners_[fun].__doc__
        else:
            for fun in returners_.keys():
                if fun == module or fun.startswith(target_mod):
                    docs[fun] = returners_[fun].__doc__
    return salt.utils.doc.strip_rst(docs)
def renderer_doc(*args):
    renderers_ = salt.loader.render(__opts__, [])
    docs = {}
    if not args:
        for func in renderers_.keys():
            docs[func] = renderers_[func].__doc__
        return salt.utils.doc.strip_rst(docs)
    for module in args:
        if "*" in module or "." in module:
            for func in fnmatch.filter(renderers_, module):
                docs[func] = renderers_[func].__doc__
        else:
            moduledot = module + "."
            for func in renderers_.keys():
                if func.startswith(moduledot):
                    docs[func] = renderers_[func].__doc__
    return salt.utils.doc.strip_rst(docs)
def list_functions(*args, **kwargs):  # pylint: disable=unused-argument
    if not args:
        return sorted(__salt__)
    names = set()
    for module in args:
        if "*" in module or "." in module:
            for func in fnmatch.filter(__salt__, module):
                names.add(func)
        else:
            moduledot = module + "."
            for func in __salt__:
                if func.startswith(moduledot):
                    names.add(func)
    return sorted(names)
def list_modules(*args):
    modules = set()
    if not args:
        for func in __salt__:
            modules.add(func.split(".")[0])
        return sorted(modules)
    for module in args:
        if "*" in module:
            for func in fnmatch.filter(__salt__, module):
                modules.add(func.split(".")[0])
        else:
            for func in __salt__:
                mod_test = func.split(".")[0]
                if mod_test == module:
                    modules.add(mod_test)
    return sorted(modules)
def reload_modules():
    return True
def argspec(module=""):
    return salt.utils.args.argspec_report(__salt__, module)
def state_argspec(module=""):
    st_ = salt.state.State(__opts__)
    return salt.utils.args.argspec_report(st_.states, module)
def returner_argspec(module=""):
    returners_ = salt.loader.returners(__opts__, [])
    return salt.utils.args.argspec_report(returners_, module)
def runner_argspec(module=""):
    run_ = salt.runner.Runner(__opts__)
    return salt.utils.args.argspec_report(run_.functions, module)
def list_state_functions(*args, **kwargs):  # pylint: disable=unused-argument
    st_ = salt.state.State(__opts__)
    if not args:
        return sorted(st_.states)
    names = set()
    for module in args:
        if "*" in module or "." in module:
            for func in fnmatch.filter(st_.states, module):
                names.add(func)
        else:
            moduledot = module + "."
            for func in st_.states:
                if func.startswith(moduledot):
                    names.add(func)
    return sorted(names)
def list_state_modules(*args):
    st_ = salt.state.State(__opts__)
    modules = set()
    if not args:
        for func in st_.states:
            log.debug("func %s", func)
            modules.add(func.split(".")[0])
        return sorted(modules)
    for module in args:
        if "*" in module:
            for func in fnmatch.filter(st_.states, module):
                modules.add(func.split(".")[0])
        else:
            for func in st_.states:
                mod_test = func.split(".")[0]
                if mod_test == module:
                    modules.add(mod_test)
    return sorted(modules)
def list_runners(*args):
    run_ = salt.runner.Runner(__opts__)
    runners = set()
    if not args:
        for func in run_.functions:
            runners.add(func.split(".")[0])
        return sorted(runners)
    for module in args:
        if "*" in module:
            for func in fnmatch.filter(run_.functions, module):
                runners.add(func.split(".")[0])
        else:
            for func in run_.functions:
                mod_test = func.split(".")[0]
                if mod_test == module:
                    runners.add(mod_test)
    return sorted(runners)
def list_runner_functions(*args, **kwargs):  # pylint: disable=unused-argument
    run_ = salt.runner.Runner(__opts__)
    if not args:
        return sorted(run_.functions)
    names = set()
    for module in args:
        if "*" in module or "." in module:
            for func in fnmatch.filter(run_.functions, module):
                names.add(func)
        else:
            moduledot = module + "."
            for func in run_.functions:
                if func.startswith(moduledot):
                    names.add(func)
    return sorted(names)
def list_returners(*args):
    returners_ = salt.loader.returners(__opts__, [])
    returners = set()
    if not args:
        for func in returners_.keys():
            returners.add(func.split(".")[0])
        return sorted(returners)
    for module in args:
        if "*" in module:
            for func in fnmatch.filter(returners_, module):
                returners.add(func.split(".")[0])
        else:
            for func in returners_:
                mod_test = func.split(".")[0]
                if mod_test == module:
                    returners.add(mod_test)
    return sorted(returners)
def list_returner_functions(*args, **kwargs):  # pylint: disable=unused-argument
    returners_ = salt.loader.returners(__opts__, [])
    if not args:
        return sorted(returners_)
    names = set()
    for module in args:
        if "*" in module or "." in module:
            for func in fnmatch.filter(returners_, module):
                names.add(func)
        else:
            moduledot = module + "."
            for func in returners_:
                if func.startswith(moduledot):
                    names.add(func)
    return sorted(names)
def list_renderers(*args):
    renderers_ = salt.loader.render(__opts__, [])
    renderers = set()
    if not args:
        for rend in renderers_.keys():
            renderers.add(rend)
        return sorted(renderers)
    for module in args:
        for rend in fnmatch.filter(renderers_, module):
            renderers.add(rend)
    return sorted(renderers)
def _argspec_to_schema(mod, spec):
    args = spec["args"]
    defaults = spec["defaults"] or []
    args_req = args[: len(args) - len(defaults)]
    args_defaults = list(zip(args[-len(defaults) :], defaults))
    types = {
        "title": mod,
        "description": mod,
<a name="1"></a>    }
    for i in args_req:
        types[i] = salt<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.schema.OneOfItem(
            items=(
                salt.utils.schema.BooleanItem(title=i, description=</b></font>i, required=True),
                salt.utils.schema.IntegerItem(title=i, description=i, required=True),
                salt.utils.schema.NumberItem(title=i, description=i, required=True),
                salt.utils.schema.StringItem(title=i, description=i, required=True),
            )
<a name="0"></a>        )
    for i, j in args_defaults:
        types[i] = salt<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.schema.OneOfItem(
            items=(
                salt.utils.schema.BooleanItem(title=i, description=</b></font>i, default=j),
                salt.utils.schema.IntegerItem(title=i, description=i, default=j),
                salt.utils.schema.NumberItem(title=i, description=i, default=j),
                salt.utils.schema.StringItem(title=i, description=i, default=j),
            )
        )
    return type(mod, (salt.utils.schema.Schema,), types).serialize()
def state_schema(module=""):
    specs = state_argspec(module)
    schemas = []
    for state_mod, state_spec in specs.items():
        schemas.append(_argspec_to_schema(state_mod, state_spec))
    return schemas
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltnado.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import salt.ext.tornado
import salt.ext.tornado.testing
import salt.netapi.rest_tornado.saltnado as saltnado
from tests.support.mock import MagicMock, patch
class TestJobNotRunning(salt.ext.tornado.testing.AsyncTestCase):
    def setUp(self):
        super().setUp()
        self.mock = MagicMock()
        self.mock.opts = {
            "syndic_wait": 0.1,
            "cachedir": "/tmp/testing/cachedir",
            "sock_dir": "/tmp/testing/sock_drawer",
            "transport": "zeromq",
            "extension_modules": "/tmp/testing/moduuuuules",
            "order_masters": False,
            "gather_job_timeout": 10.001,
        }
        self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
        self.handler._write_buffer = []
        self.handler._transforms = []
        self.handler.lowstate = []
        self.handler.content_type = "text/plain"
        self.handler.dumper = lambda x: x
        f = salt.ext.tornado.gen.Future()
        f.set_result({"jid": f, "minions": []})
        self.handler.saltclients.update({"local": lambda *args, **kwargs: f})
    @salt.ext.tornado.testing.gen_test
    def test_when_disbatch_has_already_finished_then_writing_return_should_not_fail(
        self,
    ):
        self.handler.finish()
        result = yield self.handler.disbatch()
    @salt.ext.tornado.testing.gen_test
    def test_when_disbatch_has_already_finished_then_finishing_should_not_fail(self):
        self.handler.finish()
        result = yield self.handler.disbatch()
    @salt.ext.tornado.testing.gen_test
    def test_when_event_times_out_and_minion_is_not_running_result_should_be_True(self):
        fut = salt.ext.tornado.gen.Future()
        fut.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.return_value = fut
        wrong_future = salt.ext.tornado.gen.Future()
        result = yield self.handler.job_not_running(
            jid=42, tgt="*", tgt_type="glob", minions=[], is_finished=wrong_future
        )
        self.assertTrue(result)
    @salt.ext.tornado.testing.gen_test
    def test_when_event_times_out_and_minion_is_not_running_minion_data_should_not_be_set(
        self,
    ):
        fut = salt.ext.tornado.gen.Future()
        fut.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.return_value = fut
        wrong_future = salt.ext.tornado.gen.Future()
        minions = {}
        result = yield self.handler.job_not_running(
            jid=42, tgt="*", tgt_type="glob", minions=minions, is_finished=wrong_future
        )
        assert not minions
    @salt.ext.tornado.testing.gen_test
    def test_when_event_finally_finishes_and_returned_minion_not_in_minions_it_should_be_set_to_False(
        self,
    ):
        expected_id = 42
        no_data_event = salt.ext.tornado.gen.Future()
        no_data_event.set_result({"data": {}})
        empty_return_event = salt.ext.tornado.gen.Future()
        empty_return_event.set_result({"data": {"return": {}}})
        actual_return_event = salt.ext.tornado.gen.Future()
        actual_return_event.set_result(
            {"data": {"return": {"something happened here": "OK?"}, "id": expected_id}}
        )
        timed_out_event = salt.ext.tornado.gen.Future()
        timed_out_event.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.side_effect = [
            no_data_event,
            empty_return_event,
            actual_return_event,
            timed_out_event,
            timed_out_event,
        ]
        minions = {}
        yield self.handler.job_not_running(
            jid=99,
            tgt="*",
            tgt_type="fnord",
            minions=minions,
            is_finished=salt.ext.tornado.gen.Future(),
        )
        self.assertFalse(minions[expected_id])
    @salt.ext.tornado.testing.gen_test
    def test_when_event_finally_finishes_and_returned_minion_already_in_minions_it_should_not_be_changed(
        self,
    ):
        expected_id = 42
        expected_value = object()
        minions = {expected_id: expected_value}
        no_data_event = salt.ext.tornado.gen.Future()
        no_data_event.set_result({"data": {}})
        empty_return_event = salt.ext.tornado.gen.Future()
        empty_return_event.set_result({"data": {"return": {}}})
        actual_return_event = salt.ext.tornado.gen.Future()
        actual_return_event.set_result(
            {"data": {"return": {"something happened here": "OK?"}, "id": expected_id}}
        )
        timed_out_event = salt.ext.tornado.gen.Future()
        timed_out_event.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.side_effect = [
            no_data_event,
            empty_return_event,
            actual_return_event,
            timed_out_event,
            timed_out_event,
        ]
        yield self.handler.job_not_running(
            jid=99,
            tgt="*",
            tgt_type="fnord",
            minions=minions,
            is_finished=salt.ext.tornado.gen.Future(),
        )
        self.assertIs(minions[expected_id], expected_value)
    @salt.ext.tornado.testing.gen_test
    def test_when_event_returns_early_and_finally_times_out_result_should_be_True(self):
        no_data_event = salt.ext.tornado.gen.Future()
        no_data_event.set_result({"data": {}})
        empty_return_event = salt.ext.tornado.gen.Future()
        empty_return_event.set_result({"data": {"return": {}}})
        actual_return_event = salt.ext.tornado.gen.Future()
        actual_return_event.set_result(
            {"data": {"return": {"something happened here": "OK?"}, "id": "fnord"}}
        )
        timed_out_event = salt.ext.tornado.gen.Future()
        timed_out_event.set_exception(saltnado.TimeoutException())
        self.mock.event_listener.get_event.side_effect = [
            no_data_event,
            empty_return_event,
            actual_return_event,
            timed_out_event,
            timed_out_event,
        ]
        result = yield self.handler.job_not_running(
            jid=99,
            tgt="*",
            tgt_type="fnord",
            minions={},
            is_finished=salt.ext.tornado.gen.Future(),
        )
        self.assertTrue(result)
    @salt.ext.tornado.testing.gen_test
    def test_when_event_finishes_but_is_finished_is_done_then_result_should_be_True(
        self,
    ):
        expected_minion_id = "fnord"
        expected_minion_value = object()
        no_data_event = salt.ext.tornado.gen.Future()
        no_data_event.set_result({"data": {}})
        empty_return_event = salt.ext.tornado.gen.Future()
        empty_return_event.set_result({"data": {"return": {}}})
        actual_return_event = salt.ext.tornado.gen.Future()
        actual_return_event.set_result(
            {
                "data": {
                    "return": {"something happened here": "OK?"},
                    "id": expected_minion_id,
                }
            }
        )
        is_finished = salt.ext.tornado.gen.Future()
        def abort(*args, **kwargs):
            yield actual_return_event
            f = salt.ext.tornado.gen.Future()
            f.set_exception(saltnado.TimeoutException())
            is_finished.set_result("This is done")
            yield f
            assert False, "Never should make it here"
        minions = {expected_minion_id: expected_minion_value}
        self.mock.event_listener.get_event.side_effect = (x for x in abort())
        result = yield self.handler.job_not_running(
            jid=99,
            tgt="*",
            tgt_type="fnord",
            minions=minions,
            is_finished=is_finished,
        )
        self.assertTrue(result)
        self.assertTrue(len(minions) == 1, str(minions))
        self.assertIs(minions[expected_minion_id], expected_minion_value)
    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_times_out_before_event_finishes_result_should_be_True(
        self,
    ):
        finished = salt.ext.tornado.gen.Future()
        finished.set_exception(saltnado.TimeoutException())
        wrong_future = salt.ext.tornado.gen.Future()
        self.mock.event_listener.get_event.return_value = wrong_future
        result = yield self.handler.job_not_running(
            jid=42, tgt="*", tgt_type="glob", minions=[], is_finished=finished
        )
        self.assertTrue(result)
    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_times_out_before_event_finishes_event_should_have_result_set_to_None(
        self,
    ):
        finished = salt.ext.tornado.gen.Future()
        finished.set_exception(saltnado.TimeoutException())
        wrong_future = salt.ext.tornado.gen.Future()
        self.mock.event_listener.get_event.return_value = wrong_future
        result = yield self.handler.job_not_running(
            jid=42, tgt="*", tgt_type="glob", minions=[], is_finished=finished
        )
        self.assertIsNone(wrong_future.result())
class TestGetMinionReturns(salt.ext.tornado.testing.AsyncTestCase):
    def setUp(self):
        super().setUp()
        self.mock = MagicMock()
        self.mock.opts = {
            "syndic_wait": 0.1,
            "cachedir": "/tmp/testing/cachedir",
            "sock_dir": "/tmp/testing/sock_drawer",
            "transport": "zeromq",
            "extension_modules": "/tmp/testing/moduuuuules",
            "order_masters": False,
            "gather_job_timeout": 10.001,
        }
        self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
        f = salt.ext.tornado.gen.Future()
        f.set_result({"jid": f, "minions": []})
    @salt.ext.tornado.testing.gen_test
    def test_if_finished_before_any_events_return_then_result_should_be_empty_dictionary(
        self,
    ):
        expected_result = {}
        xxx = salt.ext.tornado.gen.Future()
        xxx.set_result(None)
        is_finished = salt.ext.tornado.gen.Future()
        is_finished.set_result(None)
        actual_result = yield self.handler.get_minion_returns(
            events=[],
            is_finished=is_finished,
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=xxx,
            minions={},
        )
        self.assertDictEqual(actual_result, expected_result)
    @salt.ext.tornado.testing.gen_test
    def test_if_is_finished_after_events_return_then_result_should_contain_event_result_data(
        self,
    ):
        expected_result = {
            "minion1": {"fnord": "this is some fnordish data"},
            "minion2": {"fnord": "this is some other fnordish data"},
        }
        xxx = salt.ext.tornado.gen.Future()
        xxx.set_result(None)
        is_finished = salt.ext.tornado.gen.Future()
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]
        events[0].set_result(
            {
                "tag": "fnord",
                "data": {"id": "minion1", "return": expected_result["minion1"]},
            }
        )
        events[1].set_result(
            {
                "tag": "fnord",
                "data": {"id": "minion2", "return": expected_result["minion2"]},
            }
        )
        self.io_loop.call_later(0.2, lambda: is_finished.set_result(None))
        actual_result = yield self.handler.get_minion_returns(
            events=events,
            is_finished=is_finished,
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=xxx,
            minions={
                "minion1": False,
                "minion2": False,
                "never returning minion": False,
            },
        )
        assert actual_result == expected_result
    @salt.ext.tornado.testing.gen_test
    def test_if_timed_out_after_events_return_then_result_should_contain_event_result_data(
        self,
    ):
        expected_result = {
            "minion1": {"fnord": "this is some fnordish data"},
            "minion2": {"fnord": "this is some other fnordish data"},
        }
        xxx = salt.ext.tornado.gen.Future()
        xxx.set_result(None)
        is_timed_out = salt.ext.tornado.gen.Future()
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]
        events[0].set_result(
            {
                "tag": "fnord",
                "data": {"id": "minion1", "return": expected_result["minion1"]},
            }
        )
        events[1].set_result(
            {
                "tag": "fnord",
                "data": {"id": "minion2", "return": expected_result["minion2"]},
            }
        )
        self.io_loop.call_later(0.2, lambda: is_timed_out.set_result(None))
        actual_result = yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=is_timed_out,
            min_wait_time=xxx,
            minions={
                "minion1": False,
                "minion2": False,
                "never returning minion": False,
            },
        )
        assert actual_result == expected_result
    @salt.ext.tornado.testing.gen_test
    def test_if_wait_timer_is_not_done_even_though_results_are_then_data_should_not_yet_be_returned(
        self,
    ):
        expected_result = {
            "one": {"fnordy one": "one has some data"},
            "two": {"fnordy two": "two has some data"},
        }
        events = [salt.ext.tornado.gen.Future(), salt.ext.tornado.gen.Future()]
        events[0].set_result(
            {"tag": "fnord", "data": {"id": "one", "return": expected_result["one"]}}
        )
        events[1].set_result(
            {"tag": "fnord", "data": {"id": "two", "return": expected_result["two"]}}
        )
<a name="1"></a>        wait_timer = salt.ext.tornado.gen.Future()
        fut = self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.tornado.gen.Future(),
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=wait_timer,
            minions=</b></font>{"one": False, "two": False},
        )
        def boop():
            yield fut
        self.io_loop.spawn_callback(boop)
        yield salt.ext.tornado.gen.sleep(0.1)
        assert not fut.done()
        wait_timer.set_result(None)
        actual_result = yield fut
        assert actual_result == expected_result
    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_any_other_futures_should_be_canceled(self):
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]
        is_finished = salt.ext.tornado.gen.Future()
        is_finished.set_result(None)
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=is_finished,
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=salt.ext.tornado.gen.Future(),
            minions={"one": False, "two": False},
        )
        are_done = [event.done() for event in events]
        assert all(are_done)
    @salt.ext.tornado.testing.gen_test
    def test_when_an_event_times_out_then_we_should_not_enter_an_infinite_loop(self):
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]
        events[3].set_exception(saltnado.TimeoutException())
        times_out_later = salt.ext.tornado.gen.Future()
        self.io_loop.call_later(0.5, lambda: times_out_later.set_result(None))
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=times_out_later,
            min_wait_time=salt.ext.tornado.gen.Future(),
            minions={"one": False, "two": False},
        )
        are_done = [event.done() for event in events]
        assert all(are_done)
        assert times_out_later.done()
    @salt.ext.tornado.testing.gen_test
    def test_when_is_timed_out_any_other_futures_should_be_canceled(self):
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]
        is_timed_out = salt.ext.tornado.gen.Future()
        is_timed_out.set_result(None)
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=is_timed_out,
            min_wait_time=salt.ext.tornado.gen.Future(),
            minions={"one": False, "two": False},
        )
        are_done = [event.done() for event in events]
        assert all(are_done)
    @salt.ext.tornado.testing.gen_test
    def test_when_min_wait_time_and_nothing_todo_any_other_futures_should_be_canceled(
        self,
    ):
        events = [
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
            salt.ext.tornado.gen.Future(),
        ]
        is_finished = salt.ext.tornado.gen.Future()
        min_wait_time = salt.ext.tornado.gen.Future()
        self.io_loop.call_later(0.2, lambda: min_wait_time.set_result(None))
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=is_finished,
            is_timed_out=salt.ext.tornado.gen.Future(),
            min_wait_time=min_wait_time,
            minions={"one": True, "two": True},
        )
        are_done = [event.done() for event in events] + [is_finished.done()]
        assert all(are_done)
    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_but_not_is_timed_out_then_timed_out_should_not_be_set_to_done(
        self,
    ):
        events = [salt.ext.tornado.gen.Future()]
        is_timed_out = salt.ext.tornado.gen.Future()
        is_finished = salt.ext.tornado.gen.Future()
        is_finished.set_result(None)
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=is_finished,
            is_timed_out=is_timed_out,
            min_wait_time=salt.ext.tornado.gen.Future(),
            minions={"one": False, "two": False},
        )
        assert not is_timed_out.done()
    @salt.ext.tornado.testing.gen_test
    def test_when_min_wait_time_and_all_completed_but_not_is_timed_out_then_timed_out_should_not_be_set_to_done(
        self,
    ):
        events = [salt.ext.tornado.gen.Future()]
        is_timed_out = salt.ext.tornado.gen.Future()
        min_wait_time = salt.ext.tornado.gen.Future()
        self.io_loop.call_later(0.2, lambda: min_wait_time.set_result(None))
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=is_timed_out,
            min_wait_time=min_wait_time,
            minions={"one": True},
        )
        assert not is_timed_out.done()
    @salt.ext.tornado.testing.gen_test
    def test_when_things_are_completed_but_not_timed_out_then_timed_out_event_should_not_be_done(
        self,
    ):
        events = [
            salt.ext.tornado.gen.Future(),
        ]
        events[0].set_result({"tag": "fnord", "data": {"id": "one", "return": {}}})
        min_wait_time = salt.ext.tornado.gen.Future()
        min_wait_time.set_result(None)
        is_timed_out = salt.ext.tornado.gen.Future()
        yield self.handler.get_minion_returns(
            events=events,
            is_finished=salt.ext.tornado.gen.Future(),
            is_timed_out=is_timed_out,
            min_wait_time=min_wait_time,
            minions={"one": True},
        )
        assert not is_timed_out.done()
class TestDisbatchLocal(salt.ext.tornado.testing.AsyncTestCase):
    def setUp(self):
        super().setUp()
        self.mock = MagicMock()
        self.mock.opts = {
            "syndic_wait": 0.1,
            "cachedir": "/tmp/testing/cachedir",
            "sock_dir": "/tmp/testing/sock_drawer",
            "transport": "zeromq",
            "extension_modules": "/tmp/testing/moduuuuules",
            "order_masters": False,
            "gather_job_timeout": 10.001,
        }
        self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
    @salt.ext.tornado.testing.gen_test
<a name="0"></a>    def test_when_is_timed_out_is_set_before_other_events_are_completed_then_result_should_be_empty_dictionary(
        self,
    ):
        completed_event = salt.ext<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        gather_timeout = 0.1
        event_timeout =</b></font> gather_timeout + 0.05
        def fancy_get_event(*args, **kwargs):
            if kwargs.get("tag").endswith("/ret"):
                return never_completed
            return completed_event
        def completer():
            completed_event.set_result(
                {
                    "tag": "fnord",
                    "data": {
                        "return": "This should never be in chunk_ret",
                        "id": "fnord",
                    },
                }
            )
        self.io_loop.call_later(event_timeout, completer)
        f = salt.ext.tornado.gen.Future()
        f.set_result({"jid": "42", "minions": []})
        with patch.object(
            self.handler.application.event_listener,
            "get_event",
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.dict(
            self.handler.application.opts,
            {"gather_job_timeout": gather_timeout, "timeout": 42},
        ), patch.dict(
            self.handler.saltclients, {"local": lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
            )
        assert result == {}
    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_is_set_before_events_return_then_no_data_should_be_returned(
        self,
    ):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        gather_timeout = 2
        event_timeout = gather_timeout - 1
        def fancy_get_event(*args, **kwargs):
            if kwargs.get("tag").endswith("/ret"):
                return never_completed
            return completed_event
        def completer():
            completed_event.set_result(
                {
                    "tag": "fnord",
                    "data": {
                        "return": "This should never be in chunk_ret",
                        "id": "fnord",
                    },
                }
            )
        self.io_loop.call_later(event_timeout, completer)
        def toggle_is_finished(*args, **kwargs):
            finished = kwargs.get("is_finished", args[4] if len(args) &gt; 4 else None)
            assert finished is not None
            finished.set_result(42)
        f = salt.ext.tornado.gen.Future()
        f.set_result({"jid": "42", "minions": []})
        with patch.object(
            self.handler.application.event_listener,
            "get_event",
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.object(
            self.handler,
            "job_not_running",
            autospec=True,
            side_effect=toggle_is_finished,
        ), patch.dict(
            self.handler.application.opts,
            {"gather_job_timeout": gather_timeout, "timeout": 42},
        ), patch.dict(
            self.handler.saltclients, {"local": lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
            )
        assert result == {}
    @salt.ext.tornado.testing.gen_test
    def test_when_is_finished_then_all_collected_data_should_be_returned(self):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        gather_timeout = 42
        completed_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
        for i, event in enumerate(completed_events):
            event.set_result(
                {
                    "tag": "fnord",
                    "data": {
                        "return": "return from fnord {}".format(i),
                        "id": "fnord {}".format(i),
                    },
                }
            )
        uncompleted_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
        events = iter(completed_events + uncompleted_events)
        expected_result = {
            "fnord 0": "return from fnord 0",
            "fnord 1": "return from fnord 1",
            "fnord 2": "return from fnord 2",
            "fnord 3": "return from fnord 3",
            "fnord 4": "return from fnord 4",
        }
        def fancy_get_event(*args, **kwargs):
            if kwargs.get("tag").endswith("/ret"):
                return never_completed
            else:
                return next(events)
        def toggle_is_finished(*args, **kwargs):
            finished = kwargs.get("is_finished", args[4] if len(args) &gt; 4 else None)
            assert finished is not None
            finished.set_result(42)
        f = salt.ext.tornado.gen.Future()
        f.set_result({"jid": "42", "minions": ["non-existent minion"]})
        with patch.object(
            self.handler.application.event_listener,
            "get_event",
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.object(
            self.handler,
            "job_not_running",
            autospec=True,
            side_effect=toggle_is_finished,
        ), patch.dict(
            self.handler.application.opts,
            {"gather_job_timeout": gather_timeout, "timeout": 42},
        ), patch.dict(
            self.handler.saltclients, {"local": lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
            )
        assert result == expected_result
    @salt.ext.tornado.testing.gen_test
    def test_when_is_timed_out_then_all_collected_data_should_be_returned(self):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        gather_timeout = 2
        completed_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
        for i, event in enumerate(completed_events):
            event.set_result(
                {
                    "tag": "fnord",
                    "data": {
                        "return": "return from fnord {}".format(i),
                        "id": "fnord {}".format(i),
                    },
                }
            )
        uncompleted_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
        events = iter(completed_events + uncompleted_events)
        expected_result = {
            "fnord 0": "return from fnord 0",
            "fnord 1": "return from fnord 1",
            "fnord 2": "return from fnord 2",
            "fnord 3": "return from fnord 3",
            "fnord 4": "return from fnord 4",
        }
        def fancy_get_event(*args, **kwargs):
            if kwargs.get("tag").endswith("/ret"):
                return never_completed
            else:
                return next(events)
        f = salt.ext.tornado.gen.Future()
        f.set_result({"jid": "42", "minions": ["non-existent minion"]})
        with patch.object(
            self.handler.application.event_listener,
            "get_event",
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.dict(
            self.handler.application.opts,
            {"gather_job_timeout": gather_timeout, "timeout": 42},
        ), patch.dict(
            self.handler.saltclients, {"local": lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
            )
        assert result == expected_result
    @salt.ext.tornado.testing.gen_test
    def test_when_minions_all_return_then_all_collected_data_should_be_returned(self):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        gather_timeout = 20
        completed_events = [salt.ext.tornado.gen.Future() for _ in range(10)]
        events_by_id = {}
        for i, event in enumerate(completed_events):
            id_ = "fnord {}".format(i)
            events_by_id[id_] = event
            event.set_result(
                {
                    "tag": "fnord",
                    "data": {"return": "return from {}".format(id_), "id": id_},
                }
            )
        expected_result = {
            "fnord 0": "return from fnord 0",
            "fnord 1": "return from fnord 1",
            "fnord 2": "return from fnord 2",
            "fnord 3": "return from fnord 3",
            "fnord 4": "return from fnord 4",
            "fnord 5": "return from fnord 5",
            "fnord 6": "return from fnord 6",
            "fnord 7": "return from fnord 7",
            "fnord 8": "return from fnord 8",
            "fnord 9": "return from fnord 9",
        }
        def fancy_get_event(*args, **kwargs):
            tag = kwargs.get("tag", "").rpartition("/")[-1]
            return events_by_id.get(tag, never_completed)
        f = salt.ext.tornado.gen.Future()
        f.set_result(
            {
                "jid": "42",
                "minions": [e.result()["data"]["id"] for e in completed_events],
            }
        )
        with patch.object(
            self.handler.application.event_listener,
            "get_event",
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.dict(
            self.handler.application.opts,
            {"gather_job_timeout": gather_timeout, "timeout": 42},
        ), patch.dict(
            self.handler.saltclients, {"local": lambda *args, **kwargs: f}
        ):
            result = yield self.handler._disbatch_local(
                chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
            )
        assert result == expected_result
    @salt.ext.tornado.testing.gen_test
    def test_when_min_wait_time_has_not_passed_then_disbatch_should_not_return_expected_data_until_time_has_passed(
        self,
    ):
        completed_event = salt.ext.tornado.gen.Future()
        never_completed = salt.ext.tornado.gen.Future()
        wait_timer = salt.ext.tornado.gen.Future()
        gather_timeout = 20
        completed_events = [salt.ext.tornado.gen.Future() for _ in range(10)]
        events_by_id = {}
        for i, event in enumerate(completed_events):
            id_ = "fnord {}".format(i)
            events_by_id[id_] = event
            event.set_result(
                {
                    "tag": "fnord",
                    "data": {"return": "return from {}".format(id_), "id": id_},
                }
            )
        expected_result = {
            "fnord 0": "return from fnord 0",
            "fnord 1": "return from fnord 1",
            "fnord 2": "return from fnord 2",
            "fnord 3": "return from fnord 3",
            "fnord 4": "return from fnord 4",
            "fnord 5": "return from fnord 5",
            "fnord 6": "return from fnord 6",
            "fnord 7": "return from fnord 7",
            "fnord 8": "return from fnord 8",
            "fnord 9": "return from fnord 9",
        }
        def fancy_get_event(*args, **kwargs):
            tag = kwargs.get("tag", "").rpartition("/")[-1]
            return events_by_id.get(tag, never_completed)
        minions = {}
        def capture_minions(*args, **kwargs):
            nonlocal minions
            minions = args[3]
        orig_sleep = salt.ext.tornado.gen.sleep
        fakeo_timer = object()
        @salt.ext.tornado.gen.coroutine
        def fake_sleep(timer):
            if timer is fakeo_timer:
                yield wait_timer
            else:
                yield orig_sleep(timer)
        f = salt.ext.tornado.gen.Future()
        f.set_result(
            {
                "jid": "42",
                "minions": [e.result()["data"]["id"] for e in completed_events],
            }
        )
        with patch.object(
            self.handler.application.event_listener,
            "get_event",
            autospec=True,
            side_effect=fancy_get_event,
        ), patch.object(
            self.handler,
            "job_not_running",
            autospec=True,
            side_effect=capture_minions,
        ), patch.dict(
            self.handler.application.opts,
            {
                "gather_job_timeout": gather_timeout,
                "timeout": 42,
                "syndic_wait": fakeo_timer,
                "order_masters": True,
            },
        ), patch(
            "salt.ext.tornado.gen.sleep",
            autospec=True,
            side_effect=fake_sleep,
        ), patch.dict(
            self.handler.saltclients, {"local": lambda *args, **kwargs: f}
        ):
            fut = self.handler._disbatch_local(
                chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
            )
            def boop():
                yield fut
            self.io_loop.spawn_callback(boop)
            yield salt.ext.tornado.gen.sleep(0.1)
            assert all(minions[m_id] for m_id in minions)
            assert not fut.done()
            wait_timer.set_result(None)
            result = yield fut
        assert result == expected_result
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
