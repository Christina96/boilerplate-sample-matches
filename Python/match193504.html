<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for sysmod.py &amp; test_saltnado.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for sysmod.py &amp; test_saltnado.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>sysmod.py (2.7874565%)<th>test_saltnado.py (1.2624934%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(851-853)<td><a href="#" name="0">(621-625)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(839-841)<td><a href="#" name="1">(401-404)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>sysmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import fnmatch
2 import logging
3 import salt.loader
4 import salt.runner
5 import salt.state
6 import salt.utils.args
7 import salt.utils.doc
8 import salt.utils.schema
9 log = logging.getLogger(__name__)
10 __virtualname__ = "sys"
11 __proxyenabled__ = ["*"]
12 def __virtual__():
13     return __virtualname__
14 def doc(*args):
15     docs = {}
16     if not args:
17         for fun in __salt__:
18             docs[fun] = __salt__[fun].__doc__
19         return salt.utils.doc.strip_rst(docs)
20     for module in args:
21         _use_fnmatch = False
22         if "*" in module:
23             target_mod = module
24             _use_fnmatch = True
25         elif module:
26             target_mod = module + "." if not module.endswith(".") else module
27         else:
28             target_mod = ""
29         if _use_fnmatch:
30             for fun in fnmatch.filter(__salt__, target_mod):
31                 docs[fun] = __salt__[fun].__doc__
32         else:
33             for fun in __salt__:
34                 if fun == module or fun.startswith(target_mod):
35                     docs[fun] = __salt__[fun].__doc__
36     return salt.utils.doc.strip_rst(docs)
37 def state_doc(*args):
38     st_ = salt.state.State(__opts__)
39     docs = {}
40     if not args:
41         for fun in st_.states:
42             state = fun.split(".")[0]
43             if state not in docs:
44                 if hasattr(st_.states[fun], "__globals__"):
45                     docs[state] = st_.states[fun].__globals__["__doc__"]
46             docs[fun] = st_.states[fun].__doc__
47         return salt.utils.doc.strip_rst(docs)
48     for module in args:
49         _use_fnmatch = False
50         if "*" in module:
51             target_mod = module
52             _use_fnmatch = True
53         elif module:
54             target_mod = module + "." if not module.endswith(".") else module
55         else:
56             target_mod = ""
57         if _use_fnmatch:
58             for fun in fnmatch.filter(st_.states, target_mod):
59                 state = fun.split(".")[0]
60                 if hasattr(st_.states[fun], "__globals__"):
61                     docs[state] = st_.states[fun].__globals__["__doc__"]
62                 docs[fun] = st_.states[fun].__doc__
63         else:
64             for fun in st_.states:
65                 if fun == module or fun.startswith(target_mod):
66                     state = module.split(".")[0]
67                     if state not in docs:
68                         if hasattr(st_.states[fun], "__globals__"):
69                             docs[state] = st_.states[fun].__globals__["__doc__"]
70                     docs[fun] = st_.states[fun].__doc__
71     return salt.utils.doc.strip_rst(docs)
72 def runner_doc(*args):
73     run_ = salt.runner.Runner(__opts__)
74     docs = {}
75     if not args:
76         for fun in run_.functions:
77             docs[fun] = run_.functions[fun].__doc__
78         return salt.utils.doc.strip_rst(docs)
79     for module in args:
80         _use_fnmatch = False
81         if "*" in module:
82             target_mod = module
83             _use_fnmatch = True
84         elif module:
85             target_mod = module + "." if not module.endswith(".") else module
86         else:
87             target_mod = ""
88         if _use_fnmatch:
89             for fun in fnmatch.filter(run_.functions, target_mod):
90                 docs[fun] = run_.functions[fun].__doc__
91         else:
92             for fun in run_.functions:
93                 if fun == module or fun.startswith(target_mod):
94                     docs[fun] = run_.functions[fun].__doc__
95     return salt.utils.doc.strip_rst(docs)
96 def returner_doc(*args):
97     returners_ = salt.loader.returners(__opts__, [])
98     docs = {}
99     if not args:
100         for fun in returners_:
101             docs[fun] = returners_[fun].__doc__
102         return salt.utils.doc.strip_rst(docs)
103     for module in args:
104         _use_fnmatch = False
105         if "*" in module:
106             target_mod = module
107             _use_fnmatch = True
108         elif module:
109             target_mod = module + "." if not module.endswith(".") else module
110         else:
111             target_mod = ""
112         if _use_fnmatch:
113             for fun in returners_:
114                 if fun == module or fun.startswith(target_mod):
115                     docs[fun] = returners_[fun].__doc__
116         else:
117             for fun in returners_.keys():
118                 if fun == module or fun.startswith(target_mod):
119                     docs[fun] = returners_[fun].__doc__
120     return salt.utils.doc.strip_rst(docs)
121 def renderer_doc(*args):
122     renderers_ = salt.loader.render(__opts__, [])
123     docs = {}
124     if not args:
125         for func in renderers_.keys():
126             docs[func] = renderers_[func].__doc__
127         return salt.utils.doc.strip_rst(docs)
128     for module in args:
129         if "*" in module or "." in module:
130             for func in fnmatch.filter(renderers_, module):
131                 docs[func] = renderers_[func].__doc__
132         else:
133             moduledot = module + "."
134             for func in renderers_.keys():
135                 if func.startswith(moduledot):
136                     docs[func] = renderers_[func].__doc__
137     return salt.utils.doc.strip_rst(docs)
138 def list_functions(*args, **kwargs):  # pylint: disable=unused-argument
139     if not args:
140         return sorted(__salt__)
141     names = set()
142     for module in args:
143         if "*" in module or "." in module:
144             for func in fnmatch.filter(__salt__, module):
145                 names.add(func)
146         else:
147             moduledot = module + "."
148             for func in __salt__:
149                 if func.startswith(moduledot):
150                     names.add(func)
151     return sorted(names)
152 def list_modules(*args):
153     modules = set()
154     if not args:
155         for func in __salt__:
156             modules.add(func.split(".")[0])
157         return sorted(modules)
158     for module in args:
159         if "*" in module:
160             for func in fnmatch.filter(__salt__, module):
161                 modules.add(func.split(".")[0])
162         else:
163             for func in __salt__:
164                 mod_test = func.split(".")[0]
165                 if mod_test == module:
166                     modules.add(mod_test)
167     return sorted(modules)
168 def reload_modules():
169     return True
170 def argspec(module=""):
171     return salt.utils.args.argspec_report(__salt__, module)
172 def state_argspec(module=""):
173     st_ = salt.state.State(__opts__)
174     return salt.utils.args.argspec_report(st_.states, module)
175 def returner_argspec(module=""):
176     returners_ = salt.loader.returners(__opts__, [])
177     return salt.utils.args.argspec_report(returners_, module)
178 def runner_argspec(module=""):
179     run_ = salt.runner.Runner(__opts__)
180     return salt.utils.args.argspec_report(run_.functions, module)
181 def list_state_functions(*args, **kwargs):  # pylint: disable=unused-argument
182     st_ = salt.state.State(__opts__)
183     if not args:
184         return sorted(st_.states)
185     names = set()
186     for module in args:
187         if "*" in module or "." in module:
188             for func in fnmatch.filter(st_.states, module):
189                 names.add(func)
190         else:
191             moduledot = module + "."
192             for func in st_.states:
193                 if func.startswith(moduledot):
194                     names.add(func)
195     return sorted(names)
196 def list_state_modules(*args):
197     st_ = salt.state.State(__opts__)
198     modules = set()
199     if not args:
200         for func in st_.states:
201             log.debug("func %s", func)
202             modules.add(func.split(".")[0])
203         return sorted(modules)
204     for module in args:
205         if "*" in module:
206             for func in fnmatch.filter(st_.states, module):
207                 modules.add(func.split(".")[0])
208         else:
209             for func in st_.states:
210                 mod_test = func.split(".")[0]
211                 if mod_test == module:
212                     modules.add(mod_test)
213     return sorted(modules)
214 def list_runners(*args):
215     run_ = salt.runner.Runner(__opts__)
216     runners = set()
217     if not args:
218         for func in run_.functions:
219             runners.add(func.split(".")[0])
220         return sorted(runners)
221     for module in args:
222         if "*" in module:
223             for func in fnmatch.filter(run_.functions, module):
224                 runners.add(func.split(".")[0])
225         else:
226             for func in run_.functions:
227                 mod_test = func.split(".")[0]
228                 if mod_test == module:
229                     runners.add(mod_test)
230     return sorted(runners)
231 def list_runner_functions(*args, **kwargs):  # pylint: disable=unused-argument
232     run_ = salt.runner.Runner(__opts__)
233     if not args:
234         return sorted(run_.functions)
235     names = set()
236     for module in args:
237         if "*" in module or "." in module:
238             for func in fnmatch.filter(run_.functions, module):
239                 names.add(func)
240         else:
241             moduledot = module + "."
242             for func in run_.functions:
243                 if func.startswith(moduledot):
244                     names.add(func)
245     return sorted(names)
246 def list_returners(*args):
247     returners_ = salt.loader.returners(__opts__, [])
248     returners = set()
249     if not args:
250         for func in returners_.keys():
251             returners.add(func.split(".")[0])
252         return sorted(returners)
253     for module in args:
254         if "*" in module:
255             for func in fnmatch.filter(returners_, module):
256                 returners.add(func.split(".")[0])
257         else:
258             for func in returners_:
259                 mod_test = func.split(".")[0]
260                 if mod_test == module:
261                     returners.add(mod_test)
262     return sorted(returners)
263 def list_returner_functions(*args, **kwargs):  # pylint: disable=unused-argument
264     returners_ = salt.loader.returners(__opts__, [])
265     if not args:
266         return sorted(returners_)
267     names = set()
268     for module in args:
269         if "*" in module or "." in module:
270             for func in fnmatch.filter(returners_, module):
271                 names.add(func)
272         else:
273             moduledot = module + "."
274             for func in returners_:
275                 if func.startswith(moduledot):
276                     names.add(func)
277     return sorted(names)
278 def list_renderers(*args):
279     renderers_ = salt.loader.render(__opts__, [])
280     renderers = set()
281     if not args:
282         for rend in renderers_.keys():
283             renderers.add(rend)
284         return sorted(renderers)
285     for module in args:
286         for rend in fnmatch.filter(renderers_, module):
287             renderers.add(rend)
288     return sorted(renderers)
289 def _argspec_to_schema(mod, spec):
290     args = spec["args"]
291     defaults = spec["defaults"] or []
292     args_req = args[: len(args) - len(defaults)]
293     args_defaults = list(zip(args[-len(defaults) :], defaults))
294     types = {
295         "title": mod,
296         "description": mod,
297 <a name="1"></a>    }
298     for i in args_req:
299         types[i] = salt<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.schema.OneOfItem(
300             items=(
301                 salt.utils.schema.BooleanItem(title=i, description=</b></font>i, required=True),
302                 salt.utils.schema.IntegerItem(title=i, description=i, required=True),
303                 salt.utils.schema.NumberItem(title=i, description=i, required=True),
304                 salt.utils.schema.StringItem(title=i, description=i, required=True),
305             )
306 <a name="0"></a>        )
307     for i, j in args_defaults:
308         types[i] = salt<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.schema.OneOfItem(
309             items=(
310                 salt.utils.schema.BooleanItem(title=i, description=</b></font>i, default=j),
311                 salt.utils.schema.IntegerItem(title=i, description=i, default=j),
312                 salt.utils.schema.NumberItem(title=i, description=i, default=j),
313                 salt.utils.schema.StringItem(title=i, description=i, default=j),
314             )
315         )
316     return type(mod, (salt.utils.schema.Schema,), types).serialize()
317 def state_schema(module=""):
318     specs = state_argspec(module)
319     schemas = []
320     for state_mod, state_spec in specs.items():
321         schemas.append(_argspec_to_schema(state_mod, state_spec))
322     return schemas
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltnado.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.ext.tornado
2 import salt.ext.tornado.testing
3 import salt.netapi.rest_tornado.saltnado as saltnado
4 from tests.support.mock import MagicMock, patch
5 class TestJobNotRunning(salt.ext.tornado.testing.AsyncTestCase):
6     def setUp(self):
7         super().setUp()
8         self.mock = MagicMock()
9         self.mock.opts = {
10             "syndic_wait": 0.1,
11             "cachedir": "/tmp/testing/cachedir",
12             "sock_dir": "/tmp/testing/sock_drawer",
13             "transport": "zeromq",
14             "extension_modules": "/tmp/testing/moduuuuules",
15             "order_masters": False,
16             "gather_job_timeout": 10.001,
17         }
18         self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
19         self.handler._write_buffer = []
20         self.handler._transforms = []
21         self.handler.lowstate = []
22         self.handler.content_type = "text/plain"
23         self.handler.dumper = lambda x: x
24         f = salt.ext.tornado.gen.Future()
25         f.set_result({"jid": f, "minions": []})
26         self.handler.saltclients.update({"local": lambda *args, **kwargs: f})
27     @salt.ext.tornado.testing.gen_test
28     def test_when_disbatch_has_already_finished_then_writing_return_should_not_fail(
29         self,
30     ):
31         self.handler.finish()
32         result = yield self.handler.disbatch()
33     @salt.ext.tornado.testing.gen_test
34     def test_when_disbatch_has_already_finished_then_finishing_should_not_fail(self):
35         self.handler.finish()
36         result = yield self.handler.disbatch()
37     @salt.ext.tornado.testing.gen_test
38     def test_when_event_times_out_and_minion_is_not_running_result_should_be_True(self):
39         fut = salt.ext.tornado.gen.Future()
40         fut.set_exception(saltnado.TimeoutException())
41         self.mock.event_listener.get_event.return_value = fut
42         wrong_future = salt.ext.tornado.gen.Future()
43         result = yield self.handler.job_not_running(
44             jid=42, tgt="*", tgt_type="glob", minions=[], is_finished=wrong_future
45         )
46         self.assertTrue(result)
47     @salt.ext.tornado.testing.gen_test
48     def test_when_event_times_out_and_minion_is_not_running_minion_data_should_not_be_set(
49         self,
50     ):
51         fut = salt.ext.tornado.gen.Future()
52         fut.set_exception(saltnado.TimeoutException())
53         self.mock.event_listener.get_event.return_value = fut
54         wrong_future = salt.ext.tornado.gen.Future()
55         minions = {}
56         result = yield self.handler.job_not_running(
57             jid=42, tgt="*", tgt_type="glob", minions=minions, is_finished=wrong_future
58         )
59         assert not minions
60     @salt.ext.tornado.testing.gen_test
61     def test_when_event_finally_finishes_and_returned_minion_not_in_minions_it_should_be_set_to_False(
62         self,
63     ):
64         expected_id = 42
65         no_data_event = salt.ext.tornado.gen.Future()
66         no_data_event.set_result({"data": {}})
67         empty_return_event = salt.ext.tornado.gen.Future()
68         empty_return_event.set_result({"data": {"return": {}}})
69         actual_return_event = salt.ext.tornado.gen.Future()
70         actual_return_event.set_result(
71             {"data": {"return": {"something happened here": "OK?"}, "id": expected_id}}
72         )
73         timed_out_event = salt.ext.tornado.gen.Future()
74         timed_out_event.set_exception(saltnado.TimeoutException())
75         self.mock.event_listener.get_event.side_effect = [
76             no_data_event,
77             empty_return_event,
78             actual_return_event,
79             timed_out_event,
80             timed_out_event,
81         ]
82         minions = {}
83         yield self.handler.job_not_running(
84             jid=99,
85             tgt="*",
86             tgt_type="fnord",
87             minions=minions,
88             is_finished=salt.ext.tornado.gen.Future(),
89         )
90         self.assertFalse(minions[expected_id])
91     @salt.ext.tornado.testing.gen_test
92     def test_when_event_finally_finishes_and_returned_minion_already_in_minions_it_should_not_be_changed(
93         self,
94     ):
95         expected_id = 42
96         expected_value = object()
97         minions = {expected_id: expected_value}
98         no_data_event = salt.ext.tornado.gen.Future()
99         no_data_event.set_result({"data": {}})
100         empty_return_event = salt.ext.tornado.gen.Future()
101         empty_return_event.set_result({"data": {"return": {}}})
102         actual_return_event = salt.ext.tornado.gen.Future()
103         actual_return_event.set_result(
104             {"data": {"return": {"something happened here": "OK?"}, "id": expected_id}}
105         )
106         timed_out_event = salt.ext.tornado.gen.Future()
107         timed_out_event.set_exception(saltnado.TimeoutException())
108         self.mock.event_listener.get_event.side_effect = [
109             no_data_event,
110             empty_return_event,
111             actual_return_event,
112             timed_out_event,
113             timed_out_event,
114         ]
115         yield self.handler.job_not_running(
116             jid=99,
117             tgt="*",
118             tgt_type="fnord",
119             minions=minions,
120             is_finished=salt.ext.tornado.gen.Future(),
121         )
122         self.assertIs(minions[expected_id], expected_value)
123     @salt.ext.tornado.testing.gen_test
124     def test_when_event_returns_early_and_finally_times_out_result_should_be_True(self):
125         no_data_event = salt.ext.tornado.gen.Future()
126         no_data_event.set_result({"data": {}})
127         empty_return_event = salt.ext.tornado.gen.Future()
128         empty_return_event.set_result({"data": {"return": {}}})
129         actual_return_event = salt.ext.tornado.gen.Future()
130         actual_return_event.set_result(
131             {"data": {"return": {"something happened here": "OK?"}, "id": "fnord"}}
132         )
133         timed_out_event = salt.ext.tornado.gen.Future()
134         timed_out_event.set_exception(saltnado.TimeoutException())
135         self.mock.event_listener.get_event.side_effect = [
136             no_data_event,
137             empty_return_event,
138             actual_return_event,
139             timed_out_event,
140             timed_out_event,
141         ]
142         result = yield self.handler.job_not_running(
143             jid=99,
144             tgt="*",
145             tgt_type="fnord",
146             minions={},
147             is_finished=salt.ext.tornado.gen.Future(),
148         )
149         self.assertTrue(result)
150     @salt.ext.tornado.testing.gen_test
151     def test_when_event_finishes_but_is_finished_is_done_then_result_should_be_True(
152         self,
153     ):
154         expected_minion_id = "fnord"
155         expected_minion_value = object()
156         no_data_event = salt.ext.tornado.gen.Future()
157         no_data_event.set_result({"data": {}})
158         empty_return_event = salt.ext.tornado.gen.Future()
159         empty_return_event.set_result({"data": {"return": {}}})
160         actual_return_event = salt.ext.tornado.gen.Future()
161         actual_return_event.set_result(
162             {
163                 "data": {
164                     "return": {"something happened here": "OK?"},
165                     "id": expected_minion_id,
166                 }
167             }
168         )
169         is_finished = salt.ext.tornado.gen.Future()
170         def abort(*args, **kwargs):
171             yield actual_return_event
172             f = salt.ext.tornado.gen.Future()
173             f.set_exception(saltnado.TimeoutException())
174             is_finished.set_result("This is done")
175             yield f
176             assert False, "Never should make it here"
177         minions = {expected_minion_id: expected_minion_value}
178         self.mock.event_listener.get_event.side_effect = (x for x in abort())
179         result = yield self.handler.job_not_running(
180             jid=99,
181             tgt="*",
182             tgt_type="fnord",
183             minions=minions,
184             is_finished=is_finished,
185         )
186         self.assertTrue(result)
187         self.assertTrue(len(minions) == 1, str(minions))
188         self.assertIs(minions[expected_minion_id], expected_minion_value)
189     @salt.ext.tornado.testing.gen_test
190     def test_when_is_finished_times_out_before_event_finishes_result_should_be_True(
191         self,
192     ):
193         finished = salt.ext.tornado.gen.Future()
194         finished.set_exception(saltnado.TimeoutException())
195         wrong_future = salt.ext.tornado.gen.Future()
196         self.mock.event_listener.get_event.return_value = wrong_future
197         result = yield self.handler.job_not_running(
198             jid=42, tgt="*", tgt_type="glob", minions=[], is_finished=finished
199         )
200         self.assertTrue(result)
201     @salt.ext.tornado.testing.gen_test
202     def test_when_is_finished_times_out_before_event_finishes_event_should_have_result_set_to_None(
203         self,
204     ):
205         finished = salt.ext.tornado.gen.Future()
206         finished.set_exception(saltnado.TimeoutException())
207         wrong_future = salt.ext.tornado.gen.Future()
208         self.mock.event_listener.get_event.return_value = wrong_future
209         result = yield self.handler.job_not_running(
210             jid=42, tgt="*", tgt_type="glob", minions=[], is_finished=finished
211         )
212         self.assertIsNone(wrong_future.result())
213 class TestGetMinionReturns(salt.ext.tornado.testing.AsyncTestCase):
214     def setUp(self):
215         super().setUp()
216         self.mock = MagicMock()
217         self.mock.opts = {
218             "syndic_wait": 0.1,
219             "cachedir": "/tmp/testing/cachedir",
220             "sock_dir": "/tmp/testing/sock_drawer",
221             "transport": "zeromq",
222             "extension_modules": "/tmp/testing/moduuuuules",
223             "order_masters": False,
224             "gather_job_timeout": 10.001,
225         }
226         self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
227         f = salt.ext.tornado.gen.Future()
228         f.set_result({"jid": f, "minions": []})
229     @salt.ext.tornado.testing.gen_test
230     def test_if_finished_before_any_events_return_then_result_should_be_empty_dictionary(
231         self,
232     ):
233         expected_result = {}
234         xxx = salt.ext.tornado.gen.Future()
235         xxx.set_result(None)
236         is_finished = salt.ext.tornado.gen.Future()
237         is_finished.set_result(None)
238         actual_result = yield self.handler.get_minion_returns(
239             events=[],
240             is_finished=is_finished,
241             is_timed_out=salt.ext.tornado.gen.Future(),
242             min_wait_time=xxx,
243             minions={},
244         )
245         self.assertDictEqual(actual_result, expected_result)
246     @salt.ext.tornado.testing.gen_test
247     def test_if_is_finished_after_events_return_then_result_should_contain_event_result_data(
248         self,
249     ):
250         expected_result = {
251             "minion1": {"fnord": "this is some fnordish data"},
252             "minion2": {"fnord": "this is some other fnordish data"},
253         }
254         xxx = salt.ext.tornado.gen.Future()
255         xxx.set_result(None)
256         is_finished = salt.ext.tornado.gen.Future()
257         events = [
258             salt.ext.tornado.gen.Future(),
259             salt.ext.tornado.gen.Future(),
260             salt.ext.tornado.gen.Future(),
261             salt.ext.tornado.gen.Future(),
262         ]
263         events[0].set_result(
264             {
265                 "tag": "fnord",
266                 "data": {"id": "minion1", "return": expected_result["minion1"]},
267             }
268         )
269         events[1].set_result(
270             {
271                 "tag": "fnord",
272                 "data": {"id": "minion2", "return": expected_result["minion2"]},
273             }
274         )
275         self.io_loop.call_later(0.2, lambda: is_finished.set_result(None))
276         actual_result = yield self.handler.get_minion_returns(
277             events=events,
278             is_finished=is_finished,
279             is_timed_out=salt.ext.tornado.gen.Future(),
280             min_wait_time=xxx,
281             minions={
282                 "minion1": False,
283                 "minion2": False,
284                 "never returning minion": False,
285             },
286         )
287         assert actual_result == expected_result
288     @salt.ext.tornado.testing.gen_test
289     def test_if_timed_out_after_events_return_then_result_should_contain_event_result_data(
290         self,
291     ):
292         expected_result = {
293             "minion1": {"fnord": "this is some fnordish data"},
294             "minion2": {"fnord": "this is some other fnordish data"},
295         }
296         xxx = salt.ext.tornado.gen.Future()
297         xxx.set_result(None)
298         is_timed_out = salt.ext.tornado.gen.Future()
299         events = [
300             salt.ext.tornado.gen.Future(),
301             salt.ext.tornado.gen.Future(),
302             salt.ext.tornado.gen.Future(),
303             salt.ext.tornado.gen.Future(),
304         ]
305         events[0].set_result(
306             {
307                 "tag": "fnord",
308                 "data": {"id": "minion1", "return": expected_result["minion1"]},
309             }
310         )
311         events[1].set_result(
312             {
313                 "tag": "fnord",
314                 "data": {"id": "minion2", "return": expected_result["minion2"]},
315             }
316         )
317         self.io_loop.call_later(0.2, lambda: is_timed_out.set_result(None))
318         actual_result = yield self.handler.get_minion_returns(
319             events=events,
320             is_finished=salt.ext.tornado.gen.Future(),
321             is_timed_out=is_timed_out,
322             min_wait_time=xxx,
323             minions={
324                 "minion1": False,
325                 "minion2": False,
326                 "never returning minion": False,
327             },
328         )
329         assert actual_result == expected_result
330     @salt.ext.tornado.testing.gen_test
331     def test_if_wait_timer_is_not_done_even_though_results_are_then_data_should_not_yet_be_returned(
332         self,
333     ):
334         expected_result = {
335             "one": {"fnordy one": "one has some data"},
336             "two": {"fnordy two": "two has some data"},
337         }
338         events = [salt.ext.tornado.gen.Future(), salt.ext.tornado.gen.Future()]
339         events[0].set_result(
340             {"tag": "fnord", "data": {"id": "one", "return": expected_result["one"]}}
341         )
342         events[1].set_result(
343             {"tag": "fnord", "data": {"id": "two", "return": expected_result["two"]}}
344         )
345 <a name="1"></a>        wait_timer = salt.ext.tornado.gen.Future()
346         fut = self.handler.get_minion_returns(
347             events=events,
348             is_finished=salt.ext<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.tornado.gen.Future(),
349             is_timed_out=salt.ext.tornado.gen.Future(),
350             min_wait_time=wait_timer,
351             minions=</b></font>{"one": False, "two": False},
352         )
353         def boop():
354             yield fut
355         self.io_loop.spawn_callback(boop)
356         yield salt.ext.tornado.gen.sleep(0.1)
357         assert not fut.done()
358         wait_timer.set_result(None)
359         actual_result = yield fut
360         assert actual_result == expected_result
361     @salt.ext.tornado.testing.gen_test
362     def test_when_is_finished_any_other_futures_should_be_canceled(self):
363         events = [
364             salt.ext.tornado.gen.Future(),
365             salt.ext.tornado.gen.Future(),
366             salt.ext.tornado.gen.Future(),
367             salt.ext.tornado.gen.Future(),
368             salt.ext.tornado.gen.Future(),
369         ]
370         is_finished = salt.ext.tornado.gen.Future()
371         is_finished.set_result(None)
372         yield self.handler.get_minion_returns(
373             events=events,
374             is_finished=is_finished,
375             is_timed_out=salt.ext.tornado.gen.Future(),
376             min_wait_time=salt.ext.tornado.gen.Future(),
377             minions={"one": False, "two": False},
378         )
379         are_done = [event.done() for event in events]
380         assert all(are_done)
381     @salt.ext.tornado.testing.gen_test
382     def test_when_an_event_times_out_then_we_should_not_enter_an_infinite_loop(self):
383         events = [
384             salt.ext.tornado.gen.Future(),
385             salt.ext.tornado.gen.Future(),
386             salt.ext.tornado.gen.Future(),
387             salt.ext.tornado.gen.Future(),
388             salt.ext.tornado.gen.Future(),
389         ]
390         events[3].set_exception(saltnado.TimeoutException())
391         times_out_later = salt.ext.tornado.gen.Future()
392         self.io_loop.call_later(0.5, lambda: times_out_later.set_result(None))
393         yield self.handler.get_minion_returns(
394             events=events,
395             is_finished=salt.ext.tornado.gen.Future(),
396             is_timed_out=times_out_later,
397             min_wait_time=salt.ext.tornado.gen.Future(),
398             minions={"one": False, "two": False},
399         )
400         are_done = [event.done() for event in events]
401         assert all(are_done)
402         assert times_out_later.done()
403     @salt.ext.tornado.testing.gen_test
404     def test_when_is_timed_out_any_other_futures_should_be_canceled(self):
405         events = [
406             salt.ext.tornado.gen.Future(),
407             salt.ext.tornado.gen.Future(),
408             salt.ext.tornado.gen.Future(),
409             salt.ext.tornado.gen.Future(),
410             salt.ext.tornado.gen.Future(),
411         ]
412         is_timed_out = salt.ext.tornado.gen.Future()
413         is_timed_out.set_result(None)
414         yield self.handler.get_minion_returns(
415             events=events,
416             is_finished=salt.ext.tornado.gen.Future(),
417             is_timed_out=is_timed_out,
418             min_wait_time=salt.ext.tornado.gen.Future(),
419             minions={"one": False, "two": False},
420         )
421         are_done = [event.done() for event in events]
422         assert all(are_done)
423     @salt.ext.tornado.testing.gen_test
424     def test_when_min_wait_time_and_nothing_todo_any_other_futures_should_be_canceled(
425         self,
426     ):
427         events = [
428             salt.ext.tornado.gen.Future(),
429             salt.ext.tornado.gen.Future(),
430             salt.ext.tornado.gen.Future(),
431             salt.ext.tornado.gen.Future(),
432             salt.ext.tornado.gen.Future(),
433         ]
434         is_finished = salt.ext.tornado.gen.Future()
435         min_wait_time = salt.ext.tornado.gen.Future()
436         self.io_loop.call_later(0.2, lambda: min_wait_time.set_result(None))
437         yield self.handler.get_minion_returns(
438             events=events,
439             is_finished=is_finished,
440             is_timed_out=salt.ext.tornado.gen.Future(),
441             min_wait_time=min_wait_time,
442             minions={"one": True, "two": True},
443         )
444         are_done = [event.done() for event in events] + [is_finished.done()]
445         assert all(are_done)
446     @salt.ext.tornado.testing.gen_test
447     def test_when_is_finished_but_not_is_timed_out_then_timed_out_should_not_be_set_to_done(
448         self,
449     ):
450         events = [salt.ext.tornado.gen.Future()]
451         is_timed_out = salt.ext.tornado.gen.Future()
452         is_finished = salt.ext.tornado.gen.Future()
453         is_finished.set_result(None)
454         yield self.handler.get_minion_returns(
455             events=events,
456             is_finished=is_finished,
457             is_timed_out=is_timed_out,
458             min_wait_time=salt.ext.tornado.gen.Future(),
459             minions={"one": False, "two": False},
460         )
461         assert not is_timed_out.done()
462     @salt.ext.tornado.testing.gen_test
463     def test_when_min_wait_time_and_all_completed_but_not_is_timed_out_then_timed_out_should_not_be_set_to_done(
464         self,
465     ):
466         events = [salt.ext.tornado.gen.Future()]
467         is_timed_out = salt.ext.tornado.gen.Future()
468         min_wait_time = salt.ext.tornado.gen.Future()
469         self.io_loop.call_later(0.2, lambda: min_wait_time.set_result(None))
470         yield self.handler.get_minion_returns(
471             events=events,
472             is_finished=salt.ext.tornado.gen.Future(),
473             is_timed_out=is_timed_out,
474             min_wait_time=min_wait_time,
475             minions={"one": True},
476         )
477         assert not is_timed_out.done()
478     @salt.ext.tornado.testing.gen_test
479     def test_when_things_are_completed_but_not_timed_out_then_timed_out_event_should_not_be_done(
480         self,
481     ):
482         events = [
483             salt.ext.tornado.gen.Future(),
484         ]
485         events[0].set_result({"tag": "fnord", "data": {"id": "one", "return": {}}})
486         min_wait_time = salt.ext.tornado.gen.Future()
487         min_wait_time.set_result(None)
488         is_timed_out = salt.ext.tornado.gen.Future()
489         yield self.handler.get_minion_returns(
490             events=events,
491             is_finished=salt.ext.tornado.gen.Future(),
492             is_timed_out=is_timed_out,
493             min_wait_time=min_wait_time,
494             minions={"one": True},
495         )
496         assert not is_timed_out.done()
497 class TestDisbatchLocal(salt.ext.tornado.testing.AsyncTestCase):
498     def setUp(self):
499         super().setUp()
500         self.mock = MagicMock()
501         self.mock.opts = {
502             "syndic_wait": 0.1,
503             "cachedir": "/tmp/testing/cachedir",
504             "sock_dir": "/tmp/testing/sock_drawer",
505             "transport": "zeromq",
506             "extension_modules": "/tmp/testing/moduuuuules",
507             "order_masters": False,
508             "gather_job_timeout": 10.001,
509         }
510         self.handler = saltnado.SaltAPIHandler(self.mock, self.mock)
511     @salt.ext.tornado.testing.gen_test
512 <a name="0"></a>    def test_when_is_timed_out_is_set_before_other_events_are_completed_then_result_should_be_empty_dictionary(
513         self,
514     ):
515         completed_event = salt.ext<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.tornado.gen.Future()
516         never_completed = salt.ext.tornado.gen.Future()
517         gather_timeout = 0.1
518         event_timeout =</b></font> gather_timeout + 0.05
519         def fancy_get_event(*args, **kwargs):
520             if kwargs.get("tag").endswith("/ret"):
521                 return never_completed
522             return completed_event
523         def completer():
524             completed_event.set_result(
525                 {
526                     "tag": "fnord",
527                     "data": {
528                         "return": "This should never be in chunk_ret",
529                         "id": "fnord",
530                     },
531                 }
532             )
533         self.io_loop.call_later(event_timeout, completer)
534         f = salt.ext.tornado.gen.Future()
535         f.set_result({"jid": "42", "minions": []})
536         with patch.object(
537             self.handler.application.event_listener,
538             "get_event",
539             autospec=True,
540             side_effect=fancy_get_event,
541         ), patch.dict(
542             self.handler.application.opts,
543             {"gather_job_timeout": gather_timeout, "timeout": 42},
544         ), patch.dict(
545             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
546         ):
547             result = yield self.handler._disbatch_local(
548                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
549             )
550         assert result == {}
551     @salt.ext.tornado.testing.gen_test
552     def test_when_is_finished_is_set_before_events_return_then_no_data_should_be_returned(
553         self,
554     ):
555         completed_event = salt.ext.tornado.gen.Future()
556         never_completed = salt.ext.tornado.gen.Future()
557         gather_timeout = 2
558         event_timeout = gather_timeout - 1
559         def fancy_get_event(*args, **kwargs):
560             if kwargs.get("tag").endswith("/ret"):
561                 return never_completed
562             return completed_event
563         def completer():
564             completed_event.set_result(
565                 {
566                     "tag": "fnord",
567                     "data": {
568                         "return": "This should never be in chunk_ret",
569                         "id": "fnord",
570                     },
571                 }
572             )
573         self.io_loop.call_later(event_timeout, completer)
574         def toggle_is_finished(*args, **kwargs):
575             finished = kwargs.get("is_finished", args[4] if len(args) &gt; 4 else None)
576             assert finished is not None
577             finished.set_result(42)
578         f = salt.ext.tornado.gen.Future()
579         f.set_result({"jid": "42", "minions": []})
580         with patch.object(
581             self.handler.application.event_listener,
582             "get_event",
583             autospec=True,
584             side_effect=fancy_get_event,
585         ), patch.object(
586             self.handler,
587             "job_not_running",
588             autospec=True,
589             side_effect=toggle_is_finished,
590         ), patch.dict(
591             self.handler.application.opts,
592             {"gather_job_timeout": gather_timeout, "timeout": 42},
593         ), patch.dict(
594             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
595         ):
596             result = yield self.handler._disbatch_local(
597                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
598             )
599         assert result == {}
600     @salt.ext.tornado.testing.gen_test
601     def test_when_is_finished_then_all_collected_data_should_be_returned(self):
602         completed_event = salt.ext.tornado.gen.Future()
603         never_completed = salt.ext.tornado.gen.Future()
604         gather_timeout = 42
605         completed_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
606         for i, event in enumerate(completed_events):
607             event.set_result(
608                 {
609                     "tag": "fnord",
610                     "data": {
611                         "return": "return from fnord {}".format(i),
612                         "id": "fnord {}".format(i),
613                     },
614                 }
615             )
616         uncompleted_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
617         events = iter(completed_events + uncompleted_events)
618         expected_result = {
619             "fnord 0": "return from fnord 0",
620             "fnord 1": "return from fnord 1",
621             "fnord 2": "return from fnord 2",
622             "fnord 3": "return from fnord 3",
623             "fnord 4": "return from fnord 4",
624         }
625         def fancy_get_event(*args, **kwargs):
626             if kwargs.get("tag").endswith("/ret"):
627                 return never_completed
628             else:
629                 return next(events)
630         def toggle_is_finished(*args, **kwargs):
631             finished = kwargs.get("is_finished", args[4] if len(args) &gt; 4 else None)
632             assert finished is not None
633             finished.set_result(42)
634         f = salt.ext.tornado.gen.Future()
635         f.set_result({"jid": "42", "minions": ["non-existent minion"]})
636         with patch.object(
637             self.handler.application.event_listener,
638             "get_event",
639             autospec=True,
640             side_effect=fancy_get_event,
641         ), patch.object(
642             self.handler,
643             "job_not_running",
644             autospec=True,
645             side_effect=toggle_is_finished,
646         ), patch.dict(
647             self.handler.application.opts,
648             {"gather_job_timeout": gather_timeout, "timeout": 42},
649         ), patch.dict(
650             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
651         ):
652             result = yield self.handler._disbatch_local(
653                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
654             )
655         assert result == expected_result
656     @salt.ext.tornado.testing.gen_test
657     def test_when_is_timed_out_then_all_collected_data_should_be_returned(self):
658         completed_event = salt.ext.tornado.gen.Future()
659         never_completed = salt.ext.tornado.gen.Future()
660         gather_timeout = 2
661         completed_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
662         for i, event in enumerate(completed_events):
663             event.set_result(
664                 {
665                     "tag": "fnord",
666                     "data": {
667                         "return": "return from fnord {}".format(i),
668                         "id": "fnord {}".format(i),
669                     },
670                 }
671             )
672         uncompleted_events = [salt.ext.tornado.gen.Future() for _ in range(5)]
673         events = iter(completed_events + uncompleted_events)
674         expected_result = {
675             "fnord 0": "return from fnord 0",
676             "fnord 1": "return from fnord 1",
677             "fnord 2": "return from fnord 2",
678             "fnord 3": "return from fnord 3",
679             "fnord 4": "return from fnord 4",
680         }
681         def fancy_get_event(*args, **kwargs):
682             if kwargs.get("tag").endswith("/ret"):
683                 return never_completed
684             else:
685                 return next(events)
686         f = salt.ext.tornado.gen.Future()
687         f.set_result({"jid": "42", "minions": ["non-existent minion"]})
688         with patch.object(
689             self.handler.application.event_listener,
690             "get_event",
691             autospec=True,
692             side_effect=fancy_get_event,
693         ), patch.dict(
694             self.handler.application.opts,
695             {"gather_job_timeout": gather_timeout, "timeout": 42},
696         ), patch.dict(
697             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
698         ):
699             result = yield self.handler._disbatch_local(
700                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
701             )
702         assert result == expected_result
703     @salt.ext.tornado.testing.gen_test
704     def test_when_minions_all_return_then_all_collected_data_should_be_returned(self):
705         completed_event = salt.ext.tornado.gen.Future()
706         never_completed = salt.ext.tornado.gen.Future()
707         gather_timeout = 20
708         completed_events = [salt.ext.tornado.gen.Future() for _ in range(10)]
709         events_by_id = {}
710         for i, event in enumerate(completed_events):
711             id_ = "fnord {}".format(i)
712             events_by_id[id_] = event
713             event.set_result(
714                 {
715                     "tag": "fnord",
716                     "data": {"return": "return from {}".format(id_), "id": id_},
717                 }
718             )
719         expected_result = {
720             "fnord 0": "return from fnord 0",
721             "fnord 1": "return from fnord 1",
722             "fnord 2": "return from fnord 2",
723             "fnord 3": "return from fnord 3",
724             "fnord 4": "return from fnord 4",
725             "fnord 5": "return from fnord 5",
726             "fnord 6": "return from fnord 6",
727             "fnord 7": "return from fnord 7",
728             "fnord 8": "return from fnord 8",
729             "fnord 9": "return from fnord 9",
730         }
731         def fancy_get_event(*args, **kwargs):
732             tag = kwargs.get("tag", "").rpartition("/")[-1]
733             return events_by_id.get(tag, never_completed)
734         f = salt.ext.tornado.gen.Future()
735         f.set_result(
736             {
737                 "jid": "42",
738                 "minions": [e.result()["data"]["id"] for e in completed_events],
739             }
740         )
741         with patch.object(
742             self.handler.application.event_listener,
743             "get_event",
744             autospec=True,
745             side_effect=fancy_get_event,
746         ), patch.dict(
747             self.handler.application.opts,
748             {"gather_job_timeout": gather_timeout, "timeout": 42},
749         ), patch.dict(
750             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
751         ):
752             result = yield self.handler._disbatch_local(
753                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
754             )
755         assert result == expected_result
756     @salt.ext.tornado.testing.gen_test
757     def test_when_min_wait_time_has_not_passed_then_disbatch_should_not_return_expected_data_until_time_has_passed(
758         self,
759     ):
760         completed_event = salt.ext.tornado.gen.Future()
761         never_completed = salt.ext.tornado.gen.Future()
762         wait_timer = salt.ext.tornado.gen.Future()
763         gather_timeout = 20
764         completed_events = [salt.ext.tornado.gen.Future() for _ in range(10)]
765         events_by_id = {}
766         for i, event in enumerate(completed_events):
767             id_ = "fnord {}".format(i)
768             events_by_id[id_] = event
769             event.set_result(
770                 {
771                     "tag": "fnord",
772                     "data": {"return": "return from {}".format(id_), "id": id_},
773                 }
774             )
775         expected_result = {
776             "fnord 0": "return from fnord 0",
777             "fnord 1": "return from fnord 1",
778             "fnord 2": "return from fnord 2",
779             "fnord 3": "return from fnord 3",
780             "fnord 4": "return from fnord 4",
781             "fnord 5": "return from fnord 5",
782             "fnord 6": "return from fnord 6",
783             "fnord 7": "return from fnord 7",
784             "fnord 8": "return from fnord 8",
785             "fnord 9": "return from fnord 9",
786         }
787         def fancy_get_event(*args, **kwargs):
788             tag = kwargs.get("tag", "").rpartition("/")[-1]
789             return events_by_id.get(tag, never_completed)
790         minions = {}
791         def capture_minions(*args, **kwargs):
792             nonlocal minions
793             minions = args[3]
794         orig_sleep = salt.ext.tornado.gen.sleep
795         fakeo_timer = object()
796         @salt.ext.tornado.gen.coroutine
797         def fake_sleep(timer):
798             if timer is fakeo_timer:
799                 yield wait_timer
800             else:
801                 yield orig_sleep(timer)
802         f = salt.ext.tornado.gen.Future()
803         f.set_result(
804             {
805                 "jid": "42",
806                 "minions": [e.result()["data"]["id"] for e in completed_events],
807             }
808         )
809         with patch.object(
810             self.handler.application.event_listener,
811             "get_event",
812             autospec=True,
813             side_effect=fancy_get_event,
814         ), patch.object(
815             self.handler,
816             "job_not_running",
817             autospec=True,
818             side_effect=capture_minions,
819         ), patch.dict(
820             self.handler.application.opts,
821             {
822                 "gather_job_timeout": gather_timeout,
823                 "timeout": 42,
824                 "syndic_wait": fakeo_timer,
825                 "order_masters": True,
826             },
827         ), patch(
828             "salt.ext.tornado.gen.sleep",
829             autospec=True,
830             side_effect=fake_sleep,
831         ), patch.dict(
832             self.handler.saltclients, {"local": lambda *args, **kwargs: f}
833         ):
834             fut = self.handler._disbatch_local(
835                 chunk={"tgt": "*", "tgt_type": "glob", "fun": "test.ping"}
836             )
837             def boop():
838                 yield fut
839             self.io_loop.spawn_callback(boop)
840             yield salt.ext.tornado.gen.sleep(0.1)
841             assert all(minions[m_id] for m_id in minions)
842             assert not fut.done()
843             wait_timer.set_result(None)
844             result = yield fut
845         assert result == expected_result
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
