<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_botomod.py &amp; proxmox.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_botomod.py &amp; proxmox.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_botomod.py (3.7383177%)<th>proxmox.py (0.81632656%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(26-38)<td><a href="#" name="0">(44-56)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_botomod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import salt.utils.boto3mod as boto3mod
3 import salt.utils.botomod as botomod
4 from salt.exceptions import SaltInvocationError
5 from salt.utils.versions import LooseVersion
6 from tests.support.mixins import LoaderModuleMockMixin
7 from tests.support.mock import MagicMock, patch
8 from tests.support.runtests import RUNTIME_VARS
9 from tests.support.unit import TestCase, skipIf
10 try:
11     import boto
12     boto.ENDPOINTS_PATH = os.path.join(
13         RUNTIME_VARS.TESTS_DIR, "unit/files/endpoints.json"
14     )
15     import boto.exception
16     from boto.exception import BotoServerError
17     HAS_BOTO = True
18     HAS_BOTO = False
19 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try:
20     import boto3
21     HAS_BOTO3 = True
22 except ImportError:
23     HAS_BOTO3 = False
24 try:
25     from moto import mock_ec2
26     HAS_MOTO = True
27 except ImportError:
28     HAS_MOTO =</b></font> False
29     def mock_ec2(self):
30         def stub_function(self):
31             pass
32         return stub_function
33 required_boto_version = "2.0.0"
34 required_boto3_version = "1.2.1"
35 region = "us-east-1"
36 access_key = "GKTADJGHEIQSXMKKRBJ08H"
37 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
38 conn_parameters = {
39     "region": region,
40     "key": access_key,
41     "keyid": secret_key,
42     "profile": {},
43 }
44 service = "ec2"
45 resource_name = "test-instance"
46 resource_id = "i-a1b2c3"
47 error_body = """
48 &lt;Response&gt;
49     &lt;Errors&gt;
50          &lt;Error&gt;
51            &lt;Code&gt;Error code text&lt;/Code&gt;
52            &lt;Message&gt;Error message&lt;/Message&gt;
53          &lt;/Error&gt;
54     &lt;/Errors&gt;
55     &lt;RequestID&gt;request ID&lt;/RequestID&gt;
56 &lt;/Response&gt;
57 """
58 no_error_body = """
59 &lt;Response&gt;
60     &lt;Errors /&gt;
61     &lt;RequestID&gt;request ID&lt;/RequestID&gt;
62 &lt;/Response&gt;
63 """
64 def _has_required_boto():
65     if not HAS_BOTO:
66         return False
67     elif LooseVersion(boto.__version__) &lt; LooseVersion(required_boto_version):
68         return False
69     else:
70         return True
71 def _has_required_boto3():
72     try:
73         if not HAS_BOTO3:
74             return False
75         elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
76             return False
77         else:
78             return True
79     except AttributeError as exc:
80         if "has no attribute '__version__'" not in str(exc):
81             raise
82         return False
83 def _has_required_moto():
84     if not HAS_MOTO:
85         return False
86     else:
87         import pkg_resources
88         if LooseVersion(pkg_resources.get_distribution("moto").version) &lt; LooseVersion(
89             "0.3.7"
90         ):
91             return False
92         return True
93 class BotoUtilsTestCaseBase(TestCase, LoaderModuleMockMixin):
94     def setup_loader_modules(self):
95         module_globals = {
96             "__salt__": {"config.option": MagicMock(return_value="dummy_opt")}
97         }
98         return {botomod: module_globals, boto3mod: module_globals}
99 class BotoUtilsCacheIdTestCase(BotoUtilsTestCaseBase):
100     def test_set_and_get_with_no_auth_params(self):
101         botomod.cache_id(service, resource_name, resource_id=resource_id)
102         self.assertEqual(botomod.cache_id(service, resource_name), resource_id)
103     def test_set_and_get_with_explicit_auth_params(self):
104         botomod.cache_id(
105             service, resource_name, resource_id=resource_id, **conn_parameters
106         )
107         self.assertEqual(
108             botomod.cache_id(service, resource_name, **conn_parameters), resource_id
109         )
110     def test_set_and_get_with_different_region_returns_none(self):
111         botomod.cache_id(
112             service, resource_name, resource_id=resource_id, region="us-east-1"
113         )
114         self.assertEqual(
115             botomod.cache_id(service, resource_name, region="us-west-2"), None
116         )
117     def test_set_and_get_after_invalidation_returns_none(self):
118         botomod.cache_id(service, resource_name, resource_id=resource_id)
119         botomod.cache_id(
120             service, resource_name, resource_id=resource_id, invalidate=True
121         )
122         self.assertEqual(botomod.cache_id(service, resource_name), None)
123     def test_partial(self):
124         cache_id = botomod.cache_id_func(service)
125         cache_id(resource_name, resource_id=resource_id)
126         self.assertEqual(cache_id(resource_name), resource_id)
127 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
128 @skipIf(HAS_MOTO is False, "The moto module must be installed.")
129 @skipIf(
130     _has_required_boto() is False,
131     "The boto module must be greater than or equal to version {}".format(
132         required_boto_version
133     ),
134 )
135 class BotoUtilsGetConnTestCase(BotoUtilsTestCaseBase):
136     @mock_ec2
137     def test_conn_is_cached(self):
138         conn = botomod.get_connection(service, **conn_parameters)
139         self.assertTrue(conn in botomod.__context__.values())
140     @mock_ec2
141     def test_conn_is_cache_with_profile(self):
142         conn = botomod.get_connection(service, profile=conn_parameters)
143         self.assertTrue(conn in botomod.__context__.values())
144     @mock_ec2
145     def test_get_conn_with_no_auth_params_raises_invocation_error(self):
146         with patch(
147             "boto.{}.connect_to_region".format(service),
148             side_effect=boto.exception.NoAuthHandlerFound(),
149         ):
150             with self.assertRaises(SaltInvocationError):
151                 botomod.get_connection(service)
152     @mock_ec2
153     def test_get_conn_error_raises_command_execution_error(self):
154         with patch(
155             "boto.{}.connect_to_region".format(service),
156             side_effect=BotoServerError(400, "Mocked error", body=error_body),
157         ):
158             with self.assertRaises(BotoServerError):
159                 botomod.get_connection(service)
160     @mock_ec2
161     def test_partial(self):
162         get_conn = botomod.get_connection_func(service)
163         conn = get_conn(**conn_parameters)
164         self.assertTrue(conn in botomod.__context__.values())
165 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
166 @skipIf(
167     _has_required_boto() is False,
168     "The boto module must be greater than or equal to version {}".format(
169         required_boto_version
170     ),
171 )
172 class BotoUtilsGetErrorTestCase(BotoUtilsTestCaseBase):
173     def test_error_message(self):
174         e = BotoServerError("400", "Mocked error", body=error_body)
175         r = botomod.get_error(e)
176         expected = {
177             "aws": {
178                 "code": "Error code text",
179                 "message": "Error message",
180                 "reason": "Mocked error",
181                 "status": "400",
182             },
183             "message": "Mocked error: Error message",
184         }
185         self.assertEqual(r, expected)
186     def test_exception_message_with_no_body(self):
187         e = BotoServerError("400", "Mocked error")
188         r = botomod.get_error(e)
189         expected = {
190             "aws": {"reason": "Mocked error", "status": "400"},
191             "message": "Mocked error",
192         }
193         self.assertEqual(r, expected)
194     def test_exception_message_with_no_error_in_body(self):
195         e = BotoServerError("400", "Mocked error", body=no_error_body)
196         r = botomod.get_error(e)
197         expected = {
198             "aws": {"reason": "Mocked error", "status": "400"},
199             "message": "Mocked error",
200         }
201         self.assertEqual(r, expected)
202 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
203 @skipIf(
204     _has_required_boto() is False,
205     "The boto module must be greater than or equal to version {}".format(
206         required_boto_version
207     ),
208 )
209 @skipIf(HAS_BOTO3 is False, "The boto3 module must be installed.")
210 @skipIf(
211     _has_required_boto3() is False,
212     "The boto3 module must be greater than or equal to version {}".format(
213         required_boto3_version
214     ),
215 )
216 class BotoBoto3CacheContextCollisionTest(BotoUtilsTestCaseBase):
217     def test_context_conflict_between_boto_and_boto3_utils(self):
218         botomod.assign_funcs(__name__, "ec2")
219         boto3mod.assign_funcs(__name__, "ec2", get_conn_funcname="_get_conn3")
220         boto_ec2_conn = botomod.get_connection(
221             "ec2", region=region, key=secret_key, keyid=access_key
222         )
223         boto3_ec2_conn = boto3mod.get_connection(
224             "ec2", region=region, key=secret_key, keyid=access_key
225         )
226         self.assertNotEqual(id(boto_ec2_conn), id(boto3_ec2_conn))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>proxmox.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import pprint
3 import re
4 import socket
5 import time
6 import salt.config as config
7 import salt.utils.cloud
8 import salt.utils.json
9 from salt.exceptions import (
10     SaltCloudExecutionFailure,
11     SaltCloudExecutionTimeout,
12 )
13 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try:
14     import requests
15     HAS_REQUESTS = True
16 except ImportError:
17     HAS_REQUESTS = False
18 try:
19     from IPy import IP
20     HAS_IPY = True
21 except ImportError:
22     HAS_IPY =</b></font> False
23 log = logging.getLogger(__name__)
24 __virtualname__ = "proxmox"
25 def __virtual__():
26     if get_configured_provider() is False:
27         return False
28     if get_dependencies() is False:
29         return False
30     return __virtualname__
31 def _get_active_provider_name():
32     try:
33         return __active_provider_name__.value()
34     except AttributeError:
35         return __active_provider_name__
36 def get_configured_provider():
37     return config.is_provider_configured(
38         __opts__, _get_active_provider_name() or __virtualname__, ("user",)
39     )
40 def get_dependencies():
41     deps = {"requests": HAS_REQUESTS, "IPy": HAS_IPY}
42     return config.check_driver_dependencies(__virtualname__, deps)
43 url = None
44 port = None
45 ticket = None
46 csrf = None
47 verify_ssl = None
48 api = None
49 def _authenticate():
50     global url, port, ticket, csrf, verify_ssl
51     url = config.get_cloud_config_value(
52         "url", get_configured_provider(), __opts__, search_global=False
53     )
54     port = config.get_cloud_config_value(
55         "port", get_configured_provider(), __opts__, default=8006, search_global=False
56     )
57     username = (
58         config.get_cloud_config_value(
59             "user", get_configured_provider(), __opts__, search_global=False
60         ),
61     )
62     passwd = config.get_cloud_config_value(
63         "password", get_configured_provider(), __opts__, search_global=False
64     )
65     verify_ssl = config.get_cloud_config_value(
66         "verify_ssl",
67         get_configured_provider(),
68         __opts__,
69         default=True,
70         search_global=False,
71     )
72     connect_data = {"username": username, "password": passwd}
73     full_url = "https://{}:{}/api2/json/access/ticket".format(url, port)
74     returned_data = requests.post(full_url, verify=verify_ssl, data=connect_data).json()
75     ticket = {"PVEAuthCookie": returned_data["data"]["ticket"]}
76     csrf = str(returned_data["data"]["CSRFPreventionToken"])
77 def query(conn_type, option, post_data=None):
78     if ticket is None or csrf is None or url is None:
79         log.debug("Not authenticated yet, doing that now..")
80         _authenticate()
81     full_url = "https://{}:{}/api2/json/{}".format(url, port, option)
82     log.debug("%s: %s (%s)", conn_type, full_url, post_data)
83     httpheaders = {
84         "Accept": "application/json",
85         "Content-Type": "application/x-www-form-urlencoded",
86         "User-Agent": "salt-cloud-proxmox",
87     }
88     if conn_type == "post":
89         httpheaders["CSRFPreventionToken"] = csrf
90         response = requests.post(
91             full_url,
92             verify=verify_ssl,
93             data=post_data,
94             cookies=ticket,
95             headers=httpheaders,
96         )
97     elif conn_type == "put":
98         httpheaders["CSRFPreventionToken"] = csrf
99         response = requests.put(
100             full_url,
101             verify=verify_ssl,
102             data=post_data,
103             cookies=ticket,
104             headers=httpheaders,
105         )
106     elif conn_type == "delete":
107         httpheaders["CSRFPreventionToken"] = csrf
108         response = requests.delete(
109             full_url,
110             verify=verify_ssl,
111             data=post_data,
112             cookies=ticket,
113             headers=httpheaders,
114         )
115     elif conn_type == "get":
116         response = requests.get(full_url, verify=verify_ssl, cookies=ticket)
117     response.raise_for_status()
118     try:
119         returned_data = response.json()
120         if "data" not in returned_data:
121             raise SaltCloudExecutionFailure
122         return returned_data["data"]
123     except Exception:  # pylint: disable=broad-except
124         log.error("Error in trying to process JSON")
125         log.error(response)
126 def _get_vm_by_name(name, allDetails=False):
127     vms = get_resources_vms(includeConfig=allDetails)
128     if name in vms:
129         return vms[name]
130     log.info('VM with name "%s" could not be found.', name)
131     return False
132 def _get_vm_by_id(vmid, allDetails=False):
133     for vm_name, vm_details in get_resources_vms(includeConfig=allDetails).items():
134         if str(vm_details["vmid"]) == str(vmid):
135             return vm_details
136     log.info('VM with ID "%s" could not be found.', vmid)
137     return False
138 def _get_next_vmid():
139     return int(query("get", "cluster/nextid"))
140 def _check_ip_available(ip_addr):
141     for vm_name, vm_details in get_resources_vms(includeConfig=True).items():
142         vm_config = vm_details["config"]
143         if ip_addr in vm_config["ip_address"] or vm_config["ip_address"] == ip_addr:
144             log.debug('IP "%s" is already defined', ip_addr)
145             return False
146     log.debug("IP '%s' is available to be defined", ip_addr)
147     return True
148 def _parse_proxmox_upid(node, vm_=None):
149     ret = {}
150     upid = node
151     node = node.split(":")
152     if node[0] == "UPID":
153         ret["node"] = str(node[1])
154         ret["pid"] = str(node[2])
155         ret["pstart"] = str(node[3])
156         ret["starttime"] = str(node[4])
157         ret["type"] = str(node[5])
158         ret["vmid"] = str(node[6])
159         ret["user"] = str(node[7])
160         ret["upid"] = str(upid)
161         if vm_ is not None and "technology" in vm_:
162             ret["technology"] = str(vm_["technology"])
163     return ret
164 def _lookup_proxmox_task(upid):
165     log.debug("Getting creation status for upid: %s", upid)
166     tasks = query("get", "cluster/tasks")
167     if tasks:
168         for task in tasks:
169             if task["upid"] == upid:
170                 log.debug("Found upid task: %s", task)
171                 return task
172     return False
173 def get_resources_nodes(call=None, resFilter=None):
174     log.debug("Getting resource: nodes.. (filter: %s)", resFilter)
175     resources = query("get", "cluster/resources")
176     ret = {}
177     for resource in resources:
178         if "type" in resource and resource["type"] == "node":
179             name = resource["node"]
180             ret[name] = resource
181     if resFilter is not None:
182         log.debug("Filter given: %s, returning requested resource: nodes", resFilter)
183         return ret[resFilter]
184     log.debug("Filter not given: %s, returning all resource: nodes", ret)
185     return ret
186 def get_resources_vms(call=None, resFilter=None, includeConfig=True):
187     timeoutTime = time.time() + 60
188     while True:
189         log.debug("Getting resource: vms.. (filter: %s)", resFilter)
190         resources = query("get", "cluster/resources")
191         ret = {}
192         badResource = False
193         for resource in resources:
194             if "type" in resource and resource["type"] in ["openvz", "qemu", "lxc"]:
195                 try:
196                     name = resource["name"]
197                 except KeyError:
198                     badResource = True
199                     log.debug("No name in VM resource %s", repr(resource))
200                     break
201                 ret[name] = resource
202                 if includeConfig:
203                     ret[name]["config"] = get_vmconfig(
204                         ret[name]["vmid"], ret[name]["node"], ret[name]["type"]
205                     )
206         if time.time() &gt; timeoutTime:
207             raise SaltCloudExecutionTimeout("FAILED to get the proxmox resources vms")
208         if not badResource:
209             break
210         time.sleep(0.5)
211     if resFilter is not None:
212         log.debug("Filter given: %s, returning requested resource: nodes", resFilter)
213         return ret[resFilter]
214     log.debug("Filter not given: %s, returning all resource: nodes", ret)
215     return ret
216 def script(vm_):
217     script_name = config.get_cloud_config_value("script", vm_, __opts__)
218     if not script_name:
219         script_name = "bootstrap-salt"
220     return salt.utils.cloud.os_script(
221         script_name,
222         vm_,
223         __opts__,
224         salt.utils.cloud.salt_config_to_yaml(
225             salt.utils.cloud.minion_config(__opts__, vm_)
226         ),
227     )
228 def avail_locations(call=None):
229     if call == "action":
230         raise SaltCloudSystemExit(
231             "The avail_locations function must be called with "
232             "-f or --function, or with the --list-locations option"
233         )
234     nodes = query("get", "nodes")
235     ret = {}
236     for node in nodes:
237         name = node["node"]
238         ret[name] = node
239     return ret
240 def avail_images(call=None, location="local"):
241     if call == "action":
242         raise SaltCloudSystemExit(
243             "The avail_images function must be called with "
244             "-f or --function, or with the --list-images option"
245         )
246     ret = {}
247     for host_name, host_details in avail_locations().items():
248         for item in query(
249             "get", "nodes/{}/storage/{}/content".format(host_name, location)
250         ):
251             ret[item["volid"]] = item
252     return ret
253 def list_nodes(call=None):
254     if call == "action":
255         raise SaltCloudSystemExit(
256             "The list_nodes function must be called with -f or --function."
257         )
258     ret = {}
259     for vm_name, vm_details in get_resources_vms(includeConfig=True).items():
260         log.debug("VM_Name: %s", vm_name)
261         log.debug("vm_details: %s", vm_details)
262         ret[vm_name] = {}
263         ret[vm_name]["id"] = str(vm_details["vmid"])
264         ret[vm_name]["image"] = str(vm_details["vmid"])
265         ret[vm_name]["size"] = str(vm_details["disk"])
266         ret[vm_name]["state"] = str(vm_details["status"])
267         private_ips = []
268         public_ips = []
269         if (
270             "ip_address" in vm_details["config"]
271             and vm_details["config"]["ip_address"] != "-"
272         ):
273             ips = vm_details["config"]["ip_address"].split(" ")
274             for ip_ in ips:
275                 if IP(ip_).iptype() == "PRIVATE":
276                     private_ips.append(str(ip_))
277                 else:
278                     public_ips.append(str(ip_))
279         ret[vm_name]["private_ips"] = private_ips
280         ret[vm_name]["public_ips"] = public_ips
281     return ret
282 def list_nodes_full(call=None):
283     if call == "action":
284         raise SaltCloudSystemExit(
285             "The list_nodes_full function must be called with -f or --function."
286         )
287     return get_resources_vms(includeConfig=True)
288 def list_nodes_select(call=None):
289     return salt.utils.cloud.list_nodes_select(
290         list_nodes_full(),
291         __opts__["query.selection"],
292         call,
293     )
294 def _stringlist_to_dictionary(input_string):
295     return dict(item.strip().split("=") for item in input_string.split(",") if item)
296 def _dictionary_to_stringlist(input_dict):
297     return ",".join("{}={}".format(k, input_dict[k]) for k in sorted(input_dict.keys()))
298 def _reconfigure_clone(vm_, vmid):
299     if not vm_.get("technology") == "qemu":
300         log.warning("Reconfiguring clones is only available under `qemu`")
301         return
302     log.info("Configuring cloned VM")
303     for setting in vm_:
304         if re.match(r"^(ide|sata|scsi)(\d+)$", setting):
305             postParams = {setting: vm_[setting]}
306             query(
307                 "post",
308                 "nodes/{}/qemu/{}/config".format(vm_["host"], vmid),
309                 postParams,
310             )
311         elif re.match(r"^net(\d+)$", setting):
312             data = query("get", "nodes/{}/qemu/{}/config".format(vm_["host"], vmid))
313             new_setting = {}
314             if setting in data:
315                 new_setting.update(_stringlist_to_dictionary(data[setting]))
316             new_setting.update(_stringlist_to_dictionary(vm_[setting]))
317             postParams = {setting: _dictionary_to_stringlist(new_setting)}
318             query(
319                 "post",
320                 "nodes/{}/qemu/{}/config".format(vm_["host"], vmid),
321                 postParams,
322             )
323 def create(vm_):
324     try:
325         if (
326             vm_["profile"]
327             and config.is_profile_configured(
328                 __opts__,
329                 _get_active_provider_name() or "proxmox",
330                 vm_["profile"],
331                 vm_=vm_,
332             )
333             is False
334         ):
335             return False
336     except AttributeError:
337         pass
338     ret = {}
339     __utils__["cloud.fire_event"](
340         "event",
341         "starting create",
342         "salt/cloud/{}/creating".format(vm_["name"]),
343         args=__utils__["cloud.filter_event"](
344             "creating", vm_, ["name", "profile", "provider", "driver"]
345         ),
346         sock_dir=__opts__["sock_dir"],
347         transport=__opts__["transport"],
348     )
349     log.info("Creating Cloud VM %s", vm_["name"])
350     if "use_dns" in vm_ and "ip_address" not in vm_:
351         use_dns = vm_["use_dns"]
352         if use_dns:
353             from socket import gethostbyname, gaierror
354             try:
355                 ip_address = gethostbyname(str(vm_["name"]))
356             except gaierror:
357                 log.debug("Resolving of %s failed", vm_["name"])
358             else:
359                 vm_["ip_address"] = str(ip_address)
360     try:
361         newid = _get_next_vmid()
362         data = create_node(vm_, newid)
363     except Exception as exc:  # pylint: disable=broad-except
364         log.error(
365             "Error creating %s on PROXMOX\n\n"
366             "The following exception was thrown when trying to "
367             "run the initial deployment: \n%s",
368             vm_["name"],
369             exc,
370             exc_info_on_loglevel=logging.DEBUG,
371         )
372         return False
373     ret["creation_data"] = data
374     name = vm_["name"]  # hostname which we know
375     if "clone" in vm_ and vm_["clone"] is True:
376         vmid = newid
377     else:
378         vmid = data["vmid"]  # vmid which we have received
379     host = data["node"]  # host which we have received
380     nodeType = data["technology"]  # VM tech (Qemu / OpenVZ)
381     agent_get_ip = vm_.get("agent_get_ip", False)
382     if agent_get_ip is False:
383         if "ip_address" in vm_:
384             ip_address = str(vm_["ip_address"])
385         elif "public_ips" in data:
386             ip_address = str(data["public_ips"][0])  # first IP
387         elif "private_ips" in data:
388             ip_address = str(data["private_ips"][0])  # first IP
389         else:
390             raise SaltCloudExecutionFailure("Could not determine an IP address to use")
391         log.debug("Using IP address %s", ip_address)
392     if not wait_for_created(data["upid"], timeout=300):
393         return {"Error": "Unable to create {}, command timed out".format(name)}
394     if vm_.get("clone") is True:
395         _reconfigure_clone(vm_, vmid)
396     if not start(name, vmid, call="action"):
397         log.error("Node %s (%s) failed to start!", name, vmid)
398         raise SaltCloudExecutionFailure
399     log.debug('Waiting for state "running" for vm %s on %s', vmid, host)
400     if not wait_for_state(vmid, "running"):
401         return {"Error": "Unable to start {}, command timed out".format(name)}
402     if agent_get_ip is True:
403         try:
404             ip_address = salt.utils.cloud.wait_for_fun(
405                 _find_agent_ip, vm_=vm_, vmid=vmid
406             )
407         except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
408             try:
409                 destroy(vm_["name"])
410             except SaltCloudSystemExit:
411                 pass
412             finally:
413                 raise SaltCloudSystemExit(str(exc))
414         log.debug("Using IP address %s", ip_address)
415     ssh_username = config.get_cloud_config_value(
416         "ssh_username", vm_, __opts__, default="root"
417     )
418     ssh_password = config.get_cloud_config_value(
419         "password",
420         vm_,
421         __opts__,
422     )
423     ret["ip_address"] = ip_address
424     ret["username"] = ssh_username
425     ret["password"] = ssh_password
426     vm_["ssh_host"] = ip_address
427     vm_["password"] = ssh_password
428     ret = __utils__["cloud.bootstrap"](vm_, __opts__)
429     log.info("Created Cloud VM '%s'", vm_["name"])
430     log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
431     __utils__["cloud.fire_event"](
432         "event",
433         "created instance",
434         "salt/cloud/{}/created".format(vm_["name"]),
435         args=__utils__["cloud.filter_event"](
436             "created", vm_, ["name", "profile", "provider", "driver"]
437         ),
438         sock_dir=__opts__["sock_dir"],
439     )
440     return ret
441 def preferred_ip(vm_, ips):
442     proto = config.get_cloud_config_value(
443         "protocol", vm_, __opts__, default="ipv4", search_global=False
444     )
445     family = socket.AF_INET
446     if proto == "ipv6":
447         family = socket.AF_INET6
448     for ip in ips:
449         ignore_ip = ignore_cidr(vm_, ip)
450         if ignore_ip:
451             continue
452         try:
453             socket.inet_pton(family, ip)
454             return ip
455         except Exception:  # pylint: disable=broad-except
456             continue
457     return False
458 def ignore_cidr(vm_, ip):
459     from ipaddress import ip_address, ip_network
460     cidrs = config.get_cloud_config_value(
461         "ignore_cidr", vm_, __opts__, default=[], search_global=False
462     )
463     if cidrs and isinstance(cidrs, str):
464         cidrs = [cidrs]
465     for cidr in cidrs or []:
466         if ip_address(ip) in ip_network(cidr):
467             log.warning("IP %r found within %r; ignoring it.", ip, cidr)
468             return True
469     return False
470 def _find_agent_ip(vm_, vmid):
471     if not vm_.get("technology") == "qemu":
472         log.warning("Find agent IP is only available under `qemu`")
473         return
474     ips = []
475     endpoint = "nodes/{}/qemu/{}/agent/network-get-interfaces".format(vm_["host"], vmid)
476     interfaces = query("get", endpoint)
477     for interface in interfaces["result"]:
478         if str(interface.get("hardware-address")) == "00:00:00:00:00:00":
479             continue
480         if "ip-addresses" not in interface:
481             continue
482         for if_addr in interface["ip-addresses"]:
483             ip_addr = if_addr.get("ip-address")
484             if ip_addr is not None:
485                 ips.append(str(ip_addr))
486     if len(ips) &gt; 0:
487         return preferred_ip(vm_, ips)
488     raise SaltCloudExecutionFailure
489 def _import_api():
490     global api
491     full_url = "https://{}:{}/pve-docs/api-viewer/apidoc.js".format(url, port)
492     returned_data = requests.get(full_url, verify=verify_ssl)
493     re_filter = re.compile("(?&lt;=pveapi =)(.*)(?=^;)", re.DOTALL | re.MULTILINE)
494     api_json = re_filter.findall(returned_data.text)[0]
495     api = salt.utils.json.loads(api_json)
496 def _get_properties(path="", method="GET", forced_params=None):
497     if api is None:
498         _import_api()
499     sub = api
500     path_levels = [level for level in path.split("/") if level != ""]
501     search_path = ""
502     props = []
503     parameters = set([] if forced_params is None else forced_params)
504     for elem in path_levels[:-1]:
505         search_path += "/" + elem
506         sub = next(item for item in sub if item["path"] == search_path)["children"]
507     search_path += "/" + path_levels[-1]
508     sub = next(item for item in sub if item["path"] == search_path)
509     try:
510         props = sub["info"][method]["parameters"]["properties"].keys()
511     except KeyError as exc:
512         log.error('method not found: "%s"', exc)
513     for prop in props:
514         numerical = re.match(r"(\w+)\[n\]", prop)
515         if numerical:
516             for i in range(10):
517                 parameters.add(numerical.group(1) + str(i))
518         else:
519             parameters.add(prop)
520     return parameters
521 def create_node(vm_, newid):
522     newnode = {}
523     if "technology" not in vm_:
524         vm_["technology"] = "openvz"  # default virt tech if none is given
525     if vm_["technology"] not in ["qemu", "openvz", "lxc"]:
526         log.error(
527             "Wrong VM type. Valid options are: qemu, openvz (proxmox3) or lxc"
528             " (proxmox4)"
529         )
530         raise SaltCloudExecutionFailure
531     if "host" not in vm_:
532         vm_["host"] = config.get_cloud_config_value(
533             "default_host", get_configured_provider(), __opts__, search_global=False
534         )
535     if vm_["host"] is None:
536         log.error("No host given to create this VM on")
537         raise SaltCloudExecutionFailure
538     vmhost = vm_["host"]
539     newnode["vmid"] = newid
540     for prop in "cpuunits", "description", "memory", "onboot":
541         if prop in vm_:  # if the property is set, use it for the VM request
542             newnode[prop] = vm_[prop]
543     if vm_["technology"] == "openvz":
544         newnode["hostname"] = vm_["name"]
545         newnode["ostemplate"] = vm_["image"]
546         for prop in (
547             "cpus",
548             "disk",
549             "ip_address",
550             "nameserver",
551             "password",
552             "swap",
553             "poolid",
554             "storage",
555         ):
556             if prop in vm_:  # if the property is set, use it for the VM request
557                 newnode[prop] = vm_[prop]
558     elif vm_["technology"] == "lxc":
559         newnode["hostname"] = vm_["name"]
560         newnode["ostemplate"] = vm_["image"]
561         static_props = (
562             "cpuunits",
563             "cpulimit",
564             "rootfs",
565             "cores",
566             "description",
567             "memory",
568             "onboot",
569             "net0",
570             "password",
571             "nameserver",
572             "swap",
573             "storage",
574             "rootfs",
575         )
576         for prop in _get_properties("/nodes/{node}/lxc", "POST", static_props):
577             if prop in vm_:  # if the property is set, use it for the VM request
578                 newnode[prop] = vm_[prop]
579         if "pubkey" in vm_:
580             newnode["ssh-public-keys"] = vm_["pubkey"]
581         if "disk" in vm_:
582             log.warning(
583                 'The "disk" option is not supported for LXC hosts and was ignored'
584             )
585         if "ip_address" in vm_ and "net0" not in vm_:
586             newnode["net0"] = (
587                 "bridge=vmbr0,ip=" + vm_["ip_address"] + "/24,name=eth0,type=veth"
588             )
589             if "gw" in vm_:
590                 newnode["net0"] = newnode["net0"] + ",gw=" + vm_["gw"]
591     elif vm_["technology"] == "qemu":
592         static_props = (
593             "acpi",
594             "cores",
595             "cpu",
596             "pool",
597             "storage",
598             "sata0",
599             "ostype",
600             "ide2",
601             "net0",
602         )
603         for prop in _get_properties("/nodes/{node}/qemu", "POST", static_props):
604             if prop in vm_:  # if the property is set, use it for the VM request
605                 newnode[prop] = vm_[prop]
606     __utils__["cloud.fire_event"](
607         "event",
608         "requesting instance",
609         "salt/cloud/{}/requesting".format(vm_["name"]),
610         args={
611             "kwargs": __utils__["cloud.filter_event"](
612                 "requesting", newnode, list(newnode)
613             ),
614         },
615         sock_dir=__opts__["sock_dir"],
616     )
617     log.debug("Preparing to generate a node using these parameters: %s ", newnode)
618     if "clone" in vm_ and vm_["clone"] is True and vm_["technology"] == "qemu":
619         postParams = {}
620         postParams["newid"] = newnode["vmid"]
621         for prop in "description", "format", "full", "name":
622             if (
623                 "clone_" + prop in vm_
624             ):  # if the property is set, use it for the VM request
625                 postParams[prop] = vm_["clone_" + prop]
626         try:
627             int(vm_["clone_from"])
628         except ValueError:
629             if ":" in vm_["clone_from"]:
630                 vmhost = vm_["clone_from"].split(":")[0]
631                 vm_["clone_from"] = vm_["clone_from"].split(":")[1]
632         node = query(
633             "post",
634             "nodes/{}/qemu/{}/clone".format(vmhost, vm_["clone_from"]),
635             postParams,
636         )
637     else:
638         node = query("post", "nodes/{}/{}".format(vmhost, vm_["technology"]), newnode)
639     return _parse_proxmox_upid(node, vm_)
640 def show_instance(name, call=None):
641     if call != "action":
642         raise SaltCloudSystemExit(
643             "The show_instance action must be called with -a or --action."
644         )
645     nodes = list_nodes_full()
646     __utils__["cloud.cache_node"](nodes[name], _get_active_provider_name(), __opts__)
647     return nodes[name]
648 def get_vmconfig(vmid, node=None, node_type="openvz"):
649     if node is None:
650         for host_name, host_details in avail_locations().items():
651             for item in query("get", "nodes/{}/{}".format(host_name, node_type)):
652                 if item["vmid"] == vmid:
653                     node = host_name
654     data = query("get", "nodes/{}/{}/{}/config".format(node, node_type, vmid))
655     return data
656 def wait_for_created(upid, timeout=300):
657     start_time = time.time()
658     info = _lookup_proxmox_task(upid)
659     if not info:
660         log.error(
661             "wait_for_created: No task information retrieved based on given criteria."
662         )
663         raise SaltCloudExecutionFailure
664     while True:
665         if "status" in info and info["status"] == "OK":
666             log.debug("Host has been created!")
667             return True
668         time.sleep(3)  # Little more patience, we're not in a hurry
669         if time.time() - start_time &gt; timeout:
670             log.debug("Timeout reached while waiting for host to be created")
671             return False
672         info = _lookup_proxmox_task(upid)
673 def wait_for_state(vmid, state, timeout=300):
674     start_time = time.time()
675     node = get_vm_status(vmid=vmid)
676     if not node:
677         log.error("wait_for_state: No VM retrieved based on given criteria.")
678         raise SaltCloudExecutionFailure
679     while True:
680         if node["status"] == state:
681             log.debug('Host %s is now in "%s" state!', node["name"], state)
682             return True
683         time.sleep(1)
684         if time.time() - start_time &gt; timeout:
685             log.debug(
686                 "Timeout reached while waiting for %s to become %s", node["name"], state
687             )
688             return False
689         node = get_vm_status(vmid=vmid)
690         log.debug(
691             'State for %s is: "%s" instead of "%s"', node["name"], node["status"], state
692         )
693 def destroy(name, call=None):
694     if call == "function":
695         raise SaltCloudSystemExit(
696             "The destroy action must be called with -d, --destroy, -a or --action."
697         )
698     __utils__["cloud.fire_event"](
699         "event",
700         "destroying instance",
701         "salt/cloud/{}/destroying".format(name),
702         args={"name": name},
703         sock_dir=__opts__["sock_dir"],
704         transport=__opts__["transport"],
705     )
706     vmobj = _get_vm_by_name(name)
707     if vmobj is not None:
708         if get_vm_status(vmid=vmobj["vmid"])["status"] != "stopped":
709             stop(name, vmobj["vmid"], "action")
710         if not wait_for_state(vmobj["vmid"], "stopped"):
711             return {"Error": "Unable to stop {}, command timed out".format(name)}
712         time.sleep(3)
713         query("delete", "nodes/{}/{}".format(vmobj["node"], vmobj["id"]))
714         __utils__["cloud.fire_event"](
715             "event",
716             "destroyed instance",
717             "salt/cloud/{}/destroyed".format(name),
718             args={"name": name},
719             sock_dir=__opts__["sock_dir"],
720             transport=__opts__["transport"],
721         )
722         if __opts__.get("update_cachedir", False) is True:
723             __utils__["cloud.delete_minion_cachedir"](
724                 name, _get_active_provider_name().split(":")[0], __opts__
725             )
726         return {"Destroyed": "{} was destroyed.".format(name)}
727 def set_vm_status(status, name=None, vmid=None):
728     log.debug("Set status to %s for %s (%s)", status, name, vmid)
729     if vmid is not None:
730         log.debug("set_vm_status: via ID - VMID %s (%s): %s", vmid, name, status)
731         vmobj = _get_vm_by_id(vmid)
732     else:
733         log.debug("set_vm_status: via name - VMID %s (%s): %s", vmid, name, status)
734         vmobj = _get_vm_by_name(name)
735     if not vmobj or "node" not in vmobj or "type" not in vmobj or "vmid" not in vmobj:
736         log.error("Unable to set status %s for %s (%s)", status, name, vmid)
737         raise SaltCloudExecutionTimeout
738     log.debug("VM_STATUS: Has desired info (%s). Setting status..", vmobj)
739     data = query(
740         "post",
741         "nodes/{}/{}/{}/status/{}".format(
742             vmobj["node"], vmobj["type"], vmobj["vmid"], status
743         ),
744     )
745     result = _parse_proxmox_upid(data, vmobj)
746     if result is not False and result is not None:
747         log.debug("Set_vm_status action result: %s", result)
748         return True
749     return False
750 def get_vm_status(vmid=None, name=None):
751     if vmid is not None:
752         log.debug("get_vm_status: VMID %s", vmid)
753         vmobj = _get_vm_by_id(vmid)
754     elif name is not None:
755         log.debug("get_vm_status: name %s", name)
756         vmobj = _get_vm_by_name(name)
757     else:
758         log.debug("get_vm_status: No ID or NAME given")
759         raise SaltCloudExecutionFailure
760     log.debug("VM found: %s", vmobj)
761     if vmobj is not None and "node" in vmobj:
762         log.debug("VM_STATUS: Has desired info. Retrieving.. (%s)", vmobj["name"])
763         data = query(
764             "get",
765             "nodes/{}/{}/{}/status/current".format(
766                 vmobj["node"], vmobj["type"], vmobj["vmid"]
767             ),
768         )
769         return data
770     log.error("VM or requested status not found..")
771     return False
772 def start(name, vmid=None, call=None):
773     if call != "action":
774         raise SaltCloudSystemExit(
775             "The start action must be called with -a or --action."
776         )
777     log.debug("Start: %s (%s) = Start", name, vmid)
778     if not set_vm_status("start", name, vmid=vmid):
779         log.error("Unable to bring VM %s (%s) up..", name, vmid)
780         raise SaltCloudExecutionFailure
781     return {"Started": "{} was started.".format(name)}
782 def stop(name, vmid=None, call=None):
783     if call != "action":
784         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
785     if not set_vm_status("stop", name, vmid=vmid):
786         log.error("Unable to bring VM %s (%s) down..", name, vmid)
787         raise SaltCloudExecutionFailure
788     return {"Stopped": "{} was stopped.".format(name)}
789 def shutdown(name=None, vmid=None, call=None):
790     if call != "action":
791         raise SaltCloudSystemExit(
792             "The shutdown action must be called with -a or --action."
793         )
794     if not set_vm_status("shutdown", name, vmid=vmid):
795         log.error("Unable to shut VM %s (%s) down..", name, vmid)
796         raise SaltCloudExecutionFailure
797     return {"Shutdown": "{} was shutdown.".format(name)}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
