<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_botomod.py & proxmox.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_botomod.py & proxmox.py
      </h3>
      <h1 align="center">
        1.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_botomod.py (3.7383177%)<TH>proxmox.py (0.81632656%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match228457-0.html#0',2,'match228457-1.html#0',3)" NAME="0">(26-38)<TD><A HREF="javascript:ZweiFrames('match228457-0.html#0',2,'match228457-1.html#0',3)" NAME="0">(44-56)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_botomod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import os

import salt.utils.boto3mod as boto3mod
import salt.utils.botomod as botomod
from salt.exceptions import SaltInvocationError
from salt.utils.versions import LooseVersion
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import TestCase, skipIf

# pylint: disable=import-error
try:
    import boto

    boto.ENDPOINTS_PATH = os.path.join(
        RUNTIME_VARS.TESTS_DIR, &quot;unit/files/endpoints.json&quot;
    )
    import boto.exception
    from boto.exception import BotoServerError

    HAS_BOTO = True
<A NAME="0"></A>except ImportError:
    HAS_BOTO = False

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match228457-1.html#0',3,'match228457-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try:
    import boto3

    HAS_BOTO3 = True
except ImportError:
    HAS_BOTO3 = False

try:
    from moto import mock_ec2

    HAS_MOTO = True
except ImportError:
    HAS_MOTO =</B></FONT> False

    def mock_ec2(self):
        &quot;&quot;&quot;
        if the mock_ec2 function is not available due to import failure
        this replaces the decorated function with stub_function.
        Allows unit tests to use the @mock_ec2 decorator
        without a &quot;NameError: name 'mock_ec2' is not defined&quot; error.
        &quot;&quot;&quot;

        def stub_function(self):
            pass

        return stub_function


required_boto_version = &quot;2.0.0&quot;
required_boto3_version = &quot;1.2.1&quot;
region = &quot;us-east-1&quot;
access_key = &quot;GKTADJGHEIQSXMKKRBJ08H&quot;
secret_key = &quot;askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs&quot;
conn_parameters = {
    &quot;region&quot;: region,
    &quot;key&quot;: access_key,
    &quot;keyid&quot;: secret_key,
    &quot;profile&quot;: {},
}

service = &quot;ec2&quot;
resource_name = &quot;test-instance&quot;
resource_id = &quot;i-a1b2c3&quot;


error_body = &quot;&quot;&quot;
&lt;Response&gt;
    &lt;Errors&gt;
         &lt;Error&gt;
           &lt;Code&gt;Error code text&lt;/Code&gt;
           &lt;Message&gt;Error message&lt;/Message&gt;
         &lt;/Error&gt;
    &lt;/Errors&gt;
    &lt;RequestID&gt;request ID&lt;/RequestID&gt;
&lt;/Response&gt;
&quot;&quot;&quot;

no_error_body = &quot;&quot;&quot;
&lt;Response&gt;
    &lt;Errors /&gt;
    &lt;RequestID&gt;request ID&lt;/RequestID&gt;
&lt;/Response&gt;
&quot;&quot;&quot;


def _has_required_boto():
    &quot;&quot;&quot;
    Returns True/False boolean depending on if Boto is installed and correct
    version.
    &quot;&quot;&quot;
    if not HAS_BOTO:
        return False
    elif LooseVersion(boto.__version__) &lt; LooseVersion(required_boto_version):
        return False
    else:
        return True


def _has_required_boto3():
    &quot;&quot;&quot;
    Returns True/False boolean depending on if Boto is installed and correct
    version.
    &quot;&quot;&quot;
    try:
        if not HAS_BOTO3:
            return False
        elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
            return False
        else:
            return True
    except AttributeError as exc:
        if &quot;has no attribute '__version__'&quot; not in str(exc):
            raise
        return False


def _has_required_moto():
    &quot;&quot;&quot;
    Returns True/False boolean depending on if Moto is installed and correct
    version.
    &quot;&quot;&quot;
    if not HAS_MOTO:
        return False
    else:
        import pkg_resources

        if LooseVersion(pkg_resources.get_distribution(&quot;moto&quot;).version) &lt; LooseVersion(
            &quot;0.3.7&quot;
        ):
            return False
        return True


class BotoUtilsTestCaseBase(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        module_globals = {
            &quot;__salt__&quot;: {&quot;config.option&quot;: MagicMock(return_value=&quot;dummy_opt&quot;)}
        }
        return {botomod: module_globals, boto3mod: module_globals}


class BotoUtilsCacheIdTestCase(BotoUtilsTestCaseBase):
    def test_set_and_get_with_no_auth_params(self):
        botomod.cache_id(service, resource_name, resource_id=resource_id)
        self.assertEqual(botomod.cache_id(service, resource_name), resource_id)

    def test_set_and_get_with_explicit_auth_params(self):
        botomod.cache_id(
            service, resource_name, resource_id=resource_id, **conn_parameters
        )
        self.assertEqual(
            botomod.cache_id(service, resource_name, **conn_parameters), resource_id
        )

    def test_set_and_get_with_different_region_returns_none(self):
        botomod.cache_id(
            service, resource_name, resource_id=resource_id, region=&quot;us-east-1&quot;
        )
        self.assertEqual(
            botomod.cache_id(service, resource_name, region=&quot;us-west-2&quot;), None
        )

    def test_set_and_get_after_invalidation_returns_none(self):
        botomod.cache_id(service, resource_name, resource_id=resource_id)
        botomod.cache_id(
            service, resource_name, resource_id=resource_id, invalidate=True
        )
        self.assertEqual(botomod.cache_id(service, resource_name), None)

    def test_partial(self):
        cache_id = botomod.cache_id_func(service)
        cache_id(resource_name, resource_id=resource_id)
        self.assertEqual(cache_id(resource_name), resource_id)


@skipIf(HAS_BOTO is False, &quot;The boto module must be installed.&quot;)
@skipIf(HAS_MOTO is False, &quot;The moto module must be installed.&quot;)
@skipIf(
    _has_required_boto() is False,
    &quot;The boto module must be greater than or equal to version {}&quot;.format(
        required_boto_version
    ),
)
class BotoUtilsGetConnTestCase(BotoUtilsTestCaseBase):
    @mock_ec2
    def test_conn_is_cached(self):
        conn = botomod.get_connection(service, **conn_parameters)
        self.assertTrue(conn in botomod.__context__.values())

    @mock_ec2
    def test_conn_is_cache_with_profile(self):
        conn = botomod.get_connection(service, profile=conn_parameters)
        self.assertTrue(conn in botomod.__context__.values())

    @mock_ec2
    def test_get_conn_with_no_auth_params_raises_invocation_error(self):
        with patch(
            &quot;boto.{}.connect_to_region&quot;.format(service),
            side_effect=boto.exception.NoAuthHandlerFound(),
        ):
            with self.assertRaises(SaltInvocationError):
                botomod.get_connection(service)

    @mock_ec2
    def test_get_conn_error_raises_command_execution_error(self):
        with patch(
            &quot;boto.{}.connect_to_region&quot;.format(service),
            side_effect=BotoServerError(400, &quot;Mocked error&quot;, body=error_body),
        ):
            with self.assertRaises(BotoServerError):
                botomod.get_connection(service)

    @mock_ec2
    def test_partial(self):
        get_conn = botomod.get_connection_func(service)
        conn = get_conn(**conn_parameters)
        self.assertTrue(conn in botomod.__context__.values())


@skipIf(HAS_BOTO is False, &quot;The boto module must be installed.&quot;)
@skipIf(
    _has_required_boto() is False,
    &quot;The boto module must be greater than or equal to version {}&quot;.format(
        required_boto_version
    ),
)
class BotoUtilsGetErrorTestCase(BotoUtilsTestCaseBase):
    def test_error_message(self):
        e = BotoServerError(&quot;400&quot;, &quot;Mocked error&quot;, body=error_body)
        r = botomod.get_error(e)
        expected = {
            &quot;aws&quot;: {
                &quot;code&quot;: &quot;Error code text&quot;,
                &quot;message&quot;: &quot;Error message&quot;,
                &quot;reason&quot;: &quot;Mocked error&quot;,
                &quot;status&quot;: &quot;400&quot;,
            },
            &quot;message&quot;: &quot;Mocked error: Error message&quot;,
        }
        self.assertEqual(r, expected)

    def test_exception_message_with_no_body(self):
        e = BotoServerError(&quot;400&quot;, &quot;Mocked error&quot;)
        r = botomod.get_error(e)
        expected = {
            &quot;aws&quot;: {&quot;reason&quot;: &quot;Mocked error&quot;, &quot;status&quot;: &quot;400&quot;},
            &quot;message&quot;: &quot;Mocked error&quot;,
        }
        self.assertEqual(r, expected)

    def test_exception_message_with_no_error_in_body(self):
        e = BotoServerError(&quot;400&quot;, &quot;Mocked error&quot;, body=no_error_body)
        r = botomod.get_error(e)
        expected = {
            &quot;aws&quot;: {&quot;reason&quot;: &quot;Mocked error&quot;, &quot;status&quot;: &quot;400&quot;},
            &quot;message&quot;: &quot;Mocked error&quot;,
        }
        self.assertEqual(r, expected)


@skipIf(HAS_BOTO is False, &quot;The boto module must be installed.&quot;)
@skipIf(
    _has_required_boto() is False,
    &quot;The boto module must be greater than or equal to version {}&quot;.format(
        required_boto_version
    ),
)
@skipIf(HAS_BOTO3 is False, &quot;The boto3 module must be installed.&quot;)
@skipIf(
    _has_required_boto3() is False,
    &quot;The boto3 module must be greater than or equal to version {}&quot;.format(
        required_boto3_version
    ),
)
class BotoBoto3CacheContextCollisionTest(BotoUtilsTestCaseBase):
    def test_context_conflict_between_boto_and_boto3_utils(self):
        botomod.assign_funcs(__name__, &quot;ec2&quot;)
        boto3mod.assign_funcs(__name__, &quot;ec2&quot;, get_conn_funcname=&quot;_get_conn3&quot;)

        boto_ec2_conn = botomod.get_connection(
            &quot;ec2&quot;, region=region, key=secret_key, keyid=access_key
        )
        boto3_ec2_conn = boto3mod.get_connection(
            &quot;ec2&quot;, region=region, key=secret_key, keyid=access_key
        )

        # These should *not* be the same object!
        self.assertNotEqual(id(boto_ec2_conn), id(boto3_ec2_conn))
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>proxmox.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Proxmox Cloud Module
======================

.. versionadded:: 2014.7.0

The Proxmox cloud module is used to control access to cloud providers using
the Proxmox system (KVM / OpenVZ / LXC).

Set up the cloud configuration at ``/etc/salt/cloud.providers`` or
 ``/etc/salt/cloud.providers.d/proxmox.conf``:

.. code-block:: yaml

    my-proxmox-config:
      # Proxmox account information
      user: myuser@pam or myuser@pve
      password: mypassword
      url: hypervisor.domain.tld
      port: 8006
      driver: proxmox
      verify_ssl: True

:maintainer: Frank Klaassen &lt;frank@cloudright.nl&gt;
:depends: requests &gt;= 2.2.1
:depends: IPy &gt;= 0.81
&quot;&quot;&quot;

import logging
import pprint
import re
import socket
import time

import salt.config as config
import salt.utils.cloud
import salt.utils.json
from salt.exceptions import (
    SaltCloudExecutionFailure,
    SaltCloudExecutionTimeout,
<A NAME="0"></A>    SaltCloudSystemExit,
)

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match228457-0.html#0',2,'match228457-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try:
    import requests

    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

try:
    from IPy import IP

    HAS_IPY = True
except ImportError:
    HAS_IPY =</B></FONT> False

# Get logging started
log = logging.getLogger(__name__)

__virtualname__ = &quot;proxmox&quot;


def __virtual__():
    &quot;&quot;&quot;
    Check for PROXMOX configurations
    &quot;&quot;&quot;
    if get_configured_provider() is False:
        return False

    if get_dependencies() is False:
        return False

    return __virtualname__


def _get_active_provider_name():
    try:
        return __active_provider_name__.value()
    except AttributeError:
        return __active_provider_name__


def get_configured_provider():
    &quot;&quot;&quot;
    Return the first configured instance.
    &quot;&quot;&quot;
    return config.is_provider_configured(
        __opts__, _get_active_provider_name() or __virtualname__, (&quot;user&quot;,)
    )


def get_dependencies():
    &quot;&quot;&quot;
    Warn if dependencies aren't met.
    &quot;&quot;&quot;
    deps = {&quot;requests&quot;: HAS_REQUESTS, &quot;IPy&quot;: HAS_IPY}
    return config.check_driver_dependencies(__virtualname__, deps)


url = None
port = None
ticket = None
csrf = None
verify_ssl = None
api = None


def _authenticate():
    &quot;&quot;&quot;
    Retrieve CSRF and API tickets for the Proxmox API
    &quot;&quot;&quot;
    global url, port, ticket, csrf, verify_ssl
    url = config.get_cloud_config_value(
        &quot;url&quot;, get_configured_provider(), __opts__, search_global=False
    )
    port = config.get_cloud_config_value(
        &quot;port&quot;, get_configured_provider(), __opts__, default=8006, search_global=False
    )
    username = (
        config.get_cloud_config_value(
            &quot;user&quot;, get_configured_provider(), __opts__, search_global=False
        ),
    )
    passwd = config.get_cloud_config_value(
        &quot;password&quot;, get_configured_provider(), __opts__, search_global=False
    )
    verify_ssl = config.get_cloud_config_value(
        &quot;verify_ssl&quot;,
        get_configured_provider(),
        __opts__,
        default=True,
        search_global=False,
    )

    connect_data = {&quot;username&quot;: username, &quot;password&quot;: passwd}
    full_url = &quot;https://{}:{}/api2/json/access/ticket&quot;.format(url, port)

    returned_data = requests.post(full_url, verify=verify_ssl, data=connect_data).json()

    ticket = {&quot;PVEAuthCookie&quot;: returned_data[&quot;data&quot;][&quot;ticket&quot;]}
    csrf = str(returned_data[&quot;data&quot;][&quot;CSRFPreventionToken&quot;])


def query(conn_type, option, post_data=None):
    &quot;&quot;&quot;
    Execute the HTTP request to the API
    &quot;&quot;&quot;
    if ticket is None or csrf is None or url is None:
        log.debug(&quot;Not authenticated yet, doing that now..&quot;)
        _authenticate()

    full_url = &quot;https://{}:{}/api2/json/{}&quot;.format(url, port, option)

    log.debug(&quot;%s: %s (%s)&quot;, conn_type, full_url, post_data)

    httpheaders = {
        &quot;Accept&quot;: &quot;application/json&quot;,
        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,
        &quot;User-Agent&quot;: &quot;salt-cloud-proxmox&quot;,
    }

    if conn_type == &quot;post&quot;:
        httpheaders[&quot;CSRFPreventionToken&quot;] = csrf
        response = requests.post(
            full_url,
            verify=verify_ssl,
            data=post_data,
            cookies=ticket,
            headers=httpheaders,
        )
    elif conn_type == &quot;put&quot;:
        httpheaders[&quot;CSRFPreventionToken&quot;] = csrf
        response = requests.put(
            full_url,
            verify=verify_ssl,
            data=post_data,
            cookies=ticket,
            headers=httpheaders,
        )
    elif conn_type == &quot;delete&quot;:
        httpheaders[&quot;CSRFPreventionToken&quot;] = csrf
        response = requests.delete(
            full_url,
            verify=verify_ssl,
            data=post_data,
            cookies=ticket,
            headers=httpheaders,
        )
    elif conn_type == &quot;get&quot;:
        response = requests.get(full_url, verify=verify_ssl, cookies=ticket)

    response.raise_for_status()

    try:
        returned_data = response.json()
        if &quot;data&quot; not in returned_data:
            raise SaltCloudExecutionFailure
        return returned_data[&quot;data&quot;]
    except Exception:  # pylint: disable=broad-except
        log.error(&quot;Error in trying to process JSON&quot;)
        log.error(response)


def _get_vm_by_name(name, allDetails=False):
    &quot;&quot;&quot;
    Since Proxmox works based op id's rather than names as identifiers this
    requires some filtering to retrieve the required information.
    &quot;&quot;&quot;
    vms = get_resources_vms(includeConfig=allDetails)
    if name in vms:
        return vms[name]

    log.info('VM with name &quot;%s&quot; could not be found.', name)
    return False


def _get_vm_by_id(vmid, allDetails=False):
    &quot;&quot;&quot;
    Retrieve a VM based on the ID.
    &quot;&quot;&quot;
    for vm_name, vm_details in get_resources_vms(includeConfig=allDetails).items():
        if str(vm_details[&quot;vmid&quot;]) == str(vmid):
            return vm_details

    log.info('VM with ID &quot;%s&quot; could not be found.', vmid)
    return False


def _get_next_vmid():
    &quot;&quot;&quot;
    Proxmox allows the use of alternative ids instead of autoincrementing.
    Because of that its required to query what the first available ID is.
    &quot;&quot;&quot;
    return int(query(&quot;get&quot;, &quot;cluster/nextid&quot;))


def _check_ip_available(ip_addr):
    &quot;&quot;&quot;
    Proxmox VMs refuse to start when the IP is already being used.
    This function can be used to prevent VMs being created with duplicate
    IP's or to generate a warning.
    &quot;&quot;&quot;
    for vm_name, vm_details in get_resources_vms(includeConfig=True).items():
        vm_config = vm_details[&quot;config&quot;]
        if ip_addr in vm_config[&quot;ip_address&quot;] or vm_config[&quot;ip_address&quot;] == ip_addr:
            log.debug('IP &quot;%s&quot; is already defined', ip_addr)
            return False

    log.debug(&quot;IP '%s' is available to be defined&quot;, ip_addr)
    return True


def _parse_proxmox_upid(node, vm_=None):
    &quot;&quot;&quot;
    Upon requesting a task that runs for a longer period of time a UPID is given.
    This includes information about the job and can be used to lookup information in the log.
    &quot;&quot;&quot;
    ret = {}

    upid = node
    # Parse node response
    node = node.split(&quot;:&quot;)
    if node[0] == &quot;UPID&quot;:
        ret[&quot;node&quot;] = str(node[1])
        ret[&quot;pid&quot;] = str(node[2])
        ret[&quot;pstart&quot;] = str(node[3])
        ret[&quot;starttime&quot;] = str(node[4])
        ret[&quot;type&quot;] = str(node[5])
        ret[&quot;vmid&quot;] = str(node[6])
        ret[&quot;user&quot;] = str(node[7])
        # include the upid again in case we'll need it again
        ret[&quot;upid&quot;] = str(upid)

        if vm_ is not None and &quot;technology&quot; in vm_:
            ret[&quot;technology&quot;] = str(vm_[&quot;technology&quot;])

    return ret


def _lookup_proxmox_task(upid):
    &quot;&quot;&quot;
    Retrieve the (latest) logs and retrieve the status for a UPID.
    This can be used to verify whether a task has completed.
    &quot;&quot;&quot;
    log.debug(&quot;Getting creation status for upid: %s&quot;, upid)
    tasks = query(&quot;get&quot;, &quot;cluster/tasks&quot;)

    if tasks:
        for task in tasks:
            if task[&quot;upid&quot;] == upid:
                log.debug(&quot;Found upid task: %s&quot;, task)
                return task

    return False


def get_resources_nodes(call=None, resFilter=None):
    &quot;&quot;&quot;
    Retrieve all hypervisors (nodes) available on this environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f get_resources_nodes my-proxmox-config
    &quot;&quot;&quot;
    log.debug(&quot;Getting resource: nodes.. (filter: %s)&quot;, resFilter)
    resources = query(&quot;get&quot;, &quot;cluster/resources&quot;)

    ret = {}
    for resource in resources:
        if &quot;type&quot; in resource and resource[&quot;type&quot;] == &quot;node&quot;:
            name = resource[&quot;node&quot;]
            ret[name] = resource

    if resFilter is not None:
        log.debug(&quot;Filter given: %s, returning requested resource: nodes&quot;, resFilter)
        return ret[resFilter]

    log.debug(&quot;Filter not given: %s, returning all resource: nodes&quot;, ret)
    return ret


def get_resources_vms(call=None, resFilter=None, includeConfig=True):
    &quot;&quot;&quot;
    Retrieve all VMs available on this environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f get_resources_vms my-proxmox-config
    &quot;&quot;&quot;
    timeoutTime = time.time() + 60
    while True:
        log.debug(&quot;Getting resource: vms.. (filter: %s)&quot;, resFilter)
        resources = query(&quot;get&quot;, &quot;cluster/resources&quot;)
        ret = {}
        badResource = False
        for resource in resources:
            if &quot;type&quot; in resource and resource[&quot;type&quot;] in [&quot;openvz&quot;, &quot;qemu&quot;, &quot;lxc&quot;]:
                try:
                    name = resource[&quot;name&quot;]
                except KeyError:
                    badResource = True
                    log.debug(&quot;No name in VM resource %s&quot;, repr(resource))
                    break

                ret[name] = resource

                if includeConfig:
                    # Requested to include the detailed configuration of a VM
                    ret[name][&quot;config&quot;] = get_vmconfig(
                        ret[name][&quot;vmid&quot;], ret[name][&quot;node&quot;], ret[name][&quot;type&quot;]
                    )

        if time.time() &gt; timeoutTime:
            raise SaltCloudExecutionTimeout(&quot;FAILED to get the proxmox resources vms&quot;)

        # Carry on if there wasn't a bad resource return from Proxmox
        if not badResource:
            break

        time.sleep(0.5)

    if resFilter is not None:
        log.debug(&quot;Filter given: %s, returning requested resource: nodes&quot;, resFilter)
        return ret[resFilter]

    log.debug(&quot;Filter not given: %s, returning all resource: nodes&quot;, ret)
    return ret


def script(vm_):
    &quot;&quot;&quot;
    Return the script deployment object
    &quot;&quot;&quot;
    script_name = config.get_cloud_config_value(&quot;script&quot;, vm_, __opts__)
    if not script_name:
        script_name = &quot;bootstrap-salt&quot;

    return salt.utils.cloud.os_script(
        script_name,
        vm_,
        __opts__,
        salt.utils.cloud.salt_config_to_yaml(
            salt.utils.cloud.minion_config(__opts__, vm_)
        ),
    )


def avail_locations(call=None):
    &quot;&quot;&quot;
    Return a list of the hypervisors (nodes) which this Proxmox PVE machine manages

    CLI Example:

    .. code-block:: bash

        salt-cloud --list-locations my-proxmox-config
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_locations function must be called with &quot;
            &quot;-f or --function, or with the --list-locations option&quot;
        )

    # could also use the get_resources_nodes but speed is ~the same
    nodes = query(&quot;get&quot;, &quot;nodes&quot;)

    ret = {}
    for node in nodes:
        name = node[&quot;node&quot;]
        ret[name] = node

    return ret


def avail_images(call=None, location=&quot;local&quot;):
    &quot;&quot;&quot;
    Return a list of the images that are on the provider

    CLI Example:

    .. code-block:: bash

        salt-cloud --list-images my-proxmox-config
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_images function must be called with &quot;
            &quot;-f or --function, or with the --list-images option&quot;
        )

    ret = {}
    for host_name, host_details in avail_locations().items():
        for item in query(
            &quot;get&quot;, &quot;nodes/{}/storage/{}/content&quot;.format(host_name, location)
        ):
            ret[item[&quot;volid&quot;]] = item
    return ret


def list_nodes(call=None):
    &quot;&quot;&quot;
    Return a list of the VMs that are managed by the provider

    CLI Example:

    .. code-block:: bash

        salt-cloud -Q my-proxmox-config
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes function must be called with -f or --function.&quot;
        )

    ret = {}
    for vm_name, vm_details in get_resources_vms(includeConfig=True).items():
        log.debug(&quot;VM_Name: %s&quot;, vm_name)
        log.debug(&quot;vm_details: %s&quot;, vm_details)

        # Limit resultset on what Salt-cloud demands:
        ret[vm_name] = {}
        ret[vm_name][&quot;id&quot;] = str(vm_details[&quot;vmid&quot;])
        ret[vm_name][&quot;image&quot;] = str(vm_details[&quot;vmid&quot;])
        ret[vm_name][&quot;size&quot;] = str(vm_details[&quot;disk&quot;])
        ret[vm_name][&quot;state&quot;] = str(vm_details[&quot;status&quot;])

        # Figure out which is which to put it in the right column
        private_ips = []
        public_ips = []

        if (
            &quot;ip_address&quot; in vm_details[&quot;config&quot;]
            and vm_details[&quot;config&quot;][&quot;ip_address&quot;] != &quot;-&quot;
        ):
            ips = vm_details[&quot;config&quot;][&quot;ip_address&quot;].split(&quot; &quot;)
            for ip_ in ips:
                if IP(ip_).iptype() == &quot;PRIVATE&quot;:
                    private_ips.append(str(ip_))
                else:
                    public_ips.append(str(ip_))

        ret[vm_name][&quot;private_ips&quot;] = private_ips
        ret[vm_name][&quot;public_ips&quot;] = public_ips

    return ret


def list_nodes_full(call=None):
    &quot;&quot;&quot;
    Return a list of the VMs that are on the provider

    CLI Example:

    .. code-block:: bash

        salt-cloud -F my-proxmox-config
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes_full function must be called with -f or --function.&quot;
        )

    return get_resources_vms(includeConfig=True)


def list_nodes_select(call=None):
    &quot;&quot;&quot;
    Return a list of the VMs that are on the provider, with select fields

    CLI Example:

    .. code-block:: bash

        salt-cloud -S my-proxmox-config
    &quot;&quot;&quot;
    return salt.utils.cloud.list_nodes_select(
        list_nodes_full(),
        __opts__[&quot;query.selection&quot;],
        call,
    )


def _stringlist_to_dictionary(input_string):
    &quot;&quot;&quot;
    Convert a stringlist (comma separated settings) to a dictionary

    The result of the string setting1=value1,setting2=value2 will be a python dictionary:

    {'setting1':'value1','setting2':'value2'}
    &quot;&quot;&quot;
    return dict(item.strip().split(&quot;=&quot;) for item in input_string.split(&quot;,&quot;) if item)


def _dictionary_to_stringlist(input_dict):
    &quot;&quot;&quot;
    Convert a dictionary to a stringlist (comma separated settings)

    The result of the dictionary {'setting1':'value1','setting2':'value2'} will be:

    setting1=value1,setting2=value2
    &quot;&quot;&quot;
    return &quot;,&quot;.join(&quot;{}={}&quot;.format(k, input_dict[k]) for k in sorted(input_dict.keys()))


def _reconfigure_clone(vm_, vmid):
    &quot;&quot;&quot;
    If we cloned a machine, see if we need to reconfigure any of the options such as net0,
    ide2, etc. This enables us to have a different cloud-init ISO mounted for each VM that's brought up
    :param vm_:
    :return:
    &quot;&quot;&quot;
    if not vm_.get(&quot;technology&quot;) == &quot;qemu&quot;:
        log.warning(&quot;Reconfiguring clones is only available under `qemu`&quot;)
        return

    # TODO: Support other settings here too as these are not the only ones that can be modified after a clone operation
    log.info(&quot;Configuring cloned VM&quot;)

    # Modify the settings for the VM one at a time so we can see any problems with the values
    # as quickly as possible
    for setting in vm_:
        if re.match(r&quot;^(ide|sata|scsi)(\d+)$&quot;, setting):
            postParams = {setting: vm_[setting]}
            query(
                &quot;post&quot;,
                &quot;nodes/{}/qemu/{}/config&quot;.format(vm_[&quot;host&quot;], vmid),
                postParams,
            )

        elif re.match(r&quot;^net(\d+)$&quot;, setting):
            # net strings are a list of comma seperated settings. We need to merge the settings so that
            # the setting in the profile only changes the settings it touches and the other settings
            # are left alone. An example of why this is necessary is because the MAC address is set
            # in here and generally you don't want to alter or have to know the MAC address of the new
            # instance, but you may want to set the VLAN bridge
            data = query(&quot;get&quot;, &quot;nodes/{}/qemu/{}/config&quot;.format(vm_[&quot;host&quot;], vmid))

            # Generate a dictionary of settings from the existing string
            new_setting = {}
            if setting in data:
                new_setting.update(_stringlist_to_dictionary(data[setting]))

            # Merge the new settings (as a dictionary) into the existing dictionary to get the
            # new merged settings
            new_setting.update(_stringlist_to_dictionary(vm_[setting]))

            # Convert the dictionary back into a string list
            postParams = {setting: _dictionary_to_stringlist(new_setting)}
            query(
                &quot;post&quot;,
                &quot;nodes/{}/qemu/{}/config&quot;.format(vm_[&quot;host&quot;], vmid),
                postParams,
            )


def create(vm_):
    &quot;&quot;&quot;
    Create a single VM from a data dict

    CLI Example:

    .. code-block:: bash

        salt-cloud -p proxmox-ubuntu vmhostname
    &quot;&quot;&quot;
    try:
        # Check for required profile parameters before sending any API calls.
        if (
            vm_[&quot;profile&quot;]
            and config.is_profile_configured(
                __opts__,
                _get_active_provider_name() or &quot;proxmox&quot;,
                vm_[&quot;profile&quot;],
                vm_=vm_,
            )
            is False
        ):
            return False
    except AttributeError:
        pass

    ret = {}

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;starting create&quot;,
        &quot;salt/cloud/{}/creating&quot;.format(vm_[&quot;name&quot;]),
        args=__utils__[&quot;cloud.filter_event&quot;](
            &quot;creating&quot;, vm_, [&quot;name&quot;, &quot;profile&quot;, &quot;provider&quot;, &quot;driver&quot;]
        ),
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    log.info(&quot;Creating Cloud VM %s&quot;, vm_[&quot;name&quot;])

    if &quot;use_dns&quot; in vm_ and &quot;ip_address&quot; not in vm_:
        use_dns = vm_[&quot;use_dns&quot;]
        if use_dns:
            from socket import gethostbyname, gaierror

            try:
                ip_address = gethostbyname(str(vm_[&quot;name&quot;]))
            except gaierror:
                log.debug(&quot;Resolving of %s failed&quot;, vm_[&quot;name&quot;])
            else:
                vm_[&quot;ip_address&quot;] = str(ip_address)

    try:
        newid = _get_next_vmid()
        data = create_node(vm_, newid)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error creating %s on PROXMOX\n\n&quot;
            &quot;The following exception was thrown when trying to &quot;
            &quot;run the initial deployment: \n%s&quot;,
            vm_[&quot;name&quot;],
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return False

    ret[&quot;creation_data&quot;] = data
    name = vm_[&quot;name&quot;]  # hostname which we know
    if &quot;clone&quot; in vm_ and vm_[&quot;clone&quot;] is True:
        vmid = newid
    else:
        vmid = data[&quot;vmid&quot;]  # vmid which we have received
    host = data[&quot;node&quot;]  # host which we have received
    nodeType = data[&quot;technology&quot;]  # VM tech (Qemu / OpenVZ)

    agent_get_ip = vm_.get(&quot;agent_get_ip&quot;, False)

    if agent_get_ip is False:
        # Determine which IP to use in order of preference:
        if &quot;ip_address&quot; in vm_:
            ip_address = str(vm_[&quot;ip_address&quot;])
        elif &quot;public_ips&quot; in data:
            ip_address = str(data[&quot;public_ips&quot;][0])  # first IP
        elif &quot;private_ips&quot; in data:
            ip_address = str(data[&quot;private_ips&quot;][0])  # first IP
        else:
            raise SaltCloudExecutionFailure(&quot;Could not determine an IP address to use&quot;)

        log.debug(&quot;Using IP address %s&quot;, ip_address)

    # wait until the vm has been created so we can start it
    if not wait_for_created(data[&quot;upid&quot;], timeout=300):
        return {&quot;Error&quot;: &quot;Unable to create {}, command timed out&quot;.format(name)}

    if vm_.get(&quot;clone&quot;) is True:
        _reconfigure_clone(vm_, vmid)

    # VM has been created. Starting..
    if not start(name, vmid, call=&quot;action&quot;):
        log.error(&quot;Node %s (%s) failed to start!&quot;, name, vmid)
        raise SaltCloudExecutionFailure

    # Wait until the VM has fully started
    log.debug('Waiting for state &quot;running&quot; for vm %s on %s', vmid, host)
    if not wait_for_state(vmid, &quot;running&quot;):
        return {&quot;Error&quot;: &quot;Unable to start {}, command timed out&quot;.format(name)}

    if agent_get_ip is True:
        try:
            ip_address = salt.utils.cloud.wait_for_fun(
                _find_agent_ip, vm_=vm_, vmid=vmid
            )
        except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
            try:
                # If VM was created but we can't connect, destroy it.
                destroy(vm_[&quot;name&quot;])
            except SaltCloudSystemExit:
                pass
            finally:
                raise SaltCloudSystemExit(str(exc))

        log.debug(&quot;Using IP address %s&quot;, ip_address)

    ssh_username = config.get_cloud_config_value(
        &quot;ssh_username&quot;, vm_, __opts__, default=&quot;root&quot;
    )
    ssh_password = config.get_cloud_config_value(
        &quot;password&quot;,
        vm_,
        __opts__,
    )

    ret[&quot;ip_address&quot;] = ip_address
    ret[&quot;username&quot;] = ssh_username
    ret[&quot;password&quot;] = ssh_password

    vm_[&quot;ssh_host&quot;] = ip_address
    vm_[&quot;password&quot;] = ssh_password
    ret = __utils__[&quot;cloud.bootstrap&quot;](vm_, __opts__)

    # Report success!
    log.info(&quot;Created Cloud VM '%s'&quot;, vm_[&quot;name&quot;])
    log.debug(&quot;'%s' VM creation details:\n%s&quot;, vm_[&quot;name&quot;], pprint.pformat(data))

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;created instance&quot;,
        &quot;salt/cloud/{}/created&quot;.format(vm_[&quot;name&quot;]),
        args=__utils__[&quot;cloud.filter_event&quot;](
            &quot;created&quot;, vm_, [&quot;name&quot;, &quot;profile&quot;, &quot;provider&quot;, &quot;driver&quot;]
        ),
        sock_dir=__opts__[&quot;sock_dir&quot;],
    )

    return ret


def preferred_ip(vm_, ips):
    &quot;&quot;&quot;
    Return either an 'ipv4' (default) or 'ipv6' address depending on 'protocol' option.
    The list of 'ipv4' IPs is filtered by ignore_cidr() to remove any unreachable private addresses.
    &quot;&quot;&quot;
    proto = config.get_cloud_config_value(
        &quot;protocol&quot;, vm_, __opts__, default=&quot;ipv4&quot;, search_global=False
    )

    family = socket.AF_INET
    if proto == &quot;ipv6&quot;:
        family = socket.AF_INET6
    for ip in ips:
        ignore_ip = ignore_cidr(vm_, ip)
        if ignore_ip:
            continue
        try:
            socket.inet_pton(family, ip)
            return ip
        except Exception:  # pylint: disable=broad-except
            continue
    return False


def ignore_cidr(vm_, ip):
    &quot;&quot;&quot;
    Return True if we are to ignore the specified IP.
    &quot;&quot;&quot;
    from ipaddress import ip_address, ip_network

    cidrs = config.get_cloud_config_value(
        &quot;ignore_cidr&quot;, vm_, __opts__, default=[], search_global=False
    )
    if cidrs and isinstance(cidrs, str):
        cidrs = [cidrs]
    for cidr in cidrs or []:
        if ip_address(ip) in ip_network(cidr):
            log.warning(&quot;IP %r found within %r; ignoring it.&quot;, ip, cidr)
            return True

    return False


def _find_agent_ip(vm_, vmid):
    &quot;&quot;&quot;
    If VM is started we would return the IP-addresses that are returned by the qemu agent on the VM.
    &quot;&quot;&quot;

    # This functionality is only available on qemu
    if not vm_.get(&quot;technology&quot;) == &quot;qemu&quot;:
        log.warning(&quot;Find agent IP is only available under `qemu`&quot;)
        return

    # Create an empty list of IP-addresses:
    ips = []

    endpoint = &quot;nodes/{}/qemu/{}/agent/network-get-interfaces&quot;.format(vm_[&quot;host&quot;], vmid)
    interfaces = query(&quot;get&quot;, endpoint)

    # If we get a result from the agent, parse it
    for interface in interfaces[&quot;result&quot;]:

        # Skip interface if hardware-address is 00:00:00:00:00:00 (loopback interface)
        if str(interface.get(&quot;hardware-address&quot;)) == &quot;00:00:00:00:00:00&quot;:
            continue

        # Skip entries without ip-addresses information
        if &quot;ip-addresses&quot; not in interface:
            continue

        for if_addr in interface[&quot;ip-addresses&quot;]:
            ip_addr = if_addr.get(&quot;ip-address&quot;)
            if ip_addr is not None:
                ips.append(str(ip_addr))

    if len(ips) &gt; 0:
        return preferred_ip(vm_, ips)

    raise SaltCloudExecutionFailure


def _import_api():
    &quot;&quot;&quot;
    Download https://&lt;url&gt;/pve-docs/api-viewer/apidoc.js
    Extract content of pveapi var (json formatted)
    Load this json content into global variable &quot;api&quot;
    &quot;&quot;&quot;
    global api
    full_url = &quot;https://{}:{}/pve-docs/api-viewer/apidoc.js&quot;.format(url, port)
    returned_data = requests.get(full_url, verify=verify_ssl)

    re_filter = re.compile(&quot;(?&lt;=pveapi =)(.*)(?=^;)&quot;, re.DOTALL | re.MULTILINE)
    api_json = re_filter.findall(returned_data.text)[0]
    api = salt.utils.json.loads(api_json)


def _get_properties(path=&quot;&quot;, method=&quot;GET&quot;, forced_params=None):
    &quot;&quot;&quot;
    Return the parameter list from api for defined path and HTTP method
    &quot;&quot;&quot;
    if api is None:
        _import_api()

    sub = api
    path_levels = [level for level in path.split(&quot;/&quot;) if level != &quot;&quot;]
    search_path = &quot;&quot;
    props = []
    parameters = set([] if forced_params is None else forced_params)
    # Browse all path elements but last
    for elem in path_levels[:-1]:
        search_path += &quot;/&quot; + elem
        # Lookup for a dictionary with path = &quot;requested path&quot; in list&quot; and return its children
        sub = next(item for item in sub if item[&quot;path&quot;] == search_path)[&quot;children&quot;]
    # Get leaf element in path
    search_path += &quot;/&quot; + path_levels[-1]
    sub = next(item for item in sub if item[&quot;path&quot;] == search_path)
    try:
        # get list of properties for requested method
        props = sub[&quot;info&quot;][method][&quot;parameters&quot;][&quot;properties&quot;].keys()
    except KeyError as exc:
        log.error('method not found: &quot;%s&quot;', exc)
    for prop in props:
        numerical = re.match(r&quot;(\w+)\[n\]&quot;, prop)
        # generate (arbitrarily) 10 properties for duplicatable properties identified by:
        # &quot;prop[n]&quot;
        if numerical:
            for i in range(10):
                parameters.add(numerical.group(1) + str(i))
        else:
            parameters.add(prop)
    return parameters


def create_node(vm_, newid):
    &quot;&quot;&quot;
    Build and submit the requestdata to create a new node
    &quot;&quot;&quot;
    newnode = {}

    if &quot;technology&quot; not in vm_:
        vm_[&quot;technology&quot;] = &quot;openvz&quot;  # default virt tech if none is given

    if vm_[&quot;technology&quot;] not in [&quot;qemu&quot;, &quot;openvz&quot;, &quot;lxc&quot;]:
        # Wrong VM type given
        log.error(
            &quot;Wrong VM type. Valid options are: qemu, openvz (proxmox3) or lxc&quot;
            &quot; (proxmox4)&quot;
        )
        raise SaltCloudExecutionFailure

    if &quot;host&quot; not in vm_:
        # Use globally configured/default location
        vm_[&quot;host&quot;] = config.get_cloud_config_value(
            &quot;default_host&quot;, get_configured_provider(), __opts__, search_global=False
        )

    if vm_[&quot;host&quot;] is None:
        # No location given for the profile
        log.error(&quot;No host given to create this VM on&quot;)
        raise SaltCloudExecutionFailure

    # Required by both OpenVZ and Qemu (KVM)
    vmhost = vm_[&quot;host&quot;]
    newnode[&quot;vmid&quot;] = newid

    for prop in &quot;cpuunits&quot;, &quot;description&quot;, &quot;memory&quot;, &quot;onboot&quot;:
        if prop in vm_:  # if the property is set, use it for the VM request
            newnode[prop] = vm_[prop]

    if vm_[&quot;technology&quot;] == &quot;openvz&quot;:
        # OpenVZ related settings, using non-default names:
        newnode[&quot;hostname&quot;] = vm_[&quot;name&quot;]
        newnode[&quot;ostemplate&quot;] = vm_[&quot;image&quot;]

        # optional VZ settings
        for prop in (
            &quot;cpus&quot;,
            &quot;disk&quot;,
            &quot;ip_address&quot;,
            &quot;nameserver&quot;,
            &quot;password&quot;,
            &quot;swap&quot;,
            &quot;poolid&quot;,
            &quot;storage&quot;,
        ):
            if prop in vm_:  # if the property is set, use it for the VM request
                newnode[prop] = vm_[prop]

    elif vm_[&quot;technology&quot;] == &quot;lxc&quot;:
        # LXC related settings, using non-default names:
        newnode[&quot;hostname&quot;] = vm_[&quot;name&quot;]
        newnode[&quot;ostemplate&quot;] = vm_[&quot;image&quot;]

        static_props = (
            &quot;cpuunits&quot;,
            &quot;cpulimit&quot;,
            &quot;rootfs&quot;,
            &quot;cores&quot;,
            &quot;description&quot;,
            &quot;memory&quot;,
            &quot;onboot&quot;,
            &quot;net0&quot;,
            &quot;password&quot;,
            &quot;nameserver&quot;,
            &quot;swap&quot;,
            &quot;storage&quot;,
            &quot;rootfs&quot;,
        )
        for prop in _get_properties(&quot;/nodes/{node}/lxc&quot;, &quot;POST&quot;, static_props):
            if prop in vm_:  # if the property is set, use it for the VM request
                newnode[prop] = vm_[prop]

        if &quot;pubkey&quot; in vm_:
            newnode[&quot;ssh-public-keys&quot;] = vm_[&quot;pubkey&quot;]

        # inform user the &quot;disk&quot; option is not supported for LXC hosts
        if &quot;disk&quot; in vm_:
            log.warning(
                'The &quot;disk&quot; option is not supported for LXC hosts and was ignored'
            )

        # LXC specific network config
        # OpenVZ allowed specifying IP and gateway. To ease migration from
        # Proxmox 3, I've mapped the ip_address and gw to a generic net0 config.
        # If you need more control, please use the net0 option directly.
        # This also assumes a /24 subnet.
        if &quot;ip_address&quot; in vm_ and &quot;net0&quot; not in vm_:
            newnode[&quot;net0&quot;] = (
                &quot;bridge=vmbr0,ip=&quot; + vm_[&quot;ip_address&quot;] + &quot;/24,name=eth0,type=veth&quot;
            )

            # gateway is optional and does not assume a default
            if &quot;gw&quot; in vm_:
                newnode[&quot;net0&quot;] = newnode[&quot;net0&quot;] + &quot;,gw=&quot; + vm_[&quot;gw&quot;]

    elif vm_[&quot;technology&quot;] == &quot;qemu&quot;:
        # optional Qemu settings
        static_props = (
            &quot;acpi&quot;,
            &quot;cores&quot;,
            &quot;cpu&quot;,
            &quot;pool&quot;,
            &quot;storage&quot;,
            &quot;sata0&quot;,
            &quot;ostype&quot;,
            &quot;ide2&quot;,
            &quot;net0&quot;,
        )
        for prop in _get_properties(&quot;/nodes/{node}/qemu&quot;, &quot;POST&quot;, static_props):
            if prop in vm_:  # if the property is set, use it for the VM request
                newnode[prop] = vm_[prop]

    # The node is ready. Lets request it to be added
    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;requesting instance&quot;,
        &quot;salt/cloud/{}/requesting&quot;.format(vm_[&quot;name&quot;]),
        args={
            &quot;kwargs&quot;: __utils__[&quot;cloud.filter_event&quot;](
                &quot;requesting&quot;, newnode, list(newnode)
            ),
        },
        sock_dir=__opts__[&quot;sock_dir&quot;],
    )

    log.debug(&quot;Preparing to generate a node using these parameters: %s &quot;, newnode)
    if &quot;clone&quot; in vm_ and vm_[&quot;clone&quot;] is True and vm_[&quot;technology&quot;] == &quot;qemu&quot;:
        postParams = {}
        postParams[&quot;newid&quot;] = newnode[&quot;vmid&quot;]

        for prop in &quot;description&quot;, &quot;format&quot;, &quot;full&quot;, &quot;name&quot;:
            if (
                &quot;clone_&quot; + prop in vm_
            ):  # if the property is set, use it for the VM request
                postParams[prop] = vm_[&quot;clone_&quot; + prop]

        try:
            int(vm_[&quot;clone_from&quot;])
        except ValueError:
            if &quot;:&quot; in vm_[&quot;clone_from&quot;]:
                vmhost = vm_[&quot;clone_from&quot;].split(&quot;:&quot;)[0]
                vm_[&quot;clone_from&quot;] = vm_[&quot;clone_from&quot;].split(&quot;:&quot;)[1]

        node = query(
            &quot;post&quot;,
            &quot;nodes/{}/qemu/{}/clone&quot;.format(vmhost, vm_[&quot;clone_from&quot;]),
            postParams,
        )
    else:
        node = query(&quot;post&quot;, &quot;nodes/{}/{}&quot;.format(vmhost, vm_[&quot;technology&quot;]), newnode)
    return _parse_proxmox_upid(node, vm_)


def show_instance(name, call=None):
    &quot;&quot;&quot;
    Show the details from Proxmox concerning an instance
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The show_instance action must be called with -a or --action.&quot;
        )

    nodes = list_nodes_full()
    __utils__[&quot;cloud.cache_node&quot;](nodes[name], _get_active_provider_name(), __opts__)
    return nodes[name]


def get_vmconfig(vmid, node=None, node_type=&quot;openvz&quot;):
    &quot;&quot;&quot;
    Get VM configuration
    &quot;&quot;&quot;
    if node is None:
        # We need to figure out which node this VM is on.
        for host_name, host_details in avail_locations().items():
            for item in query(&quot;get&quot;, &quot;nodes/{}/{}&quot;.format(host_name, node_type)):
                if item[&quot;vmid&quot;] == vmid:
                    node = host_name

    # If we reached this point, we have all the information we need
    data = query(&quot;get&quot;, &quot;nodes/{}/{}/{}/config&quot;.format(node, node_type, vmid))

    return data


def wait_for_created(upid, timeout=300):
    &quot;&quot;&quot;
    Wait until a the vm has been created successfully
    &quot;&quot;&quot;
    start_time = time.time()
    info = _lookup_proxmox_task(upid)
    if not info:
        log.error(
            &quot;wait_for_created: No task information retrieved based on given criteria.&quot;
        )
        raise SaltCloudExecutionFailure

    while True:
        if &quot;status&quot; in info and info[&quot;status&quot;] == &quot;OK&quot;:
            log.debug(&quot;Host has been created!&quot;)
            return True
        time.sleep(3)  # Little more patience, we're not in a hurry
        if time.time() - start_time &gt; timeout:
            log.debug(&quot;Timeout reached while waiting for host to be created&quot;)
            return False
        info = _lookup_proxmox_task(upid)


def wait_for_state(vmid, state, timeout=300):
    &quot;&quot;&quot;
    Wait until a specific state has been reached on a node
    &quot;&quot;&quot;
    start_time = time.time()
    node = get_vm_status(vmid=vmid)
    if not node:
        log.error(&quot;wait_for_state: No VM retrieved based on given criteria.&quot;)
        raise SaltCloudExecutionFailure

    while True:
        if node[&quot;status&quot;] == state:
            log.debug('Host %s is now in &quot;%s&quot; state!', node[&quot;name&quot;], state)
            return True
        time.sleep(1)
        if time.time() - start_time &gt; timeout:
            log.debug(
                &quot;Timeout reached while waiting for %s to become %s&quot;, node[&quot;name&quot;], state
            )
            return False
        node = get_vm_status(vmid=vmid)
        log.debug(
            'State for %s is: &quot;%s&quot; instead of &quot;%s&quot;', node[&quot;name&quot;], node[&quot;status&quot;], state
        )


def destroy(name, call=None):
    &quot;&quot;&quot;
    Destroy a node.

    CLI Example:

    .. code-block:: bash

        salt-cloud --destroy mymachine
    &quot;&quot;&quot;
    if call == &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The destroy action must be called with -d, --destroy, -a or --action.&quot;
        )

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;destroying instance&quot;,
        &quot;salt/cloud/{}/destroying&quot;.format(name),
        args={&quot;name&quot;: name},
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    vmobj = _get_vm_by_name(name)
    if vmobj is not None:
        # stop the vm
        if get_vm_status(vmid=vmobj[&quot;vmid&quot;])[&quot;status&quot;] != &quot;stopped&quot;:
            stop(name, vmobj[&quot;vmid&quot;], &quot;action&quot;)

        # wait until stopped
        if not wait_for_state(vmobj[&quot;vmid&quot;], &quot;stopped&quot;):
            return {&quot;Error&quot;: &quot;Unable to stop {}, command timed out&quot;.format(name)}

        # required to wait a bit here, otherwise the VM is sometimes
        # still locked and destroy fails.
        time.sleep(3)

        query(&quot;delete&quot;, &quot;nodes/{}/{}&quot;.format(vmobj[&quot;node&quot;], vmobj[&quot;id&quot;]))
        __utils__[&quot;cloud.fire_event&quot;](
            &quot;event&quot;,
            &quot;destroyed instance&quot;,
            &quot;salt/cloud/{}/destroyed&quot;.format(name),
            args={&quot;name&quot;: name},
            sock_dir=__opts__[&quot;sock_dir&quot;],
            transport=__opts__[&quot;transport&quot;],
        )
        if __opts__.get(&quot;update_cachedir&quot;, False) is True:
            __utils__[&quot;cloud.delete_minion_cachedir&quot;](
                name, _get_active_provider_name().split(&quot;:&quot;)[0], __opts__
            )

        return {&quot;Destroyed&quot;: &quot;{} was destroyed.&quot;.format(name)}


def set_vm_status(status, name=None, vmid=None):
    &quot;&quot;&quot;
    Convenience function for setting VM status
    &quot;&quot;&quot;
    log.debug(&quot;Set status to %s for %s (%s)&quot;, status, name, vmid)

    if vmid is not None:
        log.debug(&quot;set_vm_status: via ID - VMID %s (%s): %s&quot;, vmid, name, status)
        vmobj = _get_vm_by_id(vmid)
    else:
        log.debug(&quot;set_vm_status: via name - VMID %s (%s): %s&quot;, vmid, name, status)
        vmobj = _get_vm_by_name(name)

    if not vmobj or &quot;node&quot; not in vmobj or &quot;type&quot; not in vmobj or &quot;vmid&quot; not in vmobj:
        log.error(&quot;Unable to set status %s for %s (%s)&quot;, status, name, vmid)
        raise SaltCloudExecutionTimeout

    log.debug(&quot;VM_STATUS: Has desired info (%s). Setting status..&quot;, vmobj)
    data = query(
        &quot;post&quot;,
        &quot;nodes/{}/{}/{}/status/{}&quot;.format(
            vmobj[&quot;node&quot;], vmobj[&quot;type&quot;], vmobj[&quot;vmid&quot;], status
        ),
    )

    result = _parse_proxmox_upid(data, vmobj)

    if result is not False and result is not None:
        log.debug(&quot;Set_vm_status action result: %s&quot;, result)
        return True

    return False


def get_vm_status(vmid=None, name=None):
    &quot;&quot;&quot;
    Get the status for a VM, either via the ID or the hostname
    &quot;&quot;&quot;
    if vmid is not None:
        log.debug(&quot;get_vm_status: VMID %s&quot;, vmid)
        vmobj = _get_vm_by_id(vmid)
    elif name is not None:
        log.debug(&quot;get_vm_status: name %s&quot;, name)
        vmobj = _get_vm_by_name(name)
    else:
        log.debug(&quot;get_vm_status: No ID or NAME given&quot;)
        raise SaltCloudExecutionFailure

    log.debug(&quot;VM found: %s&quot;, vmobj)

    if vmobj is not None and &quot;node&quot; in vmobj:
        log.debug(&quot;VM_STATUS: Has desired info. Retrieving.. (%s)&quot;, vmobj[&quot;name&quot;])
        data = query(
            &quot;get&quot;,
            &quot;nodes/{}/{}/{}/status/current&quot;.format(
                vmobj[&quot;node&quot;], vmobj[&quot;type&quot;], vmobj[&quot;vmid&quot;]
            ),
        )
        return data

    log.error(&quot;VM or requested status not found..&quot;)
    return False


def start(name, vmid=None, call=None):
    &quot;&quot;&quot;
    Start a node.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a start mymachine
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The start action must be called with -a or --action.&quot;
        )

    log.debug(&quot;Start: %s (%s) = Start&quot;, name, vmid)
    if not set_vm_status(&quot;start&quot;, name, vmid=vmid):
        log.error(&quot;Unable to bring VM %s (%s) up..&quot;, name, vmid)
        raise SaltCloudExecutionFailure

    # xxx: TBD: Check here whether the status was actually changed to 'started'

    return {&quot;Started&quot;: &quot;{} was started.&quot;.format(name)}


def stop(name, vmid=None, call=None):
    &quot;&quot;&quot;
    Stop a node (&quot;pulling the plug&quot;).

    CLI Example:

    .. code-block:: bash

        salt-cloud -a stop mymachine
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(&quot;The stop action must be called with -a or --action.&quot;)

    if not set_vm_status(&quot;stop&quot;, name, vmid=vmid):
        log.error(&quot;Unable to bring VM %s (%s) down..&quot;, name, vmid)
        raise SaltCloudExecutionFailure

    # xxx: TBD: Check here whether the status was actually changed to 'stopped'

    return {&quot;Stopped&quot;: &quot;{} was stopped.&quot;.format(name)}


def shutdown(name=None, vmid=None, call=None):
    &quot;&quot;&quot;
    Shutdown a node via ACPI.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a shutdown mymachine
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The shutdown action must be called with -a or --action.&quot;
        )

    if not set_vm_status(&quot;shutdown&quot;, name, vmid=vmid):
        log.error(&quot;Unable to shut VM %s (%s) down..&quot;, name, vmid)
        raise SaltCloudExecutionFailure

    # xxx: TBD: Check here whether the status was actually changed to 'stopped'

    return {&quot;Shutdown&quot;: &quot;{} was shutdown.&quot;.format(name)}
</PRE>
</div>
  </div>
</body>
</html>
