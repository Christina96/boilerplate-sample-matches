<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_botomod.py &amp; proxmox.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_botomod.py &amp; proxmox.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_botomod.py (3.7383177%)<th>proxmox.py (0.81632656%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(26-38)<td><a href="#" name="0">(44-56)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_botomod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import salt.utils.boto3mod as boto3mod
3 import salt.utils.botomod as botomod
4 from salt.exceptions import SaltInvocationError
5 from salt.utils.versions import LooseVersion
6 from tests.support.mixins import LoaderModuleMockMixin
7 from tests.support.mock import MagicMock, patch
8 from tests.support.runtests import RUNTIME_VARS
9 from tests.support.unit import TestCase, skipIf
10 try:
11     import boto
12     boto.ENDPOINTS_PATH = os.path.join(
13         RUNTIME_VARS.TESTS_DIR, "unit/files/endpoints.json"
14     )
15     import boto.exception
16     from boto.exception import BotoServerError
17     HAS_BOTO = True
18 <a name="0"></a>except ImportError:
19     HAS_BOTO = False
20 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try:
21     import boto3
22     HAS_BOTO3 = True
23 except ImportError:
24     HAS_BOTO3 = False
25 try:
26     from moto import mock_ec2
27     HAS_MOTO = True
28 except ImportError:
29     HAS_MOTO =</b></font> False
30     def mock_ec2(self):
31         def stub_function(self):
32             pass
33         return stub_function
34 required_boto_version = "2.0.0"
35 required_boto3_version = "1.2.1"
36 region = "us-east-1"
37 access_key = "GKTADJGHEIQSXMKKRBJ08H"
38 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
39 conn_parameters = {
40     "region": region,
41     "key": access_key,
42     "keyid": secret_key,
43     "profile": {},
44 }
45 service = "ec2"
46 resource_name = "test-instance"
47 resource_id = "i-a1b2c3"
48 error_body = """
49 &lt;Response&gt;
50     &lt;Errors&gt;
51          &lt;Error&gt;
52            &lt;Code&gt;Error code text&lt;/Code&gt;
53            &lt;Message&gt;Error message&lt;/Message&gt;
54          &lt;/Error&gt;
55     &lt;/Errors&gt;
56     &lt;RequestID&gt;request ID&lt;/RequestID&gt;
57 &lt;/Response&gt;
58 """
59 no_error_body = """
60 &lt;Response&gt;
61     &lt;Errors /&gt;
62     &lt;RequestID&gt;request ID&lt;/RequestID&gt;
63 &lt;/Response&gt;
64 """
65 def _has_required_boto():
66     if not HAS_BOTO:
67         return False
68     elif LooseVersion(boto.__version__) &lt; LooseVersion(required_boto_version):
69         return False
70     else:
71         return True
72 def _has_required_boto3():
73     try:
74         if not HAS_BOTO3:
75             return False
76         elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
77             return False
78         else:
79             return True
80     except AttributeError as exc:
81         if "has no attribute '__version__'" not in str(exc):
82             raise
83         return False
84 def _has_required_moto():
85     if not HAS_MOTO:
86         return False
87     else:
88         import pkg_resources
89         if LooseVersion(pkg_resources.get_distribution("moto").version) &lt; LooseVersion(
90             "0.3.7"
91         ):
92             return False
93         return True
94 class BotoUtilsTestCaseBase(TestCase, LoaderModuleMockMixin):
95     def setup_loader_modules(self):
96         module_globals = {
97             "__salt__": {"config.option": MagicMock(return_value="dummy_opt")}
98         }
99         return {botomod: module_globals, boto3mod: module_globals}
100 class BotoUtilsCacheIdTestCase(BotoUtilsTestCaseBase):
101     def test_set_and_get_with_no_auth_params(self):
102         botomod.cache_id(service, resource_name, resource_id=resource_id)
103         self.assertEqual(botomod.cache_id(service, resource_name), resource_id)
104     def test_set_and_get_with_explicit_auth_params(self):
105         botomod.cache_id(
106             service, resource_name, resource_id=resource_id, **conn_parameters
107         )
108         self.assertEqual(
109             botomod.cache_id(service, resource_name, **conn_parameters), resource_id
110         )
111     def test_set_and_get_with_different_region_returns_none(self):
112         botomod.cache_id(
113             service, resource_name, resource_id=resource_id, region="us-east-1"
114         )
115         self.assertEqual(
116             botomod.cache_id(service, resource_name, region="us-west-2"), None
117         )
118     def test_set_and_get_after_invalidation_returns_none(self):
119         botomod.cache_id(service, resource_name, resource_id=resource_id)
120         botomod.cache_id(
121             service, resource_name, resource_id=resource_id, invalidate=True
122         )
123         self.assertEqual(botomod.cache_id(service, resource_name), None)
124     def test_partial(self):
125         cache_id = botomod.cache_id_func(service)
126         cache_id(resource_name, resource_id=resource_id)
127         self.assertEqual(cache_id(resource_name), resource_id)
128 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
129 @skipIf(HAS_MOTO is False, "The moto module must be installed.")
130 @skipIf(
131     _has_required_boto() is False,
132     "The boto module must be greater than or equal to version {}".format(
133         required_boto_version
134     ),
135 )
136 class BotoUtilsGetConnTestCase(BotoUtilsTestCaseBase):
137     @mock_ec2
138     def test_conn_is_cached(self):
139         conn = botomod.get_connection(service, **conn_parameters)
140         self.assertTrue(conn in botomod.__context__.values())
141     @mock_ec2
142     def test_conn_is_cache_with_profile(self):
143         conn = botomod.get_connection(service, profile=conn_parameters)
144         self.assertTrue(conn in botomod.__context__.values())
145     @mock_ec2
146     def test_get_conn_with_no_auth_params_raises_invocation_error(self):
147         with patch(
148             "boto.{}.connect_to_region".format(service),
149             side_effect=boto.exception.NoAuthHandlerFound(),
150         ):
151             with self.assertRaises(SaltInvocationError):
152                 botomod.get_connection(service)
153     @mock_ec2
154     def test_get_conn_error_raises_command_execution_error(self):
155         with patch(
156             "boto.{}.connect_to_region".format(service),
157             side_effect=BotoServerError(400, "Mocked error", body=error_body),
158         ):
159             with self.assertRaises(BotoServerError):
160                 botomod.get_connection(service)
161     @mock_ec2
162     def test_partial(self):
163         get_conn = botomod.get_connection_func(service)
164         conn = get_conn(**conn_parameters)
165         self.assertTrue(conn in botomod.__context__.values())
166 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
167 @skipIf(
168     _has_required_boto() is False,
169     "The boto module must be greater than or equal to version {}".format(
170         required_boto_version
171     ),
172 )
173 class BotoUtilsGetErrorTestCase(BotoUtilsTestCaseBase):
174     def test_error_message(self):
175         e = BotoServerError("400", "Mocked error", body=error_body)
176         r = botomod.get_error(e)
177         expected = {
178             "aws": {
179                 "code": "Error code text",
180                 "message": "Error message",
181                 "reason": "Mocked error",
182                 "status": "400",
183             },
184             "message": "Mocked error: Error message",
185         }
186         self.assertEqual(r, expected)
187     def test_exception_message_with_no_body(self):
188         e = BotoServerError("400", "Mocked error")
189         r = botomod.get_error(e)
190         expected = {
191             "aws": {"reason": "Mocked error", "status": "400"},
192             "message": "Mocked error",
193         }
194         self.assertEqual(r, expected)
195     def test_exception_message_with_no_error_in_body(self):
196         e = BotoServerError("400", "Mocked error", body=no_error_body)
197         r = botomod.get_error(e)
198         expected = {
199             "aws": {"reason": "Mocked error", "status": "400"},
200             "message": "Mocked error",
201         }
202         self.assertEqual(r, expected)
203 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
204 @skipIf(
205     _has_required_boto() is False,
206     "The boto module must be greater than or equal to version {}".format(
207         required_boto_version
208     ),
209 )
210 @skipIf(HAS_BOTO3 is False, "The boto3 module must be installed.")
211 @skipIf(
212     _has_required_boto3() is False,
213     "The boto3 module must be greater than or equal to version {}".format(
214         required_boto3_version
215     ),
216 )
217 class BotoBoto3CacheContextCollisionTest(BotoUtilsTestCaseBase):
218     def test_context_conflict_between_boto_and_boto3_utils(self):
219         botomod.assign_funcs(__name__, "ec2")
220         boto3mod.assign_funcs(__name__, "ec2", get_conn_funcname="_get_conn3")
221         boto_ec2_conn = botomod.get_connection(
222             "ec2", region=region, key=secret_key, keyid=access_key
223         )
224         boto3_ec2_conn = boto3mod.get_connection(
225             "ec2", region=region, key=secret_key, keyid=access_key
226         )
227         self.assertNotEqual(id(boto_ec2_conn), id(boto3_ec2_conn))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>proxmox.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import pprint
3 import re
4 import socket
5 import time
6 import salt.config as config
7 import salt.utils.cloud
8 import salt.utils.json
9 from salt.exceptions import (
10     SaltCloudExecutionFailure,
11     SaltCloudExecutionTimeout,
12 <a name="0"></a>    SaltCloudSystemExit,
13 )
14 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try:
15     import requests
16     HAS_REQUESTS = True
17 except ImportError:
18     HAS_REQUESTS = False
19 try:
20     from IPy import IP
21     HAS_IPY = True
22 except ImportError:
23     HAS_IPY =</b></font> False
24 log = logging.getLogger(__name__)
25 __virtualname__ = "proxmox"
26 def __virtual__():
27     if get_configured_provider() is False:
28         return False
29     if get_dependencies() is False:
30         return False
31     return __virtualname__
32 def _get_active_provider_name():
33     try:
34         return __active_provider_name__.value()
35     except AttributeError:
36         return __active_provider_name__
37 def get_configured_provider():
38     return config.is_provider_configured(
39         __opts__, _get_active_provider_name() or __virtualname__, ("user",)
40     )
41 def get_dependencies():
42     deps = {"requests": HAS_REQUESTS, "IPy": HAS_IPY}
43     return config.check_driver_dependencies(__virtualname__, deps)
44 url = None
45 port = None
46 ticket = None
47 csrf = None
48 verify_ssl = None
49 api = None
50 def _authenticate():
51     global url, port, ticket, csrf, verify_ssl
52     url = config.get_cloud_config_value(
53         "url", get_configured_provider(), __opts__, search_global=False
54     )
55     port = config.get_cloud_config_value(
56         "port", get_configured_provider(), __opts__, default=8006, search_global=False
57     )
58     username = (
59         config.get_cloud_config_value(
60             "user", get_configured_provider(), __opts__, search_global=False
61         ),
62     )
63     passwd = config.get_cloud_config_value(
64         "password", get_configured_provider(), __opts__, search_global=False
65     )
66     verify_ssl = config.get_cloud_config_value(
67         "verify_ssl",
68         get_configured_provider(),
69         __opts__,
70         default=True,
71         search_global=False,
72     )
73     connect_data = {"username": username, "password": passwd}
74     full_url = "https://{}:{}/api2/json/access/ticket".format(url, port)
75     returned_data = requests.post(full_url, verify=verify_ssl, data=connect_data).json()
76     ticket = {"PVEAuthCookie": returned_data["data"]["ticket"]}
77     csrf = str(returned_data["data"]["CSRFPreventionToken"])
78 def query(conn_type, option, post_data=None):
79     if ticket is None or csrf is None or url is None:
80         log.debug("Not authenticated yet, doing that now..")
81         _authenticate()
82     full_url = "https://{}:{}/api2/json/{}".format(url, port, option)
83     log.debug("%s: %s (%s)", conn_type, full_url, post_data)
84     httpheaders = {
85         "Accept": "application/json",
86         "Content-Type": "application/x-www-form-urlencoded",
87         "User-Agent": "salt-cloud-proxmox",
88     }
89     if conn_type == "post":
90         httpheaders["CSRFPreventionToken"] = csrf
91         response = requests.post(
92             full_url,
93             verify=verify_ssl,
94             data=post_data,
95             cookies=ticket,
96             headers=httpheaders,
97         )
98     elif conn_type == "put":
99         httpheaders["CSRFPreventionToken"] = csrf
100         response = requests.put(
101             full_url,
102             verify=verify_ssl,
103             data=post_data,
104             cookies=ticket,
105             headers=httpheaders,
106         )
107     elif conn_type == "delete":
108         httpheaders["CSRFPreventionToken"] = csrf
109         response = requests.delete(
110             full_url,
111             verify=verify_ssl,
112             data=post_data,
113             cookies=ticket,
114             headers=httpheaders,
115         )
116     elif conn_type == "get":
117         response = requests.get(full_url, verify=verify_ssl, cookies=ticket)
118     response.raise_for_status()
119     try:
120         returned_data = response.json()
121         if "data" not in returned_data:
122             raise SaltCloudExecutionFailure
123         return returned_data["data"]
124     except Exception:  # pylint: disable=broad-except
125         log.error("Error in trying to process JSON")
126         log.error(response)
127 def _get_vm_by_name(name, allDetails=False):
128     vms = get_resources_vms(includeConfig=allDetails)
129     if name in vms:
130         return vms[name]
131     log.info('VM with name "%s" could not be found.', name)
132     return False
133 def _get_vm_by_id(vmid, allDetails=False):
134     for vm_name, vm_details in get_resources_vms(includeConfig=allDetails).items():
135         if str(vm_details["vmid"]) == str(vmid):
136             return vm_details
137     log.info('VM with ID "%s" could not be found.', vmid)
138     return False
139 def _get_next_vmid():
140     return int(query("get", "cluster/nextid"))
141 def _check_ip_available(ip_addr):
142     for vm_name, vm_details in get_resources_vms(includeConfig=True).items():
143         vm_config = vm_details["config"]
144         if ip_addr in vm_config["ip_address"] or vm_config["ip_address"] == ip_addr:
145             log.debug('IP "%s" is already defined', ip_addr)
146             return False
147     log.debug("IP '%s' is available to be defined", ip_addr)
148     return True
149 def _parse_proxmox_upid(node, vm_=None):
150     ret = {}
151     upid = node
152     node = node.split(":")
153     if node[0] == "UPID":
154         ret["node"] = str(node[1])
155         ret["pid"] = str(node[2])
156         ret["pstart"] = str(node[3])
157         ret["starttime"] = str(node[4])
158         ret["type"] = str(node[5])
159         ret["vmid"] = str(node[6])
160         ret["user"] = str(node[7])
161         ret["upid"] = str(upid)
162         if vm_ is not None and "technology" in vm_:
163             ret["technology"] = str(vm_["technology"])
164     return ret
165 def _lookup_proxmox_task(upid):
166     log.debug("Getting creation status for upid: %s", upid)
167     tasks = query("get", "cluster/tasks")
168     if tasks:
169         for task in tasks:
170             if task["upid"] == upid:
171                 log.debug("Found upid task: %s", task)
172                 return task
173     return False
174 def get_resources_nodes(call=None, resFilter=None):
175     log.debug("Getting resource: nodes.. (filter: %s)", resFilter)
176     resources = query("get", "cluster/resources")
177     ret = {}
178     for resource in resources:
179         if "type" in resource and resource["type"] == "node":
180             name = resource["node"]
181             ret[name] = resource
182     if resFilter is not None:
183         log.debug("Filter given: %s, returning requested resource: nodes", resFilter)
184         return ret[resFilter]
185     log.debug("Filter not given: %s, returning all resource: nodes", ret)
186     return ret
187 def get_resources_vms(call=None, resFilter=None, includeConfig=True):
188     timeoutTime = time.time() + 60
189     while True:
190         log.debug("Getting resource: vms.. (filter: %s)", resFilter)
191         resources = query("get", "cluster/resources")
192         ret = {}
193         badResource = False
194         for resource in resources:
195             if "type" in resource and resource["type"] in ["openvz", "qemu", "lxc"]:
196                 try:
197                     name = resource["name"]
198                 except KeyError:
199                     badResource = True
200                     log.debug("No name in VM resource %s", repr(resource))
201                     break
202                 ret[name] = resource
203                 if includeConfig:
204                     ret[name]["config"] = get_vmconfig(
205                         ret[name]["vmid"], ret[name]["node"], ret[name]["type"]
206                     )
207         if time.time() &gt; timeoutTime:
208             raise SaltCloudExecutionTimeout("FAILED to get the proxmox resources vms")
209         if not badResource:
210             break
211         time.sleep(0.5)
212     if resFilter is not None:
213         log.debug("Filter given: %s, returning requested resource: nodes", resFilter)
214         return ret[resFilter]
215     log.debug("Filter not given: %s, returning all resource: nodes", ret)
216     return ret
217 def script(vm_):
218     script_name = config.get_cloud_config_value("script", vm_, __opts__)
219     if not script_name:
220         script_name = "bootstrap-salt"
221     return salt.utils.cloud.os_script(
222         script_name,
223         vm_,
224         __opts__,
225         salt.utils.cloud.salt_config_to_yaml(
226             salt.utils.cloud.minion_config(__opts__, vm_)
227         ),
228     )
229 def avail_locations(call=None):
230     if call == "action":
231         raise SaltCloudSystemExit(
232             "The avail_locations function must be called with "
233             "-f or --function, or with the --list-locations option"
234         )
235     nodes = query("get", "nodes")
236     ret = {}
237     for node in nodes:
238         name = node["node"]
239         ret[name] = node
240     return ret
241 def avail_images(call=None, location="local"):
242     if call == "action":
243         raise SaltCloudSystemExit(
244             "The avail_images function must be called with "
245             "-f or --function, or with the --list-images option"
246         )
247     ret = {}
248     for host_name, host_details in avail_locations().items():
249         for item in query(
250             "get", "nodes/{}/storage/{}/content".format(host_name, location)
251         ):
252             ret[item["volid"]] = item
253     return ret
254 def list_nodes(call=None):
255     if call == "action":
256         raise SaltCloudSystemExit(
257             "The list_nodes function must be called with -f or --function."
258         )
259     ret = {}
260     for vm_name, vm_details in get_resources_vms(includeConfig=True).items():
261         log.debug("VM_Name: %s", vm_name)
262         log.debug("vm_details: %s", vm_details)
263         ret[vm_name] = {}
264         ret[vm_name]["id"] = str(vm_details["vmid"])
265         ret[vm_name]["image"] = str(vm_details["vmid"])
266         ret[vm_name]["size"] = str(vm_details["disk"])
267         ret[vm_name]["state"] = str(vm_details["status"])
268         private_ips = []
269         public_ips = []
270         if (
271             "ip_address" in vm_details["config"]
272             and vm_details["config"]["ip_address"] != "-"
273         ):
274             ips = vm_details["config"]["ip_address"].split(" ")
275             for ip_ in ips:
276                 if IP(ip_).iptype() == "PRIVATE":
277                     private_ips.append(str(ip_))
278                 else:
279                     public_ips.append(str(ip_))
280         ret[vm_name]["private_ips"] = private_ips
281         ret[vm_name]["public_ips"] = public_ips
282     return ret
283 def list_nodes_full(call=None):
284     if call == "action":
285         raise SaltCloudSystemExit(
286             "The list_nodes_full function must be called with -f or --function."
287         )
288     return get_resources_vms(includeConfig=True)
289 def list_nodes_select(call=None):
290     return salt.utils.cloud.list_nodes_select(
291         list_nodes_full(),
292         __opts__["query.selection"],
293         call,
294     )
295 def _stringlist_to_dictionary(input_string):
296     return dict(item.strip().split("=") for item in input_string.split(",") if item)
297 def _dictionary_to_stringlist(input_dict):
298     return ",".join("{}={}".format(k, input_dict[k]) for k in sorted(input_dict.keys()))
299 def _reconfigure_clone(vm_, vmid):
300     if not vm_.get("technology") == "qemu":
301         log.warning("Reconfiguring clones is only available under `qemu`")
302         return
303     log.info("Configuring cloned VM")
304     for setting in vm_:
305         if re.match(r"^(ide|sata|scsi)(\d+)$", setting):
306             postParams = {setting: vm_[setting]}
307             query(
308                 "post",
309                 "nodes/{}/qemu/{}/config".format(vm_["host"], vmid),
310                 postParams,
311             )
312         elif re.match(r"^net(\d+)$", setting):
313             data = query("get", "nodes/{}/qemu/{}/config".format(vm_["host"], vmid))
314             new_setting = {}
315             if setting in data:
316                 new_setting.update(_stringlist_to_dictionary(data[setting]))
317             new_setting.update(_stringlist_to_dictionary(vm_[setting]))
318             postParams = {setting: _dictionary_to_stringlist(new_setting)}
319             query(
320                 "post",
321                 "nodes/{}/qemu/{}/config".format(vm_["host"], vmid),
322                 postParams,
323             )
324 def create(vm_):
325     try:
326         if (
327             vm_["profile"]
328             and config.is_profile_configured(
329                 __opts__,
330                 _get_active_provider_name() or "proxmox",
331                 vm_["profile"],
332                 vm_=vm_,
333             )
334             is False
335         ):
336             return False
337     except AttributeError:
338         pass
339     ret = {}
340     __utils__["cloud.fire_event"](
341         "event",
342         "starting create",
343         "salt/cloud/{}/creating".format(vm_["name"]),
344         args=__utils__["cloud.filter_event"](
345             "creating", vm_, ["name", "profile", "provider", "driver"]
346         ),
347         sock_dir=__opts__["sock_dir"],
348         transport=__opts__["transport"],
349     )
350     log.info("Creating Cloud VM %s", vm_["name"])
351     if "use_dns" in vm_ and "ip_address" not in vm_:
352         use_dns = vm_["use_dns"]
353         if use_dns:
354             from socket import gethostbyname, gaierror
355             try:
356                 ip_address = gethostbyname(str(vm_["name"]))
357             except gaierror:
358                 log.debug("Resolving of %s failed", vm_["name"])
359             else:
360                 vm_["ip_address"] = str(ip_address)
361     try:
362         newid = _get_next_vmid()
363         data = create_node(vm_, newid)
364     except Exception as exc:  # pylint: disable=broad-except
365         log.error(
366             "Error creating %s on PROXMOX\n\n"
367             "The following exception was thrown when trying to "
368             "run the initial deployment: \n%s",
369             vm_["name"],
370             exc,
371             exc_info_on_loglevel=logging.DEBUG,
372         )
373         return False
374     ret["creation_data"] = data
375     name = vm_["name"]  # hostname which we know
376     if "clone" in vm_ and vm_["clone"] is True:
377         vmid = newid
378     else:
379         vmid = data["vmid"]  # vmid which we have received
380     host = data["node"]  # host which we have received
381     nodeType = data["technology"]  # VM tech (Qemu / OpenVZ)
382     agent_get_ip = vm_.get("agent_get_ip", False)
383     if agent_get_ip is False:
384         if "ip_address" in vm_:
385             ip_address = str(vm_["ip_address"])
386         elif "public_ips" in data:
387             ip_address = str(data["public_ips"][0])  # first IP
388         elif "private_ips" in data:
389             ip_address = str(data["private_ips"][0])  # first IP
390         else:
391             raise SaltCloudExecutionFailure("Could not determine an IP address to use")
392         log.debug("Using IP address %s", ip_address)
393     if not wait_for_created(data["upid"], timeout=300):
394         return {"Error": "Unable to create {}, command timed out".format(name)}
395     if vm_.get("clone") is True:
396         _reconfigure_clone(vm_, vmid)
397     if not start(name, vmid, call="action"):
398         log.error("Node %s (%s) failed to start!", name, vmid)
399         raise SaltCloudExecutionFailure
400     log.debug('Waiting for state "running" for vm %s on %s', vmid, host)
401     if not wait_for_state(vmid, "running"):
402         return {"Error": "Unable to start {}, command timed out".format(name)}
403     if agent_get_ip is True:
404         try:
405             ip_address = salt.utils.cloud.wait_for_fun(
406                 _find_agent_ip, vm_=vm_, vmid=vmid
407             )
408         except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
409             try:
410                 destroy(vm_["name"])
411             except SaltCloudSystemExit:
412                 pass
413             finally:
414                 raise SaltCloudSystemExit(str(exc))
415         log.debug("Using IP address %s", ip_address)
416     ssh_username = config.get_cloud_config_value(
417         "ssh_username", vm_, __opts__, default="root"
418     )
419     ssh_password = config.get_cloud_config_value(
420         "password",
421         vm_,
422         __opts__,
423     )
424     ret["ip_address"] = ip_address
425     ret["username"] = ssh_username
426     ret["password"] = ssh_password
427     vm_["ssh_host"] = ip_address
428     vm_["password"] = ssh_password
429     ret = __utils__["cloud.bootstrap"](vm_, __opts__)
430     log.info("Created Cloud VM '%s'", vm_["name"])
431     log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
432     __utils__["cloud.fire_event"](
433         "event",
434         "created instance",
435         "salt/cloud/{}/created".format(vm_["name"]),
436         args=__utils__["cloud.filter_event"](
437             "created", vm_, ["name", "profile", "provider", "driver"]
438         ),
439         sock_dir=__opts__["sock_dir"],
440     )
441     return ret
442 def preferred_ip(vm_, ips):
443     proto = config.get_cloud_config_value(
444         "protocol", vm_, __opts__, default="ipv4", search_global=False
445     )
446     family = socket.AF_INET
447     if proto == "ipv6":
448         family = socket.AF_INET6
449     for ip in ips:
450         ignore_ip = ignore_cidr(vm_, ip)
451         if ignore_ip:
452             continue
453         try:
454             socket.inet_pton(family, ip)
455             return ip
456         except Exception:  # pylint: disable=broad-except
457             continue
458     return False
459 def ignore_cidr(vm_, ip):
460     from ipaddress import ip_address, ip_network
461     cidrs = config.get_cloud_config_value(
462         "ignore_cidr", vm_, __opts__, default=[], search_global=False
463     )
464     if cidrs and isinstance(cidrs, str):
465         cidrs = [cidrs]
466     for cidr in cidrs or []:
467         if ip_address(ip) in ip_network(cidr):
468             log.warning("IP %r found within %r; ignoring it.", ip, cidr)
469             return True
470     return False
471 def _find_agent_ip(vm_, vmid):
472     if not vm_.get("technology") == "qemu":
473         log.warning("Find agent IP is only available under `qemu`")
474         return
475     ips = []
476     endpoint = "nodes/{}/qemu/{}/agent/network-get-interfaces".format(vm_["host"], vmid)
477     interfaces = query("get", endpoint)
478     for interface in interfaces["result"]:
479         if str(interface.get("hardware-address")) == "00:00:00:00:00:00":
480             continue
481         if "ip-addresses" not in interface:
482             continue
483         for if_addr in interface["ip-addresses"]:
484             ip_addr = if_addr.get("ip-address")
485             if ip_addr is not None:
486                 ips.append(str(ip_addr))
487     if len(ips) &gt; 0:
488         return preferred_ip(vm_, ips)
489     raise SaltCloudExecutionFailure
490 def _import_api():
491     global api
492     full_url = "https://{}:{}/pve-docs/api-viewer/apidoc.js".format(url, port)
493     returned_data = requests.get(full_url, verify=verify_ssl)
494     re_filter = re.compile("(?&lt;=pveapi =)(.*)(?=^;)", re.DOTALL | re.MULTILINE)
495     api_json = re_filter.findall(returned_data.text)[0]
496     api = salt.utils.json.loads(api_json)
497 def _get_properties(path="", method="GET", forced_params=None):
498     if api is None:
499         _import_api()
500     sub = api
501     path_levels = [level for level in path.split("/") if level != ""]
502     search_path = ""
503     props = []
504     parameters = set([] if forced_params is None else forced_params)
505     for elem in path_levels[:-1]:
506         search_path += "/" + elem
507         sub = next(item for item in sub if item["path"] == search_path)["children"]
508     search_path += "/" + path_levels[-1]
509     sub = next(item for item in sub if item["path"] == search_path)
510     try:
511         props = sub["info"][method]["parameters"]["properties"].keys()
512     except KeyError as exc:
513         log.error('method not found: "%s"', exc)
514     for prop in props:
515         numerical = re.match(r"(\w+)\[n\]", prop)
516         if numerical:
517             for i in range(10):
518                 parameters.add(numerical.group(1) + str(i))
519         else:
520             parameters.add(prop)
521     return parameters
522 def create_node(vm_, newid):
523     newnode = {}
524     if "technology" not in vm_:
525         vm_["technology"] = "openvz"  # default virt tech if none is given
526     if vm_["technology"] not in ["qemu", "openvz", "lxc"]:
527         log.error(
528             "Wrong VM type. Valid options are: qemu, openvz (proxmox3) or lxc"
529             " (proxmox4)"
530         )
531         raise SaltCloudExecutionFailure
532     if "host" not in vm_:
533         vm_["host"] = config.get_cloud_config_value(
534             "default_host", get_configured_provider(), __opts__, search_global=False
535         )
536     if vm_["host"] is None:
537         log.error("No host given to create this VM on")
538         raise SaltCloudExecutionFailure
539     vmhost = vm_["host"]
540     newnode["vmid"] = newid
541     for prop in "cpuunits", "description", "memory", "onboot":
542         if prop in vm_:  # if the property is set, use it for the VM request
543             newnode[prop] = vm_[prop]
544     if vm_["technology"] == "openvz":
545         newnode["hostname"] = vm_["name"]
546         newnode["ostemplate"] = vm_["image"]
547         for prop in (
548             "cpus",
549             "disk",
550             "ip_address",
551             "nameserver",
552             "password",
553             "swap",
554             "poolid",
555             "storage",
556         ):
557             if prop in vm_:  # if the property is set, use it for the VM request
558                 newnode[prop] = vm_[prop]
559     elif vm_["technology"] == "lxc":
560         newnode["hostname"] = vm_["name"]
561         newnode["ostemplate"] = vm_["image"]
562         static_props = (
563             "cpuunits",
564             "cpulimit",
565             "rootfs",
566             "cores",
567             "description",
568             "memory",
569             "onboot",
570             "net0",
571             "password",
572             "nameserver",
573             "swap",
574             "storage",
575             "rootfs",
576         )
577         for prop in _get_properties("/nodes/{node}/lxc", "POST", static_props):
578             if prop in vm_:  # if the property is set, use it for the VM request
579                 newnode[prop] = vm_[prop]
580         if "pubkey" in vm_:
581             newnode["ssh-public-keys"] = vm_["pubkey"]
582         if "disk" in vm_:
583             log.warning(
584                 'The "disk" option is not supported for LXC hosts and was ignored'
585             )
586         if "ip_address" in vm_ and "net0" not in vm_:
587             newnode["net0"] = (
588                 "bridge=vmbr0,ip=" + vm_["ip_address"] + "/24,name=eth0,type=veth"
589             )
590             if "gw" in vm_:
591                 newnode["net0"] = newnode["net0"] + ",gw=" + vm_["gw"]
592     elif vm_["technology"] == "qemu":
593         static_props = (
594             "acpi",
595             "cores",
596             "cpu",
597             "pool",
598             "storage",
599             "sata0",
600             "ostype",
601             "ide2",
602             "net0",
603         )
604         for prop in _get_properties("/nodes/{node}/qemu", "POST", static_props):
605             if prop in vm_:  # if the property is set, use it for the VM request
606                 newnode[prop] = vm_[prop]
607     __utils__["cloud.fire_event"](
608         "event",
609         "requesting instance",
610         "salt/cloud/{}/requesting".format(vm_["name"]),
611         args={
612             "kwargs": __utils__["cloud.filter_event"](
613                 "requesting", newnode, list(newnode)
614             ),
615         },
616         sock_dir=__opts__["sock_dir"],
617     )
618     log.debug("Preparing to generate a node using these parameters: %s ", newnode)
619     if "clone" in vm_ and vm_["clone"] is True and vm_["technology"] == "qemu":
620         postParams = {}
621         postParams["newid"] = newnode["vmid"]
622         for prop in "description", "format", "full", "name":
623             if (
624                 "clone_" + prop in vm_
625             ):  # if the property is set, use it for the VM request
626                 postParams[prop] = vm_["clone_" + prop]
627         try:
628             int(vm_["clone_from"])
629         except ValueError:
630             if ":" in vm_["clone_from"]:
631                 vmhost = vm_["clone_from"].split(":")[0]
632                 vm_["clone_from"] = vm_["clone_from"].split(":")[1]
633         node = query(
634             "post",
635             "nodes/{}/qemu/{}/clone".format(vmhost, vm_["clone_from"]),
636             postParams,
637         )
638     else:
639         node = query("post", "nodes/{}/{}".format(vmhost, vm_["technology"]), newnode)
640     return _parse_proxmox_upid(node, vm_)
641 def show_instance(name, call=None):
642     if call != "action":
643         raise SaltCloudSystemExit(
644             "The show_instance action must be called with -a or --action."
645         )
646     nodes = list_nodes_full()
647     __utils__["cloud.cache_node"](nodes[name], _get_active_provider_name(), __opts__)
648     return nodes[name]
649 def get_vmconfig(vmid, node=None, node_type="openvz"):
650     if node is None:
651         for host_name, host_details in avail_locations().items():
652             for item in query("get", "nodes/{}/{}".format(host_name, node_type)):
653                 if item["vmid"] == vmid:
654                     node = host_name
655     data = query("get", "nodes/{}/{}/{}/config".format(node, node_type, vmid))
656     return data
657 def wait_for_created(upid, timeout=300):
658     start_time = time.time()
659     info = _lookup_proxmox_task(upid)
660     if not info:
661         log.error(
662             "wait_for_created: No task information retrieved based on given criteria."
663         )
664         raise SaltCloudExecutionFailure
665     while True:
666         if "status" in info and info["status"] == "OK":
667             log.debug("Host has been created!")
668             return True
669         time.sleep(3)  # Little more patience, we're not in a hurry
670         if time.time() - start_time &gt; timeout:
671             log.debug("Timeout reached while waiting for host to be created")
672             return False
673         info = _lookup_proxmox_task(upid)
674 def wait_for_state(vmid, state, timeout=300):
675     start_time = time.time()
676     node = get_vm_status(vmid=vmid)
677     if not node:
678         log.error("wait_for_state: No VM retrieved based on given criteria.")
679         raise SaltCloudExecutionFailure
680     while True:
681         if node["status"] == state:
682             log.debug('Host %s is now in "%s" state!', node["name"], state)
683             return True
684         time.sleep(1)
685         if time.time() - start_time &gt; timeout:
686             log.debug(
687                 "Timeout reached while waiting for %s to become %s", node["name"], state
688             )
689             return False
690         node = get_vm_status(vmid=vmid)
691         log.debug(
692             'State for %s is: "%s" instead of "%s"', node["name"], node["status"], state
693         )
694 def destroy(name, call=None):
695     if call == "function":
696         raise SaltCloudSystemExit(
697             "The destroy action must be called with -d, --destroy, -a or --action."
698         )
699     __utils__["cloud.fire_event"](
700         "event",
701         "destroying instance",
702         "salt/cloud/{}/destroying".format(name),
703         args={"name": name},
704         sock_dir=__opts__["sock_dir"],
705         transport=__opts__["transport"],
706     )
707     vmobj = _get_vm_by_name(name)
708     if vmobj is not None:
709         if get_vm_status(vmid=vmobj["vmid"])["status"] != "stopped":
710             stop(name, vmobj["vmid"], "action")
711         if not wait_for_state(vmobj["vmid"], "stopped"):
712             return {"Error": "Unable to stop {}, command timed out".format(name)}
713         time.sleep(3)
714         query("delete", "nodes/{}/{}".format(vmobj["node"], vmobj["id"]))
715         __utils__["cloud.fire_event"](
716             "event",
717             "destroyed instance",
718             "salt/cloud/{}/destroyed".format(name),
719             args={"name": name},
720             sock_dir=__opts__["sock_dir"],
721             transport=__opts__["transport"],
722         )
723         if __opts__.get("update_cachedir", False) is True:
724             __utils__["cloud.delete_minion_cachedir"](
725                 name, _get_active_provider_name().split(":")[0], __opts__
726             )
727         return {"Destroyed": "{} was destroyed.".format(name)}
728 def set_vm_status(status, name=None, vmid=None):
729     log.debug("Set status to %s for %s (%s)", status, name, vmid)
730     if vmid is not None:
731         log.debug("set_vm_status: via ID - VMID %s (%s): %s", vmid, name, status)
732         vmobj = _get_vm_by_id(vmid)
733     else:
734         log.debug("set_vm_status: via name - VMID %s (%s): %s", vmid, name, status)
735         vmobj = _get_vm_by_name(name)
736     if not vmobj or "node" not in vmobj or "type" not in vmobj or "vmid" not in vmobj:
737         log.error("Unable to set status %s for %s (%s)", status, name, vmid)
738         raise SaltCloudExecutionTimeout
739     log.debug("VM_STATUS: Has desired info (%s). Setting status..", vmobj)
740     data = query(
741         "post",
742         "nodes/{}/{}/{}/status/{}".format(
743             vmobj["node"], vmobj["type"], vmobj["vmid"], status
744         ),
745     )
746     result = _parse_proxmox_upid(data, vmobj)
747     if result is not False and result is not None:
748         log.debug("Set_vm_status action result: %s", result)
749         return True
750     return False
751 def get_vm_status(vmid=None, name=None):
752     if vmid is not None:
753         log.debug("get_vm_status: VMID %s", vmid)
754         vmobj = _get_vm_by_id(vmid)
755     elif name is not None:
756         log.debug("get_vm_status: name %s", name)
757         vmobj = _get_vm_by_name(name)
758     else:
759         log.debug("get_vm_status: No ID or NAME given")
760         raise SaltCloudExecutionFailure
761     log.debug("VM found: %s", vmobj)
762     if vmobj is not None and "node" in vmobj:
763         log.debug("VM_STATUS: Has desired info. Retrieving.. (%s)", vmobj["name"])
764         data = query(
765             "get",
766             "nodes/{}/{}/{}/status/current".format(
767                 vmobj["node"], vmobj["type"], vmobj["vmid"]
768             ),
769         )
770         return data
771     log.error("VM or requested status not found..")
772     return False
773 def start(name, vmid=None, call=None):
774     if call != "action":
775         raise SaltCloudSystemExit(
776             "The start action must be called with -a or --action."
777         )
778     log.debug("Start: %s (%s) = Start", name, vmid)
779     if not set_vm_status("start", name, vmid=vmid):
780         log.error("Unable to bring VM %s (%s) up..", name, vmid)
781         raise SaltCloudExecutionFailure
782     return {"Started": "{} was started.".format(name)}
783 def stop(name, vmid=None, call=None):
784     if call != "action":
785         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
786     if not set_vm_status("stop", name, vmid=vmid):
787         log.error("Unable to bring VM %s (%s) down..", name, vmid)
788         raise SaltCloudExecutionFailure
789     return {"Stopped": "{} was stopped.".format(name)}
790 def shutdown(name=None, vmid=None, call=None):
791     if call != "action":
792         raise SaltCloudSystemExit(
793             "The shutdown action must be called with -a or --action."
794         )
795     if not set_vm_status("shutdown", name, vmid=vmid):
796         log.error("Unable to shut VM %s (%s) down..", name, vmid)
797         raise SaltCloudExecutionFailure
798     return {"Shutdown": "{} was shutdown.".format(name)}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
