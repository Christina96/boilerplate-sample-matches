
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-bin_image.py</h3>
            <pre><code>1  import binascii
2  import copy
3  import hashlib
4  import io
5  import os
6  import re
7  import struct
8  from .loader import ESPLoader
9  from .targets import (
10      ESP32C2ROM,
11      ESP32C3ROM,
12      ESP32C6BETAROM,
13      ESP32C6ROM,
14      ESP32H2BETA1ROM,
15      ESP32H2BETA2ROM,
16      ESP32H2ROM,
17      ESP32ROM,
18      ESP32S2ROM,
19      ESP32S3BETA2ROM,
20      ESP32S3ROM,
21      ESP8266ROM,
22  )
23  from .util import FatalError, byte, pad_to
24  def align_file_position(f, size):
25      align = (size - 1) - (f.tell() % size)
26      f.seek(align, 1)
27  def LoadFirmwareImage(chip, image_file):
28      def select_image_class(f, chip):
29          chip = re.sub(r&quot;[-()]&quot;, &quot;&quot;, chip.lower())
30          if chip != &quot;esp8266&quot;:
31              return {
32                  &quot;esp32&quot;: ESP32FirmwareImage,
33                  &quot;esp32s2&quot;: ESP32S2FirmwareImage,
34                  &quot;esp32s3beta2&quot;: ESP32S3BETA2FirmwareImage,
35                  &quot;esp32s3&quot;: ESP32S3FirmwareImage,
36                  &quot;esp32c3&quot;: ESP32C3FirmwareImage,
37                  &quot;esp32c6beta&quot;: ESP32C6BETAFirmwareImage,
38                  &quot;esp32h2beta1&quot;: ESP32H2BETA1FirmwareImage,
39                  &quot;esp32h2beta2&quot;: ESP32H2BETA2FirmwareImage,
40                  &quot;esp32c2&quot;: ESP32C2FirmwareImage,
41                  &quot;esp32c6&quot;: ESP32C6FirmwareImage,
42                  &quot;esp32h2&quot;: ESP32H2FirmwareImage,
43              }[chip](f)
44          else:  # Otherwise, ESP8266 so look at magic to determine the image type
45              magic = ord(f.read(1))
46              f.seek(0)
47              if magic == ESPLoader.ESP_IMAGE_MAGIC:
48                  return ESP8266ROMFirmwareImage(f)
49              elif magic == ESP8266V2FirmwareImage.IMAGE_V2_MAGIC:
50                  return ESP8266V2FirmwareImage(f)
51              else:
52                  raise FatalError(&quot;Invalid image magic number: %d&quot; % magic)
53      if isinstance(image_file, str):
54          with open(image_file, &quot;rb&quot;) as f:
55              return select_image_class(f, chip)
56      return select_image_class(image_file, chip)
57  class ImageSegment(object):
58      def __init__(self, addr, data, file_offs=None):
59          self.addr = addr
60          self.data = data
61          self.file_offs = file_offs
62          self.include_in_checksum = True
63          if self.addr != 0:
64              self.pad_to_alignment(
65                  4
66              )  # pad all &quot;real&quot; ImageSegments 4 byte aligned length
67      def copy_with_new_addr(self, new_addr):
68          return ImageSegment(new_addr, self.data, 0)
69      def split_image(self, split_len):
70          result = copy.copy(self)
71          result.data = self.data[:split_len]
72          self.data = self.data[split_len:]
73          self.addr += split_len
74          self.file_offs = None
75          result.file_offs = None
76          return result
77      def __repr__(self):
78          r = &quot;len 0x%05x load 0x%08x&quot; % (len(self.data), self.addr)
79          if self.file_offs is not None:
80              r += &quot; file_offs 0x%08x&quot; % (self.file_offs)
81          return r
82      def get_memory_type(self, image):
83          return [
84              map_range[2]
85              for map_range in image.ROM_LOADER.MEMORY_MAP
86              if map_range[0] &lt;= self.addr &lt; map_range[1]
87          ]
88      def pad_to_alignment(self, alignment):
89          self.data = pad_to(self.data, alignment, b&quot;\x00&quot;)
90  class ELFSection(ImageSegment):
91      def __init__(self, name, addr, data):
92          super(ELFSection, self).__init__(addr, data)
93          self.name = name.decode(&quot;utf-8&quot;)
94      def __repr__(self):
95          return &quot;%s %s&quot; % (self.name, super(ELFSection, self).__repr__())
96  class BaseFirmwareImage(object):
97      SEG_HEADER_LEN = 8
98      SHA256_DIGEST_LEN = 32
99      def __init__(self):
100          self.segments = []
101          self.entrypoint = 0
102          self.elf_sha256 = None
103          self.elf_sha256_offset = 0
104          self.pad_to_size = 0
105      def load_common_header(self, load_file, expected_magic):
106          (
107              magic,
108              segments,
109              self.flash_mode,
110              self.flash_size_freq,
111              self.entrypoint,
112          ) = struct.unpack(&quot;&lt;BBBBI&quot;, load_file.read(8))
113          if magic != expected_magic:
114              raise FatalError(&quot;Invalid firmware image magic=0x%x&quot; % (magic))
115          return segments
116      def verify(self):
117          if len(self.segments) &gt; 16:
118              raise FatalError(
119                  &quot;Invalid segment count %d (max 16). &quot;
120                  &quot;Usually this indicates a linker script problem.&quot; % len(self.segments)
121              )
122      def load_segment(self, f, is_irom_segment=False):
123          file_offs = f.tell()
124          (offset, size) = struct.unpack(&quot;&lt;II&quot;, f.read(8))
125          self.warn_if_unusual_segment(offset, size, is_irom_segment)
126          segment_data = f.read(size)
127          if len(segment_data) &lt; size:
128              raise FatalError(
129                  &quot;End of file reading segment 0x%x, length %d (actual length %d)&quot;
130                  % (offset, size, len(segment_data))
131              )
132          segment = ImageSegment(offset, segment_data, file_offs)
133          self.segments.append(segment)
134          return segment
135      def warn_if_unusual_segment(self, offset, size, is_irom_segment):
136          if not is_irom_segment:
137              if offset &gt; 0x40200000 or offset &lt; 0x3FFE0000 or size &gt; 65536:
138                  print(&quot;WARNING: Suspicious segment 0x%x, length %d&quot; % (offset, size))
139      def maybe_patch_segment_data(self, f, segment_data):
140          segment_len = len(segment_data)
141          file_pos = f.tell()  # file_pos is position in the .bin file
142          if (
143              self.elf_sha256_offset &gt;= file_pos
144              and self.elf_sha256_offset &lt; file_pos + segment_len
145          ):
146              patch_offset = self.elf_sha256_offset - file_pos
147              if (
148                  patch_offset &lt; self.SEG_HEADER_LEN
149                  or patch_offset + self.SHA256_DIGEST_LEN &gt; segment_len
150              ):
151                  raise FatalError(
152                      &quot;Cannot place SHA256 digest on segment boundary&quot;
153                      &quot;(elf_sha256_offset=%d, file_pos=%d, segment_size=%d)&quot;
154                      % (self.elf_sha256_offset, file_pos, segment_len)
155                  )
156              patch_offset -= self.SEG_HEADER_LEN
157              if (
158                  segment_data[patch_offset : patch_offset + self.SHA256_DIGEST_LEN]
159                  != b&quot;\x00&quot; * self.SHA256_DIGEST_LEN
160              ):
161                  raise FatalError(
162                      &quot;Contents of segment at SHA256 digest offset 0x%x are not all zero.&quot;
163                      &quot; Refusing to overwrite.&quot; % self.elf_sha256_offset
164                  )
165              assert len(self.elf_sha256) == self.SHA256_DIGEST_LEN
166              segment_data = (
167                  segment_data[0:patch_offset]
168                  + self.elf_sha256
169                  + segment_data[patch_offset + self.SHA256_DIGEST_LEN :]
170              )
171          return segment_data
172      def save_segment(self, f, segment, checksum=None):
173          segment_data = self.maybe_patch_segment_data(f, segment.data)
174          f.write(struct.pack(&quot;&lt;II&quot;, segment.addr, len(segment_data)))
175          f.write(segment_data)
176          if checksum is not None:
177              return ESPLoader.checksum(segment_data, checksum)
178      def read_checksum(self, f):
179          align_file_position(f, 16)
180          return ord(f.read(1))
181      def calculate_checksum(self):
182          checksum = ESPLoader.ESP_CHECKSUM_MAGIC
183          for seg in self.segments:
184              if seg.include_in_checksum:
185                  checksum = ESPLoader.checksum(seg.data, checksum)
186          return checksum
187      def append_checksum(self, f, checksum):
188          align_file_position(f, 16)
189          f.write(struct.pack(b&quot;B&quot;, checksum))
190      def write_common_header(self, f, segments):
191          f.write(
192              struct.pack(
193                  &quot;&lt;BBBBI&quot;,
194                  ESPLoader.ESP_IMAGE_MAGIC,
195                  len(segments),
196                  self.flash_mode,
197                  self.flash_size_freq,
198                  self.entrypoint,
199              )
200          )
201      def is_irom_addr(self, addr):
202          return ESP8266ROM.IROM_MAP_START &lt;= addr &lt; ESP8266ROM.IROM_MAP_END
203      def get_irom_segment(self):
204          irom_segments = [s for s in self.segments if self.is_irom_addr(s.addr)]
205          if len(irom_segments) &gt; 0:
206              if len(irom_segments) != 1:
207                  raise FatalError(
208                      &quot;Found %d segments that could be irom0. Bad ELF file?&quot;
209                      % len(irom_segments)
210                  )
211              return irom_segments[0]
212          return None
213      def get_non_irom_segments(self):
214          irom_segment = self.get_irom_segment()
215          return [s for s in self.segments if s != irom_segment]
216      def merge_adjacent_segments(self):
217          if not self.segments:
218              return  # nothing to merge
219          segments = []
220          for i in range(len(self.segments) - 1, 0, -1):
221              elem = self.segments[i - 1]
222              next_elem = self.segments[i]
223              if all(
224                  (
225                      elem.get_memory_type(self) == next_elem.get_memory_type(self),
226                      elem.include_in_checksum == next_elem.include_in_checksum,
227                      next_elem.addr == elem.addr + len(elem.data),
228                  )
229              ):
230                  elem.data += next_elem.data
231              else:
232                  segments.insert(0, next_elem)
233          segments.insert(0, self.segments[0])
234          self.segments = segments
235      def set_mmu_page_size(self, size):
236          print(
237              &quot;WARNING: Changing MMU page size is not supported on {}! &quot;
238              &quot;Defaulting to 64KB.&quot;.format(self.ROM_LOADER.CHIP_NAME)
239          )
240  class ESP8266ROMFirmwareImage(BaseFirmwareImage):
241      ROM_LOADER = ESP8266ROM
242      def __init__(self, load_file=None):
243          super(ESP8266ROMFirmwareImage, self).__init__()
244          self.flash_mode = 0
245          self.flash_size_freq = 0
246          self.version = 1
247          if load_file is not None:
248              segments = self.load_common_header(load_file, ESPLoader.ESP_IMAGE_MAGIC)
249              for _ in range(segments):
250                  self.load_segment(load_file)
251              self.checksum = self.read_checksum(load_file)
252              self.verify()
253      def default_output_name(self, input_file):
254          return input_file + &quot;-&quot;
255      def save(self, basename):
256          irom_segment = self.get_irom_segment()
257          if irom_segment is not None:
258              with open(
259                  &quot;%s0x%05x.bin&quot;
260                  % (basename, irom_segment.addr - ESP8266ROM.IROM_MAP_START),
261                  &quot;wb&quot;,
262              ) as f:
263                  f.write(irom_segment.data)
264          normal_segments = self.get_non_irom_segments()
265          with open(&quot;%s0x00000.bin&quot; % basename, &quot;wb&quot;) as f:
266              self.write_common_header(f, normal_segments)
267              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
268              for segment in normal_segments:
269                  checksum = self.save_segment(f, segment, checksum)
270              self.append_checksum(f, checksum)
271  ESP8266ROM.BOOTLOADER_IMAGE = ESP8266ROMFirmwareImage
272  class ESP8266V2FirmwareImage(BaseFirmwareImage):
273      ROM_LOADER = ESP8266ROM
274      IMAGE_V2_MAGIC = 0xEA
275      IMAGE_V2_SEGMENT = 4
276      def __init__(self, load_file=None):
277          super(ESP8266V2FirmwareImage, self).__init__()
278          self.version = 2
279          if load_file is not None:
280              segments = self.load_common_header(load_file, self.IMAGE_V2_MAGIC)
281              if segments != self.IMAGE_V2_SEGMENT:
282                  print(
283                      &#x27;Warning: V2 header has unexpected &quot;segment&quot; count %d (usually 4)&#x27;
284                      % segments
285                  )
286              irom_segment = self.load_segment(load_file, True)
287              irom_segment.addr = 0
288              irom_segment.include_in_checksum = False
289              first_flash_mode = self.flash_mode
290              first_flash_size_freq = self.flash_size_freq
291              first_entrypoint = self.entrypoint
292              segments = self.load_common_header(load_file, ESPLoader.ESP_IMAGE_MAGIC)
293              if first_flash_mode != self.flash_mode:
294                  print(
295                      &quot;WARNING: Flash mode value in first header (0x%02x) disagrees &quot;
296                      &quot;with second (0x%02x). Using second value.&quot;
297                      % (first_flash_mode, self.flash_mode)
298                  )
299              if first_flash_size_freq != self.flash_size_freq:
300                  print(
301                      &quot;WARNING: Flash size/freq value in first header (0x%02x) disagrees &quot;
302                      &quot;with second (0x%02x). Using second value.&quot;
303                      % (first_flash_size_freq, self.flash_size_freq)
304                  )
305              if first_entrypoint != self.entrypoint:
306                  print(
307                      &quot;WARNING: Entrypoint address in first header (0x%08x) disagrees &quot;
308                      &quot;with second header (0x%08x). Using second value.&quot;
309                      % (first_entrypoint, self.entrypoint)
310                  )
311              for _ in range(segments):
312                  self.load_segment(load_file)
313              self.checksum = self.read_checksum(load_file)
314              self.verify()
315      def default_output_name(self, input_file):
316          irom_segment = self.get_irom_segment()
317          if irom_segment is not None:
318              irom_offs = irom_segment.addr - ESP8266ROM.IROM_MAP_START
319          else:
320              irom_offs = 0
321          return &quot;%s-0x%05x.bin&quot; % (
322              os.path.splitext(input_file)[0],
323              irom_offs &amp; ~(ESPLoader.FLASH_SECTOR_SIZE - 1),
324          )
325      def save(self, filename):
326          with open(filename, &quot;wb&quot;) as f:
327              f.write(
328                  struct.pack(
329                      b&quot;&lt;BBBBI&quot;,
330                      self.IMAGE_V2_MAGIC,
331                      self.IMAGE_V2_SEGMENT,
332                      self.flash_mode,
333                      self.flash_size_freq,
334                      self.entrypoint,
335                  )
336              )
337              irom_segment = self.get_irom_segment()
338              if irom_segment is not None:
339                  irom_segment = irom_segment.copy_with_new_addr(0)
340                  irom_segment.pad_to_alignment(
341                      16
342                  )  # irom_segment must end on a 16 byte boundary
343                  self.save_segment(f, irom_segment)
344              normal_segments = self.get_non_irom_segments()
345              self.write_common_header(f, normal_segments)
346              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
347              for segment in normal_segments:
348                  checksum = self.save_segment(f, segment, checksum)
349              self.append_checksum(f, checksum)
350          with open(filename, &quot;rb&quot;) as f:
351              crc = esp8266_crc32(f.read())
352          with open(filename, &quot;ab&quot;) as f:
353              f.write(struct.pack(b&quot;&lt;I&quot;, crc))
354  def esp8266_crc32(data):
355      crc = binascii.crc32(data, 0) &amp; 0xFFFFFFFF
356      if crc &amp; 0x80000000:
357          return crc ^ 0xFFFFFFFF
358      else:
359          return crc + 1
360  class ESP32FirmwareImage(BaseFirmwareImage):
361      ROM_LOADER = ESP32ROM
362      WP_PIN_DISABLED = 0xEE
363      EXTENDED_HEADER_STRUCT_FMT = &quot;&lt;BBBBHBHH&quot; + (&quot;B&quot; * 4) + &quot;B&quot;
364      IROM_ALIGN = 65536
365      def __init__(self, load_file=None, append_digest=True):
366          super(ESP32FirmwareImage, self).__init__()
367          self.secure_pad = None
368          self.flash_mode = 0
369          self.flash_size_freq = 0
370          self.version = 1
371          self.wp_pin = self.WP_PIN_DISABLED
372          self.clk_drv = 0
373          self.q_drv = 0
374          self.d_drv = 0
375          self.cs_drv = 0
376          self.hd_drv = 0
377          self.wp_drv = 0
378          self.chip_id = 0
379          self.min_rev = 0
380          self.min_rev_full = 0
381          self.max_rev_full = 0
382          self.append_digest = append_digest
383          if load_file is not None:
384              start = load_file.tell()
385              segments = self.load_common_header(load_file, ESPLoader.ESP_IMAGE_MAGIC)
386              self.load_extended_header(load_file)
387              for _ in range(segments):
388                  self.load_segment(load_file)
389              self.checksum = self.read_checksum(load_file)
390              if self.append_digest:
391                  end = load_file.tell()
392                  self.stored_digest = load_file.read(32)
393                  load_file.seek(start)
394                  calc_digest = hashlib.sha256()
395                  calc_digest.update(load_file.read(end - start))
396                  self.calc_digest = calc_digest.digest()  # TODO: decide what to do here?
397              self.verify()
398      def is_flash_addr(self, addr):
399          return (
400              self.ROM_LOADER.IROM_MAP_START &lt;= addr &lt; self.ROM_LOADER.IROM_MAP_END
401          ) or (self.ROM_LOADER.DROM_MAP_START &lt;= addr &lt; self.ROM_LOADER.DROM_MAP_END)
402      def default_output_name(self, input_file):
403          return &quot;%s.bin&quot; % (os.path.splitext(input_file)[0])
404      def warn_if_unusual_segment(self, offset, size, is_irom_segment):
405          pass  # TODO: add warnings for wrong ESP32 segment offset/size combinations
406      def save(self, filename):
407          total_segments = 0
408          with io.BytesIO() as f:  # write file to memory first
409              self.write_common_header(f, self.segments)
410              self.save_extended_header(f)
411              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
412              flash_segments = [
413                  copy.deepcopy(s)
414                  for s in sorted(self.segments, key=lambda s: s.addr)
415                  if self.is_flash_addr(s.addr)
416              ]
417              ram_segments = [
418                  copy.deepcopy(s)
419                  for s in sorted(self.segments, key=lambda s: s.addr)
420                  if not self.is_flash_addr(s.addr)
421              ]
422              for segment in flash_segments:
423                  if segment.name == &quot;.flash.appdesc&quot;:
424                      flash_segments.remove(segment)
425                      flash_segments.insert(0, segment)
426                      break
427              for segment in ram_segments:
428                  if segment.name == &quot;.dram0.bootdesc&quot;:
429                      ram_segments.remove(segment)
430                      ram_segments.insert(0, segment)
431                      break
432              if len(flash_segments) &gt; 0:
433                  last_addr = flash_segments[0].addr
434                  for segment in flash_segments[1:]:
435                      if segment.addr // self.IROM_ALIGN == last_addr // self.IROM_ALIGN:
436                          raise FatalError(
437                              &quot;Segment loaded at 0x%08x lands in same 64KB flash mapping &quot;
438                              &quot;as segment loaded at 0x%08x. Can&#x27;t generate binary. &quot;
439                              &quot;Suggest changing linker script or ELF to merge sections.&quot;
440                              % (segment.addr, last_addr)
441                          )
442                      last_addr = segment.addr
443              def get_alignment_data_needed(segment):
444                  align_past = (segment.addr % self.IROM_ALIGN) - self.SEG_HEADER_LEN
445                  pad_len = (self.IROM_ALIGN - (f.tell() % self.IROM_ALIGN)) + align_past
446                  if pad_len == 0 or pad_len == self.IROM_ALIGN:
447                      return 0  # already aligned
448                  pad_len -= self.SEG_HEADER_LEN
449                  if pad_len &lt; 0:
450                      pad_len += self.IROM_ALIGN
451                  return pad_len
452              while len(flash_segments) &gt; 0:
453                  segment = flash_segments[0]
454                  pad_len = get_alignment_data_needed(segment)
455                  if pad_len &gt; 0:  # need to pad
456                      if len(ram_segments) &gt; 0 and pad_len &gt; self.SEG_HEADER_LEN:
457                          pad_segment = ram_segments[0].split_image(pad_len)
458                          if len(ram_segments[0].data) == 0:
459                              ram_segments.pop(0)
460                      else:
461                          pad_segment = ImageSegment(0, b&quot;\x00&quot; * pad_len, f.tell())
462                      checksum = self.save_segment(f, pad_segment, checksum)
463                      total_segments += 1
464                  else:
465                      assert (
466                          f.tell() + 8
467                      ) % self.IROM_ALIGN == segment.addr % self.IROM_ALIGN
468                      checksum = self.save_flash_segment(f, segment, checksum)
469                      flash_segments.pop(0)
470                      total_segments += 1
471              for segment in ram_segments:
472                  checksum = self.save_segment(f, segment, checksum)
473                  total_segments += 1
474              if self.secure_pad:
475                  if not self.append_digest:
476                      raise FatalError(
477                          &quot;secure_pad only applies if a SHA-256 digest &quot;
478                          &quot;is also appended to the image&quot;
479                      )
480                  align_past = (f.tell() + self.SEG_HEADER_LEN) % self.IROM_ALIGN
481                  checksum_space = 16
482                  if self.secure_pad == &quot;1&quot;:
483                      space_after_checksum = 32 + 4 + 64 + 12
484                  elif self.secure_pad == &quot;2&quot;:  # Secure Boot V2
485                      space_after_checksum = 32
486                  pad_len = (
487                      self.IROM_ALIGN - align_past - checksum_space - space_after_checksum
488                  ) % self.IROM_ALIGN
489                  pad_segment = ImageSegment(0, b&quot;\x00&quot; * pad_len, f.tell())
490                  checksum = self.save_segment(f, pad_segment, checksum)
491                  total_segments += 1
492              self.append_checksum(f, checksum)
493              image_length = f.tell()
494              if self.secure_pad:
495                  assert ((image_length + space_after_checksum) % self.IROM_ALIGN) == 0
496              f.seek(1)
497              f.write(bytes([total_segments]))
498              if self.append_digest:
499                  f.seek(0)
500                  digest = hashlib.sha256()
501                  digest.update(f.read(image_length))
502                  f.write(digest.digest())
503              if self.pad_to_size:
504                  image_length = f.tell()
505                  if image_length % self.pad_to_size != 0:
506                      pad_by = self.pad_to_size - (image_length % self.pad_to_size)
507                      f.write(b&quot;\xff&quot; * pad_by)
508              with open(filename, &quot;wb&quot;) as real_file:
509                  real_file.write(f.getvalue())
510      def save_flash_segment(self, f, segment, checksum=None):
511          segment_end_pos = f.tell() + len(segment.data) + self.SEG_HEADER_LEN
512          segment_len_remainder = segment_end_pos % self.IROM_ALIGN
513          if segment_len_remainder &lt; 0x24:
514              segment.data += b&quot;\x00&quot; * (0x24 - segment_len_remainder)
515          return self.save_segment(f, segment, checksum)
516      def load_extended_header(self, load_file):
517          def split_byte(n):
518              return (n &amp; 0x0F, (n &gt;&gt; 4) &amp; 0x0F)
519          fields = list(
520              struct.unpack(self.EXTENDED_HEADER_STRUCT_FMT, load_file.read(16))
521          )
522          self.wp_pin = fields[0]
523          self.clk_drv, self.q_drv = split_byte(fields[1])
524          self.d_drv, self.cs_drv = split_byte(fields[2])
525          self.hd_drv, self.wp_drv = split_byte(fields[3])
526          self.chip_id = fields[4]
527          if self.chip_id != self.ROM_LOADER.IMAGE_CHIP_ID:
528              print(
529                  (
530                      &quot;Unexpected chip id in image. Expected %d but value was %d. &quot;
531                      &quot;Is this image for a different chip model?&quot;
532                  )
533                  % (self.ROM_LOADER.IMAGE_CHIP_ID, self.chip_id)
534              )
535          self.min_rev = fields[5]
536          self.min_rev_full = fields[6]
537          self.max_rev_full = fields[7]
538          append_digest = fields[-1]  # last byte is append_digest
539          if append_digest in [0, 1]:
540              self.append_digest = append_digest == 1
541          else:
542              raise RuntimeError(
543                  &quot;Invalid value for append_digest field (0x%02x). Should be 0 or 1.&quot;,
544                  append_digest,
545              )
546      def save_extended_header(self, save_file):
547          def join_byte(ln, hn):
548              return (ln &amp; 0x0F) + ((hn &amp; 0x0F) &lt;&lt; 4)
549          append_digest = 1 if self.append_digest else 0
550          fields = [
551              self.wp_pin,
552              join_byte(self.clk_drv, self.q_drv),
553              join_byte(self.d_drv, self.cs_drv),
554              join_byte(self.hd_drv, self.wp_drv),
555              self.ROM_LOADER.IMAGE_CHIP_ID,
556              self.min_rev,
557              self.min_rev_full,
558              self.max_rev_full,
559          ]
560          fields += [0] * 4  # padding
561          fields += [append_digest]
562          packed = struct.pack(self.EXTENDED_HEADER_STRUCT_FMT, *fields)
563          save_file.write(packed)
564  class ESP8266V3FirmwareImage(ESP32FirmwareImage):
565      EXTENDED_HEADER_STRUCT_FMT = &quot;B&quot; * 16
566      def is_flash_addr(self, addr):
567          return addr &gt; ESP8266ROM.IROM_MAP_START
568      def save(self, filename):
569          total_segments = 0
570          with io.BytesIO() as f:  # write file to memory first
571              self.write_common_header(f, self.segments)
572              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
573              flash_segments = [
574                  copy.deepcopy(s)
575                  for s in sorted(self.segments, key=lambda s: s.addr)
576                  if self.is_flash_addr(s.addr) and len(s.data)
577              ]
578              ram_segments = [
579                  copy.deepcopy(s)
580                  for s in sorted(self.segments, key=lambda s: s.addr)
581                  if not self.is_flash_addr(s.addr) and len(s.data)
582              ]
583              if len(flash_segments) &gt; 0:
584                  last_addr = flash_segments[0].addr
585                  for segment in flash_segments[1:]:
586                      if segment.addr // self.IROM_ALIGN == last_addr // self.IROM_ALIGN:
587                          raise FatalError(
588                              &quot;Segment loaded at 0x%08x lands in same 64KB flash mapping &quot;
589                              &quot;as segment loaded at 0x%08x. Can&#x27;t generate binary. &quot;
590                              &quot;Suggest changing linker script or ELF to merge sections.&quot;
591                              % (segment.addr, last_addr)
592                          )
593                      last_addr = segment.addr
594              while len(flash_segments) &gt; 0:
595                  segment = flash_segments[0]
596                  if segment.name == &quot;.flash.rodata&quot;:
597                      segment.data = segment.data[8:]
598                  checksum = self.save_segment(f, segment, checksum)
599                  flash_segments.pop(0)
600                  total_segments += 1
601              for segment in ram_segments:
602                  checksum = self.save_segment(f, segment, checksum)
603                  total_segments += 1
604              self.append_checksum(f, checksum)
605              image_length = f.tell()
606              f.seek(1)
607              f.write(bytes([total_segments]))
608              if self.append_digest:
609                  f.seek(0)
610                  digest = hashlib.sha256()
611                  digest.update(f.read(image_length))
612                  f.write(digest.digest())
613              with open(filename, &quot;wb&quot;) as real_file:
614                  real_file.write(f.getvalue())
615      def load_extended_header(self, load_file):
616          def split_byte(n):
617              return (n &amp; 0x0F, (n &gt;&gt; 4) &amp; 0x0F)
618          fields = list(
619              struct.unpack(self.EXTENDED_HEADER_STRUCT_FMT, load_file.read(16))
620          )
621          self.wp_pin = fields[0]
622          self.clk_drv, self.q_drv = split_byte(fields[1])
623          self.d_drv, self.cs_drv = split_byte(fields[2])
624          self.hd_drv, self.wp_drv = split_byte(fields[3])
625          if fields[15] in [0, 1]:
626              self.append_digest = fields[15] == 1
627          else:
628              raise RuntimeError(
629                  &quot;Invalid value for append_digest field (0x%02x). Should be 0 or 1.&quot;,
630                  fields[15],
631              )
632          if any(f for f in fields[4:15] if f != 0):
633              print(
634                  &quot;Warning: some reserved header fields have non-zero values. &quot;
635                  &quot;This image may be from a newer esptool.py?&quot;
636              )
637  ESP32ROM.BOOTLOADER_IMAGE = ESP32FirmwareImage
638  class ESP32S2FirmwareImage(ESP32FirmwareImage):
639      ROM_LOADER = ESP32S2ROM
640  ESP32S2ROM.BOOTLOADER_IMAGE = ESP32S2FirmwareImage
641  class ESP32S3BETA2FirmwareImage(ESP32FirmwareImage):
642      ROM_LOADER = ESP32S3BETA2ROM
643  ESP32S3BETA2ROM.BOOTLOADER_IMAGE = ESP32S3BETA2FirmwareImage
644  class ESP32S3FirmwareImage(ESP32FirmwareImage):
645      ROM_LOADER = ESP32S3ROM
646  ESP32S3ROM.BOOTLOADER_IMAGE = ESP32S3FirmwareImage
647  class ESP32C3FirmwareImage(ESP32FirmwareImage):
648      ROM_LOADER = ESP32C3ROM
649  ESP32C3ROM.BOOTLOADER_IMAGE = ESP32C3FirmwareImage
650  class ESP32C6BETAFirmwareImage(ESP32FirmwareImage):
651      ROM_LOADER = ESP32C6BETAROM
652  ESP32C6BETAROM.BOOTLOADER_IMAGE = ESP32C6BETAFirmwareImage
653  class ESP32H2BETA1FirmwareImage(ESP32FirmwareImage):
654      ROM_LOADER = ESP32H2BETA1ROM
655  ESP32H2BETA1ROM.BOOTLOADER_IMAGE = ESP32H2BETA1FirmwareImage
656  class ESP32H2BETA2FirmwareImage(ESP32FirmwareImage):
657      ROM_LOADER = ESP32H2BETA2ROM
658  ESP32H2BETA2ROM.BOOTLOADER_IMAGE = ESP32H2BETA2FirmwareImage
659  class ESP32C2FirmwareImage(ESP32FirmwareImage):
660      ROM_LOADER = ESP32C2ROM
661      def set_mmu_page_size(self, size):
662          if size not in [16384, 32768, 65536]:
663              raise FatalError(
664                  &quot;{} bytes is not a valid ESP32-C2 page size, &quot;
665                  &quot;select from 64KB, 32KB, 16KB.&quot;.format(size)
666              )
667          self.IROM_ALIGN = size
668  ESP32C2ROM.BOOTLOADER_IMAGE = ESP32C2FirmwareImage
669  class ESP32C6FirmwareImage(ESP32FirmwareImage):
670      ROM_LOADER = ESP32C6ROM
671      def set_mmu_page_size(self, size):
672          if size not in [8192, 16384, 32768, 65536]:
673              raise FatalError(
674                  &quot;{} bytes is not a valid ESP32-C6 page size, &quot;
675                  &quot;select from 64KB, 32KB, 16KB, 8KB.&quot;.format(size)
676              )
677          self.IROM_ALIGN = size
678  ESP32C6ROM.BOOTLOADER_IMAGE = ESP32C6FirmwareImage
679  class ESP32H2FirmwareImage(ESP32C6FirmwareImage):
680      ROM_LOADER = ESP32H2ROM
681  ESP32H2ROM.BOOTLOADER_IMAGE = ESP32H2FirmwareImage
682  class ELFFile(object):
683      SEC_TYPE_PROGBITS = 0x01
684      SEC_TYPE_STRTAB = 0x03
685      SEC_TYPE_INITARRAY = 0x0E
686      SEC_TYPE_FINIARRAY = 0x0F
687      PROG_SEC_TYPES = (SEC_TYPE_PROGBITS, SEC_TYPE_INITARRAY, SEC_TYPE_FINIARRAY)
688      LEN_SEC_HEADER = 0x28
689      SEG_TYPE_LOAD = 0x01
690      LEN_SEG_HEADER = 0x20
691      def __init__(self, name):
692          self.name = name
693          with open(self.name, &quot;rb&quot;) as f:
694              self._read_elf_file(f)
695      def get_section(self, section_name):
696          for s in self.sections:
697              if s.name == section_name:
698                  return s
699          raise ValueError(&quot;No section %s in ELF file&quot; % section_name)
700      def _read_elf_file(self, f):
701          LEN_FILE_HEADER = 0x34
702          try:
703              (
704                  ident,
705                  _type,
706                  machine,
707                  _version,
708                  self.entrypoint,
709                  _phoff,
710                  shoff,
711                  _flags,
712                  _ehsize,
713                  _phentsize,
714                  _phnum,
715                  shentsize,
716                  shnum,
717                  shstrndx,
718              ) = struct.unpack(&quot;&lt;16sHHLLLLLHHHHHH&quot;, f.read(LEN_FILE_HEADER))
719          except struct.error as e:
720              raise FatalError(
721                  &quot;Failed to read a valid ELF header from %s: %s&quot; % (self.name, e)
722              )
723          if byte(ident, 0) != 0x7F or ident[1:4] != b&quot;ELF&quot;:
724              raise FatalError(&quot;%s has invalid ELF magic header&quot; % self.name)
725          if machine not in [0x5E, 0xF3]:
726              raise FatalError(
727                  &quot;%s does not appear to be an Xtensa or an RISCV ELF file. &quot;
728                  &quot;e_machine=%04x&quot; % (self.name, machine)
729              )
730          if shentsize != self.LEN_SEC_HEADER:
731              raise FatalError(
732                  &quot;%s has unexpected section header entry size 0x%x (not 0x%x)&quot;
733                  % (self.name, shentsize, self.LEN_SEC_HEADER)
734              )
735          if shnum == 0:
736              raise FatalError(&quot;%s has 0 section headers&quot; % (self.name))
737          self._read_sections(f, shoff, shnum, shstrndx)
738          self._read_segments(f, _phoff, _phnum, shstrndx)
739      def _read_sections(self, f, section_header_offs, section_header_count, shstrndx):
740          f.seek(section_header_offs)
741          len_bytes = section_header_count * self.LEN_SEC_HEADER
742          section_header = f.read(len_bytes)
743          if len(section_header) == 0:
744              raise FatalError(
745                  &quot;No section header found at offset %04x in ELF file.&quot;
746                  % section_header_offs
747              )
748          if len(section_header) != (len_bytes):
749              raise FatalError(
750                  &quot;Only read 0x%x bytes from section header (expected 0x%x.) &quot;
751                  &quot;Truncated ELF file?&quot; % (len(section_header), len_bytes)
752              )
753          section_header_offsets = range(0, len(section_header), self.LEN_SEC_HEADER)
754          def read_section_header(offs):
755              name_offs, sec_type, _flags, lma, sec_offs, size = struct.unpack_from(
756                  &quot;&lt;LLLLLL&quot;, section_header[offs:]
757              )
758              return (name_offs, sec_type, lma, size, sec_offs)
759          all_sections = [read_section_header(offs) for offs in section_header_offsets]
760          prog_sections = [s for s in all_sections if s[1] in ELFFile.PROG_SEC_TYPES]
761          if not (shstrndx * self.LEN_SEC_HEADER) in section_header_offsets:
762              raise FatalError(&quot;ELF file has no STRTAB section at shstrndx %d&quot; % shstrndx)
763          _, sec_type, _, sec_size, sec_offs = read_section_header(
764              shstrndx * self.LEN_SEC_HEADER
765          )
766          if sec_type != ELFFile.SEC_TYPE_STRTAB:
767              print(
768                  &quot;WARNING: ELF file has incorrect STRTAB section type 0x%02x&quot; % sec_type
769              )
770          f.seek(sec_offs)
771          string_table = f.read(sec_size)
772          def lookup_string(offs):
773              raw = string_table[offs:]
774              return raw[: raw.index(b&quot;\x00&quot;)]
775          def read_data(offs, size):
776              f.seek(offs)
777              return f.read(size)
778          prog_sections = [
779              ELFSection(lookup_string(n_offs), lma, read_data(offs, size))
780              for (n_offs, _type, lma, size, offs) in prog_sections
781              if lma != 0 and size &gt; 0
782          ]
783          self.sections = prog_sections
784      def _read_segments(self, f, segment_header_offs, segment_header_count, shstrndx):
785          f.seek(segment_header_offs)
786          len_bytes = segment_header_count * self.LEN_SEG_HEADER
787          segment_header = f.read(len_bytes)
788          if len(segment_header) == 0:
789              raise FatalError(
790                  &quot;No segment header found at offset %04x in ELF file.&quot;
791                  % segment_header_offs
792              )
793          if len(segment_header) != (len_bytes):
794              raise FatalError(
795                  &quot;Only read 0x%x bytes from segment header (expected 0x%x.) &quot;
796                  &quot;Truncated ELF file?&quot; % (len(segment_header), len_bytes)
797              )
798          segment_header_offsets = range(0, len(segment_header), self.LEN_SEG_HEADER)
799          def read_segment_header(offs):
800              (
801                  seg_type,
802                  seg_offs,
803                  _vaddr,
804                  lma,
805                  size,
806                  _memsize,
807                  _flags,
808                  _align,
809              ) = struct.unpack_from(&quot;&lt;LLLLLLLL&quot;, segment_header[offs:])
810              return (seg_type, lma, size, seg_offs)
811          all_segments = [read_segment_header(offs) for offs in segment_header_offsets]
812          prog_segments = [s for s in all_segments if s[0] == ELFFile.SEG_TYPE_LOAD]
813          def read_data(offs, size):
814              f.seek(offs)
815              return f.read(size)
816          prog_segments = [
817              ELFSection(b&quot;PHDR&quot;, lma, read_data(offs, size))
818              for (_type, lma, size, offs) in prog_segments
819              if lma != 0 and size &gt; 0
820          ]
821          self.segments = prog_segments
822      def sha256(self):
823          sha256 = hashlib.sha256()
<span onclick='openModal()' class='match'>824          with open(self.name, &quot;rb&quot;) as f:
825              sha256.update(f.read())
</span>826          return sha256.digest()
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-operations_27.py</h3>
            <pre><code>1  import argparse
2  import os  # noqa: F401. It is used in IDF scripts
3  import traceback
4  import espsecure
5  import esptool
6  from . import fields
7  from .. import util
8  from ..base_operations import (
9      add_common_commands,
10      add_force_write_always,
11      add_show_sensitive_info_option,
12      burn_bit,
13      burn_block_data,
14      burn_efuse,
15      check_error,
16      dump,
17      read_protect_efuse,
18      summary,
19      write_protect_efuse,
20  )
21  def protect_options(p):
22      p.add_argument(
23          &quot;--no-write-protect&quot;,
24          help=&quot;Disable write-protecting of the key. The key remains writable. &quot;
25          &quot;(The keys use the RS coding scheme that does not support post-write &quot;
26          &quot;data changes. Forced write can damage RS encoding bits.) &quot;
27          &quot;The write-protecting of keypurposes does not depend on the option, &quot;
28          &quot;it will be set anyway.&quot;,
29          action=&quot;store_true&quot;,
30      )
31      p.add_argument(
32          &quot;--no-read-protect&quot;,
33          help=&quot;Disable read-protecting of the key. The key remains readable software.&quot;
34          &quot;The key with keypurpose[USER, RESERVED and *_DIGEST] will remain &quot;
35          &quot;readable anyway. For the rest keypurposes the read-protection will be &quot;
36          &quot;defined the option (Read-protect by default).&quot;,
37          action=&quot;store_true&quot;,
38      )
39  def add_commands(subparsers, efuses):
40      add_common_commands(subparsers, efuses)
41      burn_key = subparsers.add_parser(
42          &quot;burn_key&quot;, help=&quot;Burn the key block with the specified name&quot;
43      )
44      protect_options(burn_key)
45      add_force_write_always(burn_key)
46      add_show_sensitive_info_option(burn_key)
47      burn_key.add_argument(
48          &quot;block&quot;,
49          help=&quot;Key block to burn&quot;,
50          action=&quot;append&quot;,
51          choices=efuses.BLOCKS_FOR_KEYS,
52      )
53      burn_key.add_argument(
54          &quot;keyfile&quot;,
55          help=&quot;File containing 256 bits of binary key data&quot;,
56          action=&quot;append&quot;,
57          type=argparse.FileType(&quot;rb&quot;),
58      )
59      burn_key.add_argument(
60          &quot;keypurpose&quot;,
61          help=&quot;Purpose to set.&quot;,
62          action=&quot;append&quot;,
63          choices=fields.EfuseKeyPurposeField.KEY_PURPOSES_NAME,
64      )
65      for _ in efuses.BLOCKS_FOR_KEYS:
66          burn_key.add_argument(
67              &quot;block&quot;,
68              help=&quot;Key block to burn&quot;,
69              nargs=&quot;?&quot;,
70              action=&quot;append&quot;,
71              metavar=&quot;BLOCK&quot;,
72              choices=efuses.BLOCKS_FOR_KEYS,
73          )
74          burn_key.add_argument(
75              &quot;keyfile&quot;,
76              help=&quot;File containing 256 bits of binary key data&quot;,
77              nargs=&quot;?&quot;,
78              action=&quot;append&quot;,
79              metavar=&quot;KEYFILE&quot;,
80              type=argparse.FileType(&quot;rb&quot;),
81          )
82          burn_key.add_argument(
83              &quot;keypurpose&quot;,
84              help=&quot;Purpose to set.&quot;,
85              nargs=&quot;?&quot;,
86              action=&quot;append&quot;,
87              metavar=&quot;KEYPURPOSE&quot;,
88              choices=fields.EfuseKeyPurposeField.KEY_PURPOSES_NAME,
89          )
90      burn_key_digest = subparsers.add_parser(
91          &quot;burn_key_digest&quot;,
92          help=&quot;Parse a RSA public key and burn the digest to key efuse block&quot;,
93      )
94      protect_options(burn_key_digest)
95      add_force_write_always(burn_key_digest)
96      add_show_sensitive_info_option(burn_key_digest)
97      burn_key_digest.add_argument(
98          &quot;block&quot;,
99          help=&quot;Key block to burn&quot;,
100          action=&quot;append&quot;,
101          choices=efuses.BLOCKS_FOR_KEYS,
102      )
103      burn_key_digest.add_argument(
104          &quot;keyfile&quot;,
105          help=&quot;Key file to digest (PEM format)&quot;,
106          action=&quot;append&quot;,
107          type=argparse.FileType(&quot;rb&quot;),
108      )
109      burn_key_digest.add_argument(
110          &quot;keypurpose&quot;,
111          help=&quot;Purpose to set.&quot;,
112          action=&quot;append&quot;,
113          choices=fields.EfuseKeyPurposeField.DIGEST_KEY_PURPOSES,
114      )
115      for _ in efuses.BLOCKS_FOR_KEYS:
116          burn_key_digest.add_argument(
117              &quot;block&quot;,
118              help=&quot;Key block to burn&quot;,
119              nargs=&quot;?&quot;,
120              action=&quot;append&quot;,
121              metavar=&quot;BLOCK&quot;,
122              choices=efuses.BLOCKS_FOR_KEYS,
123          )
124          burn_key_digest.add_argument(
125              &quot;keyfile&quot;,
126              help=&quot;Key file to digest (PEM format)&quot;,
127              nargs=&quot;?&quot;,
128              action=&quot;append&quot;,
129              metavar=&quot;KEYFILE&quot;,
130              type=argparse.FileType(&quot;rb&quot;),
131          )
132          burn_key_digest.add_argument(
133              &quot;keypurpose&quot;,
134              help=&quot;Purpose to set.&quot;,
135              nargs=&quot;?&quot;,
136              action=&quot;append&quot;,
137              metavar=&quot;KEYPURPOSE&quot;,
138              choices=fields.EfuseKeyPurposeField.DIGEST_KEY_PURPOSES,
139          )
140      p = subparsers.add_parser(
141          &quot;set_flash_voltage&quot;,
142          help=&quot;Permanently set the internal flash voltage regulator &quot;
143          &quot;to either 1.8V, 3.3V or OFF. This means GPIO45 can be high or low &quot;
144          &quot;at reset without changing the flash voltage.&quot;,
145      )
146      p.add_argument(&quot;voltage&quot;, help=&quot;Voltage selection&quot;, choices=[&quot;1.8V&quot;, &quot;3.3V&quot;, &quot;OFF&quot;])
147      p = subparsers.add_parser(
148          &quot;burn_custom_mac&quot;, help=&quot;Burn a 48-bit Custom MAC Address to EFUSE BLOCK3.&quot;
149      )
150      p.add_argument(
151          &quot;mac&quot;,
152          help=&quot;Custom MAC Address to burn given in hexadecimal format with bytes &quot;
153          &quot;separated by colons (e.g. AA:CD:EF:01:02:03).&quot;,
154          type=fields.base_fields.CheckArgValue(efuses, &quot;CUSTOM_MAC&quot;),
155      )
156      add_force_write_always(p)
157      p = subparsers.add_parser(&quot;get_custom_mac&quot;, help=&quot;Prints the Custom MAC Address.&quot;)
158  def burn_custom_mac(esp, efuses, args):
159      efuses[&quot;CUSTOM_MAC&quot;].save(args.mac)
160      if not efuses.burn_all(check_batch_mode=True):
161          return
162      get_custom_mac(esp, efuses, args)
163      print(&quot;Successful&quot;)
164  def get_custom_mac(esp, efuses, args):
165      print(&quot;Custom MAC Address: {}&quot;.format(efuses[&quot;CUSTOM_MAC&quot;].get()))
166  def set_flash_voltage(esp, efuses, args):
167      raise esptool.FatalError(&quot;set_flash_voltage is not supported!&quot;)
168  def adc_info(esp, efuses, args):
169      print(&quot;&quot;)
170      if efuses[&quot;BLK_VERSION_MAJOR&quot;].get() == 1:
171          print(&quot;Temperature Sensor Calibration = {}C&quot;.format(efuses[&quot;TEMP_SENSOR_CAL&quot;].get()))
172          print(&quot;&quot;)
173          print(&quot;ADC1 readings stored in efuse BLOCK2:&quot;)
174          print(&quot;    MODE0 D1 reading  (250mV):  {}&quot;.format(efuses[&quot;ADC1_MODE0_D1&quot;].get()))
175          print(&quot;    MODE0 D2 reading  (600mV):  {}&quot;.format(efuses[&quot;ADC1_MODE0_D2&quot;].get()))
176          print(&quot;    MODE1 D1 reading  (250mV):  {}&quot;.format(efuses[&quot;ADC1_MODE1_D1&quot;].get()))
177          print(&quot;    MODE1 D2 reading  (800mV):  {}&quot;.format(efuses[&quot;ADC1_MODE1_D2&quot;].get()))
178          print(&quot;    MODE2 D1 reading  (250mV):  {}&quot;.format(efuses[&quot;ADC1_MODE2_D1&quot;].get()))
179          print(&quot;    MODE2 D2 reading  (1000mV): {}&quot;.format(efuses[&quot;ADC1_MODE2_D2&quot;].get()))
180          print(&quot;    MODE3 D1 reading  (250mV):  {}&quot;.format(efuses[&quot;ADC1_MODE3_D1&quot;].get()))
181          print(&quot;    MODE3 D2 reading  (2000mV): {}&quot;.format(efuses[&quot;ADC1_MODE3_D2&quot;].get()))
182          print(&quot;&quot;)
183          print(&quot;ADC2 readings stored in efuse BLOCK2:&quot;)
184          print(&quot;    MODE0 D1 reading  (250mV):  {}&quot;.format(efuses[&quot;ADC2_MODE0_D1&quot;].get()))
185          print(&quot;    MODE0 D2 reading  (600mV):  {}&quot;.format(efuses[&quot;ADC2_MODE0_D2&quot;].get()))
186          print(&quot;    MODE1 D1 reading  (250mV):  {}&quot;.format(efuses[&quot;ADC2_MODE1_D1&quot;].get()))
187          print(&quot;    MODE1 D2 reading  (800mV):  {}&quot;.format(efuses[&quot;ADC2_MODE1_D2&quot;].get()))
188          print(&quot;    MODE2 D1 reading  (250mV):  {}&quot;.format(efuses[&quot;ADC2_MODE2_D1&quot;].get()))
189          print(&quot;    MODE2 D2 reading  (1000mV): {}&quot;.format(efuses[&quot;ADC2_MODE2_D2&quot;].get()))
190          print(&quot;    MODE3 D1 reading  (250mV):  {}&quot;.format(efuses[&quot;ADC2_MODE3_D1&quot;].get()))
191          print(&quot;    MODE3 D2 reading  (2000mV): {}&quot;.format(efuses[&quot;ADC2_MODE3_D2&quot;].get()))
192      else:
193          print(&quot;BLK_VERSION_MAJOR = {}&quot;.format(efuses[&quot;BLK_VERSION_MAJOR&quot;].get_meaning()))
194  def burn_key(esp, efuses, args, digest=None):
195      if digest is None:
196          datafile_list = args.keyfile[
197              0 : len([name for name in args.keyfile if name is not None]) :
198          ]
199      else:
200          datafile_list = digest[0 : len([name for name in digest if name is not None]) :]
201      efuses.force_write_always = args.force_write_always
202      block_name_list = args.block[
203          0 : len([name for name in args.block if name is not None]) :
204      ]
205      keypurpose_list = args.keypurpose[
206          0 : len([name for name in args.keypurpose if name is not None]) :
207      ]
208      util.check_duplicate_name_in_list(block_name_list)
209      if len(block_name_list) != len(datafile_list) or len(block_name_list) != len(
210          keypurpose_list
211      ):
212          raise esptool.FatalError(
213              &quot;The number of blocks (%d), datafile (%d) and keypurpose (%d) &quot;
214              &quot;should be the same.&quot;
215              % (len(block_name_list), len(datafile_list), len(keypurpose_list))
216          )
217      print(&quot;Burn keys to blocks:&quot;)
218      for block_name, datafile, keypurpose in zip(
219          block_name_list, datafile_list, keypurpose_list
220      ):
221          efuse = None
222          for block in efuses.blocks:
223              if block_name == block.name or block_name in block.alias:
224                  efuse = efuses[block.name]
225          if efuse is None:
226              raise esptool.FatalError(&quot;Unknown block name - %s&quot; % (block_name))
227          num_bytes = efuse.bit_len // 8
228          block_num = efuses.get_index_block_by_name(block_name)
229          block = efuses.blocks[block_num]
230          if digest is None:
231              data = datafile.read()
232          else:
233              data = datafile
234          print(&quot; - %s&quot; % (efuse.name), end=&quot; &quot;)
235          revers_msg = None
236          if efuses[block.key_purpose_name].need_reverse(keypurpose):
237              revers_msg = &quot;\tReversing byte order for AES-XTS hardware peripheral&quot;
238              data = data[::-1]
239          print(
240              &quot;-&gt; [{}]&quot;.format(
241                  util.hexify(data, &quot; &quot;)
242                  if args.show_sensitive_info
243                  else &quot; &quot;.join([&quot;??&quot;] * len(data))
244              )
245          )
246          if revers_msg:
247              print(revers_msg)
248          if len(data) != num_bytes:
249              raise esptool.FatalError(
250                  &quot;Incorrect key file size %d. Key file must be %d bytes (%d bits) &quot;
251                  &quot;of raw binary key data.&quot; % (len(data), num_bytes, num_bytes * 8)
252              )
253          if efuses[block.key_purpose_name].need_rd_protect(keypurpose):
254              read_protect = False if args.no_read_protect else True
255          else:
256              read_protect = False
257          write_protect = not args.no_write_protect
258          efuse.save(data)
259          disable_wr_protect_key_purpose = False
260          if efuses[block.key_purpose_name].get() != keypurpose:
261              if efuses[block.key_purpose_name].is_writeable():
262                  print(
263                      &quot;\t&#x27;%s&#x27;: &#x27;%s&#x27; -&gt; &#x27;%s&#x27;.&quot;
264                      % (
265                          block.key_purpose_name,
266                          efuses[block.key_purpose_name].get(),
267                          keypurpose,
268                      )
269                  )
270                  efuses[block.key_purpose_name].save(keypurpose)
271                  disable_wr_protect_key_purpose = True
272              else:
273                  raise esptool.FatalError(
274                      &quot;It is not possible to change &#x27;%s&#x27; to &#x27;%s&#x27; because write &quot;
275                      &quot;protection bit is set.&quot; % (block.key_purpose_name, keypurpose)
276                  )
277          else:
278              print(&quot;\t&#x27;%s&#x27; is already &#x27;%s&#x27;.&quot; % (block.key_purpose_name, keypurpose))
279              if efuses[block.key_purpose_name].is_writeable():
280                  disable_wr_protect_key_purpose = True
281          if disable_wr_protect_key_purpose:
282              print(&quot;\tDisabling write to &#x27;%s&#x27;.&quot; % block.key_purpose_name)
283              efuses[block.key_purpose_name].disable_write()
284          if read_protect:
285              print(&quot;\tDisabling read to key block&quot;)
286              efuse.disable_read()
287          if write_protect:
288              print(&quot;\tDisabling write to key block&quot;)
289              efuse.disable_write()
290          print(&quot;&quot;)
291      if not write_protect:
292          print(&quot;Keys will remain writeable (due to --no-write-protect)&quot;)
293      if args.no_read_protect:
294          print(&quot;Keys will remain readable (due to --no-read-protect)&quot;)
295      if not efuses.burn_all(check_batch_mode=True):
296          return
297      print(&quot;Successful&quot;)
298  def burn_key_digest(esp, efuses, args):
299      digest_list = []
300      datafile_list = args.keyfile[
301          0 : len([name for name in args.keyfile if name is not None]) :
302      ]
303      block_list = args.block[
304          0 : len([block for block in args.block if block is not None]) :
305      ]
306      for block_name, datafile in zip(block_list, datafile_list):
307          efuse = None
308          for block in efuses.blocks:
309              if block_name == block.name or block_name in block.alias:
310                  efuse = efuses[block.name]
311          if efuse is None:
312              raise esptool.FatalError(&quot;Unknown block name - %s&quot; % (block_name))
313          num_bytes = efuse.bit_len // 8
314          digest = espsecure._digest_sbv2_public_key(datafile)
315          if len(digest) != num_bytes:
316              raise esptool.FatalError(
317                  &quot;Incorrect digest size %d. Digest must be %d bytes (%d bits) of raw &quot;
318                  &quot;binary key data.&quot; % (len(digest), num_bytes, num_bytes * 8)
319              )
320          digest_list.append(digest)
321      burn_key(esp, efuses, args, digest=digest_list)
322  def espefuse(esp, efuses, args, command):
323      parser = argparse.ArgumentParser()
324      subparsers = parser.add_subparsers(dest=&quot;operation&quot;)
325      add_commands(subparsers, efuses)
326      try:
327          cmd_line_args = parser.parse_args(command.split())
328      except SystemExit:
329          traceback.print_stack()
330          raise esptool.FatalError(&#x27;&quot;{}&quot; - incorrect command&#x27;.format(command))
331      if cmd_line_args.operation == &quot;execute_scripts&quot;:
332          configfiles = cmd_line_args.configfiles
333          index = cmd_line_args.index
334      vars(cmd_line_args).update(vars(args))
335      if cmd_line_args.operation == &quot;execute_scripts&quot;:
336          cmd_line_args.configfiles = configfiles
337          cmd_line_args.index = index
338      if cmd_line_args.operation is None:
339          parser.print_help()
340          parser.exit(1)
341      operation_func = globals()[cmd_line_args.operation]
342      operation_func(esp, efuses, cmd_line_args)
343  def execute_scripts(esp, efuses, args):
344      efuses.batch_mode_cnt += 1
345      del args.operation
346      scripts = args.scripts
347      del args.scripts
348      for file in scripts:
<span onclick='openModal()' class='match'>349          with open(file.name, &quot;r&quot;) as file:
350              exec(compile(file.read(), file.name, &quot;exec&quot;))
</span>351      if args.debug:
352          for block in efuses.blocks:
353              data = block.get_bitstring(from_read=False)
354              block.print_block(data, &quot;regs_for_burn&quot;, args.debug)
355      efuses.batch_mode_cnt -= 1
356      if not efuses.burn_all(check_batch_mode=True):
357          return
358      print(&quot;Successful&quot;)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-bin_image.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-operations_27.py</div>
                </div>
                <div class="column column_space"><pre><code>824          with open(self.name, &quot;rb&quot;) as f:
825              sha256.update(f.read())
</pre></code></div>
                <div class="column column_space"><pre><code>349          with open(file.name, &quot;r&quot;) as file:
350              exec(compile(file.read(), file.name, &quot;exec&quot;))
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    