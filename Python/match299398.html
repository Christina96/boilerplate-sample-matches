<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for version.py &amp; gitfs_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for version.py &amp; gitfs_1.py
      </h3>
<h1 align="center">
        0.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>version.py (0.7707129%)<th>gitfs_1.py (0.26472536%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(679-688)<td><a href="#" name="0">(1355-1362)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>version.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import operator
2 import platform
3 import re
4 import sys
5 from collections import namedtuple
6 from functools import total_ordering
7 MAX_SIZE = sys.maxsize
8 VERSION_LIMIT = MAX_SIZE - 200
9 @total_ordering
10 class SaltVersion(namedtuple("SaltVersion", "name, info, released")):
11     __slots__ = ()
12     def __new__(cls, name, info, released=False):
13         if isinstance(info, int):
14             info = (info,)
15         return super().__new__(cls, name, info, released)
16     def __eq__(self, other):
17         return self.info == other.info
18     def __gt__(self, other):
19         return self.info &gt; other.info
20 class SaltVersionsInfo(type):
21     _sorted_versions = ()
22     _current_release = None
23     _previous_release = None
24     _next_release = None
25     HYDROGEN      = SaltVersion("Hydrogen"     , info=(2014, 1),  released=True)
26     HELIUM        = SaltVersion("Helium"       , info=(2014, 7),  released=True)
27     LITHIUM       = SaltVersion("Lithium"      , info=(2015, 5),  released=True)
28     BERYLLIUM     = SaltVersion("Beryllium"    , info=(2015, 8),  released=True)
29     BORON         = SaltVersion("Boron"        , info=(2016, 3),  released=True)
30     CARBON        = SaltVersion("Carbon"       , info=(2016, 11), released=True)
31     NITROGEN      = SaltVersion("Nitrogen"     , info=(2017, 7),  released=True)
32     OXYGEN        = SaltVersion("Oxygen"       , info=(2018, 3),  released=True)
33     FLUORINE      = SaltVersion("Fluorine"     , info=(2019, 2),  released=True)
34     NEON          = SaltVersion("Neon"         , info=3000,       released=True)
35     SODIUM        = SaltVersion("Sodium"       , info=3001,       released=True)
36     MAGNESIUM     = SaltVersion("Magnesium"    , info=3002,       released=True)
37     ALUMINIUM     = SaltVersion("Aluminium"    , info=3003,       released=True)
38     SILICON       = SaltVersion("Silicon"      , info=3004,       released=True)
39     PHOSPHORUS    = SaltVersion("Phosphorus"   , info=3005)
40     SULFUR        = SaltVersion("Sulfur"       , info=3006)
41     CHLORINE      = SaltVersion("Chlorine"     , info=3007)
42     ARGON         = SaltVersion("Argon"        , info=3008)
43     POTASSIUM     = SaltVersion("Potassium"    , info=3009)
44     CALCIUM       = SaltVersion("Calcium"      , info=3010)
45     SCANDIUM      = SaltVersion("Scandium"     , info=3011)
46     TITANIUM      = SaltVersion("Titanium"     , info=3012)
47     VANADIUM      = SaltVersion("Vanadium"     , info=3013)
48     CHROMIUM      = SaltVersion("Chromium"     , info=3014)
49     MANGANESE     = SaltVersion("Manganese"    , info=3015)
50     IRON          = SaltVersion("Iron"         , info=3016)
51     COBALT        = SaltVersion("Cobalt"       , info=3017)
52     NICKEL        = SaltVersion("Nickel"       , info=3018)
53     COPPER        = SaltVersion("Copper"       , info=3019)
54     ZINC          = SaltVersion("Zinc"         , info=3020)
55     GALLIUM       = SaltVersion("Gallium"      , info=3021)
56     GERMANIUM     = SaltVersion("Germanium"    , info=3022)
57     ARSENIC       = SaltVersion("Arsenic"      , info=3023)
58     SELENIUM      = SaltVersion("Selenium"     , info=3024)
59     BROMINE       = SaltVersion("Bromine"      , info=3025)
60     KRYPTON       = SaltVersion("Krypton"      , info=3026)
61     RUBIDIUM      = SaltVersion("Rubidium"     , info=3027)
62     STRONTIUM     = SaltVersion("Strontium"    , info=3028)
63     YTTRIUM       = SaltVersion("Yttrium"      , info=3029)
64     ZIRCONIUM     = SaltVersion("Zirconium"    , info=3030)
65     NIOBIUM       = SaltVersion("Niobium"      , info=3031)
66     MOLYBDENUM    = SaltVersion("Molybdenum"   , info=3032)
67     TECHNETIUM    = SaltVersion("Technetium"   , info=3033)
68     RUTHENIUM     = SaltVersion("Ruthenium"    , info=3034)
69     RHODIUM       = SaltVersion("Rhodium"      , info=3035)
70     PALLADIUM     = SaltVersion("Palladium"    , info=3036)
71     SILVER        = SaltVersion("Silver"       , info=3037)
72     CADMIUM       = SaltVersion("Cadmium"      , info=3038)
73     INDIUM        = SaltVersion("Indium"       , info=3039)
74     TIN           = SaltVersion("Tin"          , info=3040)
75     ANTIMONY      = SaltVersion("Antimony"     , info=3041)
76     TELLURIUM     = SaltVersion("Tellurium"    , info=3042)
77     IODINE        = SaltVersion("Iodine"       , info=3043)
78     XENON         = SaltVersion("Xenon"        , info=3044)
79     CESIUM        = SaltVersion("Cesium"       , info=3045)
80     BARIUM        = SaltVersion("Barium"       , info=3046)
81     LANTHANUM     = SaltVersion("Lanthanum"    , info=3047)
82     CERIUM        = SaltVersion("Cerium"       , info=3048)
83     PRASEODYMIUM  = SaltVersion("Praseodymium" , info=3049)
84     NEODYMIUM     = SaltVersion("Neodymium"    , info=3050)
85     PROMETHIUM    = SaltVersion("Promethium"   , info=3051)
86     SAMARIUM      = SaltVersion("Samarium"     , info=3052)
87     EUROPIUM      = SaltVersion("Europium"     , info=3053)
88     GADOLINIUM    = SaltVersion("Gadolinium"   , info=3054)
89     TERBIUM       = SaltVersion("Terbium"      , info=3055)
90     DYSPROSIUM    = SaltVersion("Dysprosium"   , info=3056)
91     HOLMIUM       = SaltVersion("Holmium"      , info=3057)
92     ERBIUM        = SaltVersion("Erbium"       , info=3058)
93     THULIUM       = SaltVersion("Thulium"      , info=3059)
94     YTTERBIUM     = SaltVersion("Ytterbium"    , info=3060)
95     LUTETIUM      = SaltVersion("Lutetium"     , info=3061)
96     HAFNIUM       = SaltVersion("Hafnium"      , info=3062)
97     TANTALUM      = SaltVersion("Tantalum"     , info=3063)
98     TUNGSTEN      = SaltVersion("Tungsten"     , info=3064)
99     RHENIUM       = SaltVersion("Rhenium"      , info=3065)
100     OSMIUM        = SaltVersion("Osmium"       , info=3066)
101     IRIDIUM       = SaltVersion("Iridium"      , info=3067)
102     PLATINUM      = SaltVersion("Platinum"     , info=3068)
103     GOLD          = SaltVersion("Gold"         , info=3069)
104     MERCURY       = SaltVersion("Mercury"      , info=3070)
105     THALLIUM      = SaltVersion("Thallium"     , info=3071)
106     LEAD          = SaltVersion("Lead"         , info=3072)
107     BISMUTH       = SaltVersion("Bismuth"      , info=3073)
108     POLONIUM      = SaltVersion("Polonium"     , info=3074)
109     ASTATINE      = SaltVersion("Astatine"     , info=3075)
110     RADON         = SaltVersion("Radon"        , info=3076)
111     FRANCIUM      = SaltVersion("Francium"     , info=3077)
112     RADIUM        = SaltVersion("Radium"       , info=3078)
113     ACTINIUM      = SaltVersion("Actinium"     , info=3079)
114     THORIUM       = SaltVersion("Thorium"      , info=3080)
115     PROTACTINIUM  = SaltVersion("Protactinium" , info=3081)
116     URANIUM       = SaltVersion("Uranium"      , info=3082)
117     NEPTUNIUM     = SaltVersion("Neptunium"    , info=3083)
118     PLUTONIUM     = SaltVersion("Plutonium"    , info=3084)
119     AMERICIUM     = SaltVersion("Americium"    , info=3085)
120     CURIUM        = SaltVersion("Curium"       , info=3086)
121     BERKELIUM     = SaltVersion("Berkelium"    , info=3087)
122     CALIFORNIUM   = SaltVersion("Californium"  , info=3088)
123     EINSTEINIUM   = SaltVersion("Einsteinium"  , info=3089)
124     FERMIUM       = SaltVersion("Fermium"      , info=3090)
125     MENDELEVIUM   = SaltVersion("Mendelevium"  , info=3091)
126     NOBELIUM      = SaltVersion("Nobelium"     , info=3092)
127     LAWRENCIUM    = SaltVersion("Lawrencium"   , info=3093)
128     RUTHERFORDIUM = SaltVersion("Rutherfordium", info=3094)
129     DUBNIUM       = SaltVersion("Dubnium"      , info=3095)
130     SEABORGIUM    = SaltVersion("Seaborgium"   , info=3096)
131     BOHRIUM       = SaltVersion("Bohrium"      , info=3097)
132     HASSIUM       = SaltVersion("Hassium"      , info=3098)
133     MEITNERIUM    = SaltVersion("Meitnerium"   , info=3099)
134     DARMSTADTIUM  = SaltVersion("Darmstadtium" , info=3100)
135     ROENTGENIUM   = SaltVersion("Roentgenium"  , info=3101)
136     COPERNICIUM   = SaltVersion("Copernicium"  , info=3102)
137     NIHONIUM      = SaltVersion("Nihonium"     , info=3103)
138     FLEROVIUM     = SaltVersion("Flerovium"    , info=3104)
139     MOSCOVIUM     = SaltVersion("Moscovium"    , info=3105)
140     LIVERMORIUM   = SaltVersion("Livermorium"  , info=3106)
141     TENNESSINE    = SaltVersion("Tennessine"   , info=3107)
142     OGANESSON     = SaltVersion("Oganesson"    , info=3108)
143     @classmethod
144     def versions(cls):
145         if not cls._sorted_versions:
146             cls._sorted_versions = sorted(
147                 (getattr(cls, name) for name in dir(cls) if name.isupper()),
148                 key=operator.attrgetter("info"),
149             )
150         return cls._sorted_versions
151     @classmethod
152     def current_release(cls):
153         if cls._current_release is None:
154             for version in cls.versions():
155                 if version.released is False:
156                     cls._current_release = version
157                     break
158         return cls._current_release
159     @classmethod
160     def next_release(cls):
161         if cls._next_release is None:
162             next_release_ahead = False
163             for version in cls.versions():
164                 if next_release_ahead:
165                     cls._next_release = version
166                     break
167                 if version == cls.current_release():
168                     next_release_ahead = True
169         return cls._next_release
170     @classmethod
171     def previous_release(cls):
172         if cls._previous_release is None:
173             previous = None
174             for version in cls.versions():
175                 if version == cls.current_release():
176                     break
177                 previous = version
178             cls._previous_release = previous
179         return cls._previous_release
180 class SaltStackVersion:
181     __slots__ = (
182         "name",
183         "major",
184         "minor",
185         "bugfix",
186         "mbugfix",
187         "pre_type",
188         "pre_num",
189         "noc",
190         "sha",
191     )
192     git_sha_regex = r"(?P&lt;sha&gt;g?[a-f0-9]{7,40})"
193     git_describe_regex = re.compile(
194         r"(?:[^\d]+)?(?P&lt;major&gt;[\d]{1,4})"
195         r"(?:\.(?P&lt;minor&gt;[\d]{1,2}))?"
196         r"(?:\.(?P&lt;bugfix&gt;[\d]{0,2}))?"
197         r"(?:\.(?P&lt;mbugfix&gt;[\d]{0,2}))?"
198         r"(?:(?P&lt;pre_type&gt;rc|a|b|alpha|beta|nb)(?P&lt;pre_num&gt;[\d]+))?"
199         r"(?:(?:.*)(?:\+|-)(?P&lt;noc&gt;(?:0na|[\d]+|n/a))(?:-|\.)" + git_sha_regex + r")?"
200     )
201     git_sha_regex = r"^" + git_sha_regex
202     git_sha_regex = re.compile(git_sha_regex)
203     NAMES = {v.name: v.info for v in SaltVersionsInfo.versions()}
204     LNAMES = {k.lower(): v for (k, v) in iter(NAMES.items())}
205     VNAMES = {v: k for (k, v) in iter(NAMES.items())}
206     RMATCH = {v[:2]: k for (k, v) in iter(NAMES.items())}
207     def __init__(
208         self,  # pylint: disable=C0103
209         major,
210         minor=None,
211         bugfix=None,
212         mbugfix=0,
213         pre_type=None,
214         pre_num=None,
215         noc=0,
216         sha=None,
217     ):
218         if isinstance(major, str):
219             major = int(major)
220         if isinstance(minor, str):
221             if not minor:
222                 minor = None
223             else:
224                 minor = int(minor)
225         if bugfix is None and not self.new_version(major=major):
226             bugfix = 0
227         elif isinstance(bugfix, str):
228             if not bugfix:
229                 bugfix = None
230             else:
231                 bugfix = int(bugfix)
232         if mbugfix is None:
233             mbugfix = 0
234         elif isinstance(mbugfix, str):
235             mbugfix = int(mbugfix)
236         if pre_type is None:
237             pre_type = ""
238         if pre_num is None:
239             pre_num = 0
240         elif isinstance(pre_num, str):
241             pre_num = int(pre_num)
242         if noc is None:
243             noc = 0
244         elif isinstance(noc, str) and noc in ("0na", "n/a"):
245             noc = -1
246         elif isinstance(noc, str):
247             noc = int(noc)
248         self.major = major
249         self.minor = minor
250         self.bugfix = bugfix
251         self.mbugfix = mbugfix
252         self.pre_type = pre_type
253         self.pre_num = pre_num
254         if self.new_version(major):
255             vnames_key = (major,)
256         else:
257             vnames_key = (major, minor)
258         self.name = self.VNAMES.get(vnames_key)
259         self.noc = noc
260         self.sha = sha
261     def new_version(self, major):
262         return bool(int(major) &gt;= 3000 and int(major) &lt; VERSION_LIMIT)
263     @classmethod
264     def parse(cls, version_string):
265         if version_string.lower() in cls.LNAMES:
266             return cls.from_name(version_string)
267         vstr = (
268             version_string.decode()
269             if isinstance(version_string, bytes)
270             else version_string
271         )
272         match = cls.git_describe_regex.match(vstr)
273         if not match:
274             raise ValueError(
275                 "Unable to parse version string: '{}'".format(version_string)
276             )
277         return cls(*match.groups())
278     @classmethod
279     def from_name(cls, name):
280         if name.lower() not in cls.LNAMES:
281             raise ValueError("Named version '{}' is not known".format(name))
282         return cls(*cls.LNAMES[name.lower()])
283     @classmethod
284     def from_last_named_version(cls):
285         import salt.utils.versions
286         salt.utils.versions.warn_until(
287             SaltVersionsInfo.SULFUR,
288             "The use of SaltStackVersion.from_last_named_version() is "
289             "deprecated and set to be removed in {version}. Please use "
290             "SaltStackVersion.current_release() instead.",
291         )
292         return cls.current_release()
293     @classmethod
294     def current_release(cls):
295         return cls(*SaltVersionsInfo.current_release().info)
296     @classmethod
297     def next_release(cls):
298         return cls(*SaltVersionsInfo.next_release().info)
299     @property
300     def sse(self):
301         return 0 &lt; self.major &lt; 2014
302     def min_info(self):
303         info = [self.major]
304         if self.new_version(self.major):
305             if self.minor:
306                 info.append(self.minor)
307         else:
308             info.extend([self.minor, self.bugfix, self.mbugfix])
309         return info
310     @property
311     def info(self):
312         return tuple(self.min_info())
313     @property
314     def pre_info(self):
315         info = self.min_info()
316         info.extend([self.pre_type, self.pre_num])
317         return tuple(info)
318     @property
319     def noc_info(self):
320         info = self.min_info()
321         info.extend([self.pre_type, self.pre_num, self.noc])
322         return tuple(info)
323     @property
324     def full_info(self):
325         info = self.min_info()
326         info.extend([self.pre_type, self.pre_num, self.noc, self.sha])
327         return tuple(info)
328     @property
329     def full_info_all_versions(self):
330         info = [
331             self.major,
332             self.minor,
333             self.bugfix,
334             self.mbugfix,
335             self.pre_type,
336             self.pre_num,
337             self.noc,
338             self.sha,
339         ]
340         return tuple(info)
341     @property
342     def string(self):
343         if self.new_version(self.major):
344             version_string = "{}".format(self.major)
345             if self.minor:
346                 version_string = "{}.{}".format(self.major, self.minor)
347         else:
348             version_string = "{}.{}.{}".format(self.major, self.minor, self.bugfix)
349         if self.mbugfix:
350             version_string += ".{}".format(self.mbugfix)
351         if self.pre_type:
352             version_string += "{}{}".format(self.pre_type, self.pre_num)
353         if self.noc and self.sha:
354             noc = self.noc
355             if noc &lt; 0:
356                 noc = "0na"
357             version_string += "+{}.{}".format(noc, self.sha)
358         return version_string
359     @property
360     def formatted_version(self):
361         if self.name and self.major &gt; 10000:
362             version_string = self.name
363             if self.sse:
364                 version_string += " Enterprise"
365             version_string += " (Unreleased)"
366             return version_string
367         version_string = self.string
368         if self.sse:
369             version_string += " Enterprise"
370         if (self.major, self.minor) in self.RMATCH:
371             version_string += " ({})".format(self.RMATCH[(self.major, self.minor)])
372         return version_string
373     @property
374     def pre_index(self):
375         if self.new_version(self.major):
376             pre_type = 2
377             if not isinstance(self.minor, int):
378                 pre_type = 1
379         else:
380             pre_type = 4
381         return pre_type
382     def __str__(self):
383         return self.string
384     def __compare__(self, other, method):
385         if not isinstance(other, SaltStackVersion):
386             if isinstance(other, str):
387                 other = SaltStackVersion.parse(other)
388             elif isinstance(other, (list, tuple)):
389                 other = SaltStackVersion(*other)
390             else:
391                 raise ValueError(
392                     "Cannot instantiate Version from type '{}'".format(type(other))
393                 )
394         pre_type = self.pre_index
395         other_pre_type = other.pre_index
396         other_noc_info = list(other.noc_info)
397         noc_info = list(self.noc_info)
398         if self.new_version(self.major):
399             if self.minor and not other.minor:
400                 if self.minor &gt; 0:
401                     other_noc_info[1] = 0
402             if not self.minor and other.minor:
403                 if other.minor &gt; 0:
404                     noc_info[1] = 0
405         if self.pre_type and not other.pre_type:
406             other_noc_info[other_pre_type] = "zzzzz"
407         if not self.pre_type and other.pre_type:
408             noc_info[pre_type] = "zzzzz"
409         return method(tuple(noc_info), tuple(other_noc_info))
410     def __lt__(self, other):
411         return self.__compare__(other, lambda _self, _other: _self &lt; _other)
412     def __le__(self, other):
413         return self.__compare__(other, lambda _self, _other: _self &lt;= _other)
414     def __eq__(self, other):
415         return self.__compare__(other, lambda _self, _other: _self == _other)
416     def __ne__(self, other):
417         return self.__compare__(other, lambda _self, _other: _self != _other)
418     def __ge__(self, other):
419         return self.__compare__(other, lambda _self, _other: _self &gt;= _other)
420     def __gt__(self, other):
421         return self.__compare__(other, lambda _self, _other: _self &gt; _other)
422     def __repr__(self):
423         parts = []
424         if self.name:
425             parts.append("name='{}'".format(self.name))
426         parts.extend(["major={}".format(self.major), "minor={}".format(self.minor)])
427         if self.new_version(self.major):
428             if not self.minor:
429                 parts.remove("".join([x for x in parts if re.search("^minor*", x)]))
430         else:
431             parts.extend(["bugfix={}".format(self.bugfix)])
432         if self.mbugfix:
433             parts.append("minor-bugfix={}".format(self.mbugfix))
434         if self.pre_type:
435             parts.append("{}={}".format(self.pre_type, self.pre_num))
436         noc = self.noc
437         if noc == -1:
438             noc = "0na"
439         if noc and self.sha:
440             parts.extend(["noc={}".format(noc), "sha={}".format(self.sha)])
441         return "&lt;{} {}&gt;".format(self.__class__.__name__, " ".join(parts))
442 __saltstack_version__ = SaltStackVersion.current_release()
443 def __discover_version(saltstack_version):
444     import os
445     import subprocess
446     if "SETUP_DIRNAME" in globals():
447         cwd = SETUP_DIRNAME  # pylint: disable=E0602
448         if not os.path.exists(os.path.join(cwd, ".git")):
449             return saltstack_version
450     else:
451         cwd = os.path.abspath(os.path.dirname(__file__))
452         if not os.path.exists(os.path.join(os.path.dirname(cwd), ".git")):
453             return saltstack_version
454     try:
455         kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
456         if not sys.platform.startswith("win"):
457             kwargs["close_fds"] = True
458         process = subprocess.Popen(
459             [
460                 "git",
461                 "describe",
462                 "--tags",
463                 "--long",
464                 "--match",
465                 "v[0-9]*",
466                 "--always",
467             ],
468             **kwargs
469         )
470         out, err = process.communicate()
471         out = out.decode().strip()
472         err = err.decode().strip()
473         if not out or err:
474             return saltstack_version
475         if SaltStackVersion.git_sha_regex.match(out):
476             saltstack_version.sha = out.strip()
477             saltstack_version.noc = -1
478             return saltstack_version
479         return SaltStackVersion.parse(out)
480     except OSError as os_err:
481         if os_err.errno != 2:
482             raise
483     return saltstack_version
484 def __get_version(saltstack_version):
485     try:
486         from salt._version import __saltstack_version__  # pylint: disable=E0611,F0401
487         return __saltstack_version__
488     except ImportError:
489         return __discover_version(saltstack_version)
490 __saltstack_version__ = __get_version(__saltstack_version__)
491 if __saltstack_version__.name:
492     SaltVersionsInfo._current_release = getattr(
493         SaltVersionsInfo, __saltstack_version__.name.upper()
494     )
495 del __get_version
496 __version_info__ = __saltstack_version__.info
497 __version__ = __saltstack_version__.string
498 def salt_information():
499     yield "Salt", __version__
500 def dependency_information(include_salt_cloud=False):
501     libs = [
502         ("Python", None, sys.version.rsplit("\n")<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[0].strip()),
503         ("Jinja2", "jinja2", "__version__"),
504         ("M2Crypto", "M2Crypto", "version"),
505         ("msgpack", "msgpack", "version"),
506         ("msgpack-pure", "msgpack_pure", "version"),
507         ("pycrypto", "Crypto", "__version__"),
508         ("pycryptodome", "Cryptodome", "version_info"),
509         ("PyYAML", "yaml", "__version__"),
510         ("PyZMQ", "zmq", "__version__"),
511         ("ZMQ"</b></font>, "zmq", "zmq_version"),
512         ("Mako", "mako", "__version__"),
513         ("Tornado", "tornado", "version"),
514         ("timelib", "timelib", "version"),
515         ("dateutil", "dateutil", "__version__"),
516         ("pygit2", "pygit2", "__version__"),
517         ("libgit2", "pygit2", "LIBGIT2_VERSION"),
518         ("smmap", "smmap", "__version__"),
519         ("cffi", "cffi", "__version__"),
520         ("pycparser", "pycparser", "__version__"),
521         ("gitdb", "gitdb", "__version__"),
522         ("gitpython", "git", "__version__"),
523         ("python-gnupg", "gnupg", "__version__"),
524         ("mysql-python", "MySQLdb", "__version__"),
525         ("cherrypy", "cherrypy", "__version__"),
526         ("docker-py", "docker", "__version__"),
527     ]
528     if include_salt_cloud:
529         libs.append(
530             ("Apache Libcloud", "libcloud", "__version__"),
531         )
532     for name, imp, attr in libs:
533         if imp is None:
534             yield name, attr
535             continue
536         try:
537             imp = __import__(imp)
538             version = getattr(imp, attr)
539             if callable(version):
540                 version = version()
541             if isinstance(version, (tuple, list)):
542                 version = ".".join(map(str, version))
543             yield name, version
544         except Exception:  # pylint: disable=broad-except
545             yield name, None
546 def system_information():
547     from distro import linux_distribution
548     def system_version():
549         lin_ver = linux_distribution()
550         mac_ver = platform.mac_ver()
551         win_ver = platform.win32_ver()
552         if mac_ver[0]:
553             if isinstance(mac_ver[1], (tuple, list)) and "".join(mac_ver[1]):
554                 return " ".join([mac_ver[0], ".".join(mac_ver[1]), mac_ver[2]])
555             else:
556                 return " ".join([mac_ver[0], mac_ver[2]])
557         elif win_ver[0]:
558             return " ".join(win_ver)
559         elif lin_ver[0]:
560             return " ".join(lin_ver)
561         else:
562             return ""
563     if platform.win32_ver()[0]:
564         import win32api  # pylint: disable=3rd-party-module-not-gated
565         import win32con  # pylint: disable=3rd-party-module-not-gated
566         hkey = win32con.HKEY_LOCAL_MACHINE
567         key = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
568         value_name = "ProductName"
569         reg_handle = win32api.RegOpenKey(hkey, key)
570         product_name, _ = win32api.RegQueryValueEx(reg_handle, value_name)
571         version = "Unknown"
572         release = ""
573         if "Server" in product_name:
574             for item in product_name.split(" "):
575                 if re.match(r"\d+", item):
576                     version = item
577                 if re.match(r"^R\d+$", item):
578                     release = item
579             release = "{}Server{}".format(version, release)
580         else:
581             for item in product_name.split(" "):
582                 if re.match(r"^(\d+(\.\d+)?)|Thin|Vista$", item):
583                     version = item
584             release = version
585         _, ver, service_pack, extra = platform.win32_ver()
586         version = " ".join([release, ver, service_pack, extra])
587     else:
588         version = system_version()
589         release = platform.release()
590     system = [
591         ("system", platform.system()),
592         ("dist", " ".join(linux_distribution(full_distribution_name=False))),
593         ("release", release),
594         ("machine", platform.machine()),
595         ("version", version),
596         ("locale", __salt_system_encoding__),
597     ]
598     for name, attr in system:
599         yield name, attr
600         continue
601 def extensions_information():
602     import salt.utils.entrypoints
603     extensions = {}
604     for entry_point in salt.utils.entrypoints.iter_entry_points("salt.loader"):
605         dist_nv = salt.utils.entrypoints.name_and_version_from_entry_point(entry_point)
606         if not dist_nv:
607             continue
608         if dist_nv.name in extensions:
609             continue
610         extensions[dist_nv.name] = dist_nv.version
611     return extensions
612 def versions_information(include_salt_cloud=False, include_extensions=True):
613     salt_info = list(salt_information())
614     lib_info = list(dependency_information(include_salt_cloud))
615     sys_info = list(system_information())
616     info = {
617         "Salt Version": dict(salt_info),
618         "Dependency Versions": dict(lib_info),
619         "System Versions": dict(sys_info),
620     }
621     if include_extensions:
622         extensions_info = extensions_information()
623         if extensions_info:
624             info["Salt Extensions"] = extensions_info
625     return info
626 def versions_report(include_salt_cloud=False, include_extensions=True):
627     ver_info = versions_information(
628         include_salt_cloud=include_salt_cloud, include_extensions=include_extensions
629     )
630     not_installed = "Not Installed"
631     ns_pad = len(not_installed)
632     lib_pad = max(len(name) for name in ver_info["Dependency Versions"])
633     sys_pad = max(len(name) for name in ver_info["System Versions"])
634     if include_extensions and "Salt Extensions" in ver_info:
635         ext_pad = max(len(name) for name in ver_info["Salt Extensions"])
636     else:
637         ext_pad = 1
638     padding = max(lib_pad, sys_pad, ns_pad, ext_pad) + 1
639     fmt = "{0:&gt;{pad}}: {1}"
640     info = []
641     for ver_type in (
642         "Salt Version",
643         "Dependency Versions",
644         "Salt Extensions",
645         "System Versions",
646     ):
647         if ver_type == "Salt Extensions" and ver_type not in ver_info:
648             continue
649         info.append("{}:".format(ver_type))
650         for name in sorted(ver_info[ver_type], key=lambda x: x.lower()):
651             ver = fmt.format(
652                 name, ver_info[ver_type][name] or not_installed, pad=padding
653             )
654             info.append(ver)
655         info.append(" ")
656     yield from info
657 if __name__ == "__main__":
658     print(__version__)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>gitfs_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import contextlib
2 import copy
3 import errno
4 import fnmatch
5 import glob
6 import hashlib
7 import io
8 import logging
9 import os
10 import shlex
11 import shutil
12 import stat
13 import subprocess
14 import time
15 import weakref
16 from datetime import datetime
17 import salt.ext.tornado.ioloop
18 import salt.fileserver
19 import salt.utils.configparser
20 import salt.utils.data
21 import salt.utils.files
22 import salt.utils.gzip_util
23 import salt.utils.hashutils
24 import salt.utils.itertools
25 import salt.utils.path
26 import salt.utils.platform
27 import salt.utils.stringutils
28 import salt.utils.url
29 import salt.utils.user
30 import salt.utils.versions
31 from salt.config import DEFAULT_MASTER_OPTS as _DEFAULT_MASTER_OPTS
32 from salt.exceptions import FileserverConfigError, GitLockError, get_error_message
33 from salt.utils.event import tagify
34 from salt.utils.odict import OrderedDict
35 from salt.utils.process import os_is_running as pid_exists
36 from salt.utils.versions import LooseVersion as _LooseVersion
37 VALID_REF_TYPES = _DEFAULT_MASTER_OPTS["gitfs_ref_types"]
38 PER_REMOTE_ONLY = ("name",)
39 GLOBAL_ONLY = ()
40 SYMLINK_RECURSE_DEPTH = 100
41 AUTH_PROVIDERS = ("pygit2",)
42 AUTH_PARAMS = ("user", "password", "pubkey", "privkey", "passphrase", "insecure_auth")
43 PER_SALTENV_PARAMS = ("mountpoint", "root", "ref")
44 _RECOMMEND_GITPYTHON = (
45     "GitPython is installed, you may wish to set %s_provider to "
46     "'gitpython' to use GitPython for %s support."
47 )
48 _RECOMMEND_PYGIT2 = (
49     "pygit2 is installed, you may wish to set %s_provider to "
50     "'pygit2' to use pygit2 for for %s support."
51 )
52 _INVALID_REPO = (
53     "Cache path %s (corresponding remote: %s) exists but is not a valid "
54     "git repository. You will need to manually delete this directory on the "
55     "master to continue to use this %s remote."
56 )
57 log = logging.getLogger(__name__)
58 try:
59     if (
60         salt.utils.platform.is_darwin()
61         and salt.utils.path.which("git") == "/usr/bin/git"
62     ):
63         from salt.utils.mac_utils import git_is_stub
64         if git_is_stub():
65             raise ImportError("Git is not present.")
66     import git
67     import gitdb
68     GITPYTHON_VERSION = _LooseVersion(git.__version__)
69 except Exception:  # pylint: disable=broad-except
70     GITPYTHON_VERSION = None
71 try:
72     import warnings
73     with warnings.catch_warnings():
74         warnings.simplefilter("ignore")
75         import pygit2
76     PYGIT2_VERSION = _LooseVersion(pygit2.__version__)
77     LIBGIT2_VERSION = _LooseVersion(pygit2.LIBGIT2_VERSION)
78     if PYGIT2_VERSION &lt;= _LooseVersion("0.26.3"):
79         try:
80             import pygit2.ffi
81             import pygit2.remote
82         except ImportError:
83             pass
84         else:
85             def __maybe_string(ptr):
86                 if not ptr:
87                     return None
88                 return pygit2.ffi.string(ptr).decode("utf-8")
89             pygit2.remote.maybe_string = __maybe_string
90     try:
91         GitError = pygit2.errors.GitError
92     except AttributeError:
93         GitError = Exception
94 except Exception as exc:  # pylint: disable=broad-except
95     PYGIT2_VERSION = None
96     LIBGIT2_VERSION = None
97     if not isinstance(exc, ImportError):
98         log.exception("Failed to import pygit2")
99 GITPYTHON_MINVER = _LooseVersion("0.3")
100 PYGIT2_MINVER = _LooseVersion("0.20.3")
101 LIBGIT2_MINVER = _LooseVersion("0.20.0")
102 def enforce_types(key, val):
103     non_string_params = {
104         "ssl_verify": bool,
105         "insecure_auth": bool,
106         "disable_saltenv_mapping": bool,
107         "saltenv_whitelist": "stringlist",
108         "saltenv_blacklist": "stringlist",
109         "refspecs": "stringlist",
110         "ref_types": "stringlist",
111         "update_interval": int,
112     }
113     def _find_global(key):
114         for item in non_string_params:
115             try:
116                 if key.endswith("_" + item):
117                     ret = item
118                     break
119             except TypeError:
120                 if key.endswith("_" + str(item)):
121                     ret = item
122                     break
123         else:
124             ret = None
125         return ret
126     if key not in non_string_params:
127         key = _find_global(key)
128         if key is None:
129             return str(val)
130     expected = non_string_params[key]
131     if expected == "stringlist":
132         if not isinstance(val, ((str,), list)):
133             val = str(val)
134         if isinstance(val, str):
135             return [x.strip() for x in val.split(",")]
136         return [str(x) for x in val]
137     else:
138         try:
139             return expected(val)
140         except Exception as exc:  # pylint: disable=broad-except
141             log.error(
142                 "Failed to enforce type for key=%s with val=%s, falling back "
143                 "to a string",
144                 key,
145                 val,
146             )
147             return str(val)
148 def failhard(role):
149     raise FileserverConfigError("Failed to load {}".format(role))
150 class GitProvider:
151     def __init__(
152         self,
153         opts,
154         remote,
155         per_remote_defaults,
156         per_remote_only,
157         override_params,
158         cache_root,
159         role="gitfs",
160     ):
161         self.opts = opts
162         self.role = role
163         self.global_saltenv = salt.utils.data.repack_dictlist(
164             self.opts.get("{}_saltenv".format(self.role), []),
165             strict=True,
166             recurse=True,
167             key_cb=str,
168             val_cb=lambda x, y: str(y),
169         )
170         self.conf = copy.deepcopy(per_remote_defaults)
171         for saltenv, saltenv_conf in self.global_saltenv.items():
172             if "mountpoint" in saltenv_conf:
173                 self.global_saltenv[saltenv]["mountpoint"] = salt.utils.url.strip_proto(
174                     self.global_saltenv[saltenv]["mountpoint"]
175                 )
176         per_remote_collisions = [x for x in override_params if x in per_remote_only]
177         if per_remote_collisions:
178             log.critical(
179                 "The following parameter names are restricted to per-remote "
180                 "use only: %s. This is a bug, please report it.",
181                 ", ".join(per_remote_collisions),
182             )
183         try:
184             valid_per_remote_params = override_params + per_remote_only
185         except TypeError:
186             valid_per_remote_params = list(override_params) + list(per_remote_only)
187         if isinstance(remote, dict):
188             self.id = next(iter(remote))
189             self.get_url()
190             per_remote_conf = salt.utils.data.repack_dictlist(
191                 remote[self.id],
192                 strict=True,
193                 recurse=True,
194                 key_cb=str,
195                 val_cb=enforce_types,
196             )
197             if not per_remote_conf:
198                 log.critical(
199                     "Invalid per-remote configuration for %s remote '%s'. "
200                     "If no per-remote parameters are being specified, there "
201                     "may be a trailing colon after the URL, which should be "
202                     "removed. Check the master configuration file.",
203                     self.role,
204                     self.id,
205                 )
206                 failhard(self.role)
207             if (
208                 self.role == "git_pillar"
209                 and self.branch != "__env__"
210                 and "base" in per_remote_conf
211             ):
212                 log.critical(
213                     "Invalid per-remote configuration for %s remote '%s'. base can only"
214                     " be specified if __env__ is specified as the branch name.",
215                     self.role,
216                     self.id,
217                 )
218                 failhard(self.role)
219             per_remote_errors = False
220             for param in (
221                 x for x in per_remote_conf if x not in valid_per_remote_params
222             ):
223                 per_remote_errors = True
224                 if param in AUTH_PARAMS and self.provider not in AUTH_PROVIDERS:
225                     msg = (
226                         "{0} authentication parameter '{1}' (from remote "
227                         "'{2}') is only supported by the following "
228                         "provider(s): {3}. Current {0}_provider is '{4}'.".format(
229                             self.role,
230                             param,
231                             self.id,
232                             ", ".join(AUTH_PROVIDERS),
233                             self.provider,
234                         )
235                     )
236                     if self.role == "gitfs":
237                         msg += (
238                             "See the GitFS Walkthrough in the Salt "
239                             "documentation for further information."
240                         )
241                     log.critical(msg)
242                 else:
243                     msg = (
244                         "Invalid {} configuration parameter '{}' in "
245                         "remote '{}'. Valid parameters are: {}.".format(
246                             self.role,
247                             param,
248                             self.id,
249                             ", ".join(valid_per_remote_params),
250                         )
251                     )
252                     if self.role == "gitfs":
253                         msg += (
254                             " See the GitFS Walkthrough in the Salt "
255                             "documentation for further information."
256                         )
257                     log.critical(msg)
258             if per_remote_errors:
259                 failhard(self.role)
260             self.conf.update(per_remote_conf)
261         else:
262             self.id = remote
263             self.get_url()
264         if "root" not in self.conf:
265             self.conf["root"] = ""
266         if self.role == "winrepo" and "name" not in self.conf:
267             self.conf["name"] = self.url.rsplit("/", 1)[-1]
268             if self.conf["name"].lower().endswith(".git"):
269                 self.conf["name"] = self.conf["name"][:-4]
270         if "mountpoint" in self.conf:
271             self.conf["mountpoint"] = salt.utils.url.strip_proto(
272                 self.conf["mountpoint"]
273             ).strip("/")
274         else:
275             self.conf["mountpoint"] = ""
276         if "saltenv" not in self.conf:
277             self.conf["saltenv"] = {}
278         else:
279             for saltenv, saltenv_conf in self.conf["saltenv"].items():
280                 if "mountpoint" in saltenv_conf:
281                     saltenv_ptr = self.conf["saltenv"][saltenv]
282                     saltenv_ptr["mountpoint"] = salt.utils.url.strip_proto(
283                         saltenv_ptr["mountpoint"]
284                     )
285         for key, val in self.conf.items():
286             if key not in PER_SALTENV_PARAMS and not hasattr(self, key):
287                 setattr(self, key, val)
288         for key in PER_SALTENV_PARAMS:
289             if key != "ref":
290                 setattr(self, "_" + key, self.conf[key])
291             self.add_conf_overlay(key)
292         if not hasattr(self, "refspecs"):
293             key = "{}_refspecs".format(self.role)
294             try:
295                 default_refspecs = _DEFAULT_MASTER_OPTS[key]
296             except KeyError:
297                 log.critical(
298                     "The '%s' option has no default value in salt/config/__init__.py.",
299                     key,
300                 )
301                 failhard(self.role)
302             setattr(self, "refspecs", default_refspecs)
303             log.debug(
304                 "The 'refspecs' option was not explicitly defined as a "
305                 "configurable parameter. Falling back to %s for %s remote "
306                 "'%s'.",
307                 default_refspecs,
308                 self.role,
309                 self.id,
310             )
311         delattr(self, "conf")
312         if hasattr(self, "ref_types"):
313             self.ref_types = [x.lower() for x in self.ref_types]
314             invalid_ref_types = [x for x in self.ref_types if x not in VALID_REF_TYPES]
315             if invalid_ref_types:
316                 log.critical(
317                     "The following ref_types for %s remote '%s' are "
318                     "invalid: %s. The supported values are: %s",
319                     self.role,
320                     self.id,
321                     ", ".join(invalid_ref_types),
322                     ", ".join(VALID_REF_TYPES),
323                 )
324                 failhard(self.role)
325         if not isinstance(self.url, str):
326             log.critical(
327                 "Invalid %s remote '%s'. Remotes must be strings, you "
328                 "may need to enclose the URL in quotes",
329                 self.role,
330                 self.id,
331             )
332             failhard(self.role)
333         hash_type = getattr(hashlib, self.opts.get("hash_type", "md5"))
334         self.hash = hash_type(self.id.encode("utf-8")).hexdigest()
335         self.cachedir_basename = getattr(self, "name", self.hash)
336         self.cachedir = salt.utils.path.join(cache_root, self.cachedir_basename)
337         self.linkdir = salt.utils.path.join(cache_root, "links", self.cachedir_basename)
338         if not os.path.isdir(self.cachedir):
339             os.makedirs(self.cachedir)
340         try:
341             self.new = self.init_remote()
342         except Exception as exc:  # pylint: disable=broad-except
343             msg = "Exception caught while initializing {} remote '{}': {}".format(
344                 self.role, self.id, exc
345             )
346             if isinstance(self, GitPython):
347                 msg += " Perhaps git is not available."
348             log.critical(msg, exc_info=True)
349             failhard(self.role)
350     def _get_envs_from_ref_paths(self, refs):
351         def _check_ref(env_set, rname):
352             if rname in self.saltenv_revmap:
353                 env_set.update(self.saltenv_revmap[rname])
354             else:
355                 if rname == self.base:
356                     env_set.add("base")
357                 elif not self.disable_saltenv_mapping:
358                     env_set.add(rname)
359         use_branches = "branch" in self.ref_types
360         use_tags = "tag" in self.ref_types
361         ret = set()
362         if salt.utils.stringutils.is_hex(self.base):
363             ret.add("base")
364         for ref in salt.utils.data.decode(refs):
365             if ref.startswith("refs/"):
366                 ref = ref[5:]
367             rtype, rname = ref.split("/", 1)
368             if rtype == "remotes" and use_branches:
369                 parted = rname.partition("/")
370                 rname = parted[2] if parted[2] else parted[0]
371                 _check_ref(ret, rname)
372             elif rtype == "tags" and use_tags:
373                 _check_ref(ret, rname)
374         return ret
375     def _get_lock_file(self, lock_type="update"):
376         return salt.utils.path.join(self.gitdir, lock_type + ".lk")
377     @classmethod
378     def add_conf_overlay(cls, name):
379         def _getconf(self, tgt_env="base"):
380             strip_sep = (
381                 lambda x: x.rstrip(os.sep) if name in ("root", "mountpoint") else x
382             )
383             if self.role != "gitfs":
384                 return strip_sep(getattr(self, "_" + name))
385             saltenv_conf = self.saltenv.get(tgt_env, {})
386             if name == "ref":
387                 def _get_per_saltenv(tgt_env):
388                     if name in saltenv_conf:
389                         return saltenv_conf[name]
390                     elif (
391                         tgt_env in self.global_saltenv
392                         and name in self.global_saltenv[tgt_env]
393                     ):
394                         return self.global_saltenv[tgt_env][name]
395                     else:
396                         return None
397                 per_saltenv_ref = _get_per_saltenv(tgt_env)
398                 try:
399                     all_saltenvs_ref = self.all_saltenvs
400                     if per_saltenv_ref and all_saltenvs_ref != per_saltenv_ref:
401                         log.debug(
402                             "The per-saltenv configuration has mapped the "
403                             "'%s' branch/tag to saltenv '%s' for %s "
404                             "remote '%s', but this remote has "
405                             "all_saltenvs set to '%s'. The per-saltenv "
406                             "mapping will be ignored in favor of '%s'.",
407                             per_saltenv_ref,
408                             tgt_env,
409                             self.role,
410                             self.id,
411                             all_saltenvs_ref,
412                             all_saltenvs_ref,
413                         )
414                     return all_saltenvs_ref
415                 except AttributeError:
416                     pass
417                 if tgt_env == "base":
418                     return self.base
419                 elif self.disable_saltenv_mapping:
420                     if per_saltenv_ref is None:
421                         log.debug(
422                             "saltenv mapping is disabled for %s remote '%s' "
423                             "and saltenv '%s' is not explicitly mapped",
424                             self.role,
425                             self.id,
426                             tgt_env,
427                         )
428                     return per_saltenv_ref
429                 else:
430                     return per_saltenv_ref or tgt_env
431             if name in saltenv_conf:
432                 return strip_sep(saltenv_conf[name])
433             elif (
434                 tgt_env in self.global_saltenv and name in self.global_saltenv[tgt_env]
435             ):
436                 return strip_sep(self.global_saltenv[tgt_env][name])
437             else:
438                 return strip_sep(getattr(self, "_" + name))
439         setattr(cls, name, _getconf)
440     def check_root(self):
441         root_dir = salt.utils.path.join(self.cachedir, self.root()).rstrip(os.sep)
442         if os.path.isdir(root_dir):
443             return root_dir
444         log.error(
445             "Root path '%s' not present in %s remote '%s', skipping.",
446             self.root(),
447             self.role,
448             self.id,
449         )
450         return None
451     def clean_stale_refs(self):
452         cleaned = []
453         cmd_str = "git remote prune origin"
454         env = os.environ.copy()
455         if not salt.utils.platform.is_windows():
456             env[b"LANGUAGE"] = b"C"
457             env[b"LC_ALL"] = b"C"
458         cmd = subprocess.Popen(
459             shlex.split(cmd_str),
460             close_fds=not salt.utils.platform.is_windows(),
461             cwd=os.path.dirname(self.gitdir),
462             env=env,
463             stdout=subprocess.PIPE,
464             stderr=subprocess.STDOUT,
465         )
466         output = cmd.communicate()[0]
467         output = output.decode(__salt_system_encoding__)
468         if cmd.returncode != 0:
469             log.warning(
470                 "Failed to prune stale branches for %s remote '%s'. "
471                 "Output from '%s' follows:\n%s",
472                 self.role,
473                 self.id,
474                 cmd_str,
475                 output,
476             )
477         else:
478             marker = " * [pruned] "
479             for line in salt.utils.itertools.split(output, "\n"):
480                 if line.startswith(marker):
481                     cleaned.append(line[len(marker) :].strip())
482             if cleaned:
483                 log.debug(
484                     "%s pruned the following stale refs: %s",
485                     self.role,
486                     ", ".join(cleaned),
487                 )
488         return cleaned
489     def clear_lock(self, lock_type="update"):
490         lock_file = self._get_lock_file(lock_type=lock_type)
491         def _add_error(errlist, exc):
492             msg = "Unable to remove update lock for {} ({}): {} ".format(
493                 self.url, lock_file, exc
494             )
495             log.debug(msg)
496             errlist.append(msg)
497         success = []
498         failed = []
499         try:
500             os.remove(lock_file)
501         except OSError as exc:
502             if exc.errno == errno.ENOENT:
503                 pass
504             elif exc.errno == errno.EISDIR:
505                 try:
506                     shutil.rmtree(lock_file)
507                 except OSError as exc:
508                     _add_error(failed, exc)
509             else:
510                 _add_error(failed, exc)
511         else:
512             msg = "Removed {} lock for {} remote '{}'".format(
513                 lock_type, self.role, self.id
514             )
515             log.debug(msg)
516             success.append(msg)
517         return success, failed
518     def enforce_git_config(self):
519         git_config = os.path.join(self.gitdir, "config")
520         conf = salt.utils.configparser.GitConfigParser()
521         if not conf.read(git_config):
522             log.error("Failed to read from git config file %s", git_config)
523         else:
524             conf_changed = False
525             remote_section = 'remote "origin"'
526             try:
527                 url = conf.get(remote_section, "url")
528             except salt.utils.configparser.NoSectionError:
529                 conf.add_section(remote_section)
530                 conf_changed = True
531                 url = None
532             log.debug(
533                 "Current fetch URL for %s remote '%s': %s (desired: %s)",
534                 self.role,
535                 self.id,
536                 url,
537                 self.url,
538             )
539             if url != self.url:
540                 conf.set(remote_section, "url", self.url)
541                 log.debug(
542                     "Fetch URL for %s remote '%s' set to %s",
543                     self.role,
544                     self.id,
545                     self.url,
546                 )
547                 conf_changed = True
548             try:
549                 refspecs = sorted(conf.get(remote_section, "fetch", as_list=True))
550             except salt.utils.configparser.NoOptionError:
551                 refspecs = []
552             desired_refspecs = sorted(self.refspecs)
553             log.debug(
554                 "Current refspecs for %s remote '%s': %s (desired: %s)",
555                 self.role,
556                 self.id,
557                 refspecs,
558                 desired_refspecs,
559             )
560             if refspecs != desired_refspecs:
561                 conf.set_multivar(remote_section, "fetch", self.refspecs)
562                 log.debug(
563                     "Refspecs for %s remote '%s' set to %s",
564                     self.role,
565                     self.id,
566                     desired_refspecs,
567                 )
568                 conf_changed = True
569             try:
570                 ssl_verify = conf.get("http", "sslVerify")
571             except salt.utils.configparser.NoSectionError:
572                 conf.add_section("http")
573                 ssl_verify = None
574             except salt.utils.configparser.NoOptionError:
575                 ssl_verify = None
576             desired_ssl_verify = str(self.ssl_verify).lower()
577             log.debug(
578                 "Current http.sslVerify for %s remote '%s': %s (desired: %s)",
579                 self.role,
580                 self.id,
581                 ssl_verify,
582                 desired_ssl_verify,
583             )
584             if ssl_verify != desired_ssl_verify:
585                 conf.set("http", "sslVerify", desired_ssl_verify)
586                 log.debug(
587                     "http.sslVerify for %s remote '%s' set to %s",
588                     self.role,
589                     self.id,
590                     desired_ssl_verify,
591                 )
592                 conf_changed = True
593             if conf_changed:
594                 with salt.utils.files.fopen(git_config, "w") as fp_:
595                     conf.write(fp_)
596                     log.debug(
597                         "Config updates for %s remote '%s' written to %s",
598                         self.role,
599                         self.id,
600                         git_config,
601                     )
602     def fetch(self):
603         try:
604             with self.gen_lock(lock_type="update"):
605                 log.debug("Fetching %s remote '%s'", self.role, self.id)
606                 return self._fetch()
607         except GitLockError as exc:
608             if exc.errno == errno.EEXIST:
609                 log.warning(
610                     "Update lock file is present for %s remote '%s', "
611                     "skipping. If this warning persists, it is possible that "
612                     "the update process was interrupted, but the lock could "
613                     "also have been manually set. Removing %s or running "
614                     "'salt-run cache.clear_git_lock %s type=update' will "
615                     "allow updates to continue for this remote.",
616                     self.role,
617                     self.id,
618                     self._get_lock_file(lock_type="update"),
619                     self.role,
620                 )
621             return False
622     def _lock(self, lock_type="update", failhard=False):
623         try:
624             fh_ = os.open(
625                 self._get_lock_file(lock_type), os.O_CREAT | os.O_EXCL | os.O_WRONLY
626             )
627             with os.fdopen(fh_, "wb"):
628                 os.write(fh_, salt.utils.stringutils.to_bytes(str(os.getpid())))
629         except OSError as exc:
630             if exc.errno == errno.EEXIST:
631                 with salt.utils.files.fopen(self._get_lock_file(lock_type), "r") as fd_:
632                     try:
633                         pid = int(
634                             salt.utils.stringutils.to_unicode(fd_.readline()).rstrip()
635                         )
636                     except ValueError:
637                         pid = 0
638                 global_lock_key = self.role + "_global_lock"
639                 lock_file = self._get_lock_file(lock_type=lock_type)
640                 if self.opts[global_lock_key]:
641                     msg = (
642                         "{} is enabled and {} lockfile {} is present for "
643                         "{} remote '{}'.".format(
644                             global_lock_key,
645                             lock_type,
646                             lock_file,
647                             self.role,
648                             self.id,
649                         )
650                     )
651                     if pid:
652                         msg += " Process {} obtained the lock".format(pid)
653                         if not pid_exists(pid):
654                             msg += (
655                                 " but this process is not running. The "
656                                 "update may have been interrupted. If "
657                                 "using multi-master with shared gitfs "
658                                 "cache, the lock may have been obtained "
659                                 "by another master."
660                             )
661                     log.warning(msg)
662                     if failhard:
663                         raise
664                     return
665                 elif pid and pid_exists(pid):
666                     log.warning(
667                         "Process %d has a %s %s lock (%s)",
668                         pid,
669                         self.role,
670                         lock_type,
671                         lock_file,
672                     )
673                     if failhard:
674                         raise
675                     return
676                 else:
677                     if pid:
678                         log.warning(
679                             "Process %d has a %s %s lock (%s), but this "
680                             "process is not running. Cleaning up lock file.",
681                             pid,
682                             self.role,
683                             lock_type,
684                             lock_file,
685                         )
686                     success, fail = self.clear_lock()
687                     if success:
688                         return self._lock(lock_type="update", failhard=failhard)
689                     elif failhard:
690                         raise
691                     return
692             else:
693                 msg = "Unable to set {} lock for {} ({}): {} ".format(
694                     lock_type, self.id, self._get_lock_file(lock_type), exc
695                 )
696                 log.error(msg, exc_info=True)
697                 raise GitLockError(exc.errno, msg)
698         msg = "Set {} lock for {} remote '{}'".format(lock_type, self.role, self.id)
699         log.debug(msg)
700         return msg
701     def lock(self):
702         success = []
703         failed = []
704         try:
705             result = self._lock(lock_type="update")
706         except GitLockError as exc:
707             failed.append(exc.strerror)
708         else:
709             if result is not None:
710                 success.append(result)
711         return success, failed
712     @contextlib.contextmanager
713     def gen_lock(self, lock_type="update", timeout=0, poll_interval=0.5):
714         if not isinstance(lock_type, str):
715             raise GitLockError(errno.EINVAL, "Invalid lock_type '{}'".format(lock_type))
716         try:
717             timeout = int(timeout)
718         except ValueError:
719             timeout = 0
720         else:
721             if timeout &lt; 0:
722                 timeout = 0
723         if not isinstance(poll_interval, ((int,), float)) or poll_interval &lt; 0:
724             poll_interval = 0.5
725         if poll_interval &gt; timeout:
726             poll_interval = timeout
727         lock_set = False
728         try:
729             time_start = time.time()
730             while True:
731                 try:
732                     self._lock(lock_type=lock_type, failhard=True)
733                     lock_set = True
734                     yield
735                     break
736                 except (OSError, GitLockError) as exc:
737                     if not timeout or time.time() - time_start &gt; timeout:
738                         raise GitLockError(exc.errno, exc.strerror)
739                     else:
740                         log.debug(
741                             "A %s lock is already present for %s remote "
742                             "'%s', sleeping %f second(s)",
743                             lock_type,
744                             self.role,
745                             self.id,
746                             poll_interval,
747                         )
748                         time.sleep(poll_interval)
749                         continue
750         finally:
751             if lock_set:
752                 self.clear_lock(lock_type=lock_type)
753     def init_remote(self):
754         raise NotImplementedError()
755     def checkout(self):
756         raise NotImplementedError()
757     def dir_list(self, tgt_env):
758         raise NotImplementedError()
759     def env_is_exposed(self, tgt_env):
760         return salt.utils.stringutils.check_whitelist_blacklist(
761             tgt_env,
762             whitelist=self.saltenv_whitelist,
763             blacklist=self.saltenv_blacklist,
764         )
765     def _fetch(self):
766         raise NotImplementedError()
767     def envs(self):
768         raise NotImplementedError()
769     def file_list(self, tgt_env):
770         raise NotImplementedError()
771     def find_file(self, path, tgt_env):
772         raise NotImplementedError()
773     def get_checkout_target(self):
774         if self.role == "git_pillar" and self.branch == "__env__":
775             try:
776                 return self.all_saltenvs
777             except AttributeError:
778                 pass
779             target = self.opts.get("pillarenv") or self.opts.get("saltenv") or "base"
780             return self.base if target == "base" else str(target)
781         return self.branch
782     def get_tree(self, tgt_env):
783         if not self.env_is_exposed(tgt_env):
784             return None
785         tgt_ref = self.ref(tgt_env)
786         if tgt_ref is None:
787             return None
788         for ref_type in self.ref_types:
789             try:
790                 func_name = "get_tree_from_{}".format(ref_type)
791                 func = getattr(self, func_name)
792             except AttributeError:
793                 log.error(
794                     "%s class is missing function '%s'",
795                     self.__class__.__name__,
796                     func_name,
797                 )
798             else:
799                 candidate = func(tgt_ref)
800                 if candidate is not None:
801                     return candidate
802         if self.fallback:
803             for ref_type in self.ref_types:
804                 try:
805                     func_name = "get_tree_from_{}".format(ref_type)
806                     func = getattr(self, func_name)
807                 except AttributeError:
808                     log.error(
809                         "%s class is missing function '%s'",
810                         self.__class__.__name__,
811                         func_name,
812                     )
813                 else:
814                     candidate = func(self.fallback)
815                     if candidate is not None:
816                         return candidate
817         return None
818     def get_url(self):
819         if self.role in ("git_pillar", "winrepo"):
820             try:
821                 self.branch, self.url = self.id.split(None, 1)
822             except ValueError:
823                 self.branch = self.conf["branch"]
824                 self.url = self.id
825         else:
826             self.url = self.id
827     @property
828     def linkdir_walk(self):
829         try:
830             return self._linkdir_walk
831         except AttributeError:
832             self._linkdir_walk = []
833             try:
834                 parts = self._mountpoint.split("/")
835             except AttributeError:
836                 log.error(
837                     "%s class is missing a '_mountpoint' attribute",
838                     self.__class__.__name__,
839                 )
840             else:
841                 for idx, item in enumerate(parts[:-1]):
842                     try:
843                         dirs = [parts[idx + 1]]
844                     except IndexError:
845                         dirs = []
846                     self._linkdir_walk.append(
847                         (
848                             salt.utils.path.join(self.linkdir, *parts[: idx + 1]),
849                             dirs,
850                             [],
851                         )
852                     )
853                 try:
854                     self._linkdir_walk.insert(0, (self.linkdir, [parts[0]], []))
855                 except IndexError:
856                     pass
857             return self._linkdir_walk
858     def setup_callbacks(self):
859     def verify_auth(self):
860         self.credentials = None
861         return True
862     def write_file(self, blob, dest):
863         raise NotImplementedError()
864 class GitPython(GitProvider):
865     def __init__(
866         self,
867         opts,
868         remote,
869         per_remote_defaults,
870         per_remote_only,
871         override_params,
872         cache_root,
873         role="gitfs",
874     ):
875         self.provider = "gitpython"
876         super().__init__(
877             opts,
878             remote,
879             per_remote_defaults,
880             per_remote_only,
881             override_params,
882             cache_root,
883             role,
884         )
885     def checkout(self):
886         tgt_ref = self.get_checkout_target()
887         try:
888             head_sha = self.repo.rev_parse("HEAD").hexsha
889         except Exception:  # pylint: disable=broad-except
890             head_sha = None
891         checkout_refs = [
892             ("origin/" + tgt_ref, False),
893             ("tags/" + tgt_ref, False),
894         ]
895         if self.fallback:
896             checkout_refs += [
897                 ("origin/" + self.fallback, True),
898                 ("tags/" + self.fallback, True),
899             ]
900         for checkout_ref, fallback in checkout_refs:
901             try:
902                 target_sha = self.repo.rev_parse(checkout_ref).hexsha
903             except Exception:  # pylint: disable=broad-except
904                 continue
905             else:
906                 if head_sha == target_sha:
907                     return self.check_root()
908             try:
909                 with self.gen_lock(lock_type="checkout"):
910                     self.repo.git.checkout(checkout_ref)
911                     log.debug(
912                         "%s remote '%s' has been checked out to %s%s",
913                         self.role,
914                         self.id,
915                         checkout_ref,
916                         " as fallback" if fallback else "",
917                     )
918             except GitLockError as exc:
919                 if exc.errno == errno.EEXIST:
920                     raise GitLockError(
921                         exc.errno,
922                         "Checkout lock exists for {} remote '{}'".format(
923                             self.role, self.id
924                         ),
925                     )
926                 else:
927                     log.error(
928                         "Error %d encountered obtaining checkout lock "
929                         "for %s remote '%s'",
930                         exc.errno,
931                         self.role,
932                         self.id,
933                     )
934                     return None
935             except Exception:  # pylint: disable=broad-except
936                 continue
937             return self.check_root()
938         log.error(
939             "Failed to checkout %s from %s remote '%s': remote ref does not exist",
940             tgt_ref,
941             self.role,
942             self.id,
943         )
944         return None
945     def init_remote(self):
946         new = False
947         if not os.listdir(self.cachedir):
948             self.repo = git.Repo.init(self.cachedir)
949             new = True
950         else:
951             try:
952                 self.repo = git.Repo(self.cachedir)
953             except git.exc.InvalidGitRepositoryError:
954                 log.error(_INVALID_REPO, self.cachedir, self.url, self.role)
955                 return new
956         self.gitdir = salt.utils.path.join(self.repo.working_dir, ".git")
957         self.enforce_git_config()
958         return new
959     def dir_list(self, tgt_env):
960         ret = set()
961         tree = self.get_tree(tgt_env)
962         if not tree:
963             return ret
964         if self.root(tgt_env):
965             try:
966                 tree = tree / self.root(tgt_env)
967             except KeyError:
968                 return ret
969             relpath = lambda path: os.path.relpath(path, self.root(tgt_env))
970         else:
971             relpath = lambda path: path
972         add_mountpoint = lambda path: salt.utils.path.join(
973             self.mountpoint(tgt_env), path, use_posixpath=True
974         )
975         for blob in tree.traverse():
976             if isinstance(blob, git.Tree):
977                 ret.add(add_mountpoint(relpath(blob.path)))
978         if self.mountpoint(tgt_env):
979             ret.add(self.mountpoint(tgt_env))
980         return ret
981     def envs(self):
982         ref_paths = [x.path for x in self.repo.refs]
983         return self._get_envs_from_ref_paths(ref_paths)
984     def _fetch(self):
985         origin = self.repo.remotes[0]
986         try:
987             fetch_results = origin.fetch()
988         except AssertionError:
989             fetch_results = origin.fetch()
990         new_objs = False
991         for fetchinfo in fetch_results:
992             if fetchinfo<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.old_commit is not None:
993                 log.debug(
994                     "%s has updated '%s' for remote '%s' from %s to %s",
995                     self.role,
996                     fetchinfo.name,
997                     self.id,
998                     fetchinfo.old_commit.hexsha[:7],
999                     fetchinfo.commit.hexsha[</b></font>:7],
1000                 )
1001                 new_objs = True
1002             elif fetchinfo.flags in (fetchinfo.NEW_TAG, fetchinfo.NEW_HEAD):
1003                 log.debug(
1004                     "%s has fetched new %s '%s' for remote '%s'",
1005                     self.role,
1006                     "tag" if fetchinfo.flags == fetchinfo.NEW_TAG else "head",
1007                     fetchinfo.name,
1008                     self.id,
1009                 )
1010                 new_objs = True
1011         cleaned = self.clean_stale_refs()
1012         return True if (new_objs or cleaned) else None
1013     def file_list(self, tgt_env):
1014         files = set()
1015         symlinks = {}
1016         tree = self.get_tree(tgt_env)
1017         if not tree:
1018             return files, symlinks
1019         if self.root(tgt_env):
1020             try:
1021                 tree = tree / self.root(tgt_env)
1022             except KeyError:
1023                 return files, symlinks
1024             relpath = lambda path: os.path.relpath(path, self.root(tgt_env))
1025         else:
1026             relpath = lambda path: path
1027         add_mountpoint = lambda path: salt.utils.path.join(
1028             self.mountpoint(tgt_env), path, use_posixpath=True
1029         )
1030         for file_blob in tree.traverse():
1031             if not isinstance(file_blob, git.Blob):
1032                 continue
1033             file_path = add_mountpoint(relpath(file_blob.path))
1034             files.add(file_path)
1035             if stat.S_ISLNK(file_blob.mode):
1036                 stream = io.BytesIO()
1037                 file_blob.stream_data(stream)
1038                 stream.seek(0)
1039                 link_tgt = salt.utils.stringutils.to_str(stream.read())
1040                 stream.close()
1041                 symlinks[file_path] = link_tgt
1042         return files, symlinks
1043     def find_file(self, path, tgt_env):
1044         tree = self.get_tree(tgt_env)
1045         if not tree:
1046             return None, None, None
1047         blob = None
1048         depth = 0
1049         while True:
1050             depth += 1
1051             if depth &gt; SYMLINK_RECURSE_DEPTH:
1052                 blob = None
1053                 break
1054             try:
1055                 file_blob = tree / path
1056                 if stat.S_ISLNK(file_blob.mode):
1057                     stream = io.BytesIO()
1058                     file_blob.stream_data(stream)
1059                     stream.seek(0)
1060                     link_tgt = salt.utils.stringutils.to_str(stream.read())
1061                     stream.close()
1062                     path = salt.utils.path.join(
1063                         os.path.dirname(path), link_tgt, use_posixpath=True
1064                     )
1065                 else:
1066                     blob = file_blob
1067                     if isinstance(blob, git.Tree):
1068                         blob = None
1069                     break
1070             except KeyError:
1071                 blob = None
1072                 break
1073         if isinstance(blob, git.Blob):
1074             return blob, blob.hexsha, blob.mode
1075         return None, None, None
1076     def get_tree_from_branch(self, ref):
1077         try:
1078             return git.RemoteReference(
1079                 self.repo, "refs/remotes/origin/{}".format(ref)
1080             ).commit.tree
1081         except ValueError:
1082             return None
1083     def get_tree_from_tag(self, ref):
1084         try:
1085             return git.TagReference(self.repo, "refs/tags/{}".format(ref)).commit.tree
1086         except ValueError:
1087             return None
1088     def get_tree_from_sha(self, ref):
1089         try:
1090             return self.repo.rev_parse(ref).tree
1091         except (gitdb.exc.ODBError, AttributeError):
1092             return None
1093     def write_file(self, blob, dest):
1094         with salt.utils.files.fopen(dest, "wb+") as fp_:
1095             blob.stream_data(fp_)
1096 class Pygit2(GitProvider):
1097     def __init__(
1098         self,
1099         opts,
1100         remote,
1101         per_remote_defaults,
1102         per_remote_only,
1103         override_params,
1104         cache_root,
1105         role="gitfs",
1106     ):
1107         self.provider = "pygit2"
1108         super().__init__(
1109             opts,
1110             remote,
1111             per_remote_defaults,
1112             per_remote_only,
1113             override_params,
1114             cache_root,
1115             role,
1116         )
1117     def peel(self, obj):
1118         try:
1119             return obj.peel()
1120         except AttributeError:
1121             return obj.get_object()
1122     def checkout(self):
1123         tgt_ref = self.get_checkout_target()
1124         local_ref = "refs/heads/" + tgt_ref
1125         remote_ref = "refs/remotes/origin/" + tgt_ref
1126         tag_ref = "refs/tags/" + tgt_ref
1127         try:
1128             local_head = self.repo.lookup_reference("HEAD")
1129         except KeyError:
1130             log.warning("HEAD not present in %s remote '%s'", self.role, self.id)
1131             return None
1132         try:
1133             head_sha = self.peel(local_head).hex
1134         except AttributeError:
1135             log.error(
1136                 "Unable to get SHA of HEAD for %s remote '%s'", self.role, self.id
1137             )
1138             return None
1139         except KeyError:
1140             head_sha = None
1141         refs = self.repo.listall_references()
1142         def _perform_checkout(checkout_ref, branch=True):
1143             try:
1144                 with self.gen_lock(lock_type="checkout"):
1145                     self.repo.checkout(checkout_ref)
1146                     if branch:
1147                         self.repo.reset(oid, pygit2.GIT_RESET_HARD)
1148                 return True
1149             except GitLockError as exc:
1150                 if exc.errno == errno.EEXIST:
1151                     raise GitLockError(
1152                         exc.errno,
1153                         "Checkout lock exists for {} remote '{}'".format(
1154                             self.role, self.id
1155                         ),
1156                     )
1157                 else:
1158                     log.error(
1159                         "Error %d encountered obtaining checkout lock "
1160                         "for %s remote '%s'",
1161                         exc.errno,
1162                         self.role,
1163                         self.id,
1164                     )
1165             return False
1166         try:
1167             if remote_ref not in refs and tag_ref not in refs and self.fallback:
1168                 tgt_ref = self.fallback
1169                 local_ref = "refs/heads/" + tgt_ref
1170                 remote_ref = "refs/remotes/origin/" + tgt_ref
1171                 tag_ref = "refs/tags/" + tgt_ref
1172             if remote_ref in refs:
1173                 oid = self.peel(self.repo.lookup_reference(remote_ref)).id
1174                 if local_ref not in refs:
1175                     self.repo.create_reference(local_ref, oid)
1176                 try:
1177                     target_sha = self.peel(self.repo.lookup_reference(remote_ref)).hex
1178                 except KeyError:
1179                     log.error(
1180                         "pygit2 was unable to get SHA for %s in %s remote '%s'",
1181                         local_ref,
1182                         self.role,
1183                         self.id,
1184                         exc_info=True,
1185                     )
1186                     return None
1187                 if head_sha != target_sha:
1188                     head_ref = local_head.target
1189                     if (
1190                         isinstance(head_ref, str)
1191                         and head_ref not in refs
1192                         and head_ref != local_ref
1193                     ):
1194                         branch_name = head_ref.partition("refs/heads/")[-1]
1195                         if not branch_name:
1196                             log.error(
1197                                 "pygit2 was unable to resolve branch name from "
1198                                 "HEAD ref '%s' in %s remote '%s'",
1199                                 head_ref,
1200                                 self.role,
1201                                 self.id,
1202                             )
1203                             return None
1204                         remote_head = "refs/remotes/origin/" + branch_name
1205                         if remote_head not in refs:
1206                             remote_head = remote_ref
1207                         self.repo.create_reference(
1208                             head_ref, self.repo.lookup_reference(remote_head).target
1209                         )
1210                     if not _perform_checkout(local_ref, branch=True):
1211                         return None
1212                 return self.check_root()
1213             elif tag_ref in refs:
1214                 tag_obj = self.repo.revparse_single(tag_ref)
1215                 if not isinstance(tag_obj, (pygit2.Commit, pygit2.Tag)):
1216                     log.error(
1217                         "%s does not correspond to pygit2 Commit or Tag object. It is"
1218                         " of type %s",
1219                         tag_ref,
1220                         type(tag_obj),
1221                     )
1222                 else:
1223                     try:
1224                         tag_sha = tag_obj.target.hex
1225                     except AttributeError:
1226                         try:
1227                             tag_sha = tag_obj.hex
1228                         except AttributeError:
1229                             log.error(
1230                                 "Unable to resolve %s from %s remote '%s' "
1231                                 "to either an annotated or non-annotated tag",
1232                                 tag_ref,
1233                                 self.role,
1234                                 self.id,
1235                                 exc_info=True,
1236                             )
1237                             return None
1238                     log.debug("SHA of tag %s: %s", tgt_ref, tag_sha)
1239                     if head_sha != tag_sha:
1240                         if not _perform_checkout(tag_ref, branch=False):
1241                             return None
1242                     return self.check_root()
1243         except GitLockError:
1244             raise
1245         except Exception as exc:  # pylint: disable=broad-except
1246             log.error(
1247                 "Failed to checkout %s from %s remote '%s': %s",
1248                 tgt_ref,
1249                 self.role,
1250                 self.id,
1251                 exc,
1252                 exc_info=True,
1253             )
1254             return None
1255         log.error(
1256             "Failed to checkout %s from %s remote '%s': remote ref does not exist",
1257             tgt_ref,
1258             self.role,
1259             self.id,
1260         )
1261         return None
1262     def clean_stale_refs(self, local_refs=None):  # pylint: disable=arguments-differ
1263         try:
1264             if pygit2.GIT_FETCH_PRUNE:
1265                 return []
1266         except AttributeError:
1267             pass
1268         if self.credentials is not None:
1269             log.debug(
1270                 "The installed version of pygit2 (%s) does not support "
1271                 "detecting stale refs for authenticated remotes, saltenvs "
1272                 "will not reflect branches/tags removed from remote '%s'",
1273                 PYGIT2_VERSION,
1274                 self.id,
1275             )
1276             return []
1277         return super().clean_stale_refs()
1278     def init_remote(self):
1279         home = os.path.expanduser("~")
1280         pygit2.settings.search_path[pygit2.GIT_CONFIG_LEVEL_GLOBAL] = home
1281         new = False
1282         if not os.listdir(self.cachedir):
1283             self.repo = pygit2.init_repository(self.cachedir)
1284             new = True
1285         else:
1286             try:
1287                 self.repo = pygit2.Repository(self.cachedir)
1288             except KeyError:
1289                 log.error(_INVALID_REPO, self.cachedir, self.url, self.role)
1290                 return new
1291         self.gitdir = salt.utils.path.join(self.repo.workdir, ".git")
1292         self.enforce_git_config()
1293         git_config = os.path.join(self.gitdir, "config")
1294         if os.path.exists(git_config) and PYGIT2_VERSION &gt;= _LooseVersion("0.28.0"):
1295             self.repo.config.add_file(git_config)
1296         return new
1297     def dir_list(self, tgt_env):
1298         def _traverse(tree, blobs, prefix):
1299             for entry in iter(tree):
1300                 if entry.oid not in self.repo:
1301                     continue
1302                 blob = self.repo[entry.oid]
1303                 if not isinstance(blob, pygit2.Tree):
1304                     continue
1305                 blobs.append(
1306                     salt.utils.path.join(prefix, entry.name, use_posixpath=True)
1307                 )
1308                 if blob:
1309                     _traverse(
1310                         blob,
1311                         blobs,
1312                         salt.utils.path.join(prefix, entry.name, use_posixpath=True),
1313                     )
1314         ret = set()
1315         tree = self.get_tree(tgt_env)
1316         if not tree:
1317             return ret
1318         if self.root(tgt_env):
1319             try:
1320                 oid = tree[self.root(tgt_env)].oid
1321                 tree = self.repo[oid]
1322             except KeyError:
1323                 return ret
1324             if not isinstance(tree, pygit2.Tree):
1325                 return ret
1326             relpath = lambda path: os.path.relpath(path, self.root(tgt_env))
1327         else:
1328             relpath = lambda path: path
1329         blobs = []
1330         if tree:
1331             _traverse(tree, blobs, self.root(tgt_env))
1332         add_mountpoint = lambda path: salt.utils.path.join(
1333             self.mountpoint(tgt_env), path, use_posixpath=True
1334         )
1335         for blob in blobs:
1336             ret.add(add_mountpoint(relpath(blob)))
1337         if self.mountpoint(tgt_env):
1338             ret.add(self.mountpoint(tgt_env))
1339         return ret
1340     def envs(self):
1341         ref_paths = self.repo.listall_references()
1342         return self._get_envs_from_ref_paths(ref_paths)
1343     def _fetch(self):
1344         origin = self.repo.remotes[0]
1345         refs_pre = self.repo.listall_references()
1346         fetch_kwargs = {}
1347         if self.remotecallbacks is not None:
1348             fetch_kwargs["callbacks"] = self.remotecallbacks
1349         else:
1350             if self.credentials is not None:
1351                 origin.credentials = self.credentials
1352         try:
1353             fetch_kwargs["prune"] = pygit2.GIT_FETCH_PRUNE
1354         except AttributeError:
1355             pass
1356         try:
1357             fetch_results = origin.fetch(**fetch_kwargs)
1358         except GitError as exc:  # pylint: disable=broad-except
1359             exc_str = get_error_message(exc).lower()
1360             if "unsupported url protocol" in exc_str and isinstance(
1361                 self.credentials, pygit2.Keypair
1362             ):
1363                 log.error(
1364                     "Unable to fetch SSH-based %s remote '%s'. "
1365                     "You may need to add ssh:// to the repo string or "
1366                     "libgit2 must be compiled with libssh2 to support "
1367                     "SSH authentication.",
1368                     self.role,
1369                     self.id,
1370                     exc_info=True,
1371                 )
1372             elif "authentication required but no callback set" in exc_str:
1373                 log.error(
1374                     "%s remote '%s' requires authentication, but no "
1375                     "authentication configured",
1376                     self.role,
1377                     self.id,
1378                     exc_info=True,
1379                 )
1380             else:
1381                 log.error(
1382                     "Error occurred fetching %s remote '%s': %s",
1383                     self.role,
1384                     self.id,
1385                     exc,
1386                     exc_info=True,
1387                 )
1388             return False
1389         try:
1390             received_objects = fetch_results["received_objects"]
1391         except (AttributeError, TypeError):
1392             received_objects = fetch_results.received_objects
1393         if received_objects != 0:
1394             log.debug(
1395                 "%s received %s objects for remote '%s'",
1396                 self.role,
1397                 received_objects,
1398                 self.id,
1399             )
1400         else:
1401             log.debug("%s remote '%s' is up-to-date", self.role, self.id)
1402         refs_post = self.repo.listall_references()
1403         cleaned = self.clean_stale_refs(local_refs=refs_post)
1404         return True if (received_objects or refs_pre != refs_post or cleaned) else None
1405     def file_list(self, tgt_env):
1406         def _traverse(tree, blobs, prefix):
1407             for entry in iter(tree):
1408                 if entry.oid not in self.repo:
1409                     continue
1410                 obj = self.repo[entry.oid]
1411                 if isinstance(obj, pygit2.Blob):
1412                     repo_path = salt.utils.path.join(
1413                         prefix, entry.name, use_posixpath=True
1414                     )
1415                     blobs.setdefault("files", []).append(repo_path)
1416                     if stat.S_ISLNK(tree[entry.name].filemode):
1417                         link_tgt = self.repo[tree[entry.name].oid].data
1418                         blobs.setdefault("symlinks", {})[repo_path] = link_tgt
1419                 elif isinstance(obj, pygit2.Tree):
1420                     _traverse(
1421                         obj,
1422                         blobs,
1423                         salt.utils.path.join(prefix, entry.name, use_posixpath=True),
1424                     )
1425         files = set()
1426         symlinks = {}
1427         tree = self.get_tree(tgt_env)
1428         if not tree:
1429             return files, symlinks
1430         if self.root(tgt_env):
1431             try:
1432                 oid = tree[self.root(tgt_env)].oid
1433                 tree = self.repo[oid]
1434             except KeyError:
1435                 return files, symlinks
1436             if not isinstance(tree, pygit2.Tree):
1437                 return files, symlinks
1438             relpath = lambda path: os.path.relpath(path, self.root(tgt_env))
1439         else:
1440             relpath = lambda path: path
1441         blobs = {}
1442         if tree:
1443             _traverse(tree, blobs, self.root(tgt_env))
1444         add_mountpoint = lambda path: salt.utils.path.join(
1445             self.mountpoint(tgt_env), path, use_posixpath=True
1446         )
1447         for repo_path in blobs.get("files", []):
1448             files.add(add_mountpoint(relpath(repo_path)))
1449         for repo_path, link_tgt in blobs.get("symlinks", {}).items():
1450             symlinks[add_mountpoint(relpath(repo_path))] = link_tgt
1451         return files, symlinks
1452     def find_file(self, path, tgt_env):
1453         tree = self.get_tree(tgt_env)
1454         if not tree:
1455             return None, None, None
1456         blob = None
1457         mode = None
1458         depth = 0
1459         while True:
1460             depth += 1
1461             if depth &gt; SYMLINK_RECURSE_DEPTH:
1462                 blob = None
1463                 break
1464             try:
1465                 entry = tree[path]
1466                 mode = entry.filemode
1467                 if stat.S_ISLNK(mode):
1468                     link_tgt = self.repo[entry.oid].data
1469                     path = salt.utils.path.join(
1470                         os.path.dirname(path), link_tgt, use_posixpath=True
1471                     )
1472                 else:
1473                     blob = self.repo[entry.oid]
1474                     if isinstance(blob, pygit2.Tree):
1475                         blob = None
1476                     break
1477             except KeyError:
1478                 blob = None
1479                 break
1480         if isinstance(blob, pygit2.Blob):
1481             return blob, blob.hex, mode
1482         return None, None, None
1483     def get_tree_from_branch(self, ref):
1484         try:
1485             return self.peel(
1486                 self.repo.lookup_reference("refs/remotes/origin/{}".format(ref))
1487             ).tree
1488         except KeyError:
1489             return None
1490     def get_tree_from_tag(self, ref):
1491         try:
1492             return self.peel(
1493                 self.repo.lookup_reference("refs/tags/{}".format(ref))
1494             ).tree
1495         except KeyError:
1496             return None
1497     def get_tree_from_sha(self, ref):
1498         try:
1499             return self.repo.revparse_single(ref).tree
1500         except (KeyError, TypeError, ValueError, AttributeError):
1501             return None
1502     def setup_callbacks(self):
1503         if PYGIT2_VERSION &gt;= _LooseVersion("0.23.2"):
1504             self.remotecallbacks = pygit2.RemoteCallbacks(credentials=self.credentials)
1505             if not self.ssl_verify:
1506                 self.remotecallbacks.certificate_check = lambda *args, **kwargs: True
1507         else:
1508             self.remotecallbacks = None
1509             if not self.ssl_verify:
1510                 warnings.warn(
1511                     "pygit2 does not support disabling the SSL certificate "
1512                     "check in versions prior to 0.23.2 (installed: {}). "
1513                     "Fetches for self-signed certificates will fail.".format(
1514                         PYGIT2_VERSION
1515                     )
1516                 )
1517     def verify_auth(self):
1518         self.credentials = None
1519         if os.path.isabs(self.url):
1520             return True
1521         elif not any(getattr(self, x, None) for x in AUTH_PARAMS):
1522             return True
1523         def _incomplete_auth(missing):
1524             log.critical(
1525                 "Incomplete authentication information for %s remote "
1526                 "'%s'. Missing parameters: %s",
1527                 self.role,
1528                 self.id,
1529                 ", ".join(missing),
1530             )
1531             failhard(self.role)
1532         def _key_does_not_exist(key_type, path):
1533             log.critical(
1534                 "SSH %s (%s) for %s remote '%s' could not be found, path "
1535                 "may be incorrect. Note that it may be necessary to clear "
1536                 "git_pillar locks to proceed once this is resolved and the "
1537                 "master has been started back up. A warning will be logged "
1538                 "if this is the case, with instructions.",
1539                 key_type,
1540                 path,
1541                 self.role,
1542                 self.id,
1543             )
1544             failhard(self.role)
1545         transport, _, address = self.url.partition("://")
1546         if not address:
1547             transport = "ssh"
1548             address = self.url
1549         transport = transport.lower()
1550         if transport in ("git", "file"):
1551             return True
1552         elif "ssh" in transport:
1553             required_params = ("pubkey", "privkey")
1554             user = address.split("@")[0]
1555             if user == address:
1556                 log.critical(
1557                     "Keypair specified for %s remote '%s', but remote URL "
1558                     "is missing a username",
1559                     self.role,
1560                     self.id,
1561                 )
1562                 failhard(self.role)
1563             self.user = user
1564             if all(bool(getattr(self, x, None)) for x in required_params):
1565                 keypair_params = [
1566                     getattr(self, x, None)
1567                     for x in ("user", "pubkey", "privkey", "passphrase")
1568                 ]
1569                 for idx, key_type in ((1, "pubkey"), (2, "privkey")):
1570                     key_path = keypair_params[idx]
1571                     if key_path is not None:
1572                         try:
1573                             if not os.path.isfile(key_path):
1574                                 _key_does_not_exist(key_type, key_path)
1575                         except TypeError:
1576                             _key_does_not_exist(key_type, key_path)
1577                 self.credentials = pygit2.Keypair(*keypair_params)
1578                 return True
1579             else:
1580                 missing_auth = [
1581                     x for x in required_params if not bool(getattr(self, x, None))
1582                 ]
1583                 _incomplete_auth(missing_auth)
1584         elif "http" in transport:
1585             required_params = ("user", "password")
1586             password_ok = all(bool(getattr(self, x, None)) for x in required_params)
1587             no_password_auth = not any(
1588                 bool(getattr(self, x, None)) for x in required_params
1589             )
1590             if no_password_auth:
1591                 return True
1592             if password_ok:
1593                 if transport == "http" and not self.insecure_auth:
1594                     log.critical(
1595                         "Invalid configuration for %s remote '%s'. "
1596                         "Authentication is disabled by default on http "
1597                         "remotes. Either set %s_insecure_auth to True in the "
1598                         "master configuration file, set a per-remote config "
1599                         "option named 'insecure_auth' to True, or use https "
1600                         "or ssh-based authentication.",
1601                         self.role,
1602                         self.id,
1603                         self.role,
1604                     )
1605                     failhard(self.role)
1606                 self.credentials = pygit2.UserPass(self.user, self.password)
1607                 return True
1608             else:
1609                 missing_auth = [
1610                     x for x in required_params if not bool(getattr(self, x, None))
1611                 ]
1612                 _incomplete_auth(missing_auth)
1613         else:
1614             log.critical(
1615                 "Invalid configuration for %s remote '%s'. Unsupported transport '%s'.",
1616                 self.role,
1617                 self.id,
1618                 transport,
1619             )
1620             failhard(self.role)
1621     def write_file(self, blob, dest):
1622         with salt.utils.files.fopen(dest, "wb+") as fp_:
1623             fp_.write(blob.data)
1624 GIT_PROVIDERS = {
1625     "pygit2": Pygit2,
1626     "gitpython": GitPython,
1627 }
1628 class GitBase:
1629     def __init__(
1630         self,
1631         opts,
1632         remotes=None,
1633         per_remote_overrides=(),
1634         per_remote_only=PER_REMOTE_ONLY,
1635         global_only=GLOBAL_ONLY,
1636         git_providers=None,
1637         cache_root=None,
1638         init_remotes=True,
1639     ):
1640         self.opts = opts
1641         self.git_providers = (
1642             git_providers if git_providers is not None else GIT_PROVIDERS
1643         )
1644         self.verify_provider()
1645         if cache_root is not None:
1646             self.cache_root = self.remote_root = cache_root
1647         else:
1648             self.cache_root = salt.utils.path.join(self.opts["cachedir"], self.role)
1649             self.remote_root = salt.utils.path.join(self.cache_root, "remotes")
1650         self.env_cache = salt.utils.path.join(self.cache_root, "envs.p")
1651         self.hash_cachedir = salt.utils.path.join(self.cache_root, "hash")
1652         self.file_list_cachedir = salt.utils.path.join(
1653             self.opts["cachedir"], "file_lists", self.role
1654         )
1655         if init_remotes:
1656             self.init_remotes(
1657                 remotes if remotes is not None else [],
1658                 per_remote_overrides,
1659                 per_remote_only,
1660                 global_only,
1661             )
1662     def init_remotes(
1663         self,
1664         remotes,
1665         per_remote_overrides=(),
1666         per_remote_only=PER_REMOTE_ONLY,
1667         global_only=GLOBAL_ONLY,
1668     ):
1669         override_params = copy.deepcopy(per_remote_overrides)
1670         global_auth_params = [
1671             "{}_{}".format(self.role, x)
1672             for x in AUTH_PARAMS
1673             if self.opts["{}_{}".format(self.role, x)]
1674         ]
1675         if self.provider in AUTH_PROVIDERS:
1676             override_params += AUTH_PARAMS
1677         elif global_auth_params:
1678             msg = (
1679                 "{0} authentication was configured, but the '{1}' "
1680                 "{0}_provider does not support authentication. The "
1681                 "providers for which authentication is supported in {0} "
1682                 "are: {2}.".format(self.role, self.provider, ", ".join(AUTH_PROVIDERS))
1683             )
1684             if self.role == "gitfs":
1685                 msg += (
1686                     " See the GitFS Walkthrough in the Salt documentation "
1687                     "for further information."
1688                 )
1689             log.critical(msg)
1690             failhard(self.role)
1691         per_remote_defaults = {}
1692         global_values = set(override_params)
1693         global_values.update(set(global_only))
1694         for param in global_values:
1695             key = "{}_{}".format(self.role, param)
1696             if key not in self.opts:
1697                 log.critical(
1698                     "Key '%s' not present in global configuration. This is "
1699                     "a bug, please report it.",
1700                     key,
1701                 )
1702                 failhard(self.role)
1703             per_remote_defaults[param] = enforce_types(key, self.opts[key])
1704         self.remotes = []
1705         for remote in remotes:
1706             repo_obj = self.git_providers[self.provider](
1707                 self.opts,
1708                 remote,
1709                 per_remote_defaults,
1710                 per_remote_only,
1711                 override_params,
1712                 self.cache_root,
1713                 self.role,
1714             )
1715             if hasattr(repo_obj, "repo"):
1716                 repo_obj.verify_auth()
1717                 repo_obj.setup_callbacks()
1718                 if self.opts["__role"] == "minion" and repo_obj.new:
1719                     repo_obj.fetch()
1720                 repo_obj.saltenv_revmap = {}
1721                 for saltenv, saltenv_conf in repo_obj.saltenv.items():
1722                     if "ref" in saltenv_conf:
1723                         ref = saltenv_conf["ref"]
1724                         repo_obj.saltenv_revmap.setdefault(ref, []).append(saltenv)
1725                         if saltenv == "base":
1726                             repo_obj.saltenv[saltenv].pop("ref")
1727                             if ref != repo_obj.base:
1728                                 log.warning(
1729                                     "The 'base' environment has been "
1730                                     "defined in the 'saltenv' param for %s "
1731                                     "remote %s and will override the "
1732                                     "branch/tag specified by %s_base (or a "
1733                                     "per-remote 'base' parameter).",
1734                                     self.role,
1735                                     repo_obj.id,
1736                                     self.role,
1737                                 )
1738                                 repo_obj.base = ref
1739                 all_envs = []
1740                 for env_names in repo_obj.saltenv_revmap.values():
1741                     all_envs.extend(env_names)
1742                 for key, conf in repo_obj.global_saltenv.items():
1743                     if key not in all_envs and "ref" in conf:
1744                         repo_obj.saltenv_revmap.setdefault(conf["ref"], []).append(key)
1745                 self.remotes.append(repo_obj)
1746         cachedir_map = {}
1747         for repo in self.remotes:
1748             cachedir_map.setdefault(repo.cachedir, []).append(repo.id)
1749         collisions = [x for x in cachedir_map if len(cachedir_map[x]) &gt; 1]
1750         if collisions:
1751             for dirname in collisions:
1752                 log.critical(
1753                     "The following %s remotes have conflicting cachedirs: "
1754                     "%s. Resolve this using a per-remote parameter called "
1755                     "'name'.",
1756                     self.role,
1757                     ", ".join(cachedir_map[dirname]),
1758                 )
1759                 failhard(self.role)
1760         if any(x.new for x in self.remotes):
1761             self.write_remote_map()
1762     def clear_old_remotes(self):
1763         try:
1764             cachedir_ls = os.listdir(self.cache_root)
1765         except OSError:
1766             cachedir_ls = []
1767         for repo in self.remotes:
1768             try:
1769                 cachedir_ls.remove(repo.cachedir_basename)
1770             except ValueError:
1771                 pass
1772         to_remove = []
1773         for item in cachedir_ls:
1774             if item in ("hash", "refs"):
1775                 continue
1776             path = salt.utils.path.join(self.cache_root, item)
1777             if os.path.isdir(path):
1778                 to_remove.append(path)
1779         failed = []
1780         if to_remove:
1781             for rdir in to_remove:
1782                 try:
1783                     shutil.rmtree(rdir)
1784                 except OSError as exc:
1785                     log.error(
1786                         "Unable to remove old %s remote cachedir %s: %s",
1787                         self.role,
1788                         rdir,
1789                         exc,
1790                     )
1791                     failed.append(rdir)
1792                 else:
1793                     log.debug("%s removed old cachedir %s", self.role, rdir)
1794         for fdir in failed:
1795             to_remove.remove(fdir)
1796         ret = bool(to_remove)
1797         if ret:
1798             self.write_remote_map()
1799         return ret
1800     def clear_cache(self):
1801         errors = []
1802         for rdir in (self.cache_root, self.file_list_cachedir):
1803             if os.path.exists(rdir):
1804                 try:
1805                     shutil.rmtree(rdir)
1806                 except OSError as exc:
1807                     errors.append("Unable to delete {}: {}".format(rdir, exc))
1808         return errors
1809     def clear_lock(self, remote=None, lock_type="update"):
1810         cleared = []
1811         errors = []
1812         for repo in self.remotes:
1813             if remote:
1814                 try:
1815                     if not fnmatch.fnmatch(repo.url, remote):
1816                         continue
1817                 except TypeError:
1818                     if not fnmatch.fnmatch(repo.url, str(remote)):
1819                         continue
1820             success, failed = repo.clear_lock(lock_type=lock_type)
1821             cleared.extend(success)
1822             errors.extend(failed)
1823         return cleared, errors
1824     def fetch_remotes(self, remotes=None):
1825         if remotes is None:
1826             remotes = []
1827         elif isinstance(remotes, str):
1828             remotes = remotes.split(",")
1829         elif not isinstance(remotes, list):
1830             log.error(
1831                 "Invalid 'remotes' argument (%s) for fetch_remotes. "
1832                 "Must be a list of strings",
1833                 remotes,
1834             )
1835             remotes = []
1836         changed = False
1837         for repo in self.remotes:
1838             name = getattr(repo, "name", None)
1839             if not remotes or (repo.id, name) in remotes or name in remotes:
1840                 try:
1841                     if repo.fetch():
1842                         changed = True
1843                 except Exception as exc:  # pylint: disable=broad-except
1844                     log.error(
1845                         "Exception caught while fetching %s remote '%s': %s",
1846                         self.role,
1847                         repo.id,
1848                         exc,
1849                         exc_info=True,
1850                     )
1851         return changed
1852     def lock(self, remote=None):
1853         locked = []
1854         errors = []
1855         for repo in self.remotes:
1856             if remote:
1857                 try:
1858                     if not fnmatch.fnmatch(repo.url, remote):
1859                         continue
1860                 except TypeError:
1861                     if not fnmatch.fnmatch(repo.url, str(remote)):
1862                         continue
1863             success, failed = repo.lock()
1864             locked.extend(success)
1865             errors.extend(failed)
1866         return locked, errors
1867     def update(self, remotes=None):
1868         data = {"changed": False, "backend": "gitfs"}
1869         data["changed"] = self.clear_old_remotes()
1870         if self.fetch_remotes(remotes=remotes):
1871             data["changed"] = True
1872         refresh_env_cache = self.opts["__role"] == "minion"
1873         if data["changed"] is True or not os.path.isfile(self.env_cache):
1874             env_cachedir = os.path.dirname(self.env_cache)
1875             if not os.path.exists(env_cachedir):
1876                 os.makedirs(env_cachedir)
1877             refresh_env_cache = True
1878         if refresh_env_cache:
1879             new_envs = self.envs(ignore_cache=True)
1880             with salt.utils.files.fopen(self.env_cache, "wb+") as fp_:
1881                 fp_.write(salt.payload.dumps(new_envs))
1882                 log.trace("Wrote env cache data to %s", self.env_cache)
1883         if self.opts.get("fileserver_events", False):
1884             with salt.utils.event.get_event(
1885                 "master",
1886                 self.opts["sock_dir"],
1887                 opts=self.opts,
1888                 listen=False,
1889             ) as event:
1890                 event.fire_event(data, tagify(["gitfs", "update"], prefix="fileserver"))
1891         try:
1892             salt.fileserver.reap_fileserver_cache_dir(
1893                 self.hash_cachedir, self.find_file
1894             )
1895         except OSError:
1896             pass
1897     def update_intervals(self):
1898         return {
1899             (repo.id, getattr(repo, "name", None)): repo.update_interval
1900             for repo in self.remotes
1901         }
1902     def verify_provider(self):
1903         if "verified_{}_provider".format(self.role) in self.opts:
1904             self.provider = self.opts["verified_{}_provider".format(self.role)]
1905         else:
1906             desired_provider = self.opts.get("{}_provider".format(self.role))
1907             if not desired_provider:
1908                 if self.verify_pygit2(quiet=True):
1909                     self.provider = "pygit2"
1910                 elif self.verify_gitpython(quiet=True):
1911                     self.provider = "gitpython"
1912             else:
1913                 try:
1914                     desired_provider = desired_provider.lower()
1915                 except AttributeError:
1916                     desired_provider = str(desired_provider).lower()
1917                 if desired_provider not in self.git_providers:
1918                     log.critical(
1919                         "Invalid %s_provider '%s'. Valid choices are: %s",
1920                         self.role,
1921                         desired_provider,
1922                         ", ".join(self.git_providers),
1923                     )
1924                     failhard(self.role)
1925                 elif desired_provider == "pygit2" and self.verify_pygit2():
1926                     self.provider = "pygit2"
1927                 elif desired_provider == "gitpython" and self.verify_gitpython():
1928                     self.provider = "gitpython"
1929         if not hasattr(self, "provider"):
1930             log.critical("No suitable %s provider module is installed.", self.role)
1931             failhard(self.role)
1932     def verify_gitpython(self, quiet=False):
1933         def _recommend():
1934             if PYGIT2_VERSION and "pygit2" in self.git_providers:
1935                 log.error(_RECOMMEND_PYGIT2, self.role, self.role)
1936         if not GITPYTHON_VERSION:
1937             if not quiet:
1938                 log.error(
1939                     "%s is configured but could not be loaded, is GitPython installed?",
1940                     self.role,
1941                 )
1942                 _recommend()
1943             return False
1944         elif "gitpython" not in self.git_providers:
1945             return False
1946         errors = []
1947         if GITPYTHON_VERSION &lt; GITPYTHON_MINVER:
1948             errors.append(
1949                 "{} is configured, but the GitPython version is earlier than "
1950                 "{}. Version {} detected.".format(
1951                     self.role, GITPYTHON_MINVER, GITPYTHON_VERSION
1952                 )
1953             )
1954         if not salt.utils.path.which("git"):
1955             errors.append(
1956                 "The git command line utility is required when using the "
1957                 "'gitpython' {}_provider.".format(self.role)
1958             )
1959         if errors:
1960             for error in errors:
1961                 log.error(error)
1962             if not quiet:
1963                 _recommend()
1964             return False
1965         self.opts["verified_{}_provider".format(self.role)] = "gitpython"
1966         log.debug("gitpython %s_provider enabled", self.role)
1967         return True
1968     def verify_pygit2(self, quiet=False):
1969         def _recommend():
1970             if GITPYTHON_VERSION and "gitpython" in self.git_providers:
1971                 log.error(_RECOMMEND_GITPYTHON, self.role, self.role)
1972         if not PYGIT2_VERSION:
1973             if not quiet:
1974                 log.error(
1975                     "%s is configured but could not be loaded, are pygit2 "
1976                     "and libgit2 installed?",
1977                     self.role,
1978                 )
1979                 _recommend()
1980             return False
1981         elif "pygit2" not in self.git_providers:
1982             return False
1983         errors = []
1984         if PYGIT2_VERSION &lt; PYGIT2_MINVER:
1985             errors.append(
1986                 "{} is configured, but the pygit2 version is earlier than "
1987                 "{}. Version {} detected.".format(
1988                     self.role, PYGIT2_MINVER, PYGIT2_VERSION
1989                 )
1990             )
1991         if LIBGIT2_VERSION &lt; LIBGIT2_MINVER:
1992             errors.append(
1993                 "{} is configured, but the libgit2 version is earlier than "
1994                 "{}. Version {} detected.".format(
1995                     self.role, LIBGIT2_MINVER, LIBGIT2_VERSION
1996                 )
1997             )
1998         if not getattr(pygit2, "GIT_FETCH_PRUNE", False) and not salt.utils.path.which(
1999             "git"
2000         ):
2001             errors.append(
2002                 "The git command line utility is required when using the "
2003                 "'pygit2' {}_provider.".format(self.role)
2004             )
2005         if errors:
2006             for error in errors:
2007                 log.error(error)
2008             if not quiet:
2009                 _recommend()
2010             return False
2011         self.opts["verified_{}_provider".format(self.role)] = "pygit2"
2012         log.debug("pygit2 %s_provider enabled", self.role)
2013         return True
2014     def write_remote_map(self):
2015         remote_map = salt.utils.path.join(self.cache_root, "remote_map.txt")
2016         try:
2017             with salt.utils.files.fopen(remote_map, "w+") as fp_:
2018                 timestamp = datetime.now().strftime("%d %b %Y %H:%M:%S.%f")
2019                 fp_.write("# {}_remote map as of {}\n".format(self.role, timestamp))
2020                 for repo in self.remotes:
2021                     fp_.write(
2022                         salt.utils.stringutils.to_str(
2023                             "{} = {}\n".format(repo.cachedir_basename, repo.id)
2024                         )
2025                     )
2026         except OSError:
2027             pass
2028         else:
2029             log.info("Wrote new %s remote map to %s", self.role, remote_map)
2030     def do_checkout(self, repo):
2031         time_start = time.time()
2032         while time.time() - time_start &lt;= 5:
2033             try:
2034                 return repo.checkout()
2035             except GitLockError as exc:
2036                 if exc.errno == errno.EEXIST:
2037                     time.sleep(0.1)
2038                     continue
2039                 else:
2040                     log.error(
2041                         "Error %d encountered while obtaining checkout "
2042                         "lock for %s remote '%s': %s",
2043                         exc.errno,
2044                         repo.role,
2045                         repo.id,
2046                         exc,
2047                         exc_info=True,
2048                     )
2049                     break
2050         else:
2051             log.error(
2052                 "Timed out waiting for checkout lock to be released for "
2053                 "%s remote '%s'. If this error persists, run 'salt-run "
2054                 "cache.clear_git_lock %s type=checkout' to clear it.",
2055                 self.role,
2056                 repo.id,
2057                 self.role,
2058             )
2059         return None
2060 class GitFS(GitBase):
2061     role = "gitfs"
2062     instance_map = weakref.WeakKeyDictionary()
2063     def __new__(
2064         cls,
2065         opts,
2066         remotes=None,
2067         per_remote_overrides=(),
2068         per_remote_only=PER_REMOTE_ONLY,
2069         git_providers=None,
2070         cache_root=None,
2071         init_remotes=True,
2072     ):
2073         io_loop = salt.ext.tornado.ioloop.IOLoop.current() if init_remotes else None
2074         if not init_remotes or io_loop not in cls.instance_map:
2075             obj = object.__new__(cls)
2076             super(GitFS, obj).__init__(
2077                 opts,
2078                 remotes if remotes is not None else [],
2079                 per_remote_overrides=per_remote_overrides,
2080                 per_remote_only=per_remote_only,
2081                 git_providers=git_providers
2082                 if git_providers is not None
2083                 else GIT_PROVIDERS,
2084                 cache_root=cache_root,
2085                 init_remotes=init_remotes,
2086             )
2087             if not init_remotes:
2088                 log.debug("Created gitfs object with uninitialized remotes")
2089             else:
2090                 log.debug("Created gitfs object for process %s", os.getpid())
2091                 cls.instance_map[io_loop] = obj
2092             return obj
2093         log.debug("Re-using gitfs object for process %s", os.getpid())
2094         return cls.instance_map[io_loop]
2095     def __init__(
2096         self,
2097         opts,
2098         remotes,
2099         per_remote_overrides=(),
2100         per_remote_only=PER_REMOTE_ONLY,
2101         git_providers=None,
2102         cache_root=None,
2103         init_remotes=True,
2104     ):
2105         pass
2106     def dir_list(self, load):
2107         return self._file_lists(load, "dirs")
2108     def envs(self, ignore_cache=False):
2109         if not ignore_cache:
2110             cache_match = salt.fileserver.check_env_cache(self.opts, self.env_cache)
2111             if cache_match is not None:
2112                 return cache_match
2113         ret = set()
2114         for repo in self.remotes:
2115             repo_envs = repo.envs()
2116             for env_list in repo.saltenv_revmap.values():
2117                 repo_envs.update(env_list)
2118             ret.update([x for x in repo_envs if repo.env_is_exposed(x)])
2119         return sorted(ret)
2120     def find_file(self, path, tgt_env="base", **kwargs):  # pylint: disable=W0613
2121         fnd = {"path": "", "rel": ""}
2122         if os.path.isabs(path):
2123             return fnd
2124         dest = salt.utils.path.join(self.cache_root, "refs", tgt_env, path)
2125         hashes_glob = salt.utils.path.join(
2126             self.hash_cachedir, tgt_env, "{}.hash.*".format(path)
2127         )
2128         blobshadest = salt.utils.path.join(
2129             self.hash_cachedir, tgt_env, "{}.hash.blob_sha1".format(path)
2130         )
2131         lk_fn = salt.utils.path.join(self.hash_cachedir, tgt_env, "{}.lk".format(path))
2132         destdir = os.path.dirname(dest)
2133         hashdir = os.path.dirname(blobshadest)
2134         if not os.path.isdir(destdir):
2135             try:
2136                 os.makedirs(destdir)
2137             except OSError:
2138                 os.remove(destdir)
2139                 os.makedirs(destdir)
2140         if not os.path.isdir(hashdir):
2141             try:
2142                 os.makedirs(hashdir)
2143             except OSError:
2144                 os.remove(hashdir)
2145                 os.makedirs(hashdir)
2146         for repo in self.remotes:
2147             if repo.mountpoint(tgt_env) and not path.startswith(
2148                 repo.mountpoint(tgt_env) + os.sep
2149             ):
2150                 continue
2151             if (
2152                 not salt.utils.stringutils.is_hex(tgt_env)
2153                 and tgt_env not in self.envs()
2154                 and not repo.fallback
2155             ):
2156                 continue
2157             repo_path = path[len(repo.mountpoint(tgt_env)) :].lstrip(os.sep)
2158             if repo.root(tgt_env):
2159                 repo_path = salt.utils.path.join(repo.root(tgt_env), repo_path)
2160             blob, blob_hexsha, blob_mode = repo.find_file(repo_path, tgt_env)
2161             if blob is None:
2162                 continue
2163             def _add_file_stat(fnd, mode):
2164                 if mode is not None:
2165                     fnd["stat"] = [mode]
2166                 return fnd
2167             salt.fileserver.wait_lock(lk_fn, dest)
2168             try:
2169                 with salt.utils.files.fopen(blobshadest, "r") as fp_:
2170                     sha = salt.utils.stringutils.to_unicode(fp_.read())
2171                     if sha == blob_hexsha:
2172                         fnd["rel"] = path
2173                         fnd["path"] = dest
2174                         return _add_file_stat(fnd, blob_mode)
2175             except OSError as exc:
2176                 if exc.errno != errno.ENOENT:
2177                     raise
2178             with salt.utils.files.fopen(lk_fn, "w"):
2179                 pass
2180             for filename in glob.glob(hashes_glob):
2181                 try:
2182                     os.remove(filename)
2183                 except Exception:  # pylint: disable=broad-except
2184                     pass
2185             repo.write_file(blob, dest)
2186             with salt.utils.files.fopen(blobshadest, "w+") as fp_:
2187                 fp_.write(blob_hexsha)
2188             try:
2189                 os.remove(lk_fn)
2190             except OSError:
2191                 pass
2192             fnd["rel"] = path
2193             fnd["path"] = dest
2194             return _add_file_stat(fnd, blob_mode)
2195         return fnd
2196     def serve_file(self, load, fnd):
2197         if "env" in load:
2198             load.pop("env")
2199         ret = {"data": "", "dest": ""}
2200         required_load_keys = {"path", "loc", "saltenv"}
2201         if not all(x in load for x in required_load_keys):
2202             log.debug(
2203                 "Not all of the required keys present in payload. Missing: %s",
2204                 ", ".join(required_load_keys.difference(load)),
2205             )
2206             return ret
2207         if not fnd["path"]:
2208             return ret
2209         ret["dest"] = fnd["rel"]
2210         gzip = load.get("gzip", None)
2211         fpath = os.path.normpath(fnd["path"])
2212         with salt.utils.files.fopen(fpath, "rb") as fp_:
2213             fp_.seek(load["loc"])
2214             data = fp_.read(self.opts["file_buffer_size"])
2215             if data and not salt.utils.files.is_binary(fpath):
2216                 data = data.decode(__salt_system_encoding__)
2217             if gzip and data:
2218                 data = salt.utils.gzip_util.compress(data, gzip)
2219                 ret["gzip"] = gzip
2220             ret["data"] = data
2221         return ret
2222     def file_hash(self, load, fnd):
2223         if "env" in load:
2224             load.pop("env")
2225         if not all(x in load for x in ("path", "saltenv")):
2226             return "", None
2227         ret = {"hash_type": self.opts["hash_type"]}
2228         relpath = fnd["rel"]
2229         path = fnd["path"]
2230         hashdest = salt.utils.path.join(
2231             self.hash_cachedir,
2232             load["saltenv"],
2233             "{}.hash.{}".format(relpath, self.opts["hash_type"]),
2234         )
2235         try:
2236             with salt.utils.files.fopen(hashdest, "rb") as fp_:
2237                 ret["hsum"] = fp_.read()
2238             return ret
2239         except OSError as exc:
2240             if exc.errno != errno.ENOENT:
2241                 raise
2242         try:
2243             os.makedirs(os.path.dirname(hashdest))
2244         except OSError as exc:
2245             if exc.errno != errno.EEXIST:
2246                 raise
2247         ret["hsum"] = salt.utils.hashutils.get_hash(path, self.opts["hash_type"])
2248         with salt.utils.files.fopen(hashdest, "w+") as fp_:
2249             fp_.write(ret["hsum"])
2250         return ret
2251     def _file_lists(self, load, form):
2252         if "env" in load:
2253             load.pop("env")
2254         if not os.path.isdir(self.file_list_cachedir):
2255             try:
2256                 os.makedirs(self.file_list_cachedir)
2257             except os.error:
2258                 log.error("Unable to make cachedir %s", self.file_list_cachedir)
2259                 return []
2260         list_cache = salt.utils.path.join(
2261             self.file_list_cachedir,
2262             "{}.p".format(load["saltenv"].replace(os.path.sep, "_|-")),
2263         )
2264         w_lock = salt.utils.path.join(
2265             self.file_list_cachedir,
2266             ".{}.w".format(load["saltenv"].replace(os.path.sep, "_|-")),
2267         )
2268         cache_match, refresh_cache, save_cache = salt.fileserver.check_file_list_cache(
2269             self.opts, form, list_cache, w_lock
2270         )
2271         if cache_match is not None:
2272             return cache_match
2273         if refresh_cache:
2274             log.trace("Start rebuilding gitfs file_list cache")
2275             ret = {"files": set(), "symlinks": {}, "dirs": set()}
2276             for repo in self.remotes:
2277                 if (
2278                     salt.utils.stringutils.is_hex(load["saltenv"])
2279                     or load["saltenv"] in self.envs()
2280                     or repo.fallback
2281                 ):
2282                     start = time.time()
2283                     repo_files, repo_symlinks = repo.file_list(load["saltenv"])
2284                     ret["files"].update(repo_files)
2285                     ret["symlinks"].update(repo_symlinks)
2286                     ret["dirs"].update(repo.dir_list(load["saltenv"]))
2287                     log.profile(
2288                         "gitfs file_name cache rebuild repo=%s duration=%s seconds",
2289                         repo.id,
2290                         time.time() - start,
2291                     )
2292             ret["files"] = sorted(ret["files"])
2293             ret["dirs"] = sorted(ret["dirs"])
2294             if save_cache:
2295                 salt.fileserver.write_file_list_cache(
2296                     self.opts, ret, list_cache, w_lock
2297                 )
2298             log.trace("Finished rebuilding gitfs file_list cache")
2299             return ret.get(form, [])
2300         return {} if form == "symlinks" else []
2301     def file_list(self, load):
2302         return self._file_lists(load, "files")
2303     def file_list_emptydirs(self, load):  # pylint: disable=W0613
2304         return []
2305     def symlink_list(self, load):
2306         if "env" in load:
2307             load.pop("env")
2308         if (
2309             not salt.utils.stringutils.is_hex(load["saltenv"])
2310             and load["saltenv"] not in self.envs()
2311         ):
2312             return {}
2313         if "prefix" in load:
2314             prefix = load["prefix"].strip("/")
2315         else:
2316             prefix = ""
2317         symlinks = self._file_lists(load, "symlinks")
2318         return {key: val for key, val in symlinks.items() if key.startswith(prefix)}
2319 class GitPillar(GitBase):
2320     role = "git_pillar"
2321     def checkout(self):
2322         self.pillar_dirs = OrderedDict()
2323         self.pillar_linked_dirs = []
2324         for repo in self.remotes:
2325             cachedir = self.do_checkout(repo)
2326             if cachedir is not None:
2327                 if repo.branch == "__env__" and hasattr(repo, "all_saltenvs"):
2328                     env = (
2329                         self.opts.get("pillarenv") or self.opts.get("saltenv") or "base"
2330                     )
2331                 elif repo.env:
2332                     env = repo.env
2333                 else:
2334                     if repo.branch == repo.base:
2335                         env = "base"
2336                     else:
2337                         tgt = repo.get_checkout_target()
2338                         env = "base" if tgt == repo.base else tgt
2339                 if repo._mountpoint:
2340                     if self.link_mountpoint(repo):
2341                         self.pillar_dirs[repo.linkdir] = env
2342                         self.pillar_linked_dirs.append(repo.linkdir)
2343                 else:
2344                     self.pillar_dirs[cachedir] = env
2345     def link_mountpoint(self, repo):
2346         lcachelink = salt.utils.path.join(repo.linkdir, repo._mountpoint)
2347         lcachedest = salt.utils.path.join(repo.cachedir, repo.root()).rstrip(os.sep)
2348         wipe_linkdir = False
2349         create_link = False
2350         try:
2351             with repo.gen_lock(lock_type="mountpoint", timeout=10):
2352                 walk_results = list(os.walk(repo.linkdir, followlinks=False))
2353                 if walk_results != repo.linkdir_walk:
2354                     log.debug(
2355                         "Results of walking %s differ from expected results",
2356                         repo.linkdir,
2357                     )
2358                     log.debug("Walk results: %s", walk_results)
2359                     log.debug("Expected results: %s", repo.linkdir_walk)
2360                     wipe_linkdir = True
2361                 else:
2362                     if not all(
2363                         not salt.utils.path.islink(x[0]) and os.path.isdir(x[0])
2364                         for x in walk_results[:-1]
2365                     ):
2366                         log.debug(
2367                             "Linkdir parents of %s are not all directories", lcachelink
2368                         )
2369                         wipe_linkdir = True
2370                     elif not salt.utils.path.islink(lcachelink):
2371                         wipe_linkdir = True
2372                     else:
2373                         try:
2374                             ldest = salt.utils.path.readlink(lcachelink)
2375                         except Exception:  # pylint: disable=broad-except
2376                             log.debug("Failed to read destination of %s", lcachelink)
2377                             wipe_linkdir = True
2378                         else:
2379                             if ldest != lcachedest:
2380                                 log.debug(
2381                                     "Destination of %s (%s) does not match "
2382                                     "the expected value (%s)",
2383                                     lcachelink,
2384                                     ldest,
2385                                     lcachedest,
2386                                 )
2387                                 try:
2388                                     if (
2389                                         salt.utils.platform.is_windows()
2390                                         and not ldest.startswith("\\\\")
2391                                         and os.path.isdir(ldest)
2392                                     ):
2393                                         shutil.rmtree(lcachelink)
2394                                     else:
2395                                         os.remove(lcachelink)
2396                                 except Exception as exc:  # pylint: disable=broad-except
2397                                     log.exception(
2398                                         "Failed to remove existing git_pillar "
2399                                         "mountpoint link %s: %s",
2400                                         lcachelink,
2401                                         exc.__str__(),
2402                                     )
2403                                 wipe_linkdir = False
2404                                 create_link = True
2405                 if wipe_linkdir:
2406                     create_link = True
2407                     try:
2408                         shutil.rmtree(repo.linkdir)
2409                     except OSError:
2410                         pass
2411                     try:
2412                         ldirname = os.path.dirname(lcachelink)
2413                         os.makedirs(ldirname)
2414                         log.debug("Successfully made linkdir parent %s", ldirname)
2415                     except OSError as exc:
2416                         log.error(
2417                             "Failed to os.makedirs() linkdir parent %s: %s",
2418                             ldirname,
2419                             exc.__str__(),
2420                         )
2421                         return False
2422                 if create_link:
2423                     try:
2424                         os.symlink(lcachedest, lcachelink)
2425                         log.debug(
2426                             "Successfully linked %s to cachedir %s",
2427                             lcachelink,
2428                             lcachedest,
2429                         )
2430                         return True
2431                     except OSError as exc:
2432                         log.error(
2433                             "Failed to create symlink to %s at path %s: %s",
2434                             lcachedest,
2435                             lcachelink,
2436                             exc.__str__(),
2437                         )
2438                         return False
2439         except GitLockError:
2440             log.error(
2441                 "Timed out setting mountpoint lock for %s remote '%s'. If "
2442                 "this error persists, it may be because an earlier %s "
2443                 "checkout was interrupted. The lock can be cleared by running "
2444                 "'salt-run cache.clear_git_lock %s type=mountpoint', or by "
2445                 "manually removing %s.",
2446                 self.role,
2447                 repo.id,
2448                 self.role,
2449                 self.role,
2450                 repo._get_lock_file(lock_type="mountpoint"),
2451             )
2452             return False
2453         return True
2454 class WinRepo(GitBase):
2455     role = "winrepo"
2456     winrepo_dirs = {}
2457     def checkout(self):
2458         self.winrepo_dirs = {}
2459         for repo in self.remotes:
2460             cachedir = self.do_checkout(repo)
2461             if cachedir is not None:
2462                 self.winrepo_dirs[repo.id] = cachedir
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
